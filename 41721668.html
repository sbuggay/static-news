<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1727946065570" as="style"/><link rel="stylesheet" href="styles.css?v=1727946065570"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://justine.lol/mutex/">The Fastest Mutexes</a> <span class="domain">(<a href="https://justine.lol">justine.lol</a>)</span></div><div class="subtext"><span>jart</span> | <span>286 comments</span></div><br/><div><div id="41722337" class="c"><input type="checkbox" id="c-41722337" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41721788">next</a><span>|</span><label class="collapse" for="c-41722337">[-]</label><label class="expand" for="c-41722337">[47 more]</label></div><br/><div class="children"><div class="content">Always cool to see new mutex implementations and shootouts between them, but I don’t like how this one is benchmarked. Looks like a microbenchmark.<p>Most of us who ship fast locks use very large multithreaded programs as our primary way of testing performance. The things that make a mutex fast or slow seem to be different for complex workloads with varied critical section length, varied numbers of threads contending, and varying levels of contention.<p>(Source: I wrote the fast locks that WebKit uses, I’m the person who invented the ParkingLot abstraction for lock impls (now also used in Rust and Unreal Engine), and I previously did research on fast locks for Java and have a paper about that.)</div><br/><div id="41723565" class="c"><input type="checkbox" id="c-41723565" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#41722337">parent</a><span>|</span><a href="#41723676">next</a><span>|</span><label class="collapse" for="c-41723565">[-]</label><label class="expand" for="c-41723565">[31 more]</label></div><br/><div class="children"><div class="content">To add to this, as the original&#x2F;lead author of a desktop app that frequently runs with many tens of threads, I&#x27;d like to see numbers on performance in <i>non-heavily contended cases</i>. As a real-time (audio) programmer, I am more concerned with (for example) the cost to take the mutex even when it is not already locked (which is the overwhelming situation in our app). Likewise, I want to know the cost of a try-lock operation that will fail, not what happens when N threads are contending.<p>Of course, with Cosmopolitan being open source and all, I could do these measurements myself, but still ...</div><br/><div id="41723772" class="c"><input type="checkbox" id="c-41723772" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41723565">parent</a><span>|</span><a href="#41723587">next</a><span>|</span><label class="collapse" for="c-41723772">[-]</label><label class="expand" for="c-41723772">[28 more]</label></div><br/><div class="children"><div class="content">Totally!<p>Pro tip: if you really do know that contention is unlikely, and uncontended acquisition is super important, then it&#x27;s theoretically impossible to do better than a spinlock.<p>Reason: locks that have the ability to put the thread to sleep on a queue must do compare-and-swap (or at least an atomic RMW) on `unlock`. But spinlocks can get away with just doing a store-release (or just a store with a compiler fence on X86) to `unlock`.<p>Spinlocks also have excellent throughput under most contention scenarios, though at the cost of power and being unkind to other apps on the system. If you want your spinlock to be hella fast on contention just make sure you `sched_yield` before each retry (or `SwitchToThread` on Windows, and on Darwin you can do a bit better with `thread_switch(MACH_PORT_NULL, SWITCH_OPTION_DEPRESS, 1)`).</div><br/><div id="41725378" class="c"><input type="checkbox" id="c-41725378" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41723772">parent</a><span>|</span><a href="#41724168">next</a><span>|</span><label class="collapse" for="c-41725378">[-]</label><label class="expand" for="c-41725378">[9 more]</label></div><br/><div class="children"><div class="content">&gt;  just make sure you `sched_yield` before each retry<p>Assuming `sched_yield` does something.<p>There&#x27;s a futex congestion problem inside Wine&#x27;s memory allocator. There are several levels of locks. If you&#x27;re growing a buffer, in the sense of C&#x27;s &quot;realloc&quot;, and no buffer is available, memory allocation is locked during the allocation of a bigger buffer, copying of the contents, and release of the old buffer. &quot;Push&quot; type operations can force this. Two orders of magnitude performance drops ensue when multi-threaded programs are contending for that lock.[1]<p>Inside one of the lock loops is a call to &quot;YieldProcessor&quot;.<p><pre><code>    static void spin_lock( LONG *lock )
    {
         while (InterlockedCompareExchange( lock, -1, 0 ))
             YieldProcessor();
    }
</code></pre>
But the actual code for YieldProcessor is a NOP on x86:[2]<p><pre><code>    static FORCEINLINE void YieldProcessor(void)
    {
        #ifdef __GNUC__
        #if defined(__i386__) || defined(__x86_64__)
             __asm__ __volatile__( &quot;rep; nop&quot; : : : &quot;memory&quot; );
        #elif defined(__arm__) || defined(__aarch64__)
            __asm__ __volatile__( &quot;dmb ishst\n\tyield&quot; : : : &quot;memory&quot; );
        #else
            __asm__ __volatile__( &quot;&quot; : : : &quot;memory&quot; );
        #endif
        #endif
    }</code></pre>
}<p>Wine devs are aware of this, but the mess is bad enough that no one has tackled it.
This is down in the core of what &quot;malloc&quot; calls, so changes there could have unexpected effects on many programs.
Needs attention from someone really into mutexes.<p>[1] <a href="https:&#x2F;&#x2F;forum.winehq.org&#x2F;viewtopic.php?t=37688" rel="nofollow">https:&#x2F;&#x2F;forum.winehq.org&#x2F;viewtopic.php?t=37688</a><p>[2] <a href="https:&#x2F;&#x2F;gitlab.winehq.org&#x2F;wine&#x2F;wine&#x2F;-&#x2F;blob&#x2F;HEAD&#x2F;include&#x2F;winnt.h" rel="nofollow">https:&#x2F;&#x2F;gitlab.winehq.org&#x2F;wine&#x2F;wine&#x2F;-&#x2F;blob&#x2F;HEAD&#x2F;include&#x2F;winn...</a></div><br/><div id="41727413" class="c"><input type="checkbox" id="c-41727413" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41725378">parent</a><span>|</span><a href="#41727963">next</a><span>|</span><label class="collapse" for="c-41727413">[-]</label><label class="expand" for="c-41727413">[1 more]</label></div><br/><div class="children"><div class="content">`YieldThread` is just named confusingly. It is not equivalent to `sched_yield` or `std::thread::yield()`, it&#x27;s rather a macro to issue a pause instruction (which is indeed what you typically want in a spin loop). The actual Windows equivalent would be `SwitchToThread`.</div><br/></div></div><div id="41727963" class="c"><input type="checkbox" id="c-41727963" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41725378">parent</a><span>|</span><a href="#41727413">prev</a><span>|</span><a href="#41725653">next</a><span>|</span><label class="collapse" for="c-41727963">[-]</label><label class="expand" for="c-41727963">[1 more]</label></div><br/><div class="children"><div class="content">Has WINE considered using mremap() for its realloc() implementation? It allows you to make realloc() of a sufficient size basically cost nothing. See this screenshot <a href="https:&#x2F;&#x2F;x.com&#x2F;JustineTunney&#x2F;status&#x2F;1837663502619889875" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;JustineTunney&#x2F;status&#x2F;1837663502619889875</a> On other platforms like MacOS you can achieve the same thing as mremap() by mapping to random addresses, and then using MAP_FIXED to append.</div><br/></div></div><div id="41725653" class="c"><input type="checkbox" id="c-41725653" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41725378">parent</a><span>|</span><a href="#41727963">prev</a><span>|</span><a href="#41727944">next</a><span>|</span><label class="collapse" for="c-41725653">[-]</label><label class="expand" for="c-41725653">[4 more]</label></div><br/><div class="children"><div class="content">`rep; nop;` is actually the `pause` instruction. On older CPUs it’s a standard nop, but on newer CPUs it’s a more efficient nop.<p>Spinning on the CMPXCHG is also a bad idea. You should spin on the read and only then attempt the CMPXCHG.</div><br/><div id="41727946" class="c"><input type="checkbox" id="c-41727946" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41725653">parent</a><span>|</span><a href="#41726308">next</a><span>|</span><label class="collapse" for="c-41727946">[-]</label><label class="expand" for="c-41727946">[2 more]</label></div><br/><div class="children"><div class="content">Just to clarify: the spinning on CMPXCHG is not <i>also</i> a bad idea, the YieldProcessor is correct (a pause), but inside the CMPXCHG loop it should be spinning on a pure unlocked load. Is that correct?</div><br/><div id="41728684" class="c"><input type="checkbox" id="c-41728684" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41727946">parent</a><span>|</span><a href="#41726308">next</a><span>|</span><label class="collapse" for="c-41728684">[-]</label><label class="expand" for="c-41728684">[1 more]</label></div><br/><div class="children"><div class="content">No you should spin on a read. Once you see the value you want you then try the CMPXCHG. If that succeeds you exit. If it fails you go back to spinning on the read.</div><br/></div></div></div></div><div id="41726308" class="c"><input type="checkbox" id="c-41726308" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41725653">parent</a><span>|</span><a href="#41727946">prev</a><span>|</span><a href="#41727944">next</a><span>|</span><label class="collapse" for="c-41726308">[-]</label><label class="expand" for="c-41726308">[1 more]</label></div><br/><div class="children"><div class="content">Bingo. Spinning on CMPXCHG can cause livelock.</div><br/></div></div></div></div><div id="41727944" class="c"><input type="checkbox" id="c-41727944" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41725378">parent</a><span>|</span><a href="#41725653">prev</a><span>|</span><a href="#41725620">next</a><span>|</span><label class="collapse" for="c-41727944">[-]</label><label class="expand" for="c-41727944">[1 more]</label></div><br/><div class="children"><div class="content">if YieldProcessor() actually did switch it&#x27;d be awfully expensive, like mentioned &quot;rep; nop&quot;, is not just a &quot;nop&quot;.<p>OTOH, the usual way to lock via a busy loop&#x2F;spin, does require some attempts then backoff with a random duration.</div><br/></div></div><div id="41725620" class="c"><input type="checkbox" id="c-41725620" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41725378">parent</a><span>|</span><a href="#41727944">prev</a><span>|</span><a href="#41724168">next</a><span>|</span><label class="collapse" for="c-41725620">[-]</label><label class="expand" for="c-41725620">[1 more]</label></div><br/><div class="children"><div class="content">sched_yield isn’t a nop</div><br/></div></div></div></div><div id="41724168" class="c"><input type="checkbox" id="c-41724168" checked=""/><div class="controls bullet"><span class="by">lilyball</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41723772">parent</a><span>|</span><a href="#41725378">prev</a><span>|</span><a href="#41723878">next</a><span>|</span><label class="collapse" for="c-41724168">[-]</label><label class="expand" for="c-41724168">[3 more]</label></div><br/><div class="children"><div class="content">On Darwin, it&#x27;s possible for a pure spinlock to produce a priority inversion deadlock, because Darwin has a quality of service implementation in the kernel that differs from how everyone else handles thread priority. In other kernels, a low-priority thread will still eventually be guaranteed a cpu slice, so if it&#x27;s holding a spinlock, it will eventually make progress and unlock. On Darwin with Quality of Service, it&#x27;s possible for higher-QoS threads to preempt lower-QoS threads indefinitely.<p>For this reason, on Darwin you want to avoid spinlocks unless you know that all threads touching the spinlock are always running in the same QoS. Instead of spinlocks, your go-to for low-overhead locks there is os_unfair_lock, which is a spinlock variant that donates priority of the blocked threads to the running thread.</div><br/><div id="41727630" class="c"><input type="checkbox" id="c-41727630" checked=""/><div class="controls bullet"><span class="by">namibj</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41724168">parent</a><span>|</span><a href="#41724369">next</a><span>|</span><label class="collapse" for="c-41727630">[-]</label><label class="expand" for="c-41727630">[1 more]</label></div><br/><div class="children"><div class="content">On Linux you can still easily go extremely slow with plain sched_yield() as there&#x27;s no guarantee the thread who holds the lock will get to run, especially in numa situations due to a strong bias against migrating threads across numa boundaries.
You have to use the e.g. futex API to tell the kernel what you&#x27;re waiting for.<p>Bare spinlocks are very bad in this way, unless you have dedicated hardware threads (with SMT you can pin all but one of the threads with the remaining thread being general purpose, though you may want a way to inform the scheduler which cores to currently prefer due to their pinned tasks being more idle).</div><br/></div></div><div id="41724369" class="c"><input type="checkbox" id="c-41724369" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41724168">parent</a><span>|</span><a href="#41727630">prev</a><span>|</span><a href="#41723878">next</a><span>|</span><label class="collapse" for="c-41724369">[-]</label><label class="expand" for="c-41724369">[1 more]</label></div><br/><div class="children"><div class="content">I’ve shipped code on Darwin that spinlocks and gets away with it without any noticeable cases of this happening.<p>I know it can happen in theory. But theory and practice ain’t the same.<p>I worked for Apple when I shipped this too lmao</div><br/></div></div></div></div><div id="41723878" class="c"><input type="checkbox" id="c-41723878" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41723772">parent</a><span>|</span><a href="#41724168">prev</a><span>|</span><a href="#41725256">next</a><span>|</span><label class="collapse" for="c-41723878">[-]</label><label class="expand" for="c-41723878">[6 more]</label></div><br/><div class="children"><div class="content">We use spinlocks where appropriate. In the 90s I recall that the general rule of thumb was if the lock is held for &lt;10x the context switch time, spinlocks are generally a better choice. Not sure if that&#x27;s still true of contemporary architectures.<p>The more common pattern in rt&#x2F;audio code is &quot;try to take the lock, but have an alternate code path if that fails&quot;. It&#x27;s not that is never going to be contention, but it will be extremely rare, and when it occurs, it probably matters. RWLocks are also a common pattern, with the RT thread(s) being read-only (and still being required to fall back on an alternate code path if the read lock cannot be taken).</div><br/><div id="41723989" class="c"><input type="checkbox" id="c-41723989" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41723878">parent</a><span>|</span><a href="#41727464">next</a><span>|</span><label class="collapse" for="c-41723989">[-]</label><label class="expand" for="c-41723989">[4 more]</label></div><br/><div class="children"><div class="content">These days, fast lock implementations use the following rough idiom, or some idiom that is demonstrably not any slower even for short critical sections.<p><pre><code>    if (LIKELY(CAS(&amp;lock, UNLOCKED, LOCKED))) return;
    for (unsigned i = 0; i &lt; 40; ++i) {
        &#x2F;* spin for a bounded a mount of time *&#x2F;
        if (LIKELY(CAS(&amp;lock, UNLOCKED, LOCKED))) return;
        sched_yield();
    }
    ... &#x2F;* actual full lock algo goes here *&#x2F;
</code></pre>
So, the reason to use spinlocks isn&#x27;t that they are faster for short critical sections, but that they don&#x27;t have to CAS on unlock - and so they are faster especially in the uncontended case (and in all other cases too).<p>In other words, the modern rule of thumb is something like: if you&#x27;re going to grab the lock so frequently that the uncontended lock&#x2F;unlock time shows up as a significant percentage of your execution time, then use a spinlock. That probably implies that you are probably holding the lock for &lt;100x or even &lt;1000x context switch time, or something around there.</div><br/><div id="41725119" class="c"><input type="checkbox" id="c-41725119" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41723989">parent</a><span>|</span><a href="#41726063">prev</a><span>|</span><a href="#41727464">next</a><span>|</span><label class="collapse" for="c-41725119">[-]</label><label class="expand" for="c-41725119">[2 more]</label></div><br/><div class="children"><div class="content">Huh, interesting. TIL. Thanks for that!</div><br/><div id="41727979" class="c"><input type="checkbox" id="c-41727979" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41725119">parent</a><span>|</span><a href="#41727464">next</a><span>|</span><label class="collapse" for="c-41727979">[-]</label><label class="expand" for="c-41727979">[1 more]</label></div><br/><div class="children"><div class="content">Lots of code is &#x27;lock free&#x27; and uses the same pattern (more or less). Attempt the change optimistically, if it fails spin it, if it keeps failing (Massive Contention), back off.</div><br/></div></div></div></div></div></div><div id="41727464" class="c"><input type="checkbox" id="c-41727464" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41723878">parent</a><span>|</span><a href="#41723989">prev</a><span>|</span><a href="#41725256">next</a><span>|</span><label class="collapse" for="c-41727464">[-]</label><label class="expand" for="c-41727464">[1 more]</label></div><br/><div class="children"><div class="content">Keep in mind that while try_lock() is realtime-safe, the following unlock() may not, as it may need to wake threads that have been blocked in the meantime!<p>So I would only use this pattern for situations where the very fact that a NRT thread tries to acquire the lock already means that RT safety is not a concern anymore (e.g. a device has been disconnected)</div><br/></div></div></div></div><div id="41725256" class="c"><input type="checkbox" id="c-41725256" checked=""/><div class="controls bullet"><span class="by">ot</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41723772">parent</a><span>|</span><a href="#41723878">prev</a><span>|</span><a href="#41727389">next</a><span>|</span><label class="collapse" for="c-41725256">[-]</label><label class="expand" for="c-41725256">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Reason: locks that have the ability to put the thread to sleep on a queue must do compare-and-swap (or at least an atomic RMW) on `unlock`. But spinlocks can get away with just doing a store-release (or just a store with a compiler fence on X86) to `unlock`.<p>This is something I&#x27;ve thinking about a lot over time, that the CAS is only there to atomically determine if there are any sleeping waiters on unlock and you have to do a futex_wake. I would really want some way to get away with non-fenced operations (at least on x86), but I don&#x27;t know if it&#x27;s just that nobody has figured out why, or there is a fundamental reason why that&#x27;s not possible.</div><br/><div id="41725330" class="c"><input type="checkbox" id="c-41725330" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41725256">parent</a><span>|</span><a href="#41726802">next</a><span>|</span><label class="collapse" for="c-41725330">[-]</label><label class="expand" for="c-41725330">[2 more]</label></div><br/><div class="children"><div class="content">You do need a fence in the unlock path though (at least a release fence).<p>I think the issue is that if you ask the CPU to just store something (like in a spin lock), whether or not there’s a fence, it’s an operation with limited data flow dependencies so it’s easy for the CPU to execute. Even the fence can be handled using wacky speculation tricks.<p>But if you want to do something like, “store this value but only if the old value satisfies some predicate”, then there’s a load and the whole thing is dependent on the load. So you’re asking the CPU to load, then run a predicate, then store, and for that to be fenced, and atomic.<p>Strictly more work. I don’t think there’s any trick to make it faster than just the store release.</div><br/><div id="41725784" class="c"><input type="checkbox" id="c-41725784" checked=""/><div class="controls bullet"><span class="by">ot</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41725330">parent</a><span>|</span><a href="#41726802">next</a><span>|</span><label class="collapse" for="c-41725784">[-]</label><label class="expand" for="c-41725784">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You do need a fence in the unlock path though (at least a release fence).<p>Well yes but on x86 that comes for free. The overhead of the full fence brought in by lock cmpxchg or lock xchg is in the order of ~10ns, which for an uncontended lock means that a mutex is almost 2x as slow as a spinlock.<p>A load acquire + store release would be a couple of ns (assuming everything in L1 etc...)</div><br/></div></div></div></div><div id="41726802" class="c"><input type="checkbox" id="c-41726802" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41725256">parent</a><span>|</span><a href="#41725330">prev</a><span>|</span><a href="#41727389">next</a><span>|</span><label class="collapse" for="c-41726802">[-]</label><label class="expand" for="c-41726802">[2 more]</label></div><br/><div class="children"><div class="content">As far as I know it is a fundamental limitation. You need to release the mutex, then check that there were no waiters in this order not to miss wakeups. As the mutex release must be globally visible before the load, release ordering on the mutex is not sufficient as the load could be reordered before the unlock;  hence you need a StoreLoad fence which is always the most expensive barrier.<p>Consider the implementation of Dekker&#x27;s algorithm for example.</div><br/><div id="41728529" class="c"><input type="checkbox" id="c-41728529" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41726802">parent</a><span>|</span><a href="#41727389">next</a><span>|</span><label class="collapse" for="c-41728529">[-]</label><label class="expand" for="c-41728529">[1 more]</label></div><br/><div class="children"><div class="content">Also this paper might be relevant: Laws of Order: Expensive Synchronization in
Concurrent Algorithms Cannot be Eliminated [1]<p>[1] <a href="https:&#x2F;&#x2F;www.cs.bgu.ac.il&#x2F;~hendlerd&#x2F;papers&#x2F;p168-expensiveSynch.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.bgu.ac.il&#x2F;~hendlerd&#x2F;papers&#x2F;p168-expensiveSync...</a></div><br/></div></div></div></div></div></div><div id="41727389" class="c"><input type="checkbox" id="c-41727389" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41723772">parent</a><span>|</span><a href="#41725256">prev</a><span>|</span><a href="#41726250">next</a><span>|</span><label class="collapse" for="c-41727389">[-]</label><label class="expand" for="c-41727389">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If you want your spinlock to be hella fast on contention just make sure you `sched_yield` before each retry<p>Shouldn&#x27;t you rather use pause instructions (_mm_pause, __yield, ISB, etc.) instead of thread switching? That&#x27;s what I have seen in most spin lock implementations. Maybe it depends on the use case?</div><br/><div id="41728018" class="c"><input type="checkbox" id="c-41728018" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41727389">parent</a><span>|</span><a href="#41726250">next</a><span>|</span><label class="collapse" for="c-41728018">[-]</label><label class="expand" for="c-41728018">[1 more]</label></div><br/><div class="children"><div class="content">start with few attempts w&#x2F;o pause, just busy CAS, then CAS + pause, then yield (and backoff&#x2F;sleep with random duration)</div><br/></div></div></div></div><div id="41726250" class="c"><input type="checkbox" id="c-41726250" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41723772">parent</a><span>|</span><a href="#41727389">prev</a><span>|</span><a href="#41723587">next</a><span>|</span><label class="collapse" for="c-41726250">[-]</label><label class="expand" for="c-41726250">[2 more]</label></div><br/><div class="children"><div class="content">Atomic RMW is all you need. Imagine 3 state futex lock of taken, sleeping, and unlocked. Waking thread just needs to see old value but writes unlocked unconditionally.<p>I don&#x27;t think this is more expensive than release certainly not because of the line where the write goes in most cache coherency protocols.<p>Granted this lock does wake up too many people but you did say usually uncontended.</div><br/><div id="41726653" class="c"><input type="checkbox" id="c-41726653" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41726250">parent</a><span>|</span><a href="#41723587">next</a><span>|</span><label class="collapse" for="c-41726653">[-]</label><label class="expand" for="c-41726653">[1 more]</label></div><br/><div class="children"><div class="content">And what, unconditionally futex wakes everyone?<p>That&#x27;ll be hella slow</div><br/></div></div></div></div></div></div><div id="41723587" class="c"><input type="checkbox" id="c-41723587" checked=""/><div class="controls bullet"><span class="by">ataylor284_</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41723565">parent</a><span>|</span><a href="#41723772">prev</a><span>|</span><a href="#41727150">next</a><span>|</span><label class="collapse" for="c-41723587">[-]</label><label class="expand" for="c-41723587">[1 more]</label></div><br/><div class="children"><div class="content">The writeup suggests this implementation is optimized for the not-locked case:<p>&gt; uses an optimistic CAS (compare and swap) immediately, so that locking happens quickly when there&#x27;s no contention</div><br/></div></div><div id="41727150" class="c"><input type="checkbox" id="c-41727150" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41723565">parent</a><span>|</span><a href="#41723587">prev</a><span>|</span><a href="#41723676">next</a><span>|</span><label class="collapse" for="c-41727150">[-]</label><label class="expand" for="c-41727150">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure you know but this is the opposite of what real-time  conventionally means (you have hard deadlines -&gt; worst case is the chief concern).</div><br/></div></div></div></div><div id="41723676" class="c"><input type="checkbox" id="c-41723676" checked=""/><div class="controls bullet"><span class="by">uvdn7</span><span>|</span><a href="#41722337">parent</a><span>|</span><a href="#41723565">prev</a><span>|</span><a href="#41723866">next</a><span>|</span><label class="collapse" for="c-41723676">[-]</label><label class="expand" for="c-41723676">[4 more]</label></div><br/><div class="children"><div class="content">I was thinking the same. There are many mutexes out there, some are better at certain workloads than the rest. DistributedMutex and SharedMutex come to mind (<a href="https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;folly&#x2F;blob&#x2F;main&#x2F;folly&#x2F;synchronization&#x2F;DistributedMutex.h">https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;folly&#x2F;blob&#x2F;main&#x2F;folly&#x2F;synchroniz...</a>, <a href="https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;folly&#x2F;blob&#x2F;main&#x2F;folly&#x2F;SharedMutex.h">https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;folly&#x2F;blob&#x2F;main&#x2F;folly&#x2F;SharedMute...</a>) Just like hashmaps, it&#x27;s rarely the case that a single hashmap is better under _all_ possible workloads.</div><br/><div id="41723723" class="c"><input type="checkbox" id="c-41723723" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41723676">parent</a><span>|</span><a href="#41723866">next</a><span>|</span><label class="collapse" for="c-41723723">[-]</label><label class="expand" for="c-41723723">[3 more]</label></div><br/><div class="children"><div class="content">Yeah.<p>I should say, though, that if you&#x27;re on Windows then I have yet to find a real workload where SRWLock isn&#x27;t the fastest (provided you&#x27;re fine with no recursion and with a lock that is word-sized). That lock has made some kind of deal with the devil AFAICT.</div><br/><div id="41726052" class="c"><input type="checkbox" id="c-41726052" checked=""/><div class="controls bullet"><span class="by">mmastrac</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41723723">parent</a><span>|</span><a href="#41723866">next</a><span>|</span><label class="collapse" for="c-41726052">[-]</label><label class="expand" for="c-41726052">[2 more]</label></div><br/><div class="children"><div class="content">The downside of the deal with the devil...<p><a href="https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;cpp&#x2F;comments&#x2F;1b55686&#x2F;maybe_possible_bug_in_stdshared_mutex_on_windows&#x2F;" rel="nofollow">https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;cpp&#x2F;comments&#x2F;1b55686&#x2F;maybe_possible...</a></div><br/><div id="41727535" class="c"><input type="checkbox" id="c-41727535" checked=""/><div class="controls bullet"><span class="by">Salgat</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41726052">parent</a><span>|</span><a href="#41723866">next</a><span>|</span><label class="collapse" for="c-41727535">[-]</label><label class="expand" for="c-41727535">[1 more]</label></div><br/><div class="children"><div class="content">That was a fun rabbit hole to go down.</div><br/></div></div></div></div></div></div></div></div><div id="41723866" class="c"><input type="checkbox" id="c-41723866" checked=""/><div class="controls bullet"><span class="by">ngoldbaum</span><span>|</span><a href="#41722337">parent</a><span>|</span><a href="#41723676">prev</a><span>|</span><a href="#41726348">next</a><span>|</span><label class="collapse" for="c-41723866">[-]</label><label class="expand" for="c-41723866">[5 more]</label></div><br/><div class="children"><div class="content">This style of mutex will also power PyMutex in Python 3.13. I have real-world benchmarks showing how much faster PyMutex is than the old PyThread_type_lock that was available before 3.13.</div><br/><div id="41724942" class="c"><input type="checkbox" id="c-41724942" checked=""/><div class="controls bullet"><span class="by">0xDEADFED5</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41723866">parent</a><span>|</span><a href="#41724063">next</a><span>|</span><label class="collapse" for="c-41724942">[-]</label><label class="expand" for="c-41724942">[2 more]</label></div><br/><div class="children"><div class="content">Can I use PyMutex from my own Python code?</div><br/><div id="41726256" class="c"><input type="checkbox" id="c-41726256" checked=""/><div class="controls bullet"><span class="by">ngoldbaum</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41724942">parent</a><span>|</span><a href="#41724063">next</a><span>|</span><label class="collapse" for="c-41726256">[-]</label><label class="expand" for="c-41726256">[1 more]</label></div><br/><div class="children"><div class="content">No, it wouldn’t make sense to. Use threading.Lock for that. PyMutex is available in the CPython C API.</div><br/></div></div></div></div><div id="41724063" class="c"><input type="checkbox" id="c-41724063" checked=""/><div class="controls bullet"><span class="by">miohtama</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41723866">parent</a><span>|</span><a href="#41724942">prev</a><span>|</span><a href="#41726348">next</a><span>|</span><label class="collapse" for="c-41724063">[-]</label><label class="expand" for="c-41724063">[2 more]</label></div><br/><div class="children"><div class="content">Any rough summary?</div><br/><div id="41724323" class="c"><input type="checkbox" id="c-41724323" checked=""/><div class="controls bullet"><span class="by">ngoldbaum</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41724063">parent</a><span>|</span><a href="#41726348">next</a><span>|</span><label class="collapse" for="c-41724323">[-]</label><label class="expand" for="c-41724323">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;numpy&#x2F;numpy&#x2F;issues&#x2F;26510#issuecomment-2294179545">https:&#x2F;&#x2F;github.com&#x2F;numpy&#x2F;numpy&#x2F;issues&#x2F;26510#issuecomment-229...</a><p>And now that I look at that again I realize I forgot to finish that up!</div><br/></div></div></div></div></div></div><div id="41726348" class="c"><input type="checkbox" id="c-41726348" checked=""/><div class="controls bullet"><span class="by">lovidico</span><span>|</span><a href="#41722337">parent</a><span>|</span><a href="#41723866">prev</a><span>|</span><a href="#41725120">next</a><span>|</span><label class="collapse" for="c-41726348">[-]</label><label class="expand" for="c-41726348">[1 more]</label></div><br/><div class="children"><div class="content">Definitely a microbenchmark and probably wouldn’t be generally representative of performance. This page gives pretty good standards for OS benchmarking practic, although admittedly geared more for academia <a href="https:&#x2F;&#x2F;gernot-heiser.org&#x2F;benchmarking-crimes.html" rel="nofollow">https:&#x2F;&#x2F;gernot-heiser.org&#x2F;benchmarking-crimes.html</a></div><br/></div></div><div id="41725120" class="c"><input type="checkbox" id="c-41725120" checked=""/><div class="controls bullet"><span class="by">ot</span><span>|</span><a href="#41722337">parent</a><span>|</span><a href="#41726348">prev</a><span>|</span><a href="#41724103">next</a><span>|</span><label class="collapse" for="c-41725120">[-]</label><label class="expand" for="c-41725120">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, that specific benchmark is actually likely to prefer undesirable behaviors, for example pathological unfairness: clearly the optimal scheduling of those threads runs first all the increments from the first thread, then all of the second thread, etc... because this will minimize inter-processor traffic.<p>A mutex that sleeps for a fixed amount (for example 100us) on lock failure acquisition will probably get very close to that behavior (since it almost always bunches), and &quot;win&quot; the benchmark. Still, that would be a terrible mutex for any practical application where there is any contention.<p>This is not to say that this mutex is not good (or that pthread mutexes are not bad), just that the microbenchmark in question does not measure anything that predicts performance in a real application.</div><br/><div id="41725128" class="c"><input type="checkbox" id="c-41725128" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41725120">parent</a><span>|</span><a href="#41724103">next</a><span>|</span><label class="collapse" for="c-41725128">[-]</label><label class="expand" for="c-41725128">[1 more]</label></div><br/><div class="children"><div class="content">Yeah! For all we know this performs great on real programs.<p>And for all we know it’s absolute trash on real programs.</div><br/></div></div></div></div><div id="41724103" class="c"><input type="checkbox" id="c-41724103" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#41722337">parent</a><span>|</span><a href="#41725120">prev</a><span>|</span><a href="#41722804">next</a><span>|</span><label class="collapse" for="c-41724103">[-]</label><label class="expand" for="c-41724103">[2 more]</label></div><br/><div class="children"><div class="content">Fast locks are an oxymoron vs optimized CAS</div><br/><div id="41728007" class="c"><input type="checkbox" id="c-41728007" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#41722337">root</a><span>|</span><a href="#41724103">parent</a><span>|</span><a href="#41722804">next</a><span>|</span><label class="collapse" for="c-41728007">[-]</label><label class="expand" for="c-41728007">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, b&#x2F;c locks need to have their CAS.</div><br/></div></div></div></div></div></div><div id="41721788" class="c"><input type="checkbox" id="c-41721788" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41722337">prev</a><span>|</span><a href="#41727920">next</a><span>|</span><label class="collapse" for="c-41721788">[-]</label><label class="expand" for="c-41721788">[13 more]</label></div><br/><div class="children"><div class="content">&gt; The reason why Cosmopolitan Mutexes are so good is because I used a library called nsync. It only has 371 stars on GitHub, but it was written by a distinguished engineer at Google called Mike Burrows.<p>Indeed this is the first time I&#x27;ve heard of nsync, but Mike Burrows also wrote Google&#x27;s production mutex implementation at <a href="https:&#x2F;&#x2F;github.com&#x2F;abseil&#x2F;abseil-cpp&#x2F;blob&#x2F;master&#x2F;absl&#x2F;synchronization&#x2F;mutex.h">https:&#x2F;&#x2F;github.com&#x2F;abseil&#x2F;abseil-cpp&#x2F;blob&#x2F;master&#x2F;absl&#x2F;synchr...</a> I&#x27;m curious why this mutex implementation is absent from the author&#x27;s benchmarks.<p>By the way if the author farms out to __ulock on macOS, this could be more simply achieved by just using the wait(), notify_one() member functions in the libc++&#x27;s atomic library.<p>A while ago there was also a giant thread related to improving Rust&#x27;s mutex implementation at <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;93740#issuecomment-1041391284">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;93740#issuecomment-...</a>. What&#x27;s interesting is that there&#x27;s a detailed discussion of the inner workings of almost every popular mutex implementation.</div><br/><div id="41723512" class="c"><input type="checkbox" id="c-41723512" checked=""/><div class="controls bullet"><span class="by">BryantD</span><span>|</span><a href="#41721788">parent</a><span>|</span><a href="#41722492">next</a><span>|</span><label class="collapse" for="c-41723512">[-]</label><label class="expand" for="c-41723512">[1 more]</label></div><br/><div class="children"><div class="content">Mike was a legend by the time I got to AV. The myth was that any time the search engine needed to be faster, he came in and rewrote a few core functions and went back to whatever else he was doing. Might be true, I just can&#x27;t verify it personally. Extremely smart engineer who cares about efficiency.<p>We did not, however, run on one server for any length of time.</div><br/></div></div><div id="41722492" class="c"><input type="checkbox" id="c-41722492" checked=""/><div class="controls bullet"><span class="by">the-rc</span><span>|</span><a href="#41721788">parent</a><span>|</span><a href="#41723512">prev</a><span>|</span><a href="#41722038">next</a><span>|</span><label class="collapse" for="c-41722492">[-]</label><label class="expand" for="c-41722492">[3 more]</label></div><br/><div class="children"><div class="content">Burrows is also responsible for the Burrows Wheeler Transform, Bigtable, Dapper and Chubby, among others.</div><br/><div id="41726102" class="c"><input type="checkbox" id="c-41726102" checked=""/><div class="controls bullet"><span class="by">kristianp</span><span>|</span><a href="#41721788">root</a><span>|</span><a href="#41722492">parent</a><span>|</span><a href="#41725991">next</a><span>|</span><label class="collapse" for="c-41726102">[-]</label><label class="expand" for="c-41726102">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Burrows%E2%80%93Wheeler_transform" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Burrows%E2%80%93Wheeler_tran...</a><p>&gt; The Burrows-Wheeler transform is an algorithm used to prepare data for use with data compression techniques such as bzip2</div><br/></div></div><div id="41725991" class="c"><input type="checkbox" id="c-41725991" checked=""/><div class="controls bullet"><span class="by">lokar</span><span>|</span><a href="#41721788">root</a><span>|</span><a href="#41722492">parent</a><span>|</span><a href="#41726102">prev</a><span>|</span><a href="#41722038">next</a><span>|</span><label class="collapse" for="c-41725991">[-]</label><label class="expand" for="c-41725991">[1 more]</label></div><br/><div class="children"><div class="content">Also a really nice person.  And funny.</div><br/></div></div></div></div><div id="41722038" class="c"><input type="checkbox" id="c-41722038" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41721788">parent</a><span>|</span><a href="#41722492">prev</a><span>|</span><a href="#41722877">next</a><span>|</span><label class="collapse" for="c-41722038">[-]</label><label class="expand" for="c-41722038">[5 more]</label></div><br/><div class="children"><div class="content">Although it does get there eventually, that Rust thread is about Mara&#x27;s work, which is why it eventually mentions her January 2023 book.<p>The current Rust mutex implementation (which that thread does talk about later) landed earlier this year and although if you&#x27;re on Linux it&#x27;s not (much?) different, on Windows and Mac I believe it&#x27;s new work.<p>That said, Mara&#x27;s descriptions of the guts of other people&#x27;s implementations is still interesting, just make sure to check if they&#x27;re out-dated for your situation.</div><br/><div id="41723420" class="c"><input type="checkbox" id="c-41723420" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41721788">root</a><span>|</span><a href="#41722038">parent</a><span>|</span><a href="#41722877">next</a><span>|</span><label class="collapse" for="c-41723420">[-]</label><label class="expand" for="c-41723420">[4 more]</label></div><br/><div class="children"><div class="content">&gt; although if you&#x27;re on Linux it&#x27;s not (much?) different<p>AFAIK one reason to switch was that mutexes on Linux and MacOS were not guaranteed to be moveable, so every rust&#x27;s Mutex had to box the underlying os mutex and was not const-constructible. So this makes a considerable change.</div><br/><div id="41723475" class="c"><input type="checkbox" id="c-41723475" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41721788">root</a><span>|</span><a href="#41723420">parent</a><span>|</span><a href="#41722877">next</a><span>|</span><label class="collapse" for="c-41723475">[-]</label><label class="expand" for="c-41723475">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the reason for Mara&#x27;s Mutex. I know, it doesn&#x27;t seem like five minutes, but Mara&#x27;s is now the <i>previous</i> version of the Rust Mutex implementation.<p>std::sync::Mutex::new became const in 1.63, which was <i>over two years ago</i>.</div><br/><div id="41724240" class="c"><input type="checkbox" id="c-41724240" checked=""/><div class="controls bullet"><span class="by">lilyball</span><span>|</span><a href="#41721788">root</a><span>|</span><a href="#41723475">parent</a><span>|</span><a href="#41722877">next</a><span>|</span><label class="collapse" for="c-41724240">[-]</label><label class="expand" for="c-41724240">[2 more]</label></div><br/><div class="children"><div class="content">It looks like Mara also did the work to make it const-constructible, so it&#x27;s still her implementation, no? <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;97647">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;97647</a></div><br/><div id="41724553" class="c"><input type="checkbox" id="c-41724553" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41721788">root</a><span>|</span><a href="#41724240">parent</a><span>|</span><a href="#41722877">next</a><span>|</span><label class="collapse" for="c-41724553">[-]</label><label class="expand" for="c-41724553">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, maybe I was unclear, when I pointed out that this work was in 2022 that&#x27;s not because I was trying to say it&#x27;s recent, that&#x27;s <i>two years ago</i>. The current work was in 2024.<p>Here&#x27;s the 2024 rework of Windows Mutex: <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;121956&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;121956&#x2F;</a><p>Edited to add: Since we&#x27;re going back and forth I read the blame log, the Linux implementation, with which I&#x27;m most familiar, is still 85% Mara&#x27;s although with some meaningful changes from 2024.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41722877" class="c"><input type="checkbox" id="c-41722877" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41721788">parent</a><span>|</span><a href="#41722038">prev</a><span>|</span><a href="#41727920">next</a><span>|</span><label class="collapse" for="c-41722877">[-]</label><label class="expand" for="c-41722877">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m curious why [Abseil&#x27;s] mutex implementation is absent from the author&#x27;s benchmarks.<p>Possibly because it&#x27;s C++ (as opposed to C)? I am speculating.</div><br/><div id="41725395" class="c"><input type="checkbox" id="c-41725395" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#41721788">root</a><span>|</span><a href="#41722877">parent</a><span>|</span><a href="#41727920">next</a><span>|</span><label class="collapse" for="c-41725395">[-]</label><label class="expand" for="c-41725395">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Possibly because it&#x27;s C++ (as opposed to C)?<p>MSVC 2022&#x27;s std::mutex is listed, though. (That said, GCC&#x27;s &#x2F; clang&#x27;s std::mutex is not listed for Linux or macOS.)<p>absl::Mutex does come with some microbenchmarks with a handful of points of comparison (std::mutex, absl::base_internal::SpinLock) which <i>might</i> be useful to get an approximate baseline.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;abseil&#x2F;abseil-cpp&#x2F;blob&#x2F;master&#x2F;absl&#x2F;synchronization&#x2F;mutex_benchmark.cc">https:&#x2F;&#x2F;github.com&#x2F;abseil&#x2F;abseil-cpp&#x2F;blob&#x2F;master&#x2F;absl&#x2F;synchr...</a></div><br/><div id="41726093" class="c"><input type="checkbox" id="c-41726093" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41721788">root</a><span>|</span><a href="#41725395">parent</a><span>|</span><a href="#41727920">next</a><span>|</span><label class="collapse" for="c-41726093">[-]</label><label class="expand" for="c-41726093">[1 more]</label></div><br/><div class="children"><div class="content">std::mutex is rarely used. In libc++ for example it was just pthread_mutex_t. So it&#x27;s not different from just benchmarking pthread.<p>I was talking about the wait() and notify_one() member functions for std::atomic. See <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;atomic&#x2F;atomic&#x2F;wait" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;atomic&#x2F;atomic&#x2F;wait</a> and <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;atomic&#x2F;atomic&#x2F;notify_one" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;atomic&#x2F;atomic&#x2F;notify_one</a></div><br/></div></div></div></div></div></div></div></div><div id="41727920" class="c"><input type="checkbox" id="c-41727920" checked=""/><div class="controls bullet"><span class="by">SleepyMyroslav</span><span>|</span><a href="#41721788">prev</a><span>|</span><a href="#41723161">next</a><span>|</span><label class="collapse" for="c-41727920">[-]</label><label class="expand" for="c-41727920">[2 more]</label></div><br/><div class="children"><div class="content">Completely tangential:<p>As gamedev I came to love slow mutexes that do a lot of debug things in all &#x27;developer&#x27; builds. Have debug names&#x2F;IDs, track owners, report  time spent in contention to profiler, report ownership changes to profiler...<p>People tend to structure concurrency differently and games came to some patterns to avoid locks. But they are hard to use and require programmer to restructure things. Most of the code starts as &#x27;lets slap a lock here and try to pass the milestone&#x27;. Even fast locks will be unpredictably slow and will destroy realtime guarantees if there were any. They can be fast on average but the tail end is never going to go away. I don&#x27;t want to be that guy who will come back to it chasing &#x27;oh our game has hitches&#x27; but I am usually that guy.<p>Use slow locks people. The ones that show big red in profiler. Refactor them out when you see them being hit.<p>I know its a tall order. I can count people who know how to use profiler by fingers on AAA production. And it always like that no matter how many productions I see :)<p>ps. sorry for a rant. Please, continue good research into fast concurrency primitives and algorithms.</div><br/><div id="41728010" class="c"><input type="checkbox" id="c-41728010" checked=""/><div class="controls bullet"><span class="by">simonask</span><span>|</span><a href="#41727920">parent</a><span>|</span><a href="#41723161">next</a><span>|</span><label class="collapse" for="c-41728010">[-]</label><label class="expand" for="c-41728010">[1 more]</label></div><br/><div class="children"><div class="content">Even more tangentially: This is one of the reasons I&#x27;m having a great time developing a game in Rust.<p>You never want lock contention in a game if at all avoidable, and in a lot of cases taking a lock is provably unnecessary. For example: Each frame is divided into phases, and mutable access to some shared resource only needs to happen in one specific phase (like the `update()` function before `render()`, or when hot-reloading assets). With scoped threads and Rust&#x27;s borrowing rules, you can structure things to not even need a mutex, and be completely certain that you will receive a stern compiler error if the code changes in way so you do.<p>When possible, I&#x27;d always love to take a compiler error over a spike in the profiler.</div><br/></div></div></div></div><div id="41723161" class="c"><input type="checkbox" id="c-41723161" checked=""/><div class="controls bullet"><span class="by">Uehreka</span><span>|</span><a href="#41727920">prev</a><span>|</span><a href="#41722487">next</a><span>|</span><label class="collapse" for="c-41723161">[-]</label><label class="expand" for="c-41723161">[56 more]</label></div><br/><div class="children"><div class="content">So on the one hand, all this Cosmo&#x2F;ape&#x2F;redbean stuff sounds incredible, and the comments on these articles are usually pretty positive and don’t generally debunk the concepts. But on the other hand, I never hear mention of anyone else using these things (I get that not everyone shares what they’re doing in a big way, but after so many years I’d expect to have seen a couple project writeups talk about them). Every mention of Cosmo&#x2F;ape&#x2F;redbean I’ve ever seen is from Justine’s site.<p>So I’ve gotta ask: Is there a catch? Are these tools doing something evil to achieve what they’re achieving? Is the whole thing a tom7-esque joke&#x2F;troll that I don’t get because I’m not as deep into compilers&#x2F;runtimes? Or are these really just ingenious tools that haven’t caught on yet?</div><br/><div id="41723505" class="c"><input type="checkbox" id="c-41723505" checked=""/><div class="controls bullet"><span class="by">amiga386</span><span>|</span><a href="#41723161">parent</a><span>|</span><a href="#41724947">next</a><span>|</span><label class="collapse" for="c-41723505">[-]</label><label class="expand" for="c-41723505">[27 more]</label></div><br/><div class="children"><div class="content">APE works through cunning trickery that might get patched out any day now (and in OpenBSD, it has been).<p>Most people producing cross-platform software <i>don&#x27;t</i> want a single executable that runs on every platform, they want a single <i>codebase</i> that works correctly on each platform they support.<p>With that in mind that respect, languages like go letting you cross compile for all your targets (provided you avoid CGO) is delightful... but the 3-ways-executable magic trick of APE, while really clever, doesn&#x27;t inspire confidence it&#x27;ll work forever, and for the most part it doesn&#x27;t gain you anything. Each platform has their own packaging&#x2F;signing requirements. You might as well compile a different target for each platform.</div><br/><div id="41724534" class="c"><input type="checkbox" id="c-41724534" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41723505">parent</a><span>|</span><a href="#41727997">next</a><span>|</span><label class="collapse" for="c-41724534">[-]</label><label class="expand" for="c-41724534">[4 more]</label></div><br/><div class="children"><div class="content">&gt; With that in mind that respect, languages like go letting you cross compile for all your targets (provided you avoid CGO)<p>Even that is not a big deal in most of cases, if you use zig to wrap CC: <a href="https:&#x2F;&#x2F;dev.to&#x2F;kristoff&#x2F;zig-makes-go-cross-compilation-just-work-29ho" rel="nofollow">https:&#x2F;&#x2F;dev.to&#x2F;kristoff&#x2F;zig-makes-go-cross-compilation-just-...</a></div><br/><div id="41724833" class="c"><input type="checkbox" id="c-41724833" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41724534">parent</a><span>|</span><a href="#41727997">next</a><span>|</span><label class="collapse" for="c-41724833">[-]</label><label class="expand" for="c-41724833">[3 more]</label></div><br/><div class="children"><div class="content">Does this still work? The article is from 2021 but when I last tried it this year, Go appeared to (newly) depend on headers that Zig doesn&#x27;t need and thus it doesn&#x27;t work.  The Github issue was something like &quot;yeah, we don&#x27;t need those, so I guess Go doesn&#x27;t work anymore&quot;.  Without the actual error message I can&#x27;t find the issue, however, so maybe I imagined this.</div><br/><div id="41725408" class="c"><input type="checkbox" id="c-41725408" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41724833">parent</a><span>|</span><a href="#41725112">next</a><span>|</span><label class="collapse" for="c-41725408">[-]</label><label class="expand" for="c-41725408">[1 more]</label></div><br/><div class="children"><div class="content">I believe these are the issues:
<a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;52690">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;52690</a>
<a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;14989">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;14989</a></div><br/></div></div><div id="41725112" class="c"><input type="checkbox" id="c-41725112" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41724833">parent</a><span>|</span><a href="#41725408">prev</a><span>|</span><a href="#41727997">next</a><span>|</span><label class="collapse" for="c-41725112">[-]</label><label class="expand" for="c-41725112">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I use it in my PKCS#11 client glue code.</div><br/></div></div></div></div></div></div><div id="41727997" class="c"><input type="checkbox" id="c-41727997" checked=""/><div class="controls bullet"><span class="by">karel-3d</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41723505">parent</a><span>|</span><a href="#41724534">prev</a><span>|</span><a href="#41723595">next</a><span>|</span><label class="collapse" for="c-41727997">[-]</label><label class="expand" for="c-41727997">[1 more]</label></div><br/><div class="children"><div class="content">what worked for me for cross-compiling go:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;elastic&#x2F;golang-crossbuild">https:&#x2F;&#x2F;github.com&#x2F;elastic&#x2F;golang-crossbuild</a> docker images for macos and windows (not linux though)<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rust-cross&#x2F;rust-musl-cross">https:&#x2F;&#x2F;github.com&#x2F;rust-cross&#x2F;rust-musl-cross</a>
docker images for linux (yes, it&#x27;s possible to use the same one for go, you just need to put go binary there) so it&#x27;s static with musl libc and sure to not have some weird issues with old&#x2F;new libc on old&#x2F;new&#x2F;whatever linuxes<p>(it might be over the top and the zig thing might effectively do the same thing, but I never got it to compile)<p>oh and apple-codesign rust cargo to get through the signing nonsense</div><br/></div></div><div id="41723595" class="c"><input type="checkbox" id="c-41723595" checked=""/><div class="controls bullet"><span class="by">0x1ceb00da</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41723505">parent</a><span>|</span><a href="#41727997">prev</a><span>|</span><a href="#41723785">next</a><span>|</span><label class="collapse" for="c-41723595">[-]</label><label class="expand" for="c-41723595">[10 more]</label></div><br/><div class="children"><div class="content">Wasn&#x27;t elf format modified by upstream to accomodate for cosmo? That makes it kinda official. Still hard to see a use case for it. If you want everyone to be able to run your program, just write a web app, a win32 program, or a java applet. 20 years old java applets still run on modern JVMs.</div><br/><div id="41724925" class="c"><input type="checkbox" id="c-41724925" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41723595">parent</a><span>|</span><a href="#41725910">next</a><span>|</span><label class="collapse" for="c-41724925">[-]</label><label class="expand" for="c-41724925">[1 more]</label></div><br/><div class="children"><div class="content">Justine has similar claims about POSIX allowing binary in shell scripts now<p>&gt; This is an idea whose time has come; POSIX even changed their rules about binary in shell scripts specifically to let us do it.<p><a href="https:&#x2F;&#x2F;justine.lol&#x2F;cosmo3&#x2F;" rel="nofollow">https:&#x2F;&#x2F;justine.lol&#x2F;cosmo3&#x2F;</a><p>&gt; Jilles Tjoelker from the FreeBSD project played an instrumental role in helping me to get the POSIX rules changed to allow binary in shell scripts, which is what made this project possible.<p><a href="https:&#x2F;&#x2F;justine.lol&#x2F;ape.html" rel="nofollow">https:&#x2F;&#x2F;justine.lol&#x2F;ape.html</a><p>but that&#x27;s not true, as recently discussed here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41636569">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41636569</a></div><br/></div></div><div id="41725910" class="c"><input type="checkbox" id="c-41725910" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41723595">parent</a><span>|</span><a href="#41724925">prev</a><span>|</span><a href="#41724232">next</a><span>|</span><label class="collapse" for="c-41725910">[-]</label><label class="expand" for="c-41725910">[7 more]</label></div><br/><div class="children"><div class="content">A web app is, well, a web app. Many things don&#x27;t fit this format, e.g. command line tools.<p>A Win32 program will not run out of the box on either Linux or macOS. Neither will a Java app.<p>The nice thing about Cosmopolitan is that it &quot;just works&quot; as far as end user is concerned. But without firm support from the OSes involved, it is inevitably a hack with questionable long-term stability prospects.<p>What we really need is some kind of standardized <i>low-level</i> (think LLVM bitcode or wasm) architecture- and platform-agnostic binary format that can be JIT-compiled to the same native code that a C compiler would have produced from the source. And that is supported by all major OSes out of the box.</div><br/><div id="41726011" class="c"><input type="checkbox" id="c-41726011" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41725910">parent</a><span>|</span><a href="#41726694">next</a><span>|</span><label class="collapse" for="c-41726011">[-]</label><label class="expand" for="c-41726011">[5 more]</label></div><br/><div class="children"><div class="content">Yes that&#x27;s exactly what we need. And we&#x27;ll be laughing to the bank when we bundle a browser toolbar with adware into its installer ten years down the road. Oh wait Java already did this. OTOH Cosmopolitan gives you complete autonomy. You don&#x27;t need a JVM to run a simple native command line program on multiple OSes and I proved that.</div><br/><div id="41726249" class="c"><input type="checkbox" id="c-41726249" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41726011">parent</a><span>|</span><a href="#41726694">next</a><span>|</span><label class="collapse" for="c-41726249">[-]</label><label class="expand" for="c-41726249">[4 more]</label></div><br/><div class="children"><div class="content">JVM bytecode is obviously not what I was talking about - it is neither low-level (if you can&#x27;t efficiently compile the entirety of C into it, it&#x27;s not good enough for this purpose), nor did it ever have universal first-class OS support.<p>And stuff like <a href="https:&#x2F;&#x2F;github.com&#x2F;jart&#x2F;cosmopolitan&#x2F;issues&#x2F;1263">https:&#x2F;&#x2F;github.com&#x2F;jart&#x2F;cosmopolitan&#x2F;issues&#x2F;1263</a> shows that just because it works today, it doesn&#x27;t mean that it&#x27;ll work tomorrow. What&#x27;s the guarantee that the same won&#x27;t happen on Linux or macOS eventually?<p>Don&#x27;t get me wrong, APE is a hell of a hack, and I love it for that. But it can&#x27;t be a truly stable platform without guarantees from the underlying OSes to keep all of that machinery working the same way. And if we could actually get them to agree on something like that, why not get them to agree on an <i>actual</i> portable executable format that is future-proof also wrt new CPU architectures?<p>(Note, by the way, that this is orthogonal to the whole notion of fat binaries that contain arch-specific code. That is still a useful optimization to have in practice even if one has portable bytecode, <i>alongside</i> said portable bytecode.)</div><br/><div id="41727209" class="c"><input type="checkbox" id="c-41727209" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41726249">parent</a><span>|</span><a href="#41726694">next</a><span>|</span><label class="collapse" for="c-41727209">[-]</label><label class="expand" for="c-41727209">[3 more]</label></div><br/><div class="children"><div class="content">I agree. As a user you should have those guarantees. Here&#x27;s how I&#x27;m helping you get them.<p>- With Windows, APE is just PE and WIN32 so those are already guaranteed by Microsoft.<p>- With Linux, I&#x27;ve been working with kernel maintainers to build consensus around around a patch <a href="https:&#x2F;&#x2F;justine.lol&#x2F;ape.patch" rel="nofollow">https:&#x2F;&#x2F;justine.lol&#x2F;ape.patch</a> that will let your APE binaries be loaded by binfmt_elf. This will provide you with a guarantee that they&#x27;ll still work, even if someone has for instance registered a binfmt_misc entry like WINE that&#x27;s intercepting MZ executables.<p>- With FreeBSD, I&#x27;m also working to build consensus here around another patch, that will help the kernel load APE natively as a normal ELF executable. That means you won&#x27;t need to rely on the system shell to load your program into memory.<p>- I&#x27;ve been writing a specification for APE that documents this file format, its ABI, and its historical encodings. <a href="https:&#x2F;&#x2F;github.com&#x2F;jart&#x2F;cosmopolitan&#x2F;blob&#x2F;master&#x2F;ape&#x2F;specification.md">https:&#x2F;&#x2F;github.com&#x2F;jart&#x2F;cosmopolitan&#x2F;blob&#x2F;master&#x2F;ape&#x2F;specifi...</a><p>One day in the future, when we have the support of major OSes for the native loading of portable binaries, we&#x27;ll look back at the APE shell script bootstrapping process similar to how we look back at self-extracting zip archives. When Phil Katz first invented PKZIP, it was useful to prepend the software to each archive. But nowadays it isn&#x27;t necessary, since all OSes come with support for PKZIP built in.</div><br/><div id="41728297" class="c"><input type="checkbox" id="c-41728297" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41727209">parent</a><span>|</span><a href="#41726694">next</a><span>|</span><label class="collapse" for="c-41728297">[-]</label><label class="expand" for="c-41728297">[2 more]</label></div><br/><div class="children"><div class="content">I rather suspect that Apple will not play along.<p>That said, a fat binary format that works for both Windows and Linux is already very useful.</div><br/><div id="41728431" class="c"><input type="checkbox" id="c-41728431" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41728297">parent</a><span>|</span><a href="#41726694">next</a><span>|</span><label class="collapse" for="c-41728431">[-]</label><label class="expand" for="c-41728431">[1 more]</label></div><br/><div class="children"><div class="content">If we earn the support of Linux and FreeBSD then we might stand of chance. Apple might ask for a better way to secure ape executables, which could be potentially exciting, since it&#x27;d be nice to have a vendor neutral solution to code signing.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41724232" class="c"><input type="checkbox" id="c-41724232" checked=""/><div class="controls bullet"><span class="by">bcoates</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41723595">parent</a><span>|</span><a href="#41725910">prev</a><span>|</span><a href="#41723785">next</a><span>|</span><label class="collapse" for="c-41724232">[-]</label><label class="expand" for="c-41724232">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t reasonably assume the end user system has a system JVM installed (they probably don&#x27;t, in fact) so they&#x27;re not really an alternative to a fat binary -- if you can install dependencies, you can just pick a single-target binary while you&#x27;re at it.</div><br/></div></div></div></div><div id="41723785" class="c"><input type="checkbox" id="c-41723785" checked=""/><div class="controls bullet"><span class="by">hyperion2010</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41723505">parent</a><span>|</span><a href="#41723595">prev</a><span>|</span><a href="#41723648">next</a><span>|</span><label class="collapse" for="c-41723785">[-]</label><label class="expand" for="c-41723785">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Most people<p>We&#x27;ll I&#x27;m used to not being most people, but I&#x27;d much rather be able to produce a single identical binary for my users that works everywhere than the platform specific nonsense I have to go through right now. Having to maintain different special build processes for different platforms is a stupid waste of time.<p>Frankly this is how it always should have worked except for the monopolistic behavior of various platforms in the past.</div><br/><div id="41724459" class="c"><input type="checkbox" id="c-41724459" checked=""/><div class="controls bullet"><span class="by">bjourne</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41723785">parent</a><span>|</span><a href="#41723648">next</a><span>|</span><label class="collapse" for="c-41724459">[-]</label><label class="expand" for="c-41724459">[6 more]</label></div><br/><div class="children"><div class="content">The binary is only one part of the puzzle (and largely solved by WSL). Installation&#x2F;uninstallation and desktop integration is just as much of a hassle.</div><br/><div id="41725872" class="c"><input type="checkbox" id="c-41725872" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41724459">parent</a><span>|</span><a href="#41725240">next</a><span>|</span><label class="collapse" for="c-41725872">[-]</label><label class="expand" for="c-41725872">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you can reasonably assume that people have WSL set up on Windows for the purposes of shipping desktop software. Nor does it cover Mac.</div><br/><div id="41727519" class="c"><input type="checkbox" id="c-41727519" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41725872">parent</a><span>|</span><a href="#41725240">next</a><span>|</span><label class="collapse" for="c-41727519">[-]</label><label class="expand" for="c-41727519">[1 more]</label></div><br/><div class="children"><div class="content">Well, there&#x27;s orb on mac which is in some ways better&#x2F;faster than WSL</div><br/></div></div></div></div><div id="41725240" class="c"><input type="checkbox" id="c-41725240" checked=""/><div class="controls bullet"><span class="by">cycomanic</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41724459">parent</a><span>|</span><a href="#41725872">prev</a><span>|</span><a href="#41725118">next</a><span>|</span><label class="collapse" for="c-41725240">[-]</label><label class="expand" for="c-41725240">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get the argument, if the binary part is solved by WSL it isn&#x27;t useless is it? Otherwise why would MS invest so much resources into it?</div><br/><div id="41725672" class="c"><input type="checkbox" id="c-41725672" checked=""/><div class="controls bullet"><span class="by">bjourne</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41725240">parent</a><span>|</span><a href="#41725118">next</a><span>|</span><label class="collapse" for="c-41725672">[-]</label><label class="expand" for="c-41725672">[1 more]</label></div><br/><div class="children"><div class="content">WSL can do a lot more than just run Linux binaries.</div><br/></div></div></div></div></div></div></div></div><div id="41723648" class="c"><input type="checkbox" id="c-41723648" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41723505">parent</a><span>|</span><a href="#41723785">prev</a><span>|</span><a href="#41724947">next</a><span>|</span><label class="collapse" for="c-41723648">[-]</label><label class="expand" for="c-41723648">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Most people producing cross-platform software don&#x27;t want a single executable that runs on every platform<p>They don&#x27;t? Having one file to download instead of a maze of &quot;okay so what do you have&quot; is way easier than the current mess. It would be very nice not to have to ask users what platform they&#x27;re on, they just click a link and get the thing.</div><br/><div id="41728568" class="c"><input type="checkbox" id="c-41728568" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41723648">parent</a><span>|</span><a href="#41724194">next</a><span>|</span><label class="collapse" for="c-41728568">[-]</label><label class="expand" for="c-41728568">[1 more]</label></div><br/><div class="children"><div class="content">Having the browser get the right URL for the download button is by far the most trivial issue when it comes to multi-platform support.</div><br/></div></div><div id="41724194" class="c"><input type="checkbox" id="c-41724194" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41723648">parent</a><span>|</span><a href="#41728568">prev</a><span>|</span><a href="#41726006">next</a><span>|</span><label class="collapse" for="c-41724194">[-]</label><label class="expand" for="c-41724194">[1 more]</label></div><br/><div class="children"><div class="content">Trade offs.  While there is a point to that, memory, bandwidth and storage are not free.  Users with constrains will want a smaller executable. Of course all 3 are pretty cheap these days so more and more you can get by with just one does it all executable and nobody will care about the downsides, but lets not lose track of them.</div><br/></div></div></div></div></div></div><div id="41724947" class="c"><input type="checkbox" id="c-41724947" checked=""/><div class="controls bullet"><span class="by">dundarious</span><span>|</span><a href="#41723161">parent</a><span>|</span><a href="#41723505">prev</a><span>|</span><a href="#41724165">next</a><span>|</span><label class="collapse" for="c-41724947">[-]</label><label class="expand" for="c-41724947">[2 more]</label></div><br/><div class="children"><div class="content">Mozilla llamafile uses it. Bundles model weights and an executable into a single file, that can be run from any cosmo&#x2F;ape platform, and spawns a redbean http server for you to interact with the LLM. Can also run it without the integrated weights, and read weights from the filesystem. It&#x27;s the easiest &quot;get up and go&quot; for local LLMs you could possibly create.</div><br/><div id="41726792" class="c"><input type="checkbox" id="c-41726792" checked=""/><div class="controls bullet"><span class="by">cowsandmilk</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41724947">parent</a><span>|</span><a href="#41724165">next</a><span>|</span><label class="collapse" for="c-41726792">[-]</label><label class="expand" for="c-41726792">[1 more]</label></div><br/><div class="children"><div class="content">Mozilla’s llamafile is primarily developed by jart. I wouldn’t view it as anyone else actually using cosmo&#x2F;ape</div><br/></div></div></div></div><div id="41724165" class="c"><input type="checkbox" id="c-41724165" checked=""/><div class="controls bullet"><span class="by">blenderob</span><span>|</span><a href="#41723161">parent</a><span>|</span><a href="#41724947">prev</a><span>|</span><a href="#41725823">next</a><span>|</span><label class="collapse" for="c-41724165">[-]</label><label class="expand" for="c-41724165">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Is there a catch?<p>I am only speaking for myself here. While cosmo and ape do seem very clever, I do not need this type of clever stuff in my work if the ordinary stuff already works fine.<p>Like for example if I can already cross-compile my project to other OSes and platforms or if I&#x27;ve got the infra to build my project for other OSes and platforms, I&#x27;ve no reason to look for a solution that lets me build one binary that works everywhere.<p>There&#x27;s also the thing that ape uses clever hacks to be able to run on multiple OSes. What if those hacks break someday due to how executable formats evolve? What if nobody has the time to patch APE to make it compatible with those changes?<p>But my boring tools like gcc, clang, go, rust, etc. will continue to get updated and they will continue to work with evolving OSes. So I just tend to stick with the boring. That&#x27;s why I don&#x27;t bother with the clever because the boring just works for me.</div><br/><div id="41728379" class="c"><input type="checkbox" id="c-41728379" checked=""/><div class="controls bullet"><span class="by">sublimefire</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41724165">parent</a><span>|</span><a href="#41725823">next</a><span>|</span><label class="collapse" for="c-41728379">[-]</label><label class="expand" for="c-41728379">[2 more]</label></div><br/><div class="children"><div class="content">If the executable format changes then it would affect more than just ape&#x2F;cosmopolitan. All of the old binaries would just stop working.</div><br/><div id="41728558" class="c"><input type="checkbox" id="c-41728558" checked=""/><div class="controls bullet"><span class="by">blenderob</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41728379">parent</a><span>|</span><a href="#41725823">next</a><span>|</span><label class="collapse" for="c-41728558">[-]</label><label class="expand" for="c-41728558">[1 more]</label></div><br/><div class="children"><div class="content">I am not worried about the scenario where the executable format changes breaks old binaries. That is never going to happen. No OS worth its name is going to do that.<p>I am worried about the scenario where the executable format changes just enough to break APE binaries. Like I said, APE uses very clever hacks to make itself work on multiple OSes. It is conceivable that executable formats change just enough that it breaks the clever hacks in APE binaries without breaking old ordinary binaries.</div><br/></div></div></div></div></div></div><div id="41725823" class="c"><input type="checkbox" id="c-41725823" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41723161">parent</a><span>|</span><a href="#41724165">prev</a><span>|</span><a href="#41723735">next</a><span>|</span><label class="collapse" for="c-41725823">[-]</label><label class="expand" for="c-41725823">[1 more]</label></div><br/><div class="children"><div class="content">Mozilla has a project called Llamafile (<a href="https:&#x2F;&#x2F;github.com&#x2F;Mozilla-Ocho&#x2F;llamafile">https:&#x2F;&#x2F;github.com&#x2F;Mozilla-Ocho&#x2F;llamafile</a>) that&#x27;s based on Cosmopolitan libc. And they do regularly publish popular models repackaged in that format on Hugging Face: <a href="https:&#x2F;&#x2F;huggingface.co&#x2F;models?search=llamafile" rel="nofollow">https:&#x2F;&#x2F;huggingface.co&#x2F;models?search=llamafile</a>.<p>Whether <i>that</i> in turn has any practical use beyond quickly trying out small models is another question.</div><br/></div></div><div id="41723735" class="c"><input type="checkbox" id="c-41723735" checked=""/><div class="controls bullet"><span class="by">jkachmar</span><span>|</span><a href="#41723161">parent</a><span>|</span><a href="#41725823">prev</a><span>|</span><a href="#41725827">next</a><span>|</span><label class="collapse" for="c-41723735">[-]</label><label class="expand" for="c-41723735">[3 more]</label></div><br/><div class="children"><div class="content">reposting my comment from another time this discussion came up:<p>&quot;Cosmopolitan has basically always felt like the interesting sort of technical loophole that makes for a fun blog post which is almost guaranteed to make it to the front page of HN (or similar) purely based in ingenuity &amp; dedication to the bit.<p>as a piece of foundational technology, in the way that `libc` necessarily is, it seems primarily useful for fun toys and small personal projects.<p>with that context, it always feels a little strange to see it presented as a serious alternative to something like `glibc`, `musl`, or `msvcrt`; it’s a very cute hack, but if i were to find it in something i seriously depend on i think i’d be a little taken aback.&quot;</div><br/><div id="41728447" class="c"><input type="checkbox" id="c-41728447" checked=""/><div class="controls bullet"><span class="by">sublimefire</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41723735">parent</a><span>|</span><a href="#41726673">next</a><span>|</span><label class="collapse" for="c-41728447">[-]</label><label class="expand" for="c-41728447">[1 more]</label></div><br/><div class="children"><div class="content">The problem with this take is that it is not grounded in facts that should determine if the thing is good or bad.<p>Logically having one thing instead of multiple makes sense as it simplifies the distribution and bytes stored&#x2F;transmitted. I think the issue here is that it is not time tested. I believe multiple people in various places around the globe think about it and will try to test it. With time this will either bubble up or be stale.</div><br/></div></div><div id="41726673" class="c"><input type="checkbox" id="c-41726673" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41723735">parent</a><span>|</span><a href="#41728447">prev</a><span>|</span><a href="#41725827">next</a><span>|</span><label class="collapse" for="c-41726673">[-]</label><label class="expand" for="c-41726673">[1 more]</label></div><br/><div class="children"><div class="content">But what&#x27;s actually bad about it?</div><br/></div></div></div></div><div id="41725827" class="c"><input type="checkbox" id="c-41725827" checked=""/><div class="controls bullet"><span class="by">gavindean90</span><span>|</span><a href="#41723161">parent</a><span>|</span><a href="#41723735">prev</a><span>|</span><a href="#41726897">next</a><span>|</span><label class="collapse" for="c-41725827">[-]</label><label class="expand" for="c-41725827">[1 more]</label></div><br/><div class="children"><div class="content">Tbh I don’t know that there is a catch except that there is one core person behind whole project. I like that there are fresh ideas in the C space.</div><br/></div></div><div id="41724723" class="c"><input type="checkbox" id="c-41724723" checked=""/><div class="controls bullet"><span class="by">tangus</span><span>|</span><a href="#41723161">parent</a><span>|</span><a href="#41726897">prev</a><span>|</span><a href="#41723434">next</a><span>|</span><label class="collapse" for="c-41724723">[-]</label><label class="expand" for="c-41724723">[2 more]</label></div><br/><div class="children"><div class="content">Last year I needed to make a small webapp to be hosted on a Windows server, and I thought RedBean would be ideal for it. Unfortunately it was too buggy (at least on Windows).<p>I don&#x27;t know whether RedBean is production-ready now, but a year and a half ago, that was the catch.</div><br/><div id="41724837" class="c"><input type="checkbox" id="c-41724837" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41724723">parent</a><span>|</span><a href="#41723434">next</a><span>|</span><label class="collapse" for="c-41724837">[-]</label><label class="expand" for="c-41724837">[1 more]</label></div><br/><div class="children"><div class="content">Give the latest nightly build a try: <a href="https:&#x2F;&#x2F;cosmo.zip&#x2F;pub&#x2F;cosmos&#x2F;bin&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cosmo.zip&#x2F;pub&#x2F;cosmos&#x2F;bin&#x2F;</a> Windows has been a long hard march, but we&#x27;ve recently hit near feature completion. As of last month, the final major missing piece of the puzzle was implemented, which is the ability to send UNIX signals between processes. Cosmopolitan does such a good job on Windows now that it&#x27;s not only been sturdy for redbean, but much more mature and complicated software as well, like Emacs, GNU Make, clang, Qt, and more.</div><br/></div></div></div></div><div id="41723434" class="c"><input type="checkbox" id="c-41723434" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#41723161">parent</a><span>|</span><a href="#41724723">prev</a><span>|</span><a href="#41727403">next</a><span>|</span><label class="collapse" for="c-41723434">[-]</label><label class="expand" for="c-41723434">[11 more]</label></div><br/><div class="children"><div class="content">&gt; So I’ve gotta ask: Is there a catch? Are these tools doing something evil to achieve what they’re achieving?<p>it&#x27;s not that complicated; they&#x27;re fat binaries (plus i guess a lot of papering over the differences between the platforms) that exploit a quirk of tshell:<p>&gt; One day, while studying old code, I found out that it&#x27;s possible to encode Windows Portable Executable files as a UNIX Sixth Edition shell script, due to the fact that the Thompson Shell didn&#x27;t use a shebang line.<p>(<a href="https:&#x2F;&#x2F;justine.lol&#x2F;ape.html" rel="nofollow">https:&#x2F;&#x2F;justine.lol&#x2F;ape.html</a>)<p>so the answer is simple: i can&#x27;t think of anyone that <i>wants</i> to ship fat binaries.</div><br/><div id="41725271" class="c"><input type="checkbox" id="c-41725271" checked=""/><div class="controls bullet"><span class="by">cycomanic</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41723434">parent</a><span>|</span><a href="#41723679">next</a><span>|</span><label class="collapse" for="c-41725271">[-]</label><label class="expand" for="c-41725271">[4 more]</label></div><br/><div class="children"><div class="content">Correct me if I&#x27;m wrong, but I always thought Apple universal binaries are fat binaries? So why did Apple build this ability if nobody wants it?</div><br/><div id="41726143" class="c"><input type="checkbox" id="c-41726143" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41725271">parent</a><span>|</span><a href="#41723679">next</a><span>|</span><label class="collapse" for="c-41726143">[-]</label><label class="expand" for="c-41726143">[3 more]</label></div><br/><div class="children"><div class="content">&gt; So why did Apple build this ability if nobody wants it?<p>did you miss the part where they transitioned from x86 to arm64 in 2020?</div><br/><div id="41726501" class="c"><input type="checkbox" id="c-41726501" checked=""/><div class="controls bullet"><span class="by">cycomanic</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41726143">parent</a><span>|</span><a href="#41723679">next</a><span>|</span><label class="collapse" for="c-41726501">[-]</label><label class="expand" for="c-41726501">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get your point. People were arguing that one doesn&#x27;t need fat binaries because cross compiling and having different binaries is fine. Apple clearly thought differently when they transitioned from x86 to arm (not their first architecture transition either).<p>So now you&#x27;re saying because apple finished the transition fat binaries are useless again? What about other platforms?</div><br/><div id="41726621" class="c"><input type="checkbox" id="c-41726621" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41726501">parent</a><span>|</span><a href="#41723679">next</a><span>|</span><label class="collapse" for="c-41726621">[-]</label><label class="expand" for="c-41726621">[1 more]</label></div><br/><div class="children"><div class="content">&gt; finished the transition fat binaries are useless again?<p>yup that&#x27;s exactly what i&#x27;m saying.</div><br/></div></div></div></div></div></div></div></div><div id="41723679" class="c"><input type="checkbox" id="c-41723679" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41723434">parent</a><span>|</span><a href="#41725271">prev</a><span>|</span><a href="#41727403">next</a><span>|</span><label class="collapse" for="c-41723679">[-]</label><label class="expand" for="c-41723679">[6 more]</label></div><br/><div class="children"><div class="content">Anyone focused on customer experience wants to ship a binary that just works, without customers having to know what a fat binary even is.</div><br/><div id="41724206" class="c"><input type="checkbox" id="c-41724206" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41723679">parent</a><span>|</span><a href="#41724198">next</a><span>|</span><label class="collapse" for="c-41724206">[-]</label><label class="expand" for="c-41724206">[3 more]</label></div><br/><div class="children"><div class="content">Unless the customer is one who has issues with large downloads.  Not everyone has fiber to the home with massive storage on modern computers.  Some people have the entry level systems, settle for slow internet.  Often they are in poor or &quot;third world&quot; places which means maybe you don&#x27;t care about them, but they exist.</div><br/><div id="41725325" class="c"><input type="checkbox" id="c-41725325" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41724206">parent</a><span>|</span><a href="#41725186">next</a><span>|</span><label class="collapse" for="c-41725325">[-]</label><label class="expand" for="c-41725325">[1 more]</label></div><br/><div class="children"><div class="content">Given how fat modern websites are, compassion for the bandwidth deprived seems rare.</div><br/></div></div><div id="41725186" class="c"><input type="checkbox" id="c-41725186" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41724206">parent</a><span>|</span><a href="#41725325">prev</a><span>|</span><a href="#41724198">next</a><span>|</span><label class="collapse" for="c-41725186">[-]</label><label class="expand" for="c-41725186">[1 more]</label></div><br/><div class="children"><div class="content">Fat binaries are fine. Electron is a fat binary in a different sense.</div><br/></div></div></div></div><div id="41724198" class="c"><input type="checkbox" id="c-41724198" checked=""/><div class="controls bullet"><span class="by">thefaux</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41723679">parent</a><span>|</span><a href="#41724206">prev</a><span>|</span><a href="#41727403">next</a><span>|</span><label class="collapse" for="c-41724198">[-]</label><label class="expand" for="c-41724198">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think macos will allow you to run a downloaded cosmo binary without going into security settings and enabling it. That&#x27;s not an experience I&#x27;d want my customers to have personally which means if you care about mac normies, this isn&#x27;t a viable approach.</div><br/><div id="41726657" class="c"><input type="checkbox" id="c-41726657" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41724198">parent</a><span>|</span><a href="#41727403">next</a><span>|</span><label class="collapse" for="c-41726657">[-]</label><label class="expand" for="c-41726657">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know what magic is involved, but I was able to download eg <a href="https:&#x2F;&#x2F;cosmo.zip&#x2F;pub&#x2F;cosmos&#x2F;bin&#x2F;md5sum" rel="nofollow">https:&#x2F;&#x2F;cosmo.zip&#x2F;pub&#x2F;cosmos&#x2F;bin&#x2F;md5sum</a> and run it in a terminal without having to do run &#x27;xattr -d com.apple.quarantine&#x27; on it.</div><br/></div></div></div></div></div></div></div></div><div id="41727403" class="c"><input type="checkbox" id="c-41727403" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#41723161">parent</a><span>|</span><a href="#41723434">prev</a><span>|</span><a href="#41725502">next</a><span>|</span><label class="collapse" for="c-41727403">[-]</label><label class="expand" for="c-41727403">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is the whole thing a tom7-esque joke&#x2F;troll that I don’t get because I’m not as deep into compilers&#x2F;runtimes? Or are these really just ingenious tools that haven’t caught on yet?<p>If I went up to you in 2008, and said, hey, lets build a database that doesn&#x27;t do schemas, isn&#x27;t relational, doesn&#x27;t do SQL, isn&#x27;t ACID compliant, doesn&#x27;t to joins, has transactions as an afterthought, and only does indexing sometimes, you&#x27;d think I was trolling you. And then in 2009, Mongodb came out and caught on in various places. So only time will tell if these are ingenious tools that haven&#x27;t caught on yet. There&#x27;s definitely a good amount of genius behind it, though only time will tell if it&#x27;s remembered in the vein of tom7&#x27;s harder drives or if it sees wider production use. I&#x27;ll say that if golang supported it as a platform, I&#x27;d switch my build pipelines at work over to it, since it makes their output less complicated to manage as there&#x27;s only a single binary to deal with instead of 3-4.</div><br/></div></div><div id="41725502" class="c"><input type="checkbox" id="c-41725502" checked=""/><div class="controls bullet"><span class="by">sfn42</span><span>|</span><a href="#41723161">parent</a><span>|</span><a href="#41727403">prev</a><span>|</span><a href="#41722487">next</a><span>|</span><label class="collapse" for="c-41725502">[-]</label><label class="expand" for="c-41725502">[3 more]</label></div><br/><div class="children"><div class="content">Most people aren&#x27;t writing C as far as I know. We use Java, C#, Go, Python etc, some lunatics even use Node.<p>We generally don&#x27;t care if some mutex is 3x faster than some other mutex. Most of the time if I&#x27;m even using a mutex which is rare in itself, the performance of the mutex is generally the least of my concerns.<p>I&#x27;m sure it matters to someone, but most people couldn&#x27;t give two shits if they know what they&#x27;re doing. We&#x27;re not writing code where it&#x27;s going to make a noticeable difference. There are thousands of things in our code we could optimize that would make a greater impact than a faster mutex, but we&#x27;re not looking at those either because it&#x27;s fast enough the way it is.</div><br/><div id="41725696" class="c"><input type="checkbox" id="c-41725696" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41725502">parent</a><span>|</span><a href="#41722487">next</a><span>|</span><label class="collapse" for="c-41725696">[-]</label><label class="expand" for="c-41725696">[2 more]</label></div><br/><div class="children"><div class="content">What a pointless contribution</div><br/><div id="41727241" class="c"><input type="checkbox" id="c-41727241" checked=""/><div class="controls bullet"><span class="by">yas_hmaheshwari</span><span>|</span><a href="#41723161">root</a><span>|</span><a href="#41725696">parent</a><span>|</span><a href="#41722487">next</a><span>|</span><label class="collapse" for="c-41727241">[-]</label><label class="expand" for="c-41727241">[1 more]</label></div><br/><div class="children"><div class="content">I came here to write this.  In such a good discussion thread, this was such a sore thumb</div><br/></div></div></div></div></div></div></div></div><div id="41722487" class="c"><input type="checkbox" id="c-41722487" checked=""/><div class="controls bullet"><span class="by">jonathrg</span><span>|</span><a href="#41723161">prev</a><span>|</span><a href="#41722949">next</a><span>|</span><label class="collapse" for="c-41722487">[-]</label><label class="expand" for="c-41722487">[23 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s still a new C library and it&#x27;s a little rough around the edges. But it&#x27;s getting so good, so fast, that I&#x27;m starting to view not using it in production as an abandonment of professional responsibility.<p>What an odd statement. I appreciate the Cosmopolitan project, but these exaggerated claims of superiority are usually a pretty bad red flag.</div><br/><div id="41722796" class="c"><input type="checkbox" id="c-41722796" checked=""/><div class="controls bullet"><span class="by">tredre3</span><span>|</span><a href="#41722487">parent</a><span>|</span><a href="#41727592">next</a><span>|</span><label class="collapse" for="c-41722796">[-]</label><label class="expand" for="c-41722796">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;d like to point out that Justine&#x27;s claims are usually correct. It&#x27;s just her shtick (or personality?) to use hyperbole and ego-stroking wording. I can see why some might see it as abrasive (it has caused drama before, namely in llamacpp).</div><br/><div id="41723455" class="c"><input type="checkbox" id="c-41723455" checked=""/><div class="controls bullet"><span class="by">another-acct</span><span>|</span><a href="#41722487">root</a><span>|</span><a href="#41722796">parent</a><span>|</span><a href="#41723206">next</a><span>|</span><label class="collapse" for="c-41723455">[-]</label><label class="expand" for="c-41723455">[2 more]</label></div><br/><div class="children"><div class="content">I also meant to comment about the grandstanding in her post.<p>Technical achievement aside, when a person invents something new, the burden is <i>on them</i> to prove that the new thing is a suitable replacement of &#x2F; improvement over the existing stuff. &quot;I&#x27;m starting to view &#x2F;not&#x2F; using [cosmo] in production as an abandonment of professional responsibility&quot; is emotional manipulation -- it&#x27;s guilt-tripping. Professional responsibility is the exact opposite of what she suggests: it&#x27;s not jumping on the newest bandwagon. &quot;a little rough around the edges&quot; is precisely what production environments don&#x27;t want; predictability&#x2F;stability is frequently more important than peak performance &#x2F; microbenchmarks.<p>Furthermore,<p>&gt; The C library is so deeply embedded in the software supply chain, and so depended upon, that you really don&#x27;t want it to be a planet killer.<p>This is just underhanded. She implicitly called glibc and musl &quot;planet killers&quot;.<p>First, technically speaking, it&#x27;s just not true; and even if the implied statement were remotely true (i.e., if those mutex implementations were in fact responsible for a significant amount of cycles in actual workloads), the emotional load &#x2F; snide remark (&quot;planet killer&quot;) is unjustified.<p>Second, she must know very well that whenever efficiency of computation is improved, we don&#x27;t use that for running the same workloads as before at lower cost &#x2F; smaller environmental footprint. Instead, we keep all CPUs pegged all the time, and efficiency improvements only ever translate to <i>larger profit</i>. A faster mutex too translates to more $$$ pocketed, and not to less energy consumed.<p>I find her tone of voice repulsive.</div><br/><div id="41725576" class="c"><input type="checkbox" id="c-41725576" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#41722487">root</a><span>|</span><a href="#41723455">parent</a><span>|</span><a href="#41723206">next</a><span>|</span><label class="collapse" for="c-41725576">[-]</label><label class="expand" for="c-41725576">[1 more]</label></div><br/><div class="children"><div class="content">I agree overall with your sentiment but wanted to comment on one of your statements that I perceived to be hyperbole.<p>&gt; Second, she must know very well that whenever efficiency of computation is improved, we don&#x27;t use that for running the same workloads as before at lower cost &#x2F; smaller environmental footprint. Instead, we keep all CPUs pegged all the time, and efficiency improvements only ever translate to larger profit. A faster mutex too translates to more $$$ pocketed, and not to less energy consumed.<p>It depends on the use case. If you can serve the same number of users &#x2F; requests with fewer machines, then you buy and run fewer machines. (Yes, saving energy, but also saving on both capex and opex.)<p>Also, when you&#x27;re talking about anything resembling interactivity (as you might in the context of, say, a webserver), you really don&#x27;t want to run anywhere close to 100% average utilization. With unbounded queues, you end up with arbitrarily high wait times; with bounded queues, you end up serving 503s and 429s and other server errors.<p>That said, my experience with modern webservers is that you generally don&#x27;t rely on mutexes for synchronizing most work across worker threads, and instead you try to keep your workloads as embarrassingly parallel as possible.</div><br/></div></div></div></div><div id="41723206" class="c"><input type="checkbox" id="c-41723206" checked=""/><div class="controls bullet"><span class="by">jancsika</span><span>|</span><a href="#41722487">root</a><span>|</span><a href="#41722796">parent</a><span>|</span><a href="#41723455">prev</a><span>|</span><a href="#41728505">next</a><span>|</span><label class="collapse" for="c-41723206">[-]</label><label class="expand" for="c-41723206">[1 more]</label></div><br/><div class="children"><div class="content">This case isn&#x27;t abrasive, but it&#x27;s certainly incoherent.<p>Name a single case where professional responsibility would require C code <i>advertised</i> as &quot;rough around the edges&quot; to be used anywhere near production. (The weasel words &quot;starting to&quot; do not help the logic of that sentence.)<p>I can definitely understand how OP could view this as a red flag. The author should amend it.</div><br/></div></div><div id="41728505" class="c"><input type="checkbox" id="c-41728505" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#41722487">root</a><span>|</span><a href="#41722796">parent</a><span>|</span><a href="#41723206">prev</a><span>|</span><a href="#41726475">next</a><span>|</span><label class="collapse" for="c-41728505">[-]</label><label class="expand" for="c-41728505">[1 more]</label></div><br/><div class="children"><div class="content">The drama in llamacpp was not due to language, it was due to jart making false claims and having absolutely no idea how memory maps work in addition to needlessly changing file headers to contain her name in vanity.<p>I don’t think anybody can deny that jart is a smart person, but I think there is more to it than just language abbrasiveness which people take issue with.</div><br/></div></div><div id="41726475" class="c"><input type="checkbox" id="c-41726475" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#41722487">root</a><span>|</span><a href="#41722796">parent</a><span>|</span><a href="#41728505">prev</a><span>|</span><a href="#41727592">next</a><span>|</span><label class="collapse" for="c-41726475">[-]</label><label class="expand" for="c-41726475">[1 more]</label></div><br/><div class="children"><div class="content">She claimed posix changed for her use case, and it&#x27;s not true, posix disallows what she said.<p>Indeed the first few bullet points of her writeup on how the lock works (compare and swap for uncontended, futex for contended) is already how everybody implements locks for about 20 years since the futex was introduced for exactly this. Win32 critsec from even longer ago works the same way.</div><br/></div></div></div></div><div id="41727592" class="c"><input type="checkbox" id="c-41727592" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#41722487">parent</a><span>|</span><a href="#41722796">prev</a><span>|</span><a href="#41724740">next</a><span>|</span><label class="collapse" for="c-41727592">[-]</label><label class="expand" for="c-41727592">[1 more]</label></div><br/><div class="children"><div class="content">Justine seems like a fairly brilliant and creative person, but in production I don&#x27;t think I&#x27;d want to use a libc that&#x27;s &quot;new&quot; or &quot;rough around the edges&quot;.<p>Getting &quot;so fast&quot; is not my first priority when I run things in production.  That&#x27;s stability, predictability, and reliability.  Certainly performance is important: better-performing code can mean smaller infrastructure, which is great from a cost and environmental perspective.  But fast comes last.</div><br/></div></div><div id="41724740" class="c"><input type="checkbox" id="c-41724740" checked=""/><div class="controls bullet"><span class="by">gr4vityWall</span><span>|</span><a href="#41722487">parent</a><span>|</span><a href="#41727592">prev</a><span>|</span><a href="#41723622">next</a><span>|</span><label class="collapse" for="c-41724740">[-]</label><label class="expand" for="c-41724740">[2 more]</label></div><br/><div class="children"><div class="content">It came off as humor to me, at least.</div><br/><div id="41725687" class="c"><input type="checkbox" id="c-41725687" checked=""/><div class="controls bullet"><span class="by">orochimaaru</span><span>|</span><a href="#41722487">root</a><span>|</span><a href="#41724740">parent</a><span>|</span><a href="#41723622">next</a><span>|</span><label class="collapse" for="c-41725687">[-]</label><label class="expand" for="c-41725687">[1 more]</label></div><br/><div class="children"><div class="content">I agree. It seemed like humor to me. I have been accused of using off color humor with hyperbole before. So maybe the appeal is limited.</div><br/></div></div></div></div><div id="41723622" class="c"><input type="checkbox" id="c-41723622" checked=""/><div class="controls bullet"><span class="by">fefe23</span><span>|</span><a href="#41722487">parent</a><span>|</span><a href="#41724740">prev</a><span>|</span><a href="#41723611">next</a><span>|</span><label class="collapse" for="c-41723622">[-]</label><label class="expand" for="c-41723622">[7 more]</label></div><br/><div class="children"><div class="content">Have you considered that you may have a different kind of humor than Justine?<p>Why would you even post this here? Who do you think this is helping?</div><br/><div id="41723873" class="c"><input type="checkbox" id="c-41723873" checked=""/><div class="controls bullet"><span class="by">another-acct</span><span>|</span><a href="#41722487">root</a><span>|</span><a href="#41723622">parent</a><span>|</span><a href="#41723742">next</a><span>|</span><label class="collapse" for="c-41723873">[-]</label><label class="expand" for="c-41723873">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s fair to comment not only on the subject, but on the writing itself, too.<p>And it might help Justine improve her writing (and reach a larger audience -- after all, blog posts <i>intend</i> to reach <i>some</i> audience, don&#x27;t they?). Of course you can always say, &quot;if you find yourself alienated, it&#x27;s your loss&quot;.</div><br/></div></div><div id="41723742" class="c"><input type="checkbox" id="c-41723742" checked=""/><div class="controls bullet"><span class="by">jonathrg</span><span>|</span><a href="#41722487">root</a><span>|</span><a href="#41723622">parent</a><span>|</span><a href="#41723873">prev</a><span>|</span><a href="#41723611">next</a><span>|</span><label class="collapse" for="c-41723742">[-]</label><label class="expand" for="c-41723742">[5 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t clearly come across as a joke.</div><br/><div id="41724968" class="c"><input type="checkbox" id="c-41724968" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#41722487">root</a><span>|</span><a href="#41723742">parent</a><span>|</span><a href="#41723837">next</a><span>|</span><label class="collapse" for="c-41724968">[-]</label><label class="expand" for="c-41724968">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a splash of dry humor on a personal blog in an information dense article.</div><br/><div id="41725632" class="c"><input type="checkbox" id="c-41725632" checked=""/><div class="controls bullet"><span class="by">jonathrg</span><span>|</span><a href="#41722487">root</a><span>|</span><a href="#41724968">parent</a><span>|</span><a href="#41723837">next</a><span>|</span><label class="collapse" for="c-41725632">[-]</label><label class="expand" for="c-41725632">[1 more]</label></div><br/><div class="children"><div class="content">OK, Poe&#x27;s law at work then :)</div><br/></div></div></div></div><div id="41725950" class="c"><input type="checkbox" id="c-41725950" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41722487">root</a><span>|</span><a href="#41723742">parent</a><span>|</span><a href="#41723837">prev</a><span>|</span><a href="#41723611">next</a><span>|</span><label class="collapse" for="c-41725950">[-]</label><label class="expand" for="c-41725950">[1 more]</label></div><br/><div class="children"><div class="content">I think the domain name for her website is justine.lol for a reason.</div><br/></div></div></div></div></div></div><div id="41723611" class="c"><input type="checkbox" id="c-41723611" checked=""/><div class="controls bullet"><span class="by">pmarreck</span><span>|</span><a href="#41722487">parent</a><span>|</span><a href="#41723622">prev</a><span>|</span><a href="#41726100">next</a><span>|</span><label class="collapse" for="c-41723611">[-]</label><label class="expand" for="c-41723611">[1 more]</label></div><br/><div class="children"><div class="content">I feel that there’s a certain amount of hubris that comes along with spending long periods of time solo-coding on a computer, and perhaps unwittingly starved of social contact. Without any checks on you or your work’s importance (normally provided by your bog-standard “job”), your achievements take on a grandeur that they might not have broadly earned, as impressive as they might be.<p>An example is APE (which I otherwise feel is a very impressive hack). One criticism might be “oh, so I not only get to be insecure on one platform, I can be insecure on many all at once?”<p>The longer you spend in technology, the more you realize that there are extremely few win-wins and a very many win-somes, lose-somes (tradeoffs)</div><br/></div></div><div id="41726100" class="c"><input type="checkbox" id="c-41726100" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#41722487">parent</a><span>|</span><a href="#41723611">prev</a><span>|</span><a href="#41723181">next</a><span>|</span><label class="collapse" for="c-41726100">[-]</label><label class="expand" for="c-41726100">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I appreciate the Cosmopolitan project, but these exaggerated claims of superiority are usually a pretty bad red flag.<p>In general, I agree with your sentiment, but Justine is simply a different beast. She does tend to use hyperbolic language a fair amount, but she delivers so much awesomeness that I make an exception for her.</div><br/></div></div><div id="41723181" class="c"><input type="checkbox" id="c-41723181" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#41722487">parent</a><span>|</span><a href="#41726100">prev</a><span>|</span><a href="#41722949">next</a><span>|</span><label class="collapse" for="c-41723181">[-]</label><label class="expand" for="c-41723181">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s especially a red-flag since an enormous number of projects (almost all of them?) will never tolerate shipping fat binaries (ie what cosmopolitan C is in reality).</div><br/><div id="41723763" class="c"><input type="checkbox" id="c-41723763" checked=""/><div class="controls bullet"><span class="by">ataylor284_</span><span>|</span><a href="#41722487">root</a><span>|</span><a href="#41723181">parent</a><span>|</span><a href="#41723528">next</a><span>|</span><label class="collapse" for="c-41723763">[-]</label><label class="expand" for="c-41723763">[1 more]</label></div><br/><div class="children"><div class="content">The core of this a library called nsync.  It appears most of the improvements by Justine are upstreamed into nsync itself which doesn&#x27;t have any of the baggage of cosmopolitan.  Whatever your opinion of the project or author, they&#x27;ve made good effort to not lock you in.</div><br/></div></div><div id="41723528" class="c"><input type="checkbox" id="c-41723528" checked=""/><div class="controls bullet"><span class="by">another-acct</span><span>|</span><a href="#41722487">root</a><span>|</span><a href="#41723181">parent</a><span>|</span><a href="#41723763">prev</a><span>|</span><a href="#41724127">next</a><span>|</span><label class="collapse" for="c-41723528">[-]</label><label class="expand" for="c-41723528">[1 more]</label></div><br/><div class="children"><div class="content">Agreed; this is what I&#x27;ve always (silently) thought of those fat binaries. Absolute stroke of genius, no doubt, and also a total abomination (IMO) from a sustainability perspective.</div><br/></div></div><div id="41724127" class="c"><input type="checkbox" id="c-41724127" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#41722487">root</a><span>|</span><a href="#41723181">parent</a><span>|</span><a href="#41723528">prev</a><span>|</span><a href="#41722949">next</a><span>|</span><label class="collapse" for="c-41724127">[-]</label><label class="expand" for="c-41724127">[1 more]</label></div><br/><div class="children"><div class="content">Ironic given the generous size of the average Go binary.</div><br/></div></div></div></div></div></div><div id="41722949" class="c"><input type="checkbox" id="c-41722949" checked=""/><div class="controls bullet"><span class="by">amiga386</span><span>|</span><a href="#41722487">prev</a><span>|</span><a href="#41724952">next</a><span>|</span><label class="collapse" for="c-41722949">[-]</label><label class="expand" for="c-41722949">[14 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s so good, why haven&#x27;t all C libraries adopted the same tricks?<p>My betting is that its tricks are only always-faster for certain architectures, or certain CPU models, or certain types of workload &#x2F; access patterns... and a proper benchmarking of varied workloads on all supported hardware would not show the same benefits.<p>Alternatively, maybe the semantics of the pthread API (that cosmopolitan is meant to be implementing) are somehow subtly different and this implementation isn&#x27;t strictly compliant to the spec?<p>I can&#x27;t imagine it&#x27;s that the various libc authors aren&#x27;t keeping up in state-of-the-art research on OS primitives...</div><br/><div id="41725612" class="c"><input type="checkbox" id="c-41725612" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#41722949">parent</a><span>|</span><a href="#41723079">next</a><span>|</span><label class="collapse" for="c-41725612">[-]</label><label class="expand" for="c-41725612">[3 more]</label></div><br/><div class="children"><div class="content">Those projects often have dozens of other priorities beyond just one specific API, and obsessing over individual APIs isn&#x27;t a good way to spend the limited time they have. In any case, as a concrete example to disprove your claim, you can look at malloc and string routines in your average libc on Linux.<p>glibc&#x27;s malloc is tolerable but fails handily to more modern alternatives in overall speed and scalability (it fragments badly and degrades over time, not to mention it has a dozen knobs that can deeply impact real life workloads like MALLOC_ARENA_MAX). musl malloc is completely awful in terms of performance at every level; in a multithreaded program, using musl&#x27;s allocator will destroy your performance so badly that it nearly qualifies as malpractice, in my experience.<p>musl doesn&#x27;t even have things like SIMD optimized string comparison routines. You would be shocked at how many CPU cycles in a non-trivial program are spent on those tasks, and yes it absolutely shows up in non-trivial profiles, and yes improving this improves all programs nearly universally. glibc&#x27;s optimized routines are good, but they can <i>always</i>, it seems, become faster.<p>These specific things aren&#x27;t &quot;oh, they&#x27;re hyper specific optimizations for one architecture that don&#x27;t generalize&quot;. These two things in particular -- we&#x27;re talking 2-5x wall clock reduction, and drastically improved long-term working set utilization, in nearly all workloads for any given program. These are well explored and understood spaces with good known approaches. So why didn&#x27;t they take them? Because, as always, they probably had other things to do (or conflicting priorities like musl prioritizing simplicity over peak performance, even when that philosophy is actively detrimental to users.)<p>I&#x27;m not blaming these projects or anything. Nobody sets out and says &quot;My program is slow as shit and does nothing right, and I designed it that way and I&#x27;m proud of it.&quot; But the idea that the people working on them have made only the perfect pareto frontier of design choices just isn&#x27;t realistic in the slightest and doesn&#x27;t capture the actual dynamics of how most of these projects are run.</div><br/><div id="41725705" class="c"><input type="checkbox" id="c-41725705" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#41722949">root</a><span>|</span><a href="#41725612">parent</a><span>|</span><a href="#41726771">next</a><span>|</span><label class="collapse" for="c-41725705">[-]</label><label class="expand" for="c-41725705">[1 more]</label></div><br/><div class="children"><div class="content">&gt; musl doesn&#x27;t even have things like SIMD optimized string comparison routines. You would be shocked at how many CPU cycles in a non-trivial program are spent on those tasks<p>Building GNU Make with Cosmo or glibc makes cold startup go 2x faster for me on large repos compared to building it with Musl, due to vectorized strlen() alone (since SIMD is 2x faster than SWAR). I sent Rich a patch last decade adding sse to strlen(), since I love Musl, and Cosmo is based on it. But alas he didn&#x27;t want it. Even though he seems perfectly comfortable using ARM&#x27;s strlen() assembly.<p>&gt; glibc&#x27;s malloc is tolerable but fails handily to more modern alternatives in overall speed and scalability<p>The focus and attention I put into cosmo mutexes isn&#x27;t unique. I put that care into everything else too, and malloc() is no exception. Cosmo does very well at multi-threaded memory allocation. I can pick benchmark parameters where it outperforms glibc and jemalloc by 100x. I can also pick params where jemalloc wins by 100x. But I&#x27;m reasonably certain cosmo can go faster than glibc and musl in most cases while using less memory too. You have Doug Lea to thank for that.<p>Every day is a good day working on cosmo, because I can always find an opportunity to dive into another rabbit hole. Even ones as seemingly unimportant as clocks: <a href="https:&#x2F;&#x2F;github.com&#x2F;jart&#x2F;cosmopolitan&#x2F;commit&#x2F;dd8544c3bd7899ad83492beb1a862e8d34a9a99b">https:&#x2F;&#x2F;github.com&#x2F;jart&#x2F;cosmopolitan&#x2F;commit&#x2F;dd8544c3bd7899ad...</a></div><br/></div></div><div id="41726771" class="c"><input type="checkbox" id="c-41726771" checked=""/><div class="controls bullet"><span class="by">wrsh07</span><span>|</span><a href="#41722949">root</a><span>|</span><a href="#41725612">parent</a><span>|</span><a href="#41725705">prev</a><span>|</span><a href="#41723079">next</a><span>|</span><label class="collapse" for="c-41726771">[-]</label><label class="expand" for="c-41726771">[1 more]</label></div><br/><div class="children"><div class="content">Another example is hash maps: all the large companies built better maps in cpp (folly, absl), but the number of apps that are performance sensitive and still use std::unordered_map will be astounding forever.<p>(Why not upstream? ABI compatibility which is apparently a sufficient veto reason for anything in cpp)</div><br/></div></div></div></div><div id="41723079" class="c"><input type="checkbox" id="c-41723079" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#41722949">parent</a><span>|</span><a href="#41725612">prev</a><span>|</span><a href="#41728140">next</a><span>|</span><label class="collapse" for="c-41723079">[-]</label><label class="expand" for="c-41723079">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I can&#x27;t imagine it&#x27;s that the various libc authors aren&#x27;t keeping up in state-of-the-art research on OS primitives...<p>is this sarcasm?<p>(I don&#x27;t know any libc maintainers, but as a maintainer of a few thingies myself, I do not try to implement state-of-the-art research, I try to keep my thingies stable and ensure the performance is acceptable; implementing research is out of my budget for &quot;maintenance&quot;)</div><br/><div id="41723406" class="c"><input type="checkbox" id="c-41723406" checked=""/><div class="controls bullet"><span class="by">amiga386</span><span>|</span><a href="#41722949">root</a><span>|</span><a href="#41723079">parent</a><span>|</span><a href="#41728140">next</a><span>|</span><label class="collapse" for="c-41723406">[-]</label><label class="expand" for="c-41723406">[3 more]</label></div><br/><div class="children"><div class="content">But if you maintain a few thingies, you&#x27;d probably know about rival thingies that do a similar thing, right?<p>If the rival thingies got a speed boost recently, and they were open source, you&#x27;d want to have a look at how they did it and maybe get a similar speed boost for yourself.</div><br/><div id="41723661" class="c"><input type="checkbox" id="c-41723661" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41722949">root</a><span>|</span><a href="#41723406">parent</a><span>|</span><a href="#41723729">next</a><span>|</span><label class="collapse" for="c-41723661">[-]</label><label class="expand" for="c-41723661">[1 more]</label></div><br/><div class="children"><div class="content">This is nowhere near as common as you seem to think, and mostly only happens for the narrow cases where somebody is obsessed with a particular problem so that they&#x27;d actually <i>want</i> to read other people&#x27;s solutions. Most of the implementers do not have that sort of relationship to a problem they solved in the past.<p>If in December you make a general purpose stable sort that&#x27;s 25% faster than his, Orson Peters <i>is</i> probably going to read your code and try to apply ideas from it. But sorting is the thing Peters really cares about, the people who wrote the stable sort in say Microsoft&#x27;s STL (their C++ standard library implementation) even if they still work there won&#x27;t care enough to go back and change that unless told to do so.</div><br/></div></div><div id="41723729" class="c"><input type="checkbox" id="c-41723729" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#41722949">root</a><span>|</span><a href="#41723406">parent</a><span>|</span><a href="#41723661">prev</a><span>|</span><a href="#41728140">next</a><span>|</span><label class="collapse" for="c-41723729">[-]</label><label class="expand" for="c-41723729">[1 more]</label></div><br/><div class="children"><div class="content">It depends on the calculus about (time) budget and stability. Maybe I consider performance already acceptable, and don&#x27;t have time budget to investigate beyond that. Maybe I look at &quot;nsync&quot;, see its mutex (may) change the fairness semantics, and then decide not to adopt it because this may break my callers; or its enough that it <i>may</i> change the fairness semantics, and I don&#x27;t have the budget to test nsync or a new implementation based on the nsync algorithm to determine if the semantics differ.</div><br/></div></div></div></div></div></div><div id="41728140" class="c"><input type="checkbox" id="c-41728140" checked=""/><div class="controls bullet"><span class="by">pnt12</span><span>|</span><a href="#41722949">parent</a><span>|</span><a href="#41723079">prev</a><span>|</span><a href="#41726984">next</a><span>|</span><label class="collapse" for="c-41728140">[-]</label><label class="expand" for="c-41728140">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If it&#x27;s so good, why haven&#x27;t all C libraries adopted the same tricks?<p>A man and a statiscian are walking down the street when they see a 50€ bill. The statistician keeps walking but the man stops and says &quot;hey, look at this cash on the floor?&quot;. But the statistician, uninpressed, says: &quot;must be fake, or someone would have already picked it up&quot;. And continues walking. The other man grabs the cash and takes it.</div><br/></div></div><div id="41726984" class="c"><input type="checkbox" id="c-41726984" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#41722949">parent</a><span>|</span><a href="#41728140">prev</a><span>|</span><a href="#41725724">next</a><span>|</span><label class="collapse" for="c-41726984">[-]</label><label class="expand" for="c-41726984">[1 more]</label></div><br/><div class="children"><div class="content">Are there ABI considerations for changing a pthread mutex implementation?</div><br/></div></div><div id="41725724" class="c"><input type="checkbox" id="c-41725724" checked=""/><div class="controls bullet"><span class="by">Const-me</span><span>|</span><a href="#41722949">parent</a><span>|</span><a href="#41726984">prev</a><span>|</span><a href="#41724133">next</a><span>|</span><label class="collapse" for="c-41725724">[-]</label><label class="expand" for="c-41725724">[3 more]</label></div><br/><div class="children"><div class="content">My guess is, because what’s in these current standard libraries and OSes are good enough.<p>Synchronizing multiple CPU cores together is fundamentally slow, there’s no ways around it. They are far apart on the chip, and sometimes even on different chips with some link between. When measuring time with CPU cycles that latency is rather slow.<p>Possible to avoid with good old software engineering, and over time people who wanted to extract performance from their multi-core CPUs became good at it.<p>When you’re computing something parallel which takes minutes, you’ll do great if you update the progress bar at a laughable 5 Hz. Synchronizing cores 5 times each second costs nothing regardless of how efficient is the mutex.<p>When you’re computing something interactive like a videogame, it’s often enough to synchronize cores once per rendered frame, which often happens at 60Hz.<p>Another notable example is multimedia frameworks. These handle realtime data coming at high frequencies like 48 kHz for audio, and they do non-trivial compute in these effect transforms and codecs so they need multiple cores. But they can tolerate a bit of latency so they’re just batching these samples. This dramatically saves IPC costs because you only need to lock these mutexes at 100Hz when batching 480 samples = 10ms of audio.</div><br/><div id="41726598" class="c"><input type="checkbox" id="c-41726598" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#41722949">root</a><span>|</span><a href="#41725724">parent</a><span>|</span><a href="#41725985">next</a><span>|</span><label class="collapse" for="c-41726598">[-]</label><label class="expand" for="c-41726598">[1 more]</label></div><br/><div class="children"><div class="content">&gt; When you’re computing something interactive like a videogame, it’s often enough to synchronize cores once per rendered frame, which often happens at 60Hz.<p>That&#x27;s not really the right way to do it.  If you&#x27;re actually using multiple cores in your code, you want to build a data dependency graph and let the cores walk that graph.  Max node size ends up being something loosely like 10k items to be processed.  You&#x27;ll typically see hundreds of synchronization points per frame.<p>This is the base architecture of stuff like Thread Building Blocks and rust&#x27;s rayon library.</div><br/></div></div><div id="41725985" class="c"><input type="checkbox" id="c-41725985" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#41722949">root</a><span>|</span><a href="#41725724">parent</a><span>|</span><a href="#41726598">prev</a><span>|</span><a href="#41724133">next</a><span>|</span><label class="collapse" for="c-41725985">[-]</label><label class="expand" for="c-41725985">[1 more]</label></div><br/><div class="children"><div class="content">&gt; They are far apart on the chip, and sometimes even on different chips with some link between.<p>They aren&#x27;t always. On a NUMA machine some are closer than others; M-series is an example. The cores are in clusters where some of the cache is shared, so atomics are cheap as long as it doesn&#x27;t leave the cluster.</div><br/></div></div></div></div><div id="41724133" class="c"><input type="checkbox" id="c-41724133" checked=""/><div class="controls bullet"><span class="by">dist-epoch</span><span>|</span><a href="#41722949">parent</a><span>|</span><a href="#41725724">prev</a><span>|</span><a href="#41724952">next</a><span>|</span><label class="collapse" for="c-41724133">[-]</label><label class="expand" for="c-41724133">[1 more]</label></div><br/><div class="children"><div class="content">Politics, not-invented-here syndrome, old maintainers.<p>It takes forever to change something in glibc, or the C++ equivalent.<p>There are many kinds of synchronization primitives. pthreads only supports a subset. If you are limiting yourself to them, you are most likely leaving performance on the table, but you gain portability.</div><br/></div></div></div></div><div id="41724952" class="c"><input type="checkbox" id="c-41724952" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41722949">prev</a><span>|</span><a href="#41723325">next</a><span>|</span><label class="collapse" for="c-41724952">[-]</label><label class="expand" for="c-41724952">[1 more]</label></div><br/><div class="children"><div class="content">Production isn&#x27;t about speed, efficiency,  or obviously &quot;clever hacks.&quot;<p>If I have to sacrifice 50% of my efficiency to ensure that I never get called on Sunday at 3am to fix a broken system,  no kidding,  I&#x27;ll make that trade every time.<p>Production is about _reliability_.  And writing reliable code is 10x harder than writing &quot;fast&quot; code.</div><br/></div></div><div id="41723325" class="c"><input type="checkbox" id="c-41723325" checked=""/><div class="controls bullet"><span class="by">1st1</span><span>|</span><a href="#41724952">prev</a><span>|</span><a href="#41723421">next</a><span>|</span><label class="collapse" for="c-41723325">[-]</label><label class="expand" for="c-41723325">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve even had the opportunity to make upstream contributions. For example, I found and fixed a bug in his mutex unlock function that had gone undiscovered for years.<p>I see a stream of improvements to the vendored in nsync inside the cosmopolitan project [1].  Are you planning on upstreaming most of those too?<p>A separate question -- is using the upstream nsync as safe as using your fork?<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;jart&#x2F;cosmopolitan&#x2F;commits&#x2F;master&#x2F;third_party&#x2F;nsync&#x2F;mu.c">https:&#x2F;&#x2F;github.com&#x2F;jart&#x2F;cosmopolitan&#x2F;commits&#x2F;master&#x2F;third_pa...</a></div><br/><div id="41723690" class="c"><input type="checkbox" id="c-41723690" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#41723325">parent</a><span>|</span><a href="#41723421">next</a><span>|</span><label class="collapse" for="c-41723690">[-]</label><label class="expand" for="c-41723690">[1 more]</label></div><br/><div class="children"><div class="content">If Burrows wants my C11 atomics refactoring then he shall have it. Beyond that, my changes mostly concern libc integration, systems integration, and portability. Our projects have different goals in those areas, so I&#x27;m not sure he needs them.</div><br/></div></div></div></div><div id="41723421" class="c"><input type="checkbox" id="c-41723421" checked=""/><div class="controls bullet"><span class="by">yshui</span><span>|</span><a href="#41723325">prev</a><span>|</span><a href="#41728099">next</a><span>|</span><label class="collapse" for="c-41723421">[-]</label><label class="expand" for="c-41723421">[1 more]</label></div><br/><div class="children"><div class="content">I had the pleasure of reverse-engineering win32 SRWLOCKs, and based on the author description of nsync it is very close to how SRWLOCK works internally. Kind of surprised how much faster nsync is compared to SRWLOCK.</div><br/></div></div><div id="41728099" class="c"><input type="checkbox" id="c-41728099" checked=""/><div class="controls bullet"><span class="by">mareko</span><span>|</span><a href="#41723421">prev</a><span>|</span><a href="#41725602">next</a><span>|</span><label class="collapse" for="c-41728099">[-]</label><label class="expand" for="c-41728099">[1 more]</label></div><br/><div class="children"><div class="content">If anyone&#x27;s interested in this general subject matter, a while back I did some academic research on highly scalable locks where we came up with some very high performance reader-writer locks:<p><a href="https:&#x2F;&#x2F;people.csail.mit.edu&#x2F;mareko&#x2F;spaa09-scalablerwlocks.pdf" rel="nofollow">https:&#x2F;&#x2F;people.csail.mit.edu&#x2F;mareko&#x2F;spaa09-scalablerwlocks.p...</a></div><br/></div></div><div id="41725602" class="c"><input type="checkbox" id="c-41725602" checked=""/><div class="controls bullet"><span class="by">dumdood</span><span>|</span><a href="#41728099">prev</a><span>|</span><a href="#41726690">next</a><span>|</span><label class="collapse" for="c-41725602">[-]</label><label class="expand" for="c-41725602">[2 more]</label></div><br/><div class="children"><div class="content">Threads and mutexes are the most complicating things in computer science. I am always skeptical of new implementations until they&#x27;ve been used for several years at scale. Bugs in these threading mechanisms often elude even the most intense scrutiny. When Java hit the scene in the mid 90s it exposed all manner of thread and mutex bugs in Solaris. I don&#x27;t want the fastest mutex implementation - I want a reliable one.</div><br/><div id="41727741" class="c"><input type="checkbox" id="c-41727741" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#41725602">parent</a><span>|</span><a href="#41726690">next</a><span>|</span><label class="collapse" for="c-41727741">[-]</label><label class="expand" for="c-41727741">[1 more]</label></div><br/><div class="children"><div class="content">mutexes are far from the most &#x27;complicated&#x27;. There are really not that many way to implement them (efficiently). In most cases there are best avoided, esp. on the read paths.</div><br/></div></div></div></div><div id="41726690" class="c"><input type="checkbox" id="c-41726690" checked=""/><div class="controls bullet"><span class="by">petermcneeley</span><span>|</span><a href="#41725602">prev</a><span>|</span><a href="#41721810">next</a><span>|</span><label class="collapse" for="c-41726690">[-]</label><label class="expand" for="c-41726690">[1 more]</label></div><br/><div class="children"><div class="content">This sounds like EAThread&#x27;s futex. 
<a href="https:&#x2F;&#x2F;github.com&#x2F;electronicarts&#x2F;EAThread&#x2F;blob&#x2F;master&#x2F;source&#x2F;eathread_futex.cpp">https:&#x2F;&#x2F;github.com&#x2F;electronicarts&#x2F;EAThread&#x2F;blob&#x2F;master&#x2F;sourc...</a></div><br/></div></div><div id="41721810" class="c"><input type="checkbox" id="c-41721810" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#41726690">prev</a><span>|</span><a href="#41727466">next</a><span>|</span><label class="collapse" for="c-41721810">[-]</label><label class="expand" for="c-41721810">[65 more]</label></div><br/><div class="children"><div class="content">I have to admit that I have an extremely visceral, negative feeling whenever I see a mutex, simply because I&#x27;ve had to debug enough code written by engineers who don&#x27;t really know how to use them, so a large part of previous jobs has been to remove locks from code and replace with some kind of queue or messaging abstraction [1].<p>It&#x27;s only recently that I&#x27;ve been actively looking into different locking algorithms, just because I&#x27;ve been diving in head-first to a lot of pure concurrency and distributed computing theory, a lot of which is about figuring out clever ways of doing mutexes with different tradeoffs.<p>I&#x27;ve gotten a lot better with them now, and while I still personally will gravitate towards messaging-based concurrency over locks, I do feel the need to start playing with some of the more efficient locking tools in C, like nsync (mentioned in this article).<p>[1] Before you give me shit over this, generally the replacement code runs at roughly the same speed, and I at least personally think that it&#x27;s easier to reason about.</div><br/><div id="41722160" class="c"><input type="checkbox" id="c-41722160" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#41721810">parent</a><span>|</span><a href="#41721868">next</a><span>|</span><label class="collapse" for="c-41722160">[-]</label><label class="expand" for="c-41722160">[20 more]</label></div><br/><div class="children"><div class="content">What are some examples of people using mutexes wrong? I know one gotcha is you need to maintain a consistent hierarchy. Usually the easiest way to not get snagged by that, is to have critical sections be small and pure. Java&#x27;s whole MO of letting people add a synchronized keyword to an entire method was probably not the greatest idea.</div><br/><div id="41722440" class="c"><input type="checkbox" id="c-41722440" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722160">parent</a><span>|</span><a href="#41722843">next</a><span>|</span><label class="collapse" for="c-41722440">[-]</label><label class="expand" for="c-41722440">[16 more]</label></div><br/><div class="children"><div class="content">When, how, and why.<p>The biggest part of mutexes and how to properly use them is thinking of the consistency of the data that you are working with.<p>Here&#x27;s a really common bug (psuedocode)<p><pre><code>    if (lock {data.size()} &gt; 0) {
      value = lock { data.pop() }
      lock { foo.add(value) }
    }
</code></pre>
The issue here is size can change, pop can change, and foo can change in unexpected ways between each of the acquired locks.<p>The right way to write this code is<p><pre><code>    lock {
      if (data.size() &gt; 0) {
        value = data.pop()
        foo.add(value)
      }
    }
</code></pre>
That ensures the data is all in a consistent state while you are mutating it.<p>Now, what does make this tricky is someone well-meaning might have decided to push the lock down a method.<p>Imagine, for example, you have a `Foo` where all methods operate within a mutex.<p>This code is also (likely) incorrect.<p><pre><code>    value = foo.bar()
    if (value.bat()) {
      foo.baz(value)
    }
</code></pre>
The problem here is exactly the same problem as above.  Between `foo.bar()` and `foo.baz()` the state of foo may have changed such that running `foo.baz(value)` is now a mistake.  That&#x27;s why the right thing to do is likely to have a `foo.barBaz()` method that encapsulates the `if` logic to avoid inconsistency (or to add another mutex).<p>In java, the most common manifestation (that I see) of this looks like this<p><pre><code>    var map = new ConcurrentHashMap();
    if (map.get(foo) == null)
      map.put(foo, new Value());
</code></pre>
Because now, you have a situation where the value of `foo` in the map could be 2 or more values depending on who gets it.  So, if someone is mutating `Value` concurrently you have a weird hard to track down data race.<p>The solution to this problem in java is<p><pre><code>    map.computeIfAbsent(foo, (unused)-&gt;new Value());</code></pre></div><br/><div id="41722865" class="c"><input type="checkbox" id="c-41722865" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722440">parent</a><span>|</span><a href="#41724091">next</a><span>|</span><label class="collapse" for="c-41722865">[-]</label><label class="expand" for="c-41722865">[11 more]</label></div><br/><div class="children"><div class="content">Composing locks is where Java usually blows up.<p>And computeIfAbsent can end up holding the lock for too long if the function is slow.</div><br/><div id="41723586" class="c"><input type="checkbox" id="c-41723586" checked=""/><div class="controls bullet"><span class="by">foobazgt</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722865">parent</a><span>|</span><a href="#41724091">next</a><span>|</span><label class="collapse" for="c-41723586">[-]</label><label class="expand" for="c-41723586">[10 more]</label></div><br/><div class="children"><div class="content">Composing locks isn&#x27;t a Java problem - it&#x27;s a fundamental abstraction problem with locks. This is one of the reasons why you usually reach for higher level abstractions than mutexes.<p>&gt; And computeIfAbsent can end up holding the lock for too long if the function is slow.<p>How is this different from any other lock-holding code written anywhere?</div><br/><div id="41724514" class="c"><input type="checkbox" id="c-41724514" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41723586">parent</a><span>|</span><a href="#41724091">next</a><span>|</span><label class="collapse" for="c-41724514">[-]</label><label class="expand" for="c-41724514">[9 more]</label></div><br/><div class="children"><div class="content">I’m saying Java is exceptionally bad at this because every object is its own mutex.<p>And you end up having to trade single core performance for multi core by deciding to speculatively calculate the object. If there’s no object to make the critical section is very small. But as the object sprouts features you start smashing face first into Amdahl.</div><br/><div id="41724810" class="c"><input type="checkbox" id="c-41724810" checked=""/><div class="controls bullet"><span class="by">foobazgt</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41724514">parent</a><span>|</span><a href="#41724091">next</a><span>|</span><label class="collapse" for="c-41724810">[-]</label><label class="expand" for="c-41724810">[8 more]</label></div><br/><div class="children"><div class="content">&gt;  because every object is its own mutex.<p>Not true in any practical sense.<p>&gt; And you end up having to trade single core performance for multi core by deciding to speculatively calculate the object.<p>What is the alternative you suggest? If you care about having the predicate actually hold, and you also don&#x27;t want to have to hold the lock while constructing the object, then you&#x27;re going to end up in an optimistic-concurrency scenario where you check the predicate under lock, compute the object, and check again before swapping the value in. You may end up having to throw your work away when you discover the predicate changed. Java is no better nor worse at doing this than anything else.</div><br/><div id="41725179" class="c"><input type="checkbox" id="c-41725179" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41724810">parent</a><span>|</span><a href="#41724091">next</a><span>|</span><label class="collapse" for="c-41725179">[-]</label><label class="expand" for="c-41725179">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Not true in any practical sense.<p>This is going to put a damper on any further conversation.<p>Even with coarsening and elision every synchronized function closes a lock on the enclosing object.</div><br/><div id="41726646" class="c"><input type="checkbox" id="c-41726646" checked=""/><div class="controls bullet"><span class="by">foobazgt</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41725179">parent</a><span>|</span><a href="#41725973">next</a><span>|</span><label class="collapse" for="c-41726646">[-]</label><label class="expand" for="c-41726646">[1 more]</label></div><br/><div class="children"><div class="content">&quot;every synchronized function&quot;<p>Right. Synchronized is the key word here. The vast majority of code doesn&#x27;t involve synchronized, and therefore the vast majority of objects don&#x27;t have locks associated with them. That&#x27;s quite important.<p>Those classes which do use synchronized were just going to create a ReentrantLock held for the duration of the call anyway, in which case it&#x27;s all monitorEnter and monitorExit, regardless.<p>&gt; This is going to put a damper on any further conversation.<p>Sadge.</div><br/></div></div><div id="41725973" class="c"><input type="checkbox" id="c-41725973" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41725179">parent</a><span>|</span><a href="#41726646">prev</a><span>|</span><a href="#41724091">next</a><span>|</span><label class="collapse" for="c-41725973">[-]</label><label class="expand" for="c-41725973">[5 more]</label></div><br/><div class="children"><div class="content">Do people actually use `synchronized` methods in Java these days? It&#x27;s been commonly described as an anti-pattern (for all the reasons discussed upthread here) two decades ago already.</div><br/><div id="41726441" class="c"><input type="checkbox" id="c-41726441" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41725973">parent</a><span>|</span><a href="#41724091">next</a><span>|</span><label class="collapse" for="c-41726441">[-]</label><label class="expand" for="c-41726441">[4 more]</label></div><br/><div class="children"><div class="content">The more useful question is has it been expunged from the JDK and common libraries. I think it&#x27;s been more like 10-12 years since it really started being talked about in more than certain subcommunities and that&#x27;s almost 20 years&#x27; worth of existing libraries.<p>OpenTelemetry is a fairly recent library. Even if you ignore some test fakes (where, let&#x27;s face it, who cares), it still uses it in a few places, and uses lock objects in others. I don&#x27;t see much evidence of recursion going on with the former. But that&#x27;s how things always start and later there&#x27;s running and screaming.</div><br/><div id="41726553" class="c"><input type="checkbox" id="c-41726553" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41726441">parent</a><span>|</span><a href="#41724091">next</a><span>|</span><label class="collapse" for="c-41726553">[-]</label><label class="expand" for="c-41726553">[3 more]</label></div><br/><div class="children"><div class="content">Some amount of legacy cruft is not unexpected, but it&#x27;s sad that it can be seen in new code. In .NET, which has similarly problematic semantics with lock(), linters have been flagging lock(this) for ages.<p>I wonder where this patently bad idea of every object carrying its own <i>publicly accessible</i> mutex originated in the first place. Did Java introduce it, or did it also copy that from somewhere else? And what was the motivation?</div><br/><div id="41727123" class="c"><input type="checkbox" id="c-41727123" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41726553">parent</a><span>|</span><a href="#41724091">next</a><span>|</span><label class="collapse" for="c-41727123">[-]</label><label class="expand" for="c-41727123">[2 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t attest to the history of `lock` statement from the top of my head but the API shape of lock and Monitor.Enter&#x2F;Exit methods it is desugared to looks like Win32&#x27;s EnterCriticalSection and LeaveCriticalSection. Other Monitor&#x27;s methods like Wait and Pulse look like pthread&#x27;s condvar and mutex functions.<p>.NET also has MethodImplOptions.Synchronized like Java does. However, the only place I have ever seen this attribute was on TextWriter.Synchronized implementation in CoreLib and nowhere else.<p>Java itself has `Lock` and `Condition`. In the end, most synchronization primitives do the same high-level actions and bound to end up having similar API.<p>As for `lock(this)`, much like with many other historically abused techniques that have become frowned upon - it&#x27;s not bad per se if you own the type and know that it is internal and will not be observed outside of the assembly it is defined in, provided it is small enough. It&#x27;s footgun-prone, but generally very few code paths will lock an arbitrary object instance at all, so most of the time it&#x27;s something you see so rarely it has become &quot;just write a comment why and move on&quot; when using it. Of course this requires more deliberation and it&#x27;s easier to default to blanket policies that ignore context. It can be difficult to get people to &quot;use the appropriate tool&quot; mentality.<p>.NET is also getting it&#x27;s a separate `Lock` type, on top of all the existing synchronization primitives, to move a little further away from other legacy aspects of `lock`ing on object instances.</div><br/><div id="41727629" class="c"><input type="checkbox" id="c-41727629" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41727123">parent</a><span>|</span><a href="#41724091">next</a><span>|</span><label class="collapse" for="c-41727629">[-]</label><label class="expand" for="c-41727629">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not Monitor itself that&#x27;s problematic. It&#x27;s that every object is implicitly associated with one, and <i>anyone</i> who holds a reference to an object can lock it. It doesn&#x27;t matter if the type is internal - it can still be upcast to System.Object and leaked that way.<p>In practice this means that unless you can guarantee that you never, ever leak a reference anywhere, you don&#x27;t know who else might be locking it. Which makes it impossible to reason about possible deadlocks. So the only sane way to manage it is to have a separate object used just for locking, which is never ever passed outside of the object that owns the lock.<p>And yes, this is absolutely bad design. There&#x27;s no reason why every object needs a lock, for starters - for the vast majority of them, it&#x27;s just unnecessary overhead (and yes, I know the monitors are lazily created, but every object header still needs space to store the reference to it). Then of course the fact that it&#x27;s there means that people take the easy path and just lock objects directly instead of creating separate locks, just because it&#x27;s slightly less code - and then things break. It&#x27;s almost always the wrong granularity, too.<p>Thing is, I haven&#x27;t seen this design anywhere outside of Java and .NET (which copied it from Java along with so many other bad ideas). Everybody else uses the sane and obvious approach of creating locks explicitly if and when they are needed.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41724091" class="c"><input type="checkbox" id="c-41724091" checked=""/><div class="controls bullet"><span class="by">another-acct</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722440">parent</a><span>|</span><a href="#41722865">prev</a><span>|</span><a href="#41724517">next</a><span>|</span><label class="collapse" for="c-41724091">[-]</label><label class="expand" for="c-41724091">[1 more]</label></div><br/><div class="children"><div class="content">Might want to move foo.add() out of the lock scope (assuming foo is a thread-private resource):<p><pre><code>    value = nil
    lock {
      if (data.size() &gt; 0) {
        value = data.pop()
      }
    }
    if (value) {
        foo.add(value)
    }</code></pre></div><br/></div></div><div id="41724517" class="c"><input type="checkbox" id="c-41724517" checked=""/><div class="controls bullet"><span class="by">jhatemyjob</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722440">parent</a><span>|</span><a href="#41724091">prev</a><span>|</span><a href="#41724452">next</a><span>|</span><label class="collapse" for="c-41724517">[-]</label><label class="expand" for="c-41724517">[1 more]</label></div><br/><div class="children"><div class="content">I digress but my autistic brain couldn&#x27;t help itself. Provided that it&#x27;s a recursive lock you could do this instead of adding a new method `foo.BarBaz`<p><pre><code>    foo.lock {
        value = foo.bar() &#x2F;&#x2F; foo.lock within this method is ignored
        if(value.bat()) {
            foo.baz() &#x2F;&#x2F; foo.lock within this method is ignored
        }
    }
</code></pre>
Also, to catch this bug early, you could assert foo is locked in `value.bat` or something. But that may or may not be feasible depending on how the  codebase is structured</div><br/></div></div><div id="41724452" class="c"><input type="checkbox" id="c-41724452" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722440">parent</a><span>|</span><a href="#41724517">prev</a><span>|</span><a href="#41722843">next</a><span>|</span><label class="collapse" for="c-41724452">[-]</label><label class="expand" for="c-41724452">[2 more]</label></div><br/><div class="children"><div class="content">This is one of the areas where Zig&#x27;s combination of anonymous blocks and block-based defer really pay off.  To create a locked region of code is just this<p><pre><code>    {
        mutex.lock();
        defer mutex.unlock();
        &#x2F;&#x2F; Do mutex things
    }
</code></pre>
It&#x27;s possible to get this wrong still, of course, but both the anonymous scope and the use of `defer` make it easier to get things right.<p>Nothing can prevent poor engineering around mutex use though. I&#x27;d want a critical path for a concurrent hashmap to look like this:<p><pre><code>    {
        shared_map.lock();
        defer shared_map.unlock();
        if (shared_map.getOrNull(foo) == null) {
            shared_map.put(foo, new_val);
        }
    }
</code></pre>
Where the SharedMap type has an internal mutex, and a way to check it, and all operations panic if no lock has been acquired.  It could have `shared_map.lockAndGet(OrNull?)(...)`, so that the kind of problem pattern you&#x27;re describing would stand out on the page, but it&#x27;s still a one-liner to do an atomic get when that&#x27;s all you need the critical path to perform.<p>I don&#x27;t think these invariants are overly onerous to uphold, but one does have to understand that they&#x27;re a hard requirement.</div><br/><div id="41725992" class="c"><input type="checkbox" id="c-41725992" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41724452">parent</a><span>|</span><a href="#41722843">next</a><span>|</span><label class="collapse" for="c-41725992">[-]</label><label class="expand" for="c-41725992">[1 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t seem to add anything over and above what std::mutex in C++ or a synchronized block in Java offer?</div><br/></div></div></div></div></div></div><div id="41722843" class="c"><input type="checkbox" id="c-41722843" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722160">parent</a><span>|</span><a href="#41722440">prev</a><span>|</span><a href="#41723314">next</a><span>|</span><label class="collapse" for="c-41722843">[-]</label><label class="expand" for="c-41722843">[1 more]</label></div><br/><div class="children"><div class="content">Personally I&#x27;ve had issues with performance because of people using `synchronized` too liberally, where they end up locking a lot more code than necessary.  I&#x27;ve also had issues with fairly typical circular-dependencies, causing deadlock, or at least pauses that aren&#x27;t strictly necessary.  Deadlock doesn&#x27;t happen nearly as often as textbooks have led me to believe, but it can happen with sloppily written code.<p>In regards to Java, at this point I almost never use the `synchronized` keyword anymore and instead (if I can&#x27;t easily map to some kind of queuing abstraction) use the ReentrantLock object simply because of the ability to have lock acquisition time out, and also letting you opt-in to fairness if you&#x27;d like. It&#x27;s not as pretty but it&#x27;s more flexible and as far as I&#x27;m aware it doesn&#x27;t affect performance much.<p>For the most part, though, in Java, you can get away without (explicit) locks by simply abusing the built-in data structures.  I know they&#x27;re using their own synchronization techniques behind the scenes, but I trust those to be correct more than some ad-hoc stuff I&#x27;d write as an engineer.</div><br/></div></div><div id="41723314" class="c"><input type="checkbox" id="c-41723314" checked=""/><div class="controls bullet"><span class="by">foobazgt</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722160">parent</a><span>|</span><a href="#41722843">prev</a><span>|</span><a href="#41723849">next</a><span>|</span><label class="collapse" for="c-41723314">[-]</label><label class="expand" for="c-41723314">[1 more]</label></div><br/><div class="children"><div class="content">Java&#x27;s take on monitors was definitely not great, and people were emulating mutexes with them even in the language&#x27;s earliest days.<p>Still there are a lot of things that can go wrong with mutexes: forgetting to unlock in the case of exceptions, priority inversion, recursive locking, deadlock, needlessly high contention, etc.<p>Java has had an excellent concurrency runtime with abstractions that are typically a better fit than a bare mutex for over 20 years now (c.f. Doug Lea). Synchronized still exists, because of Java&#x27;s excellent backwards compatibility.</div><br/></div></div><div id="41723849" class="c"><input type="checkbox" id="c-41723849" checked=""/><div class="controls bullet"><span class="by">foobiekr</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722160">parent</a><span>|</span><a href="#41723314">prev</a><span>|</span><a href="#41721868">next</a><span>|</span><label class="collapse" for="c-41723849">[-]</label><label class="expand" for="c-41723849">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always disliked that lock cyclic dependencies is discussed as a hierarchy when what it really comes down to is a linear order of locks.<p>The problem with lock _hierarchies_ as a concept is that a lock really should represent serialization of access to a particular pool of data, and should make no assumptions that it being held implies some other lock&#x27;s domain is also held. The code that results when people do not maintain this kind of rigor is quite terrible, but hierarchies tend to steer people into thinking that way because they imply recursively taking locks.<p>Stated differently: locks should be taken and released in a fixed order - so locks are ranked - but there should not be a model where all lower-ranked locks must be held for a given lock to be taken. The lock protects its domain and the ordering of take and release is to prevent deadlock, but there&#x27;s no requirement for completeness.</div><br/></div></div></div></div><div id="41721868" class="c"><input type="checkbox" id="c-41721868" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#41721810">parent</a><span>|</span><a href="#41722160">prev</a><span>|</span><a href="#41723573">next</a><span>|</span><label class="collapse" for="c-41721868">[-]</label><label class="expand" for="c-41721868">[29 more]</label></div><br/><div class="children"><div class="content">I feel the similarly about C&quot;s &quot;volatile&quot; (when used in multithreaded code rather than device drivers).  I&#x27;ve seen people scatter volatile around randomly until the problem goes away.  Given that volatile significantly disturbs the timing of a program, any timing sensitive bugs can be masked by adding it around randomly.</div><br/><div id="41721983" class="c"><input type="checkbox" id="c-41721983" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41721868">parent</a><span>|</span><a href="#41722439">next</a><span>|</span><label class="collapse" for="c-41721983">[-]</label><label class="expand" for="c-41721983">[20 more]</label></div><br/><div class="children"><div class="content">There seems to be a lot of voodoo beliefs around concurrent programming that lead to really bad things.<p>One of the best books I&#x27;ve read on it is Java concurrency in practice [1].  It does an excellent job of dispelling these occultic beliefs and letting the reader know exactly when and how concurrency should be implemented.  It is applicable to more languages than just java, especially since many have adopted large parts of the java memory model.<p>The worst things I usually find when reviewing concurrent code is people either not using locks when they should, using locks when they shouldn&#x27;t, and having inconsistent data guards.  I&#x27;ve seen people throw in random locks to guard local non-shared state which is just crazy town but &quot;Multiple threads are running this code, so I&#x27;m adding a lock&quot;.<p>I certainly prefer message passing over shared state.  However, it&#x27;s a little baffling to me why it&#x27;s so hard for devs to grasp how to properly maintain shared state.  Instead of just learning the basic rules, it gets couched in &quot;It&#x27;s just too hard to understand so keep adding things until it works&quot;.<p>[1] <a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Java-Concurrency-Practice-Brian-Goetz&#x2F;dp&#x2F;0321349601" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;Java-Concurrency-Practice-Brian-Goetz...</a></div><br/><div id="41722197" class="c"><input type="checkbox" id="c-41722197" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41721983">parent</a><span>|</span><a href="#41722866">next</a><span>|</span><label class="collapse" for="c-41722197">[-]</label><label class="expand" for="c-41722197">[12 more]</label></div><br/><div class="children"><div class="content">&gt;  However, it&#x27;s a little baffling to me why it&#x27;s so hard for devs to grasp how to properly maintain shared state. Instead of just learning the basic rules, it gets couched in &quot;It&#x27;s just too hard to understand so keep adding things until it works&quot;.<p>Probably because most people aren&#x27;t aware that there are basic rules to be learned. I&#x27;d imagine the typical experience is, you&#x27;re very familiar with single-threaded code, and now you&#x27;re trying to let other threads work with your data. You have heard that there are many pitfalls, and that there are special-purpose tools like mutexes to avoid those, but you look at the examples and find them mostly baffling. &quot;Why do they perform these incantations for this data but not that data, or in this place but not that place?&quot; So you come up with some weird mental model and move on with your life, never aware that there are underlying principles for maintaining shared state.<p>Personally, I didn&#x27;t understand mutexes very well at all, until I started looking into what the atomic memory orderings from C++ et al. were supposed to mean.</div><br/><div id="41722411" class="c"><input type="checkbox" id="c-41722411" checked=""/><div class="controls bullet"><span class="by">Maxatar</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722197">parent</a><span>|</span><a href="#41722866">next</a><span>|</span><label class="collapse" for="c-41722411">[-]</label><label class="expand" for="c-41722411">[11 more]</label></div><br/><div class="children"><div class="content">Not too sure what the basic rules are and I&#x27;m not able to find any list of such rules.<p>For me the biggest challenge when sharing state is that the only benefit I can see for parallelism is performance, so if I&#x27;m not gaining performance there is no reason to use parallelism. If I use coarse-grained mutexes then I end up with straight forward to reason about code but I lose the performance benefit and in fact can end up with slower than single threaded code.<p>If I use very fine grained mutexes then I end up with faster code that has very hard to find bugs that happen on very rare occasion.<p>And then on top of that even if you do write correct fine grained locking, you can still end up with slow code due to cache behavior such as false sharing and cache coherence.<p>So ultimately I disagree that writing parallel code is simple unless you&#x27;re willing to give up performance in which case you may as well just stick to single threaded code or use parallelism among independent data. Writing correct parallel software that shares state and actually delivers substantial performance benefits is incredibly difficult, and I am skeptical that there is a set of simple rules that one can simply read about.</div><br/><div id="41722620" class="c"><input type="checkbox" id="c-41722620" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722411">parent</a><span>|</span><a href="#41723224">next</a><span>|</span><label class="collapse" for="c-41722620">[-]</label><label class="expand" for="c-41722620">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Not too sure what the basic rules are and I&#x27;m not able to find any list of such rules.<p>The <i>actual</i> rules are completely terrifying because they involve the physics of microprocessors. If you&#x27;ve watched Grace Hopper&#x27;s lectures where she gives out physical nanoseconds (pieces of wire that are the same length as the distance light travels in a nanosecond, thus, the maximum possible distance data could travel in that time) you can start to appreciate the problem. It is <i>literally impossible</i> for the intuitive Sequentially Consistent model of how computers work to apply for today&#x27;s fast yet concurrent processors. Light is too slow.<p>However generally people mean either Java&#x27;s memory model or the C++ 11 (and subsequently 14, 17, 20) memory models used in languages such as C++, C and Rust. Those rules are less terrifying but still pretty complicated and the programming language promises to somehow provide an environment where these rules (not the terrifying ones) are all you need to know to write software. So that&#x27;s nice.<p>It <i>can</i> be simple to write parallel code for a language designed to make that easy. Yes even if there&#x27;s shared data. It only started to get trickier if the shared data is <i>modified</i>, so long as it isn&#x27;t we can make copies of it safely and modern CPUs will do that without actual work by the programmer.</div><br/><div id="41722867" class="c"><input type="checkbox" id="c-41722867" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722620">parent</a><span>|</span><a href="#41723224">next</a><span>|</span><label class="collapse" for="c-41722867">[-]</label><label class="expand" for="c-41722867">[4 more]</label></div><br/><div class="children"><div class="content">Are there popular languages that don&#x27;t have memory models which make reasoning about concurrent models easier?<p>A language with a notion of threading and shared state is going to have something akin to read&#x2F;write barriers built into the language memory model to tame the beast.</div><br/><div id="41724375" class="c"><input type="checkbox" id="c-41724375" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722867">parent</a><span>|</span><a href="#41725647">next</a><span>|</span><label class="collapse" for="c-41724375">[-]</label><label class="expand" for="c-41724375">[1 more]</label></div><br/><div class="children"><div class="content">I think tialaramex is overselling the complexity of concurrent memory models in practice, at least for end users. In reality, all modern memory models are based on the data-race-free theorem, which states that in the absence of data races--if your program is correctly synchronized--you can&#x27;t tell that the hardware isn&#x27;t sequentially consistent (i.e., what you naïvely expected it to do).<p>Correct synchronization is based on the happens-before relation; a data race is defined as a write and a conflicting read or write such that neither happens-before the other. Within a thread, happens-before is just regular program order. Across a thread, the main happens-before that is relevant is that an release-store on a memory location happens-before an acquire-load on that memory location (this can be generalized to any memory location <i>if</i> they&#x27;re both sequentially-consistent, but that&#x27;s usually not necessary).<p>The real cardinal rule of concurrent programming is to express your semantics in the highest-possible level of what you&#x27;re trying to do, and find some library that does all the nitty-grityy of the implementation. Can you express it with fork-join parallelism? Cool, use your standard library&#x27;s implementation of fork-join and just don&#x27;t care about it otherwise.</div><br/></div></div><div id="41725647" class="c"><input type="checkbox" id="c-41725647" checked=""/><div class="controls bullet"><span class="by">xxpor</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722867">parent</a><span>|</span><a href="#41724375">prev</a><span>|</span><a href="#41723224">next</a><span>|</span><label class="collapse" for="c-41725647">[-]</label><label class="expand" for="c-41725647">[2 more]</label></div><br/><div class="children"><div class="content">C?</div><br/><div id="41725997" class="c"><input type="checkbox" id="c-41725997" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41725647">parent</a><span>|</span><a href="#41723224">next</a><span>|</span><label class="collapse" for="c-41725997">[-]</label><label class="expand" for="c-41725997">[1 more]</label></div><br/><div class="children"><div class="content">C has the same model as C++ from the same era, so C11 is the C++ 11 model, C23 is C++ 20 and so on.<p>It&#x27;s C so you don&#x27;t get a comprehensive set of bells, whistles and horns like the C++ standard library, but the actual model is the same. At a high level it&#x27;s all the same as C++ 11, the details are not important to most people.</div><br/></div></div></div></div></div></div></div></div><div id="41723224" class="c"><input type="checkbox" id="c-41723224" checked=""/><div class="controls bullet"><span class="by">SJC_Hacker</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722411">parent</a><span>|</span><a href="#41722620">prev</a><span>|</span><a href="#41722729">next</a><span>|</span><label class="collapse" for="c-41723224">[-]</label><label class="expand" for="c-41723224">[3 more]</label></div><br/><div class="children"><div class="content">&gt; For me the biggest challenge when sharing state is that the only benefit I can see for parallelism is performance, so if I&#x27;m not gaining performance there is no reason to use parallelism.<p>Aside from performance, another very common reason is to not lock the UI from the user.  Even in UI-less programs, the ability to abort some operation which is taking too long.  Another is averaging out performance of compute tasks, even in the case where it would be faster to handle them sequentially.  Without some degree of parallelism these things are not possible.<p>Consider a web server.  Without parallelism every single request is going to completely lock the program until its complete.  With parallelism, you can spawn off each request, and handle new ones as they come in.  Perceived performance for majority of users in this case is significantly improved even in the case of single processor system - e.g. you have 99 requests which each take a single second, and then one which takes 101 seconds.  Total request time is 200 seconds &#x2F; 100 requests = 2 seconds average per request, but if that 100 second request comes in first, the other 99 are locked for 100 seconds, so average is now &gt; 100 seconds per request ...</div><br/><div id="41724637" class="c"><input type="checkbox" id="c-41724637" checked=""/><div class="controls bullet"><span class="by">Maxatar</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41723224">parent</a><span>|</span><a href="#41722729">next</a><span>|</span><label class="collapse" for="c-41724637">[-]</label><label class="expand" for="c-41724637">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Aside from performance, another very common reason is to not lock the UI from the user.<p>This is not a good fit for parallelism, this is pretty much always accomplished using concurrency ie. async&#x2F;await.</div><br/><div id="41726013" class="c"><input type="checkbox" id="c-41726013" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41724637">parent</a><span>|</span><a href="#41722729">next</a><span>|</span><label class="collapse" for="c-41726013">[-]</label><label class="expand" for="c-41726013">[1 more]</label></div><br/><div class="children"><div class="content">Assuming that the APIs &amp; libraries that you need are async. Which is, unfortunately, not always the case for historical reasons.</div><br/></div></div></div></div></div></div><div id="41722729" class="c"><input type="checkbox" id="c-41722729" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722411">parent</a><span>|</span><a href="#41723224">prev</a><span>|</span><a href="#41722673">next</a><span>|</span><label class="collapse" for="c-41722729">[-]</label><label class="expand" for="c-41722729">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Not too sure what the basic rules are and I&#x27;m not able to find any list of such rules.<p>I&#x27;d suggest the book in my original comment, Java concurrency in practice.<p>&gt; If I use very fine grained mutexes then I end up with faster code that has very hard to find bugs that happen on very rare occasion.<p>I agree this is a real risk if you are doing fine grained mutexes.  But the rules are the same whether or not you want to follow them.  If you have shared state (A, B, C) and you want to do a calculation based on the values of (A, B, C) then you need a mutex which locks (A, B, C).  Certainly, that become a problem if you have calculations that just require (A, C) and you might want to avoid locking for B.  In that case, you need a more complicated mechanism for locking than just simple mutexes which is certainly easy to get wrong.  When the (A, B, C) actions happen you have to ensure that the (A, C) actions can&#x27;t happen at the same time.<p>This isn&#x27;t a complicated rule, but it is one that can be hard to follow if you are trying to do super fine grained locking.  It&#x27;s even trickier if you are going to abuse the platform to get correct results.<p>But fine v coarse isn&#x27;t the problem I&#x27;m referring to when I say people get the simple rules wrong.  Rather, than worrying about fine vs coarse grained locking, I very frequently see code where mutexes and concurrency primitives are just peppered everywhere and haphazardly.  We might call that super coarse grained.</div><br/></div></div><div id="41722673" class="c"><input type="checkbox" id="c-41722673" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722411">parent</a><span>|</span><a href="#41722729">prev</a><span>|</span><a href="#41722866">next</a><span>|</span><label class="collapse" for="c-41722673">[-]</label><label class="expand" for="c-41722673">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Not too sure what the basic rules are and I&#x27;m not able to find any list of such rules.<p>You may want to consider <a href="https:&#x2F;&#x2F;marabos.nl&#x2F;atomics&#x2F;" rel="nofollow">https:&#x2F;&#x2F;marabos.nl&#x2F;atomics&#x2F;</a> for an approachable overview that&#x27;s still quite rigorous.</div><br/></div></div></div></div></div></div><div id="41722866" class="c"><input type="checkbox" id="c-41722866" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41721983">parent</a><span>|</span><a href="#41722197">prev</a><span>|</span><a href="#41722105">next</a><span>|</span><label class="collapse" for="c-41722866">[-]</label><label class="expand" for="c-41722866">[2 more]</label></div><br/><div class="children"><div class="content">+1 for the Java Concurrency in Practice book.  It&#x27;s the book I recommend to nearly everyone who wants to get into concurrent programming.  Goetz makes it a lot more approachable than most other books.</div><br/><div id="41722943" class="c"><input type="checkbox" id="c-41722943" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722866">parent</a><span>|</span><a href="#41722105">next</a><span>|</span><label class="collapse" for="c-41722943">[-]</label><label class="expand" for="c-41722943">[1 more]</label></div><br/><div class="children"><div class="content">Goetz has come a long way. I knew one of the people who contributed to that book and he was a little frustrated about having to explain things to him he felt he shouldn’t have had to. The implication was he’d already had this conversation with some of the other contributors.<p>Sometimes though, the newbie is going to write the clearest documentation.</div><br/></div></div></div></div><div id="41722925" class="c"><input type="checkbox" id="c-41722925" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41721983">parent</a><span>|</span><a href="#41722105">prev</a><span>|</span><a href="#41722236">next</a><span>|</span><label class="collapse" for="c-41722925">[-]</label><label class="expand" for="c-41722925">[2 more]</label></div><br/><div class="children"><div class="content">I loved concurrent code when I was starting out. I’d taken a pretty good distributed computing class which started the ball rolling. They just fit into how my brain worked very well.<p>Then I had to explain my code to other devs, either before or after they broke it, and over and over I got the message that I was being too clever. I’ve been writing Grug-brained concurrent code for so long I’m not sure I can still do the fancy shit anymore, but I’m okay with that. In fact I know I implemented multiple reader single writer at least a few times and that came back to me during this thread but I still can’t remember how I implemented it.</div><br/><div id="41723835" class="c"><input type="checkbox" id="c-41723835" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722925">parent</a><span>|</span><a href="#41722236">next</a><span>|</span><label class="collapse" for="c-41723835">[-]</label><label class="expand" for="c-41723835">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s something I&#x27;m afraid of for my latest project.  I did some concurrent stuff that wasn&#x27;t 100% clear would actually work, and I had to write a PlusCal spec to exhaustively prove to myself that what I was doing is actually OK.<p>It works pretty well, and I&#x27;m getting decent speeds, but I&#x27;m really scared someone is going to come and &quot;fix&quot; all my code by doing it the &quot;normal&quot; way, and thus slow everything down.  I&#x27;ve been trying to comment the hell out of everything, and I&#x27;ve shared the PlusCal spec, but no one else on my team knows PlusCal and I feel like most engineers don&#x27;t actually read comments, so I think it&#x27;s an inevitability that my baby is killed.</div><br/></div></div></div></div><div id="41722236" class="c"><input type="checkbox" id="c-41722236" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41721983">parent</a><span>|</span><a href="#41722925">prev</a><span>|</span><a href="#41722439">next</a><span>|</span><label class="collapse" for="c-41722236">[-]</label><label class="expand" for="c-41722236">[2 more]</label></div><br/><div class="children"><div class="content">Maybe because I had a complete semester of multiprogramming in the uni, I see almost trivial to work in such environments, and cannot comprehend why is so much mystic and voodo. Actually is pretty simple.</div><br/><div id="41723880" class="c"><input type="checkbox" id="c-41723880" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722236">parent</a><span>|</span><a href="#41722439">next</a><span>|</span><label class="collapse" for="c-41723880">[-]</label><label class="expand" for="c-41723880">[1 more]</label></div><br/><div class="children"><div class="content">I feel like it&#x27;s not terribly hard to write something that more or less works using mutexes and the like, but I find it exceedingly hard to debug. You&#x27;re at the mercy of timing and the scheduler, meaning that often just throwing a breakpoint and stepping through isn&#x27;t as easy as it would be with a sequential program.<p>I feel like with a queue or messaging abstraction, it can be easier to debug. Generally your actual <i>work</i> is being done on a single thread, meaning that traditional debugging tools work fine, and as I&#x27;ve said in sibling comments, I also just think it&#x27;s easier to reason about what&#x27;s going on.</div><br/></div></div></div></div></div></div><div id="41722439" class="c"><input type="checkbox" id="c-41722439" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41721868">parent</a><span>|</span><a href="#41721983">prev</a><span>|</span><a href="#41722490">next</a><span>|</span><label class="collapse" for="c-41722439">[-]</label><label class="expand" for="c-41722439">[2 more]</label></div><br/><div class="children"><div class="content">In most cases (in a C or C++ compiler, not Java) it&#x27;s just straight up incorrect to use volatile for something other than memory mapped I&#x2F;O. Yes, POSIX guarantees that in a specific case (signal handling IIRC) it&#x27;ll do what you meant if you use volatile int. That&#x27;s nice, but more generally this is not the right choice.<p>Unfortunately Microsoft enshrined the situation (on Windows, on their compiler, on x86 and x86-64 only) that volatile primitive types are effectively atomics with Acquire-Release ordering. This is of course awkward when Microsoft tries to bring people to a non-x86 architecture and it can&#x27;t just give them this because it would <i>suck</i> really hard, so finally they have to grow up and teach their developers about actual atomics.<p>!! Edited to fix: Previously this said Relaxed ordering, the ordering guaranteed by Microsoft is in fact Acquire-Release, hence it&#x27;s expensive to provide for architectures where that&#x27;s not the default.</div><br/><div id="41722974" class="c"><input type="checkbox" id="c-41722974" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722439">parent</a><span>|</span><a href="#41722490">next</a><span>|</span><label class="collapse" for="c-41722974">[-]</label><label class="expand" for="c-41722974">[1 more]</label></div><br/><div class="children"><div class="content">When Java implemented volatile it didn’t do anything. Later when they fixed the memory model to deal with out of order execution they made it part of the fence semantics, and then it actually made some sense.</div><br/></div></div></div></div><div id="41722490" class="c"><input type="checkbox" id="c-41722490" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41721868">parent</a><span>|</span><a href="#41722439">prev</a><span>|</span><a href="#41723573">next</a><span>|</span><label class="collapse" for="c-41722490">[-]</label><label class="expand" for="c-41722490">[6 more]</label></div><br/><div class="children"><div class="content">The &quot;volatile&quot; keyword should <i>never</i> be used for C&#x2F;C++ multithreaded code.  It&#x27;s specifically intended for access to device-mapped addresses and does not account for any specific memory model, so using it for multithreading will lead to breakage.  Please use the C&#x2F;C++ memory model facilities instead.<p>(As a contrast, note that in Java the &quot;volatile&quot; keyword can be used for multithreading, but again this does not apply to C&#x2F;C++.)</div><br/><div id="41723038" class="c"><input type="checkbox" id="c-41723038" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722490">parent</a><span>|</span><a href="#41722980">next</a><span>|</span><label class="collapse" for="c-41723038">[-]</label><label class="expand" for="c-41723038">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Please use the C&#x2F;C++ memory model facilities instead<p>I should point out that for more than half of my professional career, those facilities did not exist, so volatile was the most portable way of implementing e.g. a spinlock without the compiler optimizing away the check.  There was a period after which compilers were aggressively inlining and before C11 came out in which it could be otherwise quite hard to otherwise convince a compiler that a value might change.</div><br/><div id="41726164" class="c"><input type="checkbox" id="c-41726164" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41723038">parent</a><span>|</span><a href="#41722980">next</a><span>|</span><label class="collapse" for="c-41726164">[-]</label><label class="expand" for="c-41726164">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that volatile alone never portably guaranteed atomicity nor barriers, so such a spinlock would simply not work correctly on many architectures: other writes around it might be reordered in a way that make the lock useless.<p>It does kinda sorta work on x86 due its much-stronger-than-usual guarantees wrt move instructions even in the absence of explicit barriers. And because x86 was so dominant, people could get away with that for a while in &quot;portable&quot; code (which wasn&#x27;t really portable).</div><br/></div></div></div></div><div id="41722980" class="c"><input type="checkbox" id="c-41722980" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722490">parent</a><span>|</span><a href="#41723038">prev</a><span>|</span><a href="#41723573">next</a><span>|</span><label class="collapse" for="c-41722980">[-]</label><label class="expand" for="c-41722980">[3 more]</label></div><br/><div class="children"><div class="content">I’m surprised that’s true. C borrowed very heavily from Java when fixing the NUMA situations that were creeping into modern processors.</div><br/><div id="41724938" class="c"><input type="checkbox" id="c-41724938" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722980">parent</a><span>|</span><a href="#41723573">next</a><span>|</span><label class="collapse" for="c-41724938">[-]</label><label class="expand" for="c-41724938">[2 more]</label></div><br/><div class="children"><div class="content">The C&#x2F;C++ memory model is directly derived from the Java 5 memory model. However, the decision was made that volatile in C&#x2F;C++ specifically referred to memory-mapped I&#x2F;O stuff, and the extra machinery needed to effect the sequential consistency guarantees was undesirable. As a result, what is volatile in Java is _Atomic in C and std::atomic in C++.<p>C&#x2F;C++ also went further and adopted a few different notions of atomic variables, so you can choose between a sequentially-consistent atomic variable, a release&#x2F;acquire atomic variable, a release&#x2F;consume atomic variable (which ended up going unimplemented for reasons), and a fully relaxed atomic variable (whose specification turned out to be unexpectedly tortuous).</div><br/><div id="41726386" class="c"><input type="checkbox" id="c-41726386" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41724938">parent</a><span>|</span><a href="#41723573">next</a><span>|</span><label class="collapse" for="c-41726386">[-]</label><label class="expand" for="c-41726386">[1 more]</label></div><br/><div class="children"><div class="content">Importantly these aren&#x27;t <i>types</i> they&#x27;re operations.<p>So it&#x27;s not that you have a &quot;release&#x2F;acquire atomic variable&quot; but you have an atomic variable and it so happens you choose to do a Release store to that variable, in other code maybe you do a Relaxed fetch from the same variable, elsewhere you have a compare exchange with different ordering rules<p>Since we&#x27;re talking about Mutex here, here&#x27;s the entirety of Rust&#x27;s &quot;try_lock&quot; for Mutex on a Linux-like platform:<p><pre><code>        self.futex.compare_exchange(UNLOCKED, LOCKED, Acquire, Relaxed).is_ok()
</code></pre>
That&#x27;s a single atomic operation, in which we hope the futex is UNLOCKED, if it is we store LOCKED to it with Acquire ordering, but, if it wasn&#x27;t we use a Relaxed load to find out what it was instead of UNLOCKED.<p>We actually don&#x27;t do anything with that load, but the Ordering for both operations is specified here, not when the variable was typed.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41723573" class="c"><input type="checkbox" id="c-41723573" checked=""/><div class="controls bullet"><span class="by">another-acct</span><span>|</span><a href="#41721810">parent</a><span>|</span><a href="#41721868">prev</a><span>|</span><a href="#41722430">next</a><span>|</span><label class="collapse" for="c-41723573">[-]</label><label class="expand" for="c-41723573">[3 more]</label></div><br/><div class="children"><div class="content">&gt; remove locks from code and replace with some kind of queue or messaging abstraction<p>Shared-nothing message passing reflects the underlying (modern) computer architecture more closely, so I&#x27;d call the above a good move. Shared memory &#x2F; symmetric multiprocessing is an abstraction that leaks like a sieve; it no longer reflects how modern computers are built (multiple levels of CPU caches, cores, sockets, NUMA, etc).</div><br/><div id="41724743" class="c"><input type="checkbox" id="c-41724743" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41723573">parent</a><span>|</span><a href="#41723716">next</a><span>|</span><label class="collapse" for="c-41724743">[-]</label><label class="expand" for="c-41724743">[1 more]</label></div><br/><div class="children"><div class="content">If you are doing pure shared nothing message passing, you do not need coherent caches; in fact cache coherency gets in the way of pure message passing.<p>Viceversa if you do pure message passing you are not benefitting from hardware accelerated cache coherency and leaving performance (and usability) on the floor.</div><br/></div></div><div id="41723716" class="c"><input type="checkbox" id="c-41723716" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41723573">parent</a><span>|</span><a href="#41724743">prev</a><span>|</span><a href="#41722430">next</a><span>|</span><label class="collapse" for="c-41723716">[-]</label><label class="expand" for="c-41723716">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s good to hear! I am pretty removed from underlying hardware now, so it makes me happy to hear that better way of doing things is catching on even in low-level land.</div><br/></div></div></div></div><div id="41722430" class="c"><input type="checkbox" id="c-41722430" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#41721810">parent</a><span>|</span><a href="#41723573">prev</a><span>|</span><a href="#41724140">next</a><span>|</span><label class="collapse" for="c-41722430">[-]</label><label class="expand" for="c-41722430">[2 more]</label></div><br/><div class="children"><div class="content">&gt; some kind of queue or messaging abstraction<p>Agreed. I find things like LMAX Disruptor much easier to reason about.</div><br/><div id="41722733" class="c"><input type="checkbox" id="c-41722733" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722430">parent</a><span>|</span><a href="#41724140">next</a><span>|</span><label class="collapse" for="c-41722733">[-]</label><label class="expand" for="c-41722733">[1 more]</label></div><br/><div class="children"><div class="content">Even within Java, something like BlockingQueue will get you pretty far, and that&#x27;s built into the runtime.<p>If I am allowed to use libraries, I end up using Vert.x for nearly everything.  I think that their eventbus abstraction is easy enough to reason about, and even without using it simply using the non-blocking stuff it provides ends up being pretty handy.</div><br/></div></div></div></div><div id="41724140" class="c"><input type="checkbox" id="c-41724140" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#41721810">parent</a><span>|</span><a href="#41722430">prev</a><span>|</span><a href="#41722864">next</a><span>|</span><label class="collapse" for="c-41724140">[-]</label><label class="expand" for="c-41724140">[1 more]</label></div><br/><div class="children"><div class="content">Shared-nothing is typically The Right Choice in my experience as well. Maybe the odd atomic...</div><br/></div></div><div id="41722864" class="c"><input type="checkbox" id="c-41722864" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#41721810">parent</a><span>|</span><a href="#41724140">prev</a><span>|</span><a href="#41722265">next</a><span>|</span><label class="collapse" for="c-41722864">[-]</label><label class="expand" for="c-41722864">[8 more]</label></div><br/><div class="children"><div class="content">Message passing is just outsourcing the lock, right? For example a Go channel is internally synchronized, nothing magic about it.<p>Most of the mutex tragedies I have seen in my career have been in C, a useless language without effective scopes. In C++ it&#x27;s pretty easy to use a scoped lock. In fact I&#x27;d say I have had more trouble with people who are trying to avoid locks than with people who use them. The avoiders either think their program order is obviously correct (totally wrong on modern CPUs) or that their atomics are faster (wrong again on many CPUs).</div><br/><div id="41727232" class="c"><input type="checkbox" id="c-41727232" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722864">parent</a><span>|</span><a href="#41727158">prev</a><span>|</span><a href="#41723067">next</a><span>|</span><label class="collapse" for="c-41727232">[-]</label><label class="expand" for="c-41727232">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Message passing is just outsourcing the lock, right?<p>Kind of. If you can architect such that each channel has exactly 1 reader and 1 writer, you can send messages in a single direction with no locks. The basic idea is that you have a circular buffer with a start index and an end index. The writer can write an element and increment the end index (as long as end index+1&lt;start index which doesn&#x27;t have to be done atomically), while the reader can just read an element and increment the start index (as long as start index +1 &lt; end index). This strategy needs to use atomic operations (which are basically free when uncontested, which they will be as long as the queue has a few elements in it)</div><br/></div></div><div id="41723067" class="c"><input type="checkbox" id="c-41723067" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722864">parent</a><span>|</span><a href="#41727232">prev</a><span>|</span><a href="#41723712">next</a><span>|</span><label class="collapse" for="c-41723067">[-]</label><label class="expand" for="c-41723067">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s definitely doing synchronization behind the scenes, no argument here.  BlockingQueues in Java seem to use ReentrantLocks everywhere.  It&#x27;s outsourcing the lock to people who understand locks better.<p>It just abstracts this detail away for me, and I personally trust the libraries implementing these abstractions to be more correct than some ad hoc thing I write. It&#x27;s an abstraction that I personally find a lot easier to reason about, and so my thinking is this: if my reasoning is more likely to be correct because of the easier abstraction, and the internal synchronization is more likely to be correct, then it&#x27;s more likely that my code will be correct.<p>I don&#x27;t do super low-level stuff at all, most of my stuff ends up touching a network, so the small differences between the built-in synchronized structures vs the regular ones really don&#x27;t matter since any small gains I&#x27;d get on that will be eaten the first time I hit the network, so a considerably higher ROI for me is almost always figuring out how to reduce latency.<p>If I did C or C++, I&#x27;d probably have different opinions on this stuff.</div><br/></div></div><div id="41723712" class="c"><input type="checkbox" id="c-41723712" checked=""/><div class="controls bullet"><span class="by">foobazgt</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722864">parent</a><span>|</span><a href="#41723067">prev</a><span>|</span><a href="#41722963">next</a><span>|</span><label class="collapse" for="c-41723712">[-]</label><label class="expand" for="c-41723712">[1 more]</label></div><br/><div class="children"><div class="content">Every abstraction is about outsourcing the thing it&#x27;s abstracting away. If using a queue solves your problem, you no longer have to deal with all the headaches that you can run into using a bare mutex.</div><br/></div></div><div id="41722963" class="c"><input type="checkbox" id="c-41722963" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722864">parent</a><span>|</span><a href="#41723712">prev</a><span>|</span><a href="#41724187">next</a><span>|</span><label class="collapse" for="c-41722963">[-]</label><label class="expand" for="c-41722963">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Message passing is just outsourcing the lock, right?<p>More or less, yeah.  You can write an MPSC queue that doesn&#x27;t explicitly use a lock (or even anything that looks like a lock).</div><br/></div></div><div id="41724187" class="c"><input type="checkbox" id="c-41724187" checked=""/><div class="controls bullet"><span class="by">another-acct</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722864">parent</a><span>|</span><a href="#41722963">prev</a><span>|</span><a href="#41725383">next</a><span>|</span><label class="collapse" for="c-41724187">[-]</label><label class="expand" for="c-41724187">[1 more]</label></div><br/><div class="children"><div class="content">&gt; C, a useless language without effective scopes<p>Mutexes can be handled safely in C. It&#x27;s &quot;just another flavor&quot; of resource management, which does take quite a bit of discipline. Cascading error paths &#x2F; exit paths help.</div><br/></div></div><div id="41725383" class="c"><input type="checkbox" id="c-41725383" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41721810">root</a><span>|</span><a href="#41722864">parent</a><span>|</span><a href="#41724187">prev</a><span>|</span><a href="#41722265">next</a><span>|</span><label class="collapse" for="c-41725383">[-]</label><label class="expand" for="c-41725383">[1 more]</label></div><br/><div class="children"><div class="content">&gt; C, a useless language<p>You misspelled “fast as fuck” and “lingua franca of all architectures.”</div><br/></div></div></div></div></div></div><div id="41721902" class="c"><input type="checkbox" id="c-41721902" checked=""/><div class="controls bullet"><span class="by">alberth</span><span>|</span><a href="#41727466">prev</a><span>|</span><a href="#41725028">next</a><span>|</span><label class="collapse" for="c-41721902">[-]</label><label class="expand" for="c-41721902">[2 more]</label></div><br/><div class="children"><div class="content">Are there any Linux distro&#x27;s built&#x2F;using Cosmo?<p>(like Alpine use of musl)</div><br/><div id="41727101" class="c"><input type="checkbox" id="c-41727101" checked=""/><div class="controls bullet"><span class="by">gavindean90</span><span>|</span><a href="#41721902">parent</a><span>|</span><a href="#41725028">next</a><span>|</span><label class="collapse" for="c-41727101">[-]</label><label class="expand" for="c-41727101">[1 more]</label></div><br/><div class="children"><div class="content">Not yet</div><br/></div></div></div></div><div id="41725028" class="c"><input type="checkbox" id="c-41725028" checked=""/><div class="controls bullet"><span class="by">kgeist</span><span>|</span><a href="#41721902">prev</a><span>|</span><a href="#41722267">next</a><span>|</span><label class="collapse" for="c-41725028">[-]</label><label class="expand" for="c-41725028">[4 more]</label></div><br/><div class="children"><div class="content">&gt;Contention is where mutex implementations show their inequality. Mark was so impressed by Microsoft&#x27;s SRWLOCK that he went on to recommend Linux and FreeBSD users consider targeting Windows if mutex contention is an issue.<p>Interesting, I remember reading a detailed article where they found that there&#x27;s a lot of severe contention in the Windows kernel, compared to Linux. I think it was when they were trying to parallelize Chrome builds?</div><br/><div id="41726455" class="c"><input type="checkbox" id="c-41726455" checked=""/><div class="controls bullet"><span class="by">andreareina</span><span>|</span><a href="#41725028">parent</a><span>|</span><a href="#41725198">next</a><span>|</span><label class="collapse" for="c-41726455">[-]</label><label class="expand" for="c-41726455">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;randomascii.wordpress.com&#x2F;2017&#x2F;07&#x2F;09&#x2F;24-core-cpu-and-i-cant-move-my-mouse&#x2F;" rel="nofollow">https:&#x2F;&#x2F;randomascii.wordpress.com&#x2F;2017&#x2F;07&#x2F;09&#x2F;24-core-cpu-and...</a></div><br/></div></div><div id="41725198" class="c"><input type="checkbox" id="c-41725198" checked=""/><div class="controls bullet"><span class="by">TinkersW</span><span>|</span><a href="#41725028">parent</a><span>|</span><a href="#41726455">prev</a><span>|</span><a href="#41722267">next</a><span>|</span><label class="collapse" for="c-41725198">[-]</label><label class="expand" for="c-41725198">[2 more]</label></div><br/><div class="children"><div class="content">Maybe they weren&#x27;t using SRWLock, at least last time I checked std::mutex didn&#x27;t use it with MS STL(They were stuck with critical section because of binary compatibility).</div><br/><div id="41725537" class="c"><input type="checkbox" id="c-41725537" checked=""/><div class="controls bullet"><span class="by">markdoubleyou</span><span>|</span><a href="#41725028">root</a><span>|</span><a href="#41725198">parent</a><span>|</span><a href="#41722267">next</a><span>|</span><label class="collapse" for="c-41725537">[-]</label><label class="expand" for="c-41725537">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m the Mark who&#x27;s referenced there. When I did that original benchmark I discovered that the underlying mutex used by MSVCRT did change between versions. For example, in Visual C++ 2013, they used the Windows Concurrency Runtime, which was awful under heavy contention. Newer MSVCRT versions use SRWLOCK.<p>(And I wouldn&#x27;t characterize myself as being <i>overly</i> impressed... for my particular scenario I wrote, &quot;if you have a poorly written app that&#x27;s bottlenecked on a lock, then consider targeting Windows to make the best of a bad situation.&quot; A better approach, of course, would be to just improve your code!)</div><br/></div></div></div></div></div></div><div id="41722267" class="c"><input type="checkbox" id="c-41722267" checked=""/><div class="controls bullet"><span class="by">joelthelion</span><span>|</span><a href="#41725028">prev</a><span>|</span><a href="#41722040">next</a><span>|</span><label class="collapse" for="c-41722267">[-]</label><label class="expand" for="c-41722267">[2 more]</label></div><br/><div class="children"><div class="content">Could established libcs adopt this? If not, why not?</div><br/><div id="41722972" class="c"><input type="checkbox" id="c-41722972" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41722267">parent</a><span>|</span><a href="#41722040">next</a><span>|</span><label class="collapse" for="c-41722972">[-]</label><label class="expand" for="c-41722972">[1 more]</label></div><br/><div class="children"><div class="content">Maybe.  nsync is Apache licensed.</div><br/></div></div></div></div><div id="41722040" class="c"><input type="checkbox" id="c-41722040" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41722267">prev</a><span>|</span><a href="#41721790">next</a><span>|</span><label class="collapse" for="c-41722040">[-]</label><label class="expand" for="c-41722040">[19 more]</label></div><br/><div class="children"><div class="content">Hrm. Big fan of Justine and their work. However this is probably the <i>least</i> interesting benchmark test case for a Mutex. You should never have a bunch of threads constantly spamming the same mutex. So which mutex implementation best handles this case isn’t particularly interesting, imho.</div><br/><div id="41722107" class="c"><input type="checkbox" id="c-41722107" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#41722040">parent</a><span>|</span><a href="#41722402">next</a><span>|</span><label class="collapse" for="c-41722107">[-]</label><label class="expand" for="c-41722107">[2 more]</label></div><br/><div class="children"><div class="content">What do you consider a good benchmark test case for mutexes?</div><br/><div id="41722388" class="c"><input type="checkbox" id="c-41722388" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41722040">root</a><span>|</span><a href="#41722107">parent</a><span>|</span><a href="#41722402">next</a><span>|</span><label class="collapse" for="c-41722388">[-]</label><label class="expand" for="c-41722388">[1 more]</label></div><br/><div class="children"><div class="content">Very large multithreaded programs with lots of diverse uses of locks, including:<p>- uncontended, mildly contended, and horrifically contended<p>- short and long critical sections<p>- contention among small numbers of threads and large numbers of threads<p>- contention that happens when other locks are held recursively and those are also contended on (like, thread A wants a lock held by thread B, but thread B is trying to get a lock held by thread C)<p>Different lock algos work well or badly depending on how the locks are used, so it’s important to pick real programs as your benchmark rather than trying to cook a synthetic benchmark.</div><br/></div></div></div></div><div id="41722402" class="c"><input type="checkbox" id="c-41722402" checked=""/><div class="controls bullet"><span class="by">Salgat</span><span>|</span><a href="#41722040">parent</a><span>|</span><a href="#41722107">prev</a><span>|</span><a href="#41722194">next</a><span>|</span><label class="collapse" for="c-41722402">[-]</label><label class="expand" for="c-41722402">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say the vast majority of cases where I use a lock&#x2F;semaphore is around very expensive resources, where the utilization of that resource vastly outweighs any performance overhead of the lock.</div><br/><div id="41723826" class="c"><input type="checkbox" id="c-41723826" checked=""/><div class="controls bullet"><span class="by">another-acct</span><span>|</span><a href="#41722040">root</a><span>|</span><a href="#41722402">parent</a><span>|</span><a href="#41722194">next</a><span>|</span><label class="collapse" for="c-41723826">[-]</label><label class="expand" for="c-41723826">[1 more]</label></div><br/><div class="children"><div class="content">This is how it should be. IIRC -- apologies, can&#x27;t find a source --, Ulrich Drepper wrote somewhere about NPTL that its mutexes were not particularly lightweight, but that you should design your program for low contention anyways.<p>For highly contended data structures, spinlocks (and nowadays explicit atomics) are likely better.</div><br/></div></div></div></div><div id="41722194" class="c"><input type="checkbox" id="c-41722194" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#41722040">parent</a><span>|</span><a href="#41722402">prev</a><span>|</span><a href="#41722163">next</a><span>|</span><label class="collapse" for="c-41722194">[-]</label><label class="expand" for="c-41722194">[8 more]</label></div><br/><div class="children"><div class="content">&gt; You should never have a bunch of threads constantly spamming the same mutex.<p>I&#x27;m not sure I agree with this assessment.  I can think of a few cases where you might end up with a bunch of threads challenging the same mutex.<p>A simple example would be something like concurrently populating some data structure (list&#x2F;dict&#x2F;etc).  Yes, you could accomplish this with message passing, but that uses more memory and would be slower than just having everything wait to write to a shared location.</div><br/><div id="41724343" class="c"><input type="checkbox" id="c-41724343" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41722040">root</a><span>|</span><a href="#41722194">parent</a><span>|</span><a href="#41724150">next</a><span>|</span><label class="collapse" for="c-41724343">[-]</label><label class="expand" for="c-41724343">[3 more]</label></div><br/><div class="children"><div class="content">If you’re trying to mutate a dictionary many times from many threads you’re going to have a bad time. The fix isn’t a faster mutex, it’s don’t do that.</div><br/><div id="41725491" class="c"><input type="checkbox" id="c-41725491" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#41722040">root</a><span>|</span><a href="#41724343">parent</a><span>|</span><a href="#41724150">next</a><span>|</span><label class="collapse" for="c-41725491">[-]</label><label class="expand" for="c-41725491">[2 more]</label></div><br/><div class="children"><div class="content">Depends on the dictionary implementation.  There&#x27;s a number of thread safe dictionaries in the wild with varying degrees of parallelism performance.  Pretty much all of them benefit from faster mutexes.<p>For example, some thread safe dictionaries will segment their underlying key&#x2F;value pairs which allows them to have concurrent reads and writes for a given segment which significantly improves performance.</div><br/><div id="41726777" class="c"><input type="checkbox" id="c-41726777" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41722040">root</a><span>|</span><a href="#41725491">parent</a><span>|</span><a href="#41724150">next</a><span>|</span><label class="collapse" for="c-41726777">[-]</label><label class="expand" for="c-41726777">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Pretty much all of them benefit from faster mutexes.<p>Faster doesn&#x27;t mean fast. You really, really want to not use a thread-safe dictionary.</div><br/></div></div></div></div></div></div><div id="41724150" class="c"><input type="checkbox" id="c-41724150" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41722040">root</a><span>|</span><a href="#41722194">parent</a><span>|</span><a href="#41724343">prev</a><span>|</span><a href="#41722163">next</a><span>|</span><label class="collapse" for="c-41724150">[-]</label><label class="expand" for="c-41724150">[4 more]</label></div><br/><div class="children"><div class="content">&gt; would be slower than just having everything wait to write to a shared location<p>Nope.</div><br/><div id="41724307" class="c"><input type="checkbox" id="c-41724307" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#41722040">root</a><span>|</span><a href="#41724150">parent</a><span>|</span><a href="#41722163">next</a><span>|</span><label class="collapse" for="c-41724307">[-]</label><label class="expand" for="c-41724307">[3 more]</label></div><br/><div class="children"><div class="content">Yup.<p>Message passing has allocation pressure and cache consistency pressure not present in using a shared message location.  Especially as the amount of memory in question goes up, the benefit of a shared location increases in terms of the performance impact.<p>Sure, for something silly like writing to an int, there is negative benefit in a shared location, but when you start talking about a dictionary with 1 million entries, the shared location becomes much more of a benefit vs all the copying and allocating you&#x27;d have to do if you tried to do the same thing with message passing.<p>For some datastructures, it&#x27;s the optimal way to move data around.  For example, LMAX disruptor is about the fastest way to pass messages because of the shared memory and well tuned locks.</div><br/><div id="41726060" class="c"><input type="checkbox" id="c-41726060" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41722040">root</a><span>|</span><a href="#41724307">parent</a><span>|</span><a href="#41722163">next</a><span>|</span><label class="collapse" for="c-41726060">[-]</label><label class="expand" for="c-41726060">[2 more]</label></div><br/><div class="children"><div class="content">You are talking about writes to a data structure such as a list or a dictionary from multiple threads. Nobody uses advanced message passing techniques for that. A list is basically the poster child of why you avoid mutexes: each thread writes to its own version of a sublist, with no use of mutexes, and then at the end of the processing every thread&#x27;s lists are merged together. Merging a list takes O(1) time by manipulating a few pointers. You avoid mutexes and there&#x27;s zero drawback. I don&#x27;t know why you are talking about copying or allocating: a list requires no copying to be merged, and in this case all the allocations still happen over multiple threads so there&#x27;s no change in allocation pressure. If your allocator is bad, there could be internal mutexes inside the allocator, but that&#x27;s besides the point.<p>With dictionaries, you may have to do a bit of resizing and rehashing at the end. But in my benchmarks, it is still worthwhile.</div><br/><div id="41726223" class="c"><input type="checkbox" id="c-41726223" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#41722040">root</a><span>|</span><a href="#41726060">parent</a><span>|</span><a href="#41722163">next</a><span>|</span><label class="collapse" for="c-41726223">[-]</label><label class="expand" for="c-41726223">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Merging a list takes O(1) time<p>Depends on the list implementation.  I assume we are talking C++ lists? in that case yeah, I can see how you&#x27;d instead do a `splice` of sublists.<p>I was thinking more in terms of something like a `vector` in which case adding the sublists in requires copying values from one vector to the source vector.  That (especially if done wrong) can involve allocating potentially more than once to drop the results in.<p>But, for the record, there are lock free algorithms that don&#x27;t require a mutex to add values into a list.  You basically CAS the tail pointer with your new value.<p>That being said, I concede that for a list a mutex is probably the wrong choice.  It&#x27;s a better choice in Java which has constraints that prevent (easily) splicing together 2 lists.<p>For the dictionary, implementation is key.   A good segmented dictionary is going to be hard to beat.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41722163" class="c"><input type="checkbox" id="c-41722163" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#41722040">parent</a><span>|</span><a href="#41722194">prev</a><span>|</span><a href="#41721790">next</a><span>|</span><label class="collapse" for="c-41722163">[-]</label><label class="expand" for="c-41722163">[6 more]</label></div><br/><div class="children"><div class="content">what else would you measure? certainly the uncontended case is important and a baseline, but otherwise this is kind of weak point for mutexes - that if you don&#x27;t handle contention well then you have idle hardware or lots of additional scheduler work or kernel crossings.<p>[edit - I forget to even mention one of the most important things, that locks that reform poorly under contention can have really negative systemic effects like hot spotting the memory network, and that would show up here too]</div><br/><div id="41722309" class="c"><input type="checkbox" id="c-41722309" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41722040">root</a><span>|</span><a href="#41722163">parent</a><span>|</span><a href="#41721790">next</a><span>|</span><label class="collapse" for="c-41722309">[-]</label><label class="expand" for="c-41722309">[5 more]</label></div><br/><div class="children"><div class="content">Uncontended is <i>crucial</i>. If you want to benchmark other things that&#x27;s excellent, but if MutexA has crap uncontended performance then I&#x27;m on a loser if we pick MutexA unless I am absolutely sure we will have a lot of contention. Since contention is never desirable, that&#x27;s rare.<p>Think of this like the random input case for a sort benchmark. Do I want stuff like all-ascending, all-descending, zig-zag and so on? Sure, those are nice. But without the random input case the benchmark is not very helpful. I <i>might</i> sort a zig-zag, I <i>might</i> sort data that&#x27;s already in ascending order, but I <i>will</i> sort random data, that&#x27;s going to happen or else I would not need a sort function.</div><br/><div id="41722412" class="c"><input type="checkbox" id="c-41722412" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#41722040">root</a><span>|</span><a href="#41722309">parent</a><span>|</span><a href="#41721790">next</a><span>|</span><label class="collapse" for="c-41722412">[-]</label><label class="expand" for="c-41722412">[4 more]</label></div><br/><div class="children"><div class="content">Uncontended is uninteresting, because all mutex implementations perform roughly the same here, give or take a nanosecond or two. If you&#x27;re truly uncontended then a naïve spin lock will actually seem fastest, because xchg is faster than cmpxchg which is needed for good locks.</div><br/><div id="41723005" class="c"><input type="checkbox" id="c-41723005" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41722040">root</a><span>|</span><a href="#41722412">parent</a><span>|</span><a href="#41721790">next</a><span>|</span><label class="collapse" for="c-41723005">[-]</label><label class="expand" for="c-41723005">[3 more]</label></div><br/><div class="children"><div class="content">Uh, why do you say a naive spin lock would use xchg instead of cmpxchg?  I don&#x27;t think you could make a valid spinlock using xchg.</div><br/><div id="41723400" class="c"><input type="checkbox" id="c-41723400" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#41722040">root</a><span>|</span><a href="#41723005">parent</a><span>|</span><a href="#41721790">next</a><span>|</span><label class="collapse" for="c-41723400">[-]</label><label class="expand" for="c-41723400">[2 more]</label></div><br/><div class="children"><div class="content">On x86 you can. When xchg is used with a memory parameter it locks the bus. This is true even in the absence of a lock prefix. I included a spinlock implementation in the blog post. If you see any errors with it, then please let me know!</div><br/><div id="41725525" class="c"><input type="checkbox" id="c-41725525" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41722040">root</a><span>|</span><a href="#41723400">parent</a><span>|</span><a href="#41721790">next</a><span>|</span><label class="collapse" for="c-41725525">[-]</label><label class="expand" for="c-41725525">[1 more]</label></div><br/><div class="children"><div class="content">Oh, sure, your 1-bit spinlock with no other state works.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41721790" class="c"><input type="checkbox" id="c-41721790" checked=""/><div class="controls bullet"><span class="by">rnrn</span><span>|</span><a href="#41722040">prev</a><span>|</span><a href="#41722754">next</a><span>|</span><label class="collapse" for="c-41721790">[-]</label><label class="expand" for="c-41721790">[7 more]</label></div><br/><div class="children"><div class="content">is comsmopolitan’s mutex also less fair than the other implementations compared?</div><br/><div id="41721893" class="c"><input type="checkbox" id="c-41721893" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#41721790">parent</a><span>|</span><a href="#41722348">next</a><span>|</span><label class="collapse" for="c-41721893">[-]</label><label class="expand" for="c-41721893">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not fair, but (from the description) it does make some effort to be fairish.  It&#x27;ll queue up waiters in a linked list that is fairly fair, but new people can jump ahead of the line and grab the CAS before the list is processed.<p>However, it has added logic to start chunking through the queue after 30 wakeups from a waiter.  With that, waiting isn&#x27;t indefinite, but it also isn&#x27;t fair.<p>I have no idea how that compares to other implementation&#x27;s fairness.  I know the JDK recently abandoned fairness because of the overhead and complexity it added around mutex handling.</div><br/><div id="41722170" class="c"><input type="checkbox" id="c-41722170" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41721790">root</a><span>|</span><a href="#41721893">parent</a><span>|</span><a href="#41722348">next</a><span>|</span><label class="collapse" for="c-41722170">[-]</label><label class="expand" for="c-41722170">[3 more]</label></div><br/><div class="children"><div class="content">Fairness is known to cause serious problems such as convoys, so while &quot;unfair&quot; isn&#x27;t itself a desirable property, you might choose to be unfair because the alternatives are worse for some applications.<p>Probably a specifically Fair version of any concurrent primitive which can be fair is worth giving a distinct name, the way you&#x27;d offer both a <i>stable</i> and an <i>unstable</i> sort, knowing that the unstable sort will often (though not always) be faster but some people cannot tolerate an unstable sort so it&#x27;s useless for them.<p>On the other hand, maybe it&#x27;s an attractive nuisance and if you offered this you&#x27;d find most users took your FairMutex, and then were angry because of the inevitable problems from fairness, even though the unfair one was right there...</div><br/><div id="41722868" class="c"><input type="checkbox" id="c-41722868" checked=""/><div class="controls bullet"><span class="by">greiskul</span><span>|</span><a href="#41721790">root</a><span>|</span><a href="#41722170">parent</a><span>|</span><a href="#41722348">next</a><span>|</span><label class="collapse" for="c-41722868">[-]</label><label class="expand" for="c-41722868">[2 more]</label></div><br/><div class="children"><div class="content">In a lot of cases, programmers don&#x27;t even care about fairness, but do care about starvation. Is there a word for structures like the one discussed here, that are unfair but appear to prevent unlimited starvation?</div><br/><div id="41723740" class="c"><input type="checkbox" id="c-41723740" checked=""/><div class="controls bullet"><span class="by">DSMan195276</span><span>|</span><a href="#41721790">root</a><span>|</span><a href="#41722868">parent</a><span>|</span><a href="#41722348">next</a><span>|</span><label class="collapse" for="c-41723740">[-]</label><label class="expand" for="c-41723740">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think this lock is _guaranteed_ to prevent starvation, it just makes an effort at it. There&#x27;s only two priority levels and a hard-coded 30 wake-ups required to enter high priority - if waiters were continually joining then there could always be more than one entry in high priority and an entry could get stuck there forever. Typically it won&#x27;t matter, but if you have high contention then this might not be good enough.</div><br/></div></div></div></div></div></div></div></div><div id="41722348" class="c"><input type="checkbox" id="c-41722348" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41721790">parent</a><span>|</span><a href="#41721893">prev</a><span>|</span><a href="#41727832">next</a><span>|</span><label class="collapse" for="c-41722348">[-]</label><label class="expand" for="c-41722348">[1 more]</label></div><br/><div class="children"><div class="content">Most fast locks these days are unfair. It turns out the perf advantage of unfairness is so massive that it’s just Better (TM).</div><br/></div></div><div id="41727832" class="c"><input type="checkbox" id="c-41727832" checked=""/><div class="controls bullet"><span class="by">worstspotgain</span><span>|</span><a href="#41721790">parent</a><span>|</span><a href="#41722348">prev</a><span>|</span><a href="#41722754">next</a><span>|</span><label class="collapse" for="c-41727832">[-]</label><label class="expand" for="c-41727832">[1 more]</label></div><br/><div class="children"><div class="content">All primitive performance evaluations should be multidimensional, IMO, with fairness being one of the highest-priority variables.<p>The importance of fairness varies with the algorithm. For instance, one that alternates between being CPU-bound and disk-bound may use N_workers &gt;&gt;&gt; N_cores. These workers might not care about individual starvation at all.<p>At the other end, consider a strictly CPU-bound algorithm with N_workers==N_cores, and a rogue-ish worker that ends up hogging an important mutex by spinning around it (e.g. the one written by author of the benchmark.) If the other well-behaved workers briefly lock the mutex once prior to each job, but end up getting woken up only once every 30 locks (as this implementation apparently does,) you might end up with core utilization &lt;&lt;&lt; 100%.<p>This in turn means that APIs that let you customize the behavior can win out even if they&#x27;re not #1 on any benchmark.</div><br/></div></div></div></div><div id="41722754" class="c"><input type="checkbox" id="c-41722754" checked=""/><div class="controls bullet"><span class="by">wallstprog</span><span>|</span><a href="#41721790">prev</a><span>|</span><a href="#41722624">next</a><span>|</span><label class="collapse" for="c-41722754">[-]</label><label class="expand" for="c-41722754">[5 more]</label></div><br/><div class="children"><div class="content">&quot; I also managed to make contended nsync mutexes go 30% faster than nsync upstream on AARCH64, by porting it to use C11 atomics.&quot;<p>Curious about this -- so what does C11 atomics use to implement?  At least in Linux, C++11 atomics <i>use</i> pthreads (not the other way around).</div><br/><div id="41723335" class="c"><input type="checkbox" id="c-41723335" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#41722754">parent</a><span>|</span><a href="#41722778">next</a><span>|</span><label class="collapse" for="c-41723335">[-]</label><label class="expand" for="c-41723335">[1 more]</label></div><br/><div class="children"><div class="content">nsync has wrapper macros for all the various atomics libraries that prevented it from using two things.<p>1. Weak CAS. nsync always uses strong CAS upstream to make the portability abstraction simpler. Being able to use weak CAS when appropriate helps avoid code being generated for an additional loop.<p>2. Updating the &amp;expected parameter. nsync upstream always manually does another relaxed load when a CAS fails. This isn&#x27;t necessary with the C11 atomics API, because it gives you a relaxed load of the expected value for free when it fails.<p>Being able to exploit those two features resulted in a considerable improvement in nsync&#x27;s mu_test.c benchmark for the contended mutex case, which I measured on RPI5.</div><br/></div></div><div id="41722778" class="c"><input type="checkbox" id="c-41722778" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#41722754">parent</a><span>|</span><a href="#41723335">prev</a><span>|</span><a href="#41722923">next</a><span>|</span><label class="collapse" for="c-41722778">[-]</label><label class="expand" for="c-41722778">[1 more]</label></div><br/><div class="children"><div class="content">It depends on what atomics. In principle most of them should map to an underlying CPU primitive, and only fallback to a mutex if it&#x27;s not supported on the platform.</div><br/></div></div><div id="41722923" class="c"><input type="checkbox" id="c-41722923" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41722754">parent</a><span>|</span><a href="#41722778">prev</a><span>|</span><a href="#41723151">next</a><span>|</span><label class="collapse" for="c-41722923">[-]</label><label class="expand" for="c-41722923">[1 more]</label></div><br/><div class="children"><div class="content">Atomics mostly map to underlying compiler &#x2F; CPU intrinsics, not pthreads.</div><br/></div></div><div id="41723151" class="c"><input type="checkbox" id="c-41723151" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#41722754">parent</a><span>|</span><a href="#41722923">prev</a><span>|</span><a href="#41722624">next</a><span>|</span><label class="collapse" for="c-41723151">[-]</label><label class="expand" for="c-41723151">[1 more]</label></div><br/><div class="children"><div class="content">I am also curious about this and the ambiguity of &quot;AARCH64&quot;. There are 64-bit ARM ISA versions without atomic primitives and on these what looks like an atomic op is actually a library retry loop with potentially unbounded runtime. The original AWS Graviton CPU had this behavior. The version of the ISA that you target can have significant performance impact.</div><br/></div></div></div></div><div id="41722624" class="c"><input type="checkbox" id="c-41722624" checked=""/><div class="controls bullet"><span class="by">stonethrowaway</span><span>|</span><a href="#41722754">prev</a><span>|</span><a href="#41726576">next</a><span>|</span><label class="collapse" for="c-41722624">[-]</label><label class="expand" for="c-41722624">[3 more]</label></div><br/><div class="children"><div class="content">&gt; In 2012, Tunney started working for Google as a software engineer.[4] In March 2014, Tunney petitioned the US government on We the People to hold a referendum asking for support to retire all government employees with full pensions, transfer administrative authority to the technology industry, and appoint the executive chairman of Google Eric Schmidt as CEO of America.<p>the absolute madman</div><br/><div id="41723604" class="c"><input type="checkbox" id="c-41723604" checked=""/><div class="controls bullet"><span class="by">Dansvidania</span><span>|</span><a href="#41722624">parent</a><span>|</span><a href="#41725364">next</a><span>|</span><label class="collapse" for="c-41723604">[-]</label><label class="expand" for="c-41723604">[1 more]</label></div><br/><div class="children"><div class="content">I wonder what they (Tunney) think of that now.</div><br/></div></div><div id="41725364" class="c"><input type="checkbox" id="c-41725364" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#41722624">parent</a><span>|</span><a href="#41723604">prev</a><span>|</span><a href="#41726576">next</a><span>|</span><label class="collapse" for="c-41725364">[-]</label><label class="expand" for="c-41725364">[1 more]</label></div><br/><div class="children"><div class="content">Wild. Then again, in 2012 I was on a grippy sock vacation.</div><br/></div></div></div></div><div id="41726576" class="c"><input type="checkbox" id="c-41726576" checked=""/><div class="controls bullet"><span class="by">Akhilmurali</span><span>|</span><a href="#41722624">prev</a><span>|</span><a href="#41727969">next</a><span>|</span><label class="collapse" for="c-41726576">[-]</label><label class="expand" for="c-41726576">[1 more]</label></div><br/><div class="children"><div class="content">Just curious how the wall time is lesser than the sum of system time and user time?</div><br/></div></div><div id="41727969" class="c"><input type="checkbox" id="c-41727969" checked=""/><div class="controls bullet"><span class="by">FooBarWidget</span><span>|</span><a href="#41726576">prev</a><span>|</span><a href="#41724653">next</a><span>|</span><label class="collapse" for="c-41727969">[-]</label><label class="expand" for="c-41727969">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get it. Aren&#x27;t most of these nsync tricks also implemented in glibc mutexes? The only thing in that list that&#x27;s new to me, is long waiting. But even then I don&#x27;t get it: futexes are already supposed to handle contended waiting.</div><br/></div></div><div id="41724653" class="c"><input type="checkbox" id="c-41724653" checked=""/><div class="controls bullet"><span class="by">betimsl</span><span>|</span><a href="#41727969">prev</a><span>|</span><a href="#41722455">next</a><span>|</span><label class="collapse" for="c-41724653">[-]</label><label class="expand" for="c-41724653">[4 more]</label></div><br/><div class="children"><div class="content">And here I thought musl was better than libc <i>sigh</i></div><br/><div id="41724929" class="c"><input type="checkbox" id="c-41724929" checked=""/><div class="controls bullet"><span class="by">favorited</span><span>|</span><a href="#41724653">parent</a><span>|</span><a href="#41722455">next</a><span>|</span><label class="collapse" for="c-41724929">[-]</label><label class="expand" for="c-41724929">[3 more]</label></div><br/><div class="children"><div class="content">musl <i>is</i> a libc, and while it is superior in some ways, it is inferior in others.  If you want a statically linked libc, or a permissively licensed libc, musl is a fantastic choice.  If you want a libc with the fastest malloc implementation, you&#x27;ll probably want to look elsewhere.</div><br/><div id="41726294" class="c"><input type="checkbox" id="c-41726294" checked=""/><div class="controls bullet"><span class="by">EasyMark</span><span>|</span><a href="#41724653">root</a><span>|</span><a href="#41724929">parent</a><span>|</span><a href="#41722455">next</a><span>|</span><label class="collapse" for="c-41726294">[-]</label><label class="expand" for="c-41726294">[2 more]</label></div><br/><div class="children"><div class="content">Can’t you sub in your own malloc like the one in the article or jemalloc if you don’t like the performance of the original in your app?</div><br/><div id="41726997" class="c"><input type="checkbox" id="c-41726997" checked=""/><div class="controls bullet"><span class="by">favorited</span><span>|</span><a href="#41724653">root</a><span>|</span><a href="#41726294">parent</a><span>|</span><a href="#41722455">next</a><span>|</span><label class="collapse" for="c-41726997">[-]</label><label class="expand" for="c-41726997">[1 more]</label></div><br/><div class="children"><div class="content">Sure, and lots of projects do.  I was just trying to make the point that there isn&#x27;t one &quot;good&quot; libc that is universally better – each project has costs and benefits that are tied to its priorities.</div><br/></div></div></div></div></div></div></div></div><div id="41722455" class="c"><input type="checkbox" id="c-41722455" checked=""/><div class="controls bullet"><span class="by">gok</span><span>|</span><a href="#41724653">prev</a><span>|</span><a href="#41722857">next</a><span>|</span><label class="collapse" for="c-41722455">[-]</label><label class="expand" for="c-41722455">[2 more]</label></div><br/><div class="children"><div class="content">Consider adopting `os_sync_wait_on_address()` on Darwin for your futex needs</div><br/><div id="41722831" class="c"><input type="checkbox" id="c-41722831" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#41722455">parent</a><span>|</span><a href="#41722857">next</a><span>|</span><label class="collapse" for="c-41722831">[-]</label><label class="expand" for="c-41722831">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used that. It&#x27;s just as good as ulock although relatively new. The issue is that using this API makes cancelation points no longer atomic. SIGTHR needs to be able to know the exact instruction in memory where an asynchronous signal is delivered when interrupting a wait operation and that&#x27;s not possible if it&#x27;s inside an opaque library.</div><br/></div></div></div></div><div id="41722857" class="c"><input type="checkbox" id="c-41722857" checked=""/><div class="controls bullet"><span class="by">bjourne</span><span>|</span><a href="#41722455">prev</a><span>|</span><a href="#41726444">next</a><span>|</span><label class="collapse" for="c-41722857">[-]</label><label class="expand" for="c-41722857">[2 more]</label></div><br/><div class="children"><div class="content">I made a benchmark on this last year when I didn&#x27;t know how slow pthread mutexes were: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;76965112&#x2F;why-are-pthread-spinlocks-so-much-faster-than-mutexes" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;76965112&#x2F;why-are-pthread...</a> For my use case, the mutex wait amounted to roughly 40% of the total runtime and spinlocks were way faster. Perhaps nsync or Cosmopolitan would have made my code much faster.<p>I still believe the FUD around spinlocks is overstated. For &quot;normal&quot; hpc code the number of threads should be &lt;= the number of cores. In that scenario spinlocking will minimize the latency which likely is what you care about the most. It beats having your performance ruined by dvfs.</div><br/><div id="41728604" class="c"><input type="checkbox" id="c-41728604" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#41722857">parent</a><span>|</span><a href="#41726444">next</a><span>|</span><label class="collapse" for="c-41728604">[-]</label><label class="expand" for="c-41728604">[1 more]</label></div><br/><div class="children"><div class="content">If I&#x27;m understanding correctly, you measure pthread_lock as having about twice the overhead of a spin lock. As discussed elsethread, this is expected on x86 as a spinlock only needs an expensive CAS on lock and a cheap store on unlock, while a pthread_lock needs a CAS on both lock and unlock.</div><br/></div></div></div></div><div id="41726444" class="c"><input type="checkbox" id="c-41726444" checked=""/><div class="controls bullet"><span class="by">flymasterv</span><span>|</span><a href="#41722857">prev</a><span>|</span><a href="#41727314">next</a><span>|</span><label class="collapse" for="c-41726444">[-]</label><label class="expand" for="c-41726444">[1 more]</label></div><br/><div class="children"><div class="content">Mutices.</div><br/></div></div><div id="41727314" class="c"><input type="checkbox" id="c-41727314" checked=""/><div class="controls bullet"><span class="by">scudsworth</span><span>|</span><a href="#41726444">prev</a><span>|</span><a href="#41721986">next</a><span>|</span><label class="collapse" for="c-41727314">[-]</label><label class="expand" for="c-41727314">[1 more]</label></div><br/><div class="children"><div class="content">is it weird to compare a 96 and 24 core threadripper? i didn&#x27;t see anything about spawning more threads to make up for the additional cores or anything like that..</div><br/></div></div></div></div></div></div></div></body></html>