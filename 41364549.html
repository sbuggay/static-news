<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724749263960" as="style"/><link rel="stylesheet" href="styles.css?v=1724749263960"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://box86.org/2024/08/box64-and-risc-v-in-2024/">Box64 and RISC-V in 2024: What It Takes to Run the Witcher 3 on RISC-V</a> <span class="domain">(<a href="https://box86.org">box86.org</a>)</span></div><div class="subtext"><span>pabs3</span> | <span>24 comments</span></div><br/><div><div id="41365540" class="c"><input type="checkbox" id="c-41365540" checked=""/><div class="controls bullet"><span class="by">Manfred</span><span>|</span><a href="#41365606">next</a><span>|</span><label class="collapse" for="c-41365540">[-]</label><label class="expand" for="c-41365540">[4 more]</label></div><br/><div class="children"><div class="content">&gt; At least in the context of x86 emulation, among all 3 architectures we support, RISC-V is the least expressive one.<p>RISC was explained to me as a reduced instruction set computer in computer science history classes, but I see a lot of articles and proposed new RISC-V profiles about &quot;we just need a few more instructions to get feature parity&quot;.<p>I understand that RISC-V is just a convenient alternative to other platforms for most people, but does this also mean the RISC dream is dead?</div><br/><div id="41365644" class="c"><input type="checkbox" id="c-41365644" checked=""/><div class="controls bullet"><span class="by">ahartmetz</span><span>|</span><a href="#41365540">parent</a><span>|</span><a href="#41365583">next</a><span>|</span><label class="collapse" for="c-41365644">[-]</label><label class="expand" for="c-41365644">[1 more]</label></div><br/><div class="children"><div class="content">The explanation that I&#x27;ve seen is that it&#x27;s &quot;(reduced instruction) set computer&quot; - simple instructions, not necessarily few.</div><br/></div></div><div id="41365583" class="c"><input type="checkbox" id="c-41365583" checked=""/><div class="controls bullet"><span class="by">flanked-evergl</span><span>|</span><a href="#41365540">parent</a><span>|</span><a href="#41365644">prev</a><span>|</span><a href="#41365606">next</a><span>|</span><label class="collapse" for="c-41365583">[-]</label><label class="expand" for="c-41365583">[2 more]</label></div><br/><div class="children"><div class="content">Is there a RISC dream? I think there is an efficiency &quot;dream&quot;, there is a performance &quot;dream&quot;, there is a cost &quot;dream&quot; — there are even low-complexity relative to cost, performance and efficiency &quot;dreams&quot; — but a RISC dream? Who cares more about RISC than cost, performance, efficiency and simplicity?</div><br/><div id="41365643" class="c"><input type="checkbox" id="c-41365643" checked=""/><div class="controls bullet"><span class="by">impossiblefork</span><span>|</span><a href="#41365540">root</a><span>|</span><a href="#41365583">parent</a><span>|</span><a href="#41365606">next</a><span>|</span><label class="collapse" for="c-41365643">[-]</label><label class="expand" for="c-41365643">[1 more]</label></div><br/><div class="children"><div class="content">But we define the RISC dream as a dream that efficiency, performance and low-cost could be achieved by cores with very small instruction sets?</div><br/></div></div></div></div></div></div><div id="41365606" class="c"><input type="checkbox" id="c-41365606" checked=""/><div class="controls bullet"><span class="by">theragra</span><span>|</span><a href="#41365540">prev</a><span>|</span><a href="#41364855">next</a><span>|</span><label class="collapse" for="c-41365606">[-]</label><label class="expand" for="c-41365606">[1 more]</label></div><br/><div class="children"><div class="content">Reminded me how one famous Russian guy ran Atomic Heart on Elbrus 8S.<p>Elbrus has native translator, though, and pretty good one, afaik. Atomic Heart was kinda playable, 15-25 fps.</div><br/></div></div><div id="41364855" class="c"><input type="checkbox" id="c-41364855" checked=""/><div class="controls bullet"><span class="by">littlecranky67</span><span>|</span><a href="#41365606">prev</a><span>|</span><a href="#41364782">next</a><span>|</span><label class="collapse" for="c-41364855">[-]</label><label class="expand" for="c-41364855">[2 more]</label></div><br/><div class="children"><div class="content">Article is a bit short on &quot;the basics&quot; - I assumed they used some kind of wine port to run it. But it seems they implemented the x86_64 ISA on a RISC-V chip in some way - anyone can shed more light on that part how that is done?</div><br/><div id="41364880" class="c"><input type="checkbox" id="c-41364880" checked=""/><div class="controls bullet"><span class="by">anewhnaccount2</span><span>|</span><a href="#41364855">parent</a><span>|</span><a href="#41364782">next</a><span>|</span><label class="collapse" for="c-41364880">[-]</label><label class="expand" for="c-41364880">[1 more]</label></div><br/><div class="children"><div class="content">The basics are here: <a href="https:&#x2F;&#x2F;box86.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;box86.org&#x2F;</a> It is an emulator but:<p>&gt; Because box86 uses the native versions of some “system” libraries, like libc, libm, SDL, and OpenGL, it’s easy to integrate and use with most applications, and performance can be surprisingly high in some cases.<p>Wine can also be compiled&#x2F;run as native.</div><br/></div></div></div></div><div id="41364782" class="c"><input type="checkbox" id="c-41364782" checked=""/><div class="controls bullet"><span class="by">brandonpelfrey</span><span>|</span><a href="#41364855">prev</a><span>|</span><a href="#41364945">next</a><span>|</span><label class="collapse" for="c-41364782">[-]</label><label class="expand" for="c-41364782">[1 more]</label></div><br/><div class="children"><div class="content">Incredible result! This is a tremendous amount of work and does seem like RV is at its limits in some of these cases. The bit gather and scatter instructions should become an extension!</div><br/></div></div><div id="41364945" class="c"><input type="checkbox" id="c-41364945" checked=""/><div class="controls bullet"><span class="by">int0x29</span><span>|</span><a href="#41364782">prev</a><span>|</span><a href="#41365605">next</a><span>|</span><label class="collapse" for="c-41364945">[-]</label><label class="expand" for="c-41364945">[4 more]</label></div><br/><div class="children"><div class="content">That screenshot shows 31 gb of ram which is distinctly more than the mentioned dev board at max specs.  Are they using something else here?</div><br/><div id="41365075" class="c"><input type="checkbox" id="c-41365075" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#41364945">parent</a><span>|</span><a href="#41365301">next</a><span>|</span><label class="collapse" for="c-41365075">[-]</label><label class="expand" for="c-41365075">[1 more]</label></div><br/><div class="children"><div class="content">Pioneer, an older board.<p>Note that, today, one of the recent options with several, faster cores implementing RVA22 and RVV 1.0 is the better idea.</div><br/></div></div><div id="41365301" class="c"><input type="checkbox" id="c-41365301" checked=""/><div class="controls bullet"><span class="by">ptitSeb</span><span>|</span><a href="#41364945">parent</a><span>|</span><a href="#41365075">prev</a><span>|</span><a href="#41364985">next</a><span>|</span><label class="collapse" for="c-41365301">[-]</label><label class="expand" for="c-41365301">[1 more]</label></div><br/><div class="children"><div class="content">The milk-v pioneer comes with 128GB of RAM.</div><br/></div></div><div id="41364985" class="c"><input type="checkbox" id="c-41364985" checked=""/><div class="controls bullet"><span class="by">pengaru</span><span>|</span><a href="#41364945">parent</a><span>|</span><a href="#41365301">prev</a><span>|</span><a href="#41365605">next</a><span>|</span><label class="collapse" for="c-41364985">[-]</label><label class="expand" for="c-41364985">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;milkv.io&#x2F;pioneer" rel="nofollow">https:&#x2F;&#x2F;milkv.io&#x2F;pioneer</a></div><br/></div></div></div></div><div id="41365605" class="c"><input type="checkbox" id="c-41365605" checked=""/><div class="controls bullet"><span class="by">lyu07282</span><span>|</span><a href="#41364945">prev</a><span>|</span><a href="#41365270">next</a><span>|</span><label class="collapse" for="c-41365605">[-]</label><label class="expand" for="c-41365605">[1 more]</label></div><br/><div class="children"><div class="content">Another technically impressive Witcher 3 feat was the Switch port, it ran really well. Goes to show how much can be done with optimization and how much resources are wasted on the PC purely by bad optimization.</div><br/></div></div><div id="41365270" class="c"><input type="checkbox" id="c-41365270" checked=""/><div class="controls bullet"><span class="by">victor_cl</span><span>|</span><a href="#41365605">prev</a><span>|</span><a href="#41364800">next</a><span>|</span><label class="collapse" for="c-41365270">[-]</label><label class="expand" for="c-41365270">[2 more]</label></div><br/><div class="children"><div class="content">I remember learning RISC-V in Berkeley CS61C. Anyone from Berkeley？</div><br/><div id="41365330" class="c"><input type="checkbox" id="c-41365330" checked=""/><div class="controls bullet"><span class="by">jychang</span><span>|</span><a href="#41365270">parent</a><span>|</span><a href="#41364800">next</a><span>|</span><label class="collapse" for="c-41365330">[-]</label><label class="expand" for="c-41365330">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s nobody from Berkeley on HN</div><br/></div></div></div></div><div id="41364800" class="c"><input type="checkbox" id="c-41364800" checked=""/><div class="controls bullet"><span class="by">justahuman74</span><span>|</span><a href="#41365270">prev</a><span>|</span><label class="collapse" for="c-41364800">[-]</label><label class="expand" for="c-41364800">[8 more]</label></div><br/><div class="children"><div class="content">I hope they&#x27;re able to get this ISA-level feedback to people at RVI</div><br/><div id="41364904" class="c"><input type="checkbox" id="c-41364904" checked=""/><div class="controls bullet"><span class="by">camel-cdr</span><span>|</span><a href="#41364800">parent</a><span>|</span><a href="#41364827">next</a><span>|</span><label class="collapse" for="c-41364904">[-]</label><label class="expand" for="c-41364904">[2 more]</label></div><br/><div class="children"><div class="content">The scalar efficiency SIG has already been discussing bitfield insert and extract instructions.<p>We figured out yesterday [1], that the example in the article can already be done in four risc-v instructions, it&#x27;s just a bit trickier to come up with it:<p><pre><code>    # a0 = rax, a1 = rbx
    slli t0, a1, 64-8
    rori a0, a0, 16
    add a0, a0, t0
    rori a0, a0, 64-16
</code></pre>
[1] <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;RISCV&#x2F;comments&#x2F;1f1mnxf&#x2F;box64_and_riscv_in_2024&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;RISCV&#x2F;comments&#x2F;1f1mnxf&#x2F;box64_and_ri...</a></div><br/><div id="41365275" class="c"><input type="checkbox" id="c-41365275" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#41364800">root</a><span>|</span><a href="#41364904">parent</a><span>|</span><a href="#41364827">next</a><span>|</span><label class="collapse" for="c-41365275">[-]</label><label class="expand" for="c-41365275">[1 more]</label></div><br/><div class="children"><div class="content">Nice trick, in fact with 4 instructions it&#x27;s as efficient as extract&#x2F;insert and it works for all ADD&#x2F;SUB&#x2F;OR&#x2F;XOR&#x2F;CMP instructions (not for AND), except if the source is a high-byte register. However it&#x27;s not really a problem if code generation is not great in this case: compilers in practice will not generate accesses to these registers, and while old 16-bit assembly code has lots of such accesses it&#x27;s designed to run on processors that ran at 4-20 MHz.<p>Flag computation and conditional jumps is where the big optimization opportunities lie. Box64 uses a multi-pass decoder that computes liveness information for flags and then computes flags one by one. QEMU instead tries to store the original operands and computes flags lazily. Both approaches have advantages and disadvantages...</div><br/></div></div></div></div><div id="41364827" class="c"><input type="checkbox" id="c-41364827" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#41364800">parent</a><span>|</span><a href="#41364904">prev</a><span>|</span><label class="collapse" for="c-41364827">[-]</label><label class="expand" for="c-41364827">[5 more]</label></div><br/><div class="children"><div class="content">None of this is new. None of it.<p>In fact, bitfield extract is such an obvious oversight that it is my favourite example of how idiotic the RISCV ISA is (#2 is lack of sane addressing modes).<p>Some of the better RISCV designs, in fact, implement a custom instr to do this, eg: BEXTM in Hazard3: <a href="https:&#x2F;&#x2F;github.com&#x2F;Wren6991&#x2F;Hazard3&#x2F;blob&#x2F;stable&#x2F;doc&#x2F;hazard3.pdf">https:&#x2F;&#x2F;github.com&#x2F;Wren6991&#x2F;Hazard3&#x2F;blob&#x2F;stable&#x2F;doc&#x2F;hazard3....</a></div><br/><div id="41364944" class="c"><input type="checkbox" id="c-41364944" checked=""/><div class="controls bullet"><span class="by">renox</span><span>|</span><a href="#41364800">root</a><span>|</span><a href="#41364827">parent</a><span>|</span><label class="collapse" for="c-41364944">[-]</label><label class="expand" for="c-41364944">[4 more]</label></div><br/><div class="children"><div class="content">Whoa, someone else who doesn&#x27;t believe that the RISC-V ISA is &#x27;perfect&#x27;!
I&#x27;m curious: how the discussions on the bitfield extract have been going? Because it does really seem like an obvious oversight and something to add as a &#x27;standard  extension&#x27;.<p>What&#x27;s your take on<p>1) unaligned 32bit instructions with the C extension?<p>2) lack of &#x27;trap on overflow&#x27; for arithmetic instructions?
MIPS had it..</div><br/><div id="41365621" class="c"><input type="checkbox" id="c-41365621" checked=""/><div class="controls bullet"><span class="by">newpavlov</span><span>|</span><a href="#41364800">root</a><span>|</span><a href="#41364944">parent</a><span>|</span><a href="#41364991">next</a><span>|</span><label class="collapse" for="c-41365621">[-]</label><label class="expand" for="c-41365621">[1 more]</label></div><br/><div class="children"><div class="content">The handling of misaligned loads&#x2F;stores in RISC-V is also can be considered a disappointing point: <a href="https:&#x2F;&#x2F;github.com&#x2F;riscv&#x2F;riscv-isa-manual&#x2F;issues&#x2F;1611">https:&#x2F;&#x2F;github.com&#x2F;riscv&#x2F;riscv-isa-manual&#x2F;issues&#x2F;1611</a> It oozes with preferring convenience of hardware developers and &quot;flexibility&quot; over making practical guarantees needed by software developers. It looks like the MIPS patent on misaligned load&#x2F;store instructions has played its negative role. The patent expired in 2019, but it seems we are stuck with the current status quo nevertheless.</div><br/></div></div><div id="41364991" class="c"><input type="checkbox" id="c-41364991" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#41364800">root</a><span>|</span><a href="#41364944">parent</a><span>|</span><a href="#41365621">prev</a><span>|</span><label class="collapse" for="c-41364991">[-]</label><label class="expand" for="c-41364991">[2 more]</label></div><br/><div class="children"><div class="content">1. aarch64 does this right. RISCV tries to be too many things at once, and predictably ends up sucking at everything. Fast big cores should just stick to fixed size instrs for faster decode. You always know where instrs start, and every cacheline has an integer number of instrs. microcontroler cores can use compressed intrs, since it matters there, while trying to parallel-codec instrs does not matter there. Trying to have one arch cover it all is idiotic.<p>2. nobody uses it on mips either, so it is likely of no use.</div><br/><div id="41365378" class="c"><input type="checkbox" id="c-41365378" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#41364800">root</a><span>|</span><a href="#41364991">parent</a><span>|</span><label class="collapse" for="c-41365378">[-]</label><label class="expand" for="c-41365378">[1 more]</label></div><br/><div class="children"><div class="content">Fixed size instructions are not absolutely necessary, but keeping them naturally aligned is just better even if that means using C instructions a bit less often. It&#x27;s especially messy that 32-bit instructions can span a page.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>