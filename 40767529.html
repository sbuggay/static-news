<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719219674315" as="style"/><link rel="stylesheet" href="styles.css?v=1719219674315"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://arxiv.org/abs/2406.09649">SquirrelFS: Using the Rust compiler to check file-system crash consistency</a> <span class="domain">(<a href="https://arxiv.org">arxiv.org</a>)</span></div><div class="subtext"><span>belter</span> | <span>11 comments</span></div><br/><div><div id="40770268" class="c"><input type="checkbox" id="c-40770268" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#40771459">next</a><span>|</span><label class="collapse" for="c-40770268">[-]</label><label class="expand" for="c-40770268">[4 more]</label></div><br/><div class="children"><div class="content">Does this have a practical use?  It&#x27;s definitely a novel application of a property of Rust.  It&#x27;s also been my impression filesystem consistency is largely a solved problem thanks to write-ahead logs (WAL) and the like.<p>It&#x27;s nice the authors included a link to the underlying source code in the last paragraph:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;utsaslab&#x2F;squirrelfs">https:&#x2F;&#x2F;github.com&#x2F;utsaslab&#x2F;squirrelfs</a></div><br/><div id="40770434" class="c"><input type="checkbox" id="c-40770434" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40770268">parent</a><span>|</span><a href="#40771707">next</a><span>|</span><label class="collapse" for="c-40770434">[-]</label><label class="expand" for="c-40770434">[1 more]</label></div><br/><div class="children"><div class="content">There’s a pretty big difference between leveraging the compiler to do a formal proof of the codebase on your behalf vs runtime tests to make sure your WAL is maintaining the invariants you expect it to have.</div><br/></div></div><div id="40771707" class="c"><input type="checkbox" id="c-40771707" checked=""/><div class="controls bullet"><span class="by">jmartin2683</span><span>|</span><a href="#40770268">parent</a><span>|</span><a href="#40770434">prev</a><span>|</span><a href="#40770895">next</a><span>|</span><label class="collapse" for="c-40771707">[-]</label><label class="expand" for="c-40771707">[1 more]</label></div><br/><div class="children"><div class="content">The idea of typestate programming and how it allows you to model all of the valid states and transitions between them is definitely useful in a lot of contexts.  if you’ve ever had to call some init() method on an object in an OO language before you could call something else, this pattern would throw a compile time error if you violate that.</div><br/></div></div><div id="40770895" class="c"><input type="checkbox" id="c-40770895" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40770268">parent</a><span>|</span><a href="#40771707">prev</a><span>|</span><a href="#40771459">next</a><span>|</span><label class="collapse" for="c-40770895">[-]</label><label class="expand" for="c-40770895">[1 more]</label></div><br/><div class="children"><div class="content">Does what have a practical use? The actual filesystem, or using the typestate pattern to prove the absence of bugs?<p>The latter is clearly a practical use - no bugs (or at least vastly less likely bugs).<p>The former is maybe a no since it seems like the authors couldn&#x27;t achieve their results for &quot;normal&quot; filesystems because they are asynchronous - only for &quot;persistent memory&quot; which is synchronous. I dunno exactly who has persistent memory though. I guess it&#x27;s stuff like Intel&#x27;s Optane (which was discontinued)?</div><br/></div></div></div></div><div id="40771459" class="c"><input type="checkbox" id="c-40771459" checked=""/><div class="controls bullet"><span class="by">Shoop</span><span>|</span><a href="#40770268">prev</a><span>|</span><a href="#40772492">next</a><span>|</span><label class="collapse" for="c-40771459">[-]</label><label class="expand" for="c-40771459">[2 more]</label></div><br/><div class="children"><div class="content">I’m guessing that the synchronous update architecture they’re using only really only makes sense for persistent memory and that this couldn’t easily be adapted to conventional hard drives or SSDs?</div><br/><div id="40771801" class="c"><input type="checkbox" id="c-40771801" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#40771459">parent</a><span>|</span><a href="#40772492">next</a><span>|</span><label class="collapse" for="c-40771801">[-]</label><label class="expand" for="c-40771801">[1 more]</label></div><br/><div class="children"><div class="content">If the drive controllers don&#x27;t lie about fsync, then maybe?</div><br/></div></div></div></div><div id="40772492" class="c"><input type="checkbox" id="c-40772492" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#40771459">prev</a><span>|</span><a href="#40770494">next</a><span>|</span><label class="collapse" for="c-40772492">[-]</label><label class="expand" for="c-40772492">[1 more]</label></div><br/><div class="children"><div class="content">How does it compare to Nova-Fortis, PMFS, Strata, Ziggurat (Rust), SplitFS, and Aerie?</div><br/></div></div><div id="40770494" class="c"><input type="checkbox" id="c-40770494" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#40772492">prev</a><span>|</span><a href="#40771922">next</a><span>|</span><label class="collapse" for="c-40770494">[-]</label><label class="expand" for="c-40770494">[2 more]</label></div><br/><div class="children"><div class="content">This is definitely part of the future for better storage systems. Too much responsibility is currently in the hands of programmers (like me) to not make any mistakes. The storage layer can be a high consequence place to make a mistake!</div><br/></div></div><div id="40771922" class="c"><input type="checkbox" id="c-40771922" checked=""/><div class="controls bullet"><span class="by">KennyBlanken</span><span>|</span><a href="#40770494">prev</a><span>|</span><label class="collapse" for="c-40771922">[-]</label><label class="expand" for="c-40771922">[1 more]</label></div><br/><div class="children"><div class="content">This is great but may ultimately be useless, because the storage industry has a long history of not obeying SCSI&#x2F;IDE&#x2F;SATA&#x2F;NVMe commands around flushes and lying to the OS about when data has been committed to disk. You can&#x27;t trust a drive to write stuff when you tell it to, even when you tell it REALLY NO, SERIOUSLY, WRITE THAT SHIT DOWN NOW...and certainly not in the order you tell it to.<p>Long ago an Apple engineer told me that one of the reasons Apple sold 68k Macs with Apple-branded SCSI hard drives (and disk utilities that wouldn&#x27;t work with non-Apple drives) and continued to use Apple-branded drives well into the PowerPC and IDE era was because Apple had been burned by writing operating system &#x2F; filesystem code that took what drives reported at face value and assumed they were doing what they were supposed to according to the specs for the interface standard they&#x27;d supposedly been certified to meet.<p>Sure, it also enabled markups, but it wasn&#x27;t just about having a big margin on storage, and there are additional costs involved. It&#x27;s also why often Apple&#x2F;Quantum drives were slower - they were actually doing what they were supposed to be doing, whereas everyone else as doing what was fastest to juice reviews, and magazine reviewers were either too cozy with manufacturers, or too lazy&#x2F;stupid, to actually test to see if a drive was doing what it was supposed to be doing.<p>The groups behind the interface standards? Trademark money printer go brrrrrrrrrrrrrr. Those golf balls and yachts and supercars aren&#x27;t gonna drive themselves.<p>And yes, this has persisted into the age of NVMe flash. Power failures with SATA and NVMe flash drives can be a real risky business, because the controller is shifting data every which way. From OS memory (some NVMe drives use host memory for caching at the hardware level, which is real snake-oil salesman shit Barnum would be proud of) or drive RAM, SLC mode short term storage, and higher level cells (MLC, QLC, etc.) And the controller has to keep track of all this, in addition to its tables providing the mapping between what the OS considers physical blocks and where those blocks are actually written, due to wear leveling.<p>A power failure with an SSD can potentially brick the drive, (effectively) permanently.<p>Do reviewers test for this? Nope. Most of them didn&#x27;t even realize manufacturers were sending higher-spec NVMe drives out for review and in initial distribution, and then very quickly shifting to much cheaper controllers and flash, or they were in on it and kept their mouths shut so they didn&#x27;t lose access to review sample hardware.<p>Do not trust your storage, at all. Fault tolerance, backups, and power protection suitable for the importance of the data...</div><br/></div></div></div></div></div></div></div></body></html>