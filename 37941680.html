<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1697965257734" as="style"/><link rel="stylesheet" href="styles.css?v=1697965257734"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://marcellerusu.com/using_prolog_as_the_ast.html">Using Prolog as the AST</a> <span class="domain">(<a href="https://marcellerusu.com">marcellerusu.com</a>)</span></div><div class="subtext"><span>mpweiher</span> | <span>23 comments</span></div><br/><div><div id="37973275" class="c"><input type="checkbox" id="c-37973275" checked=""/><div class="controls bullet"><span class="by">iot_devs</span><span>|</span><a href="#37973236">next</a><span>|</span><label class="collapse" for="c-37973275">[-]</label><label class="expand" for="c-37973275">[3 more]</label></div><br/><div class="children"><div class="content">As very long term goal, I want to work on a project like this but on much larger scale.<p>I have a tiny prototype based on Go and soufflé.<p>The overall goal would be to figure out classical error conditions like nill pointers deference.<p>If I can figure out if a pointer will be nil in some execution branch, there is no reason why a computer cannot do the same.<p>However it is very hard work and the part I am currently stuck in is creating a reasonable abstraction level where I can reason (in soufflé) about code and not about an AST.<p>I personally would see this as an human race level upgrades. Imagine feeding your code to a CI that spit back something like: &quot;you will have a panic at line 156 when your input is &gt; 4&quot;<p>Moreover we will be able to check the &quot;real code&quot; starting from main down to all execution paths. Which is much more powerful than current static analysis that usually analyse a single function without considering how the function itself is invoked.<p>Beside the actual implementation difficulties, the other big elephant in the room is the amount of resources needed to run this kind of analysis.<p>(I am less concerned about that as computation resources exploded due to AI and solving SAT is getting faster and faster)</div><br/><div id="37973738" class="c"><input type="checkbox" id="c-37973738" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#37973275">parent</a><span>|</span><a href="#37973522">next</a><span>|</span><label class="collapse" for="c-37973738">[-]</label><label class="expand" for="c-37973738">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The overall goal would be to figure out classical error conditions like nill pointers deference.<p>&gt; If I can figure out if a pointer will be nil in some execution branch, there is no reason why a computer cannot do the same.<p>Note, this is called flow-sensitive typing (also called type narrowing) and I think that typescript does it.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Flow-sensitive_typing" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Flow-sensitive_typing</a><p>&gt; I personally would see this as an human race level upgrades. Imagine feeding your code to a CI that spit back something like: &quot;you will have a panic at line 156 when your input is &gt; 4&quot;<p>A model checker can do that!<p>See this<p><a href="https:&#x2F;&#x2F;model-checking.github.io&#x2F;kani&#x2F;tutorial-kinds-of-failure.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;model-checking.github.io&#x2F;kani&#x2F;tutorial-kinds-of-fail...</a><p>Other techniques are also possible<p><a href="https:&#x2F;&#x2F;github.com&#x2F;viperproject&#x2F;prusti-dev#quick-example">https:&#x2F;&#x2F;github.com&#x2F;viperproject&#x2F;prusti-dev#quick-example</a><p>(Here I could link a lot of things, I just selected two Rust projects to illustrate)<p>This works better if you are able to provide contracts in your API that says which guarantees you provide. Alternatively, asserts are useful too.</div><br/></div></div></div></div><div id="37973236" class="c"><input type="checkbox" id="c-37973236" checked=""/><div class="controls bullet"><span class="by">daitangio</span><span>|</span><a href="#37973275">prev</a><span>|</span><a href="#37972811">next</a><span>|</span><label class="collapse" for="c-37973236">[-]</label><label class="expand" for="c-37973236">[1 more]</label></div><br/><div class="children"><div class="content">Erlang first implementation was based on Prolog, which is the mahor reason of its syntax</div><br/></div></div><div id="37972811" class="c"><input type="checkbox" id="c-37972811" checked=""/><div class="controls bullet"><span class="by">JimmyRuska</span><span>|</span><a href="#37973236">prev</a><span>|</span><a href="#37972689">next</a><span>|</span><label class="collapse" for="c-37972811">[-]</label><label class="expand" for="c-37972811">[2 more]</label></div><br/><div class="children"><div class="content">Racket made a prolog implementation that is currently used in the compiler, or at least I thought I heard that in one of their talks. Might be worth trying, since its model is a language for making languages<p><a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;datalog&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;datalog&#x2F;</a><p><a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;racklog&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;racklog&#x2F;</a></div><br/><div id="37972907" class="c"><input type="checkbox" id="c-37972907" checked=""/><div class="controls bullet"><span class="by">Blackthorn</span><span>|</span><a href="#37972811">parent</a><span>|</span><a href="#37972689">next</a><span>|</span><label class="collapse" for="c-37972907">[-]</label><label class="expand" for="c-37972907">[1 more]</label></div><br/><div class="children"><div class="content">That looks pretty cool. Whenever I see the words &quot;prolog-style&quot; I always ctrl+f for &quot;cut&quot;, and this one passes!</div><br/></div></div></div></div><div id="37972689" class="c"><input type="checkbox" id="c-37972689" checked=""/><div class="controls bullet"><span class="by">simplify</span><span>|</span><a href="#37972811">prev</a><span>|</span><a href="#37973030">next</a><span>|</span><label class="collapse" for="c-37972689">[-]</label><label class="expand" for="c-37972689">[5 more]</label></div><br/><div class="children"><div class="content">Consider using Datalog (the incredible subset of Prolog) for this perfect use case. Compared to Prolog, you get:<p>1. Free de-duplication. No more debugging why a predicate is returning the same result more than once.<p>2. Commutativity. Order of predicates does not change the result. Finally, true logic programming!<p>3. Easy static analysis. There are many papers that describe how to do points-to analysis (and other similar techniques) with Datalog rules that fit on a single page :O<p>Souffle[0] is a mature Datalog that is highly performant and has many nice features. I highly recommend playing with it!<p>[0] <a href="https:&#x2F;&#x2F;souffle-lang.github.io" rel="nofollow noreferrer">https:&#x2F;&#x2F;souffle-lang.github.io</a></div><br/><div id="37972770" class="c"><input type="checkbox" id="c-37972770" checked=""/><div class="controls bullet"><span class="by">all2</span><span>|</span><a href="#37972689">parent</a><span>|</span><a href="#37973030">next</a><span>|</span><label class="collapse" for="c-37972770">[-]</label><label class="expand" for="c-37972770">[4 more]</label></div><br/><div class="children"><div class="content">Souffle seems to suffer from the standard small language issue of no code examples front and center. Also, no &quot;how is this better than X&quot; or &quot;example of usage in Y&quot;.<p>To those who have used Prolog, is the description sufficient to know what it does and if it will be useful? I&#x27;ve never use prolog and I don&#x27;t know the lingo.</div><br/><div id="37972965" class="c"><input type="checkbox" id="c-37972965" checked=""/><div class="controls bullet"><span class="by">simplify</span><span>|</span><a href="#37972689">root</a><span>|</span><a href="#37972770">parent</a><span>|</span><a href="#37973258">next</a><span>|</span><label class="collapse" for="c-37972965">[-]</label><label class="expand" for="c-37972965">[1 more]</label></div><br/><div class="children"><div class="content">I recommend starting with the simple example[0], then taking a look at the tutorial[1].<p>But I do agree that being familiar with Prolog is a big help in understanding what Souffle is. For a quick intro to Prolog, I recommend this video[2], which speaks from a &quot;industry practical&quot; point of view, and introduces concepts that almost all apply to Datalog :)<p>[0] <a href="https:&#x2F;&#x2F;souffle-lang.github.io&#x2F;simple" rel="nofollow noreferrer">https:&#x2F;&#x2F;souffle-lang.github.io&#x2F;simple</a><p>[1] <a href="https:&#x2F;&#x2F;souffle-lang.github.io&#x2F;tutorial" rel="nofollow noreferrer">https:&#x2F;&#x2F;souffle-lang.github.io&#x2F;tutorial</a><p>[2] <a href="https:&#x2F;&#x2F;twitter.com&#x2F;ThePrologClause&#x2F;status&#x2F;1500642533940023302" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;ThePrologClause&#x2F;status&#x2F;15006425339400233...</a></div><br/></div></div><div id="37973258" class="c"><input type="checkbox" id="c-37973258" checked=""/><div class="controls bullet"><span class="by">trott</span><span>|</span><a href="#37972689">root</a><span>|</span><a href="#37972770">parent</a><span>|</span><a href="#37972965">prev</a><span>|</span><a href="#37973432">next</a><span>|</span><label class="collapse" for="c-37973258">[-]</label><label class="expand" for="c-37973258">[1 more]</label></div><br/><div class="children"><div class="content">Prolog is Turing-complete, and Datalog isn&#x27;t. In light of this, I think it&#x27;s a bit of a stretch to call it a (logic) programming language. But people seem to do that.</div><br/></div></div><div id="37973432" class="c"><input type="checkbox" id="c-37973432" checked=""/><div class="controls bullet"><span class="by">crdrost</span><span>|</span><a href="#37972689">root</a><span>|</span><a href="#37972770">parent</a><span>|</span><a href="#37973258">prev</a><span>|</span><a href="#37973030">next</a><span>|</span><label class="collapse" for="c-37973432">[-]</label><label class="expand" for="c-37973432">[1 more]</label></div><br/><div class="children"><div class="content">So in the great scheme of programming languages, you had imperative languages like Fortran, eventually there was a paper “GOTO considered harmful” which ushered in a scaling-back of complexity to “structured programming” where you had named cells in which you could store values, and looping constructs like `while` and `for` to walk through them and manipulate them. Then we added on lexical closures over environments, which also take the form of “methods on objects” and “dynamic dispatch,” a bunch of different names for different  forms of single-threaded OOP. Languages like GIL-ed Python and Ruby and Node.js continue this tradition today, while other languages add threading to have shared-state concurrent programming, with its vocabulary of locks and race conditions and cache invalidation and transactions and commits and consensus algorithms and now CRDTs...<p>But, other visions of programming have coexisted with this main educational vortex, including logic programming like Prolog. Actually, if you have heard of any of these alternates, you have probably heard of <i>functional programming</i>, which can be ahistorically understood as saying “hey these locks and races and all that, it&#x27;s actually very complicated, maybe we could have a simpler model of programming for 90% of our work and only break out the Java when we really need it.” And you’re like “what will you replace it with?” and they respond “Template substitutions! It&#x27;s all the power of lexicographic scopes, all the power of looping (via recursion), but when you want to express the really complex stuff you need templates that have side effects when substituted, we can give those scary names.” So you give me a sunbeam and a raincloud and I give you back a rainbow.<p>If that&#x27;s the functional programming idea then logic programming takes the same idea but adds <i>unification</i> and <i>search</i>. The idea is “ok but why do I have to fill in all the parameters to a template before I use it? I should just say “if light shines on a droplet-cloud it makes a rainbow, a sunbeam is a light, a raincloud is a droplet-cloud, hey language, what are all the things that make a rainbow?”<p>Functional programming was based on the function, the template, the “I take these args and produce a structure looking like such-and-so.” Logic programming is based on the Horn clause, “X verbs Y, for some entities X and Y that I maybe know about and some verb that I am being introduced to.”<p>Basic things that logic programming does very well, OOP kind of struggles with. You can kind of understand this if you have written a SQL query. The verbs can be thought of as tables that foreign-key to X and to Y, if you want to write OOP to solve a logic puzzle you have to choose explicit ways to search or brute force... SQL DBs come with B-trees and indexes to solve a lot of these problems.  Whereas with Prolog you just write the pattern to match and the new pattern  to emit.<p>It&#x27;s a rather different take on what the building blocks should be.</div><br/></div></div></div></div></div></div><div id="37973030" class="c"><input type="checkbox" id="c-37973030" checked=""/><div class="controls bullet"><span class="by">yowlingcat</span><span>|</span><a href="#37972689">prev</a><span>|</span><label class="collapse" for="c-37973030">[-]</label><label class="expand" for="c-37973030">[11 more]</label></div><br/><div class="children"><div class="content">Asking this earnestly and not as a rhetorical question: what do I get from Prolog that I can&#x27;t get from using SQL? Is it speed, is it ergonomics, is it the ability to do computations that are otherwise intractable? And if there are any such advantages, at what level of complexity of abstraction do they come up, and at which level would I not see the value of using prolog?</div><br/><div id="37973402" class="c"><input type="checkbox" id="c-37973402" checked=""/><div class="controls bullet"><span class="by">oldsecondhand</span><span>|</span><a href="#37973030">parent</a><span>|</span><a href="#37973345">next</a><span>|</span><label class="collapse" for="c-37973402">[-]</label><label class="expand" for="c-37973402">[5 more]</label></div><br/><div class="children"><div class="content">SQL doesn&#x27;t have homoiconic structure like Prolog or Lisp, which would facilitate metaprogramming.<p>Prolog and Lisp were derived from first principles, SQL was designed to be a language that reads similar to English (i.e. easy to learn for non-programmers).<p>Prolog and Lisp also has the concept of &quot;atom&quot; which can represent many things, but in parsing it&#x27;s used for terminal symbols.<p>Prolog has the advantage over Lisp that you can define custom operators and their precedence, so you can create easy to read domain specific languages without excessive amounts of parentheses.<p>The built-in backtracking can also be useful for parsing.<p>Definite Clause Grammer rules are also a standard feature, which is very similar to the Backus-Naur form.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Definite_clause_grammar" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Definite_clause_grammar</a></div><br/><div id="37973502" class="c"><input type="checkbox" id="c-37973502" checked=""/><div class="controls bullet"><span class="by">yowlingcat</span><span>|</span><a href="#37973030">root</a><span>|</span><a href="#37973402">parent</a><span>|</span><a href="#37973345">next</a><span>|</span><label class="collapse" for="c-37973502">[-]</label><label class="expand" for="c-37973502">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;re talking about the &quot;how&quot; but I&#x27;m asking about the &quot;what&quot; -- and I&#x27;m not really sure I agree with much of what you mentioned. SQL &quot;reading similar to english&quot; doesn&#x27;t really mean much. Homoiconicity is syntax sugar and in practice, you can do the same thing in any vanilla programming language you&#x27;d use with SQL anyways (query builder flavored ORMs). It&#x27;s not really a killer app.<p>BNF and DCGs get a bit closer to what I&#x27;m asking, but even then I&#x27;m not sure it really adds anything novel -- what, if any advantages do you get from that over the relational algebra whose set theoretic underpinnings serve as the foundation for SQL? How is backtracking functionally different or more powerful than joining?<p>Let me give an example by way of another formalism, which is the Church-Turing correspondence that establishes a correspondence between the lambda calculus and Turing machines. Is there any theoretically stronger expressive power one gets from Prolog over SQL, or is it an ergonomics question, similar to using say, Ruby over Java?</div><br/><div id="37973629" class="c"><input type="checkbox" id="c-37973629" checked=""/><div class="controls bullet"><span class="by">Skinney</span><span>|</span><a href="#37973030">root</a><span>|</span><a href="#37973502">parent</a><span>|</span><a href="#37973699">next</a><span>|</span><label class="collapse" for="c-37973629">[-]</label><label class="expand" for="c-37973629">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is there any theoretically stronger expressive power one gets from Prolog over SQL,<p>I guess this is best illustrated by examples.<p>In prolog, you can define how people are related using &quot;facts&quot; or data:<p><pre><code>    person_parent(alfred, benny).
    person_parent(benny, carl).
</code></pre>
This then forms relationships. In SQL you could write:<p><pre><code>    CREATE TABLE persons ( name TEXT NOT NULL, parent TEXT NOT NULL);
</code></pre>
The difference lies in how you query said data.<p>Let&#x27;s say I want to know if &quot;carl&quot; is the grandparent of &quot;alfred&quot;, in Prolog I would first write a rule to define what a grandparent is:<p><pre><code>    grandparent(X, Y):- person_parent(X, Z), person_parent(Z, Y).
</code></pre>
Then query if &quot;carl&quot; is the grandparent of &quot;alfred&quot;:<p><pre><code>    grandparent(alfred, carl). --&gt; true
</code></pre>
Now, the interesting thing is that I can use the same rule to ask how many grandkids carl has:<p><pre><code>    grandparent(X, carl). --&gt; X = alfred (and any other kid)
</code></pre>
Or, I could ask how many grandparents alfred has<p><pre><code>    grandparent(alfred, Y). --&gt; Y = carl (and any other grandparent)
</code></pre>
Or I could ask for any combinations of kids and their grandparents<p><pre><code>    grandparent(X, Y). --&gt; X = alfred, Y = carl (and any other combination).
</code></pre>
In SQL, on the other hand, you&#x27;d have to write each of these queries by hand.<p>A more powerful example, is defining the rules of suduko and then asking prolog to finish solving a board for you. I will not even begin to suggest how that would be done in SQL (partly because you simply would not use SQL for that).</div><br/></div></div><div id="37973699" class="c"><input type="checkbox" id="c-37973699" checked=""/><div class="controls bullet"><span class="by">oldsecondhand</span><span>|</span><a href="#37973030">root</a><span>|</span><a href="#37973502">parent</a><span>|</span><a href="#37973629">prev</a><span>|</span><a href="#37973625">next</a><span>|</span><label class="collapse" for="c-37973699">[-]</label><label class="expand" for="c-37973699">[1 more]</label></div><br/><div class="children"><div class="content">Their theoretical expressive power are the same, they&#x27;re both turing complete languages. However their practical expressive power is different that comes from language ergonomics, standard libraries and different default optimizations.</div><br/></div></div><div id="37973625" class="c"><input type="checkbox" id="c-37973625" checked=""/><div class="controls bullet"><span class="by">MichaelBurge</span><span>|</span><a href="#37973030">root</a><span>|</span><a href="#37973502">parent</a><span>|</span><a href="#37973699">prev</a><span>|</span><a href="#37973345">next</a><span>|</span><label class="collapse" for="c-37973625">[-]</label><label class="expand" for="c-37973625">[1 more]</label></div><br/><div class="children"><div class="content">SQL with recursive CTEs is Turing-complete. So nothing stops you from writing compilers, rendering Mandelbrot fractals, parsing text, and training neural networks in SQL.</div><br/></div></div></div></div></div></div><div id="37973345" class="c"><input type="checkbox" id="c-37973345" checked=""/><div class="controls bullet"><span class="by">4ad</span><span>|</span><a href="#37973030">parent</a><span>|</span><a href="#37973402">prev</a><span>|</span><label class="collapse" for="c-37973345">[-]</label><label class="expand" for="c-37973345">[5 more]</label></div><br/><div class="children"><div class="content">I am not sure how you could meaningfully compare Prolog and SQL. Both are declarative languages, but that&#x27;s where the similarities end. SQL is for interacting with databases, whereas Prolog is, more or less, a language that you can write regular programs in.<p>Perhaps the Prolog terminology of &quot;queries&quot; and &quot;database&quot; gave you the impression it has something to do with databases that store data. It doesn&#x27;t. The query is over logical terms, and the database is a collection of Prolog facts.</div><br/><div id="37973467" class="c"><input type="checkbox" id="c-37973467" checked=""/><div class="controls bullet"><span class="by">ngruhn</span><span>|</span><a href="#37973030">root</a><span>|</span><a href="#37973345">parent</a><span>|</span><a href="#37973517">next</a><span>|</span><label class="collapse" for="c-37973467">[-]</label><label class="expand" for="c-37973467">[3 more]</label></div><br/><div class="children"><div class="content">Both languages are relational, which is fairly unique among programming languages. For example you can define a graph in Prolog like this:<p><pre><code>  edge(1, 2).
  edge(2, 3).
  edge(3, 4).
</code></pre>
These edges are naturally undirected. Similarly, in SQL you can have a table &quot;Edges&quot;:<p><pre><code>  +——-+——-+
  | 1 | 2 |
  | 2 | 3 |
  | 3 | 4 |
  +——-+——-+
</code></pre>
which also imposes no strict direction. In non-relational languages you have to define maps for both directions.<p>However, in Prolog you can easily define something like reachability using recursion:<p><pre><code>  reachable(V, V).
  reachable(V, W) :-
    edge(V, U),
    reachable(U, W).
</code></pre>
In SQL you would have to join the &quot;Edges&quot; table with itself an unknown number of times. I suspect this is possible somehow but definitely less natural.</div><br/><div id="37973581" class="c"><input type="checkbox" id="c-37973581" checked=""/><div class="controls bullet"><span class="by">j-pb</span><span>|</span><a href="#37973030">root</a><span>|</span><a href="#37973467">parent</a><span>|</span><a href="#37973550">next</a><span>|</span><label class="collapse" for="c-37973581">[-]</label><label class="expand" for="c-37973581">[1 more]</label></div><br/><div class="children"><div class="content">I get what you&#x27;re trying to say, that in Prolog you are able to lookup structures by their shape, and not by some pre-defined path, as in other languages, so you can do both `edge(1, A)` and `edge(A, 1)`.<p>But the graph in your example is still directed, simply by the virtue of predicate  arguments being ordered.<p>So your example misses two rules to be correct.<p><pre><code>  reachable(V, W) :- edge(V, W).
  reachable(V, W) :- edge(W, V).
  reachable(V, W) :-
    reachable(V, U),
    reachable(U, W).
</code></pre>
Alternatively you could introduce<p><pre><code>  edge(V, W) :- edge(W, V).</code></pre></div><br/></div></div><div id="37973550" class="c"><input type="checkbox" id="c-37973550" checked=""/><div class="controls bullet"><span class="by">Epa095</span><span>|</span><a href="#37973030">root</a><span>|</span><a href="#37973467">parent</a><span>|</span><a href="#37973581">prev</a><span>|</span><a href="#37973517">next</a><span>|</span><label class="collapse" for="c-37973550">[-]</label><label class="expand" for="c-37973550">[1 more]</label></div><br/><div class="children"><div class="content">The reachable predicate on your &#x27;naturally undirected edges&#x27; treat them as directed;-)
I would rather say that your edges are naturally directed, and then you can add a clause to make them undirected.</div><br/></div></div></div></div><div id="37973517" class="c"><input type="checkbox" id="c-37973517" checked=""/><div class="controls bullet"><span class="by">yowlingcat</span><span>|</span><a href="#37973030">root</a><span>|</span><a href="#37973345">parent</a><span>|</span><a href="#37973467">prev</a><span>|</span><label class="collapse" for="c-37973517">[-]</label><label class="expand" for="c-37973517">[1 more]</label></div><br/><div class="children"><div class="content">How are the two any different? Can you come up with any differences in expressive power between the first-order logic&#x2F;Horn clauses that underpin Prolog and the relational algebra that underpins SQL?<p>I wonder whether you&#x27;re accurately portraying the structural foundations of either Prolog or SQL.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>