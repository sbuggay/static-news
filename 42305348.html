<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733302858227" as="style"/><link rel="stylesheet" href="styles.css?v=1733302858227"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.erodriguez.de/dependency-management-fatigue-or-why-i-forever-ditched-react-for-go-htmx-templ/">Dependency management fatigue, or why I ditched React for Go+HTMX+Templ</a> <span class="domain">(<a href="https://blog.erodriguez.de">blog.erodriguez.de</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>184 comments</span></div><br/><div><div id="42308275" class="c"><input type="checkbox" id="c-42308275" checked=""/><div class="controls bullet"><span class="by">mark242</span><span>|</span><a href="#42307710">next</a><span>|</span><label class="collapse" for="c-42308275">[-]</label><label class="expand" for="c-42308275">[47 more]</label></div><br/><div class="children"><div class="content">The problem is not so much React as it is the JS ecosystem, but React is just very visible when you have these issues because there are so so so many packages being imported.<p>And the root of the problem is peer dependencies and the JS community&#x27;s lack of backwards compatibility and maintenance.<p>Take any decently-sized JS application, whether React or whatever else. Put it in Github. Turn on dependabot. Watch your pull requests go up by 5-10 PRs per week, just to bump minor versions, and then watch how 1 of those PRs, every single time, fails because of a peer dependency on a lower version.<p>This has been a problem forever in the community, and there&#x27;s no good solution. There&#x27;s also just no feasible way to make a solution due to the nature of the language and the platform itself. You just have to absorb that problem when you decide to use eg Node for your backend code or React&#x2F;etc for your frontend code.</div><br/><div id="42315285" class="c"><input type="checkbox" id="c-42315285" checked=""/><div class="controls bullet"><span class="by">aktuel</span><span>|</span><a href="#42308275">parent</a><span>|</span><a href="#42313579">next</a><span>|</span><label class="collapse" for="c-42315285">[-]</label><label class="expand" for="c-42315285">[2 more]</label></div><br/><div class="children"><div class="content">There is a good solution. It&#x27;s actually a great solution: Write everything in plain JavaScript. You get a great language to develop in. All your problems will go away. No dependency hell. Excellent load times and performance. Superb compatibility.</div><br/><div id="42315555" class="c"><input type="checkbox" id="c-42315555" checked=""/><div class="controls bullet"><span class="by">mablopoule</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42315285">parent</a><span>|</span><a href="#42313579">next</a><span>|</span><label class="collapse" for="c-42315555">[-]</label><label class="expand" for="c-42315555">[1 more]</label></div><br/><div class="children"><div class="content">This.<p>In one of my previous job, the main product was 100% pure Javascript (using AngularJS), with a few (vendored) third-party scripts, and it was very nice to work on it.<p>No package.json, no dependency issues, and above else, the workload we had was always related to business, and almost never related to external technical constraint such as a depreciated dependency.</div><br/></div></div></div></div><div id="42313579" class="c"><input type="checkbox" id="c-42313579" checked=""/><div class="controls bullet"><span class="by">acdha</span><span>|</span><a href="#42308275">parent</a><span>|</span><a href="#42315285">prev</a><span>|</span><a href="#42313223">next</a><span>|</span><label class="collapse" for="c-42313579">[-]</label><label class="expand" for="c-42313579">[13 more]</label></div><br/><div class="children"><div class="content">The JS ecosystem definitely has a big problem from the culture developed in the IE6 era where people developed so many packages working around the limited language and runtime, but React does have part of the blame here: the way it’s designed forces everything into its proprietary model instead of web standards, so you end up with tons of components duplicating other projects but in React or providing shims for those projects, Facebook’s big devrel push prioritized getting started quickly on a proof of concept rather than maintaining a larger app so you had things like Create React App adding nearly 40k dependencies before you had written a single line of code, and the culture of focusing JavaScript over built-in browser functionality (which made some sense in the 2000s when you had users stuck with IE6) means that you’re going a lot of work in runtime JavaScript rather than the browsers’ heavily-optimized C++ – and it’s often hard to change that because it’s not a direct dependency but a nested chain.<p>This is also why it’s slow and memory hungry: it’s not just the inherent inefficiency of the virtual DOM but also that having such a deep tree makes it hard to simplify - and since interoperability makes it cheaper to switch away, framework developers have conflicting incentives about making it easier.</div><br/><div id="42314044" class="c"><input type="checkbox" id="c-42314044" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42313579">parent</a><span>|</span><a href="#42313940">next</a><span>|</span><label class="collapse" for="c-42314044">[-]</label><label class="expand" for="c-42314044">[10 more]</label></div><br/><div class="children"><div class="content">React has two dependencies at runtime [0] and react-dom adds one more [1] (two are shared)?<p>[0] <a href="https:&#x2F;&#x2F;npmgraph.js.org&#x2F;?q=react" rel="nofollow">https:&#x2F;&#x2F;npmgraph.js.org&#x2F;?q=react</a><p>[1] <a href="https:&#x2F;&#x2F;npmgraph.js.org&#x2F;?q=react-dom" rel="nofollow">https:&#x2F;&#x2F;npmgraph.js.org&#x2F;?q=react-dom</a></div><br/><div id="42314338" class="c"><input type="checkbox" id="c-42314338" checked=""/><div class="controls bullet"><span class="by">strogonoff</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42314044">parent</a><span>|</span><a href="#42313940">next</a><span>|</span><label class="collapse" for="c-42314338">[-]</label><label class="expand" for="c-42314338">[9 more]</label></div><br/><div class="children"><div class="content">Can’t help being sarcastic: I have seen a couple of “I ditched React”  post-mortems that apparently start with “I decided to stop adding poorly vetted dependencies with poor package maintenance practices”, just worded differently.<p>It is unsurprising to me if the router library is the first accused. When I was starting with a new project where I am using React, I went through a bunch of router libraries. There are tons, it seems like a low-hanging fruit with many implementations and many people trying to make a living off theirs (can’t blame them for it, unless they make changes for the sake of making changes and to incentivise people to pay for support). Ultimately, I found something off in every one, so I… just decided to not use any!<p>That is the thing, React is a small rendering library[0]  and you are free to build whatever you want around it with as many or as few dependencies as you want. If the ecosystem is popular enough, there will be dependency tree monsters (simply because the ecosystem is extensive and using many dependencies allows package authors to make something impressive with less effort); switching to a less popular ecosystem as a way of dealing with that seems like <i>a</i> solution but a bit of a heavy-handed one.<p>[0] Though under Vercel it does seem to suffer from a bit of feature creep, RSC and all that, it is still pretty lean and as pointed out has two packages total in its dependency tree (some might say it’s two too many, but it is a far cry from dependency hell).</div><br/><div id="42314410" class="c"><input type="checkbox" id="c-42314410" checked=""/><div class="controls bullet"><span class="by">prisenco</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42314338">parent</a><span>|</span><a href="#42314702">next</a><span>|</span><label class="collapse" for="c-42314410">[-]</label><label class="expand" for="c-42314410">[5 more]</label></div><br/><div class="children"><div class="content">In reality though, making a case to use only the React library in a minimalist setup is just as hard to convince a team filled with people who came up in the past 10 years of front-end development as it is to convince them of using HTMX or web components. Nowadays, when people use React they use the whole kit-and-caboodle, and when they say React they mean all of it.<p>Personally, I avoid React because I don&#x27;t want a compile step. I do everything I can to avoid one. And if I do need to use a framework like React, I prefer to isolate it to exactly where I need it instead of using it to build a whole site.</div><br/><div id="42314449" class="c"><input type="checkbox" id="c-42314449" checked=""/><div class="controls bullet"><span class="by">strogonoff</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42314410">parent</a><span>|</span><a href="#42314702">next</a><span>|</span><label class="collapse" for="c-42314449">[-]</label><label class="expand" for="c-42314449">[4 more]</label></div><br/><div class="children"><div class="content">For the first part: yes, but that is why I think it is important to stress dependency vetting.<p>For the second part, a couple of times when I had to add a bit of purely client-side reactivity to something pre-existing but did not want to introduce any build step I simply aliased createElement() to el(). That said, personally I prefer TypeScript for a project of any size, so build step is implied and I can simply not think about converting JSX. Webpack triggers bad memories but esbuild is reasonable.</div><br/><div id="42314465" class="c"><input type="checkbox" id="c-42314465" checked=""/><div class="controls bullet"><span class="by">prisenco</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42314449">parent</a><span>|</span><a href="#42314702">next</a><span>|</span><label class="collapse" for="c-42314465">[-]</label><label class="expand" for="c-42314465">[3 more]</label></div><br/><div class="children"><div class="content">FYI I use jsdoc for typing in my IDE so I get the benefit of types without the build step.</div><br/><div id="42314484" class="c"><input type="checkbox" id="c-42314484" checked=""/><div class="controls bullet"><span class="by">strogonoff</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42314465">parent</a><span>|</span><a href="#42314702">next</a><span>|</span><label class="collapse" for="c-42314484">[-]</label><label class="expand" for="c-42314484">[2 more]</label></div><br/><div class="children"><div class="content">I like when it simply does not compile, which also helps if there are other various team members (or future me) who can not always be trusted to ignore typing errors. Also, I may be wrong, but I feel like JSDoc types are a bit limiting (and more verbose &amp; extra effort) compared to inline TypeScript. Coming from Python, I really enjoy the typing power of TS and do not want to compromise on that…</div><br/><div id="42314498" class="c"><input type="checkbox" id="c-42314498" checked=""/><div class="controls bullet"><span class="by">prisenco</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42314484">parent</a><span>|</span><a href="#42314702">next</a><span>|</span><label class="collapse" for="c-42314498">[-]</label><label class="expand" for="c-42314498">[1 more]</label></div><br/><div class="children"><div class="content">I prefer to just run tsc to check for type errors on GitHub commits instead of needing them for every change.<p>And yeah inline types are more verbose but I prefer to use .d.ts files for definitions and then declare with a comment (vim lets me move to definitions with ctrl-] which is nice).<p>I also come from a Go background so I actively don&#x27;t like using the more esoteric and complex types that typescript provides.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42314702" class="c"><input type="checkbox" id="c-42314702" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42314338">parent</a><span>|</span><a href="#42314410">prev</a><span>|</span><a href="#42313940">next</a><span>|</span><label class="collapse" for="c-42314702">[-]</label><label class="expand" for="c-42314702">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>React is a small rendering library</i><p>Sorry, can&#x27;t agree. React is a <i>state management</i> library that also implements efficient rendering on top of the DOM diff it computes as it propagates the state changes.<p>This allows React apps to remain so simple (one mostly linear function per component) and so composable without turning into an unmanageable dish of callback &#x2F; future spaghetti.<p>There is a number of other VDOM libraries, but what sets React apart is the data &#x2F; state flow strictly in one direction. This allows to reap many of the benefits of functional programming along the way, like everything the developer sees being immutable; not a coincidence.<p>Regarding the size, preact [1] is mostly API-compatible, but also absurdly small (3-4 kB minified), actually <i>smaller</i> than HTMX (10 kB). But with preact you likely also want preact-iso, so the size grows a little bit.<p>[1]: <a href="https:&#x2F;&#x2F;preactjs.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;preactjs.com&#x2F;</a></div><br/><div id="42314706" class="c"><input type="checkbox" id="c-42314706" checked=""/><div class="controls bullet"><span class="by">mplewis</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42314702">parent</a><span>|</span><a href="#42313940">next</a><span>|</span><label class="collapse" for="c-42314706">[-]</label><label class="expand" for="c-42314706">[2 more]</label></div><br/><div class="children"><div class="content">React notoriously doesn&#x27;t come with enough state management to properly manage state in anything larger than trivial.</div><br/><div id="42314763" class="c"><input type="checkbox" id="c-42314763" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42314706">parent</a><span>|</span><a href="#42313940">next</a><span>|</span><label class="collapse" for="c-42314763">[-]</label><label class="expand" for="c-42314763">[1 more]</label></div><br/><div class="children"><div class="content">React comes with useState, useMemo, and useCallback, which is actually enough, but it may be too low-level when you think e.g. in terms of a huge interactive form. It&#x27;s easy to write your own useWhatever based on these which would factor out your common boilerplate.<p>I suspect HTMX also does not come with every possible battery included, judging by the proliferation of libraries for HTMX-based projects. Modularity is a strength.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42313940" class="c"><input type="checkbox" id="c-42313940" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42313579">parent</a><span>|</span><a href="#42314044">prev</a><span>|</span><a href="#42313223">next</a><span>|</span><label class="collapse" for="c-42313940">[-]</label><label class="expand" for="c-42313940">[2 more]</label></div><br/><div class="children"><div class="content">&gt; inherent inefficiency of the virtual DOM<p>I was around when vDOM was being called optimized.<p>I was also around when they called it DHTML.<p>Get off my lawn!</div><br/><div id="42314762" class="c"><input type="checkbox" id="c-42314762" checked=""/><div class="controls bullet"><span class="by">acdha</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42313940">parent</a><span>|</span><a href="#42313223">next</a><span>|</span><label class="collapse" for="c-42314762">[-]</label><label class="expand" for="c-42314762">[1 more]</label></div><br/><div class="children"><div class="content">Same (I started writing JavaScript when it was called LiveScript in the Netscape betas), and I remember how the vDOM hype was conspicuously short on rigorous benchmarks – people would compare it to heavyweight frameworks which did things like touch elements repeatedly or do innerHtml cycles and say it was fast.</div><br/></div></div></div></div></div></div><div id="42313223" class="c"><input type="checkbox" id="c-42313223" checked=""/><div class="controls bullet"><span class="by">sporkland</span><span>|</span><a href="#42308275">parent</a><span>|</span><a href="#42313579">prev</a><span>|</span><a href="#42313541">next</a><span>|</span><label class="collapse" for="c-42313223">[-]</label><label class="expand" for="c-42313223">[2 more]</label></div><br/><div class="children"><div class="content">Reminds me of the Rich Hickey talk Speculation[1]. There is a special place in hell reserved for programmers that break back compat (for non-security impacting reasons) with widely used libraries, including google&#x27;s guava developers.  Linus Torvalds seems to be the only engineer with his head on straight on this topic and he has to constantly dive in and berate people that are trying to violate it in his project.<p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=oyLBGkS5ICk" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=oyLBGkS5ICk</a></div><br/><div id="42315541" class="c"><input type="checkbox" id="c-42315541" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42313223">parent</a><span>|</span><a href="#42313541">next</a><span>|</span><label class="collapse" for="c-42315541">[-]</label><label class="expand" for="c-42315541">[1 more]</label></div><br/><div class="children"><div class="content">Can you provide an example where Google Guava broken backwards compatibility?  I have used it for more than 10 years without any issues during upgrades.  To be fair, it is a huge library, and I have probably barely used 20%.</div><br/></div></div></div></div><div id="42313541" class="c"><input type="checkbox" id="c-42313541" checked=""/><div class="controls bullet"><span class="by">ajayvk</span><span>|</span><a href="#42308275">parent</a><span>|</span><a href="#42313223">prev</a><span>|</span><a href="#42308485">next</a><span>|</span><label class="collapse" for="c-42313541">[-]</label><label class="expand" for="c-42313541">[1 more]</label></div><br/><div class="children"><div class="content">I have been building a platform <a href="https:&#x2F;&#x2F;github.com&#x2F;claceio&#x2F;clace">https:&#x2F;&#x2F;github.com&#x2F;claceio&#x2F;clace</a> for teams to develop Hypermedia based internal tools.  One of the main criteria for the technology stack and the feature set has been making sure apps can be maintained easily, after six months and after six years.<p>Settled on using Go HTML templates, Starlark and HTMX. Go has a great track record of not breaking backward compatibility. Go templates are widely used by ops teams, any breaking changes there will cause ops teams to revolt. Starlark is somewhat widely used by build systems (like Bazel), any breaking changes there will cause build engineers to rise up in arms. The HTMX 1.9 to 2.0 upgrade was also painless, no changes required in my test apps. Only change required was to update the way the websocket extension is resolved.</div><br/></div></div><div id="42308485" class="c"><input type="checkbox" id="c-42308485" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#42308275">parent</a><span>|</span><a href="#42313541">prev</a><span>|</span><a href="#42309701">next</a><span>|</span><label class="collapse" for="c-42308485">[-]</label><label class="expand" for="c-42308485">[6 more]</label></div><br/><div class="children"><div class="content">For node and other technologies like react, I would prefer less, but fatter libraries that could be optimized at compile time. All those micro packages coming from nowhere and getting updated every day is a big pain.</div><br/><div id="42312123" class="c"><input type="checkbox" id="c-42312123" checked=""/><div class="controls bullet"><span class="by">chrysoprace</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42308485">parent</a><span>|</span><a href="#42313080">next</a><span>|</span><label class="collapse" for="c-42312123">[-]</label><label class="expand" for="c-42312123">[3 more]</label></div><br/><div class="children"><div class="content">Or better yet, no dependencies! The built-in&#x27;s for both JavaScript and the browser APIs are getting better and better every day, but people still reach for things like Lodash and Date libraries when the equivalent functions are built into the language and runtime itself.</div><br/><div id="42313126" class="c"><input type="checkbox" id="c-42313126" checked=""/><div class="controls bullet"><span class="by">solardev</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42312123">parent</a><span>|</span><a href="#42313080">next</a><span>|</span><label class="collapse" for="c-42313126">[-]</label><label class="expand" for="c-42313126">[2 more]</label></div><br/><div class="children"><div class="content">Some things are easy now, but some things still require multiple lines of code: <a href="https:&#x2F;&#x2F;youmightnotneed.com&#x2F;lodash" rel="nofollow">https:&#x2F;&#x2F;youmightnotneed.com&#x2F;lodash</a>. If you only need one or two, sure, just write your own, but if you&#x27;re maintaining a big project... why waste time debugging these common utility functions? You&#x27;d basically just be reinventing lodash, but with fewer community eyes and tests on it. Whoever inherits that is gonna need to debug all your util functions when something inevitably goes wrong. Like for _.pickBy(), none of these are very readable (<a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;54743996&#x2F;converting-lodashs-pickby-in-to-javascript" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;54743996&#x2F;converting-loda...</a>), another implements it wrong and leaves out the predicate (<a href="https:&#x2F;&#x2F;github.com&#x2F;you-dont-need&#x2F;You-Dont-Need-Lodash-Underscore?tab=readme-ov-file#_pickby">https:&#x2F;&#x2F;github.com&#x2F;you-dont-need&#x2F;You-Dont-Need-Lodash-Unders...</a>), etc. Why do this to your project and fellow devs when it can easily be a single tree-shaken function imported from a popular, well-maintained lib?<p>If anything, ECMA should just absorb more lodash functions into the standard lib, like they&#x27;ve gradually done with some of the array functions. But common things like that shouldn&#x27;t be up to each individual programmer &amp; team to reinvent all the time. It just needlessly expands the maintenance surface and causes subtle bugs across teams &amp; projects.<p>JS Date is in an even worse place. If you ever need to work across time zones on both the server and the client&#x2F;browser, native JS date is totally unusable because it &quot;loses&quot; the original time zone string and just coerces everything into (basically) utc milliseconds. The Temporal API is supposed to fix that, but I&#x27;ve been waiting for that for nearly a decade: <a href="https:&#x2F;&#x2F;tc39.es&#x2F;proposal-temporal&#x2F;docs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tc39.es&#x2F;proposal-temporal&#x2F;docs&#x2F;</a>. That proposal links to <a href="https:&#x2F;&#x2F;maggiepint.com&#x2F;2017&#x2F;04&#x2F;09&#x2F;fixing-javascript-date-getting-started&#x2F;" rel="nofollow">https:&#x2F;&#x2F;maggiepint.com&#x2F;2017&#x2F;04&#x2F;09&#x2F;fixing-javascript-date-get...</a>, which explains some of the weaknesses of the current JS date system.</div><br/><div id="42313595" class="c"><input type="checkbox" id="c-42313595" checked=""/><div class="controls bullet"><span class="by">chrysoprace</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42313126">parent</a><span>|</span><a href="#42313080">next</a><span>|</span><label class="collapse" for="c-42313595">[-]</label><label class="expand" for="c-42313595">[1 more]</label></div><br/><div class="children"><div class="content">I agree with you about timezones and I think a library like date-fns (and date-fns-tz) strike a nice balance by not using a bespoke intermediary object type.<p>As you say, some of them are built in and those should just be used instead in most cases. The problem is that when you leave the choice of library to use, then the choice isn&#x27;t always obvious, especially for niche use cases. A library that&#x27;s well-maintained today may not be so tomorrow when the maintainer falls ill, gets burnt out on work + open source work or simply gets bored of the project.<p>Deno has the right approach in this regard where they are creating standard libraries to go with their runtime which are expected to be maintained in the long term, but even then I&#x27;d still prefer built-in APIs in most cases.</div><br/></div></div></div></div></div></div><div id="42313080" class="c"><input type="checkbox" id="c-42313080" checked=""/><div class="controls bullet"><span class="by">solardev</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42308485">parent</a><span>|</span><a href="#42312123">prev</a><span>|</span><a href="#42314091">next</a><span>|</span><label class="collapse" for="c-42313080">[-]</label><label class="expand" for="c-42313080">[1 more]</label></div><br/><div class="children"><div class="content">Angular was kinda like that, batteries-included, but it lost to React. It wasn&#x27;t until Next that we got a similar batteries-included big framework for the React world.</div><br/></div></div><div id="42314091" class="c"><input type="checkbox" id="c-42314091" checked=""/><div class="controls bullet"><span class="by">stana</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42308485">parent</a><span>|</span><a href="#42313080">prev</a><span>|</span><a href="#42309701">next</a><span>|</span><label class="collapse" for="c-42314091">[-]</label><label class="expand" for="c-42314091">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that Svelte?</div><br/></div></div></div></div><div id="42309701" class="c"><input type="checkbox" id="c-42309701" checked=""/><div class="controls bullet"><span class="by">ebiester</span><span>|</span><a href="#42308275">parent</a><span>|</span><a href="#42308485">prev</a><span>|</span><a href="#42312902">next</a><span>|</span><label class="collapse" for="c-42309701">[-]</label><label class="expand" for="c-42309701">[6 more]</label></div><br/><div class="children"><div class="content">But here&#x27;s the thing.<p>It doesn&#x27;t matter!<p>If I&#x27;m building a personal project, I don&#x27;t have the same time to curate a full ecosystem stack and nobody in the react system is maintaining those for applications that are put to the side for weeks or months at a time.<p>As for me, I just restarted a personal project on rails because of its batteries included mentality - it means I can limit the number of dependencies, and they have gotten very good at migration paths and deprecations.</div><br/><div id="42312481" class="c"><input type="checkbox" id="c-42312481" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42309701">parent</a><span>|</span><a href="#42312902">next</a><span>|</span><label class="collapse" for="c-42312481">[-]</label><label class="expand" for="c-42312481">[5 more]</label></div><br/><div class="children"><div class="content">&gt; I just restarted a personal project on rails because of its batteries included mentality - it means I can limit the number of dependencies<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rails&#x2F;rails&#x2F;blob&#x2F;main&#x2F;Gemfile.lock">https:&#x2F;&#x2F;github.com&#x2F;rails&#x2F;rails&#x2F;blob&#x2F;main&#x2F;Gemfile.lock</a><p>Just a playful comment - not challenging your experience</div><br/><div id="42312822" class="c"><input type="checkbox" id="c-42312822" checked=""/><div class="controls bullet"><span class="by">frio</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42312481">parent</a><span>|</span><a href="#42312902">next</a><span>|</span><label class="collapse" for="c-42312822">[-]</label><label class="expand" for="c-42312822">[4 more]</label></div><br/><div class="children"><div class="content">Sure, but the framework cares about that for me. I don’t use rails personally but that’s the whole point — someone upstream of me is paying attention and making everything work together.<p>In contrast, I have work apps made in React that need regular piecemeal updating — routers, form libraries, query managers, CSS — because we’ve chosen to cobble that together ourselves. That’s fine, that’s the path we chose knowingly when we picked the tech we picked, but the point isn’t that frameworks don’t have dependencies — it’s that they take on more of the burden of managing them for you.</div><br/><div id="42313070" class="c"><input type="checkbox" id="c-42313070" checked=""/><div class="controls bullet"><span class="by">solardev</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42312822">parent</a><span>|</span><a href="#42312902">next</a><span>|</span><label class="collapse" for="c-42313070">[-]</label><label class="expand" for="c-42313070">[3 more]</label></div><br/><div class="children"><div class="content">Well, Next is kinda like that then. It takes care of the sub-dependencies for you and when you upgrade, you just upgrade to the next major Next version (which isn&#x27;t necessarily easy, but more so than upgrading 100 individual packages). They provide codemods for some stuff too.</div><br/><div id="42313127" class="c"><input type="checkbox" id="c-42313127" checked=""/><div class="controls bullet"><span class="by">goosejuice</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42313070">parent</a><span>|</span><a href="#42312902">next</a><span>|</span><label class="collapse" for="c-42313127">[-]</label><label class="expand" for="c-42313127">[2 more]</label></div><br/><div class="children"><div class="content">I suspect that most rails, or next, projects add additional dependencies than just the framework. Generally the framework isn&#x27;t the issue in my experience.</div><br/><div id="42313281" class="c"><input type="checkbox" id="c-42313281" checked=""/><div class="controls bullet"><span class="by">solardev</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42313127">parent</a><span>|</span><a href="#42312902">next</a><span>|</span><label class="collapse" for="c-42313281">[-]</label><label class="expand" for="c-42313281">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but it&#x27;s not an either&#x2F;or situation. Every big project adds dependencies, but using Next means you have some basic, common functionality included out of the box by default&#x2F;by convention (like TypeScript, linting, testing, routing, caching, SSR, static builds, serverless definitions, etc.) all done in a predefined way. Maybe your project has 200 deps, but Next would replace like 50 of the big ones that you&#x27;d otherwise have to separately install and maintain. Just having a basic page&#x2F;app router and minimal state system (via contexts and RSC and props and such) reduces a lot of the headaches of the bad old React Router days.<p>It replaces &quot;React soup of the day&quot; with a more standard &quot;recipe&quot; shared by most Next projects – like &quot;Grandma Vercel&#x27;s secret React minestrone&quot;, I guess. But yes, projects would typically still add their own &quot;spices&quot; on top of those basics.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42312902" class="c"><input type="checkbox" id="c-42312902" checked=""/><div class="controls bullet"><span class="by">froddd</span><span>|</span><a href="#42308275">parent</a><span>|</span><a href="#42309701">prev</a><span>|</span><a href="#42310022">next</a><span>|</span><label class="collapse" for="c-42312902">[-]</label><label class="expand" for="c-42312902">[7 more]</label></div><br/><div class="children"><div class="content">The main question should always be: why update?<p>Should a library become compromised with a vulnerability, fine (if said vulnerability is relevant to your usage). If you need a feature only available in a newer version, fine (I’m counting better performance as a feature).<p>What I’m seeing far too much of is upgrading for the sake of it. It feels like such a waste of dev time. Pinning dependencies should be absolutely fine.</div><br/><div id="42312916" class="c"><input type="checkbox" id="c-42312916" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42312902">parent</a><span>|</span><a href="#42313069">next</a><span>|</span><label class="collapse" for="c-42312916">[-]</label><label class="expand" for="c-42312916">[1 more]</label></div><br/><div class="children"><div class="content">You either waste your time updating daily or you rewrite from scratch every 3 years. JS is what happens when you let the inmates run the asylum.</div><br/></div></div><div id="42313069" class="c"><input type="checkbox" id="c-42313069" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42312902">parent</a><span>|</span><a href="#42312916">prev</a><span>|</span><a href="#42313109">next</a><span>|</span><label class="collapse" for="c-42313069">[-]</label><label class="expand" for="c-42313069">[1 more]</label></div><br/><div class="children"><div class="content">The issue is that feature or vulnerability might not be patched on older versions.   If you are using a 2 year old version and a non-backported vuln or needed feature comes along that means you have to absorb 2 years of breaking changes to move to that version.<p>Frequent updates allow you to address the breaks gradually rather than all at once.<p>JS is just awful, though, because of the sprawling dep tree.  I get why devs would prefer pinning as any one of the 1000 deps that get brought in could need an update and code changes on any given day.  A sticky static version requires less daily maintenance.</div><br/></div></div><div id="42313109" class="c"><input type="checkbox" id="c-42313109" checked=""/><div class="controls bullet"><span class="by">latentsea</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42312902">parent</a><span>|</span><a href="#42313069">prev</a><span>|</span><a href="#42310022">next</a><span>|</span><label class="collapse" for="c-42313109">[-]</label><label class="expand" for="c-42313109">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s vastly, vastly easier to upgrade small version bumps constantly via automated tools like renovate than it is to try upgrade several major versions every few years. It&#x27;s shite being stuck with dependencies the dev team has now put in the &quot;too hard basket&quot; in terms of upgrading because the delta is too scary or difficult and too much code has ossified around the now ancient version. Don&#x27;t willingly do that to yourself if you can avoid.</div><br/><div id="42313239" class="c"><input type="checkbox" id="c-42313239" checked=""/><div class="controls bullet"><span class="by">froddd</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42313109">parent</a><span>|</span><a href="#42310022">next</a><span>|</span><label class="collapse" for="c-42313239">[-]</label><label class="expand" for="c-42313239">[3 more]</label></div><br/><div class="children"><div class="content">I get that, and it’s a good point. But at some point that easy patch&#x2F;minor version bump becomes a major version with a breaking change, and does take time to upgrade regardless, scary delta and such. My point is that, without an actual feature need or an actual vulnerability (none of these guaranteed to spring up in future), any time spent upgrading is <i>potentially</i> wasted. I know some projects are unlikely to last beyond a few years —- in those cases I think the risk is calculated enough to not matter too much.</div><br/><div id="42314117" class="c"><input type="checkbox" id="c-42314117" checked=""/><div class="controls bullet"><span class="by">latentsea</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42313239">parent</a><span>|</span><a href="#42313376">next</a><span>|</span><label class="collapse" for="c-42314117">[-]</label><label class="expand" for="c-42314117">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s down to engineering culture at that point. We have a weekly process where we merge those PRs and including any that are failing. It doesn&#x27;t suck up much time at all, but our stuff is always well maintained with few surprises lurking. The side effect of this type of culture is high quality test suites and pipelines that you have very high confidence in and are executed frequently and quickly. It&#x27;s overall been a far better experience than just letting stuff rot.</div><br/></div></div><div id="42313376" class="c"><input type="checkbox" id="c-42313376" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42313239">parent</a><span>|</span><a href="#42314117">prev</a><span>|</span><a href="#42310022">next</a><span>|</span><label class="collapse" for="c-42313376">[-]</label><label class="expand" for="c-42313376">[1 more]</label></div><br/><div class="children"><div class="content">&gt; My point is that, without an actual feature need or an actual vulnerability (none of these guaranteed to spring up in future), any time spent upgrading is potentially wasted. I know some projects are unlikely to last beyond a few years —- in those cases I think the risk is calculated enough to not matter too much.<p>You could make the same argument for any kind of code quality efforts. Frankly I think this site probably leans too far into a high-quality mindset, but apart from anything else good programmers won&#x27;t want to work on a codebase that isn&#x27;t seen as valuable and treated as such.</div><br/></div></div></div></div></div></div></div></div><div id="42310022" class="c"><input type="checkbox" id="c-42310022" checked=""/><div class="controls bullet"><span class="by">niceice</span><span>|</span><a href="#42308275">parent</a><span>|</span><a href="#42312902">prev</a><span>|</span><a href="#42312811">next</a><span>|</span><label class="collapse" for="c-42310022">[-]</label><label class="expand" for="c-42310022">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t it still a React problem? They could have chosen to not rely on dependencies and you don&#x27;t have to add more to it.</div><br/></div></div><div id="42312811" class="c"><input type="checkbox" id="c-42312811" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#42308275">parent</a><span>|</span><a href="#42310022">prev</a><span>|</span><a href="#42312664">next</a><span>|</span><label class="collapse" for="c-42312811">[-]</label><label class="expand" for="c-42312811">[4 more]</label></div><br/><div class="children"><div class="content">It’s not a JS problem, it’s a fundamental constraint of working within the browser runtime: <a href="https:&#x2F;&#x2F;bower.sh&#x2F;my-love-letter-to-front-end-web-development" rel="nofollow">https:&#x2F;&#x2F;bower.sh&#x2F;my-love-letter-to-front-end-web-development</a></div><br/><div id="42313089" class="c"><input type="checkbox" id="c-42313089" checked=""/><div class="controls bullet"><span class="by">goosejuice</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42312811">parent</a><span>|</span><a href="#42313236">next</a><span>|</span><label class="collapse" for="c-42313089">[-]</label><label class="expand" for="c-42313089">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t dismiss the responsibility of culture in the JS dependency problem. I agree with a few points in the article but much of these dependencies aren&#x27;t needed, they are preferred and importing is normalized.<p>Left-pad wasn&#x27;t a problem because of browser constraints, it was a problem because of culture and to some extent discipline.</div><br/></div></div><div id="42313236" class="c"><input type="checkbox" id="c-42313236" checked=""/><div class="controls bullet"><span class="by">homebrewer</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42312811">parent</a><span>|</span><a href="#42313089">prev</a><span>|</span><a href="#42312664">next</a><span>|</span><label class="collapse" for="c-42313236">[-]</label><label class="expand" for="c-42313236">[2 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t excuse some authors who enjoy constantly rewriting their libraries just for the hell of it, consistently introducing breaking API changes.<p>react-router might be one of the best examples (or the worst, depends on how you look at it), and it&#x27;s unfortunately very popular, even though sane and stable alternatives exist (like wouter).</div><br/><div id="42313782" class="c"><input type="checkbox" id="c-42313782" checked=""/><div class="controls bullet"><span class="by">sriram_malhar</span><span>|</span><a href="#42308275">root</a><span>|</span><a href="#42313236">parent</a><span>|</span><a href="#42312664">next</a><span>|</span><label class="collapse" for="c-42313782">[-]</label><label class="expand" for="c-42313782">[1 more]</label></div><br/><div class="children"><div class="content">OP&#x27;s article complains specifically about wouter&#x27;s rate of change!</div><br/></div></div></div></div></div></div><div id="42312664" class="c"><input type="checkbox" id="c-42312664" checked=""/><div class="controls bullet"><span class="by">jmull</span><span>|</span><a href="#42308275">parent</a><span>|</span><a href="#42312811">prev</a><span>|</span><a href="#42314451">next</a><span>|</span><label class="collapse" for="c-42312664">[-]</label><label class="expand" for="c-42312664">[1 more]</label></div><br/><div class="children"><div class="content">Well, designing a module to be a peer dependency and then not strongly favoring backwards compatibility is a choice. When you make that choice you&#x27;re probably screwing your users, in the long run.<p>As a user of modules, if you can detect such module, you can choose not to use it, and save yourself all that future trouble.<p>Now. Let&#x27;s see. How many times has react&#x27;s major version number changed?...<p>Yes, it&#x27;s not only react, but boy are they an enthusiastic leader of this approach.</div><br/></div></div><div id="42314451" class="c"><input type="checkbox" id="c-42314451" checked=""/><div class="controls bullet"><span class="by">prisenco</span><span>|</span><a href="#42308275">parent</a><span>|</span><a href="#42312664">prev</a><span>|</span><a href="#42308592">next</a><span>|</span><label class="collapse" for="c-42314451">[-]</label><label class="expand" for="c-42314451">[1 more]</label></div><br/><div class="children"><div class="content">We also have a generation of designers who &quot;think in React&quot; who don&#x27;t approach the web like the web, but like a less form of mobile.<p>A designer who has a solid understanding of hypermedia and puts its principles first would be worth their weight in gold to a team who wanted to move away from the React ecosystem.</div><br/></div></div><div id="42308592" class="c"><input type="checkbox" id="c-42308592" checked=""/><div class="controls bullet"><span class="by">causal</span><span>|</span><a href="#42308275">parent</a><span>|</span><a href="#42314451">prev</a><span>|</span><a href="#42312794">next</a><span>|</span><label class="collapse" for="c-42308592">[-]</label><label class="expand" for="c-42308592">[1 more]</label></div><br/><div class="children"><div class="content">Yeah React itself is actually a very small part of the ecosystem that has evolved alongside React. And it&#x27;s a mature ecosystem, therefore there&#x27;s a lot of libraries to use that come at the cost of keeping them patched.<p>It&#x27;s easy to think that a new tech stack is somehow more complete because there are fewer add-ons and no vulnerabilities have been discovered yet.</div><br/></div></div><div id="42312794" class="c"><input type="checkbox" id="c-42312794" checked=""/><div class="controls bullet"><span class="by">tonyhart7</span><span>|</span><a href="#42308275">parent</a><span>|</span><a href="#42308592">prev</a><span>|</span><a href="#42307710">next</a><span>|</span><label class="collapse" for="c-42312794">[-]</label><label class="expand" for="c-42312794">[1 more]</label></div><br/><div class="children"><div class="content">Yeah even when use sveltekit, its still apparent<p>but its still pleasant imo</div><br/></div></div></div></div><div id="42307710" class="c"><input type="checkbox" id="c-42307710" checked=""/><div class="controls bullet"><span class="by">bsnnkv</span><span>|</span><a href="#42308275">prev</a><span>|</span><a href="#42308316">next</a><span>|</span><label class="collapse" for="c-42307710">[-]</label><label class="expand" for="c-42307710">[16 more]</label></div><br/><div class="children"><div class="content">I have very similar feelings to the author. I think it was back in 2019ish that I gave up on React &amp; co for good. Since then I have built a number of web apps on a relatively spartan stack of Actix, Tera and HTMX, and they have all stood the test of maintainability over time and have a core group of diehard users.<p>Last week I shipped another new web app[1] I got an idea for in &lt;24h to closed alpha testers and in &lt;7d to a public beta with no issues or fanfare.<p>Perhaps part of the increased velocity is my having gone deep and learned the ins and outs of this stack over multiple years and projects, but it is important to note that I probably would never have gained this level of mastery over these tools if I were constantly being hit with what the author calls &quot;dependency management fatigue&quot;.<p>[1]: <a href="https:&#x2F;&#x2F;blucerne.app" rel="nofollow">https:&#x2F;&#x2F;blucerne.app</a></div><br/><div id="42311258" class="c"><input type="checkbox" id="c-42311258" checked=""/><div class="controls bullet"><span class="by">mlsu</span><span>|</span><a href="#42307710">parent</a><span>|</span><a href="#42312516">next</a><span>|</span><label class="collapse" for="c-42311258">[-]</label><label class="expand" for="c-42311258">[4 more]</label></div><br/><div class="children"><div class="content">I (a novice) have been toying with web apps for a little bit now with Axum, Tera&#x2F;Askama, and HTMX. I&#x27;m doing something very similar. I find that it works well for my simple apps but then complexity gets tough when I start to have a lot of template logic. This is when I realize that frontend web dev is actually full of interesting complexity...<p>Obviously managing complexity in templates is something I&#x27;m sure people solved years and years ago, but of course now with 99% of frontend resources (blog posting, video content, courses, etc) being SPA focused, resources on doing it &quot;the old school way&quot; are scant.<p>Do you know of any resources for designing web-apps of intermediate complexity with SSR templates? Or even just good resources from the HTMX + SSR camp, aside from the HTMX fellas?</div><br/><div id="42311505" class="c"><input type="checkbox" id="c-42311505" checked=""/><div class="controls bullet"><span class="by">bsnnkv</span><span>|</span><a href="#42307710">root</a><span>|</span><a href="#42311258">parent</a><span>|</span><a href="#42312091">next</a><span>|</span><label class="collapse" for="c-42311505">[-]</label><label class="expand" for="c-42311505">[2 more]</label></div><br/><div class="children"><div class="content">My longest running web app[1] is also my most complex. Although I do use HTMX, I use it very sparingly.[2]<p>90%+ of what you need for a web app that you&#x27;re building as a one-person show can be handled by storing state in the URL - people these days can be quick to forget that this is how large and complex web apps like GitHub have run for many, many years.<p>With regards to complexity in templates, I find that you can cut down on a lot of that complexity if you enforce type constraints in your templating engine&#x27;s context object.<p>Getting in a habit of doing this early gets you thinking about ways to shift things that require conditional logic to the pre-templating stage, and more often than not it leads you to breaking down bigger templates into smaller partials and using them to compose different template variations for different views. I like this and it makes a lot of sense to me, but I&#x27;m not sure how it would feel to people who have only ever written JS SPA web apps.<p>[1]: <a href="https:&#x2F;&#x2F;notado.app" rel="nofollow">https:&#x2F;&#x2F;notado.app</a><p>[2]: Example of the only place I use HTMX in Notado (to show search results as you type): <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=KMxmf132-8k" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=KMxmf132-8k</a></div><br/><div id="42313739" class="c"><input type="checkbox" id="c-42313739" checked=""/><div class="controls bullet"><span class="by">em-bee</span><span>|</span><a href="#42307710">root</a><span>|</span><a href="#42311505">parent</a><span>|</span><a href="#42312091">next</a><span>|</span><label class="collapse" for="c-42313739">[-]</label><label class="expand" for="c-42313739">[1 more]</label></div><br/><div class="children"><div class="content">i think your approach is orthogonal to SPA. first of all, it is my understanding that react in particular favors small templates or partials. and second, with the traditional server side frameworks i have always used full page templates, and i tend to write SPA the same way. i would only break up a template if it contains selfcontained sections that could potentially be used in different places. my point is that this is not because all i ever did was SPA, but because i did things like that already for years before that.</div><br/></div></div></div></div><div id="42312091" class="c"><input type="checkbox" id="c-42312091" checked=""/><div class="controls bullet"><span class="by">merely-unlikely</span><span>|</span><a href="#42307710">root</a><span>|</span><a href="#42311258">parent</a><span>|</span><a href="#42311505">prev</a><span>|</span><a href="#42312516">next</a><span>|</span><label class="collapse" for="c-42312091">[-]</label><label class="expand" for="c-42312091">[1 more]</label></div><br/><div class="children"><div class="content">Recently I&#x27;ve also been using Axum and HTMX but instead of writing templates I&#x27;ve been using Maud to write the dynamic bits inside the handlers themselves. Then I just serve a static .html file containing everything that can be static with HTMX requests to fetch the rest.<p>The downside is Maud isn&#x27;t proper HTML but the benefit is I can use normal Rust to format my variables, etc into whatever string format I need rather than deal with a constrained templating language. It feels like writing an API that happens to serve HTML instead of JSON.<p>I debate using Askama to avoid the extra requests but there&#x27;s something nice about just serving static HTML files.</div><br/></div></div></div></div><div id="42312516" class="c"><input type="checkbox" id="c-42312516" checked=""/><div class="controls bullet"><span class="by">mattrighetti</span><span>|</span><a href="#42307710">parent</a><span>|</span><a href="#42311258">prev</a><span>|</span><a href="#42309480">next</a><span>|</span><label class="collapse" for="c-42312516">[-]</label><label class="expand" for="c-42312516">[1 more]</label></div><br/><div class="children"><div class="content">I recently shipped a project [0] with a very similar tech stack: Axum + HTMX + Askama. It’s still in beta but it’s incredible how far you can get with just html, css and less than 20 lines of js. Also, can’t beat the beauty of putting a single binary in a systemd service and have your entire frontend + backend ready to go.<p>The only downside that I see is that the binary gets big pretty fast, especially with Askama which basically is a templating engine like Tera but pulls templates at compile time in the binary so you don’t have to copy templates around on your server.<p>I have not worked with SSR a lot before but it seems it’s harder to cache pages too.<p>[0]: <a href="https:&#x2F;&#x2F;ulry.app" rel="nofollow">https:&#x2F;&#x2F;ulry.app</a></div><br/></div></div><div id="42309480" class="c"><input type="checkbox" id="c-42309480" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42307710">parent</a><span>|</span><a href="#42312516">prev</a><span>|</span><a href="#42310735">next</a><span>|</span><label class="collapse" for="c-42309480">[-]</label><label class="expand" for="c-42309480">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love to read some blog posts on your process. Actix never struck me as super easy, at least when I checked it some 2-3 years ago.</div><br/><div id="42310016" class="c"><input type="checkbox" id="c-42310016" checked=""/><div class="controls bullet"><span class="by">bsnnkv</span><span>|</span><a href="#42307710">root</a><span>|</span><a href="#42309480">parent</a><span>|</span><a href="#42310735">next</a><span>|</span><label class="collapse" for="c-42310016">[-]</label><label class="expand" for="c-42310016">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;d highly recommend reading some articles by Luca Palmieri[1], or even buying his book[2]. Although I didn&#x27;t learn this stack by working through his book, whenever I had questions through the years, my searches usually led me to his articles which are often excerpts from the larger book.<p>The high level of API stability and lack of churn in the Actix ecosystem makes the book a particularly good investment for someone looking to settle on this stack in my opinion. In keeping with the topic of this submission, I doubt I&#x27;d be comfortable spending money on a similar book about building web apps with React.<p>[1]: <a href="https:&#x2F;&#x2F;www.lpalmieri.com&#x2F;posts&#x2F;2020-08-09-zero-to-production-3-how-to-bootstrap-a-new-rust-web-api-from-scratch" rel="nofollow">https:&#x2F;&#x2F;www.lpalmieri.com&#x2F;posts&#x2F;2020-08-09-zero-to-productio...</a><p>[2]: <a href="https:&#x2F;&#x2F;www.zero2prod.com" rel="nofollow">https:&#x2F;&#x2F;www.zero2prod.com</a></div><br/><div id="42310346" class="c"><input type="checkbox" id="c-42310346" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42307710">root</a><span>|</span><a href="#42310016">parent</a><span>|</span><a href="#42310735">next</a><span>|</span><label class="collapse" for="c-42310346">[-]</label><label class="expand" for="c-42310346">[3 more]</label></div><br/><div class="children"><div class="content">Super helpful, thank you.<p>My finger is hovering on the &quot;Buy&quot; button but I have to ask: how up to date is the book to the current Actix version &#x2F; API?<p>EDIT: Frak it, I just bought it. :D</div><br/><div id="42311513" class="c"><input type="checkbox" id="c-42311513" checked=""/><div class="controls bullet"><span class="by">bsnnkv</span><span>|</span><a href="#42307710">root</a><span>|</span><a href="#42310346">parent</a><span>|</span><a href="#42310735">next</a><span>|</span><label class="collapse" for="c-42311513">[-]</label><label class="expand" for="c-42311513">[2 more]</label></div><br/><div class="children"><div class="content">For others reading this in the future:<p>&gt; Roughly every three months, the book is updated to keep up with the latest developments in the Rust ecosystem. In particular, we make sure to update all the crates we use in the book to their latest released version. If you bought a copy of the ebook, you can get the latest book revision at any time by redownloading the content from here.</div><br/><div id="42311563" class="c"><input type="checkbox" id="c-42311563" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42307710">root</a><span>|</span><a href="#42311513">parent</a><span>|</span><a href="#42310735">next</a><span>|</span><label class="collapse" for="c-42311563">[-]</label><label class="expand" for="c-42311563">[1 more]</label></div><br/><div class="children"><div class="content">And again for the future readers: do we the buyers get a notification that there&#x27;s an update and we should re-download?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42310735" class="c"><input type="checkbox" id="c-42310735" checked=""/><div class="controls bullet"><span class="by">mock-possum</span><span>|</span><a href="#42307710">parent</a><span>|</span><a href="#42309480">prev</a><span>|</span><a href="#42308316">next</a><span>|</span><label class="collapse" for="c-42310735">[-]</label><label class="expand" for="c-42310735">[5 more]</label></div><br/><div class="children"><div class="content">How have you managed to find work consistently? It seems like everyone is looking for 3-5 years of react specifically as a minimum on most job postings near me. I would love to get away from React, it is really not my favorite to worn with.</div><br/><div id="42311373" class="c"><input type="checkbox" id="c-42311373" checked=""/><div class="controls bullet"><span class="by">bsnnkv</span><span>|</span><a href="#42307710">root</a><span>|</span><a href="#42310735">parent</a><span>|</span><a href="#42311267">next</a><span>|</span><label class="collapse" for="c-42311373">[-]</label><label class="expand" for="c-42311373">[3 more]</label></div><br/><div class="children"><div class="content">I was laid off just before Thanksgiving 2023[1] from a Principal Engineer role on a Platform Engineering team. I was employed there since 2018.<p>I was very lucky to get referrals from a few folks that I social dance with in Seattle after that layoff, and I ended up with a job offer in a product area I knew very little about (networking, routing, programmable packet processing middleware with eBPF etc.)<p>Despite my lack of domain knowledge, I was told I received the offer largely because of my demonstrated proficiency in Rust (I did all the interview whiteboarding sessions in Rust), and although this isn&#x27;t something that is measured &quot;officially&quot; in the interview process, because there are many hours of me live programming online[2] for people to feel confident that they&#x27;re not hiring a dud who has hyper-specialized in passing interviews which are not representative of real-world workloads.<p>I general advise people in your situation to start looking further down the world&#x27;s dependency tree, where things churn less frequently, and where the skills you acquire will last longer. This can be easier said than done, but since my very first job was as a React developer, I can at least share my path down the dependency tree:<p>Frontend (React etc.) -&gt; Backend (web APIs) -&gt; Infrastructure &#x2F; Platform &#x2F; DevOps (started with a cloud automation focus, moved gradually towards to bare metal) -&gt; Networking (I&#x27;m in ur VPCs, directing ur packets)<p>All of this being said, the job market right now is very tough. I doubt I could walk out of this job and into another within 3 months like I did this time last year.<p>[1]: A lot of my technical blog posts on <a href="https:&#x2F;&#x2F;lgug2z.com&#x2F;articles" rel="nofollow">https:&#x2F;&#x2F;lgug2z.com&#x2F;articles</a> around that time refer to this layoff<p>[2]: <a href="https:&#x2F;&#x2F;youtube.com&#x2F;@LGUG2Z" rel="nofollow">https:&#x2F;&#x2F;youtube.com&#x2F;@LGUG2Z</a></div><br/><div id="42312086" class="c"><input type="checkbox" id="c-42312086" checked=""/><div class="controls bullet"><span class="by">phist_mcgee</span><span>|</span><a href="#42307710">root</a><span>|</span><a href="#42311373">parent</a><span>|</span><a href="#42312076">next</a><span>|</span><label class="collapse" for="c-42312086">[-]</label><label class="expand" for="c-42312086">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I general advise people in your situation to start looking further down the world&#x27;s dependency tree, where things churn less frequently, and where the skills you acquire will last longer.<p>I actually don&#x27;t agree, being &quot;further down&quot; the dependency tree, the more likely you are to be exposed to new concepts and stay agile as a developer. I moved from a backend .NET background into frontend and have found the faster pace more refreshing with the evolving web and mobile platforms. Staying with .NET would have had me writing the same EF code over and over in almost a time capsule, at least talking to old colleagues.<p>I feel like i&#x27;m more valuable now, because i&#x27;ve been through a few tech stacks and understand the benefits and drawbacks of each.</div><br/></div></div></div></div><div id="42311267" class="c"><input type="checkbox" id="c-42311267" checked=""/><div class="controls bullet"><span class="by">RapperWhoMadeIt</span><span>|</span><a href="#42307710">root</a><span>|</span><a href="#42310735">parent</a><span>|</span><a href="#42311373">prev</a><span>|</span><a href="#42308316">next</a><span>|</span><label class="collapse" for="c-42311267">[-]</label><label class="expand" for="c-42311267">[1 more]</label></div><br/><div class="children"><div class="content">Hi, author here. 
At least from my personal experience, there are still many jobs in which the main focus isn&#x27;t frontend development, and per se React.<p>I do have to work with React from time to time. But it isn&#x27;t my main focus. I usually work implementing backend systems (with Go, SQL [Postgres], Redis, etc.) and infrastructure as code with Terraform.</div><br/></div></div></div></div></div></div><div id="42308316" class="c"><input type="checkbox" id="c-42308316" checked=""/><div class="controls bullet"><span class="by">erikpukinskis</span><span>|</span><a href="#42307710">prev</a><span>|</span><a href="#42308756">next</a><span>|</span><label class="collapse" for="c-42308316">[-]</label><label class="expand" for="c-42308316">[26 more]</label></div><br/><div class="children"><div class="content">Tanner builds libraries with a huge amount of functionality. But IMO he is not great at API design. His packages often have leaky abstractions which need to be patched over time.<p>React Table and React Query are powerful but end up simultaneously doing too much and not doing enough, because their boundaries are in the wrong place.<p>What’s wonderful about React is that it’s _not_ a framework. It does one thing well, and then stops at a well thought out, well documented, well tested boundary.<p>I try to only adopt libraries that also meet that standard. It means you have a lot fewer libraries you can lean on, but it means the API surface you build on will be more stable for longer.</div><br/><div id="42308342" class="c"><input type="checkbox" id="c-42308342" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#42308316">parent</a><span>|</span><a href="#42314913">next</a><span>|</span><label class="collapse" for="c-42308342">[-]</label><label class="expand" for="c-42308342">[6 more]</label></div><br/><div class="children"><div class="content">&gt; It does one thing well<p>I&#x27;d love to know what that is and I&#x27;m a long term React user myself.</div><br/><div id="42308380" class="c"><input type="checkbox" id="c-42308380" checked=""/><div class="controls bullet"><span class="by">jeffmcmahan</span><span>|</span><a href="#42308316">root</a><span>|</span><a href="#42308342">parent</a><span>|</span><a href="#42308998">next</a><span>|</span><label class="collapse" for="c-42308380">[-]</label><label class="expand" for="c-42308380">[3 more]</label></div><br/><div class="children"><div class="content">It maps state to a set of reasonably efficient DOM updates that you generally don&#x27;t have to manage or think about.<p>Go play around with Angular 1, or BackboneJS, or try building a working SPA with jQuery, and you&#x27;ll get a sense of the breakthrough that react represented in 2013.</div><br/><div id="42308753" class="c"><input type="checkbox" id="c-42308753" checked=""/><div class="controls bullet"><span class="by">aniforprez</span><span>|</span><a href="#42308316">root</a><span>|</span><a href="#42308380">parent</a><span>|</span><a href="#42310339">next</a><span>|</span><label class="collapse" for="c-42308753">[-]</label><label class="expand" for="c-42308753">[1 more]</label></div><br/><div class="children"><div class="content">I worked with AngularJS back in 2014-15 and it was hell. We used to regularly have accidental performance dips because of the way it reacted to changes in values. IIRC it used to do two scans of all variables in all the controllers on many browser events, one for checking if something had changed and updating everything else and one for checking if the previous check changed anything that would require further updates. I don&#x27;t remember the specifics now cause it&#x27;s been so long but it got really costly really fast for complex applications (we were building real time WebRTC telephony interfaces). React was so much better because it came with restrictions on what changes were being checked and Angular was a total rewrite in Typescript with heavy performance improvements over AngularJS. The virtual DOM stuff truly was a revelation over everything everyone else was doing at the time.</div><br/></div></div><div id="42310339" class="c"><input type="checkbox" id="c-42310339" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#42308316">root</a><span>|</span><a href="#42308380">parent</a><span>|</span><a href="#42308753">prev</a><span>|</span><a href="#42308998">next</a><span>|</span><label class="collapse" for="c-42310339">[-]</label><label class="expand" for="c-42310339">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Go play around with Angular 1, or BackboneJS, or try building a working SPA with jQuery<p>I have used these in production (and mootools, prototype, and many more) and when these came out they were novel &#x2F; a breakthrough as well at the time.<p>My point being is React is no longer a simple transform from state -&gt; UI. Since fibers and concurrent rendering and suspense and server components and hooks and actions it is a much wider framework than you are remembering from 2012.</div><br/></div></div></div></div><div id="42308998" class="c"><input type="checkbox" id="c-42308998" checked=""/><div class="controls bullet"><span class="by">whoknowsidont</span><span>|</span><a href="#42308316">root</a><span>|</span><a href="#42308342">parent</a><span>|</span><a href="#42308380">prev</a><span>|</span><a href="#42314913">next</a><span>|</span><label class="collapse" for="c-42308998">[-]</label><label class="expand" for="c-42308998">[2 more]</label></div><br/><div class="children"><div class="content">&gt;I&#x27;m a long term React user myself.<p>Clearly not long enough.</div><br/><div id="42310281" class="c"><input type="checkbox" id="c-42310281" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#42308316">root</a><span>|</span><a href="#42308998">parent</a><span>|</span><a href="#42314913">next</a><span>|</span><label class="collapse" for="c-42310281">[-]</label><label class="expand" for="c-42310281">[1 more]</label></div><br/><div class="children"><div class="content">The point being that it has gotten too complicated and no longer does any one thing well.<p>Hooks, actions, server vs client components, the switch from class components to functional, the fad of HOC and render functions.<p>React today is not the same React I started with.</div><br/></div></div></div></div></div></div><div id="42314913" class="c"><input type="checkbox" id="c-42314913" checked=""/><div class="controls bullet"><span class="by">nosefurhairdo</span><span>|</span><a href="#42308316">parent</a><span>|</span><a href="#42308342">prev</a><span>|</span><a href="#42308345">next</a><span>|</span><label class="collapse" for="c-42314913">[-]</label><label class="expand" for="c-42314913">[1 more]</label></div><br/><div class="children"><div class="content">Query&#x27;s boundaries are in the wrong place? Can you elaborate?</div><br/></div></div><div id="42308345" class="c"><input type="checkbox" id="c-42308345" checked=""/><div class="controls bullet"><span class="by">jeffmcmahan</span><span>|</span><a href="#42308316">parent</a><span>|</span><a href="#42314913">prev</a><span>|</span><a href="#42308747">next</a><span>|</span><label class="collapse" for="c-42308345">[-]</label><label class="expand" for="c-42308345">[1 more]</label></div><br/><div class="children"><div class="content">This. Lean on less. I use react and a SQL driver. I have many massive react projects in production.</div><br/></div></div><div id="42308747" class="c"><input type="checkbox" id="c-42308747" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#42308316">parent</a><span>|</span><a href="#42308345">prev</a><span>|</span><a href="#42308936">next</a><span>|</span><label class="collapse" for="c-42308747">[-]</label><label class="expand" for="c-42308747">[11 more]</label></div><br/><div class="children"><div class="content">Not really, React doesn&#x27;t do &quot;one thing [well]&quot;, it&#x27;s responsible for:<p>- UI rendering<p>- State management<p>- Component lifecycle<p>- Event handling<p>- Data flow<p>- JSX templating<p>In that sense React truly is a comprehensive UI framework, not a single-purpose library.
Counter-examples of &quot;do one thing well&quot; are Lodash and Axios.</div><br/><div id="42308886" class="c"><input type="checkbox" id="c-42308886" checked=""/><div class="controls bullet"><span class="by">dmkolobov</span><span>|</span><a href="#42308316">root</a><span>|</span><a href="#42308747">parent</a><span>|</span><a href="#42312849">next</a><span>|</span><label class="collapse" for="c-42308886">[-]</label><label class="expand" for="c-42308886">[1 more]</label></div><br/><div class="children"><div class="content">I’d say all of those bullets fall under the umbrella of “rendering” in an asynchronous execution environment like browsers, where code often depends on a consistent and predictable view of the DOM.<p>I’m willing to hear arguments about the merits of how React approaches these issues, but I would want any frontend UI library for generating and updating DOM trees to address them in <i>some</i> way.</div><br/></div></div><div id="42312849" class="c"><input type="checkbox" id="c-42312849" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#42308316">root</a><span>|</span><a href="#42308747">parent</a><span>|</span><a href="#42308886">prev</a><span>|</span><a href="#42309433">next</a><span>|</span><label class="collapse" for="c-42312849">[-]</label><label class="expand" for="c-42312849">[5 more]</label></div><br/><div class="children"><div class="content">Disagree. State management is an anti feature in react and you don’t need JSX to use react.<p>It’s only true feature is the view = func(state), everything else should be outsourced to something else.</div><br/><div id="42313937" class="c"><input type="checkbox" id="c-42313937" checked=""/><div class="controls bullet"><span class="by">molszanski</span><span>|</span><a href="#42308316">root</a><span>|</span><a href="#42312849">parent</a><span>|</span><a href="#42309433">next</a><span>|</span><label class="collapse" for="c-42313937">[-]</label><label class="expand" for="c-42313937">[4 more]</label></div><br/><div class="children"><div class="content">Yup. Don&#x27;t use react for state or some hook spaghetti like react query. Use mobx and live happily ever after :)</div><br/><div id="42313986" class="c"><input type="checkbox" id="c-42313986" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#42308316">root</a><span>|</span><a href="#42313937">parent</a><span>|</span><a href="#42309433">next</a><span>|</span><label class="collapse" for="c-42313986">[-]</label><label class="expand" for="c-42313986">[3 more]</label></div><br/><div class="children"><div class="content">Exactly. Although I would go with starfx instead</div><br/><div id="42314036" class="c"><input type="checkbox" id="c-42314036" checked=""/><div class="controls bullet"><span class="by">molszanski</span><span>|</span><a href="#42308316">root</a><span>|</span><a href="#42313986">parent</a><span>|</span><a href="#42315269">next</a><span>|</span><label class="collapse" for="c-42314036">[-]</label><label class="expand" for="c-42314036">[1 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t know about starfx. Interesting.<p>To anyone reading, mobx is a more generic tool for any type of state management.<p>And starfx seems like a data fetching + holding state and providing hooks for that data kind of library. Very unique and looks someone cared to make something nice for that kind of problem</div><br/></div></div><div id="42315269" class="c"><input type="checkbox" id="c-42315269" checked=""/><div class="controls bullet"><span class="by">neoconomist</span><span>|</span><a href="#42308316">root</a><span>|</span><a href="#42313986">parent</a><span>|</span><a href="#42314036">prev</a><span>|</span><a href="#42309433">next</a><span>|</span><label class="collapse" for="c-42315269">[-]</label><label class="expand" for="c-42315269">[1 more]</label></div><br/><div class="children"><div class="content">starfx looks interesting and innovative ! thanks for sharing</div><br/></div></div></div></div></div></div></div></div><div id="42309433" class="c"><input type="checkbox" id="c-42309433" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#42308316">root</a><span>|</span><a href="#42308747">parent</a><span>|</span><a href="#42312849">prev</a><span>|</span><a href="#42309777">next</a><span>|</span><label class="collapse" for="c-42309433">[-]</label><label class="expand" for="c-42309433">[1 more]</label></div><br/><div class="children"><div class="content">State management is typically handled by other libraries. React can do it, but it&#x27;s not great for a full app.  Maybe &quot;data flow&quot; too, not really sure what makes that different from &quot;state management&quot;.</div><br/></div></div><div id="42309777" class="c"><input type="checkbox" id="c-42309777" checked=""/><div class="controls bullet"><span class="by">darepublic</span><span>|</span><a href="#42308316">root</a><span>|</span><a href="#42308747">parent</a><span>|</span><a href="#42309433">prev</a><span>|</span><a href="#42309080">next</a><span>|</span><label class="collapse" for="c-42309777">[-]</label><label class="expand" for="c-42309777">[1 more]</label></div><br/><div class="children"><div class="content">Lodash does a hundred different things and then people start using it in place of super simple code or native capabilities ballooning the third party API you need to learn</div><br/></div></div><div id="42309080" class="c"><input type="checkbox" id="c-42309080" checked=""/><div class="controls bullet"><span class="by">ambicapter</span><span>|</span><a href="#42308316">root</a><span>|</span><a href="#42308747">parent</a><span>|</span><a href="#42309777">prev</a><span>|</span><a href="#42308936">next</a><span>|</span><label class="collapse" for="c-42309080">[-]</label><label class="expand" for="c-42309080">[2 more]</label></div><br/><div class="children"><div class="content">lodash is a utility library (so chock-full of functionality) how can you say it &quot;does one thing well&quot;?</div><br/><div id="42312322" class="c"><input type="checkbox" id="c-42312322" checked=""/><div class="controls bullet"><span class="by">grodriguez100</span><span>|</span><a href="#42308316">root</a><span>|</span><a href="#42309080">parent</a><span>|</span><a href="#42308936">next</a><span>|</span><label class="collapse" for="c-42312322">[-]</label><label class="expand" for="c-42312322">[1 more]</label></div><br/><div class="children"><div class="content">He actually says it is a <i>counter-example</i> of “does one thing well”.</div><br/></div></div></div></div></div></div><div id="42308936" class="c"><input type="checkbox" id="c-42308936" checked=""/><div class="controls bullet"><span class="by">jrochkind1</span><span>|</span><a href="#42308316">parent</a><span>|</span><a href="#42308747">prev</a><span>|</span><a href="#42309157">next</a><span>|</span><label class="collapse" for="c-42308936">[-]</label><label class="expand" for="c-42308936">[5 more]</label></div><br/><div class="children"><div class="content">Who is Tanner?</div><br/><div id="42308996" class="c"><input type="checkbox" id="c-42308996" checked=""/><div class="controls bullet"><span class="by">ggregoire</span><span>|</span><a href="#42308316">root</a><span>|</span><a href="#42308936">parent</a><span>|</span><a href="#42309157">next</a><span>|</span><label class="collapse" for="c-42308996">[-]</label><label class="expand" for="c-42308996">[4 more]</label></div><br/><div class="children"><div class="content">The developer making react-query (one of the libraries mentioned in the article).<p><a href="https:&#x2F;&#x2F;tanstack.com&#x2F;query&#x2F;latest&#x2F;docs" rel="nofollow">https:&#x2F;&#x2F;tanstack.com&#x2F;query&#x2F;latest&#x2F;docs</a></div><br/><div id="42309320" class="c"><input type="checkbox" id="c-42309320" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#42308316">root</a><span>|</span><a href="#42308996">parent</a><span>|</span><a href="#42309157">next</a><span>|</span><label class="collapse" for="c-42309320">[-]</label><label class="expand" for="c-42309320">[3 more]</label></div><br/><div class="children"><div class="content">Also react-router, which I found to be way too overcomplicated and would duplicate functionality I was handling in other ways.  IIRC last major release was also not backwards compatible, and made some odd decisions in the design.  Funny enough I went with wouter (which the post also complains about) instead:  Simple, focused, does one thing well, doesn&#x27;t try to be multiple things.  I don&#x27;t recall anything about its major updates though.</div><br/><div id="42309421" class="c"><input type="checkbox" id="c-42309421" checked=""/><div class="controls bullet"><span class="by">ggregoire</span><span>|</span><a href="#42308316">root</a><span>|</span><a href="#42309320">parent</a><span>|</span><a href="#42309157">next</a><span>|</span><label class="collapse" for="c-42309421">[-]</label><label class="expand" for="c-42309421">[2 more]</label></div><br/><div class="children"><div class="content">Tanner never worked on react-router: <a href="https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;react-router&#x2F;commits&#x2F;main&#x2F;?author=tannerlinsley">https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;react-router&#x2F;commits&#x2F;main&#x2F;?auth...</a></div><br/><div id="42309808" class="c"><input type="checkbox" id="c-42309808" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#42308316">root</a><span>|</span><a href="#42309421">parent</a><span>|</span><a href="#42309157">next</a><span>|</span><label class="collapse" for="c-42309808">[-]</label><label class="expand" for="c-42309808">[1 more]</label></div><br/><div class="children"><div class="content">Sorry yeah, I got the names mixed up.  I recognized the documentation, and I do mean tanstack router with my description above.  I don&#x27;t remember why I didn&#x27;t use react-router, but skimming over its documentation I think it may have been the focus on the odd non-React-y way of doing things ( <a href="https:&#x2F;&#x2F;reactrouter.com&#x2F;start&#x2F;framework&#x2F;routing" rel="nofollow">https:&#x2F;&#x2F;reactrouter.com&#x2F;start&#x2F;framework&#x2F;routing</a> ).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42309157" class="c"><input type="checkbox" id="c-42309157" checked=""/><div class="controls bullet"><span class="by">tharmas</span><span>|</span><a href="#42308316">parent</a><span>|</span><a href="#42308936">prev</a><span>|</span><a href="#42308756">next</a><span>|</span><label class="collapse" for="c-42309157">[-]</label><label class="expand" for="c-42309157">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I try to only adopt libraries that also meet that standard.<p>Can you share what those libraries are? Not to critique your choice but to actually use.</div><br/></div></div></div></div><div id="42308756" class="c"><input type="checkbox" id="c-42308756" checked=""/><div class="controls bullet"><span class="by">causal</span><span>|</span><a href="#42308316">prev</a><span>|</span><a href="#42307626">next</a><span>|</span><label class="collapse" for="c-42308756">[-]</label><label class="expand" for="c-42308756">[17 more]</label></div><br/><div class="children"><div class="content">I always feel like these HTMX examples just shift complexity to other parts of the stack. JSX is a really elegant way to avoid templating, but we&#x27;re back to templating with HTMX, and you can easily reintroduce a complex set of libraries just trying to handle that with any scale.<p>Routing, state management, auth, components, theming, API access, and more are all still problems that people add libraries for and those problems don&#x27;t go away just because you&#x27;ve abandoned the ecosystem with the most libraries.</div><br/><div id="42309050" class="c"><input type="checkbox" id="c-42309050" checked=""/><div class="controls bullet"><span class="by">WorldMaker</span><span>|</span><a href="#42308756">parent</a><span>|</span><a href="#42314240">next</a><span>|</span><label class="collapse" for="c-42309050">[-]</label><label class="expand" for="c-42309050">[6 more]</label></div><br/><div class="children"><div class="content">I feel like a lot of the arguments for HTMX are simply delight in having &quot;permission&quot; to build MPAs again. Backend stacks are historically good at routing&#x2F;state management&#x2F;auth and more, everything old is new again. But also, yes, not everything needs to be a SPA and maybe we&#x27;ve just reached the point to start asking again &quot;why is this a SPA?&quot;<p>&gt; JSX is a really elegant way to avoid templating<p>JSX is still a templating language. It&#x27;s just an &quot;inverted one&quot; where the templates are embedded in scripts rather than the other way around. That said, I do think it is a very elegant templating system, especially because it can be type checked with Typescript. TSX is a massive improvement on most template compilers in part because it has such a massive types ecosystem today.<p>(My own efforts in &quot;post-React&quot;&#x2F;&quot;post-Angular&quot; have been TSX-based. I&#x27;ve got a Knockout-inspired view engine with a single runtime dependency on RxJS. It has a developer experience similar to React, but isn&#x27;t a virtual DOM, and has some some interesting tricks up its sleeve. I&#x27;m really happy with TSX as the template language for it.)</div><br/><div id="42309085" class="c"><input type="checkbox" id="c-42309085" checked=""/><div class="controls bullet"><span class="by">causal</span><span>|</span><a href="#42308756">root</a><span>|</span><a href="#42309050">parent</a><span>|</span><a href="#42312875">next</a><span>|</span><label class="collapse" for="c-42309085">[-]</label><label class="expand" for="c-42309085">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. I also think React did the world a favor by making functional programming a little more mainstream, which is part of what makes JSX&#x2F;TSX feel so magical when it works.</div><br/></div></div><div id="42312875" class="c"><input type="checkbox" id="c-42312875" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#42308756">root</a><span>|</span><a href="#42309050">parent</a><span>|</span><a href="#42309085">prev</a><span>|</span><a href="#42311588">next</a><span>|</span><label class="collapse" for="c-42312875">[-]</label><label class="expand" for="c-42312875">[2 more]</label></div><br/><div class="children"><div class="content">Agreed. When you just need a tiny bit of interactivity I can see the value in htmx. However, leveraging html as a dsl is bound to be limiting</div><br/><div id="42312977" class="c"><input type="checkbox" id="c-42312977" checked=""/><div class="controls bullet"><span class="by">recursivedoubts</span><span>|</span><a href="#42308756">root</a><span>|</span><a href="#42312875">parent</a><span>|</span><a href="#42311588">next</a><span>|</span><label class="collapse" for="c-42312977">[-]</label><label class="expand" for="c-42312977">[1 more]</label></div><br/><div class="children"><div class="content">here&#x27;s an example of a fairly interactive site that switched to htmx with significant savings:<p><a href="https:&#x2F;&#x2F;htmx.org&#x2F;essays&#x2F;a-real-world-react-to-htmx-port&#x2F;" rel="nofollow">https:&#x2F;&#x2F;htmx.org&#x2F;essays&#x2F;a-real-world-react-to-htmx-port&#x2F;</a><p>htmx triggers and responds to events, which can be used to integrate it into more interactive experiences, e.g.<p><a href="https:&#x2F;&#x2F;htmx.org&#x2F;examples&#x2F;sortable&#x2F;" rel="nofollow">https:&#x2F;&#x2F;htmx.org&#x2F;examples&#x2F;sortable&#x2F;</a></div><br/></div></div></div></div><div id="42311588" class="c"><input type="checkbox" id="c-42311588" checked=""/><div class="controls bullet"><span class="by">jakubmazanec</span><span>|</span><a href="#42308756">root</a><span>|</span><a href="#42309050">parent</a><span>|</span><a href="#42312875">prev</a><span>|</span><a href="#42314240">next</a><span>|</span><label class="collapse" for="c-42311588">[-]</label><label class="expand" for="c-42311588">[2 more]</label></div><br/><div class="children"><div class="content">&gt; JSX is still a templating language<p>No, it isn&#x27;t a templating language, it&#x27;s still just JavaScript - calls to createElement or _jsx or other function with some syntactic sugar to make it look like HTML.</div><br/><div id="42313161" class="c"><input type="checkbox" id="c-42313161" checked=""/><div class="controls bullet"><span class="by">svachalek</span><span>|</span><a href="#42308756">root</a><span>|</span><a href="#42311588">parent</a><span>|</span><a href="#42314240">next</a><span>|</span><label class="collapse" for="c-42313161">[-]</label><label class="expand" for="c-42313161">[1 more]</label></div><br/><div class="children"><div class="content">&gt; with some syntactic sugar<p>isn&#x27;t that what a templating language is?</div><br/></div></div></div></div></div></div><div id="42314240" class="c"><input type="checkbox" id="c-42314240" checked=""/><div class="controls bullet"><span class="by">yawaramin</span><span>|</span><a href="#42308756">parent</a><span>|</span><a href="#42309050">prev</a><span>|</span><a href="#42308877">next</a><span>|</span><label class="collapse" for="c-42314240">[-]</label><label class="expand" for="c-42314240">[1 more]</label></div><br/><div class="children"><div class="content">&gt; JSX is a really elegant way to avoid templating, but we&#x27;re back to templating with HTMX<p>Not necessarily. There are libraries in all mainstream languages that let you embed HTML generation directly in your backend server itself, without using a templating engine. Some examples:<p>Python: <a href="https:&#x2F;&#x2F;htpy.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;htpy.dev&#x2F;</a><p>Scala: <a href="https:&#x2F;&#x2F;com-lihaoyi.github.io&#x2F;scalatags&#x2F;" rel="nofollow">https:&#x2F;&#x2F;com-lihaoyi.github.io&#x2F;scalatags&#x2F;</a><p>OCaml: <a href="https:&#x2F;&#x2F;yawaramin.github.io&#x2F;dream-html&#x2F;" rel="nofollow">https:&#x2F;&#x2F;yawaramin.github.io&#x2F;dream-html&#x2F;</a> (that&#x27;s mine)<p>&gt; Routing, state management, auth, components, theming, API access, and more are all still problems that people add libraries for and those problems don&#x27;t go away<p>Actually they kinda do go away. Have you ever tried Ruby on Rails? It does all this out of the box.</div><br/></div></div><div id="42308877" class="c"><input type="checkbox" id="c-42308877" checked=""/><div class="controls bullet"><span class="by">recursivedoubts</span><span>|</span><a href="#42308756">parent</a><span>|</span><a href="#42314240">prev</a><span>|</span><a href="#42308950">next</a><span>|</span><label class="collapse" for="c-42308877">[-]</label><label class="expand" for="c-42308877">[3 more]</label></div><br/><div class="children"><div class="content">You do collapse an implementation layer by using HATEOAS[1], which can save overall complexity in the system:<p><a href="https:&#x2F;&#x2F;htmx.org&#x2F;essays&#x2F;a-real-world-react-to-htmx-port&#x2F;" rel="nofollow">https:&#x2F;&#x2F;htmx.org&#x2F;essays&#x2F;a-real-world-react-to-htmx-port&#x2F;</a><p>It&#x27;s mainly an interactivity&#x2F;simplicity tradeoff, sometimes the right trade other times not.  A lot of people are using JSX on the server side w&#x2F;htmx because it&#x27;s a good and familiar templating option on the server side.<p>[1] - <a href="https:&#x2F;&#x2F;htmx.org&#x2F;essays&#x2F;hateoas&#x2F;" rel="nofollow">https:&#x2F;&#x2F;htmx.org&#x2F;essays&#x2F;hateoas&#x2F;</a></div><br/><div id="42309029" class="c"><input type="checkbox" id="c-42309029" checked=""/><div class="controls bullet"><span class="by">causal</span><span>|</span><a href="#42308756">root</a><span>|</span><a href="#42308877">parent</a><span>|</span><a href="#42308950">next</a><span>|</span><label class="collapse" for="c-42309029">[-]</label><label class="expand" for="c-42309029">[2 more]</label></div><br/><div class="children"><div class="content">Wait did I just get a response from Carson himself? :)<p>Though my comment belies it I&#x27;m a big fan of the work - I started following Intercooler a decade ago and I&#x27;m happy to see how far things have come.<p>I&#x27;m curious about HTMX + JSX, any recommended examples there?</div><br/><div id="42309177" class="c"><input type="checkbox" id="c-42309177" checked=""/><div class="controls bullet"><span class="by">recursivedoubts</span><span>|</span><a href="#42308756">root</a><span>|</span><a href="#42309029">parent</a><span>|</span><a href="#42308950">next</a><span>|</span><label class="collapse" for="c-42309177">[-]</label><label class="expand" for="c-42309177">[1 more]</label></div><br/><div class="children"><div class="content">:) hono has a demo using it:<p><a href="https:&#x2F;&#x2F;hono.dev&#x2F;examples&#x2F;htmx" rel="nofollow">https:&#x2F;&#x2F;hono.dev&#x2F;examples&#x2F;htmx</a></div><br/></div></div></div></div></div></div><div id="42308950" class="c"><input type="checkbox" id="c-42308950" checked=""/><div class="controls bullet"><span class="by">dsego</span><span>|</span><a href="#42308756">parent</a><span>|</span><a href="#42308877">prev</a><span>|</span><a href="#42308813">next</a><span>|</span><label class="collapse" for="c-42308950">[-]</label><label class="expand" for="c-42308950">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Routing, state management, auth, components, theming, API access, and more are all still problems that people add libraries for<p>A lot of this goes away if you choose a server-side framework that handles its own routing, auth, api, templates etc. And the state management also goes away if you don&#x27;t need complex stateful widgets on the frontend.</div><br/><div id="42309180" class="c"><input type="checkbox" id="c-42309180" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#42308756">root</a><span>|</span><a href="#42308950">parent</a><span>|</span><a href="#42308813">next</a><span>|</span><label class="collapse" for="c-42309180">[-]</label><label class="expand" for="c-42309180">[3 more]</label></div><br/><div class="children"><div class="content">&gt; And the state management also goes away if you don&#x27;t need complex stateful widgets on the frontend.<p>Browsers come with a very limited selection of widgets, almost everything I make requires at least one custom widget, usually significantly more than one. How can you possibly know when you start a project that you won&#x27;t need to make any complex stateful widgets?</div><br/><div id="42309492" class="c"><input type="checkbox" id="c-42309492" checked=""/><div class="controls bullet"><span class="by">wild_egg</span><span>|</span><a href="#42308756">root</a><span>|</span><a href="#42309180">parent</a><span>|</span><a href="#42311919">next</a><span>|</span><label class="collapse" for="c-42309492">[-]</label><label class="expand" for="c-42309492">[1 more]</label></div><br/><div class="children"><div class="content">If they really are that complex, then use react for them. One of the biggest issues I have always had with react proponents is the &quot;well if I need react for X then I might as well build the whole thing in react.&quot;<p>Islands Architecture is really not complicated. The bulk of your app can be very simple hypermedia exchanges and components and when you need a really fancy widget, load it and mount it where it needs to be.</div><br/></div></div><div id="42311919" class="c"><input type="checkbox" id="c-42311919" checked=""/><div class="controls bullet"><span class="by">JamesBarney</span><span>|</span><a href="#42308756">root</a><span>|</span><a href="#42309180">parent</a><span>|</span><a href="#42309492">prev</a><span>|</span><a href="#42308813">next</a><span>|</span><label class="collapse" for="c-42311919">[-]</label><label class="expand" for="c-42311919">[1 more]</label></div><br/><div class="children"><div class="content">You can build a complex stateful widget in a MPA.</div><br/></div></div></div></div></div></div><div id="42308813" class="c"><input type="checkbox" id="c-42308813" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#42308756">parent</a><span>|</span><a href="#42308950">prev</a><span>|</span><a href="#42310402">next</a><span>|</span><label class="collapse" for="c-42308813">[-]</label><label class="expand" for="c-42308813">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t even know what problem this author has with React and how switching to HTMX is going to help them (after reading the article twice).<p>&gt; Some of the worst offenders in this respect were wouter (a React router package) and TanStackQuery (which I was using to fetch, cache and manage state from the backend).<p>Ok so don&#x27;t use wouter and TanStackQuery...?</div><br/></div></div><div id="42310402" class="c"><input type="checkbox" id="c-42310402" checked=""/><div class="controls bullet"><span class="by">mekoka</span><span>|</span><a href="#42308756">parent</a><span>|</span><a href="#42308813">prev</a><span>|</span><a href="#42307626">next</a><span>|</span><label class="collapse" for="c-42310402">[-]</label><label class="expand" for="c-42310402">[1 more]</label></div><br/><div class="children"><div class="content">For the past 4 years, most objections to HTMX have come in the form of your comment. A look from afar, trying to speculate on what development must be like.<p>After 4 years of mature devs taking it for a spin and reporting back with a thumb up, maybe it&#x27;s best to try to actually use it in a project of your own and see how close your predictions match reality.<p>Perhaps you even have experience with it of course. In which case, it&#x27;d be interesting&#x2F;useful to voice your objections more specifically.</div><br/></div></div></div></div><div id="42307626" class="c"><input type="checkbox" id="c-42307626" checked=""/><div class="controls bullet"><span class="by">schwartzworld</span><span>|</span><a href="#42308756">prev</a><span>|</span><a href="#42311746">next</a><span>|</span><label class="collapse" for="c-42307626">[-]</label><label class="expand" for="c-42307626">[21 more]</label></div><br/><div class="children"><div class="content">It’s a little weird to say you’re ditching React, when your issues are not with React but other dependencies you’ve adopted. The choice to write a backend in Go that handles routing was always there.</div><br/><div id="42308311" class="c"><input type="checkbox" id="c-42308311" checked=""/><div class="controls bullet"><span class="by">azemetre</span><span>|</span><a href="#42307626">parent</a><span>|</span><a href="#42307743">next</a><span>|</span><label class="collapse" for="c-42308311">[-]</label><label class="expand" for="c-42308311">[13 more]</label></div><br/><div class="children"><div class="content">That&#x27;s fair but react forces you into the npm mentality hard on choosing random libraries that are often abandoned, don&#x27;t have licenses, and a myriad of other issues other people have mentioned.<p>I&#x27;m dealing with a massive migration at my job where the schism between libraries going from node-sass to dart-sass caused something as simple as just updating bootstrap versions into a year long effort of having to move a dozen core libraries to their latest versions simultaneously with the result being what? It&#x27;s not like our product will be significantly faster or gain some new features, all we get is our app not breaking because the deps shit the bed.<p>I think the lessons we can learn from the frontend community is that not having a robust standard library is a failure of javascript and this problem will persist until we stop caring about backwards compatibility.<p>Will we as software engineers continue having discussions about supporting browsers from 1990 in the year 3025? I hope not, because bad decisions were made then and they have been compounded since.<p>edit: clarity</div><br/><div id="42309769" class="c"><input type="checkbox" id="c-42309769" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#42307626">root</a><span>|</span><a href="#42308311">parent</a><span>|</span><a href="#42308467">next</a><span>|</span><label class="collapse" for="c-42309769">[-]</label><label class="expand" for="c-42309769">[1 more]</label></div><br/><div class="children"><div class="content">I hope &quot;react forces you into the npm mentality hard on choosing random libraries...&quot; isn&#x27;t true. I&#x27;m just getting into a side-project using Vue and Vuetify components but not planning on using much else than commercial third-parties (which admittedly have free plans that I&#x27;m currently using).</div><br/></div></div><div id="42308467" class="c"><input type="checkbox" id="c-42308467" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42307626">root</a><span>|</span><a href="#42308311">parent</a><span>|</span><a href="#42309769">prev</a><span>|</span><a href="#42308646">next</a><span>|</span><label class="collapse" for="c-42308467">[-]</label><label class="expand" for="c-42308467">[4 more]</label></div><br/><div class="children"><div class="content">I have grown scared to look at OpenAPI and related technologies, for fear that I will find the same problems there.<p>I don&#x27;t think &quot;not caring about backwards compatibility&quot; is the issue, though?  Quite the contrary, constantly forcing migrations because things have changed hurts far more.</div><br/><div id="42314258" class="c"><input type="checkbox" id="c-42314258" checked=""/><div class="controls bullet"><span class="by">yawaramin</span><span>|</span><a href="#42307626">root</a><span>|</span><a href="#42308467">parent</a><span>|</span><a href="#42308646">next</a><span>|</span><label class="collapse" for="c-42314258">[-]</label><label class="expand" for="c-42314258">[3 more]</label></div><br/><div class="children"><div class="content">OpenAPI is a JSON API specification system. It doesn&#x27;t have any hard dependency on the npm ecosystem.</div><br/><div id="42314631" class="c"><input type="checkbox" id="c-42314631" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42307626">root</a><span>|</span><a href="#42314258">parent</a><span>|</span><a href="#42308646">next</a><span>|</span><label class="collapse" for="c-42314631">[-]</label><label class="expand" for="c-42314631">[2 more]</label></div><br/><div class="children"><div class="content">Fair that it isn&#x27;t just a JavaScript thing, but have you tried looking at the various options out there supposed to help implement with it?  Either as a client or as implementation. 
Many are abandoned.  None seem to support AWS as a target.<p>Really is wsdl all over again.</div><br/><div id="42314750" class="c"><input type="checkbox" id="c-42314750" checked=""/><div class="controls bullet"><span class="by">yawaramin</span><span>|</span><a href="#42307626">root</a><span>|</span><a href="#42314631">parent</a><span>|</span><a href="#42308646">next</a><span>|</span><label class="collapse" for="c-42314750">[-]</label><label class="expand" for="c-42314750">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. That&#x27;s how huge sprawling multi-language projects typically work. People who are interested in specific stacks maintain the code generation for those stacks. Stacks which are inherently less popular receive less attention in the OpenAPI ecosystem as well. It&#x27;s very similar with Protobuf, Thrift, etc. There&#x27;s no magic wand to automatically maintain the codegen for all stacks.<p>Also not sure how OpenAPI is supposed to support AWS as a target. Do you mean that AWS doesn&#x27;t support OpenAPI specs for their JSON HTTP services? Pretty sure that&#x27;s because they use Smithy: <a href="https:&#x2F;&#x2F;smithy.io&#x2F;2.0&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;smithy.io&#x2F;2.0&#x2F;index.html</a></div><br/></div></div></div></div></div></div></div></div><div id="42308646" class="c"><input type="checkbox" id="c-42308646" checked=""/><div class="controls bullet"><span class="by">causal</span><span>|</span><a href="#42307626">root</a><span>|</span><a href="#42308311">parent</a><span>|</span><a href="#42308467">prev</a><span>|</span><a href="#42307743">next</a><span>|</span><label class="collapse" for="c-42308646">[-]</label><label class="expand" for="c-42308646">[7 more]</label></div><br/><div class="children"><div class="content">You also don&#x27;t have to choose any of those random NPM libraries, React can stand on its own. Adopting a new technology without any of those libraries just means having to roll your own, but that was always an option.</div><br/><div id="42308795" class="c"><input type="checkbox" id="c-42308795" checked=""/><div class="controls bullet"><span class="by">azemetre</span><span>|</span><a href="#42307626">root</a><span>|</span><a href="#42308646">parent</a><span>|</span><a href="#42307743">next</a><span>|</span><label class="collapse" for="c-42308795">[-]</label><label class="expand" for="c-42308795">[6 more]</label></div><br/><div class="children"><div class="content">Do you write software professionally? Not saying this to chide but these types of comments always come from either devs that just work by themselves or green ears.<p>I have never worked on a project where the only dependency was react (let&#x27;s ignore build or testing tools for the sake of argument). What I do mostly see are projects that captured the react zeitgeist of the time in regards to which &quot;popular&quot; libraries were recommended and people just copied willy nilly.<p>Maybe this is more of an indictment against software development in general where professionals are not allowed to design and engineer robust solutions because the alternative is getting fired from your job because John Dev was able to complete more tickets in a sprint when they downloaded a bunch of bloated npm libs that will break in two years and they&#x27;ll job hop to the next place to continue the cycle.</div><br/><div id="42308902" class="c"><input type="checkbox" id="c-42308902" checked=""/><div class="controls bullet"><span class="by">causal</span><span>|</span><a href="#42307626">root</a><span>|</span><a href="#42308795">parent</a><span>|</span><a href="#42307743">next</a><span>|</span><label class="collapse" for="c-42308902">[-]</label><label class="expand" for="c-42308902">[5 more]</label></div><br/><div class="children"><div class="content">Believe it or not even large teams can effectively constrain package adoption without abandoning NPM altogether.<p>Just because you haven&#x27;t seen it doesn&#x27;t mean everyone who has must be new to the field.</div><br/><div id="42309048" class="c"><input type="checkbox" id="c-42309048" checked=""/><div class="controls bullet"><span class="by">azemetre</span><span>|</span><a href="#42307626">root</a><span>|</span><a href="#42308902">parent</a><span>|</span><a href="#42307743">next</a><span>|</span><label class="collapse" for="c-42309048">[-]</label><label class="expand" for="c-42309048">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not saying I haven&#x27;t seen it, but I would bet my lifesavings the overall percentage is quite small. Why is bringing up the minority use case helpful in these discussions? Some teams just use javascript and opt for zero dependencies too, these teams are also an extreme minority.<p>You can&#x27;t have an earnest discussion about react if you&#x27;re going to argue that no one pulls in a myriad of other dependencies. Even the react docs recommend you use frameworks when starting out:<p><a href="https:&#x2F;&#x2F;react.dev&#x2F;learn&#x2F;start-a-new-react-project" rel="nofollow">https:&#x2F;&#x2F;react.dev&#x2F;learn&#x2F;start-a-new-react-project</a><p>Your usage, while quite admirable (I earnestly mean that too, I wish I was on a team that was disciplined enough to only use react and nothing else), isn&#x27;t the common experience.</div><br/><div id="42309684" class="c"><input type="checkbox" id="c-42309684" checked=""/><div class="controls bullet"><span class="by">9rx</span><span>|</span><a href="#42307626">root</a><span>|</span><a href="#42309048">parent</a><span>|</span><a href="#42307743">next</a><span>|</span><label class="collapse" for="c-42309684">[-]</label><label class="expand" for="c-42309684">[3 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Why is bringing up the minority use case helpful in these discussions?</i><p>It was presented as a challenge to the status quo. As you point out, a majority of developers don&#x27;t ever think twice about including everything and the kitchen sink. The idea that you don&#x27;t have to do that may not be novel information to you, but is to a large number of developers. If they don&#x27;t hear it here, where are they going to hear it?</div><br/><div id="42309715" class="c"><input type="checkbox" id="c-42309715" checked=""/><div class="controls bullet"><span class="by">azemetre</span><span>|</span><a href="#42307626">root</a><span>|</span><a href="#42309684">parent</a><span>|</span><a href="#42307743">next</a><span>|</span><label class="collapse" for="c-42309715">[-]</label><label class="expand" for="c-42309715">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true but that&#x27;s not how I read their argument.</div><br/><div id="42309722" class="c"><input type="checkbox" id="c-42309722" checked=""/><div class="controls bullet"><span class="by">9rx</span><span>|</span><a href="#42307626">root</a><span>|</span><a href="#42309715">parent</a><span>|</span><a href="#42307743">next</a><span>|</span><label class="collapse" for="c-42309722">[-]</label><label class="expand" for="c-42309722">[1 more]</label></div><br/><div class="children"><div class="content">How else could it be read?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42307743" class="c"><input type="checkbox" id="c-42307743" checked=""/><div class="controls bullet"><span class="by">lordgroff</span><span>|</span><a href="#42307626">parent</a><span>|</span><a href="#42308311">prev</a><span>|</span><a href="#42308268">next</a><span>|</span><label class="collapse" for="c-42307743">[-]</label><label class="expand" for="c-42307743">[1 more]</label></div><br/><div class="children"><div class="content">That was kind of my take on this article as well. We&#x27;re comparing libraries with lots of breaking-API churn vs. libraries that don&#x27;t do as much, in another language.<p>When it comes to React itself, only breaking changes I ever experienced were 17-&gt;18 and that was such a simple fix it&#x27;s not worth talking about.</div><br/></div></div><div id="42308268" class="c"><input type="checkbox" id="c-42308268" checked=""/><div class="controls bullet"><span class="by">Tade0</span><span>|</span><a href="#42307626">parent</a><span>|</span><a href="#42307743">prev</a><span>|</span><a href="#42307996">next</a><span>|</span><label class="collapse" for="c-42308268">[-]</label><label class="expand" for="c-42308268">[1 more]</label></div><br/><div class="children"><div class="content">The problem isn&#x27;t specifically with React, but the culture around it based on the fact that it&#x27;s &quot;just a library&quot;. Net effect is that you have many more dependencies than in frameworks which provide some features out of the box and thus much greater risk of having to deal with the problem discussed here.</div><br/></div></div><div id="42307996" class="c"><input type="checkbox" id="c-42307996" checked=""/><div class="controls bullet"><span class="by">christophilus</span><span>|</span><a href="#42307626">parent</a><span>|</span><a href="#42308268">prev</a><span>|</span><a href="#42307871">next</a><span>|</span><label class="collapse" for="c-42307996">[-]</label><label class="expand" for="c-42307996">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. I’ve been using Preact on an entirely client-side SPA with a simple RPC-like backend all in typescript for 5 years or so. I can’t think of a single major dependency that has changed significantly in that time. But, I did make an effort to minimize my dependencies.</div><br/></div></div><div id="42307871" class="c"><input type="checkbox" id="c-42307871" checked=""/><div class="controls bullet"><span class="by">kerblang</span><span>|</span><a href="#42307626">parent</a><span>|</span><a href="#42307996">prev</a><span>|</span><a href="#42311746">next</a><span>|</span><label class="collapse" for="c-42307871">[-]</label><label class="expand" for="c-42307871">[4 more]</label></div><br/><div class="children"><div class="content">I had the impression that hash routing in React was deprecated and a React-based back end is almost a mandate now... Wondering what options people are actually taking?</div><br/><div id="42308105" class="c"><input type="checkbox" id="c-42308105" checked=""/><div class="controls bullet"><span class="by">sleazebreeze</span><span>|</span><a href="#42307626">root</a><span>|</span><a href="#42307871">parent</a><span>|</span><a href="#42307958">next</a><span>|</span><label class="collapse" for="c-42308105">[-]</label><label class="expand" for="c-42308105">[1 more]</label></div><br/><div class="children"><div class="content">Not at all mandated. Buying into React server-side rendering will get you into a morass of complexity. Traditional SPAs with history-based routing still work just fine.</div><br/></div></div><div id="42307958" class="c"><input type="checkbox" id="c-42307958" checked=""/><div class="controls bullet"><span class="by">martinsnow</span><span>|</span><a href="#42307626">root</a><span>|</span><a href="#42307871">parent</a><span>|</span><a href="#42308105">prev</a><span>|</span><a href="#42308137">next</a><span>|</span><label class="collapse" for="c-42307958">[-]</label><label class="expand" for="c-42307958">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never used SSR and i have quite a few react apps under my belt. Why would you need to introduce it as a full stack app?</div><br/></div></div><div id="42308137" class="c"><input type="checkbox" id="c-42308137" checked=""/><div class="controls bullet"><span class="by">ggregoire</span><span>|</span><a href="#42307626">root</a><span>|</span><a href="#42307871">parent</a><span>|</span><a href="#42307958">prev</a><span>|</span><a href="#42311746">next</a><span>|</span><label class="collapse" for="c-42308137">[-]</label><label class="expand" for="c-42308137">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using react-router for almost a decade without any issue. I deploy the apps as static websites on S3.</div><br/></div></div></div></div></div></div><div id="42311746" class="c"><input type="checkbox" id="c-42311746" checked=""/><div class="controls bullet"><span class="by">jakubmazanec</span><span>|</span><a href="#42307626">prev</a><span>|</span><a href="#42315010">next</a><span>|</span><label class="collapse" for="c-42311746">[-]</label><label class="expand" for="c-42311746">[2 more]</label></div><br/><div class="children"><div class="content">It seems to me that a lot of people are forgetting that when updating to next major version of a package, breaking changes are expected - that&#x27;s the whole point of major version number in SemVer [1]. What they actually want is seamless updates (or never changing APIs, but that not possible in most situations, and also not what you want as a package developer - you want to be able to correct your API design mistakes). That requires a lot of work from the package developers.<p>Look for example how people at Remix do it: breaking changes are hidden behind future flags [2], so you a user can turn them on one by one and adapt their code on gradually without surprises. Another solution is creating codemods for upgrades. But how many open-source package developers are willing do to this extra work?<p>Same story with peer dependencies - they&#x27;re completely fine, if package developers know how to use them.<p>As always, don&#x27;t be mad at React, don&#x27;t curse Npm, it&#x27;s not their fault. There is no great package without great effort.<p>[1] <a href="https:&#x2F;&#x2F;semver.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;semver.org&#x2F;</a>
[2] <a href="https:&#x2F;&#x2F;remix.run&#x2F;docs&#x2F;en&#x2F;main&#x2F;guides&#x2F;api-development-strategy#unstable-apis-and-future-flags" rel="nofollow">https:&#x2F;&#x2F;remix.run&#x2F;docs&#x2F;en&#x2F;main&#x2F;guides&#x2F;api-development-strate...</a></div><br/><div id="42312375" class="c"><input type="checkbox" id="c-42312375" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#42311746">parent</a><span>|</span><a href="#42315010">next</a><span>|</span><label class="collapse" for="c-42312375">[-]</label><label class="expand" for="c-42312375">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It seems to me that a lot of people are forgetting that when updating to next major version of a package, breaking changes are expected<p>No, I don&#x27;t think that&#x27;s the problem here.  The author completely understands and accepts that a new major version will break their code.  They&#x27;re asking whether there&#x27;s actually a benefit to these breaking changes.<p>&gt; seamless updates […] That requires a lot of work from the package developers.<p>Well, the lower something is in the stack, the more likely developers seem to be to put in that work.  The Linux kernel syscall API is sacred, so are most Win32 base interfaces.  libc&#x2F;VCRT almost as much.  Python versions a little bit less.  GUI toolkits and SSL libraries break a bit more frequently but tend to just be parallel install. But the more you move up the stack, the more frequent breakage you get.<p>Same in the browser. Basic DOM is backwards compatible to the stone age, but the more things you pile on the more frequent API&#x2F;update breakages become.<p>It&#x27;s really a kind of obvious logic, since the lower something is in the stack, the more things above it indirectly snake down dependencies, and the more pressure to not break things there is.</div><br/></div></div></div></div><div id="42315010" class="c"><input type="checkbox" id="c-42315010" checked=""/><div class="controls bullet"><span class="by">gloosx</span><span>|</span><a href="#42311746">prev</a><span>|</span><a href="#42308415">next</a><span>|</span><label class="collapse" for="c-42315010">[-]</label><label class="expand" for="c-42315010">[3 more]</label></div><br/><div class="children"><div class="content">Author&#x27;s frustration comes out of his personal not-necessary dependency choices, but of course his final choice was to blame the technology itself. I have one suggestion for those who are struggling with wouter, or react-video-player, or react-stank-tank-fetch or any other dependency, 100% safe way to start a successful project:<p>npm init<p>npm install react react-dom webpack @babel&#x2F;core @babel&#x2F;preset-env @babel&#x2F;preset-react<p>alias npm=&quot;echo do not use&quot;<p>that&#x27;s it; you don&#x27;t need them; they can be replaced with few hooks in 100 lines of code to fit your needs; just write javascript code, react hooks and components; don&#x27;t install weird dependencies, they won&#x27;t make it faster or more convenient in the long runl; if there is any other dependency everybody wants and needs, you will see it was last updated 9 years ago on GH and still works great to this day</div><br/><div id="42315147" class="c"><input type="checkbox" id="c-42315147" checked=""/><div class="controls bullet"><span class="by">morbicer</span><span>|</span><a href="#42315010">parent</a><span>|</span><a href="#42308415">next</a><span>|</span><label class="collapse" for="c-42315147">[-]</label><label class="expand" for="c-42315147">[2 more]</label></div><br/><div class="children"><div class="content">This would be an idea worth considering if you didn&#x27;t pick babel which will drag a half of universe with it
<a href="https:&#x2F;&#x2F;bundlephobia.com&#x2F;package&#x2F;babel-core" rel="nofollow">https:&#x2F;&#x2F;bundlephobia.com&#x2F;package&#x2F;babel-core</a><p>Use raw esbuild or swc; or be hassle free with Vite... or something else less cursed. I am grateful for Babel, it opened up the js development to new syntax but it&#x27;s a beast from the past times. (The same applies to webpack)<p>Transitive dependencies of those are exactly the thing Dependabot will nag you about day and night.</div><br/><div id="42315707" class="c"><input type="checkbox" id="c-42315707" checked=""/><div class="controls bullet"><span class="by">gloosx</span><span>|</span><a href="#42315010">root</a><span>|</span><a href="#42315147">parent</a><span>|</span><a href="#42308415">next</a><span>|</span><label class="collapse" for="c-42315707">[-]</label><label class="expand" for="c-42315707">[1 more]</label></div><br/><div class="children"><div class="content">&gt;babel which will drag a half of universe with it<p>Why should I care about 500KiB of development dependencies, they won&#x27;t leak into the build anyway? I don&#x27;t see any value in vite or other build tool since I know how to write a webpack config I need in 3 minutes, and it is the same process for almost 10 years now.</div><br/></div></div></div></div></div></div><div id="42308415" class="c"><input type="checkbox" id="c-42308415" checked=""/><div class="controls bullet"><span class="by">WD-42</span><span>|</span><a href="#42315010">prev</a><span>|</span><a href="#42308321">next</a><span>|</span><label class="collapse" for="c-42308415">[-]</label><label class="expand" for="c-42308415">[6 more]</label></div><br/><div class="children"><div class="content">In just finished migrating a fairly large client project SPA with a Django backend to just straight Django + HTMX with some Alpine sprinkled in for reactivity. Went from 100s of JavaScript dependencies to 5.<p>It feels like a massive weight off my shoulders. The SPA felt like a ticking time bomb.</div><br/><div id="42312607" class="c"><input type="checkbox" id="c-42312607" checked=""/><div class="controls bullet"><span class="by">robertoandred</span><span>|</span><a href="#42308415">parent</a><span>|</span><a href="#42308321">next</a><span>|</span><label class="collapse" for="c-42312607">[-]</label><label class="expand" for="c-42312607">[5 more]</label></div><br/><div class="children"><div class="content">Now you have new dependencies which are their own ticking time bomb.</div><br/><div id="42313532" class="c"><input type="checkbox" id="c-42313532" checked=""/><div class="controls bullet"><span class="by">WD-42</span><span>|</span><a href="#42308415">root</a><span>|</span><a href="#42312607">parent</a><span>|</span><a href="#42308321">next</a><span>|</span><label class="collapse" for="c-42313532">[-]</label><label class="expand" for="c-42313532">[4 more]</label></div><br/><div class="children"><div class="content">No, I don’t. No new deps server side. Htmx and Alpine are self contained. They have no transitive dependencies, they don’t even require a build step. Worst case I can just vendor them.</div><br/><div id="42313605" class="c"><input type="checkbox" id="c-42313605" checked=""/><div class="controls bullet"><span class="by">robertoandred</span><span>|</span><a href="#42308415">root</a><span>|</span><a href="#42313532">parent</a><span>|</span><a href="#42308321">next</a><span>|</span><label class="collapse" for="c-42313605">[-]</label><label class="expand" for="c-42313605">[3 more]</label></div><br/><div class="children"><div class="content">Just because something is self-contained doesn&#x27;t mean it isn&#x27;t a ticking time bomb.</div><br/><div id="42314445" class="c"><input type="checkbox" id="c-42314445" checked=""/><div class="controls bullet"><span class="by">WD-42</span><span>|</span><a href="#42308415">root</a><span>|</span><a href="#42313605">parent</a><span>|</span><a href="#42314286">next</a><span>|</span><label class="collapse" for="c-42314445">[-]</label><label class="expand" for="c-42314445">[1 more]</label></div><br/><div class="children"><div class="content">Sure, given enough time everything will rot. But there&#x27;s a huge spectrum here. HTMX for example - for it to suddenly stop working browsers would have to collectively drop backwards support for their most basic of features.<p>Now with the SPA it&#x27;s very possible to have a Vue2 -&gt; Vue3 situation, or just someone pulling a left-pad. Not to mention the build system requiring specific versions of nodejs, etc. And this is just to keep things running, not to speak of adding new stuff.<p>It&#x27;s not even really comparable.</div><br/></div></div><div id="42314286" class="c"><input type="checkbox" id="c-42314286" checked=""/><div class="controls bullet"><span class="by">yawaramin</span><span>|</span><a href="#42308415">root</a><span>|</span><a href="#42313605">parent</a><span>|</span><a href="#42314445">prev</a><span>|</span><a href="#42308321">next</a><span>|</span><label class="collapse" for="c-42314286">[-]</label><label class="expand" for="c-42314286">[1 more]</label></div><br/><div class="children"><div class="content">And also, just because something <i>isn&#x27;t</i> self-contained, <i>also</i> doesn&#x27;t mean it isn&#x27;t a ticking time bomb. Great, now everything is a ticking time bomb. Enjoy!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42308321" class="c"><input type="checkbox" id="c-42308321" checked=""/><div class="controls bullet"><span class="by">jeffmcmahan</span><span>|</span><a href="#42308415">prev</a><span>|</span><a href="#42307761">next</a><span>|</span><label class="collapse" for="c-42308321">[-]</label><label class="expand" for="c-42308321">[2 more]</label></div><br/><div class="children"><div class="content">React is not responsible for the stack of poorly maintained third party packages one chooses to use alongside it. You don&#x27;t actually need a router, or redux, or other &quot;state management&quot; nonsense. Your application code can&#x2F;should handle that stuff, and it won&#x27;t break, and it won&#x27;t change unless you change it.</div><br/><div id="42309538" class="c"><input type="checkbox" id="c-42309538" checked=""/><div class="controls bullet"><span class="by">andybak</span><span>|</span><a href="#42308321">parent</a><span>|</span><a href="#42307761">next</a><span>|</span><label class="collapse" for="c-42309538">[-]</label><label class="expand" for="c-42309538">[1 more]</label></div><br/><div class="children"><div class="content">&gt; React is not responsible for the stack of poorly maintained third party packages one chooses to use alongside it.<p>It&#x27;s not whether or not it&#x27;s responsible. It&#x27;s whether you suffer this pain if you choose a different framework&#x2F;platform&#x2F;language.<p>Coming from a Django&#x2F;Python perspective - the Javascript ecosystem post-npm just feels pathological in this regard.</div><br/></div></div></div></div><div id="42307761" class="c"><input type="checkbox" id="c-42307761" checked=""/><div class="controls bullet"><span class="by">ggregoire</span><span>|</span><a href="#42308321">prev</a><span>|</span><a href="#42308780">next</a><span>|</span><label class="collapse" for="c-42307761">[-]</label><label class="expand" for="c-42307761">[11 more]</label></div><br/><div class="children"><div class="content">While I also think react-query should have kept v5 compatible with the v3 API (even if the new API is better, keep the old one optional, at least for a while), the migration is fairly easy and quick to do, and more importantly, it&#x27;s not mandatory at all. I still have apps running v3 and v4 without any issues. Also, v3 to v5 is a bump of two major versions, it obviously implies breaking changes [1] (can&#x27;t tell for Go but this happens in most part of the industry, see for example Python v2 -&gt; v3, SQLAlchemy v1 -&gt; v2 or psycopg v2 -&gt; v3) and it&#x27;s not like they release a new major version every week.<p>As someone who do a good amount of frontend dev, I feel like the &quot;dependency management fatigue&quot; sentiment, which is very common on this forum, is way too much inflated. Just keep your dependencies to a reasonable number, pick solid dependencies that don&#x27;t break their APIs every year, and don&#x27;t upgrade just for the sake of it. Like you surely do with your backend environment too.<p>[1] <a href="https:&#x2F;&#x2F;semver.org" rel="nofollow">https:&#x2F;&#x2F;semver.org</a></div><br/><div id="42307846" class="c"><input type="checkbox" id="c-42307846" checked=""/><div class="controls bullet"><span class="by">rjzzleep</span><span>|</span><a href="#42307761">parent</a><span>|</span><a href="#42308780">next</a><span>|</span><label class="collapse" for="c-42307846">[-]</label><label class="expand" for="c-42307846">[10 more]</label></div><br/><div class="children"><div class="content">The thing with the react community is that this constantly happens with random things. You cannot at all compare python v2 -&gt; v3. The react community has 10 python v2-&gt;v3 situations in any given year. The only reason why it works, is that Facebook and by extension the react community think it&#x27;s okay to hire massive Frontend development teams.</div><br/><div id="42308049" class="c"><input type="checkbox" id="c-42308049" checked=""/><div class="controls bullet"><span class="by">pjc50</span><span>|</span><a href="#42307761">root</a><span>|</span><a href="#42307846">parent</a><span>|</span><a href="#42308019">next</a><span>|</span><label class="collapse" for="c-42308049">[-]</label><label class="expand" for="c-42308049">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve often felt this is the other way round: Facebook hired a massive frontend team, and therefore they have to continually create work for themselves.</div><br/><div id="42309053" class="c"><input type="checkbox" id="c-42309053" checked=""/><div class="controls bullet"><span class="by">vundercind</span><span>|</span><a href="#42307761">root</a><span>|</span><a href="#42308049">parent</a><span>|</span><a href="#42309093">next</a><span>|</span><label class="collapse" for="c-42309053">[-]</label><label class="expand" for="c-42309053">[2 more]</label></div><br/><div class="children"><div class="content">The point where they re-centered React around a bad half-implementation of Objects, in a language that already has an OO system, was when I decided they were out of real problems to solve (or didn&#x27;t know how to approach those real problems—do Forms still suck in vanilla React, without an add-on library or two?) and on to pure employment-justifying and CV-building.<p>And, more power to them, but at that point I&#x27;m not going to willingly rely on the project for anything.</div><br/><div id="42314301" class="c"><input type="checkbox" id="c-42314301" checked=""/><div class="controls bullet"><span class="by">yawaramin</span><span>|</span><a href="#42307761">root</a><span>|</span><a href="#42309053">parent</a><span>|</span><a href="#42309093">next</a><span>|</span><label class="collapse" for="c-42314301">[-]</label><label class="expand" for="c-42314301">[1 more]</label></div><br/><div class="children"><div class="content">&gt; do Forms still suck in vanilla React, without an add-on library<p>Did they ever? Wouldn&#x27;t we just do &lt;form onSubmit={handleSubmit}&gt; and then in the handler we just grab the FormData, send it to the server, get back the response, then update whatever? Doesn&#x27;t seem like it should be that hard?</div><br/></div></div></div></div><div id="42309093" class="c"><input type="checkbox" id="c-42309093" checked=""/><div class="controls bullet"><span class="by">disgruntledphd2</span><span>|</span><a href="#42307761">root</a><span>|</span><a href="#42308049">parent</a><span>|</span><a href="#42309053">prev</a><span>|</span><a href="#42308019">next</a><span>|</span><label class="collapse" for="c-42309093">[-]</label><label class="expand" for="c-42309093">[2 more]</label></div><br/><div class="children"><div class="content">Nah, they had real problems that React solved. But most applications aren&#x27;t Facebook and don&#x27;t have the same need for this.</div><br/><div id="42310242" class="c"><input type="checkbox" id="c-42310242" checked=""/><div class="controls bullet"><span class="by">9rx</span><span>|</span><a href="#42307761">root</a><span>|</span><a href="#42309093">parent</a><span>|</span><a href="#42308019">next</a><span>|</span><label class="collapse" for="c-42310242">[-]</label><label class="expand" for="c-42310242">[1 more]</label></div><br/><div class="children"><div class="content">React v1 solved a real problem, but perhaps didn&#x27;t really need 17 subsequent major revisions with another on its way? But that&#x27;s the different cultures around this discussion. The Javascript community generally seems to subscribe to progress at all cost, which the earlier commenter attributes to exceptionally large teams like that at Facebook trying to find work to do, whereas the Go community generally subscribes to the idea that it is okay to be &quot;done&quot;, clamping down on the extent of any future iterations.</div><br/></div></div></div></div></div></div><div id="42308019" class="c"><input type="checkbox" id="c-42308019" checked=""/><div class="controls bullet"><span class="by">ggregoire</span><span>|</span><a href="#42307761">root</a><span>|</span><a href="#42307846">parent</a><span>|</span><a href="#42308049">prev</a><span>|</span><a href="#42309651">next</a><span>|</span><label class="collapse" for="c-42308019">[-]</label><label class="expand" for="c-42308019">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The react community has 10 python v2-&gt;v3 situation in any given year.<p>That is not my experience. Maybe you could share with us some examples?<p>My most important dependencies, after React itself and TypeScript, are react-router (which released v6 in 2021) and react-query (which released v5 in 2023). I don&#x27;t remember other major breaking changes in recent years, at least with the dependencies I&#x27;m using.</div><br/><div id="42308329" class="c"><input type="checkbox" id="c-42308329" checked=""/><div class="controls bullet"><span class="by">tisc</span><span>|</span><a href="#42307761">root</a><span>|</span><a href="#42308019">parent</a><span>|</span><a href="#42309651">next</a><span>|</span><label class="collapse" for="c-42308329">[-]</label><label class="expand" for="c-42308329">[2 more]</label></div><br/><div class="children"><div class="content">Eslint version 9 has been causing some headaches, as it broke all existing plugins.</div><br/><div id="42313012" class="c"><input type="checkbox" id="c-42313012" checked=""/><div class="controls bullet"><span class="by">DangitBobby</span><span>|</span><a href="#42307761">root</a><span>|</span><a href="#42308329">parent</a><span>|</span><a href="#42309651">next</a><span>|</span><label class="collapse" for="c-42313012">[-]</label><label class="expand" for="c-42313012">[1 more]</label></div><br/><div class="children"><div class="content">Why did you upgrade?</div><br/></div></div></div></div></div></div><div id="42309651" class="c"><input type="checkbox" id="c-42309651" checked=""/><div class="controls bullet"><span class="by">HdS84</span><span>|</span><a href="#42307761">root</a><span>|</span><a href="#42307846">parent</a><span>|</span><a href="#42308019">prev</a><span>|</span><a href="#42308780">next</a><span>|</span><label class="collapse" for="c-42309651">[-]</label><label class="expand" for="c-42309651">[1 more]</label></div><br/><div class="children"><div class="content">Yes, we do maintenance contracts and anything react is really costly to keep up to date.
You have enormous churn just to keep existing functionality. 
Super hard to sell that you need like 30 days a year just to keep you app live workable</div><br/></div></div></div></div></div></div><div id="42308780" class="c"><input type="checkbox" id="c-42308780" checked=""/><div class="controls bullet"><span class="by">littlecranky67</span><span>|</span><a href="#42307761">prev</a><span>|</span><a href="#42307759">next</a><span>|</span><label class="collapse" for="c-42308780">[-]</label><label class="expand" for="c-42308780">[4 more]</label></div><br/><div class="children"><div class="content">&gt; No, my webapp wasn’t getting any additional benefits. I was already happy with the functionality of these packages.<p>Then why did you upgrade in the first place. Clearly there were no security issues (and those hardly play a role in Frontend world, especially in those library Tanstack and Wouter). It seems people just want to upgrade to the latest version, just to upgrade to the latest version without any benefit.<p>I do .NET development, and I skip major versions all the time, instead of upgrading every year.</div><br/><div id="42309309" class="c"><input type="checkbox" id="c-42309309" checked=""/><div class="controls bullet"><span class="by">WorldMaker</span><span>|</span><a href="#42308780">parent</a><span>|</span><a href="#42307759">next</a><span>|</span><label class="collapse" for="c-42309309">[-]</label><label class="expand" for="c-42309309">[3 more]</label></div><br/><div class="children"><div class="content">Frontend security issues <i>do</i> exist and can be big problems. Especially in SPA designs where the frontend runs a massive in-memory database of an entire application state. (As many of them do, especially if you are using things like frontend routing and ad hoc backend DB querying as both example libraries are about.)<p>.NET has a security support policy that LTS versions (currently even version numbers) are supported for a couple of years and non-LTS versions (currently odd version numbers) for a year after they&#x27;ve been released. A lot of frontend packages don&#x27;t have the maintenance budget to offer support plans on anything but the most recent major version (in part because many of them are open source and low contributor count; their own problems for the ecosystem).<p>Don&#x27;t discount security&#x2F;support maintenance concerns in the frontend. Also, yes, it is a problem that many frontend packages in the ecosystem don&#x27;t have maintenance policies as strong as the best backends.</div><br/><div id="42314955" class="c"><input type="checkbox" id="c-42314955" checked=""/><div class="controls bullet"><span class="by">nosefurhairdo</span><span>|</span><a href="#42308780">root</a><span>|</span><a href="#42309309">parent</a><span>|</span><a href="#42312936">next</a><span>|</span><label class="collapse" for="c-42314955">[-]</label><label class="expand" for="c-42314955">[1 more]</label></div><br/><div class="children"><div class="content">The packages referenced in this article do not have known security vulnerabilities in the latest minor&#x2F;patch versions of their previous majors. So the author is still complaining about an unnecessary update.</div><br/></div></div><div id="42312936" class="c"><input type="checkbox" id="c-42312936" checked=""/><div class="controls bullet"><span class="by">froddd</span><span>|</span><a href="#42308780">root</a><span>|</span><a href="#42309309">parent</a><span>|</span><a href="#42314955">prev</a><span>|</span><a href="#42307759">next</a><span>|</span><label class="collapse" for="c-42312936">[-]</label><label class="expand" for="c-42312936">[1 more]</label></div><br/><div class="children"><div class="content">On such popular and packages, one should reasonably expect security holes to be found and made public with relatively little delay. At that point, upgrading becomes relevant.</div><br/></div></div></div></div></div></div><div id="42307759" class="c"><input type="checkbox" id="c-42307759" checked=""/><div class="controls bullet"><span class="by">pawelduda</span><span>|</span><a href="#42308780">prev</a><span>|</span><a href="#42308447">next</a><span>|</span><label class="collapse" for="c-42307759">[-]</label><label class="expand" for="c-42307759">[3 more]</label></div><br/><div class="children"><div class="content">The real dependency management hell was ~10 years ago when npm, webpack, etc. became popular (TBH not just dependency, JS in general). I feel nowadays things are better</div><br/><div id="42308932" class="c"><input type="checkbox" id="c-42308932" checked=""/><div class="controls bullet"><span class="by">airstrike</span><span>|</span><a href="#42307759">parent</a><span>|</span><a href="#42308447">next</a><span>|</span><label class="collapse" for="c-42308932">[-]</label><label class="expand" for="c-42308932">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a curious expression in Brazil which translates to &quot;taking the goat out of the living room&quot;. A parable tells the story that people in a living room were complaining about everything and crying out loud how miserable they were. Someone then brings a goat into the room and chaos comes about. After enough time, the goat is carried off of the room. People are now exactly as they were before, but they do not complain anymore. The just say that life is now much better without a goat in the living room.<p>Things may be better today, but that doesn&#x27;t mean they&#x27;re necessarily good. Even after climbing a couple circles away from the very bottom of dependency management hell, we&#x27;re still condemned to endless suffering.</div><br/><div id="42314417" class="c"><input type="checkbox" id="c-42314417" checked=""/><div class="controls bullet"><span class="by">rectang</span><span>|</span><a href="#42307759">root</a><span>|</span><a href="#42308932">parent</a><span>|</span><a href="#42308447">next</a><span>|</span><label class="collapse" for="c-42314417">[-]</label><label class="expand" for="c-42314417">[1 more]</label></div><br/><div class="children"><div class="content">Thank you. My life is better for having read through this long discussion to stumble upon this profound and hilarious fable.  I will now remove the goat from the room and go do something productive.</div><br/></div></div></div></div></div></div><div id="42308447" class="c"><input type="checkbox" id="c-42308447" checked=""/><div class="controls bullet"><span class="by">lpapez</span><span>|</span><a href="#42307759">prev</a><span>|</span><a href="#42308824">next</a><span>|</span><label class="collapse" for="c-42308447">[-]</label><label class="expand" for="c-42308447">[1 more]</label></div><br/><div class="children"><div class="content">Never heard about Templ before, so I went ahead to investigate it and...<p>Wow, they reinvented PHP!</div><br/></div></div><div id="42308824" class="c"><input type="checkbox" id="c-42308824" checked=""/><div class="controls bullet"><span class="by">rasmus-kirk</span><span>|</span><a href="#42308447">prev</a><span>|</span><a href="#42314499">next</a><span>|</span><label class="collapse" for="c-42308824">[-]</label><label class="expand" for="c-42308824">[1 more]</label></div><br/><div class="children"><div class="content">Check out htmx playground, helped me learn it better:<p><a href="https:&#x2F;&#x2F;lassebomh.github.io&#x2F;htmx-playground&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lassebomh.github.io&#x2F;htmx-playground&#x2F;</a></div><br/></div></div><div id="42314499" class="c"><input type="checkbox" id="c-42314499" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42308824">prev</a><span>|</span><a href="#42310190">next</a><span>|</span><label class="collapse" for="c-42314499">[-]</label><label class="expand" for="c-42314499">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s great when you can just pick a simpler tool, and it turns out to be an adequate tool. When you don&#x27;t need the benefits which React provides for building <i>very complex</i> interfaces, there&#x27;s no reason to put up with its complexity.<p>There are kinds of applications though where React is indispensable, and HTMX would become unmanageable spaghetti. Stuff like Facebook (the original authors of React), GMail, Jira, etc. Such complex applications (not &quot;websites&quot;) are relatively rare. If yours is not of this class, do explore simpler solutions unless you enjoy React and would write it for fun (and even then).</div><br/></div></div><div id="42310190" class="c"><input type="checkbox" id="c-42310190" checked=""/><div class="controls bullet"><span class="by">swyx</span><span>|</span><a href="#42314499">prev</a><span>|</span><a href="#42307616">next</a><span>|</span><label class="collapse" for="c-42310190">[-]</label><label class="expand" for="c-42310190">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Is it necessary to literally break the API of a fundamental component in a React webapp 5 times ?!?!<p>i cant speak to tanstack specifics but just fyi to general HN audience that it is very normal to bump a major version just because a major dependency  bumped a major version (eg Typescript or React), and often its just a sign of deprecating legacy apis than breaking anything core.</div><br/><div id="42312312" class="c"><input type="checkbox" id="c-42312312" checked=""/><div class="controls bullet"><span class="by">RadiozRadioz</span><span>|</span><a href="#42310190">parent</a><span>|</span><a href="#42307616">next</a><span>|</span><label class="collapse" for="c-42312312">[-]</label><label class="expand" for="c-42312312">[2 more]</label></div><br/><div class="children"><div class="content">Deprecating &quot;legacy APIs&quot;, from the perspective of the API users, _is_ breaking core functionality. Functionality that existed previously is now gone, that is a breaking change.<p>Additionally, bumping a major version because a dependency changed isn&#x27;t a common practice to my knowledge. In fact I&#x27;d say it&#x27;s incorrect. You bump a major version if _your_ API has breaking changes. If one of your dependencies changed but you&#x27;ve adapted in a way that is transparent to your users, that is a patch not a major.</div><br/><div id="42313004" class="c"><input type="checkbox" id="c-42313004" checked=""/><div class="controls bullet"><span class="by">acemarke</span><span>|</span><a href="#42310190">root</a><span>|</span><a href="#42312312">parent</a><span>|</span><a href="#42307616">next</a><span>|</span><label class="collapse" for="c-42313004">[-]</label><label class="expand" for="c-42313004">[1 more]</label></div><br/><div class="children"><div class="content">It can be more complex than that.<p>When we shipped React-Redux v8, we rewrote our internals to drop our own subscription management logic, and switched to React&#x27;s new `useSyncExternalStore` hook instead.  However, `uSES` only was added with React 18, and we still wanted to support earlier versions of React that had hooks (16.8+, 17).  So, we defaulted to using React&#x27;s &quot;shim&quot; package that provided a backwards-compatible implementation of `usES`, at the cost of a bit of extra bundle size.<p>Once React 18 reached sufficient adoption, we wanted to drop the use of the `uSES` shim package and use the built-in version, but that required React 18 as a minimum dependency.  So, we did that in a major, React-Redux v9.<p>Code _using_ React-Redux never changed in the slightest - it&#x27;s still the same `useSelector` calls either way. But given that anyone attempting to mix React-Redux v9 and React &lt;=17 would have it break, that was clearly a major version bump for us.</div><br/></div></div></div></div></div></div><div id="42307616" class="c"><input type="checkbox" id="c-42307616" checked=""/><div class="controls bullet"><span class="by">askonomm</span><span>|</span><a href="#42310190">prev</a><span>|</span><a href="#42314367">next</a><span>|</span><label class="collapse" for="c-42307616">[-]</label><label class="expand" for="c-42307616">[4 more]</label></div><br/><div class="children"><div class="content">Similarly, my favorite web stack these days is good ol&#x27; PHP for the API and HTMX for the front-end. It keeps everything simple and all the complexity in one place. Love it.</div><br/><div id="42307680" class="c"><input type="checkbox" id="c-42307680" checked=""/><div class="controls bullet"><span class="by">phplovesong</span><span>|</span><a href="#42307616">parent</a><span>|</span><a href="#42314367">next</a><span>|</span><label class="collapse" for="c-42307680">[-]</label><label class="expand" for="c-42307680">[3 more]</label></div><br/><div class="children"><div class="content">Haxe compiled to JS and PHP is my goto for traditional web apps. I get the type safety and access to a vast ecosystem. Bonus, i can share code both on the client and server.</div><br/><div id="42308066" class="c"><input type="checkbox" id="c-42308066" checked=""/><div class="controls bullet"><span class="by">christophilus</span><span>|</span><a href="#42307616">root</a><span>|</span><a href="#42307680">parent</a><span>|</span><a href="#42309799">next</a><span>|</span><label class="collapse" for="c-42308066">[-]</label><label class="expand" for="c-42308066">[1 more]</label></div><br/><div class="children"><div class="content">Do you use haxe for your day job, or just on side projects. If professionally, I’d love to read a write up of how you use it.</div><br/></div></div><div id="42309799" class="c"><input type="checkbox" id="c-42309799" checked=""/><div class="controls bullet"><span class="by">askonomm</span><span>|</span><a href="#42307616">root</a><span>|</span><a href="#42307680">parent</a><span>|</span><a href="#42308066">prev</a><span>|</span><a href="#42314367">next</a><span>|</span><label class="collapse" for="c-42309799">[-]</label><label class="expand" for="c-42309799">[1 more]</label></div><br/><div class="children"><div class="content">I like to keep things as vanilla as I can because historically using languages that transpile into other languages has been quite horrible in my experience (for debugging reasons among many other things).</div><br/></div></div></div></div></div></div><div id="42314367" class="c"><input type="checkbox" id="c-42314367" checked=""/><div class="controls bullet"><span class="by">hitekker</span><span>|</span><a href="#42307616">prev</a><span>|</span><a href="#42313982">next</a><span>|</span><label class="collapse" for="c-42314367">[-]</label><label class="expand" for="c-42314367">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been enjoying Web Components with lit-html (and not lit) so far.
The developer experience is definitely worse compared to Vue, but I feel there&#x27;s less ideology and careerism.<p>Plus, Claude generates some pretty nice code out of the box!</div><br/></div></div><div id="42313982" class="c"><input type="checkbox" id="c-42313982" checked=""/><div class="controls bullet"><span class="by">molszanski</span><span>|</span><a href="#42314367">prev</a><span>|</span><a href="#42308589">next</a><span>|</span><label class="collapse" for="c-42313982">[-]</label><label class="expand" for="c-42313982">[1 more]</label></div><br/><div class="children"><div class="content">shameless plug<p>If anyone is looking for IoC + async dependency injection in react components I&#x27;ve made a tiny lib that does wonders for me in a an `iti+mobx` combo<p><a href="https:&#x2F;&#x2F;itijs.org&#x2F;docs&#x2F;with-react&#x2F;react-full#async-request-for-multiple-items" rel="nofollow">https:&#x2F;&#x2F;itijs.org&#x2F;docs&#x2F;with-react&#x2F;react-full#async-request-f...</a>
<a href="https:&#x2F;&#x2F;stackblitz.com&#x2F;edit&#x2F;github-3g8pzp?file=src%2FApp.tsx" rel="nofollow">https:&#x2F;&#x2F;stackblitz.com&#x2F;edit&#x2F;github-3g8pzp?file=src%2FApp.tsx</a></div><br/></div></div><div id="42308589" class="c"><input type="checkbox" id="c-42308589" checked=""/><div class="controls bullet"><span class="by">yayoohooyahoo</span><span>|</span><a href="#42313982">prev</a><span>|</span><a href="#42308378">next</a><span>|</span><label class="collapse" for="c-42308589">[-]</label><label class="expand" for="c-42308589">[2 more]</label></div><br/><div class="children"><div class="content">I wish backward compatibility was a thing in js library development but clearly there&#x27;s nothing fun in keeping things working, so developers break API all the time for no reasons.<p>I don&#x27;t how many time I was dealing with a breaking changes for trivial things like making an API prettier, renaming a few functions, a few parameters here and there because it suits the author&#x27;s aesthetic sensibilities.<p>They&#x27;re of course perfectly free to do this and being open source they don&#x27;t owe anything to anybody, but I still wish that there was some degree of responsibility towards the end user. Or else why even release the code publicly? End users don&#x27;t care *at all* how pretty the API is, we just want things to work.</div><br/><div id="42314002" class="c"><input type="checkbox" id="c-42314002" checked=""/><div class="controls bullet"><span class="by">johnny22</span><span>|</span><a href="#42308589">parent</a><span>|</span><a href="#42308378">next</a><span>|</span><label class="collapse" for="c-42314002">[-]</label><label class="expand" for="c-42314002">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Or else why even release the code publicly?<p>So folks who would rather not have to write the functionality themselves can use it (like myself). Nobody is forcing you to use any of this.</div><br/></div></div></div></div><div id="42308378" class="c"><input type="checkbox" id="c-42308378" checked=""/><div class="controls bullet"><span class="by">shreddit</span><span>|</span><a href="#42308589">prev</a><span>|</span><a href="#42311971">next</a><span>|</span><label class="collapse" for="c-42308378">[-]</label><label class="expand" for="c-42308378">[2 more]</label></div><br/><div class="children"><div class="content">Hmm, I wished the author would have gone a little deeper into why Go+Htmx+Templ is better than just rant about why react is bad. Which isn’t even a react specific problem but more of a npm ecosystem one.<p>I also ditched react on my side projects but for a whole different set of reasons.</div><br/><div id="42313485" class="c"><input type="checkbox" id="c-42313485" checked=""/><div class="controls bullet"><span class="by">RapperWhoMadeIt</span><span>|</span><a href="#42308378">parent</a><span>|</span><a href="#42311971">next</a><span>|</span><label class="collapse" for="c-42313485">[-]</label><label class="expand" for="c-42313485">[1 more]</label></div><br/><div class="children"><div class="content">Hi, author here!<p>I think that is a very valid criticism. I wanted to keep the article concise, but I should have elaborated more on why Go+HTMX+Templ solves the dependency management fatigue.<p>As I said in the article, it is mainly anecdotal evidence, i.e. the experience from having to maintain projects with either React or Go+HTMX. 
For example, in the Go+HTMX project I handle state management and routing solely with the Go stdlib (which is very very stable IMHO), I don&#x27;t have to ever worry that a dependency update will force me to perform painful refactoring work.<p>Maybe in a future article I can expand on these points, thank you for the feedback :)</div><br/></div></div></div></div><div id="42309101" class="c"><input type="checkbox" id="c-42309101" checked=""/><div class="controls bullet"><span class="by">oellegaard</span><span>|</span><a href="#42311971">prev</a><span>|</span><a href="#42314678">next</a><span>|</span><label class="collapse" for="c-42309101">[-]</label><label class="expand" for="c-42309101">[1 more]</label></div><br/><div class="children"><div class="content">In general, and this applies to many language communities, you are encouraged to include all kind of garbage dependencies into your project.<p>Adding dependencies should be something you consider carefully. Every line of code has a maintenance cost - a dependency has it times 1000. Effectively you are adding technical debt in many cases.<p>For instance I just developed a new react app with just react and react-router. My colleagues suggested react-query but why add this when you can do all you need with a few lines of code and fetch?</div><br/></div></div><div id="42314678" class="c"><input type="checkbox" id="c-42314678" checked=""/><div class="controls bullet"><span class="by">eezing</span><span>|</span><a href="#42309101">prev</a><span>|</span><a href="#42308391">next</a><span>|</span><label class="collapse" for="c-42314678">[-]</label><label class="expand" for="c-42314678">[1 more]</label></div><br/><div class="children"><div class="content">My favorite offenders are the CJS to ESM (only) conversions.</div><br/></div></div><div id="42308391" class="c"><input type="checkbox" id="c-42308391" checked=""/><div class="controls bullet"><span class="by">narrator</span><span>|</span><a href="#42314678">prev</a><span>|</span><a href="#42308370">next</a><span>|</span><label class="collapse" for="c-42308391">[-]</label><label class="expand" for="c-42308391">[1 more]</label></div><br/><div class="children"><div class="content">The never-ending cycle of Javascript libraries continues.  It&#x27;s an HN cliche at this point : <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32914452">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32914452</a><p>In fact, it reminds me of Joseph Tainter&#x27;s theories in Collapse of Complex Societies.  Additional civilizational complexity adds value until it starts producing negative marginal returns and then the complexity collapses and reverts to simpler forms.</div><br/></div></div><div id="42308370" class="c"><input type="checkbox" id="c-42308370" checked=""/><div class="controls bullet"><span class="by">xutopia</span><span>|</span><a href="#42308391">prev</a><span>|</span><a href="#42312208">next</a><span>|</span><label class="collapse" for="c-42308370">[-]</label><label class="expand" for="c-42308370">[1 more]</label></div><br/><div class="children"><div class="content">Rails has Hotwire&#x2F;Turbo, Phoenix has LiveView, others use various methods like Htmx to get away from the SPA nonsense a majority of us are living with.</div><br/></div></div><div id="42312208" class="c"><input type="checkbox" id="c-42312208" checked=""/><div class="controls bullet"><span class="by">deepsun</span><span>|</span><a href="#42308370">prev</a><span>|</span><a href="#42308534">next</a><span>|</span><label class="collapse" for="c-42312208">[-]</label><label class="expand" for="c-42312208">[1 more]</label></div><br/><div class="children"><div class="content">Go dependencies are not much different. You mostly import directly from github.com, and it&#x27;s a pain to review all the changelogs. Compared to Java&#x2F;.Net that traditionally have fewer better tested dependency updates.</div><br/></div></div><div id="42308534" class="c"><input type="checkbox" id="c-42308534" checked=""/><div class="controls bullet"><span class="by">oldgregg</span><span>|</span><a href="#42312208">prev</a><span>|</span><a href="#42313930">next</a><span>|</span><label class="collapse" for="c-42308534">[-]</label><label class="expand" for="c-42308534">[1 more]</label></div><br/><div class="children"><div class="content">I love the go+alpine+htmx+templ GAHT stack as long as I have defined and limited interaction needs. Things get tricky when you need more complex interaction because there isn&#x27;t much example&#x2F;LLM code out there for complex situations. Then you end up having your view code split between the server and some random JS on the front end and it kinda kills the simple GHAT fun.</div><br/></div></div><div id="42313930" class="c"><input type="checkbox" id="c-42313930" checked=""/><div class="controls bullet"><span class="by">molszanski</span><span>|</span><a href="#42308534">prev</a><span>|</span><a href="#42313626">next</a><span>|</span><label class="collapse" for="c-42313930">[-]</label><label class="expand" for="c-42313930">[1 more]</label></div><br/><div class="children"><div class="content">IDK, I haven&#x27;t changed the react dependencies in 5 years. Everything is the same and I am happy.</div><br/></div></div><div id="42313626" class="c"><input type="checkbox" id="c-42313626" checked=""/><div class="controls bullet"><span class="by">CaliViking</span><span>|</span><a href="#42313930">prev</a><span>|</span><label class="collapse" for="c-42313626">[-]</label><label class="expand" for="c-42313626">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t this also a Single Page Application (SPA) problem? To me, it looks like we are building monolithic Javascript applications that are running in a browser execution engine.
HTMX seems to be much more componentized.</div><br/></div></div></div></div></div></div></div></body></html>