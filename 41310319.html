<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724576472774" as="style"/><link rel="stylesheet" href="styles.css?v=1724576472774"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.trailofbits.com/2024/08/21/yolo-is-not-a-valid-hash-construction/">&quot;YOLO&quot; is not a valid hash construction</a> <span class="domain">(<a href="https://blog.trailofbits.com">blog.trailofbits.com</a>)</span></div><div class="subtext"><span>ssklash</span> | <span>66 comments</span></div><br/><div><div id="41342010" class="c"><input type="checkbox" id="c-41342010" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41341172">next</a><span>|</span><label class="collapse" for="c-41342010">[-]</label><label class="expand" for="c-41342010">[12 more]</label></div><br/><div class="children"><div class="content">&gt; The issue we run into here is ambiguous encoding.<p>What I have done in the past for this is to encode the messages as UTF-8 and separate them by 0xFF, since that byte value never occurs in UTF-8 encoding [0]. If the messages to be hashed are character strings, you have to decide on <i>some</i> encoding anyway in order to hash them.<p>[0] UTF-8 bytes always contain at least one zero bit: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;UTF-8#Encoding" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;UTF-8#Encoding</a>. Incidentally, if one wanted to create the UTF-8 equivalent of zero-terminated strings without reserving a character value (like NUL) as the sentinel value, one could use 0xFF for that.</div><br/><div id="41342508" class="c"><input type="checkbox" id="c-41342508" checked=""/><div class="controls bullet"><span class="by">oconnor663</span><span>|</span><a href="#41342010">parent</a><span>|</span><a href="#41344671">next</a><span>|</span><label class="collapse" for="c-41342508">[-]</label><label class="expand" for="c-41342508">[9 more]</label></div><br/><div class="children"><div class="content">I usually recommend an 8-byte length suffix for each piece instead of a separator.* That way you don&#x27;t need to make any assumptions about what bytes are legal. Putting the length in suffix position means you can still stream input into your hash state without knowing how long it&#x27;s going to be in advance, and 2^64 bytes is enough for any practical application. (The maximum input size of SHA-256 is less than this.)<p>I&#x27;m less sanguine than the authors about using Protobuf or CBOR for &quot;canonical&quot; serialization like this. I think it tends to &quot;work until it doesn&#x27;t&quot;. It&#x27;s not what these formats were designed for, and you have to ask awkward questions like &quot;is the order of struct fields guaranteed?&quot; and &quot;do integers always use the smallest possible representation?&quot;. This is more obvious for JSON, as the post points out, but every common serialization format I&#x27;m aware of has problems like this. I think we need a dedicated standard to do a good job of this, but I&#x27;m not aware of anything widespread. It&#x27;s a surprisingly hard problem.<p>* Technically you only need the suffix for each variable-length piece, and you can omit the first one. But it&#x27;s more complicated if the number of pieces is variable. (If you have two adjacent fixed-length pieces, and then you combine them, does the hash change?) This sort of penny-pinching is interesting to think about in a design that&#x27;s going to come with a giant set of test vectors, but it&#x27;s asking for trouble in an application doing something custom. This is another reason I&#x27;d like to have a standard here.</div><br/><div id="41342846" class="c"><input type="checkbox" id="c-41342846" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41342010">root</a><span>|</span><a href="#41342508">parent</a><span>|</span><a href="#41344294">next</a><span>|</span><label class="collapse" for="c-41342846">[-]</label><label class="expand" for="c-41342846">[5 more]</label></div><br/><div class="children"><div class="content">It depends on the use case. If, for example, you want to hash a username–password pair, I find<p><pre><code>    write(toUtf8(username));
    write((byte) 0xFF);  &#x2F;&#x2F; never occurs in UTF-8, hence unambiguous separator
    write(toUtf8(password));
</code></pre>
to be most straightforward and parsimonious, and the assumption is maximally local.</div><br/><div id="41342918" class="c"><input type="checkbox" id="c-41342918" checked=""/><div class="controls bullet"><span class="by">oconnor663</span><span>|</span><a href="#41342010">root</a><span>|</span><a href="#41342846">parent</a><span>|</span><a href="#41344294">next</a><span>|</span><label class="collapse" for="c-41342918">[-]</label><label class="expand" for="c-41342918">[4 more]</label></div><br/><div class="children"><div class="content">I agree that this approach works in the use case you&#x27;re describing, but there are a couple reasons I wouldn&#x27;t want to teach it broadly. Mainly, a caveat like &quot;remember to only use this with UTF-8 strings and not with arbitrary bytes&quot; is exactly the sort of thing applications routinely get wrong in the wild. Also, focusing on wacky edge cases, do we <i>really</i> know that our UTF-8 strings are valid UTF-8? Maybe we&#x27;re comfortable staking our security on that in a language like Rust, where invalid strings are literally undefined behavior anyway. But what about in Go for example, where this snippet writes 0xff to stdout with no warnings whatsoever?<p><pre><code>    func main() {
        s := string([]byte{0xff})
        fmt.Println(s)
    }</code></pre></div><br/><div id="41342949" class="c"><input type="checkbox" id="c-41342949" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41342010">root</a><span>|</span><a href="#41342918">parent</a><span>|</span><a href="#41344294">next</a><span>|</span><label class="collapse" for="c-41342949">[-]</label><label class="expand" for="c-41342949">[3 more]</label></div><br/><div class="children"><div class="content">&gt; do we really know that our UTF-8 strings are valid UTF-8?<p>I’m explicitly talking about cases where you UTF-8-encode right where you’re hashing.<p>With the length approach, you also have to take care you’re using the correct byte length, for example, and not forget the final length (i.e. it’s a suffix and not just a separator). And for user input like passwords, you’d probably want to NFC-canonicalize before hashing. There’s always things you have to pay attention to.<p>You can encapsulate it in a function that hashes a list of character strings passed as its (typed) argument. Then you have a safe and reusable function.</div><br/><div id="41343069" class="c"><input type="checkbox" id="c-41343069" checked=""/><div class="controls bullet"><span class="by">oconnor663</span><span>|</span><a href="#41342010">root</a><span>|</span><a href="#41342949">parent</a><span>|</span><a href="#41344294">next</a><span>|</span><label class="collapse" for="c-41343069">[-]</label><label class="expand" for="c-41343069">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I’m explicitly talking about cases where you UTF-8-encode right where you’re hashing.<p>Totally, I get that. I think what you&#x27;re pointing out is that in a language like Python for example, the scenario I&#x27;m trying to describe is meaningless. You can&#x27;t make an &quot;invalid string&quot; in Python (as far as I know, without resorting to FFI), because it checks things like that during string decoding, and it&#x27;ll just crash.<p>But languages like C&#x2F;C++&#x2F;Rust&#x2F;Go work differently. As these languages are commonly used, the string -&gt; UTF-8 step is actually a no-op, because the assumption is that strings are already UTF-8 in memory. (In C or C++ this is usually in the programmer&#x27;s head rather than in the types, but it&#x27;s a common choice.) In these languages it&#x27;s possible for the result of that no-op &quot;encoding&quot; to be invalid, if the input string was invalid somehow. This is a pretty weird edge case and almost certainly a bug that the application needs to fix fix anyway, but if we&#x27;re noodling about cryptography best practices, it might be nice to limit the &quot;blast radius&quot; of a bug like that.</div><br/><div id="41343583" class="c"><input type="checkbox" id="c-41343583" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41342010">root</a><span>|</span><a href="#41343069">parent</a><span>|</span><a href="#41344294">next</a><span>|</span><label class="collapse" for="c-41343583">[-]</label><label class="expand" for="c-41343583">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But languages like C&#x2F;C++&#x2F;Rust&#x2F;Go work differently. As these languages are commonly used, the string -&gt; UTF-8 step is actually a no-op, because the assumption is that strings are already UTF-8 in memory.<p>No.<p>Rust&#x27;s string types are explicitly UTF-8 text. If what you&#x27;ve got isn&#x27;t UTF-8 text, it&#x27;s not a Rust string type. Here&#x27;s the signature of the conversion you say is &quot;actually a no-op&quot;.<p>pub fn from_utf8(vec: Vec&lt;u8&gt;) -&gt; Result&lt;String, FromUtf8Error&gt;<p>That says if you&#x27;ve got a growable array of bytes and you claim it&#x27;s UTF-8 text, you can have a String back if you&#x27;re correct about that. If you were wrong you get a FromUtf8Error, which is a wrapper around that growable array and some diagnostic information.<p>Edited to add:<p>The reason I was looking at this thread is because of course Rust for its own purposes does exactly what layer8 describes - it emits a single 0xFF byte to separate strings <i>because</i> Rust&#x27;s strings are guaranteed UTF-8.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41344294" class="c"><input type="checkbox" id="c-41344294" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41342010">root</a><span>|</span><a href="#41342508">parent</a><span>|</span><a href="#41342846">prev</a><span>|</span><a href="#41342803">next</a><span>|</span><label class="collapse" for="c-41344294">[-]</label><label class="expand" for="c-41344294">[1 more]</label></div><br/><div class="children"><div class="content">bencode was designed to solve the canonicality problem. so is asn.1 cer. but it is sufficient to have an unambiguous encoding to prevent the vulnerabilities in this post; nonunique encodings will only produce interoperability problems, not security holes</div><br/></div></div><div id="41342803" class="c"><input type="checkbox" id="c-41342803" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#41342010">root</a><span>|</span><a href="#41342508">parent</a><span>|</span><a href="#41344294">prev</a><span>|</span><a href="#41344671">next</a><span>|</span><label class="collapse" for="c-41342803">[-]</label><label class="expand" for="c-41342803">[2 more]</label></div><br/><div class="children"><div class="content">Does that mean the random suffix is effectively a secret? Otherwise an attacker could construct inputs with the separator, achieving the same thing as a simple separator, right?</div><br/><div id="41342834" class="c"><input type="checkbox" id="c-41342834" checked=""/><div class="controls bullet"><span class="by">oconnor663</span><span>|</span><a href="#41342010">root</a><span>|</span><a href="#41342803">parent</a><span>|</span><a href="#41344671">next</a><span>|</span><label class="collapse" for="c-41342834">[-]</label><label class="expand" for="c-41342834">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a random suffix, but a length suffix. So for example putting &quot;hello&quot; and &quot;world!&quot; together looks like &quot;hello&quot; | 5 | &quot;world!&quot; | 6. Concretely, you probably represent 5 and 6 as eight little-endian bytes, i.e. `n.to_bytes(8, &#x27;little&#x27;)` in Python. If you want to stop attackers from guessing&#x2F;constructing hashes, you need to get a secret key involved, which is what the &quot;YoloMAC&quot; section of the post is about.</div><br/></div></div></div></div></div></div><div id="41344671" class="c"><input type="checkbox" id="c-41344671" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41342010">parent</a><span>|</span><a href="#41342508">prev</a><span>|</span><a href="#41342429">next</a><span>|</span><label class="collapse" for="c-41344671">[-]</label><label class="expand" for="c-41344671">[1 more]</label></div><br/><div class="children"><div class="content">If your data can&#x27;t contain a NUL byte then you could just XOR all the bytes of the message by the separator character byte itself.</div><br/></div></div><div id="41342429" class="c"><input type="checkbox" id="c-41342429" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#41342010">parent</a><span>|</span><a href="#41344671">prev</a><span>|</span><a href="#41341172">next</a><span>|</span><label class="collapse" for="c-41342429">[-]</label><label class="expand" for="c-41342429">[1 more]</label></div><br/><div class="children"><div class="content">That actually makes more sense than the usual opposite approach of using over-long encoding for NULs in the data.</div><br/></div></div></div></div><div id="41341172" class="c"><input type="checkbox" id="c-41341172" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41342010">prev</a><span>|</span><a href="#41341203">next</a><span>|</span><label class="collapse" for="c-41341172">[-]</label><label class="expand" for="c-41341172">[17 more]</label></div><br/><div class="children"><div class="content">This is a good post, but there&#x27;s a little too much ritual in here about password-based KDFs for my taste. Put all the mainstream KDFs on a dartboard, yes including PBKDF2, and throw a dart. I think you&#x27;ll be fine. Bcrypt, the most popular password hash, has held up surprisingly well, and scrypt might still be one of the best options.</div><br/><div id="41341458" class="c"><input type="checkbox" id="c-41341458" checked=""/><div class="controls bullet"><span class="by">Vecr</span><span>|</span><a href="#41341172">parent</a><span>|</span><a href="#41342092">next</a><span>|</span><label class="collapse" for="c-41341458">[-]</label><label class="expand" for="c-41341458">[9 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no point intentionally making your implementation weaker than it has to be.</div><br/><div id="41341730" class="c"><input type="checkbox" id="c-41341730" checked=""/><div class="controls bullet"><span class="by">delusional</span><span>|</span><a href="#41341172">root</a><span>|</span><a href="#41341458">parent</a><span>|</span><a href="#41342092">next</a><span>|</span><label class="collapse" for="c-41341730">[-]</label><label class="expand" for="c-41341730">[8 more]</label></div><br/><div class="children"><div class="content">The complement is also true. There&#x27;s no point in making it stronger than it has to be.<p>If I have this box that says Bcrypt, but scrypt might be better. I can either spend a bunch of time re-implementing scrypt, or I can shove Bcrypt into there and move on. If Bcrypt is sufficient, then I don&#x27;t really care if scrypt would be &quot;better&quot;</div><br/><div id="41341850" class="c"><input type="checkbox" id="c-41341850" checked=""/><div class="controls bullet"><span class="by">Vecr</span><span>|</span><a href="#41341172">root</a><span>|</span><a href="#41341730">parent</a><span>|</span><a href="#41342092">next</a><span>|</span><label class="collapse" for="c-41341850">[-]</label><label class="expand" for="c-41341850">[7 more]</label></div><br/><div class="children"><div class="content">I think tptacek is talking about a ground-up design, in that case I think you should use Argon2id. Using something weaker is not really needed, turn the parallelism down to 1 and then start reducing the rounds and memory until it works for your case.</div><br/><div id="41342145" class="c"><input type="checkbox" id="c-41342145" checked=""/><div class="controls bullet"><span class="by">Aachen</span><span>|</span><a href="#41341172">root</a><span>|</span><a href="#41341850">parent</a><span>|</span><a href="#41342084">next</a><span>|</span><label class="collapse" for="c-41342145">[-]</label><label class="expand" for="c-41342145">[5 more]</label></div><br/><div class="children"><div class="content">The LUKS2 source code mentions there is an attack on Argon2 which they prevent by setting rounds to 2 or 4 iirc. Not sure what that&#x27;s about though, would need to look it up again but perhaps heed the recommended settings to avoid such pitfalls<p>As for parallelism=1, why would you do that? My understanding is that you want it to a point where it&#x27;ll saturate your memory bus because then you&#x27;re getting the most out of your system -&gt; making it the hardest for the attacker. (Pretty sure this takes more than one thread on a modern system because I&#x27;ve tested that argon2id with the same number of rounds and memory gets faster with more threads.) Beyond that, increasing memory usage is good because that dominates the die space of an ASIC which in turn dominates the cost, if I remember and understood the argon2 paper correctly. The repetitions value is the last thing to touch, namely when you&#x27;ve run out of threads and usable RAM (such as when it gets into DoS territory)<p>(I focus on argon2 because that&#x27;s what I&#x27;ve read up on. Scrypt is also a good option but I&#x27;m not sure the same advice applies because it has this TMTO attack. The underlying concepts will be the same of course, but tweaking one parameter before another may play into the attacker&#x27;s hand.)</div><br/><div id="41342388" class="c"><input type="checkbox" id="c-41342388" checked=""/><div class="controls bullet"><span class="by">Vecr</span><span>|</span><a href="#41341172">root</a><span>|</span><a href="#41342145">parent</a><span>|</span><a href="#41342084">next</a><span>|</span><label class="collapse" for="c-41342388">[-]</label><label class="expand" for="c-41342388">[4 more]</label></div><br/><div class="children"><div class="content">No. The parallelism is an upper bound, higher reduces security. If you&#x27;re running a server for multiple clients each client should only get one thread for argon2 anyway, more won&#x27;t help your overall throughput.</div><br/><div id="41343328" class="c"><input type="checkbox" id="c-41343328" checked=""/><div class="controls bullet"><span class="by">Aachen</span><span>|</span><a href="#41341172">root</a><span>|</span><a href="#41342388">parent</a><span>|</span><a href="#41342084">next</a><span>|</span><label class="collapse" for="c-41343328">[-]</label><label class="expand" for="c-41343328">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not understanding the <i>why</i> behind that claim</div><br/><div id="41345349" class="c"><input type="checkbox" id="c-41345349" checked=""/><div class="controls bullet"><span class="by">rstuart4133</span><span>|</span><a href="#41341172">root</a><span>|</span><a href="#41343328">parent</a><span>|</span><a href="#41343761">next</a><span>|</span><label class="collapse" for="c-41345349">[-]</label><label class="expand" for="c-41345349">[1 more]</label></div><br/><div class="children"><div class="content">PBKDF2 makes it harder by using more ALU related functions to calculate the key.  The problem is ALU&#x27;s are rather easy to add to a chip, which means it is relatively easy to increase parallelism.  ALU parallelism is I&#x27;m guessing what you are thinking of.<p>The others target other constraints, with varying degrees of success.  Scrypt for example targets the connection between the CPU chip and DRAM.  It doesn&#x27;t use a lot of CPU time, but rather jumps in a very random way over a whole pile of memory.  So adding ALU&#x27;s doesn&#x27;t help you crack scrypt.  You have to increase memory bandwidth.  How fast you can access memory is effectively limited by the numbers of pins you can put on a die, and the number of pins is far harder to increase that the number of ALU&#x27;s.<p>So the answer is yes parallelism always helps, but if you chose the things that constrains you to stuff that is hard to add (like pins) adding that parallelism is hard.</div><br/></div></div><div id="41343761" class="c"><input type="checkbox" id="c-41343761" checked=""/><div class="controls bullet"><span class="by">Vecr</span><span>|</span><a href="#41341172">root</a><span>|</span><a href="#41343328">parent</a><span>|</span><a href="#41345349">prev</a><span>|</span><a href="#41342084">next</a><span>|</span><label class="collapse" for="c-41343761">[-]</label><label class="expand" for="c-41343761">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been a while, I thought it was something to do with the blocks but it probably depends on what the exact state of the art is for cracking at this point.<p>Don&#x27;t put it any higher than 4, that&#x27;s for sure.<p>In theory a parallelism on 1 should make it so the information required to do the next step has to be computed linearly (think of the dependency graph, it should look like a line instead of diverging then converging) but it&#x27;s possible that either never worked or got cracked.</div><br/></div></div></div></div></div></div></div></div><div id="41342084" class="c"><input type="checkbox" id="c-41342084" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41341172">root</a><span>|</span><a href="#41341850">parent</a><span>|</span><a href="#41342145">prev</a><span>|</span><a href="#41342092">next</a><span>|</span><label class="collapse" for="c-41342084">[-]</label><label class="expand" for="c-41342084">[1 more]</label></div><br/><div class="children"><div class="content">I would probably still reach for scrypt.</div><br/></div></div></div></div></div></div></div></div><div id="41342092" class="c"><input type="checkbox" id="c-41342092" checked=""/><div class="controls bullet"><span class="by">Aachen</span><span>|</span><a href="#41341172">parent</a><span>|</span><a href="#41341458">prev</a><span>|</span><a href="#41341973">next</a><span>|</span><label class="collapse" for="c-41342092">[-]</label><label class="expand" for="c-41342092">[3 more]</label></div><br/><div class="children"><div class="content">Still a difference between &quot;you&#x27;ll be fine&quot; and &quot;if you&#x27;re newly choosing, might as well <i>not</i> pick PBKDF2 where anyone with a regular GPU gets a 100x speedup compared to your server CPU&quot;. Bcrypt wasn&#x27;t even designed for memory hardness but is so much more annoying to crack because it seems to stress (per my understanding) the GPU&#x27;s memory bus <i>just</i> enough with the iirc 4k state table that&#x27;s being randomly accessed</div><br/><div id="41342174" class="c"><input type="checkbox" id="c-41342174" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41341172">root</a><span>|</span><a href="#41342092">parent</a><span>|</span><a href="#41341973">next</a><span>|</span><label class="collapse" for="c-41342174">[-]</label><label class="expand" for="c-41342174">[2 more]</label></div><br/><div class="children"><div class="content">In the browser, PBKDF2 can still make sense, because all modern browsers support it via <i>SubtleCrypto.deriveKey()</i>, and you may want to avoid the overhead of a JS-implemented alternative. Just select the maximum iteration count that is still acceptable for your use case and targeted devices (mobile devices tend to be the slowest).</div><br/><div id="41342210" class="c"><input type="checkbox" id="c-41342210" checked=""/><div class="controls bullet"><span class="by">Aachen</span><span>|</span><a href="#41341172">root</a><span>|</span><a href="#41342174">parent</a><span>|</span><a href="#41341973">next</a><span>|</span><label class="collapse" for="c-41342210">[-]</label><label class="expand" for="c-41342210">[1 more]</label></div><br/><div class="children"><div class="content">Very true. May make sense to check how WASM implementations stack up, though. Makes me realise I don&#x27;t even know if WASM does multithreading; maybe via background workers?</div><br/></div></div></div></div></div></div><div id="41341973" class="c"><input type="checkbox" id="c-41341973" checked=""/><div class="controls bullet"><span class="by">vintermann</span><span>|</span><a href="#41341172">parent</a><span>|</span><a href="#41342092">prev</a><span>|</span><a href="#41342154">next</a><span>|</span><label class="collapse" for="c-41341973">[-]</label><label class="expand" for="c-41341973">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it was conspicuous to me that for the two other examples, they mentioned &quot;this has been used in a real attack!&quot;, but for key derivation functions, they didn&#x27;t say that.<p>Sure, you should still use Argon2.</div><br/></div></div><div id="41342154" class="c"><input type="checkbox" id="c-41342154" checked=""/><div class="controls bullet"><span class="by">FreakLegion</span><span>|</span><a href="#41341172">parent</a><span>|</span><a href="#41341973">prev</a><span>|</span><a href="#41341203">next</a><span>|</span><label class="collapse" for="c-41342154">[-]</label><label class="expand" for="c-41342154">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;d draw a line at the post&#x27;s NIST-adjacent advice.<p>With the caveat that I may be up to two years out of date here: Last I checked Balloon was a bad choice (only a research implementation) and Argon2 didn&#x27;t meet the requirements (unapproved primitive in BLAKE2).<p>With enough rigamarole can you get these into a government office? Probably. But scrypt and yescrypt (the default on most Linux systems) already fit the bill, so just use one of those.</div><br/><div id="41342901" class="c"><input type="checkbox" id="c-41342901" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41341172">root</a><span>|</span><a href="#41342154">parent</a><span>|</span><a href="#41341203">next</a><span>|</span><label class="collapse" for="c-41342901">[-]</label><label class="expand" for="c-41342901">[2 more]</label></div><br/><div class="children"><div class="content">I have a really hard time taking the attack research on password KDFs all that seriously. I don&#x27;t think there are many common threat models where &quot;weaknesses&quot; in password hashes are more than marginal issues.<p>Not using a real password KDF is a big issue. Using the wrong one, not so much.</div><br/><div id="41343496" class="c"><input type="checkbox" id="c-41343496" checked=""/><div class="controls bullet"><span class="by">FreakLegion</span><span>|</span><a href="#41341172">root</a><span>|</span><a href="#41342901">parent</a><span>|</span><a href="#41341203">next</a><span>|</span><label class="collapse" for="c-41343496">[-]</label><label class="expand" for="c-41343496">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t disagree at all. My comment is about paperwork and selling to the government (&quot;operating in the FIPS world&quot;, as the post has it, where NIST enters the conversation). I&#x27;m sure you can get away with tacking PBKDF2 onto Argon2 here, but those are hoops you don&#x27;t need to jump through.</div><br/></div></div></div></div></div></div></div></div><div id="41341203" class="c"><input type="checkbox" id="c-41341203" checked=""/><div class="controls bullet"><span class="by">trainofbit</span><span>|</span><a href="#41341172">prev</a><span>|</span><a href="#41341976">next</a><span>|</span><label class="collapse" for="c-41341203">[-]</label><label class="expand" for="c-41341203">[6 more]</label></div><br/><div class="children"><div class="content">The RFC recommendation for 1G RAM or 64MB Argon PKDF is insane. Don&#x27;t follow this advice. In a real world server, any API endpoint using this advice will quickly become a DOS vector. A saner value is 1MB for Argon. It stills blocks major GPU attacks, which is the whole point.</div><br/><div id="41341373" class="c"><input type="checkbox" id="c-41341373" checked=""/><div class="controls bullet"><span class="by">galdor</span><span>|</span><a href="#41341203">parent</a><span>|</span><a href="#41342081">next</a><span>|</span><label class="collapse" for="c-41341373">[-]</label><label class="expand" for="c-41341373">[2 more]</label></div><br/><div class="children"><div class="content">OWASP recommendations for Argon2id are 19MiB memory, iterations 2, parallelism 1. And following OWASP is not only a good idea for security but also makes it easy to justify with IT security, compliance, etc.</div><br/><div id="41341381" class="c"><input type="checkbox" id="c-41341381" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41341203">root</a><span>|</span><a href="#41341373">parent</a><span>|</span><a href="#41342081">next</a><span>|</span><label class="collapse" for="c-41341381">[-]</label><label class="expand" for="c-41341381">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been a little while since I&#x27;ve looked carefully but I would not take OWASP especially seriously on matters of cryptography. It helps to understand that OWASP is more of an affinity group than a carefully structured authority, and some of its official recommendations are more akin to wiki pages than real standards.</div><br/></div></div></div></div><div id="41342081" class="c"><input type="checkbox" id="c-41342081" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41341203">parent</a><span>|</span><a href="#41341373">prev</a><span>|</span><a href="#41341976">next</a><span>|</span><label class="collapse" for="c-41342081">[-]</label><label class="expand" for="c-41342081">[3 more]</label></div><br/><div class="children"><div class="content">You have to be careful to toss around gigabytes, but what&#x27;s unreasonable about 64MB?  You should only be running about one per core, right?.</div><br/><div id="41343592" class="c"><input type="checkbox" id="c-41343592" checked=""/><div class="controls bullet"><span class="by">lmz</span><span>|</span><a href="#41341203">root</a><span>|</span><a href="#41342081">parent</a><span>|</span><a href="#41341976">next</a><span>|</span><label class="collapse" for="c-41343592">[-]</label><label class="expand" for="c-41343592">[2 more]</label></div><br/><div class="children"><div class="content">Some people run more threads than cores and if they do the KDF in the same thread you can see how that will end poorly.</div><br/><div id="41344015" class="c"><input type="checkbox" id="c-41344015" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41341203">root</a><span>|</span><a href="#41343592">parent</a><span>|</span><a href="#41341976">next</a><span>|</span><label class="collapse" for="c-41344015">[-]</label><label class="expand" for="c-41344015">[1 more]</label></div><br/><div class="children"><div class="content">Somewhat more threads is fine too.  If it&#x27;s <i>tons</i> of uncontrolled threads then they have a problem of fighting and slowdown even if memory use was zero, and once they fix that 64MB will also stop being a problem.</div><br/></div></div></div></div></div></div></div></div><div id="41341976" class="c"><input type="checkbox" id="c-41341976" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41341203">prev</a><span>|</span><a href="#41342487">next</a><span>|</span><label class="collapse" for="c-41341976">[-]</label><label class="expand" for="c-41341976">[2 more]</label></div><br/><div class="children"><div class="content">&gt; While Keccak doesn’t suffer from the length-extension attacks that HMAC is meant to address, the phrase “simply prepending the message with the key” carries a lot of assumptions about key length and key formatting with it.<p>A <i>lot</i> of assumptions, or just that it&#x27;s fixed length?</div><br/><div id="41342116" class="c"><input type="checkbox" id="c-41342116" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#41341976">parent</a><span>|</span><a href="#41342487">next</a><span>|</span><label class="collapse" for="c-41342116">[-]</label><label class="expand" for="c-41342116">[1 more]</label></div><br/><div class="children"><div class="content">also that the key is never used for anything else (which could allow for unintentional collisions)</div><br/></div></div></div></div><div id="41342487" class="c"><input type="checkbox" id="c-41342487" checked=""/><div class="controls bullet"><span class="by">blauditore</span><span>|</span><a href="#41341976">prev</a><span>|</span><a href="#41341120">next</a><span>|</span><label class="collapse" for="c-41342487">[-]</label><label class="expand" for="c-41342487">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m no expert and a bit tired, but: Is the problem around hashing password + salt for a key just about the fact it can be brute-forced with enough recources, or did I miss something?</div><br/><div id="41342756" class="c"><input type="checkbox" id="c-41342756" checked=""/><div class="controls bullet"><span class="by">lilyball</span><span>|</span><a href="#41342487">parent</a><span>|</span><a href="#41341120">next</a><span>|</span><label class="collapse" for="c-41342756">[-]</label><label class="expand" for="c-41342756">[3 more]</label></div><br/><div class="children"><div class="content">Basically, yeah. It sounds like the problem is the difficulty of cracking it scales linearly, and a ton of work has gone into figuring out how to efficiently crack it. Modern KDFs are memory-hard, which is a resource that&#x27;s a lot harder&#x2F;more expensive to scale than computing power.</div><br/><div id="41343744" class="c"><input type="checkbox" id="c-41343744" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41342487">root</a><span>|</span><a href="#41342756">parent</a><span>|</span><a href="#41341120">next</a><span>|</span><label class="collapse" for="c-41343744">[-]</label><label class="expand" for="c-41343744">[2 more]</label></div><br/><div class="children"><div class="content">But as Thomas points out, this is almost certainly not a problem you should actually care about.<p>If the user of your new Shiny Goat service used the password &quot;ShinyGoat&quot; then all the memory hard KDF shenanigans in the world won&#x27;t help, attackers will guess &quot;ShinyGoat&quot;, and that&#x27;s correct, they&#x27;re in.<p>If another user chose a 32 random alphanumerics then it doesn&#x27;t matter if you just dropped in PBKDF2 with whatever default settings because the attackers couldn&#x27;t guess 32 random alphanumerics no matter what.<p>The KDF comes into the picture only for users who&#x27;ve chosen aggressively mediocre passwords. Not so easy attackers will definitely guess them, not so hard that it&#x27;s impossible. Users who insist their &quot;password&quot; must be a single English word, or who insist on memorizing their passwords and so nothing longer than six characters is acceptable. That sort of thing. The attackers <i>can</i> guess these passwords, but they need a <i>lot</i> of guesses so the KDF can make it impractical.<p>That&#x27;s just not a plausible scenario for a real world attack and therefore it should not be a focus for your attention. You should use a real KDF, but PBKDF2 is fine for this purpose, any time you spend arguing about which KDF to use or implementing a different KDF, rather than solving actual defects in your system&#x27;s security is a bad trade.</div><br/><div id="41344611" class="c"><input type="checkbox" id="c-41344611" checked=""/><div class="controls bullet"><span class="by">lilyball</span><span>|</span><a href="#41342487">root</a><span>|</span><a href="#41343744">parent</a><span>|</span><a href="#41341120">next</a><span>|</span><label class="collapse" for="c-41344611">[-]</label><label class="expand" for="c-41344611">[1 more]</label></div><br/><div class="children"><div class="content">PBKDF2 is at least better than YoloPBKDF (which looks rather like PBKDF1). Besides brute-forcing, YoloPBKDF&#x2F;PBKDF1 has a maximum key length (the length of the hash function output) whereas PBKDF2 can construct longer keys. PBKDF2 also uses a pseudorandom function like HMAC-SHA-1 instead of just a hash function, and I&#x27;m assuming that change was done because it strengthens the security in some fashion.<p>In any case, if you have the choice of making &quot;aggressively mediocre&quot; passwords harder to crack, is there a reason not to do so?</div><br/></div></div></div></div></div></div></div></div><div id="41341907" class="c"><input type="checkbox" id="c-41341907" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#41341120">prev</a><span>|</span><a href="#41344522">next</a><span>|</span><label class="collapse" for="c-41341907">[-]</label><label class="expand" for="c-41341907">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s interesting that using JSON encoding for all messages eliminates many of the problems.<p>ambiguous encoding? Nothing ambiguous about JSON, you don&#x27;t even need any separator. Or merge them into json array.<p>length-extension attacks? appending non-whitespace to json makes it invalid (for sane decoders at least)</div><br/><div id="41342311" class="c"><input type="checkbox" id="c-41342311" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41341907">parent</a><span>|</span><a href="#41344522">next</a><span>|</span><label class="collapse" for="c-41342311">[-]</label><label class="expand" for="c-41342311">[2 more]</label></div><br/><div class="children"><div class="content">Yes, but there are lots of ways to get different encodings (and therefore hashes) for the same data: whitespace, JSON object key order, and the different ways of escaping characters.<p>If you want a <i>unique</i> hash (like, for a hash table lookup) then you&#x27;ll need to sort the keys of every object and use a particular implementation of JSON.stringify.<p>(Also, what do you mean by &quot;you don&#x27;t even need any separator?&quot;)</div><br/><div id="41342462" class="c"><input type="checkbox" id="c-41342462" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#41341907">root</a><span>|</span><a href="#41342311">parent</a><span>|</span><a href="#41344522">next</a><span>|</span><label class="collapse" for="c-41342462">[-]</label><label class="expand" for="c-41342462">[1 more]</label></div><br/><div class="children"><div class="content">XML has a complex solution for this, canonicalization[1], to enable signed XMLs[2]. Seems some folks are trying the same with JSON[3].<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Canonical_XML" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Canonical_XML</a><p>[2]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;XML_Signature" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;XML_Signature</a><p>[3]: <a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc8785" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc8785</a></div><br/></div></div></div></div></div></div><div id="41344522" class="c"><input type="checkbox" id="c-41344522" checked=""/><div class="controls bullet"><span class="by">hiddencost</span><span>|</span><a href="#41341907">prev</a><span>|</span><a href="#41340814">next</a><span>|</span><label class="collapse" for="c-41344522">[-]</label><label class="expand" for="c-41344522">[3 more]</label></div><br/><div class="children"><div class="content">Oh fun. They actually give some erroneous advice.<p>Proto bufs don&#x27;t guarantee consistent serialization.</div><br/><div id="41344633" class="c"><input type="checkbox" id="c-41344633" checked=""/><div class="controls bullet"><span class="by">JoachimSchipper</span><span>|</span><a href="#41344522">parent</a><span>|</span><a href="#41344883">next</a><span>|</span><label class="collapse" for="c-41344633">[-]</label><label class="expand" for="c-41344633">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not ideal, but it&#x27;s not a cryptographic risk.<p>Using an encoding that (like Protobuf) has multiple representations for a message may cause you problems if you switch implementations - sha256(encode(msg)) might yield different hashes on different implementations of encode().<p>But the main risk is an encoding that has multiple interpretations of a single encoding (e.g. sha256(encode(&quot;admin&quot;, &quot;true&quot;)) == sha256(encode(&quot;admint&quot;, &quot;rue&quot;))), and Protobuf (can be unserialized, and thus) doesn&#x27;t have <i>that</i> problem.</div><br/></div></div><div id="41344883" class="c"><input type="checkbox" id="c-41344883" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#41344522">parent</a><span>|</span><a href="#41344633">prev</a><span>|</span><a href="#41340814">next</a><span>|</span><label class="collapse" for="c-41344883">[-]</label><label class="expand" for="c-41344883">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Note that, while many serialization methods will create unambiguous encodings, they don’t all necessarily produce unique encodings. For instance, JSON is largely insensitive to changes in whitespace and element ordering, so using JSON serializations produced by different libraries could lead to different hashes. Be careful!</div><br/></div></div></div></div><div id="41340814" class="c"><input type="checkbox" id="c-41340814" checked=""/><div class="controls bullet"><span class="by">krackers</span><span>|</span><a href="#41344522">prev</a><span>|</span><a href="#41341056">next</a><span>|</span><label class="collapse" for="c-41340814">[-]</label><label class="expand" for="c-41340814">[8 more]</label></div><br/><div class="children"><div class="content">A cryptography course should be mandated in the curriculum of most universities, just so people gain some intuition about the types of attacks that are possible. Just yelling &quot;don&#x27;t roll your own crypto&quot; isn&#x27;t practical advice when most issues come from misusing primitives or combining primitives in a &quot;weak&quot; manner.</div><br/><div id="41344168" class="c"><input type="checkbox" id="c-41344168" checked=""/><div class="controls bullet"><span class="by">nick238</span><span>|</span><a href="#41340814">parent</a><span>|</span><a href="#41342070">next</a><span>|</span><label class="collapse" for="c-41344168">[-]</label><label class="expand" for="c-41344168">[1 more]</label></div><br/><div class="children"><div class="content">Software engineers should be made aware of such pitfalls, but I don&#x27;t think a whole course is necessary or useful. It&#x27;s very easy to build encryption that you can&#x27;t crack, especially because the &quot;types of attacks&quot; is a truly endless font.<p>It&#x27;s probably more useful to have a module within a course to discuss the current state of the art and learning some history about how the methods were chosen (e.g. NIST&#x27;s AES, SHA2&#x2F;3, and PQC open processes. I think making it very obvious that there are extremely good, quality, free tools out there would reduce the likelihood of someone DIYing some crap.<p>That said, I once spec&#x27;d using Ed25519 asymmetric signatures for webhooks sent out to customers, and later on one of our Elixir developers was complaining that the throughput was garbage. I was confused because <a href="https:&#x2F;&#x2F;ed25519.cr.yp.to&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ed25519.cr.yp.to&#x2F;</a> boasts signing rates of ~27k&#x2F;sec&#x2F;core on very old hardware. Turns out they were using some &quot;pure Elixir&quot; library which had shit (over 1000x worse) performance. There wasn&#x27;t any real surface area for attacks here, but there are plenty of devs who will blindly search package-manager-of-choice for an otherwise good encryption and get screwed. Not sure who blame in that scenario.</div><br/></div></div><div id="41342070" class="c"><input type="checkbox" id="c-41342070" checked=""/><div class="controls bullet"><span class="by">axoltl</span><span>|</span><a href="#41340814">parent</a><span>|</span><a href="#41344168">prev</a><span>|</span><a href="#41341052">next</a><span>|</span><label class="collapse" for="c-41342070">[-]</label><label class="expand" for="c-41342070">[2 more]</label></div><br/><div class="children"><div class="content">Speaking as someone that has both broken crypto systems and designed ones that got broken (internally, in review, before they made it out), it takes a lot of practice to become proficient at cryptography. Sometimes a little bit of knowledge is worse than none at all.</div><br/><div id="41343062" class="c"><input type="checkbox" id="c-41343062" checked=""/><div class="controls bullet"><span class="by">gopher_space</span><span>|</span><a href="#41340814">root</a><span>|</span><a href="#41342070">parent</a><span>|</span><a href="#41341052">next</a><span>|</span><label class="collapse" for="c-41343062">[-]</label><label class="expand" for="c-41343062">[1 more]</label></div><br/><div class="children"><div class="content">The problem with repeating &quot;don&#x27;t roll your own&quot; is that you&#x27;re <i>also</i> going to cock up implementing someone else&#x27;s solution.</div><br/></div></div></div></div><div id="41341052" class="c"><input type="checkbox" id="c-41341052" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41340814">parent</a><span>|</span><a href="#41342070">prev</a><span>|</span><a href="#41341704">next</a><span>|</span><label class="collapse" for="c-41341052">[-]</label><label class="expand" for="c-41341052">[3 more]</label></div><br/><div class="children"><div class="content">Do you have any hard evidence that somehow mandating a &quot;cryptography course&quot; fixes this?<p>My guess is that it doesn&#x27;t help and might even make things worse because now they&#x27;ll think &quot;Don&#x27;t roll your own&quot; was an instruction to plebs who didn&#x27;t take that one semester cryptography course at school.</div><br/><div id="41341759" class="c"><input type="checkbox" id="c-41341759" checked=""/><div class="controls bullet"><span class="by">reubenmorais</span><span>|</span><a href="#41340814">root</a><span>|</span><a href="#41341052">parent</a><span>|</span><a href="#41341790">next</a><span>|</span><label class="collapse" for="c-41341759">[-]</label><label class="expand" for="c-41341759">[1 more]</label></div><br/><div class="children"><div class="content">The cryptography course in my bachelor&#x27;s was good enough to paint a picture of the complexity involved. By then I had already heard the &quot;don&#x27;t roll your own crypto&quot; mantra, so maybe that primed me, but the semester course helped to get an appreciation for the subtle ways information leaks when you try to contain it. It also gave me some more confidence to push back if for example a colleague tried to convince me that the mantra doesn&#x27;t apply to them&#x2F;us.<p>Obviously you can&#x27;t mandate a high quality course into existence, but I definitely good value out of having it in the required curriculum.</div><br/></div></div><div id="41341790" class="c"><input type="checkbox" id="c-41341790" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#41340814">root</a><span>|</span><a href="#41341052">parent</a><span>|</span><a href="#41341759">prev</a><span>|</span><a href="#41341704">next</a><span>|</span><label class="collapse" for="c-41341790">[-]</label><label class="expand" for="c-41341790">[1 more]</label></div><br/><div class="children"><div class="content">My primary takeaway from the cryptography course I took was a good understanding of <i>why</i> I shouldn&#x27;t try to roll my own crypto, but a lot of that came down to the course design. Mine spent significantly more time on covering how various cryptography schemes were broken than on how to implement things, and a course which was the other way around could easily inspire false confidence.</div><br/></div></div></div></div><div id="41341704" class="c"><input type="checkbox" id="c-41341704" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#41340814">parent</a><span>|</span><a href="#41341052">prev</a><span>|</span><a href="#41341056">next</a><span>|</span><label class="collapse" for="c-41341704">[-]</label><label class="expand" for="c-41341704">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen crypto papers (and cited!) that are worse than this advice. Not sure what you are trying to say here.</div><br/></div></div></div></div><div id="41341056" class="c"><input type="checkbox" id="c-41341056" checked=""/><div class="controls bullet"><span class="by">playingalong</span><span>|</span><a href="#41340814">prev</a><span>|</span><a href="#41340867">next</a><span>|</span><label class="collapse" for="c-41341056">[-]</label><label class="expand" for="c-41341056">[6 more]</label></div><br/><div class="children"><div class="content">The article is not that different than &quot;don&#x27;t invent your own cryptography&quot;.<p>It&#x27;s hard to understand for non-crypto specialists. It uses notions which are unknown to most programmers like MAC or other *MACs.<p>So not sure who is the target audience for this.</div><br/><div id="41343464" class="c"><input type="checkbox" id="c-41343464" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#41341056">parent</a><span>|</span><a href="#41341176">next</a><span>|</span><label class="collapse" for="c-41343464">[-]</label><label class="expand" for="c-41343464">[1 more]</label></div><br/><div class="children"><div class="content">The problem with the general assertion, &quot;don&#x27;t roll your own crypto&quot;, is the potential for implicit-misconstruction-by-contrast of professionally rolled cryptography being a pluggable, install-and-forget black box solution.<p>This is of course bunk, because the boundary layer and level of abstraction matters, and the apparent target audience for this content marketing piece is any developer that might fall into the trap of assuming otherwise. The selection, integration, and configuration of cryptographic elements into an application carries as much significance for the strength of the resulting cryptosystem as the cryptographic qualities of the elements themselves, especially when considered by an attacker that seeks to drive a wedge into any gap available.<p>The article is obviously far from a comprehensive survey on the topic but does zero in on a few of the practical cases for hash functions, although you&#x27;re not obliged to necessarily draw the same conclusions since (as the comments in these threads reveal) there are more alternatives than those directly discussed.</div><br/></div></div><div id="41341176" class="c"><input type="checkbox" id="c-41341176" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41341056">parent</a><span>|</span><a href="#41343464">prev</a><span>|</span><a href="#41341482">next</a><span>|</span><label class="collapse" for="c-41341176">[-]</label><label class="expand" for="c-41341176">[1 more]</label></div><br/><div class="children"><div class="content">Trail runs a cryptography practice that does assurance work for cryptography engineers. They&#x27;re not writing to encourage randomly-selected HN readers to design their own cryptosystems.</div><br/></div></div><div id="41341482" class="c"><input type="checkbox" id="c-41341482" checked=""/><div class="controls bullet"><span class="by">yarg</span><span>|</span><a href="#41341056">parent</a><span>|</span><a href="#41341176">prev</a><span>|</span><a href="#41341127">next</a><span>|</span><label class="collapse" for="c-41341482">[-]</label><label class="expand" for="c-41341482">[1 more]</label></div><br/><div class="children"><div class="content">It was simple enough for me as a non-crypto guy - in fact, it seemed mostly obvious.</div><br/></div></div><div id="41341127" class="c"><input type="checkbox" id="c-41341127" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#41341056">parent</a><span>|</span><a href="#41341482">prev</a><span>|</span><a href="#41341803">next</a><span>|</span><label class="collapse" for="c-41341127">[-]</label><label class="expand" for="c-41341127">[1 more]</label></div><br/><div class="children"><div class="content">It is essentially “don’t roll your own crypto”, but instead being screeds of complexity it just highlights a few very basic and simple things that seem “obviously fine” to folk that are unfamiliar (eg doesn’t touch on any complex reasons for it being bad, and doesn’t just say “you’re stupid”). It then gives examples of these basic problems causing real world failures, and it then just says “this is what you should use instead”.<p>Eg it’s very to-the-point, doesn’t spend all its time talking about how the professionals are awesome and better than you, and gives actionable recommendations. Most “don’t roll your own crypto” articles don’t do that and just come off as being elitist, and don’t actually _help_ the reader.</div><br/></div></div></div></div></div></div></div></div></div></body></html>