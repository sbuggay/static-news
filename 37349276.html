<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693818074588" as="style"/><link rel="stylesheet" href="styles.css?v=1693818074588"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://goto.ucsd.edu/~ucsdpl-blog/liquidtypes/2015/09/19/liquid-types/">A Gentle Introduction to Liquid Types</a> <span class="domain">(<a href="https://goto.ucsd.edu">goto.ucsd.edu</a>)</span></div><div class="subtext"><span>marvinborner</span> | <span>58 comments</span></div><br/><div><div id="37376010" class="c"><input type="checkbox" id="c-37376010" checked=""/><div class="controls bullet"><span class="by">one-punch</span><span>|</span><a href="#37376161">next</a><span>|</span><label class="collapse" for="c-37376010">[-]</label><label class="expand" for="c-37376010">[8 more]</label></div><br/><div class="children"><div class="content">Liquid Types enabled a 6x speed up in high-performance parsing of UDP packets, according to &quot;Scrap your Bounds Checks with Liquid Haskell&quot; of Gabriella Gonzalez [1].<p>With Liquid Haskell, the bound checks are moved from runtime to compile time, semi-automatically handled by SMT-solvers. Static types help programmers to write correct programs faster, and the programs also run faster.<p>As an aside, speeding up programs with static analysis (constrained dynamism) are also present in Mojo (a variant of Python) or Swift [2].<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;Gabriella439&#x2F;slides&#x2F;blob&#x2F;main&#x2F;liquidhaskell&#x2F;slides.md">https:&#x2F;&#x2F;github.com&#x2F;Gabriella439&#x2F;slides&#x2F;blob&#x2F;main&#x2F;liquidhaske...</a> &quot;Scrap your Bounds Checks with Liquid Haskell&quot;<p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;modularml&#x2F;mojo&#x2F;discussions&#x2F;466">https:&#x2F;&#x2F;github.com&#x2F;modularml&#x2F;mojo&#x2F;discussions&#x2F;466</a> &quot;Mojo and Dynamism&quot;</div><br/><div id="37376791" class="c"><input type="checkbox" id="c-37376791" checked=""/><div class="controls bullet"><span class="by">hyperhello</span><span>|</span><a href="#37376010">parent</a><span>|</span><a href="#37376946">next</a><span>|</span><label class="collapse" for="c-37376791">[-]</label><label class="expand" for="c-37376791">[2 more]</label></div><br/><div class="children"><div class="content">Maybe naive question, but what if a UCP packet comes in that doesn’t meet the requirements of the parser? Undefined behavior?</div><br/><div id="37376958" class="c"><input type="checkbox" id="c-37376958" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#37376010">root</a><span>|</span><a href="#37376791">parent</a><span>|</span><a href="#37376946">next</a><span>|</span><label class="collapse" for="c-37376958">[-]</label><label class="expand" for="c-37376958">[1 more]</label></div><br/><div class="children"><div class="content">The type system removes checks that are redundant or unnecessary given the rest of the code. It doesn&#x27;t assume things about external data.</div><br/></div></div></div></div><div id="37376946" class="c"><input type="checkbox" id="c-37376946" checked=""/><div class="controls bullet"><span class="by">anon-3988</span><span>|</span><a href="#37376010">parent</a><span>|</span><a href="#37376791">prev</a><span>|</span><a href="#37376603">next</a><span>|</span><label class="collapse" for="c-37376946">[-]</label><label class="expand" for="c-37376946">[1 more]</label></div><br/><div class="children"><div class="content">I assume Liquid Types can greatly increased performance in C programs where pointer checks are littered everywhere.</div><br/></div></div><div id="37376603" class="c"><input type="checkbox" id="c-37376603" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#37376010">parent</a><span>|</span><a href="#37376946">prev</a><span>|</span><a href="#37376161">next</a><span>|</span><label class="collapse" for="c-37376603">[-]</label><label class="expand" for="c-37376603">[4 more]</label></div><br/><div class="children"><div class="content">This seems to be a complication to haskell to fix a performance problem that is only in haskell.</div><br/><div id="37376812" class="c"><input type="checkbox" id="c-37376812" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#37376010">root</a><span>|</span><a href="#37376603">parent</a><span>|</span><a href="#37376161">next</a><span>|</span><label class="collapse" for="c-37376812">[-]</label><label class="expand" for="c-37376812">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that&#x27;s fair. Automated bounds checking exists in many languages (and most modern high-level languages). In Rust you might be incentivised to use unsafe blocks for array access in performance sensitive code. Julia has its `@inbounds` annotation. Some languages might not have an escape hatch at all.<p>Automatically removing bounds checking where safe seems like a good goal, but in all but the most trivial cases its quite complex for the compiler to decide what&#x27;s safe.</div><br/><div id="37377783" class="c"><input type="checkbox" id="c-37377783" checked=""/><div class="controls bullet"><span class="by">capitalsigma</span><span>|</span><a href="#37376010">root</a><span>|</span><a href="#37376812">parent</a><span>|</span><a href="#37376161">next</a><span>|</span><label class="collapse" for="c-37377783">[-]</label><label class="expand" for="c-37377783">[2 more]</label></div><br/><div class="children"><div class="content">It seems a little disingenuous to call something written in an obscure Haskell dialect a &quot;high performance UDP packet parser&quot;</div><br/><div id="37378132" class="c"><input type="checkbox" id="c-37378132" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#37376010">root</a><span>|</span><a href="#37377783">parent</a><span>|</span><a href="#37376161">next</a><span>|</span><label class="collapse" for="c-37378132">[-]</label><label class="expand" for="c-37378132">[1 more]</label></div><br/><div class="children"><div class="content">Why? Looks like they&#x27;re doing realtime network monitoring for security purposes. Sounds like a high performance application to me. Haskell has a reputation for being slow, but the proof is in the pudding - and what&#x27;s being asserted is that a stronger type system enables better optimization.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37376161" class="c"><input type="checkbox" id="c-37376161" checked=""/><div class="controls bullet"><span class="by">A_D_E_P_T</span><span>|</span><a href="#37376010">prev</a><span>|</span><a href="#37376963">next</a><span>|</span><label class="collapse" for="c-37376161">[-]</label><label class="expand" for="c-37376161">[2 more]</label></div><br/><div class="children"><div class="content">I honestly thought that this was going to be about actual liquid types -- from the regular ones that (macroscopically) differ largely in terms of viscosity, to non-Newtonian liquids which have non-linear viscosity characteristics, to long-chain (PEG-type) polymers that have slightly unusual flow characteristics, to superfluids that have extremely weird characteristics and zero viscosity.<p>...I&#x27;d read that article.  Now I&#x27;m starting to think that I should write it.</div><br/><div id="37377088" class="c"><input type="checkbox" id="c-37377088" checked=""/><div class="controls bullet"><span class="by">rytill</span><span>|</span><a href="#37376161">parent</a><span>|</span><a href="#37376963">next</a><span>|</span><label class="collapse" for="c-37377088">[-]</label><label class="expand" for="c-37377088">[1 more]</label></div><br/><div class="children"><div class="content">I’d read it! That sounds really interesting.</div><br/></div></div></div></div><div id="37376963" class="c"><input type="checkbox" id="c-37376963" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#37376161">prev</a><span>|</span><a href="#37376047">next</a><span>|</span><label class="collapse" for="c-37376963">[-]</label><label class="expand" for="c-37376963">[5 more]</label></div><br/><div class="children"><div class="content">An important thing to remember about fancy type systems is that they can only make guarantees in a closed world. If your data comes from the network or a file, you will likely need a reader or parser that does runtime checks somewhere, but a good type system can provide assurance that you did each check exactly once.<p>On a complicated single-process system (a monolith), that can be a big improvement. For distributed systems (microservices), there will still be plenty of runtime checks. That&#x27;s what allows each service to have its own lifecycle.<p>I&#x27;m wondering what Elixir will do, given that Erlang servers divide up work into lots of independent, distributed components?</div><br/><div id="37377431" class="c"><input type="checkbox" id="c-37377431" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#37376963">parent</a><span>|</span><a href="#37378078">next</a><span>|</span><label class="collapse" for="c-37377431">[-]</label><label class="expand" for="c-37377431">[3 more]</label></div><br/><div class="children"><div class="content">This is a fantastic point, and a huge issue that I had with TypeScript.<p>Libraries for TypeScript like Zod[0] allow you to define types and validate against them at runtime. For example: <a href="https:&#x2F;&#x2F;stackblitz.com&#x2F;edit&#x2F;typescript-pwzng4?file=index.ts" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackblitz.com&#x2F;edit&#x2F;typescript-pwzng4?file=index.ts</a><p>At work, we use this to validate API responses, local storage contents, or URL&#x2F;router data. It solves the problem you described -- dirty data coming from outside of the type system.<p>This isn&#x27;t a plug for Zod or TypeScript -- there are other similar libraries for TypeScript, and I would imagine other statically typed languages have something to fill this role.<p>[0]: <a href="https:&#x2F;&#x2F;zod.dev&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;zod.dev&#x2F;</a></div><br/><div id="37378051" class="c"><input type="checkbox" id="c-37378051" checked=""/><div class="controls bullet"><span class="by">diarrhea</span><span>|</span><a href="#37376963">root</a><span>|</span><a href="#37377431">parent</a><span>|</span><a href="#37377505">next</a><span>|</span><label class="collapse" for="c-37378051">[-]</label><label class="expand" for="c-37378051">[1 more]</label></div><br/><div class="children"><div class="content">Two random thoughts:<p>- why is there `safeParse`? Why is parsing not safe by default? Have an `unsafeParse` as an escape hatch, not the other way around.<p>- the imperative check for `success` seems unfortunate. Then again, I am familiar with pydantic from Python, which seems awfully similar to Zod, and there you&#x27;d get an Exception on failure which you&#x27;d have to catch. Some would call that uglier (I don&#x27;t). Point being, I don&#x27;t know of a better alternative, but sure hope native liquid&#x2F;dependent types wouldn&#x27;t suffer from this anymore</div><br/></div></div><div id="37377505" class="c"><input type="checkbox" id="c-37377505" checked=""/><div class="controls bullet"><span class="by">svrtknst</span><span>|</span><a href="#37376963">root</a><span>|</span><a href="#37377431">parent</a><span>|</span><a href="#37378051">prev</a><span>|</span><a href="#37378078">next</a><span>|</span><label class="collapse" for="c-37377505">[-]</label><label class="expand" for="c-37377505">[1 more]</label></div><br/><div class="children"><div class="content">TypeScript became so much more pleasant to use after we started using parsers regularly. We use Runtypes in some projects and a hand rolled lib I wrote in others, and being able to parse unknown data into a known shape is a life saver.<p>Glad to not have to write seemingly thousands of lines of interfaces and type guards any more.</div><br/></div></div></div></div><div id="37378078" class="c"><input type="checkbox" id="c-37378078" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37376963">parent</a><span>|</span><a href="#37377431">prev</a><span>|</span><a href="#37376047">next</a><span>|</span><label class="collapse" for="c-37378078">[-]</label><label class="expand" for="c-37378078">[1 more]</label></div><br/><div class="children"><div class="content">Most modern languages with static types have some way to preserve them across network&#x2F;file transports. You can use a serialisation format that is typed (e.g. FlatBuffers etc.) or a library that validates the types on load, e.g. Serde. Even Python has Pydantic.</div><br/></div></div></div></div><div id="37376047" class="c"><input type="checkbox" id="c-37376047" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#37376963">prev</a><span>|</span><a href="#37376319">next</a><span>|</span><label class="collapse" for="c-37376047">[-]</label><label class="expand" for="c-37376047">[1 more]</label></div><br/><div class="children"><div class="content">This sort of idea is why I sketched out pdv [0] in Zig. Even extremely simple type systems can handle arbitrary invariants when you are allowed to compute with those invariants at compile time.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;hmusgrave&#x2F;pdv">https:&#x2F;&#x2F;github.com&#x2F;hmusgrave&#x2F;pdv</a></div><br/></div></div><div id="37376319" class="c"><input type="checkbox" id="c-37376319" checked=""/><div class="controls bullet"><span class="by">__vec__</span><span>|</span><a href="#37376047">prev</a><span>|</span><a href="#37376962">next</a><span>|</span><label class="collapse" for="c-37376319">[-]</label><label class="expand" for="c-37376319">[2 more]</label></div><br/><div class="children"><div class="content">DML link in the article is broken - Might I instead point you to a relevant ATS-lang (successor<i>2 of DML) documentation about `Dependent Types in ATS2` <a href="https:&#x2F;&#x2F;ats-lang.sourceforge.net&#x2F;DOCUMENT&#x2F;INTPROGINATS&#x2F;HTML&#x2F;c2100.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;ats-lang.sourceforge.net&#x2F;DOCUMENT&#x2F;INTPROGINATS&#x2F;HTML&#x2F;...</a><p>This link discusses, along with other usefulness, the use of dependent types for the likes of array bounds checking, creating &quot;sorts&quot; of numbers satisfying various predicates, and more interestingly the utility of combining Dependent Types with PURE Linear Types (as opposed to Affine Types a la Rust lol) ...<p>AFAIK, DML was originally intended as a gateway to constructing typed assembly (DARPA)<p>Having been a researcher in this field for, this quote from the original paper on &#x27;Liquid Types&#x27; originally seemed suspect....
&quot;a system that combines Hindley-Milner type inference with Predicate Abstraction to automatically infer dependent types precise enough to prove a variety of safety properties&quot; .... type inference with dependent types is undecidable!? Then again, this is one of the primary focuses of ATS3, I digress...<p>This area of research is rich in pipe-dreams and cerebral investigation. From my biased opinion, ATS3 (the current version of the successor</i>3 of DML, being actively devloped by the PI Professor Hongwei Xi, is the only language in this space to be aimed at practical programming in industry... of course there is always haskell....)<p>What I mean is that, TEMPLATES++ Linear Types + Dependent Types + Hindley Milner Type inference ....<p>At the end of the day, who doesn&#x27;t love hyper efficient meta-programming magic?</div><br/><div id="37377085" class="c"><input type="checkbox" id="c-37377085" checked=""/><div class="controls bullet"><span class="by">doublec</span><span>|</span><a href="#37376319">parent</a><span>|</span><a href="#37376962">next</a><span>|</span><label class="collapse" for="c-37377085">[-]</label><label class="expand" for="c-37377085">[1 more]</label></div><br/><div class="children"><div class="content">ATS is great, I’ve used ATS1 and ATS2 quite a bit and it worked well. Unfortunately it suffers a bit from the “rewrite every few years” as research directions change.</div><br/></div></div></div></div><div id="37376962" class="c"><input type="checkbox" id="c-37376962" checked=""/><div class="controls bullet"><span class="by">richard_fey</span><span>|</span><a href="#37376319">prev</a><span>|</span><a href="#37376333">next</a><span>|</span><label class="collapse" for="c-37376962">[-]</label><label class="expand" for="c-37376962">[6 more]</label></div><br/><div class="children"><div class="content">How do you define operations on these liquid types? You can&#x27;t even define subtraction or addition on this &quot;non zero integer type&quot;. These types are not closed so how is it useful?</div><br/><div id="37377525" class="c"><input type="checkbox" id="c-37377525" checked=""/><div class="controls bullet"><span class="by">saithound</span><span>|</span><a href="#37376962">parent</a><span>|</span><a href="#37377125">next</a><span>|</span><label class="collapse" for="c-37377525">[-]</label><label class="expand" for="c-37377525">[2 more]</label></div><br/><div class="children"><div class="content">Liquid types are represented under the hood using ordinary data types, so e.g. the nonzero integer type will be stored as a value of ordinary Haskell integer type at runtime. Subtraction on the underlying type is defined as usual.<p>Now, the Liquid Haskell type checker knows a lot about integers: it can deduce whether your invocation of x-y could give a negative result or not.<p>If it cannot result in a negative value (e.g. because y has a particular liquid type), the type checker will accept your program, and you&#x27;ll be able to use the subtraction function as you normally would.<p>However, if your invocation of x-y could potentially result in a negative value (e.g. because the values of x,y are not sufficiently constrained), the type checker will reject your program, and tell you to do something else (e.g. add runtime checks that rule out a negative result before invoking the subtraction).</div><br/><div id="37378116" class="c"><input type="checkbox" id="c-37378116" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37376962">root</a><span>|</span><a href="#37377525">parent</a><span>|</span><a href="#37377125">next</a><span>|</span><label class="collapse" for="c-37378116">[-]</label><label class="expand" for="c-37378116">[1 more]</label></div><br/><div class="children"><div class="content">Presumably it will reject it with a helpful message like &quot;no&quot;?<p>I think that&#x27;s the main disadvantage of these types. It&#x27;s now no longer a decidable system with (usually) easy to understand error messages. You&#x27;re in the realm of formal verification and SMT solvers where the only error message is &quot;didn&#x27;t work; try something else&quot;.<p>Probably still good but I think it&#x27;s important to be aware of the downsides.</div><br/></div></div></div></div><div id="37377125" class="c"><input type="checkbox" id="c-37377125" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#37376962">parent</a><span>|</span><a href="#37377525">prev</a><span>|</span><a href="#37376333">next</a><span>|</span><label class="collapse" for="c-37377125">[-]</label><label class="expand" for="c-37377125">[3 more]</label></div><br/><div class="children"><div class="content">Addition isn&#x27;t a problem, any nonzero integer plus a nonzero integer is a nonzero integer.<p>For subtraction it becomes fallible. You get back an option, 5 - 4 = Some(1), 4 - 5 = None. (These are probably methods rather than infix operators, your language may vary.)<p>See for example the methods documented here: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;std&#x2F;num&#x2F;struct.NonZeroUsize.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;std&#x2F;num&#x2F;struct.NonZeroUsize...</a><p>As for it&#x27;s utility, it enables certain optimizations and it can be a useful constraint. Eg for ensuring that you don&#x27;t divide or multiply by zero.</div><br/><div id="37378208" class="c"><input type="checkbox" id="c-37378208" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#37376962">root</a><span>|</span><a href="#37377125">parent</a><span>|</span><a href="#37377805">next</a><span>|</span><label class="collapse" for="c-37378208">[-]</label><label class="expand" for="c-37378208">[1 more]</label></div><br/><div class="children"><div class="content">It is worth pointing out that the same problems apply to &quot;normal&quot; integer types like int32&#x2F;uint32; you can trivially over&#x2F;underflow the bounds with basic arithmetic. In that sense it doesn&#x27;t really matter what the bounds are exactly.</div><br/></div></div><div id="37377805" class="c"><input type="checkbox" id="c-37377805" checked=""/><div class="controls bullet"><span class="by">pharmakom</span><span>|</span><a href="#37376962">root</a><span>|</span><a href="#37377125">parent</a><span>|</span><a href="#37378208">prev</a><span>|</span><a href="#37376333">next</a><span>|</span><label class="collapse" for="c-37377805">[-]</label><label class="expand" for="c-37377805">[1 more]</label></div><br/><div class="children"><div class="content">It would be in interred ring to have a memory bounds for the program too!</div><br/></div></div></div></div></div></div><div id="37376333" class="c"><input type="checkbox" id="c-37376333" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#37376962">prev</a><span>|</span><a href="#37377660">next</a><span>|</span><label class="collapse" for="c-37376333">[-]</label><label class="expand" for="c-37376333">[2 more]</label></div><br/><div class="children"><div class="content">I like this sort of idea for typifying dynamic languages (like JS)<p>What if instead of TS, you had plain JS as-is (no compiler needed!) then just add comment like:<p><pre><code>    &#x2F;* x is an integer, x &gt; 0 ... *&#x2F; 
    function add(x, y) { ...
</code></pre>
Sorry the example ain&#x27;t great but the point is that you can be precise with refinement types. I think refinement types (less all the mathy explanations) are more intuitive. They would be like assertions or C# code contracts. The content of those types would look &quot;business-ey&quot; rather than &quot;category theory-ish&quot;.</div><br/><div id="37376357" class="c"><input type="checkbox" id="c-37376357" checked=""/><div class="controls bullet"><span class="by">__vec__</span><span>|</span><a href="#37376333">parent</a><span>|</span><a href="#37377660">next</a><span>|</span><label class="collapse" for="c-37376357">[-]</label><label class="expand" for="c-37376357">[1 more]</label></div><br/><div class="children"><div class="content">The difference is an informative error message at compile time when such fails to satisfy the &#x27;refinement&#x27;</div><br/></div></div></div></div><div id="37377660" class="c"><input type="checkbox" id="c-37377660" checked=""/><div class="controls bullet"><span class="by">everybodyknows</span><span>|</span><a href="#37376333">prev</a><span>|</span><a href="#37376110">next</a><span>|</span><label class="collapse" for="c-37377660">[-]</label><label class="expand" for="c-37377660">[1 more]</label></div><br/><div class="children"><div class="content">Title needs to append (2015).</div><br/></div></div><div id="37376110" class="c"><input type="checkbox" id="c-37376110" checked=""/><div class="controls bullet"><span class="by">dionian</span><span>|</span><a href="#37377660">prev</a><span>|</span><a href="#37375601">next</a><span>|</span><label class="collapse" for="c-37376110">[-]</label><label class="expand" for="c-37376110">[3 more]</label></div><br/><div class="children"><div class="content">reminds me a little of eiffel&#x27;s design by contract. it looks really promising</div><br/><div id="37378341" class="c"><input type="checkbox" id="c-37378341" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#37376110">parent</a><span>|</span><a href="#37376115">next</a><span>|</span><label class="collapse" for="c-37378341">[-]</label><label class="expand" for="c-37378341">[1 more]</label></div><br/><div class="children"><div class="content">It made me wonder too, what the (practical) advantage over contracts is. If anything, Liquid Types seem less powerful. E.g., you can&#x27;t use it to express a relation between two function parameters. It seems to be a macro for contracts (the type name implicitly copies its restriction as a contract clause), so in that sense it could be welcome as a practical way of improving correctness.</div><br/></div></div><div id="37376115" class="c"><input type="checkbox" id="c-37376115" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#37376110">parent</a><span>|</span><a href="#37378341">prev</a><span>|</span><a href="#37375601">next</a><span>|</span><label class="collapse" for="c-37376115">[-]</label><label class="expand" for="c-37376115">[1 more]</label></div><br/><div class="children"><div class="content">Your intuition is right. Liquid (refinement) types, design by contract and Hoare logic have, essentially, the same expressiveness.<p>Personally I find refinement types more promising than dependent types, but time will tell.</div><br/></div></div></div></div><div id="37375601" class="c"><input type="checkbox" id="c-37375601" checked=""/><div class="controls bullet"><span class="by">peepeepoopoo33</span><span>|</span><a href="#37376110">prev</a><span>|</span><label class="collapse" for="c-37375601">[-]</label><label class="expand" for="c-37375601">[27 more]</label></div><br/><div class="children"><div class="content">Programming language design took a wrong turn with these extremely complicated type systems.  They end up hurting developer productivity, and you spend more time fiddling with types than solving the problem at hand.  We should be focusing on more effective forms of abstraction instead of types.</div><br/><div id="37375698" class="c"><input type="checkbox" id="c-37375698" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#37375601">parent</a><span>|</span><a href="#37375819">next</a><span>|</span><label class="collapse" for="c-37375698">[-]</label><label class="expand" for="c-37375698">[8 more]</label></div><br/><div class="children"><div class="content">What languages are you talking about? I find that the weaker the type system the more I feel fiddling with it is a waste, eg Python, but I don&#x27;t feel that way when I&#x27;m working with a strong type system that can not only help eliminate bugs but aid the compiler in analysis and actually deliver a better artefact, eg Rust.<p>LSPs are a sort of middle ground where I derive a lot of the value from, and even weak type systems really help the analysis of the LSP. They make me immensely more productive. I&#x27;ve been writing a lot of TypeScript lately, and I may not have taken the plunge to the frontend if LSPs hadn&#x27;t made it dramatically easier. So in that case the impact on my productivity is +100%.</div><br/><div id="37378117" class="c"><input type="checkbox" id="c-37378117" checked=""/><div class="controls bullet"><span class="by">diarrhea</span><span>|</span><a href="#37375601">root</a><span>|</span><a href="#37375698">parent</a><span>|</span><a href="#37376906">next</a><span>|</span><label class="collapse" for="c-37378117">[-]</label><label class="expand" for="c-37378117">[3 more]</label></div><br/><div class="children"><div class="content">I am familiar with both Python and its typing, and Rust. Obviously, Rust has ADTs, which open up a whole new class of types. However, I wouldn&#x27;t call Python&#x27;s type system weak! It&#x27;s still under very active development, but making full use of it (i.e., type annotations) and the strictest settings in mypy makes for a very powerful combination. I&#x27;ve never felt the system was too weak; if anything, I was.<p>There&#x27;s type narrowing, warnings for not awaiting Awaitables, generics, protocols&#x2F;interfaces, even whole function signatures can be lifted into the type system (ParamSpec). Dictionaries can be turned into typed versions as well, which is quite powerful.<p>By default, it&#x27;s weaker, as it&#x27;s optional. Rust&#x27;s isn&#x27;t optional. But start a greenfield project with type annotations and you won&#x27;t be disappointed, I hope. Features like ADTs will still be absent, but I feel that&#x27;s an orthogonal issue to type safety etc.</div><br/><div id="37378240" class="c"><input type="checkbox" id="c-37378240" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#37375601">root</a><span>|</span><a href="#37378117">parent</a><span>|</span><a href="#37378176">next</a><span>|</span><label class="collapse" for="c-37378240">[-]</label><label class="expand" for="c-37378240">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. Maybe weak is too strong a claim. I have done a lot of typed Python code fwiw. I&#x27;m certainly never going back to untyped Python for anything outside of a scripting context.<p>The &quot;Python wasn&#x27;t weak, I was&quot; is an accurate call out, I have abandoned complex annotations in Python before because there was a bunch of cruft involved and the documentation wasn&#x27;t always as straightforward as I&#x27;d have liked.<p>The lack of ADTs (and thus a Result type) combined with the lack of exceptions as part of the function signature (like Java) make it really difficult to develop a reliable application. Maybe that&#x27;s not quite a type safety issue, but it&#x27;s a safety issue for sure.<p>Digging in, it looks like people are working around this by <i>returning</i> exceptions, which is very clever and I hadn&#x27;t thought of it before.</div><br/></div></div><div id="37378176" class="c"><input type="checkbox" id="c-37378176" checked=""/><div class="controls bullet"><span class="by">meheleventyone</span><span>|</span><a href="#37375601">root</a><span>|</span><a href="#37378117">parent</a><span>|</span><a href="#37378240">prev</a><span>|</span><a href="#37376906">next</a><span>|</span><label class="collapse" for="c-37378176">[-]</label><label class="expand" for="c-37378176">[1 more]</label></div><br/><div class="children"><div class="content">A lot of people probably don’t know that Python is adding optional types FWIW. I started and stopped using Python before it was even thought about.</div><br/></div></div></div></div><div id="37376906" class="c"><input type="checkbox" id="c-37376906" checked=""/><div class="controls bullet"><span class="by">kristopolous</span><span>|</span><a href="#37375601">root</a><span>|</span><a href="#37375698">parent</a><span>|</span><a href="#37378117">prev</a><span>|</span><a href="#37375819">next</a><span>|</span><label class="collapse" for="c-37376906">[-]</label><label class="expand" for="c-37376906">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not the parent but at least for me, my #1 complaint is &quot;whiny computer&quot;.<p>Especially when dealing with someone else&#x27;s code, it can be a ceremonial roadblock for moving data around that could easily be processed without issue but artificial constraints in order to service an orthodoxy have been erected to make things needlessly more brittle.<p>In the name of reducing bugs, it in practice can often impose workarounds that increase the chance the confusion and more bugs.<p>This isn&#x27;t always the case but most of the time things are built in incompetent hands (including my own). Accommodating for this reality is probably the better move. Imposition of absolutist rules doesn&#x27;t improve the behavior of incompetency, it just makes it more subversive and the defects it creates more insidious</div><br/><div id="37377032" class="c"><input type="checkbox" id="c-37377032" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#37375601">root</a><span>|</span><a href="#37376906">parent</a><span>|</span><a href="#37375819">next</a><span>|</span><label class="collapse" for="c-37377032">[-]</label><label class="expand" for="c-37377032">[3 more]</label></div><br/><div class="children"><div class="content">Hmm interesting. Are these projects that were originally untyped but then gradually typed later? I ask because I&#x27;ve not really encountered that, the most I&#x27;ve had to do is add asserts or ifs to help explain to the typechecker something that I could see as a human. A few times in a gradually typed language I&#x27;ve needed to add an ignore to a line. But it&#x27;s been rare in my experience.<p>I try not to think of it as whining, I try to think of it as the type checker helpfully pointing out, &quot;hey, you haven&#x27;t done your due diligence here.&quot; I ran into this advice when learning Rust and it made it much more pleasant. In the same way that you might chase a series of failing tests to finish a task, you can chase a series of type warnings. I have them integrated into my editor, so usually the &quot;series&quot; is length 1 because I&#x27;m knocking them out as they arise.<p>The projects I&#x27;ve worked with that were previously untyped (Python SaaS backends), I never actually ran the type checker on the entire source code. But if I had a megabyte of type errors that weren&#x27;t really going to provide value to the business, yeah that would feel like a waste of time. Unless we were having serious quality issues and it was between annotating the entire codebase and rewriting it from scratch, I&#x27;d leave well enough alone - it&#x27;s a tool, not a religion. But the new code I&#x27;m checking in, that&#x27;s getting annotated for sure.<p>I don&#x27;t really see types as arbitrary absolutist rules. They&#x27;re the semantics of the language, they&#x27;re the rules you&#x27;re following whether you have a typechecker or not. And if you violate them you&#x27;re gunnuh get bugs and crashes regardless. I too am a flawed human who frequently makes mistakes, and I like having them caught immediately, before I&#x27;ve even checked my code in.</div><br/><div id="37377064" class="c"><input type="checkbox" id="c-37377064" checked=""/><div class="controls bullet"><span class="by">kristopolous</span><span>|</span><a href="#37375601">root</a><span>|</span><a href="#37377032">parent</a><span>|</span><a href="#37375819">next</a><span>|</span><label class="collapse" for="c-37377064">[-]</label><label class="expand" for="c-37377064">[2 more]</label></div><br/><div class="children"><div class="content">I probably just choose my projects wrong. I get attracted to charity cases and disasters for some reason. I&#x27;ve tried to stop but there&#x27;s obviously something complicated going on</div><br/><div id="37377101" class="c"><input type="checkbox" id="c-37377101" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#37375601">root</a><span>|</span><a href="#37377064">parent</a><span>|</span><a href="#37375819">next</a><span>|</span><label class="collapse" for="c-37377101">[-]</label><label class="expand" for="c-37377101">[1 more]</label></div><br/><div class="children"><div class="content">Haha. It&#x27;s a niche and I respect it. All software is bad but it&#x27;s worth supporting software that&#x27;s useful.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37375819" class="c"><input type="checkbox" id="c-37375819" checked=""/><div class="controls bullet"><span class="by">systems</span><span>|</span><a href="#37375601">parent</a><span>|</span><a href="#37375698">prev</a><span>|</span><a href="#37376715">next</a><span>|</span><label class="collapse" for="c-37375819">[-]</label><label class="expand" for="c-37375819">[2 more]</label></div><br/><div class="children"><div class="content">complexity doesn&#x27;t go away, you distribute it<p>you either create a complex program, with simple language constructs, or a simple program with complex language constructs<p>if you use only the simplest types, your program will be very complex, if you put all the complexity in types, your type system will be very complex<p>you need to balance things<p>i think OOP is the extreme where all the complexity is in the Object system (or types system)<p>functional programming with complex types, i think give a nicer balance, where some logic goes into the program flow and some goes into types<p>anyway balance is everything, keep things balanced , dont lean too much into any direction</div><br/><div id="37376001" class="c"><input type="checkbox" id="c-37376001" checked=""/><div class="controls bullet"><span class="by">dietr1ch</span><span>|</span><a href="#37375601">root</a><span>|</span><a href="#37375819">parent</a><span>|</span><a href="#37376715">next</a><span>|</span><label class="collapse" for="c-37376001">[-]</label><label class="expand" for="c-37376001">[1 more]</label></div><br/><div class="children"><div class="content">Well, intrinsic complexity can be split, but artificial complexity might be added on top of it.<p>Languages and libraries that are well designed and compose better end up being great at taming complexity.
Functional languages are made to compose better, but their popularity is a hint that they are not that simple to use effectively.</div><br/></div></div></div></div><div id="37376715" class="c"><input type="checkbox" id="c-37376715" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#37375601">parent</a><span>|</span><a href="#37375819">prev</a><span>|</span><a href="#37375694">next</a><span>|</span><label class="collapse" for="c-37376715">[-]</label><label class="expand" for="c-37376715">[3 more]</label></div><br/><div class="children"><div class="content">Similar arguments here: <a href="https:&#x2F;&#x2F;bower.sh&#x2F;typescript-terrible-for-library-developers" rel="nofollow noreferrer">https:&#x2F;&#x2F;bower.sh&#x2F;typescript-terrible-for-library-developers</a><p>As a library developer I spend substantially more time on making the types right than the actual implementation. It can be brutal at times.</div><br/><div id="37378142" class="c"><input type="checkbox" id="c-37378142" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37375601">root</a><span>|</span><a href="#37376715">parent</a><span>|</span><a href="#37375694">next</a><span>|</span><label class="collapse" for="c-37378142">[-]</label><label class="expand" for="c-37378142">[2 more]</label></div><br/><div class="children"><div class="content">Think of how much time you&#x27;d have to spend writing trivial tests instead if you didn&#x27;t have an automated system to detect basic mistakes like typos and type confusion!<p>I guess you can complain that Typescript forces you to spend time making sure your code meets a minimal bar of correctness...</div><br/><div id="37378216" class="c"><input type="checkbox" id="c-37378216" checked=""/><div class="controls bullet"><span class="by">meheleventyone</span><span>|</span><a href="#37375601">root</a><span>|</span><a href="#37378142">parent</a><span>|</span><a href="#37375694">next</a><span>|</span><label class="collapse" for="c-37378216">[-]</label><label class="expand" for="c-37378216">[1 more]</label></div><br/><div class="children"><div class="content">Library developers in particular should see type complexity as a warning that something isn’t great in the design. This seems largely an issue for libraries migrating to TS which isn’t a surprise.</div><br/></div></div></div></div></div></div><div id="37375694" class="c"><input type="checkbox" id="c-37375694" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#37375601">parent</a><span>|</span><a href="#37376715">prev</a><span>|</span><a href="#37375637">next</a><span>|</span><label class="collapse" for="c-37375694">[-]</label><label class="expand" for="c-37375694">[11 more]</label></div><br/><div class="children"><div class="content">&gt; more effective forms of abstraction instead of types<p>do you have any in mind ?<p>I often think about a blend of functional and OO as &#x27;protocol graphs&#x27; but it&#x27;s a faint idea for now</div><br/><div id="37375712" class="c"><input type="checkbox" id="c-37375712" checked=""/><div class="controls bullet"><span class="by">peepeepoopoo33</span><span>|</span><a href="#37375601">root</a><span>|</span><a href="#37375694">parent</a><span>|</span><a href="#37375789">next</a><span>|</span><label class="collapse" for="c-37375712">[-]</label><label class="expand" for="c-37375712">[9 more]</label></div><br/><div class="children"><div class="content">Array programming is an extremely powerful paradigm that is criminally underused outside of data science applications.  It also feels like the full power of array programming hasn&#x27;t been explored yet.</div><br/><div id="37375812" class="c"><input type="checkbox" id="c-37375812" checked=""/><div class="controls bullet"><span class="by">mostlylurks</span><span>|</span><a href="#37375601">root</a><span>|</span><a href="#37375712">parent</a><span>|</span><a href="#37375789">next</a><span>|</span><label class="collapse" for="c-37375812">[-]</label><label class="expand" for="c-37375812">[8 more]</label></div><br/><div class="children"><div class="content">Array programming doesn&#x27;t really have much effect on how relevant a type system is for a particular language. At most it will let you make operations generic over the rank of the inputs (scalar, array, array of arrays, etc), which is nice, but the scalar values at the bottom of that hierarchy are subject to all the same factors that motivate the type systems present in any other modern language.</div><br/><div id="37375910" class="c"><input type="checkbox" id="c-37375910" checked=""/><div class="controls bullet"><span class="by">peepeepoopoo33</span><span>|</span><a href="#37375601">root</a><span>|</span><a href="#37375812">parent</a><span>|</span><a href="#37375789">next</a><span>|</span><label class="collapse" for="c-37375910">[-]</label><label class="expand" for="c-37375910">[7 more]</label></div><br/><div class="children"><div class="content">My point is that academic PL research has diverged significantly from the kinds of problems people are really facing.  That&#x27;s why we&#x27;ve seen array programming emerge organically to address a direct industry need, and it didn&#x27;t come from the PL crowd at all.</div><br/><div id="37375951" class="c"><input type="checkbox" id="c-37375951" checked=""/><div class="controls bullet"><span class="by">joaogui1</span><span>|</span><a href="#37375601">root</a><span>|</span><a href="#37375910">parent</a><span>|</span><a href="#37378136">next</a><span>|</span><label class="collapse" for="c-37375951">[-]</label><label class="expand" for="c-37375951">[4 more]</label></div><br/><div class="children"><div class="content">APL started at Harvard (though it developed more in IBM) and even nowadays there&#x27;s the ARRAY workshop co-located with one of the main PL conferences.<p>The thing is that while array programming is amazing for some specific problems it&#x27;s not going to help you make sure that you don&#x27;t have memory errors, race conditions, or wrong states in your program</div><br/><div id="37376000" class="c"><input type="checkbox" id="c-37376000" checked=""/><div class="controls bullet"><span class="by">peepeepoopoo33</span><span>|</span><a href="#37375601">root</a><span>|</span><a href="#37375951">parent</a><span>|</span><a href="#37376168">prev</a><span>|</span><a href="#37378136">next</a><span>|</span><label class="collapse" for="c-37376000">[-]</label><label class="expand" for="c-37376000">[2 more]</label></div><br/><div class="children"><div class="content">The implementations of array programming in use today are quite different from APL, and they all came from industry.<p>&gt; it&#x27;s not going to help you make sure that you don&#x27;t have memory errors, race conditions<p>Not only does array programming abstract away those kinds of errors, it also solves the problems that I care about: code that is faster, more expressive, and easier to read and write.  Unwieldy type systems do not help me solve those problems.</div><br/><div id="37376108" class="c"><input type="checkbox" id="c-37376108" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#37375601">root</a><span>|</span><a href="#37376000">parent</a><span>|</span><a href="#37378136">next</a><span>|</span><label class="collapse" for="c-37376108">[-]</label><label class="expand" for="c-37376108">[1 more]</label></div><br/><div class="children"><div class="content">I can see how array programming helps with certain memory errors, but I don&#x27;t think it helps with race conditions. Whereas eg Rust ownership, borrowing, and lifetimes eliminate one class of race conditions (data races) in safe code.<p>Type systems also enable optimizations that do make code faster. Eg monomorphization. Consider that JITs makes untyped code faster by inferring types at runtime. See also this comment <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37376010">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37376010</a><p>I honestly can&#x27;t make heads or tails of the idea that type systems don&#x27;t help make code more expressive? They allow you to express your precise intent in a way that&#x27;s legible to both humans and the compiler.</div><br/></div></div></div></div></div></div><div id="37378136" class="c"><input type="checkbox" id="c-37378136" checked=""/><div class="controls bullet"><span class="by">diarrhea</span><span>|</span><a href="#37375601">root</a><span>|</span><a href="#37375910">parent</a><span>|</span><a href="#37375951">prev</a><span>|</span><a href="#37375959">next</a><span>|</span><label class="collapse" for="c-37378136">[-]</label><label class="expand" for="c-37378136">[1 more]</label></div><br/><div class="children"><div class="content">&gt; academic PL research has diverged significantly from the kinds of problems people are really facing<p>Was it ever not?</div><br/></div></div></div></div></div></div></div></div><div id="37375789" class="c"><input type="checkbox" id="c-37375789" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#37375601">root</a><span>|</span><a href="#37375694">parent</a><span>|</span><a href="#37375712">prev</a><span>|</span><a href="#37375637">next</a><span>|</span><label class="collapse" for="c-37375789">[-]</label><label class="expand" for="c-37375789">[1 more]</label></div><br/><div class="children"><div class="content">This protocol graph idea sounds intriguing. I&#x27;d love to hear more about it if you&#x27;re interested in sharing.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>