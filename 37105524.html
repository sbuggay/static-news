<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1691917258801" as="style"/><link rel="stylesheet" href="styles.css?v=1691917258801"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/NixOS/rfcs/pull/136">NixOS RFC 136 approved: A plan to stabilize the new CLI and Flakes incrementally</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>seabass-labrax</span> | <span>103 comments</span></div><br/><div><div id="37107990" class="c"><input type="checkbox" id="c-37107990" checked=""/><div class="controls bullet"><span class="by">gallexme</span><span>|</span><a href="#37105885">next</a><span>|</span><label class="collapse" for="c-37107990">[-]</label><label class="expand" for="c-37107990">[1 more]</label></div><br/><div class="children"><div class="content">Love nix and flakes, can easily describe my whole infrastructure in nix(even generating terraform files  from it, manage secrets(agenix,agenix-rekey), and dev tools required to work on parts of the infrastructure(LSP&#x27;s, deploy-rs, secrets decrypting using ssh key,rekeying secrets to public keys of machines), all in one flake, one monorepo (virtually split up with the josh project into multiple repos with shared history,works really well)<p>I love it, only thing I would love if there was a proper way for passing arguments to flakes for build &#x2F;dev&#x2F;run only dependencies and other ways to specialize the scope of the user using the flake and infrastructure attached to it :)</div><br/></div></div><div id="37105885" class="c"><input type="checkbox" id="c-37105885" checked=""/><div class="controls bullet"><span class="by">bergkvist</span><span>|</span><a href="#37107990">prev</a><span>|</span><a href="#37105742">next</a><span>|</span><label class="collapse" for="c-37105885">[-]</label><label class="expand" for="c-37105885">[16 more]</label></div><br/><div class="children"><div class="content">The biggest show-stoppers for me with flakes is:<p>Building third party flakes takes forever since every flake uses its own version of nixpkgs. If you don&#x27;t pin your third party flake urls they might also change under your nose as you run the same command again a day later.<p>Flakes are coupled to git. You need to remember to stage changes whenever you do Ctrl+S in your editor before rebuilding. I&#x27;ve wasted more time than I&#x27;d like to admit wondering why what I&#x27;m building doesn&#x27;t include my latest change.<p>Flakes copy the entire directory into the nix store. This is terrible for mono-repos - and especially if it contains any large files. There is an issue about making the copying of the entire directory into &#x2F;nix&#x2F;store lazy - though this doesn&#x27;t really address the problem. It just treats some common symptoms.<p>This kind of copying would likely be a lot more acceptable if it was specified explicitly in flake.nix, rather than implicitly. Then you could also use your own filters for ignoring files, rather than relying on the coupling to git and its staging area.</div><br/><div id="37105965" class="c"><input type="checkbox" id="c-37105965" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#37105885">parent</a><span>|</span><a href="#37106120">next</a><span>|</span><label class="collapse" for="c-37105965">[-]</label><label class="expand" for="c-37105965">[1 more]</label></div><br/><div class="children"><div class="content">This is good constructive criticism and I&#x27;d like to second every part of it.<p>You&#x27;re probably already aware, but for the benefit of newcomers in this thread, here&#x27;s a link to the massive PR trying to work out more efficient copying of local flakes to the Nix store:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nix&#x2F;pull&#x2F;6530">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nix&#x2F;pull&#x2F;6530</a><p>A few dedicated folks are working really hard to break that thing down and test it and get it merged. I can hardly wait!</div><br/></div></div><div id="37106120" class="c"><input type="checkbox" id="c-37106120" checked=""/><div class="controls bullet"><span class="by">_hl_</span><span>|</span><a href="#37105885">parent</a><span>|</span><a href="#37105965">prev</a><span>|</span><a href="#37107889">next</a><span>|</span><label class="collapse" for="c-37106120">[-]</label><label class="expand" for="c-37106120">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Building third party flakes takes forever since every flake uses its own version of nixpkgs.<p>The “official” (as in, community consensus) solution seems to be to bring your own nixpkgs, and manually override the nixpkgs of every dependency (and their transitive dendencies) and verify your build still works. Which just doesn’t seem right to me.<p>Flakes are great for building an ecosystem of composable, reproducable software. The more they succeed at that, the bigger the problem becomes. Surely it’s not too late to figure out a principled solution before stabilizing flakes?</div><br/><div id="37107529" class="c"><input type="checkbox" id="c-37107529" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#37105885">root</a><span>|</span><a href="#37106120">parent</a><span>|</span><a href="#37106451">next</a><span>|</span><label class="collapse" for="c-37107529">[-]</label><label class="expand" for="c-37107529">[1 more]</label></div><br/><div class="children"><div class="content">I think the current solution is not too far from an ideal scenario: package the most commonly used dependencies&#x2F;programs in nixpks (roughly what would be available with other package managers’ default channel&#x2F;repository), and use flakes as an out-of-tree solution for proprietary&#x2F;freemium&#x2F;hard-to-package&#x2F;very specialist software, similarly to what you might use Docker for.<p>That way you get the benefit of a minimal-sized system with no size overhead for the most part, yet out-of-tree git repos get reproducible at any commit, and it is even easier than adding a new repo to apt, etc.<p>With content-addressable hashing, the problem may largely solve itself, reusing unchanged dependencies between older flakes.</div><br/></div></div><div id="37106451" class="c"><input type="checkbox" id="c-37106451" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#37105885">root</a><span>|</span><a href="#37106120">parent</a><span>|</span><a href="#37107529">prev</a><span>|</span><a href="#37107889">next</a><span>|</span><label class="collapse" for="c-37106451">[-]</label><label class="expand" for="c-37106451">[2 more]</label></div><br/><div class="children"><div class="content">The traditional way is to reduce the surface area of the core package as much as possible, such that it sees less changes&#x2F;releases overall.<p>The way I would do it with nix is: because everything gets hashed, just check that the built output with a new nix-pkg version matches the hash with the old version and fail out&#x2F;fetch the older version as a second step. The rest is just finding ways to cache that build fail information so that you can share the result across users transparently.</div><br/><div id="37107491" class="c"><input type="checkbox" id="c-37107491" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#37105885">root</a><span>|</span><a href="#37106451">parent</a><span>|</span><a href="#37107889">next</a><span>|</span><label class="collapse" for="c-37107491">[-]</label><label class="expand" for="c-37107491">[1 more]</label></div><br/><div class="children"><div class="content">There is work on content-based hashing, but that is not only related to flakes. So that problem may get solved, and is likely the correct path forward.</div><br/></div></div></div></div></div></div><div id="37107889" class="c"><input type="checkbox" id="c-37107889" checked=""/><div class="controls bullet"><span class="by">rq1</span><span>|</span><a href="#37105885">parent</a><span>|</span><a href="#37106120">prev</a><span>|</span><a href="#37107262">next</a><span>|</span><label class="collapse" for="c-37107889">[-]</label><label class="expand" for="c-37107889">[1 more]</label></div><br/><div class="children"><div class="content">Well, not necessarily. There’s a `follows` argument to pin through the different dependencies. It’s not ideal but it’s there.</div><br/></div></div><div id="37107262" class="c"><input type="checkbox" id="c-37107262" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#37105885">parent</a><span>|</span><a href="#37107889">prev</a><span>|</span><a href="#37107451">next</a><span>|</span><label class="collapse" for="c-37107262">[-]</label><label class="expand" for="c-37107262">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Building third party flakes takes forever since every flake uses its own version of nixpkgs.<p>That&#x27;s not quite right. It <i>may</i> use a predefined version of nixpkgs and there may be a reason the version is hardcoded to something. But if that&#x27;s not what you want, you can use something like `nix run ... --override-input nixpkgs nixpkgs` and it will run with your current system nixpkgs version instead.</div><br/></div></div><div id="37107451" class="c"><input type="checkbox" id="c-37107451" checked=""/><div class="controls bullet"><span class="by">tikhonj</span><span>|</span><a href="#37105885">parent</a><span>|</span><a href="#37107262">prev</a><span>|</span><a href="#37106958">next</a><span>|</span><label class="collapse" for="c-37107451">[-]</label><label class="expand" for="c-37107451">[1 more]</label></div><br/><div class="children"><div class="content">I used to be annoyed by how Flakes are coupled to Git, but I&#x27;ve realized that dealing with that is way less pain than dealing with builds that accidentally depend on non-version-controlled files. Missing an unstaged file is annoying, but it gives you an explicit error message and it&#x27;s easy to fix; accidentally depending on a wrong file can skate by silently (perhaps leading to extra rebuilds but nothing more) until you try to reproduce the build somewhere else, and then it&#x27;s at least a small headache to debug and fix.</div><br/></div></div><div id="37106958" class="c"><input type="checkbox" id="c-37106958" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#37105885">parent</a><span>|</span><a href="#37107451">prev</a><span>|</span><a href="#37106286">next</a><span>|</span><label class="collapse" for="c-37106958">[-]</label><label class="expand" for="c-37106958">[2 more]</label></div><br/><div class="children"><div class="content">FYI, if you want Flakes to not be tied to Git, I&#x27;d recommend using `nix [...] path:&#x2F;&#x2F;$PWD` or something along those lines. This will bypass the VCS detection for you.<p>Given that the Git thing is meant to stop you from shooting yourself in the foot, I think maybe it&#x27;s time to conclude it wasn&#x27;t really that great of an idea. However, I still see why it works that way.</div><br/><div id="37107114" class="c"><input type="checkbox" id="c-37107114" checked=""/><div class="controls bullet"><span class="by">rrix2</span><span>|</span><a href="#37105885">root</a><span>|</span><a href="#37106958">parent</a><span>|</span><a href="#37106286">next</a><span>|</span><label class="collapse" for="c-37107114">[-]</label><label class="expand" for="c-37107114">[1 more]</label></div><br/><div class="children"><div class="content">This makes the third issue of the parent comment much worse, unfortunately since there will be a new &#x2F;nix&#x2F;store hash when even things in .gitignore or things like lock files or editor backup files are touched. I&#x27;ve cleaned up hundreds of gigs after a long evening of hacking</div><br/></div></div></div></div><div id="37106286" class="c"><input type="checkbox" id="c-37106286" checked=""/><div class="controls bullet"><span class="by">predictabl3</span><span>|</span><a href="#37105885">parent</a><span>|</span><a href="#37106958">prev</a><span>|</span><a href="#37105938">next</a><span>|</span><label class="collapse" for="c-37106286">[-]</label><label class="expand" for="c-37106286">[2 more]</label></div><br/><div class="children"><div class="content">&gt;You need to remember to stage changes whenever you do Ctrl+S in your editor before rebuilding<p>This is decidely not quite true. You must have the file visible to Git. Flakes still just uses the files, as long as they&#x27;re tracked by git. As long as you have no new files that aren&#x27;t in the index, staging unstaged changes will not change eval.<p>That said, yes, when you add a new file to a flakes repo, you start to develop a habit of always adding it to the stage&#x2F;index for eval.<p>but you should ONLY ever see this as a very very obvious &quot;file not found&quot;, it is not a subtle problem as this post implies.</div><br/><div id="37106650" class="c"><input type="checkbox" id="c-37106650" checked=""/><div class="controls bullet"><span class="by">colordrops</span><span>|</span><a href="#37105885">root</a><span>|</span><a href="#37106286">parent</a><span>|</span><a href="#37105938">next</a><span>|</span><label class="collapse" for="c-37106650">[-]</label><label class="expand" for="c-37106650">[1 more]</label></div><br/><div class="children"><div class="content">I concur, this has not been something I&#x27;ve tripped up on. It&#x27;s pretty obvious when it&#x27;s the problem.</div><br/></div></div></div></div><div id="37105938" class="c"><input type="checkbox" id="c-37105938" checked=""/><div class="controls bullet"><span class="by">jacoblambda</span><span>|</span><a href="#37105885">parent</a><span>|</span><a href="#37106286">prev</a><span>|</span><a href="#37105742">next</a><span>|</span><label class="collapse" for="c-37105938">[-]</label><label class="expand" for="c-37105938">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Flakes copy the entire directory into the nix store. This is terrible for mono-repos - and especially if it contains any large files. There is an issue about making the copying of the entire directory into &#x2F;nix&#x2F;store lazy - though this doesn&#x27;t really address the problem. It just treats some common symptoms.<p>Could you not just do a sparse checkout for monorepos?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;pull&#x2F;135881">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;pull&#x2F;135881</a></div><br/><div id="37105974" class="c"><input type="checkbox" id="c-37105974" checked=""/><div class="controls bullet"><span class="by">bergkvist</span><span>|</span><a href="#37105885">root</a><span>|</span><a href="#37105938">parent</a><span>|</span><a href="#37105742">next</a><span>|</span><label class="collapse" for="c-37105974">[-]</label><label class="expand" for="c-37105974">[2 more]</label></div><br/><div class="children"><div class="content">My use case here is not using pkgs.fetchgit etc - but rather when developing a package locally and rebuilding it.<p>Let&#x27;s say I&#x27;m working on a huge monorepo locally, with GBs of code and data in it, most of which I want to ignore in my nix build. Let&#x27;s say the files I actually care about are also not in a single subfolder. Then I can&#x27;t just move the flake.nix to that subfolder either.</div><br/><div id="37106065" class="c"><input type="checkbox" id="c-37106065" checked=""/><div class="controls bullet"><span class="by">jacoblambda</span><span>|</span><a href="#37105885">root</a><span>|</span><a href="#37105974">parent</a><span>|</span><a href="#37105742">next</a><span>|</span><label class="collapse" for="c-37106065">[-]</label><label class="expand" for="c-37106065">[1 more]</label></div><br/><div class="children"><div class="content">Oh yeah in that case it&#x27;d be a problem. There might be a way around that but that case definitely isn&#x27;t ideal. albeit you could probably sparse-checkout your repo to avoid that if you don&#x27;t need all of it.<p>definitely not ideal and I agree that until lazy file mapping, content addressed derivations, and file deduplication get implemented that the UX will be rough in some cases.</div><br/></div></div></div></div></div></div></div></div><div id="37105742" class="c"><input type="checkbox" id="c-37105742" checked=""/><div class="controls bullet"><span class="by">bongobingo1</span><span>|</span><a href="#37105885">prev</a><span>|</span><a href="#37106743">next</a><span>|</span><label class="collapse" for="c-37105742">[-]</label><label class="expand" for="c-37105742">[34 more]</label></div><br/><div class="children"><div class="content">Ive always loved the idea of nix, but feel like I&#x27;ve read numerous, if not horror, at least uncomfortable stories about the actual real-world experience after the initial &quot;setup yak shaving&quot; is done - which is often exciting for &quot;us&quot;, it&#x27;s the new project problem solving part before it falls into the boring &quot;work&quot; part.<p>If I have an arch system now, how useful is it to use Nix or Homemanager on a non-nixos <i>linux</i> system? I dont really want to dump a working system and duel booting always has whatever you need on the other system.<p>Do you <i>get</i> anything when not using NixOS to manage <i>everything</i>? What good is it if half my system is installed by pacman, half by asdf-per-project and the rest by nix? Has anyone gone down this route? What is the actual lived experience of half-assing it?</div><br/><div id="37105869" class="c"><input type="checkbox" id="c-37105869" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#37105742">parent</a><span>|</span><a href="#37105806">next</a><span>|</span><label class="collapse" for="c-37105869">[-]</label><label class="expand" for="c-37105869">[6 more]</label></div><br/><div class="children"><div class="content">It can get you two major things. Docker-like reproducibility for any development project in a much more convenient way. And the ability to try lots of software <i>without</i> installing it.<p>For me, the last one is a gamechanger, as I am no longer worried about littering my system with tons of dependencies. Say I want to convert an eBook I downloaded. I can quickly use Calibre for a one-off thing, with nix run nixpkgs#calibre.</div><br/><div id="37106224" class="c"><input type="checkbox" id="c-37106224" checked=""/><div class="controls bullet"><span class="by">jfoutz</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37105869">parent</a><span>|</span><a href="#37107441">next</a><span>|</span><label class="collapse" for="c-37106224">[-]</label><label class="expand" for="c-37106224">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m new to nix&#x2F;nixos but gradually building up my environment.<p>it&#x27;s like having your whole OS in git. it&#x27;s amazing. want to try out some nightly build? no problem.<p>on most computers (personal, home computers) the various lib dirs get scary after a while. repoquery can help, but is kind of a hassle. if some executable `foo` depends on some specific behavior in some version of some library, it&#x27;s fine. that weird library can stay in place, I can try out nightly&#x27;s of foo, can always rollback to the system that used to work, and can flip to the new foo when it&#x27;s ready.<p>I think it&#x27;s a good practice to wipe and re provision from time to time to make sure provisioning and backups actually work, but like, you can screw around with _crazy_ things and not really have to worry about having to rebuild the whole thing. (well, I haven&#x27;t yet) I still will, because that&#x27;s how I am. but I can do it when I feel like it, not when I fucked up. it&#x27;s so easy to un fuck a nix system.<p>I guess the big caveat is, this is a hobby. I haven&#x27;t used nix for work. Back in the day, I did support docker in production when the kernel patches were coming pretty quickly. Finding the right balance of patch level, and libc version, that would support docker, and the other stuff that needed to run was a pretty complicated dance, and missing a step would be, not great. Knowing what I know now, even as a hobbyist, I probably could have made my life a lot easier back then.</div><br/><div id="37107557" class="c"><input type="checkbox" id="c-37107557" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37106224">parent</a><span>|</span><a href="#37107441">next</a><span>|</span><label class="collapse" for="c-37107557">[-]</label><label class="expand" for="c-37107557">[1 more]</label></div><br/><div class="children"><div class="content">Exactly, I have been a huge distro hopper to the point that having the same install for a month was already at the high end (though I did keep my home partition).<p>Now I have 2 years old NixOS installs on personal machines and they do not get bloated with packages that the package manager can no longer handle, and is basically always at a state as if it were freshly installed. It just “feels right”. To me, that makes the occasional edge cases worthwhile to suffer through (some binary package, mostly) - especially that in most cases something like steam-run is enough to make it work. When it isn’t, systemd-nspawn can boot you into any systemd distro you would want.</div><br/></div></div></div></div><div id="37107441" class="c"><input type="checkbox" id="c-37107441" checked=""/><div class="controls bullet"><span class="by">bpye</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37105869">parent</a><span>|</span><a href="#37106224">prev</a><span>|</span><a href="#37106219">next</a><span>|</span><label class="collapse" for="c-37107441">[-]</label><label class="expand" for="c-37107441">[1 more]</label></div><br/><div class="children"><div class="content">I also really like flakes. I know they are still experimental today - though hopefully that&#x27;ll improve with this RFC - but they make it trivial to have an out of tree package. For example I just recently created a flake for a vendor OpenOCD fork [0] - and now I can reference that in my home-manager config or from some other project.<p>[0] - <a href="https:&#x2F;&#x2F;github.com&#x2F;benpye&#x2F;openocd&#x2F;blob&#x2F;mrs-2023-08-07&#x2F;default.nix">https:&#x2F;&#x2F;github.com&#x2F;benpye&#x2F;openocd&#x2F;blob&#x2F;mrs-2023-08-07&#x2F;defaul...</a></div><br/></div></div><div id="37106219" class="c"><input type="checkbox" id="c-37106219" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37105869">parent</a><span>|</span><a href="#37107441">prev</a><span>|</span><a href="#37105806">next</a><span>|</span><label class="collapse" for="c-37106219">[-]</label><label class="expand" for="c-37106219">[2 more]</label></div><br/><div class="children"><div class="content">I get Docker-actual reproducibility with Fedora Silverblue and toolboxes. Enter one of my Arch&#x2F;Fedora containers, install Calibre without affecting the host. Even better than Nix because I can test custom distributions, rather than each environment simply being another NixOS.<p>In fact, I&#x27;ve departed from vanilla Silverblue, as now my base image is an actual, bona-fide Docker container as well.<p>I feel like the immutable Linux OS is the pragmatic approach, whereas NixOS is the pure, ideal way that requires a lot of changes to tools and workflow to work. Maybe even in this case, worse is better.</div><br/><div id="37106875" class="c"><input type="checkbox" id="c-37106875" checked=""/><div class="controls bullet"><span class="by">pkulak</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37106219">parent</a><span>|</span><a href="#37105806">next</a><span>|</span><label class="collapse" for="c-37106875">[-]</label><label class="expand" for="c-37106875">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, Silverblue is pretty great. But Nix and Silverblue both require changes to your workflow. I like Nix more, but  I don’t think one is objectively better.</div><br/></div></div></div></div></div></div><div id="37105806" class="c"><input type="checkbox" id="c-37105806" checked=""/><div class="controls bullet"><span class="by">pkulak</span><span>|</span><a href="#37105742">parent</a><span>|</span><a href="#37105869">prev</a><span>|</span><a href="#37105801">next</a><span>|</span><label class="collapse" for="c-37105806">[-]</label><label class="expand" for="c-37105806">[3 more]</label></div><br/><div class="children"><div class="content">I don’t know the value of half-assing it, but committing your full ass is amazing. Don’t abandon a working system, but the next time you wait a whole three weeks to pacman -syu and your GPG keys are out of date and everything goes to hell… give it a shot.<p>Honestly, it’s Home Manager that really adds the maximum value, and getting all the way there takes a full weekend, but what were you gonna do anyway?</div><br/><div id="37107535" class="c"><input type="checkbox" id="c-37107535" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37105806">parent</a><span>|</span><a href="#37105949">next</a><span>|</span><label class="collapse" for="c-37107535">[-]</label><label class="expand" for="c-37107535">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Honestly, it’s Home Manager that really adds the maximum value<p>I feel like Nix does have such killer features, but they are different for everyone.<p>For me it was:<p>- system management (nixos + nix-darwin. I wish there was something like nix-darwin for non-nixos linux distros, binding daemon systemd units and desktop files into the &quot;hosting&quot; distro)<p>- on-the-spot running without globally installing for one shot tasks (nix-shell -p iotop --run iotop)<p>- &quot;just works&quot; project environment (default.nix+shell.nix or flakes)<p>These are the ones that made me tip over and decide to go from tiptoeing to full tilt</div><br/></div></div><div id="37105949" class="c"><input type="checkbox" id="c-37105949" checked=""/><div class="controls bullet"><span class="by">tiffanyg</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37105806">parent</a><span>|</span><a href="#37107535">prev</a><span>|</span><a href="#37105801">next</a><span>|</span><label class="collapse" for="c-37105949">[-]</label><label class="expand" for="c-37105949">[1 more]</label></div><br/><div class="children"><div class="content"><i>I don’t know the value of half-assing it, but committing your full ass is amazing.</i><p>Indeed. As no less than Ron Swanson rendered unto us - an exemplar in classic American yarn form:<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;k6hZ9KdG1QU" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;k6hZ9KdG1QU</a><p>... wise words.</div><br/></div></div></div></div><div id="37105801" class="c"><input type="checkbox" id="c-37105801" checked=""/><div class="controls bullet"><span class="by">clhodapp</span><span>|</span><a href="#37105742">parent</a><span>|</span><a href="#37105806">prev</a><span>|</span><a href="#37105808">next</a><span>|</span><label class="collapse" for="c-37105801">[-]</label><label class="expand" for="c-37105801">[1 more]</label></div><br/><div class="children"><div class="content">I use home-manager on Ubuntu on my work machine. You have to pay the full learning curve of Nix. Once you do, it works just fine. I think there comes a natural pressure to use Nix for as much as possible and slowly cut down one&#x27;s dependency on the &quot;base&quot; system when you go this route. Maybe that&#x27;s just because I want to see my investment in Nix pay off.<p>I would say that the biggest benefit you get is the hugeness and currentness of nixpkgs and the fact that it becomes a lot less important what software you have &quot;installed&quot;.</div><br/></div></div><div id="37105808" class="c"><input type="checkbox" id="c-37105808" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#37105742">parent</a><span>|</span><a href="#37105801">prev</a><span>|</span><a href="#37107457">next</a><span>|</span><label class="collapse" for="c-37105808">[-]</label><label class="expand" for="c-37105808">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s fine, just be sure you know where your tools are coming from (use the which command a lot when unsure).  Nix might have more up to date or bleeding edge software, although since you&#x27;re on arch in my experience nix can lag even arch by a little bit.<p>Fully reproducible environments with home manager and nixos are neat but IMHO you can just use ansible to do the same thing on debian, arch, etc. if those systems have the packages you need.<p>When you inevitably find software that isn&#x27;t in nix (or are packaging your own software), be prepared to take a quantum leap in complexity as you now need to fully understand the nix language and its concepts like derivations.  This isn&#x27;t necessarily hard but it is not documented well at all, and there are factions in nix at odds with each other (flakes vs. nix-env) which make learning it even more confusing.</div><br/><div id="37107452" class="c"><input type="checkbox" id="c-37107452" checked=""/><div class="controls bullet"><span class="by">bpye</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37105808">parent</a><span>|</span><a href="#37106607">next</a><span>|</span><label class="collapse" for="c-37107452">[-]</label><label class="expand" for="c-37107452">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s fine, just be sure you know where your tools are coming from (use the which command a lot when unsure). Nix might have more up to date or bleeding edge software, although since you&#x27;re on arch in my experience nix can lag even arch by a little bit.<p>That&#x27;ll depend if you&#x27;re on stable or not. If you&#x27;re on stable and you need something from unstable that&#x27;s also possible without any real risk of breakage on NixOS.</div><br/></div></div><div id="37106607" class="c"><input type="checkbox" id="c-37106607" checked=""/><div class="controls bullet"><span class="by">jsomedon</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37105808">parent</a><span>|</span><a href="#37107452">prev</a><span>|</span><a href="#37106345">next</a><span>|</span><label class="collapse" for="c-37106607">[-]</label><label class="expand" for="c-37106607">[2 more]</label></div><br/><div class="children"><div class="content">&gt; When you inevitably find software that isn&#x27;t in nix (or are packaging your own software), be prepared to take a quantum leap in complexity as you now need to fully understand the nix language and its concepts like derivations. This isn&#x27;t necessarily hard but it is not documented well at all, and there are factions in nix at odds with each other (flakes vs. nix-env) which make learning it even more confusing.<p>Exactly this was why I am so hesitant to switch to nix. I tried to dig into the details of nix, language, derivation and whatnot, but documentations and community discussions are, in my experience pretty segregated that left me confused, and I eventually went back to arch.</div><br/><div id="37107600" class="c"><input type="checkbox" id="c-37107600" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37106607">parent</a><span>|</span><a href="#37106345">next</a><span>|</span><label class="collapse" for="c-37107600">[-]</label><label class="expand" for="c-37107600">[1 more]</label></div><br/><div class="children"><div class="content">In 90% of the cases it is as easy as modifying the earlier version’s version and hash. I think learning nix from outside-in is perhaps easier - grep for something you are looking for, and as if it were a language and you are a small kid, imitate that.<p>Though I will give you that there is enough complexity in specifying which nixpkgs&#x2F;flake gets built, where is it places, etc as is, especially with the `nix-\w+` vs `nix \w+` variants being slightly different, to the point that I always have to look it up in the man page&#x2F;in my history whether I need -A and the like.</div><br/></div></div></div></div><div id="37106345" class="c"><input type="checkbox" id="c-37106345" checked=""/><div class="controls bullet"><span class="by">bongobingo1</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37105808">parent</a><span>|</span><a href="#37106607">prev</a><span>|</span><a href="#37106933">next</a><span>|</span><label class="collapse" for="c-37106345">[-]</label><label class="expand" for="c-37106345">[1 more]</label></div><br/><div class="children"><div class="content">&gt; When you inevitably find software that isn&#x27;t in nix (or are packaging your own software), be prepared to take a quantum leap in complexity<p>I think this is where most of the &quot;i went back&quot; posts I read came from. That and hitting issues with programs that expect to be able to write to some XDG dirs.</div><br/></div></div><div id="37106933" class="c"><input type="checkbox" id="c-37106933" checked=""/><div class="controls bullet"><span class="by">tkz1312</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37105808">parent</a><span>|</span><a href="#37106345">prev</a><span>|</span><a href="#37106708">next</a><span>|</span><label class="collapse" for="c-37106933">[-]</label><label class="expand" for="c-37106933">[1 more]</label></div><br/><div class="children"><div class="content">fwiw nixpkgs has significantly more packages than arch (including the aur), and those packages are also significantly more up to date. No other repo comes close to nixpkgs in this regard. This has been the case for quite some years now.<p><a href="https:&#x2F;&#x2F;repology.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;repology.org&#x2F;</a></div><br/></div></div><div id="37106708" class="c"><input type="checkbox" id="c-37106708" checked=""/><div class="controls bullet"><span class="by">colordrops</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37105808">parent</a><span>|</span><a href="#37106933">prev</a><span>|</span><a href="#37107457">next</a><span>|</span><label class="collapse" for="c-37106708">[-]</label><label class="expand" for="c-37106708">[1 more]</label></div><br/><div class="children"><div class="content">Sorry to be blunt but I&#x27;ve seen nearly exact comments as yours and they come off as someone who hasn&#x27;t really used Nix and doesn&#x27;t understand the value proposition and the problems it solves.<p>I&#x27;ve used Ansible for years, then moved to Nix and have been on it for a year and a half. Yes the configuration language is more complex than Ansible&#x27;s but it&#x27;s also way more consistent and predictable. The bit of complexity comes with a lot of additional benefit. Ansible half-asses it, only giving you idempotency <i>if</i> you stay within certain boundaries in how you write configs.  And a leaky system is a system that will break. Making it even worse is that you are building on top of a moving target with a distribution underneath that will break your Ansible scripts regularly as the system changes. Ansible is a huge mess and not suitable for the job IMHO.<p>With NixOS, the entire system  is controlled by config, so there is only one source of truth for the state of the system, unlike Ansible. This is a fundamental flaw.  Ansible is a hack on top of pre-existing setups.<p>With Nix, my system only gets more stable with time. It&#x27;s the opposite of anything I&#x27;ve ever used, where systems get crufty and have to be reinstalled every couple years.  Since the state of the system is fully determined by your config, you can always get to an exact state without a bunch of extra shit missing or added.<p>And the language isn&#x27;t really that hard for anyone who&#x27;s done a bit of programming. It&#x27;s certainly easier than most general purpose languages, as it&#x27;s static data 90% of the time with a bit of logic thrown in when needed.</div><br/></div></div></div></div><div id="37107457" class="c"><input type="checkbox" id="c-37107457" checked=""/><div class="controls bullet"><span class="by">sullyj3</span><span>|</span><a href="#37105742">parent</a><span>|</span><a href="#37105808">prev</a><span>|</span><a href="#37105896">next</a><span>|</span><label class="collapse" for="c-37107457">[-]</label><label class="expand" for="c-37107457">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m running home-manager on arch and it&#x27;s fantastic. I&#x27;m only using it for cli&#x2F;tui programs, as I&#x27;ve had trouble getting gui software to correctly create desktop entries which show up in my menus. You can use it alongside pacman just fine.</div><br/><div id="37107581" class="c"><input type="checkbox" id="c-37107581" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37107457">parent</a><span>|</span><a href="#37105896">next</a><span>|</span><label class="collapse" for="c-37107581">[-]</label><label class="expand" for="c-37107581">[2 more]</label></div><br/><div class="children"><div class="content">In the worst case scenario, you can just manually create files in your home directory if needed, so putting them under .local&#x2F;share something should get you desktop entries (though depending on the desktop&#x2F;window manager you may need a restart).</div><br/><div id="37107668" class="c"><input type="checkbox" id="c-37107668" checked=""/><div class="controls bullet"><span class="by">sullyj3</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37107581">parent</a><span>|</span><a href="#37105896">next</a><span>|</span><label class="collapse" for="c-37107668">[-]</label><label class="expand" for="c-37107668">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;d much rather just install with pacman than manage them manually though.</div><br/></div></div></div></div></div></div><div id="37105896" class="c"><input type="checkbox" id="c-37105896" checked=""/><div class="controls bullet"><span class="by">wtetzner</span><span>|</span><a href="#37105742">parent</a><span>|</span><a href="#37107457">prev</a><span>|</span><a href="#37105932">next</a><span>|</span><label class="collapse" for="c-37105896">[-]</label><label class="expand" for="c-37105896">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Do you get anything when not using NixOS to manage everything?<p>Sure, I think the biggest benefit is being able to get a temporary environment for a project. You can have all of your dependencies pinned, even for languages that don&#x27;t have package managers, and for mixed-language projects. You can get easily get a shell that contains the exact compiler versions, libraries, etc. from a single config file, and it&#x27;s isolated from the rest of the system. I guess it&#x27;s kind of like having a lighter-weight container.</div><br/><div id="37105920" class="c"><input type="checkbox" id="c-37105920" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37105896">parent</a><span>|</span><a href="#37107119">next</a><span>|</span><label class="collapse" for="c-37105920">[-]</label><label class="expand" for="c-37105920">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s no lighter than a process running in docker, on a Linux machine at least.  With docker you have a whole root filesystem packaged up and a process inside it is executed on your system with certain kernel namespacing to set its root filesystem, users, network access, limits on memory and CPU usage, etc.<p>With nix instead of a tarball being the root filesystem it&#x27;s a bunch of symlinks to stuff in the nix store directory--the process you run is exactly the same as whatever you&#x27;re running in docker.<p>One crucial difference is that nix does nothing for network isolation, you have to do all that on your own (if you need it).</div><br/><div id="37106093" class="c"><input type="checkbox" id="c-37106093" checked=""/><div class="controls bullet"><span class="by">Filligree</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37105920">parent</a><span>|</span><a href="#37106969">next</a><span>|</span><label class="collapse" for="c-37106093">[-]</label><label class="expand" for="c-37106093">[2 more]</label></div><br/><div class="children"><div class="content">Nix doesn&#x27;t do network, PID or filesystem isolation.<p>That&#x27;s a feature. I don&#x27;t normally want any of those.</div><br/><div id="37106160" class="c"><input type="checkbox" id="c-37106160" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37106093">parent</a><span>|</span><a href="#37106969">next</a><span>|</span><label class="collapse" for="c-37106160">[-]</label><label class="expand" for="c-37106160">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t have to use them, docker has flags to disable things like network isolation.  If you want to go deeper systemd-nspawn doesn&#x27;t isolate anything (network, pid, user, etc.).  And if you are some anti-systemd zealot the plain old chroot command does what you want too (and has done so for decades).</div><br/></div></div></div></div><div id="37106969" class="c"><input type="checkbox" id="c-37106969" checked=""/><div class="controls bullet"><span class="by">pkulak</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37105920">parent</a><span>|</span><a href="#37106093">prev</a><span>|</span><a href="#37107119">next</a><span>|</span><label class="collapse" for="c-37106969">[-]</label><label class="expand" for="c-37106969">[2 more]</label></div><br/><div class="children"><div class="content">It’s a lot lighter in terms of disk space. Yes, drives are cheap, but even so, bringing in a different version of debian-slim for every executable gets bloaty. I routinely reclaim 10s (sometimes 100s) of gigs with a podman system reset.</div><br/><div id="37107611" class="c"><input type="checkbox" id="c-37107611" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37106969">parent</a><span>|</span><a href="#37107119">next</a><span>|</span><label class="collapse" for="c-37107611">[-]</label><label class="expand" for="c-37107611">[1 more]</label></div><br/><div class="children"><div class="content">Also in RAM. You don’t want to runa whole-ass container for `ls`.</div><br/></div></div></div></div></div></div><div id="37107119" class="c"><input type="checkbox" id="c-37107119" checked=""/><div class="controls bullet"><span class="by">toastal</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37105896">parent</a><span>|</span><a href="#37105920">prev</a><span>|</span><a href="#37105932">next</a><span>|</span><label class="collapse" for="c-37107119">[-]</label><label class="expand" for="c-37107119">[1 more]</label></div><br/><div class="children"><div class="content">The biggest advantage is the ability to reproduce your mutable environment‽ You get more advantages when the whole environment is reproducible.</div><br/></div></div></div></div><div id="37105932" class="c"><input type="checkbox" id="c-37105932" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#37105742">parent</a><span>|</span><a href="#37105896">prev</a><span>|</span><a href="#37105852">next</a><span>|</span><label class="collapse" for="c-37105932">[-]</label><label class="expand" for="c-37105932">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Do you <i>get</i> anything when not using NixOS to manage <i>everything</i>? [...] Has anyone gone down this route?<p>Yeah, for sure! I don&#x27;t use Nix this way very much on Linux because I mostly just use NixOS. But I use Nix this way on macOS at work every day, because that&#x27;s the Unix desktop that&#x27;s available to engineers there.<p>By not going full NixOS, the tradeoff is that you suffer some minor integration issues, and in return you get some more escape hatches. This is a pretty good option for some people imo.<p>Declarative system config on non-NixOS is a bit more work, because you either have to write your own sort of metapackages with buildEnv¹ or use a third-party module system like Home Manager, System Manager (that one&#x27;s in very early stages, so pronably skip it if you&#x27;re a newbie), or Nix-Darwin. The latter are really nice, but you might have to think about how they plug into things like your OS&#x27;s bashrc file sometimes, and sometimes their install procedures are kinda wonky.<p>The other main integration quirk to watch out for on non-NixOS is 3D graphics acceleration. Check out nixGL and you&#x27;ll be covered for that.<p>Using Nix for nifty per-project development environments, though, is pretty smooth and basically identical whether you&#x27;re on NixOS or not. If that&#x27;s an interesting use case for you, Nix on non-NixOS is worth checking out.<p>Nix as a package manager for  CLI tools that don&#x27;t depend on the base system, or trying out software without permanently installing it, is also kinda nice on other distros. It&#x27;s especially nice for running newer software on top of stale distros, but it can also take you in the other direction, which might sometimes be useful on Arch.<p>I think the head first approach of just committing to daily driving NixOS can be good for some people, and it certainly was for me. But learning your way around the Nix language and developer tools by focusing on developer environments and oddball packages on a foreign OS can definitely make for an easier, lower stakes learning process.<p>&gt; What good is it if half my system is installed by pacman, half by asdf-per-project and the rest by nix?<p>If you&#x27;re not using Nix for any per-project stuff, you&#x27;re definitely missing some value, as that&#x27;s likely among the first low-hanging fruit you&#x27;ll encounter on your Nix journey.<p>That said, stacking Nix with other package managers and only using it where it makes most sense is totally viable. On macOS, I use it in combination with light use of pkgsrc and Homebrew. You can definitely do the same kind of thing on Linux.</div><br/></div></div><div id="37105852" class="c"><input type="checkbox" id="c-37105852" checked=""/><div class="controls bullet"><span class="by">abathur</span><span>|</span><a href="#37105742">parent</a><span>|</span><a href="#37105932">prev</a><span>|</span><a href="#37106743">next</a><span>|</span><label class="collapse" for="c-37105852">[-]</label><label class="expand" for="c-37105852">[5 more]</label></div><br/><div class="children"><div class="content">It depends on what you&#x27;re hoping to get out of it. I mostly-whole-ass it, but I still use the mac app store and homebrew for a few things. Most projects are Nix by this point.<p>It&#x27;s hard to tell from how you say it; if you aren&#x27;t using it for any projects <i>and</i> would just be using it for a slice of your system&#x2F;user packages, I suspect you&#x27;ll end up not really seeing what the fuss is about. If you will try to use it with some projects, I&#x27;d start there and see how it goes.<p>(It should be fairly low stakes. If it doesn&#x27;t stick, you won&#x27;t disrupt yourself that much. If it does stick, you&#x27;ll have a better sense of what you want to hand over to it and why.)</div><br/><div id="37106846" class="c"><input type="checkbox" id="c-37106846" checked=""/><div class="controls bullet"><span class="by">throwaway290</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37105852">parent</a><span>|</span><a href="#37106743">next</a><span>|</span><label class="collapse" for="c-37106846">[-]</label><label class="expand" for="c-37106846">[4 more]</label></div><br/><div class="children"><div class="content">How do you personally use Nix on a project, any tips? Do you use flakes? What are first steps&#x2F;basic scaffolding? I am eager to get into Nix but not ready to go full on (I&#x27;m also on Mac but some devs may be on Linux)<p>Is it possible with complex projects like based on Electron? Is it reasonable to use Nix in Docker (eg. I am on Mac but want to build it like it&#x27;s on CI)?</div><br/><div id="37107195" class="c"><input type="checkbox" id="c-37107195" checked=""/><div class="controls bullet"><span class="by">fortunateregard</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37106846">parent</a><span>|</span><a href="#37107587">next</a><span>|</span><label class="collapse" for="c-37107195">[-]</label><label class="expand" for="c-37107195">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How do you use Nix on a project, any tips?<p>Combining nix with direnv is a popular combo for dev environments. Example: <a href="https:&#x2F;&#x2F;determinate.systems&#x2F;posts&#x2F;nix-direnv" rel="nofollow noreferrer">https:&#x2F;&#x2F;determinate.systems&#x2F;posts&#x2F;nix-direnv</a><p>If you haven&#x27;t worked with nix before, the quick start here is a good place to start <a href="https:&#x2F;&#x2F;zero-to-nix.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;zero-to-nix.com&#x2F;</a></div><br/></div></div><div id="37107587" class="c"><input type="checkbox" id="c-37107587" checked=""/><div class="controls bullet"><span class="by">abathur</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37106846">parent</a><span>|</span><a href="#37107195">prev</a><span>|</span><a href="#37106743">next</a><span>|</span><label class="collapse" for="c-37107587">[-]</label><label class="expand" for="c-37107587">[2 more]</label></div><br/><div class="children"><div class="content">&gt; How do you use Nix on a project, any tips? What are first steps&#x2F;basic scaffolding? I am eager to get into Nix but not ready to go full on (I&#x27;m also on Mac but some devs may be on Linux)<p>Not sure I can boil it down to tips, but: more or less any time I need to do something regularly that involves third-party code, I&#x27;ll be using Nix to manage it. Specifics depends on the project. There are templates around (and templating is built into flakes via `nix flake init`), but I haven&#x27;t used those much myself.<p>Maybe a sense of general patterns helps?<p>Most of my projects have at least a shell.nix (devShell expression in flake.nix) for setting up an environment to work on the project. I.e., add appropriate deps to path, define some utility shell functions, start up database servers and so on.<p>Sometimes that&#x27;s all. For example, my blog just has a shell.nix for providing dependencies like hugo, gist, make, jq, etc., defining some helper functions for scaffolding new posts and such, and then I use Makefile targets for creating a dev build, production build, and publishing.<p>If it&#x27;s something others might use, I&#x27;ll generally have a default.nix&#x2F;flake expression for building the package. Then I can use that for testing it, for integrating it in other projects or my own systems or whatever.<p>I&#x27;ll often have one or more expressions for ~testing it. (If I have more than one, the first might be a straight test, and the 2nd might be a performance suite comparing it against similar tools, for example.)<p>If I&#x27;m researching several potential alternatives, I may build a Nix expression that builds all of them, pulls them all into scope, and then invokes them all to compare whatever I care about. Then I can readily repeat the same check locally, or go run it a bunch in CI.<p>If it&#x27;s something I have CI set up for, I may bother to have a ~normal build that runs against pinned dependency versions whenever I make code changes, and then also set up a ~canary build that regularly re-runs my project&#x27;s main&#x2F;master against the latest nixpkgs so that I get some notice if something I depend on happens to be broken.<p>&gt; Is it possible with complex projects like based on Electron?<p>I&#x27;m not familiar with the Electron packaging, sorry. I know it&#x27;s doable because we&#x27;ve got a number of electron packages, but I don&#x27;t have perspective on how easy it is and whether it&#x27;s working on Linux and macOS or just the former.<p>&gt; Is it reasonable to use Nix in Docker (eg. I am on Mac but want to build it like it&#x27;s on CI)?<p>Sure. There&#x27;s an official Nix container image, and some of our gitlab CI jobs use it. IIRC it&#x27;s a little tricky to install Nix in a container imperatively, but I think the state of that has improved since the last time I needed to fiddle with our setup.</div><br/><div id="37107643" class="c"><input type="checkbox" id="c-37107643" checked=""/><div class="controls bullet"><span class="by">throwaway290</span><span>|</span><a href="#37105742">root</a><span>|</span><a href="#37107587">parent</a><span>|</span><a href="#37106743">next</a><span>|</span><label class="collapse" for="c-37107643">[-]</label><label class="expand" for="c-37107643">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, this is super helpful!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37106743" class="c"><input type="checkbox" id="c-37106743" checked=""/><div class="controls bullet"><span class="by">sourcegrift</span><span>|</span><a href="#37105742">prev</a><span>|</span><a href="#37107169">next</a><span>|</span><label class="collapse" for="c-37106743">[-]</label><label class="expand" for="c-37106743">[15 more]</label></div><br/><div class="children"><div class="content">My biggest problem with flakes is that it is too much added complexity for tiny incremental gains (as per my limited understanding, happy to be corrected). Not only do most users gain very, very little from it, it also deters users from using nix for two reasons:<p>1) There is more to learn now.<p>2) Split ecosystem.<p>I&#x27;m looking to be educated, I&#x27;ve made contributions to nixpkgs (two &quot;mid-sized&quot; changes) but for some reason I couldn&#x27;t bring myself to learn flakes ... Although that could have been because they were in limbo.<p>I have to say though, nix is increasingly becoming a nerd thing philosophizing over minute issues rather than &quot;getting shit done&quot; to benefit the maximum number of users ... :-(</div><br/><div id="37107139" class="c"><input type="checkbox" id="c-37107139" checked=""/><div class="controls bullet"><span class="by">rgoulter</span><span>|</span><a href="#37106743">parent</a><span>|</span><a href="#37107655">next</a><span>|</span><label class="collapse" for="c-37107139">[-]</label><label class="expand" for="c-37107139">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Not only do most users gain very, very little from it<p>How do you come to that conclusion?<p>Those who switch to using flakes are enthusiastic about the improved UX.<p>&gt; flakes is that it is too much added complexity for tiny incremental gains<p>A &#x27;flake&#x27; is more&#x2F;less a set of inputs and a set of outputs. I&#x27;d say it&#x27;s less complicated than a package.json file in an NPM project.<p>The benefits are hard to get otherwise.<p>With flakes, `flake.nix` provides a standard entrypoint to a Nix codebase. Without flakes, you might see a `default.nix`, but would have to read the `default.nix` to know how it&#x27;s supposed to be called.<p>With flakes, the exact version of Nixpkgs used is locked. Without flakes, I&#x27;m not aware of an easy way to do this with channels; and there are a variety of ways (read: no standard way) to do this in Nix code.</div><br/><div id="37107483" class="c"><input type="checkbox" id="c-37107483" checked=""/><div class="controls bullet"><span class="by">sullyj3</span><span>|</span><a href="#37106743">root</a><span>|</span><a href="#37107139">parent</a><span>|</span><a href="#37107429">next</a><span>|</span><label class="collapse" for="c-37107483">[-]</label><label class="expand" for="c-37107483">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A &#x27;flake&#x27; is more&#x2F;less a set of inputs and a set of outputs. I&#x27;d say it&#x27;s less complicated than a package.json file in an NPM project.<p>It&#x27;s conceptually comparably complicated, but the actual practical experience of writing flakes is much more complicated. This is not the fault of flakes specifically, but rather due to the complexity of nixpkgs. Although on second thoughts the fact that there are a bunch of libraries like flake-utils and flake-parts out there does seem to point at a verbosity UX issue.</div><br/></div></div><div id="37107429" class="c"><input type="checkbox" id="c-37107429" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#37106743">root</a><span>|</span><a href="#37107139">parent</a><span>|</span><a href="#37107483">prev</a><span>|</span><a href="#37107655">next</a><span>|</span><label class="collapse" for="c-37107429">[-]</label><label class="expand" for="c-37107429">[1 more]</label></div><br/><div class="children"><div class="content">For me the biggest benefits of flakes are:<p>- flake-specific state is fully captured and locked<p>- this locking applies for all platforms the flake targets<p>- extreme ability to be composed<p>The first two solve the same issue as Gemfile.lock, its the PLATFORMS section, and the platform annotations on each of its gem line, which allows `bundle lock` to lock not just for the platform it&#x27;s being run on but all platforms that are targeted.<p>It also canonicalizes the way to declare targets to build, whereas previously it was kind of TIMTOWTDI (e.g default.nix evaluation is the default target and calling nix-build sans arguments builds that to `result`, and if you want more you write alternative nix files, the whole organisation of that is on you)<p>These are very useful for project-oriented nix stuff.<p>For system (nixos, nix-darwin)&#x2F;environment&#x2F;profile&#x2F;home management I still prefer classic channels, which gives me a single, consistent nixpkgs source, kind of like BSD&#x27;s base which is handled as a whole (except here it applies to the whole of packages). I am still able to locally override this or that by selectively pulling another nixpkgs (or other source) and use that to pick a specific package version (either forward or backward) but otherwise I stick to the single consistent one.<p>It feels to me that using flakes for the whole system would be like using npm and having a whole recursive tree of `node_modules`. I certainly don&#x27;t want to have a thousand different openssl around!</div><br/></div></div></div></div><div id="37107655" class="c"><input type="checkbox" id="c-37107655" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#37106743">parent</a><span>|</span><a href="#37107139">prev</a><span>|</span><a href="#37106852">next</a><span>|</span><label class="collapse" for="c-37107655">[-]</label><label class="expand" for="c-37107655">[1 more]</label></div><br/><div class="children"><div class="content">As a counter-anecdote, as someone who used to be a newcomer to Nix, it took until I encountered flakes before I went &quot;aha, <i>this</i> is how it was always meant to be&quot;.</div><br/></div></div><div id="37106852" class="c"><input type="checkbox" id="c-37106852" checked=""/><div class="controls bullet"><span class="by">pkulak</span><span>|</span><a href="#37106743">parent</a><span>|</span><a href="#37107655">prev</a><span>|</span><a href="#37107093">next</a><span>|</span><label class="collapse" for="c-37106852">[-]</label><label class="expand" for="c-37106852">[6 more]</label></div><br/><div class="children"><div class="content">I think we all have our own aha moments with things like this. I thought like you until I really dug in and set up Home Manager as well. My moment, and maybe this means nothing to you, was when I realized I could reference any package in a config file without even “installing” it. So it’s no longer that I have config files in Git somewhere, and then also a list of all the packages I need to install somewhere else; the config files themselves pull in the packages they need by virtue of referencing them. There are a million other things, but that’s when I was like, “Okay, I’m actually gonna do this.”</div><br/><div id="37107129" class="c"><input type="checkbox" id="c-37107129" checked=""/><div class="controls bullet"><span class="by">sourcegrift</span><span>|</span><a href="#37106743">root</a><span>|</span><a href="#37106852">parent</a><span>|</span><a href="#37106957">next</a><span>|</span><label class="collapse" for="c-37107129">[-]</label><label class="expand" for="c-37107129">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m familiar with home manager (or as I like to call it, a hammer looking for a nail, that solves no problem). I don&#x27;t think home manager has any relationship with flakes. Also, nix solves actual real problems, home manager doesn&#x27;t. There are better dotfile managers. In fact, vim understands the syntaxes of a lot of dotfiles, with home manager, you even lose that.</div><br/><div id="37107428" class="c"><input type="checkbox" id="c-37107428" checked=""/><div class="controls bullet"><span class="by">colordrops</span><span>|</span><a href="#37106743">root</a><span>|</span><a href="#37107129">parent</a><span>|</span><a href="#37106957">next</a><span>|</span><label class="collapse" for="c-37107428">[-]</label><label class="expand" for="c-37107428">[2 more]</label></div><br/><div class="children"><div class="content">There are Nix LSP servers now that handle embedded config files. But beyond that, you can always just leave the config in its original format and import it into the Nix config, and not lose your syntax highlighting.<p>Speaking of vim, I&#x27;ve got neovim configured completely with home manager. It references plugins as first-class nix packages, and also any external dependencies like language servers, node packages, parsing tools etc are also managed by Nix. You can reference the deps in the vim config and it will automatically download and point to them in the nix store without even installing them.<p>It&#x27;s amazing. Everytime I upgrade and building my system, my nvim setup gets upgraded automatically too. No need for a package manager or manual updates.</div><br/><div id="37107905" class="c"><input type="checkbox" id="c-37107905" checked=""/><div class="controls bullet"><span class="by">sourcegrift</span><span>|</span><a href="#37106743">root</a><span>|</span><a href="#37107428">parent</a><span>|</span><a href="#37106957">next</a><span>|</span><label class="collapse" for="c-37107905">[-]</label><label class="expand" for="c-37107905">[1 more]</label></div><br/><div class="children"><div class="content">But I have the exact same setup without the &quot;hammer-searching-for-nail&quot; home manager. (Almost) all of my vim plugins are managed by my nixos config</div><br/></div></div></div></div></div></div><div id="37106957" class="c"><input type="checkbox" id="c-37106957" checked=""/><div class="controls bullet"><span class="by">ibizaman</span><span>|</span><a href="#37106743">root</a><span>|</span><a href="#37106852">parent</a><span>|</span><a href="#37107129">prev</a><span>|</span><a href="#37107093">next</a><span>|</span><label class="collapse" for="c-37106957">[-]</label><label class="expand" for="c-37106957">[2 more]</label></div><br/><div class="children"><div class="content">I’m maybe missing something but non-flake nix also pull packages by just referencing them. Right?</div><br/><div id="37107083" class="c"><input type="checkbox" id="c-37107083" checked=""/><div class="controls bullet"><span class="by">rgoulter</span><span>|</span><a href="#37106743">root</a><span>|</span><a href="#37106957">parent</a><span>|</span><a href="#37107093">next</a><span>|</span><label class="collapse" for="c-37107083">[-]</label><label class="expand" for="c-37107083">[1 more]</label></div><br/><div class="children"><div class="content">Yes, in Nix code it is possible to refer to arbitrary Nix codebases from Nix code.<p>I&#x27;d point to the home-manager installation instructions for an example of Nix flakes having a nicer UX. Running flake-enabled codebases is just much nicer than non-flake codebases.<p><a href="https:&#x2F;&#x2F;nix-community.github.io&#x2F;home-manager&#x2F;index.html#sec-install-standalone" rel="nofollow noreferrer">https:&#x2F;&#x2F;nix-community.github.io&#x2F;home-manager&#x2F;index.html#sec-...</a><p><a href="https:&#x2F;&#x2F;nix-community.github.io&#x2F;home-manager&#x2F;index.html#sec-flakes-standalone" rel="nofollow noreferrer">https:&#x2F;&#x2F;nix-community.github.io&#x2F;home-manager&#x2F;index.html#sec-...</a><p>The former involves running `nix-channel --add &lt;...&gt; home-manager &amp;&amp; nix-channel --update` in order for `&lt;home-manager&gt;` to mean anything. With the latter, it&#x27;s simply `nix run home-manager&#x2F;release-23.05 -- init --switch`. (Albeit, `home-manager` is already registered as an alias for `github:nix-community&#x2F;home-manager`).<p>One key detail is that `nix-channel --add` modifies the &#x27;system state&#x27;, whereas running flakes essentially does not.<p>-- Regarding &quot;you can pull in arbitrary Nix code by reference&quot;. With flakes, you have a standard entry point where you know the interface it has. Whereas, having a &#x27;default.nix&#x27; is a convention, and there&#x27;s no way to know how a `default.nix` is to be used without reading its source.</div><br/></div></div></div></div></div></div><div id="37107093" class="c"><input type="checkbox" id="c-37107093" checked=""/><div class="controls bullet"><span class="by">eternityforest</span><span>|</span><a href="#37106743">parent</a><span>|</span><a href="#37106852">prev</a><span>|</span><a href="#37107044">next</a><span>|</span><label class="collapse" for="c-37107093">[-]</label><label class="expand" for="c-37107093">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s kind of scary because Nix is one of the coolest concepts for how to manage Linux systems... Most everything else has so much baggage from things that were designed around hand-maintained, non-disposable installs.<p>But the community does seem to be still tinkering focused.<p>I miss the early 2000s when even the hackers seemed to want to make their stuff easy to use(although my source for that is I saw a screenshot of low orbit ion cannon one time, I don&#x27;t actually know much about hacker history).</div><br/><div id="37107458" class="c"><input type="checkbox" id="c-37107458" checked=""/><div class="controls bullet"><span class="by">esjeon</span><span>|</span><a href="#37106743">root</a><span>|</span><a href="#37107093">parent</a><span>|</span><a href="#37107044">next</a><span>|</span><label class="collapse" for="c-37107458">[-]</label><label class="expand" for="c-37107458">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But the community does seem to be still tinkering focused.<p>Because Nix does NOT make packaging easier. Maintainers are the ones who create distros, and they can live a happy life with something as crude as PKGBUILD, since build instructions are almost always stable.<p>Even for users, most of them just don&#x27;t need to juggle with package versions. Bleeding edge is mostly covered by Arch and package pinning works ridiculously well for daily uses.<p>So &quot;make their stuff easy to use&quot; doesn&#x27;t apply here. Rather, Nix is <i>harder</i> to use in reality.</div><br/><div id="37107565" class="c"><input type="checkbox" id="c-37107565" checked=""/><div class="controls bullet"><span class="by">eternityforest</span><span>|</span><a href="#37106743">root</a><span>|</span><a href="#37107458">parent</a><span>|</span><a href="#37107044">next</a><span>|</span><label class="collapse" for="c-37107565">[-]</label><label class="expand" for="c-37107565">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never heard of Arch and only fairly rarely heard of Manjaro as being suitable for anyone but tinkerers, at least not in the way Android is.<p>A few months ago Steam stopped working. Nobody seemed to know why. It&#x27;s back now, but git-cola is gone and I&#x27;m not even sure how I broke it.  Some nonsense about type errors in the hotkey module, which I don&#x27;t have time to debug right now so I&#x27;m just ignoring and using the flatpak.<p>Most everything I use on a daily basis has 100s of MBs of dependencies in several layers... Forgetting the virtualeng when pip installing something that happens to have a PyQT dependency and trashing my git cola is... not great and Linux is full of stuff like this.<p>The amount of effort needed to avoid or fix this kind trouble is more that I imagine Nix would need if it was fully polished.<p>On Nix I was able to package a Python app in a matter of hours, and</div><br/></div></div></div></div></div></div><div id="37107044" class="c"><input type="checkbox" id="c-37107044" checked=""/><div class="controls bullet"><span class="by">Cloudef</span><span>|</span><a href="#37106743">parent</a><span>|</span><a href="#37107093">prev</a><span>|</span><a href="#37107169">next</a><span>|</span><label class="collapse" for="c-37107044">[-]</label><label class="expand" for="c-37107044">[1 more]</label></div><br/><div class="children"><div class="content">You can do everything without flakes as well by using fetchTarball, fetchGit etc, with shasums, but flakes just improves the ergonomics. Because of the lock files, flakes are also faster, especially nice if you use nix develop (the new nix-shell alt)</div><br/></div></div></div></div><div id="37107169" class="c"><input type="checkbox" id="c-37107169" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#37106743">prev</a><span>|</span><a href="#37105657">next</a><span>|</span><label class="collapse" for="c-37107169">[-]</label><label class="expand" for="c-37107169">[3 more]</label></div><br/><div class="children"><div class="content">I still fail to understand the naming conventions behind Nix. I don&#x27;t know what a &quot;flake&quot; or &quot;derivation&quot; is without double checking, the naming sucks.</div><br/><div id="37107848" class="c"><input type="checkbox" id="c-37107848" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#37107169">parent</a><span>|</span><a href="#37105657">next</a><span>|</span><label class="collapse" for="c-37107848">[-]</label><label class="expand" for="c-37107848">[2 more]</label></div><br/><div class="children"><div class="content">&gt; without double checking<p>It&#x27;s fine, Nix things are conceptually different from anything before.<p>You could say flakes are like Rakefile, but that would be a lie. You could say they&#x27;re like Gemfile and Gemfile.lock, but that would be a lie too.<p>You could say that derivations are like packages, but that would be a lie, you could say they&#x27;re like container images but that would be a lie too.<p>Now, you can try to understand what these concepts are by mapping to known knowledge of other things in terms of use cases they solve, that&#x27;s fine, but at their core these concepts are different and quite unique, so it only makes sense for them to have different names.<p>Naming is hard, Nix folks had to pick one for each concept, and they chose not to lie by picking existing names that would not map and create bias in the understanding and expectations. It makes for a steeper learning curve, but I&#x27;d argue long term in the learning process it&#x27;s the right move.<p>Let me try to give some synthesised definitions (which may be incomplete and lies in the Feynman sense):<p>- a derivation is the reification (or realisation, as in, &quot;make it real&quot;) of a function call on the filesystem. IOW the concrete result is derived from the function call, memoized using content addressing.<p>- a flake is a central definition of a number of target derivations in the context of a specific source state of dependencies. If you look at an actual (snow)flake there&#x27;s this recursive&#x2F;fractal design coming from a central point, which kind of visually  represent the conceptual structure underpinning a nix flake.<p>So for me the names totally make sense! But I can understand that they don&#x27;t out of the blue (and they did not for me at first!)<p>It turns out (not really by accident) that these cover use cases that were implemented by this or that tool, and instinctively through a partial understanding of the nix concepts we&#x27;re in conflict: the other tools give us a (biased) understanding which both increases and is in conflict with our understanding of nix concepts. This is a normal process, but at some point by letting go of what we previously know and trying to understand new things for what they are and not what we project onto them, we open ourselves to fully grok, and both fully leverage the new concepts and realise their limitations.</div><br/><div id="37107947" class="c"><input type="checkbox" id="c-37107947" checked=""/><div class="controls bullet"><span class="by">mongol</span><span>|</span><a href="#37107169">root</a><span>|</span><a href="#37107848">parent</a><span>|</span><a href="#37105657">next</a><span>|</span><label class="collapse" for="c-37107947">[-]</label><label class="expand" for="c-37107947">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you look at an actual (snow)flake there&#x27;s this recursive&#x2F;fractal design coming from a central point, which kind of visually represent the conceptual structure underpinning a nix flake<p>Never thought about it that way, but it kind of makes sense. I thought the name was inspired by the Nix logo.</div><br/></div></div></div></div></div></div><div id="37105657" class="c"><input type="checkbox" id="c-37105657" checked=""/><div class="controls bullet"><span class="by">m1keil</span><span>|</span><a href="#37107169">prev</a><span>|</span><a href="#37106154">next</a><span>|</span><label class="collapse" for="c-37105657">[-]</label><label class="expand" for="c-37105657">[10 more]</label></div><br/><div class="children"><div class="content">&gt; With the goal of ending this current limbo and soothe longstanding tensions in the Nix community<p>Can someone with more background give a quick explanation about why is this a source of tension in the nix community in the first place? Is this a situation of too many cooks in the kitchen or something else?</div><br/><div id="37105834" class="c"><input type="checkbox" id="c-37105834" checked=""/><div class="controls bullet"><span class="by">RaitoBezarius</span><span>|</span><a href="#37105657">parent</a><span>|</span><a href="#37105683">next</a><span>|</span><label class="collapse" for="c-37105834">[-]</label><label class="expand" for="c-37105834">[4 more]</label></div><br/><div class="children"><div class="content">For example, Flakes have no concept of cross compilation and makes this use case extremely tedious to use.<p>Flakes were a RFC then merged as an experimental feature and shilled too much to the community to the point they are now a quasi standardized feature even though they didn&#x27;t go through RFC and therefore ignored all the valuable feedback.<p>This whole debacle made a lot of invested people tired on both sides.</div><br/><div id="37106536" class="c"><input type="checkbox" id="c-37106536" checked=""/><div class="controls bullet"><span class="by">40yearoldman</span><span>|</span><a href="#37105657">root</a><span>|</span><a href="#37105834">parent</a><span>|</span><a href="#37106295">next</a><span>|</span><label class="collapse" for="c-37106536">[-]</label><label class="expand" for="c-37106536">[2 more]</label></div><br/><div class="children"><div class="content">What? I compile my arm64 system on a amd64 system and send them to my cache server so my arm systems don’t have to do the work and just download the outputs and apply them.</div><br/><div id="37107023" class="c"><input type="checkbox" id="c-37107023" checked=""/><div class="controls bullet"><span class="by">seabass-labrax</span><span>|</span><a href="#37105657">root</a><span>|</span><a href="#37106536">parent</a><span>|</span><a href="#37106295">next</a><span>|</span><label class="collapse" for="c-37107023">[-]</label><label class="expand" for="c-37107023">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s something I would like to try for my PinePhone. It&#x27;s been tedious to do development for it, as the PinePhone&#x27;s CPU struggles with most compilation tasks. Using Nix would be a good way of building for that platform&#x27;s somewhat exotic features (arm64 and musl libc) on a more powerful machine, without confusing the system package manager with package versions outside the distribution - I should be able to copy the Nix derivations over and install them temporarily with nix-shell. Thanks for the inspiration!</div><br/></div></div></div></div><div id="37106295" class="c"><input type="checkbox" id="c-37106295" checked=""/><div class="controls bullet"><span class="by">predictabl3</span><span>|</span><a href="#37105657">root</a><span>|</span><a href="#37105834">parent</a><span>|</span><a href="#37106536">prev</a><span>|</span><a href="#37105683">next</a><span>|</span><label class="collapse" for="c-37106295">[-]</label><label class="expand" for="c-37106295">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Flakes have no concept of cross compilation and makes this use case extremely tedious to use.<p>I don&#x27;t agree at all. I use flakes with cross compilation literally all of the time. Having a concept of &quot;cross-compilation&quot; at the CLI level, instead of being part of the nix evaluation itself would be a travesty IMO. I love being able to do a single nix eval that includes 3 different architecture of native builds for my host toplevels, along with &quot;cross&quot; variants that set hostPlatform to x86 and produce cross-builds.</div><br/></div></div></div></div><div id="37105683" class="c"><input type="checkbox" id="c-37105683" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#37105657">parent</a><span>|</span><a href="#37105834">prev</a><span>|</span><a href="#37106154">next</a><span>|</span><label class="collapse" for="c-37105683">[-]</label><label class="expand" for="c-37105683">[5 more]</label></div><br/><div class="children"><div class="content">Because Flakes are simultaneously discouraged and labeled as unfinished, yet used by many.<p>Some aspects of Flakes are a bit contentious. For example, official adoption of Flakes will mean Nix will no longer be a mono-repository. Plus, Flakes are tightly coupled to Git.<p>However, Flakes bring welcome improvements to longstanding issues. Most notably, package pinning and explicit versioning, which are problematic when using channels.</div><br/><div id="37107713" class="c"><input type="checkbox" id="c-37107713" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#37105657">root</a><span>|</span><a href="#37105683">parent</a><span>|</span><a href="#37105793">next</a><span>|</span><label class="collapse" for="c-37107713">[-]</label><label class="expand" for="c-37107713">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For example, official adoption of Flakes will mean Nix will no longer be a mono-repo.<p>Do you mean nixpkgs? I don&#x27;t think stabilizing flakes means nixpkgs won&#x27;t remain a monorepo.</div><br/></div></div><div id="37105793" class="c"><input type="checkbox" id="c-37105793" checked=""/><div class="controls bullet"><span class="by">PuercoPop</span><span>|</span><a href="#37105657">root</a><span>|</span><a href="#37105683">parent</a><span>|</span><a href="#37107713">prev</a><span>|</span><a href="#37106154">next</a><span>|</span><label class="collapse" for="c-37105793">[-]</label><label class="expand" for="c-37105793">[3 more]</label></div><br/><div class="children"><div class="content">I use nix with flakes, have written a couple of flakes day to day use. I am not a nix power user. But based on my current understanding this statement seems incorrect<p>&gt; Flakes are tightly coupled to Git.<p>How is it tightly coupled to Git if it supports Mercurial out of the box?<p>Other than using version control to determine what are the sources of the derivation, what does flakes lean on version control?</div><br/><div id="37105839" class="c"><input type="checkbox" id="c-37105839" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#37105657">root</a><span>|</span><a href="#37105793">parent</a><span>|</span><a href="#37106154">next</a><span>|</span><label class="collapse" for="c-37105839">[-]</label><label class="expand" for="c-37105839">[2 more]</label></div><br/><div class="children"><div class="content">I meant this kind of issue: <a href="https:&#x2F;&#x2F;discourse.nixos.org&#x2F;t&#x2F;can-i-use-flakes-within-a-git-repo-without-committing-flake-nix&#x2F;18196" rel="nofollow noreferrer">https:&#x2F;&#x2F;discourse.nixos.org&#x2F;t&#x2F;can-i-use-flakes-within-a-git-...</a></div><br/><div id="37105922" class="c"><input type="checkbox" id="c-37105922" checked=""/><div class="controls bullet"><span class="by">PuercoPop</span><span>|</span><a href="#37105657">root</a><span>|</span><a href="#37105839">parent</a><span>|</span><a href="#37106154">next</a><span>|</span><label class="collapse" for="c-37105922">[-]</label><label class="expand" for="c-37105922">[1 more]</label></div><br/><div class="children"><div class="content">That is what I was trying to say by<p>&gt; Other than using version control to determine what are the sources of the derivation<p>I don&#x27;t think that defaulting to using git to list the sources when inside a git repo means that it is tightly coupled to git. If one doesn&#x27;t want to commit&#x2F;stage the flake files in the repo one can do `nix develop .` and it works . It will take a little longer because it will copy the entire directory to the store iiuc.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37106154" class="c"><input type="checkbox" id="c-37106154" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#37105657">prev</a><span>|</span><a href="#37107259">next</a><span>|</span><label class="collapse" for="c-37106154">[-]</label><label class="expand" for="c-37106154">[1 more]</label></div><br/><div class="children"><div class="content">It feels really good to see this RFC cross the finish line into a finalized plan.<p>The plan itself seems very well thought out. I had a vague desire for an incremental stabilization of flakes some time ago, but this is so much better.<p>The flakes divide is one of the biggest remaining problemd facing the community, now that the issues with the release cycle have improved so much and continue to improve. Each step taken in executing this plan will be a real boon for the Nix community.<p>Onward!</div><br/></div></div><div id="37107259" class="c"><input type="checkbox" id="c-37107259" checked=""/><div class="controls bullet"><span class="by">aktuel</span><span>|</span><a href="#37106154">prev</a><span>|</span><a href="#37105635">next</a><span>|</span><label class="collapse" for="c-37107259">[-]</label><label class="expand" for="c-37107259">[1 more]</label></div><br/><div class="children"><div class="content">One smaller UI improvement I would like to see is being able to retrieve the exact git commit of an installed flake. This seems not to be possible atm. Main argument for not having this is putting a reference to the git commit into the nix store folder would break hermetic evaluation. (You can habe multiple commits resulting in the same code.) It should however not be too hard to log that information separately somewhere else. It is somewhat disapointing for this link to be missing when flakes are already tied to git as they are.<p>The log entries could also include a flag if the flake was installed &quot;dirty&quot; (having uncomitted changes at the time).</div><br/></div></div><div id="37105635" class="c"><input type="checkbox" id="c-37105635" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#37107259">prev</a><span>|</span><a href="#37105733">next</a><span>|</span><label class="collapse" for="c-37105635">[-]</label><label class="expand" for="c-37105635">[1 more]</label></div><br/><div class="children"><div class="content">Sweet! That&#x27;ll give people some clarity. Flakes have been great.</div><br/></div></div><div id="37105733" class="c"><input type="checkbox" id="c-37105733" checked=""/><div class="controls bullet"><span class="by">jsomedon</span><span>|</span><a href="#37105635">prev</a><span>|</span><a href="#37105639">next</a><span>|</span><label class="collapse" for="c-37105733">[-]</label><label class="expand" for="c-37105733">[3 more]</label></div><br/><div class="children"><div class="content">I wanted to switch to nixos but current segregation between flakes and (traditional) nix features was a huge stop sign for me. Seems like this move is a good sign resolving this issue. Hope they bring things nice together -- features, doc, the community etc.</div><br/><div id="37107576" class="c"><input type="checkbox" id="c-37107576" checked=""/><div class="controls bullet"><span class="by">sullyj3</span><span>|</span><a href="#37105733">parent</a><span>|</span><a href="#37105746">next</a><span>|</span><label class="collapse" for="c-37107576">[-]</label><label class="expand" for="c-37107576">[1 more]</label></div><br/><div class="children"><div class="content">I empathise with this uncertainty. As I understand it, flakes aren&#x27;t incompatible with the previous way of doing things. Rather they represent an additional feature which can be used on top of them.<p>For example if you have a shell.nix that you were running with `nix-shell` which defaults to using channels to obtain nixpkgs<p><pre><code>    { pkgs ? import &lt;nixpkgs&gt; {} }:
      pkgs.mkShell {
      # ...
</code></pre>
You can reuse it in your flake.nix<p><pre><code>    devShells.${system}.default = import .&#x2F;shell.nix { inherit pkgs; };
</code></pre>
And it will use the locked nixpkgs input defined in your flake. You can run it with the new `nix develop` command, but `nix-shell` will continue to work, giving you the previous behaviour.</div><br/></div></div><div id="37105746" class="c"><input type="checkbox" id="c-37105746" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#37105733">parent</a><span>|</span><a href="#37107576">prev</a><span>|</span><a href="#37105639">next</a><span>|</span><label class="collapse" for="c-37105746">[-]</label><label class="expand" for="c-37105746">[1 more]</label></div><br/><div class="children"><div class="content">I just started using flakes like a year and a half ago for my configs (easy nixpkgs pinning in git was worth it). No issues so far - take the plunge!</div><br/></div></div></div></div><div id="37105639" class="c"><input type="checkbox" id="c-37105639" checked=""/><div class="controls bullet"><span class="by">setheron</span><span>|</span><a href="#37105733">prev</a><span>|</span><a href="#37105860">next</a><span>|</span><label class="collapse" for="c-37105639">[-]</label><label class="expand" for="c-37105639">[11 more]</label></div><br/><div class="children"><div class="content">I&#x27;m still in the &#x27;meh&#x27; camp for flakes. 
I use niv and it gives me enough usability.<p>I find the need to include additional libraries to make flakes usable for some reason a weird hurdle I don&#x27;t personally enjoy (i.e. flake-parts or systems)</div><br/><div id="37105666" class="c"><input type="checkbox" id="c-37105666" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#37105639">parent</a><span>|</span><a href="#37105811">next</a><span>|</span><label class="collapse" for="c-37105666">[-]</label><label class="expand" for="c-37105666">[1 more]</label></div><br/><div class="children"><div class="content">The thing I actually love about Flakes is the fact that my immutable system configuration now also contains the versions of dependencies, instead of them being in some out-of-band special area. This is super nice for rollbacks and just general visibility.<p>It&#x27;s even more of a plus that it is aware of Git and makes rather surprisingly intelligent decisions when automatically upgrading the system on a schedule (as one example, it seems to be able to deal with when the Git repository has staged or unstaged changes just fine, producing commits with just the lockfile changes.)</div><br/></div></div><div id="37105811" class="c"><input type="checkbox" id="c-37105811" checked=""/><div class="controls bullet"><span class="by">biggestlou</span><span>|</span><a href="#37105639">parent</a><span>|</span><a href="#37105666">prev</a><span>|</span><a href="#37105845">next</a><span>|</span><label class="collapse" for="c-37105811">[-]</label><label class="expand" for="c-37105811">[3 more]</label></div><br/><div class="children"><div class="content">Niv is fine and good but there&#x27;s a lot that it will never provide, like the ability to `nix run` packages or `nix flake show` what your project provides with only a URL in hand.</div><br/><div id="37106636" class="c"><input type="checkbox" id="c-37106636" checked=""/><div class="controls bullet"><span class="by">setheron</span><span>|</span><a href="#37105639">root</a><span>|</span><a href="#37105811">parent</a><span>|</span><a href="#37105845">next</a><span>|</span><label class="collapse" for="c-37106636">[-]</label><label class="expand" for="c-37106636">[2 more]</label></div><br/><div class="children"><div class="content">You can still `nix run` packages using niv -- no clue what you talking about.<p>You can also just look at the niv sources.json file pretty easily if you knew the URL.  Rather trivial command to run.<p>I don&#x27;t find the above compelling (or correct?)</div><br/><div id="37106868" class="c"><input type="checkbox" id="c-37106868" checked=""/><div class="controls bullet"><span class="by">biggestlou</span><span>|</span><a href="#37105639">root</a><span>|</span><a href="#37106636">parent</a><span>|</span><a href="#37105845">next</a><span>|</span><label class="collapse" for="c-37106868">[-]</label><label class="expand" for="c-37106868">[1 more]</label></div><br/><div class="children"><div class="content">nix run github:DeterminateSystems&#x2F;flake-checker<p>What&#x27;s the Niv equivalent of this?</div><br/></div></div></div></div></div></div><div id="37105845" class="c"><input type="checkbox" id="c-37105845" checked=""/><div class="controls bullet"><span class="by">RaitoBezarius</span><span>|</span><a href="#37105639">parent</a><span>|</span><a href="#37105811">prev</a><span>|</span><a href="#37105749">next</a><span>|</span><label class="collapse" for="c-37105845">[-]</label><label class="expand" for="c-37105845">[1 more]</label></div><br/><div class="children"><div class="content">I moved to npins which has slightly more features that niv.<p>But niv has been great, I wish we can have patching natively so all my tons of patches can be bolted on faster.</div><br/></div></div><div id="37105749" class="c"><input type="checkbox" id="c-37105749" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#37105639">parent</a><span>|</span><a href="#37105845">prev</a><span>|</span><a href="#37105813">next</a><span>|</span><label class="collapse" for="c-37105749">[-]</label><label class="expand" for="c-37105749">[1 more]</label></div><br/><div class="children"><div class="content">Luckily, you can still use niv! I still am for certain projects. It works so well for what it does. Flakes give a little more ofc.</div><br/></div></div><div id="37105813" class="c"><input type="checkbox" id="c-37105813" checked=""/><div class="controls bullet"><span class="by">solomonb</span><span>|</span><a href="#37105639">parent</a><span>|</span><a href="#37105749">prev</a><span>|</span><a href="#37106323">next</a><span>|</span><label class="collapse" for="c-37105813">[-]</label><label class="expand" for="c-37105813">[2 more]</label></div><br/><div class="children"><div class="content">You absolutely do not need flake-parts.</div><br/><div id="37107571" class="c"><input type="checkbox" id="c-37107571" checked=""/><div class="controls bullet"><span class="by">mongol</span><span>|</span><a href="#37105639">root</a><span>|</span><a href="#37105813">parent</a><span>|</span><a href="#37106323">next</a><span>|</span><label class="collapse" for="c-37107571">[-]</label><label class="expand" for="c-37107571">[1 more]</label></div><br/><div class="children"><div class="content">What is it even? I see it referenced now and then and don&#x27;t understand in what situations it would be useful.</div><br/></div></div></div></div><div id="37106323" class="c"><input type="checkbox" id="c-37106323" checked=""/><div class="controls bullet"><span class="by">predictabl3</span><span>|</span><a href="#37105639">parent</a><span>|</span><a href="#37105813">prev</a><span>|</span><a href="#37105860">next</a><span>|</span><label class="collapse" for="c-37106323">[-]</label><label class="expand" for="c-37106323">[2 more]</label></div><br/><div class="children"><div class="content">Except that niv doesn&#x27;t ensure pure evaluation, and thus a number of non-flakes, niv-friendly projects are unusable with flakes, and are often difficult to work with otherwise due to their impurities.<p>It also can&#x27;t do transient overrides which is quite literally the essential reason that Flakes is killer to me.<p>For example, I can cross-compile to riscv64-linux, including a bunch of 3rd party flakes repos *specifically* because I refer to them and then override their nixpkgs to point to my nixpkgs with various cross-compilation fixes.<p>Definitely not possible to do this with niv.<p>It also does nothing to solve the countless issues with channels that I&#x27;ve watched afflict countless new Nix users, every week, for 3+ years. [insert the usual 8-stop troubleshoot list when a user has any issue possibly related to channels]</div><br/><div id="37106632" class="c"><input type="checkbox" id="c-37106632" checked=""/><div class="controls bullet"><span class="by">setheron</span><span>|</span><a href="#37105639">root</a><span>|</span><a href="#37106323">parent</a><span>|</span><a href="#37105860">next</a><span>|</span><label class="collapse" for="c-37106632">[-]</label><label class="expand" for="c-37106632">[1 more]</label></div><br/><div class="children"><div class="content">I tend to just override nixpkgs downstream. 
I think the situation you are describing is more power-user.<p>Flakes to me introduced a lot of overhead beyond what niv can provide.<p>I get 99% value just pinning my top level dependencies since most of the time I&#x27;m referring nixpkgs + 1-2 other packages.</div><br/></div></div></div></div></div></div><div id="37105860" class="c"><input type="checkbox" id="c-37105860" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#37105639">prev</a><span>|</span><a href="#37105934">next</a><span>|</span><label class="collapse" for="c-37105860">[-]</label><label class="expand" for="c-37105860">[1 more]</label></div><br/><div class="children"><div class="content">Fantastic! Happy flake user here who will be pleased to have the documentation updated and referring to the workflows we use.</div><br/></div></div><div id="37105934" class="c"><input type="checkbox" id="c-37105934" checked=""/><div class="controls bullet"><span class="by">EE84M3i</span><span>|</span><a href="#37105860">prev</a><span>|</span><a href="#37105887">next</a><span>|</span><label class="collapse" for="c-37105934">[-]</label><label class="expand" for="c-37105934">[2 more]</label></div><br/><div class="children"><div class="content">Can someone that understands this &quot;limbo&quot; and &quot;long standing tensions&quot; give a TL;DR for someone that knows what flakes and the new cli are but hasn&#x27;t been following the community discussions around it?</div><br/><div id="37106033" class="c"><input type="checkbox" id="c-37106033" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#37105934">parent</a><span>|</span><a href="#37105887">next</a><span>|</span><label class="collapse" for="c-37106033">[-]</label><label class="expand" for="c-37106033">[1 more]</label></div><br/><div class="children"><div class="content">Flakes are amazing but have been designated as an unstable or beta feature for I think literally years now, which creates tension between the desire to get them polished and perfect and the desire to have them be the one true official way to do things already.</div><br/></div></div></div></div><div id="37105887" class="c"><input type="checkbox" id="c-37105887" checked=""/><div class="controls bullet"><span class="by">1attice</span><span>|</span><a href="#37105934">prev</a><span>|</span><a href="#37107086">next</a><span>|</span><label class="collapse" for="c-37105887">[-]</label><label class="expand" for="c-37105887">[2 more]</label></div><br/><div class="children"><div class="content">NixOS is honestly so beautiful and rare. I&#x27;m delighted that the project is moving forward in this way.<p>A friend of mine called it a &quot;rabbit hole&quot; but TBH it&#x27;s words of power -- I can speak new instances of my environment into existence, not only on newly-acquired compute devices, but on other OSes as well (I put some effort into segmenting the user environment and system config between home-manager and standard &#x2F;etc&#x2F;nixos&#x2F;*)<p>Nix flakes will only make me more powerful</div><br/><div id="37107315" class="c"><input type="checkbox" id="c-37107315" checked=""/><div class="controls bullet"><span class="by">fortunateregard</span><span>|</span><a href="#37105887">parent</a><span>|</span><a href="#37107086">next</a><span>|</span><label class="collapse" for="c-37107315">[-]</label><label class="expand" for="c-37107315">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I can speak new instances of my environment into existence<p>You&#x27;re not kidding. I used nixos-anywhere [1] for the first time the other day. You can point it to any linux host and it will partition, format, and supplant the target&#x27;s existing OS with your nixOS config, all with a single command. Incredible.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;numtide&#x2F;nixos-anywhere">https:&#x2F;&#x2F;github.com&#x2F;numtide&#x2F;nixos-anywhere</a></div><br/></div></div></div></div><div id="37107086" class="c"><input type="checkbox" id="c-37107086" checked=""/><div class="controls bullet"><span class="by">toastal</span><span>|</span><a href="#37105887">prev</a><span>|</span><label class="collapse" for="c-37107086">[-]</label><label class="expand" for="c-37107086">[1 more]</label></div><br/><div class="children"><div class="content">I hope the standardize on aliasing -ise and -ize endings in the CLI instead of throwing errors to folks just wanting to optmise or optimize because it shouldn’t matter.</div><br/></div></div></div></div></div></div></div></body></html>