<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1690880459345" as="style"/><link rel="stylesheet" href="styles.css?v=1690880459345"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://matklad.github.io/2023/04/09/can-you-trust-a-compiler-to-optimize-your-code.html">Can you trust a compiler to optimize your code?</a> <span class="domain">(<a href="https://matklad.github.io">matklad.github.io</a>)</span></div><div class="subtext"><span>LinuxBender</span> | <span>9 comments</span></div><br/><div><div id="36953561" class="c"><input type="checkbox" id="c-36953561" checked=""/><div class="controls bullet"><span class="by">Pannoniae</span><span>|</span><a href="#36953451">next</a><span>|</span><label class="collapse" for="c-36953561">[-]</label><label class="expand" for="c-36953561">[5 more]</label></div><br/><div class="children"><div class="content">Many absolutely fall into the trap of &quot;don&#x27;t optimise because premature optimisation etc., compiler is smarter than you, and library authors are definitely smarter than you&quot;. The result of that approach is that in 2023, our desktop is worse in usability and performance than what is was in 1998.<p>With SIMD, you always have to check what the compiler generates, you can&#x27;t just write something and expect it to be vectorised. Similar to other optimisations such as de-virtualisation - it might happen or it might not. If it doesn&#x27;t, you have to do it yourself by hand, or somehow convince the compiler to do it.</div><br/><div id="36953877" class="c"><input type="checkbox" id="c-36953877" checked=""/><div class="controls bullet"><span class="by">mlazos</span><span>|</span><a href="#36953561">parent</a><span>|</span><a href="#36953650">next</a><span>|</span><label class="collapse" for="c-36953877">[-]</label><label class="expand" for="c-36953877">[1 more]</label></div><br/><div class="children"><div class="content">Nah that’s not lack of premature optimization, that’s just electron apps and everyone learning JavaScript.</div><br/></div></div><div id="36953650" class="c"><input type="checkbox" id="c-36953650" checked=""/><div class="controls bullet"><span class="by">galkk</span><span>|</span><a href="#36953561">parent</a><span>|</span><a href="#36953877">prev</a><span>|</span><a href="#36953614">next</a><span>|</span><label class="collapse" for="c-36953650">[-]</label><label class="expand" for="c-36953650">[1 more]</label></div><br/><div class="children"><div class="content">You don’t even get information&#x2F; diagnostics about copy elision &#x2F; return value optimization in c++, if that happened or not in particular place in the code.<p>Only by looking into assembler :(</div><br/></div></div><div id="36953614" class="c"><input type="checkbox" id="c-36953614" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#36953561">parent</a><span>|</span><a href="#36953650">prev</a><span>|</span><a href="#36953451">next</a><span>|</span><label class="collapse" for="c-36953614">[-]</label><label class="expand" for="c-36953614">[2 more]</label></div><br/><div class="children"><div class="content">Machines aren’t slow because people don’t use SIMD.</div><br/><div id="36953747" class="c"><input type="checkbox" id="c-36953747" checked=""/><div class="controls bullet"><span class="by">Pannoniae</span><span>|</span><a href="#36953561">root</a><span>|</span><a href="#36953614">parent</a><span>|</span><a href="#36953451">next</a><span>|</span><label class="collapse" for="c-36953747">[-]</label><label class="expand" for="c-36953747">[1 more]</label></div><br/><div class="children"><div class="content">Of course, that was a jab at the lack of optimisation in general, not SIMD specifically.</div><br/></div></div></div></div></div></div><div id="36953451" class="c"><input type="checkbox" id="c-36953451" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#36953561">prev</a><span>|</span><a href="#36953485">next</a><span>|</span><label class="collapse" for="c-36953451">[-]</label><label class="expand" for="c-36953451">[1 more]</label></div><br/><div class="children"><div class="content">This is good advice.<p>Still, a lot of problems seem to remain firmly in the &quot;write it with intrinsics&quot; region even if you do your best to help the compiler out. For any operation that involves filtering a list, the compiler will not generate the lookup table of shuffles that is used in the fastest solutions (maybe the story is different on AVX-512 where there are dedicated filtering instructions or on NEON where movemask costs more because there isn&#x27;t such an instruction). For parsing and formatting strings, the compiler usually will not take branchy code and decide to compute both branches and vectorize it even if it is guaranteed chunks of the appropriate size. Some concrete examples of the how simple these problems can be while remaining out of reach are &quot;Given a mutable list of u32, remove all multiples of 3&quot; and &quot;Given a list of newline-separated UUIDs and an equally large list of mutable u128, parse the hexadecimal bytes of each UUID into the corresponding u128&quot;.</div><br/></div></div><div id="36953485" class="c"><input type="checkbox" id="c-36953485" checked=""/><div class="controls bullet"><span class="by">sakras</span><span>|</span><a href="#36953451">prev</a><span>|</span><a href="#36953703">next</a><span>|</span><label class="collapse" for="c-36953485">[-]</label><label class="expand" for="c-36953485">[1 more]</label></div><br/><div class="children"><div class="content">This is overall very solid. However you have to be careful to not go overboard with this line reasoning. I&#x27;ve seen people try to explain away inefficient code by inventing a chain of optimizations that the compiler <i>could</i> conceivably do. If this chain is too long, it probably won&#x27;t happen! The most common pitfall I&#x27;ve seen is relying on inlining too much (specifically a C++ template monster). As far as I can tell, compilers have a fixed number of inline passes, and don&#x27;t keep inlining until they hit a fixed point.</div><br/></div></div><div id="36953703" class="c"><input type="checkbox" id="c-36953703" checked=""/><div class="controls bullet"><span class="by">declanhaigh</span><span>|</span><a href="#36953485">prev</a><span>|</span><label class="collapse" for="c-36953703">[-]</label><label class="expand" for="c-36953703">[1 more]</label></div><br/><div class="children"><div class="content">Ken Thompson once made a similar point about compilers and trust but in terms of security:<p><a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~rdriley&#x2F;487&#x2F;papers&#x2F;Thompson_1984_ReflectionsonTrustingTrust.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~rdriley&#x2F;487&#x2F;papers&#x2F;Thompson_1984_Ref...</a></div><br/></div></div></div></div></div></div></div></body></html>