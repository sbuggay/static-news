<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731056467293" as="style"/><link rel="stylesheet" href="styles.css?v=1731056467293"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://opensource.microsoft.com/blog/2024/11/07/introducing-hyperlight-virtual-machine-based-security-for-functions-at-scale/">Hyperlight: Virtual machine-based security for functions at scale</a> <span class="domain">(<a href="https://opensource.microsoft.com">opensource.microsoft.com</a>)</span></div><div class="subtext"><span>yoshuaw</span> | <span>19 comments</span></div><br/><div><div id="42078477" class="c"><input type="checkbox" id="c-42078477" checked=""/><div class="controls bullet"><span class="by">yoshuaw</span><span>|</span><a href="#42079711">next</a><span>|</span><label class="collapse" for="c-42078477">[-]</label><label class="expand" for="c-42078477">[3 more]</label></div><br/><div class="children"><div class="content">The Azure Upstream team has been working on a really fast hypervisor library written in Rust for the past three years. It does less than you&#x27;d conventionally do with hypervisors, but in turn it can start VMs around 2 orders of magnitude faster (around 1-2ms&#x2F;VM).<p>I think this is really cool, and the library was just released on GitHub for anyone to try. I’m happy I got to help them write their announcement post — and I figured this might be interesting for folks here!</div><br/><div id="42081744" class="c"><input type="checkbox" id="c-42081744" checked=""/><div class="controls bullet"><span class="by">dangoodmanUT</span><span>|</span><a href="#42078477">parent</a><span>|</span><a href="#42079711">next</a><span>|</span><label class="collapse" for="c-42081744">[-]</label><label class="expand" for="c-42081744">[2 more]</label></div><br/><div class="children"><div class="content">Do you think requiring to use their packages is too limiting for widespread usage? Seems like you&#x27;re forced to use Rust or C atm.<p>This seems like a limitation that sits in a somewhat unusable place: For something simple and platform-specific (e.g. a HTTP transform) we can just use JS where the boot time perf makes up for the execution perf, and for something more serious like a full-fledged API 120ms should be more than enough time (and we can preemtively scale as long as we&#x27;re not already at 0)</div><br/><div id="42082523" class="c"><input type="checkbox" id="c-42082523" checked=""/><div class="controls bullet"><span class="by">yoshuaw</span><span>|</span><a href="#42078477">root</a><span>|</span><a href="#42081744">parent</a><span>|</span><a href="#42079711">next</a><span>|</span><label class="collapse" for="c-42082523">[-]</label><label class="expand" for="c-42082523">[1 more]</label></div><br/><div class="children"><div class="content">The way to think about Hyperlight is as a security substrate intended to host application runtimes. You’re right that the Hyperlight API only supports C and Rust today — but you can use that to for example load Python or JS runtimes which can then execute those languages natively.<p>But we might be able to do even better than that by leveraging Wasm Components [1] and WASI 0.2 [2]. Using a VM guest based on Wasmtime, suddenly it becomes possible to run functions written in any language that can compile to Wasm Components — all using standard tooling and interfaces.<p>I believe the team has a prototype VM guest based on Wasmtime working, but they still needed a little more time before it’s ready to be published. Stay tuned for future announcements?<p>[1]: <a href="https:&#x2F;&#x2F;component-model.bytecodealliance.org&#x2F;introduction.html" rel="nofollow">https:&#x2F;&#x2F;component-model.bytecodealliance.org&#x2F;introduction.ht...</a><p>[2]: <a href="https:&#x2F;&#x2F;wasi.dev" rel="nofollow">https:&#x2F;&#x2F;wasi.dev</a></div><br/></div></div></div></div></div></div><div id="42079711" class="c"><input type="checkbox" id="c-42079711" checked=""/><div class="controls bullet"><span class="by">generalizations</span><span>|</span><a href="#42078477">prev</a><span>|</span><a href="#42080010">next</a><span>|</span><label class="collapse" for="c-42079711">[-]</label><label class="expand" for="c-42079711">[6 more]</label></div><br/><div class="children"><div class="content">&gt; These micro VMs operate without a kernel or operating system, keeping overhead low. Instead, guests are built specifically for Hyperlight using the Hyperlight Guest library, which provides a controlled set of APIs that facilitate interaction between host and guest<p>Sounds like this is closer to a chroot&#x2F;unikernel than a &quot;micro VM&quot; - a slightly more firewalled chroot without most of the os libs, or a unikernel without the kernel. Pretty sure it&#x27;s not a &quot;virtual machine&quot; though.<p>Only pointing this out because these sorts of containers&#x2F;unikernels&#x2F;vms exist on a spectrum, and each type carries its own strengths and limitations; calling this by the wrong name associates it with the wrong set of tradeoffs.</div><br/><div id="42079997" class="c"><input type="checkbox" id="c-42079997" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#42079711">parent</a><span>|</span><a href="#42080069">next</a><span>|</span><label class="collapse" for="c-42079997">[-]</label><label class="expand" for="c-42079997">[2 more]</label></div><br/><div class="children"><div class="content">I guess if it uses CR3 it&#x27;s a &quot;process&quot; and if it uses VMLAUNCH it&#x27;s a &quot;VM&quot;.</div><br/><div id="42080179" class="c"><input type="checkbox" id="c-42080179" checked=""/><div class="controls bullet"><span class="by">generalizations</span><span>|</span><a href="#42079711">root</a><span>|</span><a href="#42079997">parent</a><span>|</span><a href="#42080069">next</a><span>|</span><label class="collapse" for="c-42080179">[-]</label><label class="expand" for="c-42080179">[1 more]</label></div><br/><div class="children"><div class="content">Heh. Going by that delineation we end up with very VM-ish containers and (now) very container-ish VMs. Though this seems like it&#x27;s even more stripped down than a unikernel - which would also be a &quot;VM&quot; here.</div><br/></div></div></div></div><div id="42080069" class="c"><input type="checkbox" id="c-42080069" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#42079711">parent</a><span>|</span><a href="#42079997">prev</a><span>|</span><a href="#42080010">next</a><span>|</span><label class="collapse" for="c-42080069">[-]</label><label class="expand" for="c-42080069">[3 more]</label></div><br/><div class="children"><div class="content">I thought a chroot was not considered a real security boundary?</div><br/><div id="42082015" class="c"><input type="checkbox" id="c-42082015" checked=""/><div class="controls bullet"><span class="by">ronsor</span><span>|</span><a href="#42079711">root</a><span>|</span><a href="#42080069">parent</a><span>|</span><a href="#42080010">next</a><span>|</span><label class="collapse" for="c-42082015">[-]</label><label class="expand" for="c-42082015">[2 more]</label></div><br/><div class="children"><div class="content">Chroot is a real security boundary as long as you use it properly. That said, namespaces on Linux are much superior at this point, so I can only recommend using `chroot` for POSIX compliance.</div><br/><div id="42083337" class="c"><input type="checkbox" id="c-42083337" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#42079711">root</a><span>|</span><a href="#42082015">parent</a><span>|</span><a href="#42080010">next</a><span>|</span><label class="collapse" for="c-42083337">[-]</label><label class="expand" for="c-42083337">[1 more]</label></div><br/><div class="children"><div class="content">chroot is great for all sorts of things, but they&#x27;re not security-related.<p>A lot of tools expect to do things to &quot;your system&quot; at absolute paths — chroot lets those tools operate against an explicitly wired-up semi-virtualized simulacra of your system, designed to pass through just the parts of those operations you want to your real host, while routing the rest of the effects into a &quot;rootfs in a can&quot;, that you&#x27;re either building up, or will immediately throw away.<p>Think: debootstrap; or pivot-root; or mounting your rootfs to fix your GRUB config and re-run update-grub from your initramfs rescue shell.</div><br/></div></div></div></div></div></div></div></div><div id="42080010" class="c"><input type="checkbox" id="c-42080010" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#42079711">prev</a><span>|</span><a href="#42082869">next</a><span>|</span><label class="collapse" for="c-42080010">[-]</label><label class="expand" for="c-42080010">[5 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t see any mention of firecracker, which is the first thing I think of in this space. Anyone have a TL;DR comparison?</div><br/><div id="42081612" class="c"><input type="checkbox" id="c-42081612" checked=""/><div class="controls bullet"><span class="by">eyberg</span><span>|</span><a href="#42080010">parent</a><span>|</span><a href="#42082869">next</a><span>|</span><label class="collapse" for="c-42081612">[-]</label><label class="expand" for="c-42081612">[4 more]</label></div><br/><div class="children"><div class="content">Firecracker can run ordinary linux&#x2F;GPOS vms and unikernels.<p>Unikernels can run inside of firecracker.<p>Unikernels are focused on single applications whereas general purpose operating systems are focused on multiple applications.<p>This is focused on running <i>functions</i> embedded inside a host program. So it is fairly different than other things out there and in a class of its own.</div><br/><div id="42081827" class="c"><input type="checkbox" id="c-42081827" checked=""/><div class="controls bullet"><span class="by">ATechGuy</span><span>|</span><a href="#42080010">root</a><span>|</span><a href="#42081612">parent</a><span>|</span><a href="#42082869">next</a><span>|</span><label class="collapse" for="c-42081827">[-]</label><label class="expand" for="c-42081827">[3 more]</label></div><br/><div class="children"><div class="content">&gt; each function request to have its own hypervisor for protection.<p>They are talking about isolating serverless functions, not host program functions. In that sense, it is exactly what Firecracker does for lambda functions</div><br/><div id="42082072" class="c"><input type="checkbox" id="c-42082072" checked=""/><div class="controls bullet"><span class="by">eyberg</span><span>|</span><a href="#42080010">root</a><span>|</span><a href="#42081827">parent</a><span>|</span><a href="#42082869">next</a><span>|</span><label class="collapse" for="c-42082072">[-]</label><label class="expand" for="c-42082072">[2 more]</label></div><br/><div class="children"><div class="content">Firecracker boots up a runtime that has a full blown operating system in it - lambda just happens to call a known program with a known function. In that sense sure it provides similar functionality but it&#x27;s really quite different. That&#x27;s not what fly uses firecracker for, for instance.<p>Qemu&#x2F;firecracker are in the same space - this is different.<p>These are most definitely in a different boat as you embed the guest functions inside the host program and then you register those functions. Taken from the readme:<p>&gt; The host can call functions implemented and exposed by the guest (known as guest functions).<p>&gt; Once running, the guest can call functions implemented and exposed by the host (known as host functions).<p>This is more in the &#x27;safe plugin&#x27; type of space. As with most things in this space - the best way to learn about them is to simply try it out.</div><br/><div id="42084343" class="c"><input type="checkbox" id="c-42084343" checked=""/><div class="controls bullet"><span class="by">stogot</span><span>|</span><a href="#42080010">root</a><span>|</span><a href="#42082072">parent</a><span>|</span><a href="#42082869">next</a><span>|</span><label class="collapse" for="c-42084343">[-]</label><label class="expand" for="c-42084343">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The host can call functions implemented and exposed by the guest (known as guest functions).<p>Can you explain this a bit more? Why&#x2F;when would a developer want to do this?  What’s the advantage over firecracker?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42082869" class="c"><input type="checkbox" id="c-42082869" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#42080010">prev</a><span>|</span><a href="#42082956">next</a><span>|</span><label class="collapse" for="c-42082869">[-]</label><label class="expand" for="c-42082869">[1 more]</label></div><br/><div class="children"><div class="content">They mention that most guests are expected to run code in a VM&#x2F;interpreter... I wonder if they have a build of V8 or JSC for their environment?</div><br/></div></div><div id="42082956" class="c"><input type="checkbox" id="c-42082956" checked=""/><div class="controls bullet"><span class="by">oneplane</span><span>|</span><a href="#42082869">prev</a><span>|</span><a href="#42084068">next</a><span>|</span><label class="collapse" for="c-42082956">[-]</label><label class="expand" for="c-42082956">[1 more]</label></div><br/><div class="children"><div class="content">So in essence, this is somewhere between a unikernel+firecracker combo and a WASM module, but using VT.</div><br/></div></div><div id="42084068" class="c"><input type="checkbox" id="c-42084068" checked=""/><div class="controls bullet"><span class="by">7e</span><span>|</span><a href="#42082956">prev</a><span>|</span><a href="#42082478">next</a><span>|</span><label class="collapse" for="c-42084068">[-]</label><label class="expand" for="c-42084068">[1 more]</label></div><br/><div class="children"><div class="content">Use CHERI for this?</div><br/></div></div><div id="42082478" class="c"><input type="checkbox" id="c-42082478" checked=""/><div class="controls bullet"><span class="by">m3kw9</span><span>|</span><a href="#42084068">prev</a><span>|</span><label class="collapse" for="c-42082478">[-]</label><label class="expand" for="c-42082478">[1 more]</label></div><br/><div class="children"><div class="content">What a loaded term, where do IT people come up with this stuff?</div><br/></div></div></div></div></div></div></div></body></html>