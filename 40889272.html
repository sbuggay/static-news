<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720602064561" as="style"/><link rel="stylesheet" href="styles.css?v=1720602064561"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://medium.com/@abdulgh/compile-time-json-deserialization-in-c-1e3d41a73628">Compile-time JSON deserialization in C++</a>Â <span class="domain">(<a href="https://medium.com">medium.com</a>)</span></div><div class="subtext"><span>dctwin</span> | <span>24 comments</span></div><br/><div><div id="40923069" class="c"><input type="checkbox" id="c-40923069" checked=""/><div class="controls bullet"><span class="by">stephc_int13</span><span>|</span><a href="#40922640">next</a><span>|</span><label class="collapse" for="c-40923069">[-]</label><label class="expand" for="c-40923069">[9 more]</label></div><br/><div class="children"><div class="content">I am afraid of the compile-time cost.<p>For this kind of things I tend to prefer using a simpler program (written in anything you like) to generate C or C++ instead of having the compile do the same thing much slowly.<p>Meta programming can be good, but it is even better done with an actual meta program, IMO.</div><br/><div id="40924279" class="c"><input type="checkbox" id="c-40924279" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40923069">parent</a><span>|</span><a href="#40923258">next</a><span>|</span><label class="collapse" for="c-40924279">[-]</label><label class="expand" for="c-40924279">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>generate C or C++ instead of having the compile do the same thing much slowly</i><p>That&#x27;s a wild-assed guess. A JSON decoder right in the compiler could easily be faster than generation involving extra tool invocations and multiple passes.<p>Also, if you use ten code generators for ten different features in a pipeline instead of ten compile-time things built into the language, will <i>that</i> still be faster? What if most files use just use one one or two features? You have to pass them through all the generators just in case; each generator decides whether the file contains anything that it knows how to expand.</div><br/><div id="40924498" class="c"><input type="checkbox" id="c-40924498" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#40923069">root</a><span>|</span><a href="#40924279">parent</a><span>|</span><a href="#40923258">next</a><span>|</span><label class="collapse" for="c-40924498">[-]</label><label class="expand" for="c-40924498">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not taking sides but I don&#x27;t think a code-gen tool necessitates re-scanning the entire codebase every compile.  gRPC would be a good example.</div><br/><div id="40924815" class="c"><input type="checkbox" id="c-40924815" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40923069">root</a><span>|</span><a href="#40924498">parent</a><span>|</span><a href="#40923258">next</a><span>|</span><label class="collapse" for="c-40924815">[-]</label><label class="expand" for="c-40924815">[1 more]</label></div><br/><div class="children"><div class="content">Well not every compile. Obviously, incremental compiles (thanks to a tool like make) notice that the generated code is still newer than the inputs.<p>Obviously, you have files that are not generated. They don&#x27;t need any gen tool.<p>That&#x27;s a disadvantage. If you want to start using JSON at compile time in a file, and the technology for that is a code generator, you have to move that file to a different category, perhaps by changing its suffix, and possibly indicate it somewhere in the build system as one of the sources needing the json generator. Whereas if it&#x27;s in the language, you just do it in your .cpp file and that&#x27;s it.<p>Token based macro preprocessors and code generators are simply not defensible in the face of structural macro systems and compile-time evaluation. They are just something you use when you don&#x27;t have the latter. You can use code generators and preprocessors with languages that don&#x27;t have anything built in, and which are resistant to change (will not support any decent metaprogramming in the foreseeable future).</div><br/></div></div></div></div></div></div><div id="40923258" class="c"><input type="checkbox" id="c-40923258" checked=""/><div class="controls bullet"><span class="by">adolph</span><span>|</span><a href="#40923069">parent</a><span>|</span><a href="#40924279">prev</a><span>|</span><a href="#40922640">next</a><span>|</span><label class="collapse" for="c-40923258">[-]</label><label class="expand" for="c-40923258">[5 more]</label></div><br/><div class="children"><div class="content">Brings to mind the old story about a JSON DSL<p><a href="https:&#x2F;&#x2F;thedailywtf.com&#x2F;articles&#x2F;the-inner-json-effect" rel="nofollow">https:&#x2F;&#x2F;thedailywtf.com&#x2F;articles&#x2F;the-inner-json-effect</a></div><br/><div id="40923931" class="c"><input type="checkbox" id="c-40923931" checked=""/><div class="controls bullet"><span class="by">threatripper</span><span>|</span><a href="#40923069">root</a><span>|</span><a href="#40923258">parent</a><span>|</span><a href="#40922640">next</a><span>|</span><label class="collapse" for="c-40923931">[-]</label><label class="expand" for="c-40923931">[4 more]</label></div><br/><div class="children"><div class="content">Is this real? It can&#x27;t be real. Nobody can be this stupid. But then again it takes a special kind of person who doesn&#x27;t understand satire to actually do something like that. Somebody, where they would say &quot;we trained him wrong on purpose as a kind of a joke&quot;.</div><br/><div id="40924971" class="c"><input type="checkbox" id="c-40924971" checked=""/><div class="controls bullet"><span class="by">1f60c</span><span>|</span><a href="#40923069">root</a><span>|</span><a href="#40923931">parent</a><span>|</span><a href="#40924241">next</a><span>|</span><label class="collapse" for="c-40924971">[-]</label><label class="expand" for="c-40924971">[1 more]</label></div><br/><div class="children"><div class="content">It has to be satire because of Tom&#x27;s complete overreaction and the fact that comments are actually one of the easiest things to handle when building a lexer (usually, you can just discard them). Eval&#x27;ing them makes no sense.<p>That said, I suppose stranger things have happened.</div><br/></div></div><div id="40924241" class="c"><input type="checkbox" id="c-40924241" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#40923069">root</a><span>|</span><a href="#40923931">parent</a><span>|</span><a href="#40924971">prev</a><span>|</span><a href="#40924340">next</a><span>|</span><label class="collapse" for="c-40924241">[-]</label><label class="expand" for="c-40924241">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m _pretty_ sure it&#x27;s satire, but the fact that you and I can&#x27;t say for sure is perhaps illustrative of the failure.<p>I&#x27;ve encountered this pattern several times over my career. Some very smart programmer decides that for &quot;reasons&quot; the standard way to do something is &quot;bad&quot;. (Usually &quot;performance&quot; or &quot;bloat&quot; are words bandied around.) They then happily architect a new system to replace the &quot;old thing&quot;. Of course the new thing is completely undocumented (because genius programmers don&#x27;t waste their time writing docs).<p>If you&#x27;re _lucky_ the programmer then spends his whole career there maintaining the thing. If you&#x27;re lucky the whole thing becomes obsolete and discarded before he retires. Hint: You&#x27;re not lucky.<p>So what you are left with is this big ball of smoosh, with no documentation, that no-one can figure-out, much less understand. Oh he designed this before multi-core processors were a thing? Before we switched to a preemtive threaded OS? Well no, none of the code is thread-safe, and he&#x27;s left the company so we need someone to &quot;just update it&quot;.<p>There are reasons standard libraries exist. There are usually reasons they&#x27;re a bit slower than hand-coding specific cases in assembler. There are reasons why they are &quot;bloated&quot; with support for lots of edge-cases. (like comments).<p>When some really smart person starts talking about how it&#x27;s all rubbish, be afraid. Be very afraid.</div><br/></div></div><div id="40924340" class="c"><input type="checkbox" id="c-40924340" checked=""/><div class="controls bullet"><span class="by">_nalply</span><span>|</span><a href="#40923069">root</a><span>|</span><a href="#40923931">parent</a><span>|</span><a href="#40924241">prev</a><span>|</span><a href="#40922640">next</a><span>|</span><label class="collapse" for="c-40924340">[-]</label><label class="expand" for="c-40924340">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the inner platform effect. When I was young I fell into the same trap. I invented a flexible database schema where I put each field into a database row with some metadata describing the field. But that&#x27;s nonsense. Just use what the database provides.<p>There&#x27;s a Wikipedia page about it: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Inner-platform_effect" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Inner-platform_effect</a><p>A variant of it is: Any sufficiently complicated program contains a slow and buggy implementation of half of Lisp. That&#x27;s the Greenspun&#x27;s tenth rule: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Greenspun%27s_tenth_rule" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Greenspun%27s_tenth_rule</a><p>This applies to the kernel as well to put it bluntly and a bit ironically: eBPF, but this shouldn&#x27;t be understood that I mean that eBPF is not well thought out! <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;EBPF" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;EBPF</a></div><br/></div></div></div></div></div></div></div></div><div id="40922640" class="c"><input type="checkbox" id="c-40922640" checked=""/><div class="controls bullet"><span class="by">nikki93</span><span>|</span><a href="#40923069">prev</a><span>|</span><a href="#40889273">next</a><span>|</span><label class="collapse" for="c-40922640">[-]</label><label class="expand" for="c-40922640">[1 more]</label></div><br/><div class="children"><div class="content">I use this static reflection hack in C++ -- <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;enh8za4ja" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;enh8za4ja</a><p>You do have to tag struct fields with a macro, but you can attach contexpr-visitable attributes. There&#x27;s also a static limit to how many reflectable fields you can have, all reflectable fields need to be at the front of the struct, and the struct needs to be an aggregate.</div><br/></div></div><div id="40889273" class="c"><input type="checkbox" id="c-40889273" checked=""/><div class="controls bullet"><span class="by">dctwin</span><span>|</span><a href="#40922640">prev</a><span>|</span><a href="#40924222">next</a><span>|</span><label class="collapse" for="c-40889273">[-]</label><label class="expand" for="c-40889273">[6 more]</label></div><br/><div class="children"><div class="content">Hello! I wrote this short blog post about using pattern-matching-like template metaprogramming to deserialize JSON at build time - please let me know what you think (especially if you see improvements)</div><br/><div id="40922713" class="c"><input type="checkbox" id="c-40922713" checked=""/><div class="controls bullet"><span class="by">worstspotgain</span><span>|</span><a href="#40889273">parent</a><span>|</span><a href="#40924539">next</a><span>|</span><label class="collapse" for="c-40922713">[-]</label><label class="expand" for="c-40922713">[1 more]</label></div><br/><div class="children"><div class="content">As someone who used to have to do this sort of compile-time stuff with previous versions of the standard, I&#x27;m jealous of how much more can be done now that I don&#x27;t have to.<p>If you&#x27;re looking for an interesting follow-up project, here&#x27;s something I had to do once that&#x27;s now become much easier: compute a compile-time hash of the compilation for the current translation unit, e.g. __BASE_FILE__ hashed together with __TIMESTAMP__ or the equivalents for each platform.<p>This allows you to dynamically invalidate on-disk caches and trigger new-build tripwires based on ongoing revisions. Development and release builds are handled identically: if source file X handles a cache and X was recompiled, discard the cache.</div><br/></div></div><div id="40924539" class="c"><input type="checkbox" id="c-40924539" checked=""/><div class="controls bullet"><span class="by">svalorzen</span><span>|</span><a href="#40889273">parent</a><span>|</span><a href="#40922713">prev</a><span>|</span><a href="#40924277">next</a><span>|</span><label class="collapse" for="c-40924539">[-]</label><label class="expand" for="c-40924539">[1 more]</label></div><br/><div class="children"><div class="content">I recently actually tried to do a very similar thing, although a bit tighter in scope. What stopped me what that actually deserializing floating points cannot currently be done at compile time; the only utility available to do so is `from_chars` and it is only constexpr for ints.<p>I did not see any mention of this in the post; so are you actually simply extracting the string versions of the numbers, without verifying nor deserializing them?</div><br/></div></div><div id="40924277" class="c"><input type="checkbox" id="c-40924277" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#40889273">parent</a><span>|</span><a href="#40924539">prev</a><span>|</span><a href="#40922262">next</a><span>|</span><label class="collapse" for="c-40924277">[-]</label><label class="expand" for="c-40924277">[1 more]</label></div><br/><div class="children"><div class="content">The concept reminds me of F#&#x27;s &quot;Type Providers&quot; [1].<p>In terms of the implementation ... I feel like C++ is best when used in an &quot;orthodox style&quot; and minimizing the use of templates as much as possible.<p>--<p>1: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;fsharp&#x2F;tutorials&#x2F;type-providers&#x2F;" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;fsharp&#x2F;tutorials&#x2F;ty...</a></div><br/></div></div><div id="40922262" class="c"><input type="checkbox" id="c-40922262" checked=""/><div class="controls bullet"><span class="by">whizzter</span><span>|</span><a href="#40889273">parent</a><span>|</span><a href="#40924277">prev</a><span>|</span><a href="#40922280">next</a><span>|</span><label class="collapse" for="c-40922262">[-]</label><label class="expand" for="c-40922262">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s cute and neat to be able to do it 100% constexpr, however as you mention the indexers feels a tad inelegant.<p>I&#x27;ve written 2 iterations of a reflection library where you needed to annotate structs slightly with an ugly macro but once done you could just do: Message msg; if (parse_json(str,msg)) { ..process msg struct.. }<p>The previous iterations were for C++11 and C++17 but it seems that with C++20 features you don&#x27;t even seem to need the macro uglyness so I personally think libraries need to move in the direction of plain old structs.</div><br/></div></div><div id="40922280" class="c"><input type="checkbox" id="c-40922280" checked=""/><div class="controls bullet"><span class="by">cobbal</span><span>|</span><a href="#40889273">parent</a><span>|</span><a href="#40922262">prev</a><span>|</span><a href="#40924222">next</a><span>|</span><label class="collapse" for="c-40922280">[-]</label><label class="expand" for="c-40922280">[1 more]</label></div><br/><div class="children"><div class="content">small note: &quot;JSON in its pure form anarchic&quot; is missing a verb</div><br/></div></div></div></div><div id="40924222" class="c"><input type="checkbox" id="c-40924222" checked=""/><div class="controls bullet"><span class="by">abbeyj</span><span>|</span><a href="#40889273">prev</a><span>|</span><a href="#40922546">next</a><span>|</span><label class="collapse" for="c-40924222">[-]</label><label class="expand" for="c-40924222">[1 more]</label></div><br/><div class="children"><div class="content">Could you use something like `template &lt;StringLiteral str&gt; constexpr inline Key&lt;str&gt; key;`?  Then you could write `key&lt;&quot;myKey&quot;&gt;` instead of `Key&lt;&quot;myKey&quot;&gt;{}`, saving you from needing the `{}` each time.</div><br/></div></div><div id="40922546" class="c"><input type="checkbox" id="c-40922546" checked=""/><div class="controls bullet"><span class="by">nikeee</span><span>|</span><a href="#40924222">prev</a><span>|</span><a href="#40924216">next</a><span>|</span><label class="collapse" for="c-40922546">[-]</label><label class="expand" for="c-40922546">[2 more]</label></div><br/><div class="children"><div class="content">Could this be leveraged to emit a parser that is specialized for the provided type that can be used at runtime? Afaik .NET does something like that using code generators.<p>The advantage being that the parser is tailored to the specific type that is deserialized and it writes directly to the struct&#x27;s fields instead of going through some dictionary.</div><br/><div id="40924219" class="c"><input type="checkbox" id="c-40924219" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#40922546">parent</a><span>|</span><a href="#40924216">next</a><span>|</span><label class="collapse" for="c-40924219">[-]</label><label class="expand" for="c-40924219">[1 more]</label></div><br/><div class="children"><div class="content">This lib does something like that:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;beached&#x2F;daw_json_link">https:&#x2F;&#x2F;github.com&#x2F;beached&#x2F;daw_json_link</a></div><br/></div></div></div></div><div id="40924216" class="c"><input type="checkbox" id="c-40924216" checked=""/><div class="controls bullet"><span class="by">anothername12</span><span>|</span><a href="#40922546">prev</a><span>|</span><a href="#40922821">next</a><span>|</span><label class="collapse" for="c-40924216">[-]</label><label class="expand" for="c-40924216">[3 more]</label></div><br/><div class="children"><div class="content">Not a C++ user, but is this the same as #. reader macro in Common Lisp?</div><br/><div id="40924672" class="c"><input type="checkbox" id="c-40924672" checked=""/><div class="controls bullet"><span class="by">heisig</span><span>|</span><a href="#40924216">parent</a><span>|</span><a href="#40924330">next</a><span>|</span><label class="collapse" for="c-40924672">[-]</label><label class="expand" for="c-40924672">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the #. reader macro is one of the ways how you can achieve this in Common Lisp.  Using the reader macro is also way more efficient because you don&#x27;t awkwardly use your compiler as an interpreter for a weird subset of your actual language - you simply call to compiled code.<p>Seeing Greenspun&#x27;s tenth rule [1] in action again and again is one of the weird things we Common Lisp programmers have to endure.  I wish we would have more discussions on how to improve Lisp even further instead of trying to &#x27;fix&#x27; C or C++ for the umpteenth time.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Greenspun%27s_tenth_rule" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Greenspun%27s_tenth_rule</a></div><br/></div></div><div id="40924330" class="c"><input type="checkbox" id="c-40924330" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40924216">parent</a><span>|</span><a href="#40924672">prev</a><span>|</span><a href="#40922821">next</a><span>|</span><label class="collapse" for="c-40924330">[-]</label><label class="expand" for="c-40924330">[1 more]</label></div><br/><div class="children"><div class="content">Also, this:<p><pre><code>  (defmacro macro-time (&amp;rest forms)
    `(quote ,(eval `(progn ,@forms))))
</code></pre>
<i>forms</i> are evaluated at macro-expansion-time, and their result is quoted, and substituted for the (macro-time ...) invocation.<p>For instance, if we have a <i>snarf-file</i> function which reads a text file and returns the contents as a string, we can do:<p><pre><code>  (macro-time (snarf-file &quot;foo.txt&quot;))
</code></pre>
and we now have the contents of foo.txt as a string literal.</div><br/></div></div></div></div><div id="40922821" class="c"><input type="checkbox" id="c-40922821" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#40924216">prev</a><span>|</span><label class="collapse" for="c-40922821">[-]</label><label class="expand" for="c-40922821">[1 more]</label></div><br/><div class="children"><div class="content">I think the value of compile-time JSON deserialization is... well I was going to say zero but really it&#x27;s negative. It&#x27;s a cute trick, but please don&#x27;t ever do this in a real project.</div><br/></div></div></div></div></div></div></div></body></html>