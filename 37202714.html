<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692608464110" as="style"/><link rel="stylesheet" href="styles.css?v=1692608464110"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.akshaykhot.com/ruby-hash-is-a-swiss-army-knife/">Ruby&#x27;s hash is a Swiss-army knife</a> <span class="domain">(<a href="https://www.akshaykhot.com">www.akshaykhot.com</a>)</span></div><div class="subtext"><span>software_writer</span> | <span>51 comments</span></div><br/><div><div id="37203955" class="c"><input type="checkbox" id="c-37203955" checked=""/><div class="controls bullet"><span class="by">andolanra</span><span>|</span><a href="#37204784">next</a><span>|</span><label class="collapse" for="c-37203955">[-]</label><label class="expand" for="c-37203955">[4 more]</label></div><br/><div class="children"><div class="content">Since Ruby 3, the automatic coercion of keywords to a hash—the second example underneath &quot;Passing Hash to Functions&quot; in this post—is considered a legacy style and is generally frowned upon in new code. That is to say, code like the second call to `foo` here:<p><pre><code>    def foo(kwargs = {})
      kwargs
    end
    
    foo({k: 1})  # ok: passing hash argument
    foo(k: 1)    # ok: keywords coerced to hash
</code></pre>
One of the strongest arguments for avoiding this sugar is that it makes the code more brittle in the face of future changes. In particular, in the example above, if we add a new keyword argument to `foo`, then any call which omitted the curly braces will break, while calls which used them will keep working fine:<p><pre><code>    # added a new keyword arg here
    def foo(kwargs = {}, frob: false)
      kwargs
    end
    
    foo({k: 1})  # still ok: `frob` defaults to false
    foo(k: 1)    # ArgumentError: no keyword: :k
</code></pre>
This is touched on in the blog post describing the extensive changes made to keywords in Ruby 3: <a href="https:&#x2F;&#x2F;www.ruby-lang.org&#x2F;en&#x2F;news&#x2F;2019&#x2F;12&#x2F;12&#x2F;separation-of-positional-and-keyword-arguments-in-ruby-3-0&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.ruby-lang.org&#x2F;en&#x2F;news&#x2F;2019&#x2F;12&#x2F;12&#x2F;separation-of-p...</a></div><br/><div id="37204901" class="c"><input type="checkbox" id="c-37204901" checked=""/><div class="controls bullet"><span class="by">Klonoar</span><span>|</span><a href="#37203955">parent</a><span>|</span><a href="#37203982">next</a><span>|</span><label class="collapse" for="c-37204901">[-]</label><label class="expand" for="c-37204901">[1 more]</label></div><br/><div class="children"><div class="content">This might be me having huffed too many types lately, but I feel like I would <i>want that to break</i>.</div><br/></div></div><div id="37203982" class="c"><input type="checkbox" id="c-37203982" checked=""/><div class="controls bullet"><span class="by">software_writer</span><span>|</span><a href="#37203955">parent</a><span>|</span><a href="#37204901">prev</a><span>|</span><a href="#37205603">next</a><span>|</span><label class="collapse" for="c-37203982">[-]</label><label class="expand" for="c-37203982">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right, thanks for the demo and sharing the link, really appreciated. I&#x27;ll update the article to mention this.</div><br/></div></div></div></div><div id="37204784" class="c"><input type="checkbox" id="c-37204784" checked=""/><div class="controls bullet"><span class="by">faitswulff</span><span>|</span><a href="#37203955">prev</a><span>|</span><a href="#37205768">next</a><span>|</span><label class="collapse" for="c-37204784">[-]</label><label class="expand" for="c-37204784">[11 more]</label></div><br/><div class="children"><div class="content">My favorite little-known fact about Ruby hashes is that they respond to `to_proc` and can be used as procs. For example, you can do this:<p>a = { 1 =&gt; &#x27;a&#x27;, 2 =&gt; &#x27;b&#x27; }<p>[1, 2, 3].map(&amp;a)<p>#=&gt; [&#x27;a&#x27;, &#x27;b&#x27;, nil]</div><br/><div id="37205424" class="c"><input type="checkbox" id="c-37205424" checked=""/><div class="controls bullet"><span class="by">nix-zarathustra</span><span>|</span><a href="#37204784">parent</a><span>|</span><a href="#37205619">next</a><span>|</span><label class="collapse" for="c-37205424">[-]</label><label class="expand" for="c-37205424">[5 more]</label></div><br/><div class="children"><div class="content">One of the most beautiful things in Ruby that I have ever seen is this fibonacci code.<p><pre><code>  fib = Hash.new do |k, v|
    next 1 if v == 0 || v == 1
    k[v-1] + k[v-2]
  end</code></pre></div><br/><div id="37206967" class="c"><input type="checkbox" id="c-37206967" checked=""/><div class="controls bullet"><span class="by">devoutsalsa</span><span>|</span><a href="#37204784">root</a><span>|</span><a href="#37205424">parent</a><span>|</span><a href="#37206036">next</a><span>|</span><label class="collapse" for="c-37206967">[-]</label><label class="expand" for="c-37206967">[1 more]</label></div><br/><div class="children"><div class="content">With caching...<p><pre><code>   fib = Hash.new do |k, v|
     next 1 if v == 0 || v == 1

     unless k.key? v
       k[v] = k[v-1] + k[v-2]
     end

     k[v]
   end</code></pre></div><br/></div></div><div id="37206036" class="c"><input type="checkbox" id="c-37206036" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#37204784">root</a><span>|</span><a href="#37205424">parent</a><span>|</span><a href="#37206967">prev</a><span>|</span><a href="#37206023">next</a><span>|</span><label class="collapse" for="c-37206036">[-]</label><label class="expand" for="c-37206036">[1 more]</label></div><br/><div class="children"><div class="content">Or an Ackermann:<p><pre><code>    A = Hash.new { |a,(m,n)| a[[m,n]] = m==0 ? n+1 : n==0 ? a[[m-1,1]] : a[[m-1, a[[m, n-1]]]] }

    A[[3,4]] #=&gt; 125

    A.inspect #=&gt; ... long
</code></pre>
However, the application utility of a self-populating lazily-evaluated lookup structure goes further. A hash with a default function works great as a simple caching wrapper for all manner of results, for example when talking to slow or fine-grained APIs.</div><br/></div></div><div id="37206023" class="c"><input type="checkbox" id="c-37206023" checked=""/><div class="controls bullet"><span class="by">hit8run</span><span>|</span><a href="#37204784">root</a><span>|</span><a href="#37205424">parent</a><span>|</span><a href="#37206036">prev</a><span>|</span><a href="#37205619">next</a><span>|</span><label class="collapse" for="c-37206023">[-]</label><label class="expand" for="c-37206023">[2 more]</label></div><br/><div class="children"><div class="content">Let’s make it a one liner :D<p>fib = Hash.new {|hash, key| hash[key] = key &lt; 2 ? key : hash[key-1] + hash[key-2] }<p>Example:
fib[123] # =&gt; 22698374052006863956975682<p>Makes use of memoization.</div><br/><div id="37206211" class="c"><input type="checkbox" id="c-37206211" checked=""/><div class="controls bullet"><span class="by">nix-zarathustra</span><span>|</span><a href="#37204784">root</a><span>|</span><a href="#37206023">parent</a><span>|</span><a href="#37205619">next</a><span>|</span><label class="collapse" for="c-37206211">[-]</label><label class="expand" for="c-37206211">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I was going off of memory and thought that it was memoising it, but I made a mistake and fixed it.<p><pre><code>  fib = Hash.new do |k, v|
    next 1 if v == 0 || v == 1
    k[v] = k[v-1] + k[v-2]
  end
</code></pre>
I like yours better though, it seems a lot simpler with the less than 2 check.</div><br/></div></div></div></div></div></div><div id="37205619" class="c"><input type="checkbox" id="c-37205619" checked=""/><div class="controls bullet"><span class="by">cyclotron3k</span><span>|</span><a href="#37204784">parent</a><span>|</span><a href="#37205424">prev</a><span>|</span><a href="#37205163">next</a><span>|</span><label class="collapse" for="c-37205619">[-]</label><label class="expand" for="c-37205619">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s cool, I didn&#x27;t know that!<p>But now I&#x27;m wondering where that would be a better solution than just using the `Hash#values_at` method...?</div><br/></div></div><div id="37205163" class="c"><input type="checkbox" id="c-37205163" checked=""/><div class="controls bullet"><span class="by">software_writer</span><span>|</span><a href="#37204784">parent</a><span>|</span><a href="#37205619">prev</a><span>|</span><a href="#37205768">next</a><span>|</span><label class="collapse" for="c-37205163">[-]</label><label class="expand" for="c-37205163">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t quite understand how this code works. Where does the `nil` come from? What operation are we performing on 3 that causes it to return `nil`?</div><br/><div id="37205195" class="c"><input type="checkbox" id="c-37205195" checked=""/><div class="controls bullet"><span class="by">breckenedge</span><span>|</span><a href="#37204784">root</a><span>|</span><a href="#37205163">parent</a><span>|</span><a href="#37205482">next</a><span>|</span><label class="collapse" for="c-37205195">[-]</label><label class="expand" for="c-37205195">[2 more]</label></div><br/><div class="children"><div class="content">1, 2, and 3 are being passed as lookups to the a hash. 3 is undefined on the hash, hence nil.</div><br/><div id="37205221" class="c"><input type="checkbox" id="c-37205221" checked=""/><div class="controls bullet"><span class="by">software_writer</span><span>|</span><a href="#37204784">root</a><span>|</span><a href="#37205195">parent</a><span>|</span><a href="#37205482">next</a><span>|</span><label class="collapse" for="c-37205221">[-]</label><label class="expand" for="c-37205221">[1 more]</label></div><br/><div class="children"><div class="content">Ah, that makes sense. Thank you!</div><br/></div></div></div></div></div></div></div></div><div id="37205768" class="c"><input type="checkbox" id="c-37205768" checked=""/><div class="controls bullet"><span class="by">defanor</span><span>|</span><a href="#37204784">prev</a><span>|</span><a href="#37205220">next</a><span>|</span><label class="collapse" for="c-37205768">[-]</label><label class="expand" for="c-37205768">[2 more]</label></div><br/><div class="children"><div class="content">It is just a hash map with a few common functions defined; hash maps are occasionally useful, but what is all the praise about?<p>The mentioned &quot;simple&quot; bit is arguable: as a language&#x27;s building block, a hash map is relatively complex and specific, since those can be built out of lists (or trees, though lists&#x2F;arrays may be preferable for efficiency), which can be built out of pairs (product types, cons cells, tuples; unless going for that efficiency, though it can still be pretty efficient with trees). Maybe it is one of those &quot;simple versus easy&quot; mix-ups.</div><br/><div id="37206221" class="c"><input type="checkbox" id="c-37206221" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#37205768">parent</a><span>|</span><a href="#37205220">next</a><span>|</span><label class="collapse" for="c-37206221">[-]</label><label class="expand" for="c-37206221">[1 more]</label></div><br/><div class="children"><div class="content">Well yeah, it&#x27;s &quot;simple&quot; (or easy) to use, definitely not simple to implement. But having an easy-to-use hashmap is par for the course for most newer languages - not only Ruby, but also PHP (associative arrays), JS (objects), Go (built-in map type) etc.</div><br/></div></div></div></div><div id="37205220" class="c"><input type="checkbox" id="c-37205220" checked=""/><div class="controls bullet"><span class="by">irjustin</span><span>|</span><a href="#37205768">prev</a><span>|</span><a href="#37203449">next</a><span>|</span><label class="collapse" for="c-37205220">[-]</label><label class="expand" for="c-37205220">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been in Python&#x2F;Django for about a year now and I really miss Ruby&#x27;s hash vs the dict.<p>`.dig(:key, :key, :etc)` is so nice to find deeply nested data without blowing up.<p>One thing I don&#x27;t miss is knowing whether a hash&#x27;s keys are strings vs symbols. While it&#x27;s easily solvable, I&#x27;ve definitely lost time only to smack myself that I need to use a str but was always feeding a sym and swore that this should be a sym based hash.</div><br/><div id="37205306" class="c"><input type="checkbox" id="c-37205306" checked=""/><div class="controls bullet"><span class="by">code_biologist</span><span>|</span><a href="#37205220">parent</a><span>|</span><a href="#37203449">next</a><span>|</span><label class="collapse" for="c-37205306">[-]</label><label class="expand" for="c-37205306">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know ruby and if it&#x27;s the same, but if you&#x27;re not using a library like funcy or toolz for a nested get helper, you can do `dict.get(&#x27;key&#x27;, {}).get(&#x27;key2&#x27;, {}).get(&#x27;key3&#x27;)`. Not the prettiest, but can do in a pinch.</div><br/><div id="37205744" class="c"><input type="checkbox" id="c-37205744" checked=""/><div class="controls bullet"><span class="by">irjustin</span><span>|</span><a href="#37205220">root</a><span>|</span><a href="#37205306">parent</a><span>|</span><a href="#37203449">next</a><span>|</span><label class="collapse" for="c-37205744">[-]</label><label class="expand" for="c-37205744">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! i didn&#x27;t know about these and will check them out for sure. Tired of `if key in hash:` nested layers.</div><br/></div></div></div></div></div></div><div id="37203449" class="c"><input type="checkbox" id="c-37203449" checked=""/><div class="controls bullet"><span class="by">block_dagger</span><span>|</span><a href="#37205220">prev</a><span>|</span><a href="#37204423">next</a><span>|</span><label class="collapse" for="c-37203449">[-]</label><label class="expand" for="c-37203449">[5 more]</label></div><br/><div class="children"><div class="content">Ruby’s Hash is probably the handiest data structure I’ve ever encountered. Thanks Matz.</div><br/><div id="37203718" class="c"><input type="checkbox" id="c-37203718" checked=""/><div class="controls bullet"><span class="by">thibaut_barrere</span><span>|</span><a href="#37203449">parent</a><span>|</span><a href="#37204551">next</a><span>|</span><label class="collapse" for="c-37203718">[-]</label><label class="expand" for="c-37203718">[2 more]</label></div><br/><div class="children"><div class="content">Definitely! As a matter of fact, this is the default data structure I use when writing Ruby ETL code (e.g. <a href="https:&#x2F;&#x2F;github.com&#x2F;thbar&#x2F;kiba&#x2F;wiki">https:&#x2F;&#x2F;github.com&#x2F;thbar&#x2F;kiba&#x2F;wiki</a>).<p>Methods like &quot;except&quot; (<a href="https:&#x2F;&#x2F;docs.ruby-lang.org&#x2F;en&#x2F;3.2&#x2F;Hash.html#method-i-except" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.ruby-lang.org&#x2F;en&#x2F;3.2&#x2F;Hash.html#method-i-except</a>) or &quot;fetch&quot; (raising an error on missing key) are very convenient to write defensive data processing code!<p>Similarly, in Elixir, I use Maps a lot for the same type of jobs (<a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;1.15.4&#x2F;Map.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;1.15.4&#x2F;Map.html</a>), with similar properties.</div><br/><div id="37205316" class="c"><input type="checkbox" id="c-37205316" checked=""/><div class="controls bullet"><span class="by">code_biologist</span><span>|</span><a href="#37203449">root</a><span>|</span><a href="#37203718">parent</a><span>|</span><a href="#37204551">next</a><span>|</span><label class="collapse" for="c-37205316">[-]</label><label class="expand" for="c-37205316">[1 more]</label></div><br/><div class="children"><div class="content">Kiba looks like a really cool framework, thanks for posting it!</div><br/></div></div></div></div><div id="37204551" class="c"><input type="checkbox" id="c-37204551" checked=""/><div class="controls bullet"><span class="by">Gigachad</span><span>|</span><a href="#37203449">parent</a><span>|</span><a href="#37203718">prev</a><span>|</span><a href="#37204423">next</a><span>|</span><label class="collapse" for="c-37204551">[-]</label><label class="expand" for="c-37204551">[2 more]</label></div><br/><div class="children"><div class="content">I wish it was typed though. So many times I’ve seen a function that takes a hash of “options” or “config” and have no idea what that actually contains. Even for official rails methods it’s often complex to know what the possible options are. Some of them seem almost internal with how obscure they are.</div><br/><div id="37206156" class="c"><input type="checkbox" id="c-37206156" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#37203449">root</a><span>|</span><a href="#37204551">parent</a><span>|</span><a href="#37204423">next</a><span>|</span><label class="collapse" for="c-37206156">[-]</label><label class="expand" for="c-37206156">[1 more]</label></div><br/><div class="children"><div class="content">RBS+steep to the rescue! We typed our configuration this way for ddtrace Ruby. On the external (set) side it makes it very easy to explore configuration in an editor, on the internal (get) side it makes us ensure we don&#x27;t make mistakes.</div><br/></div></div></div></div></div></div><div id="37204423" class="c"><input type="checkbox" id="c-37204423" checked=""/><div class="controls bullet"><span class="by">q7xvh97o2pDhNrh</span><span>|</span><a href="#37203449">prev</a><span>|</span><a href="#37203645">next</a><span>|</span><label class="collapse" for="c-37204423">[-]</label><label class="expand" for="c-37204423">[3 more]</label></div><br/><div class="children"><div class="content">This is a lovely overview. Hash is a great example of how delightful it can be to program in Ruby.<p>One more technique worth noting is the chained functional style of using Hash, which you can do in Ruby because Hash inherits from Enumerable. If you&#x27;re prototyping a script to do some data-cleaning, this makes it easy to build up your pipeline and iterate on it. For example:<p><pre><code>    foobar = { ...your data here... }
    foobar.map do |k, v|
      # ...
      # do some transformation here
      # ...
      # and then return the replacement key&#x2F;value for this entry
      [key, new_value]
    end.select do |k, v|
      # do some filtering here, e.g.:
      is_foobarable?(k, v)
    end.map do |k, v|
      # ...
      # do some expensive transformation here on the smaller data set
      # ...
      [key, newer_value]
    end.to_h
</code></pre>
(Note that you have to call #to_h at the end since the Enumerable functions will coerce the hash into an array of arrays.)<p>Now your code literally shows the pipeline that your data is falling through — and each of these steps can be side-effect-free, with no mutations to the original foobar structure.</div><br/><div id="37204619" class="c"><input type="checkbox" id="c-37204619" checked=""/><div class="controls bullet"><span class="by">my_new_account0</span><span>|</span><a href="#37204423">parent</a><span>|</span><a href="#37203645">next</a><span>|</span><label class="collapse" for="c-37204619">[-]</label><label class="expand" for="c-37204619">[2 more]</label></div><br/><div class="children"><div class="content">Unless things have changed and Ruby has stream fusion now, this is bad advice for scale. You are iterating over a fat object multiple times. Even if its uglier its much better in this case to create an empty array&#x2F;hash, iterate over with #each and #&lt;&lt; to the hash.<p>I worked at the largest Rails shop in the world and this would be rejected in code review.<p>Edited to add more detail: the only method you need to write to implement Enumerable is #each. Every step of your pipeline here is _another_ call to #each. Just do it once.</div><br/><div id="37206132" class="c"><input type="checkbox" id="c-37206132" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#37204423">root</a><span>|</span><a href="#37204619">parent</a><span>|</span><a href="#37203645">next</a><span>|</span><label class="collapse" for="c-37206132">[-]</label><label class="expand" for="c-37206132">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s #lazy to turn things into a lazy enumerator, to be iterated over when you so desire with e.g #force.<p>If you&#x27;re going to iterate over an accumulator variable, use the for keyword instead of each, it&#x27;s faster.<p>Alternatively, one can use .reduce({}) { |h, (k, v)| ... h } or .each.with_object({}) { |(k, v), h| ... } which makes the block not close over an external variable, and makes the assignment to that variable &quot;atomic&quot; (wrt the hash construction, the variable will only contain the final result, that is if a final variable is needed at all, which it may not with implicit return of the last value)</div><br/></div></div></div></div></div></div><div id="37203645" class="c"><input type="checkbox" id="c-37203645" checked=""/><div class="controls bullet"><span class="by">j_crick</span><span>|</span><a href="#37204423">prev</a><span>|</span><a href="#37206014">next</a><span>|</span><label class="collapse" for="c-37203645">[-]</label><label class="expand" for="c-37203645">[1 more]</label></div><br/><div class="children"><div class="content">It should be noted that ** operator works like .merge, and also accounts for the order of key definition in a given hash declaration (whatever is declared earlier gets overwritten if a key with same name is used in the same hash declaration later).</div><br/></div></div><div id="37206014" class="c"><input type="checkbox" id="c-37206014" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#37203645">prev</a><span>|</span><a href="#37206039">next</a><span>|</span><label class="collapse" for="c-37206014">[-]</label><label class="expand" for="c-37206014">[1 more]</label></div><br/><div class="children"><div class="content">For me the most useful bit about #fetch is not that it throws, it&#x27;s that it allows setting a default value while distinguishing between a missing key and a key with nil as a value. If I want to handle key presence without a default I just use #key? as exceptions come with additional performance cost (building the stacktrace)</div><br/></div></div><div id="37206039" class="c"><input type="checkbox" id="c-37206039" checked=""/><div class="controls bullet"><span class="by">blarnopre</span><span>|</span><a href="#37206014">prev</a><span>|</span><a href="#37204978">next</a><span>|</span><label class="collapse" for="c-37206039">[-]</label><label class="expand" for="c-37206039">[3 more]</label></div><br/><div class="children"><div class="content">The only thing I really miss in the default Ruby hash is property access for keys like JavaScript has.<p>I know, I know, OStruct does this but it&#x27;s not the thing that gets built from hash literals so it&#x27;s less convenient.<p>It&#x27;s a minor quibble</div><br/><div id="37206212" class="c"><input type="checkbox" id="c-37206212" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#37206039">parent</a><span>|</span><a href="#37204978">next</a><span>|</span><label class="collapse" for="c-37206212">[-]</label><label class="expand" for="c-37206212">[2 more]</label></div><br/><div class="children"><div class="content">OpenStructs are ungodly slow anyway. If you want such accessors you probably want a plain Struct anyway and not mix hashness and method accessors. You can even define additional methods on structs:<p><pre><code>    Foo = Struct.new(:a, :b, keyword_init: true) do
      def frobz
        ...
      end
    end
</code></pre>
Structs are quicker to instantiate than classes but slower to call methods on, so if you instantiate a lot but seldom call they&#x27;re great. Otherwise a class is better.</div><br/><div id="37206770" class="c"><input type="checkbox" id="c-37206770" checked=""/><div class="controls bullet"><span class="by">ljm</span><span>|</span><a href="#37206039">root</a><span>|</span><a href="#37206212">parent</a><span>|</span><a href="#37204978">next</a><span>|</span><label class="collapse" for="c-37206770">[-]</label><label class="expand" for="c-37206770">[1 more]</label></div><br/><div class="children"><div class="content">The new Data class in Ruby 3.2 also does the job (although it&#x27;s intended for immutable data)<p><a href="https:&#x2F;&#x2F;docs.ruby-lang.org&#x2F;en&#x2F;3.2&#x2F;Data.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.ruby-lang.org&#x2F;en&#x2F;3.2&#x2F;Data.html</a></div><br/></div></div></div></div></div></div><div id="37204978" class="c"><input type="checkbox" id="c-37204978" checked=""/><div class="controls bullet"><span class="by">gilfoyle</span><span>|</span><a href="#37206039">prev</a><span>|</span><a href="#37203924">next</a><span>|</span><label class="collapse" for="c-37204978">[-]</label><label class="expand" for="c-37204978">[3 more]</label></div><br/><div class="children"><div class="content">Also that it maintains insertion order (since Ruby 1.9) opens up more use cases.</div><br/><div id="37205393" class="c"><input type="checkbox" id="c-37205393" checked=""/><div class="controls bullet"><span class="by">software_writer</span><span>|</span><a href="#37204978">parent</a><span>|</span><a href="#37203924">next</a><span>|</span><label class="collapse" for="c-37205393">[-]</label><label class="expand" for="c-37205393">[2 more]</label></div><br/><div class="children"><div class="content">Do you know any use cases, other than iteration? Would love to know any interesting ones. Thanks!</div><br/><div id="37206457" class="c"><input type="checkbox" id="c-37206457" checked=""/><div class="controls bullet"><span class="by">byroot</span><span>|</span><a href="#37204978">root</a><span>|</span><a href="#37205393">parent</a><span>|</span><a href="#37203924">next</a><span>|</span><label class="collapse" for="c-37206457">[-]</label><label class="expand" for="c-37206457">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, you can use it to implement a simple (but not necessarily very performant) LRU: <a href="https:&#x2F;&#x2F;github.com&#x2F;SamSaffron&#x2F;lru_redux&#x2F;blob&#x2F;037ee594aded59764487d4a1a5b4077fa710ae3b&#x2F;lib&#x2F;lru_redux&#x2F;cache.rb">https:&#x2F;&#x2F;github.com&#x2F;SamSaffron&#x2F;lru_redux&#x2F;blob&#x2F;037ee594aded597...</a></div><br/></div></div></div></div></div></div><div id="37203924" class="c"><input type="checkbox" id="c-37203924" checked=""/><div class="controls bullet"><span class="by">drbojingle</span><span>|</span><a href="#37204978">prev</a><span>|</span><a href="#37204409">next</a><span>|</span><label class="collapse" for="c-37203924">[-]</label><label class="expand" for="c-37203924">[11 more]</label></div><br/><div class="children"><div class="content">PHP&#x27;s associative array is very similar yea?</div><br/><div id="37204025" class="c"><input type="checkbox" id="c-37204025" checked=""/><div class="controls bullet"><span class="by">software_writer</span><span>|</span><a href="#37203924">parent</a><span>|</span><a href="#37204068">next</a><span>|</span><label class="collapse" for="c-37204025">[-]</label><label class="expand" for="c-37204025">[9 more]</label></div><br/><div class="children"><div class="content">Yes, hashes in Ruby, associative arrays in PHP, maps in Go[1], dictionaries in Python[2] and C#[3] represent the same concept, a collection of key-value pairs.<p>[1]: <a href="https:&#x2F;&#x2F;gobyexample.com&#x2F;maps" rel="nofollow noreferrer">https:&#x2F;&#x2F;gobyexample.com&#x2F;maps</a>
[2]: <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;tutorial&#x2F;datastructures.html#dictionaries" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;tutorial&#x2F;datastructures.html#dicti...</a>
[3]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.collections.generic.dictionary-2?view=net-7.0" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.collecti...</a></div><br/><div id="37204344" class="c"><input type="checkbox" id="c-37204344" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#37203924">root</a><span>|</span><a href="#37204025">parent</a><span>|</span><a href="#37204064">next</a><span>|</span><label class="collapse" for="c-37204344">[-]</label><label class="expand" for="c-37204344">[1 more]</label></div><br/><div class="children"><div class="content">The interesting thing is that it definitely <i>feels</i> different to me.<p>While the basic data structure is obviously identical to its counterparts, the way it interacts with the ecosystem as a whole makes it feel way more powerful. The interaction of hashes, symbols, and blocks lead to a language which feels like it is designed with DSLs as first-class citizens. This leads to things like Ruby on Rails, which at first glance feels like pure magic.<p>I get a somewhat similar feeling about lists in Python. Because of its very extensive list comprehension you start <i>thinking</i> in lists, leading to some very clean code which would be extremely awkward to implement in many other languages.</div><br/></div></div><div id="37204064" class="c"><input type="checkbox" id="c-37204064" checked=""/><div class="controls bullet"><span class="by">my_new_account0</span><span>|</span><a href="#37203924">root</a><span>|</span><a href="#37204025">parent</a><span>|</span><a href="#37204344">prev</a><span>|</span><a href="#37204068">next</a><span>|</span><label class="collapse" for="c-37204064">[-]</label><label class="expand" for="c-37204064">[7 more]</label></div><br/><div class="children"><div class="content">Yes. The OP&#x27;s post is basically &quot;baby&#x27;s first API.&quot; The are a very handy API but relying on them at scale is much less efficient than structs or arrays. This post doesn&#x27;t even go into the different performance characters of these APIs, which can be a major foot gun.<p>I&#x27;ve noticed a lot of novice-level posts on here lately. Although I admit the post was very well written.</div><br/><div id="37204143" class="c"><input type="checkbox" id="c-37204143" checked=""/><div class="controls bullet"><span class="by">ceautery</span><span>|</span><a href="#37203924">root</a><span>|</span><a href="#37204064">parent</a><span>|</span><a href="#37204823">next</a><span>|</span><label class="collapse" for="c-37204143">[-]</label><label class="expand" for="c-37204143">[2 more]</label></div><br/><div class="children"><div class="content">Novice level posts are great. Someone found something exciting to them, not new to us, but we should encourage them to keep exploring and writing.</div><br/><div id="37204264" class="c"><input type="checkbox" id="c-37204264" checked=""/><div class="controls bullet"><span class="by">schrodinger</span><span>|</span><a href="#37203924">root</a><span>|</span><a href="#37204143">parent</a><span>|</span><a href="#37204823">next</a><span>|</span><label class="collapse" for="c-37204264">[-]</label><label class="expand" for="c-37204264">[1 more]</label></div><br/><div class="children"><div class="content">Also, the votes imply interest!</div><br/></div></div></div></div><div id="37204823" class="c"><input type="checkbox" id="c-37204823" checked=""/><div class="controls bullet"><span class="by">djur</span><span>|</span><a href="#37203924">root</a><span>|</span><a href="#37204064">parent</a><span>|</span><a href="#37204143">prev</a><span>|</span><a href="#37206082">next</a><span>|</span><label class="collapse" for="c-37204823">[-]</label><label class="expand" for="c-37204823">[1 more]</label></div><br/><div class="children"><div class="content">My experience is that Struct only performs better than Hash in a pretty narrow set of circumstances, rarely enough to be a deciding factor unless profiling suggests it to be.</div><br/></div></div><div id="37206082" class="c"><input type="checkbox" id="c-37206082" checked=""/><div class="controls bullet"><span class="by">Glyptodon</span><span>|</span><a href="#37203924">root</a><span>|</span><a href="#37204064">parent</a><span>|</span><a href="#37204823">prev</a><span>|</span><a href="#37204668">next</a><span>|</span><label class="collapse" for="c-37206082">[-]</label><label class="expand" for="c-37206082">[1 more]</label></div><br/><div class="children"><div class="content">Ruby structs or c-family structs?</div><br/></div></div><div id="37204668" class="c"><input type="checkbox" id="c-37204668" checked=""/><div class="controls bullet"><span class="by">dikei</span><span>|</span><a href="#37203924">root</a><span>|</span><a href="#37204064">parent</a><span>|</span><a href="#37206082">prev</a><span>|</span><a href="#37204068">next</a><span>|</span><label class="collapse" for="c-37204668">[-]</label><label class="expand" for="c-37204668">[2 more]</label></div><br/><div class="children"><div class="content">I find it funny that he said he didn&#x27;t know what to pick between 5 types of IDictionary in C#.<p>* Hashtable<p>* SortedList<p>* SortedList&lt;TKey, TValue&gt;<p>* Dictionary&lt;TKey, TValue&gt;<p>* ConcurrentDictionary&lt;TKey, TValue&gt;<p>I don&#x27;t even know C# (just Java), yet I know that you&#x27;d probably want to use Dictionary&lt;TKey, TValue&gt; most of the time.</div><br/><div id="37205345" class="c"><input type="checkbox" id="c-37205345" checked=""/><div class="controls bullet"><span class="by">software_writer</span><span>|</span><a href="#37203924">root</a><span>|</span><a href="#37204668">parent</a><span>|</span><a href="#37204068">next</a><span>|</span><label class="collapse" for="c-37205345">[-]</label><label class="expand" for="c-37205345">[1 more]</label></div><br/><div class="children"><div class="content">To be honest, I wrote that just to add a little drama ;)</div><br/></div></div></div></div></div></div></div></div><div id="37204068" class="c"><input type="checkbox" id="c-37204068" checked=""/><div class="controls bullet"><span class="by">johannes1234321</span><span>|</span><a href="#37203924">parent</a><span>|</span><a href="#37204025">prev</a><span>|</span><a href="#37204409">next</a><span>|</span><label class="collapse" for="c-37204068">[-]</label><label class="expand" for="c-37204068">[1 more]</label></div><br/><div class="children"><div class="content">Selling it as associative array is nice. (And I know the docs do that, too)<p>It&#x27;s a doubly linked list, array, hashmap all in one, with some weird magic when handling numeric indices.<p>There&#x27;s often the time when using another language that I made a bad choice by picking either an array or hash or list while later I need one of the other properties PHP would give me by default. The extra cost for most uses is neglectible.</div><br/></div></div></div></div><div id="37204409" class="c"><input type="checkbox" id="c-37204409" checked=""/><div class="controls bullet"><span class="by">sottol</span><span>|</span><a href="#37203924">prev</a><span>|</span><label class="collapse" for="c-37204409">[-]</label><label class="expand" for="c-37204409">[3 more]</label></div><br/><div class="children"><div class="content">In my opinion Lua&#x27;s equivalent tables or more of a Swiss army knife.<p>It&#x27;s been a while since I&#x27;ve used them but afair they combine hash&#x2F;dict, array and objects in one data structure.<p>They&#x27;re hashes as usual. With a special constructor or int keys they turn into arrays, last I looked the Lua interpreter even optimizes contiguous ranges of keys as arrays. And by adding metatables and metamethods they also emulate JS-style objects.</div><br/><div id="37204892" class="c"><input type="checkbox" id="c-37204892" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#37204409">parent</a><span>|</span><label class="collapse" for="c-37204892">[-]</label><label class="expand" for="c-37204892">[2 more]</label></div><br/><div class="children"><div class="content">My feeling with Lua is that it&#x27;s lacking arrays due to minimalism, as in &quot;we don&#x27;t need arrays because tables will do&quot;.  Probably the same reason why there is no &quot;continue&quot; in a for-loop.<p>In comparison, Ruby has arrays and hashes, and gives me the feeling &quot;yes these do exactly what you expected, but wait there is more!&quot;  In that sense it does feel more like a Swiss army knife.</div><br/><div id="37206615" class="c"><input type="checkbox" id="c-37206615" checked=""/><div class="controls bullet"><span class="by">astrobe_</span><span>|</span><a href="#37204409">root</a><span>|</span><a href="#37204892">parent</a><span>|</span><label class="collapse" for="c-37206615">[-]</label><label class="expand" for="c-37206615">[1 more]</label></div><br/><div class="children"><div class="content">On the contrary, they acknowledged that hash tables only was pushing it a bit too far, so they implemented arrays sort of &quot;on the side&quot; of tables.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>