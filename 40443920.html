<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716454870978" as="style"/><link rel="stylesheet" href="styles.css?v=1716454870978"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/onecodex/rust-bfield">Show HN: B-field, a novel probabilistic key-value data structure (`rust-bfield`)</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>boyd</span> | <span>33 comments</span></div><br/><div><div id="40446399" class="c"><input type="checkbox" id="c-40446399" checked=""/><div class="controls bullet"><span class="by">pkhuong</span><span>|</span><a href="#40444645">next</a><span>|</span><label class="collapse" for="c-40446399">[-]</label><label class="expand" for="c-40446399">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;d expect a comparison with compact (or even succinct) constructions for arbitrary functions, like MWHC. Section 3.2 of <a href="https:&#x2F;&#x2F;vigna.di.unimi.it&#x2F;ftp&#x2F;papers&#x2F;TheoryPracticeMonotone.pdf" rel="nofollow">https:&#x2F;&#x2F;vigna.di.unimi.it&#x2F;ftp&#x2F;papers&#x2F;TheoryPracticeMonotone....</a> has a good overview.<p>Given a set S of arbitrary hashable values, it&#x27;s possible to represent a function from S to r bits in |S|r + o(|S|) bits (keys outside S are mapped to random r-bit values). More practical construction hit ~1.23 |S|r, or even |S|(r + 1.23) bits. It should also be faster to evaluate than `r` bloom filter lookups for large datasets.<p>I think the main advantage of the bloom filter (or compressed bitmap) approach is it can be updated incrementally. MWHC-style representations are better suited to build once &#x2F; read many workloads.</div><br/><div id="40446621" class="c"><input type="checkbox" id="c-40446621" checked=""/><div class="controls bullet"><span class="by">boyd</span><span>|</span><a href="#40446399">parent</a><span>|</span><a href="#40444645">next</a><span>|</span><label class="collapse" for="c-40446621">[-]</label><label class="expand" for="c-40446621">[4 more]</label></div><br/><div class="children"><div class="content">My understanding is that a perfect hash function maps elements elements to a <i>unique</i> integer (i.e., it&#x27;s a one-to-one mapping). I think PHF data structures will also always return a value. So if you look up an element not in the constructed PHF, you&#x27;ll always get a &quot;false positive&quot; value.<p>In contrast, a B-field lets you map a key to an arbitrary number of (typically non-unique) values. So I could map a million elements to &quot;1&quot;, another million to &quot;2&quot;, etc.<p>I&#x27;m not especially current (or fluent!) in that literature though, so would love pointers to anything that doesn&#x27;t have the above constraints.</div><br/><div id="40446650" class="c"><input type="checkbox" id="c-40446650" checked=""/><div class="controls bullet"><span class="by">pkhuong</span><span>|</span><a href="#40446399">root</a><span>|</span><a href="#40446621">parent</a><span>|</span><a href="#40444645">next</a><span>|</span><label class="collapse" for="c-40446650">[-]</label><label class="expand" for="c-40446650">[3 more]</label></div><br/><div class="children"><div class="content">The MWHC construction represents minimal (monotone!) perfect hash functions as arbitrary functions to the ceil(log(n)) bits needed to store the rank... where the value happens to be the rank, but could be anything.</div><br/><div id="40446712" class="c"><input type="checkbox" id="c-40446712" checked=""/><div class="controls bullet"><span class="by">boyd</span><span>|</span><a href="#40446399">root</a><span>|</span><a href="#40446650">parent</a><span>|</span><a href="#40444645">next</a><span>|</span><label class="collapse" for="c-40446712">[-]</label><label class="expand" for="c-40446712">[2 more]</label></div><br/><div class="children"><div class="content">... meaning it is an &quot;injective&quot; function that maps <i>unique</i> key-value pairs, correct? Genuinely asking, I have glancing familiarity via their use in assembly algorithms but (a) don&#x27;t have a formal math&#x2F;CS background; and (b) haven&#x27;t read any of the papers recently.</div><br/><div id="40446767" class="c"><input type="checkbox" id="c-40446767" checked=""/><div class="controls bullet"><span class="by">pkhuong</span><span>|</span><a href="#40446399">root</a><span>|</span><a href="#40446712">parent</a><span>|</span><a href="#40444645">next</a><span>|</span><label class="collapse" for="c-40446767">[-]</label><label class="expand" for="c-40446767">[1 more]</label></div><br/><div class="children"><div class="content">No, it doesn&#x27;t have to be injective. In theory, the range can be any group. It&#x27;s k bits in practice (with addition mod 2^k or xor as the group operator), but k need not have any relationship with `lg(|S|)`.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40444645" class="c"><input type="checkbox" id="c-40444645" checked=""/><div class="controls bullet"><span class="by">danking00</span><span>|</span><a href="#40446399">prev</a><span>|</span><a href="#40445053">next</a><span>|</span><label class="collapse" for="c-40444645">[-]</label><label class="expand" for="c-40444645">[3 more]</label></div><br/><div class="children"><div class="content">I think it might help readers to include a narrative about an example  application. Perhaps I’m in the minority but I tend to think of Bloom filters as a way to reliably know something <i>isn’t</i> in a set (e.g. so as to not run an expensive disk read). This data structure seems to view them the dual way: “this is maybe the right value for this key”.<p>I’ve seen that view work for visualizations like approximate CDFs and medians where I have some statement like “with probability p, the value differs from truth by less than e”. Is this data structure used in a similar way? My instinct is that visualizations having a low rate of being wrong is OK because the human will follow up that visualization with more tests. In the end you have lots of evidence supporting the conclusion.</div><br/><div id="40445685" class="c"><input type="checkbox" id="c-40445685" checked=""/><div class="controls bullet"><span class="by">boyd</span><span>|</span><a href="#40444645">parent</a><span>|</span><a href="#40445053">next</a><span>|</span><label class="collapse" for="c-40445685">[-]</label><label class="expand" for="c-40445685">[2 more]</label></div><br/><div class="children"><div class="content">Ah, we need to clarify the language! The B-field will <i>always return the correct value for an inserted key.</i><p>False positives are only returned for keys that have not been inserted. This is akin to a Bloom filter falsely returning that a key is in the set).</div><br/><div id="40446075" class="c"><input type="checkbox" id="c-40446075" checked=""/><div class="controls bullet"><span class="by">dpc_01234</span><span>|</span><a href="#40444645">root</a><span>|</span><a href="#40445685">parent</a><span>|</span><a href="#40445053">next</a><span>|</span><label class="collapse" for="c-40446075">[-]</label><label class="expand" for="c-40446075">[1 more]</label></div><br/><div class="children"><div class="content">I second that &quot;The B-field will always return the correct or Indeterminate value for an inserted key.&quot; before listing classes of errors would clarify it by a lot.</div><br/></div></div></div></div></div></div><div id="40445053" class="c"><input type="checkbox" id="c-40445053" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#40444645">prev</a><span>|</span><a href="#40446321">next</a><span>|</span><label class="collapse" for="c-40445053">[-]</label><label class="expand" for="c-40445053">[9 more]</label></div><br/><div class="children"><div class="content">Curious idea. So it’s for cases where you have any key but associated with one of only (preferably few) discrete values. I.E. your url example is great with url as a key but subpar if url were to be the value (padded to length n with trailing nulls encoded as a fixed width int array)?<p>With its interesting set of guarantees, I can’t see a case where you could use this unless you are 100% positive all keys have previously been inserted into the set, otherwise you risk getting a wrong value in return (instead of no value). A traditional bloom filter is similar but in the worst case you throw away work because you look up the determinative data&#x2F;value but here it’s a bit trickier.<p>Lots of applications tolerate missing results but significantly fewer can  tolerate “unknowingly incorrect” results.<p>Question about the implementation: I would have expected the primary interface to be in-memory with some api for disk spillover for large datasets but while all the docs say “designed for in-memory lookups” the rust api shows that you need to provide it with a temp directory to create the structure? (Also, fyi, you use temp::temp_file() but never actually use the result, instead using the hard-coded &#x2F;tmp path.)</div><br/><div id="40445351" class="c"><input type="checkbox" id="c-40445351" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#40445053">parent</a><span>|</span><a href="#40445733">next</a><span>|</span><label class="collapse" for="c-40445351">[-]</label><label class="expand" for="c-40445351">[5 more]</label></div><br/><div class="children"><div class="content">It seems like this would be most suitable for a system aggregating data. As long as you aggregate enough data points that the error averages out, it wouldn&#x27;t be an issue.<p>I guess another use case could be as any kind of &quot;hint&quot; where you need to do an authoritative lookup regardless of the filter lookup.<p>E.g., the file might be on this host, but you&#x27;ll need to reach the host and check for the file either way, so if you go to the wrong host sometimes, it&#x27;s not the end of the world.<p>That&#x27;s something that&#x27;s not possible with a bloom filter.<p>Seems like you could combine a shared static file and a host local cache to work around the errors as well (e.g., each host can cache whatever keys they&#x27;ve looked up that were wrong, but they can do LRU to get the best of both worlds (frequently accessed data is correct, while you can look up infrequent data with some chance of a miss).</div><br/><div id="40445641" class="c"><input type="checkbox" id="c-40445641" checked=""/><div class="controls bullet"><span class="by">boyd</span><span>|</span><a href="#40445053">root</a><span>|</span><a href="#40445351">parent</a><span>|</span><a href="#40445733">next</a><span>|</span><label class="collapse" for="c-40445641">[-]</label><label class="expand" for="c-40445641">[4 more]</label></div><br/><div class="children"><div class="content">I think those are both good examples of where you can manage the cost of a false positive.<p>In genomics, we&#x27;re using this to map a DNA substring (or &quot;k-mer&quot;) to a value. We can tolerate a very low error rate for those individual substrings, especially since any erroneous values will be random (vs. having the same or correlated values). So, with some simple threshold-based filtering, our false positive problem goes away.<p>Again, you&#x27;ll never get the incorrect value for a key <i>in the B-field</i>, only for a key not in the B-field (which can return a false positive with a low, tunable error rate).</div><br/><div id="40446232" class="c"><input type="checkbox" id="c-40446232" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#40445053">root</a><span>|</span><a href="#40445641">parent</a><span>|</span><a href="#40445733">next</a><span>|</span><label class="collapse" for="c-40446232">[-]</label><label class="expand" for="c-40446232">[3 more]</label></div><br/><div class="children"><div class="content">Yes, that makes sense.<p>Ooc, what do you think about the comparison to posting lists (aka bitmap indexes).<p>Some searching shows ML folks are also interested in compressing KV caches for models, so if your technique is applicable there you can probably find infinite funding :P</div><br/><div id="40446491" class="c"><input type="checkbox" id="c-40446491" checked=""/><div class="controls bullet"><span class="by">boyd</span><span>|</span><a href="#40445053">root</a><span>|</span><a href="#40446232">parent</a><span>|</span><a href="#40445733">next</a><span>|</span><label class="collapse" for="c-40446491">[-]</label><label class="expand" for="c-40446491">[2 more]</label></div><br/><div class="children"><div class="content">So a bitmap index requires a bit per unique value IIRC (plus the key and some amount of overhead). So for ~32 unique values you&#x27;re already at 4 bytes, 40 bytes per key-value pair for 320 values, etc.<p>In comparison, a B-field will let you store 32 distinct values at ~3.4 bytes (27 bits) per key-value pair at a 0.1% FP rate.</div><br/><div id="40448504" class="c"><input type="checkbox" id="c-40448504" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#40445053">root</a><span>|</span><a href="#40446491">parent</a><span>|</span><a href="#40445733">next</a><span>|</span><label class="collapse" for="c-40448504">[-]</label><label class="expand" for="c-40448504">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I&#x27;m not claiming that they&#x27;re going to perform as well, just that they&#x27;re sort of similar in the space of problems.<p>There&#x27;s different techniques used for compressing them, mostly around sorting the keys and e.g., run length encoding the values.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40445733" class="c"><input type="checkbox" id="c-40445733" checked=""/><div class="controls bullet"><span class="by">boyd</span><span>|</span><a href="#40445053">parent</a><span>|</span><a href="#40445351">prev</a><span>|</span><a href="#40445467">next</a><span>|</span><label class="collapse" for="c-40445733">[-]</label><label class="expand" for="c-40445733">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So it’s for cases where you have any key but associated with one of only (preferably few) discrete values<p>We use it for a case with ~million unique values, but it&#x27;s certainly more space efficient for cases where you have tens, hundreds, or thousands of values. The &quot;Space Requirements&quot; section has a few examples: <a href="https:&#x2F;&#x2F;github.com&#x2F;onecodex&#x2F;rust-bfield?tab=readme-ov-file#space-requirements">https:&#x2F;&#x2F;github.com&#x2F;onecodex&#x2F;rust-bfield?tab=readme-ov-file#s...</a> (e.g., you can store a key-value pair with 32 distinct values in ~27 bits of space at a 0.1% false positive rate).<p>&gt; all the docs say “designed for in-memory lookups”<p>We use mmap for persistence as our use case is largely a build-once, read many times one. As a practical matter, the data structure involves lots of random access, so is better suited to in-memory use from a speed POV.<p>&gt; fyi, you use temp::temp_file() but never actually use the result, instead using the hard-coded &#x2F;tmp path<p>Thank you, have opened an issue and we&#x27;ll fix it!</div><br/></div></div><div id="40445467" class="c"><input type="checkbox" id="c-40445467" checked=""/><div class="controls bullet"><span class="by">Buttons840</span><span>|</span><a href="#40445053">parent</a><span>|</span><a href="#40445733">prev</a><span>|</span><a href="#40446321">next</a><span>|</span><label class="collapse" for="c-40445467">[-]</label><label class="expand" for="c-40445467">[2 more]</label></div><br/><div class="children"><div class="content">Wonder if the error rate can be controlled?</div><br/><div id="40445665" class="c"><input type="checkbox" id="c-40445665" checked=""/><div class="controls bullet"><span class="by">boyd</span><span>|</span><a href="#40445053">root</a><span>|</span><a href="#40445467">parent</a><span>|</span><a href="#40446321">next</a><span>|</span><label class="collapse" for="c-40445665">[-]</label><label class="expand" for="c-40445665">[1 more]</label></div><br/><div class="children"><div class="content">Yes you can manage the error rate by controlling the overall size of the allocated bit array and several other parameters. There&#x27;s a (slightly obtuse) section on parameter selection here: <a href="https:&#x2F;&#x2F;github.com&#x2F;onecodex&#x2F;rust-bfield?tab=readme-ov-file#parameter-selection">https:&#x2F;&#x2F;github.com&#x2F;onecodex&#x2F;rust-bfield?tab=readme-ov-file#p...</a><p>And a Jupyter notebook example here: <a href="https:&#x2F;&#x2F;github.com&#x2F;onecodex&#x2F;rust-bfield&#x2F;blob&#x2F;main&#x2F;docs&#x2F;notebook&#x2F;calculate-parameters.ipynb">https:&#x2F;&#x2F;github.com&#x2F;onecodex&#x2F;rust-bfield&#x2F;blob&#x2F;main&#x2F;docs&#x2F;noteb...</a><p>We do need a better &quot;smart parameter selection&quot; method for instantiating a B-field on-the-fly.</div><br/></div></div></div></div></div></div><div id="40446321" class="c"><input type="checkbox" id="c-40446321" checked=""/><div class="controls bullet"><span class="by">judofyr</span><span>|</span><a href="#40445053">prev</a><span>|</span><a href="#40450099">next</a><span>|</span><label class="collapse" for="c-40446321">[-]</label><label class="expand" for="c-40446321">[5 more]</label></div><br/><div class="children"><div class="content">Very interesting and I&#x27;ll have to read more to understand how it fully works, but _initially_ the space requirements doesn&#x27;t seem too impressive? Am I missing something here? Is my calculation&#x2F;assumption completely off? Maybe the solution here is more flexible?<p>One alternative approach for many of these problems is to start with a perfect minimal hash function which hashes your key into a unique number [0, N) and then have a packed array of size N where each element is of a fixed byte size. To look up the value you first use the hash function to get an index, and then you look up in the packed array. There&#x27;s also no error rate here: This is exact.<p>PTHash (<a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2104.10402" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2104.10402</a>) needs roughly ~4 bits per element to create a perfect minimal hash function.<p>&gt; Store 1 billion web URLs and assign each of them one of a small number of categories values (n=8) in 2.22Gb (params include ν=8, κ=1, =0.1%; 19 bits per element)<p>Assuming that &quot;n=8&quot; here means &quot;8 bits&quot; we need 1GB (8 bits * billion) to represent all of the values, and then 500 MB for the hash function (4 bits * billion).<p>I also don&#x27;t quite understand what &quot;2.22Gb&quot; here refers to. 19 bits * billion = 2.357 SI-giga bytes = 19 SI-giga bits = 2.212 gibi bytes.<p>&gt; Store 1 billion DNA or RNA k-mers (&quot;ACGTA...&quot;) and associate them with any of the ~500k bacterial IDs current described by NCBI in 6.93Gb (ν=62, κ=4, =0.1%; 59 bits per element)<p>&quot;~500k bacterial ID&quot; can be represented with 19 bits. 1 billion of these take ~2.3GB, and then we have the additional 500MB for the perfect hash function.<p>Another data structure which is even more fine-tuned for this problem space is Bumped Ribbon Retrieval (<a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2109.01892" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2109.01892</a>) where they have &lt;1% overhead over just storing the plain bit values.<p>EDIT: Aha! One thing I forgot about: The alternatives I mentioned above all have a construction cost. I&#x27;ve been playing with them in the 100k-1M range and they&#x27;ve all been pretty instant (&lt;1s), but I don&#x27;t have any experience in the billion range. Maybe it&#x27;s too slow there?</div><br/><div id="40447933" class="c"><input type="checkbox" id="c-40447933" checked=""/><div class="controls bullet"><span class="by">c0deb0t</span><span>|</span><a href="#40446321">parent</a><span>|</span><a href="#40447942">next</a><span>|</span><label class="collapse" for="c-40447933">[-]</label><label class="expand" for="c-40447933">[2 more]</label></div><br/><div class="children"><div class="content">PTHash and other minimum perfect hash functions return an arbitrary value if the query key did not exist when building the MPHF, so they can be a lot smaller. B-field can identify query keys that don&#x27;t exist in the set (with high probability?).<p>What I&#x27;m wondering is why the Kraken2 probabilistic hash table doesn&#x27;t work. It uses 32 bits per element in an open addressing hash table. For 1 billion k-mers and 19 bits for the value, 32 - 19 = 13 bits of the key hash can be stored alongside the value, helping disambiguate hash collisions. If the load factor is 1.25x, then that&#x27;s 4 * 10^9 * 1.25 = 5GB total, better than ~7GB. Also, this is only one cache miss (+ linear probing that can be SIMD accelerated) per lookup.</div><br/><div id="40448696" class="c"><input type="checkbox" id="c-40448696" checked=""/><div class="controls bullet"><span class="by">boyd</span><span>|</span><a href="#40446321">root</a><span>|</span><a href="#40447933">parent</a><span>|</span><a href="#40447942">next</a><span>|</span><label class="collapse" for="c-40448696">[-]</label><label class="expand" for="c-40448696">[1 more]</label></div><br/><div class="children"><div class="content">&gt; PTHash and other minimum perfect hash functions return an arbitrary value if the query key did not exist when building the MPHF, so they can be a lot smaller. B-field can identify query keys that don&#x27;t exist in the set (with high probability?).<p>Yes, exactly.<p>&gt; What I&#x27;m wondering is why the Kraken2 probabilistic hash table doesn&#x27;t work.<p>I just <i>skimmed</i> the paper again (has been a while since a close reading), but my refreshed understanding is:<p>* Like the B-field, there are also false positives.<p>* When multiple hashed keys (k-mers) collide in the Kraken2 hash table, it has to store a &quot;reduced&quot; value for those key-value pairs. While there&#x27;s an elegant solution for this issue for the problem of taxonomic classification (lowest common ancestor), it still results in a loss of specificity. There&#x27;s a similar issue with &quot;indeterminate&quot; results in the B-field, but this rate can be reduced to ~0 with secondary arrays.<p>* The original Kraken2 paper describes using 17 bits for taxonomic IDs (~131K unique values). I don&#x27;t know how many tax IDs current Kraken2 DB builds use offhand, but the error rate climbs significantly as you use additional bits for the value vs. key (e.g., to represent &gt;=2^20 values, see Fig S4). I don&#x27;t have a good sense for the performance and other engineering tradeoffs of just extending the hash code &gt;32 bits. I also don&#x27;t know what the data structure overhead is beyond those &gt;32 bits&#x2F;pair.<p>So, for a metagenomics classifier <i>specifically</i>, some subtle tradeoffs but honestly database quality and the classification algorithm likely matters a lot more than the marginal FP rates with either data structure -- we just happen to have come to this solution.<p>For other applications, my sense is a B-field is generally going to be much more flexible (e.g., supporting arbitrary keys vs. a specific fixed-length encoding) but of course it depends on the specifics.</div><br/></div></div></div></div><div id="40448133" class="c"><input type="checkbox" id="c-40448133" checked=""/><div class="controls bullet"><span class="by">ricardobeat</span><span>|</span><a href="#40446321">parent</a><span>|</span><a href="#40447942">prev</a><span>|</span><a href="#40450099">next</a><span>|</span><label class="collapse" for="c-40448133">[-]</label><label class="expand" for="c-40448133">[1 more]</label></div><br/><div class="children"><div class="content">One huge downside of your suggested approach is that adding a single entry requires rebuilding the entire hash.</div><br/></div></div></div></div><div id="40450099" class="c"><input type="checkbox" id="c-40450099" checked=""/><div class="controls bullet"><span class="by">xvilka</span><span>|</span><a href="#40446321">prev</a><span>|</span><a href="#40451482">next</a><span>|</span><label class="collapse" for="c-40450099">[-]</label><label class="expand" for="c-40450099">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s another library unrelated to the data structure but is from the same field - an interval tree structure - Lapper[1][2]<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;sstadick&#x2F;rust-lapper">https:&#x2F;&#x2F;github.com&#x2F;sstadick&#x2F;rust-lapper</a><p>[2] <a href="https:&#x2F;&#x2F;docs.rs&#x2F;rust-lapper" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;rust-lapper</a></div><br/></div></div><div id="40451482" class="c"><input type="checkbox" id="c-40451482" checked=""/><div class="controls bullet"><span class="by">seffect</span><span>|</span><a href="#40450099">prev</a><span>|</span><a href="#40444925">next</a><span>|</span><label class="collapse" for="c-40451482">[-]</label><label class="expand" for="c-40451482">[1 more]</label></div><br/><div class="children"><div class="content">IIRC with a bloom filter if returns false you can be sure it is not in the set but if it returns true it probably is in the set but might be a clash giving a false positive?<p>Is the same true with this data structure.<p>I guess you could mitigate this by storing an additionally hash or the original key in it’s entirety as the value?</div><br/></div></div><div id="40444925" class="c"><input type="checkbox" id="c-40444925" checked=""/><div class="controls bullet"><span class="by">alexbowe</span><span>|</span><a href="#40451482">prev</a><span>|</span><a href="#40445756">next</a><span>|</span><label class="collapse" for="c-40444925">[-]</label><label class="expand" for="c-40444925">[2 more]</label></div><br/><div class="children"><div class="content">Interesting read, thanks for sharing!<p>If you have some benchmark results, it&#x27;d be great to see how it compares to traditional data structures in practice, for different datasets and varying k-mer lengths</div><br/><div id="40445753" class="c"><input type="checkbox" id="c-40445753" checked=""/><div class="controls bullet"><span class="by">boyd</span><span>|</span><a href="#40444925">parent</a><span>|</span><a href="#40445756">next</a><span>|</span><label class="collapse" for="c-40445753">[-]</label><label class="expand" for="c-40445753">[1 more]</label></div><br/><div class="children"><div class="content">Thank you! The &quot;Space Requirements&quot; section in the README has a few examples, and your comment has made me realize our (micro-)benchmark link in the README is broken.<p>We&#x27;ll get that fixed and maybe find the time to do a larger post with some benchmarks on both space&#x2F;time tradeoffs and overall performance vs. other data structures.</div><br/></div></div></div></div><div id="40445756" class="c"><input type="checkbox" id="c-40445756" checked=""/><div class="controls bullet"><span class="by">neutrinobro</span><span>|</span><a href="#40444925">prev</a><span>|</span><a href="#40445117">next</a><span>|</span><label class="collapse" for="c-40445756">[-]</label><label class="expand" for="c-40445756">[2 more]</label></div><br/><div class="children"><div class="content">Ughh...the term B-field already has a very strong association with magnetic fields. I&#x27;m sure it sounded like a good name given the context, but these types of name-collisions generally makes searching for a specific topic more and more painful each year.</div><br/><div id="40449021" class="c"><input type="checkbox" id="c-40449021" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#40445756">parent</a><span>|</span><a href="#40445117">next</a><span>|</span><label class="collapse" for="c-40449021">[-]</label><label class="expand" for="c-40449021">[1 more]</label></div><br/><div class="children"><div class="content">Old terms age out too, so it&#x27;s not that bad. In the context of ML, for example, &quot;generative models&quot; meant something else twenty years ago. Nobody who&#x27;s got into ML recently would even know what the old meaning is.</div><br/></div></div></div></div><div id="40445117" class="c"><input type="checkbox" id="c-40445117" checked=""/><div class="controls bullet"><span class="by">vslira</span><span>|</span><a href="#40445756">prev</a><span>|</span><a href="#40445377">next</a><span>|</span><label class="collapse" for="c-40445117">[-]</label><label class="expand" for="c-40445117">[1 more]</label></div><br/><div class="children"><div class="content">Great work, thanks for sharing!<p>In a somewhat tangent note, does anyone have a good resource for designing probabilistic data structures? At a high level, I&#x27;m looking for something that helps me understand what is and isn&#x27;t feasible and, given a problem and constraints, how would I go on to design a specific DS for a problem. Doesn&#x27;t need to be all that general, but something that is more than an analysis of existing structures</div><br/></div></div><div id="40445377" class="c"><input type="checkbox" id="c-40445377" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#40445117">prev</a><span>|</span><a href="#40449838">next</a><span>|</span><label class="collapse" for="c-40445377">[-]</label><label class="expand" for="c-40445377">[2 more]</label></div><br/><div class="children"><div class="content">I wonder... The comparison here is against a bloom filter, but is this actually more similar to a sketch?<p>Or... Actually this is sort of like a posting list (e.g., a list of places that a given document appears: <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Inverted_index" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Inverted_index</a>)</div><br/><div id="40447289" class="c"><input type="checkbox" id="c-40447289" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#40445377">parent</a><span>|</span><a href="#40449838">next</a><span>|</span><label class="collapse" for="c-40447289">[-]</label><label class="expand" for="c-40447289">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a probabilistic associative array. A better benchmark is a Bloomier filter: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bloom_filter#Bloomier_filters" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bloom_filter#Bloomier_filters</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>