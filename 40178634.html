<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1714381266442" as="style"/><link rel="stylesheet" href="styles.css?v=1714381266442"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.figma.com/blog/speeding-up-build-times/">Speeding up C++ build times</a> <span class="domain">(<a href="https://www.figma.com">www.figma.com</a>)</span></div><div class="subtext"><span>skilled</span> | <span>126 comments</span></div><br/><div><div id="40192643" class="c"><input type="checkbox" id="c-40192643" checked=""/><div class="controls bullet"><span class="by">kjksf</span><span>|</span><a href="#40196009">next</a><span>|</span><label class="collapse" for="c-40192643">[-]</label><label class="expand" for="c-40192643">[35 more]</label></div><br/><div class="children"><div class="content">I wrote about how I keep build times sane in SumatraPDF at <a href="https:&#x2F;&#x2F;blog.kowalczyk.info&#x2F;article&#x2F;96a4706ec8e44bc4b0bafda2d9ba502f&#x2F;extreme-include-discipline-for-c-code.html" rel="nofollow">https:&#x2F;&#x2F;blog.kowalczyk.info&#x2F;article&#x2F;96a4706ec8e44bc4b0bafda2...</a><p>The idea is the same: reduce the duplicate parsing of .h files.<p>I don&#x27;t use any tools, just a hard-core discipline of only #include&#x27;ing .h in .cpp files.<p>The problem is that if you start #include&#x27;ing .h in .h, you quickly start introducing duplication that is intractable, for a human, to avoid.<p>On another note: C++ compiler should by default keep statistics about the chain of #include&#x27;s &#x2F; parsing during compilation and dump it to a file at the end and also summarize how badly you&#x27;re re-parsing the same .h files during build.<p>That info would help people remove redundant #include&#x27;s.<p>But of course even if they do have such options, you have to turn on some flags and they&#x27;ll spam your build output instead of writing to a file.</div><br/><div id="40194136" class="c"><input type="checkbox" id="c-40194136" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40192643">parent</a><span>|</span><a href="#40193006">next</a><span>|</span><label class="collapse" for="c-40194136">[-]</label><label class="expand" for="c-40194136">[9 more]</label></div><br/><div class="children"><div class="content">Having written, benchmarked, and maintained C and C++ compilers for decades, I know why the compiles are slow:<p>1. phases of translation<p>2. constant rescanning and reparsing of .h files<p>3. cannot parse without doing semantic analysis<p>4. the preprocessor has its own tokens - so you gotta tokenize the .h file, do the preprocessing, convert it back to text, then tokenize the text again with the C&#x2F;C++ compiler. This is madness. (Although with the C compiler I did manage to merge the preprocessor lexer with the compiler lexer, this made it the speed champ.)<p>This experience fed into D which:<p>1. uses modules instead of .h files. No matter how many times a module is imported, it is lexed&#x2F;parsed&#x2F;semanticed exactly once.<p>2. module semantics are independent of who&#x2F;what imports them<p>3. no phases of translation<p>4. lexing and parsing is independent of semantic analysis</div><br/><div id="40194379" class="c"><input type="checkbox" id="c-40194379" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40194136">parent</a><span>|</span><a href="#40195623">next</a><span>|</span><label class="collapse" for="c-40194379">[-]</label><label class="expand" for="c-40194379">[7 more]</label></div><br/><div class="children"><div class="content">Having done some casual benchmarking <i>recently</i>, I found that GCC is about 15 times slower when optimizing than when not. In both situations, the compiler is scanning the same header files, so that activity is bound up within the 1&#x2F;15th of the optimized compilation time.<p>It used to be a common wisdom that the character-level processing of code took the most time. Just like the old floating-point is slow; always use integer when possible.<p>Also note that the <i>ccache</i> tool greatly speeds up C and C++ builds. Yet, the input to <i>ccache</i> is the preprocessed translation unit! When you&#x27;re using <i>ccache</i>, none of the preprocessing is skipped.  <i>ccache</i> hashes the preprocesed translation unit (plus compiler command line options and the path of the compiler executable and such) in an intelligent way and the checks its cache. If there is a hit, it pulls the .o out of its cache, otherwise it invokes the compiler on the preprocessed translation unit.<p>If most of the time were spent in preprocessing, a much more modest speedup would be observed with ccache.</div><br/><div id="40195583" class="c"><input type="checkbox" id="c-40195583" checked=""/><div class="controls bullet"><span class="by">taylorius</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40194379">parent</a><span>|</span><a href="#40194630">next</a><span>|</span><label class="collapse" for="c-40195583">[-]</label><label class="expand" for="c-40195583">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Just like the old floating-point is slow; always use integer when possible.&quot;<p>I know this was only an aside - but it took me the longest time to properly internalize that floats were fast these days. I&#x27;m still getting used to the idea that double precision isn&#x27;t a preposterous extravagance. :D</div><br/><div id="40196035" class="c"><input type="checkbox" id="c-40196035" checked=""/><div class="controls bullet"><span class="by">Arech</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40195583">parent</a><span>|</span><a href="#40194630">next</a><span>|</span><label class="collapse" for="c-40196035">[-]</label><label class="expand" for="c-40196035">[2 more]</label></div><br/><div class="children"><div class="content">It depends on what you&#x27;re doing. Doubles are still slower than floats due to twice bigger requirements imposed on memory performance &amp; cache size. So if you doing a &quot;calculator&quot; style of work, there&#x27;s not much difference, but if you&#x27;re processing large arrays of data, it&#x27;s still something you should think of.</div><br/><div id="40196136" class="c"><input type="checkbox" id="c-40196136" checked=""/><div class="controls bullet"><span class="by">taylorius</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40196035">parent</a><span>|</span><a href="#40194630">next</a><span>|</span><label class="collapse" for="c-40196136">[-]</label><label class="expand" for="c-40196136">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, exactly that. I was getting artifacts processing long vectors, and it was 32 bit float precision that was the culprit.</div><br/></div></div></div></div></div></div><div id="40194630" class="c"><input type="checkbox" id="c-40194630" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40194379">parent</a><span>|</span><a href="#40195583">prev</a><span>|</span><a href="#40195623">next</a><span>|</span><label class="collapse" for="c-40194630">[-]</label><label class="expand" for="c-40194630">[3 more]</label></div><br/><div class="children"><div class="content">Generally when benchmarking compile speeds, the unoptimized build is used, as that is the edit-compile-debug loop. It&#x27;s always been true that a good optimizer will dominate the build times.<p>Back in the Bronze Age (1990s) I endeavored to speed up compilation in a manner that you describe ccache as doing. After the .h files were taken care of, the compiler would roll out to disk the state of the compiler. (It could also do this with individual .h files.) Then, instead of doing all the .h files again, it would just memory map in the precompiled .h file.<p>And yes, it resulted in a dramatic improvement in compile times, as you describe.<p>The downside was one had to be extremely careful about compiling the .h files the same way each time. One difference could affect the path through the .h files, and invalidate the precompiled version.<p>It was quite a lot of careful work to make that work, and I expect ccache is also a complex piece of work.<p>What I learned from that is it&#x27;s easier to just fix the language so none of that is necessary. C&#x2F;C++ can be so fixed, the proof is ImportC, a C compiler that can use imports instead of .h files, and can compile multiple .c files in one invocation and merge them into a single .o file.</div><br/><div id="40195307" class="c"><input type="checkbox" id="c-40195307" checked=""/><div class="controls bullet"><span class="by">SleepyMyroslav</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40194630">parent</a><span>|</span><a href="#40195623">next</a><span>|</span><label class="collapse" for="c-40195307">[-]</label><label class="expand" for="c-40195307">[2 more]</label></div><br/><div class="children"><div class="content">There is a reason of why<p>&gt; unoptimized build is used, as that is the edit-compile-debug loop<p>is no longer true.<p>Modern C++ has a lot of metaprogramming abstractions in it and they are no cost only in optimized builds.<p>In my years of gamedev work I have not met a sizeable project that was working in unoptimized builds even for debug purposes. Unoptimized only worked in unit tests or small tools.</div><br/><div id="40195951" class="c"><input type="checkbox" id="c-40195951" checked=""/><div class="controls bullet"><span class="by">59nadir</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40195307">parent</a><span>|</span><a href="#40195623">next</a><span>|</span><label class="collapse" for="c-40195951">[-]</label><label class="expand" for="c-40195951">[1 more]</label></div><br/><div class="children"><div class="content">I think at that point the real solution is to seriously consider all of the language constructs you use and their compile times as well. It&#x27;s not a given that using more of C++ is always better and real, sustainable change in compile times can be had by moving more and more towards C in many ways but keeping some of the safety C++ provides.<p>(I&#x27;m sure you&#x27;ve been there, though; gamedev is one of the areas I would expect people to be more sensible about their C++ feature usage in.)</div><br/></div></div></div></div></div></div></div></div><div id="40195623" class="c"><input type="checkbox" id="c-40195623" checked=""/><div class="controls bullet"><span class="by">zerr</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40194136">parent</a><span>|</span><a href="#40194379">prev</a><span>|</span><a href="#40193006">next</a><span>|</span><label class="collapse" for="c-40195623">[-]</label><label class="expand" for="c-40195623">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t `#pragma once` helpful for avoiding reparsing headers?</div><br/></div></div></div></div><div id="40193006" class="c"><input type="checkbox" id="c-40193006" checked=""/><div class="controls bullet"><span class="by">Maxatar</span><span>|</span><a href="#40192643">parent</a><span>|</span><a href="#40194136">prev</a><span>|</span><a href="#40194352">next</a><span>|</span><label class="collapse" for="c-40193006">[-]</label><label class="expand" for="c-40193006">[7 more]</label></div><br/><div class="children"><div class="content">&gt;On another note: C++ compiler should by default keep statistics about the chain of #include&#x27;s &#x2F; parsing during compilation and dump it to a file at the end and also summarize how badly you&#x27;re re-parsing the same .h files during build.<p>Clang does offer something very close to this, and if you use it you&#x27;ll find parsing the same&#x2F;duplicate header files contributes on the order of microseconds to the overall compile time. Your article is from 1989, which is likely before compilers implemented duplicate header file elimination [1], but nowadays all C++ compilers optimize the common #ifndef&#x2F;#define header guard as well as #pragma once so that they entirely ignore parsing the same file over and over again.<p>[1] <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;cpp&#x2F;Once-Only-Headers.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;cpp&#x2F;Once-Only-Headers.html</a></div><br/><div id="40194141" class="c"><input type="checkbox" id="c-40194141" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40193006">parent</a><span>|</span><a href="#40194352">next</a><span>|</span><label class="collapse" for="c-40194141">[-]</label><label class="expand" for="c-40194141">[6 more]</label></div><br/><div class="children"><div class="content">True, but when you&#x27;re compiling a.c and then b.c, the .h files get reparsed all over again.</div><br/><div id="40194433" class="c"><input type="checkbox" id="c-40194433" checked=""/><div class="controls bullet"><span class="by">highfrequency</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40194141">parent</a><span>|</span><a href="#40194411">next</a><span>|</span><label class="collapse" for="c-40194433">[-]</label><label class="expand" for="c-40194433">[2 more]</label></div><br/><div class="children"><div class="content">Correct me if I&#x27;m wrong, but I believe the parent comment&#x27;s strategy of only #including header files within .c files only helps reduce duplicate header file parsing within each compilation unit. So it wouldn&#x27;t do anything to improve the case you mention (duplicate header compilation across compilation units) anyway, while adding much additional overhead in manually tracking header file dependencies.<p>Also, given your experience in compilers - keen to see if you agree that because modern compilers optimize away re-scanning of the same header file within a compilation unit anyway (in the presence of include guards), the strategy of only #including header files within .c files is close to useless.</div><br/><div id="40194650" class="c"><input type="checkbox" id="c-40194650" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40194433">parent</a><span>|</span><a href="#40194411">next</a><span>|</span><label class="collapse" for="c-40194650">[-]</label><label class="expand" for="c-40194650">[1 more]</label></div><br/><div class="children"><div class="content">The not rescanning if the #include guards are there goes back to the mid 1980s. It&#x27;s not a modern feature :-)<p>&gt; the strategy of only #including header files within .c files is close to useless<p>It probably is. It also means the user of the .h file has to manage the .h file&#x27;s dependencies, which is not the best practice. .h files should be self-contained.</div><br/></div></div></div></div><div id="40194411" class="c"><input type="checkbox" id="c-40194411" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40194141">parent</a><span>|</span><a href="#40194433">prev</a><span>|</span><a href="#40194392">next</a><span>|</span><label class="collapse" for="c-40194411">[-]</label><label class="expand" for="c-40194411">[2 more]</label></div><br/><div class="children"><div class="content">This is not only not true, but not possible. Many kind sof defintiions in .h files <i>may not</i> be repeated without error, like:<p><pre><code>  struct foo { int bar; };
</code></pre>
or<p><pre><code>  typedef int xyzzy_t;

</code></pre>
This is why you have include guards:<p><pre><code>  #ifndef FOO_H_3DF0_755A
  #define FOO_H_3DF0_755A

  struct foo { int bar; }

  #endif
</code></pre>
GCC optimized the handling of headers with include guards 30 years ago already.<p>If you think most of your compile time is spent in preprocessing, benchmark a clean build with the optimization set to -O0 versus your full optimization like -O2 or whatever you are using.<p>Both builds perform preprocessing; thus the preprocessing time is bounded by the total time spent in the -O0 build: if the actual semantic analysis of tokens and code generation at -O0 were to take next to no time at all, then we would have to attribute the time to tokenizing and preprocessing. But even then, all the additional time observed under -O2 is <i>not</i> tokenizing and preprocessing.</div><br/><div id="40194547" class="c"><input type="checkbox" id="c-40194547" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40194411">parent</a><span>|</span><a href="#40194392">next</a><span>|</span><label class="collapse" for="c-40194547">[-]</label><label class="expand" for="c-40194547">[1 more]</label></div><br/><div class="children"><div class="content">Um, I think there is a misunderstanding.<p><pre><code>    gcc -c a.c
    gcc -c b.c
</code></pre>
requires reparsing of the .h files used by both.</div><br/></div></div></div></div></div></div></div></div><div id="40194352" class="c"><input type="checkbox" id="c-40194352" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40192643">parent</a><span>|</span><a href="#40193006">prev</a><span>|</span><a href="#40194364">next</a><span>|</span><label class="collapse" for="c-40194352">[-]</label><label class="expand" for="c-40194352">[1 more]</label></div><br/><div class="children"><div class="content">In modern compilers, the scanning of tokens is a tiny fraction of the compile time.<p>If the header files are properly protected with inclusion guards, then at worst the contents are tokenized by the preprocessor, and not seen by anything else.
But for decades now, compilers have been smart enough to recognize include guards 
and not actually open the file. So that is to say, when the compiler has seen a file of this form  once:<p><pre><code>  #ifndef FOO
  #define FOO
  ...
  #endif
</code></pre>
and is asked to #include that same file again, it knows that this file is guarded by FOO. If FOO exists, it won&#x27;t even open that file.<p>There are reasons to avoid including .h files in .h files, but you&#x27;re not going to get compile time gains out of it, other than perhaps through secondary effects.<p>By secondary effects I mean this: when in a project you forbid .h files including other .h files, it hurts to add new dependencies into header files. When you change a header such that it needs some definition in another, you have to go into every .cpp file and add the #include.  So, you find ways to reduce the dependencies to avoid doing that.<p>When .h files are allowed to include others, the dependencies grow rampant. You want to compile a little banana, but it depends on the gorilla, which needs the whole jungle, just to be defined. Juggling the jungle definition takes a bit of time. C++ definitions are complicated, requiring lots of processing to develop. Not as much as optimizing the banana that is the actual subject being compiled to code, but not as little as skipping header files.</div><br/></div></div><div id="40194364" class="c"><input type="checkbox" id="c-40194364" checked=""/><div class="controls bullet"><span class="by">highfrequency</span><span>|</span><a href="#40192643">parent</a><span>|</span><a href="#40194352">prev</a><span>|</span><a href="#40193477">next</a><span>|</span><label class="collapse" for="c-40194364">[-]</label><label class="expand" for="c-40194364">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We try to mitigate it with #ifdef guards, #pragma once etc. but in my experience those band-aids don’t solve the problem.<p>Why don&#x27;t include guards solve the problem of duplicate parsing of .h files within one compilation unit? I believe modern compilers can entirely optimize away even the opening and scanning of the file. And even without that, modern NVMe disks are so fast I would imagine the file opens would be negligible.<p>Curious to hear if anyone has data on whether duplicate header file parsing is still an actual performance issue even with modern compilers, modern SSDs, and #pragma once.</div><br/></div></div><div id="40193477" class="c"><input type="checkbox" id="c-40193477" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40192643">parent</a><span>|</span><a href="#40194364">prev</a><span>|</span><a href="#40195782">next</a><span>|</span><label class="collapse" for="c-40193477">[-]</label><label class="expand" for="c-40193477">[1 more]</label></div><br/><div class="children"><div class="content">As much as I hate long compilation times, I also value code discoverability, readability, and consistency. Your (i.e., Rob Pike’s) strategy seems like a nightmare to me. I love Rob, but I can’t follow this rule.</div><br/></div></div><div id="40195782" class="c"><input type="checkbox" id="c-40195782" checked=""/><div class="controls bullet"><span class="by">timvdalen</span><span>|</span><a href="#40192643">parent</a><span>|</span><a href="#40193477">prev</a><span>|</span><a href="#40195809">next</a><span>|</span><label class="collapse" for="c-40195782">[-]</label><label class="expand" for="c-40195782">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for building SumatraPDF! I just switched away from Windows, but I&#x27;ve been a happy user for a very long time, and it&#x27;s hard to get that mix of user experience just right. Really appreciate your work.</div><br/></div></div><div id="40195809" class="c"><input type="checkbox" id="c-40195809" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#40192643">parent</a><span>|</span><a href="#40195782">prev</a><span>|</span><a href="#40192941">next</a><span>|</span><label class="collapse" for="c-40195809">[-]</label><label class="expand" for="c-40195809">[2 more]</label></div><br/><div class="children"><div class="content">The entire article&#x27;s premise is misguided as slow C++ build times are usually a result of inexperienced SWEs unfamiliar with the language&#x27;s &quot;fun&quot; build rules.</div><br/><div id="40196062" class="c"><input type="checkbox" id="c-40196062" checked=""/><div class="controls bullet"><span class="by">Arech</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40195809">parent</a><span>|</span><a href="#40192941">next</a><span>|</span><label class="collapse" for="c-40196062">[-]</label><label class="expand" for="c-40196062">[1 more]</label></div><br/><div class="children"><div class="content">In enterprise you are almost always under a pressure to deliver something asap, so some bad practices are just a natural consequence of that. They could have liked to do it differently, but then they would only be half way to delivering what they have already shipped. There are always tradeoffs.</div><br/></div></div></div></div><div id="40192941" class="c"><input type="checkbox" id="c-40192941" checked=""/><div class="controls bullet"><span class="by">electroly</span><span>|</span><a href="#40192643">parent</a><span>|</span><a href="#40195809">prev</a><span>|</span><a href="#40194699">next</a><span>|</span><label class="collapse" for="c-40192941">[-]</label><label class="expand" for="c-40192941">[1 more]</label></div><br/><div class="children"><div class="content">If you use a &quot;unity&quot; build (all .cpp files concatenated into one compilation unit) with the normal &#x27;#pragma once&#x27; or guard in the headers, then you can be certain that every header file is parsed only once, with no discipline needed. CMake can do this for you with an option. You lose the ability to do incremental builds of individual changed files, but it may be fast enough that you don&#x27;t care.<p>For my own personal projects, I just use ccache and precompiled headers. It&#x27;s good enough for me. I don&#x27;t want to have to apply &quot;hard-core discipline&quot; to my projects.</div><br/></div></div><div id="40194699" class="c"><input type="checkbox" id="c-40194699" checked=""/><div class="controls bullet"><span class="by">greenavocado</span><span>|</span><a href="#40192643">parent</a><span>|</span><a href="#40192941">prev</a><span>|</span><a href="#40192893">next</a><span>|</span><label class="collapse" for="c-40194699">[-]</label><label class="expand" for="c-40194699">[4 more]</label></div><br/><div class="children"><div class="content">Only a handful of commenters have mentioned &quot;#pragma once&quot;, which is alarmingly few people considering how many C++ practitioners are out there. &quot;#pragma once&quot; is the obvious way to deal with this problem.</div><br/><div id="40195315" class="c"><input type="checkbox" id="c-40195315" checked=""/><div class="controls bullet"><span class="by">Arech</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40194699">parent</a><span>|</span><a href="#40192893">next</a><span>|</span><label class="collapse" for="c-40195315">[-]</label><label class="expand" for="c-40195315">[3 more]</label></div><br/><div class="children"><div class="content">`#pragma once` isn&#x27;t standardized. Even though all major modern compilers do support it (hopefully, but not guaranteed in the same way), if you care about portability to some not even very esoteric platform, it most likely uses ancient compilers (or based on ancient version of a major compiler) that might not support it.
But besides that I too don&#x27;t see a reason why not use a better `#pragma once` instead if include guards...</div><br/><div id="40195453" class="c"><input type="checkbox" id="c-40195453" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40195315">parent</a><span>|</span><a href="#40192893">next</a><span>|</span><label class="collapse" for="c-40195453">[-]</label><label class="expand" for="c-40195453">[2 more]</label></div><br/><div class="children"><div class="content">Pragma once is a defacto standard and is supported by every compiler and platform you’re ever going to work with. If you need to support the targets it doesn’t work with, then you’ll get a loud compile error.<p>The old include guards are error prone, requiring a unique key per header. Getting that wrong can cause anything from a compile error, an obtuse linker error, or a runtime bug depending on what’s in the header.<p>The chances of someone copy pasting a header and breaking the include guard are significantly higher than the chances of someone deciding that we need to support an esoteric embedded target overnight.</div><br/><div id="40195740" class="c"><input type="checkbox" id="c-40195740" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40195453">parent</a><span>|</span><a href="#40192893">next</a><span>|</span><label class="collapse" for="c-40195740">[-]</label><label class="expand" for="c-40195740">[1 more]</label></div><br/><div class="children"><div class="content">This. #pragma once is more consistently supported than many parts of the standard. Just use it. (And I&#x27;ve worked with some of those esoteric embedded targets. Haven&#x27;t run into a compiler that didn&#x27;t support it yet)</div><br/></div></div></div></div></div></div></div></div><div id="40192893" class="c"><input type="checkbox" id="c-40192893" checked=""/><div class="controls bullet"><span class="by">johannes1234321</span><span>|</span><a href="#40192643">parent</a><span>|</span><a href="#40194699">prev</a><span>|</span><a href="#40194025">next</a><span>|</span><label class="collapse" for="c-40192893">[-]</label><label class="expand" for="c-40192893">[2 more]</label></div><br/><div class="children"><div class="content">&gt; On another note: C++ compiler should by default keep statistics about the chain of #include&#x27;s &#x2F; parsing during compilation and dump it to a file at the end and also summarize how badly you&#x27;re re-parsing the same .h files during build.<p>Not exactly that, but do you know clang&#x27;s -ftime-trace and tools like <a href="https:&#x2F;&#x2F;github.com&#x2F;aras-p&#x2F;ClangBuildAnalyzer">https:&#x2F;&#x2F;github.com&#x2F;aras-p&#x2F;ClangBuildAnalyzer</a> which help analyzing where time is actually spent? (In small repeated headers I don&#x27;t see much of a problem, but they of course may contain not so small things ...)</div><br/><div id="40194936" class="c"><input type="checkbox" id="c-40194936" checked=""/><div class="controls bullet"><span class="by">touisteur</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40192893">parent</a><span>|</span><a href="#40194025">next</a><span>|</span><label class="collapse" for="c-40194936">[-]</label><label class="expand" for="c-40194936">[1 more]</label></div><br/><div class="children"><div class="content">Any idea whether gcc is roadmapping including this?</div><br/></div></div></div></div><div id="40194025" class="c"><input type="checkbox" id="c-40194025" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40192643">parent</a><span>|</span><a href="#40192893">prev</a><span>|</span><a href="#40193773">next</a><span>|</span><label class="collapse" for="c-40194025">[-]</label><label class="expand" for="c-40194025">[1 more]</label></div><br/><div class="children"><div class="content">Oh, the joys of using a language that thinks (automated) copy-and-paste coding is the same as a module system.</div><br/></div></div><div id="40193773" class="c"><input type="checkbox" id="c-40193773" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#40192643">parent</a><span>|</span><a href="#40194025">prev</a><span>|</span><a href="#40192735">next</a><span>|</span><label class="collapse" for="c-40193773">[-]</label><label class="expand" for="c-40193773">[1 more]</label></div><br/><div class="children"><div class="content">Shouldn&#x27;t precompiled headers mitigate that?</div><br/></div></div><div id="40192735" class="c"><input type="checkbox" id="c-40192735" checked=""/><div class="controls bullet"><span class="by">sfpotter</span><span>|</span><a href="#40192643">parent</a><span>|</span><a href="#40193773">prev</a><span>|</span><a href="#40196009">next</a><span>|</span><label class="collapse" for="c-40192735">[-]</label><label class="expand" for="c-40192735">[3 more]</label></div><br/><div class="children"><div class="content">How much of a speedup did you get switching over to Rob Pike style includes?</div><br/><div id="40192999" class="c"><input type="checkbox" id="c-40192999" checked=""/><div class="controls bullet"><span class="by">cpeterso</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40192735">parent</a><span>|</span><a href="#40196009">next</a><span>|</span><label class="collapse" for="c-40192999">[-]</label><label class="expand" for="c-40192999">[2 more]</label></div><br/><div class="children"><div class="content">I had to look this up:<p>Rob Pike’s rule is that header files should not include other header files; they should only document which other header files they depend on so programmers can directly include those other header files in their .c files.<p><a href="https:&#x2F;&#x2F;bytes.com&#x2F;topic&#x2F;c&#x2F;answers&#x2F;217074-rob-pikes-simple-include-rule" rel="nofollow">https:&#x2F;&#x2F;bytes.com&#x2F;topic&#x2F;c&#x2F;answers&#x2F;217074-rob-pikes-simple-in...</a></div><br/><div id="40195147" class="c"><input type="checkbox" id="c-40195147" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#40192643">root</a><span>|</span><a href="#40192999">parent</a><span>|</span><a href="#40196009">next</a><span>|</span><label class="collapse" for="c-40195147">[-]</label><label class="expand" for="c-40195147">[1 more]</label></div><br/><div class="children"><div class="content">This seems like the kind of thing that a compiler should be good at instead of making the user jump through hoops.</div><br/></div></div></div></div></div></div></div></div><div id="40196009" class="c"><input type="checkbox" id="c-40196009" checked=""/><div class="controls bullet"><span class="by">saidinesh5</span><span>|</span><a href="#40192643">prev</a><span>|</span><a href="#40195561">next</a><span>|</span><label class="collapse" for="c-40196009">[-]</label><label class="expand" for="c-40196009">[1 more]</label></div><br/><div class="children"><div class="content">Funnily enough, this topic was all they asked in one of the job interviews I had when I was younger.. they shared a bunch of sources files and asked me where&#x2F;what I could do to improve the compilation speeds.<p>I didn&#x27;t realize how big the impact of these little changes were (only include what you use, forward declare as much as you can, PIMPL etc..) until I worked on a large codebase in that company.</div><br/></div></div><div id="40195561" class="c"><input type="checkbox" id="c-40195561" checked=""/><div class="controls bullet"><span class="by">pietroppeter</span><span>|</span><a href="#40196009">prev</a><span>|</span><a href="#40192680">next</a><span>|</span><label class="collapse" for="c-40195561">[-]</label><label class="expand" for="c-40195561">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It is written purely in Python and does not use Clang, which makes it fast to run—usually in just a couple of seconds.<p>Oh, the irony</div><br/><div id="40195795" class="c"><input type="checkbox" id="c-40195795" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#40195561">parent</a><span>|</span><a href="#40192680">next</a><span>|</span><label class="collapse" for="c-40195795">[-]</label><label class="expand" for="c-40195795">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, reading this article is supposed to promote Figma&#x27;s engineering team for &#x27;solving&#x27; a solved problem: it does quite the opposite.</div><br/></div></div></div></div><div id="40192680" class="c"><input type="checkbox" id="c-40192680" checked=""/><div class="controls bullet"><span class="by">petermcneeley</span><span>|</span><a href="#40195561">prev</a><span>|</span><a href="#40195693">next</a><span>|</span><label class="collapse" for="c-40192680">[-]</label><label class="expand" for="c-40192680">[9 more]</label></div><br/><div class="children"><div class="content">The video game industry uses bulk builds (master files) which groups all .cc s into very large single .cc files.  The speedups here are like 5-10x at least. These bulk files are sent to other developers machines with possible caching. The result is 12 min builds instead of 6 hours.</div><br/><div id="40193712" class="c"><input type="checkbox" id="c-40193712" checked=""/><div class="controls bullet"><span class="by">shanemhansen</span><span>|</span><a href="#40192680">parent</a><span>|</span><a href="#40194158">next</a><span>|</span><label class="collapse" for="c-40193712">[-]</label><label class="expand" for="c-40193712">[1 more]</label></div><br/><div class="children"><div class="content">Chrome supported this for a long time and it really helped small developers outside of Google be able to build chrome without specialist machines.<p>But that feature was pulled by the chrome team with the stated justification being that since C++ guaranteed different things (iirc around variable scopes outside of a namespace) for one file vs multiple files, supporting the jumbo build option meant writing some language that was &quot;not C++&quot;.<p>Unfortunate.</div><br/></div></div><div id="40194158" class="c"><input type="checkbox" id="c-40194158" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40192680">parent</a><span>|</span><a href="#40193712">prev</a><span>|</span><a href="#40193884">next</a><span>|</span><label class="collapse" for="c-40194158">[-]</label><label class="expand" for="c-40194158">[1 more]</label></div><br/><div class="children"><div class="content">How it works with D is you can do separate compilation:<p><pre><code>    dmd -c a.d
    dmd -c b.d
    dmd a.o b.o
</code></pre>
or do it all in one go:<p><pre><code>    dmd a.d b.d
</code></pre>
Over time, the latter became the preferred method. With it, the compiler generates one large .o file for a.d and b.d, more or less creating a &quot;pre-linked&quot; object file. This also means lots of inlining opportunities are present without needing linker support for intermodule inlining.</div><br/></div></div><div id="40193884" class="c"><input type="checkbox" id="c-40193884" checked=""/><div class="controls bullet"><span class="by">celrod</span><span>|</span><a href="#40192680">parent</a><span>|</span><a href="#40194158">prev</a><span>|</span><a href="#40194589">next</a><span>|</span><label class="collapse" for="c-40193884">[-]</label><label class="expand" for="c-40193884">[1 more]</label></div><br/><div class="children"><div class="content">If using cmake, you can try a unity build. <a href="https:&#x2F;&#x2F;cmake.org&#x2F;cmake&#x2F;help&#x2F;latest&#x2F;prop_tgt&#x2F;UNITY_BUILD.html" rel="nofollow">https:&#x2F;&#x2F;cmake.org&#x2F;cmake&#x2F;help&#x2F;latest&#x2F;prop_tgt&#x2F;UNITY_BUILD.htm...</a><p>You can also specify a `-DUNITY_BUILD_BATCH_SIZE` to control how many get grouped, so you can still get some parallelism.
However, I think it&#x27;d be more natural to be able to specify number of batches (e.g. `nproc`) than their size.<p>Code bases may need some updating to work.</div><br/></div></div><div id="40194589" class="c"><input type="checkbox" id="c-40194589" checked=""/><div class="controls bullet"><span class="by">Twirrim</span><span>|</span><a href="#40192680">parent</a><span>|</span><a href="#40193884">prev</a><span>|</span><a href="#40193311">next</a><span>|</span><label class="collapse" for="c-40194589">[-]</label><label class="expand" for="c-40194589">[1 more]</label></div><br/><div class="children"><div class="content">sqlite uses something like this approach too, and there are additional optimisation advantages from keeping everything in a single file:<p><a href="https:&#x2F;&#x2F;sqlite.org&#x2F;amalgamation.html" rel="nofollow">https:&#x2F;&#x2F;sqlite.org&#x2F;amalgamation.html</a><p><pre><code>    Over 100 separate source files are concatenated into a single large file of C-code named &quot;sqlite3.c&quot; and referred to as &quot;the amalgamation&quot;. The amalgamation contains everything an application needs to embed SQLite.
    
    Combining all the code for SQLite into one big file makes SQLite easier to deploy — there is just one file to keep track of. And because all code is in a single translation unit, compilers can do better inter-procedure and inlining optimization resulting in machine code that is between 5% and 10% faster.</code></pre></div><br/></div></div><div id="40193311" class="c"><input type="checkbox" id="c-40193311" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40192680">parent</a><span>|</span><a href="#40194589">prev</a><span>|</span><a href="#40193511">next</a><span>|</span><label class="collapse" for="c-40193311">[-]</label><label class="expand" for="c-40193311">[2 more]</label></div><br/><div class="children"><div class="content">It makes sense. As projects grow, the average header file is included O(n) times from O(n) different .cc files - leading to O(n^2) parsed header files during compilation. And thus, O(n^2) work for the compiler.<p>Merging everything into one big .cc file reduces the compilation job back to an O(n) task, since each header only needs to be parsed once.<p>Its stupid that any of this is necessary, but I suppose its easier to hack around the problem than fix the problem in the language.</div><br/><div id="40194161" class="c"><input type="checkbox" id="c-40194161" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40192680">root</a><span>|</span><a href="#40193311">parent</a><span>|</span><a href="#40193511">next</a><span>|</span><label class="collapse" for="c-40194161">[-]</label><label class="expand" for="c-40194161">[1 more]</label></div><br/><div class="children"><div class="content">Those problems are fixable with C&#x2F;C++, but nobody seems to want to do it. They are fixed with dlang&#x27;s ImportC. You can do things like:<p><pre><code>    dmd a.c b.c
</code></pre>
and it will compile and link the C files together. ImportC also supports modules (to solve the .h problems).<p>It&#x27;s all quite doable.</div><br/></div></div></div></div><div id="40193511" class="c"><input type="checkbox" id="c-40193511" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#40192680">parent</a><span>|</span><a href="#40193311">prev</a><span>|</span><a href="#40195693">next</a><span>|</span><label class="collapse" for="c-40193511">[-]</label><label class="expand" for="c-40193511">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m starting to believe that one static&#x2F;shared library should be produced by compiling exactly one cpp file. Go ahead and logically break your code into as many cpp files as you want. But there should then be a single cpp file that includes all other cpp files.<p>The whole C++ build model is terrible and broken. Everyone knows n^2 algorithms are bad and yet here we are.</div><br/><div id="40193584" class="c"><input type="checkbox" id="c-40193584" checked=""/><div class="controls bullet"><span class="by">sfpotter</span><span>|</span><a href="#40192680">root</a><span>|</span><a href="#40193511">parent</a><span>|</span><a href="#40195693">next</a><span>|</span><label class="collapse" for="c-40193584">[-]</label><label class="expand" for="c-40193584">[1 more]</label></div><br/><div class="children"><div class="content">Everyone: &quot;O(n^2) algorithms are bad.&quot;<p>Also everyone: &quot;Just do the stupidest thing in the shortest amount of time possible. We&#x27;ll fix it later.&quot;</div><br/></div></div></div></div></div></div><div id="40195693" class="c"><input type="checkbox" id="c-40195693" checked=""/><div class="controls bullet"><span class="by">tinganho</span><span>|</span><a href="#40192680">prev</a><span>|</span><a href="#40192998">next</a><span>|</span><label class="collapse" for="c-40195693">[-]</label><label class="expand" for="c-40195693">[1 more]</label></div><br/><div class="children"><div class="content">One thing that crossed my mind when I was looking at the TypeScript compiler. Was that it was parsing header &quot;d.ts&quot; files even though it wasn&#x27;t used in source. Although, it had some references of a type in a small main function.<p>Iirc, I think this was how most compilers did. The downside is that transitive deps can easily explode. Thus, compiling a super small main function can takes seconds.<p>I did suggest a solution to just lazily parse&#x2F;check symbols if they are encountered in source. Instead of when including a type, you have to parse all the transitive header files of the file that defines the type.</div><br/></div></div><div id="40192998" class="c"><input type="checkbox" id="c-40192998" checked=""/><div class="controls bullet"><span class="by">diath</span><span>|</span><a href="#40195693">prev</a><span>|</span><a href="#40195956">next</a><span>|</span><label class="collapse" for="c-40192998">[-]</label><label class="expand" for="c-40192998">[1 more]</label></div><br/><div class="children"><div class="content">Ever since I tried -ftime-trace in Clang to improve build times in a project a while ago, I&#x27;ve been very conscious about using forward declarations wherever possible, however I wish we had proper module support that actually worked well, having to keep this in mind whenever writing new code just so your project doesn&#x27;t take forever to compile sucks, this shouldn&#x27;t even be something we have to keep in mind in 2024.</div><br/></div></div><div id="40195956" class="c"><input type="checkbox" id="c-40195956" checked=""/><div class="controls bullet"><span class="by">jsbus</span><span>|</span><a href="#40192998">prev</a><span>|</span><a href="#40196037">next</a><span>|</span><label class="collapse" for="c-40195956">[-]</label><label class="expand" for="c-40195956">[1 more]</label></div><br/><div class="children"><div class="content">I was thinking about applying at Figma a couple days ago. Seeing the engineering culture portrayed in this post, I do not any more.</div><br/></div></div><div id="40196037" class="c"><input type="checkbox" id="c-40196037" checked=""/><div class="controls bullet"><span class="by">Gupie</span><span>|</span><a href="#40195956">prev</a><span>|</span><a href="#40192533">next</a><span>|</span><label class="collapse" for="c-40196037">[-]</label><label class="expand" for="c-40196037">[1 more]</label></div><br/><div class="children"><div class="content">Link times are the main pain for our edit, build, debug cycle.</div><br/></div></div><div id="40192533" class="c"><input type="checkbox" id="c-40192533" checked=""/><div class="controls bullet"><span class="by">snypehype46</span><span>|</span><a href="#40196037">prev</a><span>|</span><a href="#40195663">next</a><span>|</span><label class="collapse" for="c-40192533">[-]</label><label class="expand" for="c-40192533">[3 more]</label></div><br/><div class="children"><div class="content">Coincidentally in the project I&#x27;m currently working I managed to reduce our compile times significantly (~35% faster) using ClangBuildAnalyzer [1]. The main two things that helped were precompiled headers and explicit template instantiations.<p>Unfortunately, the project still remains heavy to compile because of our use of Eigen throughout the entire codebase. The analysis with Clang&#x27;s &quot;-ftime-trace&quot; show that 75-80% of the compilation time is spent in the optimisation stage, but not really sure what to do about that.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;aras-p&#x2F;ClangBuildAnalyzer">https:&#x2F;&#x2F;github.com&#x2F;aras-p&#x2F;ClangBuildAnalyzer</a></div><br/><div id="40193892" class="c"><input type="checkbox" id="c-40193892" checked=""/><div class="controls bullet"><span class="by">celrod</span><span>|</span><a href="#40192533">parent</a><span>|</span><a href="#40195663">next</a><span>|</span><label class="collapse" for="c-40193892">[-]</label><label class="expand" for="c-40193892">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the trick with explicit template instantiations?
Including them in the precompiled header?</div><br/><div id="40194843" class="c"><input type="checkbox" id="c-40194843" checked=""/><div class="controls bullet"><span class="by">logicchains</span><span>|</span><a href="#40192533">root</a><span>|</span><a href="#40193892">parent</a><span>|</span><a href="#40195663">next</a><span>|</span><label class="collapse" for="c-40194843">[-]</label><label class="expand" for="c-40194843">[1 more]</label></div><br/><div class="children"><div class="content">You leave them uninstantiated in the header file and explicitly instantiate them in the .cc file (only works if there&#x27;s a small number of possible instantiations).</div><br/></div></div></div></div></div></div><div id="40195663" class="c"><input type="checkbox" id="c-40195663" checked=""/><div class="controls bullet"><span class="by">ErikCorry</span><span>|</span><a href="#40192533">prev</a><span>|</span><a href="#40192061">next</a><span>|</span><label class="collapse" for="c-40195663">[-]</label><label class="expand" for="c-40195663">[2 more]</label></div><br/><div class="children"><div class="content">My tip: Increase the size of .cc files. Since each .cc file is including tens of thousands of .h lines, you should not allow developers to check in &lt; 100 line .cc files.<p>The OP was seeing build times increase faster than loc. Probably someone on the team likes small .cc files.</div><br/><div id="40196033" class="c"><input type="checkbox" id="c-40196033" checked=""/><div class="controls bullet"><span class="by">choppaface</span><span>|</span><a href="#40195663">parent</a><span>|</span><a href="#40192061">next</a><span>|</span><label class="collapse" for="c-40196033">[-]</label><label class="expand" for="c-40196033">[1 more]</label></div><br/><div class="children"><div class="content">But translation units &#x2F; small .cc files can build in parallel and cached, and with multi-core thus it&#x27;s desirable to have many small translation units.  Except of course when there&#x27;s eventually one large translation unit that needs everything and then link time dominates ...<p>The article emphasizes a common issue about headers.. X-Code and Visual Studio work around this to some extent with pre-compiled headers, something that can be really hard to set up in ccache.  If Figma&#x27;s whole team is using macs (they mention getting everybody macbooks?) then I wonder if they could just switch to X-Code and use built-in pch support.  While that introduces a dependency on X-Code :(  maybe their whole C++ stack will get effectively re-written in the next couple of years anyways?</div><br/></div></div></div></div><div id="40192061" class="c"><input type="checkbox" id="c-40192061" checked=""/><div class="controls bullet"><span class="by">LeSaucy</span><span>|</span><a href="#40195663">prev</a><span>|</span><a href="#40195218">next</a><span>|</span><label class="collapse" for="c-40192061">[-]</label><label class="expand" for="c-40192061">[5 more]</label></div><br/><div class="children"><div class="content">I use c++ on the daily and find that ccache and an m1&#x2F;2&#x2F;3 cpu go a very long way to reducing build times.</div><br/><div id="40195536" class="c"><input type="checkbox" id="c-40195536" checked=""/><div class="controls bullet"><span class="by">ErikCorry</span><span>|</span><a href="#40192061">parent</a><span>|</span><a href="#40193859">next</a><span>|</span><label class="collapse" for="c-40195536">[-]</label><label class="expand" for="c-40195536">[1 more]</label></div><br/><div class="children"><div class="content">Ccache is great but then change one central .h file and you are back to square one.</div><br/></div></div><div id="40193859" class="c"><input type="checkbox" id="c-40193859" checked=""/><div class="controls bullet"><span class="by">scheme271</span><span>|</span><a href="#40192061">parent</a><span>|</span><a href="#40195536">prev</a><span>|</span><a href="#40192360">next</a><span>|</span><label class="collapse" for="c-40193859">[-]</label><label class="expand" for="c-40193859">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I got 15 minute build times down to under 30s using ccache.  Doesn&#x27;t help with cold rebuilds but once you have a cache, it really does help things significantly.</div><br/></div></div><div id="40192360" class="c"><input type="checkbox" id="c-40192360" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#40192061">parent</a><span>|</span><a href="#40193859">prev</a><span>|</span><a href="#40195218">next</a><span>|</span><label class="collapse" for="c-40192360">[-]</label><label class="expand" for="c-40192360">[2 more]</label></div><br/><div class="children"><div class="content">Not sure why this was downvoted.  It&#x27;s true that ccache and build parallelization (e.g. icecream) can grease the wheels enough that builds are no longer a dev cycle bottleneck.<p>What the article is about, though, is changing the source code so that it is intrinsically faster to compile.  At some point you say &quot;this program isn&#x27;t complicated, why does it take so long to compile?&quot;  Then you start looking at unnecessary includes, transitive includes, forward declarations, excessive inlining, etc.</div><br/><div id="40193862" class="c"><input type="checkbox" id="c-40193862" checked=""/><div class="controls bullet"><span class="by">rjkaplan</span><span>|</span><a href="#40192061">root</a><span>|</span><a href="#40192360">parent</a><span>|</span><a href="#40195218">next</a><span>|</span><label class="collapse" for="c-40193862">[-]</label><label class="expand" for="c-40193862">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m guessing the comment was downvoted because the suggestions are mentioned in the first paragraph of the article...<p>&gt; After trying a few stopgap solutions—like purchasing M1 Maxs for our team—build times gradually reverted to their original pace; Ccache and remote caching weren’t enough either.</div><br/></div></div></div></div></div></div><div id="40195218" class="c"><input type="checkbox" id="c-40195218" checked=""/><div class="controls bullet"><span class="by">stockhorn</span><span>|</span><a href="#40192061">prev</a><span>|</span><a href="#40193489">next</a><span>|</span><label class="collapse" for="c-40195218">[-]</label><label class="expand" for="c-40195218">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve also tried to optimize c++ compile times on large projects a few times. I never got IWYU working properly and I always hated the fact that I still have to care about header files at all. Then I switched to doing rust full time, which made all the fiddling with header files obsolete. This felt amazing. But now I&#x27;m facing the same problem, slow compile times :). Only this time I have to rely on the compiler team to make the improvements and I cant do much on my side AFAIK.</div><br/><div id="40195486" class="c"><input type="checkbox" id="c-40195486" checked=""/><div class="controls bullet"><span class="by">Nereuxofficial</span><span>|</span><a href="#40195218">parent</a><span>|</span><a href="#40193489">next</a><span>|</span><label class="collapse" for="c-40195486">[-]</label><label class="expand" for="c-40195486">[1 more]</label></div><br/><div class="children"><div class="content">Well that&#x27;s not quite true. You can do a few things: 
1. Reduce dependencies and features of dependencies
2. Use a faster linker like mold
3. Use a faster compiler backend like cranelift(if possible)
4. Use the parallel compiler frontend(again if using nightly is possible)
5. Use sccache to cache dependencies
But i do get what you mean. Especially in CI the build times are often long</div><br/></div></div></div></div><div id="40193489" class="c"><input type="checkbox" id="c-40193489" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#40195218">prev</a><span>|</span><a href="#40192755">next</a><span>|</span><label class="collapse" for="c-40193489">[-]</label><label class="expand" for="c-40193489">[7 more]</label></div><br/><div class="children"><div class="content">A big improvement in compile times with modern C++ can be had with C++20 standard modules.<p>This requires extremely bleeding-edge toolchains, though: VS 2022 17.10, Clang 18, and GCC 14.</div><br/><div id="40194355" class="c"><input type="checkbox" id="c-40194355" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#40193489">parent</a><span>|</span><a href="#40193910">next</a><span>|</span><label class="collapse" for="c-40194355">[-]</label><label class="expand" for="c-40194355">[3 more]</label></div><br/><div class="children"><div class="content">You know you are talking about C++ when &quot;bleeding edge&quot; is compilers from 3 years ago which implement the version before the current standard from 4 years ago....</div><br/><div id="40195657" class="c"><input type="checkbox" id="c-40195657" checked=""/><div class="controls bullet"><span class="by">Longhanks</span><span>|</span><a href="#40193489">root</a><span>|</span><a href="#40194355">parent</a><span>|</span><a href="#40194419">next</a><span>|</span><label class="collapse" for="c-40195657">[-]</label><label class="expand" for="c-40195657">[1 more]</label></div><br/><div class="children"><div class="content">Well, ISO C++ is a standard, and the standard being finished does not mean the implementation being finished.<p>Also, modules is probably one of the biggest changes in terms of work required in build systems, compilers and tooling since at least C++11.</div><br/></div></div><div id="40194419" class="c"><input type="checkbox" id="c-40194419" checked=""/><div class="controls bullet"><span class="by">IAmLiterallyAB</span><span>|</span><a href="#40193489">root</a><span>|</span><a href="#40194355">parent</a><span>|</span><a href="#40195657">prev</a><span>|</span><a href="#40193910">next</a><span>|</span><label class="collapse" for="c-40194419">[-]</label><label class="expand" for="c-40194419">[1 more]</label></div><br/><div class="children"><div class="content">Clang 18 came out in March and GCC 14 isn&#x27;t even out. So those are bleeding edge by just about any metric</div><br/></div></div></div></div><div id="40193910" class="c"><input type="checkbox" id="c-40193910" checked=""/><div class="controls bullet"><span class="by">celrod</span><span>|</span><a href="#40193489">parent</a><span>|</span><a href="#40194355">prev</a><span>|</span><a href="#40193601">next</a><span>|</span><label class="collapse" for="c-40193910">[-]</label><label class="expand" for="c-40193910">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m still waiting for clangd support, e.g. [0] before trying modules. But maybe I should just try it, as at least one person reports that it already works [1].<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;clangd&#x2F;clangd&#x2F;issues&#x2F;1293">https:&#x2F;&#x2F;github.com&#x2F;clangd&#x2F;clangd&#x2F;issues&#x2F;1293</a>
[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;snu-sf-class&#x2F;swpp202401&#x2F;issues&#x2F;21">https:&#x2F;&#x2F;github.com&#x2F;snu-sf-class&#x2F;swpp202401&#x2F;issues&#x2F;21</a></div><br/></div></div><div id="40193601" class="c"><input type="checkbox" id="c-40193601" checked=""/><div class="controls bullet"><span class="by">sfpotter</span><span>|</span><a href="#40193489">parent</a><span>|</span><a href="#40193910">prev</a><span>|</span><a href="#40195423">next</a><span>|</span><label class="collapse" for="c-40193601">[-]</label><label class="expand" for="c-40193601">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m under the impression &quot;big&quot; here <i>might</i> mean a 10-20% improvement if you&#x27;re lucky. Good to back this claim up with hard data.</div><br/></div></div><div id="40195423" class="c"><input type="checkbox" id="c-40195423" checked=""/><div class="controls bullet"><span class="by">bdd8f1df777b</span><span>|</span><a href="#40193489">parent</a><span>|</span><a href="#40193601">prev</a><span>|</span><a href="#40192755">next</a><span>|</span><label class="collapse" for="c-40195423">[-]</label><label class="expand" for="c-40195423">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m still waiting for CMake support to mature.</div><br/></div></div></div></div><div id="40192755" class="c"><input type="checkbox" id="c-40192755" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#40193489">prev</a><span>|</span><a href="#40194105">next</a><span>|</span><label class="collapse" for="c-40192755">[-]</label><label class="expand" for="c-40192755">[3 more]</label></div><br/><div class="children"><div class="content">Bazel + remote workers yields a great user experience with small infrastructure footprint per developer, but requires quite a bit of work to initially set up. You get reproducible builds, caching of test results and blazingly fast CI as a side effect.</div><br/><div id="40193014" class="c"><input type="checkbox" id="c-40193014" checked=""/><div class="controls bullet"><span class="by">jack_pp</span><span>|</span><a href="#40192755">parent</a><span>|</span><a href="#40192873">next</a><span>|</span><label class="collapse" for="c-40193014">[-]</label><label class="expand" for="c-40193014">[1 more]</label></div><br/><div class="children"><div class="content">when you use tensorflow from python you&#x27;re basically using c++</div><br/></div></div><div id="40192873" class="c"><input type="checkbox" id="c-40192873" checked=""/><div class="controls bullet"><span class="by">bburnett44</span><span>|</span><a href="#40192755">parent</a><span>|</span><a href="#40193014">prev</a><span>|</span><a href="#40194105">next</a><span>|</span><label class="collapse" for="c-40192873">[-]</label><label class="expand" for="c-40192873">[1 more]</label></div><br/><div class="children"><div class="content">lol I initially read this as remote people workers and was super confused</div><br/></div></div></div></div><div id="40194105" class="c"><input type="checkbox" id="c-40194105" checked=""/><div class="controls bullet"><span class="by">Kelteseth</span><span>|</span><a href="#40192755">prev</a><span>|</span><a href="#40192420">next</a><span>|</span><label class="collapse" for="c-40194105">[-]</label><label class="expand" for="c-40194105">[1 more]</label></div><br/><div class="children"><div class="content">I recently created <a href="https:&#x2F;&#x2F;arewemodulesyet.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;arewemodulesyet.org&#x2F;</a> to track module adoption in the c++ ecosystem. I used how often a vcpkg manifest file changed to get a rough estimate how popular a library is.</div><br/></div></div><div id="40192420" class="c"><input type="checkbox" id="c-40192420" checked=""/><div class="controls bullet"><span class="by">wifijammer</span><span>|</span><a href="#40194105">prev</a><span>|</span><a href="#40181990">next</a><span>|</span><label class="collapse" for="c-40192420">[-]</label><label class="expand" for="c-40192420">[8 more]</label></div><br/><div class="children"><div class="content">I really hate the repetition from separating out header and definition files so I&#x27;ve been writing my whole codebase headers only.<p>I feel like this kills my compile time but I&#x27;m not sure how to fix it. Precompiled headers?</div><br/><div id="40195335" class="c"><input type="checkbox" id="c-40195335" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40192420">parent</a><span>|</span><a href="#40192459">next</a><span>|</span><label class="collapse" for="c-40195335">[-]</label><label class="expand" for="c-40195335">[1 more]</label></div><br/><div class="children"><div class="content">C++20 modules.<p>Currently mostly usable on VC++ vlatest, and clang 17, with clang 18 bringing in support for c++23 import std (VC++ already does it).<p>Sadly GCC is still far behind, not to mention all the other ones still catching up with C++17.</div><br/></div></div><div id="40192459" class="c"><input type="checkbox" id="c-40192459" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40192420">parent</a><span>|</span><a href="#40195335">prev</a><span>|</span><a href="#40192488">next</a><span>|</span><label class="collapse" for="c-40192459">[-]</label><label class="expand" for="c-40192459">[5 more]</label></div><br/><div class="children"><div class="content">If you have all your application code in headers you&#x27;ll get the fastest build times (for full rebuilds at least) by including <i>all</i> headers into a single main.cpp file and build just that, since that way there is no redundant code for the compiler to build at all.<p>Of course the downside is that every tiny code change triggers a full rebuild then, but it&#x27;s quite likely that the most time is spent in the linker anyway, so maybe worth a try.</div><br/><div id="40192627" class="c"><input type="checkbox" id="c-40192627" checked=""/><div class="controls bullet"><span class="by">runevault</span><span>|</span><a href="#40192420">root</a><span>|</span><a href="#40192459">parent</a><span>|</span><a href="#40193950">next</a><span>|</span><label class="collapse" for="c-40192627">[-]</label><label class="expand" for="c-40192627">[3 more]</label></div><br/><div class="children"><div class="content">I think I&#x27;ve heard this called a Unity build where there&#x27;s a precompile step that just dumps everything into a single file and compiles that so it doesn&#x27;t have to re-include everything at different compilation units (when I first heard the term I got confused because it was in a game dev context but had nothing to do with the Unity engine lol).</div><br/><div id="40192660" class="c"><input type="checkbox" id="c-40192660" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40192420">root</a><span>|</span><a href="#40192627">parent</a><span>|</span><a href="#40193950">next</a><span>|</span><label class="collapse" for="c-40192660">[-]</label><label class="expand" for="c-40192660">[2 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s typically called unity or jumbo build, and can also be done with regular source files.<p>Cmake has a feature to do that automatically during the build:
 <a href="https:&#x2F;&#x2F;cmake.org&#x2F;cmake&#x2F;help&#x2F;latest&#x2F;prop_tgt&#x2F;UNITY_BUILD.html" rel="nofollow">https:&#x2F;&#x2F;cmake.org&#x2F;cmake&#x2F;help&#x2F;latest&#x2F;prop_tgt&#x2F;UNITY_BUILD.htm...</a><p>...haven&#x27;t tinkered with it yet though.</div><br/><div id="40194230" class="c"><input type="checkbox" id="c-40194230" checked=""/><div class="controls bullet"><span class="by">runevault</span><span>|</span><a href="#40192420">root</a><span>|</span><a href="#40192660">parent</a><span>|</span><a href="#40193950">next</a><span>|</span><label class="collapse" for="c-40194230">[-]</label><label class="expand" for="c-40194230">[1 more]</label></div><br/><div class="children"><div class="content">Huh did not know cmake had it built in. Thanks for the information!</div><br/></div></div></div></div></div></div><div id="40193950" class="c"><input type="checkbox" id="c-40193950" checked=""/><div class="controls bullet"><span class="by">asvitkine</span><span>|</span><a href="#40192420">root</a><span>|</span><a href="#40192459">parent</a><span>|</span><a href="#40192627">prev</a><span>|</span><a href="#40192488">next</a><span>|</span><label class="collapse" for="c-40193950">[-]</label><label class="expand" for="c-40193950">[1 more]</label></div><br/><div class="children"><div class="content">Except then there&#x27;s no parallelism since you&#x27;re only building one file. Ideally you&#x27;d split it into N files to take advantage of multiple cores, but then you have to decide how to split it...</div><br/></div></div></div></div><div id="40192488" class="c"><input type="checkbox" id="c-40192488" checked=""/><div class="controls bullet"><span class="by">ranger_danger</span><span>|</span><a href="#40192420">parent</a><span>|</span><a href="#40192459">prev</a><span>|</span><a href="#40181990">next</a><span>|</span><label class="collapse" for="c-40192488">[-]</label><label class="expand" for="c-40192488">[1 more]</label></div><br/><div class="children"><div class="content">ccache is one solution, or a script&#x2F;IDE plugin that will create both the header&#x2F;definition from a signature you provide?</div><br/></div></div></div></div><div id="40181990" class="c"><input type="checkbox" id="c-40181990" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40192420">prev</a><span>|</span><a href="#40194625">next</a><span>|</span><label class="collapse" for="c-40181990">[-]</label><label class="expand" for="c-40181990">[5 more]</label></div><br/><div class="children"><div class="content">This blog entry is highly disappointing. The Sigma blog post reads as if they reinvented the wheel with basic information that is not only widely known and understood but it also featured in books published decades ago.<p>The blog post authors would do well if they got up to speed on the basics of working with C++ projects. Books such as &quot;Large scale C++ vol1&quot; by John Lakos already cover this and much more.</div><br/><div id="40192268" class="c"><input type="checkbox" id="c-40192268" checked=""/><div class="controls bullet"><span class="by">rileymat2</span><span>|</span><a href="#40181990">parent</a><span>|</span><a href="#40184395">next</a><span>|</span><label class="collapse" for="c-40192268">[-]</label><label class="expand" for="c-40192268">[3 more]</label></div><br/><div class="children"><div class="content">It could be my bias but it seems a lot of inexperienced developers no longer read comprehensive books on topics but survive on Google, stack overflow, some documentation with examples&#x2F;simple tutorials, blog posts and now Gpts.<p>All are useful tools but they are very poor in eliminating unknown unknowns like a book would.</div><br/><div id="40192540" class="c"><input type="checkbox" id="c-40192540" checked=""/><div class="controls bullet"><span class="by">bdowling</span><span>|</span><a href="#40181990">root</a><span>|</span><a href="#40192268">parent</a><span>|</span><a href="#40184395">next</a><span>|</span><label class="collapse" for="c-40192540">[-]</label><label class="expand" for="c-40192540">[2 more]</label></div><br/><div class="children"><div class="content">You think only inexperienced developers have stopped reading books?</div><br/><div id="40192583" class="c"><input type="checkbox" id="c-40192583" checked=""/><div class="controls bullet"><span class="by">rileymat2</span><span>|</span><a href="#40181990">root</a><span>|</span><a href="#40192540">parent</a><span>|</span><a href="#40184395">next</a><span>|</span><label class="collapse" for="c-40192583">[-]</label><label class="expand" for="c-40192583">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s fair, I bet it is more widespread, but people starting in the last 15-20 years did not even have the initial introduction.   I read a lot, it surprised me to find out that it was atypical in an industry that is supposed to be somewhat about leveraging brainpower.  May as well stand on the shoulders of giants.</div><br/></div></div></div></div></div></div><div id="40184395" class="c"><input type="checkbox" id="c-40184395" checked=""/><div class="controls bullet"><span class="by">SuperV1234</span><span>|</span><a href="#40181990">parent</a><span>|</span><a href="#40192268">prev</a><span>|</span><a href="#40194625">next</a><span>|</span><label class="collapse" for="c-40184395">[-]</label><label class="expand" for="c-40184395">[1 more]</label></div><br/><div class="children"><div class="content">Shameless plug from my talk:
<a href="https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=PfHD3BsVsAM" rel="nofollow">https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=PfHD3BsVsAM</a></div><br/></div></div></div></div><div id="40194625" class="c"><input type="checkbox" id="c-40194625" checked=""/><div class="controls bullet"><span class="by">feverzsj</span><span>|</span><a href="#40181990">prev</a><span>|</span><a href="#40194388">next</a><span>|</span><label class="collapse" for="c-40194625">[-]</label><label class="expand" for="c-40194625">[1 more]</label></div><br/><div class="children"><div class="content">On the contrary, I prefer putting everything in header file, and put related headers in same source file just for compile. It&#x27;s basically unit build but without its drawbacks.</div><br/></div></div><div id="40194388" class="c"><input type="checkbox" id="c-40194388" checked=""/><div class="controls bullet"><span class="by">setheron</span><span>|</span><a href="#40194625">prev</a><span>|</span><a href="#40195097">next</a><span>|</span><label class="collapse" for="c-40194388">[-]</label><label class="expand" for="c-40194388">[1 more]</label></div><br/><div class="children"><div class="content">Isnt this what header guards are for or the #pragma include</div><br/></div></div><div id="40195097" class="c"><input type="checkbox" id="c-40195097" checked=""/><div class="controls bullet"><span class="by">ramon156</span><span>|</span><a href="#40194388">prev</a><span>|</span><a href="#40192975">next</a><span>|</span><label class="collapse" for="c-40195097">[-]</label><label class="expand" for="c-40195097">[1 more]</label></div><br/><div class="children"><div class="content">The longest acronym I know is WYSIWYG (What You See Is What You Get)</div><br/></div></div><div id="40192975" class="c"><input type="checkbox" id="c-40192975" checked=""/><div class="controls bullet"><span class="by">allpaca</span><span>|</span><a href="#40195097">prev</a><span>|</span><a href="#40192514">next</a><span>|</span><label class="collapse" for="c-40192975">[-]</label><label class="expand" for="c-40192975">[4 more]</label></div><br/><div class="children"><div class="content">C++ is evolving so much, however I don&#x27;t understand this thing: why people continue to develop AI projects with Python? I&#x27;d choose C++ instead...</div><br/><div id="40193039" class="c"><input type="checkbox" id="c-40193039" checked=""/><div class="controls bullet"><span class="by">bpicolo</span><span>|</span><a href="#40192975">parent</a><span>|</span><a href="#40193114">next</a><span>|</span><label class="collapse" for="c-40193039">[-]</label><label class="expand" for="c-40193039">[2 more]</label></div><br/><div class="children"><div class="content">Because they&#x27;re python libraries that just wrap C and C++. All the performance upside with better ergonomics</div><br/><div id="40193199" class="c"><input type="checkbox" id="c-40193199" checked=""/><div class="controls bullet"><span class="by">oivey</span><span>|</span><a href="#40192975">root</a><span>|</span><a href="#40193039">parent</a><span>|</span><a href="#40193114">next</a><span>|</span><label class="collapse" for="c-40193199">[-]</label><label class="expand" for="c-40193199">[1 more]</label></div><br/><div class="children"><div class="content">Putting this another way, people use Python because it makes it way easier to compose together the underlying C++ code. Composition and polymorphism in C++’s static type system is rather weak.<p>Of course there is also the relative succintness of Python and other advantages, too.</div><br/></div></div></div></div><div id="40193114" class="c"><input type="checkbox" id="c-40193114" checked=""/><div class="controls bullet"><span class="by">VHRanger</span><span>|</span><a href="#40192975">parent</a><span>|</span><a href="#40193039">prev</a><span>|</span><a href="#40192514">next</a><span>|</span><label class="collapse" for="c-40193114">[-]</label><label class="expand" for="c-40193114">[1 more]</label></div><br/><div class="children"><div class="content">Because you need a dynamic language to do rapid iteration.<p>You don&#x27;t want to recompile, re-parse a 12GB parquet file, etc. everytime you try a new parameter in a model.</div><br/></div></div></div></div><div id="40192514" class="c"><input type="checkbox" id="c-40192514" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40192975">prev</a><span>|</span><a href="#40194289">next</a><span>|</span><label class="collapse" for="c-40192514">[-]</label><label class="expand" for="c-40192514">[1 more]</label></div><br/><div class="children"><div class="content">DIWYDU sound like a better tool than IWYU.</div><br/></div></div><div id="40194289" class="c"><input type="checkbox" id="c-40194289" checked=""/><div class="controls bullet"><span class="by">teunispeters</span><span>|</span><a href="#40192514">prev</a><span>|</span><a href="#40192273">next</a><span>|</span><label class="collapse" for="c-40194289">[-]</label><label class="expand" for="c-40194289">[4 more]</label></div><br/><div class="children"><div class="content">(silly answer) use Visual C++.  I&#x27;ve been coding across MacOS, Linux, and Windows 11, with roughly comparable machines in a lot of ways (all Intel).   Visual C++ while awkward for compatibility - is very very fast for builds, and not bad for IDE interface for rapid fixes.<p>More serious - I moved to CMake presets and with that came a lot of cache optimization - including parallel builds.  MacOS is now almost as fast as Windows for build, and Linux&#x2F;gcc not far behind.  Windows C++ seems to have the lowest modern feature compatibility, followed by MacOS&#x2F;Clang, with Linux&#x2F;recent GCC being the most complex.   A lot of the newer features seem to add a lot to the build time..<p>... mind I&#x27;ve been working with C++ only for the last few months, and C for many years before, so consider it a beginner post in a lot of ways.  Still, it was interesting to explore, and I&#x27;ll be continuing to explore - I haven&#x27;t yet enabled ccache for instance which I suspect will improve a lot.</div><br/><div id="40194331" class="c"><input type="checkbox" id="c-40194331" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#40194289">parent</a><span>|</span><a href="#40192273">next</a><span>|</span><label class="collapse" for="c-40194331">[-]</label><label class="expand" for="c-40194331">[3 more]</label></div><br/><div class="children"><div class="content">My experience is the exact opposite. Moving a multimillion line C++ code base from msbuild to CMake&#x2F;ninja on Windows cut the build time in half.<p>Chrome got even better speedups I believe by building with clang&#x2F;ninja on Windows.<p>Bazel is where the real benefits lie by reusing other people&#x27;s (or CI machine&#x27;s) partial build artifacts via a centralized cache and by avoiding to run tests that are not affected by code changes.</div><br/><div id="40194757" class="c"><input type="checkbox" id="c-40194757" checked=""/><div class="controls bullet"><span class="by">spacemanspiff01</span><span>|</span><a href="#40194289">root</a><span>|</span><a href="#40194331">parent</a><span>|</span><a href="#40192273">next</a><span>|</span><label class="collapse" for="c-40194757">[-]</label><label class="expand" for="c-40194757">[2 more]</label></div><br/><div class="children"><div class="content">How does bazel work with cmake builds?</div><br/><div id="40195775" class="c"><input type="checkbox" id="c-40195775" checked=""/><div class="controls bullet"><span class="by">tambre</span><span>|</span><a href="#40194289">root</a><span>|</span><a href="#40194757">parent</a><span>|</span><a href="#40192273">next</a><span>|</span><label class="collapse" for="c-40195775">[-]</label><label class="expand" for="c-40195775">[1 more]</label></div><br/><div class="children"><div class="content">Seems it has the necessary integration points to run CMake builds as an external command. The same way you could build Make, Autotools, Meson or Bazel projects from CMake with the necessary external command plumbings.<p>Obviously both fille the same purpose of being a build system, though Bazel is also a build executor not just a generator. Integration would mean either adding BUILD language support to CMake or vice-versa, but you wouldn&#x27;t get the particular benefits of either this way.</div><br/></div></div></div></div></div></div></div></div><div id="40192273" class="c"><input type="checkbox" id="c-40192273" checked=""/><div class="controls bullet"><span class="by">Scubabear68</span><span>|</span><a href="#40194289">prev</a><span>|</span><a href="#40195098">next</a><span>|</span><label class="collapse" for="c-40192273">[-]</label><label class="expand" for="c-40192273">[6 more]</label></div><br/><div class="children"><div class="content">I find it hard to believe that this post indicates that C++ build times are proportional to included bytes, period.<p>I haven’t used C++ in quite a while, but aren’t templates a big part of this issue?</div><br/><div id="40192344" class="c"><input type="checkbox" id="c-40192344" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40192273">parent</a><span>|</span><a href="#40195098">next</a><span>|</span><label class="collapse" for="c-40192344">[-]</label><label class="expand" for="c-40192344">[5 more]</label></div><br/><div class="children"><div class="content">It becomes believable when you consider that your own code is just a very tiny appendix dangling off the end of a massive chunk of included data. For instance just including &lt;vector&gt; results in a 24kloc compilation unit of gnarly template code in Clang with C++23:<p><a href="https:&#x2F;&#x2F;www.godbolt.org&#x2F;z&#x2F;G18WGdET5" rel="nofollow">https:&#x2F;&#x2F;www.godbolt.org&#x2F;z&#x2F;G18WGdET5</a><p>...add &lt;string&gt; and &lt;algorithm&gt; and you&#x27;re at 45kloc:<p><a href="https:&#x2F;&#x2F;www.godbolt.org&#x2F;z&#x2F;Whv73YPYh" rel="nofollow">https:&#x2F;&#x2F;www.godbolt.org&#x2F;z&#x2F;Whv73YPYh</a><p>...and those numbers have been growing steadily by a couple thousand lines in each new C++ version.<p>Multiply this with a few thousand source files (not atypical with the old &#x27;clean code&#x27; rule to prefer small source files, e.g. one file per class), and that&#x27;s already dozens to hundreds of million lines of code the compiler needs to process on a full rebuild, all spent on compiling &lt;vector&gt; over and over again.<p>TL;DR: the most effective way to improve build times in C++ is to split your project into few big source files instead of many small files (either manually, e.g. one big source file per &#x27;system&#x27;, or let the build system take care of it via &#x27;unity&#x27; or &#x27;jumbo&#x27; builds).</div><br/><div id="40192529" class="c"><input type="checkbox" id="c-40192529" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40192273">root</a><span>|</span><a href="#40192344">parent</a><span>|</span><a href="#40195098">next</a><span>|</span><label class="collapse" for="c-40192529">[-]</label><label class="expand" for="c-40192529">[4 more]</label></div><br/><div class="children"><div class="content">Except that doesn&#x27;t improve the time of iterative builds, which are the only ones that really matter to software development.</div><br/><div id="40192568" class="c"><input type="checkbox" id="c-40192568" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40192273">root</a><span>|</span><a href="#40192529">parent</a><span>|</span><a href="#40195098">next</a><span>|</span><label class="collapse" for="c-40192568">[-]</label><label class="expand" for="c-40192568">[3 more]</label></div><br/><div class="children"><div class="content">It does though for header changes, which then may trigger fewer source file compilations. IME in incremental builds the most time is spent in the linker anyway.<p>&gt; which are the only ones that really matter to software development.<p>Debatable in this age of cloud CI builds ;)</div><br/><div id="40195443" class="c"><input type="checkbox" id="c-40195443" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40192273">root</a><span>|</span><a href="#40192568">parent</a><span>|</span><a href="#40193332">next</a><span>|</span><label class="collapse" for="c-40195443">[-]</label><label class="expand" for="c-40195443">[1 more]</label></div><br/><div class="children"><div class="content">Splitting everything in small files makes it so that very little needs to recompile when you change something.<p>Linking is pretty much just I&#x2F;O-bound unless you&#x27;re using LTO. This is assuming you&#x27;re using a modern linker like mold.</div><br/></div></div><div id="40193332" class="c"><input type="checkbox" id="c-40193332" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40192273">root</a><span>|</span><a href="#40192568">parent</a><span>|</span><a href="#40195443">prev</a><span>|</span><a href="#40195098">next</a><span>|</span><label class="collapse" for="c-40193332">[-]</label><label class="expand" for="c-40193332">[1 more]</label></div><br/><div class="children"><div class="content">&gt; IME in incremental builds the most time is spent in the linker anyway.<p>A lot of time is spent in the linker because the linker needs to parse and deduplicate any monomorphized C++ classes (like vector). This takes time proportional to the number of compiled copies of the class &#x2F; function that are kicking around.<p>So I&#x27;d expect linking times to also decrease if you&#x27;re compiling fewer, larger source files.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40195098" class="c"><input type="checkbox" id="c-40195098" checked=""/><div class="controls bullet"><span class="by">ramon156</span><span>|</span><a href="#40192273">prev</a><span>|</span><a href="#40189639">next</a><span>|</span><label class="collapse" for="c-40195098">[-]</label><label class="expand" for="c-40195098">[1 more]</label></div><br/><div class="children"><div class="content">The longest acronym I know is WYSIWYG (What You See Is What You Get)</div><br/></div></div><div id="40193362" class="c"><input type="checkbox" id="c-40193362" checked=""/><div class="controls bullet"><span class="by">gosub100</span><span>|</span><a href="#40189639">prev</a><span>|</span><a href="#40192250">next</a><span>|</span><label class="collapse" for="c-40193362">[-]</label><label class="expand" for="c-40193362">[5 more]</label></div><br/><div class="children"><div class="content">I just checked and distcc [1] is still a thing. It&#x27;s been around a while now, I remember messing with it in about 2010. It allows you to parallelize your builds across multiple machines. Not as relevant now with todays multicore CPUs, but if you or your employer can&#x27;t afford to buy you a work station, distcc might be your answer.<p>[1] <a href="https:&#x2F;&#x2F;www.distcc.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.distcc.org&#x2F;</a></div><br/><div id="40193470" class="c"><input type="checkbox" id="c-40193470" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40193362">parent</a><span>|</span><a href="#40195321">next</a><span>|</span><label class="collapse" for="c-40193470">[-]</label><label class="expand" for="c-40193470">[2 more]</label></div><br/><div class="children"><div class="content">Use icecream or sccache. sccache optionally supports distributed builds.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;mozilla&#x2F;sccache&#x2F;blob&#x2F;main&#x2F;docs&#x2F;DistributedQuickstart.md">https:&#x2F;&#x2F;github.com&#x2F;mozilla&#x2F;sccache&#x2F;blob&#x2F;main&#x2F;docs&#x2F;Distribute...</a></div><br/><div id="40196073" class="c"><input type="checkbox" id="c-40196073" checked=""/><div class="controls bullet"><span class="by">saidinesh5</span><span>|</span><a href="#40193362">root</a><span>|</span><a href="#40193470">parent</a><span>|</span><a href="#40195321">next</a><span>|</span><label class="collapse" for="c-40196073">[-]</label><label class="expand" for="c-40196073">[1 more]</label></div><br/><div class="children"><div class="content">Back in college days, I had to use icecream to compile some of KDE codebase. Our laptops were quickly thermal throttling and simply couldn&#x27;t handle so much code. Add to that crazy summers here, icecream was a godsend.</div><br/></div></div></div></div><div id="40195321" class="c"><input type="checkbox" id="c-40195321" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40193362">parent</a><span>|</span><a href="#40193470">prev</a><span>|</span><a href="#40195427">next</a><span>|</span><label class="collapse" for="c-40195321">[-]</label><label class="expand" for="c-40195321">[1 more]</label></div><br/><div class="children"><div class="content">Even if you have a beefy workstation, if your projects has thousands of translation units (i.e. any moderately large c++program), distcc (and ccache) still help significantly.<p>Unfortunately linking becomes the bottleneck.</div><br/></div></div><div id="40195427" class="c"><input type="checkbox" id="c-40195427" checked=""/><div class="controls bullet"><span class="by">curiousgal</span><span>|</span><a href="#40193362">parent</a><span>|</span><a href="#40195321">prev</a><span>|</span><a href="#40192250">next</a><span>|</span><label class="collapse" for="c-40195427">[-]</label><label class="expand" for="c-40195427">[1 more]</label></div><br/><div class="children"><div class="content">We use Incredibuild at work.</div><br/></div></div></div></div><div id="40192250" class="c"><input type="checkbox" id="c-40192250" checked=""/><div class="controls bullet"><span class="by">juunpp</span><span>|</span><a href="#40193362">prev</a><span>|</span><label class="collapse" for="c-40192250">[-]</label><label class="expand" for="c-40192250">[13 more]</label></div><br/><div class="children"><div class="content">Just another self-promotion blog post with near zero information density. &quot;Behold, the vastness of our vanity, regurgitating old news like we just discovered something new.&quot; Do these posts really help with hiring?<p>CLION also highlights unused includes, nothing new here. Use a good IDE. A networked ccache also does wonders if your org allows it.<p>Slow build otherwise stem from a combination of: a) lack of proper modules in C++ (until recently) and b) unidiomatic or just terrible code bases. To help with the latter, hide physical implementations (PIMPL for class state, forward declarations for imports), avoid OOP-style C++ above all, minimize use of templates, design sound and minimal modules. No rocket science.</div><br/><div id="40192338" class="c"><input type="checkbox" id="c-40192338" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#40192250">parent</a><span>|</span><a href="#40192581">next</a><span>|</span><label class="collapse" for="c-40192338">[-]</label><label class="expand" for="c-40192338">[1 more]</label></div><br/><div class="children"><div class="content">Three times I&#x27;ve joined a team that has a substantial C++ codebase, and three times I&#x27;ve been tempted to use libclang based tooling to automate changes, or at least to identify patterns that could be changed.<p>This article, while not the nerdy deep dive I&#x27;d like, does touch on what happens when you try to do that.  You realize that the C++ standard library is really complicated, that your existing code is really fucked up, and that libclang is too limited a tool.  You end up writing a XSLT engine in hacked up python, but by a different name.<p>[LibTooling][1] is probably The Right Thing (&quot;in C++&quot;, as the article says), but I never spent the time to get it working.<p>Somebody write a DSL for C++ inspection and transformations that uses LibTooling as a backend.  I bet there are many, but none close at hand.<p>edit: [this][2] is close...<p>[1]: <a href="https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;LibTooling.html" rel="nofollow">https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;LibTooling.html</a><p>[2]: <a href="https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;LibASTMatchersTutorial.html#intermezzo-learn-ast-matcher-basics" rel="nofollow">https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;LibASTMatchersTutorial.html#inte...</a></div><br/></div></div><div id="40192581" class="c"><input type="checkbox" id="c-40192581" checked=""/><div class="controls bullet"><span class="by">stefan_</span><span>|</span><a href="#40192250">parent</a><span>|</span><a href="#40192338">prev</a><span>|</span><label class="collapse" for="c-40192581">[-]</label><label class="expand" for="c-40192581">[11 more]</label></div><br/><div class="children"><div class="content">Is there anyone else that gets unreasonably angry at stuff like PIMPL? It is truly the most braindead, bereft of sense activity in this world. There was a comment in one of the many Rust threads that called C++ a respectable language now but then things like PIMPL snap you right back into the wasteland it is.</div><br/><div id="40192807" class="c"><input type="checkbox" id="c-40192807" checked=""/><div class="controls bullet"><span class="by">Maxatar</span><span>|</span><a href="#40192250">root</a><span>|</span><a href="#40192581">parent</a><span>|</span><a href="#40194005">next</a><span>|</span><label class="collapse" for="c-40192807">[-]</label><label class="expand" for="c-40192807">[1 more]</label></div><br/><div class="children"><div class="content">No, maybe the acronym is ugly, sounds like pimple? But other than that the use of the technique is invaluable to writing stable ABIs which in turn makes distribution of C++ libraries a lot easier.</div><br/></div></div><div id="40194005" class="c"><input type="checkbox" id="c-40194005" checked=""/><div class="controls bullet"><span class="by">bun_terminator</span><span>|</span><a href="#40192250">root</a><span>|</span><a href="#40192581">parent</a><span>|</span><a href="#40192807">prev</a><span>|</span><a href="#40192673">next</a><span>|</span><label class="collapse" for="c-40194005">[-]</label><label class="expand" for="c-40194005">[1 more]</label></div><br/><div class="children"><div class="content">I have never used or seen pimpl in my life, and c++ is all I do</div><br/></div></div><div id="40192673" class="c"><input type="checkbox" id="c-40192673" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#40192250">root</a><span>|</span><a href="#40192581">parent</a><span>|</span><a href="#40194005">prev</a><span>|</span><label class="collapse" for="c-40192673">[-]</label><label class="expand" for="c-40192673">[8 more]</label></div><br/><div class="children"><div class="content">PIMPL is an elegant solution to multiple problems. Idk what you could possibly have against it besides the extra work involved. I don&#x27;t think any language has solved the fundamental problem of hiding details better than PIMPL does.</div><br/><div id="40193321" class="c"><input type="checkbox" id="c-40193321" checked=""/><div class="controls bullet"><span class="by">bananaboy</span><span>|</span><a href="#40192250">root</a><span>|</span><a href="#40192673">parent</a><span>|</span><a href="#40193544">next</a><span>|</span><label class="collapse" for="c-40193321">[-]</label><label class="expand" for="c-40193321">[4 more]</label></div><br/><div class="children"><div class="content">I really like C#&#x27;s `partial` keyword as a solution to the problem of hiding implementation details. It lets you declare a class over several files, so you can have one file which is only the public interface, and another which has private implementation.</div><br/><div id="40193547" class="c"><input type="checkbox" id="c-40193547" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#40192250">root</a><span>|</span><a href="#40193321">parent</a><span>|</span><a href="#40193544">next</a><span>|</span><label class="collapse" for="c-40193547">[-]</label><label class="expand" for="c-40193547">[3 more]</label></div><br/><div class="children"><div class="content">That is essentially the same idea as PIMPL. You put the private parts of the class (e.g., the data layout) in some file that is held privately. I guess you could argue that there is extra syntax involved with PIMPL because C++ is more low-level than C#, but it&#x27;s not so bad. The actual implementation of a class can be spread over as many files as you want in C++.</div><br/><div id="40194414" class="c"><input type="checkbox" id="c-40194414" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#40192250">root</a><span>|</span><a href="#40193547">parent</a><span>|</span><a href="#40193544">next</a><span>|</span><label class="collapse" for="c-40194414">[-]</label><label class="expand" for="c-40194414">[2 more]</label></div><br/><div class="children"><div class="content">And yet C, an even lower-level language, achieves the same effect without the duplication of PIMPL.  You just forward-declare a struct, and declare functions that accept pointers to it: the header doesn&#x27;t need to contain the struct fields, and you don&#x27;t need to define any wrapper functions.  Technically you can do the same in C++.  But in C++ to make an idiomatic API you need methods instead of free functions, and you can&#x27;t declare methods on forward-declared classes.  Why not?  Well, I can imagine some reasons… but they have more to do with C++&#x27;s idiosyncrasies than any fundamental limitation of a low-level language.<p>The C++ committee could address this, but instead they seem to want to pretend separate compilation doesn&#x27;t exist.  (Why are there no official headers to forward-declare STL types, except for whatever happens to be in &lt;iosfwd&gt;?)  Then they complain about how annoying it is to preserve ABI stability for the standard library, blaming the very concept of a stable ABI [1] [2], all while there are simple language tweaks that could make it infinitely more tractable!  But now I&#x27;m ranting.<p>[1] <a href="https:&#x2F;&#x2F;cor3ntin.github.io&#x2F;posts&#x2F;abi&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cor3ntin.github.io&#x2F;posts&#x2F;abi&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;thephd.dev&#x2F;binary-banshees-digital-demons-abi-c-c++-help-me-god-please" rel="nofollow">https:&#x2F;&#x2F;thephd.dev&#x2F;binary-banshees-digital-demons-abi-c-c++-...</a></div><br/><div id="40194958" class="c"><input type="checkbox" id="c-40194958" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#40192250">root</a><span>|</span><a href="#40194414">parent</a><span>|</span><a href="#40193544">next</a><span>|</span><label class="collapse" for="c-40194958">[-]</label><label class="expand" for="c-40194958">[1 more]</label></div><br/><div class="children"><div class="content">First of all, comparing C to C++ in this way is silly, because C++ is a very different language. But there are some similarities.<p>&gt; You just forward-declare a struct, and declare functions that accept pointers to it: the header doesn&#x27;t need to contain the struct fields, and you don&#x27;t need to define any wrapper functions.<p>Those functions would be more verbose because they must contain an explicit `this` equivalent pointer. This would have to be repeated at every single call site. So it&#x27;s not really helping.<p>You don&#x27;t need wrapper functions for PIMPL. You can have them if you think it&#x27;s worthwhile, of course.<p>&gt;Technically you can do the same in C++. But in C++ to make an idiomatic API you need methods instead of free functions, and you can&#x27;t declare methods on forward-declared classes. Why not?<p>There are good technical reasons why you can&#x27;t tack member functions into the interface of a forward-declared function. There would be nowhere for that information to go, if nothing else. I think I heard a talk about adding new metaprogramming features to C++ that <i>might</i> address this in like C++26, but anyway it&#x27;s not a significant problem to simply avoid the problem<p>I think you can probably make some template-based thing that would automate implementing the wrappers for you. But it would be a convoluted solution to what I consider a non-problem.<p>&gt;The C++ committee could address this, but instead they seem to want to pretend separate compilation doesn&#x27;t exist. (Why are there no official headers to forward-declare STL types, except for whatever happens to be in &lt;iosfwd&gt;?)<p>Most of the STL types that people need are based on templates. It does not make sense to forward-declare those. I just don&#x27;t see a use case for forward-declaring much besides io stuff and maybe strings.<p>&gt;Then they complain about how annoying it is to preserve ABI stability for the standard library, blaming the very concept of a stable ABI [1] [2], all while there are simple language tweaks that could make it infinitely more tractable! But now I&#x27;m ranting.<p>There seems to be a faction of the C++ committee that does not share the traditional commitment to backward compatibility. They have gone so far as to lobby for a rolling release language, which is guaranteed to be a disaster if implemented. I think wanting to break ABI might be a sign of that. Let&#x27;s hope they use good judgement and not turn the language into an ever-shifting code rot generator.<p>Keep in mind, there may be ABI breakage coming from your library provider anyway, on top of what the committee wants. So it&#x27;s not necessarily such a cataclysmic surprise as something you&#x27;re supposed to plan around anyway. ABI stability between language standards is mostly a concern for people who link code built with different C++ standards (probably, a lot of code). It wouldn&#x27;t be the end of the world if you had to recompile old code to a newer standard, but it might generate significant work.</div><br/></div></div></div></div></div></div></div></div><div id="40193544" class="c"><input type="checkbox" id="c-40193544" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#40192250">root</a><span>|</span><a href="#40192673">parent</a><span>|</span><a href="#40193321">prev</a><span>|</span><label class="collapse" for="c-40193544">[-]</label><label class="expand" for="c-40193544">[3 more]</label></div><br/><div class="children"><div class="content">Ada had all of C++&#x27;s problems figured out in 1983. PIMPL as a means of boosting compiler performance is fundamentally braindead. We shouldn&#x27;t be bending over backwards with broken tools to make them sort of work.</div><br/><div id="40195360" class="c"><input type="checkbox" id="c-40195360" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40192250">root</a><span>|</span><a href="#40193544">parent</a><span>|</span><a href="#40193572">next</a><span>|</span><label class="collapse" for="c-40195360">[-]</label><label class="expand" for="c-40195360">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunely &quot;bending over backwards with broken tools&quot; is exactly to what made C++ a success in first place, an idea also adopted by Objective-C and TypeScript.<p>Trying to make the best out of an improved langauge, while not touching the broken tools of the existing kingdom they were trying to build upon.<p>Naturally such decision goes both ways, helps gain adoption, and becomes a huge weight to carry around when backwards compatibility matters for staying relevant.</div><br/></div></div><div id="40193572" class="c"><input type="checkbox" id="c-40193572" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#40192250">root</a><span>|</span><a href="#40193544">parent</a><span>|</span><a href="#40195360">prev</a><span>|</span><label class="collapse" for="c-40193572">[-]</label><label class="expand" for="c-40193572">[1 more]</label></div><br/><div class="children"><div class="content">PIMPL doesn&#x27;t only boost compiler performance. It provides code-hiding and ABI stability for everyone using it effectively. It&#x27;s like killing 3 birds with one stone. PIMPL for sure isn&#x27;t gonna be the thing to convince me that C++ is broken.<p>Ada has piqued my curiosity before but I think if it was as good as you make it sound, it might have at least 1% market share after 40 years. It doesn&#x27;t. I can&#x27;t justify the time investment to learn it unless I get a job that demands it.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>