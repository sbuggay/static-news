<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732611672515" as="style"/><link rel="stylesheet" href="styles.css?v=1732611672515"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blogsystem5.substack.com/p/dos-memory-models">Revisiting the DOS Memory Models</a> <span class="domain">(<a href="https://blogsystem5.substack.com">blogsystem5.substack.com</a>)</span></div><div class="subtext"><span>mooreds</span> | <span>24 comments</span></div><br/><div><div id="42243015" class="c"><input type="checkbox" id="c-42243015" checked=""/><div class="controls bullet"><span class="by">jmmv</span><span>|</span><a href="#42243518">next</a><span>|</span><label class="collapse" for="c-42243015">[-]</label><label class="expand" for="c-42243015">[1 more]</label></div><br/><div class="children"><div class="content">Original author here. Thanks for sharing!<p>I see various comments below along the lines of “oh, the article is missing so and so”. OK… then please see the other articles in this series! I think they cover most of what you are mentioning :-)<p>The first was on EMS, XMS, HMA and the like: <a href="https:&#x2F;&#x2F;blogsystem5.substack.com&#x2F;p&#x2F;from-0-to-1-mb-in-dos" rel="nofollow">https:&#x2F;&#x2F;blogsystem5.substack.com&#x2F;p&#x2F;from-0-to-1-mb-in-dos</a><p>The second was on unreal mode: <a href="https:&#x2F;&#x2F;blogsystem5.substack.com&#x2F;p&#x2F;beyond-the-1-mb-barrier-in-dos" rel="nofollow">https:&#x2F;&#x2F;blogsystem5.substack.com&#x2F;p&#x2F;beyond-the-1-mb-barrier-i...</a><p>The third was on DJGPP: <a href="https:&#x2F;&#x2F;blogsystem5.substack.com&#x2F;p&#x2F;running-gnu-on-dos-with-djgpp" rel="nofollow">https:&#x2F;&#x2F;blogsystem5.substack.com&#x2F;p&#x2F;running-gnu-on-dos-with-d...</a><p>And the last, which follows this one, is on 64 bit memory models: <a href="https:&#x2F;&#x2F;blogsystem5.substack.com&#x2F;p&#x2F;x86-64-programming-models" rel="nofollow">https:&#x2F;&#x2F;blogsystem5.substack.com&#x2F;p&#x2F;x86-64-programming-models</a><p>Some of these were previously discussed here too, but composing this in mobile and finding links is rather painful… so excuse me from not providing those links now.</div><br/></div></div><div id="42243518" class="c"><input type="checkbox" id="c-42243518" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42243015">prev</a><span>|</span><a href="#42242888">next</a><span>|</span><label class="collapse" for="c-42243518">[-]</label><label class="expand" for="c-42243518">[2 more]</label></div><br/><div class="children"><div class="content">The Zortech C&#x2F;C++ compiler had another memory model: handle pointers. When dereferencing a handle pointer, the compiler emitted code that would swap in the necessary page from expanded memory, extended memory, or disk.<p>It works like a virtual memory system, except that the compiler emitted the necessary code rather than the CPU doing it in microcode.<p><a href="https:&#x2F;&#x2F;www.digitalmars.com&#x2F;ctg&#x2F;handle-pointers.html" rel="nofollow">https:&#x2F;&#x2F;www.digitalmars.com&#x2F;ctg&#x2F;handle-pointers.html</a><p>Similarly, Zortech C++ had the &quot;VCM&quot; memory model, which worked like virtual memory. Your code pages would be swapped in an out of memory as needed.<p><a href="https:&#x2F;&#x2F;digitalmars.com&#x2F;ctg&#x2F;vcm.html" rel="nofollow">https:&#x2F;&#x2F;digitalmars.com&#x2F;ctg&#x2F;vcm.html</a></div><br/><div id="42243538" class="c"><input type="checkbox" id="c-42243538" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#42243518">parent</a><span>|</span><a href="#42242888">next</a><span>|</span><label class="collapse" for="c-42243538">[-]</label><label class="expand" for="c-42243538">[1 more]</label></div><br/><div class="children"><div class="content">That is sort of like inlining the demand paging code from the OS. When we have exokernels, they exist as a library so can be delt with like regular code<p>This would be trivial (and fun) to implement with Wasm.</div><br/></div></div></div></div><div id="42242888" class="c"><input type="checkbox" id="c-42242888" checked=""/><div class="controls bullet"><span class="by">Aardwolf</span><span>|</span><a href="#42243518">prev</a><span>|</span><a href="#42243521">next</a><span>|</span><label class="collapse" for="c-42242888">[-]</label><label class="expand" for="c-42242888">[6 more]</label></div><br/><div class="children"><div class="content">Many things in computing are elegant and beautiful, but this is not one if them imho (the overlapping segments, the multiple pointer types, the usage of 32 bits to only access 1MB, &#x27;medium&#x27; having less data than &#x27;compact&#x27;, ...)</div><br/><div id="42243469" class="c"><input type="checkbox" id="c-42243469" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#42242888">parent</a><span>|</span><a href="#42243074">next</a><span>|</span><label class="collapse" for="c-42243469">[-]</label><label class="expand" for="c-42243469">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but this is not one<p>It really is though.  Memory and thus data _and_ instruction encoding were incredibly important.  Physical wires on the circuit board were at a premium then as well.  It was an incredibly popular platform because it was highly capable while being stupidly cheap compared to other setups.<p>Engineering is all about tradeoffs.  &quot;Purity&quot; almost never makes it on the whiteboard.</div><br/></div></div><div id="42243074" class="c"><input type="checkbox" id="c-42243074" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#42242888">parent</a><span>|</span><a href="#42243469">prev</a><span>|</span><a href="#42243521">next</a><span>|</span><label class="collapse" for="c-42243074">[-]</label><label class="expand" for="c-42243074">[4 more]</label></div><br/><div class="children"><div class="content">Yeah, good thing that e.g. RV64 has RIP-relative addressing mode that can address anywhere in the whole 56-bits of available space with no problems, unlike the silly 8086 that resorted to using a base register to overcome the short size of its immediate fields.</div><br/><div id="42243472" class="c"><input type="checkbox" id="c-42243472" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#42242888">root</a><span>|</span><a href="#42243074">parent</a><span>|</span><a href="#42243521">next</a><span>|</span><label class="collapse" for="c-42243472">[-]</label><label class="expand" for="c-42243472">[3 more]</label></div><br/><div class="children"><div class="content">...and then x86_64 went ahead and added RIP relative addressing back in,  and you get the full 64 bits of address space.</div><br/><div id="42243602" class="c"><input type="checkbox" id="c-42243602" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#42242888">root</a><span>|</span><a href="#42243472">parent</a><span>|</span><a href="#42243521">next</a><span>|</span><label class="collapse" for="c-42243602">[-]</label><label class="expand" for="c-42243602">[2 more]</label></div><br/><div class="children"><div class="content">...you know that that&#x27;s not true, neither for x64 nor RV64, and my comment was sarcastic, right? Both can only straightforwardly address ±2 GiB from the instruction pointer; beyond that, it&#x27;s &quot;large code model&quot; all over again, with the same inelegant workarounds that&#x27;s been rediscovered since the late sixties or so. GOT and PLT versus pools of absolute 64-bit addresses, pick the least worst one.</div><br/><div id="42243709" class="c"><input type="checkbox" id="c-42243709" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#42242888">root</a><span>|</span><a href="#42243602">parent</a><span>|</span><a href="#42243521">next</a><span>|</span><label class="collapse" for="c-42243709">[-]</label><label class="expand" for="c-42243709">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and my comment was sarcastic, right?<p>Pardon me for not realizing and treating it appropriately.<p>&gt; with the same inelegant workarounds that&#x27;s been rediscovered since the late sixties or so<p>Short of creating instructions that take 64bit immediate operands you&#x27;re always going to pay the same price.  An indirection.  This will look different because it will be implemented most efficiently differently on different architectures.<p>&gt; GOT and PLT versus pools of absolute 64-bit addresses, pick the least worst one.<p>Or statically define all those addresses within your binary.  That seems more &quot;elegant&quot; to you?  You&#x27;ll have the same problem but your loader will now be inside out or you&#x27;ll have none of the features the loader can provide for you.<p>At that point just statically link all your dependencies and  call it an early day.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42243521" class="c"><input type="checkbox" id="c-42243521" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#42242888">prev</a><span>|</span><a href="#42242922">next</a><span>|</span><label class="collapse" for="c-42243521">[-]</label><label class="expand" for="c-42243521">[1 more]</label></div><br/><div class="children"><div class="content">I think it is a pity Intel went with 16 byte paragraphs instead of 256 byte paragraphs for the 8086.<p>With 16 byte paragraphs, a 16 bit segment and 16 bit offset can only address 1MiB (ignoring the HMA you can get on 80286+).<p>With 256 byte paragraphs, the 8086 would have been able to address 16MiB in real mode (again not counting the HMA, which would have been a bit smaller: 65,280 bytes instead of 65,520 bytes).</div><br/></div></div><div id="42242922" class="c"><input type="checkbox" id="c-42242922" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#42243521">prev</a><span>|</span><a href="#42243137">next</a><span>|</span><label class="collapse" for="c-42242922">[-]</label><label class="expand" for="c-42242922">[2 more]</label></div><br/><div class="children"><div class="content">I feel like this is missing EMS and XMS memory. Both were well supported ways of getting more than 640k. EMS worked by page banking. 1 or 2 64k segments of memory would be changed to point to different 64k banks from an add on memory card.  XMS just did a copy instead of a page bank IIRC. It&#x27;s been a long time but I wrote DOS apps that used both to support more than 640k of memory using both standards.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Expanded_memory" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Expanded_memory</a><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Extended_memory" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Extended_memory</a></div><br/><div id="42242998" class="c"><input type="checkbox" id="c-42242998" checked=""/><div class="controls bullet"><span class="by">jmmv</span><span>|</span><a href="#42242922">parent</a><span>|</span><a href="#42243137">next</a><span>|</span><label class="collapse" for="c-42242998">[-]</label><label class="expand" for="c-42242998">[1 more]</label></div><br/><div class="children"><div class="content">You should read the very first article I wrote in this “series” then, linked to from the opening paragraph: <a href="https:&#x2F;&#x2F;blogsystem5.substack.com&#x2F;p&#x2F;from-0-to-1-mb-in-dos" rel="nofollow">https:&#x2F;&#x2F;blogsystem5.substack.com&#x2F;p&#x2F;from-0-to-1-mb-in-dos</a> (previously discussed in <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39031369">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39031369</a> at the beginning of the year).</div><br/></div></div></div></div><div id="42243137" class="c"><input type="checkbox" id="c-42243137" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42242922">prev</a><span>|</span><a href="#42222757">next</a><span>|</span><label class="collapse" for="c-42243137">[-]</label><label class="expand" for="c-42243137">[1 more]</label></div><br/><div class="children"><div class="content">As someone that was already coding during those days, having done the transition from a Timex 2068 into MS-DOS 3.3 and wonderful 5¼-inch floppies, the article is quite good.<p>One thing missing are overlays, where we could have some form of primitive dynamic loading, having multiple code segments for the same memory region, naturally only one could be active at a time.</div><br/></div></div><div id="42222757" class="c"><input type="checkbox" id="c-42222757" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42243137">prev</a><span>|</span><a href="#42242944">next</a><span>|</span><label class="collapse" for="c-42222757">[-]</label><label class="expand" for="c-42222757">[3 more]</label></div><br/><div class="children"><div class="content">Today Java has pointer compression where you use a 32 bit reference but shift it a few places to the left to make a 64-bit address which saves space on pointers but wastes it on alignment</div><br/><div id="42243258" class="c"><input type="checkbox" id="c-42243258" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#42222757">parent</a><span>|</span><a href="#42242933">next</a><span>|</span><label class="collapse" for="c-42243258">[-]</label><label class="expand" for="c-42243258">[1 more]</label></div><br/><div class="children"><div class="content">All allocated objects would have the three least significant bits as 0. Any java object cannot be &#x27;too small&#x27; as they all have object headers (more if you need a fully blown synchronized&#x2F;mutex). So with compressed pointers (up to 32GB Heaps) all objects are aligned but then again, each pointer is 4 bytes only (instead of 8). Overall it&#x27;s a massive win.</div><br/></div></div><div id="42242933" class="c"><input type="checkbox" id="c-42242933" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#42222757">parent</a><span>|</span><a href="#42243258">prev</a><span>|</span><a href="#42242944">next</a><span>|</span><label class="collapse" for="c-42242933">[-]</label><label class="expand" for="c-42242933">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not wasted on alignment, since that alignment is already required (unless you need a very large heap). Remember that Java&#x27;s GC heap is <i>only</i> used to allocate Objects, not raw bytes. There are ways to allocate memory outside of the heap and if you&#x27;re dealing with that much raw data you should probably be using them.</div><br/></div></div></div></div><div id="42242944" class="c"><input type="checkbox" id="c-42242944" checked=""/><div class="controls bullet"><span class="by">geon</span><span>|</span><a href="#42222757">prev</a><span>|</span><a href="#42242965">next</a><span>|</span><label class="collapse" for="c-42242944">[-]</label><label class="expand" for="c-42242944">[3 more]</label></div><br/><div class="children"><div class="content">Is this only relevant to real mode, or is it still in use in protected mode and&#x2F;or x64?</div><br/><div id="42243010" class="c"><input type="checkbox" id="c-42243010" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#42242944">parent</a><span>|</span><a href="#42242965">next</a><span>|</span><label class="collapse" for="c-42243010">[-]</label><label class="expand" for="c-42243010">[2 more]</label></div><br/><div class="children"><div class="content">On 32-bit Windows, segmentation registers still exist, but they are almost always set to zero.  CS (code segment), DS (data segment), ES (extra segment), and SS (stack segment) are all set to zero.  But FS and GS are used for other purposes.<p>For a 32-bit program, FS is used to point to the Thread Information Block (TIB).  GS is used to point to thread-local storage since after Windows XP.  Programs using GS for thread-local storage won&#x27;t work on prior versions of Windows (they&#x27;ll just crash on the first access).<p>X64 made it even more formal that CS, DS, SS and ES are fixed at zero.  32-bit programs running on a 64-bit OS can&#x27;t reassign them anymore, but basically no programs actually try to do that anyway.<p>---<p>As for shorter types of pointers being in use?  Basically shorter pointers are only used for things relative to the program counter EIP, such as short jumps.  With 32-bit protected mode code, you can use 32-bit pointers and not worry about 64K-size segments at all.<p>---<p>Meanwhile, some x64 programs did adopt a convention to use shorter pointers, 32-bit pointers on a 64-bit operating system.  This convention is called x32, but almost nobody adopted it.</div><br/><div id="42243275" class="c"><input type="checkbox" id="c-42243275" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#42242944">root</a><span>|</span><a href="#42243010">parent</a><span>|</span><a href="#42242965">next</a><span>|</span><label class="collapse" for="c-42243275">[-]</label><label class="expand" for="c-42243275">[1 more]</label></div><br/><div class="children"><div class="content">&gt;some x64 programs did adopt a convention to use shorter pointers, 32-bit pointers on a 64-bit operating system.<p>It&#x27;s doable in managed languages, e.g. Java has compressed pointers  by default on sub 32GB heaps. I suppose it&#x27;s doable even in C alike setup (incl OS calls) but that would require wrappers to bit shift the pointers on each dereference (and passive to the OS, extern)</div><br/></div></div></div></div></div></div><div id="42242965" class="c"><input type="checkbox" id="c-42242965" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#42242944">prev</a><span>|</span><a href="#42230004">next</a><span>|</span><label class="collapse" for="c-42242965">[-]</label><label class="expand" for="c-42242965">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s worth noting that <i>all</i> the memory models have DS=SS, which makes sense for C (where you often take the address of a local variable - though nothing is <i>stopping</i> you from having a separate &quot;data stack&quot; for those) but is a silly restriction for some other languages.<p>I&#x27;m sure <i>someone</i> took advantage of this, but my knowledge is purely theoretical.</div><br/><div id="42243262" class="c"><input type="checkbox" id="c-42243262" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#42242965">parent</a><span>|</span><a href="#42230004">next</a><span>|</span><label class="collapse" for="c-42243262">[-]</label><label class="expand" for="c-42243262">[1 more]</label></div><br/><div class="children"><div class="content">I never had SS=DS in Assembly. Used it for TSR for example.</div><br/></div></div></div></div><div id="42230004" class="c"><input type="checkbox" id="c-42230004" checked=""/><div class="controls bullet"><span class="by">brudgers</span><span>|</span><a href="#42242965">prev</a><span>|</span><a href="#42243444">next</a><span>|</span><label class="collapse" for="c-42230004">[-]</label><label class="expand" for="c-42230004">[1 more]</label></div><br/><div class="children"><div class="content">&quot;DOS Memory Models&quot; brought &quot;QEMM&quot; immediately to mind.<p>So possibly related, <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;QEMM" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;QEMM</a></div><br/></div></div><div id="42243444" class="c"><input type="checkbox" id="c-42243444" checked=""/><div class="controls bullet"><span class="by">malthaus</span><span>|</span><a href="#42230004">prev</a><span>|</span><label class="collapse" for="c-42243444">[-]</label><label class="expand" for="c-42243444">[1 more]</label></div><br/><div class="children"><div class="content">this brings back traumatic memories of fiddling for hours with various config files to make games work on DOS back in the day</div><br/></div></div></div></div></div></div></div></body></html>