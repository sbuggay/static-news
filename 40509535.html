<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717059669946" as="style"/><link rel="stylesheet" href="styles.css?v=1717059669946"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.felixge.de/blazingly-fast-shadow-stacks-for-go/">Fast Shadow Stacks for Go</a>Â <span class="domain">(<a href="https://blog.felixge.de">blog.felixge.de</a>)</span></div><div class="subtext"><span>ingve</span> | <span>9 comments</span></div><br/><div><div id="40521159" class="c"><input type="checkbox" id="c-40521159" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#40520823">next</a><span>|</span><label class="collapse" for="c-40521159">[-]</label><label class="expand" for="c-40521159">[3 more]</label></div><br/><div class="children"><div class="content">In an ideal world, we&#x27;d be using an ABI that keeps the code (return addresses) and data (spilled function params&#x2F;locals) in two separate stacks. Then the profiling would be as straightforward as a memory copy of the code stack.</div><br/><div id="40521377" class="c"><input type="checkbox" id="c-40521377" checked=""/><div class="controls bullet"><span class="by">mmaniac</span><span>|</span><a href="#40521159">parent</a><span>|</span><a href="#40521192">next</a><span>|</span><label class="collapse" for="c-40521377">[-]</label><label class="expand" for="c-40521377">[1 more]</label></div><br/><div class="children"><div class="content">Would that not complicate function prologues &amp; epilogues?<p>I suppose hardware support (e.g. dedicated call&#x2F;ret instructions accessing a second stack pointer) is also desirable if you want to do this sort of thing.</div><br/></div></div><div id="40521192" class="c"><input type="checkbox" id="c-40521192" checked=""/><div class="controls bullet"><span class="by">felixge</span><span>|</span><a href="#40521159">parent</a><span>|</span><a href="#40521377">prev</a><span>|</span><a href="#40520823">next</a><span>|</span><label class="collapse" for="c-40521192">[-]</label><label class="expand" for="c-40521192">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what hardware shadow stacks in modern intel&#x2F;arm CPUs can do! It just needs to be exposed to user space and become widely available.</div><br/></div></div></div></div><div id="40520823" class="c"><input type="checkbox" id="c-40520823" checked=""/><div class="controls bullet"><span class="by">felixge</span><span>|</span><a href="#40521159">prev</a><span>|</span><label class="collapse" for="c-40520823">[-]</label><label class="expand" for="c-40520823">[5 more]</label></div><br/><div class="children"><div class="content">OP here, happy to answer any question.</div><br/><div id="40521049" class="c"><input type="checkbox" id="c-40521049" checked=""/><div class="controls bullet"><span class="by">nikolayasdf123</span><span>|</span><a href="#40520823">parent</a><span>|</span><a href="#40520956">next</a><span>|</span><label class="collapse" for="c-40521049">[-]</label><label class="expand" for="c-40521049">[2 more]</label></div><br/><div class="children"><div class="content">Did you get any response from Go core team? Might make sense to open issue in GitHub <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;</a> and start thread in <a href="https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-dev" rel="nofollow">https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-dev</a></div><br/><div id="40521074" class="c"><input type="checkbox" id="c-40521074" checked=""/><div class="controls bullet"><span class="by">felixge</span><span>|</span><a href="#40520823">root</a><span>|</span><a href="#40521049">parent</a><span>|</span><a href="#40520956">next</a><span>|</span><label class="collapse" for="c-40521074">[-]</label><label class="expand" for="c-40521074">[1 more]</label></div><br/><div class="children"><div class="content">I know that at least two engineers from the runtime team have seen the post in the #darkarts channel of gopher slack. One of them left a fire emoji :).<p>I&#x27;ll probably bring it up in the by-weekly Go runtime diagnostics sync [1] next Thursday, but my guess is that they&#x27;ll have the same conclusion as me: Neat trick, but not a good idea for the runtime until hardware shadow stacks become widely available and accessible.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;57175">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;57175</a></div><br/></div></div></div></div><div id="40520956" class="c"><input type="checkbox" id="c-40520956" checked=""/><div class="controls bullet"><span class="by">nickcw</span><span>|</span><a href="#40520823">parent</a><span>|</span><a href="#40521049">prev</a><span>|</span><label class="collapse" for="c-40520956">[-]</label><label class="expand" for="c-40520956">[2 more]</label></div><br/><div class="children"><div class="content">Very interesting article thank you.<p>Do you see this speeding up real world Go programs?</div><br/><div id="40520999" class="c"><input type="checkbox" id="c-40520999" checked=""/><div class="controls bullet"><span class="by">felixge</span><span>|</span><a href="#40520823">root</a><span>|</span><a href="#40520956">parent</a><span>|</span><label class="collapse" for="c-40520999">[-]</label><label class="expand" for="c-40520999">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! And to answer you question: No, it won&#x27;t speed up Go programs for now. This was mostly a fun research project for me.<p>The low hanging fruits to speed up stack unwinding in the Go runtime is to switch to frame pointer unwinding in more places. In go1.21 we contributed patches to do this for the execution tracer. For the upcoming go1.23 release, my colleague Nick contributed patches to upgrade the block and mutex profiler. Once the go1.24 tree opens, we&#x27;re hoping to tackle the memory profiler as well as copystack. The latter would benefit all Go programs, even those not using profiling. But it&#x27;s likely going to be relative small win (&lt;= 1%).<p>Once all of this is done, shadow stacks have the potential to make things even faster. But the problem is that we&#x27;ll be deeply in diminishing returns territory at that point. Speeding up stack capturing is great when it makes up 80-90% of your overhead (this was the case for the execution tracer before frame pointers). But once we&#x27;re down to 1-2% (the current situation for the execution tracer), another 8x speedup is not going to buy us much, especially when it has downsides.<p>The only future in which shadow stacks could speed up real Go programs is one where we decide to drop frame pointer support in the compiler, which could provide 1-2% speedup for all Go programs. Once hardware shadow stacks become widely available and accessible, I think that would be worth considering. But that&#x27;s likely to be a few years down the road from now.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>