<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734080459057" as="style"/><link rel="stylesheet" href="styles.css?v=1734080459057"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://research.swtch.com/plmm">Programming Language Memory Models (2021)</a>Â <span class="domain">(<a href="https://research.swtch.com">research.swtch.com</a>)</span></div><div class="subtext"><span>fanf2</span> | <span>26 comments</span></div><br/><div><div id="42400471" class="c"><input type="checkbox" id="c-42400471" checked=""/><div class="controls bullet"><span class="by">pvg</span><span>|</span><a href="#42401501">next</a><span>|</span><label class="collapse" for="c-42400471">[-]</label><label class="expand" for="c-42400471">[1 more]</label></div><br/><div class="children"><div class="content">Discussion at the time <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27750610">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27750610</a></div><br/></div></div><div id="42401501" class="c"><input type="checkbox" id="c-42401501" checked=""/><div class="controls bullet"><span class="by">kmeisthax</span><span>|</span><a href="#42400471">prev</a><span>|</span><a href="#42405926">next</a><span>|</span><label class="collapse" for="c-42401501">[-]</label><label class="expand" for="c-42401501">[20 more]</label></div><br/><div class="children"><div class="content">I&#x27;d like to necro one particular comment from this discussion. Someone said that &quot;x86 cannot have acquire&#x2F;release semantics&quot;, because by default x86 has total store order (TSO).<p>My question: What stops Intel or AMD from providing an opt-in weaker memory model? Or what would the programming model look like for new programs that wanted to abandon TSO for better performance? Would it just be weak order prefixes for existing memory-altering instructions? Would you need a process-wide bit to weakly order the whole program? Would that affect loaded libraries (including OS-provided libraries) too? Would programs dropping TSO potentially affect kernels or hypervisors above them on the privilege hierarchy of the CPU?</div><br/><div id="42401668" class="c"><input type="checkbox" id="c-42401668" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#42401501">parent</a><span>|</span><a href="#42402060">next</a><span>|</span><label class="collapse" for="c-42401668">[-]</label><label class="expand" for="c-42401668">[8 more]</label></div><br/><div class="children"><div class="content">To be pedantic, x86 <i>does</i> have opt-in weaker memory models. When you&#x27;re setting up the TLB entries, you can configure how strong the cache behavior is for the memory... which means in practice, you can&#x27;t really access these memory models unless you&#x27;re doing firmware, or you&#x27;re using nontemporal stores [1].<p>On a more practical level, however, it&#x27;s actually disruptive to make the hardware have optional less-restrictive semantic operations, because the other instructions might need more fences to guarantee the necessary properties. For example, on x86, compilers drop all explicit store fences because they&#x27;re &quot;unnecessary&quot; on the hardware, and adding in operations that would make them necessary, even for existing code that doesn&#x27;t know about the instructions that don&#x27;t exist yet.<p>[1] Incidentally, this means trying to read the manual to figure out what a nontemporal store actually does can feel like turning your brain to mush.</div><br/><div id="42404017" class="c"><input type="checkbox" id="c-42404017" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#42401501">root</a><span>|</span><a href="#42401668">parent</a><span>|</span><a href="#42401760">next</a><span>|</span><label class="collapse" for="c-42404017">[-]</label><label class="expand" for="c-42404017">[3 more]</label></div><br/><div class="children"><div class="content">The cache behavior regarding the ordering of memory accesses cannot be configured.<p>What you can select when mapping memory is to make some regions uncached (with several variants, e.g. write-combining).<p>Some of the kinds of uncached memory regions, especially those whose names include &quot;write-combining&quot;, implement weaker orderings of the memory accesses in comparison with how cacheable memory works on x86, where 3 of the 4 kinds of memory access reorderings are prohibited (i.e. all except that subsequent loads can be performed before prior stores).<p>However choosing a memory type with weakly-ordered accesses cannot increase the performance on x86, because the loss of performance by not using the cache is much greater.<p>The weakly-ordered accesses only recover a small part of the performance loss caused by uncached memory.</div><br/><div id="42404889" class="c"><input type="checkbox" id="c-42404889" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#42401501">root</a><span>|</span><a href="#42404017">parent</a><span>|</span><a href="#42401760">next</a><span>|</span><label class="collapse" for="c-42404889">[-]</label><label class="expand" for="c-42404889">[2 more]</label></div><br/><div class="children"><div class="content">Is the mapping memory stuff separate from what&#x27;s being set up by the OS as part of the TLB? I&#x27;m generally willfully ignorant of the privileged side of ISAs since I&#x27;m firmly a compilers guy, so I mostly only got this level of stuff by having to look at it thanks to it being incorporated into the definition of nontemporal store on x86 (which still ends up being confusing as heck).</div><br/><div id="42405450" class="c"><input type="checkbox" id="c-42405450" checked=""/><div class="controls bullet"><span class="by">NobodyNada</span><span>|</span><a href="#42401501">root</a><span>|</span><a href="#42404889">parent</a><span>|</span><a href="#42401760">next</a><span>|</span><label class="collapse" for="c-42405450">[-]</label><label class="expand" for="c-42405450">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the &quot;mapping memory stuff&quot; is the page tables. (The TLB is an internal cache the processor keeps of recently used page table entries, which is <i>mostly</i> internal to the processor and transparent to the OS, except that the OS needs to remember to issue a special instruction to invalidate the TLB after modifying page tables.)</div><br/></div></div></div></div></div></div><div id="42401760" class="c"><input type="checkbox" id="c-42401760" checked=""/><div class="controls bullet"><span class="by">kmeisthax</span><span>|</span><a href="#42401501">root</a><span>|</span><a href="#42401668">parent</a><span>|</span><a href="#42404017">prev</a><span>|</span><a href="#42402060">next</a><span>|</span><label class="collapse" for="c-42401760">[-]</label><label class="expand" for="c-42401760">[4 more]</label></div><br/><div class="children"><div class="content">&gt; For example, on x86, compilers drop all explicit store fences because they&#x27;re &quot;unnecessary&quot; on the hardware<p>I mean specifically for new programs that are written with weaker memory models in mind. So you&#x27;d have to enable an -fNOTSO flag on your compiler that emits all the fences that would otherwise be skipped.<p>Looking at what I can find about nontemporal stores, they sound like they already have a weird kind of release semantics on x86, even though their intent was to avoid cache thrashing, not so much to allow greater memory reordering. Are these actually used in compilers?</div><br/><div id="42406556" class="c"><input type="checkbox" id="c-42406556" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#42401501">root</a><span>|</span><a href="#42401760">parent</a><span>|</span><a href="#42401780">next</a><span>|</span><label class="collapse" for="c-42406556">[-]</label><label class="expand" for="c-42406556">[1 more]</label></div><br/><div class="children"><div class="content">Compilers can generate non-temporal ops if you ask for it explicitly in some form. And they are problematic: <a href="https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;64521">https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;64521</a></div><br/></div></div><div id="42401780" class="c"><input type="checkbox" id="c-42401780" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#42401501">root</a><span>|</span><a href="#42401760">parent</a><span>|</span><a href="#42406556">prev</a><span>|</span><a href="#42403351">next</a><span>|</span><label class="collapse" for="c-42401780">[-]</label><label class="expand" for="c-42401780">[1 more]</label></div><br/><div class="children"><div class="content">Compilers will generally expose a nontemporal store intrinsic, but don&#x27;t expect them to actually try to use it automatically.</div><br/></div></div><div id="42403351" class="c"><input type="checkbox" id="c-42403351" checked=""/><div class="controls bullet"><span class="by">anonymousDan</span><span>|</span><a href="#42401501">root</a><span>|</span><a href="#42401760">parent</a><span>|</span><a href="#42401780">prev</a><span>|</span><a href="#42402060">next</a><span>|</span><label class="collapse" for="c-42403351">[-]</label><label class="expand" for="c-42403351">[1 more]</label></div><br/><div class="children"><div class="content">I think they were particularly beneficial in some workloads for optane persistent memory</div><br/></div></div></div></div></div></div><div id="42402060" class="c"><input type="checkbox" id="c-42402060" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#42401501">parent</a><span>|</span><a href="#42401668">prev</a><span>|</span><a href="#42402148">next</a><span>|</span><label class="collapse" for="c-42402060">[-]</label><label class="expand" for="c-42402060">[1 more]</label></div><br/><div class="children"><div class="content">(We detached this from <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42400471">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42400471</a> since it&#x27;s a good top-level comment)</div><br/></div></div><div id="42402148" class="c"><input type="checkbox" id="c-42402148" checked=""/><div class="controls bullet"><span class="by">SubjectToChange</span><span>|</span><a href="#42401501">parent</a><span>|</span><a href="#42402060">prev</a><span>|</span><a href="#42403078">next</a><span>|</span><label class="collapse" for="c-42402148">[-]</label><label class="expand" for="c-42402148">[1 more]</label></div><br/><div class="children"><div class="content"><i>My question: What stops Intel or AMD from providing an opt-in weaker memory model?</i><p>Probably for the same reason Intel&#x2F;AMD doesn&#x27;t get rid of the rest of the cruft in x86-64, i.e. backwards compatibility. Additionally, there would be issues with Intel&#x2F;AMD leveraging an optional weak memory model in their chips without compromising the performance of legacy TSO applications. They are probably better off making x86-64 perform best under TSO.</div><br/></div></div><div id="42403078" class="c"><input type="checkbox" id="c-42403078" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#42401501">parent</a><span>|</span><a href="#42402148">prev</a><span>|</span><a href="#42401686">next</a><span>|</span><label class="collapse" for="c-42403078">[-]</label><label class="expand" for="c-42403078">[6 more]</label></div><br/><div class="children"><div class="content">&gt; x86 cannot have acquire&#x2F;release semantics<p>As I said at the time, this is nonsense. All stores on x86 are have release semantics and all loads have acquire semantics.<p>Atomic RMW are sequentially consistent.<p>Technically you could implement relaxed stores via non temporal stores but it would be pointless.</div><br/><div id="42403754" class="c"><input type="checkbox" id="c-42403754" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#42401501">root</a><span>|</span><a href="#42403078">parent</a><span>|</span><a href="#42403628">next</a><span>|</span><label class="collapse" for="c-42403754">[-]</label><label class="expand" for="c-42403754">[1 more]</label></div><br/><div class="children"><div class="content">It is correct that on x86 all normal stores have release semantics and all normal loads have acquire semantics (only a few instructions behave differently, i.e. the string instructions and the streaming &quot;non-temporal&quot; store instructions).<p>However the ordering properties of the x86 stores and loads are stronger than that. An x86 store is not only a release store, but it has an additional property that could be called of being an &quot;initial store&quot;, i.e. a store that is guaranteed to be performed before all subsequent stores.<p>An x86 load is not only an acquire load, but it has an additional property that could be called of being a &quot;final load&quot;, i.e. a load that is guaranteed to be performed after all prior loads.<p>The research paper that has introduced the concepts of acquire loads and release stores (in May 1990) was mistaken. They have claimed that these 2 kinds of accesses are enough for the synchronization of accesses to shared resources.<p>While it is true that acquire loads and release  stores are sufficient for implementing critical sections, there are other algorithms for accessing shared resources that need the other 2 kinds of ordered loads and stores, i.e. final loads and initial stores.<p>On x86, this does not matter, because the normal loads and stores provide all 4 kinds of ordered loads and stores, so any algorithm can be implemented without using memory barriers or other special instructions.<p>In ISAs that provide only 2 kinds of ordered loads and stores, i.e. acquire loads and release stores, like Arm Aarch64, the other 2 kinds of ordered loads and stores must be synthesized using memory barriers, i.e. an initial store is made by a weakly-ordered store followed by a store barrier, while a final load is made by a weakly-ordered load preceded by a load barrier.<p>Arm Aarch64 does not have load barriers, but it has stronger acquire barriers, which can always be used instead of any load barriers. The Arm Aarch64 acquire barrier has the confusing mnemonic DMB.LD, apparently inspired by the x86 LFENCE, which is also an acquire barrier, not a load barrier, despite its confusing mnemonic.<p>(a load barrier guarantees that all prior loads are performed before all subsequent loads; an acquire barrier guarantees that all prior loads are performed before all subsequent loads <i>and</i> stores; such memory barriers are stronger than necessary; the weaker ordering properties provided by the 4 kinds of ordered loads and stores are sufficient)</div><br/></div></div><div id="42403628" class="c"><input type="checkbox" id="c-42403628" checked=""/><div class="controls bullet"><span class="by">kmeisthax</span><span>|</span><a href="#42401501">root</a><span>|</span><a href="#42403078">parent</a><span>|</span><a href="#42403754">prev</a><span>|</span><a href="#42401686">next</a><span>|</span><label class="collapse" for="c-42403628">[-]</label><label class="expand" for="c-42403628">[4 more]</label></div><br/><div class="children"><div class="content">For those watching along at home, we&#x27;re talking about these two comments from dragontamer:<p>- <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27753913">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27753913</a><p>- <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27762749">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27762749</a><p>I interpreted dragontamer&#x27;s comment to mean &quot;x86 does not have relaxed stores&quot;, not &quot;x86 does not have a strong memory model&quot;. The (presumed) problem is that you can&#x27;t actually test acquire&#x2F;release code on x86, because it won&#x27;t crash if you get it wrong.<p>There&#x27;s a second level of this in C++&#x27;s memory model: consume&#x2F;release. I&#x27;ve no idea what the difference between acquire and consume are; when I look it up there&#x27;s usually some reference to the DEC Alpha, a 30 year old workstation and server chip nobody uses today which was legendary for pushing the boundaries of memory ordering. My assumption is that no hardware provides memory ordering exactly as weak as consume, so I shouldn&#x27;t bother asking for it, since it&#x27;ll just get strengthened to acquire on any chip that matters.<p>Also, from you and one other person, it sounds like relaxed memory models aren&#x27;t actually a performance benefit? Would the opposite - ARM mandating TSO in ARMv9.1-A or whatever - make sense? A lot of ink and code is wasted talking about memory model strengths.</div><br/><div id="42403869" class="c"><input type="checkbox" id="c-42403869" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#42401501">root</a><span>|</span><a href="#42403628">parent</a><span>|</span><a href="#42401686">next</a><span>|</span><label class="collapse" for="c-42403869">[-]</label><label class="expand" for="c-42403869">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s a second level of this in C++&#x27;s memory model: consume&#x2F;release. I&#x27;ve no idea what the difference between acquire and consume are; when I look it up there&#x27;s usually some reference to the DEC Alpha, a 30 year old workstation and server chip nobody uses today which was legendary for pushing the boundaries of memory ordering. My assumption is that no hardware provides memory ordering exactly as weak as consume, so I shouldn&#x27;t bother asking for it, since it&#x27;ll just get strengthened to acquire on any chip that matters.<p>You have it wrong here.<p>So the basic idea behind release&#x2F;consume comes from an observation that, on all hardware not named Alpha [1], there is no hardware fence needed to guarantee that a load happens-before another load that is data-dependent on the first load. So the C++ committee decided to add a memory model that would preserve this guarantee. A consume load is exactly like an acquire load, but only for other loads that are data-dependent on that load as opposed to all loads in general. So whereas an acquire load requires a fence on pretty much every hardware not x86 or SPARC in TSO mode, a consume load would only require a fence on Alpha.<p>For various reasons, data-dependency isn&#x27;t a property that compilers are in the position of guaranteeing, which means every compiler ended up implementing consume as the stronger acquire instead, defeating its entire design goal of eliminating unnecessary fences. There have been a couple of attempts within the committee to try to find a path that would let something like consume by tweaking the necessary data dependence definitions, but none of them have swayed the implementers, so the current state is that they&#x27;ve given up and let consume die.<p>Of particular note is that release&#x2F;consume is not designed to <i>support</i> the Alpha memory model; in fact, it&#x27;s quite the opposite: it&#x27;s designed to support everybody <i>but</i> Alpha, since for Alpha (and essentially only Alpha), release&#x2F;consume is not usefully weaker than release&#x2F;acquire. Instead, the people who benefit are the PPCs and the ARMs of the world, for whom release&#x2F;consume is a better approximation of their native memory model and would allow many fences to be omitted.<p>[1] Actually, some accelerator hardware might have memory models as weak as Alpha here, but I&#x27;m far less familiar with memory models as they apply to accelerators.</div><br/><div id="42406274" class="c"><input type="checkbox" id="c-42406274" checked=""/><div class="controls bullet"><span class="by">kmeisthax</span><span>|</span><a href="#42401501">root</a><span>|</span><a href="#42403869">parent</a><span>|</span><a href="#42404365">next</a><span>|</span><label class="collapse" for="c-42406274">[-]</label><label class="expand" for="c-42406274">[1 more]</label></div><br/><div class="children"><div class="content">So, just to confirm my own (new) understanding now:<p>Consume is &quot;I want to read data from a pointer, please do not reorder loads that go through the pointer&quot;<p>and Acquire is &quot;I want to read data from a pointer, please do not reorder loads that happen after this one, *whether or not they go through the same pointer&quot;<p>there&#x27;s no relation to the Alpha aside from it being the only processor that needs a barrier for Consume<p>and for whatever reason compilers don&#x27;t or can&#x27;t do the dependency tracking that would let them take advantage of the weaker guarantees of Consume, so in practice it just becomes Acquire?</div><br/></div></div><div id="42404365" class="c"><input type="checkbox" id="c-42404365" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#42401501">root</a><span>|</span><a href="#42403869">parent</a><span>|</span><a href="#42406274">prev</a><span>|</span><a href="#42401686">next</a><span>|</span><label class="collapse" for="c-42404365">[-]</label><label class="expand" for="c-42404365">[1 more]</label></div><br/><div class="children"><div class="content">Thank you! I have argued this point so many times on HN :).</div><br/></div></div></div></div></div></div></div></div><div id="42401686" class="c"><input type="checkbox" id="c-42401686" checked=""/><div class="controls bullet"><span class="by">4ad</span><span>|</span><a href="#42401501">parent</a><span>|</span><a href="#42403078">prev</a><span>|</span><a href="#42405926">next</a><span>|</span><label class="collapse" for="c-42401686">[-]</label><label class="expand" for="c-42401686">[3 more]</label></div><br/><div class="children"><div class="content">There is this myth that having a weaker memory model can lead to higher performance. It sounds plausible, and it was a good idea to explore at the end of the 80s, but in the end it turned out that it&#x27;s simply not substantiated by facts. Note that Apple Silicon is TSO.<p>Related: <a href="https:&#x2F;&#x2F;kcsrk.info&#x2F;papers&#x2F;pldi18-memory.pdf" rel="nofollow">https:&#x2F;&#x2F;kcsrk.info&#x2F;papers&#x2F;pldi18-memory.pdf</a></div><br/><div id="42402005" class="c"><input type="checkbox" id="c-42402005" checked=""/><div class="controls bullet"><span class="by">SubjectToChange</span><span>|</span><a href="#42401501">root</a><span>|</span><a href="#42401686">parent</a><span>|</span><a href="#42401820">next</a><span>|</span><label class="collapse" for="c-42402005">[-]</label><label class="expand" for="c-42402005">[1 more]</label></div><br/><div class="children"><div class="content"><i>Note that Apple Silicon is TSO.</i><p>Apple Silicon supports both Arm&#x27;s relaxed memory model and Intel&#x27;s TSO for backwards compatibility. Microsoft is doing the same for Windows on Arm.</div><br/></div></div><div id="42401820" class="c"><input type="checkbox" id="c-42401820" checked=""/><div class="controls bullet"><span class="by">fwip</span><span>|</span><a href="#42401501">root</a><span>|</span><a href="#42401686">parent</a><span>|</span><a href="#42402005">prev</a><span>|</span><a href="#42405926">next</a><span>|</span><label class="collapse" for="c-42401820">[-]</label><label class="expand" for="c-42401820">[1 more]</label></div><br/><div class="children"><div class="content">Apple&#x27;s Mx chip has an instruction to enable TSO, which Rosetta uses when running x86 code. I don&#x27;t believe it uses TSO when running native ARM code, but I could be mistaken.</div><br/></div></div></div></div></div></div><div id="42405926" class="c"><input type="checkbox" id="c-42405926" checked=""/><div class="controls bullet"><span class="by">squirrellous</span><span>|</span><a href="#42401501">prev</a><span>|</span><a href="#42400453">next</a><span>|</span><label class="collapse" for="c-42405926">[-]</label><label class="expand" for="c-42405926">[1 more]</label></div><br/><div class="children"><div class="content">Just wanted to say that to me, this series is the holy grail of breaking down an inscrutably technical topic with decades of research behind it into understandable language, while at the same time retaining all the necessary complexities and not âdumbing downâ anything. Truly a delight to read if you are interested in the topic. I can only aspire to be a writer like Russ some day.</div><br/></div></div></div></div></div></div></div></body></html>