<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706432456069" as="style"/><link rel="stylesheet" href="styles.css?v=1706432456069"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.e-basteln.de/computing/65f02/65f02/">The 100MHz 6502 (2022)</a> <span class="domain">(<a href="https://www.e-basteln.de">www.e-basteln.de</a>)</span></div><div class="subtext"><span>throwup238</span> | <span>41 comments</span></div><br/><div><div id="39163627" class="c"><input type="checkbox" id="c-39163627" checked=""/><div class="controls bullet"><span class="by">Lio</span><span>|</span><a href="#39160909">next</a><span>|</span><label class="collapse" for="c-39163627">[-]</label><label class="expand" for="c-39163627">[1 more]</label></div><br/><div class="children"><div class="content">This sounds like it would be really suitable for a BBC Micro second processor.<p>They had designs for, amongst other, a 64K 65C02 running at a different clock speed[1].<p>Back in the day I always wanted one for playing Elite[2] (but then I also wished that Acorn had provided an official hardware update for 16 colours instead of 8.)<p>1. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;BBC_Micro_expansion_unit" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;BBC_Micro_expansion_unit</a><p>2. <a href="https:&#x2F;&#x2F;www.bbcelite.com&#x2F;6502sp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.bbcelite.com&#x2F;6502sp&#x2F;</a></div><br/></div></div><div id="39160909" class="c"><input type="checkbox" id="c-39160909" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#39163627">prev</a><span>|</span><a href="#39162294">next</a><span>|</span><label class="collapse" for="c-39160909">[-]</label><label class="expand" for="c-39160909">[9 more]</label></div><br/><div class="children"><div class="content">Throwing a cache into a system that never had a cache before can be quite tricky.<p>You could have these kinds of memory pages:<p>* Fixed ROM bank<p>* Bankswitchable ROM bank<p>* Fixed RAM bank<p>* Bankswtichable RAM bank<p>* IO memory<p>* RAM that&#x27;s read by external devices<p>* RAM that&#x27;s written to by external devices  (basically just IO)<p>Caching is <i>trivially easy</i> for fixed a ROM or RAM bank which are not used by other devices.  Caching a bankswitchable bank requires either invalidating on bankswitch, or knowing the bank switching well enough to just cache everything.  Pure IO memory is simple, no caching for that at all.  For RAM that&#x27;s read by other devices, Write-Through caching would work.</div><br/><div id="39161524" class="c"><input type="checkbox" id="c-39161524" checked=""/><div class="controls bullet"><span class="by">masfuerte</span><span>|</span><a href="#39160909">parent</a><span>|</span><a href="#39161088">next</a><span>|</span><label class="collapse" for="c-39161524">[-]</label><label class="expand" for="c-39161524">[6 more]</label></div><br/><div class="children"><div class="content">The BBC Master had an even funkier mode.  The RAM bank accessed could depend on the current program counter.<p>Imagine a video display taking 16K of RAM.  This would be situated between addresses 0x4000 and 0x8000.  This same memory range also included non-video RAM.  The hardware transparently selected the video or non-video RAM depending on which code was accessing it.<p>Specifically, if the program counter was at 0xC000 or above (i.e. code in the OS ROM was running) then accesses to the video range would go to the video RAM.  But if the program counter was elsewhere (i.e. running user code or an application ROM) then accesses to the video range would go to user RAM, not video RAM.<p>Additionally, there was a hardware register controlling this so that user code could choose to directly access the video RAM, and OS code could access the user RAM.</div><br/><div id="39161724" class="c"><input type="checkbox" id="c-39161724" checked=""/><div class="controls bullet"><span class="by">forinti</span><span>|</span><a href="#39160909">root</a><span>|</span><a href="#39161524">parent</a><span>|</span><a href="#39161088">next</a><span>|</span><label class="collapse" for="c-39161724">[-]</label><label class="expand" for="c-39161724">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been looking for a detailed explanation on this, because I would like to know how they read the PC.<p>The New Advanced User&#x27;s Manual describes the flag at &amp;FE34 on the Master and B+ and I&#x27;ve read this thing about using the PC from a few places but I haven&#x27;t found any specifics.<p>Could you clarify? How do you know from the outside what&#x27;s in the PC?</div><br/><div id="39162099" class="c"><input type="checkbox" id="c-39162099" checked=""/><div class="controls bullet"><span class="by">ddingus</span><span>|</span><a href="#39160909">root</a><span>|</span><a href="#39161724">parent</a><span>|</span><a href="#39161088">next</a><span>|</span><label class="collapse" for="c-39162099">[-]</label><label class="expand" for="c-39162099">[4 more]</label></div><br/><div class="children"><div class="content">Would they not just mooch the address off the address bus?</div><br/><div id="39162682" class="c"><input type="checkbox" id="c-39162682" checked=""/><div class="controls bullet"><span class="by">morcheeba</span><span>|</span><a href="#39160909">root</a><span>|</span><a href="#39162099">parent</a><span>|</span><a href="#39161088">next</a><span>|</span><label class="collapse" for="c-39162682">[-]</label><label class="expand" for="c-39162682">[3 more]</label></div><br/><div class="children"><div class="content">Yep.  The 65C02 has a SYNC output that goes high to indicate an instruction is being fetched on the current cycle.  Since there is no cache, it&#x27;s pretty simple to use this to determine the PC.</div><br/><div id="39163148" class="c"><input type="checkbox" id="c-39163148" checked=""/><div class="controls bullet"><span class="by">ddingus</span><span>|</span><a href="#39160909">root</a><span>|</span><a href="#39162682">parent</a><span>|</span><a href="#39163485">next</a><span>|</span><label class="collapse" for="c-39163148">[-]</label><label class="expand" for="c-39163148">[1 more]</label></div><br/><div class="children"><div class="content">Thought so.  From there, it is a bit of logic to map the chip selects to make the writes and reads come and go from the intended resources.</div><br/></div></div><div id="39163485" class="c"><input type="checkbox" id="c-39163485" checked=""/><div class="controls bullet"><span class="by">forinti</span><span>|</span><a href="#39160909">root</a><span>|</span><a href="#39162682">parent</a><span>|</span><a href="#39163148">prev</a><span>|</span><a href="#39161088">next</a><span>|</span><label class="collapse" for="c-39163485">[-]</label><label class="expand" for="c-39163485">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s it then. I was missing the sync pin. Thank you.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39161088" class="c"><input type="checkbox" id="c-39161088" checked=""/><div class="controls bullet"><span class="by">rbanffy</span><span>|</span><a href="#39160909">parent</a><span>|</span><a href="#39161524">prev</a><span>|</span><a href="#39162294">next</a><span>|</span><label class="collapse" for="c-39161088">[-]</label><label class="expand" for="c-39161088">[2 more]</label></div><br/><div class="children"><div class="content">The article mentions the bank-switching issues and that the FPGA only has 64K, which limits emulation of higher memory configs - it’d not emulate a &#x2F;&#x2F;e with 80-column display (which requires 128K).</div><br/><div id="39163167" class="c"><input type="checkbox" id="c-39163167" checked=""/><div class="controls bullet"><span class="by">bpye</span><span>|</span><a href="#39160909">root</a><span>|</span><a href="#39161088">parent</a><span>|</span><a href="#39162294">next</a><span>|</span><label class="collapse" for="c-39163167">[-]</label><label class="expand" for="c-39163167">[1 more]</label></div><br/><div class="children"><div class="content">You could plausibly make bank switching work, but it’d take some effort. You’d want your block RAM to act as a write back cache, and then any bank switch must be intercepted and delayed until you can flush the full contents of the cache to memory.<p>Or if bank switching is fast and occurs too frequently for that to be viable, you could avoid the flush across a bank switch, but then you may need to perform a bank switch for an eviction.</div><br/></div></div></div></div></div></div><div id="39162294" class="c"><input type="checkbox" id="c-39162294" checked=""/><div class="controls bullet"><span class="by">nubinetwork</span><span>|</span><a href="#39160909">prev</a><span>|</span><a href="#39160560">next</a><span>|</span><label class="collapse" for="c-39162294">[-]</label><label class="expand" for="c-39162294">[1 more]</label></div><br/><div class="children"><div class="content">Just throwing it out there, but I think you can still buy eZ180&#x27;s that run at something like 133mhz.<p>Edit: hmm nope, mouser and digikey don&#x27;t have them anymore...  fastest I could find was 50mhz and it was marked as not for new designs.  Bummer.</div><br/></div></div><div id="39160560" class="c"><input type="checkbox" id="c-39160560" checked=""/><div class="controls bullet"><span class="by">pvg</span><span>|</span><a href="#39162294">prev</a><span>|</span><a href="#39160574">next</a><span>|</span><label class="collapse" for="c-39160560">[-]</label><label class="expand" for="c-39160560">[1 more]</label></div><br/><div class="children"><div class="content">Big previous thread in from 2021:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28852857">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28852857</a></div><br/></div></div><div id="39160574" class="c"><input type="checkbox" id="c-39160574" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#39160560">prev</a><span>|</span><a href="#39162307">next</a><span>|</span><label class="collapse" for="c-39160574">[-]</label><label class="expand" for="c-39160574">[16 more]</label></div><br/><div class="children"><div class="content">There are 300MHz 8051s around in all sorts of unlikely places. Many pocket mp3 players used to be based on them.</div><br/><div id="39163305" class="c"><input type="checkbox" id="c-39163305" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#39160574">parent</a><span>|</span><a href="#39160798">next</a><span>|</span><label class="collapse" for="c-39163305">[-]</label><label class="expand" for="c-39163305">[1 more]</label></div><br/><div class="children"><div class="content">The Z80 was common in MP3&#x2F;&quot;MP4&quot; players too.</div><br/></div></div><div id="39160798" class="c"><input type="checkbox" id="c-39160798" checked=""/><div class="controls bullet"><span class="by">Moto7451</span><span>|</span><a href="#39160574">parent</a><span>|</span><a href="#39163305">prev</a><span>|</span><a href="#39162307">next</a><span>|</span><label class="collapse" for="c-39160798">[-]</label><label class="expand" for="c-39160798">[14 more]</label></div><br/><div class="children"><div class="content">Is there an advantage to a 300MHz 8051 vs a Cortex M0? Predated their existence?<p>I know there’s a lot of 8051 tooling but I’m only a dabbler in microcontrollers and it seems like AVRs and M0&#x2F;M3s have taken the place of PICs and 8051s in hobby world.</div><br/><div id="39160906" class="c"><input type="checkbox" id="c-39160906" checked=""/><div class="controls bullet"><span class="by">ddingus</span><span>|</span><a href="#39160574">root</a><span>|</span><a href="#39160798">parent</a><span>|</span><a href="#39161018">next</a><span>|</span><label class="collapse" for="c-39160906">[-]</label><label class="expand" for="c-39160906">[10 more]</label></div><br/><div class="children"><div class="content">There are a few:<p>If you need rapid, real time responses to external signals, the faster clocked 8 bitters are excellent!  Many chips can get into an interrupt service routine in just a handful of cycles.  In tandem with this, these devices can pack a lot of logic into a small amount of code.<p>From Dallas Semi:   Our 1 clock-per-machine-cycle processors reached a remarkable performance goal—1 clock-per-machine-cycle, currently at 33 million instructions per second (MIPS).<p>From Silicon Labs:  The proven 8051 core received a welcome second wind when its architecture lost patent protection
in 1998. [...]  The original Intel 8051 core took 12 cycles to execute 1 instruction; thus, at 12 MHz, it ran at 1million
instructions per second (1 MIP). In contrast, a 100 MHz Silicon Labs 8051 core will run at 100 MIPS or
100 times faster than the classic 8051 at a frequency that is only about 8x the classic 8051’s
frequency.<p>That&#x27;s really fast, when it comes to responding to external events!<p>Say one needs to read an incoming data stream, or control something moving at a high rate of speed.  Both of these tasks depend on a device that can sense and respond in as close to real time as things get.<p>Large, production proven, time tested code bodies.  6502, 8051, z80, etc...  all have a ton of library code that&#x27;s not difficult to understand and make use of.<p>Often, these 8 bit designs can run on crazy low power, or operate very efficiently at full speed.<p>Licensing isn&#x27;t generally an issue.  Adding a well documented and production proven 8 bit core to a specialized design works pretty well!  Often, the custom hardware on chip does the heavy lifting, leaving UX and control tasks, both of which are easy and lean enough for 8 bits of CPU to make sense.<p>The last thing I would put here is subjective, but ease of development can be an advantage, but it depends on the developer.  Once someone has bootstrapped themselves onto 8 bit computing, the constraints on development both limit possible application scope and with that limit comes ease of development.  When used to their strengths, simple chips like these are easy to develop for.  It&#x27;s possible for one person to completely understand a device and with that understanding fully exploit it.</div><br/><div id="39163280" class="c"><input type="checkbox" id="c-39163280" checked=""/><div class="controls bullet"><span class="by">iamflimflam1</span><span>|</span><a href="#39160574">root</a><span>|</span><a href="#39160906">parent</a><span>|</span><a href="#39161356">next</a><span>|</span><label class="collapse" for="c-39163280">[-]</label><label class="expand" for="c-39163280">[1 more]</label></div><br/><div class="children"><div class="content">Interesting - I’ve been playing with some SD Card to USB interface ICs and almost all of them include an 8051 core.</div><br/></div></div><div id="39161356" class="c"><input type="checkbox" id="c-39161356" checked=""/><div class="controls bullet"><span class="by">nullc</span><span>|</span><a href="#39160574">root</a><span>|</span><a href="#39160906">parent</a><span>|</span><a href="#39163280">prev</a><span>|</span><a href="#39161018">next</a><span>|</span><label class="collapse" for="c-39161356">[-]</label><label class="expand" for="c-39161356">[8 more]</label></div><br/><div class="children"><div class="content">I wonder what the limit of computing power per joule is with current technology, assuming you were freely able to change the architecture.<p>For example, perhaps you wouldn&#x27;t use an integer instruction pointer, because a full adder to increment it is expensive.  Instead you could use a LFSR where each increment requires only a couple xor gates and some wires.  But it would mean that your code would have to be scattered in memory in a funny order.  No problem for a smart assembler.<p>How much computing power could you drive from a device powered by nothing other than ambient RF?</div><br/><div id="39162457" class="c"><input type="checkbox" id="c-39162457" checked=""/><div class="controls bullet"><span class="by">IIAOPSW</span><span>|</span><a href="#39160574">root</a><span>|</span><a href="#39161356">parent</a><span>|</span><a href="#39162292">next</a><span>|</span><label class="collapse" for="c-39162457">[-]</label><label class="expand" for="c-39162457">[3 more]</label></div><br/><div class="children"><div class="content">&gt;I wonder what the limit of computing power per joule is<p>Today you&#x27;re going to learn that the universe puts a hard limit on this known as &quot;Launder&#x27;s principle&quot;.<p>To derive it in short, the (information) entropy on the input side of a single traditional logic gate is 2 bits, but on the output side it is just 1 bit. This seems to imply that the (physical) entropy of the computer would go down after the computation, because your computer had more possible physical states it could be in at the time of input than it seems to have at the time of output. But this is impossible as it violates the 2nd law of thermodynamics.<p>To resolve the contradiction, each logic gate must be putting the missing bit of entropy on an untracked non-computational degree of freedom within the physical system. In other words the untracked &quot;missing&quot; information is encoded as seemingly random waste heat, and dumped into the environment at room temperature.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Landauer%27s_principle" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Landauer%27s_principle</a></div><br/><div id="39162930" class="c"><input type="checkbox" id="c-39162930" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#39160574">root</a><span>|</span><a href="#39162457">parent</a><span>|</span><a href="#39163159">next</a><span>|</span><label class="collapse" for="c-39162930">[-]</label><label class="expand" for="c-39162930">[1 more]</label></div><br/><div class="children"><div class="content">From the linked Wikipedia, as a more direct answer to GP’s question:<p>&gt; Modern computers use about a billion times as much energy per operation [than this theoretical minimum energy per bit of entropy “erased”]</div><br/></div></div><div id="39163159" class="c"><input type="checkbox" id="c-39163159" checked=""/><div class="controls bullet"><span class="by">nullc</span><span>|</span><a href="#39160574">root</a><span>|</span><a href="#39162457">parent</a><span>|</span><a href="#39162930">prev</a><span>|</span><a href="#39162292">next</a><span>|</span><label class="collapse" for="c-39163159">[-]</label><label class="expand" for="c-39163159">[1 more]</label></div><br/><div class="children"><div class="content">well aware, which is why I put the technology limit on it!</div><br/></div></div></div></div><div id="39162292" class="c"><input type="checkbox" id="c-39162292" checked=""/><div class="controls bullet"><span class="by">crotchfire</span><span>|</span><a href="#39160574">root</a><span>|</span><a href="#39161356">parent</a><span>|</span><a href="#39162457">prev</a><span>|</span><a href="#39162185">next</a><span>|</span><label class="collapse" for="c-39162292">[-]</label><label class="expand" for="c-39162292">[2 more]</label></div><br/><div class="children"><div class="content">... and adding an integer to a pointer would be hellaciously expensive.<p>If you have the foundry SPICE models you can calculate these kinds of lower-limit values.  I did this for 45nm a long time ago and vaguely recall getting numbers down in the double-digit femtojoule range for 32-bit addition, measuring only transistor R+C.<p>But the transistors don&#x27;t really cost anything; all the CV^2 is in charging and discharging the wires.  And the &quot;C&quot; is totally geometry-dependent.  It&#x27;s not like software -- at least not when you&#x27;re pushing all the limits -- everything affects everything else.</div><br/><div id="39163180" class="c"><input type="checkbox" id="c-39163180" checked=""/><div class="controls bullet"><span class="by">nullc</span><span>|</span><a href="#39160574">root</a><span>|</span><a href="#39162292">parent</a><span>|</span><a href="#39162185">next</a><span>|</span><label class="collapse" for="c-39163180">[-]</label><label class="expand" for="c-39163180">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  ... and adding an integer to a pointer would be hellaciously expensive.<p>Fair, though if it were only the PC and instruction memory that were permuted that isn&#x27;t much of an issue.<p>It&#x27;s not <i>that bad</i> the circuit looks more like a multiplier rather than an adder. (search term would be LFSR fast-forward or jump-ahead).<p>PC is updated presumably on every cycle, while adding an an integer to it is probably a rare operation (just don&#x27;t use computed jumps...).</div><br/></div></div></div></div><div id="39162185" class="c"><input type="checkbox" id="c-39162185" checked=""/><div class="controls bullet"><span class="by">ddingus</span><span>|</span><a href="#39160574">root</a><span>|</span><a href="#39161356">parent</a><span>|</span><a href="#39162292">prev</a><span>|</span><a href="#39161595">next</a><span>|</span><label class="collapse" for="c-39162185">[-]</label><label class="expand" for="c-39162185">[1 more]</label></div><br/><div class="children"><div class="content">I think of this too. And I break it down into ads and operations. An ad is simply summing two inputs of some kind. In operation, might be a change of state or an input coming online or going away. Something analogous to the bit operations and or not exclusive or and friends.<p>With all the physics talk of information being fundamental, I suspect we will find both an upper bound and a lower bound.<p>The upper bound will be something like compute power per volume divided by energy or some similar construct. Basically you can only pack so much information and so many operations into a given region of space and energy level possible for that energy for that region of space to contain.<p>The lower bound might be something like the plank constant for computation. What&#x27;s the smallest unit of space and energy level that can support an add, for example. It&#x27;s interesting to think about.<p>Sorry for the typos I used voice dictation on this one</div><br/></div></div><div id="39161595" class="c"><input type="checkbox" id="c-39161595" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#39160574">root</a><span>|</span><a href="#39161356">parent</a><span>|</span><a href="#39162185">prev</a><span>|</span><a href="#39161018">next</a><span>|</span><label class="collapse" for="c-39161595">[-]</label><label class="expand" for="c-39161595">[1 more]</label></div><br/><div class="children"><div class="content">The thing you describe about replacing PC with an LFSR has actually been done, to simplify the silicon. Some very cheap 4-bit micro controllers, often used for TV Remotes, in fact, do this.</div><br/></div></div></div></div></div></div><div id="39161018" class="c"><input type="checkbox" id="c-39161018" checked=""/><div class="controls bullet"><span class="by">addaon</span><span>|</span><a href="#39160574">root</a><span>|</span><a href="#39160798">parent</a><span>|</span><a href="#39160906">prev</a><span>|</span><a href="#39160958">next</a><span>|</span><label class="collapse" for="c-39161018">[-]</label><label class="expand" for="c-39161018">[1 more]</label></div><br/><div class="children"><div class="content">Besides the other comments, you can get 8051s at much lower power than M0s... think 1 picojoule per (8 bit) op vs 10 picojoules per (32 bit) op, give or take. It&#x27;s pretty common to see 8051s in the low power zone of microcontrollers that also have one or more 32 bit cores on them. Generally the low power zone (including the 8051) can be run off an external clock (so 25 MHz - 100 MHz) in the 1 mW range, or can be run off an RC oscillator at a lower speed (like 7 ± 3 MHz) in the 100 µA range, both of which usefully extend the ability of the system to monitor for wake events and decide when to bring those Arm big boys on line. Some can even take the 8051 down to your 32 kHz real time clock for &lt; 40 µA operation.</div><br/></div></div><div id="39160958" class="c"><input type="checkbox" id="c-39160958" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#39160574">root</a><span>|</span><a href="#39160798">parent</a><span>|</span><a href="#39161018">prev</a><span>|</span><a href="#39160817">next</a><span>|</span><label class="collapse" for="c-39160958">[-]</label><label class="expand" for="c-39160958">[1 more]</label></div><br/><div class="children"><div class="content">M0s have taken the place of many 8051s in the &quot;pro&quot; world as well.  There&#x27;s still the niche that sibling comments have mentioned, but a lot of &quot;default small MCUs&quot; for new projects used to be 8051s and are now M0s.</div><br/></div></div><div id="39160817" class="c"><input type="checkbox" id="c-39160817" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#39160574">root</a><span>|</span><a href="#39160798">parent</a><span>|</span><a href="#39160958">prev</a><span>|</span><a href="#39162307">next</a><span>|</span><label class="collapse" for="c-39160817">[-]</label><label class="expand" for="c-39160817">[1 more]</label></div><br/><div class="children"><div class="content">8051 has no cost to license and if you are mostly using an accelerator to decode mp3, then the servicing of it is simple enough. Why rewrite the code you already have (from before cortex-m0 existed) or redesign the accelerator you already have?</div><br/></div></div></div></div></div></div><div id="39162307" class="c"><input type="checkbox" id="c-39162307" checked=""/><div class="controls bullet"><span class="by">Theodores</span><span>|</span><a href="#39160574">prev</a><span>|</span><a href="#39161977">next</a><span>|</span><label class="collapse" for="c-39162307">[-]</label><label class="expand" for="c-39162307">[3 more]</label></div><br/><div class="children"><div class="content">I wish I could go back in time to run Mandelbrot fractals on a BBC Micro with this - think how impressed people would be with instant zoom rather than a half hour wait!</div><br/><div id="39162685" class="c"><input type="checkbox" id="c-39162685" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#39162307">parent</a><span>|</span><a href="#39161977">next</a><span>|</span><label class="collapse" for="c-39162685">[-]</label><label class="expand" for="c-39162685">[2 more]</label></div><br/><div class="children"><div class="content">Part of the magic was the half hour wait though. It felt as though you were doing some serious computation!</div><br/><div id="39163317" class="c"><input type="checkbox" id="c-39163317" checked=""/><div class="controls bullet"><span class="by">ddingus</span><span>|</span><a href="#39162307">root</a><span>|</span><a href="#39162685">parent</a><span>|</span><a href="#39161977">next</a><span>|</span><label class="collapse" for="c-39163317">[-]</label><label class="expand" for="c-39163317">[1 more]</label></div><br/><div class="children"><div class="content">Same with things like sine plots.<p>The reveal is part of the fun.<p>I just had a thought about what might be really fun at 100Mhz, and that is cellular automata.  There are the classic game of life rules.  Going fast on those is fun.<p>But, maybe a more general engine is worth writing.  I may try it on my 16Mhz 6502 system.</div><br/></div></div></div></div></div></div><div id="39161977" class="c"><input type="checkbox" id="c-39161977" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#39162307">prev</a><span>|</span><a href="#39160551">next</a><span>|</span><label class="collapse" for="c-39161977">[-]</label><label class="expand" for="c-39161977">[4 more]</label></div><br/><div class="children"><div class="content">People write games for the TI-99&#x2F;4A in TI BASIC (or Extended BASIC) that would be too slow to be any fun on the original hardware, but flip on Classic99&#x27;s Turbo mode and suddenly you have arcade action!<p>I can see an upgrade like this enabling games, demos, and other software that wouldn&#x27;t be possible on the stock Apple or Commodore systems.</div><br/><div id="39162137" class="c"><input type="checkbox" id="c-39162137" checked=""/><div class="controls bullet"><span class="by">ddingus</span><span>|</span><a href="#39161977">parent</a><span>|</span><a href="#39162843">next</a><span>|</span><label class="collapse" for="c-39162137">[-]</label><label class="expand" for="c-39162137">[1 more]</label></div><br/><div class="children"><div class="content">It does not take 100Mhz to do that.<p>A while back I bought a FastChip for my Apple 2e.  That delivers a 16Mhz 65C02 or 65C816 (I bought the latter option)<p>The trick to getting superfast Applesoft is to copy it into the card fast RAM.  Otherwise, Applesoft is still faster than stock, but main board RAM is still clocked at 1Mhz.  Not enough of a boost to really matter.<p>However, once Applesoft is on the card, the situation is reversed!  All accesses to main board RAM are 1Mhz, but that is plenty fast to draw a ton of graphics.  Applesoft programs run crazy fast when the 16Mhz 6502 has the job.</div><br/></div></div><div id="39162843" class="c"><input type="checkbox" id="c-39162843" checked=""/><div class="controls bullet"><span class="by">leptons</span><span>|</span><a href="#39161977">parent</a><span>|</span><a href="#39162137">prev</a><span>|</span><a href="#39160551">next</a><span>|</span><label class="collapse" for="c-39162843">[-]</label><label class="expand" for="c-39162843">[2 more]</label></div><br/><div class="children"><div class="content">There are demos written for the SuperCPU 20mhz accelerator for the C64. There are also demos written for the Ram Expansion Unit. I think there was one recent demo released that runs in an emulator with no throttling so it&#x27;s something like a 40MHz C64.<p>One interesting demo combines 4 Commodore 64s to run one demo, called &quot;Quad Core&quot;<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;B4UBlpTucFc?si=a1irvH7CRYhETnk9" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;B4UBlpTucFc?si=a1irvH7CRYhETnk9</a></div><br/><div id="39163344" class="c"><input type="checkbox" id="c-39163344" checked=""/><div class="controls bullet"><span class="by">ddingus</span><span>|</span><a href="#39161977">root</a><span>|</span><a href="#39162843">parent</a><span>|</span><a href="#39160551">next</a><span>|</span><label class="collapse" for="c-39163344">[-]</label><label class="expand" for="c-39163344">[1 more]</label></div><br/><div class="children"><div class="content">The Quad one is neat!</div><br/></div></div></div></div></div></div><div id="39161048" class="c"><input type="checkbox" id="c-39161048" checked=""/><div class="controls bullet"><span class="by">satiric</span><span>|</span><a href="#39160551">prev</a><span>|</span><label class="collapse" for="c-39161048">[-]</label><label class="expand" for="c-39161048">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;d be surprised if 6502-based computers really ran OK at 100MHz: surely you&#x27;d run into EMI or timing issues when using the same motherboard at 100 times the original clock speed?</div><br/><div id="39161073" class="c"><input type="checkbox" id="c-39161073" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#39161048">parent</a><span>|</span><a href="#39161066">next</a><span>|</span><label class="collapse" for="c-39161073">[-]</label><label class="expand" for="c-39161073">[2 more]</label></div><br/><div class="children"><div class="content">This doesn’t do that. It runs an FPGA-built 6502 with 64kB of RAM at 100MHz. The FPGA knows which memory addresses it has to read and write to the actual memory of the system it’s plugged in, and, when needed, accesses that at the speed the system expects.</div><br/><div id="39161392" class="c"><input type="checkbox" id="c-39161392" checked=""/><div class="controls bullet"><span class="by">satiric</span><span>|</span><a href="#39161048">root</a><span>|</span><a href="#39161073">parent</a><span>|</span><a href="#39161066">next</a><span>|</span><label class="collapse" for="c-39161392">[-]</label><label class="expand" for="c-39161392">[1 more]</label></div><br/><div class="children"><div class="content">Oh I see, that&#x27;s neat. That makes way more sense   that what I was thinking.</div><br/></div></div></div></div><div id="39161066" class="c"><input type="checkbox" id="c-39161066" checked=""/><div class="controls bullet"><span class="by">rbanffy</span><span>|</span><a href="#39161048">parent</a><span>|</span><a href="#39161073">prev</a><span>|</span><label class="collapse" for="c-39161066">[-]</label><label class="expand" for="c-39161066">[1 more]</label></div><br/><div class="children"><div class="content">It slows down to access the bus when needed. Memory access runs at full speed all the time as the memory is inside the FPGA.</div><br/></div></div></div></div></div></div></div></div></div></body></html>