<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732525268515" as="style"/><link rel="stylesheet" href="styles.css?v=1732525268515"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.sqlite.org/lang_with.html#outlandish_recursive_query_examples">SQLite: Outlandish Recursive Query Examples</a> <span class="domain">(<a href="https://www.sqlite.org">www.sqlite.org</a>)</span></div><div class="subtext"><span>Rendello</span> | <span>43 comments</span></div><br/><div><div id="42231693" class="c"><input type="checkbox" id="c-42231693" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#42233417">next</a><span>|</span><label class="collapse" for="c-42231693">[-]</label><label class="expand" for="c-42231693">[22 more]</label></div><br/><div class="children"><div class="content">No matter how much time I spend contemplating recursive CTE examples, I just cannot “get it” enough to write my own without a lot of trial and error and head-scratching. I would love to take a 2 hour class on “thinking in SQL for hackers” or something, but I haven’t really found anything to improve my mental model from “broken” to “working” so far.</div><br/><div id="42231849" class="c"><input type="checkbox" id="c-42231849" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#42231693">parent</a><span>|</span><a href="#42233237">next</a><span>|</span><label class="collapse" for="c-42231849">[-]</label><label class="expand" for="c-42231849">[1 more]</label></div><br/><div class="children"><div class="content">A prerequisite to understanding is knowing the CTE syntax (&quot;WITH&quot;). That&#x27;s just a group of SQL queries that can refer to one another. It&#x27;s extremely useful for making modular SQL queries and has nothing to do with recursion.<p>Then when you use &quot;WITH RECURSIVE&quot;, the queries can now refer back to themselves. This is just a for loop over a queue of SQL results, conceptually. The part before the UNION ALL fills the queue to start, and the part after the UNION ALL runs once for each result in the queue, adding all results back into the queue.<p>If you understand this, then you can understand the Sudoku or Mandelbrot examples (definitely don&#x27;t start with trying to understand these two though). For example, the Sudoku example contains one recursive query, &quot;x(s, ind)&quot;. As explained on the page, &quot;s&quot; is the puzzle (unsolved spaces shown as &quot;.&quot;) and &quot;ind&quot; is the index of the first unsolved space (or 0 for a solved puzzle). It creates an unsolved puzzle in the initial setup. The for loop body finds all valid values for the first unsolved space, and the next index to solve; then puts all these results into the queue. The final (non-recursive) SELECT in the CTE looks over all results in the queue, and returns the one where the index is 0 (the solved puzzles).</div><br/></div></div><div id="42233237" class="c"><input type="checkbox" id="c-42233237" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#42231693">parent</a><span>|</span><a href="#42231849">prev</a><span>|</span><a href="#42232105">next</a><span>|</span><label class="collapse" for="c-42233237">[-]</label><label class="expand" for="c-42233237">[4 more]</label></div><br/><div class="children"><div class="content">SQL recursive queries are just loops.  The CTE is a UNION or UNION ALL query (well, never use UNION ALL <i>unless</i> you really want to loop infinitely!) where one side is the query that seeds the CTE and the other is executed and its outputs added to the CTE, and the last part is repeated until the CTE stops growing.  There&#x27;s just one more detail: the &quot;recursive&quot; side of the UNION query needs to do a JOIN to the CTE itself (thus the &quot;recursion&quot;), but this doesn&#x27;t change the loop nature of the thing.<p>That&#x27;s it.  It&#x27;s just a simple loop.<p>(Yes, recursion is looping.  But in this case it&#x27;s very clear that a stack is not needed, that the recursion is &quot;tail recursion&quot; if know what that is.)<p>The hard part lies in getting the JOIN in the &quot;recursive&quot; side of the UNION query right.  Here&#x27;s a transitive closure query:<p><pre><code>  WITH RECURSIVE closure AS (
    SELECT parent, child FROM relationships
    UNION
    SELECT c.parent AS ancestor, r.child AS descendant
    FROM closure c
    JOIN relationships r ON c.child = r.parent
  )
  SELECT * FROM closure;
</code></pre>
Here `SELECT parent, child FROM relationships` is the seed, and the rest (`SELECT c.parent, r.child ...`) is the recursive part of the query that gets repeated until the whole set of results from the seed and all the repetitions of the recursive part stops growing.  The recursive part simply says to add to the `closure` all the children of children of tuples in the closure, but with the parents from the closure as the parents.  So if this were human parent&#x2F;child relationships then initially you might have your parents&#x27; relationships to you, and also yours to your children, and this will find that your parents are ancestors to your children.</div><br/><div id="42233276" class="c"><input type="checkbox" id="c-42233276" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#42231693">root</a><span>|</span><a href="#42233237">parent</a><span>|</span><a href="#42232105">next</a><span>|</span><label class="collapse" for="c-42233276">[-]</label><label class="expand" for="c-42233276">[3 more]</label></div><br/><div class="children"><div class="content">&gt; However, if the example had used UNION instead of UNION ALL, then SQLite would have had to keep around all previously generated content in order to check for duplicates. For this reason, programmers should strive to use UNION ALL instead of UNION when feasible.</div><br/><div id="42233604" class="c"><input type="checkbox" id="c-42233604" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#42231693">root</a><span>|</span><a href="#42233276">parent</a><span>|</span><a href="#42232105">next</a><span>|</span><label class="collapse" for="c-42233604">[-]</label><label class="expand" for="c-42233604">[2 more]</label></div><br/><div class="children"><div class="content">Of course, if you have loop detection in your business logic when writing to the database, then you can safely use UNION ALL always.<p>EDIT: Removed a bunch of stuff that was partly based on a faulty memory of how UNION works vs UNION ALL.  Indeed, UNION ALL means the RDBMS does not need to keep around the whole result set.</div><br/><div id="42233709" class="c"><input type="checkbox" id="c-42233709" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#42231693">root</a><span>|</span><a href="#42233604">parent</a><span>|</span><a href="#42232105">next</a><span>|</span><label class="collapse" for="c-42233709">[-]</label><label class="expand" for="c-42233709">[1 more]</label></div><br/><div class="children"><div class="content">Just to be clear, the reason I mentioned this in response to your original post is that UNION ALL doesn&#x27;t have anything to do with the query recursing infinitely: it just allows the database engine to not keep previous results around. If you have a query that recurses infinitely, with UNION it will definitely exhaust the memory of the database engine, and with UNION ALL it will never stop returning results, which may exhaust the memory of the database client (unless it discards the results).</div><br/></div></div></div></div></div></div></div></div><div id="42232105" class="c"><input type="checkbox" id="c-42232105" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#42231693">parent</a><span>|</span><a href="#42233237">prev</a><span>|</span><a href="#42233715">next</a><span>|</span><label class="collapse" for="c-42232105">[-]</label><label class="expand" for="c-42232105">[5 more]</label></div><br/><div class="children"><div class="content">An crucial point for me was realizing that &quot;recursive CTEs&quot; are not really recursive but better understood as iterative, in other words a loop. The results of each iteration are fed into the next iteration, until no new result is produced.</div><br/><div id="42233518" class="c"><input type="checkbox" id="c-42233518" checked=""/><div class="controls bullet"><span class="by">fifilura</span><span>|</span><a href="#42231693">root</a><span>|</span><a href="#42232105">parent</a><span>|</span><a href="#42233507">next</a><span>|</span><label class="collapse" for="c-42233518">[-]</label><label class="expand" for="c-42233518">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t recursion exactly that? A loop that feeds into the next iteration.</div><br/></div></div><div id="42233507" class="c"><input type="checkbox" id="c-42233507" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42231693">root</a><span>|</span><a href="#42232105">parent</a><span>|</span><a href="#42233518">prev</a><span>|</span><a href="#42233715">next</a><span>|</span><label class="collapse" for="c-42233507">[-]</label><label class="expand" for="c-42233507">[3 more]</label></div><br/><div class="children"><div class="content">Yes, iteration is a special case of recursion.</div><br/><div id="42233659" class="c"><input type="checkbox" id="c-42233659" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#42231693">root</a><span>|</span><a href="#42233507">parent</a><span>|</span><a href="#42233715">next</a><span>|</span><label class="collapse" for="c-42233659">[-]</label><label class="expand" for="c-42233659">[2 more]</label></div><br/><div class="children"><div class="content">All recursion is iteration.  Sometimes you have a stack to help you, and other times you get tail recursion optimization, but it&#x27;s always a loop.</div><br/><div id="42234121" class="c"><input type="checkbox" id="c-42234121" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42231693">root</a><span>|</span><a href="#42233659">parent</a><span>|</span><a href="#42233715">next</a><span>|</span><label class="collapse" for="c-42234121">[-]</label><label class="expand" for="c-42234121">[1 more]</label></div><br/><div class="children"><div class="content">What makes you think so?<p>Please have a look at  the formal definition of regular expressions at <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Regular_expression#Formal_definition" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Regular_expression#Formal_defi...</a> on Wikipedia, and let me know where the stack and the iterations are.  I can&#x27;t find them.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Recursive_definition#Well_formed_formula" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Recursive_definition#Well_form...</a> is also a good example.<p>Regular expressions are a particularly interesting example because you brought up &#x27;loops&#x27;, so I&#x27;m assuming you are interested in how you can implement some of these recursive definitions on a computer.<p>So for regular expressions a common technique is to compile them to a finite state machine. You can model that in your computer as one block of eg assembly instruction per machine state.  To move to a different state, you just &#x27;jmp&#x27; to the corresponding code&#x27;s address.<p>That&#x27;s pretty fun to work out, but I still don&#x27;t see anything I would describe as a &#x27;loop&#x27; here.<p>Yes, some programming languages have special purpose looping constructs.  But they are of limited usefulness, and not particularly fundamental: they usually get compiled away.</div><br/></div></div></div></div></div></div></div></div><div id="42233715" class="c"><input type="checkbox" id="c-42233715" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#42231693">parent</a><span>|</span><a href="#42232105">prev</a><span>|</span><a href="#42231898">next</a><span>|</span><label class="collapse" for="c-42233715">[-]</label><label class="expand" for="c-42233715">[1 more]</label></div><br/><div class="children"><div class="content">I highly recommend the O&#x27;Reilly SQL Pocket Guide (<a href="https:&#x2F;&#x2F;www.oreilly.com&#x2F;library&#x2F;view&#x2F;sql-pocket-guide&#x2F;9781492090397&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.oreilly.com&#x2F;library&#x2F;view&#x2F;sql-pocket-guide&#x2F;978149...</a>).  Its explanation of CTEs is fantastic, and it does a great job on many other parts of SQL, and it&#x27;s a short and sweet book you could read in a few hours.  And it will server as a reference long after you first absorb it.</div><br/></div></div><div id="42231898" class="c"><input type="checkbox" id="c-42231898" checked=""/><div class="controls bullet"><span class="by">danielheath</span><span>|</span><a href="#42231693">parent</a><span>|</span><a href="#42233715">prev</a><span>|</span><a href="#42233446">next</a><span>|</span><label class="collapse" for="c-42231898">[-]</label><label class="expand" for="c-42231898">[3 more]</label></div><br/><div class="children"><div class="content">“Thinking in sql” is hard because it’s an awkward syntax for the (much simpler) relational algebra.<p>Learn to think in terms of the relational algebra, and how to translate that to&#x2F;from SQL, and it starts making sense.</div><br/><div id="42232992" class="c"><input type="checkbox" id="c-42232992" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#42231693">root</a><span>|</span><a href="#42231898">parent</a><span>|</span><a href="#42233675">next</a><span>|</span><label class="collapse" for="c-42232992">[-]</label><label class="expand" for="c-42232992">[1 more]</label></div><br/><div class="children"><div class="content">I can express my ideas well enough in various Datalog&#x2F;Prolog variants w&#x2F; the horn syntax. But when it comes to translating that from several discrete simple propositions into one massive CTE-stack SQL query I get very puzzled. I wrote a toy Datalog-to-SQLite compiler (<a href="https:&#x2F;&#x2F;percival.jake.tl" rel="nofollow">https:&#x2F;&#x2F;percival.jake.tl</a>) but I struggle to grasp the translation skill myself</div><br/></div></div><div id="42233675" class="c"><input type="checkbox" id="c-42233675" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#42231693">root</a><span>|</span><a href="#42231898">parent</a><span>|</span><a href="#42232992">prev</a><span>|</span><a href="#42233446">next</a><span>|</span><label class="collapse" for="c-42233675">[-]</label><label class="expand" for="c-42233675">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t find that the syntax gets in the way of thinking in relational algebra, but I did learn SQL first.</div><br/></div></div></div></div><div id="42233446" class="c"><input type="checkbox" id="c-42233446" checked=""/><div class="controls bullet"><span class="by">tlarkworthy</span><span>|</span><a href="#42231693">parent</a><span>|</span><a href="#42231898">prev</a><span>|</span><a href="#42231791">next</a><span>|</span><label class="collapse" for="c-42233446">[-]</label><label class="expand" for="c-42233446">[2 more]</label></div><br/><div class="children"><div class="content">Some things that helped me<p>Every query response in SQL is a rectangular matrix [1]. JOINs add columns sideways. UNIONs add rows vertically[2].<p>[1] Which is why tree shaped data is awkward to query in SQL in one round-trip.<p>[2] From this you realize why the column names have to match to apply a UNION, and why recursion is something to do with a UNION.</div><br/><div id="42234063" class="c"><input type="checkbox" id="c-42234063" checked=""/><div class="controls bullet"><span class="by">fifilura</span><span>|</span><a href="#42231693">root</a><span>|</span><a href="#42233446">parent</a><span>|</span><a href="#42231791">next</a><span>|</span><label class="collapse" for="c-42234063">[-]</label><label class="expand" for="c-42234063">[1 more]</label></div><br/><div class="children"><div class="content">And if you get stuck, since it is all about rows and columns, just sketch it out in Excel.<p>Not using formulas in Excel but just using it as a rows&#x2F;columns editor.<p>This makes it visually clearer.</div><br/></div></div></div></div><div id="42231791" class="c"><input type="checkbox" id="c-42231791" checked=""/><div class="controls bullet"><span class="by">pawelduda</span><span>|</span><a href="#42231693">parent</a><span>|</span><a href="#42233446">prev</a><span>|</span><a href="#42232407">next</a><span>|</span><label class="collapse" for="c-42231791">[-]</label><label class="expand" for="c-42231791">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s unusual and not a commonly needed tool in SQL. I always need a quick refresher on how to write these after a longer break</div><br/></div></div><div id="42232407" class="c"><input type="checkbox" id="c-42232407" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#42231693">parent</a><span>|</span><a href="#42231791">prev</a><span>|</span><a href="#42231751">next</a><span>|</span><label class="collapse" for="c-42232407">[-]</label><label class="expand" for="c-42232407">[1 more]</label></div><br/><div class="children"><div class="content">For &quot;ordinary&quot; working programmers (some denominator of reasonably common knowledge across the industry without any specific skills that help with CTEs in particular), there are a couple mental models I find helpful:<p>1. Recursion and iteration are duals of each other. Anywhere a &quot;recursive&quot; CTE is a good tool for the job, there exists a natural for-loop or while-loop you would write in an ordinary programming language to solve the same job. Figure out what that looks like, and then you can translate it to SQL. Optimizing further often isn&#x27;t necessary. The general form isn&#x27;t terrible (ellipses hide the extra columns you&#x27;d have to manually include in most SQL dialects):<p><pre><code>  WITH RECURSIVE t(n, ...) AS (
      SELECT 1 as n, * from base_case
    UNION ALL
      SELECT n+1, f(...) FROM t WHERE not_terminated(n, ...)
  )
  SELECT something_interesting(...) FROM t
</code></pre>
1 (continued). You can explicitly encode for-loops and while-loops, doing all the normal sorts of things an ordinary programming language allows. SQL is just a different language representing all the things you already know how to do; don&#x27;t make it complicated until performance becomes a problem.<p>2. There exists a concept of &quot;equality saturation&quot; that&#x27;s exceptionally powerful in a number of domains. Everything in (1) is familiar to an ordinary working programmer, but the database&#x27;s mental model of a recursive CTE is<p><pre><code>  while (not_done(working_set)) {
    working_set.extend(process(working_set));
  }
</code></pre>
2 (continued 0). One model of solving a sudoku puzzle is an iterative&#x2F;recursive branch-and-bound algorithm (try a reasonable thing, expand all the easily learnable knowledge, exit if impossible or if done (recursing at each level), go to the next reasonable thing). One &quot;equality saturation&quot; version of that solution is (plus a stopping condition somewhere):<p>2a. For each partial potential solution<p>2b. For all the ways in which the potential solution is viable<p>2c. Expand into all those new potentialities<p>2 (continued 1). That ability to describe a monotonically increasing set of things which finitely approaches a boundary is powerful in math, powerful in search, powerful in optimization (the Rust EGG crate (e-graphs good) has reasonable documentation for one particular concrete way in which that idea could manifest, if such concreteness helps you learn -- whether you know&#x2F;like Rust or not), and so on. Gradient descent is just expanding your information till you don&#x27;t have much more to learn. Optimizing a program is just expanding the set of optimization-based re-writes till you don&#x27;t have any more re-writes (and pick the best one). Parsing a document is just adding to the things you know about it till no parsing rules can glean any more information. Since that thinking modality is how the database treats your query, you&#x27;ll usually have better optimized queries if you can naturally formulate your problem in that language (as opposed to the naive iterative solution I proposed in (1)). Not all problems can be thus phrased, but if you&#x27;re doing a lot of work in your database with recursive CTEs, it&#x27;s a good idea to spend a week or three hammering home.<p>3. Combining (1) and (2) a bit, your database will usually have a cost somewhere around O(all_the_rows_you_produce) when evaluating recursive CTEs. These tasks only get hard when performance is a problem and you have to figure out how to take the naive ideas from (1) and transform them into the expected model of (2) in a way that actually reduces unnecessary work. For the sudoku example, you can do that by adding a bit more internal state to transform the breadth-first-search I described into a depth-first-search (making the solution _more_ iterative, interestingly; the &quot;natural&quot; solution is very slow comparatively), but in general you might have to get very creative or might not actually have a reasonable solution available.</div><br/></div></div><div id="42231751" class="c"><input type="checkbox" id="c-42231751" checked=""/><div class="controls bullet"><span class="by">daelon</span><span>|</span><a href="#42231693">parent</a><span>|</span><a href="#42232407">prev</a><span>|</span><a href="#42232103">next</a><span>|</span><label class="collapse" for="c-42231751">[-]</label><label class="expand" for="c-42231751">[1 more]</label></div><br/><div class="children"><div class="content">I would also love to take that class!</div><br/></div></div><div id="42232103" class="c"><input type="checkbox" id="c-42232103" checked=""/><div class="controls bullet"><span class="by">hobs</span><span>|</span><a href="#42231693">parent</a><span>|</span><a href="#42231751">prev</a><span>|</span><a href="#42231767">next</a><span>|</span><label class="collapse" for="c-42232103">[-]</label><label class="expand" for="c-42232103">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s just going to be practice, recursion in general is annoying to think about. Start simple, have a loop you want to write instead of a recursive thing, write it step by step instead of trying to do it all at once.<p>I was implementing newton raphson a few years ago in SQL (so as not to implement it as a straight loop) and iterating over the problem several times really helped.<p>Get a query.
Now think of the next step in the iteration, and you&#x27;re basically writing a query that connects to that.
And now, it runs again and again based on the previous criteria.<p>If you can isolate each part of the query for each logical step you&#x27;re going to have a much simpler problem to mentally solve.</div><br/></div></div><div id="42231767" class="c"><input type="checkbox" id="c-42231767" checked=""/><div class="controls bullet"><span class="by">nbbaier</span><span>|</span><a href="#42231693">parent</a><span>|</span><a href="#42232103">prev</a><span>|</span><a href="#42233417">next</a><span>|</span><label class="collapse" for="c-42231767">[-]</label><label class="expand" for="c-42231767">[1 more]</label></div><br/><div class="children"><div class="content">Sign me up for this class too!</div><br/></div></div></div></div><div id="42233417" class="c"><input type="checkbox" id="c-42233417" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#42231693">prev</a><span>|</span><a href="#42232095">next</a><span>|</span><label class="collapse" for="c-42233417">[-]</label><label class="expand" for="c-42233417">[1 more]</label></div><br/><div class="children"><div class="content">I thought this might be a relatively new example - I remember having seen the fractal one but I didn&#x27;t recall the Sudoku one.<p>Turns out both of those examples have been in that documentation for over a decade now! <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20140331191105&#x2F;http:&#x2F;&#x2F;sqlite.org&#x2F;lang_with.html" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20140331191105&#x2F;http:&#x2F;&#x2F;sqlite.org...</a></div><br/></div></div><div id="42232095" class="c"><input type="checkbox" id="c-42232095" checked=""/><div class="controls bullet"><span class="by">dspillett</span><span>|</span><a href="#42233417">prev</a><span>|</span><a href="#42232013">next</a><span>|</span><label class="collapse" for="c-42232095">[-]</label><label class="expand" for="c-42232095">[1 more]</label></div><br/><div class="children"><div class="content">The Mandelbrot example had been around in various forms for quite some time, IIRC I first saw it in ~2006 for SQL Server which gained recursive CTE support in its 2005 release. Another example from around that time was using recursive CTEs to define dragon curves using spatial types that would then be drawn using SSMS&#x27;s support for displaying data in those types.</div><br/></div></div><div id="42232013" class="c"><input type="checkbox" id="c-42232013" checked=""/><div class="controls bullet"><span class="by">rkwz</span><span>|</span><a href="#42232095">prev</a><span>|</span><a href="#42232379">next</a><span>|</span><label class="collapse" for="c-42232013">[-]</label><label class="expand" for="c-42232013">[1 more]</label></div><br/><div class="children"><div class="content">Not SQLite, but recently used Postgres Recursive CTEs for graph retrieval - <a href="https:&#x2F;&#x2F;www.sheshbabu.com&#x2F;posts&#x2F;graph-retrieval-using-postgres-recursive-ctes&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.sheshbabu.com&#x2F;posts&#x2F;graph-retrieval-using-postgr...</a></div><br/></div></div><div id="42232379" class="c"><input type="checkbox" id="c-42232379" checked=""/><div class="controls bullet"><span class="by">jschrf</span><span>|</span><a href="#42232013">prev</a><span>|</span><a href="#42233654">next</a><span>|</span><label class="collapse" for="c-42232379">[-]</label><label class="expand" for="c-42232379">[1 more]</label></div><br/><div class="children"><div class="content">CTEs are extremely useful mechanisms for writing modular and easily maintainable queries, particularly around anything to do with ETL, graphs, and timeseries data. Highly recommend.</div><br/></div></div><div id="42233654" class="c"><input type="checkbox" id="c-42233654" checked=""/><div class="controls bullet"><span class="by">firer</span><span>|</span><a href="#42232379">prev</a><span>|</span><a href="#42231746">next</a><span>|</span><label class="collapse" for="c-42233654">[-]</label><label class="expand" for="c-42233654">[1 more]</label></div><br/><div class="children"><div class="content">I love this stuff. If anybody wants another outlandish example here is an emulator I built: <a href="https:&#x2F;&#x2F;github.com&#x2F;DanielFi&#x2F;sqlite-vm&#x2F;blob&#x2F;main&#x2F;emulator.sql">https:&#x2F;&#x2F;github.com&#x2F;DanielFi&#x2F;sqlite-vm&#x2F;blob&#x2F;main&#x2F;emulator.sql</a></div><br/></div></div><div id="42231746" class="c"><input type="checkbox" id="c-42231746" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42233654">prev</a><span>|</span><a href="#42232909">next</a><span>|</span><label class="collapse" for="c-42231746">[-]</label><label class="expand" for="c-42231746">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve mostly kept the usage to &quot;sane&quot; stuff like turning delimiter-separated text into rows, or walking a graph.<p>As much as I enjoy the Mandelbrot set, I bought the Fractint book as a kid, anyone done any outlandish but useful recursive queries?<p>PS: awesome explanation of how exactly the recursive query works. Wish I had read it when I first needed it in some other DB which help did not have such a clear explanation. Tore out a lot of hair before I got it working right.</div><br/><div id="42232434" class="c"><input type="checkbox" id="c-42232434" checked=""/><div class="controls bullet"><span class="by">airstrike</span><span>|</span><a href="#42231746">parent</a><span>|</span><a href="#42232799">next</a><span>|</span><label class="collapse" for="c-42232434">[-]</label><label class="expand" for="c-42232434">[1 more]</label></div><br/><div class="children"><div class="content">12 years ago I wrote a recursive CTE which aggregated a bunch of accounting journal entries from pretty big SAP extracts with intermediate account also needing to be calculated in a way that rolled up to company-level values, with some tagging&#x2F;indexing in the process. I remember only being able to finish the query after some kind anon helped me in an IRC channel at 4am on a weeknight... to this day I&#x27;m immensely grateful to them<p>I made it into a neat little Django portal with configurable permissions, interactive charts for the data, filtering, etc.<p>It became a ~10-min async celery task running in the background from what previously used to take the company weeks to create that report in an error prone way with macros written by someone long gone &#x2F; in another department. I&#x27;m still pretty proud of that app even though it never got implemented. I got promoted, moved to a different department and don&#x27;t think it ever saw the light of day, but I do have the code laying around somewhere</div><br/></div></div><div id="42232799" class="c"><input type="checkbox" id="c-42232799" checked=""/><div class="controls bullet"><span class="by">JaggerFoo</span><span>|</span><a href="#42231746">parent</a><span>|</span><a href="#42232434">prev</a><span>|</span><a href="#42232127">next</a><span>|</span><label class="collapse" for="c-42232799">[-]</label><label class="expand" for="c-42232799">[1 more]</label></div><br/><div class="children"><div class="content">Years ago I came across a Knapsack problem solution written in Oracle SQL, that I adapted to Daily Fantasy Golf.<p>Here&#x27;s the source: <a href="https:&#x2F;&#x2F;aprogrammerwrites.eu&#x2F;?p=878" rel="nofollow">https:&#x2F;&#x2F;aprogrammerwrites.eu&#x2F;?p=878</a><p>Cheers</div><br/></div></div><div id="42232127" class="c"><input type="checkbox" id="c-42232127" checked=""/><div class="controls bullet"><span class="by">hobs</span><span>|</span><a href="#42231746">parent</a><span>|</span><a href="#42232799">prev</a><span>|</span><a href="#42232909">next</a><span>|</span><label class="collapse" for="c-42232127">[-]</label><label class="expand" for="c-42232127">[1 more]</label></div><br/><div class="children"><div class="content">Last time it was useful I re-implemented XIRR(<a href="https:&#x2F;&#x2F;support.microsoft.com&#x2F;en-us&#x2F;office&#x2F;xirr-function-de1242ec-6477-445b-b11b-a303ad9adc9d" rel="nofollow">https:&#x2F;&#x2F;support.microsoft.com&#x2F;en-us&#x2F;office&#x2F;xirr-function-de1...</a>) using Excel&#x27;s approach in pure SQL so it would be able to make the finance bros happy, it was something like 50,000x faster than the user defined function&#x2F;loop approach.</div><br/></div></div></div></div><div id="42232909" class="c"><input type="checkbox" id="c-42232909" checked=""/><div class="controls bullet"><span class="by">owlninja</span><span>|</span><a href="#42231746">prev</a><span>|</span><a href="#42231458">next</a><span>|</span><label class="collapse" for="c-42232909">[-]</label><label class="expand" for="c-42232909">[2 more]</label></div><br/><div class="children"><div class="content">I often have to generate ad-hoc recursive queries for bills of materials. Any one have good ideas to make something more self serve for end users? I guess just some sort of app where the user supplies the top level part works, but I wonder if it should be pre-exploded? Often I am given a list of many parts to explode.</div><br/><div id="42233599" class="c"><input type="checkbox" id="c-42233599" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#42232909">parent</a><span>|</span><a href="#42231458">next</a><span>|</span><label class="collapse" for="c-42233599">[-]</label><label class="expand" for="c-42233599">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Something more self-serve&quot; is essentially what graph databases provide.<p>If you don&#x27;t have the time to use one of those or build your own (and you probably shouldn&#x27;t) sort of thing on top of SQL, then you can instead define a bunch of VIEWs using recursive queries and GROUP BY and aggregation functions to provide something simple for your users to query.<p>If you do want to build something more general purpose... If you begin by modeling your schema in something other than SQL DDLs (like with an AST) and then model FKs as bi-directional relationships (because they are), and if you add a way to group those relationships, and further provide a way to define a subset of like columns from all the tables in a graph defined by a group of those relationships, then suddenly you can also come up with a simple(ish) language for expressing [sub-]graphs that you want to fetch.  And there&#x27;s your ad-hoc query language for dealing with recursive graphs in your relational data.</div><br/></div></div></div></div><div id="42231458" class="c"><input type="checkbox" id="c-42231458" checked=""/><div class="controls bullet"><span class="by">clumsysmurf</span><span>|</span><a href="#42232909">prev</a><span>|</span><a href="#42231428">next</a><span>|</span><label class="collapse" for="c-42231458">[-]</label><label class="expand" for="c-42231458">[4 more]</label></div><br/><div class="children"><div class="content">Just curios: can CTE&#x27;s be used to make time series range queries easier &#x2F; more performant?<p>Sqlite is the default option on Android and it&#x27;s pretty common to have time series sensor data that needs to be captured, stored, and analyzed...<p>But sqlite isn&#x27;t really meant for a time series workload.<p>There is also duckdb but I&#x27;m not sure about the status of the Android bindings.</div><br/><div id="42232029" class="c"><input type="checkbox" id="c-42232029" checked=""/><div class="controls bullet"><span class="by">dspillett</span><span>|</span><a href="#42231458">parent</a><span>|</span><a href="#42232116">next</a><span>|</span><label class="collapse" for="c-42232029">[-]</label><label class="expand" for="c-42232029">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; can CTE&#x27;s be used to make time series range queries easier &#x2F; more performant?</i><p>On their own, I&#x27;d guess likely not a lot. If a view would help, a CTE will help similarly without needing the external structure, if a correlated subquery would help, then yes similarly, especially if the pattern is repeated in the overall query.<p>In conjunction with other things (good indexing, materialised sequences (&quot;numbers&quot; tables), etc.), is guess yes.<p>Though you need to be much more specific about your data and the queries in question before I can do better than these vague guesses.</div><br/></div></div><div id="42232116" class="c"><input type="checkbox" id="c-42232116" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#42231458">parent</a><span>|</span><a href="#42232029">prev</a><span>|</span><a href="#42231664">next</a><span>|</span><label class="collapse" for="c-42232116">[-]</label><label class="expand" for="c-42232116">[1 more]</label></div><br/><div class="children"><div class="content">No. They are a query syntax, they don&#x27;t change the storage or retrieval performance.</div><br/></div></div><div id="42231664" class="c"><input type="checkbox" id="c-42231664" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#42231458">parent</a><span>|</span><a href="#42232116">prev</a><span>|</span><a href="#42231428">next</a><span>|</span><label class="collapse" for="c-42231664">[-]</label><label class="expand" for="c-42231664">[1 more]</label></div><br/><div class="children"><div class="content">nothing really helps with potato slow Android device &#x2F; storage media. CTE is not magic sauce that will make sqlite go faster.<p>Depending on the recursion pattern and the overhead of your sqlite driver, it can be faster to do many ID lookups then try to cram it all into one mega CTE query.<p><a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;np1queryprob.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;np1queryprob.html</a><p>source: we have the CTE for loading page data in the notion Android app, and the network regularly beats disk on lower end Android devices using whichever query we pick.</div><br/></div></div></div></div><div id="42231428" class="c"><input type="checkbox" id="c-42231428" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#42231458">prev</a><span>|</span><a href="#42232436">next</a><span>|</span><label class="collapse" for="c-42231428">[-]</label><label class="expand" for="c-42231428">[3 more]</label></div><br/><div class="children"><div class="content">Firefox bookmarks have nested folders in an arbitrary depth tree,  so a recursive CTE might be faster;  
<a href="https:&#x2F;&#x2F;www.google.com&#x2F;search?q=Firefox+bookmarks+%22CTE%22" rel="nofollow">https:&#x2F;&#x2F;www.google.com&#x2F;search?q=Firefox+bookmarks+%22CTE%22</a><p>(Edit) 
&quot;Bug 1452376 - Replace GetDescendantFolders with a recursive subquery&quot; <a href="https:&#x2F;&#x2F;hg.mozilla.org&#x2F;integration&#x2F;autoland&#x2F;rev&#x2F;827cc04dacce" rel="nofollow">https:&#x2F;&#x2F;hg.mozilla.org&#x2F;integration&#x2F;autoland&#x2F;rev&#x2F;827cc04dacce</a><p>&quot;Recursive Queries Using Common Table Expressions&quot; 
<a href="https:&#x2F;&#x2F;gist.github.com&#x2F;jbrown123&#x2F;b65004fd4e8327748b650c77383bf553" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;jbrown123&#x2F;b65004fd4e8327748b650c7738...</a></div><br/><div id="42232233" class="c"><input type="checkbox" id="c-42232233" checked=""/><div class="controls bullet"><span class="by">leeoniya</span><span>|</span><a href="#42231428">parent</a><span>|</span><a href="#42232436">next</a><span>|</span><label class="collapse" for="c-42232233">[-]</label><label class="expand" for="c-42232233">[2 more]</label></div><br/><div class="children"><div class="content">storing the tree as an MPTT&#x2F;NestedSet would massively simplify this, without any subquery shenanigans.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Nested_set_model" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Nested_set_model</a><p><a href="https:&#x2F;&#x2F;imrannazar.com&#x2F;articles&#x2F;modified-preorder-tree-traversal" rel="nofollow">https:&#x2F;&#x2F;imrannazar.com&#x2F;articles&#x2F;modified-preorder-tree-trave...</a></div><br/><div id="42233066" class="c"><input type="checkbox" id="c-42233066" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#42231428">root</a><span>|</span><a href="#42232233">parent</a><span>|</span><a href="#42232436">next</a><span>|</span><label class="collapse" for="c-42233066">[-]</label><label class="expand" for="c-42233066">[1 more]</label></div><br/><div class="children"><div class="content">Well the read query has simpler syntax with MPTT but implementing the whole structure is more complicated and any re-organization like moving a folder around requires rewriting a lot of rows. Although it doesn’t apply to the Firefox use-case, I’ve never understood how this technique can be applied to anything but the most trivially sized, roughly immutable trees. What do you do in a production system when two people move two different node in the tree? It seems to need all kinds of complicated locks.</div><br/></div></div></div></div></div></div><div id="42232436" class="c"><input type="checkbox" id="c-42232436" checked=""/><div class="controls bullet"><span class="by">otteromkram</span><span>|</span><a href="#42231428">prev</a><span>|</span><label class="collapse" for="c-42232436">[-]</label><label class="expand" for="c-42232436">[2 more]</label></div><br/><div class="children"><div class="content">The SQL formatting on this website is atrocious.<p>I can&#x27;t find a good reason not to left-align everything vs trying to right-align keywords and keep everything else on one line until the next keyword.</div><br/><div id="42233792" class="c"><input type="checkbox" id="c-42233792" checked=""/><div class="controls bullet"><span class="by">thissuchness</span><span>|</span><a href="#42232436">parent</a><span>|</span><label class="collapse" for="c-42233792">[-]</label><label class="expand" for="c-42233792">[1 more]</label></div><br/><div class="children"><div class="content">Can you give an example of a query you find offensive, and how you&#x27;d format it better?</div><br/></div></div></div></div></div></div></div></div></div></body></html>