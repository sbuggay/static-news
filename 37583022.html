<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1695373261159" as="style"/><link rel="stylesheet" href="styles.css?v=1695373261159"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lakesare.brick.do/lean-coq-isabel-and-their-proof-trees-yjnd2O2RgxwV">Lean, Coq and other proof assistants: Visualising proofs as trees</a> <span class="domain">(<a href="https://lakesare.brick.do">lakesare.brick.do</a>)</span></div><div class="subtext"><span>lakesare</span> | <span>28 comments</span></div><br/><div><div id="37608802" class="c"><input type="checkbox" id="c-37608802" checked=""/><div class="controls bullet"><span class="by">isaacfrond</span><span>|</span><a href="#37609438">next</a><span>|</span><label class="collapse" for="c-37608802">[-]</label><label class="expand" for="c-37608802">[4 more]</label></div><br/><div class="children"><div class="content">A few years back I made a concerted effort to learn Isabelle, the HOL based theorem prover. Proofs read a bit like natural languages but are fully rigorous, moreover Isabelle has application in math as well as programming. What&#x27;s not to like.<p>What I found out was, that after diligently doing all the tutorials, and making all the exercises, there is still a huge gap between my skills and what is needed for real work. Note even that, you cannot even follow proofs of real theorems. Even with the reference manual in hand, trying to follow along word by word, there is a lot outright missing. From what I could gather, those that had successfully learned it  did so at the hand of a master who explains the arcane incantations needed to get from proof state to proof state.<p>I&#x27;d still love to learn a formal theorem proving language, any one really, and be able to do formal proofs, but i&#x27;m not sure how. Coq seems even more arcane than Hol&#x2F;Isabelle. I&#x27;m not sure about Lean, but I&#x27;m skeptical about learning it without having an expert on call.</div><br/><div id="37608922" class="c"><input type="checkbox" id="c-37608922" checked=""/><div class="controls bullet"><span class="by">practal</span><span>|</span><a href="#37608802">parent</a><span>|</span><a href="#37609034">next</a><span>|</span><label class="collapse" for="c-37608922">[-]</label><label class="expand" for="c-37608922">[1 more]</label></div><br/><div class="children"><div class="content">I hear you. I picked up Isabelle relatively easily, but I had the good fortune to be at one of the places where Isabelle is developed, and actually became later part of that group for my PhD.<p>Still, even for me, dealing with various issues in Isabelle is frustrating (I will not even touch stuff like Coq or Lean, these are just insults on my mathematical senses). I know how this all can be made more accessible and natural and practical, and I am working on it. I, too, want to be using such a tool for real stuff. In particular, integrating LLMs with theorem provers is very promising, and I think the new logic I am developing is especially suited for it. You could argue, but well, a natural language interface is just the surface, and the complexity remains just under this surface. I would not argue against that in principle, but my new logic hopefully also takes care of a lot of unnecessary complexity and complications under the hood.</div><br/></div></div><div id="37609034" class="c"><input type="checkbox" id="c-37609034" checked=""/><div class="controls bullet"><span class="by">robinzfc</span><span>|</span><a href="#37608802">parent</a><span>|</span><a href="#37608922">prev</a><span>|</span><a href="#37608893">next</a><span>|</span><label class="collapse" for="c-37609034">[-]</label><label class="expand" for="c-37609034">[1 more]</label></div><br/><div class="children"><div class="content">It was a similar experience for me when I tried to learn proving with Isabelle&#x2F;HOL without an expert help. I gave up and switched to Isabelle&#x2F;ZF and that was easy, my standard mathematics background was sufficient. I use a subset of the Isar language that is needed for my formalized mathematics hobby (shameless plug: isarmathlib.org). Of course if your goal is software verification, then Isabelle&#x2F;HOL is the way to go. Btw, Isabelle is not &quot;the HOL based theorem prover&quot;, Isabelle&#x2F;HOL is just its most popular logic.</div><br/></div></div><div id="37608893" class="c"><input type="checkbox" id="c-37608893" checked=""/><div class="controls bullet"><span class="by">jksk61</span><span>|</span><a href="#37608802">parent</a><span>|</span><a href="#37609034">prev</a><span>|</span><a href="#37609438">next</a><span>|</span><label class="collapse" for="c-37608893">[-]</label><label class="expand" for="c-37608893">[1 more]</label></div><br/><div class="children"><div class="content">well, for lean I know there&#x27;s a discord (with a fair amount of experts) and a fair share of resources nowadays. However, I did try 3 years ago and the jump between solving a simple algebra proof and contributing to Mathlib (or even understand something in it), is quite high.<p>Coq is well designed&#x2F;easy to understand but it is missing a core mathlib like Lean. Moreover, most proofs are designed to &quot;compile&quot; quickly and not to be human readable.</div><br/></div></div></div></div><div id="37609438" class="c"><input type="checkbox" id="c-37609438" checked=""/><div class="controls bullet"><span class="by">butokai</span><span>|</span><a href="#37608802">prev</a><span>|</span><a href="#37604928">next</a><span>|</span><label class="collapse" for="c-37609438">[-]</label><label class="expand" for="c-37609438">[1 more]</label></div><br/><div class="children"><div class="content">For the Coq proof assistant, a recent approach to graphical proofs is Actema: <a href="https:&#x2F;&#x2F;www.actema.xyz&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.actema.xyz&#x2F;</a></div><br/></div></div><div id="37604928" class="c"><input type="checkbox" id="c-37604928" checked=""/><div class="controls bullet"><span class="by">Reubend</span><span>|</span><a href="#37609438">prev</a><span>|</span><a href="#37605178">next</a><span>|</span><label class="collapse" for="c-37604928">[-]</label><label class="expand" for="c-37604928">[4 more]</label></div><br/><div class="children"><div class="content">Thanks for posting this. As a beginner, do I need to already know what &quot;sequent-calculus-style trees&quot; are for this to be useful?<p>I didn&#x27;t see any broad explanation of what the tree structure means here. I can see that disjunctions split a branch into 2 branches, but I&#x27;m still pretty confused overall.</div><br/><div id="37605214" class="c"><input type="checkbox" id="c-37605214" checked=""/><div class="controls bullet"><span class="by">lakesare</span><span>|</span><a href="#37604928">parent</a><span>|</span><a href="#37606170">next</a><span>|</span><label class="collapse" for="c-37605214">[-]</label><label class="expand" for="c-37605214">[1 more]</label></div><br/><div class="children"><div class="content">It isn&#x27;t necessary to know theory for these visualisations to be useful, both Traf and Paperproof (and sequence calculus trees!) should, ideally, just reflect what&#x27;s already happening in your mental image while you&#x27;re writing a Lean&#x2F;Coq&#x2F;on-paper mathematical proof.
But I agree it warrants a tutorial&#x2F;explanation, got to write it.
I think it might be particularly unclear what&#x27;s happening if you&#x27;re just looking at the full tree of the already-proved-theorem. As we&#x27;re writing the proof, hypothesis nodes (green, what we have) move down; and goal nodes (red, what we want to have) move up. So it kind of goes from both sides to the center, and you should read it &quot;from both sides to the center&quot;, takes getting used to. Here is a video of what&#x27;s happening in Paperproof as we&#x27;re writing the proof e.g.: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=0dVj4ITAF1o">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=0dVj4ITAF1o</a>.</div><br/></div></div><div id="37606170" class="c"><input type="checkbox" id="c-37606170" checked=""/><div class="controls bullet"><span class="by">colanderman</span><span>|</span><a href="#37604928">parent</a><span>|</span><a href="#37605214">prev</a><span>|</span><a href="#37605267">next</a><span>|</span><label class="collapse" for="c-37606170">[-]</label><label class="expand" for="c-37606170">[1 more]</label></div><br/><div class="children"><div class="content">Sequent calculus trees [1] are straightforward.  Essentially read them as: for each horizontal line, the judgment (assumptions ⊢ conclusion) below the line is valid if-and-only-if the judgments above the line are valid, by grace of the syntactic transformation rule named to the right of the line.  These are stacked atop one another to form a tree, the leaves at the top (with nothing above the lines) being axioms of the system, the root at the bottom being the judgment whose proof is the tree.<p>Sometimes the trees are upside down from this, for reasons I haven&#x27;t been able to divine.  Some logics also permit multiple (alternative) conclusions in a judgment, which is then properly called a sequent.<p>Nearly the same notation is used for type judgements in type theory as well, with &quot;assumptions ⊢ conclusion&quot; being replaced by &quot;environment ⊢ type assignments&quot;. [2]<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sequent_calculus#The_system_LK" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sequent_calculus#The_system_LK</a>  (The preceding section introduces the notation but uses the upside-down variant, for unclear reasons -- I&#x27;ve rarely seen it elsewhere.)<p>[2] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Type_theory#Technical_details" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Type_theory#Technical_details</a></div><br/></div></div><div id="37605267" class="c"><input type="checkbox" id="c-37605267" checked=""/><div class="controls bullet"><span class="by">cobbal</span><span>|</span><a href="#37604928">parent</a><span>|</span><a href="#37606170">prev</a><span>|</span><a href="#37605178">next</a><span>|</span><label class="collapse" for="c-37605267">[-]</label><label class="expand" for="c-37605267">[1 more]</label></div><br/><div class="children"><div class="content">Some searching found <a href="http:&#x2F;&#x2F;logitext.mit.edu&#x2F;tutorial" rel="nofollow noreferrer">http:&#x2F;&#x2F;logitext.mit.edu&#x2F;tutorial</a> . It tries to explain sequent calculus with an interactive gui prover. Not sure how approachable it is... I&#x27;ve gotten too used to these things to know how to explain them properly.</div><br/></div></div></div></div><div id="37605178" class="c"><input type="checkbox" id="c-37605178" checked=""/><div class="controls bullet"><span class="by">tunesmith</span><span>|</span><a href="#37604928">prev</a><span>|</span><a href="#37604985">next</a><span>|</span><label class="collapse" for="c-37605178">[-]</label><label class="expand" for="c-37605178">[4 more]</label></div><br/><div class="children"><div class="content">Well, I think a DAG would generally be better than a tree for visually representing a proof. Because a premise can support multiple lemmas.<p>One site I&#x27;ve been working on uses graphs to generate arguments in that fashion:<p><a href="http:&#x2F;&#x2F;concludia.org&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;concludia.org&#x2F;</a></div><br/><div id="37605574" class="c"><input type="checkbox" id="c-37605574" checked=""/><div class="controls bullet"><span class="by">lakesare</span><span>|</span><a href="#37605178">parent</a><span>|</span><a href="#37604985">next</a><span>|</span><label class="collapse" for="c-37605574">[-]</label><label class="expand" for="c-37605574">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s correct, in fact we would have a DAG if we displayed all possible arrows, but we conceal it to make the UI easier to interact with for the user. Hypotheses (green nodes) form many little trees, and goals (red trees) form a single tree. These must be trees, and not lattices, because that&#x27;s just how Lean and Coq tactics work. However, tactics make use of hypotheses, and these can be displayed as arrows that connect hypotheses and goals, making it, in this sense, a DAG (here is an example, I moved the nodes a bit to make the arrows obvious <a href="https:&#x2F;&#x2F;github.com&#x2F;Paper-Proof&#x2F;paperproof&#x2F;issues&#x2F;9#issuecomment-1730438164">https:&#x2F;&#x2F;github.com&#x2F;Paper-Proof&#x2F;paperproof&#x2F;issues&#x2F;9#issuecomm...</a>).
Concludia looks interesting, does it support first-order logic&#x2F;ORs?</div><br/><div id="37606205" class="c"><input type="checkbox" id="c-37606205" checked=""/><div class="controls bullet"><span class="by">tunesmith</span><span>|</span><a href="#37605178">root</a><span>|</span><a href="#37605574">parent</a><span>|</span><a href="#37604985">next</a><span>|</span><label class="collapse" for="c-37606205">[-]</label><label class="expand" for="c-37606205">[2 more]</label></div><br/><div class="children"><div class="content">Propositional, so no exists or foralls, but yes for ORs and NOTs. Acyclic only.</div><br/><div id="37606407" class="c"><input type="checkbox" id="c-37606407" checked=""/><div class="controls bullet"><span class="by">lakesare</span><span>|</span><a href="#37605178">root</a><span>|</span><a href="#37606205">parent</a><span>|</span><a href="#37604985">next</a><span>|</span><label class="collapse" for="c-37606407">[-]</label><label class="expand" for="c-37606407">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of characteristica universalis</div><br/></div></div></div></div></div></div></div></div><div id="37604985" class="c"><input type="checkbox" id="c-37604985" checked=""/><div class="controls bullet"><span class="by">nathell</span><span>|</span><a href="#37605178">prev</a><span>|</span><a href="#37608392">next</a><span>|</span><label class="collapse" for="c-37604985">[-]</label><label class="expand" for="c-37604985">[2 more]</label></div><br/><div class="children"><div class="content">Reminds me of Leslie Lamport’s „How to Write a Proof” [1]. I wonder whether there exist tools that aid in manually writing visualisable proofs?<p><a href="https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;pubs&#x2F;lamport-how-to-write.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;pubs&#x2F;lamport-how-to-write....</a></div><br/><div id="37606295" class="c"><input type="checkbox" id="c-37606295" checked=""/><div class="controls bullet"><span class="by">colanderman</span><span>|</span><a href="#37604985">parent</a><span>|</span><a href="#37608392">next</a><span>|</span><label class="collapse" for="c-37606295">[-]</label><label class="expand" for="c-37606295">[1 more]</label></div><br/><div class="children"><div class="content">Interesting, the notation used in that paper presages the notation used by TLA⁺² [1].  I actually have written up an exposition of TLA⁺² proof steps using sequent calculus notation [2] with the intention of writing a proof visualizer for it.<p>[1] <a href="https:&#x2F;&#x2F;tla.msr-inria.inria.fr&#x2F;tlaps&#x2F;content&#x2F;Documentation&#x2F;Tutorial&#x2F;Hierarchical_proofs.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;tla.msr-inria.inria.fr&#x2F;tlaps&#x2F;content&#x2F;Documentation&#x2F;T...</a><p>[2] <a href="https:&#x2F;&#x2F;chris.pacejo.net&#x2F;stuff&#x2F;tla-tips#proof-step-quick-reference" rel="nofollow noreferrer">https:&#x2F;&#x2F;chris.pacejo.net&#x2F;stuff&#x2F;tla-tips#proof-step-quick-ref...</a></div><br/></div></div></div></div><div id="37608392" class="c"><input type="checkbox" id="c-37608392" checked=""/><div class="controls bullet"><span class="by">throwaway2562</span><span>|</span><a href="#37604985">prev</a><span>|</span><a href="#37606114">next</a><span>|</span><label class="collapse" for="c-37608392">[-]</label><label class="expand" for="c-37608392">[1 more]</label></div><br/><div class="children"><div class="content">Jonathon Gorard’s Abstract Proof Networks - in Mathematica - may be of interest<p><a href="https:&#x2F;&#x2F;community.wolfram.com&#x2F;groups&#x2F;-&#x2F;m&#x2F;t&#x2F;1135271" rel="nofollow noreferrer">https:&#x2F;&#x2F;community.wolfram.com&#x2F;groups&#x2F;-&#x2F;m&#x2F;t&#x2F;1135271</a></div><br/></div></div><div id="37606114" class="c"><input type="checkbox" id="c-37606114" checked=""/><div class="controls bullet"><span class="by">SkyMarshal</span><span>|</span><a href="#37608392">prev</a><span>|</span><a href="#37583023">next</a><span>|</span><label class="collapse" for="c-37606114">[-]</label><label class="expand" for="c-37606114">[1 more]</label></div><br/><div class="children"><div class="content">Cool idea.  Here are about ~30 more that might be of interest.  Not all are code proof assistants, just listing extras in case serendipity.<p><a href="https:&#x2F;&#x2F;pastebin.com&#x2F;bYXWj7w6" rel="nofollow noreferrer">https:&#x2F;&#x2F;pastebin.com&#x2F;bYXWj7w6</a></div><br/></div></div><div id="37605298" class="c"><input type="checkbox" id="c-37605298" checked=""/><div class="controls bullet"><span class="by">mjfl</span><span>|</span><a href="#37583023">prev</a><span>|</span><label class="collapse" for="c-37605298">[-]</label><label class="expand" for="c-37605298">[9 more]</label></div><br/><div class="children"><div class="content">What is it with proof assistant designers and terrible naming instincts? &quot;Lean&quot; as a name collides with all sorts of business&#x2F;engineering productivity frameworks &quot;Lean software development&quot;, &quot;lean business management&quot;, &quot;running a lean startup&quot;. And of course Coq is phallic both in English and the original French. It must be the case that the people that design these things live in a separate plane of existence where these things don&#x27;t bother them.</div><br/><div id="37607969" class="c"><input type="checkbox" id="c-37607969" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#37605298">parent</a><span>|</span><a href="#37606298">next</a><span>|</span><label class="collapse" for="c-37607969">[-]</label><label class="expand" for="c-37607969">[1 more]</label></div><br/><div class="children"><div class="content">Yes, unfortunately, Lean is harder to search for than some other programming languages. Although it seems workable: both DuckDuckGo and Google return Lean-related top results for me for &quot;lean induction&quot; and &quot;lean match expression,&quot; for example.<p>&gt; And of course Coq is phallic both in English and the original French.<p>Is it phallic in French too? I am not a French speaker. According to the French Wiktionary, &quot;coq&quot; means rooster, male chicken, cooked rooster, male partridge, a self-important person, a rooster on top of a church bell tower, a loose coin, a tool used for ironing, a kind of fish, a part used in watchmaking, or a cook working on a ship.[1] None of these sound phallic to me.<p>I have not seen evidence that this was intended as an English pun. Rather, it seems to have been a double pun in French, for the calculus of constructions (CoC) which Coq is based on, and Thierry Coquand who developed CoC.[2] So I just assume that it wasn&#x27;t meant to be phallic and remind myself that some people speak French and they name their software French names.<p>[1] <a href="https:&#x2F;&#x2F;fr.wiktionary.org&#x2F;w&#x2F;index.php?title=coq&amp;oldid=32519426#Nom_commun_1" rel="nofollow noreferrer">https:&#x2F;&#x2F;fr.wiktionary.org&#x2F;w&#x2F;index.php?title=coq&amp;oldid=325194...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;coq&#x2F;coq&#x2F;wiki&#x2F;Alternative-names">https:&#x2F;&#x2F;github.com&#x2F;coq&#x2F;coq&#x2F;wiki&#x2F;Alternative-names</a></div><br/></div></div><div id="37606298" class="c"><input type="checkbox" id="c-37606298" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#37605298">parent</a><span>|</span><a href="#37607969">prev</a><span>|</span><a href="#37605988">next</a><span>|</span><label class="collapse" for="c-37606298">[-]</label><label class="expand" for="c-37606298">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s practically impossible to pick names that haven&#x27;t been used for something else. I&#x27;ve taken to using the contraction of random amusing phrases when I want a unique name, but this isn&#x27;t any better. Just fun (for me).<p>Relevant example: my current toy proof engine and language is called lesc. There are lots of things called &quot;lesc&quot;, but none of them to my knowledge stand for Less Elegant Space Cowboy.</div><br/></div></div><div id="37605988" class="c"><input type="checkbox" id="c-37605988" checked=""/><div class="controls bullet"><span class="by">hcta</span><span>|</span><a href="#37605298">parent</a><span>|</span><a href="#37606298">prev</a><span>|</span><a href="#37608276">next</a><span>|</span><label class="collapse" for="c-37605988">[-]</label><label class="expand" for="c-37605988">[1 more]</label></div><br/><div class="children"><div class="content">you say that like it is a bad thing. Sign me up for the plane of existence without management frameworks please.</div><br/></div></div><div id="37605632" class="c"><input type="checkbox" id="c-37605632" checked=""/><div class="controls bullet"><span class="by">lakesare</span><span>|</span><a href="#37605298">parent</a><span>|</span><a href="#37608276">prev</a><span>|</span><a href="#37606822">next</a><span>|</span><label class="collapse" for="c-37605632">[-]</label><label class="expand" for="c-37605632">[2 more]</label></div><br/><div class="children"><div class="content">I love &quot;Lean&quot; actually, have you noticed ∃∀. Googling Lean concepts does primarily return the codeine syrup links though yes.</div><br/><div id="37606720" class="c"><input type="checkbox" id="c-37606720" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#37605298">root</a><span>|</span><a href="#37605632">parent</a><span>|</span><a href="#37606822">next</a><span>|</span><label class="collapse" for="c-37606720">[-]</label><label class="expand" for="c-37606720">[1 more]</label></div><br/><div class="children"><div class="content">N for Natural numbers.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>