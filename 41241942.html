<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723712457157" as="style"/><link rel="stylesheet" href="styles.css?v=1723712457157"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://leanrada.com/notes/sweep-and-prune/">Sort, sweep, and prune: Collision detection algorithms (2023)</a> <span class="domain">(<a href="https://leanrada.com">leanrada.com</a>)</span></div><div class="subtext"><span>wonger_</span> | <span>55 comments</span></div><br/><div><div id="41246155" class="c"><input type="checkbox" id="c-41246155" checked=""/><div class="controls bullet"><span class="by">jonnycat</span><span>|</span><a href="#41251858">next</a><span>|</span><label class="collapse" for="c-41246155">[-]</label><label class="expand" for="c-41246155">[9 more]</label></div><br/><div class="children"><div class="content">One interesting note on this approach is that the author suggests using a &quot;fast&quot; sorting algorithm like mergesort&#x2F;quicksort as the sorting algorithm for best performance.  But in practice, you may get better performance from a &quot;worse&quot; sorting algorithm: insertion sort.<p>The reason is that objects in collision detection systems tend to move relatively small steps between frames, meaning you can keep lists from the previous frame that are already mostly sorted.  For sorting these mostly sorted lists, insertion sort tends towards O(n) while Quicksort tends towards O(n^2)!</div><br/><div id="41246289" class="c"><input type="checkbox" id="c-41246289" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#41246155">parent</a><span>|</span><a href="#41253796">next</a><span>|</span><label class="collapse" for="c-41246289">[-]</label><label class="expand" for="c-41246289">[5 more]</label></div><br/><div class="children"><div class="content">The author covers this pretty much exactly as you describe it. From Part 2 of TFA,<p>&gt; <i>Let’s look at the sort step, which is the bottleneck of the algorithm according to the analysis.</i><p>&gt; <i>You can see that most of the time, the sort does nothing at all! The list is almost always already sorted from the previous frame.</i><p>&gt; <i>Even when it becomes unsorted, it usually just takes a couple of swaps to be sorted again.</i><p>&gt; <i>Here’s insertion sort in action:</i></div><br/><div id="41247133" class="c"><input type="checkbox" id="c-41247133" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41246155">root</a><span>|</span><a href="#41246289">parent</a><span>|</span><a href="#41253796">next</a><span>|</span><label class="collapse" for="c-41247133">[-]</label><label class="expand" for="c-41247133">[4 more]</label></div><br/><div class="children"><div class="content">If you use a modern sort, it&#x27;ll just go &quot;Oh that&#x27;s sorted, we&#x27;re done&quot;. Pattern Defeating Quicksort will do that and so would Glidesort, Driftsort, IPNsort and so on. Most of these algorithms will also correctly shortcut trivial &quot;almost sorted&quot; cases like 123457689 (only longer, if you really only have nine elements you want a custom sort for that, there will be a correct algorithm and it&#x27;s probably written down somewhere already)<p>Rust&#x27;s <i>old</i> sorts, both of them, get this right. There&#x27;s a fair chance the current version of your C++ stdlib even gets this right in its unstable sort. In 1965 it&#x27;s understandable that you reach for an insertion sort for this case, in 2024 it&#x27;s embarrassing if your language doesn&#x27;t provide a built-in sort where this just works.</div><br/><div id="41253806" class="c"><input type="checkbox" id="c-41253806" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41246155">root</a><span>|</span><a href="#41247133">parent</a><span>|</span><a href="#41248628">next</a><span>|</span><label class="collapse" for="c-41253806">[-]</label><label class="expand" for="c-41253806">[1 more]</label></div><br/><div class="children"><div class="content">For what it&#x27;s worth, Haskell&#x27;s built-in sort does this, and I think Python, too.  (But I&#x27;m not as confident about Python.  My memory is a bit hazy.)</div><br/></div></div><div id="41248628" class="c"><input type="checkbox" id="c-41248628" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#41246155">root</a><span>|</span><a href="#41247133">parent</a><span>|</span><a href="#41253806">prev</a><span>|</span><a href="#41253796">next</a><span>|</span><label class="collapse" for="c-41248628">[-]</label><label class="expand" for="c-41248628">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Rust&#x27;s old sorts, both of them, get this right.<p>And the newer sort in the stdlib does too, right?<p>Link <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;1dl079x&#x2F;the_rust_stdlib_is_getting_blazingly_faster_sort&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;1dl079x&#x2F;the_rust_stdl...</a></div><br/><div id="41249207" class="c"><input type="checkbox" id="c-41249207" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41246155">root</a><span>|</span><a href="#41248628">parent</a><span>|</span><a href="#41253796">next</a><span>|</span><label class="collapse" for="c-41249207">[-]</label><label class="expand" for="c-41249207">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the stdlib provided sort and sort_unstable in Rust 1.81 and later are<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Voultapher&#x2F;sort-research-rs&#x2F;blob&#x2F;main&#x2F;writeup&#x2F;driftsort_introduction&#x2F;text.md">https:&#x2F;&#x2F;github.com&#x2F;Voultapher&#x2F;sort-research-rs&#x2F;blob&#x2F;main&#x2F;wri...</a>
and 
<a href="https:&#x2F;&#x2F;github.com&#x2F;Voultapher&#x2F;sort-research-rs&#x2F;blob&#x2F;main&#x2F;writeup&#x2F;ipnsort_introduction&#x2F;text.md">https:&#x2F;&#x2F;github.com&#x2F;Voultapher&#x2F;sort-research-rs&#x2F;blob&#x2F;main&#x2F;wri...</a></div><br/></div></div></div></div></div></div></div></div><div id="41253796" class="c"><input type="checkbox" id="c-41253796" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41246155">parent</a><span>|</span><a href="#41246289">prev</a><span>|</span><a href="#41248132">next</a><span>|</span><label class="collapse" for="c-41253796">[-]</label><label class="expand" for="c-41253796">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For sorting these mostly sorted lists, insertion sort tends towards O(n) while Quicksort tends towards O(n^2)!<p>Only if you pick your pivot really, really badly.  You can randomise your pivot to get O(n log n), or in the case of already almost sorted lists, you can pick a pivot by just picking the element in the middle of the list.<p>But you are right, that even with optimal pivots, QuickSort is still O(n log n) even in the best case.  There are simple variants of merge sort that give you O(n log k) behaviour where k is the number of runs (both ascending and descending) in the data.  The &#x27;sort&#x27; you get by default in eg Haskell&#x27;s standard library uses such an algorithm.  I think Python does, too.</div><br/></div></div><div id="41248132" class="c"><input type="checkbox" id="c-41248132" checked=""/><div class="controls bullet"><span class="by">GistNoesis</span><span>|</span><a href="#41246155">parent</a><span>|</span><a href="#41253796">prev</a><span>|</span><a href="#41253543">next</a><span>|</span><label class="collapse" for="c-41248132">[-]</label><label class="expand" for="c-41248132">[1 more]</label></div><br/><div class="children"><div class="content">There is an alternative to sorting every step : Build your indexing structure a little looser, so that you catch the candidates collisions when object have moved less than epsilon.<p>For example that can be done by increasing the radius of the spheres by epsilon.
As long as the spheres have not moved by epsilon, you don&#x27;t need to recompute the index.<p>To avoid latency peaks when you do need to recompute the index, you can start building a lagging index by sorting 10% each frame (aka amortizing the computation cost). After 10 frames you have an index that is valid as long as the position is within epsilon of the position 10 frames ago.</div><br/></div></div></div></div><div id="41251858" class="c"><input type="checkbox" id="c-41251858" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#41246155">prev</a><span>|</span><a href="#41250789">next</a><span>|</span><label class="collapse" for="c-41251858">[-]</label><label class="expand" for="c-41251858">[3 more]</label></div><br/><div class="children"><div class="content">A long time ago I did something similar but rather than sorting I just kept index lists for each direction and the objects sorted themselves. Meaning like there are 4 lists `objectIndicesSortedByLeftEdge&#x2F;RightEdge&#x2F;TopEdge&#x2F;BottomEdge`  If an object moves horizontally then it updates its own indices in the leftEdge and rightEdge arrays. This is because as it moves it likely only has to swap 1 or 2 indices at most to move itself.</div><br/><div id="41251984" class="c"><input type="checkbox" id="c-41251984" checked=""/><div class="controls bullet"><span class="by">novaleaf</span><span>|</span><a href="#41251858">parent</a><span>|</span><a href="#41250789">next</a><span>|</span><label class="collapse" for="c-41251984">[-]</label><label class="expand" for="c-41251984">[2 more]</label></div><br/><div class="children"><div class="content">I think your method seems useful for scenes that are mostly static.  the &quot;recreate the graph&quot; approach seems better the more dynamic things are.</div><br/><div id="41252166" class="c"><input type="checkbox" id="c-41252166" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#41251858">root</a><span>|</span><a href="#41251984">parent</a><span>|</span><a href="#41250789">next</a><span>|</span><label class="collapse" for="c-41252166">[-]</label><label class="expand" for="c-41252166">[1 more]</label></div><br/><div class="children"><div class="content">objects are unlikely to jump from one side the screen to the other so comparing them to stuff on the other side of the screen seems like a waste (which is what a generic sort will do).</div><br/></div></div></div></div></div></div><div id="41250789" class="c"><input type="checkbox" id="c-41250789" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#41251858">prev</a><span>|</span><a href="#41252849">next</a><span>|</span><label class="collapse" for="c-41250789">[-]</label><label class="expand" for="c-41250789">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always enjoyed this document regarding continuous collision detection:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;bepu&#x2F;bepuphysics2&#x2F;blob&#x2F;master&#x2F;Documentation&#x2F;ContinuousCollisionDetection.md">https:&#x2F;&#x2F;github.com&#x2F;bepu&#x2F;bepuphysics2&#x2F;blob&#x2F;master&#x2F;Documentati...</a><p>The library itself is amazing in terms of performance. It is a bit challenging to integrate with though due to the amount of optimization involved.</div><br/></div></div><div id="41252849" class="c"><input type="checkbox" id="c-41252849" checked=""/><div class="controls bullet"><span class="by">AndrewKemendo</span><span>|</span><a href="#41250789">prev</a><span>|</span><a href="#41245382">next</a><span>|</span><label class="collapse" for="c-41252849">[-]</label><label class="expand" for="c-41252849">[1 more]</label></div><br/><div class="children"><div class="content">This was really well put together.<p>What’s funny is that I’ve been doing some form of gamedev since late 90s and most of this is abstracted by engines at this point, but this is essential to understanding how complex system simulations work.<p>Thanks to the author for making a very accessible article</div><br/></div></div><div id="41245382" class="c"><input type="checkbox" id="c-41245382" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#41252849">prev</a><span>|</span><a href="#41249107">next</a><span>|</span><label class="collapse" for="c-41245382">[-]</label><label class="expand" for="c-41245382">[1 more]</label></div><br/><div class="children"><div class="content">I enjoyed the use of illustration.  Seems like an appropriate usage.<p>Sometimes I feel like these articles with interactive illustrations are more like an excuse to put together a bunch of cool demos, like there&#x27;s a lot of fluff with not much substance (a bit like a TED talk), but this one didn&#x27;t let the illustrations take over.</div><br/></div></div><div id="41249107" class="c"><input type="checkbox" id="c-41249107" checked=""/><div class="controls bullet"><span class="by">fuzzythinker</span><span>|</span><a href="#41245382">prev</a><span>|</span><a href="#41245397">next</a><span>|</span><label class="collapse" for="c-41249107">[-]</label><label class="expand" for="c-41249107">[1 more]</label></div><br/><div class="children"><div class="content">Part 2: <a href="https:&#x2F;&#x2F;leanrada.com&#x2F;notes&#x2F;sweep-and-prune-2&#x2F;" rel="nofollow">https:&#x2F;&#x2F;leanrada.com&#x2F;notes&#x2F;sweep-and-prune-2&#x2F;</a><p>Check out his other goodies <a href="https:&#x2F;&#x2F;leanrada.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;leanrada.com&#x2F;</a></div><br/></div></div><div id="41245397" class="c"><input type="checkbox" id="c-41245397" checked=""/><div class="controls bullet"><span class="by">JKCalhoun</span><span>|</span><a href="#41249107">prev</a><span>|</span><a href="#41252450">next</a><span>|</span><label class="collapse" for="c-41245397">[-]</label><label class="expand" for="c-41245397">[13 more]</label></div><br/><div class="children"><div class="content">&gt; This naive algorithm runs in O(n2) time in Big O terms.<p>Is this true? The naive algorithm&#x27;s outer loop (i) counts n - 1, while the inner loop (j) begins at i + 1 (so counts progressively less than n - 1).<p>Not a CS major, is this roughly equivalent (for large values of n) to O(n2) or is it, as it appears, something less?</div><br/><div id="41245632" class="c"><input type="checkbox" id="c-41245632" checked=""/><div class="controls bullet"><span class="by">spacecadet_</span><span>|</span><a href="#41245397">parent</a><span>|</span><a href="#41245716">next</a><span>|</span><label class="collapse" for="c-41245632">[-]</label><label class="expand" for="c-41245632">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right that it&#x27;s not exactly n^2. For the i-th element we perform (n - i - 1) comparisons (indexing from 0). This adds up to a total of (n - 1) * n &#x2F; 2 comparisons. (see <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Triangular_number" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Triangular_number</a>)<p>In the end it doesn&#x27;t make a difference for big-O analysis because it&#x27;s used to describe the behavior when n approaches infinity, where the quadratic factor takes over.</div><br/></div></div><div id="41245716" class="c"><input type="checkbox" id="c-41245716" checked=""/><div class="controls bullet"><span class="by">qwery</span><span>|</span><a href="#41245397">parent</a><span>|</span><a href="#41245632">prev</a><span>|</span><a href="#41245481">next</a><span>|</span><label class="collapse" for="c-41245716">[-]</label><label class="expand" for="c-41245716">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;optimisation&quot; of starting the inner loop at `j = i + 1` is done to avoid testing every pair of objects <i>twice</i>.<p>[Ed: I should add that it also prevents testing an object against itself.]<p>The algorithm is O(n^2) because every pair will be checked <i>once</i>.</div><br/></div></div><div id="41245481" class="c"><input type="checkbox" id="c-41245481" checked=""/><div class="controls bullet"><span class="by">friendzis</span><span>|</span><a href="#41245397">parent</a><span>|</span><a href="#41245716">prev</a><span>|</span><a href="#41245485">next</a><span>|</span><label class="collapse" for="c-41245481">[-]</label><label class="expand" for="c-41245481">[7 more]</label></div><br/><div class="children"><div class="content">Big O is just complexity classes, describing how number of abstract computations <i>scale</i> (that&#x27;s the key word) with input size (input list length). Generally speaking, if you could analytically express number of computations as a function of input size, Big O takes the largest term and drops all factors.<p>It does not necessarily describe performance of the algorithm. `20n2^+5n` and `2n^2 + 9001n` are both O(n^2)</div><br/><div id="41247792" class="c"><input type="checkbox" id="c-41247792" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#41245397">root</a><span>|</span><a href="#41245481">parent</a><span>|</span><a href="#41245485">next</a><span>|</span><label class="collapse" for="c-41247792">[-]</label><label class="expand" for="c-41247792">[6 more]</label></div><br/><div class="children"><div class="content">&gt; It does not necessarily describe performance of the algorithm.<p>Not necessarily true. It does indeed describe performance of the algorithm. It just compares scenarios with coarser granularity. You can tell from the very start that a O(1) algorithm is expected to outperform a O(N²) alternative.</div><br/><div id="41248089" class="c"><input type="checkbox" id="c-41248089" checked=""/><div class="controls bullet"><span class="by">ohwellhere</span><span>|</span><a href="#41245397">root</a><span>|</span><a href="#41247792">parent</a><span>|</span><a href="#41253033">next</a><span>|</span><label class="collapse" for="c-41248089">[-]</label><label class="expand" for="c-41248089">[4 more]</label></div><br/><div class="children"><div class="content">My algorithms class taught to think of it not as &quot;describing performance&quot; in an absolute sense, but as &quot;describing how performance changes as the size of the input data increases&quot;.<p>It is not necessarily true that an O(1) algorithm will outperform an O(n^2) alternative on a particular set of data. But it is true that an O(1) algorithm will outperform an O(n^2) alternative as the size of the input data increases.</div><br/><div id="41250451" class="c"><input type="checkbox" id="c-41250451" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41245397">root</a><span>|</span><a href="#41248089">parent</a><span>|</span><a href="#41248430">next</a><span>|</span><label class="collapse" for="c-41250451">[-]</label><label class="expand" for="c-41250451">[1 more]</label></div><br/><div class="children"><div class="content">This sometimes doesn&#x27;t work out in practice because the scaling involved runs into a limitation your big-O model didn&#x27;t account for. Typical examples are: The size of the machine registers, physical RAM, addressable storage, or transmission speeds.<p>If your O(1) algorithm takes an hour for any input, and the competition is O(n) it may seem like there must be cases where you&#x27;re better, and then you realise n is the size in bytes of some data in RAM, and your competitors can do 4GB per second. You won&#x27;t be competitive until we&#x27;re talking about 15TB of data and then you remember you only have 64GB of RAM.<p>Big-O complexities are not useless, but they&#x27;re a poor summary alone, about as useful as knowing the mean price of items at supermarkets. I guess this supermarket is cheaper? Or it offers more small items? Or it has no high-end items? Or something?</div><br/></div></div><div id="41248430" class="c"><input type="checkbox" id="c-41248430" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#41245397">root</a><span>|</span><a href="#41248089">parent</a><span>|</span><a href="#41250451">prev</a><span>|</span><a href="#41253033">next</a><span>|</span><label class="collapse" for="c-41248430">[-]</label><label class="expand" for="c-41248430">[2 more]</label></div><br/><div class="children"><div class="content">&gt; (...) but as &quot;describing how performance changes as the size of the input data increases&quot;.<p>Yes, that&#x27;s the definition of asymptotic computational complexity. That&#x27;s the whole point of these comparisons. It&#x27;s pointless to compare algorithms when input size is in the single digit scale.</div><br/><div id="41249302" class="c"><input type="checkbox" id="c-41249302" checked=""/><div class="controls bullet"><span class="by">Kubuxu</span><span>|</span><a href="#41245397">root</a><span>|</span><a href="#41248430">parent</a><span>|</span><a href="#41253033">next</a><span>|</span><label class="collapse" for="c-41249302">[-]</label><label class="expand" for="c-41249302">[1 more]</label></div><br/><div class="children"><div class="content">You could have an O(N^2) algorithm outperform an O(N) on the scale of 10,000 (or whatever scale you want to imagine). The big-O notation compares only asymptotic behaviour, and sometimes the lower power factors are overwhelming.</div><br/></div></div></div></div></div></div><div id="41253033" class="c"><input type="checkbox" id="c-41253033" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#41245397">root</a><span>|</span><a href="#41247792">parent</a><span>|</span><a href="#41248089">prev</a><span>|</span><a href="#41245485">next</a><span>|</span><label class="collapse" for="c-41253033">[-]</label><label class="expand" for="c-41253033">[1 more]</label></div><br/><div class="children"><div class="content">Counter-examples: <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Galactic_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Galactic_algorithm</a><p>All that different complexity classes show is that there is some n for which one outperforms the other. In practice this n can be extremely large.</div><br/></div></div></div></div></div></div><div id="41245485" class="c"><input type="checkbox" id="c-41245485" checked=""/><div class="controls bullet"><span class="by">yeevs</span><span>|</span><a href="#41245397">parent</a><span>|</span><a href="#41245481">prev</a><span>|</span><a href="#41245528">next</a><span>|</span><label class="collapse" for="c-41245485">[-]</label><label class="expand" for="c-41245485">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s the summation of numbers from 1 to n which is n(n+1)&#x2F;2. This reduces to quadratic complexity because big O notation ignores all coefficients and terms that scale slower</div><br/></div></div><div id="41245528" class="c"><input type="checkbox" id="c-41245528" checked=""/><div class="controls bullet"><span class="by">cinntaile</span><span>|</span><a href="#41245397">parent</a><span>|</span><a href="#41245485">prev</a><span>|</span><a href="#41247289">next</a><span>|</span><label class="collapse" for="c-41245528">[-]</label><label class="expand" for="c-41245528">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know if this will make more sense to you but Big O is like limit calculations from calculus.</div><br/></div></div><div id="41247289" class="c"><input type="checkbox" id="c-41247289" checked=""/><div class="controls bullet"><span class="by">veryrealsid</span><span>|</span><a href="#41245397">parent</a><span>|</span><a href="#41245528">prev</a><span>|</span><a href="#41252450">next</a><span>|</span><label class="collapse" for="c-41247289">[-]</label><label class="expand" for="c-41247289">[1 more]</label></div><br/><div class="children"><div class="content">这今天</div><br/></div></div></div></div><div id="41252450" class="c"><input type="checkbox" id="c-41252450" checked=""/><div class="controls bullet"><span class="by">whatever1</span><span>|</span><a href="#41245397">prev</a><span>|</span><a href="#41246178">next</a><span>|</span><label class="collapse" for="c-41252450">[-]</label><label class="expand" for="c-41252450">[1 more]</label></div><br/><div class="children"><div class="content">I was curious if any linear programming methods have been proposed for the problem since you just need to see if a point is inside a polyhedron or if two polyhedra intersect. There are.<a href="https:&#x2F;&#x2F;users.encs.concordia.ca&#x2F;~akgunduz&#x2F;CollisionDetection.pdf" rel="nofollow">https:&#x2F;&#x2F;users.encs.concordia.ca&#x2F;~akgunduz&#x2F;CollisionDetection...</a></div><br/></div></div><div id="41246178" class="c"><input type="checkbox" id="c-41246178" checked=""/><div class="controls bullet"><span class="by">rendaw</span><span>|</span><a href="#41252450">prev</a><span>|</span><a href="#41251958">next</a><span>|</span><label class="collapse" for="c-41246178">[-]</label><label class="expand" for="c-41246178">[2 more]</label></div><br/><div class="children"><div class="content">I hadn&#x27;t seen this before, but isn&#x27;t it similar to using something like a quad-tree to reduce the number of potential colliders?</div><br/><div id="41246425" class="c"><input type="checkbox" id="c-41246425" checked=""/><div class="controls bullet"><span class="by">deliveryboyman</span><span>|</span><a href="#41246178">parent</a><span>|</span><a href="#41251958">next</a><span>|</span><label class="collapse" for="c-41246425">[-]</label><label class="expand" for="c-41246425">[1 more]</label></div><br/><div class="children"><div class="content">Yes, although you&#x27;re more likely to see something like a k-d tree in offline rendering than in real-time rendering.</div><br/></div></div></div></div><div id="41251958" class="c"><input type="checkbox" id="c-41251958" checked=""/><div class="controls bullet"><span class="by">MrLeap</span><span>|</span><a href="#41246178">prev</a><span>|</span><a href="#41249221">next</a><span>|</span><label class="collapse" for="c-41251958">[-]</label><label class="expand" for="c-41251958">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a big fan of spatial grid hashes to simplify situations like this. Nice to see other approaches. Iterative Insertion sorting would be easier to port to a compute shader than a spatial grid hash, so maybe this method is better if we get into the millions of objects range?</div><br/></div></div><div id="41249221" class="c"><input type="checkbox" id="c-41249221" checked=""/><div class="controls bullet"><span class="by">RaftPeople</span><span>|</span><a href="#41251958">prev</a><span>|</span><a href="#41246723">next</a><span>|</span><label class="collapse" for="c-41249221">[-]</label><label class="expand" for="c-41249221">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I won’t cover other approaches, such as space partitioning or spatial tree subdivision</i><p>I&#x27;m curious about this comment, anyone know if the algorithm in the article is generally faster than space partitioning&#x2F;spatial tree subdivision?<p>A long time ago I used a spatial tree type of approach which seemed naively to be a pretty good approach, but I never investigated or compared algorithms other people were using (this was 80&#x27;s, pre-internet).</div><br/><div id="41249449" class="c"><input type="checkbox" id="c-41249449" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#41249221">parent</a><span>|</span><a href="#41246723">next</a><span>|</span><label class="collapse" for="c-41249449">[-]</label><label class="expand" for="c-41249449">[1 more]</label></div><br/><div class="children"><div class="content">The complexity involved in maintaining space partitioning, tree subdivision etc can end up being a big hassle, especially if you have huge numbers of moving objects.<p>It&#x27;s much easier to write, debug and optimize something that manages a single list of entities, or a grid of i.e. 256x256 &#x27;cells&#x27; that each contain a list of entities, than it is to set up a complex partitioning scheme that maintains all your tree invariants every time an object moves.<p>In the days of i.e. DOOM or Quake the performance of these underlying systems was much more important than it is now, so it (IMO) made more sense for the authors of those engines to cook up really complex partitioning systems. But these days CPUs are really good at blasting through sorted arrays of items, and less good at chasing linked lists&#x2F;trees (comparatively) than they used to be, due to pipelining. Your CPU time isn&#x27;t going to be spent on managing those entity lists but will instead be spent on things like AI, rendering, etc.</div><br/></div></div></div></div><div id="41246723" class="c"><input type="checkbox" id="c-41246723" checked=""/><div class="controls bullet"><span class="by">bambax</span><span>|</span><a href="#41249221">prev</a><span>|</span><a href="#41245766">next</a><span>|</span><label class="collapse" for="c-41246723">[-]</label><label class="expand" for="c-41246723">[1 more]</label></div><br/><div class="children"><div class="content">Excellent article. Sorting the list is a really simple and neat idea, without the need for clustering or a special data structure.</div><br/></div></div><div id="41245766" class="c"><input type="checkbox" id="c-41245766" checked=""/><div class="controls bullet"><span class="by">wood_spirit</span><span>|</span><a href="#41246723">prev</a><span>|</span><a href="#41245905">next</a><span>|</span><label class="collapse" for="c-41245766">[-]</label><label class="expand" for="c-41245766">[7 more]</label></div><br/><div class="children"><div class="content">A tangent, but HNers interested in an article on collision detection might know: are there any similar articles that show how to compute the intersection of two capsules (as in the space that that a sphere moving in a straight line in a time step occupies) in 3D?  My own hobby 3D game got stuck on that hurdle and I couldn’t find any examples anywhere :(</div><br/><div id="41246247" class="c"><input type="checkbox" id="c-41246247" checked=""/><div class="controls bullet"><span class="by">qwery</span><span>|</span><a href="#41245766">parent</a><span>|</span><a href="#41247678">next</a><span>|</span><label class="collapse" for="c-41246247">[-]</label><label class="expand" for="c-41246247">[2 more]</label></div><br/><div class="children"><div class="content">Capsule-capsule overlap can be detected by treating the capsules as line segments with radius&#x2F;thickness.
But I think you need something more complicated than capsule-capsule intersection to truly solve the problem (continuous collision detection between dynamic objects).<p>The Rapier project and its documentation[0] might be of interest to you. Rapier has a more sophisticated CCD implementation than most (popular in gamedev) physics engines.<p>&gt; Rapier implements nonlinear CCD, meaning that it takes into account both the angular and translational motion of the rigid-body.<p>[0] <a href="https:&#x2F;&#x2F;rapier.rs&#x2F;docs&#x2F;user_guides&#x2F;rust&#x2F;rigid_bodies#continuous-collision-detection" rel="nofollow">https:&#x2F;&#x2F;rapier.rs&#x2F;docs&#x2F;user_guides&#x2F;rust&#x2F;rigid_bodies#continu...</a></div><br/><div id="41253495" class="c"><input type="checkbox" id="c-41253495" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41245766">root</a><span>|</span><a href="#41246247">parent</a><span>|</span><a href="#41247678">next</a><span>|</span><label class="collapse" for="c-41253495">[-]</label><label class="expand" for="c-41253495">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t worked on collision detection since the 1990s. But convex hull collisions are very fast with GJK. And the space swept by translating a convex hull is itself a convex hull. So continuous collision detection (no fly-through) is possible that way. But that&#x27;s usually overkill. Objects that move more than their own dimension in one frame time are usually bullets, and those should get special handling.</div><br/></div></div></div></div><div id="41247678" class="c"><input type="checkbox" id="c-41247678" checked=""/><div class="controls bullet"><span class="by">GistNoesis</span><span>|</span><a href="#41245766">parent</a><span>|</span><a href="#41246247">prev</a><span>|</span><a href="#41245953">next</a><span>|</span><label class="collapse" for="c-41247678">[-]</label><label class="expand" for="c-41247678">[1 more]</label></div><br/><div class="children"><div class="content">For fine collision between capsules, you consider the capsules as 3d segments with thickness. And two of those collide if the distance between segments &lt; sum of half-thicknesses.<p>You can check this site with nice animations which explain how to compute the distance between segments : <a href="https:&#x2F;&#x2F;zalo.github.io&#x2F;blog&#x2F;closest-point-between-segments&#x2F;" rel="nofollow">https:&#x2F;&#x2F;zalo.github.io&#x2F;blog&#x2F;closest-point-between-segments&#x2F;</a><p>One more generic way to compute the distance between shapes is to view it as a minimization problem.
You take a point A inside object 1 and a point B inside object 2, and you minimize the squared distance between the points : ||A-B||^2 while constraining point A to object 1 and point B to object 2.<p>In the case of capsules, this is a &quot;convex&quot; optimization problem : So one way of solving for the points, is to take a minimization (newton) step and then project back each point to its respective convex object (projection is well defined and unique because of the convex property) (It usually need less than 10 iterations).<p>In geometry, we often decompose object into convex unions. One example is sphere-trees, where you cover your object with spheres.<p>This allow you to use fast coarse collision algorithm for spheres to find collision candidates of your capsules : You cover your capsules with spheres (a little bigger than the thickness) so that the capsule is inside the union of the spheres.</div><br/></div></div><div id="41245953" class="c"><input type="checkbox" id="c-41245953" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#41245766">parent</a><span>|</span><a href="#41247678">prev</a><span>|</span><a href="#41245903">next</a><span>|</span><label class="collapse" for="c-41245953">[-]</label><label class="expand" for="c-41245953">[1 more]</label></div><br/><div class="children"><div class="content">You make one of them have thickness of both, so that the collision detection becomes line vs capsule collision.<p>Another trick is to rotate both so that one of the move directions is axis-aligned, and then the problem looks more like AABB.</div><br/></div></div><div id="41245903" class="c"><input type="checkbox" id="c-41245903" checked=""/><div class="controls bullet"><span class="by">xeonmc</span><span>|</span><a href="#41245766">parent</a><span>|</span><a href="#41245953">prev</a><span>|</span><a href="#41245905">next</a><span>|</span><label class="collapse" for="c-41245903">[-]</label><label class="expand" for="c-41245903">[2 more]</label></div><br/><div class="children"><div class="content">Isn’t it just a matter of checking if two lines’ perigee fall within radius sum, and if so check if the respective segments’ closest points to the perigee are within radius sum?</div><br/></div></div></div></div><div id="41245905" class="c"><input type="checkbox" id="c-41245905" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#41245766">prev</a><span>|</span><a href="#41245597">next</a><span>|</span><label class="collapse" for="c-41245905">[-]</label><label class="expand" for="c-41245905">[2 more]</label></div><br/><div class="children"><div class="content">Since the balls probably don’t move much per frame, should the list be considered “nearly sorted?”</div><br/><div id="41248429" class="c"><input type="checkbox" id="c-41248429" checked=""/><div class="controls bullet"><span class="by">Sharlin</span><span>|</span><a href="#41245905">parent</a><span>|</span><a href="#41245597">next</a><span>|</span><label class="collapse" for="c-41248429">[-]</label><label class="expand" for="c-41248429">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the author gets to that in the second part.</div><br/></div></div></div></div><div id="41245597" class="c"><input type="checkbox" id="c-41245597" checked=""/><div class="controls bullet"><span class="by">sixthDot</span><span>|</span><a href="#41245905">prev</a><span>|</span><a href="#41247093">next</a><span>|</span><label class="collapse" for="c-41245597">[-]</label><label class="expand" for="c-41245597">[3 more]</label></div><br/><div class="children"><div class="content">The title was curious to me because I expected more a post about the `intersects` function, e.g the pip algorithm... turns out it&#x27;s more about the complexity involved by the number of objects to test, which in the end is also interesting.</div><br/><div id="41247314" class="c"><input type="checkbox" id="c-41247314" checked=""/><div class="controls bullet"><span class="by">veryrealsid</span><span>|</span><a href="#41245597">parent</a><span>|</span><a href="#41247093">next</a><span>|</span><label class="collapse" for="c-41247314">[-]</label><label class="expand" for="c-41247314">[2 more]</label></div><br/><div class="children"><div class="content">我Ronald Hansen</div><br/><div id="41250150" class="c"><input type="checkbox" id="c-41250150" checked=""/><div class="controls bullet"><span class="by">sixthDot</span><span>|</span><a href="#41245597">root</a><span>|</span><a href="#41247314">parent</a><span>|</span><a href="#41247093">next</a><span>|</span><label class="collapse" for="c-41250150">[-]</label><label class="expand" for="c-41250150">[1 more]</label></div><br/><div class="children"><div class="content">E Don Lancaster</div><br/></div></div></div></div></div></div><div id="41247093" class="c"><input type="checkbox" id="c-41247093" checked=""/><div class="controls bullet"><span class="by">denvaar</span><span>|</span><a href="#41245597">prev</a><span>|</span><a href="#41246540">next</a><span>|</span><label class="collapse" for="c-41247093">[-]</label><label class="expand" for="c-41247093">[1 more]</label></div><br/><div class="children"><div class="content">Got distracted (in a good way) by this website. It&#x27;s fun and inspiring.</div><br/></div></div><div id="41246540" class="c"><input type="checkbox" id="c-41246540" checked=""/><div class="controls bullet"><span class="by">syntaxing</span><span>|</span><a href="#41247093">prev</a><span>|</span><a href="#41247852">next</a><span>|</span><label class="collapse" for="c-41246540">[-]</label><label class="expand" for="c-41246540">[1 more]</label></div><br/><div class="children"><div class="content">Super interesting, my first thought before I read the article was why not a bloom filter but didn’t expect it to be “physical” collision</div><br/></div></div><div id="41247852" class="c"><input type="checkbox" id="c-41247852" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41246540">prev</a><span>|</span><a href="#41252452">next</a><span>|</span><label class="collapse" for="c-41247852">[-]</label><label class="expand" for="c-41247852">[1 more]</label></div><br/><div class="children"><div class="content">The animations don’t show on iOS Safari.</div><br/></div></div><div id="41252452" class="c"><input type="checkbox" id="c-41252452" checked=""/><div class="controls bullet"><span class="by">yazzku</span><span>|</span><a href="#41247852">prev</a><span>|</span><a href="#41246499">next</a><span>|</span><label class="collapse" for="c-41252452">[-]</label><label class="expand" for="c-41252452">[1 more]</label></div><br/><div class="children"><div class="content">Not mentioned is spatial hashing, which works well without complex data structures.<p>Also sad that you need all this complexity to test 25 balls in Javascript. 25^2 is a small number in C, especially when your balls fit in cache.<p>Still a good introduction to various algorithms, though.</div><br/></div></div><div id="41246499" class="c"><input type="checkbox" id="c-41246499" checked=""/><div class="controls bullet"><span class="by">justbookmark</span><span>|</span><a href="#41252452">prev</a><span>|</span><a href="#41247546">next</a><span>|</span><label class="collapse" for="c-41246499">[-]</label><label class="expand" for="c-41246499">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;southkorea&#x2F;southkorea-maps&#x2F;issues&#x2F;11">https:&#x2F;&#x2F;github.com&#x2F;southkorea&#x2F;southkorea-maps&#x2F;issues&#x2F;11</a></div><br/></div></div><div id="41247546" class="c"><input type="checkbox" id="c-41247546" checked=""/><div class="controls bullet"><span class="by">FrustratedMonky</span><span>|</span><a href="#41246499">prev</a><span>|</span><label class="collapse" for="c-41247546">[-]</label><label class="expand" for="c-41247546">[1 more]</label></div><br/><div class="children"><div class="content">Very Nice animated examples</div><br/></div></div></div></div></div></div></div></body></html>