<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704013264123" as="style"/><link rel="stylesheet" href="styles.css?v=1704013264123"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://ugrep.com/">Ugrep – a more powerful, fast, user-friendly, compatible grep</a> <span class="domain">(<a href="https://ugrep.com">ugrep.com</a>)</span></div><div class="subtext"><span>smartmic</span> | <span>87 comments</span></div><br/><div><div id="38819541" class="c"><input type="checkbox" id="c-38819541" checked=""/><div class="controls bullet"><span class="by">graphe</span><span>|</span><a href="#38820270">next</a><span>|</span><label class="collapse" for="c-38819541">[-]</label><label class="expand" for="c-38819541">[11 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a thread on performance vs rg (ripgrep). <a href="https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;ripgrep&#x2F;discussions&#x2F;2597">https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;ripgrep&#x2F;discussions&#x2F;2597</a> didn&#x27;t know about hypergrep either.</div><br/><div id="38820779" class="c"><input type="checkbox" id="c-38820779" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#38819541">parent</a><span>|</span><a href="#38822661">next</a><span>|</span><label class="collapse" for="c-38820779">[-]</label><label class="expand" for="c-38820779">[8 more]</label></div><br/><div class="children"><div class="content">Haven&#x27;t benchmarked *grep implementations, but assuming those are just CLI wrappers around RegEx libraries, I&#x27;d expect the RegEx benchmarks to be broader and more representative.<p>There, hyperscan is generally the king, which means hypergrep numbers are likely accurate: <a href="https:&#x2F;&#x2F;github.com&#x2F;p-ranav&#x2F;hypergrep?tab=readme-ov-file#directory-search-usr">https:&#x2F;&#x2F;github.com&#x2F;p-ranav&#x2F;hypergrep?tab=readme-ov-file#dire...</a><p>Disclaimer: I rarely use any *grep utilities, but often implement string libraries.</div><br/><div id="38820832" class="c"><input type="checkbox" id="c-38820832" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#38819541">root</a><span>|</span><a href="#38820779">parent</a><span>|</span><a href="#38821321">next</a><span>|</span><label class="collapse" for="c-38820832">[-]</label><label class="expand" for="c-38820832">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m the author of ripgrep and its regex engine.<p>Your claim is true to a first approximation. But greps are line oriented, and that means there are optimizations that can be done that are hard to do in a general regex library. You can read more about that here: <a href="https:&#x2F;&#x2F;blog.burntsushi.net&#x2F;ripgrep&#x2F;#anatomy-of-a-grep" rel="nofollow">https:&#x2F;&#x2F;blog.burntsushi.net&#x2F;ripgrep&#x2F;#anatomy-of-a-grep</a> (greps are more than simple CLI wrappers around a regex engine).<p>If you read my commentary in the ripgrep discussion above, you&#x27;ll note that it isn&#x27;t just about the benchmarks themselves being accurate, but the model they represent. Nevertheless, I linked the hypergrep benchmarks not because of Hyperscan, but because they were done by someone who isn&#x27;t the author of either ripgrep or ugrep.<p>As for regex benchmarks, you&#x27;ll want to check out rebar: <a href="https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;rebar">https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;rebar</a><p>You can see my full thoughts around benchmark design and philosophy if you read the rebar documentation. Be warned though, you&#x27;ll need some time.<p>There is a fork of ripgrep with Hyperscan support: <a href="https:&#x2F;&#x2F;sr.ht&#x2F;~pierrenn&#x2F;ripgrep&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sr.ht&#x2F;~pierrenn&#x2F;ripgrep&#x2F;</a><p>Hyperscan also has some preculiarities on how it reports matches. You won&#x27;t notice it in basic usage, but it will appear when using something like the -o&#x2F;--only-matching flag. For example, Hyperscan will report matches of a, b and c for the regex \w+, where as a normal grep will just report a match of abc. (And this makes sense given the design and motivation for Hyperscan.) Hypergrep goes to some pain to paper over this, but IIRC the logic is not fully correct. I&#x27;m on mobile, otherwise I would link to the reddit thread where I had a convo about this with the hypergrep author.</div><br/><div id="38821308" class="c"><input type="checkbox" id="c-38821308" checked=""/><div class="controls bullet"><span class="by">haberman</span><span>|</span><a href="#38819541">root</a><span>|</span><a href="#38820832">parent</a><span>|</span><a href="#38821321">next</a><span>|</span><label class="collapse" for="c-38821308">[-]</label><label class="expand" for="c-38821308">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m on mobile, otherwise I would link to the reddit thread where I had a convo about this with the hypergrep author.<p>From some searching I think you might mean this: <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;cpp&#x2F;comments&#x2F;143d148&#x2F;hypergrep_a_new_fastest_grep_to_search&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;cpp&#x2F;comments&#x2F;143d148&#x2F;hypergrep_a_ne...</a></div><br/><div id="38821327" class="c"><input type="checkbox" id="c-38821327" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#38819541">root</a><span>|</span><a href="#38821308">parent</a><span>|</span><a href="#38821321">next</a><span>|</span><label class="collapse" for="c-38821327">[-]</label><label class="expand" for="c-38821327">[1 more]</label></div><br/><div class="children"><div class="content">Ah yup! I just posted a follow-up that links to that with an example (from a build of hypergrep off of latest master): <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38821321">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38821321</a></div><br/></div></div></div></div></div></div><div id="38821321" class="c"><input type="checkbox" id="c-38821321" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#38819541">root</a><span>|</span><a href="#38820779">parent</a><span>|</span><a href="#38820832">prev</a><span>|</span><a href="#38822661">next</a><span>|</span><label class="collapse" for="c-38821321">[-]</label><label class="expand" for="c-38821321">[4 more]</label></div><br/><div class="children"><div class="content">OK, now that I have hands on a keyboard, this is what I meant by Hyperscan&#x27;s match semantics being &quot;peculiar&quot;:<p><pre><code>    $ echo &#x27;foobar&#x27; | hg -o &#x27;\w{3}&#x27;
    1:foobar
    $ echo &#x27;foobar&#x27; | grep -E -n -o &#x27;\w{3}&#x27;
    1:foo
    1:bar
</code></pre>
Here&#x27;s the aforementioned reddit thread: <a href="https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;cpp&#x2F;comments&#x2F;143d148&#x2F;hypergrep_a_new_fastest_grep_to_search&#x2F;jn952bp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;cpp&#x2F;comments&#x2F;143d148&#x2F;hypergrep_a_ne...</a><p>I want to be clear that these are intended semantics as part of Hyperscan. It&#x27;s not a bug with Hyperscan. But it is something you&#x27;ll need to figure out how to deal with (whether that&#x27;s papering over it somehow, although I&#x27;m not sure that&#x27;s possible, or documenting it as a difference) if you&#x27;re building a grep around Hyperscan.</div><br/><div id="38822101" class="c"><input type="checkbox" id="c-38822101" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38819541">root</a><span>|</span><a href="#38821321">parent</a><span>|</span><a href="#38822246">next</a><span>|</span><label class="collapse" for="c-38822101">[-]</label><label class="expand" for="c-38822101">[1 more]</label></div><br/><div class="children"><div class="content">How about: use Hyperscan to round up all the lines that contain matches, and process those again with regex for the &quot;-o&quot; semantics.</div><br/></div></div><div id="38822246" class="c"><input type="checkbox" id="c-38822246" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#38819541">root</a><span>|</span><a href="#38821321">parent</a><span>|</span><a href="#38822101">prev</a><span>|</span><a href="#38822661">next</a><span>|</span><label class="collapse" for="c-38822246">[-]</label><label class="expand" for="c-38822246">[2 more]</label></div><br/><div class="children"><div class="content">is that an alias, or does hypergrep really use the same command name as mercurial?</div><br/><div id="38822260" class="c"><input type="checkbox" id="c-38822260" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38819541">root</a><span>|</span><a href="#38822246">parent</a><span>|</span><a href="#38822661">next</a><span>|</span><label class="collapse" for="c-38822260">[-]</label><label class="expand" for="c-38822260">[1 more]</label></div><br/><div class="children"><div class="content">It was renamed: <a href="https:&#x2F;&#x2F;github.com&#x2F;p-ranav&#x2F;hypergrep&#x2F;commit&#x2F;ee85b713aa84e0050a3b36030000778ccfd4882f">https:&#x2F;&#x2F;github.com&#x2F;p-ranav&#x2F;hypergrep&#x2F;commit&#x2F;ee85b713aa84e005...</a></div><br/></div></div></div></div></div></div></div></div><div id="38822661" class="c"><input type="checkbox" id="c-38822661" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#38819541">parent</a><span>|</span><a href="#38820779">prev</a><span>|</span><a href="#38820503">next</a><span>|</span><label class="collapse" for="c-38822661">[-]</label><label class="expand" for="c-38822661">[1 more]</label></div><br/><div class="children"><div class="content">rg uses a lot of memory in the OpenSubtitles test. 903M vs 29M for ugrep.  Unlike the previous test, we are not told the size of the file being searched.<p>Would be interesting to see comparisons where memory is limited, i.e., where the file being searched will not fit entirely into memory.</div><br/></div></div><div id="38820503" class="c"><input type="checkbox" id="c-38820503" checked=""/><div class="controls bullet"><span class="by">infocollector</span><span>|</span><a href="#38819541">parent</a><span>|</span><a href="#38822661">prev</a><span>|</span><a href="#38820270">next</a><span>|</span><label class="collapse" for="c-38820503">[-]</label><label class="expand" for="c-38820503">[1 more]</label></div><br/><div class="children"><div class="content">I think you should try it before you read these conflicting benchmarks from the authors: <a href="https:&#x2F;&#x2F;github.com&#x2F;Genivia&#x2F;ugrep-benchmarks">https:&#x2F;&#x2F;github.com&#x2F;Genivia&#x2F;ugrep-benchmarks</a></div><br/></div></div></div></div><div id="38820270" class="c"><input type="checkbox" id="c-38820270" checked=""/><div class="controls bullet"><span class="by">joshka</span><span>|</span><a href="#38819541">prev</a><span>|</span><a href="#38820220">next</a><span>|</span><label class="collapse" for="c-38820270">[-]</label><label class="expand" for="c-38820270">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a few ripgrep based tuis:<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;acheronfail&#x2F;repgrep">https:&#x2F;&#x2F;github.com&#x2F;acheronfail&#x2F;repgrep</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;konradsz&#x2F;igrep">https:&#x2F;&#x2F;github.com&#x2F;konradsz&#x2F;igrep</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;seg-mx&#x2F;grep_tui">https:&#x2F;&#x2F;github.com&#x2F;seg-mx&#x2F;grep_tui</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;Robertleoj&#x2F;grepedit">https:&#x2F;&#x2F;github.com&#x2F;Robertleoj&#x2F;grepedit</a></div><br/><div id="38821433" class="c"><input type="checkbox" id="c-38821433" checked=""/><div class="controls bullet"><span class="by">nsagent</span><span>|</span><a href="#38820270">parent</a><span>|</span><a href="#38820220">next</a><span>|</span><label class="collapse" for="c-38821433">[-]</label><label class="expand" for="c-38821433">[1 more]</label></div><br/><div class="children"><div class="content">You can also use fzf with ripgrep to great effect:<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;junegunn&#x2F;fzf&#x2F;blob&#x2F;master&#x2F;ADVANCED.md#using-fzf-as-interactive-ripgrep-launcher">https:&#x2F;&#x2F;github.com&#x2F;junegunn&#x2F;fzf&#x2F;blob&#x2F;master&#x2F;ADVANCED.md#usin...</a></div><br/></div></div></div></div><div id="38820220" class="c"><input type="checkbox" id="c-38820220" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#38820270">prev</a><span>|</span><a href="#38822203">next</a><span>|</span><label class="collapse" for="c-38820220">[-]</label><label class="expand" for="c-38820220">[3 more]</label></div><br/><div class="children"><div class="content">Interesting, it supports an n-gram indexer.  ripgrep has had this planned for a few years now [1] but hasn&#x27;t implemented it yet.  For large codebases I&#x27;ve been using csearch, but it has a lot of limitations.<p>Unfortunately... I just tried the indexer and it&#x27;s extremely slow on my machine.  It took 86 seconds to index a Linux kernel tree, while csearch&#x27;s cindex tool took 8 seconds.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;ripgrep&#x2F;issues&#x2F;1497">https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;ripgrep&#x2F;issues&#x2F;1497</a></div><br/><div id="38820498" class="c"><input type="checkbox" id="c-38820498" checked=""/><div class="controls bullet"><span class="by">dtgriscom</span><span>|</span><a href="#38820220">parent</a><span>|</span><a href="#38822203">next</a><span>|</span><label class="collapse" for="c-38820498">[-]</label><label class="expand" for="c-38820498">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s close to a gig of disk reads; I trust you didn&#x27;t try ugrep first and then cindex second, without taking into account caching.</div><br/><div id="38821395" class="c"><input type="checkbox" id="c-38821395" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#38820220">root</a><span>|</span><a href="#38820498">parent</a><span>|</span><a href="#38822203">next</a><span>|</span><label class="collapse" for="c-38821395">[-]</label><label class="expand" for="c-38821395">[1 more]</label></div><br/><div class="children"><div class="content">I ran both multiple times, alternating (and making sure to clean out the indexes in between).  Results were reasonably consistent across runs.</div><br/></div></div></div></div></div></div><div id="38822203" class="c"><input type="checkbox" id="c-38822203" checked=""/><div class="controls bullet"><span class="by">zaidhaan</span><span>|</span><a href="#38820220">prev</a><span>|</span><a href="#38822601">next</a><span>|</span><label class="collapse" for="c-38822203">[-]</label><label class="expand" for="c-38822203">[2 more]</label></div><br/><div class="children"><div class="content">A little off-topic, but I&#x27;d love to see a tool similar to this that provides real-time previews for an entire shell pipeline which, most importantly, integrates into the shell. This allows for leveraging the completion system to complete command-line flags and using the line editor to navigate the pipeline.<p>In zsh, the closest thing I&#x27;ve gotten to this was to bind Ctrl-\ to the `accept-and-hold` zle widget, which executes what is in the current buffer while still retaining it and the cursor position. That gets me close (no more ^P^B^B^B^B for editing), but I&#x27;d much rather see the result of the pipeline in real-time rather than having to manually hit a key whenever I want to see the result.</div><br/><div id="38822352" class="c"><input type="checkbox" id="c-38822352" checked=""/><div class="controls bullet"><span class="by">wazzaps</span><span>|</span><a href="#38822203">parent</a><span>|</span><a href="#38822601">next</a><span>|</span><label class="collapse" for="c-38822352">[-]</label><label class="expand" for="c-38822352">[1 more]</label></div><br/><div class="children"><div class="content">Sounds similar to this: <a href="https:&#x2F;&#x2F;github.com&#x2F;akavel&#x2F;up">https:&#x2F;&#x2F;github.com&#x2F;akavel&#x2F;up</a></div><br/></div></div></div></div><div id="38822601" class="c"><input type="checkbox" id="c-38822601" checked=""/><div class="controls bullet"><span class="by">tarun_anand</span><span>|</span><a href="#38822203">prev</a><span>|</span><a href="#38819605">next</a><span>|</span><label class="collapse" for="c-38822601">[-]</label><label class="expand" for="c-38822601">[1 more]</label></div><br/><div class="children"><div class="content">Very insightful discussion. Is there a regex library that is tuned for in-memory data&#x2F;strings? Similar to in-memory databases?<p>I recall using hyperscan but isn&#x27;t it discontinued.</div><br/></div></div><div id="38819605" class="c"><input type="checkbox" id="c-38819605" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38822601">prev</a><span>|</span><a href="#38819542">next</a><span>|</span><label class="collapse" for="c-38819605">[-]</label><label class="expand" for="c-38819605">[5 more]</label></div><br/><div class="children"><div class="content">Important note: not actually compatible. It took me <i>seconds</i> to find an option that does something completely different than the GNU version.</div><br/><div id="38819873" class="c"><input type="checkbox" id="c-38819873" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#38819605">parent</a><span>|</span><a href="#38819843">next</a><span>|</span><label class="collapse" for="c-38819873">[-]</label><label class="expand" for="c-38819873">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. And here are some concrete examples around locale:<p><pre><code>    $ grep -V | head -n1
    grep (GNU grep) 3.11
    $ alias ugrep-grep=&quot;ugrep-4.4.1 -G -U -Y -. --sort -Dread -dread&quot;
    $ echo &#x27;pokémon&#x27; | LC_ALL=en_US.UTF-8 grep &#x27;pok[[=e=]]mon&#x27;
    pokémon
    $ echo &#x27;pokémon&#x27; | LC_ALL=en_US.UTF-8 ugrep-grep &#x27;pok[[=e=]]mon&#x27;
    $ echo &#x27;γ&#x27; | LC_ALL=en_US.UTF-8 grep -i &#x27;Γ&#x27;
    γ
    $ echo &#x27;γ&#x27; | LC_ALL=en_US.UTF-8 ugrep-grep -i &#x27;Γ&#x27;
</code></pre>
BSD grep works like GNU grep too:<p><pre><code>    $ grep -V
    grep (BSD grep, GNU compatible) 2.6.0-FreeBSD
    $ echo &#x27;pokémon&#x27; | LC_ALL=en_US.UTF-8 grep &#x27;pok[[=e=]]mon&#x27;
    pokémon
    $ echo &#x27;γ&#x27; | LC_ALL=en_US.UTF-8 grep -i &#x27;Γ&#x27;
    γ</code></pre></div><br/></div></div><div id="38819843" class="c"><input type="checkbox" id="c-38819843" checked=""/><div class="controls bullet"><span class="by">e12e</span><span>|</span><a href="#38819605">parent</a><span>|</span><a href="#38819873">prev</a><span>|</span><a href="#38819704">next</a><span>|</span><label class="collapse" for="c-38819843">[-]</label><label class="expand" for="c-38819843">[2 more]</label></div><br/><div class="children"><div class="content">I would assume compatible meant posix&#x2F;bsd - unless explicitly advertised AS &quot;GNU grep compatible&quot;?</div><br/><div id="38819875" class="c"><input type="checkbox" id="c-38819875" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#38819605">root</a><span>|</span><a href="#38819843">parent</a><span>|</span><a href="#38819704">next</a><span>|</span><label class="collapse" for="c-38819875">[-]</label><label class="expand" for="c-38819875">[1 more]</label></div><br/><div class="children"><div class="content">From the OP: &quot;Ugrep is compatible with GNU grep and supports GNU grep command-line options.&quot;</div><br/></div></div></div></div><div id="38819704" class="c"><input type="checkbox" id="c-38819704" checked=""/><div class="controls bullet"><span class="by">fwip</span><span>|</span><a href="#38819605">parent</a><span>|</span><a href="#38819843">prev</a><span>|</span><a href="#38819542">next</a><span>|</span><label class="collapse" for="c-38819704">[-]</label><label class="expand" for="c-38819704">[1 more]</label></div><br/><div class="children"><div class="content">Which option is that? I&#x27;m scanning the ugrep page, but nothing is popping out to me.</div><br/></div></div></div></div><div id="38819542" class="c"><input type="checkbox" id="c-38819542" checked=""/><div class="controls bullet"><span class="by">mathverse</span><span>|</span><a href="#38819605">prev</a><span>|</span><a href="#38822570">next</a><span>|</span><label class="collapse" for="c-38819542">[-]</label><label class="expand" for="c-38819542">[2 more]</label></div><br/><div class="children"><div class="content">Also look at <a href="https:&#x2F;&#x2F;github.com&#x2F;stealth&#x2F;grab">https:&#x2F;&#x2F;github.com&#x2F;stealth&#x2F;grab</a> from Sebastian Krahmer.</div><br/><div id="38821160" class="c"><input type="checkbox" id="c-38821160" checked=""/><div class="controls bullet"><span class="by">meowface</span><span>|</span><a href="#38819542">parent</a><span>|</span><a href="#38822570">next</a><span>|</span><label class="collapse" for="c-38821160">[-]</label><label class="expand" for="c-38821160">[1 more]</label></div><br/><div class="children"><div class="content">ripgrep, grab, ugrep, hypergrep... Any of the four are probably fast enough for any of my use cases but I suddenly feel tempted to micro-optimize and spend ages comparing them all.</div><br/></div></div></div></div><div id="38822570" class="c"><input type="checkbox" id="c-38822570" checked=""/><div class="controls bullet"><span class="by">nineteen96</span><span>|</span><a href="#38819542">prev</a><span>|</span><a href="#38819426">next</a><span>|</span><label class="collapse" for="c-38822570">[-]</label><label class="expand" for="c-38822570">[1 more]</label></div><br/><div class="children"><div class="content">this is slick! easily the best of these new grep tools. thanks for sharing. i’ll use this when grep(1) doesn’t quite cut it</div><br/></div></div><div id="38819426" class="c"><input type="checkbox" id="c-38819426" checked=""/><div class="controls bullet"><span class="by">infamia</span><span>|</span><a href="#38822570">prev</a><span>|</span><a href="#38821901">next</a><span>|</span><label class="collapse" for="c-38819426">[-]</label><label class="expand" for="c-38819426">[1 more]</label></div><br/><div class="children"><div class="content">Ugrep is also available in Debian based repos, which is super nice.</div><br/></div></div><div id="38821901" class="c"><input type="checkbox" id="c-38821901" checked=""/><div class="controls bullet"><span class="by">ijustlovemath</span><span>|</span><a href="#38819426">prev</a><span>|</span><a href="#38820876">next</a><span>|</span><label class="collapse" for="c-38821901">[-]</label><label class="expand" for="c-38821901">[4 more]</label></div><br/><div class="children"><div class="content">Any particular reason why newer tools don&#x27;t follow the well-established XDG standard for config files? Those folder structures probably already exist on end user machines, and keep your home directory from getting cluttered with tens of config files</div><br/><div id="38821932" class="c"><input type="checkbox" id="c-38821932" checked=""/><div class="controls bullet"><span class="by">xcdzvyn</span><span>|</span><a href="#38821901">parent</a><span>|</span><a href="#38822263">next</a><span>|</span><label class="collapse" for="c-38821932">[-]</label><label class="expand" for="c-38821932">[1 more]</label></div><br/><div class="children"><div class="content">Slight rant&#x2F;aside but Firefox is bad for this. You can point it to a custom profile path (e.g. .config&#x2F;mozilla) but ~&#x2F;.mozilla&#x2F;profile.ini MUST exist. Only that one file - you can move everything else.</div><br/></div></div><div id="38822263" class="c"><input type="checkbox" id="c-38822263" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38821901">parent</a><span>|</span><a href="#38821932">prev</a><span>|</span><a href="#38821923">next</a><span>|</span><label class="collapse" for="c-38822263">[-]</label><label class="expand" for="c-38822263">[1 more]</label></div><br/><div class="children"><div class="content">XDG isn&#x27;t recognized as an authority outside of XDG.</div><br/></div></div><div id="38821923" class="c"><input type="checkbox" id="c-38821923" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#38821901">parent</a><span>|</span><a href="#38822263">prev</a><span>|</span><a href="#38820876">next</a><span>|</span><label class="collapse" for="c-38821923">[-]</label><label class="expand" for="c-38821923">[1 more]</label></div><br/><div class="children"><div class="content">For ripgrep at least, you set an environment variable telling it where to look for a config file. You can put it anywhere, so you don&#x27;t need to put it in $HOME.<p>I didn&#x27;t do XDG because this route seemed simpler, and XDG isn&#x27;t something that is used everywhere.</div><br/></div></div></div></div><div id="38820876" class="c"><input type="checkbox" id="c-38820876" checked=""/><div class="controls bullet"><span class="by">jftuga</span><span>|</span><a href="#38821901">prev</a><span>|</span><a href="#38819558">next</a><span>|</span><label class="collapse" for="c-38820876">[-]</label><label class="expand" for="c-38820876">[1 more]</label></div><br/><div class="children"><div class="content">I really like the fuzzy match feature. Useful for typos or off by 1-2 characters.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Genivia&#x2F;ugrep#fuzzy">https:&#x2F;&#x2F;github.com&#x2F;Genivia&#x2F;ugrep#fuzzy</a></div><br/></div></div><div id="38819558" class="c"><input type="checkbox" id="c-38819558" checked=""/><div class="controls bullet"><span class="by">jraph</span><span>|</span><a href="#38820876">prev</a><span>|</span><a href="#38819845">next</a><span>|</span><label class="collapse" for="c-38819558">[-]</label><label class="expand" for="c-38819558">[3 more]</label></div><br/><div class="children"><div class="content">Okay, this solves a feature I was occasionally missing for a long time: searching for several terms in files (the &quot;Googling files&quot; feature). I wrote a 8 line script a few weeks ago to do this, that I will gladly throw away. I&#x27;ll look into the TUI too.<p>(I&#x27;ve been using ripgrep for quite some time now, how does this otherwise compare to it? would I be able to just replace rg with ug?)</div><br/><div id="38821128" class="c"><input type="checkbox" id="c-38821128" checked=""/><div class="controls bullet"><span class="by">bishfish</span><span>|</span><a href="#38819558">parent</a><span>|</span><a href="#38820257">next</a><span>|</span><label class="collapse" for="c-38821128">[-]</label><label class="expand" for="c-38821128">[1 more]</label></div><br/><div class="children"><div class="content">ugrep+ has this feature similar to ripgrep-all.<p>For regular use, I use ugrep’s %u option with its format feature to only get one match per line same as other grep tools.<p>Overall, I’m a happy user of ugrep. ugrep works as well as ripgrep for me. It’s VERY fast and has built-in option to search archives within archives recursively.</div><br/></div></div><div id="38820257" class="c"><input type="checkbox" id="c-38820257" checked=""/><div class="controls bullet"><span class="by">Levitating</span><span>|</span><a href="#38819558">parent</a><span>|</span><a href="#38821128">prev</a><span>|</span><a href="#38819845">next</a><span>|</span><label class="collapse" for="c-38820257">[-]</label><label class="expand" for="c-38820257">[1 more]</label></div><br/><div class="children"><div class="content">Is it that different from using fzf?<p>I currently use ripgrep-all (which can search into anything, video captions or pdfs) and fzf.</div><br/></div></div></div></div><div id="38819845" class="c"><input type="checkbox" id="c-38819845" checked=""/><div class="controls bullet"><span class="by">ww520</span><span>|</span><a href="#38819558">prev</a><span>|</span><a href="#38820898">next</a><span>|</span><label class="collapse" for="c-38819845">[-]</label><label class="expand" for="c-38819845">[1 more]</label></div><br/><div class="children"><div class="content">Just tried it out.  It&#x27;s blazingly fast.  The interactive TUI search is pretty sweet.</div><br/></div></div><div id="38820898" class="c"><input type="checkbox" id="c-38820898" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#38819845">prev</a><span>|</span><a href="#38819501">next</a><span>|</span><label class="collapse" for="c-38820898">[-]</label><label class="expand" for="c-38820898">[4 more]</label></div><br/><div class="children"><div class="content">Someone please just standardize the grep flags across all platforms.<p>Specifically -P &#x2F; --perl-regexp support on MacOS and FreeBSD<p>It really would reduce the WTF moments for the students.<p>Insert jokes about standards below...  =)</div><br/><div id="38820920" class="c"><input type="checkbox" id="c-38820920" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#38820898">parent</a><span>|</span><a href="#38819501">next</a><span>|</span><label class="collapse" for="c-38820920">[-]</label><label class="expand" for="c-38820920">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what POSIX was supposed to be.<p>It&#x27;s easier IMO to just use the same tool on all platforms. Which you can of course do.</div><br/><div id="38820975" class="c"><input type="checkbox" id="c-38820975" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#38820898">root</a><span>|</span><a href="#38820920">parent</a><span>|</span><a href="#38819501">next</a><span>|</span><label class="collapse" for="c-38820975">[-]</label><label class="expand" for="c-38820975">[2 more]</label></div><br/><div class="children"><div class="content">Not sure if brew&#x27;s grep is as NERF&#x27;ed, but POSIX standard often is just a subset of minimal features for the GNU version.<p>Cheers, =)</div><br/><div id="38820992" class="c"><input type="checkbox" id="c-38820992" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#38820898">root</a><span>|</span><a href="#38820975">parent</a><span>|</span><a href="#38819501">next</a><span>|</span><label class="collapse" for="c-38820992">[-]</label><label class="expand" for="c-38820992">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s the problem. You need to maintain a close attention level to know which things are POSIX. And in the case of GNU grep, you actually need to set POSIXLY_CORRECT=1. Otherwise its behavior is <i>not</i> a subset.<p>POSIX also forbids greps from searching UTF-16 because it mandates that certain characters always use a single byte. ripgrep, for example, doesn&#x27;t have this constraint and thus can transparently search UTF-16 correctly via BOM sniffing.</div><br/></div></div></div></div></div></div></div></div><div id="38819501" class="c"><input type="checkbox" id="c-38819501" checked=""/><div class="controls bullet"><span class="by">dmlerner</span><span>|</span><a href="#38820898">prev</a><span>|</span><a href="#38820786">next</a><span>|</span><label class="collapse" for="c-38819501">[-]</label><label class="expand" for="c-38819501">[32 more]</label></div><br/><div class="children"><div class="content">Why not ripgrep?</div><br/><div id="38820625" class="c"><input type="checkbox" id="c-38820625" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#38819501">parent</a><span>|</span><a href="#38819963">next</a><span>|</span><label class="collapse" for="c-38820625">[-]</label><label class="expand" for="c-38820625">[1 more]</label></div><br/><div class="children"><div class="content">Why not ugrep?<p>They are more or less equivalent. One has obscure feature X other has obscure feature Y, one is a bit faster on A, other is a bit faster on B, the defaults are a bit different, and one is written in Rust, the other in C++.<p>Pick the one you like, or both. I have both on my machine, and tend to use the one that does what I want with the least options. I also use GNU grep when I don&#x27;t need the speed or features of either ug and rg.</div><br/></div></div><div id="38819963" class="c"><input type="checkbox" id="c-38819963" checked=""/><div class="controls bullet"><span class="by">tredre3</span><span>|</span><a href="#38819501">parent</a><span>|</span><a href="#38820625">prev</a><span>|</span><a href="#38821193">next</a><span>|</span><label class="collapse" for="c-38819963">[-]</label><label class="expand" for="c-38819963">[11 more]</label></div><br/><div class="children"><div class="content">One thing I never liked about ripgrep is that it doesn&#x27;t have a pager. Yes, it can be configured to use the system-wide ones, but it&#x27;s an extra step (and every time I have to google how to preserve colors) and on Windows you&#x27;re SOL unless you install gnu utils or something. The author always refused to fix that.<p>Ugrep not only has a pager built in, but it also allows searching the results which is super nice! And that feature works on all supported platforms!</div><br/><div id="38820059" class="c"><input type="checkbox" id="c-38820059" checked=""/><div class="controls bullet"><span class="by">bornfreddy</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38819963">parent</a><span>|</span><a href="#38820047">next</a><span>|</span><label class="collapse" for="c-38820059">[-]</label><label class="expand" for="c-38820059">[4 more]</label></div><br/><div class="children"><div class="content">Interesting - for me a built-in pager is an antifeature. I don&#x27;t want to figure out how to leave the utility. Worst of all, pager usually means that sometimes you get more pages and you need to press q to exit, and sometimes not. Annoying. I often type yhe next command right away and the pager means I get stuck, or worse, pager starts doing something in response to my keys (looking at you, `git log`).<p>Then again I&#x27;m on Linux and can always pipe to less if I need to. I&#x27;m also not the target audience for ugrep because I&#x27;ve never noticed that <i>grep</i> would be slow. :shrug:</div><br/><div id="38820828" class="c"><input type="checkbox" id="c-38820828" checked=""/><div class="controls bullet"><span class="by">amethyst</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38820059">parent</a><span>|</span><a href="#38820749">next</a><span>|</span><label class="collapse" for="c-38820828">[-]</label><label class="expand" for="c-38820828">[2 more]</label></div><br/><div class="children"><div class="content">You might appreciate setting `PAGER=cat` in your environment. ;)<p>Git obeys that value, and I would <i>hope</i> that most other UNIXy terminal apps do too.</div><br/><div id="38822564" class="c"><input type="checkbox" id="c-38822564" checked=""/><div class="controls bullet"><span class="by">bornfreddy</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38820828">parent</a><span>|</span><a href="#38820749">next</a><span>|</span><label class="collapse" for="c-38822564">[-]</label><label class="expand" for="c-38822564">[1 more]</label></div><br/><div class="children"><div class="content">Oh, wow, thank you! I must try this.</div><br/></div></div></div></div><div id="38820749" class="c"><input type="checkbox" id="c-38820749" checked=""/><div class="controls bullet"><span class="by">VTimofeenko</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38820059">parent</a><span>|</span><a href="#38820828">prev</a><span>|</span><a href="#38820047">next</a><span>|</span><label class="collapse" for="c-38820749">[-]</label><label class="expand" for="c-38820749">[1 more]</label></div><br/><div class="children"><div class="content">Some terminal emulators (kitty for sure) support &quot;open last command output in pager&quot;. Works great with a pager that can understand ANSI colors - less fussing around with variables and flags to preserve colors in the pager</div><br/></div></div></div></div><div id="38820047" class="c"><input type="checkbox" id="c-38820047" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38819963">parent</a><span>|</span><a href="#38820059">prev</a><span>|</span><a href="#38821193">next</a><span>|</span><label class="collapse" for="c-38820047">[-]</label><label class="expand" for="c-38820047">[6 more]</label></div><br/><div class="children"><div class="content">This is what I do personally:<p><pre><code>    $ cat ~&#x2F;bin&#x2F;rgp
    #!&#x2F;bin&#x2F;sh
    exec rg -p &quot;$@&quot; | less -RFX
</code></pre>
Should work just fine. For Windows, you can install `bat` to use a pager if you don&#x27;t otherwise have one. You don&#x27;t need GNU utils to have a pager.</div><br/><div id="38821184" class="c"><input type="checkbox" id="c-38821184" checked=""/><div class="controls bullet"><span class="by">anjanb</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38820047">parent</a><span>|</span><a href="#38821193">next</a><span>|</span><label class="collapse" for="c-38821184">[-]</label><label class="expand" for="c-38821184">[5 more]</label></div><br/><div class="children"><div class="content">hi @burntsushi,<p><pre><code>   fan of your tool. like it&#x27;s speed and defaults.</code></pre>
I use windows : didn&#x27;t understand what you mean by &quot;install `bat`&quot; to use a pager.<p>I use cygwin and WSL for my unix needs. I have more and less in cygwin for use in windows.</div><br/><div id="38821205" class="c"><input type="checkbox" id="c-38821205" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38821184">parent</a><span>|</span><a href="#38821193">next</a><span>|</span><label class="collapse" for="c-38821205">[-]</label><label class="expand" for="c-38821205">[4 more]</label></div><br/><div class="children"><div class="content">I referenced bat because I&#x27;ve found that suggesting cygwin sometimes provokes a negative reaction. The GP also mentioned needing to install GNU tooling as if it were a negative.<p>bat is fancy pager written in Rust. It&#x27;s on GitHub: <a href="https:&#x2F;&#x2F;github.com&#x2F;sharkdp&#x2F;bat">https:&#x2F;&#x2F;github.com&#x2F;sharkdp&#x2F;bat</a></div><br/><div id="38822602" class="c"><input type="checkbox" id="c-38822602" checked=""/><div class="controls bullet"><span class="by">ilyagr</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38821205">parent</a><span>|</span><a href="#38821747">next</a><span>|</span><label class="collapse" for="c-38822602">[-]</label><label class="expand" for="c-38822602">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t believe bat is a paper; it&#x27;s more of a pretty-printer that tends to call less.<p>Two pallets that should work on Windows are <a href="https:&#x2F;&#x2F;github.com&#x2F;walles&#x2F;moar">https:&#x2F;&#x2F;github.com&#x2F;walles&#x2F;moar</a> (golang) and <a href="https:&#x2F;&#x2F;github.com&#x2F;markbt&#x2F;streampager">https:&#x2F;&#x2F;github.com&#x2F;markbt&#x2F;streampager</a> (Rust). There might also be a newer one that uses rust, I&#x27;m unsure.</div><br/></div></div><div id="38821747" class="c"><input type="checkbox" id="c-38821747" checked=""/><div class="controls bullet"><span class="by">anjanb</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38821205">parent</a><span>|</span><a href="#38822602">prev</a><span>|</span><a href="#38821193">next</a><span>|</span><label class="collapse" for="c-38821747">[-]</label><label class="expand" for="c-38821747">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure you know but windows command prompt always came with its inbuilt pager -- more. So, you could always do &quot;dir | more&quot; or &quot;rg -p &quot;%*&quot; | more &quot;. (more is good with colors without flags)</div><br/><div id="38821914" class="c"><input type="checkbox" id="c-38821914" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38821747">parent</a><span>|</span><a href="#38821193">next</a><span>|</span><label class="collapse" for="c-38821914">[-]</label><label class="expand" for="c-38821914">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t! I&#x27;m not a Windows user. Colors are half the battle, so that&#x27;s good. Will it only appear if paging is actually needed? That&#x27;s what the flags to `less` do in my wrapper script above. They are rather critical for this use case.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38821193" class="c"><input type="checkbox" id="c-38821193" checked=""/><div class="controls bullet"><span class="by">MrDrMcCoy</span><span>|</span><a href="#38819501">parent</a><span>|</span><a href="#38819963">prev</a><span>|</span><a href="#38819838">next</a><span>|</span><label class="collapse" for="c-38821193">[-]</label><label class="expand" for="c-38821193">[1 more]</label></div><br/><div class="children"><div class="content">For me, it&#x27;s a lot easier to compile a static binary of a C++ app than a Rust one. Never got that to work. Also nice to have compatibility with all of grep&#x27;s arguments.</div><br/></div></div><div id="38819838" class="c"><input type="checkbox" id="c-38819838" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#38819501">parent</a><span>|</span><a href="#38821193">prev</a><span>|</span><a href="#38819551">next</a><span>|</span><label class="collapse" for="c-38819838">[-]</label><label class="expand" for="c-38819838">[1 more]</label></div><br/><div class="children"><div class="content">The best practical reason to choose this is its interactive features, like regexp building.</div><br/></div></div><div id="38819551" class="c"><input type="checkbox" id="c-38819551" checked=""/><div class="controls bullet"><span class="by">devraza</span><span>|</span><a href="#38819501">parent</a><span>|</span><a href="#38819838">prev</a><span>|</span><a href="#38819554">next</a><span>|</span><label class="collapse" for="c-38819551">[-]</label><label class="expand" for="c-38819551">[3 more]</label></div><br/><div class="children"><div class="content">From the ugrep README:<p>For an up-to-date performance comparison of the latest ugrep, please see the ugrep performance benchmarks [at <a href="https:&#x2F;&#x2F;github.com&#x2F;Genivia&#x2F;ugrep-benchmarks">https:&#x2F;&#x2F;github.com&#x2F;Genivia&#x2F;ugrep-benchmarks</a>]. Ugrep is faster than GNU grep, Silver Searcher, ack, sift. Ugrep&#x27;s speed beats ripgrep in most benchmarks.</div><br/><div id="38819635" class="c"><input type="checkbox" id="c-38819635" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38819551">parent</a><span>|</span><a href="#38819554">next</a><span>|</span><label class="collapse" for="c-38819635">[-]</label><label class="expand" for="c-38819635">[2 more]</label></div><br/><div class="children"><div class="content">Does these performance comparison take into account the things BurntSushi (ripgrep author) pointed out in the ripgrep issue link elsewhere ITT? <a href="https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;ripgrep&#x2F;discussions&#x2F;2597">https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;ripgrep&#x2F;discussions&#x2F;2597</a><p>Either way, ripgrep is awesome and I’m staying with it.</div><br/><div id="38820508" class="c"><input type="checkbox" id="c-38820508" checked=""/><div class="controls bullet"><span class="by">devraza</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38819635">parent</a><span>|</span><a href="#38819554">next</a><span>|</span><label class="collapse" for="c-38820508">[-]</label><label class="expand" for="c-38820508">[1 more]</label></div><br/><div class="children"><div class="content">Agreed - ripgrep is great, and I&#x27;m not planning to switch either. The performance improvement is tiny, anyways.</div><br/></div></div></div></div></div></div><div id="38819554" class="c"><input type="checkbox" id="c-38819554" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#38819501">parent</a><span>|</span><a href="#38819551">prev</a><span>|</span><a href="#38819653">next</a><span>|</span><label class="collapse" for="c-38819554">[-]</label><label class="expand" for="c-38819554">[12 more]</label></div><br/><div class="children"><div class="content">I assume the grep compatible bit is attractive to some people. Not me, but they exist.</div><br/><div id="38819625" class="c"><input type="checkbox" id="c-38819625" checked=""/><div class="controls bullet"><span class="by">derriz</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38819554">parent</a><span>|</span><a href="#38819653">next</a><span>|</span><label class="collapse" for="c-38819625">[-]</label><label class="expand" for="c-38819625">[11 more]</label></div><br/><div class="children"><div class="content">I find myself returning to grep from my default of rg because I&#x27;m just too lazy to learn a new regex language.  Stuff like word boundaries &quot;\&lt;word\&gt;&quot; or multiple patterns &quot;\(one\|two\)&quot;.</div><br/><div id="38819681" class="c"><input type="checkbox" id="c-38819681" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38819625">parent</a><span>|</span><a href="#38819895">next</a><span>|</span><label class="collapse" for="c-38819681">[-]</label><label class="expand" for="c-38819681">[6 more]</label></div><br/><div class="children"><div class="content">That seems like the weirdest take ever: ripgrep uses pretty standard PCRE patterns, which are a lot more common than posix’s bre monstrosity.<p>To me the regex langage is very much a reason to not use grep.</div><br/><div id="38819933" class="c"><input type="checkbox" id="c-38819933" checked=""/><div class="controls bullet"><span class="by">derriz</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38819681">parent</a><span>|</span><a href="#38819757">next</a><span>|</span><label class="collapse" for="c-38819933">[-]</label><label class="expand" for="c-38819933">[3 more]</label></div><br/><div class="children"><div class="content">A bit hyperbolic, no?<p>If you consider it &quot;the weirdest ever&quot;, I&#x27;m guessing that I&#x27;m probably older than you.  I&#x27;ve certainly been using regex long before PCRE became common.<p>As a vim user I compose 10s if not 100s of regexes a day.  It does not use PCRE.  Nor does sed, a tool I&#x27;ve been using for decades.  Do you also recommend not using these?</div><br/><div id="38820291" class="c"><input type="checkbox" id="c-38820291" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38819933">parent</a><span>|</span><a href="#38819757">next</a><span>|</span><label class="collapse" for="c-38820291">[-]</label><label class="expand" for="c-38820291">[2 more]</label></div><br/><div class="children"><div class="content">I use all of those tools but the inconsistency drives me crazy as it&#x27;s hard to remember which syntax to use where.  Here&#x27;s how to match the end of a word:<p>ripgrep, Python, JavaScript, and practically every other non-C language: \b<p>vim: \&gt;<p>BSD sed: [[:&gt;:]]<p>GNU sed, GNU grep: \&gt; or \b<p>BSD grep: \&gt;, \b, or [[:&gt;:]]<p>less: depends on the OS it&#x27;s running on</div><br/><div id="38820350" class="c"><input type="checkbox" id="c-38820350" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38820291">parent</a><span>|</span><a href="#38819757">next</a><span>|</span><label class="collapse" for="c-38820350">[-]</label><label class="expand" for="c-38820350">[1 more]</label></div><br/><div class="children"><div class="content">Did you know that not all of those use the same definition of what a &quot;word&quot; character is? Regex engines differ on the inclusion of things like \p{Join_Control}, \p{Mark} and \p{Connector_Puncuation}. Although in the case of \p{Connector_Punctuation}, regex engines will usually at least include underscore. See: <a href="https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;rebar&#x2F;blob&#x2F;f9a4f5c9efda069e7986a262efe8649aa78c0933&#x2F;benchmarks&#x2F;definitions&#x2F;test&#x2F;unicode&#x2F;word-boundary.toml">https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;rebar&#x2F;blob&#x2F;f9a4f5c9efda069e798...</a><p>And then there&#x27;s \p{Letter}. It can be spelled in a lot of ways: \pL, \p{L}, \p{Letter}, \p{gc=Letter}, \p{gc:Letter}, \p{LeTtEr}. All equivalent. Very few regex engines support all of them. Several support \p{L} but not \pL. See: <a href="https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;rebar&#x2F;blob&#x2F;f9a4f5c9efda069e7986a262efe8649aa78c0933&#x2F;benchmarks&#x2F;definitions&#x2F;test&#x2F;unicode&#x2F;letter.toml">https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;rebar&#x2F;blob&#x2F;f9a4f5c9efda069e798...</a></div><br/></div></div></div></div></div></div><div id="38819757" class="c"><input type="checkbox" id="c-38819757" checked=""/><div class="controls bullet"><span class="by">pbhjpbhj</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38819681">parent</a><span>|</span><a href="#38819933">prev</a><span>|</span><a href="#38819895">next</a><span>|</span><label class="collapse" for="c-38819757">[-]</label><label class="expand" for="c-38819757">[2 more]</label></div><br/><div class="children"><div class="content">`pgrep`, or `grep -P`, uses PCRE though, AFAIUI.</div><br/></div></div></div></div><div id="38819895" class="c"><input type="checkbox" id="c-38819895" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38819625">parent</a><span>|</span><a href="#38819681">prev</a><span>|</span><a href="#38819653">next</a><span>|</span><label class="collapse" for="c-38819895">[-]</label><label class="expand" for="c-38819895">[4 more]</label></div><br/><div class="children"><div class="content">ripgrep&#x27;s regex syntax is pretty similar to grep -E. So if you know grep -E, most of that will transfer over.<p>Also, \&lt; and \&gt; are in ripgrep 14. Although you usually just want to use the -w&#x2F;--word-regexp flag.</div><br/><div id="38820055" class="c"><input type="checkbox" id="c-38820055" checked=""/><div class="controls bullet"><span class="by">xoranth</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38819895">parent</a><span>|</span><a href="#38819653">next</a><span>|</span><label class="collapse" for="c-38820055">[-]</label><label class="expand" for="c-38820055">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Also, \&lt; and \&gt; are in ripgrep 14<p>Isn&#x27;t that inconsistent with the way Perl&#x27;s regex syntax was designed? In Perl&#x27;s syntax an escaped non-ASCII character is always a literal [^1], and that is guaranteed not to change.<p>That&#x27;s nice for beginners because it saves you from having to memorize all the metacharacters. If you are in doubt you on whether something has a special meaning, you just escape it.<p>[^1]: <a href="https:&#x2F;&#x2F;perldoc.perl.org&#x2F;perlrebackslash#The-backslash" rel="nofollow">https:&#x2F;&#x2F;perldoc.perl.org&#x2F;perlrebackslash#The-backslash</a></div><br/><div id="38820186" class="c"><input type="checkbox" id="c-38820186" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38820055">parent</a><span>|</span><a href="#38819653">next</a><span>|</span><label class="collapse" for="c-38820186">[-]</label><label class="expand" for="c-38820186">[2 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s inconsistent with Perl. But there are many things in ripgrep&#x27;s default regex engine that are inconsistent with Perl, including the fact that all patterns are guaranteed to finish a search in linear time with respect to the haystack. (So no look-around or back-references are supported.) It is a non-goal of ripgrep to be consistent with Perl. Thankfully, if you want that, then you can get pretty close by passing the -P&#x2F;--pcre2 flag.<p>With that said, I do like Perl&#x27;s philosophy here. And it was my philosophy too up until recently. I decided to make an exception for \&lt; and \&gt; given their prevalence.<p>It was also only relatively recently that I made it possible for superfluous escapes to exist. Prior to ripgrep 14, unrecognized escapes were forbidden:<p><pre><code>    $ echo &#x27;@&#x27; | rg-13.0.0 &#x27;\@&#x27;
    regex parse error:
        \@
        ^^
    error: unrecognized escape sequence
    $ echo &#x27;@&#x27; | rg &#x27;\@&#x27;
    @
</code></pre>
I had done it this way to make it possible to add new escape sequences in a semver compatible release. But in reality, if I were to ever add new escape sequences, it use one of the ascii alpha-numeric characters, as Perl does. So I decided it was okay to forever and always give up the ability to make, e.g., `\@` mean something other than just matching a literal `@`.<p>`\&lt;` and `\&gt;` are forever and always the lone exceptions to this. It is perhaps a trap for beginners, but there are many traps in regexes, and this seemed worth it.<p>Note that `\b{start}` and `\b{end}` also exist and are aliases for `\&lt;` and `\&gt;`. The more niche `\b{start-half}` and `\b{end-half}` also exist, and <i>those</i> are what are used to implement the -w&#x2F;--word-regexp flag. (Their semantics match GNU grep&#x27;s -w&#x2F;--word-regexp.) For example, `\b-2\b` will not match in `foo -2 bar` since `-` is not a word character and `\b` demands `\w` on one side and `\W` on the other. However, `rg -w -e -2` will match `-2` in `foo -2 bar`:<p><pre><code>    $ echo &#x27;foo -2 bar&#x27; | rg -w -e &#x27;\b-2\b&#x27;
    $ echo &#x27;foo -2 bar&#x27; | rg -w -e -2
    foo -2 bar</code></pre></div><br/><div id="38820354" class="c"><input type="checkbox" id="c-38820354" checked=""/><div class="controls bullet"><span class="by">xoranth</span><span>|</span><a href="#38819501">root</a><span>|</span><a href="#38820186">parent</a><span>|</span><a href="#38819653">next</a><span>|</span><label class="collapse" for="c-38820354">[-]</label><label class="expand" for="c-38820354">[1 more]</label></div><br/><div class="children"><div class="content">Ok, makes sense. And thanks for the detailed explaination about word boundaries and the hint about the --pcre flag (I hadn&#x27;t realized it existed).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38819653" class="c"><input type="checkbox" id="c-38819653" checked=""/><div class="controls bullet"><span class="by">meindnoch</span><span>|</span><a href="#38819501">parent</a><span>|</span><a href="#38819554">prev</a><span>|</span><a href="#38819729">next</a><span>|</span><label class="collapse" for="c-38819653">[-]</label><label class="expand" for="c-38819653">[1 more]</label></div><br/><div class="children"><div class="content">Because this is faster?</div><br/></div></div><div id="38819729" class="c"><input type="checkbox" id="c-38819729" checked=""/><div class="controls bullet"><span class="by">bsdpufferfish</span><span>|</span><a href="#38819501">parent</a><span>|</span><a href="#38819653">prev</a><span>|</span><a href="#38820786">next</a><span>|</span><label class="collapse" for="c-38819729">[-]</label><label class="expand" for="c-38819729">[1 more]</label></div><br/><div class="children"><div class="content">ripgrep stole the name but doesn’t follow the posix standard.</div><br/></div></div></div></div><div id="38820786" class="c"><input type="checkbox" id="c-38820786" checked=""/><div class="controls bullet"><span class="by">Sparkyte</span><span>|</span><a href="#38819501">prev</a><span>|</span><a href="#38820871">next</a><span>|</span><label class="collapse" for="c-38820786">[-]</label><label class="expand" for="c-38820786">[4 more]</label></div><br/><div class="children"><div class="content">Cool, but in a real life scenario where the system is not able to pull from external packages because it is in a secured environment makes myself think this is moot as you&#x27;ll be out of practice of actually running grep. I would avoid not staying out of practice with grep.<p>On the other hand for a non-work environment where security isn&#x27;t in question this is cool.</div><br/><div id="38820801" class="c"><input type="checkbox" id="c-38820801" checked=""/><div class="controls bullet"><span class="by">seanp2k2</span><span>|</span><a href="#38820786">parent</a><span>|</span><a href="#38821010">next</a><span>|</span><label class="collapse" for="c-38820801">[-]</label><label class="expand" for="c-38820801">[1 more]</label></div><br/><div class="children"><div class="content">This. I had to beg and wait about a year to get jq added to our base image once it passed sec review and all that.</div><br/></div></div><div id="38821010" class="c"><input type="checkbox" id="c-38821010" checked=""/><div class="controls bullet"><span class="by">kyawzazaw</span><span>|</span><a href="#38820786">parent</a><span>|</span><a href="#38820801">prev</a><span>|</span><a href="#38821132">next</a><span>|</span><label class="collapse" for="c-38821010">[-]</label><label class="expand" for="c-38821010">[1 more]</label></div><br/><div class="children"><div class="content">I find bat pretty useful on my local machine</div><br/></div></div></div></div><div id="38820871" class="c"><input type="checkbox" id="c-38820871" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#38820786">prev</a><span>|</span><a href="#38819662">next</a><span>|</span><label class="collapse" for="c-38820871">[-]</label><label class="expand" for="c-38820871">[7 more]</label></div><br/><div class="children"><div class="content">I feel like if you&#x27;re going to make a new grep and put a web page for it, your webpage should start with why your grep is better than the default (or all the other ones).<p>Why did you build a new grep?</div><br/><div id="38821233" class="c"><input type="checkbox" id="c-38821233" checked=""/><div class="controls bullet"><span class="by">infamia</span><span>|</span><a href="#38820871">parent</a><span>|</span><a href="#38821144">next</a><span>|</span><label class="collapse" for="c-38821233">[-]</label><label class="expand" for="c-38821233">[5 more]</label></div><br/><div class="children"><div class="content">&gt; I feel like if you&#x27;re going to make a new grep and put a web page for it, your webpage should start with why your grep is better than the default (or all the other ones).<p>No snark here, but is the subtitle not enough to start?  &quot;a more powerful, ultra fast, user-friendly, compatible grep&quot;</div><br/><div id="38822156" class="c"><input type="checkbox" id="c-38822156" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#38820871">root</a><span>|</span><a href="#38821233">parent</a><span>|</span><a href="#38821748">next</a><span>|</span><label class="collapse" for="c-38822156">[-]</label><label class="expand" for="c-38822156">[2 more]</label></div><br/><div class="children"><div class="content">Not really.<p>* a more powerful -- This is meaningless without some sort of examples.  Powerful how?  What does it do that&#x27;s better than grep?<p>* ultra fast -- This at least means <i>something</i>, but it should be quantified in some way.  &quot;50%+ faster for most uses cases&quot; or something like that.<p>* user-friendly -- not even sure what this means.  Seems kind of subjective anyway.  I find grep plenty user friendly, for a command line tool.<p>* compatible grep -- I mean, they all are pretty much, but I guess it&#x27;s good to know this?</div><br/><div id="38822504" class="c"><input type="checkbox" id="c-38822504" checked=""/><div class="controls bullet"><span class="by">infamia</span><span>|</span><a href="#38820871">root</a><span>|</span><a href="#38822156">parent</a><span>|</span><a href="#38821748">next</a><span>|</span><label class="collapse" for="c-38822504">[-]</label><label class="expand" for="c-38822504">[1 more]</label></div><br/><div class="children"><div class="content">&gt; * ultra fast -- This at least means something, but it should be quantified in some way. &quot;50%+ faster for most uses cases&quot; or something like that.<p>That would be begging for nerd rage posts, just like so many disputing the benchmarks. &gt;:D<p>&gt; * user-friendly -- not even sure what this means. Seems kind of subjective anyway. I find grep plenty user friendly, for a command line tool.<p>Just below is a huge, captioned screenshot of the TUI?<p>&gt; * compatible grep -- I mean, they all are pretty much, but I guess it&#x27;s good to know this?<p>One would think so... but I have so many scars concerning incompatibilities with different versions of grep (as do others in the comments). If you don&#x27;t know, then that feature isn&#x27;t listed for you. :)</div><br/></div></div></div></div><div id="38821748" class="c"><input type="checkbox" id="c-38821748" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#38820871">root</a><span>|</span><a href="#38821233">parent</a><span>|</span><a href="#38822156">prev</a><span>|</span><a href="#38821144">next</a><span>|</span><label class="collapse" for="c-38821748">[-]</label><label class="expand" for="c-38821748">[2 more]</label></div><br/><div class="children"><div class="content">no snark here, but the subtitle was the start of my confusion: what does &quot;user-friendly&quot; mean in the context of grep, and why should I believe the claim?<p>regular expressions are not friendly, but the user friendly way for a cli filter to behave is to return retvals appropriately, output to stdout, error messages to stderr... does user friendly mean copious output to stderr? what else could it possibly mean? do I want copious output to stderr?</div><br/><div id="38822562" class="c"><input type="checkbox" id="c-38822562" checked=""/><div class="controls bullet"><span class="by">infamia</span><span>|</span><a href="#38820871">root</a><span>|</span><a href="#38821748">parent</a><span>|</span><a href="#38821144">next</a><span>|</span><label class="collapse" for="c-38822562">[-]</label><label class="expand" for="c-38822562">[1 more]</label></div><br/><div class="children"><div class="content">&gt; no snark here, but the subtitle was the start of my confusion: what does &quot;user-friendly&quot; mean in the context of grep, and why should I believe the claim?<p>Granted, it is far from a thing of beauty, but there is a large, captioned screenshot of the included text user interface just beneath.  Then again, it is a website for a command line tool. &quot;Many Bothans died to bring us this information.&quot;</div><br/></div></div></div></div></div></div></div></div><div id="38820357" class="c"><input type="checkbox" id="c-38820357" checked=""/><div class="controls bullet"><span class="by">stevebmark</span><span>|</span><a href="#38819662">prev</a><span>|</span><label class="collapse" for="c-38820357">[-]</label><label class="expand" for="c-38820357">[1 more]</label></div><br/><div class="children"><div class="content">There are many grep variations. The Unix philosophy: do one thing well. The Unix reality: do many things poorly*<p>*grep, awk, sed</div><br/></div></div></div></div></div></div></div></body></html>