<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1711270853153" as="style"/><link rel="stylesheet" href="styles.css?v=1711270853153"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.righto.com/2024/03/8088-prefetch-circuitry.html">The Intel 8088 processor&#x27;s instruction prefetch circuitry: a look inside</a> <span class="domain">(<a href="https://www.righto.com">www.righto.com</a>)</span></div><div class="subtext"><span>matt_d</span> | <span>32 comments</span></div><br/><div><div id="39805751" class="c"><input type="checkbox" id="c-39805751" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#39803491">next</a><span>|</span><label class="collapse" for="c-39805751">[-]</label><label class="expand" for="c-39805751">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s quite humbling to look at how much they had to know to implement all these little details, and then realise that this is a 45-year-old design which is several orders of magnitude less complex than modern processors. Even other well-known CPUs of the time like the 6502 and Z80 are only a few years older, yet far simpler.</div><br/></div></div><div id="39803491" class="c"><input type="checkbox" id="c-39803491" checked=""/><div class="controls bullet"><span class="by">jecel</span><span>|</span><a href="#39805751">prev</a><span>|</span><a href="#39802149">next</a><span>|</span><label class="collapse" for="c-39803491">[-]</label><label class="expand" for="c-39803491">[5 more]</label></div><br/><div class="children"><div class="content">A 4116 DRAM chip with a 250 ns access time would have a 500 ns cycle time, so could read or write 2 million words per second. The Acorn people called this a 2 MHz memory. You could have shorter cycle times in &quot;column mode&quot; where you pulsed the &#x2F;CAS signal only to access words in the same row and the Acorn designers made good use of that for the Electron (reading 8 bits from a 4 bit wide memory) and the ARM based Archimedes (fetching instructions other than jump, load or store as well as loading the video and audio FIFOs).<p>From one DRAM generation to the next the cycle time might be different for chips with the same access time. This allowed me to make the 512KB Macintosh faster than the 128KB one (<a href="http:&#x2F;&#x2F;www.merlintec.com&#x2F;lsi&#x2F;mac512.html" rel="nofollow">http:&#x2F;&#x2F;www.merlintec.com&#x2F;lsi&#x2F;mac512.html</a>).</div><br/><div id="39804362" class="c"><input type="checkbox" id="c-39804362" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#39803491">parent</a><span>|</span><a href="#39804296">next</a><span>|</span><label class="collapse" for="c-39804362">[-]</label><label class="expand" for="c-39804362">[2 more]</label></div><br/><div class="children"><div class="content">You could also have shorter cycles times by just doing it and assuming it&#x27;ll be fine. Acorn&#x27;s Master Turbo uses 4864-2 DRAMs, which have a 150 ns access time&#x2F;270 ns cycle time, for, I think, a max throughput of 1e9&#x2F;270=3,703,703 bytes&#x2F;sec - but the Master Turbo&#x27;s 65c02 CPU runs at 4 MHz, and therefore requires 4,000,000 bytes&#x2F;sec. And, somehow, it works...</div><br/><div id="39805088" class="c"><input type="checkbox" id="c-39805088" checked=""/><div class="controls bullet"><span class="by">jecel</span><span>|</span><a href="#39803491">root</a><span>|</span><a href="#39804362">parent</a><span>|</span><a href="#39804296">next</a><span>|</span><label class="collapse" for="c-39805088">[-]</label><label class="expand" for="c-39805088">[1 more]</label></div><br/><div class="children"><div class="content">That is probably similar to how you could use both sides of a single sided floppy. Both sides were tested and the factory ended up with a huge pile of floppies that passed both sides and a small pile that failed one side (and some that failed both sides and were discarded). The market wanted more single sided disks so they simply moved a number of floppies from the first pile to the second. That meant that you mostly likely got a double sided product when you paid for a single sided one. But it was a risk.<p>Same thing of processor and memory speed bins.</div><br/></div></div></div></div><div id="39804296" class="c"><input type="checkbox" id="c-39804296" checked=""/><div class="controls bullet"><span class="by">djmips</span><span>|</span><a href="#39803491">parent</a><span>|</span><a href="#39804362">prev</a><span>|</span><a href="#39802149">next</a><span>|</span><label class="collapse" for="c-39804296">[-]</label><label class="expand" for="c-39804296">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a fantastic read! Thanks for sharing. What are you working on these days?</div><br/><div id="39805123" class="c"><input type="checkbox" id="c-39805123" checked=""/><div class="controls bullet"><span class="by">jecel</span><span>|</span><a href="#39803491">root</a><span>|</span><a href="#39804296">parent</a><span>|</span><a href="#39802149">next</a><span>|</span><label class="collapse" for="c-39805123">[-]</label><label class="expand" for="c-39805123">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! I still design Smalltalk computers like I did back then but now I also design my own processors.</div><br/></div></div></div></div></div></div><div id="39802149" class="c"><input type="checkbox" id="c-39802149" checked=""/><div class="controls bullet"><span class="by">h2odragon</span><span>|</span><a href="#39803491">prev</a><span>|</span><a href="#39802074">next</a><span>|</span><label class="collapse" for="c-39802149">[-]</label><label class="expand" for="c-39802149">[17 more]</label></div><br/><div class="children"><div class="content">&gt; The 8086&#x2F;8088 do not provide consistency ...  self-modifying code can be used to determine the queue length, distinguishing the 8086 from the 8088 in software.<p>I sincerely doubt I was the first to work that out; but I remember being so incredibly happy when <i>I</i> figured that one out, when it solved a problem i had.<p>Cannot now recall why the difference was significant, something about installing different routines for bashing serial ports i think.</div><br/><div id="39802953" class="c"><input type="checkbox" id="c-39802953" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#39802149">parent</a><span>|</span><a href="#39802358">next</a><span>|</span><label class="collapse" for="c-39802953">[-]</label><label class="expand" for="c-39802953">[5 more]</label></div><br/><div class="children"><div class="content">In the era before internet, you either figured things out on your own or you couldn&#x27;t get anything done.<p>If you were very lucky, some magazine might have mentioned it. Another way out was to just use disassembler if some other software package performed the same thing.</div><br/><div id="39803391" class="c"><input type="checkbox" id="c-39803391" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#39802149">root</a><span>|</span><a href="#39802953">parent</a><span>|</span><a href="#39804111">next</a><span>|</span><label class="collapse" for="c-39803391">[-]</label><label class="expand" for="c-39803391">[3 more]</label></div><br/><div class="children"><div class="content">You still do on occasion. Some years ago I’ve tried to write a precisely timed bitbanging loop on a STM8 microcontroller (a 650x&#x2F;680x-alike with an allegedly 3-stage pipeline and a small prefetch buffer; cents per chip pre-Covid), and the instruction prefetch completely screwed me up. (At least I think it was the instruction prefetch? The thing depended on branch target alignment, whatever it was.) The one relevant question on Stack Overflow that hasn’t received any answers in years; the manufacturer documentation mentions its instruction timings are “simplified”, aka a lie, and gives a more elaborate model of the pipeline that it admits is also a lie and can’t reproduce the timings I’m seeing.<p>Many things <i>are</i> immeasurably easier than what I remember as a middle-schooler with an utterly anachronistic 286 in post-Soviet early 2000s Moscow, so that’s nice. It doesn’t make the blasted loop work, though.<p>(Many others are also worse. Today’s me could work the motherboard design of the 286 by looking at it, even without the manuals; my current laptop’s manufacturer’s refusal to release the schematics annoys me enough that I’ve half a mind to ask some physicists if they have a CT machine they could run the board through.)</div><br/><div id="39804477" class="c"><input type="checkbox" id="c-39804477" checked=""/><div class="controls bullet"><span class="by">ddingus</span><span>|</span><a href="#39802149">root</a><span>|</span><a href="#39803391">parent</a><span>|</span><a href="#39803512">next</a><span>|</span><label class="collapse" for="c-39804477">[-]</label><label class="expand" for="c-39804477">[1 more]</label></div><br/><div class="children"><div class="content">Looks to me like you, and perhaps others, could benefit from a set of timing tests.<p>You know, setup a test harness. With timers and such, then walk through the cases.<p>Of course, that is exactly what the manufacturer should have done!  I always wondered at the high errata metrics associated with some catalog parts.  It is just not enough to work through the circuit and hope for the best!</div><br/></div></div><div id="39803512" class="c"><input type="checkbox" id="c-39803512" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#39802149">root</a><span>|</span><a href="#39803391">parent</a><span>|</span><a href="#39804477">prev</a><span>|</span><a href="#39804111">next</a><span>|</span><label class="collapse" for="c-39803512">[-]</label><label class="expand" for="c-39803512">[1 more]</label></div><br/><div class="children"><div class="content">Compared to now, back then it was a lot more you had to figure out on your own.<p>I remember coding a game on C64 in the eighties. Just to figure out how to print the players <i>score</i> so that it is sufficiently fast was a challenge. Dividing by 10 with modulo to convert numbers to digits was just way too slow.<p>My method was not to use normal math, but to directly manipulate screen RAM characters when the score increased.<p>That was a very cheap way to increase the players score by say 1000 – you didn&#x27;t even have to care about 3 lowest digits, just inc thousands place by 1, if it overflowed past 9, increase next position left, etc.</div><br/></div></div></div></div><div id="39804111" class="c"><input type="checkbox" id="c-39804111" checked=""/><div class="controls bullet"><span class="by">djmips</span><span>|</span><a href="#39802149">root</a><span>|</span><a href="#39802953">parent</a><span>|</span><a href="#39803391">prev</a><span>|</span><a href="#39802358">next</a><span>|</span><label class="collapse" for="c-39804111">[-]</label><label class="expand" for="c-39804111">[1 more]</label></div><br/><div class="children"><div class="content">The public or college library could really come in handy.</div><br/></div></div></div></div><div id="39802358" class="c"><input type="checkbox" id="c-39802358" checked=""/><div class="controls bullet"><span class="by">transitionnel</span><span>|</span><a href="#39802149">parent</a><span>|</span><a href="#39802953">prev</a><span>|</span><a href="#39802258">next</a><span>|</span><label class="collapse" for="c-39802358">[-]</label><label class="expand" for="c-39802358">[1 more]</label></div><br/><div class="children"><div class="content">Half of what keeps me going is the belief that I can randomly wander into this forum and witness black magic being tossed around like spare change. ;D</div><br/></div></div><div id="39802258" class="c"><input type="checkbox" id="c-39802258" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#39802149">parent</a><span>|</span><a href="#39802358">prev</a><span>|</span><a href="#39802074">next</a><span>|</span><label class="collapse" for="c-39802258">[-]</label><label class="expand" for="c-39802258">[10 more]</label></div><br/><div class="children"><div class="content">Neat! Eventually, Intel added the CPUID instruction so you could determine the processor type without trickery.</div><br/><div id="39803162" class="c"><input type="checkbox" id="c-39803162" checked=""/><div class="controls bullet"><span class="by">Agingcoder</span><span>|</span><a href="#39802149">root</a><span>|</span><a href="#39802258">parent</a><span>|</span><a href="#39802371">next</a><span>|</span><label class="collapse" for="c-39803162">[-]</label><label class="expand" for="c-39803162">[2 more]</label></div><br/><div class="children"><div class="content">There were all kinds of tricks prior to cpuid to figure out what kind of cpu you were running on . I had actually forgotten about that - thanks for reminding me !</div><br/><div id="39803735" class="c"><input type="checkbox" id="c-39803735" checked=""/><div class="controls bullet"><span class="by">rzzzt</span><span>|</span><a href="#39802149">root</a><span>|</span><a href="#39803162">parent</a><span>|</span><a href="#39802371">next</a><span>|</span><label class="collapse" for="c-39803735">[-]</label><label class="expand" for="c-39803735">[1 more]</label></div><br/><div class="children"><div class="content">Robert Collins&#x27; article lists some of these methods, mostly centered around flag bits behavior: <a href="http:&#x2F;&#x2F;www.rcollins.org&#x2F;ddj&#x2F;Sep96&#x2F;Sep96.html" rel="nofollow">http:&#x2F;&#x2F;www.rcollins.org&#x2F;ddj&#x2F;Sep96&#x2F;Sep96.html</a></div><br/></div></div></div></div><div id="39802371" class="c"><input type="checkbox" id="c-39802371" checked=""/><div class="controls bullet"><span class="by">temac</span><span>|</span><a href="#39802149">root</a><span>|</span><a href="#39802258">parent</a><span>|</span><a href="#39803162">prev</a><span>|</span><a href="#39802074">next</a><span>|</span><label class="collapse" for="c-39802371">[-]</label><label class="expand" for="c-39802371">[7 more]</label></div><br/><div class="children"><div class="content">IIRC it was added on Pentium and maybe late 486. You had to do classic tricks to identify the model before that.</div><br/><div id="39802724" class="c"><input type="checkbox" id="c-39802724" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#39802149">root</a><span>|</span><a href="#39802371">parent</a><span>|</span><a href="#39802690">next</a><span>|</span><label class="collapse" for="c-39802724">[-]</label><label class="expand" for="c-39802724">[1 more]</label></div><br/><div class="children"><div class="content">CPUID has been added first in Pentium (66 MHz), in 1993.<p>Nevertheless, there have been some late variants of 486 that have been introduced after the first Pentium, in 1994 or later, and which had CPUID, e.g. the Intel 486DX4 (100 MHz).<p>AMD had 2 generations of 486DX4 (and of 486DX2), the first did not have CPUID (and it had a write-through cache memory), while the second had CPUID (and it had a write-back cache memory).<p>Some Cyrix CPUs with properties intermediate between 486 and Pentium had CPUID, but it was disabled by default and it could be enabled in the BIOS.<p>Measuring the length of the prefetch queue was the standard method to identify 8088 vs. 8086 and this was available in several commercial CPU detection utilities that were available for MS-DOS, e.g. in Norton Utilities or the like.<p>At that time I have discovered this by disassembling such a utility program.</div><br/></div></div><div id="39802690" class="c"><input type="checkbox" id="c-39802690" checked=""/><div class="controls bullet"><span class="by">accrual</span><span>|</span><a href="#39802149">root</a><span>|</span><a href="#39802371">parent</a><span>|</span><a href="#39802724">prev</a><span>|</span><a href="#39802571">next</a><span>|</span><label class="collapse" for="c-39802690">[-]</label><label class="expand" for="c-39802690">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, I have a 486 DX-50 without CPUID, and a 486 DX2-66 with CPUID support. The latter provides much more detail when viewed in CPU-Z.</div><br/></div></div><div id="39802571" class="c"><input type="checkbox" id="c-39802571" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#39802149">root</a><span>|</span><a href="#39802371">parent</a><span>|</span><a href="#39802690">prev</a><span>|</span><a href="#39802074">next</a><span>|</span><label class="collapse" for="c-39802571">[-]</label><label class="expand" for="c-39802571">[4 more]</label></div><br/><div class="children"><div class="content">I beieve in the Pentium, the prefetch queue became snooped, which coincides nicely with the introduction of CPUID.</div><br/><div id="39802792" class="c"><input type="checkbox" id="c-39802792" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#39802149">root</a><span>|</span><a href="#39802571">parent</a><span>|</span><a href="#39802595">next</a><span>|</span><label class="collapse" for="c-39802792">[-]</label><label class="expand" for="c-39802792">[1 more]</label></div><br/><div class="children"><div class="content">In Pentium the cache memory became split into instruction cache and data cache.<p>This has forced the introduction of the snooping workaround, otherwise the stores into the data cache would not have influenced the content of the instruction cache.</div><br/></div></div><div id="39802595" class="c"><input type="checkbox" id="c-39802595" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#39802149">root</a><span>|</span><a href="#39802571">parent</a><span>|</span><a href="#39802792">prev</a><span>|</span><a href="#39802074">next</a><span>|</span><label class="collapse" for="c-39802595">[-]</label><label class="expand" for="c-39802595">[2 more]</label></div><br/><div class="children"><div class="content">it also may have something to do with why CPUID is strongly serializing? that always really confused me..its not like, the CPU type is going to race with a load or a store</div><br/><div id="39802707" class="c"><input type="checkbox" id="c-39802707" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#39802149">root</a><span>|</span><a href="#39802595">parent</a><span>|</span><a href="#39802074">next</a><span>|</span><label class="collapse" for="c-39802707">[-]</label><label class="expand" for="c-39802707">[1 more]</label></div><br/><div class="children"><div class="content">I suspect the serialising is just a side effect of the CPUID instruction being implemented as a massive microcode routine.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39802074" class="c"><input type="checkbox" id="c-39802074" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#39802149">prev</a><span>|</span><a href="#39804210">next</a><span>|</span><label class="collapse" for="c-39802074">[-]</label><label class="expand" for="c-39802074">[6 more]</label></div><br/><div class="children"><div class="content">Author here for your 8086&#x2F;8088 questions...</div><br/><div id="39803816" class="c"><input type="checkbox" id="c-39803816" checked=""/><div class="controls bullet"><span class="by">Tuna-Fish</span><span>|</span><a href="#39802074">parent</a><span>|</span><a href="#39804210">next</a><span>|</span><label class="collapse" for="c-39803816">[-]</label><label class="expand" for="c-39803816">[5 more]</label></div><br/><div class="children"><div class="content">From the blog:<p>&gt; However, the 8-bit bus enabled cheaper computer hardware.<p>I wonder if that can be expanded on. An old (now departed) friend once said to me that this was a mirage, because the only thing that the narrower bus really bought them was that it made the 16kB configuration possible, which no-one actually bought (the minimum for using floppies was 32kB!). He claimed that the narrower bus didn&#x27;t actually make the configurations with more RAM cheaper because it made them require more support chips. Is there any truth to this?</div><br/><div id="39805835" class="c"><input type="checkbox" id="c-39805835" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#39802074">root</a><span>|</span><a href="#39803816">parent</a><span>|</span><a href="#39804334">next</a><span>|</span><label class="collapse" for="c-39805835">[-]</label><label class="expand" for="c-39805835">[1 more]</label></div><br/><div class="children"><div class="content">The cost saving was more a marketing trick.<p>Most of the savings were not from memory but from the reuse of the existing 8-bit peripherals without additional hardware and without software changes.<p>On a 16-bit bus, you could connect an 8-bit peripheral to one of its halves, but then the internal registers that previously were at consecutive addresses now were spread at multiples of 2.<p>When doing only 8-bit transfers, you could rewrite the software drivers to use the modified addresses. However you could not do 16-bit transfers, because the bytes were no longer in the same word. This could be fixed with additional buffers, decoders and registers, to convert 16-bit transfers into pairs of 8-bit transfers on the same bus half (like 8088 did internally), but that would increase the cost.<p>Even if these compatibility problems were not too difficult to solve, most preferred to avoid them, in the quest for minimum cost.</div><br/></div></div><div id="39804334" class="c"><input type="checkbox" id="c-39804334" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#39802074">root</a><span>|</span><a href="#39803816">parent</a><span>|</span><a href="#39805835">prev</a><span>|</span><a href="#39804017">next</a><span>|</span><label class="collapse" for="c-39804334">[-]</label><label class="expand" for="c-39804334">[1 more]</label></div><br/><div class="children"><div class="content">According to Dave Bradley, one of the creators of the IBM PC, &quot;We chose the 8088 [over the 8086] because of its 8-bit data bus. The smaller bus saved money in the areas of RAM, ROM, and logic for the simple system.&quot;<p>Another thing is that even if almost nobody bought the minimal RAM configuration, having a low-cost configuration can be very important from a marketing standpoint. (By the way, it&#x27;s kind of amazing that the base RAM for an IBM PC was just 16 kilobytes, and now 16 gigabytes is a base RAM configuration.)<p><a href="https:&#x2F;&#x2F;www.tech-insider.org&#x2F;personal-computers&#x2F;research&#x2F;1990&#x2F;09.html" rel="nofollow">https:&#x2F;&#x2F;www.tech-insider.org&#x2F;personal-computers&#x2F;research&#x2F;199...</a></div><br/></div></div><div id="39804017" class="c"><input type="checkbox" id="c-39804017" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#39802074">root</a><span>|</span><a href="#39803816">parent</a><span>|</span><a href="#39804334">prev</a><span>|</span><a href="#39804210">next</a><span>|</span><label class="collapse" for="c-39804017">[-]</label><label class="expand" for="c-39804017">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s mentioned at the bottom of this article[0] that Intel had an obsession with using the smallest packaging and pin count possible, while competitors did not see any need to be that conservative. I wonder if that has something to do with it.<p>[0] <a href="https:&#x2F;&#x2F;www.righto.com&#x2F;2023&#x2F;07&#x2F;8086-pins.html" rel="nofollow">https:&#x2F;&#x2F;www.righto.com&#x2F;2023&#x2F;07&#x2F;8086-pins.html</a></div><br/><div id="39804374" class="c"><input type="checkbox" id="c-39804374" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#39802074">root</a><span>|</span><a href="#39804017">parent</a><span>|</span><a href="#39804210">next</a><span>|</span><label class="collapse" for="c-39804374">[-]</label><label class="expand" for="c-39804374">[1 more]</label></div><br/><div class="children"><div class="content">The 8088 and 8086 actually have the same number of pins and almost identical pinouts, despite the the difference in data bus width. This is because the data and address are multiplexed onto the same pins, because of intel&#x27;s obsession with lowest pincount (each pin does add quite a bit of cost to packaging).<p>On the 8086, the bottom 16 address pins (of 20) are multiplexed with data, on the 8088, only the bottom 8 address pins are multiplexed.<p>So you had to demultiplex the bus no matter which chip you chose. I think the cost savings mostly come from being able to configure systems with only 8 DRAM chips per bank (instead of 16 DRAM chips per bank with the 8086). A 16 bit bus also requires that your ROM chips are in pairs, and it probably increases the motherboard routing complexity. And a small bit of extra decoding logic.<p>A 16 bit bus would have also required IBM to skip straight over the 8 bit ISA standard with it&#x27;s smaller sockets and forced up the complexity of all PC expansion cards (which would also require double the ROM chips, double the RAM chips and extra logic)<p>Edit: And now that I think about it, the fact that the upper bit of the address bus aren&#x27;t multiplexed might actually allow you to simplify the DRAM row&#x2F;column addressing logic... But only if you put the column into the upper bits of the address.</div><br/></div></div></div></div></div></div></div></div><div id="39804210" class="c"><input type="checkbox" id="c-39804210" checked=""/><div class="controls bullet"><span class="by">kinj28</span><span>|</span><a href="#39802074">prev</a><span>|</span><label class="collapse" for="c-39804210">[-]</label><label class="expand" for="c-39804210">[2 more]</label></div><br/><div class="children"><div class="content">I wonder if queue length is already maintained by queue counter then is there really a need for MT flag?<p>Let’s say even if it is possible to do it, would the resulting saving of real estate and power would be worth the effort?</div><br/><div id="39804278" class="c"><input type="checkbox" id="c-39804278" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#39804210">parent</a><span>|</span><label class="collapse" for="c-39804278">[-]</label><label class="expand" for="c-39804278">[1 more]</label></div><br/><div class="children"><div class="content">Two reasons:<p>1. The queue is 4 bytes long, which fits neatly in a two bit counter. You would have to switch to a three bit counter to store the 5th state, which increases the area and power usage by ~50%<p>2. The MT signal is explictly needed to stall the execution unit when the prefetch queue is empty. If you replaced the flag register with a 5th state of the queue counter, then you would still need combination logic to generate the MT signal (queue[0] != 1 || queue[1] != 1 || queue[2] != 1)<p>I&#x27;m guessing this two bit counter + MT flag scheme is actually optimal from a transistor count perspective.</div><br/></div></div></div></div></div></div></div></div></div></body></html>