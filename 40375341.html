<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715850055887" as="style"/><link rel="stylesheet" href="styles.css?v=1715850055887"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://graydon2.dreamwidth.org/312681.html">Some notes on Rust, mutable aliasing and formal verification</a> <span class="domain">(<a href="https://graydon2.dreamwidth.org">graydon2.dreamwidth.org</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>12 comments</span></div><br/><div><div id="40376035" class="c"><input type="checkbox" id="c-40376035" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40376058">next</a><span>|</span><label class="collapse" for="c-40376035">[-]</label><label class="expand" for="c-40376035">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a good article.<p>Having worked on program verification in the past, Rust looks like the most useful modern language to which formal methods can be applied. Rust&#x27;s rules eliminate so many of the cases that are hard to formalize.<p>Big remaining problems involve deadlock analysis, both in the thread sense and in the Rc&#x2F;borrow sense. Those are somewhat equivalent. I&#x27;d like to have static deadlock analysis in Rust. If you had that, I think you could get safe back-pointers, too. If you can prove that all borrow and upgrade calls can&#x27;t fail, you can eliminate most reference counts. That gives you free interior mutability when that&#x27;s possible.<p>The author&#x27;s comment on provers is interesting. The big problem with theorem provers is that they&#x27;re developed by people who like to prove theorems. They&#x27;re in love with the formalism. This leads to a UI disconnect with programmers.<p>You can knock off most things you have to prove with a SAT solver. But you&#x27;ll need something heavier for the hard problems. Coq is too manual. The author thinks ACL2 is too functional. Not sure what to do there, but I&#x27;ve been out of this for decades.<p>Machine learning may help in guiding theorem provers. Most programs aren&#x27;t that original in terms of control flow and data usage. So inferring a proof plan from other code may work.
ML systems can&#x27;t be trusted to <i>do</i> the proof, but may take over guiding the process.</div><br/><div id="40376282" class="c"><input type="checkbox" id="c-40376282" checked=""/><div class="controls bullet"><span class="by">xavxav</span><span>|</span><a href="#40376035">parent</a><span>|</span><a href="#40376071">next</a><span>|</span><label class="collapse" for="c-40376282">[-]</label><label class="expand" for="c-40376282">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can knock off most things you have to prove with a SAT solver. But you&#x27;ll need something heavier for the hard problems. Coq is too manual. The author thinks ACL2 is too functional. Not sure what to do there, but I&#x27;ve been out of this for decades.<p>Agreed, though I think Lean is making big progress in the UX front of ITP verification through its extensive meta-programming facilities.<p>My issue with these tools applied to verifying external languages like Rust, is that the proof is not written in the target language, forcing your developers to learn two languages.<p>I have recently been thinking about what a &quot;verification aware Rust&quot; would look like, colored by my experience writing Creusot, the work on Verus and Aeneas and my time in the lab developing Why3. I think building such a language from the ground up could provide a step change in ease of verification even from Rust, particularly with regard to those &quot;hard parts&quot; of the proof.</div><br/></div></div><div id="40376071" class="c"><input type="checkbox" id="c-40376071" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#40376035">parent</a><span>|</span><a href="#40376282">prev</a><span>|</span><a href="#40376058">next</a><span>|</span><label class="collapse" for="c-40376071">[-]</label><label class="expand" for="c-40376071">[2 more]</label></div><br/><div class="children"><div class="content">I think that Coq&#x2F;Agda&#x2F;Lean and friends are really going to be the winners in the proof space. Interactivity is a pretty good model for the feedback loop, and they&#x27;re systems that exist and work, without a lost of asterisks.<p>The biggest thing I think these tools are missing out of the box is, basically, &quot;run quickcheck on my proof for me&quot;. It&#x27;s too easy to have some code, and try to prove some property that isn&#x27;t true, and rip your hair out thinking &quot;why can&#x27;t I get the proof working!&quot;<p>If halfway through your proof you end up in a thing that seems nonsensical, it would be nice for these tools to just have a &quot;try to generate a counter-example from here&quot; command that spits out a thing.<p>Proofs are so path-dependent, and it&#x27;s not trivial to do in general. But I think they are all very close to greatness, and every time I&#x27;ve gone through the effort to formally verify a thing, it&#x27;s been pretty illuminating. Just... if you&#x27;re trying to prove some code, the process should take into account the idea that your code might be buggy.</div><br/><div id="40376234" class="c"><input type="checkbox" id="c-40376234" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40376035">root</a><span>|</span><a href="#40376071">parent</a><span>|</span><a href="#40376058">next</a><span>|</span><label class="collapse" for="c-40376234">[-]</label><label class="expand" for="c-40376234">[1 more]</label></div><br/><div class="children"><div class="content">I also quite like Idris, the problem with these languages is that they require being a Mage level 10, while most folks are still getting around magic exists.</div><br/></div></div></div></div></div></div><div id="40376058" class="c"><input type="checkbox" id="c-40376058" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#40376035">prev</a><span>|</span><a href="#40376376">next</a><span>|</span><label class="collapse" for="c-40376058">[-]</label><label class="expand" for="c-40376058">[3 more]</label></div><br/><div class="children"><div class="content">I really like that we are now two posts deep from a quote from a ~1973 paper by Hoare. I posted a really long comment in the original boat’s article’s HN thread pointing out that skewing the quote towards a Rust-centric view (while understandable given boat’s history with the language) was an artificial narrowing of the scope of Hoare’s critique. Now Grayson has taken that narrow slice and used it as jumping off point to discuss a few interesting areas&#x2F;design-points of Rust. While I still think my comment was correct, the ensuing discussion by Grayson in this blog were more than sufficient to overcome any technical gripes with the inciting article.</div><br/><div id="40376066" class="c"><input type="checkbox" id="c-40376066" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#40376058">parent</a><span>|</span><a href="#40376376">next</a><span>|</span><label class="collapse" for="c-40376066">[-]</label><label class="expand" for="c-40376066">[2 more]</label></div><br/><div class="children"><div class="content">My original comment about boat’s post citing the Hoare paper:<p>After the opening quote by Hoare and a quick intro paragraph, the author says &#x27;What Tony Hoare was writing about when he said that references are like jumps was the problem of mutable, aliased state.&#x27; withoutboats is a well known Rust developer, so I guess this assumption about Hoare&#x27;s quote should not be a surprise.
However, I don&#x27;t see the text of the quote as reinforcing that perspective. I can see an argument for the article&#x27;s extrapolation, taking Hoare&#x27;s seemingly more general lamentations about the semantic existence of references (a semantic group containing at least &#x27;reference, pointer, or indirect address into the languageas an assignable item of data&#x27;) and then applying to the Rust model of non-aliased, mutable state as an attempt to circumvent the problems Hoare is addressing. But this argument is an attempt at taking a narrowly scoped perspective on a problem, correcting that small slice of the greater problem, and then announcing the entirety of the problem no longer exists. Like I said, understandable why the article would take this direction, I just don&#x27;t think it truly addresses the totality of Hoare&#x27;s critique of references as an undesirable semantic abstraction.
The title of the section withoutboats has quoted and the first sentence are unfortunately left out of his selection:
&quot;8. Variables One of the most powerful and most dangerous aspects of machine code programming is that each individual instruction of the code can change the content of any register, any location of store, and alter the condition of any peripheral: it can even change its neighboring instructions or itself. Worse still, the identity of the location changed is not always apparent from the written form of the instruction; it cannot be determined until run time, when the values of base registers, index registers, and indirect addresses are known.&quot; [This paragraph is essentially acknowledging that low-level machine code gains its computational power from unlimited ability to alter the state of computation]
Also, the ... following the quote&#x27;s second paragraph omits the following: &quot;For example, in ALGOL 68, the assignment x : = y; always changes x , but the assignment x: = y+l; if x is a reference variable may change any other variable (of appropriate type) in the whole machine. One variable it can never change is x!&quot; [This quote, which was removed, makes it explicit that Hoare is addressing the mere existence of references]
Both of the omitted sections tend very strongly toward Hoare&#x27;s actual critiques being the semantic concept of references in high level languages being problematic, not merely mutable state. There is some natural extension of Hoare&#x27;s discussion of references as means of assignment, which does lead to the &#x27;spooky action&#x27; occurances. However, following this section of Hints on Programming Language Design, Hoare talks for a bit about structured programming, scope, and parameter importance. Discussing that without references, programmers have disjoint names for semantic objects and those are only altered&#x2F;mutated by passing the sole existing object to a procedure as a parameter and having it passed back.
Overall, the TL;DR may be negatively stated as Rust developer gonna view things through a Rust-y lense. However, I think that is an incorrect reading. withoutboats skipped a crucial step in his going from Hoare&#x27;s critique of referencs, they went directly from the text to an interpretation of the critique focused on aliased, mutable state. There is some discussion to be had about Hoare&#x27;s assumptions of a single semantic object existing in a one-to-one correspondence with a disjoint source code name, especially in the context of multi-processor and networked programming prevalent in 2024. While I think that a more general solution to Hoare&#x27;s problem exists and acknowledge Rust&#x27;s attempts to at least tame a portion of the problem, I don&#x27;t think any language has &#x27;fixed&#x27; this issue.</div><br/><div id="40376262" class="c"><input type="checkbox" id="c-40376262" checked=""/><div class="controls bullet"><span class="by">the_mitsuhiko</span><span>|</span><a href="#40376058">root</a><span>|</span><a href="#40376066">parent</a><span>|</span><a href="#40376376">next</a><span>|</span><label class="collapse" for="c-40376262">[-]</label><label class="expand" for="c-40376262">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Both of the omitted sections tend very strongly toward Hoare&#x27;s actual critiques being the semantic concept of references in high level languages being problematic, not merely mutable state.<p>Both sections however talk about mutations. Immutable references are not any different from inputs into a function.</div><br/></div></div></div></div></div></div><div id="40376376" class="c"><input type="checkbox" id="c-40376376" checked=""/><div class="controls bullet"><span class="by">shivanshu120</span><span>|</span><a href="#40376058">prev</a><span>|</span><a href="#40375996">next</a><span>|</span><label class="collapse" for="c-40376376">[-]</label><label class="expand" for="c-40376376">[1 more]</label></div><br/><div class="children"><div class="content">This is very good article for rust</div><br/></div></div><div id="40375996" class="c"><input type="checkbox" id="c-40375996" checked=""/><div class="controls bullet"><span class="by">Jaxan</span><span>|</span><a href="#40376376">prev</a><span>|</span><a href="#40376306">next</a><span>|</span><label class="collapse" for="c-40375996">[-]</label><label class="expand" for="c-40375996">[1 more]</label></div><br/><div class="children"><div class="content">I read the linked article by Boats and found it great. I was really amazed by the 50-years old quote by Hoare, it’s still relevant and very well put.</div><br/></div></div><div id="40376306" class="c"><input type="checkbox" id="c-40376306" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#40375996">prev</a><span>|</span><label class="collapse" for="c-40376306">[-]</label><label class="expand" for="c-40376306">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The typical Rust program has either no refcells, or a very small number, just as it has either no unsafe code or a very small amount<p>Really?  How are we quantifying this?</div><br/><div id="40376368" class="c"><input type="checkbox" id="c-40376368" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#40376306">parent</a><span>|</span><label class="collapse" for="c-40376368">[-]</label><label class="expand" for="c-40376368">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think anyone has actual measurements on this, but at the same time anyone who&#x27;s written and read a significant amount of Rust[1] can tell you that <i>unsafe</i> and <i>RefCell</i> aren&#x27;t something you encounter every day (or even every year when it comes to <i>RefCell</i>).<p>[1] for my part I&#x27;ve been doing it full time for the past 7 years, and also teach Rust at university.</div><br/></div></div></div></div></div></div></div></div></div></body></html>