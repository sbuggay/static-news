<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724749263960" as="style"/><link rel="stylesheet" href="styles.css?v=1724749263960"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://transactional.blog/blog/2024-erasure-coding">Erasure Coding for Distributed Systems</a> <span class="domain">(<a href="https://transactional.blog">transactional.blog</a>)</span></div><div class="subtext"><span>eatonphil</span> | <span>44 comments</span></div><br/><div><div id="41364462" class="c"><input type="checkbox" id="c-41364462" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#41363134">next</a><span>|</span><label class="collapse" for="c-41364462">[-]</label><label class="expand" for="c-41364462">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised rateless fountain codes aren&#x27;t mentioned! If you enjoy this sort of thing, you&#x27;ll find the Luby Transform Code fascinating: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Luby_transform_code" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Luby_transform_code</a><p>This paper is a really nice overview with more detail: <a href="https:&#x2F;&#x2F;switzernet.com&#x2F;people&#x2F;emin-gabrielyan&#x2F;060112-capillary-references&#x2F;ref&#x2F;MacKay05.pdf" rel="nofollow">https:&#x2F;&#x2F;switzernet.com&#x2F;people&#x2F;emin-gabrielyan&#x2F;060112-capilla...</a><p>LT codes are used as the &quot;outer code&quot; in the linear time RaptorQ encoding specified in RFC6330: <a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc6330" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc6330</a></div><br/><div id="41365185" class="c"><input type="checkbox" id="c-41365185" checked=""/><div class="controls bullet"><span class="by">Luker88</span><span>|</span><a href="#41364462">parent</a><span>|</span><a href="#41365232">next</a><span>|</span><label class="collapse" for="c-41365185">[-]</label><label class="expand" for="c-41365185">[1 more]</label></div><br/><div class="children"><div class="content">I have implemented RaptorQ and RFC6330.<p>First, the rfc is pointlessly complex and optimized for files, not for streaming. if you want to play with it, manage blocks by yourself, ignore the asinine interleaving and block size management.<p>Second, the algorithm is actually split in two parts, and while the second (generation of repair blocks) is linear, the first is cubic on the number of messages that you put together in a block (~~ matrix gaussian elimination).<p>And while parts of both encoding and decoding can be cached, I think that &quot;linear time&quot; encoding for raptorq is actually just false marketing speak.</div><br/></div></div><div id="41365232" class="c"><input type="checkbox" id="c-41365232" checked=""/><div class="controls bullet"><span class="by">jumperabg</span><span>|</span><a href="#41364462">parent</a><span>|</span><a href="#41365185">prev</a><span>|</span><a href="#41364473">next</a><span>|</span><label class="collapse" for="c-41365232">[-]</label><label class="expand" for="c-41365232">[1 more]</label></div><br/><div class="children"><div class="content">Are rateless fountain codes the better solution and if are there any systems that are using them?</div><br/></div></div><div id="41364473" class="c"><input type="checkbox" id="c-41364473" checked=""/><div class="controls bullet"><span class="by">AYBABTME</span><span>|</span><a href="#41364462">parent</a><span>|</span><a href="#41365232">prev</a><span>|</span><a href="#41363134">next</a><span>|</span><label class="collapse" for="c-41364473">[-]</label><label class="expand" for="c-41364473">[2 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t there patent problems with fountain codes?</div><br/><div id="41364487" class="c"><input type="checkbox" id="c-41364487" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#41364462">root</a><span>|</span><a href="#41364473">parent</a><span>|</span><a href="#41363134">next</a><span>|</span><label class="collapse" for="c-41364487">[-]</label><label class="expand" for="c-41364487">[1 more]</label></div><br/><div class="children"><div class="content">Luby&#x27;s original paper was published in 2002. Not sure about RaptorQ though...</div><br/></div></div></div></div></div></div><div id="41363134" class="c"><input type="checkbox" id="c-41363134" checked=""/><div class="controls bullet"><span class="by">otterley</span><span>|</span><a href="#41364462">prev</a><span>|</span><a href="#41362876">next</a><span>|</span><label class="collapse" for="c-41363134">[-]</label><label class="expand" for="c-41363134">[11 more]</label></div><br/><div class="children"><div class="content">Erasure coding has been around for a very long time. Remember PAR2 files on Usenet? <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Parchive" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Parchive</a></div><br/><div id="41365009" class="c"><input type="checkbox" id="c-41365009" checked=""/><div class="controls bullet"><span class="by">masspro</span><span>|</span><a href="#41363134">parent</a><span>|</span><a href="#41363154">next</a><span>|</span><label class="collapse" for="c-41365009">[-]</label><label class="expand" for="c-41365009">[2 more]</label></div><br/><div class="children"><div class="content">I was unpleasantly surprised by but thankful to have found eclecticlight.co’s findings about PAR2. When I learned about PAR2 I immediately wanted to make par files for everything because bit rot scares me. But, from <a href="https:&#x2F;&#x2F;eclecticlight.co&#x2F;2020&#x2F;04&#x2F;20&#x2F;file-integrity-5-how-well-does-error-correcting-code-work&#x2F;" rel="nofollow">https:&#x2F;&#x2F;eclecticlight.co&#x2F;2020&#x2F;04&#x2F;20&#x2F;file-integrity-5-how-wel...</a> :<p>&gt; This has serious implications for the use of Par2 with files much larger than 20 MB, and probably rules it out as a method of ECC for those larger than 1 GB.<p>I assumed 10% PAR file size == resistance to 10% of the input file being corrupted, but that’s not how it works. The article shows some nonlinear and non-obvious relationships between input file size, par file size, and maximum number of recoverable errors.</div><br/><div id="41365475" class="c"><input type="checkbox" id="c-41365475" checked=""/><div class="controls bullet"><span class="by">hcs</span><span>|</span><a href="#41363134">root</a><span>|</span><a href="#41365009">parent</a><span>|</span><a href="#41363154">next</a><span>|</span><label class="collapse" for="c-41365475">[-]</label><label class="expand" for="c-41365475">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s my understanding that par2 is designed for missing files (parts of a multi part archive), not the uniform random bit rot corruption used in that article. I think it can recover a much larger corrupted or missing block, approaching the size of the parity files.<p>But yeah if that&#x27;s your data loss model then par2 isn&#x27;t the right approach. (Not sure what is.)</div><br/></div></div></div></div><div id="41363154" class="c"><input type="checkbox" id="c-41363154" checked=""/><div class="controls bullet"><span class="by">jeremycarter</span><span>|</span><a href="#41363134">parent</a><span>|</span><a href="#41365009">prev</a><span>|</span><a href="#41364409">next</a><span>|</span><label class="collapse" for="c-41363154">[-]</label><label class="expand" for="c-41363154">[7 more]</label></div><br/><div class="children"><div class="content">When I was younger, I literally thought PAR&#x27;s were magic files. I had no idea how they worked, and from a distance it was magic.</div><br/><div id="41363518" class="c"><input type="checkbox" id="c-41363518" checked=""/><div class="controls bullet"><span class="by">cdumler</span><span>|</span><a href="#41363134">root</a><span>|</span><a href="#41363154">parent</a><span>|</span><a href="#41364146">next</a><span>|</span><label class="collapse" for="c-41363518">[-]</label><label class="expand" for="c-41363518">[2 more]</label></div><br/><div class="children"><div class="content"><i>&quot;Any sufficiently advanced technology is indistinguishable from magic.&quot; -- Arthur C. Clarke</i><p>I thought the same thing when using PAR files.  They&#x27;re still useful today if you save things on media that can be damaged (CD, DVD, Blue-Ray) or across multiple multiple media.<p>Eventually, I decided to dig into the math behind it. It is a surprisingly simple principle:<p><i>Given polynomial of a degree X and an array of data points of size X, there is one and only one solution to the polynomial&#x27;s coefficients such that it will pass through those data points.</i><p>So, stripe the data into bands of arrays, compute the polynomial, and compute additional data points of the curve, and save it with the original data.  If you have at least the array&#x27;s size of data points ( original array and&#x2F;or parity values) and know the place in the list for each data point (thus which data is missing), there is one and only one solution to the polynomial equation.  Once you solve the polynomial again, you can compute any point, including the missing ones.  Again, because there is one and only one solution for the curve.<p>The devil is the math necessary solve the polynomials, which is why it is so computationally intensive.</div><br/><div id="41364700" class="c"><input type="checkbox" id="c-41364700" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#41363134">root</a><span>|</span><a href="#41363518">parent</a><span>|</span><a href="#41364146">next</a><span>|</span><label class="collapse" for="c-41364700">[-]</label><label class="expand" for="c-41364700">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>&quot;Any sufficiently advanced technology is indistinguishable from magic.&quot; -- Arthur C. Clarke</i><p><i>&quot;If anything seems like magic you&#x27;re not asking enough questions.&quot;</i> -- Mario Romero Vega</div><br/></div></div></div></div><div id="41364146" class="c"><input type="checkbox" id="c-41364146" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#41363134">root</a><span>|</span><a href="#41363154">parent</a><span>|</span><a href="#41363518">prev</a><span>|</span><a href="#41364409">next</a><span>|</span><label class="collapse" for="c-41364146">[-]</label><label class="expand" for="c-41364146">[4 more]</label></div><br/><div class="children"><div class="content">PAR files use ReedSolomon error correction which IMO might as well be magic.<p>Galois Fields are really awesome (and are related to CRC codes). The level of effort to learn is quite high. NASAs guide to ReedSolomon was amazing though<p>-----------<p>XOR codes are easier and sloppier. But are actually what&#x27;s used today despite being imperfect.<p>Let&#x27;s say you have A, B, C... Z as your data.<p>Parity#1 could be XOR(A, B, Z). If B were missing, Parity#1 XOR A XOR Z can back-calculate B.<p>Parity#2 can be a random set of all previous entries (including Parity#1). Etc. etc. etc.<p>Keep adding XOR parity codes until your probability of reconstruction is high enough to please you.<p>I believe this concept is called a Fountain Code.</div><br/><div id="41364661" class="c"><input type="checkbox" id="c-41364661" checked=""/><div class="controls bullet"><span class="by">exikyut</span><span>|</span><a href="#41363134">root</a><span>|</span><a href="#41364146">parent</a><span>|</span><a href="#41364422">next</a><span>|</span><label class="collapse" for="c-41364661">[-]</label><label class="expand" for="c-41364661">[1 more]</label></div><br/><div class="children"><div class="content">Is that introduction <a href="https:&#x2F;&#x2F;ntrs.nasa.gov&#x2F;citations&#x2F;19900019023" rel="nofollow">https:&#x2F;&#x2F;ntrs.nasa.gov&#x2F;citations&#x2F;19900019023</a> -&gt; <a href="https:&#x2F;&#x2F;ntrs.nasa.gov&#x2F;api&#x2F;citations&#x2F;19900019023&#x2F;downloads&#x2F;19900019023.pdf" rel="nofollow">https:&#x2F;&#x2F;ntrs.nasa.gov&#x2F;api&#x2F;citations&#x2F;19900019023&#x2F;downloads&#x2F;19...</a> [PDF]?</div><br/></div></div><div id="41364422" class="c"><input type="checkbox" id="c-41364422" checked=""/><div class="controls bullet"><span class="by">halfcat</span><span>|</span><a href="#41363134">root</a><span>|</span><a href="#41364146">parent</a><span>|</span><a href="#41364661">prev</a><span>|</span><a href="#41364409">next</a><span>|</span><label class="collapse" for="c-41364422">[-]</label><label class="expand" for="c-41364422">[2 more]</label></div><br/><div class="children"><div class="content">Also I’ve found that while most people (non-tech) don’t have a concept of XOR, they probably took basic algebra and understand 1+?=3<p>Arithmetic wouldn’t be a good implementation due to integer overflow (a problem XOR doesn’t have) but it’s helpful if you ever have to explain it to the less technical business person who you need to sign off on the purchasing decision.</div><br/><div id="41364708" class="c"><input type="checkbox" id="c-41364708" checked=""/><div class="controls bullet"><span class="by">genewitch</span><span>|</span><a href="#41363134">root</a><span>|</span><a href="#41364422">parent</a><span>|</span><a href="#41364409">next</a><span>|</span><label class="collapse" for="c-41364708">[-]</label><label class="expand" for="c-41364708">[1 more]</label></div><br/><div class="children"><div class="content">that&#x27;s how i used to explain what a nonce was to explain what all the computers were doing to &quot;mine&quot; bitcoin. and then explain &quot;they&#x27;re instead trying to get a number that has a certain number of zeros in a specific place&quot;</div><br/></div></div></div></div></div></div></div></div><div id="41364409" class="c"><input type="checkbox" id="c-41364409" checked=""/><div class="controls bullet"><span class="by">halfcat</span><span>|</span><a href="#41363134">parent</a><span>|</span><a href="#41363154">prev</a><span>|</span><a href="#41362876">next</a><span>|</span><label class="collapse" for="c-41364409">[-]</label><label class="expand" for="c-41364409">[1 more]</label></div><br/><div class="children"><div class="content">Yes, also RAID5 has been in use at least since the 1980’s</div><br/></div></div></div></div><div id="41362876" class="c"><input type="checkbox" id="c-41362876" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41363134">prev</a><span>|</span><a href="#41364205">next</a><span>|</span><label class="collapse" for="c-41362876">[-]</label><label class="expand" for="c-41362876">[9 more]</label></div><br/><div class="children"><div class="content">Years back someone proposed a cute algorithm for erasure codes that depended not on spinning rust but on multipath networking.<p>I believe they called it network coding and the idea was in a network with multiple routes I might get a file faster by pulling an erasure code that used two parts of the file or even two files from one upstream instead of waiting for the entire file from the primary server.</div><br/><div id="41363714" class="c"><input type="checkbox" id="c-41363714" checked=""/><div class="controls bullet"><span class="by">epistasis</span><span>|</span><a href="#41362876">parent</a><span>|</span><a href="#41363536">next</a><span>|</span><label class="collapse" for="c-41363714">[-]</label><label class="expand" for="c-41363714">[2 more]</label></div><br/><div class="children"><div class="content">This has been used in Ceph for a long time:<p><a href="https:&#x2F;&#x2F;docs.ceph.com&#x2F;en&#x2F;latest&#x2F;rados&#x2F;operations&#x2F;erasure-code&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.ceph.com&#x2F;en&#x2F;latest&#x2F;rados&#x2F;operations&#x2F;erasure-cod...</a><p>I would not be surprised if there was a lot of stuff like this behind S3 and other cloud storage systems too, at least in the lower-access tiers of storage, but I have no actual knowledge of AWS or GCP systems.</div><br/><div id="41364523" class="c"><input type="checkbox" id="c-41364523" checked=""/><div class="controls bullet"><span class="by">preisschild</span><span>|</span><a href="#41362876">root</a><span>|</span><a href="#41363714">parent</a><span>|</span><a href="#41363536">next</a><span>|</span><label class="collapse" for="c-41364523">[-]</label><label class="expand" for="c-41364523">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I use it in my homelab and it is really awesome to have &quot;RAID(5&#x2F;6)&quot; basically work over the network.</div><br/></div></div></div></div><div id="41363536" class="c"><input type="checkbox" id="c-41363536" checked=""/><div class="controls bullet"><span class="by">sva_</span><span>|</span><a href="#41362876">parent</a><span>|</span><a href="#41363714">prev</a><span>|</span><a href="#41363339">next</a><span>|</span><label class="collapse" for="c-41363536">[-]</label><label class="expand" for="c-41363536">[3 more]</label></div><br/><div class="children"><div class="content">I thought about something like that to make video calls more stable. For example I&#x27;ll get completely different routes (sometimes noticeably lower&#x2F;more predictable latency) when I use a VPN to connect to some peer in the US (from Europe.) Would be cool to combine different routes.</div><br/><div id="41364022" class="c"><input type="checkbox" id="c-41364022" checked=""/><div class="controls bullet"><span class="by">supertrope</span><span>|</span><a href="#41362876">root</a><span>|</span><a href="#41363536">parent</a><span>|</span><a href="#41363339">next</a><span>|</span><label class="collapse" for="c-41364022">[-]</label><label class="expand" for="c-41364022">[2 more]</label></div><br/><div class="children"><div class="content">It’s called SD-WAN</div><br/><div id="41364801" class="c"><input type="checkbox" id="c-41364801" checked=""/><div class="controls bullet"><span class="by">kayg04</span><span>|</span><a href="#41362876">root</a><span>|</span><a href="#41364022">parent</a><span>|</span><a href="#41363339">next</a><span>|</span><label class="collapse" for="c-41364801">[-]</label><label class="expand" for="c-41364801">[1 more]</label></div><br/><div class="children"><div class="content">can you explain? I tried looking it up but I didn&#x27;t quite understand how it is called SD-WAN.</div><br/></div></div></div></div></div></div><div id="41363339" class="c"><input type="checkbox" id="c-41363339" checked=""/><div class="controls bullet"><span class="by">phonon</span><span>|</span><a href="#41362876">parent</a><span>|</span><a href="#41363536">prev</a><span>|</span><a href="#41363214">next</a><span>|</span><label class="collapse" for="c-41363339">[-]</label><label class="expand" for="c-41363339">[1 more]</label></div><br/><div class="children"><div class="content">With something like <a href="https:&#x2F;&#x2F;github.com&#x2F;cberner&#x2F;raptorq">https:&#x2F;&#x2F;github.com&#x2F;cberner&#x2F;raptorq</a> you can do several gbits&#x2F;s over high latency&#x2F;lossy UDP.</div><br/></div></div><div id="41363214" class="c"><input type="checkbox" id="c-41363214" checked=""/><div class="controls bullet"><span class="by">nullc</span><span>|</span><a href="#41362876">parent</a><span>|</span><a href="#41363339">prev</a><span>|</span><a href="#41364205">next</a><span>|</span><label class="collapse" for="c-41363214">[-]</label><label class="expand" for="c-41363214">[2 more]</label></div><br/><div class="children"><div class="content">Network coding is more than that, participants in the graph can synthesize new parts on the fly from parts they just got without having the whole thing.<p>FWIW, freenet at least uses fec-coded files so that you can have some flexibility in what parts you get and durability against a file becoming broken just because a single part gets lost.</div><br/><div id="41363554" class="c"><input type="checkbox" id="c-41363554" checked=""/><div class="controls bullet"><span class="by">StillBored</span><span>|</span><a href="#41362876">root</a><span>|</span><a href="#41363214">parent</a><span>|</span><a href="#41364205">next</a><span>|</span><label class="collapse" for="c-41363554">[-]</label><label class="expand" for="c-41363554">[1 more]</label></div><br/><div class="children"><div class="content">and usenet binaries with <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Parchive" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Parchive</a> and even earlier with RAR&#x27;s recovery block, and probably even earlier with BBSes, but my memory is failing me what I was using before it in the 1990s.<p>edit: I see immediately below while I was composing this, someone mentioned pararchive..</div><br/></div></div></div></div></div></div><div id="41364205" class="c"><input type="checkbox" id="c-41364205" checked=""/><div class="controls bullet"><span class="by">donavanm</span><span>|</span><a href="#41362876">prev</a><span>|</span><a href="#41365225">next</a><span>|</span><label class="collapse" for="c-41364205">[-]</label><label class="expand" for="c-41364205">[2 more]</label></div><br/><div class="children"><div class="content">If youre interested in EC you might want to consider larger multi dimensional cases. Think of encoding not just across spindles, but another failure domain like rack, room, DC, or region. The goal being to tolerate common component failures, and larger system failures (or partitions) as well. A nice intro <a href="https:&#x2F;&#x2F;chameleoncloud.org&#x2F;blog&#x2F;2023&#x2F;12&#x2F;12&#x2F;design-considerations-and-analysis-of-multi-level-erasure-coding-in-large-scale-data-centers&#x2F;" rel="nofollow">https:&#x2F;&#x2F;chameleoncloud.org&#x2F;blog&#x2F;2023&#x2F;12&#x2F;12&#x2F;design-considerat...</a></div><br/><div id="41364923" class="c"><input type="checkbox" id="c-41364923" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#41364205">parent</a><span>|</span><a href="#41365225">next</a><span>|</span><label class="collapse" for="c-41364923">[-]</label><label class="expand" for="c-41364923">[1 more]</label></div><br/><div class="children"><div class="content">You also need to take into account other constraints, like recovery time.   If one of your companies datacenters gets destroyed, then it&#x27;s great to be able to recover from the other 6 using clever erasure codes, but if that recovery requires reading every byte of data in every other DC and sending it over the network, it&#x27;s gonna take 6 months+ to transfer all that data over a cross ocean fiber which might only be 1 Tbps.</div><br/></div></div></div></div><div id="41365225" class="c"><input type="checkbox" id="c-41365225" checked=""/><div class="controls bullet"><span class="by">akww</span><span>|</span><a href="#41364205">prev</a><span>|</span><a href="#41362971">next</a><span>|</span><label class="collapse" for="c-41365225">[-]</label><label class="expand" for="c-41365225">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me also of Rabin’s Information Dispersal Algorithm, described in a paper here:<p><a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;62044.62050" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;62044.62050</a></div><br/></div></div><div id="41362971" class="c"><input type="checkbox" id="c-41362971" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#41365225">prev</a><span>|</span><a href="#41364240">next</a><span>|</span><label class="collapse" for="c-41362971">[-]</label><label class="expand" for="c-41362971">[2 more]</label></div><br/><div class="children"><div class="content">Has anybody used Wirehair in a project? <a href="https:&#x2F;&#x2F;github.com&#x2F;catid&#x2F;wirehair">https:&#x2F;&#x2F;github.com&#x2F;catid&#x2F;wirehair</a><p>I&#x27;m curious if it&#x27;s well-defined enough to base a standard around--informally if not formally--for building a large file archiving&#x2F;data recovery project I&#x27;ve been mulling over for nearly 10 years. It&#x27;s the only large block erasure code I&#x27;ve found that has both the ideal (or nearly ideal) algorithmic performance <i>and</i> API. That makes it a nice blackbox for my use case, unlike something like RaptorQ, which leaks little details all over the place, driving up the complexity and rigidness of the rest of the stack. But Wirehair isn&#x27;t a spec, it&#x27;s an (experimental?) implementation of an idea. It seems stable, but unless&#x2F;until I try writing a second implementation, or it&#x27;s seen substantial use (exposing any sharp edges in the algorithm) I worry how easily it would translate to a reliable specification or second implementation.</div><br/><div id="41363192" class="c"><input type="checkbox" id="c-41363192" checked=""/><div class="controls bullet"><span class="by">nullc</span><span>|</span><a href="#41362971">parent</a><span>|</span><a href="#41364240">next</a><span>|</span><label class="collapse" for="c-41363192">[-]</label><label class="expand" for="c-41363192">[1 more]</label></div><br/><div class="children"><div class="content">We previously used it in Bitcoin Fibre (a fork of the Bitcoin node software with special enhancements for block relay).   It&#x27;s extremely nice.<p>Be aware that Qualcomm might claim that its covered by RaptorQ patents (it is conceptually related), though the earliest of those are about to expire (or just expired, haven&#x27;t checked the file wrapper lately) and QC has made some commitment to not apply the RaptorQ patents outside of wireless (but that might be only for conforming implementations, I don&#x27;t recall).<p>I&#x27;ve looked at what it would take to specify it-- which would be something that we&#x27;d want to do if using it in the bitcoin protocol proper and wasn&#x27;t super excited about doing it-- even though myself and several other bitcoin developers are quite comfortable with number theory and error correcting codes.  It&#x27;s just that wirehairs structure has a fair amount of adhoc-ish details and knowing us we might get sucked into a trap of improving it. :)<p>There might be some renewed interest in bitcoin land at getting a fountain code into wide use, if so waiting a while might result in someone else writing a spec.<p>Depending on your exact application you might find <a href="https:&#x2F;&#x2F;github.com&#x2F;catid&#x2F;fecal">https:&#x2F;&#x2F;github.com&#x2F;catid&#x2F;fecal</a> interesting too... if your expected erasures count is very low it could be faster than wirehair.<p>Leopard is mentioned in the article-- it&#x27;s not a fountain code but it has a pretty big block size.  It has a nice advantage for specification: it&#x27;s merely a very fast implementation of a boring RS code (so a spec would arguably only need to document the field and generator choice).</div><br/></div></div></div></div><div id="41364240" class="c"><input type="checkbox" id="c-41364240" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#41362971">prev</a><span>|</span><a href="#41363448">next</a><span>|</span><label class="collapse" for="c-41364240">[-]</label><label class="expand" for="c-41364240">[3 more]</label></div><br/><div class="children"><div class="content">Yep, this is the key tech behind Ceph&#x27;s Erasure Code pool: <a href="https:&#x2F;&#x2F;docs.ceph.com&#x2F;en&#x2F;latest&#x2F;rados&#x2F;operations&#x2F;erasure-code&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.ceph.com&#x2F;en&#x2F;latest&#x2F;rados&#x2F;operations&#x2F;erasure-cod...</a><p>This does not come without trade-offs though, you cannot update the coding parameters (k, m) afterwards, so you either have to be very sure that those parameters are going to work in a long time, or you have to start from scratch. This inelasticity is also the reason why replicas are still the dominant choice for HA fault tolerant data storage.</div><br/><div id="41364738" class="c"><input type="checkbox" id="c-41364738" checked=""/><div class="controls bullet"><span class="by">jsolson</span><span>|</span><a href="#41364240">parent</a><span>|</span><a href="#41364373">next</a><span>|</span><label class="collapse" for="c-41364738">[-]</label><label class="expand" for="c-41364738">[1 more]</label></div><br/><div class="children"><div class="content">Funny story, if you&#x27;re using Rook Ceph and say &quot;I&#x27;m going to try to update these parameters to see if it will let me (and trigger a re-encoding)&quot; it absolutely will let you change them, but it does not trigger anything to re-encode.<p>It just uses --force and leaves you with a corrupt filesystem.<p>I suppose that&#x27;s only really funny in a &quot;you had to be there, and not be me&quot; sense.</div><br/></div></div></div></div><div id="41363448" class="c"><input type="checkbox" id="c-41363448" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#41364240">prev</a><span>|</span><a href="#41363583">next</a><span>|</span><label class="collapse" for="c-41363448">[-]</label><label class="expand" for="c-41363448">[5 more]</label></div><br/><div class="children"><div class="content">Am I right in thinking that products made during an M of N incident are coded differently to when all N are available? If so, you might want a bitflag to denote &quot;needs to be re-encoded when the N is restored&quot; or else you have some files with less than stellar recovery for a random loss in the N set.</div><br/><div id="41363494" class="c"><input type="checkbox" id="c-41363494" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#41363448">parent</a><span>|</span><a href="#41363583">next</a><span>|</span><label class="collapse" for="c-41363494">[-]</label><label class="expand" for="c-41363494">[4 more]</label></div><br/><div class="children"><div class="content">Whenever you have a stripe with missing chunks they need to be re-encoded ASAP because those stripes will be lost if they lose enough chunks. Every distributed storage system needs some kind of librarian to go around grooming the stripes to keep them out of danger.</div><br/><div id="41363598" class="c"><input type="checkbox" id="c-41363598" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#41363448">root</a><span>|</span><a href="#41363494">parent</a><span>|</span><a href="#41363949">next</a><span>|</span><label class="collapse" for="c-41363598">[-]</label><label class="expand" for="c-41363598">[2 more]</label></div><br/><div class="children"><div class="content">My point was specifically to new things created during the period. Resilvering happens on addition of a replacement drive in ZFS. I am less sure that otherwise valid, complete checksum states of files made during the loss period get uplifted to the wider stripe count when that is done.<p>I say that because I have seen some stuff which suggests when you grow the FS with new VDEV in ZFS there are circumstances where the balance is not fixed and you can have persisting unbalanced IO state.</div><br/><div id="41363667" class="c"><input type="checkbox" id="c-41363667" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#41363448">root</a><span>|</span><a href="#41363598">parent</a><span>|</span><a href="#41363949">next</a><span>|</span><label class="collapse" for="c-41363667">[-]</label><label class="expand" for="c-41363667">[1 more]</label></div><br/><div class="children"><div class="content">In distributed systems you don&#x27;t need to be constrained to writing to a set of devices one of which is not available. You can just write anywhere, and remember where.</div><br/></div></div></div></div><div id="41363949" class="c"><input type="checkbox" id="c-41363949" checked=""/><div class="controls bullet"><span class="by">markhahn</span><span>|</span><a href="#41363448">root</a><span>|</span><a href="#41363494">parent</a><span>|</span><a href="#41363598">prev</a><span>|</span><a href="#41363583">next</a><span>|</span><label class="collapse" for="c-41363949">[-]</label><label class="expand" for="c-41363949">[1 more]</label></div><br/><div class="children"><div class="content">just a suggestion: let the curator&#x27;s activity be called &quot;preening&quot; rather than &quot;grooming&quot;...</div><br/></div></div></div></div></div></div><div id="41363583" class="c"><input type="checkbox" id="c-41363583" checked=""/><div class="controls bullet"><span class="by">anonymousDan</span><span>|</span><a href="#41363448">prev</a><span>|</span><a href="#41363168">next</a><span>|</span><label class="collapse" for="c-41363583">[-]</label><label class="expand" for="c-41363583">[1 more]</label></div><br/><div class="children"><div class="content">Is it the case that it&#x27;s really only practical for read-only or very read intensive workloads?</div><br/></div></div><div id="41363168" class="c"><input type="checkbox" id="c-41363168" checked=""/><div class="controls bullet"><span class="by">from-nibly</span><span>|</span><a href="#41363583">prev</a><span>|</span><a href="#41364423">next</a><span>|</span><label class="collapse" for="c-41363168">[-]</label><label class="expand" for="c-41363168">[1 more]</label></div><br/><div class="children"><div class="content">This is one of the replication strategies that ceph uses for its distributed blob stores</div><br/></div></div><div id="41364423" class="c"><input type="checkbox" id="c-41364423" checked=""/><div class="controls bullet"><span class="by">nullc</span><span>|</span><a href="#41363168">prev</a><span>|</span><a href="#41362603">next</a><span>|</span><label class="collapse" for="c-41364423">[-]</label><label class="expand" for="c-41364423">[2 more]</label></div><br/><div class="children"><div class="content">unfortunately modern cpus are still pretty sparse on tools to make erasure codes extremely fast.  E.g. no vector clmuls.</div><br/><div id="41365551" class="c"><input type="checkbox" id="c-41365551" checked=""/><div class="controls bullet"><span class="by">klauspost</span><span>|</span><a href="#41364423">parent</a><span>|</span><a href="#41362603">next</a><span>|</span><label class="collapse" for="c-41365551">[-]</label><label class="expand" for="c-41365551">[1 more]</label></div><br/><div class="children"><div class="content">Almost all (x86) CPUs sold have GFNI. That can pretty much saturate memory bandwidth on a single core or two. You can use SSSE3 pshufb for the rest which is about half the speed.<p>ARM has NEON and SVE&#x2F;SVE 2. They also operate very fast.<p>So not sure what you are thinking of.</div><br/></div></div></div></div></div></div></div></div></div></body></html>