<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699261260895" as="style"/><link rel="stylesheet" href="styles.css?v=1699261260895"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dave.cheney.net/paste/gophercon-sg-2023.html">Building a high performance JSON parser</a>Â <span class="domain">(<a href="https://dave.cheney.net">dave.cheney.net</a>)</span></div><div class="subtext"><span>davecheney</span> | <span>157 comments</span></div><br/><div><div id="38153268" class="c"><input type="checkbox" id="c-38153268" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#38150906">next</a><span>|</span><label class="collapse" for="c-38153268">[-]</label><label class="expand" for="c-38153268">[15 more]</label></div><br/><div class="children"><div class="content">Looks pretty good! Even though I&#x27;ve written far too many JSON parsers already in my career, it&#x27;s really nice to have a reference for how to think about making a reasonable, fast JSON parser, going through each step individually.<p>That said, I will say one thing: you don&#x27;t <i>really</i> need to have an explicit tokenizer for JSON. You can get rid of the concept of tokens and integrate parsing and tokenization <i>entirely</i>. This is what I usually do since it makes everything simpler. This is a lot harder to do with something like the rest of ECMAscript since in something like ECMAscript you wind up needing look-ahead (sometimes arbitrarily large look-ahead... consider arrow functions: it&#x27;s mostly a subset of the grammar of a parenthesized expression. Comma is an operator, and for default values, equal is an operator. It isn&#x27;t until the =&gt; does or does not appear that you know for sure!)</div><br/><div id="38153656" class="c"><input type="checkbox" id="c-38153656" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#38153268">parent</a><span>|</span><a href="#38150906">next</a><span>|</span><label class="collapse" for="c-38153656">[-]</label><label class="expand" for="c-38153656">[14 more]</label></div><br/><div class="children"><div class="content">What line of work are you in that you&#x27;ve &quot;written far too many JSON parsers already&quot; in your career?!!!</div><br/><div id="38154126" class="c"><input type="checkbox" id="c-38154126" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#38153268">root</a><span>|</span><a href="#38153656">parent</a><span>|</span><a href="#38155701">next</a><span>|</span><label class="collapse" for="c-38154126">[-]</label><label class="expand" for="c-38154126">[5 more]</label></div><br/><div class="children"><div class="content">Reasons differ. C++ is a really hard place to be. It&#x27;s gotten better, but if you can&#x27;t tolerate exceptions, need code that is as-obviously-memory-safe-as-possible, can parse incrementally (think SAX style), off-the-shelf options like jsoncpp may not fit the bill.<p>Handling large documents is indeed another big one. It <i>sort-of</i> fits in the same category as being able to parse incrementally. That said, Go has a JSON scanner you can sort of use for incremental parsing, but in practice I&#x27;ve found it to be a lot slower, so for large documents it&#x27;s a problem.<p>I&#x27;ve done a couple in hobby projects too. One time I did a partial one in Win32-style C89 because I wanted one that didn&#x27;t depend on libc.</div><br/><div id="38156988" class="c"><input type="checkbox" id="c-38156988" checked=""/><div class="controls bullet"><span class="by">beached_whale</span><span>|</span><a href="#38153268">root</a><span>|</span><a href="#38154126">parent</a><span>|</span><a href="#38155701">next</a><span>|</span><label class="collapse" for="c-38156988">[-]</label><label class="expand" for="c-38156988">[4 more]</label></div><br/><div class="children"><div class="content">The large documents are often fixed by using mmap&#x2F;virtualalloc of the file, but Boost.JSON has a streaming mode and is reasonably fast and the license is good for pulling into anything.  It&#x27;s not the fastest, but faster than rapid with the interface of nlohmann JSON.  For most tasks, it does seem that most of hte libraries taking a JSON document approach are wasting a lot of time&#x2F;memory to get to the point that we want normal data structures, not a JSON document tree.  If we pull that out and parse straight to the data structures there is a lot of win in performance and memory with less&#x2F;no code, just mappings.  That&#x27;s how I approached it at least.</div><br/><div id="38158553" class="c"><input type="checkbox" id="c-38158553" checked=""/><div class="controls bullet"><span class="by">c-smile</span><span>|</span><a href="#38153268">root</a><span>|</span><a href="#38156988">parent</a><span>|</span><a href="#38155701">next</a><span>|</span><label class="collapse" for="c-38158553">[-]</label><label class="expand" for="c-38158553">[3 more]</label></div><br/><div class="children"><div class="content">&gt; that most of hte libraries taking a JSON document approach are wasting a lot of time&#x2F;memory<p>I agree. That&#x27;s the same situation as with XML&#x2F;HTML. In many cases you don&#x27;t really need to build a DOM or JSOM in memory. If your task is about deserializing some native structures.<p>This XML scanner of mine does not allocate any memory at all while parsing HTML&#x2F;XML: 
<a href="https:&#x2F;&#x2F;www.codeproject.com&#x2F;Articles&#x2F;14076&#x2F;Fast-and-Compact-HTML-XML-Scanner-Tokenizer" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.codeproject.com&#x2F;Articles&#x2F;14076&#x2F;Fast-and-Compact-...</a><p>It is even simpler than SAX parser.</div><br/><div id="38159247" class="c"><input type="checkbox" id="c-38159247" checked=""/><div class="controls bullet"><span class="by">beached_whale</span><span>|</span><a href="#38153268">root</a><span>|</span><a href="#38158553">parent</a><span>|</span><a href="#38158745">prev</a><span>|</span><a href="#38155701">next</a><span>|</span><label class="collapse" for="c-38159247">[-]</label><label class="expand" for="c-38159247">[1 more]</label></div><br/><div class="children"><div class="content">For the interesting JSON of a significant size, an interator&#x2F;range interface that parses to concrete types works really well.  Usually they are large arrays or JSONL like things</div><br/></div></div></div></div></div></div></div></div><div id="38155701" class="c"><input type="checkbox" id="c-38155701" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#38153268">root</a><span>|</span><a href="#38153656">parent</a><span>|</span><a href="#38154126">prev</a><span>|</span><a href="#38153772">next</a><span>|</span><label class="collapse" for="c-38155701">[-]</label><label class="expand" for="c-38155701">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen &quot;somebody doesn&#x27;t agree with the standard and we must support it&quot; way too many times, and I&#x27;ve written JSON parsers because of this. (And, of course, it&#x27;s easy to get some difference with the JSON standard.)<p>I&#x27;ve had problems with handling streams like the OP on basically every programing language and data-encoding language pair that I&#x27;ve tried. It looks like nobody ever thinks about it (I do use chunking any time I can, but some times you can&#x27;t).<p>There are probably lots and lots of reasons to write your own parser.</div><br/><div id="38155871" class="c"><input type="checkbox" id="c-38155871" checked=""/><div class="controls bullet"><span class="by">jbiggley</span><span>|</span><a href="#38153268">root</a><span>|</span><a href="#38155701">parent</a><span>|</span><a href="#38153772">next</a><span>|</span><label class="collapse" for="c-38155871">[-]</label><label class="expand" for="c-38155871">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of my favourite quote about standards.<p>&gt;The wonderful thing about standards is that there are so many of them to choose from.<p>And, keeping with the theme, this quote may be from Grace Hopper, Andrew Tanenbaum,  Patricia Seybold or Ken Olsen.</div><br/></div></div></div></div><div id="38153772" class="c"><input type="checkbox" id="c-38153772" checked=""/><div class="controls bullet"><span class="by">craigching</span><span>|</span><a href="#38153268">root</a><span>|</span><a href="#38153656">parent</a><span>|</span><a href="#38155701">prev</a><span>|</span><a href="#38155539">next</a><span>|</span><label class="collapse" for="c-38153772">[-]</label><label class="expand" for="c-38153772">[4 more]</label></div><br/><div class="children"><div class="content">Probably anywhere that requires parsing large JSON documents. Off the shelf JSON parsers are notoriously slow on large JSON documents.</div><br/><div id="38159502" class="c"><input type="checkbox" id="c-38159502" checked=""/><div class="controls bullet"><span class="by">zlg_codes</span><span>|</span><a href="#38153268">root</a><span>|</span><a href="#38153772">parent</a><span>|</span><a href="#38157010">next</a><span>|</span><label class="collapse" for="c-38159502">[-]</label><label class="expand" for="c-38159502">[1 more]</label></div><br/><div class="children"><div class="content">What on Earth are you storing in JSON that this sort of performance issue becomes an issue?<p>How big is &#x27;large&#x27; here?<p>I built a simple CRUD inventory program to keep track of one&#x27;s gaming backlog and progress, and the dumped JSON of my entire 500+ game statuses is under 60kB and can be imported in under a second on decade-old hardware.<p>I&#x27;m having difficulty picturing a JSON dataset big enough to slow down modern hardware. Maybe Gentoo&#x27;s portage tree if it were JSON encoded?</div><br/></div></div><div id="38157010" class="c"><input type="checkbox" id="c-38157010" checked=""/><div class="controls bullet"><span class="by">beached_whale</span><span>|</span><a href="#38153268">root</a><span>|</span><a href="#38153772">parent</a><span>|</span><a href="#38159502">prev</a><span>|</span><a href="#38155375">next</a><span>|</span><label class="collapse" for="c-38157010">[-]</label><label class="expand" for="c-38157010">[1 more]</label></div><br/><div class="children"><div class="content">There are several that are into the GB&#x2F;s of performance with various interfaces.  Most are just trash for large documents and sit in the allocators far too long, but that&#x27;s not required either</div><br/></div></div><div id="38155375" class="c"><input type="checkbox" id="c-38155375" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#38153268">root</a><span>|</span><a href="#38153772">parent</a><span>|</span><a href="#38157010">prev</a><span>|</span><a href="#38155539">next</a><span>|</span><label class="collapse" for="c-38155375">[-]</label><label class="expand" for="c-38155375">[1 more]</label></div><br/><div class="children"><div class="content">Not necessarily, for example Newtonsoft is fine with multiple hundreds of megabyes if you use it correctly. But of course depends on how large we are talking about.</div><br/></div></div></div></div><div id="38155539" class="c"><input type="checkbox" id="c-38155539" checked=""/><div class="controls bullet"><span class="by">lgas</span><span>|</span><a href="#38153268">root</a><span>|</span><a href="#38153656">parent</a><span>|</span><a href="#38153772">prev</a><span>|</span><a href="#38156685">next</a><span>|</span><label class="collapse" for="c-38155539">[-]</label><label class="expand" for="c-38155539">[1 more]</label></div><br/><div class="children"><div class="content">Someone misunderstood the JSONParserFactory somewhere along the line.</div><br/></div></div><div id="38156685" class="c"><input type="checkbox" id="c-38156685" checked=""/><div class="controls bullet"><span class="by">crabbone</span><span>|</span><a href="#38153268">root</a><span>|</span><a href="#38153656">parent</a><span>|</span><a href="#38155539">prev</a><span>|</span><a href="#38150906">next</a><span>|</span><label class="collapse" for="c-38156685">[-]</label><label class="expand" for="c-38156685">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve written JSON parsers because in one instance we had to allow users to keep their formatting but also edit documents programmatically.  At the time I couldn&#x27;t find parsers that did that, but it was a while back.<p>In another instance, it was easier to parse into some application-specific structures, skipping the whole intermediate generic step (for performance reasons).<p>With JSON it&#x27;s easier to convince your boss that you can actually write such a parser because the language is relatively simple (if you overlook botched definitions of basically every element...)  So, for example, if the application that uses JSON is completely under your control, you may take advantage of stupid decisions made by JSON authors to simplify many things.  More concretely, you can decide that there will never be more than X digits in numbers.  That you will never use &quot;null&quot;.  Or that you will always put elements of the same type into &quot;lists&quot;.  Or that you will never repeat keys in &quot;hash tables&quot;.</div><br/></div></div></div></div></div></div><div id="38150906" class="c"><input type="checkbox" id="c-38150906" checked=""/><div class="controls bullet"><span class="by">eatonphil</span><span>|</span><a href="#38153268">prev</a><span>|</span><a href="#38156259">next</a><span>|</span><label class="collapse" for="c-38150906">[-]</label><label class="expand" for="c-38150906">[30 more]</label></div><br/><div class="children"><div class="content">The walkthrough is very nice, how to do this if you&#x27;re going to do it.<p>If you&#x27;re going for pure performance in a production environment you might take a look at Daniel Lemire&#x27;s work: <a href="https:&#x2F;&#x2F;github.com&#x2F;simdjson&#x2F;simdjson">https:&#x2F;&#x2F;github.com&#x2F;simdjson&#x2F;simdjson</a>. Or the MinIO port of it to Go: <a href="https:&#x2F;&#x2F;github.com&#x2F;minio&#x2F;simdjson-go">https:&#x2F;&#x2F;github.com&#x2F;minio&#x2F;simdjson-go</a>.</div><br/><div id="38151207" class="c"><input type="checkbox" id="c-38151207" checked=""/><div class="controls bullet"><span class="by">vjerancrnjak</span><span>|</span><a href="#38150906">parent</a><span>|</span><a href="#38151581">next</a><span>|</span><label class="collapse" for="c-38151207">[-]</label><label class="expand" for="c-38151207">[19 more]</label></div><br/><div class="children"><div class="content">If your JSON always looks the same you can also do better than general JSON parsers.</div><br/><div id="38151551" class="c"><input type="checkbox" id="c-38151551" checked=""/><div class="controls bullet"><span class="by">lylejantzi3rd</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38151207">parent</a><span>|</span><a href="#38151773">next</a><span>|</span><label class="collapse" for="c-38151551">[-]</label><label class="expand" for="c-38151551">[4 more]</label></div><br/><div class="children"><div class="content">Andreas Fredriksson demonstrates exactly that in this video: <a href="https:&#x2F;&#x2F;vimeo.com&#x2F;644068002" rel="nofollow noreferrer">https:&#x2F;&#x2F;vimeo.com&#x2F;644068002</a></div><br/><div id="38155879" class="c"><input type="checkbox" id="c-38155879" checked=""/><div class="controls bullet"><span class="by">kaladin_1</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38151551">parent</a><span>|</span><a href="#38152926">next</a><span>|</span><label class="collapse" for="c-38155879">[-]</label><label class="expand" for="c-38155879">[2 more]</label></div><br/><div class="children"><div class="content">I really enjoyed this video even though he lost me with the SIMD code.</div><br/><div id="38157132" class="c"><input type="checkbox" id="c-38157132" checked=""/><div class="controls bullet"><span class="by">gnuvince</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38155879">parent</a><span>|</span><a href="#38152926">next</a><span>|</span><label class="collapse" for="c-38157132">[-]</label><label class="expand" for="c-38157132">[1 more]</label></div><br/><div class="children"><div class="content">I like this video because there&#x27;s a lot of a good actionable advice before he gets into SIMD code.</div><br/></div></div></div></div><div id="38152926" class="c"><input type="checkbox" id="c-38152926" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38151551">parent</a><span>|</span><a href="#38155879">prev</a><span>|</span><a href="#38151773">next</a><span>|</span><label class="collapse" for="c-38152926">[-]</label><label class="expand" for="c-38152926">[1 more]</label></div><br/><div class="children"><div class="content">Very enjoyable video!</div><br/></div></div></div></div><div id="38151773" class="c"><input type="checkbox" id="c-38151773" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38151207">parent</a><span>|</span><a href="#38151551">prev</a><span>|</span><a href="#38151658">next</a><span>|</span><label class="collapse" for="c-38151773">[-]</label><label class="expand" for="c-38151773">[2 more]</label></div><br/><div class="children"><div class="content">You might also move to something other than JSON if parsing it is a significant part of your workload.</div><br/><div id="38153492" class="c"><input type="checkbox" id="c-38153492" checked=""/><div class="controls bullet"><span class="by">haswell</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38151773">parent</a><span>|</span><a href="#38151658">next</a><span>|</span><label class="collapse" for="c-38153492">[-]</label><label class="expand" for="c-38153492">[1 more]</label></div><br/><div class="children"><div class="content">Most of the times Iâve had to deal with JSON performance issues, it involved a 3rd party API and JSON was the only option.<p>If youâre building something net-new and know youâll have these problems out the gate, something other than JSON might be feasible, but the moment some other system not in the closed loop needs to work with the data, youâre back to JSON and any associated perf issues.</div><br/></div></div></div></div><div id="38151658" class="c"><input type="checkbox" id="c-38151658" checked=""/><div class="controls bullet"><span class="by">diarrhea</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38151207">parent</a><span>|</span><a href="#38151773">prev</a><span>|</span><a href="#38151581">next</a><span>|</span><label class="collapse" for="c-38151658">[-]</label><label class="expand" for="c-38151658">[12 more]</label></div><br/><div class="children"><div class="content">I wonder: can fast, special-case JSON parsers be dynamically autogenerated from JSON Schemas?<p>Perhaps some macro-ridden Rust monstrosity that spits out specialised parsers at compile time, dynamicallyâ¦</div><br/><div id="38151729" class="c"><input type="checkbox" id="c-38151729" checked=""/><div class="controls bullet"><span class="by">minhazm</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38151658">parent</a><span>|</span><a href="#38152225">next</a><span>|</span><label class="collapse" for="c-38151729">[-]</label><label class="expand" for="c-38151729">[2 more]</label></div><br/><div class="children"><div class="content">For json schema specifically there are some tools like go-jsonschema[1] but I&#x27;ve never used them personally. But you can use something like ffjson[2] in go to generate a static serialize&#x2F;deserialize function based on a struct definition.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;omissis&#x2F;go-jsonschema">https:&#x2F;&#x2F;github.com&#x2F;omissis&#x2F;go-jsonschema</a>
[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;pquerna&#x2F;ffjson">https:&#x2F;&#x2F;github.com&#x2F;pquerna&#x2F;ffjson</a></div><br/><div id="38155649" class="c"><input type="checkbox" id="c-38155649" checked=""/><div class="controls bullet"><span class="by">atombender</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38151729">parent</a><span>|</span><a href="#38152225">next</a><span>|</span><label class="collapse" for="c-38155649">[-]</label><label class="expand" for="c-38155649">[1 more]</label></div><br/><div class="children"><div class="content">Hey, go-jsonschema is my project. (Someone else just took over maintaining it, though.) It still relies on the standard Go parser; all it does it generate structs with the right types and tags.</div><br/></div></div></div></div><div id="38152225" class="c"><input type="checkbox" id="c-38152225" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38151658">parent</a><span>|</span><a href="#38151729">prev</a><span>|</span><a href="#38154223">next</a><span>|</span><label class="collapse" for="c-38152225">[-]</label><label class="expand" for="c-38152225">[1 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t the serde crate&#x27;s json support do precisely this?  It generates structs that have optional in all the right places and with all the right types anyway. Seems like the llvm optimiser can probably do something useful with that even if the serde feature isn&#x27;t using apriori knowledge out of the schema.</div><br/></div></div><div id="38154223" class="c"><input type="checkbox" id="c-38154223" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38151658">parent</a><span>|</span><a href="#38152225">prev</a><span>|</span><a href="#38152666">next</a><span>|</span><label class="collapse" for="c-38154223">[-]</label><label class="expand" for="c-38154223">[3 more]</label></div><br/><div class="children"><div class="content">A fundamental problem with JSON parsing is that it has variable length fields that don&#x27;t encode their length, in a streaming scenario you basically need to keep resizing your buffer until the data fits.  If the data is on disk and not streaming you may get away with reading ahead to find the end of the field first, but that&#x27;s also not particularly fast.<p>Schemas can&#x27;t fix that.</div><br/><div id="38156907" class="c"><input type="checkbox" id="c-38156907" checked=""/><div class="controls bullet"><span class="by">robocat</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38154223">parent</a><span>|</span><a href="#38152666">next</a><span>|</span><label class="collapse" for="c-38156907">[-]</label><label class="expand" for="c-38156907">[2 more]</label></div><br/><div class="children"><div class="content">Only if you are using pointers&#x2F;slices into the buffer as an optimisation.<p>Otherwise there is no need to keep a buffer of anything after it has been parsed.</div><br/><div id="38157543" class="c"><input type="checkbox" id="c-38157543" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38156907">parent</a><span>|</span><a href="#38152666">next</a><span>|</span><label class="collapse" for="c-38157543">[-]</label><label class="expand" for="c-38157543">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m talking about during parsing.<p>Let&#x27;s assume I send you a JSON object that is one very long string and nothing else. It&#x27;s e.g. 1 GB in size.  To know you need to allocate a 1GB buffer, you need to first scan it, and then copy it; or keep reallocating the same buffer until it fits.<p>It&#x27;s an absurd case, but shorter strings face similar overhead.</div><br/></div></div></div></div></div></div><div id="38152666" class="c"><input type="checkbox" id="c-38152666" checked=""/><div class="controls bullet"><span class="by">dleeftink</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38151658">parent</a><span>|</span><a href="#38154223">prev</a><span>|</span><a href="#38155521">next</a><span>|</span><label class="collapse" for="c-38152666">[-]</label><label class="expand" for="c-38152666">[3 more]</label></div><br/><div class="children"><div class="content">Somewhat tangentially related, Fabian Iwand posted this regex prefix tree visualiser&#x2F;generator last week [0], which may offer some inspiration for prototyping auto generated schemas.</div><br/><div id="38158338" class="c"><input type="checkbox" id="c-38158338" checked=""/><div class="controls bullet"><span class="by">dleeftink</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38152666">parent</a><span>|</span><a href="#38155654">next</a><span>|</span><label class="collapse" for="c-38158338">[-]</label><label class="expand" for="c-38158338">[1 more]</label></div><br/><div class="children"><div class="content">Forgot to include the link:<p>[0]: <a href="https:&#x2F;&#x2F;observablehq.com&#x2F;@mootari&#x2F;regex-from-strings" rel="nofollow noreferrer">https:&#x2F;&#x2F;observablehq.com&#x2F;@mootari&#x2F;regex-from-strings</a></div><br/></div></div><div id="38155654" class="c"><input type="checkbox" id="c-38155654" checked=""/><div class="controls bullet"><span class="by">atombender</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38152666">parent</a><span>|</span><a href="#38158338">prev</a><span>|</span><a href="#38155521">next</a><span>|</span><label class="collapse" for="c-38155654">[-]</label><label class="expand" for="c-38155654">[1 more]</label></div><br/><div class="children"><div class="content">You forgot to include the link?</div><br/></div></div></div></div><div id="38155521" class="c"><input type="checkbox" id="c-38155521" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38151658">parent</a><span>|</span><a href="#38152666">prev</a><span>|</span><a href="#38153187">next</a><span>|</span><label class="collapse" for="c-38155521">[-]</label><label class="expand" for="c-38155521">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s relatively common in D application to use the compile time capabilities to generator a parser at compile time</div><br/></div></div><div id="38153187" class="c"><input type="checkbox" id="c-38153187" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38151658">parent</a><span>|</span><a href="#38155521">prev</a><span>|</span><a href="#38151581">next</a><span>|</span><label class="collapse" for="c-38153187">[-]</label><label class="expand" for="c-38153187">[1 more]</label></div><br/><div class="children"><div class="content">Pydantic does that to some extend I think.</div><br/></div></div></div></div></div></div><div id="38151581" class="c"><input type="checkbox" id="c-38151581" checked=""/><div class="controls bullet"><span class="by">fooster</span><span>|</span><a href="#38150906">parent</a><span>|</span><a href="#38151207">prev</a><span>|</span><a href="#38151793">next</a><span>|</span><label class="collapse" for="c-38151581">[-]</label><label class="expand" for="c-38151581">[1 more]</label></div><br/><div class="children"><div class="content">Last time I compared the performance of various json parsers the simd one turned out to be disappointingly slow.</div><br/></div></div><div id="38151793" class="c"><input type="checkbox" id="c-38151793" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#38150906">parent</a><span>|</span><a href="#38151581">prev</a><span>|</span><a href="#38152194">next</a><span>|</span><label class="collapse" for="c-38151793">[-]</label><label class="expand" for="c-38151793">[7 more]</label></div><br/><div class="children"><div class="content">The fastest json lib in Go is the one done by the company behind Tiktok.</div><br/><div id="38153056" class="c"><input type="checkbox" id="c-38153056" checked=""/><div class="controls bullet"><span class="by">rockinghigh</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38151793">parent</a><span>|</span><a href="#38152010">next</a><span>|</span><label class="collapse" for="c-38153056">[-]</label><label class="expand" for="c-38153056">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;bytedance&#x2F;sonic">https:&#x2F;&#x2F;github.com&#x2F;bytedance&#x2F;sonic</a></div><br/></div></div><div id="38152010" class="c"><input type="checkbox" id="c-38152010" checked=""/><div class="controls bullet"><span class="by">ken47</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38151793">parent</a><span>|</span><a href="#38153056">prev</a><span>|</span><a href="#38153390">next</a><span>|</span><label class="collapse" for="c-38152010">[-]</label><label class="expand" for="c-38152010">[3 more]</label></div><br/><div class="children"><div class="content">Fastest at what?</div><br/><div id="38153876" class="c"><input type="checkbox" id="c-38153876" checked=""/><div class="controls bullet"><span class="by">cannonpalms</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38152010">parent</a><span>|</span><a href="#38153390">next</a><span>|</span><label class="collapse" for="c-38153876">[-]</label><label class="expand" for="c-38153876">[2 more]</label></div><br/><div class="children"><div class="content">&gt; For all sizes of json and all scenarios of usage, Sonic performs best.<p>The repository has benchmarks</div><br/><div id="38155326" class="c"><input type="checkbox" id="c-38155326" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38153876">parent</a><span>|</span><a href="#38153390">next</a><span>|</span><label class="collapse" for="c-38155326">[-]</label><label class="expand" for="c-38155326">[1 more]</label></div><br/><div class="children"><div class="content">Iâm not seeing simdjson in them though? I must be missing something because the Go port of it is explicitly mentioned in the motivation[1] (not the real thing, though).<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;bytedance&#x2F;sonic&#x2F;blob&#x2F;main&#x2F;docs&#x2F;INTRODUCTION.md">https:&#x2F;&#x2F;github.com&#x2F;bytedance&#x2F;sonic&#x2F;blob&#x2F;main&#x2F;docs&#x2F;INTRODUCTI...</a></div><br/></div></div></div></div></div></div><div id="38153390" class="c"><input type="checkbox" id="c-38153390" checked=""/><div class="controls bullet"><span class="by">pizzafeelsright</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38151793">parent</a><span>|</span><a href="#38152010">prev</a><span>|</span><a href="#38153389">next</a><span>|</span><label class="collapse" for="c-38153390">[-]</label><label class="expand" for="c-38153390">[1 more]</label></div><br/><div class="children"><div class="content">Excellent treat vector.</div><br/></div></div><div id="38153389" class="c"><input type="checkbox" id="c-38153389" checked=""/><div class="controls bullet"><span class="by">pizzafeelsright</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38151793">parent</a><span>|</span><a href="#38153390">prev</a><span>|</span><a href="#38152194">next</a><span>|</span><label class="collapse" for="c-38153389">[-]</label><label class="expand" for="c-38153389">[1 more]</label></div><br/><div class="children"><div class="content">Excellent treat vector.</div><br/></div></div></div></div><div id="38152194" class="c"><input type="checkbox" id="c-38152194" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#38150906">parent</a><span>|</span><a href="#38151793">prev</a><span>|</span><a href="#38156259">next</a><span>|</span><label class="collapse" for="c-38152194">[-]</label><label class="expand" for="c-38152194">[2 more]</label></div><br/><div class="children"><div class="content">simdjson has not been the fastest for a long long time</div><br/><div id="38152483" class="c"><input type="checkbox" id="c-38152483" checked=""/><div class="controls bullet"><span class="by">jzwinck</span><span>|</span><a href="#38150906">root</a><span>|</span><a href="#38152194">parent</a><span>|</span><a href="#38156259">next</a><span>|</span><label class="collapse" for="c-38152483">[-]</label><label class="expand" for="c-38152483">[1 more]</label></div><br/><div class="children"><div class="content">What is faster? According to <a href="https:&#x2F;&#x2F;github.com&#x2F;kostya&#x2F;benchmarks#json">https:&#x2F;&#x2F;github.com&#x2F;kostya&#x2F;benchmarks#json</a> nothing is.</div><br/></div></div></div></div></div></div><div id="38156259" class="c"><input type="checkbox" id="c-38156259" checked=""/><div class="controls bullet"><span class="by">wood_spirit</span><span>|</span><a href="#38150906">prev</a><span>|</span><a href="#38159769">next</a><span>|</span><label class="collapse" for="c-38156259">[-]</label><label class="expand" for="c-38156259">[1 more]</label></div><br/><div class="children"><div class="content">My own lessons from writing fast json parsers has a lot of language-type things but here are some generalisations:<p>Avoid heap allocations in tokenising.  Have a tokeniser that is a function that returns a stack-allocated struct or an int64 token that is a packed field describing the start, length and type offsets etc of the token.<p>Avoid heap allocations in parsing: support a getString(key String) type interface for clients that what to chop up a buffer.<p>For deserialising to object where you know the fields at compile time, generally generate a switch case of key length before comparing string values.<p>My experience in data pipelines that process lots of json is that choice of json library can be a 3-10x performance difference and that all the main parsers want to allocate objects.<p>If the classes you are serialising or deserialising is known at compile time then Jackson Java does a good job but you can get a 2x boost with careful coding and profiling.<p>Whereas if you are paying aribrary json then all the mainstream parsers want to do lots of allocations that a more intrusive parser that you write yourself can avoid, and that you can make massive performance wins if you are processing thousands or millions of objects per second.</div><br/></div></div><div id="38159769" class="c"><input type="checkbox" id="c-38159769" checked=""/><div class="controls bullet"><span class="by">romshark</span><span>|</span><a href="#38156259">prev</a><span>|</span><a href="#38160048">next</a><span>|</span><label class="collapse" for="c-38159769">[-]</label><label class="expand" for="c-38159769">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve recently held a talk (<a href="https:&#x2F;&#x2F;youtu.be&#x2F;a7VBbbcmxyQ?si=0fGVxfc4qmKMVCXk" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;a7VBbbcmxyQ?si=0fGVxfc4qmKMVCXk</a>) about github.com&#x2F;romshark&#x2F;jscan that I&#x27;ve been working on. It&#x27;s a performance-oriented JSON iterator &#x2F; tokenizer you might want to take a look at if interested in high performance zero allocation JSON parsing in Go.</div><br/></div></div><div id="38160048" class="c"><input type="checkbox" id="c-38160048" checked=""/><div class="controls bullet"><span class="by">flaie</span><span>|</span><a href="#38159769">prev</a><span>|</span><a href="#38159839">next</a><span>|</span><label class="collapse" for="c-38160048">[-]</label><label class="expand" for="c-38160048">[1 more]</label></div><br/><div class="children"><div class="content">This was a very good read, and I did learn some nice tricks, thank you very much.</div><br/></div></div><div id="38159839" class="c"><input type="checkbox" id="c-38159839" checked=""/><div class="controls bullet"><span class="by">EdwardDiego</span><span>|</span><a href="#38160048">prev</a><span>|</span><a href="#38152704">next</a><span>|</span><label class="collapse" for="c-38159839">[-]</label><label class="expand" for="c-38159839">[1 more]</label></div><br/><div class="children"><div class="content">A person who helped me out a lot when I was learning to code wrote his own .NET JSON library because the MS provided one had a rough API and was quite slow.<p>His lib became the defacto JSON lib in .NET dev and naturally, MS head-hunted him.<p>Fast JSON is that important these days.</div><br/></div></div><div id="38152704" class="c"><input type="checkbox" id="c-38152704" checked=""/><div class="controls bullet"><span class="by">jensneuse</span><span>|</span><a href="#38159839">prev</a><span>|</span><a href="#38153539">next</a><span>|</span><label class="collapse" for="c-38152704">[-]</label><label class="expand" for="c-38152704">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve taken a very similar approach and built a GraphQL tokenizer and parser (amongst many other things) that&#x27;s also zero memory allocations and quite fast. In case you&#x27;d like to check out the code: <a href="https:&#x2F;&#x2F;github.com&#x2F;wundergraph&#x2F;graphql-go-tools">https:&#x2F;&#x2F;github.com&#x2F;wundergraph&#x2F;graphql-go-tools</a></div><br/><div id="38160137" class="c"><input type="checkbox" id="c-38160137" checked=""/><div class="controls bullet"><span class="by">romshark</span><span>|</span><a href="#38152704">parent</a><span>|</span><a href="#38152832">next</a><span>|</span><label class="collapse" for="c-38160137">[-]</label><label class="expand" for="c-38160137">[1 more]</label></div><br/><div class="children"><div class="content">You might also want to check out this abomination of mine: <a href="https:&#x2F;&#x2F;github.com&#x2F;graph-guard&#x2F;gqlscan">https:&#x2F;&#x2F;github.com&#x2F;graph-guard&#x2F;gqlscan</a><p>I&#x27;ve held a talk about this, unfortunately wasn&#x27;t recorded. I&#x27;ve tried to squeeze as much out of Go as I could and I&#x27;ve went crazy doing that :D</div><br/></div></div><div id="38152832" class="c"><input type="checkbox" id="c-38152832" checked=""/><div class="controls bullet"><span class="by">markl42</span><span>|</span><a href="#38152704">parent</a><span>|</span><a href="#38160137">prev</a><span>|</span><a href="#38153539">next</a><span>|</span><label class="collapse" for="c-38152832">[-]</label><label class="expand" for="c-38152832">[2 more]</label></div><br/><div class="children"><div class="content">How big of an issue is this for GQL servers where all queries are known ahead of time (allowlist) - i.e. you can cache&#x2F;memorize the ast parsing and this is only a perf issue for a few minutes after the container starts up<p>Or does this bite us in other ways too?</div><br/><div id="38152911" class="c"><input type="checkbox" id="c-38152911" checked=""/><div class="controls bullet"><span class="by">jensneuse</span><span>|</span><a href="#38152704">root</a><span>|</span><a href="#38152832">parent</a><span>|</span><a href="#38153539">next</a><span>|</span><label class="collapse" for="c-38152911">[-]</label><label class="expand" for="c-38152911">[1 more]</label></div><br/><div class="children"><div class="content">I build GraphQL API gateways &#x2F; Routers for 5+ years now. It would be nice if trusted Documents or persisted operations were the default, but the reality is that a lot of people want to open up their GraphQL to the public. For that reason we&#x27;ve build a fast parser, validator, normalizer and many other things to support these use cases.</div><br/></div></div></div></div></div></div><div id="38153539" class="c"><input type="checkbox" id="c-38153539" checked=""/><div class="controls bullet"><span class="by">evmar</span><span>|</span><a href="#38152704">prev</a><span>|</span><a href="#38154255">next</a><span>|</span><label class="collapse" for="c-38153539">[-]</label><label class="expand" for="c-38153539">[1 more]</label></div><br/><div class="children"><div class="content">In n2[1] I needed a fast tokenizer and had the same &quot;garbage factory&quot; problem, which is basically that there&#x27;s a set of constant tokens (like json.Delim in this post) and then strings which cause allocations.<p>I came up with what I think is a kind of neat solution, which is that the tokenizer is generic over some T and takes a function from byteslice to T and uses T in place of the strings.  This way, when the caller has some more efficient representation available (like one that allocates less) it can provide one, but I can still unit test the tokenizer with the identity function for convenience.<p>In a sense this is like fusing the tokenizer with the parser at build time, but the generic allows layering the tokenizer such that it doesn&#x27;t know about the parser&#x27;s representation.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;evmar&#x2F;n2">https:&#x2F;&#x2F;github.com&#x2F;evmar&#x2F;n2</a></div><br/></div></div><div id="38154255" class="c"><input type="checkbox" id="c-38154255" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#38153539">prev</a><span>|</span><a href="#38150916">next</a><span>|</span><label class="collapse" for="c-38154255">[-]</label><label class="expand" for="c-38154255">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s possible to improve over the standard library with better API design, but it&#x27;s not really possible to do a fully streaming parser that doesn&#x27;t half fill structures before finding an error and bailing out in the middle, which is another explicit design constraint for the standard library.</div><br/></div></div><div id="38150916" class="c"><input type="checkbox" id="c-38150916" checked=""/><div class="controls bullet"><span class="by">rexfuzzle</span><span>|</span><a href="#38154255">prev</a><span>|</span><a href="#38156532">next</a><span>|</span><label class="collapse" for="c-38150916">[-]</label><label class="expand" for="c-38150916">[1 more]</label></div><br/><div class="children"><div class="content">Great to see a shout out to Phil Pearl!
Also worth looking at <a href="https:&#x2F;&#x2F;github.com&#x2F;bytedance&#x2F;sonic">https:&#x2F;&#x2F;github.com&#x2F;bytedance&#x2F;sonic</a></div><br/></div></div><div id="38156532" class="c"><input type="checkbox" id="c-38156532" checked=""/><div class="controls bullet"><span class="by">wslh</span><span>|</span><a href="#38150916">prev</a><span>|</span><a href="#38152617">next</a><span>|</span><label class="collapse" for="c-38156532">[-]</label><label class="expand" for="c-38156532">[1 more]</label></div><br/><div class="children"><div class="content">I remember this JSON benchmark page from RapidJSON [1].<p>[1] <a href="https:&#x2F;&#x2F;rapidjson.org&#x2F;md_doc_performance.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;rapidjson.org&#x2F;md_doc_performance.html</a></div><br/></div></div><div id="38152617" class="c"><input type="checkbox" id="c-38152617" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#38156532">prev</a><span>|</span><a href="#38155966">next</a><span>|</span><label class="collapse" for="c-38152617">[-]</label><label class="expand" for="c-38152617">[18 more]</label></div><br/><div class="children"><div class="content">&quot;Itâs unrealistic to expect to have the entire input in memory&quot; -- wrong for most applications</div><br/><div id="38155950" class="c"><input type="checkbox" id="c-38155950" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#38152617">parent</a><span>|</span><a href="#38152676">next</a><span>|</span><label class="collapse" for="c-38155950">[-]</label><label class="expand" for="c-38155950">[3 more]</label></div><br/><div class="children"><div class="content">Most applications read JSONs from networks, where you have a stream. Buffering and fiddling with the whole request in memory increases latency by a lot, even if your JSON is smallish.</div><br/><div id="38156314" class="c"><input type="checkbox" id="c-38156314" checked=""/><div class="controls bullet"><span class="by">Rapzid</span><span>|</span><a href="#38152617">root</a><span>|</span><a href="#38155950">parent</a><span>|</span><a href="#38156139">next</a><span>|</span><label class="collapse" for="c-38156314">[-]</label><label class="expand" for="c-38156314">[1 more]</label></div><br/><div class="children"><div class="content">Most(<i>most</i>) JSON payloads are probably much smaller than many buffer sizes so just end up all in memory anyway.</div><br/></div></div><div id="38156139" class="c"><input type="checkbox" id="c-38156139" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#38152617">root</a><span>|</span><a href="#38155950">parent</a><span>|</span><a href="#38156314">prev</a><span>|</span><a href="#38152676">next</a><span>|</span><label class="collapse" for="c-38156139">[-]</label><label class="expand" for="c-38156139">[1 more]</label></div><br/><div class="children"><div class="content">On a carefully built WebSocket server you would ensure your WebSocket messages all fit within a single MTU.</div><br/></div></div></div></div><div id="38152676" class="c"><input type="checkbox" id="c-38152676" checked=""/><div class="controls bullet"><span class="by">isuckatcoding</span><span>|</span><a href="#38152617">parent</a><span>|</span><a href="#38155950">prev</a><span>|</span><a href="#38153456">next</a><span>|</span><label class="collapse" for="c-38152676">[-]</label><label class="expand" for="c-38152676">[5 more]</label></div><br/><div class="children"><div class="content">Yes but for applications where you need to do ETL style transformations on large datasets, streaming is an immensely useful strategy.<p>Sure you could argue go isnât the right tool for the job but  I donât see why it canât be done with the right optimizations like this effort.</div><br/><div id="38153270" class="c"><input type="checkbox" id="c-38153270" checked=""/><div class="controls bullet"><span class="by">dh2022</span><span>|</span><a href="#38152617">root</a><span>|</span><a href="#38152676">parent</a><span>|</span><a href="#38153456">next</a><span>|</span><label class="collapse" for="c-38153270">[-]</label><label class="expand" for="c-38153270">[4 more]</label></div><br/><div class="children"><div class="content">If performance is important why would you keep large datasets in JSON format?</div><br/><div id="38155609" class="c"><input type="checkbox" id="c-38155609" checked=""/><div class="controls bullet"><span class="by">Maxion</span><span>|</span><a href="#38152617">root</a><span>|</span><a href="#38153270">parent</a><span>|</span><a href="#38154192">next</a><span>|</span><label class="collapse" for="c-38155609">[-]</label><label class="expand" for="c-38155609">[1 more]</label></div><br/><div class="children"><div class="content">Because you work at or for some bureaucratic MegaCorp, that does weird things with no real logic behind it other than clueless Dilbert managers making decisions based on LinkedIn blogs. Alternatively desperate IT consultants trying to get something to work with too low of a budget and&#x2F;or no access to do things the right way.<p>Be glad you have JSON to parse, and not EDI, some custom deliminated data format (with no or old documentation) - or <i>shudders</i> you work in the airline industry with SABRE.</div><br/></div></div><div id="38154192" class="c"><input type="checkbox" id="c-38154192" checked=""/><div class="controls bullet"><span class="by">querulous</span><span>|</span><a href="#38152617">root</a><span>|</span><a href="#38153270">parent</a><span>|</span><a href="#38155609">prev</a><span>|</span><a href="#38155362">next</a><span>|</span><label class="collapse" for="c-38154192">[-]</label><label class="expand" for="c-38154192">[1 more]</label></div><br/><div class="children"><div class="content">sometimes it&#x27;s not your data</div><br/></div></div><div id="38155362" class="c"><input type="checkbox" id="c-38155362" checked=""/><div class="controls bullet"><span class="by">isuckatcoding</span><span>|</span><a href="#38152617">root</a><span>|</span><a href="#38153270">parent</a><span>|</span><a href="#38154192">prev</a><span>|</span><a href="#38153456">next</a><span>|</span><label class="collapse" for="c-38155362">[-]</label><label class="expand" for="c-38155362">[1 more]</label></div><br/><div class="children"><div class="content">Usually because the downstream service or store needs it</div><br/></div></div></div></div></div></div><div id="38153456" class="c"><input type="checkbox" id="c-38153456" checked=""/><div class="controls bullet"><span class="by">mannyv</span><span>|</span><a href="#38152617">parent</a><span>|</span><a href="#38152676">prev</a><span>|</span><a href="#38153968">next</a><span>|</span><label class="collapse" for="c-38153456">[-]</label><label class="expand" for="c-38153456">[6 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re building a library you either need to explicitly call out your limits or do streaming.<p>I&#x27;ve pumped gigs of jaon data, so a streaming parser is appreciated. Plus streaming shows the author is better at engineering and is aware of the various use cases.<p>Memory is not cheap or free except in theory.</div><br/><div id="38154897" class="c"><input type="checkbox" id="c-38154897" checked=""/><div class="controls bullet"><span class="by">jjeaff</span><span>|</span><a href="#38152617">root</a><span>|</span><a href="#38153456">parent</a><span>|</span><a href="#38156939">next</a><span>|</span><label class="collapse" for="c-38154897">[-]</label><label class="expand" for="c-38154897">[2 more]</label></div><br/><div class="children"><div class="content">I guess it&#x27;s all relative. Memory is significantly cheaper if you get it anywhere but on loan from a cloud provider.</div><br/><div id="38155738" class="c"><input type="checkbox" id="c-38155738" checked=""/><div class="controls bullet"><span class="by">mannyv</span><span>|</span><a href="#38152617">root</a><span>|</span><a href="#38154897">parent</a><span>|</span><a href="#38156939">next</a><span>|</span><label class="collapse" for="c-38155738">[-]</label><label class="expand" for="c-38155738">[1 more]</label></div><br/><div class="children"><div class="content">RAM is always expensive no matter where you get it from.<p>Would you rather do two hours of work or force thousands of people to buy more RAM because your library is a memory hog?<p>And on embedded systems RAM is a premium. More RAM = most cost.</div><br/></div></div></div></div><div id="38156939" class="c"><input type="checkbox" id="c-38156939" checked=""/><div class="controls bullet"><span class="by">crabbone</span><span>|</span><a href="#38152617">root</a><span>|</span><a href="#38153456">parent</a><span>|</span><a href="#38154897">prev</a><span>|</span><a href="#38153968">next</a><span>|</span><label class="collapse" for="c-38156939">[-]</label><label class="expand" for="c-38156939">[3 more]</label></div><br/><div class="children"><div class="content">Here people confidently keep repeating &quot;streaming JSON&quot;.  What do you mean by that?  I&#x27;m genuinely curios.<p>Do you mean XML SAX-like interface?  If so, how do you deal with repeated keys in &quot;hash tables&quot;?  Do you first translate JSON into intermediate objects (i.e. arrays, hash-tables) and then transform them into application-specific structures, or do you try to skip the intermediate step?<p>I mean, streaming <i>tokens</i> is kind of worthless on its own.  If you are going for SAX-like interface, you want to be able to go all the way with streaming (i.e. in no layer of the code that reads JSON you don&#x27;t &quot;accumulate&quot; data (esp. not possibly indefinitely) until it can be sent to the layer above that).</div><br/><div id="38157302" class="c"><input type="checkbox" id="c-38157302" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#38152617">root</a><span>|</span><a href="#38156939">parent</a><span>|</span><a href="#38153968">next</a><span>|</span><label class="collapse" for="c-38157302">[-]</label><label class="expand" for="c-38157302">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If so, how do you deal with repeated keys in &quot;hash tables&quot;?<p>depending on the parser, behaviour might differ. But looking at <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;21832701&#x2F;does-json-syntax-allow-duplicate-keys-in-an-object" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;21832701&#x2F;does-json-synta...</a> , it seems like the &quot;best&quot; option is to have &#x27;last key wins&#x27; as the resolution.<p>This works fine under a SAX like interface in a streaming JSON parser - your &#x27;event handler&#x27; code will execute for a given key, and a 2nd time for the duplicate.</div><br/><div id="38159853" class="c"><input type="checkbox" id="c-38159853" checked=""/><div class="controls bullet"><span class="by">cowl</span><span>|</span><a href="#38152617">root</a><span>|</span><a href="#38157302">parent</a><span>|</span><a href="#38153968">next</a><span>|</span><label class="collapse" for="c-38159853">[-]</label><label class="expand" for="c-38159853">[1 more]</label></div><br/><div class="children"><div class="content">last key wins is terrible advice and has serious security implications.<p>see <a href="https:&#x2F;&#x2F;bishopfox.com&#x2F;blog&#x2F;json-interoperability-vulnerabilities" rel="nofollow noreferrer">https:&#x2F;&#x2F;bishopfox.com&#x2F;blog&#x2F;json-interoperability-vulnerabili...</a> or <a href="https:&#x2F;&#x2F;www.cvedetails.com&#x2F;cve&#x2F;CVE-2017-12635&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cvedetails.com&#x2F;cve&#x2F;CVE-2017-12635&#x2F;</a> for concrete examples where this treatment causes security issues.<p>the <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc7493" rel="nofollow noreferrer">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc7493</a> defines a more strict format where duplicate keys are not allowed.</div><br/></div></div></div></div></div></div></div></div><div id="38153968" class="c"><input type="checkbox" id="c-38153968" checked=""/><div class="controls bullet"><span class="by">e12e</span><span>|</span><a href="#38152617">parent</a><span>|</span><a href="#38153456">prev</a><span>|</span><a href="#38153192">next</a><span>|</span><label class="collapse" for="c-38153968">[-]</label><label class="expand" for="c-38153968">[2 more]</label></div><br/><div class="children"><div class="content">If you can live with &quot;fits on disk&quot; mmap() is a viable option? Unless you truly need streaming (early handling of early data, like a stream of transactions&#x2F;operations from a single JSON file?)</div><br/><div id="38155747" class="c"><input type="checkbox" id="c-38155747" checked=""/><div class="controls bullet"><span class="by">mannyv</span><span>|</span><a href="#38152617">root</a><span>|</span><a href="#38153968">parent</a><span>|</span><a href="#38153192">next</a><span>|</span><label class="collapse" for="c-38155747">[-]</label><label class="expand" for="c-38155747">[1 more]</label></div><br/><div class="children"><div class="content">In general, JSON comes over the network, so MMAP won&#x27;t really work unless you save to a file. But then you&#x27;ll run out of disk space.<p>I mean, you have a 1k, 2k, 4k buffer. Why use more, because it&#x27;s too much work?</div><br/></div></div></div></div><div id="38153192" class="c"><input type="checkbox" id="c-38153192" checked=""/><div class="controls bullet"><span class="by">capableweb</span><span>|</span><a href="#38152617">parent</a><span>|</span><a href="#38153968">prev</a><span>|</span><a href="#38155966">next</a><span>|</span><label class="collapse" for="c-38153192">[-]</label><label class="expand" for="c-38153192">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;yourdatafitsinram.net&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;yourdatafitsinram.net&#x2F;</a></div><br/></div></div></div></div><div id="38155966" class="c"><input type="checkbox" id="c-38155966" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#38152617">prev</a><span>|</span><a href="#38151212">next</a><span>|</span><label class="collapse" for="c-38155966">[-]</label><label class="expand" for="c-38155966">[1 more]</label></div><br/><div class="children"><div class="content">&quot;But there is a better trick that we can use that is more space efficient than this table, and is sometimes called a computed goto.&quot;<p>From 1989:<p><a href="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;spitbol&#x2F;x32&#x2F;master&#x2F;docs&#x2F;spitbol-manual-v3.7.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;spitbol&#x2F;x32&#x2F;master&#x2F;docs&#x2F;sp...</a><p>&quot;Indirection in the Goto field is a more powerful version of the computed Goto which appears in some languages. It allows a program to quickly perform a multi-way control branch based on an item of data.&quot;</div><br/></div></div><div id="38151212" class="c"><input type="checkbox" id="c-38151212" checked=""/><div class="controls bullet"><span class="by">peterohler</span><span>|</span><a href="#38155966">prev</a><span>|</span><a href="#38151473">next</a><span>|</span><label class="collapse" for="c-38151212">[-]</label><label class="expand" for="c-38151212">[1 more]</label></div><br/><div class="children"><div class="content">You might want to take a look at <a href="https:&#x2F;&#x2F;github.com&#x2F;ohler55&#x2F;ojg">https:&#x2F;&#x2F;github.com&#x2F;ohler55&#x2F;ojg</a>. It takes a different approach with a single pass parser. There are some performance benchmarks included on the README.md landing page.</div><br/></div></div><div id="38151473" class="c"><input type="checkbox" id="c-38151473" checked=""/><div class="controls bullet"><span class="by">arun-mani-j</span><span>|</span><a href="#38151212">prev</a><span>|</span><a href="#38152611">next</a><span>|</span><label class="collapse" for="c-38151473">[-]</label><label class="expand" for="c-38151473">[8 more]</label></div><br/><div class="children"><div class="content">I remember reading a SO question which asks for a C library to parse JSON. A comment was like - C developers won&#x27;t use a library for JSON, they will write one themselves.<p>I don&#x27;t know how &quot;true&quot; that comment is but I thought I should try to write a parser myself to get a feel :D<p>So I wrote one, in Python - <a href="https:&#x2F;&#x2F;arunmani.in&#x2F;articles&#x2F;silly-json-parser&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;arunmani.in&#x2F;articles&#x2F;silly-json-parser&#x2F;</a><p>It was a delightful experience though, writing and testing to break your own code with different variety of inputs. :)</div><br/><div id="38152266" class="c"><input type="checkbox" id="c-38152266" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#38151473">parent</a><span>|</span><a href="#38151808">next</a><span>|</span><label class="collapse" for="c-38152266">[-]</label><label class="expand" for="c-38152266">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I remember reading a SO question which asks for a C library to parse JSON. A comment was like - C developers won&#x27;t use a library for JSON, they will write one themselves.<p>&gt; I don&#x27;t know how &quot;true&quot; that comment is<p>Either way it&#x27;s a good way to get a pair of quadratic loops in your program: <a href="https:&#x2F;&#x2F;nee.lv&#x2F;2021&#x2F;02&#x2F;28&#x2F;How-I-cut-GTA-Online-loading-times-by-70&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;nee.lv&#x2F;2021&#x2F;02&#x2F;28&#x2F;How-I-cut-GTA-Online-loading-times...</a></div><br/></div></div><div id="38151808" class="c"><input type="checkbox" id="c-38151808" checked=""/><div class="controls bullet"><span class="by">janmo</span><span>|</span><a href="#38151473">parent</a><span>|</span><a href="#38152266">prev</a><span>|</span><a href="#38152663">next</a><span>|</span><label class="collapse" for="c-38151808">[-]</label><label class="expand" for="c-38151808">[4 more]</label></div><br/><div class="children"><div class="content">I wrote a small JSON parser in C myself which I called jsoncut.
It just cuts out a certain part of a json file. I deal with large JSON files, but want only to extract and parse certain parts of it. All libraries I tried parse everything, use a lot of RAM and are slow.<p>Link here, if interested to have a look:
<a href="https:&#x2F;&#x2F;github.com&#x2F;rgex&#x2F;jsoncut">https:&#x2F;&#x2F;github.com&#x2F;rgex&#x2F;jsoncut</a></div><br/><div id="38152526" class="c"><input type="checkbox" id="c-38152526" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38151473">root</a><span>|</span><a href="#38151808">parent</a><span>|</span><a href="#38152663">next</a><span>|</span><label class="collapse" for="c-38152526">[-]</label><label class="expand" for="c-38152526">[3 more]</label></div><br/><div class="children"><div class="content">The words youâre looking for are SAX-like JSON parser or streaming json parser. I donât know if thereâs any command line tools like the one you wrote that use it though to provide a jq-like interface.</div><br/><div id="38152954" class="c"><input type="checkbox" id="c-38152954" checked=""/><div class="controls bullet"><span class="by">janmo</span><span>|</span><a href="#38151473">root</a><span>|</span><a href="#38152526">parent</a><span>|</span><a href="#38152663">next</a><span>|</span><label class="collapse" for="c-38152954">[-]</label><label class="expand" for="c-38152954">[2 more]</label></div><br/><div class="children"><div class="content">I tried JQ and other command line tools, all were extremely slow and seemed to always parse the entire file.<p>My parser just reads the file byte by byte until it finds the target, then outputs the content. When that&#x27;s done it stops reading the file, meaning that it can be extremely fast when the targeted information is at the beginning of the JSON file.</div><br/><div id="38156251" class="c"><input type="checkbox" id="c-38156251" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38151473">root</a><span>|</span><a href="#38152954">parent</a><span>|</span><a href="#38152663">next</a><span>|</span><label class="collapse" for="c-38156251">[-]</label><label class="expand" for="c-38156251">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re still describing a SAX parser (i.e. streaming). jq doesn&#x27;t use a SAX parser because it&#x27;s a multi-pass document editor at its core, hence why I said &quot;jq-like&quot; in terms of supporting a similar syntax for single-pass queries. If you used RapidJSON&#x27;s SAX parser in the body of your custom code (returning false once you found what you&#x27;re looking for), I&#x27;m pretty sure it would significantly outperform your custom hand-rolled code. Of course, your custom code is very small with no external dependencies and presumably fast enough, so tradeoffs.</div><br/></div></div></div></div></div></div></div></div><div id="38152663" class="c"><input type="checkbox" id="c-38152663" checked=""/><div class="controls bullet"><span class="by">jjice</span><span>|</span><a href="#38151473">parent</a><span>|</span><a href="#38151808">prev</a><span>|</span><a href="#38151504">next</a><span>|</span><label class="collapse" for="c-38152663">[-]</label><label class="expand" for="c-38152663">[1 more]</label></div><br/><div class="children"><div class="content">I guess there are only so many ways to write a JSON parser b cause one I wrote on a train in Python looks very similar!<p>I thought it would be nice and simple but it really was still simpler than I expected. It&#x27;s a fantastic spec if you need to throw one together yourself, without massive performance considerations.</div><br/></div></div><div id="38151504" class="c"><input type="checkbox" id="c-38151504" checked=""/><div class="controls bullet"><span class="by">xoac</span><span>|</span><a href="#38151473">parent</a><span>|</span><a href="#38152663">prev</a><span>|</span><a href="#38152611">next</a><span>|</span><label class="collapse" for="c-38151504">[-]</label><label class="expand" for="c-38151504">[1 more]</label></div><br/><div class="children"><div class="content">Good for you but what does this have to do with the article?</div><br/></div></div></div></div><div id="38152611" class="c"><input type="checkbox" id="c-38152611" checked=""/><div class="controls bullet"><span class="by">isuckatcoding</span><span>|</span><a href="#38151473">prev</a><span>|</span><a href="#38159827">next</a><span>|</span><label class="collapse" for="c-38152611">[-]</label><label class="expand" for="c-38152611">[1 more]</label></div><br/><div class="children"><div class="content">This is fantastically useful.<p>Funny enough I stumbled upon your article just yesterday through google search.</div><br/></div></div><div id="38159827" class="c"><input type="checkbox" id="c-38159827" checked=""/><div class="controls bullet"><span class="by">hknmtt</span><span>|</span><a href="#38152611">prev</a><span>|</span><a href="#38153074">next</a><span>|</span><label class="collapse" for="c-38159827">[-]</label><label class="expand" for="c-38159827">[1 more]</label></div><br/><div class="children"><div class="content">what does this bring over goccy&#x27;s json encoder?</div><br/></div></div><div id="38153074" class="c"><input type="checkbox" id="c-38153074" checked=""/><div class="controls bullet"><span class="by">nwpierce</span><span>|</span><a href="#38159827">prev</a><span>|</span><a href="#38153579">next</a><span>|</span><label class="collapse" for="c-38153074">[-]</label><label class="expand" for="c-38153074">[1 more]</label></div><br/><div class="children"><div class="content">Writing a json parser is definitely an educational experience. I wrote one this summer for my own purposes that is decently fast: <a href="https:&#x2F;&#x2F;github.com&#x2F;nwpierce&#x2F;jsb">https:&#x2F;&#x2F;github.com&#x2F;nwpierce&#x2F;jsb</a></div><br/></div></div><div id="38153579" class="c"><input type="checkbox" id="c-38153579" checked=""/><div class="controls bullet"><span class="by">suzzer99</span><span>|</span><a href="#38153074">prev</a><span>|</span><a href="#38152384">next</a><span>|</span><label class="collapse" for="c-38153579">[-]</label><label class="expand" for="c-38153579">[13 more]</label></div><br/><div class="children"><div class="content">Can someone explain to me why JSON can&#x27;t have comments or trailing commas? I really hope the performance gains are worth it, because I&#x27;ve lost 100s of man-hours to those things, and had to resort to stuff like this in package.json:<p><pre><code>  &quot;IMPORTANT: do not run the scripts below this line, they are for CICD only&quot;: true,</code></pre></div><br/><div id="38153686" class="c"><input type="checkbox" id="c-38153686" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#38153579">parent</a><span>|</span><a href="#38153784">next</a><span>|</span><label class="collapse" for="c-38153686">[-]</label><label class="expand" for="c-38153686">[9 more]</label></div><br/><div class="children"><div class="content">It can&#x27;t have comments because it didn&#x27;t originally had comments, so now it&#x27;s too late. And it originally didn&#x27;t have comments, because Douglas Cockford thought they could be abused for parsing instructions.<p>As for not having trailing commas, it&#x27;s probably a less intentional bad design choice.<p>That said, if you want commas and comments, and control the parsers that will be used for your JSON, then use JSONC (JSON with comments). VSCode for example does that for its JSON configuration.</div><br/><div id="38154106" class="c"><input type="checkbox" id="c-38154106" checked=""/><div class="controls bullet"><span class="by">explaininjs</span><span>|</span><a href="#38153579">root</a><span>|</span><a href="#38153686">parent</a><span>|</span><a href="#38155336">next</a><span>|</span><label class="collapse" for="c-38154106">[-]</label><label class="expand" for="c-38154106">[1 more]</label></div><br/><div class="children"><div class="content">JSONC also supports trailing commas. It is, in effect, &quot;JSON with no downsides&quot;.<p>TOML&#x2F;Yaml always drive me batty with all their obscure special syntax. Whereas it&#x27;s almost impossible to look at a formatted blob of JSON and not have a very solid understanding of what it represents.<p>The one thing I <i>might</i> add is multiline strings with `&#x27;s, but even that is probably more trouble than it&#x27;s worth, as you immediately start going down the path of &quot;well let&#x27;s also have syntax to strip the indentation from those strings, maybe we should add new syntax to support raw strings, ...&quot;</div><br/></div></div><div id="38155336" class="c"><input type="checkbox" id="c-38155336" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#38153579">root</a><span>|</span><a href="#38153686">parent</a><span>|</span><a href="#38154106">prev</a><span>|</span><a href="#38154332">next</a><span>|</span><label class="collapse" for="c-38155336">[-]</label><label class="expand" for="c-38155336">[1 more]</label></div><br/><div class="children"><div class="content">Amusingly, it originally <i>did</i> have comments. Removing comments was the one change Crockford ever made to the spec[1].<p>[1] <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20150105080225&#x2F;https:&#x2F;&#x2F;plus.google.com&#x2F;+DouglasCrockfordEsq&#x2F;posts&#x2F;RK8qyGVaGSr" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20150105080225&#x2F;https:&#x2F;&#x2F;plus.goog...</a> (thank you Internet Archive for making Googleâs social network somewhat accessible and less than useless)</div><br/></div></div><div id="38154332" class="c"><input type="checkbox" id="c-38154332" checked=""/><div class="controls bullet"><span class="by">tubthumper8</span><span>|</span><a href="#38153579">root</a><span>|</span><a href="#38153686">parent</a><span>|</span><a href="#38155336">prev</a><span>|</span><a href="#38157520">next</a><span>|</span><label class="collapse" for="c-38154332">[-]</label><label class="expand" for="c-38154332">[4 more]</label></div><br/><div class="children"><div class="content">Does JSONC have a specification or formal definition? People have suggested[1] using JSON5[2] instead for that reason<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;vscode&#x2F;issues&#x2F;100688">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;vscode&#x2F;issues&#x2F;100688</a><p>[2] <a href="https:&#x2F;&#x2F;spec.json5.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;spec.json5.org&#x2F;</a></div><br/><div id="38155418" class="c"><input type="checkbox" id="c-38155418" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#38153579">root</a><span>|</span><a href="#38154332">parent</a><span>|</span><a href="#38157520">next</a><span>|</span><label class="collapse" for="c-38155418">[-]</label><label class="expand" for="c-38155418">[3 more]</label></div><br/><div class="children"><div class="content">Unfortunately, JSON5 says keys can be ES5 IdentifierName[1]s, which means you must carry around Unicode tables. This makes it a non-option for small devices, for example. (I mean, not really, you technically <i>could</i> fit the necessary data and code in low single-digit kilobytes, but it feels stupid that you have to. Or you could just not do that but then itâs no longer JSON5 and what was the point of having a spec again?)<p>[1] <a href="https:&#x2F;&#x2F;es5.github.io&#x2F;x7.html#x7.6" rel="nofollow noreferrer">https:&#x2F;&#x2F;es5.github.io&#x2F;x7.html#x7.6</a></div><br/><div id="38156871" class="c"><input type="checkbox" id="c-38156871" checked=""/><div class="controls bullet"><span class="by">debugnik</span><span>|</span><a href="#38153579">root</a><span>|</span><a href="#38155418">parent</a><span>|</span><a href="#38158404">next</a><span>|</span><label class="collapse" for="c-38156871">[-]</label><label class="expand" for="c-38156871">[1 more]</label></div><br/><div class="children"><div class="content">Or take the SQLite route, if you don&#x27;t need to reject strictly invalid JSON5. When they extended SQLite&#x27;s JSON parser to support JSON5, they specifically relaxed the definition of unquoted keys (in a compatible way) to avoid Unicode tables[1]:<p>&gt; Strict JSON5 requires that unquoted object keys must be ECMAScript 5.1 IdentifierNames. But large unicode tables and lots of code is required in order to determine whether or not a key is an ECMAScript 5.1 IdentifierName. For this reason, SQLite allows object keys to include any unicode characters greater than U+007f that are not whitespace characters. This relaxed definition of &quot;identifier&quot; greatly simplifies the implementation and allows the JSON parser to be smaller and run faster.<p>[1]: <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;json1.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.sqlite.org&#x2F;json1.html</a></div><br/></div></div><div id="38158404" class="c"><input type="checkbox" id="c-38158404" checked=""/><div class="controls bullet"><span class="by">tubthumper8</span><span>|</span><a href="#38153579">root</a><span>|</span><a href="#38155418">parent</a><span>|</span><a href="#38156871">prev</a><span>|</span><a href="#38157520">next</a><span>|</span><label class="collapse" for="c-38158404">[-]</label><label class="expand" for="c-38158404">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, definitely for small devices. For things like VS Code&#x27;s configuration file format (the parent comment) or other such use cases, I don&#x27;t see a problem</div><br/></div></div></div></div></div></div><div id="38157520" class="c"><input type="checkbox" id="c-38157520" checked=""/><div class="controls bullet"><span class="by">nigeltao</span><span>|</span><a href="#38153579">root</a><span>|</span><a href="#38153686">parent</a><span>|</span><a href="#38154332">prev</a><span>|</span><a href="#38157147">next</a><span>|</span><label class="collapse" for="c-38157520">[-]</label><label class="expand" for="c-38157520">[1 more]</label></div><br/><div class="children"><div class="content">If you want commas and comments, another term to search for is JWCC, which literally stands for &quot;JSON With Commas and Comments&quot;. HuJSON is another name for it.</div><br/></div></div><div id="38157147" class="c"><input type="checkbox" id="c-38157147" checked=""/><div class="controls bullet"><span class="by">suzzer99</span><span>|</span><a href="#38153579">root</a><span>|</span><a href="#38153686">parent</a><span>|</span><a href="#38157520">prev</a><span>|</span><a href="#38153784">next</a><span>|</span><label class="collapse" for="c-38157147">[-]</label><label class="expand" for="c-38157147">[1 more]</label></div><br/><div class="children"><div class="content">Yeah if you could get NPM to allow JSONC in package.json, that&#x27;d be great.</div><br/></div></div></div></div><div id="38153784" class="c"><input type="checkbox" id="c-38153784" checked=""/><div class="controls bullet"><span class="by">semiquaver</span><span>|</span><a href="#38153579">parent</a><span>|</span><a href="#38153686">prev</a><span>|</span><a href="#38153729">next</a><span>|</span><label class="collapse" for="c-38153784">[-]</label><label class="expand" for="c-38153784">[1 more]</label></div><br/><div class="children"><div class="content">Itâs not that it âcanâtâ, more like it âdoesnâtâ. Douglas Crockford prioritized simplicity when specifying JSON. Its BNF grammar famously fits on one side of a business card.<p>Other flavors of JSON that include support for comments and trailing commas exist, but they are reasonably called by different names. One of these is YAML (mostly a superset of JSON). To some extent the difficulties with YAML (like unquoted ânoâ being a synonym for false) have vindicated Crockfordâs priorities.</div><br/></div></div><div id="38153729" class="c"><input type="checkbox" id="c-38153729" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#38153579">parent</a><span>|</span><a href="#38153784">prev</a><span>|</span><a href="#38156995">next</a><span>|</span><label class="collapse" for="c-38153729">[-]</label><label class="expand" for="c-38153729">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know the historic reason why it wasn&#x27;t included in the original spec, but at this point it doesn&#x27;t matter. JSON is entrenched and not going to change.<p>If you want comments, you can always use jsonc.</div><br/></div></div><div id="38156995" class="c"><input type="checkbox" id="c-38156995" checked=""/><div class="controls bullet"><span class="by">crabbone</span><span>|</span><a href="#38153579">parent</a><span>|</span><a href="#38153729">prev</a><span>|</span><a href="#38152384">next</a><span>|</span><label class="collapse" for="c-38156995">[-]</label><label class="expand" for="c-38156995">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no real reason for that.  It just happened like that.  These aren&#x27;t the only bad decisions made by JSON author, and not the worst either.<p>What you can do is: write comments using pound sign, and rename your files to YAML.  You will also get a benefit of a million ways of writing multiline strings -- very confusing, but sometimes useful.</div><br/></div></div></div></div><div id="38152076" class="c"><input type="checkbox" id="c-38152076" checked=""/><div class="controls bullet"><span class="by">mannyv</span><span>|</span><a href="#38152384">prev</a><span>|</span><a href="#38154311">next</a><span>|</span><label class="collapse" for="c-38152076">[-]</label><label class="expand" for="c-38152076">[1 more]</label></div><br/><div class="children"><div class="content">These are always interesting to read because you get to see runtime quirks. I&#x27;m surprised there was so much function call overhead, for example. And it&#x27;s interesting you can bypass range checkong.<p>The most important thing, though, is the process: measure then optimize.</div><br/></div></div><div id="38154311" class="c"><input type="checkbox" id="c-38154311" checked=""/><div class="controls bullet"><span class="by">hintymad</span><span>|</span><a href="#38152076">prev</a><span>|</span><a href="#38153174">next</a><span>|</span><label class="collapse" for="c-38154311">[-]</label><label class="expand" for="c-38154311">[1 more]</label></div><br/><div class="children"><div class="content">How is this compared to Daniel Lemire&#x27;s simdjson? <a href="https:&#x2F;&#x2F;github.com&#x2F;simdjson&#x2F;simdjson">https:&#x2F;&#x2F;github.com&#x2F;simdjson&#x2F;simdjson</a></div><br/></div></div><div id="38153174" class="c"><input type="checkbox" id="c-38153174" checked=""/><div class="controls bullet"><span class="by">lamontcg</span><span>|</span><a href="#38154311">prev</a><span>|</span><a href="#38150849">next</a><span>|</span><label class="collapse" for="c-38153174">[-]</label><label class="expand" for="c-38153174">[1 more]</label></div><br/><div class="children"><div class="content">Wish I wasn&#x27;t 4 or 5 uncompleted projects deep right now and had the time to rewrite a monkey parser using all these tricks.</div><br/></div></div><div id="38150849" class="c"><input type="checkbox" id="c-38150849" checked=""/><div class="controls bullet"><span class="by">denysvitali</span><span>|</span><a href="#38153174">prev</a><span>|</span><a href="#38151140">next</a><span>|</span><label class="collapse" for="c-38150849">[-]</label><label class="expand" for="c-38150849">[1 more]</label></div><br/><div class="children"><div class="content">Also interesting:
<a href="https:&#x2F;&#x2F;youtu.be&#x2F;a7VBbbcmxyQ" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;a7VBbbcmxyQ</a></div><br/></div></div><div id="38151140" class="c"><input type="checkbox" id="c-38151140" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#38150849">prev</a><span>|</span><a href="#38156866">next</a><span>|</span><label class="collapse" for="c-38151140">[-]</label><label class="expand" for="c-38151140">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised there&#x27;s no way to say &#x27;I really mean it, inline this function&#x27; for the stuff that didn&#x27;t inline because it was too big.<p>The baseline whitespace count&#x2F;search operation seems like it would be MUCH faster if you vectorized it with SIMD, but I can understand that being out of scope for the author.</div><br/><div id="38152223" class="c"><input type="checkbox" id="c-38152223" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#38151140">parent</a><span>|</span><a href="#38156866">next</a><span>|</span><label class="collapse" for="c-38152223">[-]</label><label class="expand" for="c-38152223">[5 more]</label></div><br/><div class="children"><div class="content">Of course you can force-inline.</div><br/><div id="38152700" class="c"><input type="checkbox" id="c-38152700" checked=""/><div class="controls bullet"><span class="by">cbarrick</span><span>|</span><a href="#38151140">root</a><span>|</span><a href="#38152223">parent</a><span>|</span><a href="#38156866">next</a><span>|</span><label class="collapse" for="c-38152700">[-]</label><label class="expand" for="c-38152700">[4 more]</label></div><br/><div class="children"><div class="content">Obviously you can manually inline functions. That&#x27;s what happened in the article.<p>The comment is about having a directive or annotation to make the compiler inline the function for you, which Go does not have. IMO, the pre-inline code was cleaner to me. It&#x27;s a shame that the compiler could not optimize it.<p>There was once a proposal for this, but it&#x27;s really against Go&#x27;s design as a language.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;21536">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;21536</a></div><br/><div id="38153923" class="c"><input type="checkbox" id="c-38153923" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#38151140">root</a><span>|</span><a href="#38152700">parent</a><span>|</span><a href="#38156866">next</a><span>|</span><label class="collapse" for="c-38153923">[-]</label><label class="expand" for="c-38153923">[3 more]</label></div><br/><div class="children"><div class="content">You can in any systems programming language.<p>Go is mostly a toy language for cloud people.</div><br/><div id="38154568" class="c"><input type="checkbox" id="c-38154568" checked=""/><div class="controls bullet"><span class="by">cbarrick</span><span>|</span><a href="#38151140">root</a><span>|</span><a href="#38153923">parent</a><span>|</span><a href="#38156866">next</a><span>|</span><label class="collapse" for="c-38154568">[-]</label><label class="expand" for="c-38154568">[2 more]</label></div><br/><div class="children"><div class="content">&gt; toy language<p>You may be surprised to hear that Go is used in a ton of large scale critical systems.</div><br/><div id="38155682" class="c"><input type="checkbox" id="c-38155682" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#38151140">root</a><span>|</span><a href="#38154568">parent</a><span>|</span><a href="#38156866">next</a><span>|</span><label class="collapse" for="c-38155682">[-]</label><label class="expand" for="c-38155682">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t consider cloud technology a critical system.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38156866" class="c"><input type="checkbox" id="c-38156866" checked=""/><div class="controls bullet"><span class="by">crabbone</span><span>|</span><a href="#38151140">prev</a><span>|</span><a href="#38158663">next</a><span>|</span><label class="collapse" for="c-38156866">[-]</label><label class="expand" for="c-38156866">[1 more]</label></div><br/><div class="children"><div class="content">Maybe I overlooked something, but the author keeps repeating that they wrote a &quot;streaming&quot; parser, but never explained what that actually means.  In particular, they never explained how did they deal with repeating keys in &quot;hash tables&quot;.  What does their parser do?  Calls the &quot;sink&quot; code twice with the repeated key?  Waits until the entire &quot;hash table&quot; is red and then calls the &quot;sink&quot; code?<p>In my mind, JSON is inherently inadequate for streaming because of hierarchical structure, no length know upfront and most importantly, repeating keys.  You could probably make a subset of JSON more streaming-friendly, but at this point, why bother?  I mean, if the solution is to modify JSON, then a better solution would be something that&#x27;s not JSON at all.</div><br/></div></div><div id="38158663" class="c"><input type="checkbox" id="c-38158663" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#38156866">prev</a><span>|</span><a href="#38153844">next</a><span>|</span><label class="collapse" for="c-38158663">[-]</label><label class="expand" for="c-38158663">[1 more]</label></div><br/><div class="children"><div class="content">My favorite bit about this is his reference to John Ousterhout, Define errors out of existence. youtu.be&#x2F;bmSAYlu0NcY?si=WjC1ouEN1ad2OWjp&amp;t=1312<p>Note the distinct lack of:<p><pre><code>    if err != nil {</code></pre></div><br/></div></div><div id="38153844" class="c"><input type="checkbox" id="c-38153844" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#38158663">prev</a><span>|</span><a href="#38150937">next</a><span>|</span><label class="collapse" for="c-38153844">[-]</label><label class="expand" for="c-38153844">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Any (useful) JSON decoder code cannot go faster that this.<p>That line feels like a troll. Cunninghamâs Law in action.<p>You can definitely go faster than 2 Gb&#x2F;sec. In a word, SIMD.</div><br/><div id="38155825" class="c"><input type="checkbox" id="c-38155825" checked=""/><div class="controls bullet"><span class="by">shoo</span><span>|</span><a href="#38153844">parent</a><span>|</span><a href="#38150937">next</a><span>|</span><label class="collapse" for="c-38155825">[-]</label><label class="expand" for="c-38155825">[2 more]</label></div><br/><div class="children"><div class="content">we could re-frame by distinguishing problem statements from implementations<p>Problem A:  read a stream of bytes, parse it as JSON<p>Problem B:  read a stream of bytes, count how many bytes match a JSON whitespace character<p>Problem B should require fewer resources* to solve than problem A.  So in that sense problem B is a relaxation of problem A, and a highly efficient implementation of problem B should be able to process bytes much more efficiently than an &quot;optimal&quot; implementation of problem A.<p>So in this sense, we can probably all agree with the author that counting whitespace bytes is an easier problem than the full parsing problem.<p>We&#x27;re agreed that the author&#x27;s implementation (half a page of go code that fits on a talk slide) to solve problem B isn&#x27;t the most efficient way to solve problem B.<p>I remember reading somewhere the advice that to set a really solid target for benchmarking, you should avoid measuring the performance of implementations and instead try to estimate a theoretical upper bound on performance, based on say a simplified model of how the hardware works and a simplification of the problem -- that hopefully still captures the essence of what the bottleneck is. Then you can compare any implementation to that (unreachable) theoretical upper bound, to get more of an idea of how much performance is still left on the table.<p>* for reasonably boring choices of target platform, e.g. amd64 + ram, not some hypothetical hardware platform with surprisingly fast dedicated support for JSON parsing and bad support for anything else.</div><br/><div id="38157823" class="c"><input type="checkbox" id="c-38157823" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#38153844">root</a><span>|</span><a href="#38155825">parent</a><span>|</span><a href="#38150937">next</a><span>|</span><label class="collapse" for="c-38157823">[-]</label><label class="expand" for="c-38157823">[1 more]</label></div><br/><div class="children"><div class="content">Everything you said is totally reasonable. I&#x27;m a big fan of napkin math and theoretical upper bounds on performance.<p>simdjson (<a href="https:&#x2F;&#x2F;github.com&#x2F;simdjson&#x2F;simdjson">https:&#x2F;&#x2F;github.com&#x2F;simdjson&#x2F;simdjson</a>) claims to fully parse JSON on the order of 3 GB&#x2F;sec. Which is faster than OP&#x27;s Go whitespace parsing! These tests are running on different hardware so it&#x27;s not apples-to-apples.<p>The phrase &quot;cannot go faster than this&quot; is just begging for a &quot;well ackshully&quot;. Which I hate to do. But the fact that there is an existence proof of Problem A running faster in C++ SIMD than OP&#x27;s Probably B scalar Go is quite interesting and worth calling out imho. But I admit it doesn&#x27;t change the rest of the post.</div><br/></div></div></div></div></div></div><div id="38151621" class="c"><input type="checkbox" id="c-38151621" checked=""/><div class="controls bullet"><span class="by">visarga</span><span>|</span><a href="#38150937">prev</a><span>|</span><label class="collapse" for="c-38151621">[-]</label><label class="expand" for="c-38151621">[7 more]</label></div><br/><div class="children"><div class="content">nowadays I am more interested in a &quot;forgiving&quot; JSON&#x2F;YAML parser, that would recover from LLM errors, is there such a thing?</div><br/><div id="38152466" class="c"><input type="checkbox" id="c-38152466" checked=""/><div class="controls bullet"><span class="by">explaininjs</span><span>|</span><a href="#38151621">parent</a><span>|</span><a href="#38151829">next</a><span>|</span><label class="collapse" for="c-38152466">[-]</label><label class="expand" for="c-38152466">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps not quite what you&#x27;re asking for, but along the same lines there&#x27;s this &quot;Incomplete JSON&quot; parser, which takes a string of JSON as it&#x27;s coming out of an LLM and parses it into as much data as it can get. Useful for building streaming UI&#x27;s, for instance it is used on <a href="https:&#x2F;&#x2F;rexipie.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;rexipie.com</a> quite extensively.<p><a href="https:&#x2F;&#x2F;gist.github.com&#x2F;JacksonKearl&#x2F;6778c02bf85495d1e39291c0f7b9ea9c" rel="nofollow noreferrer">https:&#x2F;&#x2F;gist.github.com&#x2F;JacksonKearl&#x2F;6778c02bf85495d1e39291c...</a><p>Some example test cases:<p><pre><code>    { input: &#x27;[{&quot;a&quot;: 0, &quot;b&quot;:&#x27;, output: [{ a: 0 }] },
    { input: &#x27;[{&quot;a&quot;: 0, &quot;b&quot;: 1&#x27;, output: [{ a: 0, b: 1 }] },

    { input: &quot;[{},&quot;, output: [{}] },
    { input: &quot;[{},1&quot;, output: [{}, 1] },
    { input: &#x27;[{},&quot;&#x27;, output: [{}, &quot;&quot;] },
    { input: &#x27;[{},&quot;abc&#x27;, output: [{}, &quot;abc&quot;] },
</code></pre>
Work could be done to optimize it, for instance add streaming support. But the cycles consumed either way is minimal for LLM-output-length=constrained JSON.<p>Fun fact: as best I can tell, GPT-4 is entirely unable to synthesize code to accomplish this task. Perhaps that will change as this implementation is made public, I do not know.</div><br/></div></div><div id="38151829" class="c"><input type="checkbox" id="c-38151829" checked=""/><div class="controls bullet"><span class="by">RichieAHB</span><span>|</span><a href="#38151621">parent</a><span>|</span><a href="#38152466">prev</a><span>|</span><a href="#38151646">next</a><span>|</span><label class="collapse" for="c-38151829">[-]</label><label class="expand" for="c-38151829">[1 more]</label></div><br/><div class="children"><div class="content">I feel like trying to infer valid JSON from invalid JSON  is a recipe for garbage. Youâd probably be better off doing a second pass with the âJSONâ through the LLM but, as the sibling commenter said, at this point even the good JSON may be garbage â¦</div><br/></div></div><div id="38151646" class="c"><input type="checkbox" id="c-38151646" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#38151621">parent</a><span>|</span><a href="#38151829">prev</a><span>|</span><a href="#38152500">next</a><span>|</span><label class="collapse" for="c-38151646">[-]</label><label class="expand" for="c-38151646">[1 more]</label></div><br/><div class="children"><div class="content">If the LLM did such a bad job that the syntax is wrong, do you really trust the data inside?<p>Forgiving parsers&#x2F;lexers are common in language compilers for languages like rust or C# or typescript, you may want to investigate typescript in particular since it&#x27;s applicable to JSON syntax. Maybe you could repurpose their parser.</div><br/></div></div><div id="38152500" class="c"><input type="checkbox" id="c-38152500" checked=""/><div class="controls bullet"><span class="by">gurrasson</span><span>|</span><a href="#38151621">parent</a><span>|</span><a href="#38151646">prev</a><span>|</span><a href="#38152352">next</a><span>|</span><label class="collapse" for="c-38152500">[-]</label><label class="expand" for="c-38152500">[2 more]</label></div><br/><div class="children"><div class="content">The jsonrepair tool <a href="https:&#x2F;&#x2F;github.com&#x2F;josdejong&#x2F;jsonrepair">https:&#x2F;&#x2F;github.com&#x2F;josdejong&#x2F;jsonrepair</a> might interest you. It&#x27;s tailored to fix JSON strings.<p>I&#x27;ve been looking into something similar for handling partial JSONs, where you only have the first n chars of a JSON. This is common with LLM with streamed outputs aimed at reducing latency. If one knows the JSON schema ahead, then one can start processing these first fields before the remaining data has fully loaded. If you have to wait for the whole thing to load there is little point in streaming.<p>Was looking for a library that could do this parsing.</div><br/><div id="38152537" class="c"><input type="checkbox" id="c-38152537" checked=""/><div class="controls bullet"><span class="by">explaininjs</span><span>|</span><a href="#38151621">root</a><span>|</span><a href="#38152500">parent</a><span>|</span><a href="#38152352">next</a><span>|</span><label class="collapse" for="c-38152537">[-]</label><label class="expand" for="c-38152537">[1 more]</label></div><br/><div class="children"><div class="content">See my sibling comment :)</div><br/></div></div></div></div><div id="38152352" class="c"><input type="checkbox" id="c-38152352" checked=""/><div class="controls bullet"><span class="by">_dain_</span><span>|</span><a href="#38151621">parent</a><span>|</span><a href="#38152500">prev</a><span>|</span><label class="collapse" for="c-38152352">[-]</label><label class="expand" for="c-38152352">[1 more]</label></div><br/><div class="children"><div class="content">halloween was last week</div><br/></div></div></div></div></div></div></div></div></div></body></html>