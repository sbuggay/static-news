<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721206870077" as="style"/><link rel="stylesheet" href="styles.css?v=1721206870077"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.magiroux.com/eight-years-of-graphql">Eight Years of GraphQL</a> <span class="domain">(<a href="https://www.magiroux.com">www.magiroux.com</a>)</span></div><div class="subtext"><span>fagnerbrack</span> | <span>48 comments</span></div><br/><div><div id="40983098" class="c"><input type="checkbox" id="c-40983098" checked=""/><div class="controls bullet"><span class="by">georgyo</span><span>|</span><a href="#40983193">next</a><span>|</span><label class="collapse" for="c-40983098">[-]</label><label class="expand" for="c-40983098">[28 more]</label></div><br/><div class="children"><div class="content">Wait, people are using graphql for private, not exposed, backend apis?<p>Who would torture themselves like that?<p>Isn&#x27;t the whole point that your frontend can make the exact queries it needs and load the exact data it needs?<p>Namely, last I checked, client libraries for working with graphql are only good with JS. I tried working with graphql a few years ago in python and the only two client libraries absolutely sucked. Server libraries were great, but python clients sucked, badly. I ended up writing bare requests with a hardcoded heredoc for the query and endless square brackets to get the fields for the little data I needed.<p>Maybe the situation improved dramatically in the last three years, but I can&#x27;t imagine so dramatically.<p>I wouldn&#x27;t pick graphql as a private backend API in a million years. Well, maybe if ever single service was written in nodejs with no possibility of using other languages.</div><br/><div id="40983503" class="c"><input type="checkbox" id="c-40983503" checked=""/><div class="controls bullet"><span class="by">deergomoo</span><span>|</span><a href="#40983098">parent</a><span>|</span><a href="#40983609">next</a><span>|</span><label class="collapse" for="c-40983503">[-]</label><label class="expand" for="c-40983503">[2 more]</label></div><br/><div class="children"><div class="content">I remain unconvinced that GraphQL is the tech we should have chosen, but we’re using it privately to mesh together subgraphs from different teams’ various areas of concern and it seems to be working pretty well. There’s been talk of opening it up to clients, but the idea of trying to apply a permission&#x2F;access control layer is nightmare material.<p>As for language support, I’ve used a couple of libraries on both the client and server side for both Go and PHP, and they seem pretty good. JavaScript&#x2F;TypeScript definitely seem to be the first-class citizens though.</div><br/><div id="40983564" class="c"><input type="checkbox" id="c-40983564" checked=""/><div class="controls bullet"><span class="by">throwaway3306a</span><span>|</span><a href="#40983098">root</a><span>|</span><a href="#40983503">parent</a><span>|</span><a href="#40983609">next</a><span>|</span><label class="collapse" for="c-40983564">[-]</label><label class="expand" for="c-40983564">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but the idea of trying to apply a permission&#x2F;access control layer is nightmare material.<p>In your case of many disparate services, the nightmare is just the same with REST.</div><br/></div></div></div></div><div id="40983609" class="c"><input type="checkbox" id="c-40983609" checked=""/><div class="controls bullet"><span class="by">ecjhdnc2025</span><span>|</span><a href="#40983098">parent</a><span>|</span><a href="#40983503">prev</a><span>|</span><a href="#40983148">next</a><span>|</span><label class="collapse" for="c-40983609">[-]</label><label class="expand" for="c-40983609">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Who would torture themselves like that?<p>It&#x27;s not really torture. I do. I have built a private federation API in a system where there&#x27;s a &quot;mothership&quot; service that needs to talk to individual websites.<p>Those websites are WordPress at the moment but they may be Magento, PrestaShop or whatever in the future.<p>GraphQL means I can <i>template</i> the API calls used to keep them in sync with the mothership. It&#x27;s awesome.<p>I also use it for the frontend&#x2F;backend connection of a couple of admin APIs and an intranet app.<p>Nuxt frontends, Laravel&#x2F;Lighthouse headless backends. The only pain point is the unnecessarily complex Apollo stuff in the client, but that gives you really nice smart queries in Nuxt 2; it may not be that crucial in Vue 3&#x2F;Nuxt 3.</div><br/></div></div><div id="40983148" class="c"><input type="checkbox" id="c-40983148" checked=""/><div class="controls bullet"><span class="by">tossandthrow</span><span>|</span><a href="#40983098">parent</a><span>|</span><a href="#40983609">prev</a><span>|</span><a href="#40983447">next</a><span>|</span><label class="collapse" for="c-40983148">[-]</label><label class="expand" for="c-40983148">[3 more]</label></div><br/><div class="children"><div class="content">Pothos + graphql Zeus gives us the ability to expose a prisma like interface to the clients with the ability to curate what fields are exposed and maintain the ability to setup field level security.<p>Oh, and we get DB schema to frontend propagation of changes to the type.<p>This is by far the best experience I have had for <i>private</i> APIs - Where we don&#x27;t need to maintain backwards compatability.<p>I do get that the HN crowd is super adverse to graphql, but I fail to see other arguments than matters of taste.</div><br/><div id="40983498" class="c"><input type="checkbox" id="c-40983498" checked=""/><div class="controls bullet"><span class="by">vosper</span><span>|</span><a href="#40983098">root</a><span>|</span><a href="#40983148">parent</a><span>|</span><a href="#40983447">next</a><span>|</span><label class="collapse" for="c-40983498">[-]</label><label class="expand" for="c-40983498">[2 more]</label></div><br/><div class="children"><div class="content">Would you consider this solution for a public (enterprise&#x2F;B2B, not public-on-the-internet-for-anyone) API? I may need to build a public API that lets customers select certain fields from a variety of objects with many fields.</div><br/><div id="40983641" class="c"><input type="checkbox" id="c-40983641" checked=""/><div class="controls bullet"><span class="by">tossandthrow</span><span>|</span><a href="#40983098">root</a><span>|</span><a href="#40983498">parent</a><span>|</span><a href="#40983447">next</a><span>|</span><label class="collapse" for="c-40983641">[-]</label><label class="expand" for="c-40983641">[1 more]</label></div><br/><div class="children"><div class="content">Hmm, this is a really good questions and would definitely require a bit more information about the customer relation to fully answer.<p>In a setup where you can deprecate fields and remove them after X weeks I think it could wor well - My impression is just not that enterprise works like that?<p>I would probably go the route of having fully versioned APIs in the specific setup (GraphQl or not) - which is something that would be a hassle with a tight coupling between the Prisma schema and the GraphQl schema as proposed.<p>Thinking about it, all the situations where I have successfully used GraphQL, there has been a relatively tight coupling between the database schema and the graphQl schema. Previously it has been Ecto + Absinthe + Zeus (Elixir on the backend).</div><br/></div></div></div></div></div></div><div id="40983447" class="c"><input type="checkbox" id="c-40983447" checked=""/><div class="controls bullet"><span class="by">JoRyGu</span><span>|</span><a href="#40983098">parent</a><span>|</span><a href="#40983148">prev</a><span>|</span><a href="#40983243">next</a><span>|</span><label class="collapse" for="c-40983447">[-]</label><label class="expand" for="c-40983447">[1 more]</label></div><br/><div class="children"><div class="content">We use it for an application that aggregates data for consumption by several different teams that all consume different subsets of the data. When you have a pretty simple use-case it&#x27;s really not that bad to get a decently functioning API off the ground, and because it&#x27;s self-documenting we can spend our time on more mission critical work.</div><br/></div></div><div id="40983243" class="c"><input type="checkbox" id="c-40983243" checked=""/><div class="controls bullet"><span class="by">lijok</span><span>|</span><a href="#40983098">parent</a><span>|</span><a href="#40983447">prev</a><span>|</span><a href="#40983434">next</a><span>|</span><label class="collapse" for="c-40983243">[-]</label><label class="expand" for="c-40983243">[8 more]</label></div><br/><div class="children"><div class="content">Can’t understand people’s obsession with client libraries. What need is there for a graphql client? Why is writing raw queries insufficient?</div><br/><div id="40983288" class="c"><input type="checkbox" id="c-40983288" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#40983098">root</a><span>|</span><a href="#40983243">parent</a><span>|</span><a href="#40983434">next</a><span>|</span><label class="collapse" for="c-40983288">[-]</label><label class="expand" for="c-40983288">[7 more]</label></div><br/><div class="children"><div class="content">Because people like to use typed languages and in that case writing raw queries makes you work against the typesystem essentially.</div><br/><div id="40983401" class="c"><input type="checkbox" id="c-40983401" checked=""/><div class="controls bullet"><span class="by">JoeyJoJoJr</span><span>|</span><a href="#40983098">root</a><span>|</span><a href="#40983288">parent</a><span>|</span><a href="#40983348">next</a><span>|</span><label class="collapse" for="c-40983401">[-]</label><label class="expand" for="c-40983401">[4 more]</label></div><br/><div class="children"><div class="content">If you use OpenAPI&#x2F;Swagger you can most likely generate the client code along with the types. I use the npm package below, and it just seems to work simply without any headaches.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;hey-api&#x2F;openapi-ts">https:&#x2F;&#x2F;github.com&#x2F;hey-api&#x2F;openapi-ts</a></div><br/><div id="40983465" class="c"><input type="checkbox" id="c-40983465" checked=""/><div class="controls bullet"><span class="by">tossandthrow</span><span>|</span><a href="#40983098">root</a><span>|</span><a href="#40983401">parent</a><span>|</span><a href="#40983348">next</a><span>|</span><label class="collapse" for="c-40983465">[-]</label><label class="expand" for="c-40983465">[3 more]</label></div><br/><div class="children"><div class="content">so ..  a matter of taste? Sure you enjoy swagger over the numerous GQL code gen alternatives.</div><br/><div id="40983590" class="c"><input type="checkbox" id="c-40983590" checked=""/><div class="controls bullet"><span class="by">JoeyJoJoJr</span><span>|</span><a href="#40983098">root</a><span>|</span><a href="#40983465">parent</a><span>|</span><a href="#40983348">next</a><span>|</span><label class="collapse" for="c-40983590">[-]</label><label class="expand" for="c-40983590">[2 more]</label></div><br/><div class="children"><div class="content">I was responding to your point specifically about manually writing code in typed languages, highlighting that there are solutions to avoid that. I am not dismissing your use of GraphQL.</div><br/><div id="40983666" class="c"><input type="checkbox" id="c-40983666" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#40983098">root</a><span>|</span><a href="#40983590">parent</a><span>|</span><a href="#40983348">next</a><span>|</span><label class="collapse" for="c-40983666">[-]</label><label class="expand" for="c-40983666">[1 more]</label></div><br/><div class="children"><div class="content">First, that was not me who you just responded to.<p>Second, I don&#x27;t think it&#x27;s very comparable. The big drawback of &quot;RESTful APIs&quot; is that you cannot combine things. You call an endpoint and you add some query parameters, that&#x27;s pretty much it.<p>In Graphql, you can combine and even nest queries. You simply cannot (or don&#x27;t want to) generate all combinations in advance, so you&#x27;ll decide adhoc in your code. Therefore you need a library that can do these combinations adhoc for you in a typesafe way.</div><br/></div></div></div></div></div></div></div></div><div id="40983348" class="c"><input type="checkbox" id="c-40983348" checked=""/><div class="controls bullet"><span class="by">lijok</span><span>|</span><a href="#40983098">root</a><span>|</span><a href="#40983288">parent</a><span>|</span><a href="#40983401">prev</a><span>|</span><a href="#40983434">next</a><span>|</span><label class="collapse" for="c-40983348">[-]</label><label class="expand" for="c-40983348">[2 more]</label></div><br/><div class="children"><div class="content">I see, so bindings for gql constructs is what we’re after?</div><br/><div id="40983483" class="c"><input type="checkbox" id="c-40983483" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#40983098">root</a><span>|</span><a href="#40983348">parent</a><span>|</span><a href="#40983434">next</a><span>|</span><label class="collapse" for="c-40983483">[-]</label><label class="expand" for="c-40983483">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. But since gql is very flexible, you then also want to combine them in an adhoc way but still get the right structure&#x2F;types back. Then there is also batching, reusing inputs and so on, so ultimately a library saves a lot of time and effort when things grow bigger.</div><br/></div></div></div></div></div></div></div></div><div id="40983434" class="c"><input type="checkbox" id="c-40983434" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#40983098">parent</a><span>|</span><a href="#40983243">prev</a><span>|</span><a href="#40983399">next</a><span>|</span><label class="collapse" for="c-40983434">[-]</label><label class="expand" for="c-40983434">[1 more]</label></div><br/><div class="children"><div class="content">I think the public&#x2F;private distinction here is more in &quot;officially allowed for public use&quot; vs &quot;API your frontend uses but is not documented for public use&quot;. Obviously security is still a thing, but having good ergonomics for your frontend devs means your frontend devs can just work forward and backend people can focus on other things instead of going back and forth on perf issues downstream of REST APIs</div><br/></div></div><div id="40983399" class="c"><input type="checkbox" id="c-40983399" checked=""/><div class="controls bullet"><span class="by">alexchamberlain</span><span>|</span><a href="#40983098">parent</a><span>|</span><a href="#40983434">prev</a><span>|</span><a href="#40983163">next</a><span>|</span><label class="collapse" for="c-40983399">[-]</label><label class="expand" for="c-40983399">[1 more]</label></div><br/><div class="children"><div class="content">I wrote a series of backend, internal GraphQL APIs. I think the argument of &quot;make the exact queries it needs and load the exact data it needs&quot; actually applies _more_ to internal APIs than to frontends, where I personally prefer a well schema&#x27;d BFF pattern. We did face some performance issues with some of the server libraries, unfortunately, but the backend development team were extremely productive in comparison to supporting multiple API shapes.</div><br/></div></div><div id="40983163" class="c"><input type="checkbox" id="c-40983163" checked=""/><div class="controls bullet"><span class="by">joeldo</span><span>|</span><a href="#40983098">parent</a><span>|</span><a href="#40983399">prev</a><span>|</span><a href="#40983259">next</a><span>|</span><label class="collapse" for="c-40983163">[-]</label><label class="expand" for="c-40983163">[1 more]</label></div><br/><div class="children"><div class="content">I think there is some confusion with the term &#x27;public&#x27; here.<p>The Graphql server itself is still publicly exposed to the internet, but the ability to query is not. Queries have to be whitelisted ahead of time (persisted queries).</div><br/></div></div><div id="40983259" class="c"><input type="checkbox" id="c-40983259" checked=""/><div class="controls bullet"><span class="by">rapsey</span><span>|</span><a href="#40983098">parent</a><span>|</span><a href="#40983163">prev</a><span>|</span><a href="#40983182">next</a><span>|</span><label class="collapse" for="c-40983259">[-]</label><label class="expand" for="c-40983259">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Who would torture themselves like that?<p>Because people love chasing tech fads.</div><br/></div></div><div id="40983182" class="c"><input type="checkbox" id="c-40983182" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#40983098">parent</a><span>|</span><a href="#40983259">prev</a><span>|</span><a href="#40983236">next</a><span>|</span><label class="collapse" for="c-40983182">[-]</label><label class="expand" for="c-40983182">[1 more]</label></div><br/><div class="children"><div class="content">You’d be amazed at how much self-inflicted difficulties developers are willing to subject themselves to in the name of doing things in the same way that a FAANG does.</div><br/></div></div><div id="40983236" class="c"><input type="checkbox" id="c-40983236" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#40983098">parent</a><span>|</span><a href="#40983182">prev</a><span>|</span><a href="#40983150">next</a><span>|</span><label class="collapse" for="c-40983236">[-]</label><label class="expand" for="c-40983236">[6 more]</label></div><br/><div class="children"><div class="content">This is nonsense. GraphQL queries are simple HTTP requests, with no more complexity than REST. You POST a query string and some JSON and it’s done. If your client makes it harder than that, don’t use it.<p>Here’s my workflow for creating an API with Postgraphile:<p><pre><code>    create view graphql.object as select some,columns from table;
</code></pre>
(That’s it)<p>It’s trivial to query it with curl, I’d give an example but I’m afk rn.<p>I’ve been using GraphQL for about the same amount of time as in the article and it solved a bunch of problems for me.<p>It’s so easy to use, and saves so much time - once you spend the time to understand it.</div><br/><div id="40983321" class="c"><input type="checkbox" id="c-40983321" checked=""/><div class="controls bullet"><span class="by">dudus</span><span>|</span><a href="#40983098">root</a><span>|</span><a href="#40983236">parent</a><span>|</span><a href="#40983425">next</a><span>|</span><label class="collapse" for="c-40983321">[-]</label><label class="expand" for="c-40983321">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve veen reading about graphql forever and never understood it. Your comment finally made it click for me. Do you happen to have any more documentation around your method of working?</div><br/><div id="40983423" class="c"><input type="checkbox" id="c-40983423" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#40983098">root</a><span>|</span><a href="#40983321">parent</a><span>|</span><a href="#40983425">next</a><span>|</span><label class="collapse" for="c-40983423">[-]</label><label class="expand" for="c-40983423">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately I’m on a bus to the airport for a couple of days so I’m a bit constrained.<p>If you know Postgres, I would recommend taking a look at Postgraphile. It’s awesome, and comes with an explorer web UI that really helps (GraphIQL with extras). Everything happens in real time. so if you update a view, the UI updates.<p>There are lots of GraphQL clients but many of them do all sorts of crap you don’t need. I just use graphql-request which is super simple. But of course you can just use fetch() too.<p>There are also lots of “standards” for GraphQL that make it seem more complex than it is. Ignore that stuff and just start playing with a good server like Postgraphile.<p>Good luck!</div><br/></div></div></div></div><div id="40983425" class="c"><input type="checkbox" id="c-40983425" checked=""/><div class="controls bullet"><span class="by">megadal</span><span>|</span><a href="#40983098">root</a><span>|</span><a href="#40983236">parent</a><span>|</span><a href="#40983321">prev</a><span>|</span><a href="#40983150">next</a><span>|</span><label class="collapse" for="c-40983425">[-]</label><label class="expand" for="c-40983425">[3 more]</label></div><br/><div class="children"><div class="content">&gt; This is nonsense. GraphQL queries are simple HTTP requests, with no more complexity than REST. You POST a query string and some JSON<p>The complexity of GraphQL in fact begins there, and also sort of explains a lot of why GraphQL is all but simple:
Why am I using a query language instead of just passing an AST via JSON, a data format every general purpose language supports very well these days?<p>The answer to the above question, and most of GraphQLs other complexities: Some arbitrary design decision.<p>Another example:
GraphQL could&#x27;ve easily been expressed as a REST API, even an Open API. From what I have seen, with the help of VC backing and FAANG endorsement, GraphQL mostly rose to replace JSON:API, which accomplishes pretty much all of the same goals in just JSON (and is RESTful).<p>One big issue of GraphQL is also that API clients tend to suck. That&#x27;s not a problem for OpenAPIs.<p>And again, why is this the case? <i>Some arbitrary design decision.</i><p>I feel like in general, someone creating a new DSL where it&#x27;s not needed (and is obviously designed to look cool rather than actually be expressive), is a good sign they&#x27;re just writing the software to stroke their ego rather than reach a meaningful end.<p>That&#x27;s why in all the promo material for GraphQL you only see the query language, and not all of the actual setup required to send a request or even what an actual GraphQL HTTP request looks like. GraphQL, the framework, is not actually as simple and elegant as GraphQL the query language attempts to portray it as.<p>It&#x27;s almost like someone came up with a query language for fun then came up with all the details of how a web server would utilize it afterwards.<p>Even today, GraphQL markets itself only as a query language (<i>A query language for your API</i>). When, as you have already mentioned, it is more than that.<p>That&#x27;s why most developers know vaguely what GraphQL is (&quot;Oh, that one language&quot;) but not how it actually works in practice. And when they actually encounter it, it feels almost like a betrayal, because it&#x27;s nowhere near as simple, sleek or elegant as all the marketing they saw suggested.<p>At least, this was my experience when having to deal with a 
third party GraphQL API (funny enough, they migrated from REST, see ShipHero).</div><br/><div id="40983611" class="c"><input type="checkbox" id="c-40983611" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#40983098">root</a><span>|</span><a href="#40983425">parent</a><span>|</span><a href="#40983150">next</a><span>|</span><label class="collapse" for="c-40983611">[-]</label><label class="expand" for="c-40983611">[2 more]</label></div><br/><div class="children"><div class="content">These are just assertions with little to back them up. As TFA says, you can make all the same claims for REST. And GraphQL works the same as REST. But instead of a complex mishmash if positional and named parameters, it has a super simple query structure.<p>When you create a stack of REST APIs, you’re creating a DSL. But it’s a DSL with arbitrary and frequently undocumented relationships between objects, no type safety, and masses of hidden complexity.<p>GraphQL is simple. If you don’t think it’s simple, you don’t understand it.<p>&gt; One big issue of GraphQL is also that API clients tend to suck. That&#x27;s not a problem for OpenAPIs.<p>The clients are unnecessary. You can get ridiculously complex clients for REST, too. But you can also use GraphQL just using fetch().<p>The only material difference between the two from a client perspective is:<p>* REST gives you everything, even if you don’t want it<p>* GraphQL requires you to request what you want using a minimal query language.<p>GraphQL also lets you perform multiple queries in parallel, on the server, which REST can’t easily do.<p>REST is a PITA for any data model that’s more complex than CRUD.</div><br/><div id="40983694" class="c"><input type="checkbox" id="c-40983694" checked=""/><div class="controls bullet"><span class="by">megadal</span><span>|</span><a href="#40983098">root</a><span>|</span><a href="#40983611">parent</a><span>|</span><a href="#40983150">next</a><span>|</span><label class="collapse" for="c-40983694">[-]</label><label class="expand" for="c-40983694">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you can make all the same claims for REST<p>That&#x27;s why I mentioned OpenAPIs, which you certainly can&#x27;t make the same claims about. I have never had a problem with an OpenAPI, it&#x27;s almost like a litmus test of web developer competence how simple it is.<p>&gt; But instead of a complex mishmash if positional and named parameters, it has a super simple query structure.<p>Have you <i>ever</i> used an OpenAPI or an OpenAPI client? I seriously implore you to look at ShipHero&#x27;s GraphQL documentation and look at <i>any</i> OpenAPI docs and pretend like GraphQL is simpler.<p>But if you&#x27;ve ever used an OpenAPI client, you know this is just a problem in theory, not in practice. I have never accidentally passed a parameter to the body, path, query or headers when it should&#x27;ve been elsewhere.<p>The problem is non-existent, especially since most people don&#x27;t write OpenAPI requests from scratch.. you can just throw the document anywhere and you will have some easier way to make requests.<p>And even if that&#x27;s the case, almost every OpenAPI doc UI I&#x27;ve seen has an option to show you the cURL and substitutes in parameters from the UI. You could just fill out the UI and copy the cURL request.<p>&gt; When you create a stack of REST APIs, you’re creating a DSL. But it’s a DSL with arbitrary and frequently undocumented relationships between objects, no type safety, and masses of hidden complexity.<p>I&#x27;m beginning to think this entire comment is a strawman: my argument is that a graph-based OpenAPI would have been better than GraphQL. Any REST API can be an OpenAPI. You are comparing apples to oranges.<p>I am comparing a RESTful Graph based data access API (like JSON:API) to GraphQL.<p>You are taking what sounds like the kind of REST API you&#x27;d find in a w3schools tutorial and comparing it to GraphQL.<p>&gt; GraphQL is simple. If you don’t think it’s simple, you don’t understand it.<p>That many developers find GraphQL difficult to understand is literally a testament to its complexity. This statement contradicts itself unless you believe I&#x27;m the only developer on the internet with this opinion, which I have a hard time believing given this entire comment is filled with strawman arguments you use against others who dislike GraphQL.<p>&gt; The clients are unnecessary. You can get ridiculously complex clients for REST, too. But you can also use GraphQL just using fetch().<p><i>Types are unnecessary. You can get ridiculously complex with strictly typed languages, too. But you can also just type everything dynamically and go crazy if the type system in my wacky language annoys you.</i><p>&gt; REST gives you everything, even if you don’t want it<p>That&#x27;s completely up to the REST API. I&#x27;ve written several that disagree with you. I&#x27;ve literally written RESTful Graph based data access APIs. Multiple. At tech startups.<p>&gt; GraphQL requires you to request what you want using a minimal query language.<p>So it requires complexity to enforce low bandwidth, got it. There is definitely no other way to lower bandwidth than enforcing complexity.<p>Usually I just use ABAC. You get the fields you can see. You can select a minimal list if you want. You don&#x27;t have to type out 32 field names if you need them all.<p>I sometimes wish GraphQL just took a chapter from SQLs book. What you described here is not a feature.<p>&gt; GraphQL also lets you perform multiple queries in parallel, on the server, which REST can’t easily do.<p>Ironically, <i>that</i> is up to the GraphQL implementation. ShipHero&#x27;s does not support this, and requires N+1 queries in many common cases. I suspect that&#x27;s not uncommon with GraphQL APIs, but I have no evidence for this.<p>But my suspicion is based on the fact that rigging up a GraphQL API implementation is a daunting enough task on its own, and multiple queries feels like it would be an after-thought to someone doing a quick-and-dirty setup. Which is how most people set up bleeding infrastructure (which is what GraphQL was when it was largely popular), because there&#x27;s not much knowledge, documentation or expertise readily available.<p>&gt; REST is a PITA for any data model that’s more complex than CRUD.<p>Again, you&#x27;re strawmanning. You&#x27;re arguing against REST, not a RESTful Graph based data access API, like JSON:API.<p>REST is not an API. GraphQL is. It is basically an API proxy with a query language disguised as a graph based data access API.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40983193" class="c"><input type="checkbox" id="c-40983193" checked=""/><div class="controls bullet"><span class="by">loveparade</span><span>|</span><a href="#40983098">prev</a><span>|</span><a href="#40983789">next</a><span>|</span><label class="collapse" for="c-40983193">[-]</label><label class="expand" for="c-40983193">[2 more]</label></div><br/><div class="children"><div class="content">Eight Years of GraphQL, and I have yet to find a single use case for it in my projects. I&#x27;ve had to interact with external GraphQL APIs a few times and each time it has been a terribly painful experience. Funnily enough, for the few queries where GraphQL would&#x27;ve actually been useful to get some deeply nested data structure, it was usually impossible to use it because the &quot;query is too big&#x2F;deep&quot; or it had cycles</div><br/><div id="40983257" class="c"><input type="checkbox" id="c-40983257" checked=""/><div class="controls bullet"><span class="by">PUSH_AX</span><span>|</span><a href="#40983193">parent</a><span>|</span><a href="#40983789">next</a><span>|</span><label class="collapse" for="c-40983257">[-]</label><label class="expand" for="c-40983257">[1 more]</label></div><br/><div class="children"><div class="content">Are any of your APIs used by multiple consumers? This was the strongest use case I found personally.</div><br/></div></div></div></div><div id="40983789" class="c"><input type="checkbox" id="c-40983789" checked=""/><div class="controls bullet"><span class="by">bcherny</span><span>|</span><a href="#40983193">prev</a><span>|</span><a href="#40983634">next</a><span>|</span><label class="collapse" for="c-40983789">[-]</label><label class="expand" for="c-40983789">[1 more]</label></div><br/><div class="children"><div class="content">A lot of people in this thread are criticizing GraphQL.<p>The reality is that GraphQL is a great tool for one job: building APIs that scale across thousands of engineers, billions of users, and many megawatts of machines. This is what we use GraphQL for at Meta.<p>To make it work well, it takes dedicated teams building infrastructure that makes the DevX great. It takes many years to build this out across various backends, clients, and internal tools. We have open sourced some of this infra — the GraphQL spec, Relay, GraphiQL, etc.<p>But there are many tools we built that we have not open sourced yet, largely because they’re tightly coupled to our internal ORMs, runtimes, error handling, authentication and security systems, and so on. I wish we open sourced more of our GraphQL stack, so more people could experience the awesome DevX we have internally.</div><br/></div></div><div id="40983634" class="c"><input type="checkbox" id="c-40983634" checked=""/><div class="controls bullet"><span class="by">est</span><span>|</span><a href="#40983789">prev</a><span>|</span><a href="#40983144">next</a><span>|</span><label class="collapse" for="c-40983634">[-]</label><label class="expand" for="c-40983634">[2 more]</label></div><br/><div class="children"><div class="content">GraphQL is painful. I am thinking some SQL but with more access control would be better.</div><br/><div id="40983726" class="c"><input type="checkbox" id="c-40983726" checked=""/><div class="controls bullet"><span class="by">resonious</span><span>|</span><a href="#40983634">parent</a><span>|</span><a href="#40983144">next</a><span>|</span><label class="collapse" for="c-40983726">[-]</label><label class="expand" for="c-40983726">[1 more]</label></div><br/><div class="children"><div class="content">Completely agree. Most GraphQL interfaces are papered over a relational database that speaks SQL. It seems ridiculous to me to have 2 query languages on top of one another like this. Feels like any GraphQL system could&#x27;ve just exposed their SQL directly for way less code and more flexibility.<p>Though I guess the layer in between lets you change your SQL schema without changing the GraphQL schema.</div><br/></div></div></div></div><div id="40983144" class="c"><input type="checkbox" id="c-40983144" checked=""/><div class="controls bullet"><span class="by">lukevp</span><span>|</span><a href="#40983634">prev</a><span>|</span><a href="#40983273">next</a><span>|</span><label class="collapse" for="c-40983144">[-]</label><label class="expand" for="c-40983144">[2 more]</label></div><br/><div class="children"><div class="content">The breaking changes part from the original article was clear to me. The author was saying that if you control the API and the client, it’s often quicker to release changes that are not backwards compatible as long as you can coordinate the release of the two. Then there’s no need to version at all. Sounds like this is harder with graphql than REST.</div><br/><div id="40983252" class="c"><input type="checkbox" id="c-40983252" checked=""/><div class="controls bullet"><span class="by">nesarkvechnep</span><span>|</span><a href="#40983144">parent</a><span>|</span><a href="#40983273">next</a><span>|</span><label class="collapse" for="c-40983252">[-]</label><label class="expand" for="c-40983252">[1 more]</label></div><br/><div class="children"><div class="content">You probably mean JSON over HTTP when saying REST but the original idea of REST is painless evolution. No vX in the URL.</div><br/></div></div></div></div><div id="40983273" class="c"><input type="checkbox" id="c-40983273" checked=""/><div class="controls bullet"><span class="by">robbyiq999</span><span>|</span><a href="#40983144">prev</a><span>|</span><a href="#40983606">next</a><span>|</span><label class="collapse" for="c-40983273">[-]</label><label class="expand" for="c-40983273">[5 more]</label></div><br/><div class="children"><div class="content">GrahpQL was something that came up heavily in Front-End job ads and maybe even mentioned during my experience interviewing around 2017-2020 
I was once even turned down for not having enough &quot;GraphQL Experience&quot; - Whatever that was. This was during a particularly painful 6 month rut for me - job search wise. It&#x27;s absolutely infuriating that the tide has now changed. GraphQL doesn&#x27;t matter. Did it ever? What was the point?</div><br/><div id="40983663" class="c"><input type="checkbox" id="c-40983663" checked=""/><div class="controls bullet"><span class="by">rpgwaiter</span><span>|</span><a href="#40983273">parent</a><span>|</span><a href="#40983495">next</a><span>|</span><label class="collapse" for="c-40983663">[-]</label><label class="expand" for="c-40983663">[1 more]</label></div><br/><div class="children"><div class="content">I find it really useful when your API accesses many different data sources, especially if they aren’t ones you control. You can make requests out only if you need to based on the query fields. It’s a great layer of glue for other APIs. If those other APIs are also GQL the process is very easy on your end.<p>GQL can abstract auth layers for external services, the user only has to auth with your service. The user only has to keep track of your single GQL url path instead of remembering “GET &#x2F;users, PUT &#x2F;posts, etc”. You’d probably have a  premade GQL playground setup at the single URL too. If you forget the query options, do an introspection query, which most interactive GQL clients do in the background for you. It also makes caching&#x2F;memos really easy, as you can memoize the GQL layer based on user query instead of implementing it for each upstream resource. Same deal with rate limiting. Also being able to ask for arbitrary number of resources by just making more named queries in a single request can be useful.<p>Having the .gql file be THE source of truth and typing for your schema is really nice. Most other setups I&#x27;ve seen like OpenAPI are usually disconnected from your actual API code, where it’s technically possible to diverge from your stated schema.</div><br/></div></div><div id="40983495" class="c"><input type="checkbox" id="c-40983495" checked=""/><div class="controls bullet"><span class="by">treve</span><span>|</span><a href="#40983273">parent</a><span>|</span><a href="#40983663">prev</a><span>|</span><a href="#40983606">next</a><span>|</span><label class="collapse" for="c-40983495">[-]</label><label class="expand" for="c-40983495">[3 more]</label></div><br/><div class="children"><div class="content">Web development goes through annoying hype cycles. GraphQL has great use-cases but it was overvalued. Unfortunately even if you recognize it you can&#x27;t always avoid it if you want to be competitive in the market. Cynicism can be a trap with this stuff because it may just make you less hireable.</div><br/><div id="40983649" class="c"><input type="checkbox" id="c-40983649" checked=""/><div class="controls bullet"><span class="by">ecjhdnc2025</span><span>|</span><a href="#40983273">root</a><span>|</span><a href="#40983495">parent</a><span>|</span><a href="#40983606">next</a><span>|</span><label class="collapse" for="c-40983649">[-]</label><label class="expand" for="c-40983649">[2 more]</label></div><br/><div class="children"><div class="content">I personally think GraphQL delivered on quite a lot of its hype, and I have become a bit more forgiving of web dev hype cycles in the light of crypto, NFT and generative-BS hype cycles...</div><br/><div id="40983788" class="c"><input type="checkbox" id="c-40983788" checked=""/><div class="controls bullet"><span class="by">treve</span><span>|</span><a href="#40983273">root</a><span>|</span><a href="#40983649">parent</a><span>|</span><a href="#40983606">next</a><span>|</span><label class="collapse" for="c-40983788">[-]</label><label class="expand" for="c-40983788">[1 more]</label></div><br/><div class="children"><div class="content">In my opinion the GraphQL &#x27;wake up call&#x27; (if we can call it that) has less to do with its intrinsic value. With the right team, with the right use-case it&#x27;s excellent. So please don&#x27;t take it as GraphQL=bad.<p>However I think we&#x27;ve seen a lot of &#x27;GraphQL as the default paradigm from the get-go&#x27;, which I think is a trap and has caused a fair bit of pain for all the small startups out there that were sold on this.</div><br/></div></div></div></div></div></div></div></div><div id="40983606" class="c"><input type="checkbox" id="c-40983606" checked=""/><div class="controls bullet"><span class="by">chx</span><span>|</span><a href="#40983273">prev</a><span>|</span><a href="#40983673">next</a><span>|</span><label class="collapse" for="c-40983606">[-]</label><label class="expand" for="c-40983606">[2 more]</label></div><br/><div class="children"><div class="content">I never understood the point. Really don&#x27;t. GraphQL does not provide any built-in mechanisms for filtering, sorting, pagination or other arbitrary transformations of the response. If you are already built those then might as well just include the data necessary and use a REST API.</div><br/><div id="40983643" class="c"><input type="checkbox" id="c-40983643" checked=""/><div class="controls bullet"><span class="by">ecjhdnc2025</span><span>|</span><a href="#40983606">parent</a><span>|</span><a href="#40983673">next</a><span>|</span><label class="collapse" for="c-40983643">[-]</label><label class="expand" for="c-40983643">[1 more]</label></div><br/><div class="children"><div class="content">It depends on whether your chosen platform can do it.<p>If you&#x27;re coding resolvers by hand, that is not fun. But for example the Lighthouse GraphQL layer for Laravel (it&#x27;s a schema-first thing based on the Webonyx PHP GraphQL reference implementation) can do a lot of this for you using schema decorations.<p><a href="https:&#x2F;&#x2F;lighthouse-php.com" rel="nofollow">https:&#x2F;&#x2F;lighthouse-php.com</a><p>It has where&#x2F;filter&#x2F;sort&#x2F;pagination, automatic scope narrowing etc., and you have very little code (if any) beyond the graphql schema to set it up. It integrates brilliantly with the Eloquent query builder.<p>One of the best applications for PHP IMO; it is really enormously productive.</div><br/></div></div></div></div><div id="40983673" class="c"><input type="checkbox" id="c-40983673" checked=""/><div class="controls bullet"><span class="by">elmigranto</span><span>|</span><a href="#40983606">prev</a><span>|</span><a href="#40983097">next</a><span>|</span><label class="collapse" for="c-40983673">[-]</label><label class="expand" for="c-40983673">[1 more]</label></div><br/><div class="children"><div class="content">So if most of the issues with GraphQL are the same as with the other approach, what is the point of GraphQL that justifies all the complexity?</div><br/></div></div><div id="40983097" class="c"><input type="checkbox" id="c-40983097" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#40983673">prev</a><span>|</span><label class="collapse" for="c-40983097">[-]</label><label class="expand" for="c-40983097">[4 more]</label></div><br/><div class="children"><div class="content">I think that instead of addressing and correcting the original post the author validated and confirmed everything that was said in that original post.</div><br/><div id="40983402" class="c"><input type="checkbox" id="c-40983402" checked=""/><div class="controls bullet"><span class="by">AWebOfBrown</span><span>|</span><a href="#40983097">parent</a><span>|</span><a href="#40983345">next</a><span>|</span><label class="collapse" for="c-40983402">[-]</label><label class="expand" for="c-40983402">[1 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s demonstrably false.<p>His point about the runtime complexity of an API being entirely distinct from how the interface to it&#x27;s code is exposed (whether GraphQL or REST or otherwise) is fairly obvious, I think.<p>The counter-argument is that unlimited query complexity makes it far bigger problem, and the author&#x27;s point is that if you&#x27;re using it for private APIs with persisted queries, you shouldn&#x27;t have that problem unknowingly.<p>Don&#x27;t get me wrong - I think the takeaway is that GraphQL&#x27;s niche is quite small, and he&#x27;s defending exactly that niche. It&#x27;s not often the case that you can develop an API in a private manner which doesn&#x27;t undercut higher-order value in the future, as the rise of AWS hopefully made evident.</div><br/></div></div><div id="40983345" class="c"><input type="checkbox" id="c-40983345" checked=""/><div class="controls bullet"><span class="by">fleshgrinder</span><span>|</span><a href="#40983097">parent</a><span>|</span><a href="#40983402">prev</a><span>|</span><a href="#40983386">next</a><span>|</span><label class="collapse" for="c-40983345">[-]</label><label class="expand" for="c-40983345">[1 more]</label></div><br/><div class="children"><div class="content">Glad I&#x27;m not the only one who feels that it&#x27;s handwavy and full of excuses.</div><br/></div></div><div id="40983386" class="c"><input type="checkbox" id="c-40983386" checked=""/><div class="controls bullet"><span class="by">RedShift1</span><span>|</span><a href="#40983097">parent</a><span>|</span><a href="#40983345">prev</a><span>|</span><label class="collapse" for="c-40983386">[-]</label><label class="expand" for="c-40983386">[1 more]</label></div><br/><div class="children"><div class="content">I think you missed the point, most of the problems that affect GraphQL APIs you will also experience with REST APIs, or any kind of APIs.</div><br/></div></div></div></div></div></div></div></div></div></body></html>