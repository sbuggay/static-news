<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715504454133" as="style"/><link rel="stylesheet" href="styles.css?v=1715504454133"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/NHAS/wag">Show HN: Wag, MFA and Enrollment for WireGuard</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>Nullence</span> | <span>46 comments</span></div><br/><div><div id="40328814" class="c"><input type="checkbox" id="c-40328814" checked=""/><div class="controls bullet"><span class="by">ta1243</span><span>|</span><a href="#40327643">next</a><span>|</span><label class="collapse" for="c-40328814">[-]</label><label class="expand" for="c-40328814">[3 more]</label></div><br/><div class="children"><div class="content">This looks nice, but a couple of things<p>&gt; curl <a href="http:&#x2F;&#x2F;public.server.address:8080&#x2F;register_device?key=e83253fd9962c68f73aa5088604f3f425d58a963bfb5c0889cca54d63a34b2e3" rel="nofollow">http:&#x2F;&#x2F;public.server.address:8080&#x2F;register_device?key=e83253...</a><p>&gt; The service will return a fully templated response<p>It looks like the &quot;registration&quot; involves the server generating a private key then sending to the client, rather than the client generating a private key and sending the public key to the server.<p>Not only that but your example is http! Probably worth replacing that part at least in case people think http is a reasonable option.<p>&gt; To authenticate the user should browse to the servers vpn address, in the example, case 192.168.1.1:8080, where they will be prompted for their 2fa code.<p>So when the session times out, is there any way for the client to realise this? Or does their ssh session (or whatever) just stop working?<p>I&#x27;ve on and off looked for a wireguard client which can do something like the captive portal detection on wifi. Ideally it would be an extra line in the config file (like persistentkeepalive), which does a URL pull. Could be checked periodically (like with the keepalive). If it returns &quot;OK&quot;, then fine, if it doesn&#x27;t return then there&#x27;s a network problem, but if it returns a &quot;Location&quot; header, the client would pop up a browser at that location, allowing for session reauthentication or whatever.<p>I haven&#x27;t found one.</div><br/><div id="40332903" class="c"><input type="checkbox" id="c-40332903" checked=""/><div class="controls bullet"><span class="by">blipvert</span><span>|</span><a href="#40328814">parent</a><span>|</span><a href="#40331097">next</a><span>|</span><label class="collapse" for="c-40332903">[-]</label><label class="expand" for="c-40332903">[1 more]</label></div><br/><div class="children"><div class="content">I have written a similar server (per-device client cert required which gets you mTLS to a logon page which uses OIDC the authenticate the user and enable the tunnel) but the client is the tricky bit.<p>I have written one in Go for the Mac which uses the command line wg from Brew and handles key gen, but it is clunky and requires sudo.<p>A proper native app which uses the network entitlements would be great, but it is beyond my ken</div><br/></div></div><div id="40331097" class="c"><input type="checkbox" id="c-40331097" checked=""/><div class="controls bullet"><span class="by">20after4</span><span>|</span><a href="#40328814">parent</a><span>|</span><a href="#40332903">prev</a><span>|</span><a href="#40327643">next</a><span>|</span><label class="collapse" for="c-40331097">[-]</label><label class="expand" for="c-40331097">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve on and off looked for a wireguard client which can do something like the captive portal detection on wifi. Ideally it would be an extra line in the config file (like persistentkeepalive), which does a URL pull. Could be checked periodically (like with the keepalive). If it returns &quot;OK&quot;, then fine, if it doesn&#x27;t return then there&#x27;s a network problem, but if it returns a &quot;Location&quot; header, the client would pop up a browser at that location, allowing for session reauthentication or whatever.<p>That would be really cool. I hope the author of this will consider it.</div><br/></div></div></div></div><div id="40327643" class="c"><input type="checkbox" id="c-40327643" checked=""/><div class="controls bullet"><span class="by">asimops</span><span>|</span><a href="#40328814">prev</a><span>|</span><a href="#40327415">next</a><span>|</span><label class="collapse" for="c-40327643">[-]</label><label class="expand" for="c-40327643">[6 more]</label></div><br/><div class="children"><div class="content">Have you tackled the issue of session management or are you planning to do so?
Essentially wireguard key are just eternal session keys.<p>I would expect software that implements the wireguard transport layer to implement session management to be called a working VPN server solution. This means a second channel to the server for periodically rotating session keys, terminating sessions, changing IP addresses, configuring new routes and repeating authentication if necessary.</div><br/><div id="40329069" class="c"><input type="checkbox" id="c-40329069" checked=""/><div class="controls bullet"><span class="by">gchamonlive</span><span>|</span><a href="#40327643">parent</a><span>|</span><a href="#40328415">next</a><span>|</span><label class="collapse" for="c-40329069">[-]</label><label class="expand" for="c-40329069">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;d use firezone for that. It has an option that forces the user to login to the platform regularly. Coupling that with an external identity provider via oidc is a very solid and simple solution for session management.</div><br/><div id="40332130" class="c"><input type="checkbox" id="c-40332130" checked=""/><div class="controls bullet"><span class="by">cchance</span><span>|</span><a href="#40327643">root</a><span>|</span><a href="#40329069">parent</a><span>|</span><a href="#40331382">next</a><span>|</span><label class="collapse" for="c-40332130">[-]</label><label class="expand" for="c-40332130">[1 more]</label></div><br/><div class="children"><div class="content">Firezone seems to have come really far from when i last used it wow... But ... I really like running headscale for most of my stuff as i prefer the p2p meshing for direct connections from server to server latency regardless of where they are.</div><br/></div></div><div id="40331382" class="c"><input type="checkbox" id="c-40331382" checked=""/><div class="controls bullet"><span class="by">jamilbk</span><span>|</span><a href="#40327643">root</a><span>|</span><a href="#40329069">parent</a><span>|</span><a href="#40332130">prev</a><span>|</span><a href="#40328415">next</a><span>|</span><label class="collapse" for="c-40331382">[-]</label><label class="expand" for="c-40331382">[1 more]</label></div><br/><div class="children"><div class="content">Just a quick note -- 1.0 goes a little further and rotates the WireGuard keys upon each auth session, so the private key never leaves the tunnel process memory. You need the Firezone client for that, though.</div><br/></div></div></div></div><div id="40328415" class="c"><input type="checkbox" id="c-40328415" checked=""/><div class="controls bullet"><span class="by">Aloha</span><span>|</span><a href="#40327643">parent</a><span>|</span><a href="#40329069">prev</a><span>|</span><a href="#40327415">next</a><span>|</span><label class="collapse" for="c-40328415">[-]</label><label class="expand" for="c-40328415">[2 more]</label></div><br/><div class="children"><div class="content">It seems to me that if I were building a VPN client like Global Protect but using WG, I&#x27;d have an eternal per client auth key that is used to set up an initial tunnel to the VPN controller, over that you perform auth, etc, then you&#x27;re given another session key, which is valid as long as that session is. The first tunnel would disconnect as soon as you finished authenticating and got your actual session key.</div><br/><div id="40328755" class="c"><input type="checkbox" id="c-40328755" checked=""/><div class="controls bullet"><span class="by">mbreese</span><span>|</span><a href="#40327643">root</a><span>|</span><a href="#40328415">parent</a><span>|</span><a href="#40327415">next</a><span>|</span><label class="collapse" for="c-40328755">[-]</label><label class="expand" for="c-40328755">[1 more]</label></div><br/><div class="children"><div class="content">Why even have the first tunnel? You could do the entire thing out of hand over a web interface or other mechanism. If the public address of the WG server (or the authn server) is known and available, then there’s no real difference in setting up the connection over a persistent WG channel vs an HTTPS service.<p>Both solutions are custom for that VPN, so I’d just have one WG tunnel that’s controlled through a secured (web)service. The bonus is that you wouldn’t need a hard coded initial key. (You’d still need some authentication mechanism, but it could be more than fixed public&#x2F;private key pairs).</div><br/></div></div></div></div></div></div><div id="40327415" class="c"><input type="checkbox" id="c-40327415" checked=""/><div class="controls bullet"><span class="by">d-z-m</span><span>|</span><a href="#40327643">prev</a><span>|</span><a href="#40327404">next</a><span>|</span><label class="collapse" for="c-40327415">[-]</label><label class="expand" for="c-40327415">[8 more]</label></div><br/><div class="children"><div class="content">Do you protect against bruteforcing the TOTP code?  I.e. via rate-limiting or a set amount of retries? I took a quick glance at the code and couldn&#x27;t find anything to this effect.<p>The scenario I&#x27;m imagining is: someone opens the TOTP entry UI in their browser, opens devtools, and starts to loop through all possible TOTP codes.</div><br/><div id="40327619" class="c"><input type="checkbox" id="c-40327619" checked=""/><div class="controls bullet"><span class="by">8organicbits</span><span>|</span><a href="#40327415">parent</a><span>|</span><a href="#40327605">next</a><span>|</span><label class="collapse" for="c-40327619">[-]</label><label class="expand" for="c-40327619">[1 more]</label></div><br/><div class="children"><div class="content">I think thats here:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;NHAS&#x2F;wag&#x2F;blob&#x2F;cdbdbec3393fa86bf6c823117c8af53145c52ede&#x2F;internal&#x2F;users&#x2F;user.go#L122">https:&#x2F;&#x2F;github.com&#x2F;NHAS&#x2F;wag&#x2F;blob&#x2F;cdbdbec3393fa86bf6c823117c8...</a></div><br/></div></div><div id="40327605" class="c"><input type="checkbox" id="c-40327605" checked=""/><div class="controls bullet"><span class="by">Avicebron</span><span>|</span><a href="#40327415">parent</a><span>|</span><a href="#40327619">prev</a><span>|</span><a href="#40327404">next</a><span>|</span><label class="collapse" for="c-40327605">[-]</label><label class="expand" for="c-40327605">[6 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t speak to the specifics of this particular implementation but usually if someone has the login (username + password) to get to totp that user has already been compromised..</div><br/><div id="40327661" class="c"><input type="checkbox" id="c-40327661" checked=""/><div class="controls bullet"><span class="by">asimops</span><span>|</span><a href="#40327415">root</a><span>|</span><a href="#40327605">parent</a><span>|</span><a href="#40329286">next</a><span>|</span><label class="collapse" for="c-40327661">[-]</label><label class="expand" for="c-40327661">[1 more]</label></div><br/><div class="children"><div class="content">But MFA is there to prevent this compromise from affecting the service and alert users&#x2F;admins to the compromise, right?<p>If you have username and password and are able to force the TOTP in the 60s window, the TOTP would be useless imho.</div><br/></div></div><div id="40329286" class="c"><input type="checkbox" id="c-40329286" checked=""/><div class="controls bullet"><span class="by">yonatan8070</span><span>|</span><a href="#40327415">root</a><span>|</span><a href="#40327605">parent</a><span>|</span><a href="#40327661">prev</a><span>|</span><a href="#40327404">next</a><span>|</span><label class="collapse" for="c-40329286">[-]</label><label class="expand" for="c-40329286">[4 more]</label></div><br/><div class="children"><div class="content">If a user keeps their credentials in a notebook and it got stolen, the TOTP check can be the difference between the attacker getting in, and the user being notified and changing their password</div><br/><div id="40330283" class="c"><input type="checkbox" id="c-40330283" checked=""/><div class="controls bullet"><span class="by">yardstick</span><span>|</span><a href="#40327415">root</a><span>|</span><a href="#40329286">parent</a><span>|</span><a href="#40327404">next</a><span>|</span><label class="collapse" for="c-40330283">[-]</label><label class="expand" for="c-40330283">[3 more]</label></div><br/><div class="children"><div class="content">Unfortunately these days it’s even easier with password managers containing all three (user, pass, token)</div><br/><div id="40332220" class="c"><input type="checkbox" id="c-40332220" checked=""/><div class="controls bullet"><span class="by">yonatan8070</span><span>|</span><a href="#40327415">root</a><span>|</span><a href="#40330283">parent</a><span>|</span><a href="#40330895">next</a><span>|</span><label class="collapse" for="c-40332220">[-]</label><label class="expand" for="c-40332220">[1 more]</label></div><br/><div class="children"><div class="content">I want to believe users who use a password manager are also technically literate enough to secure it properly</div><br/></div></div><div id="40330895" class="c"><input type="checkbox" id="c-40330895" checked=""/><div class="controls bullet"><span class="by">ThePowerOfFuet</span><span>|</span><a href="#40327415">root</a><span>|</span><a href="#40330283">parent</a><span>|</span><a href="#40332220">prev</a><span>|</span><a href="#40327404">next</a><span>|</span><label class="collapse" for="c-40330895">[-]</label><label class="expand" for="c-40330895">[1 more]</label></div><br/><div class="children"><div class="content">The difference being the notebook is paper and easily read, while the password manager is... quite a bit harder.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40327404" class="c"><input type="checkbox" id="c-40327404" checked=""/><div class="controls bullet"><span class="by">mahkoh</span><span>|</span><a href="#40327415">prev</a><span>|</span><a href="#40327924">next</a><span>|</span><label class="collapse" for="c-40327404">[-]</label><label class="expand" for="c-40327404">[4 more]</label></div><br/><div class="children"><div class="content">&gt;IPv4 only.<p>You&#x27;d think that sites choosing wireguard would have a more modern setup and might make heavy use of (self service) ULAs.</div><br/><div id="40329338" class="c"><input type="checkbox" id="c-40329338" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40327404">parent</a><span>|</span><a href="#40330822">next</a><span>|</span><label class="collapse" for="c-40329338">[-]</label><label class="expand" for="c-40329338">[1 more]</label></div><br/><div class="children"><div class="content">What are the ULA wins you&#x27;re thinking of here?</div><br/></div></div></div></div></div></div></div></div></div></body></html>