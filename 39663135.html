<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710147663537" as="style"/><link rel="stylesheet" href="styles.css?v=1710147663537"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.brendangregg.com/blog//2024-03-10/ebpf-documentary.html">eBPF Documentary</a> <span class="domain">(<a href="https://www.brendangregg.com">www.brendangregg.com</a>)</span></div><div class="subtext"><span>JNRowe</span> | <span>45 comments</span></div><br/><div><div id="39665304" class="c"><input type="checkbox" id="c-39665304" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#39663550">next</a><span>|</span><label class="collapse" for="c-39665304">[-]</label><label class="expand" for="c-39665304">[3 more]</label></div><br/><div class="children"><div class="content">&quot;eBPF Documentary: An exciting train wreck in progress&quot;<p>That would be a better title. eBPF started as a small extension to just be able to insert small trivial hooks. It&#x27;s now basically a hacked-up broken WebAssembly clone, with zero forethought put into it. NIH syndrome at its worst.<p>It has recently grown unlimited loops with runtime metering, making the static verifier basically a worthless complexity. Before that, it had acquired exceptions and stack unwinding.</div><br/><div id="39665908" class="c"><input type="checkbox" id="c-39665908" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39665304">parent</a><span>|</span><a href="#39665498">next</a><span>|</span><label class="collapse" for="c-39665908">[-]</label><label class="expand" for="c-39665908">[1 more]</label></div><br/><div class="children"><div class="content">While I agree its design isn&#x27;t the best, versus something like Solaris DTrace, it predates WebAssembly, so hardly a clone.</div><br/></div></div><div id="39665498" class="c"><input type="checkbox" id="c-39665498" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#39665304">parent</a><span>|</span><a href="#39665908">prev</a><span>|</span><a href="#39663550">next</a><span>|</span><label class="collapse" for="c-39665498">[-]</label><label class="expand" for="c-39665498">[1 more]</label></div><br/><div class="children"><div class="content">Architecture independent eBPF &quot;rescue binaries&quot; could be an interesting part of a distribution toolset..  or attack rootkit.  It&#x27;s hard to have nice things.</div><br/></div></div></div></div><div id="39663550" class="c"><input type="checkbox" id="c-39663550" checked=""/><div class="controls bullet"><span class="by">softirq</span><span>|</span><a href="#39665304">prev</a><span>|</span><a href="#39663403">next</a><span>|</span><label class="collapse" for="c-39663550">[-]</label><label class="expand" for="c-39663550">[3 more]</label></div><br/><div class="children"><div class="content">The genius of ebpf is allowing for pluggable policy in a world where the kernel API is very slow to change and can’t meet everyone’s needs. Whether it’s how the kernel handles packets off the wire, how it controls traffic, scheduling entities, or instrumentation, ebpf lets you provide logic rather than turn a bunch of knobs or use a bespoke syscall that only handles one case. It also moves the processing logic to the data in the kernel rather than having the kernel have to do expensive copies to and from userspace.<p>ebpf isn’t really novel beyond the interfaces it provides. They are just kernel modules that have been vetted and are sandboxed. Inserting executable code has been part of the kernel since forever in module form and kprobes.</div><br/><div id="39663588" class="c"><input type="checkbox" id="c-39663588" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#39663550">parent</a><span>|</span><a href="#39663403">next</a><span>|</span><label class="collapse" for="c-39663588">[-]</label><label class="expand" for="c-39663588">[2 more]</label></div><br/><div class="children"><div class="content">&gt; the kernel API is very slow to change and can’t meet everyone’s needs<p>Better yet - eBPF provides a stable A<i>B</i>I:) It makes things that were formerly kernel-internal possible to work with from a stable ~userspace interface.</div><br/><div id="39664506" class="c"><input type="checkbox" id="c-39664506" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#39663550">root</a><span>|</span><a href="#39663588">parent</a><span>|</span><a href="#39663403">next</a><span>|</span><label class="collapse" for="c-39664506">[-]</label><label class="expand" for="c-39664506">[1 more]</label></div><br/><div class="children"><div class="content">bpf tooling generally provides no stability guarantees when you interact with kernel primitives. See [0], for example. Tho things have improved somewhat with CO-RE<p>[0] - <a href="https:&#x2F;&#x2F;lore.kernel.org&#x2F;lkml&#x2F;93a20759600c05b6d9e4359a1517c88e06b44834.camel@fb.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lore.kernel.org&#x2F;lkml&#x2F;93a20759600c05b6d9e4359a1517c88...</a></div><br/></div></div></div></div></div></div><div id="39663403" class="c"><input type="checkbox" id="c-39663403" checked=""/><div class="controls bullet"><span class="by">xrd</span><span>|</span><a href="#39663550">prev</a><span>|</span><a href="#39665492">next</a><span>|</span><label class="collapse" for="c-39663403">[-]</label><label class="expand" for="c-39663403">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been hearing more and more about eBPF, especially here on HN.<p>I haven&#x27;t yet watched the documentary so perhaps it is answered there. But, the analogy of JavaScript inside the kernel is great and I&#x27;m left wondering: what was the way to do it previously? Userland network tool? This standardizes on a interface to the kernel, not a language, right? Feels off to say it is JavaScript because that comes with a lot of baggage, but also (as a versatile and ubiquitous language) incredibly powerful and useful tool. Is that intentional by the author?</div><br/><div id="39663473" class="c"><input type="checkbox" id="c-39663473" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39663403">parent</a><span>|</span><a href="#39664232">next</a><span>|</span><label class="collapse" for="c-39663473">[-]</label><label class="expand" for="c-39663473">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But, the analogy of JavaScript inside the kernel is great and I&#x27;m left wondering: what was the way to do it previously? Userland network tool? This standardizes on a interface to the kernel, not a language, right?<p>Guess&#x2F;sketch: It&#x27;s a language in most senses. Previously the kernel had APIs for packet filtering rules for iptables etc., but the set of rules you could use was somewhat &quot;static&quot; - rules would have parameters, so you could do things like if the source IP is in this range then rewrite it as this and direct it to this interface, but it was kind of like one of those visual flowchart languages where you can drag and drop the available boxes in a given order, but if there isn&#x27;t a box to do what you want then you&#x27;re stuck. Whereas with eBPF it really is scriptable - rather than a specific rule type you can just submit the script you want it to run - and nowadays it&#x27;s become kind of a general kernel scripting language rather than just for networking.<p>I&#x27;d draw a parallel with how 3D graphics programming has shifted from &quot;you can do these kinds of transformations, submit a list of what you want to run in what order&quot; to &quot;this is our shader programming language, just write whatever you want to do as a program in this language&quot;.</div><br/><div id="39663926" class="c"><input type="checkbox" id="c-39663926" checked=""/><div class="controls bullet"><span class="by">bhickey</span><span>|</span><a href="#39663403">root</a><span>|</span><a href="#39663473">parent</a><span>|</span><a href="#39664232">next</a><span>|</span><label class="collapse" for="c-39663926">[-]</label><label class="expand" for="c-39663926">[1 more]</label></div><br/><div class="children"><div class="content">iptables is definitely limited in comparison to eBPF, but that isn&#x27;t the innovative step. BPF was around for more than twenty years before eBPF came around. Around 2013 I worked on a packet analysis pipeline that generated BPF code dynamically at runtime. eBPF isn&#x27;t more scriptable than BPF in this sense. The language does add some opcodes and loops that weren&#x27;t available in the original, but this is relatively modest.<p>The real genius of what these folks did was extending the usefulness of BPF beyond the network stack. Without a provably safe language it would&#x27;ve been impossible to enable flexible kernel tracing.</div><br/></div></div></div></div><div id="39664232" class="c"><input type="checkbox" id="c-39664232" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#39663403">parent</a><span>|</span><a href="#39663473">prev</a><span>|</span><a href="#39664618">next</a><span>|</span><label class="collapse" for="c-39664232">[-]</label><label class="expand" for="c-39664232">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This standardizes on a interface to the kernel, not a language, right?<p>It&#x27;s a VM that runs JIT-compiled eBPF programs. You can write code in C or Golang or other languages that compiles down to eBPF. I did a video looking at the kernel eBPF code here: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;hznUH_zP77U?t=1165" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;hznUH_zP77U?t=1165</a><p>&gt; wondering: what was the way to do it previously? Userland network tool?<p>My understanding is that userland network tools were common in fields like finance that needed fast custom networking and wanted to eliminate the overhead of context switching. I don&#x27;t know how common they are&#x2F;were in other fields though.</div><br/><div id="39665625" class="c"><input type="checkbox" id="c-39665625" checked=""/><div class="controls bullet"><span class="by">shp0ngle</span><span>|</span><a href="#39663403">root</a><span>|</span><a href="#39664232">parent</a><span>|</span><a href="#39664618">next</a><span>|</span><label class="collapse" for="c-39665625">[-]</label><label class="expand" for="c-39665625">[1 more]</label></div><br/><div class="children"><div class="content">golang compiles to eBPF? including the whole golang runtime with garbage collector? that... surprises me<p>edit: I don&#x27;t see anything on the web that would show golang compiles to eBPF. I see bpf2go which is the other way around.</div><br/></div></div></div></div><div id="39664618" class="c"><input type="checkbox" id="c-39664618" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#39663403">parent</a><span>|</span><a href="#39664232">prev</a><span>|</span><a href="#39664507">next</a><span>|</span><label class="collapse" for="c-39664618">[-]</label><label class="expand" for="c-39664618">[1 more]</label></div><br/><div class="children"><div class="content">Ad-hoc kernel extensions were a pretty common answer, and one thing a lot of people love about eBPF is that it subsumes most of the reasons people wrote lkms commercially.</div><br/></div></div><div id="39664507" class="c"><input type="checkbox" id="c-39664507" checked=""/><div class="controls bullet"><span class="by">jeremiahbuckley</span><span>|</span><a href="#39663403">parent</a><span>|</span><a href="#39664618">prev</a><span>|</span><a href="#39665492">next</a><span>|</span><label class="collapse" for="c-39664507">[-]</label><label class="expand" for="c-39664507">[1 more]</label></div><br/><div class="children"><div class="content">One of the big wins is not so much “build and run your own stuff” but there are very nice low-cost (in terms of compute) performance utilities built on eBPF<p><a href="https:&#x2F;&#x2F;github.com&#x2F;iovisor&#x2F;bcc">https:&#x2F;&#x2F;github.com&#x2F;iovisor&#x2F;bcc</a><p>There are so many utilities in that list; there’s a diagram midway down the readme which tries to help show their uses. bcc-tools should be available in any distro.<p>Also, Brendan Gregg does a ton of performance stuff that is worth knowing about if you check out his other work. Not eBPF only. Flame graphs are useful.</div><br/></div></div></div></div><div id="39665492" class="c"><input type="checkbox" id="c-39665492" checked=""/><div class="controls bullet"><span class="by">brcmthrowaway</span><span>|</span><a href="#39663403">prev</a><span>|</span><a href="#39663395">next</a><span>|</span><label class="collapse" for="c-39665492">[-]</label><label class="expand" for="c-39665492">[1 more]</label></div><br/><div class="children"><div class="content">Brendan Gregg will get a Turing Award for this, congrats!</div><br/></div></div><div id="39663395" class="c"><input type="checkbox" id="c-39663395" checked=""/><div class="controls bullet"><span class="by">bch</span><span>|</span><a href="#39665492">prev</a><span>|</span><a href="#39663457">next</a><span>|</span><label class="collapse" for="c-39663395">[-]</label><label class="expand" for="c-39663395">[12 more]</label></div><br/><div class="children"><div class="content">I was a little disappointed DTrace[0] was not mentioned at all. The instrumentation (not the SDN) isn’t novel, not even to Linux (DTrace is available on Linux - I understand licensing is at least questionable (for some distros), but that aside…). [1]<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;DTrace" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;DTrace</a><p>[1] <a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;operating-systems&#x2F;oracle-linux&#x2F;dtrace-tutorial&#x2F;dtrace-tutorial-IntroducingDTrace.html" rel="nofollow">https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;operating-systems&#x2F;oracle-linux&#x2F;dt...</a></div><br/><div id="39663736" class="c"><input type="checkbox" id="c-39663736" checked=""/><div class="controls bullet"><span class="by">ta8645</span><span>|</span><a href="#39663395">parent</a><span>|</span><a href="#39663428">next</a><span>|</span><label class="collapse" for="c-39663736">[-]</label><label class="expand" for="c-39663736">[9 more]</label></div><br/><div class="children"><div class="content">DTrace was not the inspiration for eBPF at all, so it&#x27;s not obvious it is relevant to mention.  As the documentary mentions, the initial impetus for eBPF, was software defined networking.<p>eBPF is a much bigger and more comprehensive infrastructure piece (networking, tracing, security, etc) than DTrace.  And thanks to licensing issues, even within the limited domain of tracing, DTrace will likely become a footnote in history, while eBPF becomes available on every major OS platform.</div><br/><div id="39663816" class="c"><input type="checkbox" id="c-39663816" checked=""/><div class="controls bullet"><span class="by">bcantrill</span><span>|</span><a href="#39663395">root</a><span>|</span><a href="#39663736">parent</a><span>|</span><a href="#39663428">next</a><span>|</span><label class="collapse" for="c-39663816">[-]</label><label class="expand" for="c-39663816">[8 more]</label></div><br/><div class="children"><div class="content">There aren&#x27;t &quot;licensing issues&quot; with DTrace -- you are merely referring to the fact that it is licensed under the MPL-derived CDDL and not the GPL. But it is definitely true that they are not seeking to solve the same problems! Safety is very core to DTrace[0]; the difference here is entirely deliberate.<p>[0] <a href="https:&#x2F;&#x2F;bcantrill.dtrace.org&#x2F;2005&#x2F;07&#x2F;19&#x2F;dtrace-safety&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bcantrill.dtrace.org&#x2F;2005&#x2F;07&#x2F;19&#x2F;dtrace-safety&#x2F;</a></div><br/><div id="39663867" class="c"><input type="checkbox" id="c-39663867" checked=""/><div class="controls bullet"><span class="by">ta8645</span><span>|</span><a href="#39663395">root</a><span>|</span><a href="#39663816">parent</a><span>|</span><a href="#39663428">next</a><span>|</span><label class="collapse" for="c-39663867">[-]</label><label class="expand" for="c-39663867">[7 more]</label></div><br/><div class="children"><div class="content">AFAIU, it goes beyond safety; eBPF is designed to run entirely in the kernel rather than requiring a user-space bridge. So it&#x27;s able to operate at line speeds in networking scenarios etc.<p>&gt; you are merely referring to the fact that it is licensed under the MPL-derived CDDL and not the GPL.<p>Not really.  I&#x27;m referring to the fact the eBPF will be available across Microsoft, Apple, and Linux, and there is no other technology that will be able to offer that.<p>&gt; not seeking to solve the same problems!<p>Exactly.  eBPF has a much broader and more significant problem set, not just tracing, but also security modules, software defined networking, and an almost unlimited future potential as well.</div><br/><div id="39663901" class="c"><input type="checkbox" id="c-39663901" checked=""/><div class="controls bullet"><span class="by">bcantrill</span><span>|</span><a href="#39663395">root</a><span>|</span><a href="#39663867">parent</a><span>|</span><a href="#39663953">next</a><span>|</span><label class="collapse" for="c-39663901">[-]</label><label class="expand" for="c-39663901">[1 more]</label></div><br/><div class="children"><div class="content">A few points of clarification:<p>- DTrace <i>does</i> execute entirely in the kernel.  Indeed, anonymous tracing is instrumenting the system without any corresponding user process whatsoever<p>- DTrace exists on quite a few systems, <i>including</i> (with caveats) Windows, MacOS and Linux.<p>- The unbounded nature of eBPF very much runs contrary to the safety that DTrace assures; DTrace isn&#x27;t seeking to augment the system, but merely to understand it</div><br/></div></div><div id="39663953" class="c"><input type="checkbox" id="c-39663953" checked=""/><div class="controls bullet"><span class="by">bch</span><span>|</span><a href="#39663395">root</a><span>|</span><a href="#39663867">parent</a><span>|</span><a href="#39663901">prev</a><span>|</span><a href="#39663428">next</a><span>|</span><label class="collapse" for="c-39663953">[-]</label><label class="expand" for="c-39663953">[5 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m referring to the fact the eBPF will be available across Microsoft, Apple, and Linux, and there is no other technology that will be able to offer that.<p>I don’t know if there’s some qualification I’m missing in your statement, but does this not count?<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows-hardware&#x2F;drivers&#x2F;devtest&#x2F;dtrace" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows-hardware&#x2F;drivers&#x2F;d...</a><p><a href="https:&#x2F;&#x2F;opensource.apple.com&#x2F;source&#x2F;dtrace&#x2F;" rel="nofollow">https:&#x2F;&#x2F;opensource.apple.com&#x2F;source&#x2F;dtrace&#x2F;</a><p><a href="https:&#x2F;&#x2F;docs.freebsd.org&#x2F;en&#x2F;books&#x2F;handbook&#x2F;dtrace&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.freebsd.org&#x2F;en&#x2F;books&#x2F;handbook&#x2F;dtrace&#x2F;</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;dtrace4linux&#x2F;linux">https:&#x2F;&#x2F;github.com&#x2F;dtrace4linux&#x2F;linux</a></div><br/><div id="39664387" class="c"><input type="checkbox" id="c-39664387" checked=""/><div class="controls bullet"><span class="by">ta8645</span><span>|</span><a href="#39663395">root</a><span>|</span><a href="#39663953">parent</a><span>|</span><a href="#39663428">next</a><span>|</span><label class="collapse" for="c-39664387">[-]</label><label class="expand" for="c-39664387">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <a href="https:&#x2F;&#x2F;github.com&#x2F;dtrace4linux&#x2F;linux">https:&#x2F;&#x2F;github.com&#x2F;dtrace4linux&#x2F;linux</a><p><pre><code>    Last commit, 5 years ago.
</code></pre>
While you&#x27;re correct to say that DTrace is available on Linux, it is so restricted as to be much less capable than eBPF.  It is the reason it will become a footnote, and eBPF will become ubiquitous.</div><br/><div id="39664634" class="c"><input type="checkbox" id="c-39664634" checked=""/><div class="controls bullet"><span class="by">bcantrill</span><span>|</span><a href="#39663395">root</a><span>|</span><a href="#39664387">parent</a><span>|</span><a href="#39663428">next</a><span>|</span><label class="collapse" for="c-39664634">[-]</label><label class="expand" for="c-39664634">[3 more]</label></div><br/><div class="children"><div class="content">It may become a footnote on Linux, but Linux isn&#x27;t the only system out there -- and DTrace remains alive and well in many systems (not least in its reference implementation in illumos[0]).<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;illumos&#x2F;illumos-gate">https:&#x2F;&#x2F;github.com&#x2F;illumos&#x2F;illumos-gate</a></div><br/><div id="39664688" class="c"><input type="checkbox" id="c-39664688" checked=""/><div class="controls bullet"><span class="by">ta8645</span><span>|</span><a href="#39663395">root</a><span>|</span><a href="#39664634">parent</a><span>|</span><a href="#39663428">next</a><span>|</span><label class="collapse" for="c-39664688">[-]</label><label class="expand" for="c-39664688">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re discounting the network effects.  Also, eBPF provides many more capabilities beyond dTrace, and it will be ubiquitous across all OS, without having to make the exception for Linux.  Anyone targeting full cross-platform capabilities will be better served by eBPF.  The unfortunate history that crippled dTrace on Linux, will lead to its ultimate sidelining.</div><br/><div id="39665545" class="c"><input type="checkbox" id="c-39665545" checked=""/><div class="controls bullet"><span class="by">bcantrill</span><span>|</span><a href="#39663395">root</a><span>|</span><a href="#39664688">parent</a><span>|</span><a href="#39663428">next</a><span>|</span><label class="collapse" for="c-39665545">[-]</label><label class="expand" for="c-39665545">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really know what you mean by network effects, but perhaps we&#x27;re just talking about two different things:  you are looking at eBPF as a substrate to deliver arbitrary software (?!) whereas I view DTrace exclusively as a diagnostic tool.  As to their relative capabilities:  its other potential advantages aside, eBPF (and the tooling built upon it like bcc) lacks much of the functionality and polish of DTrace when attempting to accurately instrument the system. Its lack of robustness makes even basic instrumentation challenging,[0] let alone the richer (and admittedly, more esoteric) features of DTrace that it&#x27;s missing entirely.<p>[0] <a href="https:&#x2F;&#x2F;oxide-and-friends.transistor.fm&#x2F;episodes&#x2F;mr-nagles-wild-ride" rel="nofollow">https:&#x2F;&#x2F;oxide-and-friends.transistor.fm&#x2F;episodes&#x2F;mr-nagles-w...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39663428" class="c"><input type="checkbox" id="c-39663428" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#39663395">parent</a><span>|</span><a href="#39663736">prev</a><span>|</span><a href="#39663457">next</a><span>|</span><label class="collapse" for="c-39663428">[-]</label><label class="expand" for="c-39663428">[2 more]</label></div><br/><div class="children"><div class="content">i feel like the fact that the page mentions brendan gregg is a pretty strong reference to dtrace already.  actually it doesn&#x27;t just mention him, it&#x27;s completely written by him</div><br/><div id="39663452" class="c"><input type="checkbox" id="c-39663452" checked=""/><div class="controls bullet"><span class="by">bch</span><span>|</span><a href="#39663395">root</a><span>|</span><a href="#39663428">parent</a><span>|</span><a href="#39663457">next</a><span>|</span><label class="collapse" for="c-39663452">[-]</label><label class="expand" for="c-39663452">[1 more]</label></div><br/><div class="children"><div class="content">I think people that know, know he <i>was</i> involved (in the userland aspect) of DTrace, but I get a sense for some reason there’s no love lost between Brendan and “DTrace”.</div><br/></div></div></div></div></div></div><div id="39663457" class="c"><input type="checkbox" id="c-39663457" checked=""/><div class="controls bullet"><span class="by">James_K</span><span>|</span><a href="#39663395">prev</a><span>|</span><a href="#39663232">next</a><span>|</span><label class="collapse" for="c-39663457">[-]</label><label class="expand" for="c-39663457">[17 more]</label></div><br/><div class="children"><div class="content">It has always seemed quite obvious to me that dealing in machine code is a flawed approach for distributing software. At the most basic level, it entails giving someone else near unfettered access to the hardware of your computer and simply hoping that they do nothing malicious or malformed. Yet the software world as a whole seems continually shocked at the idea of using anything else. Perhaps someday we will learn this lesson in its entirety and begin to share code rather than blobs.</div><br/><div id="39663572" class="c"><input type="checkbox" id="c-39663572" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#39663457">parent</a><span>|</span><a href="#39665516">next</a><span>|</span><label class="collapse" for="c-39663572">[-]</label><label class="expand" for="c-39663572">[11 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think machine code is the problem? Running a native binary doesn&#x27;t give it access to anything inherently; the OS gives access through syscalls, and can impose restrictions - and indeed, <i>does</i>; it&#x27;s not like running a binary on Linux automatically gives it access to anything under &#x2F;dev.<p>Also, it&#x27;s not that the <i>whole</i> software world thinks blob-only software is normal; I&#x27;m typing this on a nice comfy GNU&#x2F;Linux box where the only blobs are some firmware. (Edit: And to be quite clear, a good chunk of this community would really <i>like</i> to get rid of those blobs too, it&#x27;s just that we don&#x27;t have a fix at this point.)</div><br/><div id="39663861" class="c"><input type="checkbox" id="c-39663861" checked=""/><div class="controls bullet"><span class="by">James_K</span><span>|</span><a href="#39663457">root</a><span>|</span><a href="#39663572">parent</a><span>|</span><a href="#39665516">next</a><span>|</span><label class="collapse" for="c-39663861">[-]</label><label class="expand" for="c-39663861">[10 more]</label></div><br/><div class="children"><div class="content">&gt; Running a native binary doesn&#x27;t give it access to anything inherently<p>While this is true from a certain perspective, machine code creates a system which must grand access to many things to become usable. A shared file system is a good example of this. Some software could easily echo a line into you .profile that tries to launch a key-logger, and this works in many cases. The expectation of software existing as opaque files creates a huge amount of work for the OS in verifying the exact behaviour of the software as it runs (and in ways which can often be circumvented), rather than a source-based approach in which malware is never allowed to touch the processor.<p>&gt; I&#x27;m typing this on a nice comfy GNU&#x2F;Linux box where the only blobs are some firmware<p>So you suffer the worst of both worlds then. You&#x27;ve had to download and compile the source yourself, but as the software is designed around being distributed as blobs, so you enjoy none of the benefits that might come from source distribution.</div><br/><div id="39664332" class="c"><input type="checkbox" id="c-39664332" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#39663457">root</a><span>|</span><a href="#39663861">parent</a><span>|</span><a href="#39665196">next</a><span>|</span><label class="collapse" for="c-39664332">[-]</label><label class="expand" for="c-39664332">[2 more]</label></div><br/><div class="children"><div class="content">Machine code does not require granting anything. The presence of a shared filesystem is a artifact of the OS, not any sort of inherent requirement.<p>The actual effect of machine code being opaque is actually &quot;beneficial&quot; to security as only very coarse protection boundaries are even expressible. You must coarsely separate your code to get protection which comes at a potential cost of performance. The advantage of non-machine code is that you can express very fine protection boundaries which reduces the performance cost of protection, but at the cost of more complex analysis.<p>Ensuring protection boundaries in the presence of coarsely separated code is strictly easier. You have strictly less ways to escape. Any coarsely separated code can be trivially transplanted onto a system enabling finer protection since they can just not use the finer protection. By the same logic, any protection boundary that can not protect coarsely separated code has no hope of enforcing protection on finer separations.<p>That the kernel designers of Linux, Windows, iOS, etc. can not even ensure protection in general when the systems are coarsely separated means they certainly can not be trusted to ensure protection in general when things are more finely separated. If they could, fixing their existing coarse protection boundary would be a trivial consequence. About the only theoretical reason why this might not apply to eBPF is that it is not &quot;general&quot; in that many programs are not expressible, but that is not sound, positive evidence of suitability where as the historical track record of protection in all commercial operating systems is abysmal to say the least. Claims of finally achieving security (on a strictly harder variant of the problem) are extraordinary claims and extraordinary claims demand extraordinary evidence.</div><br/><div id="39665854" class="c"><input type="checkbox" id="c-39665854" checked=""/><div class="controls bullet"><span class="by">James_K</span><span>|</span><a href="#39663457">root</a><span>|</span><a href="#39664332">parent</a><span>|</span><a href="#39665196">next</a><span>|</span><label class="collapse" for="c-39665854">[-]</label><label class="expand" for="c-39665854">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Machine code does not require granting anything<p>It requires that you actually run software on your CPU before you can tell if it&#x27;s malicious or not, by which point it is often too late to do anything about it. Almost all malware that exists does so thanks to this fact.</div><br/></div></div></div></div><div id="39665196" class="c"><input type="checkbox" id="c-39665196" checked=""/><div class="controls bullet"><span class="by">cookiengineer</span><span>|</span><a href="#39663457">root</a><span>|</span><a href="#39663861">parent</a><span>|</span><a href="#39664332">prev</a><span>|</span><a href="#39663933">next</a><span>|</span><label class="collapse" for="c-39665196">[-]</label><label class="expand" for="c-39665196">[2 more]</label></div><br/><div class="children"><div class="content">What else do you suggest then? Is there even hardware available that implements a high-level VM programming language as an abstraction layer (instead of e.g. the x86 instruction set)?</div><br/><div id="39665844" class="c"><input type="checkbox" id="c-39665844" checked=""/><div class="controls bullet"><span class="by">James_K</span><span>|</span><a href="#39663457">root</a><span>|</span><a href="#39665196">parent</a><span>|</span><a href="#39663933">next</a><span>|</span><label class="collapse" for="c-39665844">[-]</label><label class="expand" for="c-39665844">[1 more]</label></div><br/><div class="children"><div class="content">An program sits on top of hardware and can act as a go-between. Think of the web browser, or the JVM. Both insanely popular by virtue of providing the basic features I describe, and also evidence that they needn&#x27;t even be integrated to the operating system. Something of this nature that also provides the basics of an interactive desktop.</div><br/></div></div></div></div><div id="39663933" class="c"><input type="checkbox" id="c-39663933" checked=""/><div class="controls bullet"><span class="by">gggmaster</span><span>|</span><a href="#39663457">root</a><span>|</span><a href="#39663861">parent</a><span>|</span><a href="#39665196">prev</a><span>|</span><a href="#39664715">next</a><span>|</span><label class="collapse" for="c-39663933">[-]</label><label class="expand" for="c-39663933">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s better than an OS that you have no control from top to bottom. But sure, it isn&#x27;t ideal.</div><br/></div></div><div id="39665260" class="c"><input type="checkbox" id="c-39665260" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#39663457">root</a><span>|</span><a href="#39663861">parent</a><span>|</span><a href="#39664715">prev</a><span>|</span><a href="#39664099">next</a><span>|</span><label class="collapse" for="c-39665260">[-]</label><label class="expand" for="c-39665260">[1 more]</label></div><br/><div class="children"><div class="content">&gt; While this is true from a certain perspective, machine code creates a system which must grand access to many things to become usable. A shared file system is a good example of this. Some software could easily echo a line into you .profile that tries to launch a key-logger, and this works in many cases.<p>That&#x27;s <i>common</i>, but it&#x27;s certainly not a requirement to run native code. For example, we&#x27;ve done a pretty good job at retroactively fixing that while preserving backwards compatibility with containers (I can, and <i>have</i> run normal official Firefox binaries inside a docker container with zero access to my real home directory) or sandboxes like flatpak (bubblewrap). If you want to run real native binaries but <i>don&#x27;t</i> have to preserve backwards compatibility, then it gets easy; genode ( <a href="https:&#x2F;&#x2F;genode.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;genode.org&#x2F;</a> ) does a lovely job of truly practicing only giving programs what access you <i>want</i> to give them.<p>&gt; The expectation of software existing as opaque files creates a huge amount of work for the OS in verifying the exact behaviour of the software as it runs (and in ways which can often be circumvented), rather than a source-based approach in which malware is never allowed to touch the processor.<p>I think you&#x27;re overoptimistic regarding what you can do with the source code short of manual (human) auditing. I mean, sure there are things you can scan for to try and catch bad behavior, but in the case of actual malice I wouldn&#x27;t trust automatic code analysis to protect me.<p>&gt;&gt; I&#x27;m typing this on a nice comfy GNU&#x2F;Linux box where the only blobs are some firmware<p>&gt; So you suffer the worst of both worlds then. You&#x27;ve had to download and compile the source yourself, but as the software is designed around being distributed as blobs, so you enjoy none of the benefits that might come from source distribution.<p>I have no idea why you think either of those things? Depending on the distro I certainly <i>can</i> compile from source on my own box (ex. Gentoo, NixOS), but I can also use precompiled binaries (ex. Debian, NixOS) while still having it be trivial to go find the exact source that went in to the binary package I downloaded (this has gotten even stronger with Reproducibility efforts meaning that I can even verify the <i>exact</i> source and build config that created a specific binary). The actual application software and OS are available as Open Source code that can be audited, with binaries available as a convenience, and the only remaining blobs (unwelcome but impractical to fix so far) are firmware blobs with relatively constrained roles (and on machines with an IOMMU we can even <i>enforce</i> what access they have, which is a nice mitigation).</div><br/></div></div><div id="39664099" class="c"><input type="checkbox" id="c-39664099" checked=""/><div class="controls bullet"><span class="by">avianlyric</span><span>|</span><a href="#39663457">root</a><span>|</span><a href="#39663861">parent</a><span>|</span><a href="#39665260">prev</a><span>|</span><a href="#39665516">next</a><span>|</span><label class="collapse" for="c-39664099">[-]</label><label class="expand" for="c-39664099">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The expectation of software existing as opaque files creates a huge amount of work for the OS in verifying the exact behaviour of the software as it runs<p>That’s not really how the software&#x2F;OS relationship works. By default OS’s run software in very unprivileged CPU security contexts, where they can’t really do anything beyond but operate on memory the OS allocated to the software, with CPU instructions can’t talk directly to other hardware, or read&#x2F;write memory beyond the bounds the OS specified.<p>To do literally anything else, like open a file, write to a file, talk to a network interface, talk directly to other hardware connected to the CPU. The software needs to use a syscall, and effectively ask the OS to perform the operation on its behalf. Every single dangerous operation you can perform is guarded by the OS, the OS doesn’t <i>validate</i> anything, it simply decides to perform the operations requested, or it decides not to perform those operations.<p>The only reason why software expects so much unfettered access to a system is simply because OS have historical not limited what software was allowed to do, OS’s simply performed whatever operation was requested of them without question. It only in the last 20 years or so that security became a concern, and it occurred to us that allowing software to just do whatever it wants is probably a bad idea. But the genie is out of the bottle, and it’s proving hard to put it back in. So retroactive work to limit what software can do by default, without simply breaking everything, is slow and difficult.<p>If you ever want to understand why you can do somethings on MacOS, but not iOS, then this is a pretty good place to start (if we ignore Apple’s brand and commercial reasons for a moment). iOS only ever supported tightly sandboxed apps, that had to play nice with a draconian permissions system, where as MacOS is more standard OS, that was originally developed in the age before security was really a concern. So it’s easy to enforce tight sandboxing on iOS, where software has always had to deal with it, but hard on MacOS, where for the majority of MacOS history, sandboxing simply didn’t exist.<p>&gt; rather than a source-based approach in which malware is never allowed to touch the processor.<p>That’s a nice idea, but doesn’t really hold up to scrutiny. You need to look at the ever increasing number of supply chain attacks to realise that simply being open source does little to ensure malware doesn’t make it onto your machine. And that before we get into issues like heart bleed, where the OSS software on your machine may contain bugs or errors that allow remote parties to gain access to privileged data or credentials, via OSS software that isn’t malware, it just got bugs in it.<p>At the end of the day, it doesn’t really matter what magical security boundaries you develop, someone will find a way around it. Which is why defence in depth is such an important principle. Simply relying on the idea that Open Source means no malware is foolish. You need proper OS defences regardless.</div><br/><div id="39665879" class="c"><input type="checkbox" id="c-39665879" checked=""/><div class="controls bullet"><span class="by">James_K</span><span>|</span><a href="#39663457">root</a><span>|</span><a href="#39664099">parent</a><span>|</span><a href="#39665516">next</a><span>|</span><label class="collapse" for="c-39665879">[-]</label><label class="expand" for="c-39665879">[1 more]</label></div><br/><div class="children"><div class="content">I know all that. The process you describe is the OS verifying the behaviour of software as it runs.<p>&gt;That’s a nice idea, but doesn’t really hold up to scrutiny<p>It does actually. The kind of attack you describe only works because software exists in non-source based systems. If you were going to run a Haskell function, and you were told that I was going to modify its body in some way, there is no way I can insert malware into it because you cannot reach out of the context of the function and mess with the operating system. Software is composed of functions, which naturally run in a fully containerised state and only become dangerous when the OS adds an additional layer of computer-wide state.</div><br/></div></div></div></div></div></div></div></div><div id="39665516" class="c"><input type="checkbox" id="c-39665516" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#39663457">parent</a><span>|</span><a href="#39663572">prev</a><span>|</span><a href="#39665499">next</a><span>|</span><label class="collapse" for="c-39665516">[-]</label><label class="expand" for="c-39665516">[2 more]</label></div><br/><div class="children"><div class="content">&quot;That&#x27;s a really cool security aware script language you&#x27;ve got there!  So..  um..  how can I extend it to call third party libraries?&quot;<p>Perhaps the idea that &quot;the computer&quot; is one single entity with a shared security domain and view of hardware is the flaw.  Why can my web browser read my tax documents unless I go through a bunch of rather absurd efforts to prevent something so simple?</div><br/><div id="39665621" class="c"><input type="checkbox" id="c-39665621" checked=""/><div class="controls bullet"><span class="by">xorcist</span><span>|</span><a href="#39663457">root</a><span>|</span><a href="#39665516">parent</a><span>|</span><a href="#39665499">next</a><span>|</span><label class="collapse" for="c-39665621">[-]</label><label class="expand" for="c-39665621">[1 more]</label></div><br/><div class="children"><div class="content">Because you want to be able do report your taxes documents to the tax office? It&#x27;s one of those things that sound so simple on paper, but every time someone does that trivial thing and not make documents available to the web browser, usability suffers.<p>The real answer why the browser can read certain files is much more complex, your web browser is not a singular entity anymore. And the network and protcol speaking parts of it can&#x27;t access your documents, according to the principle of least authority.<p>It&#x27;s far from perfect and gets hacked every time, but do take the time to read how that&#x27;s done. The hacks are just as complex as the web browser itself. The practical problem with the browser is the enormous complexity of functions, everything from OpenGL to databases to p2p and usb, that keeps growing boundlessly.</div><br/></div></div></div></div><div id="39665499" class="c"><input type="checkbox" id="c-39665499" checked=""/><div class="controls bullet"><span class="by">brcmthrowaway</span><span>|</span><a href="#39663457">parent</a><span>|</span><a href="#39665516">prev</a><span>|</span><a href="#39663748">next</a><span>|</span><label class="collapse" for="c-39665499">[-]</label><label class="expand" for="c-39665499">[1 more]</label></div><br/><div class="children"><div class="content">ChatGPT?</div><br/></div></div><div id="39663748" class="c"><input type="checkbox" id="c-39663748" checked=""/><div class="controls bullet"><span class="by">frozenport</span><span>|</span><a href="#39663457">parent</a><span>|</span><a href="#39665499">prev</a><span>|</span><a href="#39664277">next</a><span>|</span><label class="collapse" for="c-39663748">[-]</label><label class="expand" for="c-39663748">[1 more]</label></div><br/><div class="children"><div class="content">Android and mobile platform make it hard to distribute as fully compiled source.</div><br/></div></div></div></div></div></div></div></div></div></body></html>