<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1708678853457" as="style"/><link rel="stylesheet" href="styles.css?v=1708678853457"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.undeadly.org/cgi?action=article;sid=20240222183703">New code for SIGILL faults to help identify misbranches on OpenBSD</a>Â <span class="domain">(<a href="https://www.undeadly.org">www.undeadly.org</a>)</span></div><div class="subtext"><span>peter_hansteen</span> | <span>20 comments</span></div><br/><div><div id="39472133" class="c"><input type="checkbox" id="c-39472133" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#39474071">next</a><span>|</span><label class="collapse" for="c-39472133">[-]</label><label class="expand" for="c-39472133">[17 more]</label></div><br/><div class="children"><div class="content">Can someone explain how this works? What would trigger a misbranch and how can the OS tell the difference? I read the page and the link but I don&#x27;t understand.</div><br/><div id="39472295" class="c"><input type="checkbox" id="c-39472295" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#39472133">parent</a><span>|</span><a href="#39472162">next</a><span>|</span><label class="collapse" for="c-39472295">[-]</label><label class="expand" for="c-39472295">[9 more]</label></div><br/><div class="children"><div class="content">As a ROP mitigation measure some recent CPU models have a feature that can require code to branch to a special instruction signifying a valid target; jumps to an address that doesn&#x27;t contain that instruction result in a CPU fault. On OpenBSD such a fault is translated to SIGILL, apparently, which can also occur when the CPU encounters other issues, like an invalidly encoded instruction. This patch differentiates the new type of fault so it&#x27;s easier to identify within process signal handlers by adding a new reason code, ILL_BTCFI, to SIGILL info (siginfo_t).<p>The full patch is at <a href="https:&#x2F;&#x2F;github.com&#x2F;openbsd&#x2F;src&#x2F;commit&#x2F;88580652a3669007813512ab28f5ee7ceeae4a78">https:&#x2F;&#x2F;github.com&#x2F;openbsd&#x2F;src&#x2F;commit&#x2F;88580652a3669007813512...</a><p>I&#x27;m not sure if this patch is noteworthy on its own, but perhaps it was posted because it implies this CPU feature is now supported or soon to be supported by OpenBSD.</div><br/><div id="39474421" class="c"><input type="checkbox" id="c-39474421" checked=""/><div class="controls bullet"><span class="by">brynet</span><span>|</span><a href="#39472133">root</a><span>|</span><a href="#39472295">parent</a><span>|</span><a href="#39476127">next</a><span>|</span><label class="collapse" for="c-39474421">[-]</label><label class="expand" for="c-39474421">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m not sure if this patch is noteworthy on its own, but perhaps it was posted because it implies this CPU feature is now supported or soon to be supported by OpenBSD.<p>OpenBSD has supported mandatory BTI&#x2F;IBT on Intel CPUs (11th Gen+) and arm64 (Apple M2) since 7.4 (Oct 16, 2023).<p><a href="https:&#x2F;&#x2F;www.openbsd.org&#x2F;innovations.html" rel="nofollow">https:&#x2F;&#x2F;www.openbsd.org&#x2F;innovations.html</a><p>&quot;Mandatory enforcement of indirect branch targets (BTI on arm64, IBT on Intel amd64), unless a linker flag (-Wl,-z,nobtcfi) requests no enforcement.&quot;<p><a href="https:&#x2F;&#x2F;marc.info&#x2F;?l=openbsd-ports&amp;m=168899645126958&amp;w=2" rel="nofollow">https:&#x2F;&#x2F;marc.info&#x2F;?l=openbsd-ports&amp;m=168899645126958&amp;w=2</a><p>OpenBSD recently disabled retpolines by default because they are incompatible with IBT, so there has been some work done recently that this patch could help with, e.g: adding missing indirect branch target instructions (endbr64), previously hidden by retpoline. OpenBSD has done a lot of work to push these changes into the entire software ecosystem.</div><br/><div id="39478428" class="c"><input type="checkbox" id="c-39478428" checked=""/><div class="controls bullet"><span class="by">guenthert</span><span>|</span><a href="#39472133">root</a><span>|</span><a href="#39474421">parent</a><span>|</span><a href="#39476127">next</a><span>|</span><label class="collapse" for="c-39478428">[-]</label><label class="expand" for="c-39478428">[1 more]</label></div><br/><div class="children"><div class="content">Did I get that right?  The company which brought us SPECTRE now brings us a feature requiring us to disable SPECTRE mitigation?<p>I haven&#x27;t followed this and surely misrepresent the facts above.  This is just a plea for someone in the know to clarify the situation.</div><br/></div></div></div></div><div id="39476127" class="c"><input type="checkbox" id="c-39476127" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#39472133">root</a><span>|</span><a href="#39472295">parent</a><span>|</span><a href="#39474421">prev</a><span>|</span><a href="#39475618">next</a><span>|</span><label class="collapse" for="c-39476127">[-]</label><label class="expand" for="c-39476127">[3 more]</label></div><br/><div class="children"><div class="content">For more context, CET and friends don&#x27;t actually act as a ROP mitigation in it of themselves. CET is a coarse forward edge CFI technique. For completeness, you must pair it with both some software function type assert (prevent argument type confusion by swapping function pointers, etc.) as well as a backwards edge CFI mitigation (such as secure a shadow stack for storing link addresses). Both are quite hard problems.<p>ARM&#x27;s Pointer Authentication extension is an interesting alternative which does all of this in one feature by cryptographically signing pointers in memory.</div><br/><div id="39476149" class="c"><input type="checkbox" id="c-39476149" checked=""/><div class="controls bullet"><span class="by">admax88qqq</span><span>|</span><a href="#39472133">root</a><span>|</span><a href="#39476127">parent</a><span>|</span><a href="#39475618">next</a><span>|</span><label class="collapse" for="c-39476149">[-]</label><label class="expand" for="c-39476149">[2 more]</label></div><br/><div class="children"><div class="content">Jesus. The amount of engineering that has to happen to protect against C is astounding.</div><br/><div id="39476715" class="c"><input type="checkbox" id="c-39476715" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#39472133">root</a><span>|</span><a href="#39476149">parent</a><span>|</span><a href="#39475618">next</a><span>|</span><label class="collapse" for="c-39476715">[-]</label><label class="expand" for="c-39476715">[1 more]</label></div><br/><div class="children"><div class="content">Protecting JIT-compiled code, e.g. within browsers, is at least as important a concern. Some would argue much more important, especially as usage of services like Cloudflare Workers increases.<p>Techniques like CHERI could replace MMUs in some environments, potentially improving performance.</div><br/></div></div></div></div></div></div><div id="39475618" class="c"><input type="checkbox" id="c-39475618" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#39472133">root</a><span>|</span><a href="#39472295">parent</a><span>|</span><a href="#39476127">prev</a><span>|</span><a href="#39472162">next</a><span>|</span><label class="collapse" for="c-39475618">[-]</label><label class="expand" for="c-39475618">[3 more]</label></div><br/><div class="children"><div class="content">&gt; As a ROP mitigation measure some recent CPU models have a feature that can require code to branch to a special instruction signifying a valid target; jumps to an address that doesn&#x27;t contain that instruction result in a CPU fault.<p>How much of a performance flow mitigation is this, 3-5%?</div><br/><div id="39475801" class="c"><input type="checkbox" id="c-39475801" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#39472133">root</a><span>|</span><a href="#39475618">parent</a><span>|</span><a href="#39475849">next</a><span>|</span><label class="collapse" for="c-39475801">[-]</label><label class="expand" for="c-39475801">[1 more]</label></div><br/><div class="children"><div class="content">Compiler-based CFI has low single digits impact. Hardware with ENDBR will be hard to notice, &quot;none&quot; being a reasonably accurate estimate of the impact, unless your code is weird and unusually dense with valid indirect branch targets.</div><br/></div></div><div id="39475849" class="c"><input type="checkbox" id="c-39475849" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#39472133">root</a><span>|</span><a href="#39475618">parent</a><span>|</span><a href="#39475801">prev</a><span>|</span><a href="#39472162">next</a><span>|</span><label class="collapse" for="c-39475849">[-]</label><label class="expand" for="c-39475849">[1 more]</label></div><br/><div class="children"><div class="content">in fast paths almost all the code you&#x27;re running is in icache, and even the decoded micro-ops are probably cached, so I bet it&#x27;s even cheaper than that.</div><br/></div></div></div></div></div></div><div id="39472162" class="c"><input type="checkbox" id="c-39472162" checked=""/><div class="controls bullet"><span class="by">schoen</span><span>|</span><a href="#39472133">parent</a><span>|</span><a href="#39472295">prev</a><span>|</span><a href="#39474071">next</a><span>|</span><label class="collapse" for="c-39472162">[-]</label><label class="expand" for="c-39472162">[7 more]</label></div><br/><div class="children"><div class="content">This is an instance of control-flow integrity.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Control-flow_integrity" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Control-flow_integrity</a><p>I guess (although it doesn&#x27;t specifically say) that this is making use of Intel&#x27;s CET feature?</div><br/><div id="39472277" class="c"><input type="checkbox" id="c-39472277" checked=""/><div class="controls bullet"><span class="by">mcarmichael</span><span>|</span><a href="#39472133">root</a><span>|</span><a href="#39472162">parent</a><span>|</span><a href="#39474071">next</a><span>|</span><label class="collapse" for="c-39472277">[-]</label><label class="expand" for="c-39472277">[6 more]</label></div><br/><div class="children"><div class="content">As described, something more akin to<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Return-oriented_programming#Branch_Target_Identification_(BTI)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Return-oriented_programming#Br...</a><p>That page has a reasonable summary of the exploitation techniques and history motivating this work.</div><br/><div id="39472296" class="c"><input type="checkbox" id="c-39472296" checked=""/><div class="controls bullet"><span class="by">schoen</span><span>|</span><a href="#39472133">root</a><span>|</span><a href="#39472277">parent</a><span>|</span><a href="#39474071">next</a><span>|</span><label class="collapse" for="c-39472296">[-]</label><label class="expand" for="c-39472296">[5 more]</label></div><br/><div class="children"><div class="content">Interesting! I guess that particular mechanism is ARM-specific?</div><br/><div id="39473147" class="c"><input type="checkbox" id="c-39473147" checked=""/><div class="controls bullet"><span class="by">Findecanor</span><span>|</span><a href="#39472133">root</a><span>|</span><a href="#39472296">parent</a><span>|</span><a href="#39472712">next</a><span>|</span><label class="collapse" for="c-39473147">[-]</label><label class="expand" for="c-39473147">[3 more]</label></div><br/><div class="children"><div class="content">The article mentions both 64-bit ARM and x86. Intel&#x27;s ENDBR64 (part of CET) and ARMv8.5A BTI work largely the same. The instructions are NOP on older processors or if not enabled by the OS.<p>BTW. A similar extension is also about to be approved for RISC-V: &quot;Zicfilp&quot;. It also repurposes an instruction that was previously a NOP.</div><br/><div id="39473911" class="c"><input type="checkbox" id="c-39473911" checked=""/><div class="controls bullet"><span class="by">schoen</span><span>|</span><a href="#39472133">root</a><span>|</span><a href="#39473147">parent</a><span>|</span><a href="#39472712">next</a><span>|</span><label class="collapse" for="c-39473911">[-]</label><label class="expand" for="c-39473911">[2 more]</label></div><br/><div class="children"><div class="content">Cool, thanks!<p>So, ROP itself is a (frequently very effective) workaround for W^X memory protection features, where executable code itself should be unmodifiable at runtime. I wonder if there&#x27;s a &quot;next&quot; CFI attack that calls existing functions that are actually defined as such, but in a weird order, or with weird arguments.<p>The ability to do that effectively would depend on lots of stuff, including the calling convention (as the stack or heap are easier to corrupt than registers).<p>Maybe someone is already writing an advanced ROP gadget-search that looks for &quot;real functions that can be combined to make ROP gadgets by calling them in a bizarre way&quot;. (This is already much less likely to occur in a real program ... I think ...! But maybe the return-to-libc phenomenon is still a rich source of vulnerability?)</div><br/><div id="39474057" class="c"><input type="checkbox" id="c-39474057" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#39472133">root</a><span>|</span><a href="#39473911">parent</a><span>|</span><a href="#39472712">next</a><span>|</span><label class="collapse" for="c-39474057">[-]</label><label class="expand" for="c-39474057">[1 more]</label></div><br/><div class="children"><div class="content">Interestingly, RISC-V&#x27;s Zicfilp proposal includes an optional, 20-bit label operand so that call sites and targets can be paired more strictly.<p>I&#x27;m not sure how or if it addresses trampolines and similar thunks that interpose callee and caller, but which don&#x27;t necessarily touch arguments. Such thunks are quite common in dynamically linked code as ELF and Mach-O do lazy loading by default--dynamic function symbols are initially small thunks that load the dependency and then forward the call, restoring registers and the stack without having to know the call signature.</div><br/></div></div></div></div></div></div><div id="39472712" class="c"><input type="checkbox" id="c-39472712" checked=""/><div class="controls bullet"><span class="by">seppel</span><span>|</span><a href="#39472133">root</a><span>|</span><a href="#39472296">parent</a><span>|</span><a href="#39473147">prev</a><span>|</span><a href="#39474071">next</a><span>|</span><label class="collapse" for="c-39472712">[-]</label><label class="expand" for="c-39472712">[1 more]</label></div><br/><div class="children"><div class="content">X86 has ENDBR32 and ENDBR64 (end branch) for this.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39474071" class="c"><input type="checkbox" id="c-39474071" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39472133">prev</a><span>|</span><a href="#39474272">next</a><span>|</span><label class="collapse" for="c-39474071">[-]</label><label class="expand" for="c-39474071">[1 more]</label></div><br/><div class="children"><div class="content">Neat. Is the expected consumer here meant to be debuggers, or a crash with security implication?</div><br/></div></div><div id="39474272" class="c"><input type="checkbox" id="c-39474272" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#39474071">prev</a><span>|</span><label class="collapse" for="c-39474272">[-]</label><label class="expand" for="c-39474272">[1 more]</label></div><br/><div class="children"><div class="content">Similar on approach on the &#x27;S&#x27; malloc.conf setting I guess.</div><br/></div></div></div></div></div></div></div></body></html>