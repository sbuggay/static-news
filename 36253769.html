<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1686301251749" as="style"/><link rel="stylesheet" href="styles.css?v=1686301251749"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/geoffreytools/free-types">Free-types: Higher kinded types in TypeScript</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>DesertVarnish</span> | <span>28 comments</span></div><br/><div><div id="36254536" class="c"><input type="checkbox" id="c-36254536" checked=""/><div class="controls bullet"><span class="by">esperent</span><span>|</span><a href="#36254251">next</a><span>|</span><label class="collapse" for="c-36254536">[-]</label><label class="expand" for="c-36254536">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m reasonably proficient in Typescript although I wouldn&#x27;t call myself an expert in type systems. But I&#x27;m not a beginner either.<p>However, I read though the readme and I have no idea what the usefulness of this is. Can anyone explain, in simple terms, some practical use cases for this?</div><br/><div id="36255096" class="c"><input type="checkbox" id="c-36255096" checked=""/><div class="controls bullet"><span class="by">demurgos</span><span>|</span><a href="#36254536">parent</a><span>|</span><a href="#36255026">next</a><span>|</span><label class="collapse" for="c-36255096">[-]</label><label class="expand" for="c-36255096">[1 more]</label></div><br/><div class="children"><div class="content">A situation where I need this were typings for Cycle.js a couple years ago.
At this time, you could configure it to use the observable library of your choice but it was hard to type. In particular the observable could be a `Stream from &quot;xstream&quot;` or `Observable from &quot;rxjs&quot;`<p>This lib has a method `select` to return an observable list of DOM elements for a given CSS selector. What should be its signature? If using `xstream`, it should be `select(selector: string): Stream&lt;HTMLElement[]&gt;`, and if using `rxjs` it should be `select(selector: string): Observable&lt;HTMLElement[]&gt;`. Let&#x27;s also assume that it has a second method `windowHeight` returning an observable for the window height (`Stream&lt;number&gt;` or `Observable&lt;number&gt;`).<p>We can make the lib object generic over the observable lib, but you need HKTs to type it properly. The reason is that the lib is generic over an already generic type.<p>Here is an example:<p><pre><code>    &#x2F;&#x2F; Without HKT (regular generic)
    &#x2F;&#x2F; Problem: both `select` and `windowHeight` return the same generic
    interface Cycle&lt;Obs&gt; {
      select(selector: string): Obs;
      windowHeight(): Obs;
    }
    &#x2F;&#x2F; The best we can do is type it as `Cycle&lt;Stream&lt;unknown&gt;&gt;` or `Cycle&lt;rxjs.Observable&lt;unknown&gt;&gt;`.
    
    &#x2F;&#x2F; With HKTs, using syntax from this lib, you could do:
    interface Cycle&lt;$HktObs&gt; {
      select(selector: string): apply&lt;$HktObs, HTMLElement[]&gt;;
      windowHeight(): apply&lt;$HktObs, number&gt;;
    }
    &#x2F;&#x2F; This allows to get the exact signature (with the right observable lib, without `unknown`)</code></pre></div><br/></div></div><div id="36255026" class="c"><input type="checkbox" id="c-36255026" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#36254536">parent</a><span>|</span><a href="#36255096">prev</a><span>|</span><a href="#36254771">next</a><span>|</span><label class="collapse" for="c-36255026">[-]</label><label class="expand" for="c-36255026">[1 more]</label></div><br/><div class="children"><div class="content">Higher (-order) kinded types describe functions on type constructors. Type constructors are &quot;generic types&quot;, like `T[]` that generate a list from a single type `T` or like `Map&lt;S, T&gt;` that generates a new type from two types `S` and `T`. A higher kinded type constructor is one, where you could use any (well, with certain prerequisites) of these type constructors to generate a new type. Let&#x27;s say you want to have a function `map` (like `Array.map`) that works not only with `T[]` but also with `Tree&lt;T&gt;`, `Maybe&lt;T&gt;` (`= T | undefined`), ... HKT give you the possibility to write the type of such type functions.</div><br/></div></div><div id="36254771" class="c"><input type="checkbox" id="c-36254771" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#36254536">parent</a><span>|</span><a href="#36255026">prev</a><span>|</span><a href="#36254251">next</a><span>|</span><label class="collapse" for="c-36254771">[-]</label><label class="expand" for="c-36254771">[3 more]</label></div><br/><div class="children"><div class="content">The thing is, it takes a bit of experience to appreciate why HKT are important, and typically you can only get this experience using Haskell.<p>There’s a couple of ways to think about it: it gives you a way to talk about List rather than List of T, it enables you to write partial types like partially-applied functions, or it makes it possible to define Monads.<p>But as I say, none of these things will sound immediately useful unless you have experience of using those concepts already.</div><br/><div id="36254944" class="c"><input type="checkbox" id="c-36254944" checked=""/><div class="controls bullet"><span class="by">evolveyourmind</span><span>|</span><a href="#36254536">root</a><span>|</span><a href="#36254771">parent</a><span>|</span><a href="#36254947">next</a><span>|</span><label class="collapse" for="c-36254944">[-]</label><label class="expand" for="c-36254944">[1 more]</label></div><br/><div class="children"><div class="content">Other than Monads, HKT can be used to easily write type-level functional programs [1]. This can for example help writing type-level parsers for other lanugages.<p>A real world use-case could be parsing GraphQL raw string queries and automatically infer the returned types based on a common schema, without using special code-generators.
For instance you can come up with some magic function `gql_parsed` like:<p>doc = gql_parsed`query GetUser {  user { name }}`<p>where doc is inferred as something like 
Doc&lt;Query&lt;{GetUser:{user:{name:string}}}&gt;&gt;<p>[1] <a href="https:&#x2F;&#x2F;desislav.dev&#x2F;blog&#x2F;tsfp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;desislav.dev&#x2F;blog&#x2F;tsfp&#x2F;</a></div><br/></div></div><div id="36254947" class="c"><input type="checkbox" id="c-36254947" checked=""/><div class="controls bullet"><span class="by">gizmo</span><span>|</span><a href="#36254536">root</a><span>|</span><a href="#36254771">parent</a><span>|</span><a href="#36254944">prev</a><span>|</span><a href="#36254251">next</a><span>|</span><label class="collapse" for="c-36254947">[-]</label><label class="expand" for="c-36254947">[1 more]</label></div><br/><div class="children"><div class="content">I think there is a certain kind of programmer who enjoys the aesthetics of higher-kinded types, and after having made the investment to truly grok them, wants these HKTs to also be useful in practice.<p>I don’t think the benefit ever materializes and highly abstract code is just indulgence.<p>Much like the people who endlessly tinker with their IDE&#x2F;emacs&#x2F;desktop environment&#x2F;shell in the name of productivity.</div><br/></div></div></div></div></div></div><div id="36254251" class="c"><input type="checkbox" id="c-36254251" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#36254536">prev</a><span>|</span><a href="#36254178">next</a><span>|</span><label class="collapse" for="c-36254251">[-]</label><label class="expand" for="c-36254251">[5 more]</label></div><br/><div class="children"><div class="content">I wonder if there is any relationship between HKT and C#&#x2F;Rust generics, from my perspective I always see HKT as &quot;A type that accepts types that generates another type&quot; and generic as &quot;A functor that accepts types that generates another type&quot;. That makes me wonder if types and functors are exchangable.</div><br/><div id="36254561" class="c"><input type="checkbox" id="c-36254561" checked=""/><div class="controls bullet"><span class="by">pdpi</span><span>|</span><a href="#36254251">parent</a><span>|</span><a href="#36255047">next</a><span>|</span><label class="collapse" for="c-36254561">[-]</label><label class="expand" for="c-36254561">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s easier to make the parallel between type-level and value-level reasoning.<p>1 is a value, and int is a concrete type.<p>function increment(x) { return x + 1 } is a value-level function. You feed it a value x and you get a value back. List&lt;T&gt; is a type-level function: you give it a concrete type T, you get another type back.<p>function applyTwice(f, x) { return f(f(x)) } is a higher-order function that takes a functions as an input. A higher-kinded type is a higher-order type function.<p>As a concrete example, consider this pseudo-Java method:<p><pre><code>    List&lt;B&gt; map&lt;A,B&gt;(Function&lt;A,B&gt; fn, List&lt;A&gt; as) { ... }
</code></pre>
You take a list, and you return a list. Thing is, Java has several list implementations: LinkedList, ArrayList, CopyOnWriteArrayList, and a few others. What I&#x27;d like to express is that whatever concrete list type goes in is <i>also</i> the concrete type that comes out. If java allowed it, you could express it like this:<p><pre><code>    L&lt;B&gt; map&lt;L&lt;T&gt; extends List&lt;T&gt;,A,B&gt;(Function&lt;A,B&gt; fn, L&lt;A&gt; as) { ... }

</code></pre>
This map is generic on L, A, and B, but also L is itself generic, so map is &quot;twice-generic&quot;, if you will.</div><br/></div></div><div id="36255047" class="c"><input type="checkbox" id="c-36255047" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#36254251">parent</a><span>|</span><a href="#36254561">prev</a><span>|</span><a href="#36254443">next</a><span>|</span><label class="collapse" for="c-36255047">[-]</label><label class="expand" for="c-36255047">[2 more]</label></div><br/><div class="children"><div class="content">&quot;A type that accepts types that generates another type&quot; is called a type constructor. And a &quot;kind&quot; is the type of a type constructor, just to have a new name and not needing to call that &quot;type&quot; too.  
&quot;Generic types&quot; like `Vec&lt;T&gt;` (in Rust) are type constructors, they &quot;generate&quot; a type `Vec&lt;T&gt;` from the type `T`. Type constructors that take one type as argument have the kind `* -&gt; *` (or as Rust-y notation `fn(*) -&gt; *` - read each asterisk as &quot;type&quot;. Type constructor that take two types arguments have the kind `* -&gt; * -&gt; *` (Rust-y: `fn(*, *) -&gt; *`).
A higher (-order) kinded type takes (for example) a type constructor (here a type constructor which takes just one argument) and generates a type from it: `(* -&gt; *) -&gt; *` (Rust-y: `fn(fn(*) -&gt; *) -&gt; *`.<p>Edit: I hope now all asterisks are properly escaped ...</div><br/><div id="36255137" class="c"><input type="checkbox" id="c-36255137" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#36254251">root</a><span>|</span><a href="#36255047">parent</a><span>|</span><a href="#36254443">next</a><span>|</span><label class="collapse" for="c-36255137">[-]</label><label class="expand" for="c-36255137">[1 more]</label></div><br/><div class="children"><div class="content">Edit2: oh, I guess misunderstood &quot;A type that accepts types that generates another type&quot;. If you meant to say &quot;A type that accepts (types that generates another type)&quot;, so a type constructor that accepts type constructors and not &quot;(A type that accepts types) that generates another type&quot;, which is a type constructor.</div><br/></div></div></div></div><div id="36254443" class="c"><input type="checkbox" id="c-36254443" checked=""/><div class="controls bullet"><span class="by">DougBTX</span><span>|</span><a href="#36254251">parent</a><span>|</span><a href="#36255047">prev</a><span>|</span><a href="#36254178">next</a><span>|</span><label class="collapse" for="c-36254443">[-]</label><label class="expand" for="c-36254443">[1 more]</label></div><br/><div class="children"><div class="content">For Rust, pre-GAT, there was no way to “output” a type which could be “called” with further arguments (very fuzzy terminology, sorry, best I can do!) or maybe in other words, you could write functions which retuned values, but not new functions.<p>Nowadays, GATs support a bigger subset of HKTs, but still not everything as I understand it.<p><a href="https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;2022&#x2F;10&#x2F;28&#x2F;gats-stabilization.html" rel="nofollow">https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;2022&#x2F;10&#x2F;28&#x2F;gats-stabilization.htm...</a></div><br/></div></div></div></div><div id="36254178" class="c"><input type="checkbox" id="c-36254178" checked=""/><div class="controls bullet"><span class="by">noobdev9000</span><span>|</span><a href="#36254251">prev</a><span>|</span><a href="#36254222">next</a><span>|</span><label class="collapse" for="c-36254178">[-]</label><label class="expand" for="c-36254178">[4 more]</label></div><br/><div class="children"><div class="content">Why</div><br/><div id="36254538" class="c"><input type="checkbox" id="c-36254538" checked=""/><div class="controls bullet"><span class="by">mbwgh</span><span>|</span><a href="#36254178">parent</a><span>|</span><a href="#36254222">next</a><span>|</span><label class="collapse" for="c-36254538">[-]</label><label class="expand" for="c-36254538">[3 more]</label></div><br/><div class="children"><div class="content">A simple example I could recall from the other day is something like this:<p><pre><code>  export type LinkedWorksheetsRecord = Record&lt;WorksheetId, Record&lt;WorksheetId, ReferenceTypeId[]&gt;&gt;;
  export type LinkedWorksheetsMap = Map&lt;WorksheetId, Map&lt;WorksheetId, ReferenceTypeId[]&gt;&gt;;
</code></pre>
What I would rather have written instead is however something like this:<p><pre><code>  export type LinkedWorksheets&lt;T&gt; = T&lt;WorksheetId, T&lt;WorksheetId, ReferenceTypeId[]&gt;&gt;;
  ...
  const myMap: LinkedWorksheets&lt;Map&gt; = ...;
</code></pre>
This is however not possible, because `Map` is a type constructor which expects two more type arguments `K, V` until it is a fully applied, concrete type `Map&lt;K, V&gt;`.<p>With a library like this, this is probably possible (unless I&#x27;ve missed something which wouldn&#x27;t surprise me). It would unfortunately surely be more verbose.<p>Still, I would be against pulling in a dependency only for something like this. The above example is simple I believe, but not exactly a &quot;killer-app&quot;.
And no, Monads aren&#x27;t either (if you don&#x27;t limit effects and don&#x27;t have do-notation) :P</div><br/><div id="36254757" class="c"><input type="checkbox" id="c-36254757" checked=""/><div class="controls bullet"><span class="by">ivxvm</span><span>|</span><a href="#36254178">root</a><span>|</span><a href="#36254538">parent</a><span>|</span><a href="#36254222">next</a><span>|</span><label class="collapse" for="c-36254757">[-]</label><label class="expand" for="c-36254757">[2 more]</label></div><br/><div class="children"><div class="content">Not really possible, because Record and Map aren&#x27;t compatible at all.
At best they both have something like `toString`.
You&#x27;ll need to define at least something like RecordFunctor&lt;T&gt; and MapFunctor&lt;T&gt; to make this useful.</div><br/><div id="36254800" class="c"><input type="checkbox" id="c-36254800" checked=""/><div class="controls bullet"><span class="by">mbwgh</span><span>|</span><a href="#36254178">root</a><span>|</span><a href="#36254757">parent</a><span>|</span><a href="#36254222">next</a><span>|</span><label class="collapse" for="c-36254800">[-]</label><label class="expand" for="c-36254800">[1 more]</label></div><br/><div class="children"><div class="content">Only if you want to abstract over them at usage-site.<p>In my case I only ever used the concrete types and converted between them at some point.</div><br/></div></div></div></div></div></div></div></div><div id="36254222" class="c"><input type="checkbox" id="c-36254222" checked=""/><div class="controls bullet"><span class="by">ToJans</span><span>|</span><a href="#36254178">prev</a><span>|</span><a href="#36254088">next</a><span>|</span><label class="collapse" for="c-36254222">[-]</label><label class="expand" for="c-36254222">[2 more]</label></div><br/><div class="children"><div class="content">Looking forward to a proper monad lib in Typescript!<p>However, I can only assume that molding&#x2F;abusing types like this might have a big - if not huge - impact on compilation times...<p>I&#x27;ve created a template-like generic type that allows you compose multiple kinds and replace any property of an object with a function returning the same type as the property, and vscode has such a hard time inferring types that intellisense has become unusable in this context.<p>Curious to see how this will turn out.</div><br/><div id="36254270" class="c"><input type="checkbox" id="c-36254270" checked=""/><div class="controls bullet"><span class="by">arnejenssen</span><span>|</span><a href="#36254222">parent</a><span>|</span><a href="#36254088">next</a><span>|</span><label class="collapse" for="c-36254270">[-]</label><label class="expand" for="c-36254270">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m using fp-ts <a href="https:&#x2F;&#x2F;gcanti.github.io&#x2F;fp-ts&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gcanti.github.io&#x2F;fp-ts&#x2F;</a></div><br/></div></div></div></div><div id="36254088" class="c"><input type="checkbox" id="c-36254088" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#36254222">prev</a><span>|</span><a href="#36254772">next</a><span>|</span><label class="collapse" for="c-36254088">[-]</label><label class="expand" for="c-36254088">[1 more]</label></div><br/><div class="children"><div class="content">I wonder how this differs from HKT&#x27;s implementation in fp-ts 2 and Effect-TS.<p><a href="https:&#x2F;&#x2F;gcanti.github.io&#x2F;fp-ts&#x2F;modules&#x2F;HKT.ts.html" rel="nofollow">https:&#x2F;&#x2F;gcanti.github.io&#x2F;fp-ts&#x2F;modules&#x2F;HKT.ts.html</a></div><br/></div></div><div id="36254772" class="c"><input type="checkbox" id="c-36254772" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36254088">prev</a><span>|</span><a href="#36254040">next</a><span>|</span><label class="collapse" for="c-36254772">[-]</label><label class="expand" for="c-36254772">[1 more]</label></div><br/><div class="children"><div class="content">Are these like type classes?</div><br/></div></div><div id="36254040" class="c"><input type="checkbox" id="c-36254040" checked=""/><div class="controls bullet"><span class="by">davedx</span><span>|</span><a href="#36254772">prev</a><span>|</span><label class="collapse" for="c-36254040">[-]</label><label class="expand" for="c-36254040">[8 more]</label></div><br/><div class="children"><div class="content">I’d love to be able to do dependent types in TS. Does this make that possible?</div><br/><div id="36255142" class="c"><input type="checkbox" id="c-36255142" checked=""/><div class="controls bullet"><span class="by">pyrale</span><span>|</span><a href="#36254040">parent</a><span>|</span><a href="#36254315">next</a><span>|</span><label class="collapse" for="c-36255142">[-]</label><label class="expand" for="c-36255142">[1 more]</label></div><br/><div class="children"><div class="content">I guess you <i>could</i> use it to implement an algebra that allows you to build dependent types, but that would be unfit for practical uses.<p>As a case in point, Haskell has first-class experience for HKTs, and dependent types implementation in haskell is getting hindered by the limits of the language.</div><br/></div></div><div id="36254315" class="c"><input type="checkbox" id="c-36254315" checked=""/><div class="controls bullet"><span class="by">frogulis</span><span>|</span><a href="#36254040">parent</a><span>|</span><a href="#36255142">prev</a><span>|</span><a href="#36254440">next</a><span>|</span><label class="collapse" for="c-36254315">[-]</label><label class="expand" for="c-36254315">[3 more]</label></div><br/><div class="children"><div class="content">Might be wrong here, but I&#x27;m of the understanding that a dependent type system is undecidable, and so to have static dependent types you need to have a more restricted language, like the inability to write arbitrarily recursive functions.<p>In short I don&#x27;t think so but I&#x27;d also love a good explanation as to why I&#x27;m wrong.</div><br/><div id="36254544" class="c"><input type="checkbox" id="c-36254544" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#36254040">root</a><span>|</span><a href="#36254315">parent</a><span>|</span><a href="#36254419">next</a><span>|</span><label class="collapse" for="c-36254544">[-]</label><label class="expand" for="c-36254544">[1 more]</label></div><br/><div class="children"><div class="content">A fully-featured dependent type system may be undecidable, but that doesn&#x27;t mean you can&#x27;t make one - it just means that there will be valid programs that the type checker nevertheless rejects, or there will be valid programs for which the type checker never terminates. It doesn&#x27;t stop you from creating a type checker in the first place; it just weakens the guarantees you can make about that type checker.<p>The Typescript type checker is (or at least was) already Turing-complete (<a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;14833">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;14833</a>) without fully supporting dependent types.</div><br/></div></div><div id="36254419" class="c"><input type="checkbox" id="c-36254419" checked=""/><div class="controls bullet"><span class="by">pxeger1</span><span>|</span><a href="#36254040">root</a><span>|</span><a href="#36254315">parent</a><span>|</span><a href="#36254544">prev</a><span>|</span><a href="#36254440">next</a><span>|</span><label class="collapse" for="c-36254419">[-]</label><label class="expand" for="c-36254419">[1 more]</label></div><br/><div class="children"><div class="content">Typescript&#x27;s type system is already undecidable (except that they limit recursion depth). I don&#x27;t know much about dependent types but I&#x27;d guess it similarly doesn&#x27;t matter much in practice that in the general case they&#x27;re undecidable?</div><br/></div></div></div></div><div id="36254440" class="c"><input type="checkbox" id="c-36254440" checked=""/><div class="controls bullet"><span class="by">amitport</span><span>|</span><a href="#36254040">parent</a><span>|</span><a href="#36254315">prev</a><span>|</span><label class="collapse" for="c-36254440">[-]</label><label class="expand" for="c-36254440">[3 more]</label></div><br/><div class="children"><div class="content">No. Typescript cannot access runtime values (I assume you mean types that depend on runtime values). In TypeScript types can depend on other types and it does support literal types which covers a lot of use cases. What do you need dependent types for?<p>[Edit: why the down vote?]</div><br/><div id="36255086" class="c"><input type="checkbox" id="c-36255086" checked=""/><div class="controls bullet"><span class="by">pyrale</span><span>|</span><a href="#36254040">root</a><span>|</span><a href="#36254440">parent</a><span>|</span><a href="#36254777">next</a><span>|</span><label class="collapse" for="c-36255086">[-]</label><label class="expand" for="c-36255086">[1 more]</label></div><br/><div class="children"><div class="content">&gt; No. Typescript cannot access runtime values (I assume you mean types that depend on runtime values).<p>That&#x27;s not the meaning of dependent types, and dependent type checkers don&#x27;t require runtime information.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>