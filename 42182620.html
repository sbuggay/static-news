<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732525268515" as="style"/><link rel="stylesheet" href="styles.css?v=1732525268515"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://xahlee.info/comp/ocaml_let_syntax.html">OCaml Syntax Sucks (2016)</a> <span class="domain">(<a href="http://xahlee.info">xahlee.info</a>)</span></div><div class="subtext"><span>Qem</span> | <span>61 comments</span></div><br/><div><div id="42232880" class="c"><input type="checkbox" id="c-42232880" checked=""/><div class="controls bullet"><span class="by">wk_end</span><span>|</span><a href="#42233137">next</a><span>|</span><label class="collapse" for="c-42232880">[-]</label><label class="expand" for="c-42232880">[12 more]</label></div><br/><div class="children"><div class="content">The title is a little inflammatory. The critique is specifically about Ocaml’s handling of let-bindings. AFAICT OP thinks the syntax sucks because:<p>1. there’s no marker to indicate the end of let scopes<p>2. functions are bound with the same syntax as constants<p>He asserts that this is confusing. In practice - for the many issues I have with Ocaml! - neither of these are actual issues, in my experience, once code formatting is applied.<p>An actual serious problem with Ocaml’s syntax is that matches don’t have a terminator, leading people to mess up nested matches frequently. Pair that with the parser’s poor error reporting&#x2F;recovery and things can become unpleasant quickly.</div><br/><div id="42234222" class="c"><input type="checkbox" id="c-42234222" checked=""/><div class="controls bullet"><span class="by">p4bl0</span><span>|</span><a href="#42232880">parent</a><span>|</span><a href="#42233030">next</a><span>|</span><label class="collapse" for="c-42234222">[-]</label><label class="expand" for="c-42234222">[1 more]</label></div><br/><div class="children"><div class="content">I was coming to say exactly this. I use OCaml a lot and never had a problem with lets. On the other hand, nested match with where you must either use parentheses or begin…end can be confusing for beginners and stays annoying forever.</div><br/></div></div><div id="42233030" class="c"><input type="checkbox" id="c-42233030" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42232880">parent</a><span>|</span><a href="#42234222">prev</a><span>|</span><a href="#42233964">next</a><span>|</span><label class="collapse" for="c-42233030">[-]</label><label class="expand" for="c-42233030">[6 more]</label></div><br/><div class="children"><div class="content">Fortunately, the OCaml compiler is very modular, and there have been efforts to make things more... reasonable.<p>- Reason, a different syntactic frontend for regular OCaml: <a href="https:&#x2F;&#x2F;reasonml.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;reasonml.github.io&#x2F;</a><p>- ReScript, a language with OCaml semantics that compiles into: JS <a href="https:&#x2F;&#x2F;rescript-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rescript-lang.org&#x2F;</a> (I suppose it&#x27;s a reincarnation of js-of-ocaml).</div><br/><div id="42233627" class="c"><input type="checkbox" id="c-42233627" checked=""/><div class="controls bullet"><span class="by">jey</span><span>|</span><a href="#42232880">root</a><span>|</span><a href="#42233030">parent</a><span>|</span><a href="#42233730">next</a><span>|</span><label class="collapse" for="c-42233627">[-]</label><label class="expand" for="c-42233627">[1 more]</label></div><br/><div class="children"><div class="content">ReScript is better described as a descendant (and fork) of ReasonML aimed to fit into the JS ecosystem. In contrast to js_of_ocaml, ReScript prioritizes interoperability with existing JS code and APIs over interop with existing OCaml code, whereas js_of_ocaml takes the opposite approach. So people looking for an improved version of JavaScript or TypeScript should probably choose ReScript, but people who are porting an existing OCaml program might prefer js_of_ocaml.</div><br/></div></div><div id="42233730" class="c"><input type="checkbox" id="c-42233730" checked=""/><div class="controls bullet"><span class="by">JoelJacobson</span><span>|</span><a href="#42232880">root</a><span>|</span><a href="#42233030">parent</a><span>|</span><a href="#42233627">prev</a><span>|</span><a href="#42233554">next</a><span>|</span><label class="collapse" for="c-42233730">[-]</label><label class="expand" for="c-42233730">[3 more]</label></div><br/><div class="children"><div class="content">I love the idea of Reason&#x2F;ReScript. I hope they can figure out a way to work together and join forces somehow, the contributions to both repos seems to have faded over the last years, but maybe that&#x27;s because the projects have stabilized, I don&#x27;t know.<p>I&#x27;ve had lots of fun playing with Reason a few years ago. I created an interactive real-time visualization tool, to see a Regexp transform into a NFA to DFA to minimal DFA graph: <a href="http:&#x2F;&#x2F;compiler.org&#x2F;reason-re-nfa&#x2F;src&#x2F;index.html" rel="nofollow">http:&#x2F;&#x2F;compiler.org&#x2F;reason-re-nfa&#x2F;src&#x2F;index.html</a>
It only works for basic regexes though.</div><br/><div id="42234467" class="c"><input type="checkbox" id="c-42234467" checked=""/><div class="controls bullet"><span class="by">chrischen</span><span>|</span><a href="#42232880">root</a><span>|</span><a href="#42233730">parent</a><span>|</span><a href="#42233874">next</a><span>|</span><label class="collapse" for="c-42234467">[-]</label><label class="expand" for="c-42234467">[1 more]</label></div><br/><div class="children"><div class="content">The ReasonML workflow continued on as Melange.<p><a href="https:&#x2F;&#x2F;melange.re" rel="nofollow">https:&#x2F;&#x2F;melange.re</a></div><br/></div></div><div id="42233874" class="c"><input type="checkbox" id="c-42233874" checked=""/><div class="controls bullet"><span class="by">danielstocks</span><span>|</span><a href="#42232880">root</a><span>|</span><a href="#42233730">parent</a><span>|</span><a href="#42234467">prev</a><span>|</span><a href="#42233554">next</a><span>|</span><label class="collapse" for="c-42233874">[-]</label><label class="expand" for="c-42233874">[1 more]</label></div><br/><div class="children"><div class="content">I can’t speak for Reason but the ReScript project and community is very alive and vibrant. There’s been some major improvements over the past year and overall it’s much more appealing and mature now compared with only a few years ago. We’ve been using it in a fairly large React app for a while and the experience has been very good.</div><br/></div></div></div></div><div id="42233554" class="c"><input type="checkbox" id="c-42233554" checked=""/><div class="controls bullet"><span class="by">BrawnyBadger53</span><span>|</span><a href="#42232880">root</a><span>|</span><a href="#42233030">parent</a><span>|</span><a href="#42233730">prev</a><span>|</span><a href="#42233964">next</a><span>|</span><label class="collapse" for="c-42233554">[-]</label><label class="expand" for="c-42233554">[1 more]</label></div><br/><div class="children"><div class="content">I feel like ReasonML should have the capacity to help bridge the gap for people learning ocaml if it weren&#x27;t so hidden.</div><br/></div></div></div></div><div id="42233964" class="c"><input type="checkbox" id="c-42233964" checked=""/><div class="controls bullet"><span class="by">soraminazuki</span><span>|</span><a href="#42232880">parent</a><span>|</span><a href="#42233030">prev</a><span>|</span><a href="#42234045">next</a><span>|</span><label class="collapse" for="c-42233964">[-]</label><label class="expand" for="c-42233964">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The title is a little inflammatory<p>I think you’re being generous. The example the author gave is awful because any language can be made illegible if you cram in complicated expressions with multiple levels of nesting into a single line. I’d say it’s <i>outright</i> flamebait.</div><br/></div></div><div id="42234045" class="c"><input type="checkbox" id="c-42234045" checked=""/><div class="controls bullet"><span class="by">pyrale</span><span>|</span><a href="#42232880">parent</a><span>|</span><a href="#42233964">prev</a><span>|</span><a href="#42233799">next</a><span>|</span><label class="collapse" for="c-42234045">[-]</label><label class="expand" for="c-42234045">[1 more]</label></div><br/><div class="children"><div class="content">&gt; functions are bound with the same syntax as constants<p>Apparently, the author hasn&#x27;t come around to understanding that functions are just another constant.</div><br/></div></div><div id="42233799" class="c"><input type="checkbox" id="c-42233799" checked=""/><div class="controls bullet"><span class="by">remexre</span><span>|</span><a href="#42232880">parent</a><span>|</span><a href="#42234045">prev</a><span>|</span><a href="#42233494">next</a><span>|</span><label class="collapse" for="c-42233799">[-]</label><label class="expand" for="c-42233799">[1 more]</label></div><br/><div class="children"><div class="content">i agree an autoformatter alleviates the let decl&#x2F;expr in practice, especially for an experienced user; an autoformatter also fixes nested matches too ime.<p>however, my university has a mandatory class taught in ocaml, which i&#x27;ve ta&#x27;d for a few times; this is the _number one_ &quot;the undergrad ta couldn&#x27;t figure out my syntax error&quot; issue students have</div><br/></div></div><div id="42233494" class="c"><input type="checkbox" id="c-42233494" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#42232880">parent</a><span>|</span><a href="#42233799">prev</a><span>|</span><a href="#42233137">next</a><span>|</span><label class="collapse" for="c-42233494">[-]</label><label class="expand" for="c-42233494">[1 more]</label></div><br/><div class="children"><div class="content">Totally agree.  In particular when I read #2 I was really scratching my head. It&#x27;s a functional language - the thing on the left of the equals sign is a pattern. Apart from the argument you pass, patterns for functions look similar to patterns for constants precisely because in a functional language everything looks like a function.  And everything looks like a function because just about everything <i>is</i> a function.<p>The match terminator end thing made me sad when I first saw this in Ocaml.  So many languages (C, bourne shell, etc etc) have this exact same problem and it completely sucks in all of them. It&#x27;s more debilitating in a functional language specifically because matches are more useful than say C case statements so you want to use them much more extensively.<p>I frequently want to do a pattern match to unpack something and then a further pattern match to unpack further - a nested match is a very intuitive thing to want. Yes you can normally unnest such a match into more complicated matches at the parent level but this is usually much harder for humans to understand.<p>...and if you had a marker for ending match scopes you could always just reuse that to end let scopes as well if you wanted to although I&#x27;ve literally never a single time run into that as a practical problem (although I haven&#x27;t written <i>that</i> much OCaml you&#x27;d think if it was a real issue I would have banged into it at least once because I found a fair few sharp edges in my time with the language).</div><br/></div></div></div></div><div id="42233137" class="c"><input type="checkbox" id="c-42233137" checked=""/><div class="controls bullet"><span class="by">laylomo2</span><span>|</span><a href="#42232880">prev</a><span>|</span><a href="#42234182">next</a><span>|</span><label class="collapse" for="c-42233137">[-]</label><label class="expand" for="c-42233137">[3 more]</label></div><br/><div class="children"><div class="content">The more I used ocaml the more I found beauty in the syntax. It’s very ergonomic in many ways:<p>1. It’s whitespace insensitive, which means I can code something up really messy and the code formatted will automatically fix it up for me.<p>2. In general there aren’t a ton of punctuation characters that are very common, which is great for typing ergonomics. Don’t get me wrong, there are still a lot of symbols, but I feel compared to some languages such as Rust, they’re used a lot less.<p>Beyond the syntax, there are a couple of things I really like about the language itself:<p>1. Due to the way the language is scoped, whenever you encounter a variable you don’t recognize, you simply have to search in the up direction to find its definition, unless it’s explicitly marked as “rec”. This is helpful if you’re browsing code without any IDE tooling, there’s less guessing involved in finding where things are defined. Downside: if the “open” keyword is used to put all of a module’s values in scope, you’re usually gonna have a bad time.<p>2. The core language is very simple; in general there are three kinds of things that matter: values, types, and modules. All values have a type, and all values and types are defined in modules.<p>3. It’s very easy to nest let bindings in order to help localize the scope of intermediate values.<p>4. It has a very fast compiler with separate compilation. The dev cycle is usually very tight (oftentimes practically instantaneous).<p>5. Most of the language encourages good practice through sane defaults, but accessing escape hatches to do “dirty” things is very easy to do.<p>6. The compiler has some restrictions which may seem arcane, such as the value restriction and weak type variables, but they are valuable in preventing you from shooting yourself in the foot, and they enable some other useful features of the language such as local mutation.</div><br/><div id="42233678" class="c"><input type="checkbox" id="c-42233678" checked=""/><div class="controls bullet"><span class="by">bloomingkales</span><span>|</span><a href="#42233137">parent</a><span>|</span><a href="#42234182">next</a><span>|</span><label class="collapse" for="c-42233678">[-]</label><label class="expand" for="c-42233678">[2 more]</label></div><br/><div class="children"><div class="content"><i>2. In general there aren’t a ton of punctuation characters that are very common, which is great for typing ergonomics. Don’t get me wrong, there are still a lot of symbols, but I feel compared to some languages such as Rust, they’re used a lot less.</i><p>I never really seen someone put that into words. I always feel a certain kind of weird when I look at a language with tons of punctuation (Typescript is good example).</div><br/><div id="42233889" class="c"><input type="checkbox" id="c-42233889" checked=""/><div class="controls bullet"><span class="by">akkad33</span><span>|</span><a href="#42233137">root</a><span>|</span><a href="#42233678">parent</a><span>|</span><a href="#42234182">next</a><span>|</span><label class="collapse" for="c-42233889">[-]</label><label class="expand" for="c-42233889">[1 more]</label></div><br/><div class="children"><div class="content">The lambda syntax and default lambda parameters alone make typescript very hard to parse</div><br/></div></div></div></div></div></div><div id="42234182" class="c"><input type="checkbox" id="c-42234182" checked=""/><div class="controls bullet"><span class="by">pxeger1</span><span>|</span><a href="#42233137">prev</a><span>|</span><a href="#42233824">next</a><span>|</span><label class="collapse" for="c-42234182">[-]</label><label class="expand" for="c-42234182">[1 more]</label></div><br/><div class="children"><div class="content">I believe OCaml&#x27;s syntax does suck, but I don’t think this article gives a compelling argument as to why. Missing an `in` turns a let expression into a top level binding and kicks a syntax error often a long way down the file, making it very hard to identify the cause. The relative precedence of let, if, match, fun, and the semicolon is unintuitive and hard to remember, making me want to add loads of unnecessary and ugly parentheses.<p>On the other hand, I like that there&#x27;s little overloaded syntax, and the meaning of different characters is fairly consistent.</div><br/></div></div><div id="42233824" class="c"><input type="checkbox" id="c-42233824" checked=""/><div class="controls bullet"><span class="by">user2342</span><span>|</span><a href="#42234182">prev</a><span>|</span><a href="#42232851">next</a><span>|</span><label class="collapse" for="c-42233824">[-]</label><label class="expand" for="c-42233824">[2 more]</label></div><br/><div class="children"><div class="content">Weak arguments in the article with badly chosen examples.<p>If one wanted to criticize OCaml syntax, the need for .mli-files (with different syntax for function signatures) and the rather clunky module&#x2F;signature syntax would be better candidates.</div><br/><div id="42233933" class="c"><input type="checkbox" id="c-42233933" checked=""/><div class="controls bullet"><span class="by">_flux</span><span>|</span><a href="#42233824">parent</a><span>|</span><a href="#42232851">next</a><span>|</span><label class="collapse" for="c-42233933">[-]</label><label class="expand" for="c-42233933">[1 more]</label></div><br/><div class="children"><div class="content">I actually rather like the mli-files. It&#x27;s a nice file to read, with the documentation and externally available symbols only. However, the fact that the syntax is so different is a bit annoying.<p>Sometimes I wrote (haven&#x27;t written OCaml for some time now..) functions like:<p><pre><code>    let foo: int -&gt; int = fun x -&gt;
      ..
</code></pre>
just to make them more similar to the syntax<p><pre><code>    val foo: int -&gt; int
</code></pre>
in the module types.</div><br/></div></div></div></div><div id="42232851" class="c"><input type="checkbox" id="c-42232851" checked=""/><div class="controls bullet"><span class="by">the_clarence</span><span>|</span><a href="#42233824">prev</a><span>|</span><a href="#42233126">next</a><span>|</span><label class="collapse" for="c-42232851">[-]</label><label class="expand" for="c-42232851">[4 more]</label></div><br/><div class="children"><div class="content">Worked on an ocaml codebase for two years. My advice is: choose a different language. It&#x27;s just not a great dev experience in general</div><br/><div id="42233441" class="c"><input type="checkbox" id="c-42233441" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#42232851">parent</a><span>|</span><a href="#42233068">next</a><span>|</span><label class="collapse" for="c-42233441">[-]</label><label class="expand" for="c-42233441">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Worked on an X language codebase for two years. My advice is: choose a different language. It&#x27;s just not a great dev experience in general.<p>I&#x27;m pretty sure it&#x27;s &quot;working on a codebase&quot; that kills your soul, not the minutae of particular language choice.</div><br/></div></div><div id="42233068" class="c"><input type="checkbox" id="c-42233068" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42232851">parent</a><span>|</span><a href="#42233441">prev</a><span>|</span><a href="#42233126">next</a><span>|</span><label class="collapse" for="c-42233068">[-]</label><label class="expand" for="c-42233068">[2 more]</label></div><br/><div class="children"><div class="content">Depends on what you compare it with, I guess.  (I worked in OCaml and Haskell and other &#x27;weird&#x27; languages professionally in different jobs for many years.)</div><br/><div id="42233894" class="c"><input type="checkbox" id="c-42233894" checked=""/><div class="controls bullet"><span class="by">akkad33</span><span>|</span><a href="#42232851">root</a><span>|</span><a href="#42233068">parent</a><span>|</span><a href="#42233126">next</a><span>|</span><label class="collapse" for="c-42233894">[-]</label><label class="expand" for="c-42233894">[1 more]</label></div><br/><div class="children"><div class="content">Fsharp is pretty good in teams f tooling at least when compared to other functional languages</div><br/></div></div></div></div></div></div><div id="42233126" class="c"><input type="checkbox" id="c-42233126" checked=""/><div class="controls bullet"><span class="by">akkad33</span><span>|</span><a href="#42232851">prev</a><span>|</span><a href="#42183448">next</a><span>|</span><label class="collapse" for="c-42233126">[-]</label><label class="expand" for="c-42233126">[1 more]</label></div><br/><div class="children"><div class="content">F# syntax improves on this I think. But why is the article so short? It ends abruptly</div><br/></div></div><div id="42183448" class="c"><input type="checkbox" id="c-42183448" checked=""/><div class="controls bullet"><span class="by">shortrounddev2</span><span>|</span><a href="#42233126">prev</a><span>|</span><a href="#42233688">next</a><span>|</span><label class="collapse" for="c-42183448">[-]</label><label class="expand" for="c-42183448">[22 more]</label></div><br/><div class="children"><div class="content">I want to like OCaml, but the tooling isn&#x27;t great and async operations require a library to work for some reason. I tried f# but if you want to do async operations there, you have to do them in these even weirder &quot;computation blocks&quot; with this annoying ! Syntax. I&#x27;ve found that the best way to write ML family programs is to let an imperative language handle IO and then write any more mathematically or logically complicated work in ML, but only after you&#x27;ve loaded all of your data</div><br/><div id="42232893" class="c"><input type="checkbox" id="c-42232893" checked=""/><div class="controls bullet"><span class="by">gabcoh</span><span>|</span><a href="#42183448">parent</a><span>|</span><a href="#42186191">next</a><span>|</span><label class="collapse" for="c-42232893">[-]</label><label class="expand" for="c-42232893">[6 more]</label></div><br/><div class="children"><div class="content">&gt; async operations require a library to work for some reason<p>Rephrased: ocaml is so flexible that async can be implemented as a library with no special support from the language.<p>This is the beauty of ocaml (and strongly typed functional languages more broadly)</div><br/><div id="42233089" class="c"><input type="checkbox" id="c-42233089" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42183448">root</a><span>|</span><a href="#42232893">parent</a><span>|</span><a href="#42233189">next</a><span>|</span><label class="collapse" for="c-42233089">[-]</label><label class="expand" for="c-42233089">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is the beauty of ocaml (and strongly typed functional languages more broadly)<p>I don&#x27;t think that&#x27;s anything specific to strongly typed functional languages.  In eg Rust even the standard library relies on third party crates.<p>Though it is still somewhat amusing to me that loops in Haskell are delivered via a third party library, if you ever actually want them.  See <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;monad-loops-0.4.3&#x2F;docs&#x2F;Control-Monad-Loops.html" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;monad-loops-0.4.3&#x2F;docs&#x2F;C...</a><p>I do agree that it&#x27;s good language design, if you can deliver what would be core functionality via a library.<p>Whether you want to integrate that library into the standard library or not is an independent question of culture and convenience.<p>(Eg Python does quite well with its batteries-included approach, but if they had better dependency management, using third party libraries wouldn&#x27;t be so bad.  It works well in eg Rust and Haskell.)</div><br/></div></div><div id="42233189" class="c"><input type="checkbox" id="c-42233189" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#42183448">root</a><span>|</span><a href="#42232893">parent</a><span>|</span><a href="#42233089">prev</a><span>|</span><a href="#42186191">next</a><span>|</span><label class="collapse" for="c-42233189">[-]</label><label class="expand" for="c-42233189">[4 more]</label></div><br/><div class="children"><div class="content">As the other commenter pointed out, this isn&#x27;t restricted to strongly-typed functional languages.<p>Clojure has core.async, which implements &quot;goroutines&quot; without any special support from the language. In fact, the `go` macro[1] is a compiler in disguise: transforming code into SSA form then constructing a state machine to deal with the &quot;yield&quot; points of async code. [2]<p>core.async runs on both Clojure and ClojureScript (i.e. both JVM and JavaScript). So in some sense, ClojureScript had something like Golang&#x27;s concurrency well before ES6 was published.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;core.async&#x2F;blob&#x2F;master&#x2F;src&#x2F;main&#x2F;clojure&#x2F;clojure&#x2F;core&#x2F;async.clj#L443">https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;core.async&#x2F;blob&#x2F;master&#x2F;src&#x2F;main&#x2F;c...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;core.async&#x2F;blob&#x2F;master&#x2F;src&#x2F;main&#x2F;clojure&#x2F;clojure&#x2F;core&#x2F;async&#x2F;impl&#x2F;ioc_macros.clj#L194">https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;core.async&#x2F;blob&#x2F;master&#x2F;src&#x2F;main&#x2F;c...</a></div><br/><div id="42233360" class="c"><input type="checkbox" id="c-42233360" checked=""/><div class="controls bullet"><span class="by">Blackthorn</span><span>|</span><a href="#42183448">root</a><span>|</span><a href="#42233189">parent</a><span>|</span><a href="#42186191">next</a><span>|</span><label class="collapse" for="c-42233360">[-]</label><label class="expand" for="c-42233360">[3 more]</label></div><br/><div class="children"><div class="content">&gt; something like Golang&#x27;s concurrency<p>That&#x27;s <i>wildly</i> overselling it. Closure core async was completely incapable of doing the one extremely important innovation that made goroutines powerful: blocking.</div><br/><div id="42234165" class="c"><input type="checkbox" id="c-42234165" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#42183448">root</a><span>|</span><a href="#42233360">parent</a><span>|</span><a href="#42233539">next</a><span>|</span><label class="collapse" for="c-42234165">[-]</label><label class="expand" for="c-42234165">[1 more]</label></div><br/><div class="children"><div class="content">Assuming &quot;blocking&quot; refers to parking goroutines, then blocking is possible.<p><pre><code>  (let [c (chan)]
    ;; creates channel that is parked forever
    (go
      (&lt;! c)))
</code></pre>
The Go translation is as follows.<p><pre><code>  c := make(chan interface{})
  &#x2F;&#x2F; creates goroutine that is parked forever
  go func() {
    &lt;-c
  }()</code></pre></div><br/></div></div><div id="42233539" class="c"><input type="checkbox" id="c-42233539" checked=""/><div class="controls bullet"><span class="by">conjurernix</span><span>|</span><a href="#42183448">root</a><span>|</span><a href="#42233360">parent</a><span>|</span><a href="#42234165">prev</a><span>|</span><a href="#42186191">next</a><span>|</span><label class="collapse" for="c-42233539">[-]</label><label class="expand" for="c-42233539">[1 more]</label></div><br/><div class="children"><div class="content">Can you elaborate? As far as I&#x27;m aware if you pull from an empty nchannel it wikl be blocking ubtik it gets a value.</div><br/></div></div></div></div></div></div></div></div><div id="42186191" class="c"><input type="checkbox" id="c-42186191" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42183448">parent</a><span>|</span><a href="#42232893">prev</a><span>|</span><a href="#42233145">next</a><span>|</span><label class="collapse" for="c-42186191">[-]</label><label class="expand" for="c-42186191">[13 more]</label></div><br/><div class="children"><div class="content">Some F# articles are outdated - they predate F# 6 which added task { } CE which simplifies asynchronous code that interacts with .NET&#x27;s standard library.<p>I found F# to be more pleasant to work with async than C# (which is already a breeze). It is true that you still have to define &#x27;task&#x27; (or &#x27;async&#x27; if you want to use Async CEs) but it is generally there for a reason. I don&#x27;t think it&#x27;s too much noise:<p><pre><code>    let printAfter (s: float&lt;second&gt;) = task {
        let time = TimeSpan.FromSeconds (float s)
        do! Task.Delay time
        printfn $&quot;Hello from F# after {s} seconds&quot;
    }</code></pre></div><br/><div id="42187262" class="c"><input type="checkbox" id="c-42187262" checked=""/><div class="controls bullet"><span class="by">shortrounddev2</span><span>|</span><a href="#42183448">root</a><span>|</span><a href="#42186191">parent</a><span>|</span><a href="#42233145">next</a><span>|</span><label class="collapse" for="c-42187262">[-]</label><label class="expand" for="c-42187262">[12 more]</label></div><br/><div class="children"><div class="content">I dislike that there&#x27;s a kind of sub-syntax specifically for async. I like how C# converts `await` into the necessary calls. In this code I think it would look better to simply have:<p><pre><code>    let async printAfter (s: float&lt;second&gt;) =
        let time = TimeSpan.FromSeconds (float s)
        await Task.Delay time
        printfn $&quot;Hello from F# after {s} seconds&quot;
</code></pre>
and then printAfter is called with `await` as well. I&#x27;m sure there&#x27;s some FP kind of philosophy which prohibits this (code with potential side effects not being properly quarantined), but to me it just results in yet more purpose-specific syntax to have to learn for F#, which is already very heavy on the number of keywords and operators</div><br/><div id="42187504" class="c"><input type="checkbox" id="c-42187504" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42183448">root</a><span>|</span><a href="#42187262">parent</a><span>|</span><a href="#42233145">next</a><span>|</span><label class="collapse" for="c-42187504">[-]</label><label class="expand" for="c-42187504">[11 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the other way around.<p>&#x27;async&#x27;-annotated methods in C# enable &#x27;await&#x27;ing on task-shaped types. It is bespoke and async-specific. There is nothing wrong with it but it&#x27;s necessary to acknowledge this limitation.<p>let!, and!, return!, etc. keywords in F# are generic - you can build your own state machines&#x2F;coroutines with resumable code, you can author completely custom logic with CEs. I&#x27;m not sure what led you to believe the opposite. `await Task.Delay` in C# is `do! Task.Delay` in F#. `let! response = http.SendAsync` is for asynchronous calls that return a value rather than unit.<p>In the same vein, seq is another CE that is more capable than iterator methods with yield return:<p><pre><code>    let values = seq {
        &#x2F;&#x2F; yield individual values
        for i in 1..10 -&gt; i
        &#x2F;&#x2F; yield a range, merged into the sequence
        yield! [11..20] &#x2F;&#x2F; note the exclamation mark
    }
</code></pre>
Adding support for this in C# would require explicit compiler changes. CEs are generic and very powerful at building execution blocks with fine control over the behavior, DSLs and more.<p>Reference: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;fsharp&#x2F;language-reference&#x2F;computation-expressions" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;fsharp&#x2F;language-ref...</a></div><br/><div id="42232822" class="c"><input type="checkbox" id="c-42232822" checked=""/><div class="controls bullet"><span class="by">shakna</span><span>|</span><a href="#42183448">root</a><span>|</span><a href="#42187504">parent</a><span>|</span><a href="#42198221">next</a><span>|</span><label class="collapse" for="c-42232822">[-]</label><label class="expand" for="c-42232822">[8 more]</label></div><br/><div class="children"><div class="content">&gt; It is bespoke and async-specific. There is nothing wrong with it but it&#x27;s necessary to acknowledge this limitation.<p>I would disagree. If you need to have a bespoke set of syntax, then something is not integrated where it should be. The language design should not be such that you are writing things differently, depending on the paradigm that you&#x27;re handling. That&#x27;s not something that occurs in every language, so it isn&#x27;t essential that it exists.<p>We can acknowledge the differences in a way that alerts the programmer, without forcing the programmer to switch syntaxes back and forth when moving between the paradigms. async&#x2F;await is one method, Promises another, etc. A different syntax is a much, much higher cognitive load.</div><br/><div id="42233542" class="c"><input type="checkbox" id="c-42233542" checked=""/><div class="controls bullet"><span class="by">Vetch</span><span>|</span><a href="#42183448">root</a><span>|</span><a href="#42232822">parent</a><span>|</span><a href="#42233353">next</a><span>|</span><label class="collapse" for="c-42233542">[-]</label><label class="expand" for="c-42233542">[2 more]</label></div><br/><div class="children"><div class="content">F#&#x27;s computation expressions are closely related to Haskell&#x27;s monads + do-notation combo, CEs are both more limited than Haskell&#x27;s approach to monads (from a type expressibility perspective) and more expressive than pure monads (from a modeling perspective, can model a general class of computational structures beyond monads; CE&#x27;s also share F#&#x27;s syntax, with extensible semantics). This notation can be advantageous and clarifying when used in the right places. It has advantages over C#&#x27;s async from a flexibility&#x2F;extensibility perspective and also provides more options in orchestrating more complex control flow across async computations. C#&#x27;s approach is more streamlined if you only care about using async according to how Tasks are designed (which still enable a quite broad scope) and don&#x27;t need the flexibility for other computational patterns.<p>Simple things like the maybe and either monad are often clearer in this notation. Complex things like alternatives to async (such as CSP derived message passing concurrency), continuations, parser combinators, non-determinism, algebraic effects and dependency tracked incremental computations are naturally modeled with this same machinery, with CE notation being a kind of super helpful DSL builder that makes certain complex computations easier to express in a sequenced manner.<p>If the custom syntax was only for async you&#x27;d have a point, but the general power of the framework make it the more preferable approach by far, in my opinion.</div><br/><div id="42233901" class="c"><input type="checkbox" id="c-42233901" checked=""/><div class="controls bullet"><span class="by">shakna</span><span>|</span><a href="#42183448">root</a><span>|</span><a href="#42233542">parent</a><span>|</span><a href="#42233353">next</a><span>|</span><label class="collapse" for="c-42233901">[-]</label><label class="expand" for="c-42233901">[1 more]</label></div><br/><div class="children"><div class="content">However, most of the industry has moved <i>away</i> from DSLs. Whilst having a unique language can make certain things more expressive, having something standard makes mistakes happen less, and increases the effectiveness of a programmer. Lisp doesn&#x27;t rule our day to day.<p>We shoehorn things that feel like, but are structurally different, to DSLs into config files and the like, using JSON&#x2F;YAML&#x2F;etc in rough ways, because DSLs introduce a cognitive overhead that doesn&#x27;t need to be there.<p>That the shoehorn happens, does mean that DSLs are something natural to reach for. You&#x27;re right there. But that we have moved away, as an industry, indicates that using any kind of DSL is a smell. That there probably is a <i>better</i> way to do it.<p>Having a core language feature using a DSL, is a smell. It could be done better.</div><br/></div></div></div></div><div id="42233353" class="c"><input type="checkbox" id="c-42233353" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42183448">root</a><span>|</span><a href="#42232822">parent</a><span>|</span><a href="#42233542">prev</a><span>|</span><a href="#42198221">next</a><span>|</span><label class="collapse" for="c-42233353">[-]</label><label class="expand" for="c-42233353">[5 more]</label></div><br/><div class="children"><div class="content">I cannot make sense of this reply. Different languages have different syntax.<p>Support of asynchronous code and of its composition is central to C#, which is why it does it via async&#x2F;await and Task&lt;T&gt; (and other Task-shaped types). Many other languages considered this important enough to adopt a similar structure to their own rendition of concurrency primitives, inspired by C# either directly or indirectly. Feel free to take issue with the designers of these languages if you have to.<p>F#, where async originates from, just happens to be more &quot;powerful&quot; as befits an FP language, where resumable code and CEs enable expressing async in a more generalized fashion. I&#x27;m not sold on idea that C# needs CEs. It already has sufficient complexity and good balance of expressiveness.</div><br/><div id="42233789" class="c"><input type="checkbox" id="c-42233789" checked=""/><div class="controls bullet"><span class="by">shakna</span><span>|</span><a href="#42183448">root</a><span>|</span><a href="#42233353">parent</a><span>|</span><a href="#42198221">next</a><span>|</span><label class="collapse" for="c-42233789">[-]</label><label class="expand" for="c-42233789">[4 more]</label></div><br/><div class="children"><div class="content">Different languages have different syntax, but most do not have a separate syntax inside themselves. A function is generally a function. They do adopt various structures - but those are structures, not syntax. I&#x27;m not sure you&#x27;ve understood that was my point.</div><br/><div id="42234054" class="c"><input type="checkbox" id="c-42234054" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42183448">root</a><span>|</span><a href="#42233789">parent</a><span>|</span><a href="#42198221">next</a><span>|</span><label class="collapse" for="c-42234054">[-]</label><label class="expand" for="c-42234054">[3 more]</label></div><br/><div class="children"><div class="content">Perhaps it&#x27;s a good idea to get familiar with the details of <i>why</i> and <i>how</i> async is to be approached in C# and F#.<p>Do-notation-like &#x27;await&#x27; is not for calling functions, it is for acting on their return values - to suspend the execution flow until the task completes.</div><br/><div id="42234294" class="c"><input type="checkbox" id="c-42234294" checked=""/><div class="controls bullet"><span class="by">shakna</span><span>|</span><a href="#42183448">root</a><span>|</span><a href="#42234054">parent</a><span>|</span><a href="#42198221">next</a><span>|</span><label class="collapse" for="c-42234294">[-]</label><label class="expand" for="c-42234294">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve written patches for F#. I do know what the hell I&#x27;m talking about.<p>However, the compiler does not, has never, <i>required</i> that it does things via a different syntax. In fact, in the early branches before that was adopted, it didn&#x27;t! The same behaviour was seen in those branches. This behaviour you expect, was never something that had to be. It was something chosen to simplify the needs of the optimiser, and in fact cut the size of code required in half. It was to reduce the amount of code needed to be maintained by the core team. And so 1087 [1] was accepted.<p>So perhaps you might need to read more into the process of the <i>why</i> and <i>how</i> async was introduced into C# and F#. It was a maintenance team problem. It was a pragmatic approach for them - not something that was the only way that this became a possibility.<p>As said, in the original branch for using tasks...<p>&gt; Having two different but similar ways of creating asynchronous computations would add some cognitive overhead (even now there are times when I am indecisive between using async or mailbox for certain parallelism&#x2F;concurrency scenarios). [0]<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;fsharp&#x2F;fslang-suggestions&#x2F;issues&#x2F;581">https:&#x2F;&#x2F;github.com&#x2F;fsharp&#x2F;fslang-suggestions&#x2F;issues&#x2F;581</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;fsharp&#x2F;fslang-design&#x2F;blob&#x2F;main&#x2F;FSharp-6.0&#x2F;FS-1087-resumable-code.md">https:&#x2F;&#x2F;github.com&#x2F;fsharp&#x2F;fslang-design&#x2F;blob&#x2F;main&#x2F;FSharp-6.0...</a></div><br/><div id="42234456" class="c"><input type="checkbox" id="c-42234456" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42183448">root</a><span>|</span><a href="#42234294">parent</a><span>|</span><a href="#42198221">next</a><span>|</span><label class="collapse" for="c-42234456">[-]</label><label class="expand" for="c-42234456">[1 more]</label></div><br/><div class="children"><div class="content">Alright, I stand corrected.<p>However, this is where our opinions differ. I <i>like</i> task CE (and taskSeq for that matter too). It serves as a good and, most importantly, performant default. It&#x27;s great to be able to choose the exact behavior of asynchronous code when task CE does not fit.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42198221" class="c"><input type="checkbox" id="c-42198221" checked=""/><div class="controls bullet"><span class="by">shortrounddev2</span><span>|</span><a href="#42183448">root</a><span>|</span><a href="#42187504">parent</a><span>|</span><a href="#42232822">prev</a><span>|</span><a href="#42233145">next</a><span>|</span><label class="collapse" for="c-42198221">[-]</label><label class="expand" for="c-42198221">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m somewhat already aware of these considerations, it&#x27;s just that when you&#x27;re working in web development, a huge amount of your code is async and this means that a large part of the code is wrapped up in these computation expressions that I think are just plain ugly</div><br/><div id="42233346" class="c"><input type="checkbox" id="c-42233346" checked=""/><div class="controls bullet"><span class="by">miffy900</span><span>|</span><a href="#42183448">root</a><span>|</span><a href="#42198221">parent</a><span>|</span><a href="#42233145">next</a><span>|</span><label class="collapse" for="c-42233346">[-]</label><label class="expand" for="c-42233346">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s so ugly about them? I don&#x27;t code in F#, but I do in C# and after reading about them I wish C# had something similar.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42233145" class="c"><input type="checkbox" id="c-42233145" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42183448">parent</a><span>|</span><a href="#42186191">prev</a><span>|</span><a href="#42233688">next</a><span>|</span><label class="collapse" for="c-42233145">[-]</label><label class="expand" for="c-42233145">[2 more]</label></div><br/><div class="children"><div class="content">You might like Scala. It has much of the good parts of OCaml or F#, but also lets you write imperative code freely when you want. The `for`&#x2F;`yield` syntax for async is very nice IMO, or you can write Javascript-like promise chaining directly if you want.</div><br/><div id="42233455" class="c"><input type="checkbox" id="c-42233455" checked=""/><div class="controls bullet"><span class="by">switchbak</span><span>|</span><a href="#42183448">root</a><span>|</span><a href="#42233145">parent</a><span>|</span><a href="#42233688">next</a><span>|</span><label class="collapse" for="c-42233455">[-]</label><label class="expand" for="c-42233455">[1 more]</label></div><br/><div class="children"><div class="content">Some interesting things happening in the structured concurrency &#x2F; &quot;Direct style&quot; space. It looks like it could become a powerful and readable way to compose (asyncy type) things. Simpler code, usable stack traces, better traceability, less function colouring concerns.<p>It&#x27;s early days in that regard, with some folks doing some really interesting things: Odersky himself &#x2F; the Ox project.</div><br/></div></div></div></div></div></div><div id="42233688" class="c"><input type="checkbox" id="c-42233688" checked=""/><div class="controls bullet"><span class="by">asplake</span><span>|</span><a href="#42183448">prev</a><span>|</span><a href="#42234151">next</a><span>|</span><label class="collapse" for="c-42233688">[-]</label><label class="expand" for="c-42233688">[1 more]</label></div><br/><div class="children"><div class="content">(2016)</div><br/></div></div><div id="42234151" class="c"><input type="checkbox" id="c-42234151" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42233688">prev</a><span>|</span><a href="#42233645">next</a><span>|</span><label class="collapse" for="c-42234151">[-]</label><label class="expand" for="c-42234151">[2 more]</label></div><br/><div class="children"><div class="content">I 100% agree. The lack of clear scoping and function call grouping syntax just turns it into a word soup. It becomes difficult to parse <i>for humans</i> and I spend a stupid amount of time just getting the semicolons, begin&#x2F;ends, etc. right.<p>It&#x27;s like... when you mismatch brackets or braces in a C-style language, except to resolve the problem you can&#x27;t just find the bracket that&#x27;s highlighted in red and count; you have to read an essay.<p>I don&#x27;t know why there are so many people here defending it. It&#x27;s pretty clearly very elegant, but extremely inconvenient.</div><br/><div id="42234481" class="c"><input type="checkbox" id="c-42234481" checked=""/><div class="controls bullet"><span class="by">edwintorok</span><span>|</span><a href="#42234151">parent</a><span>|</span><a href="#42233645">next</a><span>|</span><label class="collapse" for="c-42234481">[-]</label><label class="expand" for="c-42234481">[1 more]</label></div><br/><div class="children"><div class="content">That can be indeed very confusing when you initially learn the language.
However there are 3 things that can help:
* An auto-formatter (ocamlformat integration in your editor, or ocaml-top) that shows how the actual nesting looks like
* You can add ;; at the end of a top-level function to get a syntax error at a better location
* Use thr LSP integration of your editor which will show you where the error is as you type, so you catch the problem early</div><br/></div></div></div></div><div id="42233645" class="c"><input type="checkbox" id="c-42233645" checked=""/><div class="controls bullet"><span class="by">anacrolix</span><span>|</span><a href="#42234151">prev</a><span>|</span><a href="#42232898">next</a><span>|</span><label class="collapse" for="c-42233645">[-]</label><label class="expand" for="c-42233645">[2 more]</label></div><br/><div class="children"><div class="content">I find it less abutting now that I know about let expressions in lambda calculus. it&#x27;s still verbose though. do notation please.</div><br/><div id="42233971" class="c"><input type="checkbox" id="c-42233971" checked=""/><div class="controls bullet"><span class="by">chombier</span><span>|</span><a href="#42233645">parent</a><span>|</span><a href="#42232898">next</a><span>|</span><label class="collapse" for="c-42233971">[-]</label><label class="expand" for="c-42233971">[1 more]</label></div><br/><div class="children"><div class="content">There is a kind of &quot;do notation&quot; in OCaml with binding operators [1] (let*) for monads and (let+) for applicatives that is actually quite pleasant in practice.<p>[1] <a href="https:&#x2F;&#x2F;ocaml.org&#x2F;manual&#x2F;5.2&#x2F;bindingops.html" rel="nofollow">https:&#x2F;&#x2F;ocaml.org&#x2F;manual&#x2F;5.2&#x2F;bindingops.html</a></div><br/></div></div></div></div><div id="42232898" class="c"><input type="checkbox" id="c-42232898" checked=""/><div class="controls bullet"><span class="by">lemper</span><span>|</span><a href="#42233645">prev</a><span>|</span><a href="#42233820">next</a><span>|</span><label class="collapse" for="c-42232898">[-]</label><label class="expand" for="c-42232898">[4 more]</label></div><br/><div class="children"><div class="content">idk mate, his guide to pick prostitutes has more compelling argument compared to this article. i mean, almost all the time ocaml users don&#x27;t write their stuff &quot;nested&quot;.</div><br/><div id="42233032" class="c"><input type="checkbox" id="c-42233032" checked=""/><div class="controls bullet"><span class="by">daelon</span><span>|</span><a href="#42232898">parent</a><span>|</span><a href="#42233820">next</a><span>|</span><label class="collapse" for="c-42233032">[-]</label><label class="expand" for="c-42233032">[3 more]</label></div><br/><div class="children"><div class="content">Link? I tried to look around the site, but I.. couldn&#x27;t take very much of it.</div><br/><div id="42233136" class="c"><input type="checkbox" id="c-42233136" checked=""/><div class="controls bullet"><span class="by">akkad33</span><span>|</span><a href="#42232898">root</a><span>|</span><a href="#42233032">parent</a><span>|</span><a href="#42233820">next</a><span>|</span><label class="collapse" for="c-42233136">[-]</label><label class="expand" for="c-42233136">[2 more]</label></div><br/><div class="children"><div class="content">This one?<p><a href="http:&#x2F;&#x2F;xahlee.org&#x2F;Periodic_dosage_dir&#x2F;las_vegas&#x2F;20031015_copulate.html" rel="nofollow">http:&#x2F;&#x2F;xahlee.org&#x2F;Periodic_dosage_dir&#x2F;las_vegas&#x2F;20031015_cop...</a><p>Found it via Google</div><br/><div id="42233317" class="c"><input type="checkbox" id="c-42233317" checked=""/><div class="controls bullet"><span class="by">acjohnson55</span><span>|</span><a href="#42232898">root</a><span>|</span><a href="#42233136">parent</a><span>|</span><a href="#42233820">next</a><span>|</span><label class="collapse" for="c-42233317">[-]</label><label class="expand" for="c-42233317">[1 more]</label></div><br/><div class="children"><div class="content">Big yikes.</div><br/></div></div></div></div></div></div></div></div><div id="42233820" class="c"><input type="checkbox" id="c-42233820" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#42232898">prev</a><span>|</span><a href="#42234003">next</a><span>|</span><label class="collapse" for="c-42233820">[-]</label><label class="expand" for="c-42233820">[1 more]</label></div><br/><div class="children"><div class="content">My OCaml is very rusty, but just add some parentheses, no?</div><br/></div></div><div id="42234003" class="c"><input type="checkbox" id="c-42234003" checked=""/><div class="controls bullet"><span class="by">VeejayRampay</span><span>|</span><a href="#42233820">prev</a><span>|</span><a href="#42233224">next</a><span>|</span><label class="collapse" for="c-42234003">[-]</label><label class="expand" for="c-42234003">[1 more]</label></div><br/><div class="children"><div class="content">flamebait tantrum of a post</div><br/></div></div><div id="42233297" class="c"><input type="checkbox" id="c-42233297" checked=""/><div class="controls bullet"><span class="by">KennyBlanken</span><span>|</span><a href="#42233224">prev</a><span>|</span><label class="collapse" for="c-42233297">[-]</label><label class="expand" for="c-42233297">[2 more]</label></div><br/><div class="children"><div class="content">As a matter of policy can HN please not accept submissions with non-https URLs?<p>It&#x27;s a checkbox at most web hosts, built in to many reverse proxies, etc. There&#x27;s no excuse for not offering htttps, particularly since it places users at risk if at any point along the path between them and you, there&#x27;s someone untrustworthy.</div><br/><div id="42233471" class="c"><input type="checkbox" id="c-42233471" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#42233297">parent</a><span>|</span><label class="collapse" for="c-42233471">[-]</label><label class="expand" for="c-42233471">[1 more]</label></div><br/><div class="children"><div class="content">&gt; places users at risk<p>Help me out here, what&#x27;s the threat model here while reading troll programming blogs?</div><br/></div></div></div></div></div></div></div></div></div></body></html>