<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725440450794" as="style"/><link rel="stylesheet" href="styles.css?v=1725440450794"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://arxiv.org/abs/1901.01930">Keeping CALM: When distributed consistency is easy (2019)</a> <span class="domain">(<a href="https://arxiv.org">arxiv.org</a>)</span></div><div class="subtext"><span>harperlee</span> | <span>11 comments</span></div><br/><div><div id="41441172" class="c"><input type="checkbox" id="c-41441172" checked=""/><div class="controls bullet"><span class="by">mjb</span><span>|</span><a href="#41442377">next</a><span>|</span><label class="collapse" for="c-41441172">[-]</label><label class="expand" for="c-41441172">[2 more]</label></div><br/><div class="children"><div class="content">I love this work. I might claim it (and some of its antecedents) is the most important distributed systems work of the last decade.<p>Why? It addresses the central question in distributed (and multi-threaded!) system design: when do we need to coordinate between systems? This is important for exactly the reason that the James Hamilton quote says. Successful scalability requires avoiding coordination. Scalable systems (and efficient systems, and fast systems) are the ones that minimize scalability to the level absolutely required by the guarantees they want to offer.<p>As the authors say:<p>&gt; As system builders, of course, we are interested in the complement of this space: what can be achieved, and, importantly, how can we achieve it while minimizing complexity and
cost? The CALM Theorem presents a positive result that delineates the frontier of the possible.<p>This tool for thinking about what possible systems we can build is one that&#x27;s very understandable to most programmers:<p>&gt; A program P is monotonic if for any input sets S,T where S ⊆ T, P(S) ⊆ P(T).<p>A program is monotonic if, when you run it on a subset of its inputs, you get a subset of its outputs. As you run it on more data, the set of true things may grow, but it never shrinks.<p>&gt; A program has a consistent, coordination-free distributed implementation if and only if it is monotonic.<p>Now we have a useful roadmap to designing scalable distributed system, fault tolerant distributed systems, scalable parallel compute code, and fast multi-threaded code. Using the definition we can identify whether a program is monotonic, and if it is we know we can implement it without coordination. If it is not, we can decompose a program into monotonic and non-monotonic parts, and (if all goes well) take advantage of the non-monotonicity. In many cases, we can do tons of parallel work and only coordinate a couple times.<p>&gt; Conflict-free replicated data types (CRDTs) provide an object-
oriented framework for monotonic programming<p>More conceptual clarity! CRDTs are widely used, and widely talked about. Why do they work? Because they provide ADTs for writing monotonic programs.</div><br/><div id="41441356" class="c"><input type="checkbox" id="c-41441356" checked=""/><div class="controls bullet"><span class="by">sbazerque</span><span>|</span><a href="#41441172">parent</a><span>|</span><a href="#41442377">next</a><span>|</span><label class="collapse" for="c-41441356">[-]</label><label class="expand" for="c-41441356">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A program P is monotonic if for any input sets S,T where S ⊆ T, P(S) ⊆ P(T).<p>&gt; A program is monotonic if, when you run it on a subset of its inputs, you get a subset of its outputs. As you run it on more data, the set of true things may grow, but it never shrinks.<p>Yeah, this framework seems powerful.<p>Something I find interesting is that you can get monotonic (and therefore coordination-free) relaxations of arbitrary problems. In extremis, you can derive a relaxed version P&#x27; thus<p>P&#x27;(S) = {&lt;s, P(s)&gt; | s ⊆ S}<p>and now<p>P&#x27;(S) ⊆ P&#x27;(T) if S ⊆ T for _any_ (well defined) P<p>This seems tautological but in some cases a relaxed version is good enough: it gives you convergence and eventual consistency in a coordination-free setting, at the cost of maybe having to roll back some results. And when it doesn&#x27;t, it gives you a coherent model of what to make of the situation until coordination yields a definitive answer.<p>I wrote about this idea here: <a href="https:&#x2F;&#x2F;www.hyperhyperspace.org&#x2F;report.html#conflict-resolution" rel="nofollow">https:&#x2F;&#x2F;www.hyperhyperspace.org&#x2F;report.html#conflict-resolut...</a><p>But that was like last week, haven&#x27;t really put this in practice yet.<p>In those examples what is being processed are partially-ordered operational logs, but it&#x27;s essentially the same (just that whenever S ⊆ T there, what you&#x27;re seeing is an extension of an op log, which is a bit more intuitive).</div><br/></div></div></div></div><div id="41442377" class="c"><input type="checkbox" id="c-41442377" checked=""/><div class="controls bullet"><span class="by">mehulashah</span><span>|</span><a href="#41441172">prev</a><span>|</span><a href="#41441039">next</a><span>|</span><label class="collapse" for="c-41442377">[-]</label><label class="expand" for="c-41442377">[1 more]</label></div><br/><div class="children"><div class="content">This is a cool result from a couple of famous database experts. Though, it seems that the only set of practical programs that satisfy the CALM property are set-based operations found in database systems. These are expressive, but not expressive enough to cover all possible computations. So, is it the case that all computations can be decomposed into a partial order of CALM programs each of which don’t need coordination except at the points of order. If so, is this approach analogous to Lamport’s CStructs in Generalized Consensus?</div><br/></div></div><div id="41441039" class="c"><input type="checkbox" id="c-41441039" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#41442377">prev</a><span>|</span><a href="#41442205">next</a><span>|</span><label class="collapse" for="c-41441039">[-]</label><label class="expand" for="c-41441039">[3 more]</label></div><br/><div class="children"><div class="content">early 2019 fwiw.<p>CACM has a (large) 2020 blog post about it too: <a href="https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;keeping-calm&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;keeping-calm&#x2F;</a><p>I remember seeing a blip of this when it came out, but I haven&#x27;t heard anything since.  Anyone know if it&#x27;s known &#x2F; used &#x2F; ??, or has it been subsumed by some other thing?</div><br/><div id="41441089" class="c"><input type="checkbox" id="c-41441089" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#41441039">parent</a><span>|</span><a href="#41442604">next</a><span>|</span><label class="collapse" for="c-41441089">[-]</label><label class="expand" for="c-41441089">[1 more]</label></div><br/><div class="children"><div class="content">They seem to be iterating on this (or less graciously dumping something and moving on). The latest thing seems to be called hydro <a href="https:&#x2F;&#x2F;github.com&#x2F;hydro-project">https:&#x2F;&#x2F;github.com&#x2F;hydro-project</a></div><br/></div></div><div id="41442604" class="c"><input type="checkbox" id="c-41442604" checked=""/><div class="controls bullet"><span class="by">tylerhou</span><span>|</span><a href="#41441039">parent</a><span>|</span><a href="#41441089">prev</a><span>|</span><a href="#41442205">next</a><span>|</span><label class="collapse" for="c-41442604">[-]</label><label class="expand" for="c-41442604">[1 more]</label></div><br/><div class="children"><div class="content">You may be interested in a paper which appeared at SIGMOD: <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3639257" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3639257</a></div><br/></div></div></div></div><div id="41442205" class="c"><input type="checkbox" id="c-41442205" checked=""/><div class="controls bullet"><span class="by">MeteorMarc</span><span>|</span><a href="#41441039">prev</a><span>|</span><a href="#41442612">next</a><span>|</span><label class="collapse" for="c-41442205">[-]</label><label class="expand" for="c-41442205">[3 more]</label></div><br/><div class="children"><div class="content">Just to make this discussion less abstract: is a groupby operation monotonic?</div><br/><div id="41442285" class="c"><input type="checkbox" id="c-41442285" checked=""/><div class="controls bullet"><span class="by">bubblyworld</span><span>|</span><a href="#41442205">parent</a><span>|</span><a href="#41442315">next</a><span>|</span><label class="collapse" for="c-41442285">[-]</label><label class="expand" for="c-41442285">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s logically monotonic in the sense that as you add input data to your query, the output simply accumulates (you never have to retract any prior conclusions).<p>Consistency between two accumulators is easy, they just sum their states.</div><br/></div></div><div id="41442315" class="c"><input type="checkbox" id="c-41442315" checked=""/><div class="controls bullet"><span class="by">mehulashah</span><span>|</span><a href="#41442205">parent</a><span>|</span><a href="#41442285">prev</a><span>|</span><a href="#41442612">next</a><span>|</span><label class="collapse" for="c-41442315">[-]</label><label class="expand" for="c-41442315">[1 more]</label></div><br/><div class="children"><div class="content">Yes. Based on the definition.</div><br/></div></div></div></div><div id="41442612" class="c"><input type="checkbox" id="c-41442612" checked=""/><div class="controls bullet"><span class="by">emoII</span><span>|</span><a href="#41442205">prev</a><span>|</span><label class="collapse" for="c-41442612">[-]</label><label class="expand" for="c-41442612">[1 more]</label></div><br/><div class="children"><div class="content">How far away is this from saying ”just program distributed systems functionally”?</div><br/></div></div></div></div></div></div></div></body></html>