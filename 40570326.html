<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717491672767" as="style"/><link rel="stylesheet" href="styles.css?v=1717491672767"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://chipsandcheese.com/2024/06/03/intels-lion-cove-architecture-preview/">Intel&#x27;s Lion Cove Architecture Preview</a> <span class="domain">(<a href="https://chipsandcheese.com">chipsandcheese.com</a>)</span></div><div class="subtext"><span>zdw</span> | <span>15 comments</span></div><br/><div><div id="40570794" class="c"><input type="checkbox" id="c-40570794" checked=""/><div class="controls bullet"><span class="by">andrewia</span><span>|</span><a href="#40570744">next</a><span>|</span><label class="collapse" for="c-40570794">[-]</label><label class="expand" for="c-40570794">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s interesting to see that modern processor optimization still revolves around balancing hardware for specific tasks.  In this case, the vector scheduler has been separated from the integer scheduler, and the integer pipeline has been made much wider.  I&#x27;m sure it made sense for this revision, but I wonder if things will change in a few generations in the pendulum will swing back to simplifying and integrating more parts of the arithmrtic scheduler(s) and ALUs.<p>It&#x27;s also interesting to see that FPGA integration hasn&#x27;t gone far, and good vector performance is still important (if less important than integer).  I wonder what percentage of consumer and professional workloads make significant use of vector operations, and how much GPU and FPGA offload would alleviate the need for good vector performance.  I only know of vector operations in the context of multimedia processing, which is also suited for GPU acceleration.</div><br/><div id="40571473" class="c"><input type="checkbox" id="c-40571473" checked=""/><div class="controls bullet"><span class="by">dogma1138</span><span>|</span><a href="#40570794">parent</a><span>|</span><a href="#40570744">next</a><span>|</span><label class="collapse" for="c-40571473">[-]</label><label class="expand" for="c-40571473">[2 more]</label></div><br/><div class="children"><div class="content">AMD tried that with HSA in the past it doesn’t really work. Unless your CPU can magically offload vector processing to the GPU or another sub-processor you are still reliant on new code to get this working which means you break backward compatibility with previously compiled code.<p>The best case scenario here is if you can have the compiler do all the heavy lifting but more realistically you’ll end up having to make developers switch to a whole new programming paradigm.</div><br/><div id="40572039" class="c"><input type="checkbox" id="c-40572039" checked=""/><div class="controls bullet"><span class="by">andrewia</span><span>|</span><a href="#40570794">root</a><span>|</span><a href="#40571473">parent</a><span>|</span><a href="#40570744">next</a><span>|</span><label class="collapse" for="c-40572039">[-]</label><label class="expand" for="c-40572039">[1 more]</label></div><br/><div class="children"><div class="content">I understand that you can&#x27;t convince developers to rewrite&#x2F;recompile their applications for a processor that breaks compatibility.  I&#x27;m wondering how many existing applications would be negatively impacted by cutting down vector throughput.  With some searching, I see that some applications make mild use of it like Firefox.  However there are applications that would negatively affected, such as noise suppression in Microsoft Teams, and crypto acceleration in libssl and the Linux kernel.  Acceleration of crypto functions seems essential enough to warrant not touching vector throughput, so it seems vector operations are here to stay in CPUs.</div><br/></div></div></div></div></div></div><div id="40570744" class="c"><input type="checkbox" id="c-40570744" checked=""/><div class="controls bullet"><span class="by">andrewia</span><span>|</span><a href="#40570794">prev</a><span>|</span><a href="#40570754">next</a><span>|</span><label class="collapse" for="c-40570744">[-]</label><label class="expand" for="c-40570744">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m very interested to see independent testing of cores without SMT&#x2F;hyperthreading.  Of course it&#x27;s one less function for the hardware and thread scheduler to worry about.  But hyperthreading was a useful way to share resources between multiple threads that had light-to-intermediate workloads.  Synthetic benchmarks might show an improvement but I&#x27;m interested to see what everyday workloads, like web browsing while streaming a video, will react.</div><br/><div id="40571517" class="c"><input type="checkbox" id="c-40571517" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#40570744">parent</a><span>|</span><a href="#40571241">next</a><span>|</span><label class="collapse" for="c-40571517">[-]</label><label class="expand" for="c-40571517">[2 more]</label></div><br/><div class="children"><div class="content">Generally HT&#x2F;SMT has never been favored for high utilization needs or low wattage needs.<p>On the high utilization end, stuff like offline rendering or even some realtime games, would have significant performance degradation when HT&#x2F;SMT are enabled. It was incredibly noticeable when I worked in film.<p>And on the low wattage end, it ends up causing more overhead versus just dumping the jobs on an E core.</div><br/><div id="40572212" class="c"><input type="checkbox" id="c-40572212" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#40570744">root</a><span>|</span><a href="#40571517">parent</a><span>|</span><a href="#40571241">next</a><span>|</span><label class="collapse" for="c-40572212">[-]</label><label class="expand" for="c-40572212">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And on the low wattage end, it ends up causing more overhead versus just dumping the jobs on an E core.<p>For most of the HT&#x27;s existence there weren&#x27;t any E cores which conflicts with your &quot;never&quot; in the first sentence.</div><br/></div></div></div></div><div id="40571241" class="c"><input type="checkbox" id="c-40571241" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#40570744">parent</a><span>|</span><a href="#40571517">prev</a><span>|</span><a href="#40571785">next</a><span>|</span><label class="collapse" for="c-40571241">[-]</label><label class="expand" for="c-40571241">[1 more]</label></div><br/><div class="children"><div class="content">I was surprised that disabling SMT has improved by a few percents the Geekbench 6 multi-threaded results on a Zen 3 (5900X) CPU.<p>While there are also other tasks where SMT does not bring advantages, for the compilation of a big software project SMT does bring an obvious performance improvement, of about 20% for the same Zen 3 CPU.<p>In any case, Intel has said that they have designed 2 versions of the Lion Cove core, one without SMT for laptop&#x2F;desktop hybrid CPUs and one with SMT for server CPUs with P cores (i.e. for the successor of Granite Rapids, which will be launched later this year, using P-cores similar to those of Meteor Lake).</div><br/></div></div><div id="40571785" class="c"><input type="checkbox" id="c-40571785" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40570744">parent</a><span>|</span><a href="#40571241">prev</a><span>|</span><a href="#40571739">next</a><span>|</span><label class="collapse" for="c-40571785">[-]</label><label class="expand" for="c-40571785">[1 more]</label></div><br/><div class="children"><div class="content">Since side-channel attacks became a common thing, there is hardly a reason to keep hyperthreading around.<p>It was a product of its time, a way to get cheap multi-cores when getting real cores was too expensive for regular consumer products.<p>Besides the security issues, for high performance workloads they have always been an issue, stealing resources across shared CPU units.</div><br/></div></div><div id="40571739" class="c"><input type="checkbox" id="c-40571739" checked=""/><div class="controls bullet"><span class="by">mmaniac</span><span>|</span><a href="#40570744">parent</a><span>|</span><a href="#40571785">prev</a><span>|</span><a href="#40570754">next</a><span>|</span><label class="collapse" for="c-40571739">[-]</label><label class="expand" for="c-40571739">[1 more]</label></div><br/><div class="children"><div class="content">The need for hyperthreading has diminished with increasing core counts and shrinking power headroom. You can just run those tasks on E cores now and save energy.</div><br/></div></div></div></div><div id="40570754" class="c"><input type="checkbox" id="c-40570754" checked=""/><div class="controls bullet"><span class="by">klooney</span><span>|</span><a href="#40570744">prev</a><span>|</span><a href="#40571252">next</a><span>|</span><label class="collapse" for="c-40570754">[-]</label><label class="expand" for="c-40570754">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The removal of Hyperthreading makes a lot of sense for Lunar Lake to both reduce the die size of the version of Lion Cove found in Lunar Lake along with simplifying the job of Thread Director.<p>And, you know, stop the security vulnerability bleeding.</div><br/><div id="40570812" class="c"><input type="checkbox" id="c-40570812" checked=""/><div class="controls bullet"><span class="by">andrewia</span><span>|</span><a href="#40570754">parent</a><span>|</span><a href="#40571252">next</a><span>|</span><label class="collapse" for="c-40570812">[-]</label><label class="expand" for="c-40570812">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think hyperthreading was the bulk of the attack surface.  It definitely presented opportunities for processes to get out of bounds, but I think preemptive scheduling is the bulk of the issue.  That genie not going back in the bottle another way to significantly improve processor performance for the same amount of instructions.</div><br/><div id="40572217" class="c"><input type="checkbox" id="c-40572217" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#40570754">root</a><span>|</span><a href="#40570812">parent</a><span>|</span><a href="#40571252">next</a><span>|</span><label class="collapse" for="c-40572217">[-]</label><label class="expand" for="c-40572217">[1 more]</label></div><br/><div class="children"><div class="content">I think the real problem is cache sharing and hyperthreading kind of depends on it, so it was only ever secure to run two threads from the same security domain in the same core</div><br/></div></div></div></div></div></div><div id="40571252" class="c"><input type="checkbox" id="c-40571252" checked=""/><div class="controls bullet"><span class="by">KingOfCoders</span><span>|</span><a href="#40570754">prev</a><span>|</span><a href="#40571297">next</a><span>|</span><label class="collapse" for="c-40571252">[-]</label><label class="expand" for="c-40571252">[1 more]</label></div><br/><div class="children"><div class="content">Main thing for me, they take the Apple hint and again increase caches (and add another cache layer L0)</div><br/></div></div><div id="40571297" class="c"><input type="checkbox" id="c-40571297" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#40571252">prev</a><span>|</span><label class="collapse" for="c-40571297">[-]</label><label class="expand" for="c-40571297">[1 more]</label></div><br/><div class="children"><div class="content">End of the unified scheduler is big news, Intel had this since Core. Both AMD and Apple have split the scheduling up for a long time.</div><br/></div></div></div></div></div></div></div></body></html>