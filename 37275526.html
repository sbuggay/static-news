<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693126853352" as="style"/><link rel="stylesheet" href="styles.css?v=1693126853352"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.youtube.com/watch?v=ZI198eFghJk">Modernizing compiler design for Carbon&#x27;s toolchain [video]</a> <span class="domain">(<a href="https://www.youtube.com">www.youtube.com</a>)</span></div><div class="subtext"><span>Rusky</span> | <span>27 comments</span></div><br/><div><div id="37278893" class="c"><input type="checkbox" id="c-37278893" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#37276126">next</a><span>|</span><label class="collapse" for="c-37278893">[-]</label><label class="expand" for="c-37278893">[2 more]</label></div><br/><div class="children"><div class="content">The goal of lowering to binary at 0.1 million lines&#x2F;sec isn&#x27;t very ambitious. Virgil bootstraps its 59,000 line compiler in 400 milliseconds, which is over that number, and it does whole program reachability and optimization.<p>On the other hand, the 10 million lines&#x2F;sec parsing is probably not achievable. Thats 400MB&#x2F;s. The fastest JavaScript parser I know of, V8&#x27;s, is on the order of 60-80MB&#x2F;s. Virgil&#x27;s is about 45MB&#x2F;s. Maybe if you are parsing Lisp you can get to 200MB&#x2F;s, but no curly-braced language with actual syntax is going to parse that fast.<p>And you don&#x27;t have to parse 10X faster than semantic analysis. In my experience, semantic analysis is only about 2X as expensive as parsing, so that 1 million line&#x2F;sec goal for semantic analysis is easily achievable. (Virgil is at about 800KLoc&#x2F;sec).<p>Keep in mind the above is all just one core. 10 and 20 core CPUs are becoming widespread, and these two phases parallelize nicely. Just don&#x27;t do C&#x27;s stupid O(n^2) header madness and Carbon will compile plenty fast.</div><br/><div id="37279156" class="c"><input type="checkbox" id="c-37279156" checked=""/><div class="controls bullet"><span class="by">meeho</span><span>|</span><a href="#37278893">parent</a><span>|</span><a href="#37276126">next</a><span>|</span><label class="collapse" for="c-37279156">[-]</label><label class="expand" for="c-37279156">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Just don&#x27;t do C&#x27;s stupid O(n^2) header madness and Carbon will compile plenty fast.<p>Outdated is a better term IMO. This design made sense at that time (Weak hardware and small codebases)</div><br/></div></div></div></div><div id="37276126" class="c"><input type="checkbox" id="c-37276126" checked=""/><div class="controls bullet"><span class="by">sctb</span><span>|</span><a href="#37278893">prev</a><span>|</span><a href="#37279799">next</a><span>|</span><label class="collapse" for="c-37276126">[-]</label><label class="expand" for="c-37276126">[14 more]</label></div><br/><div class="children"><div class="content">Something that stands out to me from this talk is the idea of linearizing ASTs—I was reminded of Aaron Hsu&#x27;s work on Co dfns. There was an excellent YouTube video from years ago (does anyone have the link?) where he described how his compiler, written in APL, manages its data in an array-friendly linear fashion.</div><br/><div id="37276492" class="c"><input type="checkbox" id="c-37276492" checked=""/><div class="controls bullet"><span class="by">raphlinus</span><span>|</span><a href="#37276126">parent</a><span>|</span><a href="#37276389">next</a><span>|</span><label class="collapse" for="c-37276492">[-]</label><label class="expand" for="c-37276492">[4 more]</label></div><br/><div class="children"><div class="content">I suspect it may be: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=5I4YPkVU7mY">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=5I4YPkVU7mY</a><p>I&#x27;m interested in this because these linearized tree representations lend themselves well to processing on GPU. We use them in Vello for representing clip and blend groups, with quite deep nesting level allowed. By contrast, the traditional pointer chasing approach to ASTs limits parallelism and has poor utilization of memory bandwidth.</div><br/><div id="37276803" class="c"><input type="checkbox" id="c-37276803" checked=""/><div class="controls bullet"><span class="by">sctb</span><span>|</span><a href="#37276126">root</a><span>|</span><a href="#37276492">parent</a><span>|</span><a href="#37277703">next</a><span>|</span><label class="collapse" for="c-37276803">[-]</label><label class="expand" for="c-37276803">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the link! I just found the one I was thinking of, which is older but perhaps goes into more detail: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=gcUWTa16Jc0&amp;list=PLDU0iEj6f8duXzmgnlGX4hMHJUMYh4rJq&amp;index=3">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=gcUWTa16Jc0&amp;list=PLDU0iEj6f8...</a>.</div><br/></div></div><div id="37277703" class="c"><input type="checkbox" id="c-37277703" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#37276126">root</a><span>|</span><a href="#37276492">parent</a><span>|</span><a href="#37276803">prev</a><span>|</span><a href="#37276389">next</a><span>|</span><label class="collapse" for="c-37277703">[-]</label><label class="expand" for="c-37277703">[2 more]</label></div><br/><div class="children"><div class="content">Agreed but also this feels like a way to spending hundreds of engineer-years for a 7.3% speedup on the common case.</div><br/><div id="37279650" class="c"><input type="checkbox" id="c-37279650" checked=""/><div class="controls bullet"><span class="by">sudosysgen</span><span>|</span><a href="#37276126">root</a><span>|</span><a href="#37277703">parent</a><span>|</span><a href="#37276389">next</a><span>|</span><label class="collapse" for="c-37279650">[-]</label><label class="expand" for="c-37279650">[1 more]</label></div><br/><div class="children"><div class="content">Even a 0.5% speedup is worth hundreds of engineer-years if it&#x27;s in the common case for a popular language.</div><br/></div></div></div></div></div></div><div id="37276389" class="c"><input type="checkbox" id="c-37276389" checked=""/><div class="controls bullet"><span class="by">posnet</span><span>|</span><a href="#37276126">parent</a><span>|</span><a href="#37276492">prev</a><span>|</span><a href="#37279799">next</a><span>|</span><label class="collapse" for="c-37276389">[-]</label><label class="expand" for="c-37276389">[9 more]</label></div><br/><div class="children"><div class="content">Also similar to the design of the Luajit IR.<p>&quot;Linear, pointer-free IR: The typed IR is SSA-based and highly
  orthogonal. An instruction takes up only 64 bits. It has up to
  two operands which are 16 bit references. It&#x27;s implemented with
  a bidirectionally growable array. No trees, no pointers, no cry.
  Heavily optimized for minimal D-cache impact, too.&quot; [0]<p>[0] <a href="http:&#x2F;&#x2F;lua-users.org&#x2F;lists&#x2F;lua-l&#x2F;2009-11&#x2F;msg00089.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;lua-users.org&#x2F;lists&#x2F;lua-l&#x2F;2009-11&#x2F;msg00089.html</a></div><br/><div id="37277671" class="c"><input type="checkbox" id="c-37277671" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#37276126">root</a><span>|</span><a href="#37276389">parent</a><span>|</span><a href="#37279799">next</a><span>|</span><label class="collapse" for="c-37277671">[-]</label><label class="expand" for="c-37277671">[8 more]</label></div><br/><div class="children"><div class="content">I am a compiler engineer and this is not as great as it seems like.<p>If you are replacing pointer chasing with arbitrary indexes into arrays, you are likely going to make it orders of magnitude slower for large arrays.  (It&#x27;s barely worth it even if the array fits in L1)<p>It&#x27;s counterintuitive because pointers have been optimized on hardware for about 50 years, and array indices are just pointers that your hardware doesn&#x27;t know about.<p>The main things that go wrong are hardware prefetching and compiler optimizations taking advantage of alias analysis.</div><br/><div id="37280518" class="c"><input type="checkbox" id="c-37280518" checked=""/><div class="controls bullet"><span class="by">vanderZwan</span><span>|</span><a href="#37276126">root</a><span>|</span><a href="#37277671">parent</a><span>|</span><a href="#37279551">next</a><span>|</span><label class="collapse" for="c-37280518">[-]</label><label class="expand" for="c-37280518">[1 more]</label></div><br/><div class="children"><div class="content">Maybe the next paragraph in the link is a crucial bit of missing context here?<p>&gt; <i>Skip-list chains: The IR is threaded with segregated, per-opcode skip-list chains. The links are stored in a multi-purpose 16 bit field in the instruction. This facilitates low-overhead lookup for CSE, DSE and alias analysis. Back-linking enables short-cut  searches (average overhead is less than 1 lookup). Incremental  build-up is trivial. No hashes, no sets, no complex updates.</i><p>Seems like there is more going on than just replacing pointers with arrays 1:1.</div><br/></div></div><div id="37279551" class="c"><input type="checkbox" id="c-37279551" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#37276126">root</a><span>|</span><a href="#37277671">parent</a><span>|</span><a href="#37280518">prev</a><span>|</span><a href="#37277793">next</a><span>|</span><label class="collapse" for="c-37279551">[-]</label><label class="expand" for="c-37279551">[3 more]</label></div><br/><div class="children"><div class="content">Are you saying a move from&#x2F;to [register+offset] is a magnitude(s) slower than a move from&#x2F;to [register]? And that prefetching doesn&#x27;t work with them? Because that&#x27;s what array indices effectively result in. And... that&#x27;s not true for either case as far as I know.</div><br/><div id="37279768" class="c"><input type="checkbox" id="c-37279768" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#37276126">root</a><span>|</span><a href="#37279551">parent</a><span>|</span><a href="#37277793">next</a><span>|</span><label class="collapse" for="c-37279768">[-]</label><label class="expand" for="c-37279768">[2 more]</label></div><br/><div class="children"><div class="content">Arrays shine when you access the elements in a predictable order.<p>That&#x27;s what compiler backend and hardware optimizes for.<p>Blindly replacing pointers with random indexes into large arrays doesn&#x27;t pan out.</div><br/><div id="37280486" class="c"><input type="checkbox" id="c-37280486" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#37276126">root</a><span>|</span><a href="#37279768">parent</a><span>|</span><a href="#37277793">next</a><span>|</span><label class="collapse" for="c-37280486">[-]</label><label class="expand" for="c-37280486">[1 more]</label></div><br/><div class="children"><div class="content">This is still really vague. Doesn&#x27;t pan out how exactly? Arrays aren&#x27;t a thing at hardware level and are only sometimes a thing in compiler backend. Prefetching the next line helps, but it&#x27;s irrelevant how the type is represented in the code. (And you can explicitly prefetch from a random address as well) What downsides are you talking about here specifically? Where do the orders of magnitude come from?</div><br/></div></div></div></div></div></div><div id="37277793" class="c"><input type="checkbox" id="c-37277793" checked=""/><div class="controls bullet"><span class="by">the-smug-one</span><span>|</span><a href="#37276126">root</a><span>|</span><a href="#37277671">parent</a><span>|</span><a href="#37279551">prev</a><span>|</span><a href="#37279799">next</a><span>|</span><label class="collapse" for="c-37277793">[-]</label><label class="expand" for="c-37277793">[3 more]</label></div><br/><div class="children"><div class="content">I dunno, is that really true? The indices into the array can be 4 instead of 8 bytes on a 64-bit system for example, that would double the indices available in one cache line. And then you have the possibility of storing the in&#x2F;out node references as indices also, halving the memory there. And I know that work lists and stacks of nodes are common for certain transformations, so that would also have an impact. And that&#x27;s just one thing, having an index effectively means that you can split your data structure into multiple arrays (&#x27;struct of arrays&#x27; fashion), which might mean that you&#x27;re doing fewer accesses and jumps over all.<p>Considering all of that, I&#x27;m really not convinced that plain pointers will beat indices. I also don&#x27;t see what alias analysis has to do with it in this case, sounds like a compiler could easily do alias analysis on A being accessed only as a T by virtue of A having the type Array&lt;T,N&gt;.</div><br/><div id="37278079" class="c"><input type="checkbox" id="c-37278079" checked=""/><div class="controls bullet"><span class="by">mattsan</span><span>|</span><a href="#37276126">root</a><span>|</span><a href="#37277793">parent</a><span>|</span><a href="#37279168">next</a><span>|</span><label class="collapse" for="c-37278079">[-]</label><label class="expand" for="c-37278079">[1 more]</label></div><br/><div class="children"><div class="content">Might be worth exploring linear ASTs with relative pointers which size could be truncated along with N-byte alignments</div><br/></div></div><div id="37279168" class="c"><input type="checkbox" id="c-37279168" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#37276126">root</a><span>|</span><a href="#37277793">parent</a><span>|</span><a href="#37278079">prev</a><span>|</span><a href="#37279799">next</a><span>|</span><label class="collapse" for="c-37279168">[-]</label><label class="expand" for="c-37279168">[1 more]</label></div><br/><div class="children"><div class="content">profile it!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37279799" class="c"><input type="checkbox" id="c-37279799" checked=""/><div class="controls bullet"><span class="by">GuestHNUser</span><span>|</span><a href="#37276126">prev</a><span>|</span><a href="#37276328">next</a><span>|</span><label class="collapse" for="c-37279799">[-]</label><label class="expand" for="c-37279799">[1 more]</label></div><br/><div class="children"><div class="content">Good talk, however, I recommend people watch Andrew Kelley&#x27;s talk[1] first. His talk has clearly had a major influence on Carbon&#x27;s compiler design, plus I think Andrew&#x27;s talk is a lot more practical for those not in the compiler space.<p>[1] <a href="https:&#x2F;&#x2F;vimeo.com&#x2F;649009599" rel="nofollow noreferrer">https:&#x2F;&#x2F;vimeo.com&#x2F;649009599</a></div><br/></div></div><div id="37276328" class="c"><input type="checkbox" id="c-37276328" checked=""/><div class="controls bullet"><span class="by">isaiahg</span><span>|</span><a href="#37279799">prev</a><span>|</span><label class="collapse" for="c-37276328">[-]</label><label class="expand" for="c-37276328">[9 more]</label></div><br/><div class="children"><div class="content">I find carbon and the development of a modern replacement for C++ intriguing to watch. But for the life of me I can’t understand why someone would want this over a more mature language like D</div><br/><div id="37276832" class="c"><input type="checkbox" id="c-37276832" checked=""/><div class="controls bullet"><span class="by">sctb</span><span>|</span><a href="#37276328">parent</a><span>|</span><a href="#37276815">next</a><span>|</span><label class="collapse" for="c-37276832">[-]</label><label class="expand" for="c-37276832">[2 more]</label></div><br/><div class="children"><div class="content">At least one major reason is &quot;Interoperate with your existing C++ code, from inheritance to templates&quot; (<a href="https:&#x2F;&#x2F;github.com&#x2F;carbon-language&#x2F;carbon-lang">https:&#x2F;&#x2F;github.com&#x2F;carbon-language&#x2F;carbon-lang</a>).</div><br/><div id="37277712" class="c"><input type="checkbox" id="c-37277712" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#37276328">root</a><span>|</span><a href="#37276832">parent</a><span>|</span><a href="#37276815">next</a><span>|</span><label class="collapse" for="c-37277712">[-]</label><label class="expand" for="c-37277712">[1 more]</label></div><br/><div class="children"><div class="content">D interacts with LLVM via using C++ inheritance and templates although not via their original source to be fair.<p>N.B. ChatGPT is not a toy in this domain - weird macro? It can reason.</div><br/></div></div></div></div><div id="37276815" class="c"><input type="checkbox" id="c-37276815" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37276328">parent</a><span>|</span><a href="#37276832">prev</a><span>|</span><a href="#37279044">next</a><span>|</span><label class="collapse" for="c-37276815">[-]</label><label class="expand" for="c-37276815">[3 more]</label></div><br/><div class="children"><div class="content">The problem with D is changing direction every couple of years regarding the next big feature that will finally bring the masses into the language, while not quite finishing the last big feature that predated it.<p>Even Andrei Alexandrescu is back doing C++ at NVidia.</div><br/><div id="37276922" class="c"><input type="checkbox" id="c-37276922" checked=""/><div class="controls bullet"><span class="by">suby</span><span>|</span><a href="#37276328">root</a><span>|</span><a href="#37276815">parent</a><span>|</span><a href="#37279044">next</a><span>|</span><label class="collapse" for="c-37276922">[-]</label><label class="expand" for="c-37276922">[2 more]</label></div><br/><div class="children"><div class="content">I also don&#x27;t know if the code I write in D today will compile 20 years from now. A few months ago there was a discussion on the D forums which spilled over here about constant churn due to breaking changes in the language.</div><br/><div id="37276977" class="c"><input type="checkbox" id="c-37276977" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#37276328">root</a><span>|</span><a href="#37276922">parent</a><span>|</span><a href="#37279044">next</a><span>|</span><label class="collapse" for="c-37276977">[-]</label><label class="expand" for="c-37276977">[1 more]</label></div><br/><div class="children"><div class="content">The guy who wrote that loves controversy.</div><br/></div></div></div></div></div></div><div id="37279044" class="c"><input type="checkbox" id="c-37279044" checked=""/><div class="controls bullet"><span class="by">summerlight</span><span>|</span><a href="#37276328">parent</a><span>|</span><a href="#37276815">prev</a><span>|</span><a href="#37278974">next</a><span>|</span><label class="collapse" for="c-37279044">[-]</label><label class="expand" for="c-37279044">[1 more]</label></div><br/><div class="children"><div class="content">I think Google is exploring other options as well, such as Rust. Carbon is a more aggressive experiment with higher risks. They&#x27;ve been very clear about Carbon&#x27;s experimental status and that users should consider using Rust or something else instead of Carbon if they can use the one right now.</div><br/></div></div><div id="37278974" class="c"><input type="checkbox" id="c-37278974" checked=""/><div class="controls bullet"><span class="by">xvilka</span><span>|</span><a href="#37276328">parent</a><span>|</span><a href="#37279044">prev</a><span>|</span><a href="#37276354">next</a><span>|</span><label class="collapse" for="c-37278974">[-]</label><label class="expand" for="c-37278974">[1 more]</label></div><br/><div class="children"><div class="content">Or Rust.</div><br/></div></div></div></div></div></div></div></div></div></body></html>