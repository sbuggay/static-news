<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683968448910" as="style"/><link rel="stylesheet" href="styles.css?v=1683968448910"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.thurrott.com/windows/windows-11/282995/first-rust-code-shows-up-in-the-windows-11-kernel">First Rust code in the Windows 11 kernel</a> <span class="domain">(<a href="https://www.thurrott.com">www.thurrott.com</a>)</span></div><div class="subtext"><span>wojtczyk</span> | <span>70 comments</span></div><br/><div><div id="35924572" class="c"><input type="checkbox" id="c-35924572" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#35924266">next</a><span>|</span><label class="collapse" for="c-35924572">[-]</label><label class="expand" for="c-35924572">[19 more]</label></div><br/><div class="children"><div class="content">On a related note, Azure just endorsed Rust to replace C&#x2F;C++ as the non-garbage-collected language of choice.<p><a href="https:&#x2F;&#x2F;azure.microsoft.com&#x2F;en-us&#x2F;blog&#x2F;microsoft-azure-security-evolution-embrace-secure-multitenancy-confidential-compute-and-rust&#x2F;" rel="nofollow">https:&#x2F;&#x2F;azure.microsoft.com&#x2F;en-us&#x2F;blog&#x2F;microsoft-azure-secur...</a><p><i>&gt; Rust as the path forward over C&#x2F;C++<p>&gt; Decades of vulnerabilities have proven how difficult it is to prevent memory-corrupting bugs when using C&#x2F;C++. While garbage-collected languages like C# or Java have proven more resilient to these issues, there are scenarios where they cannot be used. For such cases, we’re betting on Rust as the alternative to C&#x2F;C++. Rust is a modern language designed to compete with the performance C&#x2F;C++, but with memory safety and thread safety guarantees built into the language. While we are not able to rewrite everything in Rust overnight, we’ve already adopted Rust in some of the most critical components of Azure’s infrastructure. We expect our adoption of Rust to expand substantially over time.</i></div><br/><div id="35925420" class="c"><input type="checkbox" id="c-35925420" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#35924572">parent</a><span>|</span><a href="#35925355">next</a><span>|</span><label class="collapse" for="c-35925420">[-]</label><label class="expand" for="c-35925420">[17 more]</label></div><br/><div class="children"><div class="content">This is great but I do wish that people could see Rust as more than a better C&#x2F;C++. It&#x27;s an amazing language for web services and CLIs.<p>It&#x27;s not just that it doesn&#x27;t have a GC. It also doesn&#x27;t have some of the worst features of OOP, it also has a sane std library, it also has an expressive type system, etc. Rust helps you write better code, even when compared to languages like Java or Python.</div><br/><div id="35926766" class="c"><input type="checkbox" id="c-35926766" checked=""/><div class="controls bullet"><span class="by">pharmakom</span><span>|</span><a href="#35924572">root</a><span>|</span><a href="#35925420">parent</a><span>|</span><a href="#35926215">next</a><span>|</span><label class="collapse" for="c-35926766">[-]</label><label class="expand" for="c-35926766">[1 more]</label></div><br/><div class="children"><div class="content">All true but it’s not as productive as a GC language from the ML family. If you don’t need the performance &#x2F; latency guarantees I’m not sure it’s worth it.</div><br/></div></div><div id="35926215" class="c"><input type="checkbox" id="c-35926215" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#35924572">root</a><span>|</span><a href="#35925420">parent</a><span>|</span><a href="#35926766">prev</a><span>|</span><a href="#35925989">next</a><span>|</span><label class="collapse" for="c-35926215">[-]</label><label class="expand" for="c-35926215">[1 more]</label></div><br/><div class="children"><div class="content">It’s as amazing for web services as C++. There might be some niche use case, but would not be my first, nor second choice there.<p>It is still a low-level language, and while it is expressive, that doesn’t stop the low-level constructs from leaking to high level abstractions — which is not a negative in itself, that’s the purpose of the language. It’s just a hard tradeoff when it comes to anything not needing low level considerations.</div><br/></div></div><div id="35925989" class="c"><input type="checkbox" id="c-35925989" checked=""/><div class="controls bullet"><span class="by">toyg</span><span>|</span><a href="#35924572">root</a><span>|</span><a href="#35925420">parent</a><span>|</span><a href="#35926215">prev</a><span>|</span><a href="#35925899">next</a><span>|</span><label class="collapse" for="c-35925989">[-]</label><label class="expand" for="c-35925989">[6 more]</label></div><br/><div class="children"><div class="content">The trade-off in complexity and loss of productivity (particularly at prototype time) are just not worth it.</div><br/><div id="35926679" class="c"><input type="checkbox" id="c-35926679" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#35924572">root</a><span>|</span><a href="#35925989">parent</a><span>|</span><a href="#35926717">next</a><span>|</span><label class="collapse" for="c-35926679">[-]</label><label class="expand" for="c-35926679">[2 more]</label></div><br/><div class="children"><div class="content">Personally I regard Rust as strictly less complex than most other languages (to use - not to learn). The space of programs you&#x27;re searching through is smaller and more constrained (there are fewer valid Rust programs then valid Python programs, and we can make stronger statements about the behavior of a valid Rust program). Ergo, simpler. Internalizing those constraints so they aren&#x27;t generally slowing you down takes an investment however.<p>Recently I had a vexing silent bug in a prototype, where I was intermingling strings and ints as keys in a dictionary, and thus not writing to the correct keys. Normally I would be more careful than that, but it was a quick and dirty proof of concept. Because this involved JSON deserialization, Python&#x27;s modest static type checking couldn&#x27;t catch it.<p>That just wouldn&#x27;t have happened in Rust. (But of course, I wouldn&#x27;t have had the particular ML libraries I needed, either, so Python remains the best option for this project.)</div><br/><div id="35926770" class="c"><input type="checkbox" id="c-35926770" checked=""/><div class="controls bullet"><span class="by">pharmakom</span><span>|</span><a href="#35924572">root</a><span>|</span><a href="#35926679">parent</a><span>|</span><a href="#35926717">next</a><span>|</span><label class="collapse" for="c-35926770">[-]</label><label class="expand" for="c-35926770">[1 more]</label></div><br/><div class="children"><div class="content">There are infinitely many Rust and Python programs, just as there are infinitely many English sentences. Search is a  really weird way to talk about programming.</div><br/></div></div></div></div><div id="35926717" class="c"><input type="checkbox" id="c-35926717" checked=""/><div class="controls bullet"><span class="by">wiz21c</span><span>|</span><a href="#35924572">root</a><span>|</span><a href="#35925989">parent</a><span>|</span><a href="#35926679">prev</a><span>|</span><a href="#35926021">next</a><span>|</span><label class="collapse" for="c-35926717">[-]</label><label class="expand" for="c-35926717">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using it for 2 years now and I can&#x27;t see any loss in productivity. Once you get used to the patterns rust and the BC force upon you, it&#x27;s just as productive as C++ (for me). But you have to get up to speed and that&#x27;s a significant effort (took about 6-12 months for me).<p>I can&#x27;t say much about the ecosystem besides it lacks something in the desktop GUI department (I use egui, it&#x27;s really good, but just it&#x27;s not strong enough). So, yeah, sometimes you miss a library and that can hurt productivity.<p>But the protections against memory and thread issues really help productivity though: I tend to make lots of mistake in these area and rust helps to to prevent many of them.</div><br/></div></div><div id="35926021" class="c"><input type="checkbox" id="c-35926021" checked=""/><div class="controls bullet"><span class="by">vgatherps</span><span>|</span><a href="#35924572">root</a><span>|</span><a href="#35925989">parent</a><span>|</span><a href="#35926717">prev</a><span>|</span><a href="#35925899">next</a><span>|</span><label class="collapse" for="c-35926021">[-]</label><label class="expand" for="c-35926021">[2 more]</label></div><br/><div class="children"><div class="content">This really depends on your use case for it, as all things - it’s hard to just make blanket statements like this</div><br/><div id="35926659" class="c"><input type="checkbox" id="c-35926659" checked=""/><div class="controls bullet"><span class="by">toyg</span><span>|</span><a href="#35924572">root</a><span>|</span><a href="#35926021">parent</a><span>|</span><a href="#35925899">next</a><span>|</span><label class="collapse" for="c-35926659">[-]</label><label class="expand" for="c-35926659">[1 more]</label></div><br/><div class="children"><div class="content">On par with &quot;Rust helps you write better code&quot; in the parent comment.</div><br/></div></div></div></div></div></div><div id="35925899" class="c"><input type="checkbox" id="c-35925899" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#35924572">root</a><span>|</span><a href="#35925420">parent</a><span>|</span><a href="#35925989">prev</a><span>|</span><a href="#35925917">next</a><span>|</span><label class="collapse" for="c-35925899">[-]</label><label class="expand" for="c-35925899">[3 more]</label></div><br/><div class="children"><div class="content">I agree with this but the ownership model is really a huge learning curve for somebody who wants to make an application where it&#x27;s OK if it crashes when there&#x27;s a bug.<p>It would be cool if there was a &quot;relaxed rust&quot; which provided interop with standard rust, but used some designated smart pointer for everything automatically (at the crate level, for example). I&#x27;m not sure how&#x2F;if this could work, but I think it would make transitioning from GC languages -&gt; Rust much easier.</div><br/><div id="35925993" class="c"><input type="checkbox" id="c-35925993" checked=""/><div class="controls bullet"><span class="by">hgomersall</span><span>|</span><a href="#35924572">root</a><span>|</span><a href="#35925899">parent</a><span>|</span><a href="#35925917">next</a><span>|</span><label class="collapse" for="c-35925993">[-]</label><label class="expand" for="c-35925993">[2 more]</label></div><br/><div class="children"><div class="content">You can more or less do this - just wrap everything in arc mutexes and clone everywhere (or use Rc for strictly single threaded). I&#x27;m sure someone will point out where it doesn&#x27;t work but I suspect it would work fairly well but with obvious costs.</div><br/><div id="35926283" class="c"><input type="checkbox" id="c-35926283" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#35924572">root</a><span>|</span><a href="#35925993">parent</a><span>|</span><a href="#35925917">next</a><span>|</span><label class="collapse" for="c-35926283">[-]</label><label class="expand" for="c-35926283">[1 more]</label></div><br/><div class="children"><div class="content">Exactly, but I&#x27;d like to see it done automatically (possibly via a special glyph enabled via crate config?), so that users of this &quot;relaxed rust&quot; don&#x27;t have to think about ownership at all, but can still participate in the rest of the Rust ecosystem, and there&#x27;s a clear &quot;off-ramp&quot; to standard rust.</div><br/></div></div></div></div></div></div><div id="35925917" class="c"><input type="checkbox" id="c-35925917" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#35924572">root</a><span>|</span><a href="#35925420">parent</a><span>|</span><a href="#35925899">prev</a><span>|</span><a href="#35925355">next</a><span>|</span><label class="collapse" for="c-35925917">[-]</label><label class="expand" for="c-35925917">[5 more]</label></div><br/><div class="children"><div class="content">Any sign of async functions in traits without the macro? One kindah would expect first class async support for web services and honestly something like Swift prob. has better balance between usability and speed for most web services.</div><br/><div id="35925934" class="c"><input type="checkbox" id="c-35925934" checked=""/><div class="controls bullet"><span class="by">hgomersall</span><span>|</span><a href="#35924572">root</a><span>|</span><a href="#35925917">parent</a><span>|</span><a href="#35925355">next</a><span>|</span><label class="collapse" for="c-35925934">[-]</label><label class="expand" for="c-35925934">[4 more]</label></div><br/><div class="children"><div class="content">Yeah, it&#x27;s expected this year: <a href="https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2023&#x2F;05&#x2F;03&#x2F;stabilizing-async-fn-in-trait.html" rel="nofollow">https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2023&#x2F;05&#x2F;03&#x2F;stabilizin...</a></div><br/><div id="35926003" class="c"><input type="checkbox" id="c-35926003" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#35924572">root</a><span>|</span><a href="#35925934">parent</a><span>|</span><a href="#35925355">next</a><span>|</span><label class="collapse" for="c-35926003">[-]</label><label class="expand" for="c-35926003">[3 more]</label></div><br/><div class="children"><div class="content">async fn do_health_check_par&lt;HC&gt;(hc: HC)
where
    HC: HealthCheck + Send + &#x27;static,
    HC::check(): Send, &#x2F;&#x2F; &lt;-- associated return type
{
    tokio::task::spawn(async move {
        if !hc.check().await {
            log_health_check_failure().await;
        }
    });
}<p>Hmm I think for 95% of the people sticking to something like Swift would work out better for them</div><br/><div id="35926289" class="c"><input type="checkbox" id="c-35926289" checked=""/><div class="controls bullet"><span class="by">hgomersall</span><span>|</span><a href="#35924572">root</a><span>|</span><a href="#35926003">parent</a><span>|</span><a href="#35925355">next</a><span>|</span><label class="collapse" for="c-35926289">[-]</label><label class="expand" for="c-35926289">[2 more]</label></div><br/><div class="children"><div class="content">Are you saying 95% of use cases require spawning new tasks within the trait implementation based on argument futures? Or are you making a more general comment about rust generics? The MVP looks about as clean as I could hope for most use cases.</div><br/><div id="35926466" class="c"><input type="checkbox" id="c-35926466" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#35924572">root</a><span>|</span><a href="#35926289">parent</a><span>|</span><a href="#35925355">next</a><span>|</span><label class="collapse" for="c-35926466">[-]</label><label class="expand" for="c-35926466">[1 more]</label></div><br/><div class="children"><div class="content">I am saying that in web services you will frequently use async functions that
look like async fn do_blah(db_repo: impl DBRepo ...) {...} and are executed on
async-std or Tokio</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="35925355" class="c"><input type="checkbox" id="c-35925355" checked=""/><div class="controls bullet"><span class="by">Gigachad</span><span>|</span><a href="#35924572">parent</a><span>|</span><a href="#35925420">prev</a><span>|</span><a href="#35924266">next</a><span>|</span><label class="collapse" for="c-35925355">[-]</label><label class="expand" for="c-35925355">[1 more]</label></div><br/><div class="children"><div class="content">Rustbros just keep winning</div><br/></div></div></div></div><div id="35924266" class="c"><input type="checkbox" id="c-35924266" checked=""/><div class="controls bullet"><span class="by">solarkraft</span><span>|</span><a href="#35924572">prev</a><span>|</span><a href="#35925727">next</a><span>|</span><label class="collapse" for="c-35924266">[-]</label><label class="expand" for="c-35924266">[20 more]</label></div><br/><div class="children"><div class="content">Damn! If I&#x27;m correctly informed, this is before Linux is doing it (actually shipping rust code, not having the infrastructure in place).</div><br/><div id="35926156" class="c"><input type="checkbox" id="c-35926156" checked=""/><div class="controls bullet"><span class="by">TazeTSchnitzel</span><span>|</span><a href="#35924266">parent</a><span>|</span><a href="#35924745">next</a><span>|</span><label class="collapse" for="c-35926156">[-]</label><label class="expand" for="c-35926156">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s easier for Windows to do it because it only targets a small number of architectures (maybe only x86-64 and AArch64 these days?), and only Microsoft need to be able to build it. The Linux kernel has a huge number of targets and the build system needs to be solid for a huge number of people.</div><br/></div></div><div id="35924745" class="c"><input type="checkbox" id="c-35924745" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#35924266">parent</a><span>|</span><a href="#35926156">prev</a><span>|</span><a href="#35924338">next</a><span>|</span><label class="collapse" for="c-35924745">[-]</label><label class="expand" for="c-35924745">[1 more]</label></div><br/><div class="children"><div class="content">Not surprising. Linux is one of the few monolithic kernels.<p>It’s kind of a worst case scenario for adding in a new language to as a result, since it can’t be added in a very isolated way.</div><br/></div></div><div id="35924338" class="c"><input type="checkbox" id="c-35924338" checked=""/><div class="controls bullet"><span class="by">therein</span><span>|</span><a href="#35924266">parent</a><span>|</span><a href="#35924745">prev</a><span>|</span><a href="#35924822">next</a><span>|</span><label class="collapse" for="c-35924338">[-]</label><label class="expand" for="c-35924338">[2 more]</label></div><br/><div class="children"><div class="content">I feel like there is a way more vibrant driver developer community for Windows anyway. It could be the architecture for kernel drivers Windows has or that many people use it for malware and game cheat development. I have a fond attachment to all the tools you have in your disposal once loaded into the kernel space on Windows. win32kbase.sys being at a certain memory location for all processes, KeUserModeCallback etc. all around really fun and interesting to hack with. Doing DKOM on PEB, TEB of kernel processes or user processes to do things you shouldn&#x27;t be able to do like call win32 apis from kernel pretending to be a process to draw things using GDI etc.<p>Even though I primarily am a Linux user and I prefer using Linux on a daily basis, dabbling in Linux kernel development failed to create this feeling of awe and infinite possibilities (and exploitability) in my mind.<p>I guess my point is, Windows Kernel development in Rust excites me. Same with Linux would be very cool but it doesn&#x27;t create the same feeling of wonder in me. Perhaps that&#x27;s why this is happening first.</div><br/><div id="35924467" class="c"><input type="checkbox" id="c-35924467" checked=""/><div class="controls bullet"><span class="by">dilawar</span><span>|</span><a href="#35924266">root</a><span>|</span><a href="#35924338">parent</a><span>|</span><a href="#35924822">next</a><span>|</span><label class="collapse" for="c-35924467">[-]</label><label class="expand" for="c-35924467">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;SubconsciousCompute&#x2F;poc-windows-rust-filter">https:&#x2F;&#x2F;github.com&#x2F;SubconsciousCompute&#x2F;poc-windows-rust-filt...</a><p>We have been playing with Rust and minifilter for Windows. Its almost there. Microsoft has been working on rust driver kit.</div><br/></div></div></div></div><div id="35924822" class="c"><input type="checkbox" id="c-35924822" checked=""/><div class="controls bullet"><span class="by">gjsman-1000</span><span>|</span><a href="#35924266">parent</a><span>|</span><a href="#35924338">prev</a><span>|</span><a href="#35925727">next</a><span>|</span><label class="collapse" for="c-35924822">[-]</label><label class="expand" for="c-35924822">[15 more]</label></div><br/><div class="children"><div class="content">Windows under the hood with the NT Kernel is actually regarded among some experts as technically superior to Linux with the driver model and personalities subsystem; it’s just that the stuff above the kernel isn’t so great…</div><br/><div id="35925026" class="c"><input type="checkbox" id="c-35925026" checked=""/><div class="controls bullet"><span class="by">waboremo</span><span>|</span><a href="#35924266">root</a><span>|</span><a href="#35924822">parent</a><span>|</span><a href="#35925833">next</a><span>|</span><label class="collapse" for="c-35925026">[-]</label><label class="expand" for="c-35925026">[7 more]</label></div><br/><div class="children"><div class="content">The one place microsoft&#x27;s advertising branch can&#x27;t get to!</div><br/><div id="35925919" class="c"><input type="checkbox" id="c-35925919" checked=""/><div class="controls bullet"><span class="by">streakfix</span><span>|</span><a href="#35924266">root</a><span>|</span><a href="#35925026">parent</a><span>|</span><a href="#35925190">next</a><span>|</span><label class="collapse" for="c-35925919">[-]</label><label class="expand" for="c-35925919">[5 more]</label></div><br/><div class="children"><div class="content">Their scheduler is pure bullcrap. It favors cpu intensive applications, meaning it&#x27;s good for gaming but horrible for every other use case</div><br/><div id="35925988" class="c"><input type="checkbox" id="c-35925988" checked=""/><div class="controls bullet"><span class="by">PaulRobinson</span><span>|</span><a href="#35924266">root</a><span>|</span><a href="#35925919">parent</a><span>|</span><a href="#35926166">next</a><span>|</span><label class="collapse" for="c-35925988">[-]</label><label class="expand" for="c-35925988">[1 more]</label></div><br/><div class="children"><div class="content">That makes sense if your main target use case is desktops where a small number of CPU-intensive apps are running, right? And even in many server apps where you have one main app being the reason the server is booted, this makes broad sense.<p>Don’t get my wrong, but me and I bleed Unix-like systems and have done for decades, but what you’re saying actually makes sense for MS as a design decision…</div><br/></div></div><div id="35926166" class="c"><input type="checkbox" id="c-35926166" checked=""/><div class="controls bullet"><span class="by">AlexSW</span><span>|</span><a href="#35924266">root</a><span>|</span><a href="#35925919">parent</a><span>|</span><a href="#35925988">prev</a><span>|</span><a href="#35926205">next</a><span>|</span><label class="collapse" for="c-35926166">[-]</label><label class="expand" for="c-35926166">[2 more]</label></div><br/><div class="children"><div class="content">How so? I believe I understand Windows&#x27; thread scheduler and this conclusion isn&#x27;t obvious to me at all; from my understanding it seemed perfectly reasonable.</div><br/><div id="35926458" class="c"><input type="checkbox" id="c-35926458" checked=""/><div class="controls bullet"><span class="by">streakfix</span><span>|</span><a href="#35924266">root</a><span>|</span><a href="#35926166">parent</a><span>|</span><a href="#35926205">next</a><span>|</span><label class="collapse" for="c-35926458">[-]</label><label class="expand" for="c-35926458">[1 more]</label></div><br/><div class="children"><div class="content">Put windows on a 4 core system. Open two terminals. Run cargo build in one terminal. Run ls in the other terminal.ls will hang for a good 10 seconds before printing output</div><br/></div></div></div></div><div id="35926205" class="c"><input type="checkbox" id="c-35926205" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35924266">root</a><span>|</span><a href="#35925919">parent</a><span>|</span><a href="#35926166">prev</a><span>|</span><a href="#35925190">next</a><span>|</span><label class="collapse" for="c-35926205">[-]</label><label class="expand" for="c-35926205">[1 more]</label></div><br/><div class="children"><div class="content">I would agree, if we would still be talking about Windows NT 4.0 or Windows 2000.</div><br/></div></div></div></div><div id="35925190" class="c"><input type="checkbox" id="c-35925190" checked=""/><div class="controls bullet"><span class="by">photonbeam</span><span>|</span><a href="#35924266">root</a><span>|</span><a href="#35925026">parent</a><span>|</span><a href="#35925919">prev</a><span>|</span><a href="#35925833">next</a><span>|</span><label class="collapse" for="c-35925190">[-]</label><label class="expand" for="c-35925190">[1 more]</label></div><br/><div class="children"><div class="content">For now<p>Syscalls powered by MSNBC</div><br/></div></div></div></div><div id="35925833" class="c"><input type="checkbox" id="c-35925833" checked=""/><div class="controls bullet"><span class="by">yukIttEft</span><span>|</span><a href="#35924266">root</a><span>|</span><a href="#35924822">parent</a><span>|</span><a href="#35925026">prev</a><span>|</span><a href="#35924917">next</a><span>|</span><label class="collapse" for="c-35925833">[-]</label><label class="expand" for="c-35925833">[1 more]</label></div><br/><div class="children"><div class="content">Citations needed.</div><br/></div></div><div id="35924917" class="c"><input type="checkbox" id="c-35924917" checked=""/><div class="controls bullet"><span class="by">LeFantome</span><span>|</span><a href="#35924266">root</a><span>|</span><a href="#35924822">parent</a><span>|</span><a href="#35925833">prev</a><span>|</span><a href="#35926011">next</a><span>|</span><label class="collapse" for="c-35924917">[-]</label><label class="expand" for="c-35924917">[1 more]</label></div><br/><div class="children"><div class="content">VMS under the hood</div><br/></div></div><div id="35926011" class="c"><input type="checkbox" id="c-35926011" checked=""/><div class="controls bullet"><span class="by">toyg</span><span>|</span><a href="#35924266">root</a><span>|</span><a href="#35924822">parent</a><span>|</span><a href="#35924917">prev</a><span>|</span><a href="#35925727">next</a><span>|</span><label class="collapse" for="c-35926011">[-]</label><label class="expand" for="c-35926011">[5 more]</label></div><br/><div class="children"><div class="content">The stuff above is actually pretty good, the problems come mostly from the obsession with supporting a flawed 30-year-old paradigm (the DOS world with its simpleton prompt), a failed system-management concept (the Registry), and the recent steer towards being adware.</div><br/><div id="35926053" class="c"><input type="checkbox" id="c-35926053" checked=""/><div class="controls bullet"><span class="by">Xeamek</span><span>|</span><a href="#35924266">root</a><span>|</span><a href="#35926011">parent</a><span>|</span><a href="#35925727">next</a><span>|</span><label class="collapse" for="c-35926053">[-]</label><label class="expand" for="c-35926053">[4 more]</label></div><br/><div class="children"><div class="content">Why is the Registry a failed concept?</div><br/><div id="35926152" class="c"><input type="checkbox" id="c-35926152" checked=""/><div class="controls bullet"><span class="by">doodlesdev</span><span>|</span><a href="#35924266">root</a><span>|</span><a href="#35926053">parent</a><span>|</span><a href="#35925727">next</a><span>|</span><label class="collapse" for="c-35926152">[-]</label><label class="expand" for="c-35926152">[3 more]</label></div><br/><div class="children"><div class="content">It tries to be both a filesystem and a database and fails miserably at both. Entries layout is a total mess that not even Microsoft pays attention to anymore.<p>Relevant:<p>Why the Windows Registry sucks … technically
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32275078" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32275078</a><p><a href="https:&#x2F;&#x2F;rwmj.wordpress.com&#x2F;2010&#x2F;02&#x2F;18&#x2F;why-the-windows-registry-sucks-technically&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rwmj.wordpress.com&#x2F;2010&#x2F;02&#x2F;18&#x2F;why-the-windows-regist...</a></div><br/><div id="35926200" class="c"><input type="checkbox" id="c-35926200" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35924266">root</a><span>|</span><a href="#35926152">parent</a><span>|</span><a href="#35925727">next</a><span>|</span><label class="collapse" for="c-35926200">[-]</label><label class="expand" for="c-35926200">[2 more]</label></div><br/><div class="children"><div class="content">Yet, the GNOME folks decided to copy it.</div><br/><div id="35926627" class="c"><input type="checkbox" id="c-35926627" checked=""/><div class="controls bullet"><span class="by">toyg</span><span>|</span><a href="#35924266">root</a><span>|</span><a href="#35926200">parent</a><span>|</span><a href="#35925727">next</a><span>|</span><label class="collapse" for="c-35926627">[-]</label><label class="expand" for="c-35926627">[1 more]</label></div><br/><div class="children"><div class="content">Never underestimate the lack of imagination in the Linux-desktop world.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="35925727" class="c"><input type="checkbox" id="c-35925727" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#35924266">prev</a><span>|</span><a href="#35926197">next</a><span>|</span><label class="collapse" for="c-35925727">[-]</label><label class="expand" for="c-35925727">[2 more]</label></div><br/><div class="children"><div class="content">Shows up? I haven&#x27;t used Windows for close to 15 years, but I have not heard that their kernel would be open source now.</div><br/><div id="35925848" class="c"><input type="checkbox" id="c-35925848" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#35925727">parent</a><span>|</span><a href="#35926197">next</a><span>|</span><label class="collapse" for="c-35925848">[-]</label><label class="expand" for="c-35925848">[1 more]</label></div><br/><div class="children"><div class="content">Ok, we&#x27;ve made the title not show up above.</div><br/></div></div></div></div><div id="35924379" class="c"><input type="checkbox" id="c-35924379" checked=""/><div class="controls bullet"><span class="by">esaym</span><span>|</span><a href="#35924789">prev</a><span>|</span><label class="collapse" for="c-35924379">[-]</label><label class="expand" for="c-35924379">[26 more]</label></div><br/><div class="children"><div class="content">Why Rust? Doesn&#x27;t Microsoft have their own similar language, C#? And then isn&#x27;t there some lore about the reason Windows Vista took so long to release was due to them trying to write the entire OS in C# or something and then having to redo everything?</div><br/><div id="35924803" class="c"><input type="checkbox" id="c-35924803" checked=""/><div class="controls bullet"><span class="by">CSMastermind</span><span>|</span><a href="#35924379">parent</a><span>|</span><a href="#35926603">next</a><span>|</span><label class="collapse" for="c-35924803">[-]</label><label class="expand" for="c-35924803">[4 more]</label></div><br/><div class="children"><div class="content">&gt; And then isn&#x27;t there some lore about the reason Windows Vista took so long to release was due to them trying to write the entire OS in C# or something and then having to redo everything?<p>It seems like you&#x27;re confusing a few different things there.<p>The &#x27;redo&#x27; step that you&#x27;re talking about happened because in the early 2000s Microsoft was getting blasted by security breaches left and right.<p>Pretty much every senior developer in the Windows org was pulled to work on security patches.  An in between update to the consumer version of Windows (codename Longhorn) was planned to hold customers over until the team had the time to do a proper iteration on the next OS.<p>As the senior devs were wrapping up their security fixes and coming back to see about shipping Longhorn they decided that it wasn&#x27;t up to their standards and more importantly they didn&#x27;t think it was moving in the right direction because it didn&#x27;t include all the security fixes they had been doing.<p>Longhorn had essentially &#x27;forked&#x27; XP pre-security fix and it was decided that it would be easier to throw out all of the Longhorn code and start fresh then to try and port all the security fixes over.<p>So they just that: they threw out everything that had been worked on, &#x27;reset&#x27; the project to be based on the latest code with all the security fixes present, and then started the development of Vista fresh.</div><br/><div id="35925057" class="c"><input type="checkbox" id="c-35925057" checked=""/><div class="controls bullet"><span class="by">GeekyBear</span><span>|</span><a href="#35924379">root</a><span>|</span><a href="#35924803">parent</a><span>|</span><a href="#35926475">next</a><span>|</span><label class="collapse" for="c-35925057">[-]</label><label class="expand" for="c-35925057">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Longhorn had essentially &#x27;forked&#x27; XP pre-security fix and it was decided that it would be easier to throw out all of the Longhorn code and start fresh then to try and port all the security fixes over.<p>Microsoft internal emails from Jim Allchin (who ran Windows at the time) to Bill Gates reveal that the issue was performance.<p>&gt; LH is a pig and I don’t see any solution to this problem.<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20210427171552&#x2F;http:&#x2F;&#x2F;blog.seattlepi.com&#x2F;microsoft&#x2F;2007&#x2F;01&#x2F;10&#x2F;jim-allchins-mac-message-the-full-text&#x2F;" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20210427171552&#x2F;http:&#x2F;&#x2F;blog.seatt...</a><p>Eventually, the solution was to drop the use of a garbage collected runtime (desired for memory safety) and go back to C&#x2F;C++ (necessary for performance).<p>Now they are moving to a language that gives you the memory safety without taking the performance hit.</div><br/><div id="35926510" class="c"><input type="checkbox" id="c-35926510" checked=""/><div class="controls bullet"><span class="by">StressedDev</span><span>|</span><a href="#35924379">root</a><span>|</span><a href="#35925057">parent</a><span>|</span><a href="#35926475">next</a><span>|</span><label class="collapse" for="c-35926510">[-]</label><label class="expand" for="c-35926510">[1 more]</label></div><br/><div class="children"><div class="content">Longhorn was slow but I doubt garbage collection was the main cause for its poor performance.  First, it was mostly written in C and C++ (remember, Microsoft does not rewrite Windows, it evolves it).  Second, the reason it was slow was some teams checked in code which was not ready.  What I mean is the code was buggy, had exceptionally poor performance, etc.  The code should never have been shared with the entire Windows organization.<p>Note teams could have private source code repositories and Windows builds.  Changes did not have to be shared with the entire Windows team.  The better teams shared their changes when they worked and were ready.  On Vista, a lot of teams shared things which were far from ready.  Note that this was unusual and did not happen on Windows XP.</div><br/></div></div></div></div><div id="35926475" class="c"><input type="checkbox" id="c-35926475" checked=""/><div class="controls bullet"><span class="by">StressedDev</span><span>|</span><a href="#35924379">root</a><span>|</span><a href="#35924803">parent</a><span>|</span><a href="#35925057">prev</a><span>|</span><a href="#35926603">next</a><span>|</span><label class="collapse" for="c-35926475">[-]</label><label class="expand" for="c-35926475">[1 more]</label></div><br/><div class="children"><div class="content">A small correction on the redo step.<p>What you are talking about was called the Windows Security Push and this is how it worked.  Basically, every developer (not just the senior ones) had to help review every line of code in Windows.  First, we were shown presentations which explained why security was important, where Microsoft products had failings, what were common security bugs and how to look for them.  I think the presentations were done my Michael Howard.  They were very good.<p>Then we were given a copy of Writing Secure Code to read.  It enumerated all of the know types of security vulnerabilities and told us how to fix them.  It also taught us how to write a threat model, validate input from untrusted sources, reduce our attack surface, use the principal of least privilege, etc.<p>Finally, we spent three months reviewing Vista&#x27;s code.  Each team was responsible for reviewing its own code.  We filed bugs as we found them and then they were fixed.<p>Note that porting the security fixes to Longhorn from Windows XP took very little work.  Windows had one code base and you could move changes from release A to release B (Windows XP and Windows Vista in this case).<p>Also, Longhorn was reset at some point but all of the work was not thrown out.  Basically, some teams reduce the scope of their work (i.e. cut features) and some projects were cancelled.  The reset did not occur because the security fixes were missing.  It ocucred because Longhorn was an out of control project which had been going on for 2 to 3 years and was not close to shipping.</div><br/></div></div></div></div><div id="35926603" class="c"><input type="checkbox" id="c-35926603" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#35924379">parent</a><span>|</span><a href="#35924803">prev</a><span>|</span><a href="#35924397">next</a><span>|</span><label class="collapse" for="c-35926603">[-]</label><label class="expand" for="c-35926603">[1 more]</label></div><br/><div class="children"><div class="content">C# is much more capable and fitting this purpose today than 10 years ago (perf, codegen quality and infrastructure have improved by orders of magnitude). However, it cannot compete with Rust when it comes to systems programming.<p>Mainly because it has different tradeoffs and its high level abstractions and other features like LINQ, interfaces, non-struct generics and async&#x2F;await are very much not zero-cost, unlike in Rust.<p>In addition, it does not offer crucial features one would want in kernel development: deterministic memory usage, compile-time safety guarantees for writing concurrent data structures and general systems-programming-first language design.<p>While C# is a perfectly viable choice for writing userspace OS components, applications, UI and etc., it is a bad choice for kernelspace when C++ or Rust exist.</div><br/></div></div><div id="35924397" class="c"><input type="checkbox" id="c-35924397" checked=""/><div class="controls bullet"><span class="by">chungy</span><span>|</span><a href="#35924379">parent</a><span>|</span><a href="#35926603">prev</a><span>|</span><a href="#35926418">next</a><span>|</span><label class="collapse" for="c-35924397">[-]</label><label class="expand" for="c-35924397">[12 more]</label></div><br/><div class="children"><div class="content">C# isn&#x27;t even remotely similar. A managed language running in a heavy VM runtime versus a direct-to-machine-code compiled language...</div><br/><div id="35925441" class="c"><input type="checkbox" id="c-35925441" checked=""/><div class="controls bullet"><span class="by">lostmsu</span><span>|</span><a href="#35924379">root</a><span>|</span><a href="#35924397">parent</a><span>|</span><a href="#35924472">next</a><span>|</span><label class="collapse" for="c-35925441">[-]</label><label class="expand" for="c-35925441">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think runtime is that big. The classlib is.</div><br/></div></div><div id="35924472" class="c"><input type="checkbox" id="c-35924472" checked=""/><div class="controls bullet"><span class="by">29athrowaway</span><span>|</span><a href="#35924379">root</a><span>|</span><a href="#35924397">parent</a><span>|</span><a href="#35925441">prev</a><span>|</span><a href="#35926418">next</a><span>|</span><label class="collapse" for="c-35924472">[-]</label><label class="expand" for="c-35924472">[10 more]</label></div><br/><div class="children"><div class="content">Have you heard of native AOT compilation?</div><br/><div id="35925596" class="c"><input type="checkbox" id="c-35925596" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#35924379">root</a><span>|</span><a href="#35924472">parent</a><span>|</span><a href="#35924531">next</a><span>|</span><label class="collapse" for="c-35925596">[-]</label><label class="expand" for="c-35925596">[4 more]</label></div><br/><div class="children"><div class="content">1. That still needs a GC, and thus heap space. Unless you make everything stackalloc which is impossible in kernel programming<p>2. It is heavily pinned by unnecessary metadata. Well, actually some maybe necesdary to facilitate GC but it is bloated anyway<p>3. RyuJIT is not as optimized as LLVM, and RyuJIT produced the AOT code. There in an abandoned project called LILAC attemping to use LLVM as a second AOT generator but it was never heard from again after 2019.<p>4. Native interoperability in .net requires JIT as well, to generate things like call sites and runtime thunks (function pointers to restore CLR context). Not only that wastes more resources but also that not all P&#x2F;Invoke calls can be AOT compiled.</div><br/><div id="35926223" class="c"><input type="checkbox" id="c-35926223" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35924379">root</a><span>|</span><a href="#35925596">parent</a><span>|</span><a href="#35924531">next</a><span>|</span><label class="collapse" for="c-35926223">[-]</label><label class="expand" for="c-35926223">[3 more]</label></div><br/><div class="children"><div class="content">- Singularity<p>- Midori<p>- Oberon<p>- Mesa&#x2F;Cedar<p>- Topaz<p>It is a matter of actually wanting to make it happen, or giving up to the voices that think otherwise.</div><br/><div id="35926607" class="c"><input type="checkbox" id="c-35926607" checked=""/><div class="controls bullet"><span class="by">omnicognate</span><span>|</span><a href="#35924379">root</a><span>|</span><a href="#35926223">parent</a><span>|</span><a href="#35924531">next</a><span>|</span><label class="collapse" for="c-35926607">[-]</label><label class="expand" for="c-35926607">[2 more]</label></div><br/><div class="children"><div class="content">That list just shows people have been experimenting with such things for decades, including in a major push with Midori: over 100 devs across Microsoft <i>and</i> Microsoft Research, and while things have been learned and fed into the development of runtimes and operating systems it hasn&#x27;t changed the fact that all the major OS kernels are written in non-memory-safe languages. Rust, on the other hand, is starting to directly impact these kernels.<p>Joe Duffy himself said with Midori they &quot;started with C# and .NET [but] were forced to radically depart in the name of security, reliability, and performance&quot; and that at one point they had 11 different garbage collectors. The jury is still out (and has been deliberating for an awfully long time) on whether you can build or even contribute to a successful, mainstream, general-purpose OS kernel in a garbage-collected language but a distinctive selling point of Rust is that you can start adding memory safety without having to. And the fact that this is actually starting to happen to more than one such kernel while Rust is still a fairly new language could be interpreted as evidence that maybe, just maybe, the GC really was the problem all along.</div><br/><div id="35926713" class="c"><input type="checkbox" id="c-35926713" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35924379">root</a><span>|</span><a href="#35926607">parent</a><span>|</span><a href="#35924531">next</a><span>|</span><label class="collapse" for="c-35926713">[-]</label><label class="expand" for="c-35926713">[1 more]</label></div><br/><div class="children"><div class="content">Joe Duffy also said at his Rustconf keynot that even with Midori running in front of their eyes, many on Windows kernel developer team dismissed it as impossible.<p>Maybe, just maybe, the problem ist technical, rather human, and that can only be tackled one funeral at a time.</div><br/></div></div></div></div></div></div></div></div><div id="35924531" class="c"><input type="checkbox" id="c-35924531" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#35924379">root</a><span>|</span><a href="#35924472">parent</a><span>|</span><a href="#35925596">prev</a><span>|</span><a href="#35924566">next</a><span>|</span><label class="collapse" for="c-35924531">[-]</label><label class="expand" for="c-35924531">[4 more]</label></div><br/><div class="children"><div class="content">Still requires a substantial runtime.</div><br/><div id="35926234" class="c"><input type="checkbox" id="c-35926234" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35924379">root</a><span>|</span><a href="#35924531">parent</a><span>|</span><a href="#35924566">next</a><span>|</span><label class="collapse" for="c-35926234">[-]</label><label class="expand" for="c-35926234">[3 more]</label></div><br/><div class="children"><div class="content">Which in many cases has already been proven by making it part of the kernel, even if Xerox, DEC&#x2F;Olivetti, ETHZ, MSR projects weren&#x27;t made available to wider audiences.<p>One can do a Google, and push it no matter what, or give up and take the adoption path that is easier to bring the safety luddites along for the ride.</div><br/><div id="35926561" class="c"><input type="checkbox" id="c-35926561" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#35924379">root</a><span>|</span><a href="#35926234">parent</a><span>|</span><a href="#35924566">next</a><span>|</span><label class="collapse" for="c-35926561">[-]</label><label class="expand" for="c-35926561">[2 more]</label></div><br/><div class="children"><div class="content">I don’t fundamentally oppose such a thing, but I assume doing so would require very careful effort. It’s much harder than integrating Rust.</div><br/><div id="35926756" class="c"><input type="checkbox" id="c-35926756" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35924379">root</a><span>|</span><a href="#35926561">parent</a><span>|</span><a href="#35924566">next</a><span>|</span><label class="collapse" for="c-35926756">[-]</label><label class="expand" for="c-35926756">[1 more]</label></div><br/><div class="children"><div class="content">For me, Rust is a nicer Ada like effort, a kind of compromise.<p>We can wait the usual progress rate of one funeral at a time until a new generation buys into fully managed OS, or another Google&#x2F;Apple big spender forces them into developers no matter what, which most likely I will not live through.<p>So we&#x27;re left with the compromise of allowing only userspace for managed languages, while adopting something like Rust for the &quot;only over my dead body folks&quot; anti any form of automatic memory management languages.<p>Given that even the success stories of bare metal deployments of managed runtimes doesn&#x27;t change their minds anyway.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="35926418" class="c"><input type="checkbox" id="c-35926418" checked=""/><div class="controls bullet"><span class="by">StressedDev</span><span>|</span><a href="#35924379">parent</a><span>|</span><a href="#35924397">prev</a><span>|</span><a href="#35924787">next</a><span>|</span><label class="collapse" for="c-35926418">[-]</label><label class="expand" for="c-35926418">[1 more]</label></div><br/><div class="children"><div class="content">Microsoft never tried to rewrite Windows in C# during the Vista project.  I know this because I worked on Vista and my team wrote code in C++.<p>Vista did include some new C# APIs and Frameworks.  The best ones were Windows Presentation Foundation and PowerShell (it uses a lot of .NET technologies).<p>Vista took a long time for a lot of reasons.  I do not know all of them but my observation was there were a few basic problems:<p>1. Teams were allowed to check in buggy code.  This led Vista to be unstable while it was being developed.  Note the Kernel code was usually very good.  The shell was frequently difficult to use because of the bugs and because of poor performance.<p>Note that when it shipped, it worked much better than it did during development.  I remember being shocked at how well it worked.  I also remember going back to Windows XP and realizing I actually liked Vista better (it had a better user interface, and I liked the improved Windows Update app).<p>2. Very poor project management.  Basically, no one knew what needed to be done or how long it would take.<p>3. A lot of overly ambitious projects and features.  Some teams really tried to do revolutionary things.  Sometimes they succeeded (The Windows Display Driver Model is an example of this).  Often, they failed (Media Foundation is a great example of a mediocre API which came out of Vista).<p>4. Some teams took dependencies on immature APIs or frameworks.  The problem was the framework and the applications using it were being developed at the same time.  This led to a lot of reworked because applications kept on having to be updated because their dependencies changed or were cancelled.<p>5. Poor leadership - Will Poole led the Window Client team (AKA the desktop version of Windows).  Wille Poole previously led the Windows Media player team.  My impression was he valued political skill, politics and empire building over competence and technical excellence.<p>After Windows Vista shipped, he was &quot;promoted&quot; to working on Windows for Emerging Markets.  After that, he &quot;managed&quot; his administrative assistant.  He then &quot;retired&quot;.<p>I am sure I missed a lot of things and I certainly do not know everything because I worked on a small part of a huge project.  Windows had thousands of software engineers, program managers, testers and managers and they worked on a lot of different things.</div><br/></div></div><div id="35924787" class="c"><input type="checkbox" id="c-35924787" checked=""/><div class="controls bullet"><span class="by">nitinreddy88</span><span>|</span><a href="#35924379">parent</a><span>|</span><a href="#35926418">prev</a><span>|</span><a href="#35924412">next</a><span>|</span><label class="collapse" for="c-35924787">[-]</label><label class="expand" for="c-35924787">[2 more]</label></div><br/><div class="children"><div class="content">You should read about: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Midori_(operating_system)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Midori_(operating_system)</a><p>Tested and Failed. There are lot of interesting learnings and blogposts from this project and lot of them are actually landed in different products of Microsoft</div><br/><div id="35926310" class="c"><input type="checkbox" id="c-35926310" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35924379">root</a><span>|</span><a href="#35924787">parent</a><span>|</span><a href="#35924412">next</a><span>|</span><label class="collapse" for="c-35926310">[-]</label><label class="expand" for="c-35926310">[1 more]</label></div><br/><div class="children"><div class="content">Tested, and successfully run the Asian Bing network nodes during its lifetime.<p>If anything, it failed at the Windows business unit politics.<p>Unfortunely it lacked the kind of management that has pushed Java no matter what on Android, or either Swift or the high road on iOS.</div><br/></div></div></div></div><div id="35924412" class="c"><input type="checkbox" id="c-35924412" checked=""/><div class="controls bullet"><span class="by">kortilla</span><span>|</span><a href="#35924379">parent</a><span>|</span><a href="#35924787">prev</a><span>|</span><a href="#35924899">next</a><span>|</span><label class="collapse" for="c-35924412">[-]</label><label class="expand" for="c-35924412">[2 more]</label></div><br/><div class="children"><div class="content">C# is akin to Java, not Rust.</div><br/><div id="35926314" class="c"><input type="checkbox" id="c-35926314" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35924379">root</a><span>|</span><a href="#35924412">parent</a><span>|</span><a href="#35924899">next</a><span>|</span><label class="collapse" for="c-35926314">[-]</label><label class="expand" for="c-35926314">[1 more]</label></div><br/><div class="children"><div class="content">Good then, given that PTC and Aicas have been seling bare metal JVMs for the last 20 years, with soft real time deployments.</div><br/></div></div></div></div><div id="35924899" class="c"><input type="checkbox" id="c-35924899" checked=""/><div class="controls bullet"><span class="by">xedrac</span><span>|</span><a href="#35924379">parent</a><span>|</span><a href="#35924412">prev</a><span>|</span><a href="#35925868">next</a><span>|</span><label class="collapse" for="c-35924899">[-]</label><label class="expand" for="c-35924899">[2 more]</label></div><br/><div class="children"><div class="content">Maybe because it solves about 80% of the PITA security bugs that have beset Windows and other systems software since the dawn of software development?  C# is garbage collected with a big runtime.  It&#x27;s not even an option.</div><br/><div id="35926319" class="c"><input type="checkbox" id="c-35926319" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35924379">root</a><span>|</span><a href="#35924899">parent</a><span>|</span><a href="#35925868">next</a><span>|</span><label class="collapse" for="c-35926319">[-]</label><label class="expand" for="c-35926319">[1 more]</label></div><br/><div class="children"><div class="content">Xerox PARC would think otherwise, pity it lost to a PDP-11 OS.</div><br/></div></div></div></div><div id="35925868" class="c"><input type="checkbox" id="c-35925868" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#35924379">parent</a><span>|</span><a href="#35924899">prev</a><span>|</span><label class="collapse" for="c-35925868">[-]</label><label class="expand" for="c-35925868">[1 more]</label></div><br/><div class="children"><div class="content">Any large company has bored people who will sneak in random languages and frameworks.
The Windows network stack used to have an embedded Prolog interpreter, just because.
I&#x27;m willing to bet there&#x27;s a small Brainfuck codebase somewhere in the depths of Google.</div><br/></div></div></div></div></div></div></div></div></div></body></html>