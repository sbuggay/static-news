<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1690362058948" as="style"/><link rel="stylesheet" href="styles.css?v=1690362058948"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://utcc.utoronto.ca/~cks/space/blog/programming/SimpleLanguageEvalPattern">The &#x27;eval&#x27; pattern for interpreting simple languages</a> <span class="domain">(<a href="https://utcc.utoronto.ca">utcc.utoronto.ca</a>)</span></div><div class="subtext"><span>ingve</span> | <span>6 comments</span></div><br/><div><div id="36873982" class="c"><input type="checkbox" id="c-36873982" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#36873256">next</a><span>|</span><label class="collapse" for="c-36873982">[-]</label><label class="expand" for="c-36873982">[1 more]</label></div><br/><div class="children"><div class="content">I think the general concept described here is great, but I feel the description is lacking a bit. I find the description is imprecise and suggests some things are hard that I don&#x27;t think are difficult.<p>What is being described is a basic tree walking interpreter. If this is new to you, and you come from the OO world, there is an extended description in <a href="https:&#x2F;&#x2F;craftinginterpreters.com&#x2F;a-tree-walk-interpreter.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;craftinginterpreters.com&#x2F;a-tree-walk-interpreter.htm...</a><p>In the FP world this very very (very!) standard. A tree walking interpreter is one hop away from FP basics. The tools you need are tools that beginners learn in their first few weeks:<p>1. algebraic data types to represent the abstract syntax tree; and<p>2. structural recursion (usually implemented via pattern matching) to walk over the algebraic data type and interpret it.<p>Using generalized algebraic data types is a small extension if you don&#x27;t want to box your result types (which addresses the comment &quot;Python&#x27;s duck typing definitely helps make your life simpler, because otherwise you need to be careful about designing what all the Eval()s return.&quot; in the OP.)<p>I don&#x27;t understand why OP says conditionals or control flow are difficult. Those have been straightforward in the interpreters I have created.<p>Overall, I feel there are standard techniques for this kind of thing, in both the OO and FP worlds. In my experience the FP world is more precise with terminology, and I think this is beneficial.</div><br/></div></div><div id="36873256" class="c"><input type="checkbox" id="c-36873256" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#36873982">prev</a><span>|</span><label class="collapse" for="c-36873256">[-]</label><label class="expand" for="c-36873256">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Doing this requires or at least wants some form of polymorphic methods or functions, since you want to be able to call a node&#x27;s Eval() without having to know anything about the node.<p>Or you know, just use sum types. A polymorphic method as meant here is really not much different from the case analysis of a sum type.</div><br/><div id="36874718" class="c"><input type="checkbox" id="c-36874718" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#36873256">parent</a><span>|</span><a href="#36873274">next</a><span>|</span><label class="collapse" for="c-36874718">[-]</label><label class="expand" for="c-36874718">[2 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s not much different why do you need to say &quot;just use sum types&quot;?<p>The distinction is that a sum type is an enumeration of types. Therefore &quot;without having to know anything about the node&quot; is not met as a requirement, with sum types you do know the type of the node (&quot;one of: a, b, c, d&quot;).<p>Polymorphism allows an abstract relationship where you say &quot;I support protocol: a&quot; and then any type&#x2F;class can implement that protocol without prior knowledge of the implementation.</div><br/><div id="36874830" class="c"><input type="checkbox" id="c-36874830" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#36873256">root</a><span>|</span><a href="#36874718">parent</a><span>|</span><a href="#36873274">next</a><span>|</span><label class="collapse" for="c-36874830">[-]</label><label class="expand" for="c-36874830">[1 more]</label></div><br/><div class="children"><div class="content">Sum types + pattern matching (algebraic data types + structural recursion) achieves the same goal as what the author describes, but uses a different implementation technique.<p>In functional programming there is often talk of &quot;duality&quot;. Two things are dual if you can make an exact correspondence between them. In this case, these two implementation techniques are duals. The OO technique is known as &quot;codata&quot;, which, as you say, is all about having a uniform protocol to interact with. (In this case, the method &quot;eval&quot;.) The FP technique is just &quot;data&quot;, which is basically interchangeable with sum types or algebraic data types. (There are minor differences in meaning that are unimportant here.) We use recursion on data, and &quot;corecursion&quot; on codata. There is more in the papers &quot;Codata in Action&quot; [1] and &quot;Data-Codata Symmetry&quot; [2].<p>What this duality means is that you can have one mental model of what you are trying to achieve, and implement it in two different ways that have different tradeoffs. Since these two different implementations are duals you can mechanically (i.e. with a program) translate between the two. I find this a really powerful way to approach design.<p>(This post is just a sketch of the ideas and, unfortunately, probably not comprehensible unless you have a pretty good grounding in programming language theory. Explaining them properly would take more space and time than I have right now.)<p>[1]: <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;uploads&#x2F;prod&#x2F;202&#x2F;01&#x2F;CoDataInAction.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;uploads&#x2F;prod&#x2F;202&#x2F;01...</a>
[2]: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2211.13004" rel="nofollow noreferrer">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2211.13004</a></div><br/></div></div></div></div><div id="36873274" class="c"><input type="checkbox" id="c-36873274" checked=""/><div class="controls bullet"><span class="by">apgwoz</span><span>|</span><a href="#36873256">parent</a><span>|</span><a href="#36874718">prev</a><span>|</span><label class="collapse" for="c-36873274">[-]</label><label class="expand" for="c-36873274">[1 more]</label></div><br/><div class="children"><div class="content">If only all languages had sum types …</div><br/></div></div></div></div></div></div></div></div></div></body></html>