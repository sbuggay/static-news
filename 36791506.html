<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689843663954" as="style"/><link rel="stylesheet" href="styles.css?v=1689843663954"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://themer.dev/blog/the-single-most-important-factor-that-differentiates-front-end-frameworks">What dif­fer­enti­ates front-end frame­works</a> <span class="domain">(<a href="https://themer.dev">themer.dev</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>179 comments</span></div><br/><div><div id="36794865" class="c"><input type="checkbox" id="c-36794865" checked=""/><div class="controls bullet"><span class="by">aluminum96</span><span>|</span><a href="#36793385">next</a><span>|</span><label class="collapse" for="c-36794865">[-]</label><label class="expand" for="c-36794865">[12 more]</label></div><br/><div class="children"><div class="content">&gt; To overcome the shortcomings of the default change detection paradigm, the Angular team is working on a new approach called Signals. Conceptually, signals are similar to Svelte stores (which we’ll get to later), and fundamentally, they solve the change detection problem the same way as React; the framework is taking control over the application’s state so that changes can be easily monitored and re-renders can be as efficient as possible.<p>I <i>radically disagree</i> with this statement. Angular Signals (and signals in general, as in SolidJS) could not be more different from React&#x27;s change detection model, and they are not particularly similar to Svelte stores either.<p>In React, your component function is a render function, which reruns. React diffs the state object when `setState` is called, determining which part of the DOM to update.<p>Signals-based solutions are generally much more fine-grained: the framework knows which portion of the DOM was affected by the signal, and does not need to diff the entire state object. This &quot;surgical&quot; approach requires more explicit state management on the part of the developer, through the use of Signals to wrap the application state. However, DOM nodes can be updated without doing a large, expensive diff. (As a corollary, the component function is typically a <i>create</i> function, not a <i>render</i> function.)<p>The developer experience is quite different as a result.</div><br/><div id="36796176" class="c"><input type="checkbox" id="c-36796176" checked=""/><div class="controls bullet"><span class="by">nwienert</span><span>|</span><a href="#36794865">parent</a><span>|</span><a href="#36796287">next</a><span>|</span><label class="collapse" for="c-36796176">[-]</label><label class="expand" for="c-36796176">[3 more]</label></div><br/><div class="children"><div class="content">Signals have their own shortcomings as well. Once you leave the &quot;re-run the render function on state change&quot; you suddenly are dealing with implicit dependencies, stale closures, cyclical updating, and all sorts of weirdness in debugging things, figuring out what triggered what, etc.<p>Signals as a concept existed well before React and I think part of the genius of React is actually not using them. In a way a signal is just a very simple version of RxJS that Angular is moving away from, with a lot of the same downsides, just without all the pipe&#x2F;abstraction mess.</div><br/><div id="36796536" class="c"><input type="checkbox" id="c-36796536" checked=""/><div class="controls bullet"><span class="by">svieira</span><span>|</span><a href="#36794865">root</a><span>|</span><a href="#36796176">parent</a><span>|</span><a href="#36796287">next</a><span>|</span><label class="collapse" for="c-36796536">[-]</label><label class="expand" for="c-36796536">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I think part of the genius of React is actually not using [signals]<p>Except that with the introduction of hooks (aka &quot;OCaml 5.0 effects, but in JS, as a UI framework&quot;) you get some of the same interesting issues cropping up in React codebases as well, just spelled differently (stale closures, implicit dependencies, weird debugging issues)</div><br/><div id="36796679" class="c"><input type="checkbox" id="c-36796679" checked=""/><div class="controls bullet"><span class="by">nwienert</span><span>|</span><a href="#36794865">root</a><span>|</span><a href="#36796536">parent</a><span>|</span><a href="#36796287">next</a><span>|</span><label class="collapse" for="c-36796679">[-]</label><label class="expand" for="c-36796679">[1 more]</label></div><br/><div class="children"><div class="content">Well you get <i>explicit</i> dependencies which have ups and downs, but closures do become an issue. That said, I find hooks less magical and less prone to cycles, especially as you&#x27;re staying with a top down data flow generally.</div><br/></div></div></div></div></div></div><div id="36796287" class="c"><input type="checkbox" id="c-36796287" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#36794865">parent</a><span>|</span><a href="#36796176">prev</a><span>|</span><a href="#36795049">next</a><span>|</span><label class="collapse" for="c-36796287">[-]</label><label class="expand" for="c-36796287">[3 more]</label></div><br/><div class="children"><div class="content">For a little while it looked like mobx was going to displace Redux in React-world, and if that had happened it would have brought this to React without having to change React itself.</div><br/><div id="36797623" class="c"><input type="checkbox" id="c-36797623" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#36794865">root</a><span>|</span><a href="#36796287">parent</a><span>|</span><a href="#36795049">next</a><span>|</span><label class="collapse" for="c-36797623">[-]</label><label class="expand" for="c-36797623">[2 more]</label></div><br/><div class="children"><div class="content">Mobx had one thing going for it -- it let you update your neighbor easily. But now Reacts useExternalStore achieves that cleanly with about 100 lines to wrap it in a cute API.<p>The proxy stuff I don&#x27;t trust. Burned me once, never again.</div><br/><div id="36798111" class="c"><input type="checkbox" id="c-36798111" checked=""/><div class="controls bullet"><span class="by">surrTurr</span><span>|</span><a href="#36794865">root</a><span>|</span><a href="#36797623">parent</a><span>|</span><a href="#36795049">next</a><span>|</span><label class="collapse" for="c-36798111">[-]</label><label class="expand" for="c-36798111">[1 more]</label></div><br/><div class="children"><div class="content">The proxy stuff always works great when fiddling around with it in a small project. However, my experience has been the same. Whenever a project using proxies leaves the playground phase, all sorts of nasty bugs and performance issues arise.</div><br/></div></div></div></div></div></div><div id="36795049" class="c"><input type="checkbox" id="c-36795049" checked=""/><div class="controls bullet"><span class="by">genuine_smiles</span><span>|</span><a href="#36794865">parent</a><span>|</span><a href="#36796287">prev</a><span>|</span><a href="#36796866">next</a><span>|</span><label class="collapse" for="c-36795049">[-]</label><label class="expand" for="c-36795049">[2 more]</label></div><br/><div class="children"><div class="content">&gt; and they are not particularly similar to Svelte stores either<p>How does Svelte differ? I’m somewhat familiar with SolidJS, and had always assumed Svelte was somewhat similar.</div><br/><div id="36795950" class="c"><input type="checkbox" id="c-36795950" checked=""/><div class="controls bullet"><span class="by">plopz</span><span>|</span><a href="#36794865">root</a><span>|</span><a href="#36795049">parent</a><span>|</span><a href="#36796866">next</a><span>|</span><label class="collapse" for="c-36795950">[-]</label><label class="expand" for="c-36795950">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not super familiar with svelte, but my understanding was that it solved it at compile time rather than run time.</div><br/></div></div></div></div><div id="36795223" class="c"><input type="checkbox" id="c-36795223" checked=""/><div class="controls bullet"><span class="by">luketheobscure</span><span>|</span><a href="#36794865">parent</a><span>|</span><a href="#36796866">prev</a><span>|</span><a href="#36793385">next</a><span>|</span><label class="collapse" for="c-36795223">[-]</label><label class="expand" for="c-36795223">[2 more]</label></div><br/><div class="children"><div class="content">There are a large number of very incorrect statements in this article.<p>&gt; True to its de-facto tagline, change detection in React is “just JavaScript.”<p>Then in the example, the author updates a variable with `setCount(count - 1)`. That&#x27;s not &quot;just JavaScript&quot;. Just JavaScript would be `count = count + 1`.</div><br/><div id="36795524" class="c"><input type="checkbox" id="c-36795524" checked=""/><div class="controls bullet"><span class="by">gyanreyer</span><span>|</span><a href="#36794865">root</a><span>|</span><a href="#36795223">parent</a><span>|</span><a href="#36793385">next</a><span>|</span><label class="collapse" for="c-36795524">[-]</label><label class="expand" for="c-36795524">[1 more]</label></div><br/><div class="children"><div class="content">Well, JavaScript has no simple way to react to an assignment like count = count + 1 without introducing some magic between the code you write and the final code that runs in the browser. Svelte is only able to achieve that experience because it has a compilation step, but React does not; hence why setState() is necessary and why people argue it&#x27;s more &quot;just JavaScript&quot; because the code you write is pretty much the final code that runs (aside from the transpilation necessary to convert JSX syntax into JS, but this doesn&#x27;t alter the way that anything works).<p>This isn&#x27;t to make any kind of judgement on either approach though, I personally really enjoy the DX that Svelte offers.</div><br/></div></div></div></div></div></div><div id="36793385" class="c"><input type="checkbox" id="c-36793385" checked=""/><div class="controls bullet"><span class="by">emorning3</span><span>|</span><a href="#36794865">prev</a><span>|</span><a href="#36793678">next</a><span>|</span><label class="collapse" for="c-36793385">[-]</label><label class="expand" for="c-36793385">[49 more]</label></div><br/><div class="children"><div class="content">Totally disagree with this.<p>Change detection is nothing but a hack to get around the fact that interacting directly with the browser DOM is very slow and blinky.<p>Imagine a world where interacting directly with the browser DOM didn&#x27;t suck, then none of these libraries would exist.<p>The crux of the problem is that the browser immediately reflects changes to the DOM to the screen.
And when you make a bunch of changes to the DOM you immediately see a bunch of changes happen, with portions of the screen being blanked out, and layout changes happening, and a whole bunch of other nasty stuff happening <i>immediately</i>, which all sucks.
And updating a physical screen is <i>slow</i> too, double sucky.
Change detection is a technique for minimizing updates to the DOM to avoid the suckiness.<p>I implemented word processors, and I&#x27;ve used a technique called &#x27;double buffering&#x27; to rerender complete pages off-screen, fast.  And then update the screen smoothly. 
If we used a proper word processor engine to display our UIs instead of a browser engine then we&#x27;d have no need for React etc...
After decades, Chrome finally has a rational equivalent to this technique called the View Transitions API.<p>My hope is that the days of doing change detection are numbered and we can finally leave all this change detection crap behind us.</div><br/><div id="36793877" class="c"><input type="checkbox" id="c-36793877" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#36793385">parent</a><span>|</span><a href="#36796628">next</a><span>|</span><label class="collapse" for="c-36793877">[-]</label><label class="expand" for="c-36793877">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the fact that interacting directly with the browser DOM is very slow and blinky.<p>This is not really true, or at least hasn&#x27;t been for many years.<p>Change detection&#x27;s primary purpose is to let other code know when something has changed, and what changed. You could theoretically re-render all your DOM based on that information, and in many cases that works much better than people expect. But the DOM is stateful, and truly large trees of 1000s of nodes are too slow to update, so frameworks try to also do minimal DOM updates.<p>&gt; The crux of the problem is that the browser immediately reflects changes to the DOM to the screen. And when you make a bunch of changes to the DOM you immediately see a bunch of changes happen, with portions of the screen being blanked out, and layout changes happening, and a whole bunch of other nasty stuff happening immediately, which all sucks<p>This is also not really true. The browser doesn&#x27;t update the screen until an animation frame. Anything you do synchronously is <i>not</i> rendered to the screen until code yields to the event loop. Even many async things, done on the microtask queue, block the next animation frame giving us visually atomic updates.<p>Lit, for instance, uses this to get async, batching rendering without unintended partial renders of the screen.</div><br/></div></div><div id="36796628" class="c"><input type="checkbox" id="c-36796628" checked=""/><div class="controls bullet"><span class="by">diegof79</span><span>|</span><a href="#36793385">parent</a><span>|</span><a href="#36793877">prev</a><span>|</span><a href="#36793592">next</a><span>|</span><label class="collapse" for="c-36796628">[-]</label><label class="expand" for="c-36796628">[1 more]</label></div><br/><div class="children"><div class="content">Engineers developing rendering engines for browsers definitely know what double buffering is. However, the accumulation of peculiar layout rules, support for CSS, and many other things  make things hard. One of the major design flaws of the DOM was allowing unrestricted mutability. If DOM mutations were transactional by default, it would offer better control over layout reflows.<p>Change detection remains a common UI issue, even in native UIs. While rerendering everything on each UI loop is possible, as complexity increases, optimizations involve detecting changes. Smalltalk introduced MVC to identify changes and update the UI. Java Swing and Qt also adopted similar mechanisms with different names (observers, signals, and slots). Apple&#x27;s Cocoa employs a variant of MVC as well. Change detection has historically been a common problem even in Win APIs.</div><br/></div></div><div id="36793592" class="c"><input type="checkbox" id="c-36793592" checked=""/><div class="controls bullet"><span class="by">robear</span><span>|</span><a href="#36793385">parent</a><span>|</span><a href="#36796628">prev</a><span>|</span><a href="#36793656">next</a><span>|</span><label class="collapse" for="c-36793592">[-]</label><label class="expand" for="c-36793592">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see it that way.  The main need for change detection in my opinion is to remove the need to update parts of the DOM in an imperative manner.  It is fine to do that for smaller projects but when a project gets large, it becomes difficult to reason about the myriad of changes happening without a system to handle that.  I find any one of the examples in the linked post way more easy to reason about than manual DOM updates.</div><br/><div id="36796157" class="c"><input type="checkbox" id="c-36796157" checked=""/><div class="controls bullet"><span class="by">apatheticonion</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36793592">parent</a><span>|</span><a href="#36794076">next</a><span>|</span><label class="collapse" for="c-36796157">[-]</label><label class="expand" for="c-36796157">[2 more]</label></div><br/><div class="children"><div class="content">Having worked extensively with the major frameworks in multiple orgs, I have largely found that templates synced with state via change detection (like Angular) result in more readable&#x2F;maintainable projects.<p>While I personally like React, it&#x27;s pretty tricky to use in reality. I have found that its idiosyncrasies make it less resilient to suboptimal contributions from engineers that are still early in their careers.<p>Broadly, the projects I have entered using React tend to be pretty wild, messy and unreliable.<p>There is cross over though, Angular projects using Redux (ngrx) are horrific. The criticism of Angular for me is the lack of control you have over the compiler, dependency versions and testing strategy.<p>Svelte and Vue are both interesting, but they use custom file formats (.vue, .svelte) which can add an extra layer of unreliability to projects using TypeScript and testing frameworks.<p>The advantage of Angular is that it&#x27;s an ergonomic abstraction that allows optimisations to occur at the engine level. It&#x27;s more like an ORM, where React is more like writing SQL queries directly.</div><br/><div id="36797008" class="c"><input type="checkbox" id="c-36797008" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36796157">parent</a><span>|</span><a href="#36794076">next</a><span>|</span><label class="collapse" for="c-36797008">[-]</label><label class="expand" for="c-36797008">[1 more]</label></div><br/><div class="children"><div class="content">Have you tried the model view update pattern?<p>If you haven&#x27;t I recommend having a look. If found it amazing for maintainability.<p>You have to be carful to structure everything well. If not you blow up the number of messages in one file. But once you get past that it&#x27;s really amazing.</div><br/></div></div></div></div><div id="36794076" class="c"><input type="checkbox" id="c-36794076" checked=""/><div class="controls bullet"><span class="by">emorning3</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36793592">parent</a><span>|</span><a href="#36796157">prev</a><span>|</span><a href="#36793656">next</a><span>|</span><label class="collapse" for="c-36794076">[-]</label><label class="expand" for="c-36794076">[2 more]</label></div><br/><div class="children"><div class="content">I agree with you that going back to the JQuery days of unmaintainable imperative code would not be a good thing.<p>But with JQuery I was able to create adaptive UIs by applying &#x27;transforms&#x27; to the DOM, I really miss that.  
Think of the way that &#x27;tag helpers&#x27; can apply cross-cutting transforms to Razor Page applications, I used to do things like that with JQuery.<p>React et al cuts me off from <i>both</i> the browser DOM <i>and</i> it&#x27;s own virtual DOM, so this I can no longer do this.
I have to do everything the React way.  
Developing with React is far less powerful than JQuery.
I still find modern frameworks to be a kind of straight-jacket.
I hope to have my transforms back in a rational way someday.</div><br/><div id="36795383" class="c"><input type="checkbox" id="c-36795383" checked=""/><div class="controls bullet"><span class="by">mr_toad</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36794076">parent</a><span>|</span><a href="#36793656">next</a><span>|</span><label class="collapse" for="c-36795383">[-]</label><label class="expand" for="c-36795383">[1 more]</label></div><br/><div class="children"><div class="content">React discourages direct DOM access, but it’s still possible.<p><a href="https:&#x2F;&#x2F;react.dev&#x2F;learn&#x2F;escape-hatches" rel="nofollow noreferrer">https:&#x2F;&#x2F;react.dev&#x2F;learn&#x2F;escape-hatches</a></div><br/></div></div></div></div></div></div><div id="36793656" class="c"><input type="checkbox" id="c-36793656" checked=""/><div class="controls bullet"><span class="by">cloogshicer</span><span>|</span><a href="#36793385">parent</a><span>|</span><a href="#36793592">prev</a><span>|</span><a href="#36798174">next</a><span>|</span><label class="collapse" for="c-36793656">[-]</label><label class="expand" for="c-36793656">[13 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know... even if the DOM was super fast, would it really be ergonomic to keep all your state in the DOM tree and only work with that?<p>I kinda doubt it.<p>So then you&#x27;d have to store some state in JS, and some in the DOM, and again you get a syncing problem, since you lost your single source of truth.<p>Or did I misunderstand your comment?</div><br/><div id="36794761" class="c"><input type="checkbox" id="c-36794761" checked=""/><div class="controls bullet"><span class="by">emorning3</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36793656">parent</a><span>|</span><a href="#36793835">next</a><span>|</span><label class="collapse" for="c-36794761">[-]</label><label class="expand" for="c-36794761">[5 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; Or did I misunderstand your comment?<p>Well, I can see now that while I expressed my dislike for change detection I didn&#x27;t paint a good picture of why I think we&#x27;d be better off without it :-).<p>While I appreciate React&#x27;s declarative programming style I dislike the fact that React (and all the change-detecting alternatives) force me to interact with the DOM through their APIs.<p>JQuery allowed me to do whatever the hell I wanted to the DOM, but the resulting screens updates were very ugly.  
And yes, JQuery resulted in ugly and unmaintainable code but that&#x27;s not on JQuery, there are rational ways to apply transforms to a DOM.<p>I want to &quot;do whatever the hell I want&quot; to the DOM because I want to apply cross-cutting, adaptive transforms to my application, like I could with JQuery.  
And I think that we&#x27;d all be better off for it.  
In the transition to React-like frameworks we have lost that ability<p>The view transition API lets me start a transition, do whatever the hell I want to the DOM, and then update the browser smoothly.<p>So what I&#x27;m imagining is a component-oriented framework like React that doesn&#x27;t lock me into a <i>component-only</i> API.  A framework that, when rendering occurs, starts a transition, let&#x27;s me do whatever the hell I want to the DOM, and then updates the browser smoothly without doing change detection.<p>And the reason I would like that is because, while React&#x27;s declarative, component-oriented development approach is nice and all, it&#x27;s also very restrictive.<p>Reacts prevents me from directly traversing and mutating the DOM, and it&#x27;s own virtual DOM, because if it did then it can&#x27;t efficiently do change detection.<p>If we replace change detection with transitions then we can &quot;do whatever the hell we want&quot; (hopefully not in an unmaintainable JQuery way) and still have smoothly updating displays.  
We&#x27;d have a framework with all the benefits of React and without the restrictions.<p>Anyway, that&#x27;s my best shot at explaining myself :-).</div><br/><div id="36795454" class="c"><input type="checkbox" id="c-36795454" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36794761">parent</a><span>|</span><a href="#36795044">prev</a><span>|</span><a href="#36793835">next</a><span>|</span><label class="collapse" for="c-36795454">[-]</label><label class="expand" for="c-36795454">[3 more]</label></div><br/><div class="children"><div class="content">I‘ve written a UI a few months ago with only lithtml and direct DOM manipulation and it worked pretty well.<p>I needed to do calculations and reading bounding boxes from the DOM initially and on resize. Basically a hack to get around CSS limitations.<p>It was crucial that this is fast enough to avoid flickering.<p>I wouldn’t have attempted this with react. I think it would still be possible with useEffect, but I tried the most lightweight and fast by default approach that was feasible.<p>Have a look at lithtml.</div><br/><div id="36796576" class="c"><input type="checkbox" id="c-36796576" checked=""/><div class="controls bullet"><span class="by">shaunxcode</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36795454">parent</a><span>|</span><a href="#36793835">next</a><span>|</span><label class="collapse" for="c-36796576">[-]</label><label class="expand" for="c-36796576">[2 more]</label></div><br/><div class="children"><div class="content">in the cljs&#x2F;reagent world anytime you need to do direct dom stuff you just use a ref - that must me the same for react proper?</div><br/><div id="36798064" class="c"><input type="checkbox" id="c-36798064" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36796576">parent</a><span>|</span><a href="#36793835">next</a><span>|</span><label class="collapse" for="c-36798064">[-]</label><label class="expand" for="c-36798064">[1 more]</label></div><br/><div class="children"><div class="content">You can pretty much do anything with a combination of refs, events and useEffect. It’s often fiddly and cumbersome though.<p>Aside:<p>That’s why I‘ve been gravitating towards approaches that have much simpler execution models.<p>You can still do declarative and functional. But you have more control when needed, create _much_ smaller bundles, have fewer dependencies, better default performance, allocate less garbage and you can reason about your code in more fundamental ways.<p>In cljs this would mean to not use a react wrapper.<p>However I personally try to avoid using any deps for frontend, and that includes cljs. Any dep needs a justification IMO.<p>That justification is often not good enough, since I’m mostly writing „interactive documents with some fancy parts“.<p>If you’re writing something like nextjournal, roam, data rabbit or similar then it’s a different story.</div><br/></div></div></div></div></div></div></div></div><div id="36793835" class="c"><input type="checkbox" id="c-36793835" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36793656">parent</a><span>|</span><a href="#36794761">prev</a><span>|</span><a href="#36798174">next</a><span>|</span><label class="collapse" for="c-36793835">[-]</label><label class="expand" for="c-36793835">[7 more]</label></div><br/><div class="children"><div class="content">At peak jquery, I argued successfully for storing  the metadata on DOM, because then you have a system of record, upon which you can build a straightforward source of truth. React does a ton of work to solve that architectural puzzle another way.<p>The thing I have run into over and over again is that when we try to pretend the system is Y when it is in fact X, inevitably the impedance mismatch results in 1) bugs that should be easy to reason about but are difficult to fix, and 2) a form of pulling the ladder up behind you.<p>If I want to continue to work on interesting things I have to be able to carve out chunks of my code to gift to #3 on the bus number list, so I have the bandwidth to double down on some other topic or expand into another.<p>I know which side my bread is buttered on. Many don’t. Which is why I have a more consistent supply of mentees than many of my peers.</div><br/><div id="36794004" class="c"><input type="checkbox" id="c-36794004" checked=""/><div class="controls bullet"><span class="by">stickfigure</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36793835">parent</a><span>|</span><a href="#36793982">next</a><span>|</span><label class="collapse" for="c-36794004">[-]</label><label class="expand" for="c-36794004">[4 more]</label></div><br/><div class="children"><div class="content">Data comes from the server as JSON. Data comes from the user as DOM events and changes. There&#x27;s always going to be an impedance mismatch.<p>The DOM API sucks, so React et al went all in with state-as-objects. IMO it was the right call.</div><br/><div id="36794582" class="c"><input type="checkbox" id="c-36794582" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36794004">parent</a><span>|</span><a href="#36793982">next</a><span>|</span><label class="collapse" for="c-36794582">[-]</label><label class="expand" for="c-36794582">[3 more]</label></div><br/><div class="children"><div class="content">I just don&#x27;t think DOM-&gt;JSON-&gt;server-&gt;microservice-&gt;DB-&gt;microservice-&gt;server-&gt;JSON-&gt;DOM is sustainable long term. It&#x27;s had a good run, but it&#x27;s a big part of the reason I&#x27;m looking at Phoenix for a personal project.  React is predicated upon solving the wrong problem.<p>Talk about impedance mismatches.</div><br/><div id="36795437" class="c"><input type="checkbox" id="c-36795437" checked=""/><div class="controls bullet"><span class="by">robertoandred</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36794582">parent</a><span>|</span><a href="#36793982">next</a><span>|</span><label class="collapse" for="c-36795437">[-]</label><label class="expand" for="c-36795437">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure switching to DOM-&gt;JSON-&gt;server-&gt;microservice-&gt;DB-&gt;microservice-&gt;server-&gt;DOM will make much of a difference.</div><br/><div id="36795714" class="c"><input type="checkbox" id="c-36795714" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36795437">parent</a><span>|</span><a href="#36793982">next</a><span>|</span><label class="collapse" for="c-36795714">[-]</label><label class="expand" for="c-36795714">[1 more]</label></div><br/><div class="children"><div class="content">Complexity is usually quadratic or factorial. Only a tiny number of systems are logarithmic. 20% reduction in parts can often be a 40-70% reduction in cognitive load.<p>But the funny thing with fractions is that if go above a threshold and come back from the brink, the path back is a smaller number than the path out. So if you go from 8 to 10 steps that&#x27;s 25% worse and if you undo that bad decision you are getting 20% better.  So you want to be careful to compare sustainable to unsustainable and not the other way around, if you follow me.</div><br/></div></div></div></div></div></div></div></div><div id="36793982" class="c"><input type="checkbox" id="c-36793982" checked=""/><div class="controls bullet"><span class="by">hombre_fatal</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36793835">parent</a><span>|</span><a href="#36794004">prev</a><span>|</span><a href="#36798174">next</a><span>|</span><label class="collapse" for="c-36793982">[-]</label><label class="expand" for="c-36793982">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I argued successfully for storing the metadata on DOM<p>Who did you convince?</div><br/><div id="36794738" class="c"><input type="checkbox" id="c-36794738" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36793982">parent</a><span>|</span><a href="#36798174">next</a><span>|</span><label class="collapse" for="c-36794738">[-]</label><label class="expand" for="c-36794738">[1 more]</label></div><br/><div class="children"><div class="content">A team working on an AJAX webapp that typically was meant to comfortable manage around 1000 blocks of state at a time. Somewhere on the order of 6-10 pieces of data per block (Which we just changed as a unit of work because 1000 was already hard enough). And when you&#x27;re dealing with 10^3 you need a couple of different ways to visualize the same data or you&#x27;re getting nowhere, so we had one or two other views that dealt with different levels of detail.</div><br/></div></div></div></div></div></div></div></div><div id="36798174" class="c"><input type="checkbox" id="c-36798174" checked=""/><div class="controls bullet"><span class="by">lozenge</span><span>|</span><a href="#36793385">parent</a><span>|</span><a href="#36793656">prev</a><span>|</span><a href="#36793663">next</a><span>|</span><label class="collapse" for="c-36798174">[-]</label><label class="expand" for="c-36798174">[1 more]</label></div><br/><div class="children"><div class="content">Any changes to the DOM aren&#x27;t reflected on screen until your code stops running. If you see a partial update it&#x27;s because your code is &quot;await&quot;ing something.</div><br/></div></div><div id="36793663" class="c"><input type="checkbox" id="c-36793663" checked=""/><div class="controls bullet"><span class="by">lincon127</span><span>|</span><a href="#36793385">parent</a><span>|</span><a href="#36798174">prev</a><span>|</span><a href="#36793935">next</a><span>|</span><label class="collapse" for="c-36793663">[-]</label><label class="expand" for="c-36793663">[2 more]</label></div><br/><div class="children"><div class="content">So what are you disagreeing with? Are you disagreeing that change detection is what mostly diffentiates the front-end frameworks? If so, what is that important factor that differentiates them if not the mechanism that modifies when change is detected? Why do you have such a strong belief that this factor isn&#x27;t it?</div><br/><div id="36793899" class="c"><input type="checkbox" id="c-36793899" checked=""/><div class="controls bullet"><span class="by">travisjungroth</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36793663">parent</a><span>|</span><a href="#36793935">next</a><span>|</span><label class="collapse" for="c-36793899">[-]</label><label class="expand" for="c-36793899">[1 more]</label></div><br/><div class="children"><div class="content">They’re disagreeing with change detection being the most important part of a frontend framework by suggesting that the browser API change dramatically so that we fix the important problem of… change detection in frontend frameworks. Yeah it’s not the most consistent.</div><br/></div></div></div></div><div id="36793935" class="c"><input type="checkbox" id="c-36793935" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#36793385">parent</a><span>|</span><a href="#36793663">prev</a><span>|</span><a href="#36793522">next</a><span>|</span><label class="collapse" for="c-36793935">[-]</label><label class="expand" for="c-36793935">[2 more]</label></div><br/><div class="children"><div class="content">Change detection has nothing to do with the speed of DOM updates, it&#x27;s about directly encoding dataflow dependencies to avoid code duplication and redundant UI updates. You could paper over the lack of dataflow updates by just updating the whole screen every time, but you still need to preserve various state, like scroll positions, highlighted text, etc. which still means only some state changes and other state does not.</div><br/><div id="36794782" class="c"><input type="checkbox" id="c-36794782" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36793935">parent</a><span>|</span><a href="#36793522">next</a><span>|</span><label class="collapse" for="c-36794782">[-]</label><label class="expand" for="c-36794782">[1 more]</label></div><br/><div class="children"><div class="content">Redundant UI updates could be okay if done quickly and cheaply. Games refresh entire framebuffers 60 times a second, redrawing the entire world, and it works fine, because they do that efficiently, and flip entire pages so that you never see a half-draw.</div><br/></div></div></div></div><div id="36793522" class="c"><input type="checkbox" id="c-36793522" checked=""/><div class="controls bullet"><span class="by">boxed</span><span>|</span><a href="#36793385">parent</a><span>|</span><a href="#36793935">prev</a><span>|</span><a href="#36793568">next</a><span>|</span><label class="collapse" for="c-36793522">[-]</label><label class="expand" for="c-36793522">[10 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not nearly all there is to it. If the DOM was fast and you could control redraws, it would still be horrible.<p>A performant big pile of mud is still a big ball of mud.</div><br/><div id="36794746" class="c"><input type="checkbox" id="c-36794746" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36793522">parent</a><span>|</span><a href="#36794058">next</a><span>|</span><label class="collapse" for="c-36794746">[-]</label><label class="expand" for="c-36794746">[1 more]</label></div><br/><div class="children"><div class="content">&quot;A performant pile of mud&quot; is a description that fits many things that still stay afloat exactly because the performance allows them to. Consider C++ or x64 as examples.</div><br/></div></div><div id="36793644" class="c"><input type="checkbox" id="c-36793644" checked=""/><div class="controls bullet"><span class="by">crooked-v</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36793522">parent</a><span>|</span><a href="#36794058">prev</a><span>|</span><a href="#36793568">next</a><span>|</span><label class="collapse" for="c-36793644">[-]</label><label class="expand" for="c-36793644">[7 more]</label></div><br/><div class="children"><div class="content">For example, there&#x27;s the way it&#x27;s <i>still</i> impossible to pass data between native Web Components without stringifying it first.</div><br/><div id="36794003" class="c"><input type="checkbox" id="c-36794003" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36793644">parent</a><span>|</span><a href="#36794068">next</a><span>|</span><label class="collapse" for="c-36794003">[-]</label><label class="expand" for="c-36794003">[5 more]</label></div><br/><div class="children"><div class="content">This is an absolutely stunningly false and ignorant statement. I can&#x27;t believe it&#x27;s still being repeated.<p>Web components are objects and they have properties that can be set. The entire web components community - which includes the developers of apps like Photoshop, Reddit, Chrome, Firefox, and a lot more - passes properties down through trees of web components _all the time_.</div><br/><div id="36798022" class="c"><input type="checkbox" id="c-36798022" checked=""/><div class="controls bullet"><span class="by">ngc6677</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36794003">parent</a><span>|</span><a href="#36794786">next</a><span>|</span><label class="collapse" for="c-36798022">[-]</label><label class="expand" for="c-36798022">[1 more]</label></div><br/><div class="children"><div class="content">I reallly love web-components. They allow to encapsulate logic, and be re-used and composed with others. It starts feeling like unix in the browser, to me.<p>Maybe a bit verbose, but here is an example <a href="https:&#x2F;&#x2F;jsfiddle.net&#x2F;8kvucm9f&#x2F;5&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;jsfiddle.net&#x2F;8kvucm9f&#x2F;5&#x2F;</a> in the context of the blog post (and with my preferences of doing things; there are just many different ways of &quot;writing web components&quot;, and can adapt many use cases).<p>Also, by using their HTML attributes (id=&quot;&quot;, name=&quot;&quot;), it is possible to make really nice features with CSS.<p>Finally, they can offer a clear API (just like the &lt;img&#x2F;&gt; or &lt;video&#x2F;&gt; or &lt;input&#x2F;&gt; elements), to the users of these elements.<p>They can be inserted, to give &quot;markdown&quot; documents (or .org mode etc. if it is converted to HTML), JSX like features, by being &quot;just embedded HTML text&quot;.<p>It is super powerful, maybe feels a bit scary at first, but all problems seems to get solvable with clean patterns.</div><br/></div></div><div id="36794786" class="c"><input type="checkbox" id="c-36794786" checked=""/><div class="controls bullet"><span class="by">spion</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36794003">parent</a><span>|</span><a href="#36798022">prev</a><span>|</span><a href="#36794068">next</a><span>|</span><label class="collapse" for="c-36794786">[-]</label><label class="expand" for="c-36794786">[3 more]</label></div><br/><div class="children"><div class="content">There is a subtle grain of truth to it - the implied &quot;declaratively&quot; here. React has went south quite a bit, but the basic idea of JSX where HTML becomes a language with first class objects, functions and bindings is extremely compelling. It offers a solution to the problems of complexity that pure HTML cannot tackle while still staying somewhat true to its declarative nature and reaping most of those benefits (instead of fully switching to the imperative DOM paradigm).</div><br/><div id="36794911" class="c"><input type="checkbox" id="c-36794911" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36794786">parent</a><span>|</span><a href="#36794068">next</a><span>|</span><label class="collapse" for="c-36794911">[-]</label><label class="expand" for="c-36794911">[2 more]</label></div><br/><div class="children"><div class="content">Adding &quot;declaratively&quot; doesn&#x27;t make it true either.<p>You can declaratively pass objects between web components in every web components library out there like Lit or Stencil.<p>Now, you may claim that that doesn&#x27;t count because the declarative part is implemented in non-standard userland libraries, to which I would reply:<p>1) So what? React is a non-standard userland library. You can&#x27;t pass data declaratively between React components without React. At least with web components there&#x27;s a standard _interface_ for the components so that many different libraries can implement the declarative parts in a completely interoperable way.<p>2) Yes, you can&#x27;t pass objects around in plain HTML because plain HTML doesn&#x27;t have references to the objects in the first place. Even if you did add a way to set properties in HTML, what would you set them to?<p>2b) This is actually likely changing as the Template Instantiation proposal moves along and possibly gets the ability to make property bindings. This will be useful for declaring custom elements that accept properties. But the question remains: where do those properties originate from? Most likely JavaScript, because HTML doesn&#x27;t have any.</div><br/><div id="36796354" class="c"><input type="checkbox" id="c-36796354" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36794911">parent</a><span>|</span><a href="#36794068">next</a><span>|</span><label class="collapse" for="c-36796354">[-]</label><label class="expand" for="c-36796354">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can declaratively pass objects between web components in every web components library out there like Lit or Stencil.<p>They capitalized Web Components, I think they&#x27;re talking about what browsers natively support and not a library or framework.</div><br/></div></div></div></div></div></div></div></div><div id="36794068" class="c"><input type="checkbox" id="c-36794068" checked=""/><div class="controls bullet"><span class="by">WickyNilliams</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36793644">parent</a><span>|</span><a href="#36794003">prev</a><span>|</span><a href="#36793568">next</a><span>|</span><label class="collapse" for="c-36794068">[-]</label><label class="expand" for="c-36794068">[1 more]</label></div><br/><div class="children"><div class="content">Not via html attributes. But it&#x27;s never been a problem to pass data via JS properties:<p><pre><code>   someWebComponent.data = { foo: &quot;bar&quot; }</code></pre></div><br/></div></div></div></div></div></div><div id="36793568" class="c"><input type="checkbox" id="c-36793568" checked=""/><div class="controls bullet"><span class="by">nwienert</span><span>|</span><a href="#36793385">parent</a><span>|</span><a href="#36793522">prev</a><span>|</span><a href="#36793584">next</a><span>|</span><label class="collapse" for="c-36793568">[-]</label><label class="expand" for="c-36793568">[2 more]</label></div><br/><div class="children"><div class="content">I think your idea of speeding up the DOM is the right one, but the view transitions API has almost nothing to do with it. That’s more for whole page changes, and doesn’t solve the main issues which is that the DOM simply does way too much and is bloated to all hell, and that JS is single threaded.<p>I’d like to see a new mode introduced ala “use strict”. I know the big brains at the top hate this but we need a way to shake off some legacy especially in the DOM. A few changes to its semantics could dramatically speed it up. And then the second part would be a way to share events and DOM across workers so we can put React essentially off the main thread. These two changes together would make websites able to feel like native apps.</div><br/><div id="36797936" class="c"><input type="checkbox" id="c-36797936" checked=""/><div class="controls bullet"><span class="by">bryanrasmussen</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36793568">parent</a><span>|</span><a href="#36793584">next</a><span>|</span><label class="collapse" for="c-36797936">[-]</label><label class="expand" for="c-36797936">[1 more]</label></div><br/><div class="children"><div class="content">&gt; DOM simply does way too much and is bloated to all hell,<p>It&#x27;s my observation that React and similar frameworks really help to bloat the DOM.<p>Now someone will say it is how people misuse React and similar frameworks.<p>and then I will say if large parts of the population using a technology make the same misuse of it, even people who know better, it seems like the technology supports that misuse and is to blame somehow.</div><br/></div></div></div></div><div id="36793584" class="c"><input type="checkbox" id="c-36793584" checked=""/><div class="controls bullet"><span class="by">garganzol</span><span>|</span><a href="#36793385">parent</a><span>|</span><a href="#36793568">prev</a><span>|</span><a href="#36793712">next</a><span>|</span><label class="collapse" for="c-36793584">[-]</label><label class="expand" for="c-36793584">[1 more]</label></div><br/><div class="children"><div class="content">DOM changes are only a part of the story. Another part is a component model that allows to build complex software from tiny and sometimes messy individual pieces.</div><br/></div></div><div id="36793712" class="c"><input type="checkbox" id="c-36793712" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#36793385">parent</a><span>|</span><a href="#36793584">prev</a><span>|</span><a href="#36795268">next</a><span>|</span><label class="collapse" for="c-36793712">[-]</label><label class="expand" for="c-36793712">[1 more]</label></div><br/><div class="children"><div class="content">With the exception of list comprehension, which is IMO not only the best feature of jquery but almost enough of a reason to use it on its own, browsers have copied most of the features at this point. Do you (or anyone else here) see an opportunity to copy features from React into the browser?<p>I know there have been earlier tricks to pop elements off the DOM, modify them heavily and then pop them back on. I wonder if it would be better to a) provide a way to mark a node and it’s children as suspended reflow, or b) provide a virtual view where you can do operations on off-DOM nodes including ones that typically trigger reflow. c) something else entirely</div><br/></div></div><div id="36795268" class="c"><input type="checkbox" id="c-36795268" checked=""/><div class="controls bullet"><span class="by">mr_toad</span><span>|</span><a href="#36793385">parent</a><span>|</span><a href="#36793712">prev</a><span>|</span><a href="#36793781">next</a><span>|</span><label class="collapse" for="c-36795268">[-]</label><label class="expand" for="c-36795268">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I implemented word processors, and I&#x27;ve used a technique called &#x27;double buffering&#x27; to rerender complete pages off-screen, fast.<p>Node trees can be created without attaching them to a document.  Then the whole tree can be attached with one call,<p>There’s no need to attach nodes individually.  I don’t know why anyone would want to do that.</div><br/></div></div><div id="36793781" class="c"><input type="checkbox" id="c-36793781" checked=""/><div class="controls bullet"><span class="by">jeremyjh</span><span>|</span><a href="#36793385">parent</a><span>|</span><a href="#36795268">prev</a><span>|</span><a href="#36794153">next</a><span>|</span><label class="collapse" for="c-36793781">[-]</label><label class="expand" for="c-36793781">[1 more]</label></div><br/><div class="children"><div class="content">You want to store your application state in a widget tree? This was the part about the old bit &#x27;o jquery approach that drove me absolutely batshit. The logical state of your UI is strewn about in Dom objects and their listeners, closures etc. There is no one place you can go to see what state is relevant to this component.</div><br/></div></div><div id="36794153" class="c"><input type="checkbox" id="c-36794153" checked=""/><div class="controls bullet"><span class="by">JohnFen</span><span>|</span><a href="#36793385">parent</a><span>|</span><a href="#36793781">prev</a><span>|</span><a href="#36795929">next</a><span>|</span><label class="collapse" for="c-36794153">[-]</label><label class="expand" for="c-36794153">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve used a technique called &#x27;double buffering&#x27; to rerender complete pages off-screen, fast.<p>I&#x27;m absolutely not a web dev (as this comment will make clear), but I&#x27;m very surprised that browsers haven&#x27;t been doing this all along. I just assumed that they did.</div><br/><div id="36795966" class="c"><input type="checkbox" id="c-36795966" checked=""/><div class="controls bullet"><span class="by">plopz</span><span>|</span><a href="#36793385">root</a><span>|</span><a href="#36794153">parent</a><span>|</span><a href="#36795929">next</a><span>|</span><label class="collapse" for="c-36795966">[-]</label><label class="expand" for="c-36795966">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure they do, theres even a construct to do this called OffscreenCanvas</div><br/></div></div></div></div><div id="36795929" class="c"><input type="checkbox" id="c-36795929" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#36793385">parent</a><span>|</span><a href="#36794153">prev</a><span>|</span><a href="#36794754">next</a><span>|</span><label class="collapse" for="c-36795929">[-]</label><label class="expand" for="c-36795929">[1 more]</label></div><br/><div class="children"><div class="content">Back in the VB6 days there was an option one had to toggle to enable the double buffer.<p>Without it all app paints had a noticeable lag.</div><br/></div></div><div id="36794754" class="c"><input type="checkbox" id="c-36794754" checked=""/><div class="controls bullet"><span class="by">ngFanboi45</span><span>|</span><a href="#36793385">parent</a><span>|</span><a href="#36795929">prev</a><span>|</span><a href="#36794533">next</a><span>|</span><label class="collapse" for="c-36794754">[-]</label><label class="expand" for="c-36794754">[1 more]</label></div><br/><div class="children"><div class="content">Change detection is one thing, and double buffering is another.
Change detection is just projecting from state changes to UI changes. It doesn&#x27;t try to solve this hypothetical &quot;flashing&quot;. That is entirely up to the browser.
Double buffering is a graphic technique meant to show smooth UI changes at the cost of doubling the memory used for the graphical object.</div><br/></div></div><div id="36794533" class="c"><input type="checkbox" id="c-36794533" checked=""/><div class="controls bullet"><span class="by">NewEntryHN</span><span>|</span><a href="#36793385">parent</a><span>|</span><a href="#36794754">prev</a><span>|</span><a href="#36794084">next</a><span>|</span><label class="collapse" for="c-36794533">[-]</label><label class="expand" for="c-36794533">[1 more]</label></div><br/><div class="children"><div class="content">In all cases you&#x27;re going to store and manage your state some place. What you describe is managing the state using the DOM itself, which would indeed be easier if the DOM wasn&#x27;t directly tied to the screen, but which would still be very cumbersome because of the lack of appropriate APIs for managing the DOM as an application state.<p>If you were to go in this direction, you would eventually make the DOM less DOM-ish, and the painting mechanism more DOM-ish, effectively shifting everything one place and going full circle back to the frameworks.</div><br/></div></div><div id="36794084" class="c"><input type="checkbox" id="c-36794084" checked=""/><div class="controls bullet"><span class="by">tabtab</span><span>|</span><a href="#36793385">parent</a><span>|</span><a href="#36794533">prev</a><span>|</span><a href="#36794320">next</a><span>|</span><label class="collapse" for="c-36794084">[-]</label><label class="expand" for="c-36794084">[1 more]</label></div><br/><div class="children"><div class="content">DOM wasn&#x27;t meant for real GUI&#x27;s and trying to trick it into being one seems a fool&#x27;s errand. It was meant for static documents. DOM is the wrong tool for the job.<p>Time for a new state-ful GUI markup standard so we don&#x27;t have to rely on the whacky DOM to get expected and common GUI idioms.<p>Maybe build the &quot;engine&quot; on top of the Tk or Qt kits to avoid starting from scratch.</div><br/></div></div><div id="36794320" class="c"><input type="checkbox" id="c-36794320" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#36793385">parent</a><span>|</span><a href="#36794084">prev</a><span>|</span><a href="#36793678">next</a><span>|</span><label class="collapse" for="c-36794320">[-]</label><label class="expand" for="c-36794320">[1 more]</label></div><br/><div class="children"><div class="content">We need DOM transactions.</div><br/></div></div></div></div><div id="36793678" class="c"><input type="checkbox" id="c-36793678" checked=""/><div class="controls bullet"><span class="by">onion2k</span><span>|</span><a href="#36793385">prev</a><span>|</span><a href="#36793243">next</a><span>|</span><label class="collapse" for="c-36793678">[-]</label><label class="expand" for="c-36793678">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t agree, because in my experience every framework is <i>fast enough</i> unless you&#x27;re either past what it&#x27;s capable of (you probably aren&#x27;t) or you&#x27;re using it wrong (you probably are). It is <i>far</i> more important to fine a framework that you like and that you understand, because then you&#x27;ll write good code that the framework can run fast.</div><br/><div id="36794889" class="c"><input type="checkbox" id="c-36794889" checked=""/><div class="controls bullet"><span class="by">plaguuuuuu</span><span>|</span><a href="#36793678">parent</a><span>|</span><a href="#36794399">next</a><span>|</span><label class="collapse" for="c-36794889">[-]</label><label class="expand" for="c-36794889">[1 more]</label></div><br/><div class="children"><div class="content">Some frameworks have nastier non-obvious footguns that make performance issues difficult to spot.<p>Funny example, in Blazor, if you have a mouse move event, by default it will decide that your <i>entire component</i> including children needs to be rerendered whenever the mouse moves by a single pixel. Unless you change state management to manual or whatever.</div><br/></div></div><div id="36794399" class="c"><input type="checkbox" id="c-36794399" checked=""/><div class="controls bullet"><span class="by">mianos</span><span>|</span><a href="#36793678">parent</a><span>|</span><a href="#36794889">prev</a><span>|</span><a href="#36794795">next</a><span>|</span><label class="collapse" for="c-36794399">[-]</label><label class="expand" for="c-36794399">[1 more]</label></div><br/><div class="children"><div class="content">I agree. Of course there is no &#x27;single factor&#x27; for almost anything.<p>So, going with the themes of attention seeking hyperbole, I would say the &#x27;single biggest factor&#x27;, is the ability to find and keep skilled developers in any of these top 10 frameworks. The differences mean <i>nothing</i> when the bigger picture is considered.</div><br/></div></div><div id="36794795" class="c"><input type="checkbox" id="c-36794795" checked=""/><div class="controls bullet"><span class="by">sp332</span><span>|</span><a href="#36793678">parent</a><span>|</span><a href="#36794399">prev</a><span>|</span><a href="#36793243">next</a><span>|</span><label class="collapse" for="c-36794795">[-]</label><label class="expand" for="c-36794795">[1 more]</label></div><br/><div class="children"><div class="content">What are you disagreeing with?</div><br/></div></div></div></div><div id="36793243" class="c"><input type="checkbox" id="c-36793243" checked=""/><div class="controls bullet"><span class="by">nsxwolf</span><span>|</span><a href="#36793678">prev</a><span>|</span><a href="#36792468">next</a><span>|</span><label class="collapse" for="c-36793243">[-]</label><label class="expand" for="c-36793243">[10 more]</label></div><br/><div class="children"><div class="content">You know what I&#x27;ve always wanted in a front end framework, as a back end developer that sometimes is forced to work on front end tickets? I want a development build mode that generates some kind of project metadata where I can just point to something on the screen and get a report of all the interesting files in the project that are responsible for what I&#x27;m seeing:<p>* API calls<p>* Templates<p>* CSS<p>* Controllers, etc.<p>My usual technique of finding some text content, looking for an i18n file and working my way backwards is tedious.</div><br/><div id="36793455" class="c"><input type="checkbox" id="c-36793455" checked=""/><div class="controls bullet"><span class="by">RandallBrown</span><span>|</span><a href="#36793243">parent</a><span>|</span><a href="#36794420">next</a><span>|</span><label class="collapse" for="c-36793455">[-]</label><label class="expand" for="c-36793455">[6 more]</label></div><br/><div class="children"><div class="content">Apologies if you&#x27;re aware of this already but every browser has a web inspector built in where you can point and click on something and at least see the HTML and CSS associated with it.</div><br/><div id="36793732" class="c"><input type="checkbox" id="c-36793732" checked=""/><div class="controls bullet"><span class="by">rubinlinux</span><span>|</span><a href="#36793243">root</a><span>|</span><a href="#36793455">parent</a><span>|</span><a href="#36794962">next</a><span>|</span><label class="collapse" for="c-36793732">[-]</label><label class="expand" for="c-36793732">[2 more]</label></div><br/><div class="children"><div class="content">And vuejs has a browser plugin which can sort-of show you which components call which components to get there.</div><br/><div id="36796381" class="c"><input type="checkbox" id="c-36796381" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#36793243">root</a><span>|</span><a href="#36793732">parent</a><span>|</span><a href="#36794962">next</a><span>|</span><label class="collapse" for="c-36796381">[-]</label><label class="expand" for="c-36796381">[1 more]</label></div><br/><div class="children"><div class="content">React and Redux both have similar addons as well, to inspect the component tree and to see the state changes over time (and even roll back; &quot;time travel debugging&quot; has been one of Redux&#x27;s primary features since it was released).</div><br/></div></div></div></div><div id="36794962" class="c"><input type="checkbox" id="c-36794962" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#36793243">root</a><span>|</span><a href="#36793455">parent</a><span>|</span><a href="#36793732">prev</a><span>|</span><a href="#36793539">next</a><span>|</span><label class="collapse" for="c-36794962">[-]</label><label class="expand" for="c-36794962">[2 more]</label></div><br/><div class="children"><div class="content">Directly surfacing the effects involved, e.g. HTTP calls via all the event handlers through layers of nesting, would indeed be nice.</div><br/><div id="36796138" class="c"><input type="checkbox" id="c-36796138" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#36793243">root</a><span>|</span><a href="#36794962">parent</a><span>|</span><a href="#36793539">next</a><span>|</span><label class="collapse" for="c-36796138">[-]</label><label class="expand" for="c-36796138">[1 more]</label></div><br/><div class="children"><div class="content">I’m not sure how other browsers’ dev tools do on this front, but at least in Chrome most requests in the Network tab will link to the file&#x2F;line of code which initiated the request. From there you should be able to set breakpoints or whatever to track subsequent requests.</div><br/></div></div></div></div><div id="36793539" class="c"><input type="checkbox" id="c-36793539" checked=""/><div class="controls bullet"><span class="by">commotionfever</span><span>|</span><a href="#36793243">root</a><span>|</span><a href="#36793455">parent</a><span>|</span><a href="#36794962">prev</a><span>|</span><a href="#36794420">next</a><span>|</span><label class="collapse" for="c-36793539">[-]</label><label class="expand" for="c-36793539">[1 more]</label></div><br/><div class="children"><div class="content">and you can also click on a request in the network tab and find out the line of code triggered it, including callstack<p>also with react dev tools you can click somewhere on the page and see the react component, it&#x27;s props, etc. similar tools are available for other frameworks</div><br/></div></div></div></div><div id="36794420" class="c"><input type="checkbox" id="c-36794420" checked=""/><div class="controls bullet"><span class="by">MatekCopatek</span><span>|</span><a href="#36793243">parent</a><span>|</span><a href="#36793455">prev</a><span>|</span><a href="#36795225">next</a><span>|</span><label class="collapse" for="c-36794420">[-]</label><label class="expand" for="c-36794420">[1 more]</label></div><br/><div class="children"><div class="content">Most of the major frameworks (I&#x27;m 100% sure about Vue and React) have browser extensions that give you extremely powerful dev tools. It&#x27;s not _exactly_ what you&#x27;re asking for, but pretty close. You can actually click on a random thing, see which component it is, what kind of state it&#x27;s holding internally etc.</div><br/></div></div><div id="36795225" class="c"><input type="checkbox" id="c-36795225" checked=""/><div class="controls bullet"><span class="by">roblh</span><span>|</span><a href="#36793243">parent</a><span>|</span><a href="#36794420">prev</a><span>|</span><a href="#36793937">next</a><span>|</span><label class="collapse" for="c-36795225">[-]</label><label class="expand" for="c-36795225">[1 more]</label></div><br/><div class="children"><div class="content">Sveltekit has a thing now where when I do the standard ctrl shift c and highlight something, it’ll open the file in vscode responsible for it. It’s honestly a little bit unsettling, but I think it’ll be useful with some practice.</div><br/></div></div><div id="36793937" class="c"><input type="checkbox" id="c-36793937" checked=""/><div class="controls bullet"><span class="by">frio</span><span>|</span><a href="#36793243">parent</a><span>|</span><a href="#36795225">prev</a><span>|</span><a href="#36792468">next</a><span>|</span><label class="collapse" for="c-36793937">[-]</label><label class="expand" for="c-36793937">[1 more]</label></div><br/><div class="children"><div class="content">You may be looking for `sourcemap`s, which store a record of the transpilation that has happened and let you work backwards.  Your browser&#x27;s tools should fetch them by default if they&#x27;re available, but depending on your frontend stack, they may not be generated by default.</div><br/></div></div></div></div><div id="36792468" class="c"><input type="checkbox" id="c-36792468" checked=""/><div class="controls bullet"><span class="by">MauranKilom</span><span>|</span><a href="#36793243">prev</a><span>|</span><a href="#36793268">next</a><span>|</span><label class="collapse" for="c-36792468">[-]</label><label class="expand" for="c-36792468">[23 more]</label></div><br/><div class="children"><div class="content">Not a frontend person, and unlikely to become one anytime soon, but maybe someone can shed some light into the downsides of Svelte? The article fails to mention any (it&#x27;s apparently &quot;win-win&quot;). Presumably if Svelte were the be-all-end-all of front-end frameworks, it would dominate soon enough?</div><br/><div id="36792578" class="c"><input type="checkbox" id="c-36792578" checked=""/><div class="controls bullet"><span class="by">tl</span><span>|</span><a href="#36792468">parent</a><span>|</span><a href="#36793174">next</a><span>|</span><label class="collapse" for="c-36792578">[-]</label><label class="expand" for="c-36792578">[1 more]</label></div><br/><div class="children"><div class="content">React:<p>- had a 3 year head start on Svetle (2013 vs. 2016)<p>- has major engineering orgs behind it. Facebook started it. Microsoft makes it work with Typescript.<p>- is easier to get started with. While JS-compilation is common, it&#x27;s required for Svetle.<p>Svelte isn&#x27;t free of pain points. Like any form of magic, it has edge cases. It&#x27;s better but not &quot;better enough&quot; to de-throne React.</div><br/></div></div><div id="36793174" class="c"><input type="checkbox" id="c-36793174" checked=""/><div class="controls bullet"><span class="by">grayrest</span><span>|</span><a href="#36792468">parent</a><span>|</span><a href="#36792578">prev</a><span>|</span><a href="#36797769">next</a><span>|</span><label class="collapse" for="c-36793174">[-]</label><label class="expand" for="c-36793174">[10 more]</label></div><br/><div class="children"><div class="content">&gt; maybe someone can shed some light into the downsides of Svelte<p>Svelte trades off runtime size for component size. It was created in the context of infographics for the New York Times online and for projects that roughly line up with that it&#x27;s pretty much the technically best option.<p>I like the Svelte authoring experience and introduced it for a few components in a React based low-code platform. The reason I phased it out was a chat component that was ~600 LoC and 50-something reactive variables in a moderately complex chain blew up into ~5k LoC of output. I also ran into what seemed to be some transient invalidation issues. I was short on time to debug this and engage with the Svelte community so I rewrote it in React to match the rest of the system. It&#x27;s possible I was doing something wrong but I don&#x27;t have enough confidence to bet on 3.x again. I&#x27;ll take another look when 4.x comes around.<p>&gt; Presumably if Svelte were the be-all-end-all of front-end frameworks, it would dominate soon enough?<p>There&#x27;s significant network effects around the established frameworks. Nobody gets fired for picking React. I personally think Solid is the best overall technically but the ecosystem and mindshare is smaller and that matters to a company making a business and not necessarily technical decision.</div><br/><div id="36797105" class="c"><input type="checkbox" id="c-36797105" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#36792468">root</a><span>|</span><a href="#36793174">parent</a><span>|</span><a href="#36793629">next</a><span>|</span><label class="collapse" for="c-36797105">[-]</label><label class="expand" for="c-36797105">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I also ran into what seemed to be some transient invalidation issues.</i><p>It sounds to me like you didn’t understand the details of Svelte’s reactivity model, which are <i>very</i> important, and fairly straightforward to learn, but different from what people are commonly used to—and so even if you theoretically learn the model, it may take time in more complex cases for it to come naturally. The crux of these sorts of problems tends to be that reactivity is a property of <i>bindings</i>, not data; and as a secondary effect, <i>mutation</i> is therefore rather hazardous.<p>&gt; <i>50-something reactive variables in a moderately complex chain</i><p>It sounds also like you’re fighting the framework. I’ve seen stuff like what you describe in some React libraries (e.g. mirroring something DOMmy in React—common, but I <i>hate</i> it because it’s so much mindless duplication, among other faults), but in Svelte at this scale you’re <i>likely</i> to get better results from seeing if you can bag things together (e.g. let x = {a, b, c} rather than let a, b, c), or passing through <i>components</i> rather than reactive variables. But these are vague concepts which may not actually be relevant or applicable.<p>Svelte is a framework that definitely requires that you work <i>with</i> it, or you’ll have a miserable time, whereas with React you can, to a much greater extent, do awful things and get away with it.<p>And when you speak of 3.x and 4.x and such—there’s basically no chance any of this stuff will ever change in Svelte, it’s too fundamental. In some cases you <i>might</i> end up with better compiler warnings, but that’ll likely be the extent of it.</div><br/><div id="36797732" class="c"><input type="checkbox" id="c-36797732" checked=""/><div class="controls bullet"><span class="by">grayrest</span><span>|</span><a href="#36792468">root</a><span>|</span><a href="#36797105">parent</a><span>|</span><a href="#36793629">next</a><span>|</span><label class="collapse" for="c-36797732">[-]</label><label class="expand" for="c-36797732">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It sounds to me like you didn’t understand the details of Svelte’s reactivity model<p>This is a reasonable assumption given what I&#x27;ve described. It&#x27;s been almost two years but from what I remember the problem was updating what should have been the same reactive binding in two different locations. When trying to debug a problem I was stepping through the code and noticed that the indicies passed to `$$invalidate` were different. Checked for typos and shadowed declarations and found none. Rolled back to checkout and found the indicies matched. In the process of undoing&#x2F;redoing my conclusion was that the introduction of an unrelated reactive binding was the difference. I could have been wrong; I was pretty exhausted at that point.<p>&gt; It sounds also like you’re fighting the framework.<p>Sure. In this case it was getting a big chunk of JSON back from an endpoint I didn&#x27;t control and trying to use a number of reactive variables to select out pieces for display. I&#x27;ve done similar things in a half dozen other reactive&#x2F;FRP libraries without issue but I assumed I was off the beaten path in Svelte.<p>I realize that this is empty complaining about other peoples&#x27; hard work. I don&#x27;t have the code any more and I don&#x27;t have a reproducible test case so I have no problem with anybody waving this off.</div><br/></div></div></div></div><div id="36793629" class="c"><input type="checkbox" id="c-36793629" checked=""/><div class="controls bullet"><span class="by">boringuser2</span><span>|</span><a href="#36792468">root</a><span>|</span><a href="#36793174">parent</a><span>|</span><a href="#36797105">prev</a><span>|</span><a href="#36797769">next</a><span>|</span><label class="collapse" for="c-36793629">[-]</label><label class="expand" for="c-36793629">[7 more]</label></div><br/><div class="children"><div class="content">Why do you care about compilation output?<p>Also, your component sounds cumbersome.</div><br/><div id="36794398" class="c"><input type="checkbox" id="c-36794398" checked=""/><div class="controls bullet"><span class="by">kabes</span><span>|</span><a href="#36792468">root</a><span>|</span><a href="#36793629">parent</a><span>|</span><a href="#36795321">next</a><span>|</span><label class="collapse" for="c-36794398">[-]</label><label class="expand" for="c-36794398">[1 more]</label></div><br/><div class="children"><div class="content">Because the article makes it sound like your application code will be smaller because you don&#x27;t need to ship the change detection library&#x2F;framework.
But in a big enough application, the explicit change detection code added by the compiler adds up to more lines of code than most frameworks.</div><br/></div></div><div id="36795321" class="c"><input type="checkbox" id="c-36795321" checked=""/><div class="controls bullet"><span class="by">grayrest</span><span>|</span><a href="#36792468">root</a><span>|</span><a href="#36793629">parent</a><span>|</span><a href="#36794398">prev</a><span>|</span><a href="#36794250">next</a><span>|</span><label class="collapse" for="c-36795321">[-]</label><label class="expand" for="c-36795321">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why do you care about compilation output?<p>I was advocating&#x2F;piloting a new framework in the app and was unhappy with the output versus the input and perceived complexity. I spend a significant fraction of my time cleaning up performance issues. A good chunk of that is download size so I care in general about what I&#x27;m sending across the wire.<p>&gt; Also, your component sounds cumbersome.<p>Sure. It was the classic feature creep scenario.</div><br/></div></div><div id="36794250" class="c"><input type="checkbox" id="c-36794250" checked=""/><div class="controls bullet"><span class="by">i-use-nixos-btw</span><span>|</span><a href="#36792468">root</a><span>|</span><a href="#36793629">parent</a><span>|</span><a href="#36795321">prev</a><span>|</span><a href="#36797769">next</a><span>|</span><label class="collapse" for="c-36794250">[-]</label><label class="expand" for="c-36794250">[4 more]</label></div><br/><div class="children"><div class="content">I’m mainly a C++ developer, not a frontend developer (though I dabble), and when I have a choice of multiple approaches the first thing I do is go to godbolt.org, implement MWEs and compare the assembly.<p>I also do a lot of code generation, and my absolute goal is to have it write code that I’d write if I were doing it by hand. That’s pretty key for me. If the output is better, then good. If the output is doing a bunch of stuff it doesn’t need to be doing because it’s taking my specific use case and making it conform with its own model for doing generic things, I don’t like it.<p>I was a web developer back when tables for layout, HTML attribute soup for styling, and applets for interactivity were going out of fashion. Semantic HTML and CSS for layout and styling and JS for interactivity were coming into fashion. Divs for layout, class soup for styling, and JS frameworks for interactivity hadn’t yet become mainstream when I stopped.<p>So my default is lean HTML, lean CSS, raw JS. Maybe JQuery if needs be. It’s an outdated default, but it’s mine. The thing is, I get great load times and performance for what I need. What I need is normal dashboard stuff - though because of the nature of the field I work in, it condenses a lot of information onto a page and that information is updating many times per second.<p>I don’t seem to get enough performance from the frontend frameworks I’ve tried. I don’t know if it comes from code bloat, or deep call stacks through god knows how many levels of indirection, the way DOM updates are issued, or something else - but it has just never seemed worth the learning curve to end up with something I can’t do myself with admittedly a lot of work.<p>As such, I find this review helpful. Svelte has caught my attention and I want to give it a go, but if the output is bloaty then that’s a red flag for me. If it’s bloaty because it isn’t doing backflips through the call stack, but is inlining code - that’s familiar territory and certainly something I can deal with.</div><br/><div id="36795164" class="c"><input type="checkbox" id="c-36795164" checked=""/><div class="controls bullet"><span class="by">grayrest</span><span>|</span><a href="#36792468">root</a><span>|</span><a href="#36794250">parent</a><span>|</span><a href="#36796281">next</a><span>|</span><label class="collapse" for="c-36795164">[-]</label><label class="expand" for="c-36795164">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So my default is lean HTML, lean CSS, raw JS.<p>This is fine but having spent a decade of my career doing this, I would never advocate for it in an app with any kind of frontend complexity or a chance to grow into it. The frameworks mostly obviate the need to understand layout thrashing, resource cleanup, and retained state conflicts in the DOM. If you&#x27;re doing simple stuff these don&#x27;t matter but they&#x27;re challenging to fix and more challenging to stay fixed when a group is contributing.<p>&gt; Svelte has caught my attention and I want to give it a go, but if the output is bloaty then that’s a red flag for me<p>Your use case is a pretty good fit for Svelte and you&#x27;re likely to get output you&#x27;d find acceptable and given your preferences I think you&#x27;re more likely to prefer its sensibilities over other frameworks that could provide the perf you&#x27;re looking for. The tradeoff is kind of like the tradeoff between monomorphization vs virtual dispatch. The Svelte compiler is basically inlining the update code instead of using shared code in a runtime.</div><br/></div></div><div id="36796281" class="c"><input type="checkbox" id="c-36796281" checked=""/><div class="controls bullet"><span class="by">nonethewiser</span><span>|</span><a href="#36792468">root</a><span>|</span><a href="#36794250">parent</a><span>|</span><a href="#36795164">prev</a><span>|</span><a href="#36794856">next</a><span>|</span><label class="collapse" for="c-36796281">[-]</label><label class="expand" for="c-36796281">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the way DOM updates are issued<p>This one, id wager. There isn’t necessarily anything wrong with your approach but Id agree that you should try svelte for this reason.</div><br/></div></div><div id="36794856" class="c"><input type="checkbox" id="c-36794856" checked=""/><div class="controls bullet"><span class="by">plaguuuuuu</span><span>|</span><a href="#36792468">root</a><span>|</span><a href="#36794250">parent</a><span>|</span><a href="#36796281">prev</a><span>|</span><a href="#36797769">next</a><span>|</span><label class="collapse" for="c-36794856">[-]</label><label class="expand" for="c-36794856">[1 more]</label></div><br/><div class="children"><div class="content">FWIW it&#x27;s a strange anecdote to me, as I remember the opposite being the case - svelte app being significantly smaller than React.<p>Svelte&#x27;s whole shtick is using ASTs from the compiler to stuff at compile time where possible, to reduce bundle size and complexity.</div><br/></div></div></div></div></div></div></div></div><div id="36797769" class="c"><input type="checkbox" id="c-36797769" checked=""/><div class="controls bullet"><span class="by">SebastianKra</span><span>|</span><a href="#36792468">parent</a><span>|</span><a href="#36793174">prev</a><span>|</span><a href="#36792611">next</a><span>|</span><label class="collapse" for="c-36797769">[-]</label><label class="expand" for="c-36797769">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m disappointed that this isn&#x27;t talked about, even when someone explicitly asks: You can&#x27;t use JS to iterate over, store or otherwise work with the output of the templating language.<p>For example:<p><pre><code>    const cells: Record&lt;string, ReactNode&gt; = { a: &quot;hello world&quot;, b: &lt;&gt;hello &lt;b&gt;world&lt;&#x2F;b&gt;&lt;&#x2F;&gt;, c: &lt;Icon src=&quot;world.png&quot; &#x2F;&gt;}
</code></pre>
The closest you could get in Svelte, is creating three new components (3 entire files), which are then rendered using `&lt;svelte.component this={HelloWorldComponent} &#x2F;&gt;`.<p>This becomes a problem, when you build composed components that decide their layout based on logic thats too complex to express in CSS or Sveltes templating system.<p>For example:<p>- A component for tabbed navigation that automatically becomes a sidebar on desktop.<p>- React Router defining its entire navigation tree [1]<p>- Ant.Design defining the columns of the table, where you can trivially supply a short callback to render a cell [2]<p>[1]: <a href="https:&#x2F;&#x2F;reactrouter.com&#x2F;en&#x2F;main&#x2F;routers&#x2F;create-browser-router" rel="nofollow noreferrer">https:&#x2F;&#x2F;reactrouter.com&#x2F;en&#x2F;main&#x2F;routers&#x2F;create-browser-route...</a>
[2]: <a href="https:&#x2F;&#x2F;ant.design&#x2F;components&#x2F;table" rel="nofollow noreferrer">https:&#x2F;&#x2F;ant.design&#x2F;components&#x2F;table</a></div><br/></div></div><div id="36792611" class="c"><input type="checkbox" id="c-36792611" checked=""/><div class="controls bullet"><span class="by">simlevesque</span><span>|</span><a href="#36792468">parent</a><span>|</span><a href="#36797769">prev</a><span>|</span><a href="#36794940">next</a><span>|</span><label class="collapse" for="c-36792611">[-]</label><label class="expand" for="c-36792611">[1 more]</label></div><br/><div class="children"><div class="content">&gt; maybe someone can shed some light into the downsides of Svelte<p>The automatic handling of dependencies and recomputing means you have less control over how updates work.<p>Also I think it is important to understand the mutations going on in your ui. Having them explicit like in Vue makes it easier to understand what is gonna happen by looking at the code versus the implicit way that Svelte uses.</div><br/></div></div><div id="36794940" class="c"><input type="checkbox" id="c-36794940" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#36792468">parent</a><span>|</span><a href="#36792611">prev</a><span>|</span><a href="#36793330">next</a><span>|</span><label class="collapse" for="c-36794940">[-]</label><label class="expand" for="c-36794940">[1 more]</label></div><br/><div class="children"><div class="content">Two-way data binding. &#x27;Nuff said.<p>Instead of easy-to-trace functional logic and pure functions you have a thing more like an electrical circuit, or like a highly advanced jQuery contraption. It&#x27;s fine and even great for smaller bits of interactivity. It becomes increasingly unwieldy as the scope grows.<p>(And for tiny bits of interactivity there is HTMX, wonderful in its own way.)</div><br/></div></div><div id="36793330" class="c"><input type="checkbox" id="c-36793330" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#36792468">parent</a><span>|</span><a href="#36794940">prev</a><span>|</span><a href="#36793605">next</a><span>|</span><label class="collapse" for="c-36793330">[-]</label><label class="expand" for="c-36793330">[1 more]</label></div><br/><div class="children"><div class="content">You need to learn a custom DSL for logic instead of using just Javascript. This makes it worse for TypeScript as well as other tools like for linting, etc. Personally I&#x27;ll never learn another DSL after JSX.<p>Implicit 2 way data binding which makes logic hard to follow in larger projects, same with their reactivity model.</div><br/></div></div><div id="36793605" class="c"><input type="checkbox" id="c-36793605" checked=""/><div class="controls bullet"><span class="by">boringuser2</span><span>|</span><a href="#36792468">parent</a><span>|</span><a href="#36793330">prev</a><span>|</span><a href="#36792573">next</a><span>|</span><label class="collapse" for="c-36793605">[-]</label><label class="expand" for="c-36793605">[1 more]</label></div><br/><div class="children"><div class="content">My experience:<p>JSX is the best templating language.<p>Svelte hides complexity and this can bite you in tracking down issues.<p>React just feels better to me for a professional project, though I like Svelte.</div><br/></div></div><div id="36792573" class="c"><input type="checkbox" id="c-36792573" checked=""/><div class="controls bullet"><span class="by">Aerbil313</span><span>|</span><a href="#36792468">parent</a><span>|</span><a href="#36793605">prev</a><span>|</span><a href="#36792978">next</a><span>|</span><label class="collapse" for="c-36792573">[-]</label><label class="expand" for="c-36792573">[5 more]</label></div><br/><div class="children"><div class="content">Well it is very new. React has a massive inertia, so it dominates for now. I do FE work and see Svelte is gaining popularity.</div><br/><div id="36792966" class="c"><input type="checkbox" id="c-36792966" checked=""/><div class="controls bullet"><span class="by">bobolino123</span><span>|</span><a href="#36792468">root</a><span>|</span><a href="#36792573">parent</a><span>|</span><a href="#36792978">next</a><span>|</span><label class="collapse" for="c-36792966">[-]</label><label class="expand" for="c-36792966">[4 more]</label></div><br/><div class="children"><div class="content">2016 is not very new</div><br/><div id="36793446" class="c"><input type="checkbox" id="c-36793446" checked=""/><div class="controls bullet"><span class="by">karaterobot</span><span>|</span><a href="#36792468">root</a><span>|</span><a href="#36792966">parent</a><span>|</span><a href="#36793007">next</a><span>|</span><label class="collapse" for="c-36793446">[-]</label><label class="expand" for="c-36793446">[1 more]</label></div><br/><div class="children"><div class="content">Probably as much as the 3 year difference is the fact that Facebook made and evangelized React. I know I didn&#x27;t hear about Svelte until 2018-2019, but I knew about React within a few days of its release.</div><br/></div></div><div id="36793641" class="c"><input type="checkbox" id="c-36793641" checked=""/><div class="controls bullet"><span class="by">boringuser2</span><span>|</span><a href="#36792468">root</a><span>|</span><a href="#36792966">parent</a><span>|</span><a href="#36793007">prev</a><span>|</span><a href="#36792978">next</a><span>|</span><label class="collapse" for="c-36793641">[-]</label><label class="expand" for="c-36793641">[1 more]</label></div><br/><div class="children"><div class="content">Actually, that&#x27;s very old in frontend years.</div><br/></div></div></div></div></div></div><div id="36792978" class="c"><input type="checkbox" id="c-36792978" checked=""/><div class="controls bullet"><span class="by">pmarreck</span><span>|</span><a href="#36792468">parent</a><span>|</span><a href="#36792573">prev</a><span>|</span><a href="#36793268">next</a><span>|</span><label class="collapse" for="c-36792978">[-]</label><label class="expand" for="c-36792978">[1 more]</label></div><br/><div class="children"><div class="content">The problem is, there is no panacea in technology, only tradeoffs. Svelte does look pretty sweet though.</div><br/></div></div></div></div><div id="36793268" class="c"><input type="checkbox" id="c-36793268" checked=""/><div class="controls bullet"><span class="by">r_singh</span><span>|</span><a href="#36792468">prev</a><span>|</span><a href="#36796754">next</a><span>|</span><label class="collapse" for="c-36793268">[-]</label><label class="expand" for="c-36793268">[17 more]</label></div><br/><div class="children"><div class="content">This website loads staggeringly fast (much faster than HN and my own static site which uses Gatsby and is hosted on Cloudfront). What’s the reason for this?</div><br/><div id="36794860" class="c"><input type="checkbox" id="c-36794860" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#36793268">parent</a><span>|</span><a href="#36794386">next</a><span>|</span><label class="collapse" for="c-36794860">[-]</label><label class="expand" for="c-36794860">[1 more]</label></div><br/><div class="children"><div class="content">The whole HTML is likely static, and it has only one &lt;script&gt;, at the very end, that attaches some async update handler to the existing DOM. No wonder it renders instantly.<p>Modern computers are obnoxiously fast, and so are modern browsers. But modern websites overload them with a sickening amount of processing and network latencies before displaying the content.</div><br/></div></div><div id="36794386" class="c"><input type="checkbox" id="c-36794386" checked=""/><div class="controls bullet"><span class="by">hbn</span><span>|</span><a href="#36793268">parent</a><span>|</span><a href="#36794860">prev</a><span>|</span><a href="#36794608">next</a><span>|</span><label class="collapse" for="c-36794386">[-]</label><label class="expand" for="c-36794386">[1 more]</label></div><br/><div class="children"><div class="content">It flashes a dark theme for a half a second before switching to light</div><br/></div></div><div id="36794608" class="c"><input type="checkbox" id="c-36794608" checked=""/><div class="controls bullet"><span class="by">suralind</span><span>|</span><a href="#36793268">parent</a><span>|</span><a href="#36794386">prev</a><span>|</span><a href="#36794587">next</a><span>|</span><label class="collapse" for="c-36794608">[-]</label><label class="expand" for="c-36794608">[1 more]</label></div><br/><div class="children"><div class="content">Served via service worker, but still Cloudflare serves it faster than my very minimalistic static blog. Perhaps it uses paid Cloudflare plan?</div><br/></div></div><div id="36794587" class="c"><input type="checkbox" id="c-36794587" checked=""/><div class="controls bullet"><span class="by">NewEntryHN</span><span>|</span><a href="#36793268">parent</a><span>|</span><a href="#36794608">prev</a><span>|</span><a href="#36793390">next</a><span>|</span><label class="collapse" for="c-36794587">[-]</label><label class="expand" for="c-36794587">[2 more]</label></div><br/><div class="children"><div class="content">52ms for me. Pretty standard for an HTML page.</div><br/><div id="36794767" class="c"><input type="checkbox" id="c-36794767" checked=""/><div class="controls bullet"><span class="by">creata</span><span>|</span><a href="#36793268">root</a><span>|</span><a href="#36794587">parent</a><span>|</span><a href="#36793390">next</a><span>|</span><label class="collapse" for="c-36794767">[-]</label><label class="expand" for="c-36794767">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think I&#x27;ve ever seen a page load in 52ms (`load`, not `DOMContentLoaded`) with caching disabled.</div><br/></div></div></div></div><div id="36793390" class="c"><input type="checkbox" id="c-36793390" checked=""/><div class="controls bullet"><span class="by">sambroner</span><span>|</span><a href="#36793268">parent</a><span>|</span><a href="#36794587">prev</a><span>|</span><a href="#36793481">next</a><span>|</span><label class="collapse" for="c-36793390">[-]</label><label class="expand" for="c-36793390">[10 more]</label></div><br/><div class="children"><div class="content">Really impressive stuff. Seems to have slowed down slightly now that it&#x27;s on the front page, but blazing fast when I first opened it.</div><br/><div id="36793579" class="c"><input type="checkbox" id="c-36793579" checked=""/><div class="controls bullet"><span class="by">rustybolt</span><span>|</span><a href="#36793268">root</a><span>|</span><a href="#36793390">parent</a><span>|</span><a href="#36793536">next</a><span>|</span><label class="collapse" for="c-36793579">[-]</label><label class="expand" for="c-36793579">[4 more]</label></div><br/><div class="children"><div class="content">Impressive? This is the default. You have to actively do stuff to make it slower.</div><br/><div id="36793910" class="c"><input type="checkbox" id="c-36793910" checked=""/><div class="controls bullet"><span class="by">travisjungroth</span><span>|</span><a href="#36793268">root</a><span>|</span><a href="#36793579">parent</a><span>|</span><a href="#36794344">next</a><span>|</span><label class="collapse" for="c-36793910">[-]</label><label class="expand" for="c-36793910">[2 more]</label></div><br/><div class="children"><div class="content">You have to actively do stuff to make a house messy, but it can still be impressive when it’s clean.</div><br/><div id="36794137" class="c"><input type="checkbox" id="c-36794137" checked=""/><div class="controls bullet"><span class="by">dylan604</span><span>|</span><a href="#36793268">root</a><span>|</span><a href="#36793910">parent</a><span>|</span><a href="#36794344">next</a><span>|</span><label class="collapse" for="c-36794137">[-]</label><label class="expand" for="c-36794137">[1 more]</label></div><br/><div class="children"><div class="content">I find it the opposite. You have to actively clean a house, but do nothing and it won&#x27;t be clean</div><br/></div></div></div></div></div></div><div id="36793536" class="c"><input type="checkbox" id="c-36793536" checked=""/><div class="controls bullet"><span class="by">8organicbits</span><span>|</span><a href="#36793268">root</a><span>|</span><a href="#36793390">parent</a><span>|</span><a href="#36793579">prev</a><span>|</span><a href="#36793481">next</a><span>|</span><label class="collapse" for="c-36793536">[-]</label><label class="expand" for="c-36793536">[5 more]</label></div><br/><div class="children"><div class="content">Interesting. I&#x27;m seeing something slower. Pagespeed shows 2.7 seconds:<p><a href="https:&#x2F;&#x2F;pagespeed.web.dev&#x2F;analysis&#x2F;https-themer-dev-blog-the-single-most-important-factor-that-differentiates-front-end-frameworks&#x2F;u10rfjgwkz?form_factor=mobile" rel="nofollow noreferrer">https:&#x2F;&#x2F;pagespeed.web.dev&#x2F;analysis&#x2F;https-themer-dev-blog-the...</a></div><br/><div id="36793756" class="c"><input type="checkbox" id="c-36793756" checked=""/><div class="controls bullet"><span class="by">sambroner</span><span>|</span><a href="#36793268">root</a><span>|</span><a href="#36793536">parent</a><span>|</span><a href="#36793722">prev</a><span>|</span><a href="#36793481">next</a><span>|</span><label class="collapse" for="c-36793756">[-]</label><label class="expand" for="c-36793756">[3 more]</label></div><br/><div class="children"><div class="content">Even just an eye-test shows it&#x27;s much faster than that for me.<p>Pagespeed shows .6 for desktop, but locally I&#x27;m seeing frames loaded under 350ms. I would have guessed much faster, but I guess the devtools don&#x27;t lie.</div><br/><div id="36794586" class="c"><input type="checkbox" id="c-36794586" checked=""/><div class="controls bullet"><span class="by">esrauch</span><span>|</span><a href="#36793268">root</a><span>|</span><a href="#36793756">parent</a><span>|</span><a href="#36794863">next</a><span>|</span><label class="collapse" for="c-36794586">[-]</label><label class="expand" for="c-36794586">[1 more]</label></div><br/><div class="children"><div class="content">I think devtools can lie in the sense that it can be slower when devtools is open in some circumstances.</div><br/></div></div><div id="36794863" class="c"><input type="checkbox" id="c-36794863" checked=""/><div class="controls bullet"><span class="by">lelandfe</span><span>|</span><a href="#36793268">root</a><span>|</span><a href="#36793756">parent</a><span>|</span><a href="#36794586">prev</a><span>|</span><a href="#36793481">next</a><span>|</span><label class="collapse" for="c-36794863">[-]</label><label class="expand" for="c-36794863">[1 more]</label></div><br/><div class="children"><div class="content">PageSpeed Insights tests on a slow internet connection and an underpowered device</div><br/></div></div></div></div></div></div></div></div><div id="36793481" class="c"><input type="checkbox" id="c-36793481" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#36793268">parent</a><span>|</span><a href="#36793390">prev</a><span>|</span><a href="#36796754">next</a><span>|</span><label class="collapse" for="c-36793481">[-]</label><label class="expand" for="c-36793481">[1 more]</label></div><br/><div class="children"><div class="content">Served from a service worker after the first load</div><br/></div></div></div></div><div id="36796754" class="c"><input type="checkbox" id="c-36796754" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#36793268">prev</a><span>|</span><a href="#36792303">next</a><span>|</span><label class="collapse" for="c-36796754">[-]</label><label class="expand" for="c-36796754">[3 more]</label></div><br/><div class="children"><div class="content">Why can&#x27;t we just use Model-View-Controller for change-detection?<p>Views subscribe with the model to get notifications about changes to different &quot;aspects&quot; of the model.  When they get a change-notification they update themselves by asking the model for its latest data for a given aspect.</div><br/><div id="36797094" class="c"><input type="checkbox" id="c-36797094" checked=""/><div class="controls bullet"><span class="by">mickael-kerjean</span><span>|</span><a href="#36796754">parent</a><span>|</span><a href="#36797494">next</a><span>|</span><label class="collapse" for="c-36797094">[-]</label><label class="expand" for="c-36797094">[1 more]</label></div><br/><div class="children"><div class="content">This is precisely the approach I started on taking to rewrite my oss frontend stuff: <a href="https:&#x2F;&#x2F;github.com&#x2F;mickael-kerjean&#x2F;filestash&#x2F;blob&#x2F;master&#x2F;public&#x2F;pages&#x2F;adminpage&#x2F;decorator_admin_only.js#L31">https:&#x2F;&#x2F;github.com&#x2F;mickael-kerjean&#x2F;filestash&#x2F;blob&#x2F;master&#x2F;pub...</a></div><br/></div></div><div id="36797494" class="c"><input type="checkbox" id="c-36797494" checked=""/><div class="controls bullet"><span class="by">vmware513</span><span>|</span><a href="#36796754">parent</a><span>|</span><a href="#36797094">prev</a><span>|</span><a href="#36792303">next</a><span>|</span><label class="collapse" for="c-36797494">[-]</label><label class="expand" for="c-36797494">[1 more]</label></div><br/><div class="children"><div class="content">It is Ember.js, beautifully solving this problem since 2012.</div><br/></div></div></div></div><div id="36792303" class="c"><input type="checkbox" id="c-36792303" checked=""/><div class="controls bullet"><span class="by">rubymamis</span><span>|</span><a href="#36796754">prev</a><span>|</span><a href="#36792395">next</a><span>|</span><label class="collapse" for="c-36792303">[-]</label><label class="expand" for="c-36792303">[9 more]</label></div><br/><div class="children"><div class="content">QML wins with bindings and signal and slots! (In this example the the <i>text</i> property of the Text componenet is binded to <i>count</i>, so whenever count changes the text changes).<p>```<p>property int count: 0<p>Button { onClicked: { count--; } }<p>Text { text: count.toString(); }<p>Button { onClicked: { count--; } }<p>Button { onClicked: { incrementLater.start(); } }<p>Timer { id:incrementLater interval: 1000 onTriggered: { count++; } }<p>```<p>Better in so many ways.</div><br/><div id="36795764" class="c"><input type="checkbox" id="c-36795764" checked=""/><div class="controls bullet"><span class="by">onsclom</span><span>|</span><a href="#36792303">parent</a><span>|</span><a href="#36795655">next</a><span>|</span><label class="collapse" for="c-36795764">[-]</label><label class="expand" for="c-36795764">[7 more]</label></div><br/><div class="children"><div class="content">Having used both QML and Svelte, I enjoy Svelte a lot more. The reactive APIs are very similar, just declare variables, mutate them, and use them. But Svelte is much nicer for many reasons:<p>1. It uses modern JavaScript and not some limited custom ES5-like JavaScript<p>2. Svelte can be used with TypeScript so your UI code can be statically typed<p>3. The integration with Svelte and VSCode is much better than QML and Qt Creator (the big thing is that IntelliSense is much better at analyzing JavaScript code than whatever Qt Creator uses)<p>4. Having an actual live reloading dev server is so much nicer than compiling and running for every change<p>5. Svelte has much better documentation than QML<p>These are just the first things that came to mind, but I could probably keep going for a while. Do you think I&#x27;m being unfair to QML? And&#x2F;or have you used Svelte?</div><br/><div id="36797053" class="c"><input type="checkbox" id="c-36797053" checked=""/><div class="controls bullet"><span class="by">rubymamis</span><span>|</span><a href="#36792303">root</a><span>|</span><a href="#36795764">parent</a><span>|</span><a href="#36796615">next</a><span>|</span><label class="collapse" for="c-36797053">[-]</label><label class="expand" for="c-36797053">[2 more]</label></div><br/><div class="children"><div class="content">1. Yes, but I never found it limiting. If I need to write some complex logic I mostly do it on the C++ side (that&#x27;s should probably be the best way anyway).<p>2. True.<p>3. Yes, Qt Creator is very lacking in that department. There are many instances where it doesn&#x27;t recognize certain commands and you need to guess if you&#x27;re writing correctly or not.<p>4. Live reloading is possible in QML. See[1] (But this should definitely be the default in Qt Creator).<p>5. I agree that QML documentation is lacking. That&#x27;s probably my biggest pain point. Some of the examples also use deprecated&#x2F;bad-practice code which is annoying (eg, using that magic `index` property rather than defining it as a required property.<p>I think you have fair points. I actually have a doc with similar things that QML needs to improve in. I never tried Svelte but I&#x27;m familiar with React, and I must say that Qt&#x2F;QML is a breath of fresh air after using React. Developing in React always felt hacky like using duct tape and glue compared to building something properly which QML&#x2F;QT feels like.<p>Apart from the points above, I still think QML has been great for my productivity and I&#x27;m impressed how easy it is to develop with it complex UIs easily. I&#x27;ve been developing a feature in my Qt C++ app in QML that turns Markdown tasks into Kanban[2]. It worked out perfectly. The tasks processing is done in C++ which sends the data to QML.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;patrickelectric&#x2F;qhot#integrate-in-qtcreator">https:&#x2F;&#x2F;github.com&#x2F;patrickelectric&#x2F;qhot#integrate-in-qtcreat...</a><p>[2] <a href="https:&#x2F;&#x2F;i.imgur.com&#x2F;C1O4Nbu.gif" rel="nofollow noreferrer">https:&#x2F;&#x2F;i.imgur.com&#x2F;C1O4Nbu.gif</a></div><br/><div id="36797698" class="c"><input type="checkbox" id="c-36797698" checked=""/><div class="controls bullet"><span class="by">onsclom</span><span>|</span><a href="#36792303">root</a><span>|</span><a href="#36797053">parent</a><span>|</span><a href="#36796615">next</a><span>|</span><label class="collapse" for="c-36797698">[-]</label><label class="expand" for="c-36797698">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the thoughtful response. It&#x27;s interesting hearing from someone who actually likes Qt. I use both React and Qt&#x2F;QML for work, and I have a hard time enjoying the Qt&#x2F;QML work. Maybe I&#x27;m missing something or doing things wrong?<p>That reloading tool is cool, though its not quite as useful as modern dev servers. It seems like this simply restarts the app on every change, but modern dev servers remember your state too.<p>I&#x27;m curious to hear more about your React experiences. I don&#x27;t love React, but I still prefer React+TypeScript over Qt+QML. With TypeScript on the strictest setting, programs are much safer than with QML or Qt. We both know QML is very unsafe. And after using TypeScript and Rust, I&#x27;m realizing C++ is a very unsafe language too. It has unexpected nulls, memory leaks, seg faults, etc. I find C++ such a rough language to use, and that could be it&#x27;s own mega rant. Qt&#x27;s crazy macro system makes things even worse and generates some crazy errors.<p>There are so many options for building great cross platform UIs now. Tauri, Flutter, React Native, etc. Those all seem to have a better dev experience than Qt&#x2F;QML. If performance and safety are really important, then you can use Tauri and write your critical code in Rust. There are also UI frameworks for Rust popping up like Dioxus so you can write everything in Rust.<p>Your &quot;Better Notes&quot; app is amazing and that Kanban is looking amazing. Though, I feel like you&#x27;re a great dev making great stuff albeit Qt&#x2F;QML, not because of Qt&#x2F;QML.</div><br/></div></div></div></div><div id="36796615" class="c"><input type="checkbox" id="c-36796615" checked=""/><div class="controls bullet"><span class="by">em-bee</span><span>|</span><a href="#36792303">root</a><span>|</span><a href="#36795764">parent</a><span>|</span><a href="#36797053">prev</a><span>|</span><a href="#36795655">next</a><span>|</span><label class="collapse" for="c-36796615">[-]</label><label class="expand" for="c-36796615">[4 more]</label></div><br/><div class="children"><div class="content">how would the above QML example be implemented in svelte?</div><br/><div id="36796814" class="c"><input type="checkbox" id="c-36796814" checked=""/><div class="controls bullet"><span class="by">onsclom</span><span>|</span><a href="#36792303">root</a><span>|</span><a href="#36796615">parent</a><span>|</span><a href="#36795655">next</a><span>|</span><label class="collapse" for="c-36796814">[-]</label><label class="expand" for="c-36796814">[3 more]</label></div><br/><div class="children"><div class="content">This QML example is implementing the example from the article, and the article already implements this example in Svelte. However, the Svelte implementation becomes even more concise when you inline the functions:<p><pre><code>  &lt;script&gt;
   let count = 0
  &lt;&#x2F;script&gt;
  
  &lt;button on:click={()=&gt;count--}&gt;decrement&lt;&#x2F;button&gt;
  &lt;span&gt;{count}&lt;&#x2F;span&gt;
  &lt;button on:click={()=&gt;count++}&gt;increment&lt;&#x2F;button&gt;
  &lt;button on:click={()=&gt;setTimeout(()=&gt;count++, 1000)}&gt;
   increment later
  &lt;&#x2F;button&gt;
</code></pre>
Play with this in the Svelte REPL here: <a href="https:&#x2F;&#x2F;svelte.dev&#x2F;repl&#x2F;97d42ad98e4b4a929d3c5a3de880e6fc?version=4.1.0" rel="nofollow noreferrer">https:&#x2F;&#x2F;svelte.dev&#x2F;repl&#x2F;97d42ad98e4b4a929d3c5a3de880e6fc?ver...</a><p>Doing this, I also realized rubymamis cheated a good bit on their QML version. It&#x27;s missing the text for the buttons. It&#x27;s not wrapped in `ApplicationWindow { }`. And there&#x27;s a bug with their implementation: If you clicked their &quot;increment later&quot; button many times quickly then it would keep resetting the timer and only increment once.</div><br/><div id="36797126" class="c"><input type="checkbox" id="c-36797126" checked=""/><div class="controls bullet"><span class="by">rubymamis</span><span>|</span><a href="#36792303">root</a><span>|</span><a href="#36796814">parent</a><span>|</span><a href="#36795655">next</a><span>|</span><label class="collapse" for="c-36797126">[-]</label><label class="expand" for="c-36797126">[2 more]</label></div><br/><div class="children"><div class="content">Haha I was typing fast just to show the QML syntax. I don&#x27;t really think good code is about lower amount of lines, but rather more about &quot;making sense&quot;. And that&#x27;s what I tried to show.<p>Regarding the timer, so in your Svelte code a new timer is being created each time? I wonder how to implement the efficiently in QML. I don&#x27;t think it&#x27;s as straightforward.<p>EDIT: Probably the best way is to expose QTimer::singleShot (C++) in QML.</div><br/><div id="36797814" class="c"><input type="checkbox" id="c-36797814" checked=""/><div class="controls bullet"><span class="by">onsclom</span><span>|</span><a href="#36792303">root</a><span>|</span><a href="#36797126">parent</a><span>|</span><a href="#36795655">next</a><span>|</span><label class="collapse" for="c-36797814">[-]</label><label class="expand" for="c-36797814">[1 more]</label></div><br/><div class="children"><div class="content">Fair gotcha, yeah honestly I find QML to be super intuitive in the same way Svelte is super intuitive. It feels like two framework authors in very different worlds came to a similar conclusion.<p>&gt; Regarding the timer, so in your Svelte code a new timer is being created each time?<p>`setTimeout`[1] isn&#x27;t even a Svelte thing, it&#x27;s a JavaScript API that QML would have access to if it was real JavaScript ;).<p>[1] <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;setTimeout" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;setTimeout</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="36795655" class="c"><input type="checkbox" id="c-36795655" checked=""/><div class="controls bullet"><span class="by">em-bee</span><span>|</span><a href="#36792303">parent</a><span>|</span><a href="#36795764">prev</a><span>|</span><a href="#36792395">next</a><span>|</span><label class="collapse" for="c-36795655">[-]</label><label class="expand" for="c-36795655">[1 more]</label></div><br/><div class="children"><div class="content">you can do the same in aurelia:<p>counter.html:<p><pre><code>    &lt;template&gt;
      &lt;div&gt;${count}&lt;&#x2F;div&gt;
      &lt;input type=&quot;text&quot; value.bind=&quot;count&quot; &#x2F;&gt;
      &lt;button click.delegate=&quot;inc()&quot;&gt;add one&lt;&#x2F;button&gt;
      &lt;button click.delegate=&quot;counter--&quot;&gt;subtract one&lt;&#x2F;button&gt;
    &lt;&#x2F;template&gt;
</code></pre>
counter.js:<p><pre><code>    export class Counter {
        constructor() {
            this.counter = 0
        }

        inc() {
            this.counter++
        }
    }</code></pre></div><br/></div></div></div></div><div id="36792395" class="c"><input type="checkbox" id="c-36792395" checked=""/><div class="controls bullet"><span class="by">austin-cheney</span><span>|</span><a href="#36792303">prev</a><span>|</span><a href="#36792621">next</a><span>|</span><label class="collapse" for="c-36792395">[-]</label><label class="expand" for="c-36792395">[8 more]</label></div><br/><div class="children"><div class="content">That is putting the cart before the horse.  Frameworks solve for a fundamental business problem well before ever approaching any technical problems.  A front-end framework is an architecture in a box, a pre-designed composition.  There are a couple of business reasons for that:<p>1) Provides a common externally defined abstraction, so that developers require less training and are more disposable.<p>2) Supplement skills of unskilled developers<p>The reason frameworks do not primarily solve for change detection, is because the browsers already provide that.  Frameworks provide an additional solution riding on the browser&#x27;s solution as an abstraction.  Framework don&#x27;t even really solve for a common set of standards either, because the browser provides that too.  I really want to say that major frameworks provide for a more narrowly construed set of APIs and design approaches, but the APIs on modern frameworks are absolutely massive, so I cannot say that either.<p>So... frameworks are really just an abstraction to achieve a particular design approach, whether good or bad.</div><br/><div id="36792458" class="c"><input type="checkbox" id="c-36792458" checked=""/><div class="controls bullet"><span class="by">whatshisface</span><span>|</span><a href="#36792395">parent</a><span>|</span><a href="#36792621">next</a><span>|</span><label class="collapse" for="c-36792458">[-]</label><label class="expand" for="c-36792458">[7 more]</label></div><br/><div class="children"><div class="content">3) Saves you from having to rewrite dataflow and state management code with every project. (Saving time is a business factor.)</div><br/><div id="36792514" class="c"><input type="checkbox" id="c-36792514" checked=""/><div class="controls bullet"><span class="by">austin-cheney</span><span>|</span><a href="#36792395">root</a><span>|</span><a href="#36792458">parent</a><span>|</span><a href="#36792621">next</a><span>|</span><label class="collapse" for="c-36792514">[-]</label><label class="expand" for="c-36792514">[6 more]</label></div><br/><div class="children"><div class="content">Those are trivial to solve for and then once you do solve for it its just a matter of copy&#x2F;paste from project to project with about 10 minutes of rewiring.  That costs dramatically less than spinning up a large framework project to project, but frameworks save on training time because most developers cannot solve for these problems on their own.</div><br/><div id="36792814" class="c"><input type="checkbox" id="c-36792814" checked=""/><div class="controls bullet"><span class="by">quest88</span><span>|</span><a href="#36792395">root</a><span>|</span><a href="#36792514">parent</a><span>|</span><a href="#36792791">next</a><span>|</span><label class="collapse" for="c-36792814">[-]</label><label class="expand" for="c-36792814">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;re describing an inhouse framework</div><br/><div id="36793501" class="c"><input type="checkbox" id="c-36793501" checked=""/><div class="controls bullet"><span class="by">austin-cheney</span><span>|</span><a href="#36792395">root</a><span>|</span><a href="#36792814">parent</a><span>|</span><a href="#36792791">next</a><span>|</span><label class="collapse" for="c-36793501">[-]</label><label class="expand" for="c-36793501">[3 more]</label></div><br/><div class="children"><div class="content">That is called Affirming the Consequent.  Something like:  all frameworks are composed of code so therefore all code eventually forms frameworks.  It&#x27;s a common form of nonsense.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Affirming_the_consequent" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Affirming_the_consequent</a></div><br/><div id="36794380" class="c"><input type="checkbox" id="c-36794380" checked=""/><div class="controls bullet"><span class="by">shigawire</span><span>|</span><a href="#36792395">root</a><span>|</span><a href="#36793501">parent</a><span>|</span><a href="#36792791">next</a><span>|</span><label class="collapse" for="c-36794380">[-]</label><label class="expand" for="c-36794380">[2 more]</label></div><br/><div class="children"><div class="content">What is the difference between code you&#x27;ve written that you use from project to project and a framework?<p>If it is just about the knowledge then wouldn&#x27;t it be valid to just gain that same knowledge about a framework?</div><br/><div id="36794878" class="c"><input type="checkbox" id="c-36794878" checked=""/><div class="controls bullet"><span class="by">austin-cheney</span><span>|</span><a href="#36792395">root</a><span>|</span><a href="#36794380">parent</a><span>|</span><a href="#36792791">next</a><span>|</span><label class="collapse" for="c-36794878">[-]</label><label class="expand" for="c-36794878">[1 more]</label></div><br/><div class="children"><div class="content">Component isolation.<p>* State management is merely a sum of few parts: a state artifact (a big object), a means to update that artifact, a place where that artifact is saved, and finally a function to apply state on page reload.  Its an isolated system.  If anything wishes to update state it just calls a function.<p>* GUI: A window system (a big function and a bunch of supporting functions for events), content, and events specific to types of content.<p>* File system: A call to the file system library from a user interaction, a library to recursively walk the file system on the back end, a messaging payload to communicate the requested file system details, a function to populate the file system data into DOM artifacts for user interaction.<p>And so on.<p>I prefer to work without frameworks because they execute far more slowly, get in the way of solving real problems (complexity), and they slow me down in writing&#x2F;testing code.  Writing applications isn&#x27;t about how to write code.  It&#x27;s about organization, flow control, and just connecting the dots between a problem and a solution.  Its the difference between repeating minimum literacy and writing an original inspiring novel.  Why would I think some giant abstraction would save me time or improve my code?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36792621" class="c"><input type="checkbox" id="c-36792621" checked=""/><div class="controls bullet"><span class="by">AceJohnny2</span><span>|</span><a href="#36792395">prev</a><span>|</span><a href="#36794692">next</a><span>|</span><label class="collapse" for="c-36792621">[-]</label><label class="expand" for="c-36792621">[6 more]</label></div><br/><div class="children"><div class="content">Offtopic:<p>The cursive italics are apparently a feature of the Victor Mono [1] font used for the full page. While it&#x27;d be amusing in Tumblr context (where cursive is used for hyperbolic emphasis), I can&#x27;t fathom why one would consider it in a code context, but to each their own...<p>You can change it (at least on Safari) by going into developer tools, clicking any node, and removing &quot;Victor Mono&quot; from --font-family<p>[1] <a href="https:&#x2F;&#x2F;rubjo.github.io&#x2F;victor-mono&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;rubjo.github.io&#x2F;victor-mono&#x2F;</a></div><br/><div id="36793704" class="c"><input type="checkbox" id="c-36793704" checked=""/><div class="controls bullet"><span class="by">8organicbits</span><span>|</span><a href="#36792621">parent</a><span>|</span><a href="#36794381">next</a><span>|</span><label class="collapse" for="c-36793704">[-]</label><label class="expand" for="c-36793704">[1 more]</label></div><br/><div class="children"><div class="content">One of the first things I do on a new browser install is to disable web fonts. I&#x27;ve never seen a site where they improve things, often they flicker in after page load, which is jarring.</div><br/></div></div><div id="36794381" class="c"><input type="checkbox" id="c-36794381" checked=""/><div class="controls bullet"><span class="by">andrewl-hn</span><span>|</span><a href="#36792621">parent</a><span>|</span><a href="#36793704">prev</a><span>|</span><a href="#36797199">next</a><span>|</span><label class="collapse" for="c-36794381">[-]</label><label class="expand" for="c-36794381">[1 more]</label></div><br/><div class="children"><div class="content">Victor is also an extremely narrow font. The author of the font motivates it as means to squeeze more code per line. Not only it would make longer lines more tolerable, but also for short lines it reduces the eye movement needed to scan the line.<p>However, I personally find the narrowness more tiring for the eyes to the point that it is even more distracting than the cursive.</div><br/></div></div><div id="36797199" class="c"><input type="checkbox" id="c-36797199" checked=""/><div class="controls bullet"><span class="by">timetraveller26</span><span>|</span><a href="#36792621">parent</a><span>|</span><a href="#36794381">prev</a><span>|</span><a href="#36792866">next</a><span>|</span><label class="collapse" for="c-36797199">[-]</label><label class="expand" for="c-36797199">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I would prefer my custom font with comic italics.</div><br/></div></div><div id="36792866" class="c"><input type="checkbox" id="c-36792866" checked=""/><div class="controls bullet"><span class="by">jbs55</span><span>|</span><a href="#36792621">parent</a><span>|</span><a href="#36797199">prev</a><span>|</span><a href="#36795009">next</a><span>|</span><label class="collapse" for="c-36792866">[-]</label><label class="expand" for="c-36792866">[1 more]</label></div><br/><div class="children"><div class="content">This also threw me off</div><br/></div></div><div id="36795009" class="c"><input type="checkbox" id="c-36795009" checked=""/><div class="controls bullet"><span class="by">dustingetz</span><span>|</span><a href="#36792621">parent</a><span>|</span><a href="#36792866">prev</a><span>|</span><a href="#36794692">next</a><span>|</span><label class="collapse" for="c-36795009">[-]</label><label class="expand" for="c-36795009">[1 more]</label></div><br/><div class="children"><div class="content">firefox reader mode; works on mobile too</div><br/></div></div></div></div><div id="36794692" class="c"><input type="checkbox" id="c-36794692" checked=""/><div class="controls bullet"><span class="by">ngFanboi45</span><span>|</span><a href="#36792621">prev</a><span>|</span><a href="#36793255">next</a><span>|</span><label class="collapse" for="c-36794692">[-]</label><label class="expand" for="c-36794692">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Angular’s change detection is a disaster. The developer gets two suboptimal choices: (1) the slow and naive default implementation, or the complexity of managing change detection manually.<p>This is completely wrong. The &quot;naive&quot; approach is the one you should always use, with the onpush strategy reserved for breaking certain cascading situations manually. But the default approach works perfectly fine, it is performant enough, and even more when compiled for production, as it runs only once (as compared to twice in the debug mode). The author is incorrectly assuming that the change detection is slow because it is automatic. That&#x27;s the entire point of the framework btw.</div><br/><div id="36797495" class="c"><input type="checkbox" id="c-36797495" checked=""/><div class="controls bullet"><span class="by">throw310822</span><span>|</span><a href="#36794692">parent</a><span>|</span><a href="#36795782">next</a><span>|</span><label class="collapse" for="c-36797495">[-]</label><label class="expand" for="c-36797495">[1 more]</label></div><br/><div class="children"><div class="content">Agree. That part reeks of &quot;that&#x27;s what I&#x27;ve heard somewhere, never bothered to check&quot;. I work daily on angular projects of reasonable complexity and the performance of the automatic change detection is perfectly fine.</div><br/></div></div><div id="36795782" class="c"><input type="checkbox" id="c-36795782" checked=""/><div class="controls bullet"><span class="by">jeremycarter</span><span>|</span><a href="#36794692">parent</a><span>|</span><a href="#36797495">prev</a><span>|</span><a href="#36793255">next</a><span>|</span><label class="collapse" for="c-36795782">[-]</label><label class="expand" for="c-36795782">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve never had an issue with the Angular change detection. Large scale projects, multiple teams touching a modular front end. Its a win!</div><br/></div></div></div></div><div id="36793255" class="c"><input type="checkbox" id="c-36793255" checked=""/><div class="controls bullet"><span class="by">jchook</span><span>|</span><a href="#36794692">prev</a><span>|</span><a href="#36793822">next</a><span>|</span><label class="collapse" for="c-36793255">[-]</label><label class="expand" for="c-36793255">[1 more]</label></div><br/><div class="children"><div class="content">VanJS[1] seems to have a somewhat different approach.<p>The entire framework is surprisingly simple and easy to understand. In benchmarks I&#x27;ve seen it perform well, even better than SolidJS.<p>1. <a href="https:&#x2F;&#x2F;vanjs.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;vanjs.org&#x2F;</a></div><br/></div></div><div id="36793822" class="c"><input type="checkbox" id="c-36793822" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#36793255">prev</a><span>|</span><a href="#36794853">next</a><span>|</span><label class="collapse" for="c-36793822">[-]</label><label class="expand" for="c-36793822">[2 more]</label></div><br/><div class="children"><div class="content">Svelte isn&#x27;t a strict win-win. It requires a compiler, and forks of JavaScript and HTML.<p>And it isn&#x27;t actually very different from React or Vue anyway, and in fact quite a bit more limited than Vue (not necessarily bad).<p>Saying:<p><pre><code>  “I’ll figure it out for you at compile time.” —Svelte
</code></pre>
is just a non-technical, basically non-meaningful statement.<p>You need to know _what_ it figures out exactly. What state and what state changes are observable? These things matter more than whether it&#x27;s done at compile time or runtime.<p>And I think the author is ascribing far more power &quot;compile time&quot; than what&#x27;s actually happening. Svelte is not doing some kind of sound data flow analysis on your JS code to figure out what could change and rewriting your code to be observable (something not really possible anyway). It&#x27;s using specific syntax conventions to make some variables into shallowly observable properties. And it adds &quot;store&quot; concept, which is more-or-less Signals as popularized in Solid, now Preact, and soon Lit and Angular.</div><br/><div id="36793838" class="c"><input type="checkbox" id="c-36793838" checked=""/><div class="controls bullet"><span class="by">lnenad</span><span>|</span><a href="#36793822">parent</a><span>|</span><a href="#36794853">next</a><span>|</span><label class="collapse" for="c-36793838">[-]</label><label class="expand" for="c-36793838">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Svelte isn&#x27;t a strict win-win. It requires a compiler, and forks of JavaScript and HTML.<p>These points weren&#x27;t touched upon by the author. He compared the frameworks from one perspective and one perspective only.</div><br/></div></div></div></div><div id="36794853" class="c"><input type="checkbox" id="c-36794853" checked=""/><div class="controls bullet"><span class="by">acaloiar</span><span>|</span><a href="#36793822">prev</a><span>|</span><a href="#36796233">next</a><span>|</span><label class="collapse" for="c-36794853">[-]</label><label class="expand" for="c-36794853">[2 more]</label></div><br/><div class="children"><div class="content">There are 10 types of front-end frameworks in this world; those that are htmx, and those that aren&#x27;t.</div><br/><div id="36797463" class="c"><input type="checkbox" id="c-36797463" checked=""/><div class="controls bullet"><span class="by">sgt</span><span>|</span><a href="#36794853">parent</a><span>|</span><a href="#36796233">next</a><span>|</span><label class="collapse" for="c-36797463">[-]</label><label class="expand" for="c-36797463">[1 more]</label></div><br/><div class="children"><div class="content">But nobody seems to use htmx. There&#x27;s a lot of momentum and eagerness in the frontend world to go full blown SPA because well.. that&#x27;s the thing that is done.</div><br/></div></div></div></div><div id="36796233" class="c"><input type="checkbox" id="c-36796233" checked=""/><div class="controls bullet"><span class="by">insin</span><span>|</span><a href="#36794853">prev</a><span>|</span><a href="#36795092">next</a><span>|</span><label class="collapse" for="c-36796233">[-]</label><label class="expand" for="c-36796233">[1 more]</label></div><br/><div class="children"><div class="content">Just leaving this here (typed without having to look it up) for anyone else who&#x27;s ever maintained large Angular app which got to a certain size and complexity before anyone _really_ understood what they were doing:<p>ExpressionChangedAfterItHasBeenCheckedError</div><br/></div></div><div id="36795092" class="c"><input type="checkbox" id="c-36795092" checked=""/><div class="controls bullet"><span class="by">rglover</span><span>|</span><a href="#36796233">prev</a><span>|</span><a href="#36796862">next</a><span>|</span><label class="collapse" for="c-36795092">[-]</label><label class="expand" for="c-36795092">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s another, often ignored differential factor for frameworks and that is ergonomics. All of the frameworks here require specific domain knowledge to pick up and understand. That knowledge typically involves confusing concepts (Svelte and Vue aren&#x27;t too bad here) that waste a ton of developer time just to wrap their head around [1]. When I look at Angular, it feels like one of those contortionist boxes at a magic show.<p>This is why I ended up building Joystick [2]. The amount of time I was wasting trying to reason through how a framework wanted me to do something vs. actually building what I wanted was driving me nuts (not to mention, having to watch people I was mentoring who had less experience struggle even more).<p>[1] Meaning, beyond a trivial interface, any sort of complex UI is often (not always) burdened by the framework&#x27;s lack of clear ergonomics. There&#x27;s a lot of having to learn &quot;why it did that&quot; in the way of getting stuff done.<p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;cheatcode&#x2F;joystick">https:&#x2F;&#x2F;github.com&#x2F;cheatcode&#x2F;joystick</a></div><br/></div></div><div id="36796862" class="c"><input type="checkbox" id="c-36796862" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#36795092">prev</a><span>|</span><a href="#36796926">next</a><span>|</span><label class="collapse" for="c-36796862">[-]</label><label class="expand" for="c-36796862">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps adrift a bit of the main topic, but curious if anyone with more than cursory experience with any of the mainstream browser front end frameworks and JavaFX could briefly compare and contrast them.<p>I do not consider myself a front end person, but I’m slowly getting more adept with FX, more so as a hobbyist than professional, but have no experience with the browser systems.</div><br/></div></div><div id="36796926" class="c"><input type="checkbox" id="c-36796926" checked=""/><div class="controls bullet"><span class="by">intellix</span><span>|</span><a href="#36796862">prev</a><span>|</span><a href="#36797458">next</a><span>|</span><label class="collapse" for="c-36796926">[-]</label><label class="expand" for="c-36796926">[1 more]</label></div><br/><div class="children"><div class="content">Stop arguing about which framework has a developer experience that you prefer and just use Qwik which is the only one that changes the playing field due to resumability.<p>You can argue over if you prefer React, Angular, Vue or Svelte but at the end of the day you&#x27;re still shipping 1-3mb bundles instead of 1kb and resuming</div><br/></div></div><div id="36797458" class="c"><input type="checkbox" id="c-36797458" checked=""/><div class="controls bullet"><span class="by">vmware513</span><span>|</span><a href="#36796926">prev</a><span>|</span><a href="#36792812">next</a><span>|</span><label class="collapse" for="c-36797458">[-]</label><label class="expand" for="c-36797458">[1 more]</label></div><br/><div class="children"><div class="content">The best change detection  framework is missing from the article. It is obviously Ember.js. It is just so elegant and simple.</div><br/></div></div><div id="36792812" class="c"><input type="checkbox" id="c-36792812" checked=""/><div class="controls bullet"><span class="by">ChrisArchitect</span><span>|</span><a href="#36797458">prev</a><span>|</span><a href="#36796485">next</a><span>|</span><label class="collapse" for="c-36792812">[-]</label><label class="expand" for="c-36792812">[6 more]</label></div><br/><div class="children"><div class="content">From June since no date on it<p>Shared by the dev <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36403909">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36403909</a></div><br/><div id="36792948" class="c"><input type="checkbox" id="c-36792948" checked=""/><div class="controls bullet"><span class="by">pmarreck</span><span>|</span><a href="#36792812">parent</a><span>|</span><a href="#36796485">next</a><span>|</span><label class="collapse" for="c-36792948">[-]</label><label class="expand" for="c-36792948">[5 more]</label></div><br/><div class="children"><div class="content">Technical blog posts without a date should be illegal</div><br/><div id="36793306" class="c"><input type="checkbox" id="c-36793306" checked=""/><div class="controls bullet"><span class="by">pc86</span><span>|</span><a href="#36792812">root</a><span>|</span><a href="#36792948">parent</a><span>|</span><a href="#36796485">next</a><span>|</span><label class="collapse" for="c-36793306">[-]</label><label class="expand" for="c-36793306">[4 more]</label></div><br/><div class="children"><div class="content">But how will I drive traffic to my evergreen course funnel with publication dates all over my articles?<p>The FA actually <i>doesn&#x27;t</i> do this, but a lot of things (including those that do very well on HN) do for exactly this reason.</div><br/><div id="36793447" class="c"><input type="checkbox" id="c-36793447" checked=""/><div class="controls bullet"><span class="by">exac</span><span>|</span><a href="#36792812">root</a><span>|</span><a href="#36793306">parent</a><span>|</span><a href="#36796485">next</a><span>|</span><label class="collapse" for="c-36793447">[-]</label><label class="expand" for="c-36793447">[3 more]</label></div><br/><div class="children"><div class="content">Using the current date for the article &#x2F;s<p>There must be a browser plugin that offers the date a website was first indexed.</div><br/><div id="36794505" class="c"><input type="checkbox" id="c-36794505" checked=""/><div class="controls bullet"><span class="by">pc86</span><span>|</span><a href="#36792812">root</a><span>|</span><a href="#36793447">parent</a><span>|</span><a href="#36793586">next</a><span>|</span><label class="collapse" for="c-36794505">[-]</label><label class="expand" for="c-36794505">[1 more]</label></div><br/><div class="children"><div class="content">I seem to recall a (non-technical) blog getting called out for basically generating a random date within the past month or so for a lot of its content, but that might just be a false memory.</div><br/></div></div><div id="36793586" class="c"><input type="checkbox" id="c-36793586" checked=""/><div class="controls bullet"><span class="by">pmarreck</span><span>|</span><a href="#36792812">root</a><span>|</span><a href="#36793447">parent</a><span>|</span><a href="#36794505">prev</a><span>|</span><a href="#36796485">next</a><span>|</span><label class="collapse" for="c-36793586">[-]</label><label class="expand" for="c-36793586">[1 more]</label></div><br/><div class="children"><div class="content">That’s a brilliant idea, if someone else hasn’t already implemented it</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36796485" class="c"><input type="checkbox" id="c-36796485" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#36792812">prev</a><span>|</span><a href="#36793237">next</a><span>|</span><label class="collapse" for="c-36796485">[-]</label><label class="expand" for="c-36796485">[1 more]</label></div><br/><div class="children"><div class="content">Surprised nobody, and the article, mentioned RiotJS. It&#x27;s maybe less framework and more library but, it is easy to make these little web-components. It&#x27;s also one of those setState and repaint types. My primary drivers is that is easy to bolt into existing projects - so one can gradually add more dynamic features without the mega-rewrite-all-at-once-to-new-tools dance.</div><br/></div></div><div id="36793237" class="c"><input type="checkbox" id="c-36793237" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#36796485">prev</a><span>|</span><a href="#36792038">next</a><span>|</span><label class="collapse" for="c-36793237">[-]</label><label class="expand" for="c-36793237">[2 more]</label></div><br/><div class="children"><div class="content">&gt; There are tons of blog posts on the internet about how frameworks differ and which one to pick for your next web project.<p>You can also just not pick one.<p>MDN is my anti-framework.</div><br/><div id="36793879" class="c"><input type="checkbox" id="c-36793879" checked=""/><div class="controls bullet"><span class="by">kaishiro</span><span>|</span><a href="#36793237">parent</a><span>|</span><a href="#36792038">next</a><span>|</span><label class="collapse" for="c-36793879">[-]</label><label class="expand" for="c-36793879">[1 more]</label></div><br/><div class="children"><div class="content">MDN has a great series of guides on front end frameworks :)
 <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Learn&#x2F;Tools_and_testing&#x2F;Client-side_JavaScript_frameworks" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Learn&#x2F;Tools_and_tes...</a></div><br/></div></div></div></div><div id="36792038" class="c"><input type="checkbox" id="c-36792038" checked=""/><div class="controls bullet"><span class="by">sublinear</span><span>|</span><a href="#36793237">prev</a><span>|</span><a href="#36793832">next</a><span>|</span><label class="collapse" for="c-36792038">[-]</label><label class="expand" for="c-36792038">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Instead, we’ll go directly to the crux of the main problem front-end frameworks set out to solve: change detection, meaning detecting changes to application state so that the UI can be updated accordingly. Change detection is the fundamental feature of front-end frameworks, and the framework authors’ solution to this one problem determines everything else about it: developer experience, user experience, API surface area, community satisfaction and involvement, etc., etc.<p>I disagree. Sure that&#x27;s at the core of how a framework is written, but all the developers really care about are the interfaces. The user doesn&#x27;t care at all unless it doesn&#x27;t work or is annoying to use.<p>If your interfaces are dictated by the way the event loop is written, there&#x27;s something wrong that needs to be decoupled. Events should be generic and interfaces should be arbitrary to what developers want.</div><br/><div id="36792236" class="c"><input type="checkbox" id="c-36792236" checked=""/><div class="controls bullet"><span class="by">phailhaus</span><span>|</span><a href="#36792038">parent</a><span>|</span><a href="#36793832">next</a><span>|</span><label class="collapse" for="c-36792236">[-]</label><label class="expand" for="c-36792236">[1 more]</label></div><br/><div class="children"><div class="content">Since it&#x27;s at the core of how a framework is written, it affects what the developers must handle and therefore the interfaces that are possible. If you know how a framework handles change detection, you already know something about the interface it must expose.</div><br/></div></div></div></div><div id="36793832" class="c"><input type="checkbox" id="c-36793832" checked=""/><div class="controls bullet"><span class="by">12_throw_away</span><span>|</span><a href="#36792038">prev</a><span>|</span><a href="#36794871">next</a><span>|</span><label class="collapse" for="c-36793832">[-]</label><label class="expand" for="c-36793832">[2 more]</label></div><br/><div class="children"><div class="content">Interesting to compare these with the results on the js-framework-benchmark page [1] (with the usual caveats about benchmarking). Without actually running the numbers, qualitatively it looks like there are 3 performance tiers: VanillaJS (fastest); Vue, Svelte and Elm (often close to vanilla); and Angular and React (sometimes comparable, sometimes much slower).<p>[1] <a href="https:&#x2F;&#x2F;krausest.github.io&#x2F;js-framework-benchmark&#x2F;current.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;krausest.github.io&#x2F;js-framework-benchmark&#x2F;current.ht...</a></div><br/><div id="36794847" class="c"><input type="checkbox" id="c-36794847" checked=""/><div class="controls bullet"><span class="by">ngFanboi45</span><span>|</span><a href="#36793832">parent</a><span>|</span><a href="#36794871">next</a><span>|</span><label class="collapse" for="c-36794847">[-]</label><label class="expand" for="c-36794847">[1 more]</label></div><br/><div class="children"><div class="content">Yep. The author is making a big leap by falling into the &quot;Angular slow&quot; meme. In my experience it isn&#x27;t, and it provides ease of use thanks to its bi-directional binding, as oposed to React&#x27;s unidirectional binding. It is not the champion of speed though, might be even the slower out of the box, but still fast enough.</div><br/></div></div></div></div><div id="36794871" class="c"><input type="checkbox" id="c-36794871" checked=""/><div class="controls bullet"><span class="by">zebracanevra</span><span>|</span><a href="#36793832">prev</a><span>|</span><a href="#36793547">next</a><span>|</span><label class="collapse" for="c-36794871">[-]</label><label class="expand" for="c-36794871">[1 more]</label></div><br/><div class="children"><div class="content">The React code in the article has a bug. If you click &quot;Increment later&quot;, then immediately click &quot;Decrement&quot;, the counter will go from 0, to -1, then erroneously to 1. To fix this, the code for the &quot;Increment later&quot; button should be `setTimeout(() =&gt; setCount(count =&gt; count + 1), 1000)`.<p>I don&#x27;t believe any of the other frameworks have this specific problem.</div><br/></div></div><div id="36793547" class="c"><input type="checkbox" id="c-36793547" checked=""/><div class="controls bullet"><span class="by">franey</span><span>|</span><a href="#36794871">prev</a><span>|</span><a href="#36792660">next</a><span>|</span><label class="collapse" for="c-36793547">[-]</label><label class="expand" for="c-36793547">[1 more]</label></div><br/><div class="children"><div class="content">It is something that distinguishes them, certainly. As someone who switched from using Vue to React at my day job, dev tooling &amp; editor support have been the things that stand out the most to me. React works well with Vite, which has helped make it easier to use, and I&#x27;ve been migrating projects away from Webpack + Jest to Vite + Vitest, which saves a lot of dependency maintenance. I definitely miss Vue 3&#x27;s VS Code extension when I work in React, though.</div><br/></div></div><div id="36792660" class="c"><input type="checkbox" id="c-36792660" checked=""/><div class="controls bullet"><span class="by">dezmou</span><span>|</span><a href="#36793547">prev</a><span>|</span><a href="#36793581">next</a><span>|</span><label class="collapse" for="c-36792660">[-]</label><label class="expand" for="c-36792660">[5 more]</label></div><br/><div class="children"><div class="content">React is not reactive at all, the &quot;state&quot; management is you calling a function &quot;setState&quot; to re-render the component.<p>And I find manual render very usefull and once you do it, you can have a global state as simple as a global object, no need to use useState anymore.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;dezmou&#x2F;useRender">https:&#x2F;&#x2F;github.com&#x2F;dezmou&#x2F;useRender</a></div><br/><div id="36796840" class="c"><input type="checkbox" id="c-36796840" checked=""/><div class="controls bullet"><span class="by">Capricorn2481</span><span>|</span><a href="#36792660">parent</a><span>|</span><a href="#36793675">next</a><span>|</span><label class="collapse" for="c-36796840">[-]</label><label class="expand" for="c-36796840">[2 more]</label></div><br/><div class="children"><div class="content">The reactive part is every component getting that prop will update versus needing to write a function in jQuery to manually update the inner HTML of those components</div><br/><div id="36797517" class="c"><input type="checkbox" id="c-36797517" checked=""/><div class="controls bullet"><span class="by">dezmou</span><span>|</span><a href="#36792660">root</a><span>|</span><a href="#36796840">parent</a><span>|</span><a href="#36793675">next</a><span>|</span><label class="collapse" for="c-36797517">[-]</label><label class="expand" for="c-36797517">[1 more]</label></div><br/><div class="children"><div class="content">States are scoped to a component, how &quot;every&quot; component that get the prop update ?</div><br/></div></div></div></div><div id="36793675" class="c"><input type="checkbox" id="c-36793675" checked=""/><div class="controls bullet"><span class="by">boringuser2</span><span>|</span><a href="#36792660">parent</a><span>|</span><a href="#36796840">prev</a><span>|</span><a href="#36793581">next</a><span>|</span><label class="collapse" for="c-36793675">[-]</label><label class="expand" for="c-36793675">[2 more]</label></div><br/><div class="children"><div class="content">This is extremely inadvisable for numerous reasons and goes against the entire design philosophy of React.<p>In short, injecting a naive render function over the react virtual dom calculation is wildly inefficient.</div><br/><div id="36794050" class="c"><input type="checkbox" id="c-36794050" checked=""/><div class="controls bullet"><span class="by">dezmou</span><span>|</span><a href="#36792660">root</a><span>|</span><a href="#36793675">parent</a><span>|</span><a href="#36793581">next</a><span>|</span><label class="collapse" for="c-36794050">[-]</label><label class="expand" for="c-36794050">[1 more]</label></div><br/><div class="children"><div class="content">This piece of code only rerender the component as if you do a setState, in fact it does a setState under the hood, maybe the word &quot;render&quot; is missleading.</div><br/></div></div></div></div></div></div><div id="36793581" class="c"><input type="checkbox" id="c-36793581" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#36792660">prev</a><span>|</span><a href="#36795856">next</a><span>|</span><label class="collapse" for="c-36793581">[-]</label><label class="expand" for="c-36793581">[1 more]</label></div><br/><div class="children"><div class="content">There is only one important factor: the frameworks others wrote, and the ones you wrote yourself.</div><br/></div></div><div id="36795856" class="c"><input type="checkbox" id="c-36795856" checked=""/><div class="controls bullet"><span class="by">ChicagoDave</span><span>|</span><a href="#36793581">prev</a><span>|</span><a href="#36792199">next</a><span>|</span><label class="collapse" for="c-36795856">[-]</label><label class="expand" for="c-36795856">[1 more]</label></div><br/><div class="children"><div class="content">The op forgot to tell you that if you use React, you have to add a slew of 3rd party libraries to make it work and no one tests every combo. This is called “unopinionated”.<p>Angular is “opinionated” in that you don’t need to add anything. It definitely has a higher learning curve, but from an enterprise perspective, it’s a safer tool.<p>And if you have so many things on a web page that performance is a problem, then I’d suggest you need a better user experience. You should never have a design that overwhelms the framework.</div><br/></div></div><div id="36792199" class="c"><input type="checkbox" id="c-36792199" checked=""/><div class="controls bullet"><span class="by">croes</span><span>|</span><a href="#36795856">prev</a><span>|</span><label class="collapse" for="c-36792199">[-]</label><label class="expand" for="c-36792199">[2 more]</label></div><br/><div class="children"><div class="content">What about Solid.JS?</div><br/><div id="36792754" class="c"><input type="checkbox" id="c-36792754" checked=""/><div class="controls bullet"><span class="by">grayrest</span><span>|</span><a href="#36792199">parent</a><span>|</span><label class="collapse" for="c-36792754">[-]</label><label class="expand" for="c-36792754">[1 more]</label></div><br/><div class="children"><div class="content">Solid works differently in that the output is implemented as a side effect of a subscription to a piece of state. Simplified, think of a signal as an event emitter and a variable with a getter and a setter. Using the getter adds its downstream effects–most notably adding&#x2F;modifying DOM nodes–as an event listener. Using the setter updates the state and triggers the event listeners.<p>Most other frameworks here (all? not sure about Vue) will invalidate and rebuild an entire component subtree if a piece of state in them changes. The solid runtime doesn&#x27;t care about components so changing a piece of state high in a subtree will only update the piece of the DOM directly depending on that state and not any nodes that were authored as sub-components.</div><br/></div></div></div></div></div></div></div></div></div></body></html>