<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737882065672" as="style"/><link rel="stylesheet" href="styles.css?v=1737882065672"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.cidrdb.org/cidr2015/Papers/CIDR15_Paper16.pdf">Immutability Changes Everything (2016) [pdf]</a> <span class="domain">(<a href="https://www.cidrdb.org">www.cidrdb.org</a>)</span></div><div class="subtext"><span>fire_lake</span> | <span>27 comments</span></div><br/><div><div id="42826787" class="c"><input type="checkbox" id="c-42826787" checked=""/><div class="controls bullet"><span class="by">gatane</span><span>|</span><a href="#42825732">next</a><span>|</span><label class="collapse" for="c-42826787">[-]</label><label class="expand" for="c-42826787">[11 more]</label></div><br/><div class="children"><div class="content">My main gripe with immutability is that making updated data requires building a full copy of the data again with the changes. Sure, you could have zippers to aid in the updating process by acting as a kind of cursor&#x2F;pointer, but raw access to data beats them anytime (even if you optimize for cache).<p>So if you had to optimize for raw speed, why not choose mutable data?<p><a href="https:&#x2F;&#x2F;ksvi.mff.cuni.cz&#x2F;~sefl&#x2F;papers&#x2F;zippers.pdf" rel="nofollow">https:&#x2F;&#x2F;ksvi.mff.cuni.cz&#x2F;~sefl&#x2F;papers&#x2F;zippers.pdf</a></div><br/><div id="42827028" class="c"><input type="checkbox" id="c-42827028" checked=""/><div class="controls bullet"><span class="by">dsQTbR7Y5mRHnZv</span><span>|</span><a href="#42826787">parent</a><span>|</span><a href="#42828649">next</a><span>|</span><label class="collapse" for="c-42827028">[-]</label><label class="expand" for="c-42827028">[1 more]</label></div><br/><div class="children"><div class="content">&gt; My main gripe with immutability is that making updated data requires building a full copy of the data again with the changes.<p>Conceptually yes, but the implementation doesn&#x27;t always necessarily need to work that way under the hood: <a href="https:&#x2F;&#x2F;www.roc-lang.org&#x2F;functional#opportunistic-mutation" rel="nofollow">https:&#x2F;&#x2F;www.roc-lang.org&#x2F;functional#opportunistic-mutation</a></div><br/></div></div><div id="42828649" class="c"><input type="checkbox" id="c-42828649" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42826787">parent</a><span>|</span><a href="#42827028">prev</a><span>|</span><a href="#42827197">next</a><span>|</span><label class="collapse" for="c-42828649">[-]</label><label class="expand" for="c-42828649">[1 more]</label></div><br/><div class="children"><div class="content">Someone should try it with postgres.  Make a raw speed branch that gets rid of the overhead of mvcc:<p><pre><code>  while querying a database each transaction sees a snapshot of data (a database version) as it was some time ago, regardless of the current state of the underlying data

  https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;7.1&#x2F;mvcc.html</code></pre></div><br/></div></div><div id="42827197" class="c"><input type="checkbox" id="c-42827197" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#42826787">parent</a><span>|</span><a href="#42828649">prev</a><span>|</span><a href="#42827503">next</a><span>|</span><label class="collapse" for="c-42827197">[-]</label><label class="expand" for="c-42827197">[7 more]</label></div><br/><div class="children"><div class="content">&gt; My main gripe with immutability is that making updated data requires building a full copy of the data again with the changes.<p>That is not true in general. There are plenty of data structures that can be updated without forcing a full copy. Lists, trees, sets, maps, etc. All of these are common in functional programming. This is discussed in the article (e.g. &quot;Append-Only Computing&quot;).</div><br/><div id="42827402" class="c"><input type="checkbox" id="c-42827402" checked=""/><div class="controls bullet"><span class="by">sarchertech</span><span>|</span><a href="#42826787">root</a><span>|</span><a href="#42827197">parent</a><span>|</span><a href="#42827503">next</a><span>|</span><label class="collapse" for="c-42827402">[-]</label><label class="expand" for="c-42827402">[6 more]</label></div><br/><div class="children"><div class="content">If you really care about performance, iterating over all of those is going to much much slower than iterating over an array.</div><br/><div id="42827422" class="c"><input type="checkbox" id="c-42827422" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#42826787">root</a><span>|</span><a href="#42827402">parent</a><span>|</span><a href="#42827503">next</a><span>|</span><label class="collapse" for="c-42827422">[-]</label><label class="expand" for="c-42827422">[5 more]</label></div><br/><div class="children"><div class="content">If you really care about multi-threading, mutating array elements is going to be much buggier than using an immutable data structure.</div><br/><div id="42828274" class="c"><input type="checkbox" id="c-42828274" checked=""/><div class="controls bullet"><span class="by">MrJohz</span><span>|</span><a href="#42826787">root</a><span>|</span><a href="#42827422">parent</a><span>|</span><a href="#42827492">next</a><span>|</span><label class="collapse" for="c-42828274">[-]</label><label class="expand" for="c-42828274">[2 more]</label></div><br/><div class="children"><div class="content">Unless you encode ownership into the type system, and then you kind of have the best of both worlds: you don&#x27;t have functions mutating things unexpectedly or by accident, but you can explicitly opt into mutation when it would be beneficial. To opt into mutation requires you to have exclusive control over data (i.e. nowhere else in your program will mutate this code at the same time), which avoids issues where different threads are trying to change the same data at the same time.</div><br/><div id="42828585" class="c"><input type="checkbox" id="c-42828585" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42826787">root</a><span>|</span><a href="#42828274">parent</a><span>|</span><a href="#42827492">next</a><span>|</span><label class="collapse" for="c-42828585">[-]</label><label class="expand" for="c-42828585">[1 more]</label></div><br/><div class="children"><div class="content">Requiring exclusive ownership avoids the issues, but it also avoids the features.<p>Sometimes you actually do want multiple threads working with data.</div><br/></div></div></div></div><div id="42827492" class="c"><input type="checkbox" id="c-42827492" checked=""/><div class="controls bullet"><span class="by">sarchertech</span><span>|</span><a href="#42826787">root</a><span>|</span><a href="#42827422">parent</a><span>|</span><a href="#42828274">prev</a><span>|</span><a href="#42827503">next</a><span>|</span><label class="collapse" for="c-42827492">[-]</label><label class="expand" for="c-42827492">[2 more]</label></div><br/><div class="children"><div class="content">Well sure but the OP wrote<p>&gt;if you had to optimize for raw speed, why not choose mutable data?<p>So in context we are talking about a case where we have to optimize for raw speed.<p>It doesn’t matter that immutable data is easier to reason about if you don’t have the performance budget to go that route.</div><br/><div id="42828286" class="c"><input type="checkbox" id="c-42828286" checked=""/><div class="controls bullet"><span class="by">reubenmorais</span><span>|</span><a href="#42826787">root</a><span>|</span><a href="#42827492">parent</a><span>|</span><a href="#42827503">next</a><span>|</span><label class="collapse" for="c-42828286">[-]</label><label class="expand" for="c-42828286">[1 more]</label></div><br/><div class="children"><div class="content">Raw speed these days means concurrent processing, so those two are more and more often the same case. The whole &quot;rewrite it in Rust&quot; trend is a very clear example of the benefits of easier correctness of concurrent programming - Rust programs end up being faster than other alternatives even though on paper C has better &quot;raw speed&quot; (e.g. no bounds checking).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42827503" class="c"><input type="checkbox" id="c-42827503" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#42826787">parent</a><span>|</span><a href="#42827197">prev</a><span>|</span><a href="#42825732">next</a><span>|</span><label class="collapse" for="c-42827503">[-]</label><label class="expand" for="c-42827503">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;356635.356640" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;356635.356640</a></div><br/></div></div></div></div><div id="42825732" class="c"><input type="checkbox" id="c-42825732" checked=""/><div class="controls bullet"><span class="by">LeftHandPath</span><span>|</span><a href="#42826787">prev</a><span>|</span><a href="#42825559">next</a><span>|</span><label class="collapse" for="c-42825732">[-]</label><label class="expand" for="c-42825732">[7 more]</label></div><br/><div class="children"><div class="content">Immutability is a fantastic tool, especially when working with enterprise data. It&#x27;s relatively easy to implement your own temporal tables on most existing databases, no special libraries or tools required. It seems really trivial&#x2F;obvious, but I&#x27;ll admit I first stumbled into the concept using the AS400 at work. If you make a mistake on payroll in IBM&#x27;s old MAPICS program, you don&#x27;t overwrite or delete it. You introduce a new &quot;backout record&quot; to nullify it, then (maybe) insert another record with the correct data. It seems obvious once you&#x27;ve seen the pattern.<p>I&#x27;ve made a few non-technical eyes go wide by explaining A) that this is done and B) how it is done. The non-tech crypto&#x2F;blockchain enthusiasts I&#x27;ve met get really excited when they learn you can make a set of data immutable <i>without</i> blockchain &#x2F; merkle trees. Actually, explaining that is a good way to introduce the concept of a merkle tree &#x2F; distributed ledger, and why &quot;blockchain&quot; is specifically for systems without a central authority.<p>(Bi)Temporal and immutable tables are especially useful for things like HR, PTO, employee clock activity, etc. Helps keep things auditable and correct.</div><br/><div id="42827000" class="c"><input type="checkbox" id="c-42827000" checked=""/><div class="controls bullet"><span class="by">teleforce</span><span>|</span><a href="#42825732">parent</a><span>|</span><a href="#42826553">next</a><span>|</span><label class="collapse" for="c-42827000">[-]</label><label class="expand" for="c-42827000">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Actually, explaining that is a good way to introduce the concept of a merkle tree &#x2F; distributed ledger, and why &quot;blockchain&quot; is specifically for systems without a central authority<p>This is a very important points, for whatever systems or solutions that you do, do not overengineer and always remember premature optimization is the root of all evil.<p>It used to be blockchain and it seems apparently ML&#x2F;AI is the new fad. Most probably majority of the solutions being design now with ML&#x2F;AI does not need it and in doing so just make it expensive&#x2F;slow&#x2F;complex&#x2F;non-deterministic&#x2F;etc.<p>People need to wake up and smell the coffee, since ultimately ML&#x2F;AL it just a tool inside the many tools toolbox.</div><br/></div></div><div id="42826553" class="c"><input type="checkbox" id="c-42826553" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42825732">parent</a><span>|</span><a href="#42827000">prev</a><span>|</span><a href="#42825950">next</a><span>|</span><label class="collapse" for="c-42826553">[-]</label><label class="expand" for="c-42826553">[2 more]</label></div><br/><div class="children"><div class="content">Without specific support from the RDBMS, bitemporal schemas are difficult with regard to cross-table references, such as foreign keys. Rows that need to be consistent between tables aren’t necessarily 1:1 anymore, but instead each row in one table needs to be consistent with all corresponding rows in the other table having an intersecting time interval. You then run into problems with transaction isolation and visibility.</div><br/><div id="42827087" class="c"><input type="checkbox" id="c-42827087" checked=""/><div class="controls bullet"><span class="by">hobs</span><span>|</span><a href="#42825732">root</a><span>|</span><a href="#42826553">parent</a><span>|</span><a href="#42825950">next</a><span>|</span><label class="collapse" for="c-42827087">[-]</label><label class="expand" for="c-42827087">[1 more]</label></div><br/><div class="children"><div class="content">Pretty much, you want triggers to store things in a schemaless fashion in an audit format so that you are free to migrate tables.<p>This does require either knowing the schema at the point in time or recording enough information to do a schema on read.<p>The other options are of course you basically run a table like an API, always adding, never removing.</div><br/></div></div></div></div><div id="42825950" class="c"><input type="checkbox" id="c-42825950" checked=""/><div class="controls bullet"><span class="by">refset</span><span>|</span><a href="#42825732">parent</a><span>|</span><a href="#42826553">prev</a><span>|</span><a href="#42827915">next</a><span>|</span><label class="collapse" for="c-42825950">[-]</label><label class="expand" for="c-42825950">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s relatively easy to implement your own temporal tables on most existing databases<p>It gets tricky when you need to change the schema without breaking historical data or queries. SQL databases could do a lot more to make immutability easier and widespread.</div><br/><div id="42826609" class="c"><input type="checkbox" id="c-42826609" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#42825732">root</a><span>|</span><a href="#42825950">parent</a><span>|</span><a href="#42827915">next</a><span>|</span><label class="collapse" for="c-42826609">[-]</label><label class="expand" for="c-42826609">[1 more]</label></div><br/><div class="children"><div class="content">One fundamental issue I’ve noticed is that typical SQL databases have a single schema per table defining both the logical and physical aspects, typically with a strong correlation between the two.<p>Databases could treat the columns as the fundamental unit with tables being not much more than a view of a bunch of columns that can change over both space (partitioning) and time (history).</div><br/></div></div></div></div></div></div><div id="42825559" class="c"><input type="checkbox" id="c-42825559" checked=""/><div class="controls bullet"><span class="by">gleenn</span><span>|</span><a href="#42825732">prev</a><span>|</span><a href="#42824994">next</a><span>|</span><label class="collapse" for="c-42825559">[-]</label><label class="expand" for="c-42825559">[1 more]</label></div><br/><div class="children"><div class="content">I love the quote &quot;accountants don&#x27;t use erasers&quot;. So many things should be modeled over time and keep track of change right out the gate. Little things like Ruby on Rails always adding timestamps to model tables was super helpful but also a little code smell. If this is obvious enough to be useful everywhere, what is the next level? One more reason Datamoic is so cool: nothing is overwritten, it is overlayed with a newer record and you can always look back and you can always also always take a slice of the db at a specific time and have a complete and consistent viewbof the universe at that time. Immutability!</div><br/></div></div><div id="42824994" class="c"><input type="checkbox" id="c-42824994" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#42825559">prev</a><span>|</span><a href="#42827816">next</a><span>|</span><label class="collapse" for="c-42824994">[-]</label><label class="expand" for="c-42824994">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>Immutability Changes Everything (2016)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27640308">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27640308</a> - June 2021 (94 comments)<p><i>Immutability Changes Everything</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10953645">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10953645</a> - Jan 2016 (4 comments)<p><i>Immutability Changes Everything [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8955130">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8955130</a> - Jan 2015 (25 comments)<p>(Reposts are fine after a year or so; links to past threads are just to satisfy extra-curious readers)</div><br/></div></div><div id="42827816" class="c"><input type="checkbox" id="c-42827816" checked=""/><div class="controls bullet"><span class="by">niuzeta</span><span>|</span><a href="#42824994">prev</a><span>|</span><a href="#42825976">next</a><span>|</span><label class="collapse" for="c-42827816">[-]</label><label class="expand" for="c-42827816">[1 more]</label></div><br/><div class="children"><div class="content">Semi-related, but is there any repository(ies?) that comprise of these technical white papers? I&#x27;m fascinated by these papers whenever they show up in my feed and I gorge on them, and I&#x27;d love more. I can&#x27;t be the only one thinking this way.</div><br/></div></div><div id="42825976" class="c"><input type="checkbox" id="c-42825976" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#42827816">prev</a><span>|</span><a href="#42825752">next</a><span>|</span><label class="collapse" for="c-42825976">[-]</label><label class="expand" for="c-42825976">[1 more]</label></div><br/><div class="children"><div class="content">Editors and form validation are where this gets tricky. The user isn&#x27;t just reporting new, independent observations to append to a log. They&#x27;re looking at existing state and deciding how to react to it. Sometimes avoiding constraint violations with other state that they&#x27;re <i>not</i> looking at is also important.<p>It often works out, but if you&#x27;re not looking at the right version then you&#x27;re risking a merge conflict.</div><br/></div></div><div id="42825752" class="c"><input type="checkbox" id="c-42825752" checked=""/><div class="controls bullet"><span class="by">prydt</span><span>|</span><a href="#42825976">prev</a><span>|</span><a href="#42825080">next</a><span>|</span><label class="collapse" for="c-42825752">[-]</label><label class="expand" for="c-42825752">[1 more]</label></div><br/><div class="children"><div class="content">One of my favorite papers! This reminds me of Martin Kleppmann&#x27;s work on Apache Samza and the idea of &quot;turning the database inside out&quot; by hosting the write-ahead log on something like Kafka and then having many different materialized views consume that log.<p>Seems like a very powerful architecture that is both simple and decouples many concerns.</div><br/></div></div><div id="42825080" class="c"><input type="checkbox" id="c-42825080" checked=""/><div class="controls bullet"><span class="by">lbj</span><span>|</span><a href="#42825752">prev</a><span>|</span><a href="#42826813">next</a><span>|</span><label class="collapse" for="c-42825080">[-]</label><label class="expand" for="c-42825080">[2 more]</label></div><br/><div class="children"><div class="content">I have to say, I really love the title :)</div><br/><div id="42825518" class="c"><input type="checkbox" id="c-42825518" checked=""/><div class="controls bullet"><span class="by">cacozen</span><span>|</span><a href="#42825080">parent</a><span>|</span><a href="#42826813">next</a><span>|</span><label class="collapse" for="c-42825518">[-]</label><label class="expand" for="c-42825518">[1 more]</label></div><br/><div class="children"><div class="content">I guess “Immutability changes nothing” wouldn’t have the same impact</div><br/></div></div></div></div><div id="42826813" class="c"><input type="checkbox" id="c-42826813" checked=""/><div class="controls bullet"><span class="by">sstanfie</span><span>|</span><a href="#42825080">prev</a><span>|</span><label class="collapse" for="c-42826813">[-]</label><label class="expand" for="c-42826813">[1 more]</label></div><br/><div class="children"><div class="content">Needs more exclaimation points!</div><br/></div></div></div></div></div></div></div></body></html>