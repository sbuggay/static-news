<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1695373261159" as="style"/><link rel="stylesheet" href="styles.css?v=1695373261159"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-6/">Speeding up the JavaScript ecosystem – Polyfills gone rogue</a> <span class="domain">(<a href="https://marvinh.dev">marvinh.dev</a>)</span></div><div class="subtext"><span>jviide</span> | <span>91 comments</span></div><br/><div><div id="37603914" class="c"><input type="checkbox" id="c-37603914" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#37605459">next</a><span>|</span><label class="collapse" for="c-37603914">[-]</label><label class="expand" for="c-37603914">[9 more]</label></div><br/><div class="children"><div class="content">I maintain a few JavaScript libraries that I manually verify compatibility against IE6 (and have lints to catch violations). I manually polyfill a few necessities and quality-of-life improvements up top in the script. Out of curiosity, I removed my polyfills and tried swc and babel both, followed by an eslint pass, and the results were absolutely atrocious. Everything gets polyfilled, even stuff that has been supported in every IE version ever. The usage-based detection is completely borked, and is completely based off string searching property&#x2F;function names. Using toString() anywhere pulls in the polyfills for Date to string, Regex to string, and Object to string. Using regex anywhere pulls in a bunch of regex polyfills. It was a nightmare and the size of my library increased by orders of magnitude!<p>(I tried opening an swc issue about optionally using typescript ast info (via a plugin, not in swc core) to have more correct usage-based polyfill detection,  but that was closed as unlikely to be acted upon.)</div><br/><div id="37603943" class="c"><input type="checkbox" id="c-37603943" checked=""/><div class="controls bullet"><span class="by">mhagemeister</span><span>|</span><a href="#37603914">parent</a><span>|</span><a href="#37604821">next</a><span>|</span><label class="collapse" for="c-37603943">[-]</label><label class="expand" for="c-37603943">[2 more]</label></div><br/><div class="children"><div class="content">Author here.<p>That mirrors my experience too on working in various projects. The automatic polyfilling story is such a good thing in theory, but reality isn&#x27;t as rosy and much more polyfills than necessary are included.</div><br/><div id="37604002" class="c"><input type="checkbox" id="c-37604002" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#37603914">root</a><span>|</span><a href="#37603943">parent</a><span>|</span><a href="#37604821">next</a><span>|</span><label class="collapse" for="c-37604002">[-]</label><label class="expand" for="c-37604002">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for writing your article and sharing! One thing I do on my other libraries is also to polyfill a few heavier things asynchronously instead of making everyone pay the price upfront, so for example I detect if a JSON polyfill is required before asynchronously loading that polyfill. I think the expectation for most things is that the browser will support them by default, and it’s ok if all&#x2F;any polyfills are loaded separately and asynchronously.</div><br/></div></div></div></div><div id="37604821" class="c"><input type="checkbox" id="c-37604821" checked=""/><div class="controls bullet"><span class="by">H1Supreme</span><span>|</span><a href="#37603914">parent</a><span>|</span><a href="#37603943">prev</a><span>|</span><a href="#37606465">next</a><span>|</span><label class="collapse" for="c-37604821">[-]</label><label class="expand" for="c-37604821">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I maintain a few JavaScript libraries that I manually verify compatibility against IE6<p>Genuinely curious why anyone would target IE6 in 2023. Is it a personal goal to have massive coverage for your library?</div><br/><div id="37604937" class="c"><input type="checkbox" id="c-37604937" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#37603914">root</a><span>|</span><a href="#37604821">parent</a><span>|</span><a href="#37606465">next</a><span>|</span><label class="collapse" for="c-37604937">[-]</label><label class="expand" for="c-37604937">[1 more]</label></div><br/><div class="children"><div class="content">It was used in the checkout flow on our website and the marginal cost of supporting IE6 wasn’t worth a lost sale. That was many years ago, and since then I don’t think we have anyone on less than IE8 due to TLS version issues with CloudFront, but the code already supported IE6 and there aren’t many polyfills extra compared to IE10, so :shrug:</div><br/></div></div></div></div><div id="37606465" class="c"><input type="checkbox" id="c-37606465" checked=""/><div class="controls bullet"><span class="by">forgotmypw17</span><span>|</span><a href="#37603914">parent</a><span>|</span><a href="#37604821">prev</a><span>|</span><a href="#37604802">next</a><span>|</span><label class="collapse" for="c-37606465">[-]</label><label class="expand" for="c-37606465">[2 more]</label></div><br/><div class="children"><div class="content">Thank you for supporting IE6. I also maintain some JS and ensure compatibility with older browsers. Someone out there still wants to use it, whether it&#x27;s an old machine with nostalgic value, the only machine they happen to have available, or just retro-computing enthusiasts, and I take pride in accommodating them. Good on you.</div><br/><div id="37608074" class="c"><input type="checkbox" id="c-37608074" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#37603914">root</a><span>|</span><a href="#37606465">parent</a><span>|</span><a href="#37604802">next</a><span>|</span><label class="collapse" for="c-37608074">[-]</label><label class="expand" for="c-37608074">[1 more]</label></div><br/><div class="children"><div class="content">Since IE6 depends on the schannel implementation of the OS, it should not support neither TLS1.2 nor TLS 1.3. This means that it simply can&#x27;t access the modern web anymore. Maybe there are still webservers out there though that still support outdated SSL&#x2F;TLS versions and were never patched <i>shudder</i></div><br/></div></div></div></div><div id="37604802" class="c"><input type="checkbox" id="c-37604802" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#37603914">parent</a><span>|</span><a href="#37606465">prev</a><span>|</span><a href="#37605459">next</a><span>|</span><label class="collapse" for="c-37604802">[-]</label><label class="expand" for="c-37604802">[2 more]</label></div><br/><div class="children"><div class="content">Why are you supporting IE6?</div><br/><div id="37604956" class="c"><input type="checkbox" id="c-37604956" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#37603914">root</a><span>|</span><a href="#37604802">parent</a><span>|</span><a href="#37605459">next</a><span>|</span><label class="collapse" for="c-37604956">[-]</label><label class="expand" for="c-37604956">[1 more]</label></div><br/><div class="children"><div class="content">I replied to a sister comment to yours but it’s an old library that started off with IE6 support maybe 10 years ago and just kinda never lost it.</div><br/></div></div></div></div></div></div><div id="37605459" class="c"><input type="checkbox" id="c-37605459" checked=""/><div class="controls bullet"><span class="by">smallnamespace</span><span>|</span><a href="#37603914">prev</a><span>|</span><a href="#37604373">next</a><span>|</span><label class="collapse" for="c-37605459">[-]</label><label class="expand" for="c-37605459">[4 more]</label></div><br/><div class="children"><div class="content">The reason libraries call polyfills directly is because it&#x27;s impolite for a library to change global scope underneath you.<p>Usually it&#x27;s the top-level application&#x27;s author who chooses and configures polyfills.<p>Now one may reasonably ask, why doesn&#x27;t the library just call Object.defineProperties directly, and tell the user to install the appropriate polyfill?<p>I&#x27;m going to guess that a library that Just Works after an npm install will see much better adoption than one that requires each user to configure their babel&#x2F;swc&#x2F;etc. correctly, especially since the library can be a dependency of another library.<p>There&#x27;s currently no standardized mechanism in the npm ecosystem to do the equivalent of &quot;Install this library, and also configure your environment to pull in all required polyfills&quot; so that the required functionality is available in global scope. One reason is because the transpilers that automatically polyfill into global scope are third-party tools.<p>Maybe a standard mechanism like this <i>should</i> exist, but it doesn&#x27;t today, hence the quite reasonable choice of library authors to directly use polyfills because doing so:<p>1. Avoids pollute the global namespace by avoiding applying a polyfill globally<p>2. Works as a dependency without additional configuration by the user<p>3. Preserve backwards compatibility<p>A somewhat cheap fix to at least reduce duplication of polyfills would be for libraries that need polyfills to accept a wide version range. That would give the package manager room to pick a version that&#x27;s compatible across call sites.</div><br/><div id="37605599" class="c"><input type="checkbox" id="c-37605599" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#37605459">parent</a><span>|</span><a href="#37608131">next</a><span>|</span><label class="collapse" for="c-37605599">[-]</label><label class="expand" for="c-37605599">[2 more]</label></div><br/><div class="children"><div class="content">But why are we polyfilling a function that exists in every version of node? When did this code <i>not</i> just work after installation that it required a polyfill?</div><br/><div id="37605780" class="c"><input type="checkbox" id="c-37605780" checked=""/><div class="controls bullet"><span class="by">vinnymac</span><span>|</span><a href="#37605459">root</a><span>|</span><a href="#37605599">parent</a><span>|</span><a href="#37608131">next</a><span>|</span><label class="collapse" for="c-37605780">[-]</label><label class="expand" for="c-37605780">[1 more]</label></div><br/><div class="children"><div class="content">My best guess is that the code was used in non-node environments.<p>It wasn’t and isn’t uncommon to pull down a dependency from npm and expect it to work in multiple runtimes.</div><br/></div></div></div></div><div id="37608131" class="c"><input type="checkbox" id="c-37608131" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#37605459">parent</a><span>|</span><a href="#37605599">prev</a><span>|</span><a href="#37604373">next</a><span>|</span><label class="collapse" for="c-37608131">[-]</label><label class="expand" for="c-37608131">[1 more]</label></div><br/><div class="children"><div class="content">Modifying global scope is the whole point of a polyfill though. And polyfills check themselves whether they were already applied or not.<p>Maybe a step to a more sane situation would be reducing redundancies between polyfill libraries to ensure they don&#x27;t step on each other&#x27;s toes.</div><br/></div></div></div></div><div id="37604373" class="c"><input type="checkbox" id="c-37604373" checked=""/><div class="controls bullet"><span class="by">romellem</span><span>|</span><a href="#37605459">prev</a><span>|</span><a href="#37603312">next</a><span>|</span><label class="collapse" for="c-37604373">[-]</label><label class="expand" for="c-37604373">[14 more]</label></div><br/><div class="children"><div class="content">There is some interesting [drama][1] with this, since this article noticeably doesn&#x27;t mention any PRs they opened to remove some of these older polyfills.<p>The reason those PRs were never opened&#x2F;merged is the maintainer of many of those libraries [has a strong stance on &quot;breaking&quot; changes][2] in software:<p>&gt; I have developed an intense avoidance for breaking changes in all of my packages, because I don&#x27;t want to inflict hundreds of millions of dollars of person-hour cost on the entire industry unnecessarily.<p>IMO this argument avoids the <i>opposite</i> claim, that people then spend a ton of time (and money) trying to make old tech work with newer tech since not everyone maintains to the same standards of backwards compatibility.<p>But regardless, no one is required to stick to a particular way of creating open source software, so the one benefit here is that you are free to [fork the library][3] (assuming its license allows for that) to remove some backwards compatibility that isn&#x27;t relevant to you.<p>[1]: <a href="https:&#x2F;&#x2F;twitter.com&#x2F;ljharb&#x2F;status&#x2F;1704912065486618915" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;ljharb&#x2F;status&#x2F;1704912065486618915</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;import-js&#x2F;eslint-plugin-import&#x2F;pull&#x2F;2447#issuecomment-1119864501">https:&#x2F;&#x2F;github.com&#x2F;import-js&#x2F;eslint-plugin-import&#x2F;pull&#x2F;2447#...</a><p>[3]: <a href="https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;react-outside-click-handler-lite" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;react-outside-click-handler-li...</a></div><br/><div id="37608346" class="c"><input type="checkbox" id="c-37608346" checked=""/><div class="controls bullet"><span class="by">lavax</span><span>|</span><a href="#37604373">parent</a><span>|</span><a href="#37604635">next</a><span>|</span><label class="collapse" for="c-37608346">[-]</label><label class="expand" for="c-37608346">[3 more]</label></div><br/><div class="children"><div class="content">I try to focus on the issues rather than individuals, but the root of the problems in the listed eslint plugin libraries points to ljharb.<p>If you do some simple digging into these libraries, you will find that these types of commits are quite common within them.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;jsx-eslint&#x2F;eslint-plugin-react&#x2F;commit&#x2F;e1dd37f743649bf43726fe102a16bc71062d8687">https:&#x2F;&#x2F;github.com&#x2F;jsx-eslint&#x2F;eslint-plugin-react&#x2F;commit&#x2F;e1d...</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;jsx-eslint&#x2F;jsx-ast-utils&#x2F;commit&#x2F;bad51d062000ffdc19d925723a6515458318cf92?diff=split">https:&#x2F;&#x2F;github.com&#x2F;jsx-eslint&#x2F;jsx-ast-utils&#x2F;commit&#x2F;bad51d062...</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;jsx-eslint&#x2F;eslint-plugin-jsx-a11y&#x2F;commit&#x2F;3d77c845a98b6fc8cf10c810996278c02e308f35">https:&#x2F;&#x2F;github.com&#x2F;jsx-eslint&#x2F;eslint-plugin-jsx-a11y&#x2F;commit&#x2F;...</a><p>He would rather see the download count of these polyfill libraries <a href="https:&#x2F;&#x2F;github.com&#x2F;ljharb&#x2F;ljharb#projects-i-maintain">https:&#x2F;&#x2F;github.com&#x2F;ljharb&#x2F;ljharb#projects-i-maintain</a> increase, compared to assessing the health of the JavaScript ecosystem.</div><br/><div id="37608906" class="c"><input type="checkbox" id="c-37608906" checked=""/><div class="controls bullet"><span class="by">shortcake27</span><span>|</span><a href="#37604373">root</a><span>|</span><a href="#37608346">parent</a><span>|</span><a href="#37604635">next</a><span>|</span><label class="collapse" for="c-37608906">[-]</label><label class="expand" for="c-37608906">[2 more]</label></div><br/><div class="children"><div class="content">ljharb is an extremely interesting person. There’s no doubting the positive impact he’s had on the OSS community and the work he’s done.<p>However, there are some things he does that are incomprehensible.<p>For example, Enzyme. Over three years ago this issue was opened for Enzyme on React 17: <a href="https:&#x2F;&#x2F;github.com&#x2F;enzymejs&#x2F;enzyme&#x2F;issues&#x2F;2429">https:&#x2F;&#x2F;github.com&#x2F;enzymejs&#x2F;enzyme&#x2F;issues&#x2F;2429</a><p>Nothing moved for a while, and I think he said something along the lines of “if you want React 17 support, stop complaining and help”. So the community got involved. There are multiple PRs adding React 17 support. Many unofficial React 17 adapters. A lot of people have put a lot of work into this, ensuring compatibility, coverage etc. Yet to this day, none of them have been merged. Eg <a href="https:&#x2F;&#x2F;github.com&#x2F;enzymejs&#x2F;enzyme&#x2F;pull&#x2F;2564">https:&#x2F;&#x2F;github.com&#x2F;enzymejs&#x2F;enzyme&#x2F;pull&#x2F;2564</a><p>Given the amount of time that has passed, and the work the community has put in, something is amiss. It feels like he’s now intentionally avoiding React 17+ support. But why? I don’t understand why someone would ask for help then ignore the help when it comes in. That isn’t much better than the swathe of rude&#x2F;entitled comments he was getting on the issue before he locked it.<p>I ended up migrating to RTL, but this made many of my tests more complicated (especially compared to shallow rendering).</div><br/><div id="37609008" class="c"><input type="checkbox" id="c-37609008" checked=""/><div class="controls bullet"><span class="by">hashar</span><span>|</span><a href="#37604373">root</a><span>|</span><a href="#37608906">parent</a><span>|</span><a href="#37604635">next</a><span>|</span><label class="collapse" for="c-37609008">[-]</label><label class="expand" for="c-37609008">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d guess the issue with that project is that it is mostly a single person effort and if that person is busy with other projects&#x2F;repos&#x2F;real life, they might not have the bandwidth to keep-up with the review, loose interest or maybe did not notice the PR update in the stream of incoming requests.<p>I guess the community (if there is any) can request to have more maintainers added to the repository to share the burden, else you still have the option to fork the repo and publish it under a different name.</div><br/></div></div></div></div></div></div><div id="37604635" class="c"><input type="checkbox" id="c-37604635" checked=""/><div class="controls bullet"><span class="by">potsandpans</span><span>|</span><a href="#37604373">parent</a><span>|</span><a href="#37608346">prev</a><span>|</span><a href="#37607399">next</a><span>|</span><label class="collapse" for="c-37604635">[-]</label><label class="expand" for="c-37604635">[4 more]</label></div><br/><div class="children"><div class="content">Ljharb is harmful to the ECMAScript community</div><br/><div id="37605004" class="c"><input type="checkbox" id="c-37605004" checked=""/><div class="controls bullet"><span class="by">silverwind</span><span>|</span><a href="#37604373">root</a><span>|</span><a href="#37604635">parent</a><span>|</span><a href="#37606346">next</a><span>|</span><label class="collapse" for="c-37605004">[-]</label><label class="expand" for="c-37605004">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m thankful for his work, but I do agree, this polyfill madness has to stop.</div><br/><div id="37606458" class="c"><input type="checkbox" id="c-37606458" checked=""/><div class="controls bullet"><span class="by">potsandpans</span><span>|</span><a href="#37604373">root</a><span>|</span><a href="#37605004">parent</a><span>|</span><a href="#37606346">next</a><span>|</span><label class="collapse" for="c-37606458">[-]</label><label class="expand" for="c-37606458">[1 more]</label></div><br/><div class="children"><div class="content">I am _appreciative_ that people like him exist, because -- personal feelings aside -- we do need people who have his level of dedication in the open source space.<p>My only interactions with ljharb have been in TC39. More often than not when looking at issues he&#x27;s active in, I find myself wanting a level of maturity and thoughtfulness that just isn&#x27;t there.<p>His contributions are neither novel or very compelling. He&#x27;s more of an open-source bureaucrat than an engineer or a developer, yet he is currently steering several major TC39 proposals. I&#x27;ve seen him shutdown or sidetrack valid input and criticisms in all of them. The vibes I get from his behavior are akin to him being a member of &quot;the cool kid club&quot; -- wanting to maintain that ingroup&#x2F;outgroup boundary very tightly.<p>He really should just get out of the standards&#x2F;committee space entirely for the time being, and get some coaching on leadership skills before reentering. I realize this is super negative. Still on the ropes whether or not this feedback belongs in the public space.</div><br/></div></div></div></div><div id="37606346" class="c"><input type="checkbox" id="c-37606346" checked=""/><div class="controls bullet"><span class="by">proxyon</span><span>|</span><a href="#37604373">root</a><span>|</span><a href="#37604635">parent</a><span>|</span><a href="#37605004">prev</a><span>|</span><a href="#37607399">next</a><span>|</span><label class="collapse" for="c-37606346">[-]</label><label class="expand" for="c-37606346">[1 more]</label></div><br/><div class="children"><div class="content">He&#x27;s frequently on a powertrip and confidently wrong about so many things. For instance he&#x27;s one of the people who perpetuate the &quot;Javascript is fast and you don&#x27;t need to optimize anything&quot; falsehood. No wonder he&#x27;s bringing in 100 polyfills into everyone&#x27;s project. He thinks JS is C.</div><br/></div></div></div></div><div id="37607399" class="c"><input type="checkbox" id="c-37607399" checked=""/><div class="controls bullet"><span class="by">crummy</span><span>|</span><a href="#37604373">parent</a><span>|</span><a href="#37604635">prev</a><span>|</span><a href="#37608284">next</a><span>|</span><label class="collapse" for="c-37607399">[-]</label><label class="expand" for="c-37607399">[1 more]</label></div><br/><div class="children"><div class="content">You know, it&#x27;s heresy to say, but if there was some kind of analytics or reporting done by the plugin we could know for sure that no node v4 users are out there on it and upgrade the deps and be done with the whole argument.</div><br/></div></div><div id="37608284" class="c"><input type="checkbox" id="c-37608284" checked=""/><div class="controls bullet"><span class="by">davedx</span><span>|</span><a href="#37604373">parent</a><span>|</span><a href="#37607399">prev</a><span>|</span><a href="#37604832">next</a><span>|</span><label class="collapse" for="c-37608284">[-]</label><label class="expand" for="c-37608284">[3 more]</label></div><br/><div class="children"><div class="content">Insanity. In projects where I have full technical control I don’t use eslint anyway, it creates a massive load of work for negligible (if any) gain. Typescript finds the important issues, prettier fixes formatting; linters just create giant swathes of useless busywork.</div><br/><div id="37609587" class="c"><input type="checkbox" id="c-37609587" checked=""/><div class="controls bullet"><span class="by">Chernobog</span><span>|</span><a href="#37604373">root</a><span>|</span><a href="#37608284">parent</a><span>|</span><a href="#37609627">next</a><span>|</span><label class="collapse" for="c-37609587">[-]</label><label class="expand" for="c-37609587">[1 more]</label></div><br/><div class="children"><div class="content">I think your description of linting can be true, but not necessarily for every eslint configuration. I feel that I&#x27;ve landed on configs that feel useful to myself and the rest of the devs in the team. Even with a rule set that contains many rules that can look nit picky at first glance, no one complains since they are auto fixable, and fixing is a part of a commit hook.<p>There are a handful of rules that are nice to have in a TypeScript project to make sure devs don&#x27;t do things that break type safety. Plus some that avoids mistakes from slipping through (even though the code is reviewed).<p>One thing I&#x27;ve found super useful is to have @typescript-eslint&#x2F;ban-ts-comment enabled, but configured so that you can still use @ts-expect-error and the others as long as you provide a comment when doing so. This is so nice when doing code reviews, either someone has provided a very good reason for the exception, or it is clear that the same result could have been achieved with a better approach. Same goes for disabling eslint rules inline in a file, also allowed if commented. I feel that this is a very good compromise between being strict with linting, but also not letting linting get in the way.</div><br/></div></div><div id="37609627" class="c"><input type="checkbox" id="c-37609627" checked=""/><div class="controls bullet"><span class="by">corbezzoli</span><span>|</span><a href="#37604373">root</a><span>|</span><a href="#37608284">parent</a><span>|</span><a href="#37609587">prev</a><span>|</span><a href="#37604832">next</a><span>|</span><label class="collapse" for="c-37609627">[-]</label><label class="expand" for="c-37609627">[1 more]</label></div><br/><div class="children"><div class="content">&gt; massive load of work for negligible (if any) gain<p>If you coded alone for 10 years and then add a strict linting config you&#x27;re going to have a really bad time.<p>If you actually follow the advice a linter gives you, you come up a 10x better developer.<p>Of course not all lint rules are created equal, but some are arguably <i>existential.</i></div><br/></div></div></div></div><div id="37604832" class="c"><input type="checkbox" id="c-37604832" checked=""/><div class="controls bullet"><span class="by">gibolt</span><span>|</span><a href="#37604373">parent</a><span>|</span><a href="#37608284">prev</a><span>|</span><a href="#37603312">next</a><span>|</span><label class="collapse" for="c-37604832">[-]</label><label class="expand" for="c-37604832">[2 more]</label></div><br/><div class="children"><div class="content">Is there not a config for minimum supported JS version? That would appease everyone, while maintaining backwards compatibility.<p>Docs should show the recommended version (modern) and show what options are available to go deeper.<p>Obviously adding those settings for every pollyfill in non-trivial, but burdening everyone with every pollyfill ever is also suboptimal. If anything, this would make cleanup easier going forward since it would all be classified</div><br/><div id="37606744" class="c"><input type="checkbox" id="c-37606744" checked=""/><div class="controls bullet"><span class="by">arthur2e5</span><span>|</span><a href="#37604373">root</a><span>|</span><a href="#37604832">parent</a><span>|</span><a href="#37603312">next</a><span>|</span><label class="collapse" for="c-37606744">[-]</label><label class="expand" for="c-37606744">[1 more]</label></div><br/><div class="children"><div class="content">There is an &quot;engine&quot;!entry in package.json, and a package manager <i>should</i> be smart enough to not upgrade past what it can. But people tend to  not use that sort of dependency flexibility and use lock files…</div><br/></div></div></div></div></div></div><div id="37603312" class="c"><input type="checkbox" id="c-37603312" checked=""/><div class="controls bullet"><span class="by">cxr</span><span>|</span><a href="#37604373">prev</a><span>|</span><a href="#37603342">next</a><span>|</span><label class="collapse" for="c-37603312">[-]</label><label class="expand" for="c-37603312">[33 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll never get NPM apologists to acknowledge this.  One of their only skills is making non-specific appeals to the necessity of it all (as essential infrastructure) and vague arguments that boil down to &quot;you need to trust the wisdom of the crowds&quot; (and e.g. the fact that it exists and everyone else is using it means that anyone who disputes its value just doesn&#x27;t understand it—bonus points for them if they manage to work in a slight that&#x27;s designed to paint you, implicitly or explicitly, as a junior), despite not being able to attest to any firsthand knowledge of the real <i>why</i> of anything they&#x27;re defending.<p>&gt; The new dependencies were all polyfills for JavaScript functions that have long been supported everywhere. The Object.defineProperties method for example was shipped as part of the very first public Node 0.10.0 release dating back to 2013.  Heck, even Internet Explorer 9 supported that.  And yet there were numerous packages in that dependend on a polyfill for it.</div><br/><div id="37603699" class="c"><input type="checkbox" id="c-37603699" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#37603312">parent</a><span>|</span><a href="#37603593">next</a><span>|</span><label class="collapse" for="c-37603699">[-]</label><label class="expand" for="c-37603699">[22 more]</label></div><br/><div class="children"><div class="content">Back in 2011ish or so when npm was just getting started and Ruby on rails was all the rage.  &quot;Do not repeat yourself&quot; was seen as a gold standard for programming.  The end result has been a mess, particularly for npm.  There were FAR too many articles talking about how &quot;there&#x27;s no such thing as too small a dependency&quot; and talks given about how much a virtue it was to create &quot;is-odd&quot; or &quot;is-even&quot; &quot;look you saved 3 lines of code that you don&#x27;t have to test!&quot;<p>Unfortunately, that compounded with browser of the era (Internet explorer...) having basically 0 support for modern javascript led to a proliferation of dependencies, polyfills, etc that are nearly impossible to remove from the ecosystem.<p>I&#x27;ve not seen a lot of node apologists that are fine with the current ecoystem.  The problem is righting the ship is going to be terribly hard.  Either existing frameworks&#x2F;libraries need to go through the effort of saying &quot;Ok, do I really need is-even, let&#x27;s remove it&quot; or we need new frameworks&#x2F;libraries to abandon tools and the ecosystem in favor of fatter and fewer dependencies.<p>I think the issue all stems from the fact that before 2010ish, there was one library and one framework, jquery  (Ok, there were others... but were there really?) and that added a good 1mb to any webpage.  The notion was we do more with less if we had a bunch of smaller deps that didn&#x27;t need to be brought in.</div><br/><div id="37604308" class="c"><input type="checkbox" id="c-37604308" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37603699">parent</a><span>|</span><a href="#37604266">next</a><span>|</span><label class="collapse" for="c-37604308">[-]</label><label class="expand" for="c-37604308">[8 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;Do not repeat yourself&quot; was seen as a gold standard for programming.<p>I remember this era. I’ve been using nodejs before npm existed and so many silly things have happened in that time.<p>I think the core problem the JS ecosystem has always had is that most JS developers are relatively inexperienced. (JS is very beginner friendly and this is the price we pay). I still vividly remember being at nodecamp in 2012 or something listening to someone tell me how great it would be if the entire OS was written in javascript. It didn’t matter how much I poked and prodded him, he couldn’t hear that it might not be an amazing idea. I think he thought it would be easier to reimplement an OS kernel in JS than it would be to just learn C. And there were lots of people around with a sparkle in their eye and those sort of wacky ideas - good or bad. It was fun and in hindsight a very silly time.<p>So yeah, of course some idiot in JS made is-even. And is-odd (which depends on is-even). I see all of this as the characteristic mistake of youth - that we go looking for overly simple rules about what is good and bad (JS good! C bad!) and then we make a mess. When we’re young we lack discernment about subtle questions. When is it better to pull in a library vs writing it yourself inline? When is JS a good or a bad idea? When should you add comments, or tests? And when do you leave them out?<p>Most of the best engineers I know made these sort of stupid philosophical mistakes when they were young. I certainly did. The JS ecosystem just suffers disproportionately from this kind of thing because so many packages in npm are written by relatively new developers.<p>I think that’s a good thing for our industry as a whole. But I also get it when Bryan Cantrill describes JS as the failed state of programming languages.</div><br/><div id="37604644" class="c"><input type="checkbox" id="c-37604644" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37604308">parent</a><span>|</span><a href="#37605251">next</a><span>|</span><label class="collapse" for="c-37604644">[-]</label><label class="expand" for="c-37604644">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>The JS ecosystem just suffers disproportionately from this kind of thing because so many packages in npm are written by relatively new developers.</i><p>I think it also suffers because it grew in the age of Internet and Open Source, which made the problem compounding. Programmers write a lot of stupid code when learning, it&#x27;s part of the process - but it used to be that the stupidity was constrained to your machine and maybe a few poor souls who ended up reading or using your code. In JS ecosystem, all that stupidity gets published, and ends up worming its way, through dependency chains, into everything.</div><br/></div></div><div id="37605251" class="c"><input type="checkbox" id="c-37605251" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37604308">parent</a><span>|</span><a href="#37604644">prev</a><span>|</span><a href="#37605212">next</a><span>|</span><label class="collapse" for="c-37605251">[-]</label><label class="expand" for="c-37605251">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; I still vividly remember being at nodecamp in 2012 or something listening to someone tell me how great it would be if the entire OS was written in javascript.</i><p>That reminds me of Gary Bernhardt&#x27;s &quot;The Birth &amp; Death of JavaScript&quot; talk[0], which one of the best comedy programming talks. Despite the comedy, it&#x27;s also a half-decent idea.<p>[0] <a href="https:&#x2F;&#x2F;www.destroyallsoftware.com&#x2F;talks&#x2F;the-birth-and-death-of-javascript" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.destroyallsoftware.com&#x2F;talks&#x2F;the-birth-and-death...</a></div><br/></div></div><div id="37605212" class="c"><input type="checkbox" id="c-37605212" checked=""/><div class="controls bullet"><span class="by">beepbooptheory</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37604308">parent</a><span>|</span><a href="#37605251">prev</a><span>|</span><a href="#37604266">next</a><span>|</span><label class="collapse" for="c-37605212">[-]</label><label class="expand" for="c-37605212">[5 more]</label></div><br/><div class="children"><div class="content">I thought is-even&#x2F;is-odd were satirical? Granted, satire echoing these same points... but, you know, just for-the-record.</div><br/><div id="37606371" class="c"><input type="checkbox" id="c-37606371" checked=""/><div class="controls bullet"><span class="by">technion</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37605212">parent</a><span>|</span><a href="#37605486">next</a><span>|</span><label class="collapse" for="c-37606371">[-]</label><label class="expand" for="c-37606371">[1 more]</label></div><br/><div class="children"><div class="content">Although it&#x27;s unclear, every time someone provides a one liner there are staunch not satire arguments about &quot;covering edge cases you didn&#x27;t think of&quot; and I disagree. Look at the actual code: <a href="https:&#x2F;&#x2F;github.com&#x2F;i-voted-for-trump&#x2F;is-odd&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;i-voted-for-trump&#x2F;is-odd&#x2F;</a><p>There&#x27;s a &quot;tested edge case&quot; where you can check isOdd(&#x27;1&#x27;) and it will work - to me the code is already wrong, isOdd(STRING) should throw. The correct solution is to use Typescript and assert the input is a number.<p>The Number.isSafeInteger check is an interesting one. Yes, it&#x27;s not &quot;safe&quot; to work with a number outside this but no doubt something in the function would be broken before an is-odd check if it was relied upon.<p>Often the edge case someone else catered to is something counter to my expectation. I would rather write two lines of code myself and be aware of the behaviour.</div><br/></div></div><div id="37605486" class="c"><input type="checkbox" id="c-37605486" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37605212">parent</a><span>|</span><a href="#37606371">prev</a><span>|</span><a href="#37605541">next</a><span>|</span><label class="collapse" for="c-37605486">[-]</label><label class="expand" for="c-37605486">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s hard to tell.<p>The author of both packages has since moved the github repos to an organisation named &quot;i-voted-for-trump&quot; and labelled the packages with the &quot;troll-bait&quot; tag.<p>But the author also claims those packages where created when they were learning to program, and they seem to have stuck with the idea of small libraries (just not quite that small). The changes seem to be due to grief the programming community has given him about those packages, as some of the worst examples of the pattern.<p>I suspect the author was being slightly satirical by choosing to do the simplest possible NPM library. But at the same time they probably believed it was a useful package, allowing new programmers (like himself) to calculate the evenness&#x2F;oddness of numbers without needing to know or google the mod-2 trick. And if you are going to learn how to create npm packages, might as well start small.<p>If they were aiming to be slightly satirical, they were not expecting that level of outrage.<p>It&#x27;s worth pointing out that the libraries do slightly more than just mod-2. It checks the argument passed in was actually an integer, and throws descriptive error messages if the argument is not a number or not an integer.</div><br/></div></div><div id="37605541" class="c"><input type="checkbox" id="c-37605541" checked=""/><div class="controls bullet"><span class="by">pphysch</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37605212">parent</a><span>|</span><a href="#37605486">prev</a><span>|</span><a href="#37604266">next</a><span>|</span><label class="collapse" for="c-37605541">[-]</label><label class="expand" for="c-37605541">[2 more]</label></div><br/><div class="children"><div class="content">Those may be satirical, but `leftpad` is real.<p><a href="https:&#x2F;&#x2F;qz.com&#x2F;646467&#x2F;how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code" rel="nofollow noreferrer">https:&#x2F;&#x2F;qz.com&#x2F;646467&#x2F;how-one-programmer-broke-the-internet-...</a></div><br/><div id="37609661" class="c"><input type="checkbox" id="c-37609661" checked=""/><div class="controls bullet"><span class="by">corbezzoli</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37605541">parent</a><span>|</span><a href="#37604266">next</a><span>|</span><label class="collapse" for="c-37609661">[-]</label><label class="expand" for="c-37609661">[1 more]</label></div><br/><div class="children"><div class="content">`left-pad` is the perfect amount of complexity and &quot;I&#x27;m sure I can do it&quot; ability by everyone who looks at it. I want you to write that logic and not have some stupid mistake that was fixed in that module 15 years ago.<p>Now we have String.prototype.padStart thanks to that debacle.</div><br/></div></div></div></div></div></div></div></div><div id="37604266" class="c"><input type="checkbox" id="c-37604266" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37603699">parent</a><span>|</span><a href="#37604308">prev</a><span>|</span><a href="#37607310">next</a><span>|</span><label class="collapse" for="c-37604266">[-]</label><label class="expand" for="c-37604266">[1 more]</label></div><br/><div class="children"><div class="content">Most people fine with the problems of the ecosystem have financial incentives.<p>Stating that you maintain 800 NPM libraries brings more clout and money than maintaining a foundational one.<p>Even with foundational packages things tend to go wrong. Why add features to an existing package if I can write several plugins? Or even worse in some cases: why use the existing configuration file if I can instead just ask users to install dozens of dummy packages that only exist to trigger a feature in my Core package?</div><br/></div></div><div id="37607310" class="c"><input type="checkbox" id="c-37607310" checked=""/><div class="controls bullet"><span class="by">tored</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37603699">parent</a><span>|</span><a href="#37604266">prev</a><span>|</span><a href="#37603856">next</a><span>|</span><label class="collapse" for="c-37607310">[-]</label><label class="expand" for="c-37607310">[1 more]</label></div><br/><div class="children"><div class="content">There was a closely related movement at the time that called for that languages should have minimal &quot;bloat&quot;, combined that with importing only what you need down to single functions, it was viewed as the future of programming.<p>I was sympathetic to that idea then, it sounded good in theory, however in practice it was horrible.<p>Today I enjoy coding in &quot;bloated&quot; languages with only a few external dependencies.</div><br/></div></div><div id="37603856" class="c"><input type="checkbox" id="c-37603856" checked=""/><div class="controls bullet"><span class="by">no_wizard</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37603699">parent</a><span>|</span><a href="#37607310">prev</a><span>|</span><a href="#37604174">next</a><span>|</span><label class="collapse" for="c-37603856">[-]</label><label class="expand" for="c-37603856">[4 more]</label></div><br/><div class="children"><div class="content">I wonder if there would be any interest from folks for an alternative npm registry that would automatically cleanup dependency chains like this (among other things, possibly), remove polyfills etc.<p>I always thought about something like this, with on the fly manipulation of packages via SWC would be pretty fast I think</div><br/><div id="37608100" class="c"><input type="checkbox" id="c-37608100" checked=""/><div class="controls bullet"><span class="by">bsimpson</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37603856">parent</a><span>|</span><a href="#37606080">next</a><span>|</span><label class="collapse" for="c-37608100">[-]</label><label class="expand" for="c-37608100">[1 more]</label></div><br/><div class="children"><div class="content">esm.sh kind of does this for livecoding environments (e.g. Codepen&#x2F;Colab) where you&#x27;re using &lt;script type=importmap&gt; instead of a bundler.</div><br/></div></div><div id="37606080" class="c"><input type="checkbox" id="c-37606080" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37603856">parent</a><span>|</span><a href="#37608100">prev</a><span>|</span><a href="#37604174">next</a><span>|</span><label class="collapse" for="c-37606080">[-]</label><label class="expand" for="c-37606080">[2 more]</label></div><br/><div class="children"><div class="content">I think a better approach would be automated tooling to detect opportunities for cleanup, and then submitting PRs to libraries.</div><br/><div id="37606333" class="c"><input type="checkbox" id="c-37606333" checked=""/><div class="controls bullet"><span class="by">rschristian</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37606080">parent</a><span>|</span><a href="#37604174">next</a><span>|</span><label class="collapse" for="c-37606333">[-]</label><label class="expand" for="c-37606333">[1 more]</label></div><br/><div class="children"><div class="content">That only works if the maintainers of the packages are interested in the cleanup -- the maintainer behind some of the packages mentioned in this thread is very much not. They prefer the bloat to incrementing the major version number.</div><br/></div></div></div></div></div></div><div id="37604174" class="c"><input type="checkbox" id="c-37604174" checked=""/><div class="controls bullet"><span class="by">Klonoar</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37603699">parent</a><span>|</span><a href="#37603856">prev</a><span>|</span><a href="#37606933">next</a><span>|</span><label class="collapse" for="c-37604174">[-]</label><label class="expand" for="c-37604174">[5 more]</label></div><br/><div class="children"><div class="content">jQuery is the one that’s outlasted them all, but yes - there were absolutely other frameworks in use. It also discounts the detour into the Backbone era before Angular and React took off.</div><br/><div id="37607365" class="c"><input type="checkbox" id="c-37607365" checked=""/><div class="controls bullet"><span class="by">paradox460</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37604174">parent</a><span>|</span><a href="#37605150">next</a><span>|</span><label class="collapse" for="c-37607365">[-]</label><label class="expand" for="c-37607365">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve interacted with devs who still bring in prototype.js<p>Within the last year even</div><br/></div></div><div id="37605150" class="c"><input type="checkbox" id="c-37605150" checked=""/><div class="controls bullet"><span class="by">arbol</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37604174">parent</a><span>|</span><a href="#37607365">prev</a><span>|</span><a href="#37606933">next</a><span>|</span><label class="collapse" for="c-37605150">[-]</label><label class="expand" for="c-37605150">[3 more]</label></div><br/><div class="children"><div class="content">MooTools springs to mind</div><br/><div id="37607882" class="c"><input type="checkbox" id="c-37607882" checked=""/><div class="controls bullet"><span class="by">Klonoar</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37605150">parent</a><span>|</span><a href="#37606933">next</a><span>|</span><label class="collapse" for="c-37607882">[-]</label><label class="expand" for="c-37607882">[2 more]</label></div><br/><div class="children"><div class="content">MooTools, Prototype, Dojo, YUI... what an era.<p>It sometimes feels like part of what we deal with now in the JS world is due to half the crowd not knowing what came before.<p>(Edit: to be clear, I think <i>the other half</i> is responsible for the advancements... so it probably evens out)</div><br/><div id="37607995" class="c"><input type="checkbox" id="c-37607995" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37607882">parent</a><span>|</span><a href="#37606933">next</a><span>|</span><label class="collapse" for="c-37607995">[-]</label><label class="expand" for="c-37607995">[1 more]</label></div><br/><div class="children"><div class="content">One of the systems I currently work on has all five of those.  Which one was in use was developer&#x27;s choice for pretty much any given page or feature.</div><br/></div></div></div></div></div></div></div></div><div id="37606933" class="c"><input type="checkbox" id="c-37606933" checked=""/><div class="controls bullet"><span class="by">onli</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37603699">parent</a><span>|</span><a href="#37604174">prev</a><span>|</span><a href="#37603593">next</a><span>|</span><label class="collapse" for="c-37606933">[-]</label><label class="expand" for="c-37606933">[2 more]</label></div><br/><div class="children"><div class="content">Is that with the 1MB a joke? Just in case it&#x27;s not, jQuery never was that big, not even uncompressed.</div><br/><div id="37608208" class="c"><input type="checkbox" id="c-37608208" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37606933">parent</a><span>|</span><a href="#37603593">next</a><span>|</span><label class="collapse" for="c-37608208">[-]</label><label class="expand" for="c-37608208">[1 more]</label></div><br/><div class="children"><div class="content">And one could download stripped-down versions with just the features needed. Important especially with jQuery UI since it had quite some heavy components.</div><br/></div></div></div></div></div></div><div id="37603593" class="c"><input type="checkbox" id="c-37603593" checked=""/><div class="controls bullet"><span class="by">CharlesW</span><span>|</span><a href="#37603312">parent</a><span>|</span><a href="#37603699">prev</a><span>|</span><a href="#37608430">next</a><span>|</span><label class="collapse" for="c-37603593">[-]</label><label class="expand" for="c-37603593">[9 more]</label></div><br/><div class="children"><div class="content">&gt; <i>You&#x27;ll never get NPM apologists to acknowledge this.</i><p>How should NPM prevent archaic dependencies, or the &quot;even more bizarre&quot; (author&#x27;s words) problem of developers calling polyfills directly instead of the function that the polyfill fills?</div><br/><div id="37604305" class="c"><input type="checkbox" id="c-37604305" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37603593">parent</a><span>|</span><a href="#37608430">next</a><span>|</span><label class="collapse" for="c-37604305">[-]</label><label class="expand" for="c-37604305">[8 more]</label></div><br/><div class="children"><div class="content">The parent is not criticising NPM the tool&#x2F;registry, but rather the ecosystem and culture.</div><br/><div id="37604551" class="c"><input type="checkbox" id="c-37604551" checked=""/><div class="controls bullet"><span class="by">cxr</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37604305">parent</a><span>|</span><a href="#37608430">next</a><span>|</span><label class="collapse" for="c-37604551">[-]</label><label class="expand" for="c-37604551">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;m happy to criticize NPM the tool.  The whole thing is designed as a second, crummier version control system that lives in disharmony with and on top of your base-level version control system (so it can subvert it).  It&#x27;s a terrible design.<p>There&#x27;s basically at most one reasonable use for npm: as a glorified download manager, i.e. to quickly fetch a module by name (right before you check it in to version control with Git).  This differs wildly, of course, from how it&#x27;s actually used, which is as a drug that sweeps mountains of unaudited code under the rug so people can trick themselves and others into thinking that none of it&#x27;s really there on the basis that it&#x27;s not visible when anyone first clones the repo.<p>To answer the other commenter&#x27;s question, &quot;How should NPM prevent archaic dependencies&quot;: it shouldn&#x27;t; it&#x27;s okay for programmers to be responsible for their work.</div><br/><div id="37605227" class="c"><input type="checkbox" id="c-37605227" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37604551">parent</a><span>|</span><a href="#37608430">next</a><span>|</span><label class="collapse" for="c-37605227">[-]</label><label class="expand" for="c-37605227">[6 more]</label></div><br/><div class="children"><div class="content">How is npm a version control system?<p>npm is a fairly standard package manager, much like many others, pretty good even.<p>I don&#x27;t know of anyone who says that package managers and source control solve the same problems. They both happen to use the word and concept of &quot;version&quot; but to mean <i>different</i> things. Yes, some projects vendor in their dependencies into their source control system, but they must either manually verify package version compatibility or use a package manager like npm to help them do it. And vendoring doesn&#x27;t work for actual packages published to the package repo. If they vendored dependencies then every dependency would be duplicated always, defeating the very purpose of a package manager!</div><br/><div id="37605966" class="c"><input type="checkbox" id="c-37605966" checked=""/><div class="controls bullet"><span class="by">cxr</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37605227">parent</a><span>|</span><a href="#37608430">next</a><span>|</span><label class="collapse" for="c-37605966">[-]</label><label class="expand" for="c-37605966">[5 more]</label></div><br/><div class="children"><div class="content">&gt; npm is a fairly standard package manager, much like many others<p>Yes.<p>&gt; They both happen to use the word and concept of &quot;version&quot; but to mean <i>different</i> things.<p>Right.  I think I covered that adequately.<p>&gt; And vendoring doesn&#x27;t work for actual packages published to the package repo.<p>What?<p>&gt; If they vendored dependencies then every dependency would be duplicated always, defeating the very purpose of a package manager!<p>Yes.  Alternatively:<p>Please clearly articulate the purpose of a package manager (in the sense of the term when it&#x27;s used to describe npm and others).  See if you can work it out so that you can state it in the form of a testable hypothesis (i.e. ideally in quantitative terms like MBs&#x2F;GBs of disk space used, or network transit, or time to fetch—or anything that you think accurately reflects what you consider to be the value proposition that npm fulfills and which we can use to evaluate it in scenarios where it would or would not be a good fit).</div><br/><div id="37606456" class="c"><input type="checkbox" id="c-37606456" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37605966">parent</a><span>|</span><a href="#37608430">next</a><span>|</span><label class="collapse" for="c-37606456">[-]</label><label class="expand" for="c-37606456">[4 more]</label></div><br/><div class="children"><div class="content">Man, this isn&#x27;t hard.<p>The purpose of a packages manager is to allow me to describe the packages and versions that my own package depends on, and download compatible versions of those dependencies and their transitive dependencies in such a way that dependencies are shared and that my runtime can use them.<p>npm does that, as does Cargo, Pub, Gems, pip, etc.</div><br/><div id="37607124" class="c"><input type="checkbox" id="c-37607124" checked=""/><div class="controls bullet"><span class="by">cxr</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37606456">parent</a><span>|</span><a href="#37608430">next</a><span>|</span><label class="collapse" for="c-37607124">[-]</label><label class="expand" for="c-37607124">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Man, this isn&#x27;t hard.<p>Well, you ducked the question—and what you did say isn&#x27;t particularly illuminating to anyone who is already familiar with npm and cargo—so it&#x27;s not at all clear at this point that you&#x27;re right about that.  (Your overall comment actually reads a lot like the sort of thing that I mentioned at the top of this thread: &quot;non-specific appeals to the necessity of it all [...] vague arguments [...] they manage to work in a slight that&#x27;s designed to paint you, implicitly or explicitly, as a junior&quot;.)<p>I&#x27;ll ask again: what is the value proposition of npm-like package managers in quantitative terms?  Your hypothesis should be falsifiable, if not testable.<p>If you&#x27;re having difficulty, we might start here:<p>&gt; in such a way that dependencies are shared<p>Why?</div><br/><div id="37607202" class="c"><input type="checkbox" id="c-37607202" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37607124">parent</a><span>|</span><a href="#37608430">next</a><span>|</span><label class="collapse" for="c-37607202">[-]</label><label class="expand" for="c-37607202">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Your hypothesis should be falsifiable, if not testable&quot;<p>Seriously? There are not strange requirements, and you&#x27;re ducking the issue by trying to force a pseudo-scientific dialog on this. There are language semantics in play, among many other considerations that I&#x27;m sure you&#x27;re <i>well</i> aware of.<p>But I don&#x27;t need to convince you, you&#x27;re already convinced. Have fun.</div><br/><div id="37607297" class="c"><input type="checkbox" id="c-37607297" checked=""/><div class="controls bullet"><span class="by">cxr</span><span>|</span><a href="#37603312">root</a><span>|</span><a href="#37607202">parent</a><span>|</span><a href="#37608430">next</a><span>|</span><label class="collapse" for="c-37607297">[-]</label><label class="expand" for="c-37607297">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Seriously?<p>Yes, seriously.<p>&gt; There are not strange requirements<p>Huh?<p>&gt; you&#x27;re ducking the issue<p>I am?  How?  (What is the issue I&#x27;m ducking?)<p>&gt; There are language semantics in play, among many other considerations that I&#x27;m sure you&#x27;re <i>well</i> aware of.<p>What?<p>&gt; I don&#x27;t need to convince you, you&#x27;re already convinced.<p>I don&#x27;t get it.  (What am I already convinced of?)  You said this wasn&#x27;t hard.  So why does it seem that way?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37608430" class="c"><input type="checkbox" id="c-37608430" checked=""/><div class="controls bullet"><span class="by">davedx</span><span>|</span><a href="#37603312">parent</a><span>|</span><a href="#37603593">prev</a><span>|</span><a href="#37603342">next</a><span>|</span><label class="collapse" for="c-37608430">[-]</label><label class="expand" for="c-37608430">[1 more]</label></div><br/><div class="children"><div class="content">It is infuriating. I love the power of the node ecosystem but the total lack of critical thinking around it drives me bonkers.</div><br/></div></div></div></div><div id="37603342" class="c"><input type="checkbox" id="c-37603342" checked=""/><div class="controls bullet"><span class="by">no_wizard</span><span>|</span><a href="#37603312">prev</a><span>|</span><a href="#37603584">next</a><span>|</span><label class="collapse" for="c-37603342">[-]</label><label class="expand" for="c-37603342">[3 more]</label></div><br/><div class="children"><div class="content">Marvin is doing wonderful work in the JS ecosystem around performance. It has been largely focused on tools and node, however, he did have an interesting set of things to say about how they optimized performance in Preact as well on his website that was really interesting too.<p>One thing I&#x27;ve noticed is the rampant duplication of polyfills and babel helpers. To the point that I now have overrides setup via pnpm and I re-write many imports of polyfills to point at my own shims, which simply re-export existing functionality native to the language, most of the time.<p>For smaller utility packages, I often simply clone the repo and copy things over that we need, or copy the src right out of the node_modules folder if possible, then I strip away all the superfluous imports (and often convert from commonjs to ESM if needed)<p>Saves so much headache, its better for users, smaller builds etc.</div><br/><div id="37604022" class="c"><input type="checkbox" id="c-37604022" checked=""/><div class="controls bullet"><span class="by">mhagemeister</span><span>|</span><a href="#37603342">parent</a><span>|</span><a href="#37603387">next</a><span>|</span><label class="collapse" for="c-37604022">[-]</label><label class="expand" for="c-37604022">[1 more]</label></div><br/><div class="children"><div class="content">Author here.<p>Thanks for the kind words! It&#x27;s feedback like this that encourages me to keep writing about it.<p>I share your experiences regarding babel helpers and haven&#x27;t found a good solution myself. Similar to you, I often patch unnecessary stuff out via patch-package, but that approach doesn&#x27;t scale well.</div><br/></div></div><div id="37603387" class="c"><input type="checkbox" id="c-37603387" checked=""/><div class="controls bullet"><span class="by">Dextro</span><span>|</span><a href="#37603342">parent</a><span>|</span><a href="#37604022">prev</a><span>|</span><a href="#37603584">next</a><span>|</span><label class="collapse" for="c-37603387">[-]</label><label class="expand" for="c-37603387">[1 more]</label></div><br/><div class="children"><div class="content">That sounds awesome. I&#x27;ve dabled with something like that but only for lodash (makings sure all different flavours get aliased to a single thing) but I never went too far with all the other stuff.<p>You wouldn&#x27;t happen to have an example of what you&#x27;re doing laying around would you? I&#x27;d be genuinely curious to try stuff like that out.</div><br/></div></div></div></div><div id="37603584" class="c"><input type="checkbox" id="c-37603584" checked=""/><div class="controls bullet"><span class="by">e_y_</span><span>|</span><a href="#37603342">prev</a><span>|</span><a href="#37606773">next</a><span>|</span><label class="collapse" for="c-37603584">[-]</label><label class="expand" for="c-37603584">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Polyfills that don’t polyfill<p>This is what&#x27;s sometimes called a &quot;ponyfill&quot;. The idea is to avoid messing with global scope (monkeypatching), which could be problematic if you have multiple polyfills for the same API or polyfills that don&#x27;t perfectly match the native behavior.<p>This can be a good thing in some situations, but in general it&#x27;s probably best to leave polyfill decisions to the bundler so you can decide which browsers you want to support. Or even produce multiple versions, a lightweight one for modern browsers and one with tons of polyfills that gets served to ancient ones.</div><br/><div id="37603986" class="c"><input type="checkbox" id="c-37603986" checked=""/><div class="controls bullet"><span class="by">mhagemeister</span><span>|</span><a href="#37603584">parent</a><span>|</span><a href="#37607493">next</a><span>|</span><label class="collapse" for="c-37603986">[-]</label><label class="expand" for="c-37603986">[2 more]</label></div><br/><div class="children"><div class="content">Author here.<p>Good point. Agree that the ideal scenario would be that the end user (or the tools they use) have the final say in which polyfills to load. It&#x27;s a bit of a bummer that they are shipped as part of npm packages without an easy way to get rid of them.<p>I wonder if our industry will move to publishing the original source files to npm in the long run. Only the last piece of the chain, the developer using these dependencies, knows what their target environments are. So the bundler could then downlevel or polyfill the code for the specified targets.</div><br/><div id="37608136" class="c"><input type="checkbox" id="c-37608136" checked=""/><div class="controls bullet"><span class="by">bsimpson</span><span>|</span><a href="#37603584">root</a><span>|</span><a href="#37603986">parent</a><span>|</span><a href="#37607493">next</a><span>|</span><label class="collapse" for="c-37608136">[-]</label><label class="expand" for="c-37608136">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always been kind of surprised that original sources aren&#x27;t part of the NPM culture.  For a long time, I included &quot;typescript:main&quot; in my package.jsons and configured my tools to prefer that to &quot;main&quot; (and now &quot;module&quot;).</div><br/></div></div></div></div><div id="37607493" class="c"><input type="checkbox" id="c-37607493" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#37603584">parent</a><span>|</span><a href="#37603986">prev</a><span>|</span><a href="#37606773">next</a><span>|</span><label class="collapse" for="c-37607493">[-]</label><label class="expand" for="c-37607493">[1 more]</label></div><br/><div class="children"><div class="content">I get not defining it yourself, especially if your polyfill is limited to the sliver of a feature you use, but why not check if the feature is there first?<p>Ok, maybe someone else monkeypatched it. But at least you’d end up using the native functionality if it was there.</div><br/></div></div></div></div><div id="37606773" class="c"><input type="checkbox" id="c-37606773" checked=""/><div class="controls bullet"><span class="by">arthur2e5</span><span>|</span><a href="#37603584">prev</a><span>|</span><a href="#37609444">next</a><span>|</span><label class="collapse" for="c-37606773">[-]</label><label class="expand" for="c-37606773">[2 more]</label></div><br/><div class="children"><div class="content">These polyfills aren&#x27;t just large, they&#x27;re also slow because they never use the native implementation. The good news is that you can replace them all with &quot;overrides&quot; in package.json. That&#x27;s what nolyfill (<a href="https:&#x2F;&#x2F;github.com&#x2F;SukkaW&#x2F;nolyfill">https:&#x2F;&#x2F;github.com&#x2F;SukkaW&#x2F;nolyfill</a>) does. Oh, and of course the README mentions ljharb.</div><br/><div id="37609445" class="c"><input type="checkbox" id="c-37609445" checked=""/><div class="controls bullet"><span class="by">scns</span><span>|</span><a href="#37606773">parent</a><span>|</span><a href="#37609444">next</a><span>|</span><label class="collapse" for="c-37609445">[-]</label><label class="expand" for="c-37609445">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d upvote you a 1000 times if i could. To lazy to mail dang if it&#x27;s possible to pin it on top.</div><br/></div></div></div></div><div id="37609444" class="c"><input type="checkbox" id="c-37609444" checked=""/><div class="controls bullet"><span class="by">pbowyer</span><span>|</span><a href="#37606773">prev</a><span>|</span><a href="#37603611">next</a><span>|</span><label class="collapse" for="c-37609444">[-]</label><label class="expand" for="c-37609444">[1 more]</label></div><br/><div class="children"><div class="content">This is a really nice post and series. I&#x27;m curious how you&#x27;re doing the profiling and then generating the flame graphs e.g. in <a href="https:&#x2F;&#x2F;marvinh.dev&#x2F;blog&#x2F;speeding-up-javascript-ecosystem&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;marvinh.dev&#x2F;blog&#x2F;speeding-up-javascript-ecosystem&#x2F;</a>. Is this Chrome&#x27;s built-in devtools being used or something else?</div><br/></div></div><div id="37603611" class="c"><input type="checkbox" id="c-37603611" checked=""/><div class="controls bullet"><span class="by">petetnt</span><span>|</span><a href="#37609444">prev</a><span>|</span><a href="#37606256">next</a><span>|</span><label class="collapse" for="c-37603611">[-]</label><label class="expand" for="c-37603611">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really care to comment about the practice itself, but the &quot;Polyfills that don’t polyfill&quot; section is missing the point: the function is called directly instead of patching the global object so that the global object is not polluted by an possibly non-standard implementation. Additionally it does use Object.defineProperty if available - furthermore it doesn&#x27;t even call itself a polyfill in the first place. If it&#x27;s needed in 2023 is a valid point however.</div><br/><div id="37603677" class="c"><input type="checkbox" id="c-37603677" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#37603611">parent</a><span>|</span><a href="#37606256">next</a><span>|</span><label class="collapse" for="c-37603677">[-]</label><label class="expand" for="c-37603677">[3 more]</label></div><br/><div class="children"><div class="content">I think it would be better to just expect the standardized functions to be present and then document that the project needs them (e.g. via peer dependencies), allowing users to install them themselves as needed.</div><br/><div id="37604040" class="c"><input type="checkbox" id="c-37604040" checked=""/><div class="controls bullet"><span class="by">shpx</span><span>|</span><a href="#37603611">root</a><span>|</span><a href="#37603677">parent</a><span>|</span><a href="#37606256">next</a><span>|</span><label class="collapse" for="c-37604040">[-]</label><label class="expand" for="c-37604040">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a lot more work than your library just working in more places.</div><br/><div id="37604159" class="c"><input type="checkbox" id="c-37604159" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#37603611">root</a><span>|</span><a href="#37604040">parent</a><span>|</span><a href="#37606256">next</a><span>|</span><label class="collapse" for="c-37604159">[-]</label><label class="expand" for="c-37604159">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think it’s all that much more: basically every bundler I’ve used uses browserslist to include polyfills for the developer’s target audience.<p>But, also, I think this sort of easy path inflicts a huge cost on the ecosystem as a whole: writing to the standards and expecting your users to supply a compliant environment solves a lot of N*M problems in the dev process.</div><br/></div></div></div></div></div></div></div></div><div id="37606256" class="c"><input type="checkbox" id="c-37606256" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#37603611">prev</a><span>|</span><a href="#37606707">next</a><span>|</span><label class="collapse" for="c-37606256">[-]</label><label class="expand" for="c-37606256">[2 more]</label></div><br/><div class="children"><div class="content">Sometimes it can be a security vulnerability to call a polyfill instead of the now available default implementation. For example, this 2018 bug [0] in the Grammarly Chrome Extension had a much wider impact due to its reliance on a fetch polyfill that was able to make requests (via XHR) to origins that native fetch could not.<p>I suppose in that case you could argue the real bug is in the XHR API, but it only affected the extension because the extension was using a fetch polyfill that relied on it in functions that could be triggered by an external page.<p>[0] <a href="https:&#x2F;&#x2F;hackerone.com&#x2F;reports&#x2F;389108" rel="nofollow noreferrer">https:&#x2F;&#x2F;hackerone.com&#x2F;reports&#x2F;389108</a></div><br/><div id="37608409" class="c"><input type="checkbox" id="c-37608409" checked=""/><div class="controls bullet"><span class="by">mhagemeister</span><span>|</span><a href="#37606256">parent</a><span>|</span><a href="#37606707">next</a><span>|</span><label class="collapse" for="c-37608409">[-]</label><label class="expand" for="c-37608409">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a very good point. Didn&#x27;t know about the grammarly incident. I could definitely see this happening again with the amount of polyfills in npm packages. Polyfills are usually frozen in time and not developed further after they are released.</div><br/></div></div></div></div><div id="37606707" class="c"><input type="checkbox" id="c-37606707" checked=""/><div class="controls bullet"><span class="by">jongjong</span><span>|</span><a href="#37606256">prev</a><span>|</span><a href="#37603516">next</a><span>|</span><label class="collapse" for="c-37606707">[-]</label><label class="expand" for="c-37606707">[1 more]</label></div><br/><div class="children"><div class="content">In the early days of the Node.js ecosystem, there was a trend which was all about &#x27;tiny modules&#x27;; many developers published tiny 10-line or so modules and people in the community were promoting these tiny modules really hard. It went a bit out of control and a lot of higher level modules were including many of those tiny modules, then those modules were themselves included into other, even higher level modules, etc... The number of modules used by some of these higher level modules&#x2F;tools&#x2F;frameworks grew exponentially and we ended up with a lot of unnecessary dependencies.<p>Each tiny module did just a bit more than it should have done or included just one more dependency than was necessary, sometimes the scope of the module would grow over time and all this added up. Also, different sub-modules used different sub-sub-modules for the same functionality so this caused a lot of duplication in the higher level modules.<p>For my own open source project, I&#x27;ve always been very careful about which dependencies I use. I favor module authors who try to keep their number of dependencies to a minimum. A lot of times, it comes down to figuring out the correct scope of the module... Most low level libraries should not need to do their own logging; therefore, they should not need to include sub-modules to colorize the bash output; instead, they should just emit events and let higher level modules handle the logging. Anyway there are many cases like that where modules give themselves too much scope.</div><br/></div></div><div id="37603516" class="c"><input type="checkbox" id="c-37603516" checked=""/><div class="controls bullet"><span class="by">jluxenberg</span><span>|</span><a href="#37606707">prev</a><span>|</span><a href="#37603246">next</a><span>|</span><label class="collapse" for="c-37603516">[-]</label><label class="expand" for="c-37603516">[6 more]</label></div><br/><div class="children"><div class="content">For what it&#x27;s worth; `eslint-plugin-react` has been around for a long time and seems to support running in very old versions of Node.JS (back to v4[1] apparently! tho I can&#x27;t find anything documenting that for sure.)<p>I was surprised to learn that Object.values is only supported in Node &gt;v7, Object.fronEntries was added in v12, etc. So for this project maybe the polyfills are needed.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;jsx-eslint&#x2F;eslint-plugin-react&#x2F;pull&#x2F;1038">https:&#x2F;&#x2F;github.com&#x2F;jsx-eslint&#x2F;eslint-plugin-react&#x2F;pull&#x2F;1038</a></div><br/><div id="37605617" class="c"><input type="checkbox" id="c-37605617" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#37603516">parent</a><span>|</span><a href="#37604115">next</a><span>|</span><label class="collapse" for="c-37605617">[-]</label><label class="expand" for="c-37605617">[1 more]</label></div><br/><div class="children"><div class="content">There are two separate questions:<p>&quot;Should libraries still be polyfilling to support ancient runtimes?&quot; and &quot;How should that polyfilling be implemented?&quot;<p>Even if a library wants to maintain backwards compatibility, we can still argue  this method of polyfilling (especially the phony polyfills) is damaging to the wider javascript ecosystem.<p>In an ideal world, the cost of polyfills for developers who don&#x27;t need them should be zero.<p>For developers using bundlers, the bundler is expected to implement any required polyfills for the developer&#x27;s targeted runtimes, and having the library ship with it&#x27;s own polyfills is counterproductive at best. However, I suspect these libraries wish to maintain compatibility for developers not using bundlers.<p>Maybe npm should be upgraded to support multiple variants of packages? That way these libraries could ship both polyfilled and non-polyfilled versions of their packages in parallel.</div><br/></div></div><div id="37604115" class="c"><input type="checkbox" id="c-37604115" checked=""/><div class="controls bullet"><span class="by">mhagemeister</span><span>|</span><a href="#37603516">parent</a><span>|</span><a href="#37605617">prev</a><span>|</span><a href="#37604231">next</a><span>|</span><label class="collapse" for="c-37604115">[-]</label><label class="expand" for="c-37604115">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, engines are a moving target. I&#x27;m all for backwards compatibility, but I&#x27;m worried about promoting old node versions with known unpatched security issues. Given that eslint itself only supports node &gt;= 12.22.0 it seems like it&#x27;s time to get rid of the polyfills.<p>I wish we as in the industry would find a better solution to adapt to this. It&#x27;s a bit unfortunate that the polyfills as part of the library code itself, which makes it difficult to get rid of them once they&#x27;re not needed anymore.</div><br/></div></div><div id="37604231" class="c"><input type="checkbox" id="c-37604231" checked=""/><div class="controls bullet"><span class="by">gigel82</span><span>|</span><a href="#37603516">parent</a><span>|</span><a href="#37604115">prev</a><span>|</span><a href="#37603246">next</a><span>|</span><label class="collapse" for="c-37604231">[-]</label><label class="expand" for="c-37604231">[3 more]</label></div><br/><div class="children"><div class="content">Genuinely curious, are there people out there using newer versions of this package with old &#x2F; unsupported versions of Node (in production)?</div><br/><div id="37605419" class="c"><input type="checkbox" id="c-37605419" checked=""/><div class="controls bullet"><span class="by">silverwind</span><span>|</span><a href="#37603516">root</a><span>|</span><a href="#37604231">parent</a><span>|</span><a href="#37605673">next</a><span>|</span><label class="collapse" for="c-37605419">[-]</label><label class="expand" for="c-37605419">[1 more]</label></div><br/><div class="children"><div class="content">Not really. Adoption of new Node versions is quite quick, given their short support periods.<p><a href="https:&#x2F;&#x2F;nodejs.org&#x2F;metrics&#x2F;summaries&#x2F;version.png" rel="nofollow noreferrer">https:&#x2F;&#x2F;nodejs.org&#x2F;metrics&#x2F;summaries&#x2F;version.png</a></div><br/></div></div><div id="37605673" class="c"><input type="checkbox" id="c-37605673" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#37603516">root</a><span>|</span><a href="#37604231">parent</a><span>|</span><a href="#37605419">prev</a><span>|</span><a href="#37603246">next</a><span>|</span><label class="collapse" for="c-37605673">[-]</label><label class="expand" for="c-37605673">[1 more]</label></div><br/><div class="children"><div class="content">It probably happens, but not really on purpose.<p>If the package.lock file gets deleted or someone runs a global npm-update then npm will update any packages while respecting semantic versioning.<p>It&#x27;s possible an organisation forgot to include the package.lock file in their deployment image and they get updated npm packages every time they redeploy. It&#x27;s also possible a developer making minor changes to a legacy system triggers packages to be updated, perhaps without even noticing.</div><br/></div></div></div></div></div></div><div id="37603246" class="c"><input type="checkbox" id="c-37603246" checked=""/><div class="controls bullet"><span class="by">azemetre</span><span>|</span><a href="#37603516">prev</a><span>|</span><a href="#37607541">next</a><span>|</span><label class="collapse" for="c-37603246">[-]</label><label class="expand" for="c-37603246">[4 more]</label></div><br/><div class="children"><div class="content">This series is great!<p>You should seriously think about consolidating them into a book. Something I notice other engineers struggle with is how to properly assess performance, read heap snapshots, or even understand how to read a flamegraph for stack tracing tools. It would be nice to point, or buy, them a resource showing this.<p>I&#x27;d definitely buy a copy.</div><br/><div id="37603432" class="c"><input type="checkbox" id="c-37603432" checked=""/><div class="controls bullet"><span class="by">bjnewman85</span><span>|</span><a href="#37603246">parent</a><span>|</span><a href="#37607541">next</a><span>|</span><label class="collapse" for="c-37603432">[-]</label><label class="expand" for="c-37603432">[3 more]</label></div><br/><div class="children"><div class="content">Second that, I would definitely buy a book based on this series.</div><br/><div id="37604249" class="c"><input type="checkbox" id="c-37604249" checked=""/><div class="controls bullet"><span class="by">mhagemeister</span><span>|</span><a href="#37603246">root</a><span>|</span><a href="#37603432">parent</a><span>|</span><a href="#37607541">next</a><span>|</span><label class="collapse" for="c-37604249">[-]</label><label class="expand" for="c-37604249">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for the kind feedback! It&#x27;s definitely something in the back of my mind. I feel like I need to collect a little more content to fill a whole book, but I&#x27;m enticed by the thought of writing one nonetheless.</div><br/><div id="37605050" class="c"><input type="checkbox" id="c-37605050" checked=""/><div class="controls bullet"><span class="by">leipert</span><span>|</span><a href="#37603246">root</a><span>|</span><a href="#37604249">parent</a><span>|</span><a href="#37607541">next</a><span>|</span><label class="collapse" for="c-37605050">[-]</label><label class="expand" for="c-37605050">[1 more]</label></div><br/><div class="children"><div class="content">Part 3 send me down a debugging route of eslint performance in the GitLab project and we were able to move from 25 min of listing time in CI, down to 5. So, thanks for the inspiration!</div><br/></div></div></div></div></div></div></div></div><div id="37607541" class="c"><input type="checkbox" id="c-37607541" checked=""/><div class="controls bullet"><span class="by">wonderfuly</span><span>|</span><a href="#37603246">prev</a><span>|</span><a href="#37607094">next</a><span>|</span><label class="collapse" for="c-37607541">[-]</label><label class="expand" for="c-37607541">[1 more]</label></div><br/><div class="children"><div class="content">Checkout <a href="https:&#x2F;&#x2F;github.com&#x2F;SukkaW&#x2F;nolyfill">https:&#x2F;&#x2F;github.com&#x2F;SukkaW&#x2F;nolyfill</a></div><br/></div></div><div id="37607094" class="c"><input type="checkbox" id="c-37607094" checked=""/><div class="controls bullet"><span class="by">deevus</span><span>|</span><a href="#37607541">prev</a><span>|</span><a href="#37603971">next</a><span>|</span><label class="collapse" for="c-37607094">[-]</label><label class="expand" for="c-37607094">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t got much experience with WASM, but is dependency hell something that WASM completely solves?<p>All of the cruft that you don&#x27;t use will get optimised away by the compiler, right?<p>I&#x27;m not aware of any production ready WASM frameworks, but I&#x27;m ready for it.</div><br/></div></div></div></div></div></div></div></body></html>