<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732784458451" as="style"/><link rel="stylesheet" href="styles.css?v=1732784458451"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/coralblocks/CoralRing">Ultra-low-latency, batching and concurrent queue for IPC in Java</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>eatonphil</span> | <span>31 comments</span></div><br/><div><div id="42261631" class="c"><input type="checkbox" id="c-42261631" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#42263378">next</a><span>|</span><label class="collapse" for="c-42261631">[-]</label><label class="expand" for="c-42261631">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;coralblocks&#x2F;CoralRing&#x2F;blob&#x2F;1168b047e0183c9195ab48505e43e8fb2faea73d&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;coralblocks&#x2F;coralring&#x2F;ring&#x2F;BlockingRingConsumer.java#L190">https:&#x2F;&#x2F;github.com&#x2F;coralblocks&#x2F;CoralRing&#x2F;blob&#x2F;1168b047e0183c...</a><p>Am I missing something here or does the BlockingRingConsumer not actually block? And worse doesn&#x27;t it just return garbage if poll is called without first checking availableToPoll?<p>The example sure looks like it... <a href="https:&#x2F;&#x2F;github.com&#x2F;coralblocks&#x2F;CoralRing&#x2F;blob&#x2F;main&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;coralblocks&#x2F;coralring&#x2F;example&#x2F;ring&#x2F;BlockingConsumer.java">https:&#x2F;&#x2F;github.com&#x2F;coralblocks&#x2F;CoralRing&#x2F;blob&#x2F;main&#x2F;src&#x2F;main&#x2F;...</a><p>Which if so isn&#x27;t this like 1&#x2F;4th a library for doing IPC? It doesn&#x27;t seem to do much itself</div><br/></div></div><div id="42263378" class="c"><input type="checkbox" id="c-42263378" checked=""/><div class="controls bullet"><span class="by">pacoverdi</span><span>|</span><a href="#42261631">prev</a><span>|</span><a href="#42259867">next</a><span>|</span><label class="collapse" for="c-42263378">[-]</label><label class="expand" for="c-42263378">[1 more]</label></div><br/><div class="children"><div class="content">Related: <a href="https:&#x2F;&#x2F;github.com&#x2F;pcdv&#x2F;jocket">https:&#x2F;&#x2F;github.com&#x2F;pcdv&#x2F;jocket</a><p>Drop-in replacement for java.net.Socket using shared memory (and optionally, futex for notification)</div><br/></div></div><div id="42259867" class="c"><input type="checkbox" id="c-42259867" checked=""/><div class="controls bullet"><span class="by">WeaselNo7</span><span>|</span><a href="#42263378">prev</a><span>|</span><a href="#42263122">next</a><span>|</span><label class="collapse" for="c-42259867">[-]</label><label class="expand" for="c-42259867">[8 more]</label></div><br/><div class="children"><div class="content">Weird to see this here!  I&#x27;ve used CoralBlocks in the low-latency trading domain previously.  Highly recommend.  The API is kind, they&#x27;re very responsive, and the latency is exceptional (and comes with all the basics like thread pinning built-in for convenience)</div><br/><div id="42260480" class="c"><input type="checkbox" id="c-42260480" checked=""/><div class="controls bullet"><span class="by">smarx007</span><span>|</span><a href="#42259867">parent</a><span>|</span><a href="#42260555">next</a><span>|</span><label class="collapse" for="c-42260480">[-]</label><label class="expand" for="c-42260480">[3 more]</label></div><br/><div class="children"><div class="content">How does it compare to LMAX Disruptor if you have any experience with both?</div><br/><div id="42261077" class="c"><input type="checkbox" id="c-42261077" checked=""/><div class="controls bullet"><span class="by">papercrane</span><span>|</span><a href="#42259867">root</a><span>|</span><a href="#42260480">parent</a><span>|</span><a href="#42260555">next</a><span>|</span><label class="collapse" for="c-42261077">[-]</label><label class="expand" for="c-42261077">[2 more]</label></div><br/><div class="children"><div class="content">They&#x27;re both similar in design, the main difference is Coral Queue can be used for IPC between JVMs, using a mmap&#x27;d file.</div><br/><div id="42261638" class="c"><input type="checkbox" id="c-42261638" checked=""/><div class="controls bullet"><span class="by">arnold_palmur</span><span>|</span><a href="#42259867">root</a><span>|</span><a href="#42261077">parent</a><span>|</span><a href="#42260555">next</a><span>|</span><label class="collapse" for="c-42261638">[-]</label><label class="expand" for="c-42261638">[1 more]</label></div><br/><div class="children"><div class="content">See <a href="https:&#x2F;&#x2F;github.com&#x2F;real-logic&#x2F;aeron">https:&#x2F;&#x2F;github.com&#x2F;real-logic&#x2F;aeron</a> (also from the creator of the disruptor)</div><br/></div></div></div></div></div></div><div id="42260555" class="c"><input type="checkbox" id="c-42260555" checked=""/><div class="controls bullet"><span class="by">algo_trader</span><span>|</span><a href="#42259867">parent</a><span>|</span><a href="#42260480">prev</a><span>|</span><a href="#42260628">next</a><span>|</span><label class="collapse" for="c-42260555">[-]</label><label class="expand" for="c-42260555">[2 more]</label></div><br/><div class="children"><div class="content">&gt; CoralBlocks in the low-latency trading domain previously.<p>Yeah, modern JVM is a true miracle and you can be x5 productive (and safe!) compared to C&#x2F;C++<p>Do you have any recommendations for a low latency work queue (with in a jvm)?<p>I want to spawn millions of micro-second-tasks per second, to worker cores..<p>I am on a massive cache CPU so memory latency hasnt raised its ugly head yet<p>EDIT: not LMAX please...</div><br/><div id="42263596" class="c"><input type="checkbox" id="c-42263596" checked=""/><div class="controls bullet"><span class="by">jffhn</span><span>|</span><a href="#42259867">root</a><span>|</span><a href="#42260555">parent</a><span>|</span><a href="#42260628">next</a><span>|</span><label class="collapse" for="c-42263596">[-]</label><label class="expand" for="c-42263596">[1 more]</label></div><br/><div class="children"><div class="content">&gt;any recommendations for a low latency work queue (with in a jvm)?<p>I toyed around the ring buffer pattern a decade ago, creating a unicast one (using CAS on entries, and eventually a logarithmic scan for next readable entry, not to brute-force-scan them all), but I&#x27;m not sure that its latency is much better than that of a regular ThreadPoolExecutor (the throughput could be better though).<p>Latency also depends on whether it spins or blocks when waiting for a slot to read or write.<p>If you want to give it a try:
<a href="https:&#x2F;&#x2F;github.com&#x2F;jeffhain&#x2F;jodk&#x2F;blob&#x2F;master&#x2F;src&#x2F;net&#x2F;jodk&#x2F;threading&#x2F;ringbuffers&#x2F;UnicastRingBuffer.java">https:&#x2F;&#x2F;github.com&#x2F;jeffhain&#x2F;jodk&#x2F;blob&#x2F;master&#x2F;src&#x2F;net&#x2F;jodk&#x2F;th...</a></div><br/></div></div></div></div><div id="42260628" class="c"><input type="checkbox" id="c-42260628" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#42259867">parent</a><span>|</span><a href="#42260555">prev</a><span>|</span><a href="#42263122">next</a><span>|</span><label class="collapse" for="c-42260628">[-]</label><label class="expand" for="c-42260628">[2 more]</label></div><br/><div class="children"><div class="content">Given the documentation says that this is supposedly to be between JVMs, how do they handle the serialize&#x2F;deserialize?</div><br/><div id="42260931" class="c"><input type="checkbox" id="c-42260931" checked=""/><div class="controls bullet"><span class="by">kasey_junk</span><span>|</span><a href="#42259867">root</a><span>|</span><a href="#42260628">parent</a><span>|</span><a href="#42263122">next</a><span>|</span><label class="collapse" for="c-42260931">[-]</label><label class="expand" for="c-42260931">[1 more]</label></div><br/><div class="children"><div class="content">They punt on the actual serialization format: <a href="https:&#x2F;&#x2F;www.coralblocks.com&#x2F;index.php&#x2F;inter-process-communication-with-coralqueue&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.coralblocks.com&#x2F;index.php&#x2F;inter-process-communic...</a><p>In most applications like this you&#x27;ll see direct byte manipulation to byte buffers because you want to pull as much performance as possible.<p>There are fast serialization formats like SBE that people leverage for this as well.</div><br/></div></div></div></div></div></div><div id="42263122" class="c"><input type="checkbox" id="c-42263122" checked=""/><div class="controls bullet"><span class="by">nwellinghoff</span><span>|</span><a href="#42259867">prev</a><span>|</span><a href="#42261935">next</a><span>|</span><label class="collapse" for="c-42263122">[-]</label><label class="expand" for="c-42263122">[7 more]</label></div><br/><div class="children"><div class="content">I don’t get it. How is this advantageous as it’s limited to one machine? Why wouldn’t you just have one jvm running multiple threads? What is the point of having multiple jvm processes interacting through this ring? Can someone enlighten me?</div><br/><div id="42263394" class="c"><input type="checkbox" id="c-42263394" checked=""/><div class="controls bullet"><span class="by">gunnarmorling</span><span>|</span><a href="#42263122">parent</a><span>|</span><a href="#42263497">next</a><span>|</span><label class="collapse" for="c-42263394">[-]</label><label class="expand" for="c-42263394">[1 more]</label></div><br/><div class="children"><div class="content">A few potential reasons for this design coming to mind:<p>- Resource allocation; you might want to give just specific amount of memory, CPU, network I&#x2F;O to specific modules of a system, which is not really feasible within a single JVM<p>- Resource isolation; e.g. a memory leak in one module of the system will affect just that specific JVM instance but not others (similar to why browsers run tabs in multiple processes);<p>- Upgrades; you can put a new version of one module of the system into place without impacting the others; while the JVM does support this via dynamic classloading (as e.g. used in OSGi or Layrry, <a href="https:&#x2F;&#x2F;github.com&#x2F;moditect&#x2F;layrry">https:&#x2F;&#x2F;github.com&#x2F;moditect&#x2F;layrry</a>), this becomes complex quickly, you can create classloader leaks, etc.<p>- Security; You might have (3rd-party) modules you want to keep isolated from the memory, data, config, etc. of other modules; in particular with the removal of the security manager, OS-enforced process isolation is the way to</div><br/></div></div><div id="42263497" class="c"><input type="checkbox" id="c-42263497" checked=""/><div class="controls bullet"><span class="by">nlitened</span><span>|</span><a href="#42263122">parent</a><span>|</span><a href="#42263394">prev</a><span>|</span><a href="#42263412">next</a><span>|</span><label class="collapse" for="c-42263497">[-]</label><label class="expand" for="c-42263497">[1 more]</label></div><br/><div class="children"><div class="content">I can throw some guesses: 1) apps deployed in separate Docker containers due to organization&#x27;s tech team separation, 2) apps that require security&#x2F;performance isolation among tenants, 3) isolation layer around memory-leaky and bug-prone third-party library code.</div><br/></div></div><div id="42263412" class="c"><input type="checkbox" id="c-42263412" checked=""/><div class="controls bullet"><span class="by">defer</span><span>|</span><a href="#42263122">parent</a><span>|</span><a href="#42263497">prev</a><span>|</span><a href="#42261935">next</a><span>|</span><label class="collapse" for="c-42263412">[-]</label><label class="expand" for="c-42263412">[4 more]</label></div><br/><div class="children"><div class="content">JVM does garbage collection, this can stop all threads at safepoints while GC occurs.<p>Those stops can be enough to ruin your low latency requirements in the high percentiles. A common strategy is to divide workloads between jvms so that you meet the requirement.</div><br/><div id="42263442" class="c"><input type="checkbox" id="c-42263442" checked=""/><div class="controls bullet"><span class="by">nwellinghoff</span><span>|</span><a href="#42263122">root</a><span>|</span><a href="#42263412">parent</a><span>|</span><a href="#42261935">next</a><span>|</span><label class="collapse" for="c-42263442">[-]</label><label class="expand" for="c-42263442">[3 more]</label></div><br/><div class="children"><div class="content">Interesting. But how do you ensure a worker that picks up a task does not pause on gc as well?</div><br/><div id="42263579" class="c"><input type="checkbox" id="c-42263579" checked=""/><div class="controls bullet"><span class="by">dikei</span><span>|</span><a href="#42263122">root</a><span>|</span><a href="#42263442">parent</a><span>|</span><a href="#42261935">next</a><span>|</span><label class="collapse" for="c-42263579">[-]</label><label class="expand" for="c-42263579">[2 more]</label></div><br/><div class="children"><div class="content">Maybe they run a small heap with a zero-pause JVM like Zing, as pause-less GC generally has lower throughput than normal GC.</div><br/><div id="42263630" class="c"><input type="checkbox" id="c-42263630" checked=""/><div class="controls bullet"><span class="by">pebal</span><span>|</span><a href="#42263122">root</a><span>|</span><a href="#42263579">parent</a><span>|</span><a href="#42261935">next</a><span>|</span><label class="collapse" for="c-42263630">[-]</label><label class="expand" for="c-42263630">[1 more]</label></div><br/><div class="children"><div class="content">Java doesn&#x27;t have real pause-less GC.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42261935" class="c"><input type="checkbox" id="c-42261935" checked=""/><div class="controls bullet"><span class="by">peterldowns</span><span>|</span><a href="#42263122">prev</a><span>|</span><a href="#42260498">next</a><span>|</span><label class="collapse" for="c-42261935">[-]</label><label class="expand" for="c-42261935">[1 more]</label></div><br/><div class="children"><div class="content">Does anyone have suggestions for something like this, but in Golang?</div><br/></div></div><div id="42260498" class="c"><input type="checkbox" id="c-42260498" checked=""/><div class="controls bullet"><span class="by">exabrial</span><span>|</span><a href="#42261935">prev</a><span>|</span><a href="#42260698">next</a><span>|</span><label class="collapse" for="c-42260498">[-]</label><label class="expand" for="c-42260498">[2 more]</label></div><br/><div class="children"><div class="content">This is fascinating. I have no idea what something like this would be used for though... what are the use cases?</div><br/><div id="42260578" class="c"><input type="checkbox" id="c-42260578" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#42260498">parent</a><span>|</span><a href="#42260698">next</a><span>|</span><label class="collapse" for="c-42260578">[-]</label><label class="expand" for="c-42260578">[1 more]</label></div><br/><div class="children"><div class="content">Basically if you want to schedule workers on a separate JVM, but don&#x27;t want to pay the latency cost of something like a DB-backed queue or a library with some FFI component.</div><br/></div></div></div></div><div id="42260698" class="c"><input type="checkbox" id="c-42260698" checked=""/><div class="controls bullet"><span class="by">capmorganbih</span><span>|</span><a href="#42260498">prev</a><span>|</span><label class="collapse" for="c-42260698">[-]</label><label class="expand" for="c-42260698">[10 more]</label></div><br/><div class="children"><div class="content">Our kafka isn’t reliable enough. I need to write data on disk before flushing it to kafka. Can I use this lis to write data to disk and then consume inside same jvm. I need data to live through restarts</div><br/><div id="42260939" class="c"><input type="checkbox" id="c-42260939" checked=""/><div class="controls bullet"><span class="by">kasey_junk</span><span>|</span><a href="#42260698">parent</a><span>|</span><a href="#42260903">next</a><span>|</span><label class="collapse" for="c-42260939">[-]</label><label class="expand" for="c-42260939">[4 more]</label></div><br/><div class="children"><div class="content">You could but its not purpose built for that.  You&#x27;d probably be happier using some other memory mapped file format for that.</div><br/><div id="42261015" class="c"><input type="checkbox" id="c-42261015" checked=""/><div class="controls bullet"><span class="by">capmorganbih</span><span>|</span><a href="#42260698">root</a><span>|</span><a href="#42260939">parent</a><span>|</span><a href="#42260903">next</a><span>|</span><label class="collapse" for="c-42261015">[-]</label><label class="expand" for="c-42261015">[3 more]</label></div><br/><div class="children"><div class="content">Could you please suggest java library for this if you know one?</div><br/><div id="42261069" class="c"><input type="checkbox" id="c-42261069" checked=""/><div class="controls bullet"><span class="by">kasey_junk</span><span>|</span><a href="#42260698">root</a><span>|</span><a href="#42261015">parent</a><span>|</span><a href="#42262633">next</a><span>|</span><label class="collapse" for="c-42261069">[-]</label><label class="expand" for="c-42261069">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;OpenHFT&#x2F;Chronicle-Queue?tab=readme-ov-file#what-is-chronicle-queue">https:&#x2F;&#x2F;github.com&#x2F;OpenHFT&#x2F;Chronicle-Queue?tab=readme-ov-fil...</a></div><br/></div></div><div id="42262633" class="c"><input type="checkbox" id="c-42262633" checked=""/><div class="controls bullet"><span class="by">avinassh</span><span>|</span><a href="#42260698">root</a><span>|</span><a href="#42261015">parent</a><span>|</span><a href="#42261069">prev</a><span>|</span><a href="#42260903">next</a><span>|</span><label class="collapse" for="c-42262633">[-]</label><label class="expand" for="c-42262633">[1 more]</label></div><br/><div class="children"><div class="content">crazy idea, but SQLite</div><br/></div></div></div></div></div></div><div id="42260903" class="c"><input type="checkbox" id="c-42260903" checked=""/><div class="controls bullet"><span class="by">sriram_malhar</span><span>|</span><a href="#42260698">parent</a><span>|</span><a href="#42260939">prev</a><span>|</span><a href="#42262613">next</a><span>|</span><label class="collapse" for="c-42260903">[-]</label><label class="expand" for="c-42260903">[4 more]</label></div><br/><div class="children"><div class="content">Can you explain what your issue is with Kafka? What makes it not reliable enough?</div><br/><div id="42261011" class="c"><input type="checkbox" id="c-42261011" checked=""/><div class="controls bullet"><span class="by">capmorganbih</span><span>|</span><a href="#42260698">root</a><span>|</span><a href="#42260903">parent</a><span>|</span><a href="#42262613">next</a><span>|</span><label class="collapse" for="c-42261011">[-]</label><label class="expand" for="c-42261011">[3 more]</label></div><br/><div class="children"><div class="content">Kafka is good. The problem is we don’t have a dedicated person to manage it so sometimes we have kafka outages</div><br/><div id="42263341" class="c"><input type="checkbox" id="c-42263341" checked=""/><div class="controls bullet"><span class="by">dikei</span><span>|</span><a href="#42260698">root</a><span>|</span><a href="#42261011">parent</a><span>|</span><a href="#42262556">next</a><span>|</span><label class="collapse" for="c-42263341">[-]</label><label class="expand" for="c-42263341">[1 more]</label></div><br/><div class="children"><div class="content">So basically, you want to build a write-ahead-log before writing data to Kafka, and I think you&#x27;re underestimating the effort to implement a WAL.<p>If you don&#x27;t have a person that can manage Kafka, you almost definitely don&#x27;t have the person to maintain a WAL.</div><br/></div></div><div id="42262556" class="c"><input type="checkbox" id="c-42262556" checked=""/><div class="controls bullet"><span class="by">jojohohanon</span><span>|</span><a href="#42260698">root</a><span>|</span><a href="#42261011">parent</a><span>|</span><a href="#42263341">prev</a><span>|</span><a href="#42262613">next</a><span>|</span><label class="collapse" for="c-42262556">[-]</label><label class="expand" for="c-42262556">[1 more]</label></div><br/><div class="children"><div class="content">There’s a whole conference in Vegas next week that want to sell you something.</div><br/></div></div></div></div></div></div><div id="42262613" class="c"><input type="checkbox" id="c-42262613" checked=""/><div class="controls bullet"><span class="by">dingi</span><span>|</span><a href="#42260698">parent</a><span>|</span><a href="#42260903">prev</a><span>|</span><label class="collapse" for="c-42262613">[-]</label><label class="expand" for="c-42262613">[1 more]</label></div><br/><div class="children"><div class="content">Write your data to a MognoDB database. Then use the Kafka Mongo connector to pull data from MongoDB to Kafka.</div><br/></div></div></div></div></div></div></div></div></div></body></html>