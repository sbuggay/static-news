<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1697274059207" as="style"/><link rel="stylesheet" href="styles.css?v=1697274059207"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://utcc.utoronto.ca/~cks/space/blog/unix/OpenBSDPfStatesAndDoS">OpenBSD PF-based firewalls suffer differently from denial of service attacks</a> <span class="domain">(<a href="https://utcc.utoronto.ca">utcc.utoronto.ca</a>)</span></div><div class="subtext"><span>mfrw</span> | <span>9 comments</span></div><br/><div><div id="37878694" class="c"><input type="checkbox" id="c-37878694" checked=""/><div class="controls bullet"><span class="by">cookiengineer</span><span>|</span><a href="#37878512">next</a><span>|</span><label class="collapse" for="c-37878694">[-]</label><label class="expand" for="c-37878694">[6 more]</label></div><br/><div class="children"><div class="content">In my opinion Linux and eBPF is considerably better and more flexible when it comes to firewalling and deep packet inspection based blocking.<p>The mentioned use case perfectly fits the eBPF XDP module&#x27;s feature set, and could easily be mitigated with the LPM trie offered by the kernel.<p>I wish that in those regards BSD maintainers would start to cooperate more with Linux, because everybody benefits from cross-kernel compatibility when it comes to eBPF.<p>I always admired the BSD maintainers, back in the days they were very innovative but I always have the feeling that at some point when their innovations take off they just stop following up with it due to either very opinionated views or lack of interest. Especially with the ongoing eBPF community.</div><br/><div id="37878713" class="c"><input type="checkbox" id="c-37878713" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#37878694">parent</a><span>|</span><a href="#37878911">next</a><span>|</span><label class="collapse" for="c-37878713">[-]</label><label class="expand" for="c-37878713">[4 more]</label></div><br/><div class="children"><div class="content">This presupposes that ebpf is obviously the one true solution and everything should use it. I would prefer that we avoid monocultures.</div><br/><div id="37878724" class="c"><input type="checkbox" id="c-37878724" checked=""/><div class="controls bullet"><span class="by">cookiengineer</span><span>|</span><a href="#37878694">root</a><span>|</span><a href="#37878713">parent</a><span>|</span><a href="#37878911">next</a><span>|</span><label class="collapse" for="c-37878724">[-]</label><label class="expand" for="c-37878724">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a mono culture but the idea of true cross-platform APIs that could make supporting BSD kernels much much easier in both terms of development time and interoperability.<p>&gt; I would prefer that we avoid monocultures.<p>Where were you to say &quot;Stop the C and POSIX monoculture&quot;, because that&#x27;s a pretty opinionated view on how to build kernels, too, you know.<p>I&#x27;d prefer interoperability over having to implement everything myself all the time, any day.</div><br/><div id="37878765" class="c"><input type="checkbox" id="c-37878765" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#37878694">root</a><span>|</span><a href="#37878724">parent</a><span>|</span><a href="#37878911">next</a><span>|</span><label class="collapse" for="c-37878765">[-]</label><label class="expand" for="c-37878765">[2 more]</label></div><br/><div class="children"><div class="content">People <i>do</i> regularly point out that POSIX limits exploration of interesting ideas in computing, and a segment of the community is actively attempting to deprecate C. I think it&#x27;s a continuum; I personally think being unix-like is a useful baseline without being too limiting, but the cost&#x2F;benefit rapidly degrades after that. As a topical example, I&#x27;m glad that everything didn&#x27;t adopt iptables, because pf seems to be more friendly to work with. I don&#x27;t <i>mind</i> ebpf, but I wouldn&#x27;t be surprised to see one of the BSDs leapfrog it.</div><br/><div id="37878856" class="c"><input type="checkbox" id="c-37878856" checked=""/><div class="controls bullet"><span class="by">cookiengineer</span><span>|</span><a href="#37878694">root</a><span>|</span><a href="#37878765">parent</a><span>|</span><a href="#37878911">next</a><span>|</span><label class="collapse" for="c-37878856">[-]</label><label class="expand" for="c-37878856">[1 more]</label></div><br/><div class="children"><div class="content">My point of view is always a little too much security focussed when it comes to kernel mod dev. I completely agree with embracing Rust and other memory safe languages. Hence why I think eBPF has huge potential due to their CORE abstractions that are very strict in terms of memory management and validation.<p>But when the source code of the NSA&#x27;s ebpf malware was leaked, I got concerned because currently there is no failsafe way to audit a running kernel.<p>I think that the logical conclusion to this has to be something like a manifest file for each running kernel module, and a better feature-based sandbox for each module that is running or hooked (e.g. usb, network, filesystem, home folder etc). Similar to how Android&#x27;s sandboxes are designed, but with a concept that is able to sandbox kernel mods, too.<p>Seccomp sandboxes are not enough, and there is gonna be a decade of new ebpf malware ahead of us.<p>I wish that rust got more traction, because that would at least solve all the pointer corruptions and overflows that can&#x2F;are going wrong in module codebases.</div><br/></div></div></div></div></div></div></div></div><div id="37878911" class="c"><input type="checkbox" id="c-37878911" checked=""/><div class="controls bullet"><span class="by">gigatexal</span><span>|</span><a href="#37878694">parent</a><span>|</span><a href="#37878713">prev</a><span>|</span><a href="#37878512">next</a><span>|</span><label class="collapse" for="c-37878911">[-]</label><label class="expand" for="c-37878911">[1 more]</label></div><br/><div class="children"><div class="content">I disagree on the firewalling front.  I mean sure eBPF and iptables likely scales well but for home or small business users until there’s a simple declarative syntax like PF that abstracts the need for small C programs to run as eBPF requires it won’t gain adoption or be used or advocated by many.<p>I’ve never had to deep packet inspect so I’m not even sure there. The article just mentions that if state tables are exhausted packets start dropping. This is the case in every switch, too. It’s a common thing. Being able to increase this is a nice stop gap. It’s not a fatal flaw wrt to PF.<p>Also for better or worse BSD being different is what makes it interesting. BSD devs and hackers are a fraction of what the Linux kernel and greater ecosystem have in terms of the all of K8s and other Linux foundation projects. But BSDs have been innovating within their community of hackers for years and they don’t need to just be a derivative of Linux.<p>That being said the concepts of eBPF could be ported and the interface adopted could be interesting. If anyone pushed or funded that effort it might be the Netflix folks.</div><br/></div></div></div></div><div id="37878512" class="c"><input type="checkbox" id="c-37878512" checked=""/><div class="controls bullet"><span class="by">PreInternet01</span><span>|</span><a href="#37878694">prev</a><span>|</span><a href="#37878789">next</a><span>|</span><label class="collapse" for="c-37878512">[-]</label><label class="expand" for="c-37878512">[1 more]</label></div><br/><div class="children"><div class="content">Running out of state table space is a very common issue for firewalls subjected to a DoS or other unprecedented high traffic situation. The only thing OpenBSD-specific here is probably the very conservative default table size.<p>For DNS servers that are set up with rate limits, keeping state on the firewall is pointless, so it&#x27;s probably best to skip that (on OpenBSD: `pass no state`, I think) -- the destination server itself knows best what&#x27;s abusive traffic and what&#x27;s not, so on the firewall, do nothing except count the packets...</div><br/></div></div><div id="37878789" class="c"><input type="checkbox" id="c-37878789" checked=""/><div class="controls bullet"><span class="by">badrabbit</span><span>|</span><a href="#37878512">prev</a><span>|</span><label class="collapse" for="c-37878789">[-]</label><label class="expand" for="c-37878789">[1 more]</label></div><br/><div class="children"><div class="content">In general, when you get DDOSed (not neccesarilu DOSed though,you would want to route around the firewalls because they process and inspect every packet&#x2F;connection their rps&#x2F;pps capacity makes them a bottleneck.</div><br/></div></div></div></div></div></div></div></body></html>