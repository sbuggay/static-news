<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685437257244" as="style"/><link rel="stylesheet" href="styles.css?v=1685437257244"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://raku-advent.blog/2022/12/20/sigils/">Sigils are underappreciated (2022)</a> <span class="domain">(<a href="https://raku-advent.blog">raku-advent.blog</a>)</span></div><div class="subtext"><span>luuuzeta</span> | <span>61 comments</span></div><br/><div><div id="36119790" class="c"><input type="checkbox" id="c-36119790" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#36119934">next</a><span>|</span><label class="collapse" for="c-36119790">[-]</label><label class="expand" for="c-36119790">[27 more]</label></div><br/><div class="children"><div class="content">I like to rate programming language&#x27;s features not by how much I use them when I&#x27;m in the given language, or how good they make me feel, but by how much I miss them when I&#x27;m in a different language, once I&#x27;m fluent in that language and writing in the native idiom. (This is important. If you&#x27;re still trying to write X in Y, yes, you&#x27;ll miss the features from X, but that&#x27;s not a useful data point.)<p>By this metric, rather a lot of features turn out to be less important than they may seem at first. Many things are a zero on this scale that I think might surprise people still on their second or third language. From this perspective you start judging not whether a language has this or that exact feature that is a solution to a problem that you are used to, but whether it has a solution at all, and how good it is on its own terms.<p>So while sigils have a lot of company in this, they are also a flat zero for me on this scale. Never ever missed them. I did a decade+ of Perl as my main language, so it&#x27;s not for lack of exposure.<p>(As an example of something that does pass this test: Closures. Hard to use anything lacking them, though as this seems to be a popular opinion nowadays, almost everything has them. But I&#x27;m old enough to remember them being a controversial feature. Also, at this point, static types. Despite my decades of dynamic typed languages, I hate going back to dynamic languages anymore. YMMV.)</div><br/><div id="36120120" class="c"><input type="checkbox" id="c-36120120" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#36119790">parent</a><span>|</span><a href="#36120047">next</a><span>|</span><label class="collapse" for="c-36120120">[-]</label><label class="expand" for="c-36120120">[9 more]</label></div><br/><div class="children"><div class="content">&gt; So while sigils have a lot of company in this, they are also a flat zero for me on this scale. Never ever missed them. I did a decade+ of Perl as my main language, so it&#x27;s not for lack of exposure.<p>I tend to miss one specific sigil (or pair of sigils): the @ and @@ sigils in Ruby, that mean &quot;instance variable&quot; and &quot;class variable&quot; respectively. Having identifier shadowing between stack-locals, and what Java would call &quot;members&quot; and &quot;statics&quot;, be <i>literally impossible</i>, is just so nice. Especially when you get it &quot;for free&quot; in terms of verbosity, rather than needing to type `self.class.` or something.<p>I also really quite interned-string-literal : sigils in Ruby&#x2F;Elixir — though I&#x27;d be equally fine with the Prolog&#x2F;Erlang approach of barewords being symbols and identifiers needing to be capitalized. As long as there&#x27;s <i>some</i> concise syntax for interned strings, especially in the context of dictionary keys. Because otherwise people just won&#x27;t use them, even when they&#x27;re there in the language. (See: Java, Python, ECMA6.)<p>Speaking of Elixir, the &quot;universal sigil&quot; ~ is kind of amazing. Define a macro sigil_h&#x2F;2, and you can suddenly write ~h&#x2F;foo&#x2F;bar (or ~h[foo]bar, or whatever other delimiter works to best avoid the need for escaping), and foo and bar will be passed to sigil_h&#x2F;2 as un-evaluated AST nodes to do with as you please. The language gives you ~w by default (which works like Ruby %w); but more interestingly, Regex literals in Elixir are just sigil_r.</div><br/><div id="36120651" class="c"><input type="checkbox" id="c-36120651" checked=""/><div class="controls bullet"><span class="by">epage</span><span>|</span><a href="#36119790">root</a><span>|</span><a href="#36120120">parent</a><span>|</span><a href="#36120230">next</a><span>|</span><label class="collapse" for="c-36120651">[-]</label><label class="expand" for="c-36120651">[6 more]</label></div><br/><div class="children"><div class="content">&gt; I tend to miss one specific sigil (or pair of sigils): the @ and @@ sigils in Ruby, that mean &quot;instance variable&quot; and &quot;class variable&quot; respectively. Having identifier shadowing between stack-locals, and what Java would call &quot;members&quot; and &quot;statics&quot;, be literally impossible, is just so nice. Especially when you get it &quot;for free&quot; in terms of verbosity, rather than needing to type `self.class.` or something.<p>When I went from C++ to Python, the explicit &quot;self&quot; felt weird but over time, I felt it was much better.  This became a lot more obvious in Rust.  In C++ you get an implicit `this` variable and you get weird trailing keywords on functions to modify the `this` variable.  Granted, these kinds of use cases won&#x27;t be needed in every language.  However, I also feel like sigils for this would be less understandable for someone unfamiliar with the language than explicit `self`.  Something I judge a language on is how easy is the code to casually maintain by a group that is trying to get other stuff done.</div><br/><div id="36121105" class="c"><input type="checkbox" id="c-36121105" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#36119790">root</a><span>|</span><a href="#36120651">parent</a><span>|</span><a href="#36121198">next</a><span>|</span><label class="collapse" for="c-36121105">[-]</label><label class="expand" for="c-36121105">[4 more]</label></div><br/><div class="children"><div class="content">The thing about Ruby is that it has uniform syntax — a.b for any a+b mean &quot;send a message :b to a.&quot; So `self.foo` (and `self.foo = bar`, too!) are possible to write, but these are always interpreted as message sends (to the :foo and :foo= methods, respectively), not as direct field accesses. The &quot;syntax-ness&quot; of @ and @@ show are that you&#x27;re specifically <i>breaking out of</i>† the paradigm of &quot;everything is a message send&quot;, to instead &quot;just&quot; access a field. It&#x27;s what makes this make sense:<p><pre><code>    def foo # define a getter method
      @foo # in terms of a field access
    end
</code></pre>
How would you write that, if the field access was spelled `self.foo`? The language wouldn&#x27;t be able to tell that you&#x27;re not just recursively calling the getter!<p>---<p>† Though, technically, you&#x27;re not breaking out of the paradigm; @foo is short for self.instance_variable_get(:@foo). It&#x27;s message-sends all the way down, until you hit natively-implemented methods.</div><br/><div id="36121515" class="c"><input type="checkbox" id="c-36121515" checked=""/><div class="controls bullet"><span class="by">iudqnolq</span><span>|</span><a href="#36119790">root</a><span>|</span><a href="#36121105">parent</a><span>|</span><a href="#36121198">next</a><span>|</span><label class="collapse" for="c-36121515">[-]</label><label class="expand" for="c-36121515">[3 more]</label></div><br/><div class="children"><div class="content">&gt; How would you write that, if the field access was spelled `self.foo`? The language wouldn&#x27;t be able to tell that you&#x27;re not just recursively calling the getter!<p>You can require parentheses for method calls put methods and fields in separate namespaces.<p><a href="https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=5264fbd42d4c90e1ee5f827eaeae5b6c" rel="nofollow">https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;editio...</a><p>Elixir supports paren-free calls but the default linter and formatter won&#x27;t let you use them except for a few whitelisted DSLs. I&#x27;ve never missed not having them.</div><br/><div id="36121648" class="c"><input type="checkbox" id="c-36121648" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#36119790">root</a><span>|</span><a href="#36121515">parent</a><span>|</span><a href="#36121198">next</a><span>|</span><label class="collapse" for="c-36121648">[-]</label><label class="expand" for="c-36121648">[2 more]</label></div><br/><div class="children"><div class="content">In languages that require parens for method calls, not using them usually gets you a method handle. Which is still in conflict with a field reference — usually because methods are just function-pointer-typed static fields.</div><br/><div id="36121756" class="c"><input type="checkbox" id="c-36121756" checked=""/><div class="controls bullet"><span class="by">iudqnolq</span><span>|</span><a href="#36119790">root</a><span>|</span><a href="#36121648">parent</a><span>|</span><a href="#36121198">next</a><span>|</span><label class="collapse" for="c-36121756">[-]</label><label class="expand" for="c-36121756">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why I said &quot;you can&quot; rather than &quot;you must&quot;. And linked to an example that of a language with the property I described.</div><br/></div></div></div></div></div></div></div></div><div id="36121198" class="c"><input type="checkbox" id="c-36121198" checked=""/><div class="controls bullet"><span class="by">jddj</span><span>|</span><a href="#36119790">root</a><span>|</span><a href="#36120651">parent</a><span>|</span><a href="#36121105">prev</a><span>|</span><a href="#36120230">next</a><span>|</span><label class="collapse" for="c-36121198">[-]</label><label class="expand" for="c-36121198">[1 more]</label></div><br/><div class="children"><div class="content">I explicit this.thing in C# as well. It started from inheriting some coding standards &#x2F; projects whose designers came straight from C and didn&#x27;t do the idiomatic _variable thing for instance variables.<p>Now it&#x27;s quite an entrenched habit and at this stage I&#x27;d prefer if the implicit access wasn&#x27;t possible.</div><br/></div></div></div></div><div id="36120230" class="c"><input type="checkbox" id="c-36120230" checked=""/><div class="controls bullet"><span class="by">systems_glitch</span><span>|</span><a href="#36119790">root</a><span>|</span><a href="#36120120">parent</a><span>|</span><a href="#36120651">prev</a><span>|</span><a href="#36120352">next</a><span>|</span><label class="collapse" for="c-36120230">[-]</label><label class="expand" for="c-36120230">[1 more]</label></div><br/><div class="children"><div class="content">Agree on Ruby ivar&#x2F;cvar sigils. We ran into some nasty variable shadowing, especially with autowiring frameworks, in big Java projects over the years.</div><br/></div></div><div id="36120352" class="c"><input type="checkbox" id="c-36120352" checked=""/><div class="controls bullet"><span class="by">davidw</span><span>|</span><a href="#36119790">root</a><span>|</span><a href="#36120120">parent</a><span>|</span><a href="#36120230">prev</a><span>|</span><a href="#36120047">next</a><span>|</span><label class="collapse" for="c-36120352">[-]</label><label class="expand" for="c-36120352">[1 more]</label></div><br/><div class="children"><div class="content">Yes, those are handy. I don&#x27;t much care for all the other ones in Ruby. Maybe the regexp one.</div><br/></div></div></div></div><div id="36120047" class="c"><input type="checkbox" id="c-36120047" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#36119790">parent</a><span>|</span><a href="#36120120">prev</a><span>|</span><a href="#36120451">next</a><span>|</span><label class="collapse" for="c-36120047">[-]</label><label class="expand" for="c-36120047">[7 more]</label></div><br/><div class="children"><div class="content">Thanks for putting into words something I&#x27;ve started to feel over time, but never conceptualized clearly.<p>I agree that closures pass the test - and I too remember when they weren&#x27;t popular. I also remember what I did <i>before</i> learning about the very idea of first-class functions and closures: I simulated them with some ad-hoc means (like function pointers in C&#x2F;C++, or passing strings to be eval()-ed in PHP, etc.).<p>This, I think, is an useful heuristic: the things likely to pass your test are the ones which people who don&#x27;t have and don&#x27;t know about them still end up approximating anyway - meaning those things are a natural solutions to some common problems.<p>I can think of couple other things that pass your test:<p>- Functions in general. It&#x27;s the basic organizational primitive in code; working without them is Not Fun.<p>- Lisp-style macros. There are many problems that would be best solved with some surgical code generation, and having that option built-in into the language makes all the difference. Most languages don&#x27;t have this type of macros - but that doesn&#x27;t mean they aren&#x27;t needed. Having done enough Lisp macrology, I saw that in those other languages I&#x27;ve always been <i>coping</i>. Missing them without knowing what they are.<p>Hell, look no further than webdev - these days, major frameworks like React, and every other minor library, and even the language evolution itself, all depend on running an external macro processor &#x2F; code generation tool as part of your build pipeline.</div><br/><div id="36120657" class="c"><input type="checkbox" id="c-36120657" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#36119790">root</a><span>|</span><a href="#36120047">parent</a><span>|</span><a href="#36120451">next</a><span>|</span><label class="collapse" for="c-36120657">[-]</label><label class="expand" for="c-36120657">[6 more]</label></div><br/><div class="children"><div class="content">A trivial but real one for me is being able to use non-alphanum chars freely in var and fn names. Being able to name a fn &#x27;string-&gt;int&#x27; or especially something like &#x27;valid?&#x27; seems very small but I really miss it in languages with more restrictions on names.</div><br/><div id="36120924" class="c"><input type="checkbox" id="c-36120924" checked=""/><div class="controls bullet"><span class="by">RHSeeger</span><span>|</span><a href="#36119790">root</a><span>|</span><a href="#36120657">parent</a><span>|</span><a href="#36121158">next</a><span>|</span><label class="collapse" for="c-36120924">[-]</label><label class="expand" for="c-36120924">[4 more]</label></div><br/><div class="children"><div class="content">Although less encompassing than what you&#x27;re talking about, I miss being able to name functions with a &quot;?&quot; at the end when they are a predicate; &quot;isValid?&quot;.</div><br/><div id="36121535" class="c"><input type="checkbox" id="c-36121535" checked=""/><div class="controls bullet"><span class="by">robotresearcher</span><span>|</span><a href="#36119790">root</a><span>|</span><a href="#36120924">parent</a><span>|</span><a href="#36121158">next</a><span>|</span><label class="collapse" for="c-36121535">[-]</label><label class="expand" for="c-36121535">[3 more]</label></div><br/><div class="children"><div class="content">That’s what the ‘is’ is for. If you have a ‘?’ character, you don’t need it. But tastes vary. I don’t even like the ‘is’.<p>1. if isValid() 
2. if valid?()
3. if isValid?()
4. if valid()<p>Number 4 is nicest to my eyes. But I guess if the ‘?’ or ‘is’ (or both) is a promise to the user that the function is a true predicate, then I can see its utility.</div><br/><div id="36121766" class="c"><input type="checkbox" id="c-36121766" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#36119790">root</a><span>|</span><a href="#36121535">parent</a><span>|</span><a href="#36121158">next</a><span>|</span><label class="collapse" for="c-36121766">[-]</label><label class="expand" for="c-36121766">[2 more]</label></div><br/><div class="children"><div class="content">&#x27;?&#x27; &#x2F; &#x27;is&#x27; get more useful with more complex predicate names than just &#x27;valid&#x27;, and they also help with certain corner cases in English. For example, what does the following code do:<p><pre><code>  if(widget.free()) { ... }
</code></pre>
Does it 1) check if the widget is &quot;free&quot; (whatever that means in the widget domain), or 2) frees the widget and checks the outcome of that operation?<p>If I saw something like this while reading code, I&#x27;d pause and carefully check what exactly is going on here.<p>In fact, I was going to write &quot;Option 2) resembles resource management patterns, for example memory management in C&quot;, but then I checked and noticed that free() in C does not return a value, so this pattern would <i>not</i> exist with malloc()&#x2F;free() - in other words, despite doing a bit of C and a lot of C++ in the past two decades, I still tripped over this.<p>Now compare with:<p><pre><code>  if(widget.isFree()) { ... }
  if(widget.free?()) { ... }
</code></pre>
Both resolve this ambiguity.<p>On that note, I&#x27;d love some kind of sigil for &quot;asserting&quot; functions - which are similar to checks, but instead of returning true&#x2F;false, they ensure the argument is in the state described by the function name, or else they throw an exception. It&#x27;s a pattern I&#x27;ve been using in exception-ful code to cut down on noise. For example:<p><pre><code>  &#x2F;&#x2F; Check if connected; if not, maybe run reconnection
  &#x2F;&#x2F; logic or attempt some other form of recovery.
  &#x2F;&#x2F; The only way control proceeds past this line is if
  &#x2F;&#x2F; the session is connected; if it isn&#x27;t and can&#x27;t be,
  &#x2F;&#x2F; exception is thrown.
  EnsureConnected(session);
   
  if(IsSomething(session, arg1)) {
    &#x2F;&#x2F; ... some code requiring connected session
  }
  &#x2F;&#x2F; ... more code requiring connected session
</code></pre>
It&#x27;s not a big deal, but in some cases, that &quot;Ensure&quot; or &quot;Assert&quot; look weird, and I don&#x27;t like inventing more synonyms for the same pattern.</div><br/><div id="36121821" class="c"><input type="checkbox" id="c-36121821" checked=""/><div class="controls bullet"><span class="by">robotresearcher</span><span>|</span><a href="#36119790">root</a><span>|</span><a href="#36121766">parent</a><span>|</span><a href="#36121158">next</a><span>|</span><label class="collapse" for="c-36121821">[-]</label><label class="expand" for="c-36121821">[1 more]</label></div><br/><div class="children"><div class="content">Good points.<p>I’d avoid overloading a standard library function name like free().<p>Your request for syntax for assertions reminds me of the ‘guard’ keyword in Swift, which is good for making sure of preconditions.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36120451" class="c"><input type="checkbox" id="c-36120451" checked=""/><div class="controls bullet"><span class="by">marai2</span><span>|</span><a href="#36119790">parent</a><span>|</span><a href="#36120047">prev</a><span>|</span><a href="#36120200">next</a><span>|</span><label class="collapse" for="c-36120451">[-]</label><label class="expand" for="c-36120451">[2 more]</label></div><br/><div class="children"><div class="content">Perl&#x27;s regex handling. That&#x27;s the one I miss in whatever other language I program in.
To be able to match AND get the matched substrings out in one line, makes this really succinct.</div><br/><div id="36121600" class="c"><input type="checkbox" id="c-36121600" checked=""/><div class="controls bullet"><span class="by">riffraff</span><span>|</span><a href="#36119790">root</a><span>|</span><a href="#36120451">parent</a><span>|</span><a href="#36120200">next</a><span>|</span><label class="collapse" for="c-36121600">[-]</label><label class="expand" for="c-36121600">[1 more]</label></div><br/><div class="children"><div class="content">isn&#x27;t that the same in any expression-oriented language ?<p>E.g. in ruby this could be<p><pre><code>    puts $1 if &#x2F;(\d+)&#x2F; =~ &#x27;test 123&#x27; # perl-like
    
    if m = &#x2F;(\d+)&#x2F;.match(&#x27;test 123&#x27;) then puts m[1] end # perl-less
</code></pre>
Perl&#x27;s regexes do more things perhaps, but this is a relatively common thing, I believe.</div><br/></div></div></div></div><div id="36120200" class="c"><input type="checkbox" id="c-36120200" checked=""/><div class="controls bullet"><span class="by">calderwoodra</span><span>|</span><a href="#36119790">parent</a><span>|</span><a href="#36120451">prev</a><span>|</span><a href="#36121229">next</a><span>|</span><label class="collapse" for="c-36120200">[-]</label><label class="expand" for="c-36120200">[3 more]</label></div><br/><div class="children"><div class="content">I like this approach - We use python for our backend and the things I miss the most from other languages are the protected&#x2F;public&#x2F;private keywords (Java), single-line `if condition: return` statements (js, ruby, etc.), and npm&#x2F;yarn&#x2F;package.json (js). I miss types too but it feels unfair to complain about that with Python.</div><br/><div id="36120935" class="c"><input type="checkbox" id="c-36120935" checked=""/><div class="controls bullet"><span class="by">scubbo</span><span>|</span><a href="#36119790">root</a><span>|</span><a href="#36120200">parent</a><span>|</span><a href="#36121229">next</a><span>|</span><label class="collapse" for="c-36120935">[-]</label><label class="expand" for="c-36120935">[2 more]</label></div><br/><div class="children"><div class="content">Fair point re: package management - but Python does support single-line conditionals, and reasonably robust type-checking with mypy.</div><br/><div id="36121626" class="c"><input type="checkbox" id="c-36121626" checked=""/><div class="controls bullet"><span class="by">calderwoodra</span><span>|</span><a href="#36119790">root</a><span>|</span><a href="#36120935">parent</a><span>|</span><a href="#36121229">next</a><span>|</span><label class="collapse" for="c-36121626">[-]</label><label class="expand" for="c-36121626">[1 more]</label></div><br/><div class="children"><div class="content">MyPy isn&#x27;t quite as nice as typescript, and it also has some trouble with Django. I know it CAN work, but does any language have a worse type system? Maybe Ruby.<p>For single line conditionals - looks like you&#x27;re right from that I can tell. I mistakenly assumed the pep8 errors were actually interpreter errors. Thank you!</div><br/></div></div></div></div></div></div><div id="36121229" class="c"><input type="checkbox" id="c-36121229" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#36119790">parent</a><span>|</span><a href="#36120200">prev</a><span>|</span><a href="#36119898">next</a><span>|</span><label class="collapse" for="c-36121229">[-]</label><label class="expand" for="c-36121229">[1 more]</label></div><br/><div class="children"><div class="content">I agree with this and in most languages I don’t miss sigils but one language I do wish supported them is plpgsql.<p>The reason is that column names and function arguments overlap a lot, which can cause ambiguities when performing updates or selects. To become productive at plpgsql it’s a problem that you have to solve.<p>There are several approaches but the one I settled on is just to prefix all formal parameters with underscores.<p>The wish I have with plpgsql is that I could use $ instead since underscore is already heavily used as a word separator.</div><br/></div></div><div id="36119898" class="c"><input type="checkbox" id="c-36119898" checked=""/><div class="controls bullet"><span class="by">Swizec</span><span>|</span><a href="#36119790">parent</a><span>|</span><a href="#36121229">prev</a><span>|</span><a href="#36120183">next</a><span>|</span><label class="collapse" for="c-36119898">[-]</label><label class="expand" for="c-36119898">[3 more]</label></div><br/><div class="children"><div class="content">Thanks for putting into words something that was on the edge of my mind, but never quite graspable.<p>Two more examples (for me?) of features that I find you really miss in a language even if you’re fluent in the local idioms: First-class functions and pattern matching.<p>Passing functions as values is <i>so nice</i> and afaik most modern languages have that feature nowadays. But I remember when it used to blow people’s minds.<p>Pattern matching is something I’ve missed ever since having it in Haskell. Such an elegant solution to a problem that you have just often enough that the typical native approach feels clunky.</div><br/><div id="36120042" class="c"><input type="checkbox" id="c-36120042" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#36119790">root</a><span>|</span><a href="#36119898">parent</a><span>|</span><a href="#36120183">next</a><span>|</span><label class="collapse" for="c-36120042">[-]</label><label class="expand" for="c-36120042">[2 more]</label></div><br/><div class="children"><div class="content">Luckily pattern matching is also catching on.<p>Rust might be partially responsible for that, maybe?  Python has also massively improved its pattern matching recently.</div><br/><div id="36121190" class="c"><input type="checkbox" id="c-36121190" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#36119790">root</a><span>|</span><a href="#36120042">parent</a><span>|</span><a href="#36120183">next</a><span>|</span><label class="collapse" for="c-36121190">[-]</label><label class="expand" for="c-36121190">[1 more]</label></div><br/><div class="children"><div class="content">Dart 3 got very nice pattern matching [1]. And the next version of Java might introduce it (but likely it will still be behind a &quot;preview&quot; flag) as well.<p>[1] <a href="https:&#x2F;&#x2F;dart.dev&#x2F;language&#x2F;patterns" rel="nofollow">https:&#x2F;&#x2F;dart.dev&#x2F;language&#x2F;patterns</a></div><br/></div></div></div></div></div></div><div id="36120183" class="c"><input type="checkbox" id="c-36120183" checked=""/><div class="controls bullet"><span class="by">waynesonfire</span><span>|</span><a href="#36119790">parent</a><span>|</span><a href="#36119898">prev</a><span>|</span><a href="#36119934">next</a><span>|</span><label class="collapse" for="c-36120183">[-]</label><label class="expand" for="c-36120183">[1 more]</label></div><br/><div class="children"><div class="content">Well articulated. Thanks.</div><br/></div></div></div></div><div id="36119934" class="c"><input type="checkbox" id="c-36119934" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36119790">prev</a><span>|</span><a href="#36119932">next</a><span>|</span><label class="collapse" for="c-36119934">[-]</label><label class="expand" for="c-36119934">[8 more]</label></div><br/><div class="children"><div class="content">Sigils in Perl were awful. They didn&#x27;t behave concretely. Sometimes it was sort of a type annotation sometimes they were a weird incantation.<p>Things like implicit scalar conversion<p><pre><code>  @foods = qw(burgers fries shakes);
  $length = @foods;
  print $length, &quot;\n&quot;;
</code></pre>
Yeah it&#x27;s easy to understand once you know what is happening but it&#x27;s obscure. There are no easy clues to let you know what is happening.<p>Then there are situations where you have a scalar but it&#x27;s a ref<p><pre><code>  %author = (
  &#x27;name&#x27;              =&gt; &quot;Harsha&quot;,
  &#x27;designation&#x27;      =&gt; &quot;Manager&quot;
  );
  
  $hash_ref = \%author;
</code></pre>
So it&#x27;s not a type its more of a language implementation detail that doesn&#x27;t add value to the programmer.<p>Where as with the Hindley–Milner type system the types exist and add value without requiring all of the extra code. You can infer the type most of the time and you get a nice strong type check at compile time.<p>Sigils seem like a step in the opposite direction to strong inferred types. You have to add a little bit of boiler plate but it&#x27;s not that strict so it&#x27;s meaning can still be confusing.</div><br/><div id="36120249" class="c"><input type="checkbox" id="c-36120249" checked=""/><div class="controls bullet"><span class="by">throwaway173738</span><span>|</span><a href="#36119934">parent</a><span>|</span><a href="#36121456">next</a><span>|</span><label class="collapse" for="c-36120249">[-]</label><label class="expand" for="c-36120249">[3 more]</label></div><br/><div class="children"><div class="content">Perl is the most confusing language I’ve ever used professionally, largely because of how it uses sigils sometimes as operators. The other source of confusion are the million and a half implicit variables that are context-specific. It’s the only language where even after ten years I still regularly have to google to do simple things like iterate over a hash. And half the time it doesn’t work because the hash is actually a ref so now you need an arcane syntax or it doesn’t work. In Perl all of the implementation details of the language become footguns for you to shoot yourself with.</div><br/><div id="36121475" class="c"><input type="checkbox" id="c-36121475" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#36119934">root</a><span>|</span><a href="#36120249">parent</a><span>|</span><a href="#36120979">next</a><span>|</span><label class="collapse" for="c-36121475">[-]</label><label class="expand" for="c-36121475">[1 more]</label></div><br/><div class="children"><div class="content">I hate to question someone&#x27;s credentials, but<p><pre><code>    for my $key (keys %hash) { ... }
</code></pre>
or if it&#x27;s a reference<p><pre><code>    for my $key (keys %{$ref_to_hash}) { ... }
</code></pre>
That is fairly simple, and not a good example of something that is difficult in Perl. If you cannot keep that straight, I suspect the extent to which you really use Perl is limited.</div><br/></div></div><div id="36120979" class="c"><input type="checkbox" id="c-36120979" checked=""/><div class="controls bullet"><span class="by">G3rn0ti</span><span>|</span><a href="#36119934">root</a><span>|</span><a href="#36120249">parent</a><span>|</span><a href="#36121475">prev</a><span>|</span><a href="#36121456">next</a><span>|</span><label class="collapse" for="c-36120979">[-]</label><label class="expand" for="c-36120979">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And half the time it doesn’t work because the hash is actually a ref<p>Perl still supports both „copy by value“ and „copy by reference“. For example:<p><pre><code>  my @copy = @original;
  my %hash_copy = %orig_hash;
  my @processed = foo_func(@copy);
  my $ref = \@copy;
  bar_func($ref); # modifies @copy in place
</code></pre>
That’s why it uses these sigils to distinguish between references being scalar values (“$”) and actual lists&#x2F;dictionaries (“@“ and “%”). Since Perl is also dynamically typed if it weren’t for the sigils, it would be quite confusing when reading “array[i] =“ somewhere not knowing whether it modifies an array created remotely or locally. Sigils communicate that because it reads “$array[$i] =“ for a local array or “$$array[$i]”
for a remote one.<p>In other languages like JavaScript or Python everything is basically a reference and, hence, you don’t quite need sigils there. However, on the flip side, you need to be more careful and constantly remind yourself of the fact you are dealing with references and not to accidentally modify the objects you get passed into your function.</div><br/></div></div></div></div><div id="36121456" class="c"><input type="checkbox" id="c-36121456" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#36119934">parent</a><span>|</span><a href="#36120249">prev</a><span>|</span><a href="#36121093">next</a><span>|</span><label class="collapse" for="c-36121456">[-]</label><label class="expand" for="c-36121456">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  @foods = qw(burgers fries shakes);
  $length = @foods;
</code></pre>
Not to mention that this refactoring introduces a bug:<p><pre><code>  $length = qw(burgers fries shakes);
</code></pre>
Because lists and arrays convert to scalars differently. A list is more of a syntactic construct and an array is a data structure. Confused the heck out of me my first few weeks of Perl.</div><br/></div></div><div id="36121093" class="c"><input type="checkbox" id="c-36121093" checked=""/><div class="controls bullet"><span class="by">G3rn0ti</span><span>|</span><a href="#36119934">parent</a><span>|</span><a href="#36121456">prev</a><span>|</span><a href="#36119932">next</a><span>|</span><label class="collapse" for="c-36121093">[-]</label><label class="expand" for="c-36121093">[3 more]</label></div><br/><div class="children"><div class="content">&gt; So it&#x27;s not a type its more of a language implementation detail<p>Well, it’s used to distinguish between values that were passed into a function via „copy by value“ or „copy by reference“. Insofar sigils have nothing to do with types but rather with function passing semantics. Yes, with a good type system you can also communicate whether an array is passed by “copy by reference” in the type signature of a function. Then you wouldn’t need sigils. But it’s a secondary feature of static types.<p>However, you could also abolish “copy by value” altogether (as JS and Python do) and then wouldn’t need neither sigils nor types.<p>&gt; Where as with the Hindley–Milner type system the types exist<p>Perl is a dynamically typed language. If it were using static types, it wouldn’t quite need sigils, yes, but then it also wouldn’t have been the Perl programming language…<p>Sigils do not really have anything to do with static types and shouldn’t be discussed in this context. Then they are also not as confusing.<p>BTW: This whole discussion of static vs. dynamic typing has become a bit tiresome over the years. It will never be settled. In the 90s everybody tended to hate static typing  and for good reasons so: It makes generic programming quite a bit more complicated than necessary. This was when all these dynamically typed scripting languages were invented to enable programmers write abstract code more easily by lifting the burden of constantly inventing composite types. „If it walks like a duck …“<p>Of course, everything is a trade off and with that approach you are prone to get more run time errors and, hence, people started test-driven development. Then developers started to hate writing tests (also for good reasons) and re-discovered static typing. Now people seem to be happy hacking ad-hoc types together — until they have to refactor other people’s programs and find it rather tricky because of the contagiousness of type signatures. When they spent enough weeks to rewrite type signatures in half of the program base they will long for the good ol’ scripting languages of the 90s again. And the cycle begins again.</div><br/><div id="36121239" class="c"><input type="checkbox" id="c-36121239" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36119934">root</a><span>|</span><a href="#36121093">parent</a><span>|</span><a href="#36121252">next</a><span>|</span><label class="collapse" for="c-36121239">[-]</label><label class="expand" for="c-36121239">[1 more]</label></div><br/><div class="children"><div class="content">I was attempting to contrast the usefulness of sigils vs static typing. While they&#x27;re different things the do serve similar purposes. They restrict a thing so one can reason about it. At a meta level they do similar things.<p>The reason I don&#x27;t like Perl&#x27;s sigils is that my head is not good at inferring meaning from something like a $ or % or \%. I prefer they way it&#x27;s done in other languages where you have to call a copy or deep copy function. Not everyone would agree with that preference.<p>I think dynamic languages have their place. I&#x27;m personally more comfortable with the training wheels on in a statically typed language. But there are times where using a statically typed language is going to arrive at an overengineered solution. There are developers that can do amazing things in dynamic languages because they&#x27;re good at catching their own errors and can leverage the flexibility of dynamic typing to their benefit.</div><br/></div></div><div id="36121252" class="c"><input type="checkbox" id="c-36121252" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#36119934">root</a><span>|</span><a href="#36121093">parent</a><span>|</span><a href="#36121239">prev</a><span>|</span><a href="#36119932">next</a><span>|</span><label class="collapse" for="c-36121252">[-]</label><label class="expand" for="c-36121252">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It makes generic programming quite a bit more complicated than necessary. This was when all these dynamically typed scripting languages were invented to enable programmers write abstract code more easily by lifting the burden of constantly inventing composite types. „If it walks like a duck …“<p>Don&#x27;t confuse duck typing with dynamic typing.</div><br/></div></div></div></div></div></div><div id="36119932" class="c"><input type="checkbox" id="c-36119932" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#36119934">prev</a><span>|</span><a href="#36120331">next</a><span>|</span><label class="collapse" for="c-36119932">[-]</label><label class="expand" for="c-36119932">[1 more]</label></div><br/><div class="children"><div class="content">Perl5 got sigils wrong, where more complex usages hinted at incorrect human parsing of expressions. That was designed borrowing from natural language, so wd should probably throw out the early part of the post. Now the post says in Raku<p><pre><code>  @  says “Use me with an array-like interface”
  %  says “Use me with a hash-like interface”
  &amp;  says “Use me with a function-like interface”
  $  says “I won’t tell you what interface you can use, but treat me as a single item”
</code></pre>
I don&#x27;t use Raku nor used much of Perl5 (only enough to learn it&#x27;s good for writing, not for reading). Sigils in Raku may be fine and better than not using them. I&#x27;ll accept that.<p>However, I much prefer inferred static typing and referential transparency where everything produces a value and it&#x27;s not material whether it&#x27;s a precomputed value or something that will produce the value when &#x27;pulled on&#x27;. The last part works well with pure functions and lazy evaluation. Until someone claiming benefits of sigils has used this alternative for large, long-lived code written and maintained by many, I&#x27;ll leave sigils to Raku alone.</div><br/></div></div><div id="36120331" class="c"><input type="checkbox" id="c-36120331" checked=""/><div class="controls bullet"><span class="by">whakim</span><span>|</span><a href="#36119932">prev</a><span>|</span><a href="#36121494">next</a><span>|</span><label class="collapse" for="c-36120331">[-]</label><label class="expand" for="c-36120331">[4 more]</label></div><br/><div class="children"><div class="content">I think there&#x27;s a piece of insight missing from the author&#x27;s analysis of non-programmatic sigils. To wit, the sigils are <i>only</i> valuable when <i>both parties deeply understand the information that the sigil is trying to convey</i>. The &quot;$framework at $dayjob&quot; example illustrates this point. Programmers familiar with the use of sigils to indicate variables intrinsically grok this phrase, but it looks like gobbledygook to non-programmers. The email inbox example is similar. (I&#x27;d argue the hashtag&#x2F;@-symbol example is a bit more complicated, because those symbols service important UX functions.)<p>I think this insight crystalizes the trade-off. I agree with the author that sigils are <i>a</i> powerful way of communicating useful information in a concise fashion. But does their inscrutability to non-expert users justify their existence? I&#x27;d argue it usually doesn&#x27;t. Whenever I&#x27;ve had to pick up a language that uses a lot of sigils (or even just had to read source code in one of those languages if I don&#x27;t use it daily), I always find the sigils require a bit of extra mental effort to process. It seems like other languages manage to express meaning in a way that is less burdensome to non-experts.</div><br/><div id="36121742" class="c"><input type="checkbox" id="c-36121742" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#36120331">parent</a><span>|</span><a href="#36121507">next</a><span>|</span><label class="collapse" for="c-36121742">[-]</label><label class="expand" for="c-36121742">[1 more]</label></div><br/><div class="children"><div class="content">I might agree with you if I ask for the fact some of the most popular beginner languages use sigils:<p>- BASIC<p>- Shell scripting<p>- PHP<p>It’s also worth noting that all languages have special tokens to identify properties of the code. Eg why does a string need to be wrapped in quotation marks but integers do not? Why do single and double quotation marks behave differently in some languages? Why do function names behave differently if you pass () vs not including parentheses in some languages?<p>At the end of the day, if you want to learn to program then you are always going to have some degree of syntax that you just have to learn. Sigils aren’t inherently hard but some languages make I them more abstract than others.<p>Another thing that’s worth baring in mind is that sigils solve a problem in languages that make heavy use of barewords, such as shells. Eg how do you know if foobar is a variable, function, keyword, parameter, etc if you syntax is<p><pre><code>   echo foobar
</code></pre>
This is why other languages then use quotation marks, parentheses, etc. But while that’s arguably more readable, it’s a pain in the arse for REPL work in a shell (I know because I’ve tried it).<p>So there’s always trade offs.</div><br/></div></div><div id="36121507" class="c"><input type="checkbox" id="c-36121507" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#36120331">parent</a><span>|</span><a href="#36121742">prev</a><span>|</span><a href="#36121293">next</a><span>|</span><label class="collapse" for="c-36121507">[-]</label><label class="expand" for="c-36121507">[1 more]</label></div><br/><div class="children"><div class="content">Ah, the classic trade-off between designing for the convenience of beginners or experts! I&#x27;m in camp expert, but I get that not all people are.</div><br/></div></div><div id="36121293" class="c"><input type="checkbox" id="c-36121293" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#36120331">parent</a><span>|</span><a href="#36121507">prev</a><span>|</span><a href="#36121494">next</a><span>|</span><label class="collapse" for="c-36121293">[-]</label><label class="expand" for="c-36121293">[1 more]</label></div><br/><div class="children"><div class="content">&gt; because those symbols service important UX functions<p>As I read the post, I was thinking that #tags and @mentions are primarily about <i>input</i>, not reading. It&#x27;s easier to just whack some #random #tags in your #sentences than to switch to a separate tag list input. Similarly, highlighting some text in order to apply the &quot;mention&quot; brush like we might with bold or italics would be strictly worse.</div><br/></div></div></div></div><div id="36121494" class="c"><input type="checkbox" id="c-36121494" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#36120331">prev</a><span>|</span><a href="#36121532">next</a><span>|</span><label class="collapse" for="c-36121494">[-]</label><label class="expand" for="c-36121494">[1 more]</label></div><br/><div class="children"><div class="content">One of the things sigil allow you to do is overload other syntax. The example I usually bring up is the difference between<p><pre><code>    @hash{a,b,c}
</code></pre>
which returns a list containing the values associated with keys a, b, and c; and on the other hand<p><pre><code>    $hash{a,b,c}
</code></pre>
which returns the single item associated with the key constructed from concatenating a, b, and c (used to emulate a three-dimensional array.)</div><br/></div></div><div id="36121532" class="c"><input type="checkbox" id="c-36121532" checked=""/><div class="controls bullet"><span class="by">mihaic</span><span>|</span><a href="#36121494">prev</a><span>|</span><a href="#36121271">next</a><span>|</span><label class="collapse" for="c-36121532">[-]</label><label class="expand" for="c-36121532">[1 more]</label></div><br/><div class="children"><div class="content">Personally, I have the exact opposite thoughs on sigils: they break my fluency in reading code.<p>Not all sigils are as bad, but to me it&#x27;s as if there&#x27;s a word from a foreign language italicized in an english sentance -- that means I&#x27;ll have a reading pause there.<p>The dollar sign is among the worst, and curly braces are the lightest, with ”@&quot; bring in the middle in terms of pausing reading.</div><br/></div></div><div id="36121271" class="c"><input type="checkbox" id="c-36121271" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#36121532">prev</a><span>|</span><a href="#36120099">next</a><span>|</span><label class="collapse" for="c-36121271">[-]</label><label class="expand" for="c-36121271">[1 more]</label></div><br/><div class="children"><div class="content">I wish that more programming languages would include detailed rationales and justifications of their features like this in their documentation. While this blog post doesn&#x27;t have the rigor of something like the Ada Rationale[1], it gives a real sense of <i>why</i> something might have been designed the way it was.<p>Maybe I just enjoy reading this sort of thing. But we are so often told to choose the &quot;best tool&quot;, or find ourselves evaluating programming languages for all sorts of reasons. Being able to understand a language in its context, the choices it made in comparison to the alternatives, can only help with that.<p>When I read the rationale for a new early-stage language Austral[2], I found myself actually able to evaluate what I thought the language might be good for, how it might evolve while under the control of the same creator, whether it fit with my personal strengths, weaknesses, methods and aesthetics, etc.<p>By contrast, I was perusing the documentation for Odin, another new language, at around the same time. While I don&#x27;t want to disparage the incredible amount of work it took to a) build a programming language and ecosystem and b) document it, I found myself wishing for a similar &quot;rationale&quot; document so I could actually compare Odin with Austral at a more abstract level than reading syntax.<p>Odin&#x27;s &quot;overview&quot; begins with an example of the lexical syntax of comments, rather than what the principle &quot;Striving for orthogonality&quot;[3] in its FAQ actually means and how it is borne out in the language as designed, compared to other approaches that could have been taken.<p>Austral, by contrast, has a great section called &quot;the cutting room floor&quot; where the creator discusses different approaches to resource safety, the difficult tradeoffs to be made, and why Austral decided on possibly the severest of all the approaches. This isn&#x27;t <i>just</i> philosophy; it tells me something useful about the tradeoffs involved in using the language.<p>Anyway, the OP helped me to understand very clearly that Raku&#x27;s priorities and values are extremely different to my own, and that it would likely be a bad choice for me to invest time in.<p>[1] <a href="http:&#x2F;&#x2F;ada-auth.org&#x2F;standards&#x2F;12rat&#x2F;html&#x2F;Rat12-TOC.html" rel="nofollow">http:&#x2F;&#x2F;ada-auth.org&#x2F;standards&#x2F;12rat&#x2F;html&#x2F;Rat12-TOC.html</a><p>[2] <a href="https:&#x2F;&#x2F;austral-lang.org&#x2F;spec&#x2F;spec.html" rel="nofollow">https:&#x2F;&#x2F;austral-lang.org&#x2F;spec&#x2F;spec.html</a><p>[3] <a href="https:&#x2F;&#x2F;odin-lang.org&#x2F;docs&#x2F;faq&#x2F;" rel="nofollow">https:&#x2F;&#x2F;odin-lang.org&#x2F;docs&#x2F;faq&#x2F;</a></div><br/></div></div><div id="36120099" class="c"><input type="checkbox" id="c-36120099" checked=""/><div class="controls bullet"><span class="by">mkoubaa</span><span>|</span><a href="#36121271">prev</a><span>|</span><a href="#36120134">next</a><span>|</span><label class="collapse" for="c-36120099">[-]</label><label class="expand" for="c-36120099">[1 more]</label></div><br/><div class="children"><div class="content">Avoiding sigils is a good future proofing strategy. When you find out you need a new syntax it&#x27;s nice to have a set of symbols that are guaranteed not to break existing code</div><br/></div></div><div id="36120134" class="c"><input type="checkbox" id="c-36120134" checked=""/><div class="controls bullet"><span class="by">js8</span><span>|</span><a href="#36120099">prev</a><span>|</span><a href="#36121054">next</a><span>|</span><label class="collapse" for="c-36120134">[-]</label><label class="expand" for="c-36120134">[3 more]</label></div><br/><div class="children"><div class="content">Regarding sigils, there is also ? and ! in Scheme and Clojure, and don&#x27;t get me started on Forth, it&#x27;s pretty much sigils all the way down.</div><br/><div id="36120207" class="c"><input type="checkbox" id="c-36120207" checked=""/><div class="controls bullet"><span class="by">grzm</span><span>|</span><a href="#36120134">parent</a><span>|</span><a href="#36121054">next</a><span>|</span><label class="collapse" for="c-36120207">[-]</label><label class="expand" for="c-36120207">[2 more]</label></div><br/><div class="children"><div class="content">In Clojure (and I’m pretty sure Scheme), <i>!</i> and <i>?</i> are not sigils in the sense that they’re special syntax like, say, <i>@</i> (which is a reader macro), or <i>@</i> and <i>@@</i> in Ruby: they just tend to be used by convention. <i>!</i> and <i>?</i> are no different than <i>a</i> or <i>b</i>.<p>You can read more about the Clojure reader here: <a href="https:&#x2F;&#x2F;clojure.org&#x2F;reference&#x2F;reader" rel="nofollow">https:&#x2F;&#x2F;clojure.org&#x2F;reference&#x2F;reader</a></div><br/><div id="36120528" class="c"><input type="checkbox" id="c-36120528" checked=""/><div class="controls bullet"><span class="by">js8</span><span>|</span><a href="#36120134">root</a><span>|</span><a href="#36120207">parent</a><span>|</span><a href="#36121054">next</a><span>|</span><label class="collapse" for="c-36120528">[-]</label><label class="expand" for="c-36120528">[1 more]</label></div><br/><div class="children"><div class="content">They somewhat follow the OP&#x27;s definition of sigil (in the yellow box), which doesn&#x27;t say that sigils have to be interpreted in a special way, only that they convey some meaning to the programmer (although it&#x27;s a bit unclear - communicate to whom, programmer or interpreter?). They are also not at the beginning of the word, but that seems to be rather arbitrary requirement.</div><br/></div></div></div></div></div></div><div id="36121054" class="c"><input type="checkbox" id="c-36121054" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#36120134">prev</a><span>|</span><a href="#36120753">next</a><span>|</span><label class="collapse" for="c-36121054">[-]</label><label class="expand" for="c-36121054">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I understand what counts as a sigil and what doesn&#x27;t.  How many sigils does the following line have?<p>&gt; echo $foo # $foo refers to the contents of the variable foo</div><br/></div></div><div id="36120753" class="c"><input type="checkbox" id="c-36120753" checked=""/><div class="controls bullet"><span class="by">jakear</span><span>|</span><a href="#36121054">prev</a><span>|</span><a href="#36119812">next</a><span>|</span><label class="collapse" for="c-36120753">[-]</label><label class="expand" for="c-36120753">[1 more]</label></div><br/><div class="children"><div class="content">Well that&#x27;s a whole lot of talk with 0 concrete code examples...<p>One interesting thing, the author mentions VS Code as abolishing the need for Hungarian notation, which is funny - the entire VS Code codebase in written in Hungarian.</div><br/></div></div><div id="36119812" class="c"><input type="checkbox" id="c-36119812" checked=""/><div class="controls bullet"><span class="by">mfranc42</span><span>|</span><a href="#36120753">prev</a><span>|</span><a href="#36120435">next</a><span>|</span><label class="collapse" for="c-36119812">[-]</label><label class="expand" for="c-36119812">[1 more]</label></div><br/><div class="children"><div class="content">Yes. Namespaces good. Escape sequences good. Terse syntax good. As long as it&#x27;s not rare and obscure good. :-)</div><br/></div></div><div id="36120435" class="c"><input type="checkbox" id="c-36120435" checked=""/><div class="controls bullet"><span class="by">Arathorn</span><span>|</span><a href="#36119812">prev</a><span>|</span><a href="#36121002">next</a><span>|</span><label class="collapse" for="c-36120435">[-]</label><label class="expand" for="c-36120435">[1 more]</label></div><br/><div class="children"><div class="content">it’s always been a naughty pleasure that Matrix uses sigils both for ‘mainstream’ user IDs (@user:domain.com) and room aliases (#room:domain.com) as well as more developer focused things - $ for event IDs, ! for room IDs: <a href="https:&#x2F;&#x2F;spec.matrix.org&#x2F;v1.7&#x2F;appendices&#x2F;#common-identifier-format" rel="nofollow">https:&#x2F;&#x2F;spec.matrix.org&#x2F;v1.7&#x2F;appendices&#x2F;#common-identifier-f...</a><p>I have a bad feeling this is due to me doing too much Perl as a child. But folks don’t seem to complain about it, especially since we also sprouted a proper URI scheme too.</div><br/></div></div><div id="36121002" class="c"><input type="checkbox" id="c-36121002" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#36120435">prev</a><span>|</span><a href="#36119950">next</a><span>|</span><label class="collapse" for="c-36121002">[-]</label><label class="expand" for="c-36121002">[1 more]</label></div><br/><div class="children"><div class="content">Pedant mode: In BASIC, since the $ is at the end of var name, is it not a sigil?</div><br/></div></div><div id="36119950" class="c"><input type="checkbox" id="c-36119950" checked=""/><div class="controls bullet"><span class="by">powera</span><span>|</span><a href="#36121002">prev</a><span>|</span><a href="#36120436">next</a><span>|</span><label class="collapse" for="c-36119950">[-]</label><label class="expand" for="c-36119950">[2 more]</label></div><br/><div class="children"><div class="content">We are past the point where sigils are useful for a modern compiler or machine interpreter.  A limited ability to avoid collisions with &quot;reserved words&quot; ... would be more of a mis-feature than a feature.<p>The value of a sigil is for the other humans reading the code.  And, I agree it can be quite valuable there.</div><br/><div id="36122018" class="c"><input type="checkbox" id="c-36122018" checked=""/><div class="controls bullet"><span class="by">Zecc</span><span>|</span><a href="#36119950">parent</a><span>|</span><a href="#36120436">next</a><span>|</span><label class="collapse" for="c-36122018">[-]</label><label class="expand" for="c-36122018">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A limited ability to avoid collisions with &quot;reserved words&quot; ... would be more of a mis-feature than a feature.<p>While I don&#x27;t necessarily disagree with you, there&#x27;s something I&#x27;d like to mention.<p>C# allows using @ before a variable name which happens to be the same as a keyword to escape the name.<p>I don&#x27;t remember the specifics, but it has saved me once when I wanted to create a class shaped exactly like a JSON object I was loading from an external source and one of the fields was a reserved word. For example, this works fine:<p><pre><code>    class MyClass
    {
        public int value;
        public string @default;
        public string @switch;
    }
    
    string json = &quot;{\&quot;value\&quot;: 8, \&quot;default\&quot;: \&quot;something\&quot;, \&quot;switch\&quot;: \&quot;on\&quot;}&quot;;

    MyClass o = JObject.Parse(json).ToObject&lt;MyClass&gt;();
    Console.WriteLine(&quot;default={0}, switch={1}&quot;, o.@default, o.@switch);</code></pre></div><br/></div></div></div></div><div id="36120436" class="c"><input type="checkbox" id="c-36120436" checked=""/><div class="controls bullet"><span class="by">smeagull</span><span>|</span><a href="#36119950">prev</a><span>|</span><a href="#36120289">next</a><span>|</span><label class="collapse" for="c-36120436">[-]</label><label class="expand" for="c-36120436">[1 more]</label></div><br/><div class="children"><div class="content">Sigils are why I gave up learning PERL. Everything I learned had a half life of 10 minutes.<p>I haven&#x27;t programmed C in a decade, I still remember most of it.</div><br/></div></div><div id="36120289" class="c"><input type="checkbox" id="c-36120289" checked=""/><div class="controls bullet"><span class="by">throwaway290</span><span>|</span><a href="#36120436">prev</a><span>|</span><a href="#36119736">next</a><span>|</span><label class="collapse" for="c-36120289">[-]</label><label class="expand" for="c-36120289">[2 more]</label></div><br/><div class="children"><div class="content">Rambling and I disagree with a lot.<p>&gt; We had that problem at  $day_job: our code was a mess, but everyone thought  $framework  would magically fix it.<p>Replace with &quot;a&quot; or &quot;that one&quot; and it&#x27;s the same or even better.<p>The reality is that $dayjob (or %dayjob% etc) signals &quot;hey I&#x27;m a programmer&quot; and is less to type.<p>&gt; I need to be able to quickly distinguish between the two types of labels so that I can notice emails that don’t have exactly one folder-label. This is a job for sigils.<p>Prefixing email labels is a workaround in this case because you don&#x27;t need to notice emails that belong to two folders if your filtering system is good.<p>&gt; As you’ve probably noticed, I’ve been saying “has an array-like interface” instead of “is an Array ”. That’s because – and this is a crucial distinction – Raku’s sigils do not encode type information. They only tell you what interface you can use.<p>&gt; ...<p>&gt; And  Buf s aren’t  Array s, nor are they any subtype of  Array . But they can be used with an array-like interface, so they can be stored in an  @ -siglied variable.<p>Sounds like a missed opportunity to type buffers as byte arrays...</div><br/><div id="36120587" class="c"><input type="checkbox" id="c-36120587" checked=""/><div class="controls bullet"><span class="by">LeonB</span><span>|</span><a href="#36120289">parent</a><span>|</span><a href="#36119736">next</a><span>|</span><label class="collapse" for="c-36120587">[-]</label><label class="expand" for="c-36120587">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The reality is that $dayjob (or %dayjob% etc) signals &quot;hey I&#x27;m a programmer&quot;<p>You’ve hit the nail on the head. It’s also about the reader who understands the context and thus feels a sense of belonging to an “in-group”.<p>It’s petty, but it’s how humans work. We form and reinforce our little cliques in anyway we can.</div><br/></div></div></div></div><div id="36119736" class="c"><input type="checkbox" id="c-36119736" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#36120289">prev</a><span>|</span><a href="#36122193">next</a><span>|</span><label class="collapse" for="c-36119736">[-]</label><label class="expand" for="c-36119736">[2 more]</label></div><br/><div class="children"><div class="content">Templating is practically universal.<p>And string interpolation (basically the same thing) is on python, groovy, and I think is coming to java.</div><br/><div id="36121087" class="c"><input type="checkbox" id="c-36121087" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#36119736">parent</a><span>|</span><a href="#36122193">next</a><span>|</span><label class="collapse" for="c-36121087">[-]</label><label class="expand" for="c-36121087">[1 more]</label></div><br/><div class="children"><div class="content">$&#x2F;<p>groovy string interpolation is ${criticism}<p>&#x2F;$</div><br/></div></div></div></div></div></div></div></div></div></body></html>