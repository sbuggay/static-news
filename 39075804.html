<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705827653097" as="style"/><link rel="stylesheet" href="styles.css?v=1705827653097"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.jeffreythompson.org/collision-detection/index.php">Collision Detection (2015)</a> <span class="domain">(<a href="https://www.jeffreythompson.org">www.jeffreythompson.org</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>30 comments</span></div><br/><div><div id="39076600" class="c"><input type="checkbox" id="c-39076600" checked=""/><div class="controls bullet"><span class="by">kipi</span><span>|</span><a href="#39076253">next</a><span>|</span><label class="collapse" for="c-39076600">[-]</label><label class="expand" for="c-39076600">[2 more]</label></div><br/><div class="children"><div class="content">Shameless self promotion, but if you&#x27;re interested in how collision detection was done in 3D (in Quake) I made a video on the topic here:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=wLHXn8IlAiA" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=wLHXn8IlAiA</a><p>The technique can detect the intersection point of a (fixed size, axially aligned) moving bounding box and a hull defined as a BSP tree.  In this sense it is rather limited compared to newer methods but it works rather well and the implementation is pretty robust, and fast enough for the primitive hardware of the day.</div><br/><div id="39076630" class="c"><input type="checkbox" id="c-39076630" checked=""/><div class="controls bullet"><span class="by">abrarsami</span><span>|</span><a href="#39076600">parent</a><span>|</span><a href="#39076253">next</a><span>|</span><label class="collapse" for="c-39076630">[-]</label><label class="expand" for="c-39076630">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for this</div><br/></div></div></div></div><div id="39076253" class="c"><input type="checkbox" id="c-39076253" checked=""/><div class="controls bullet"><span class="by">aappleby</span><span>|</span><a href="#39076600">prev</a><span>|</span><a href="#39076651">next</a><span>|</span><label class="collapse" for="c-39076253">[-]</label><label class="expand" for="c-39076253">[9 more]</label></div><br/><div class="children"><div class="content">If you want to do collision detection in something like a game and you don&#x27;t want to be constantly debugging collision issues, you have to be way way more aware of numerical precision issues than this article is.<p>For example, even a basic &quot;point in sphere&quot; test can return logically inconsistent results if the point is right on the surface of the sphere and you swap the x and z coordinates.<p>Ignoring issues like precision can result in players falling through the world or walking through walls.</div><br/><div id="39076322" class="c"><input type="checkbox" id="c-39076322" checked=""/><div class="controls bullet"><span class="by">vvanders</span><span>|</span><a href="#39076253">parent</a><span>|</span><a href="#39076662">next</a><span>|</span><label class="collapse" for="c-39076322">[-]</label><label class="expand" for="c-39076322">[5 more]</label></div><br/><div class="children"><div class="content">One of my favorite books is Real-Time Collision Detection[1] which covers this and other adjacent topics(like cache line aware data structures!). I generally refer to it as &quot;data structures for 2D&#x2F;3D&quot; and I think only the Art of Electronics has more value on a page-by-page basis for the domains I&#x27;ve enjoyed.<p>[1] <a href="https:&#x2F;&#x2F;realtimecollisiondetection.net&#x2F;books&#x2F;rtcd&#x2F;" rel="nofollow">https:&#x2F;&#x2F;realtimecollisiondetection.net&#x2F;books&#x2F;rtcd&#x2F;</a></div><br/><div id="39076353" class="c"><input type="checkbox" id="c-39076353" checked=""/><div class="controls bullet"><span class="by">OnionBlender</span><span>|</span><a href="#39076253">root</a><span>|</span><a href="#39076322">parent</a><span>|</span><a href="#39076375">next</a><span>|</span><label class="collapse" for="c-39076353">[-]</label><label class="expand" for="c-39076353">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised there was never a 2nd edition in the past 20 years.</div><br/><div id="39076675" class="c"><input type="checkbox" id="c-39076675" checked=""/><div class="controls bullet"><span class="by">_the_inflator</span><span>|</span><a href="#39076253">root</a><span>|</span><a href="#39076353">parent</a><span>|</span><a href="#39076375">next</a><span>|</span><label class="collapse" for="c-39076675">[-]</label><label class="expand" for="c-39076675">[1 more]</label></div><br/><div class="children"><div class="content">I think the advice and mechanics are timeless. This is robust CS and Math stuff which stood the test of time. And this makes the book itself so valuable. I own it.</div><br/></div></div></div></div><div id="39076375" class="c"><input type="checkbox" id="c-39076375" checked=""/><div class="controls bullet"><span class="by">lebaux</span><span>|</span><a href="#39076253">root</a><span>|</span><a href="#39076322">parent</a><span>|</span><a href="#39076353">prev</a><span>|</span><a href="#39076662">next</a><span>|</span><label class="collapse" for="c-39076375">[-]</label><label class="expand" for="c-39076375">[2 more]</label></div><br/><div class="children"><div class="content">Nice, I literally just asked the OP to provide a link! Thank you!</div><br/><div id="39076624" class="c"><input type="checkbox" id="c-39076624" checked=""/><div class="controls bullet"><span class="by">aappleby</span><span>|</span><a href="#39076253">root</a><span>|</span><a href="#39076375">parent</a><span>|</span><a href="#39076662">next</a><span>|</span><label class="collapse" for="c-39076624">[-]</label><label class="expand" for="c-39076624">[1 more]</label></div><br/><div class="children"><div class="content">Yep that&#x27;s the book.</div><br/></div></div></div></div></div></div><div id="39076662" class="c"><input type="checkbox" id="c-39076662" checked=""/><div class="controls bullet"><span class="by">_the_inflator</span><span>|</span><a href="#39076253">parent</a><span>|</span><a href="#39076322">prev</a><span>|</span><a href="#39076366">next</a><span>|</span><label class="collapse" for="c-39076662">[-]</label><label class="expand" for="c-39076662">[1 more]</label></div><br/><div class="children"><div class="content">Speedrunners will not appreciate it. ;)<p>Also, in my experience, right from the beginning you should be aware of performance issues and should be familiar with a quad tree.<p>I build shooters for Android mobile in 2016 and heavy action and lots of screen fun was impossible without quad trees.</div><br/></div></div><div id="39076366" class="c"><input type="checkbox" id="c-39076366" checked=""/><div class="controls bullet"><span class="by">lebaux</span><span>|</span><a href="#39076253">parent</a><span>|</span><a href="#39076662">prev</a><span>|</span><a href="#39076651">next</a><span>|</span><label class="collapse" for="c-39076366">[-]</label><label class="expand" for="c-39076366">[2 more]</label></div><br/><div class="children"><div class="content">This is super interesting, what further reading would you recommend for a complete beginner in collision detection? Thank you.</div><br/><div id="39076448" class="c"><input type="checkbox" id="c-39076448" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#39076253">root</a><span>|</span><a href="#39076366">parent</a><span>|</span><a href="#39076651">next</a><span>|</span><label class="collapse" for="c-39076448">[-]</label><label class="expand" for="c-39076448">[1 more]</label></div><br/><div class="children"><div class="content">Not only collision detection, but everything that uses floats like graphic does.
I would recommend introductions to numerics and linear algebra, which should cover everything needed (the theory and how to actually use floats in programs) but not be overly &quot;mathematical&quot; formulated. But as I am a mathematician (who learned that 25 years ago) I don&#x27;t háve any concrete recommendations of books or videos of lectures and you would not be able to read my handwriting, as I would have problems reading what I wrote back then ;).</div><br/></div></div></div></div></div></div><div id="39076651" class="c"><input type="checkbox" id="c-39076651" checked=""/><div class="controls bullet"><span class="by">Tade0</span><span>|</span><a href="#39076253">prev</a><span>|</span><a href="#39076697">next</a><span>|</span><label class="collapse" for="c-39076651">[-]</label><label class="expand" for="c-39076651">[2 more]</label></div><br/><div class="children"><div class="content">Note that this book talks about static collision detection.<p>In games you&#x27;ll be better off calculating the function of distance between the two objects over time and registering a hit if it reaches zero.<p>For instance, the square of distance between two circles moving at a constant speed is a parabola, so it&#x27;s enough to sample it at three points in time to get its coefficients.</div><br/><div id="39076718" class="c"><input type="checkbox" id="c-39076718" checked=""/><div class="controls bullet"><span class="by">arketyp</span><span>|</span><a href="#39076651">parent</a><span>|</span><a href="#39076697">next</a><span>|</span><label class="collapse" for="c-39076718">[-]</label><label class="expand" for="c-39076718">[1 more]</label></div><br/><div class="children"><div class="content">Kinetic triangulation problems are formulated similar to this. I&#x27;ve written an algorithm for a specific kind of triangulation schema [1] where collision events are sorted as quadratic inequalities. The math becomes quite involved when robustness is required and floating point representation is avoided. You have to treat the irrational time points of collision events as existing but expressed implicitly, as in a sort of unevaluated symbolic form. Kind of like imaginary numbers.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;mpihlstrom&#x2F;femton">https:&#x2F;&#x2F;github.com&#x2F;mpihlstrom&#x2F;femton</a></div><br/></div></div></div></div><div id="39076697" class="c"><input type="checkbox" id="c-39076697" checked=""/><div class="controls bullet"><span class="by">yzydserd</span><span>|</span><a href="#39076651">prev</a><span>|</span><a href="#39076484">next</a><span>|</span><label class="collapse" for="c-39076697">[-]</label><label class="expand" for="c-39076697">[1 more]</label></div><br/><div class="children"><div class="content">It’s a nice site and collection of techniques. However, it doesn’t fully follow through on the first page context of a resource for people new to CD in game making.<p>CD is expensive, so knowing when to check for it, and when to approximately check for it vs accurately check for it is very important. Filtering is going to save you many more clock cycles than most CD tuning. For example distance checking, and checking when you don’t need to check for tunnelling, and simple things like avoiding sqrt. You need to establish “good enough” CD for each use case.<p>I didn’t read every word so I may have glossed past those parts. I enjoyed what I did read but a chapter on the “practical” side would be a welcome addition.</div><br/></div></div><div id="39076484" class="c"><input type="checkbox" id="c-39076484" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#39076697">prev</a><span>|</span><a href="#39076301">next</a><span>|</span><label class="collapse" for="c-39076484">[-]</label><label class="expand" for="c-39076484">[2 more]</label></div><br/><div class="children"><div class="content">I recently started playing around with a physics engine library and it quickly became clear to me that I had no business attempting to build my own. I thought I was &quot;close&quot; with my DIY attempt and then read docs like the following:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;bepu&#x2F;bepuphysics2&#x2F;blob&#x2F;master&#x2F;Documentation&#x2F;ContinuousCollisionDetection.md">https:&#x2F;&#x2F;github.com&#x2F;bepu&#x2F;bepuphysics2&#x2F;blob&#x2F;master&#x2F;Documentati...</a><p>Configuring mandatory basics like &quot;solver iterations&quot; sent some strong signals to me that I was attempting to fight a dragon I couldn&#x27;t even fully see.</div><br/><div id="39076627" class="c"><input type="checkbox" id="c-39076627" checked=""/><div class="controls bullet"><span class="by">9dev</span><span>|</span><a href="#39076484">parent</a><span>|</span><a href="#39076301">next</a><span>|</span><label class="collapse" for="c-39076627">[-]</label><label class="expand" for="c-39076627">[1 more]</label></div><br/><div class="children"><div class="content">The most important part of this feeling is not giving in to being intimidated. By realising there <i>is</i> a dragon, you’ve already made a big step! Others could fight the dragon because they made the same first step at some point, not because they are so much smarter than you.</div><br/></div></div></div></div><div id="39076301" class="c"><input type="checkbox" id="c-39076301" checked=""/><div class="controls bullet"><span class="by">whatever1</span><span>|</span><a href="#39076484">prev</a><span>|</span><a href="#39076530">next</a><span>|</span><label class="collapse" for="c-39076301">[-]</label><label class="expand" for="c-39076301">[11 more]</label></div><br/><div class="children"><div class="content">The collision problem always makes me wonder if we miss something obvious. It&#x27;s so hard to solve it mathematically&#x2F;algorithmically specially when a lot of vertices are involved, yet give the same problem to a semi awake brain and can immediately give you the right answer.</div><br/><div id="39076321" class="c"><input type="checkbox" id="c-39076321" checked=""/><div class="controls bullet"><span class="by">xeonmc</span><span>|</span><a href="#39076301">parent</a><span>|</span><a href="#39076510">next</a><span>|</span><label class="collapse" for="c-39076321">[-]</label><label class="expand" for="c-39076321">[5 more]</label></div><br/><div class="children"><div class="content">the brain and eyes are massively parallel devices with stochastic ray tracing simulated for free.<p>If you can brute-force raycasts without paying the computational burden then collision is an embarrassingly parallel problem.<p>On the other hand, calculating collision on a computer is akin to a blind man feeling his way through a scene carefully checking against every object.<p>The blind man has to simulate his own raytracing with his hands, unless he can perform echolocation which once again is basically lower-resolution raytracing.<p>It does make me wonder though whether newer generation GPU focused on raytracing could finally bring hardware acceleration to collision?</div><br/><div id="39076376" class="c"><input type="checkbox" id="c-39076376" checked=""/><div class="controls bullet"><span class="by">battesonb</span><span>|</span><a href="#39076301">root</a><span>|</span><a href="#39076321">parent</a><span>|</span><a href="#39076520">next</a><span>|</span><label class="collapse" for="c-39076376">[-]</label><label class="expand" for="c-39076376">[2 more]</label></div><br/><div class="children"><div class="content">We somewhat have this with object picking. You can render objects with unique IDs to a framebuffer, so it&#x27;s all in parallel. Then you just query the buffer at your mouse coordinates.<p>Of course you lose some properties of the object and it&#x27;s on a one frame delay. There&#x27;s the added complexity of collision response, working in 3-dimensions, etc. But, to the point of just &quot;eyeballing&quot; collision, we can actually parallelize it!</div><br/><div id="39076757" class="c"><input type="checkbox" id="c-39076757" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#39076301">root</a><span>|</span><a href="#39076376">parent</a><span>|</span><a href="#39076520">next</a><span>|</span><label class="collapse" for="c-39076757">[-]</label><label class="expand" for="c-39076757">[1 more]</label></div><br/><div class="children"><div class="content">&gt;and it&#x27;s on a one frame delay<p>Reading a texture from the GPU can take more than one frame.</div><br/></div></div></div></div><div id="39076520" class="c"><input type="checkbox" id="c-39076520" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#39076301">root</a><span>|</span><a href="#39076321">parent</a><span>|</span><a href="#39076376">prev</a><span>|</span><a href="#39076372">next</a><span>|</span><label class="collapse" for="c-39076520">[-]</label><label class="expand" for="c-39076520">[1 more]</label></div><br/><div class="children"><div class="content">&gt; could finally bring hardware acceleration to collision<p>Physx has collision detection.</div><br/></div></div><div id="39076372" class="c"><input type="checkbox" id="c-39076372" checked=""/><div class="controls bullet"><span class="by">guitarlimeo</span><span>|</span><a href="#39076301">root</a><span>|</span><a href="#39076321">parent</a><span>|</span><a href="#39076520">prev</a><span>|</span><a href="#39076510">next</a><span>|</span><label class="collapse" for="c-39076372">[-]</label><label class="expand" for="c-39076372">[1 more]</label></div><br/><div class="children"><div class="content">This is a nice analogy, never thought of it that way but it makes sense!</div><br/></div></div></div></div><div id="39076510" class="c"><input type="checkbox" id="c-39076510" checked=""/><div class="controls bullet"><span class="by">Jasper_</span><span>|</span><a href="#39076301">parent</a><span>|</span><a href="#39076321">prev</a><span>|</span><a href="#39076553">next</a><span>|</span><label class="collapse" for="c-39076510">[-]</label><label class="expand" for="c-39076510">[1 more]</label></div><br/><div class="children"><div class="content">The brain solves it by noticing where two solid polygons overlap. In that sense, you could also find the collision by rasterizing both shapes and testing whether any pixels overlap, but that&#x27;s going to be slower and less precise than an algorithmic version.<p>With just an algebraic version of two polygons, your brain can&#x27;t solve it as easily.</div><br/></div></div><div id="39076489" class="c"><input type="checkbox" id="c-39076489" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#39076301">parent</a><span>|</span><a href="#39076553">prev</a><span>|</span><a href="#39076324">next</a><span>|</span><label class="collapse" for="c-39076489">[-]</label><label class="expand" for="c-39076489">[1 more]</label></div><br/><div class="children"><div class="content">The problém with collision detection is less that is hard to do at all (it is actually quite simple), it is that it takes too long to brute-force check all of them. The samé problém as with raytracing.</div><br/></div></div><div id="39076324" class="c"><input type="checkbox" id="c-39076324" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#39076301">parent</a><span>|</span><a href="#39076489">prev</a><span>|</span><a href="#39076407">next</a><span>|</span><label class="collapse" for="c-39076324">[-]</label><label class="expand" for="c-39076324">[1 more]</label></div><br/><div class="children"><div class="content">No? It&#x27;s just one of the thousands of tasks that biological brains are envolved to do well.</div><br/></div></div><div id="39076407" class="c"><input type="checkbox" id="c-39076407" checked=""/><div class="controls bullet"><span class="by">lebaux</span><span>|</span><a href="#39076301">parent</a><span>|</span><a href="#39076324">prev</a><span>|</span><a href="#39076530">next</a><span>|</span><label class="collapse" for="c-39076407">[-]</label><label class="expand" for="c-39076407">[1 more]</label></div><br/><div class="children"><div class="content">You are missing one single line of math, basically 1=0=∞. This line of math is what separates humanity from fusion energy. Of course, I am fully aware of how crazy that sounds -- go ahead, try to find proof that 1=0=∞ does not compute. It is impossible to prove this does not work and at the same time; the proof that this line of math works is impossible to grasp. If I am right, this very comment will become pretty famous, if I am wrong, literally nothing happens and we all move on with our lives. Sadly, for me personally, it is impossible to ignore this math problem.<p>I call it &quot;The Last Paradox&quot;. It is at very least interesting mental&#x2F;math&#x2F;physics exercise. Gotta run!</div><br/></div></div></div></div><div id="39076530" class="c"><input type="checkbox" id="c-39076530" checked=""/><div class="controls bullet"><span class="by">elwell</span><span>|</span><a href="#39076301">prev</a><span>|</span><a href="#39076419">next</a><span>|</span><label class="collapse" for="c-39076530">[-]</label><label class="expand" for="c-39076530">[1 more]</label></div><br/><div class="children"><div class="content">Here is my very basic collision detection in ClojureScript: <a href="https:&#x2F;&#x2F;github.com&#x2F;celwell&#x2F;wordsmith&#x2F;blob&#x2F;master&#x2F;src&#x2F;cljs&#x2F;wordsmith&#x2F;physics.cljs">https:&#x2F;&#x2F;github.com&#x2F;celwell&#x2F;wordsmith&#x2F;blob&#x2F;master&#x2F;src&#x2F;cljs&#x2F;wo...</a></div><br/></div></div><div id="39076419" class="c"><input type="checkbox" id="c-39076419" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39076530">prev</a><span>|</span><label class="collapse" for="c-39076419">[-]</label><label class="expand" for="c-39076419">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>Collision Detection (2015)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=24735824">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=24735824</a> - Oct 2020 (33 comments)</div><br/></div></div></div></div></div></div></div></body></html>