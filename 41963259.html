<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1730365268680" as="style"/><link rel="stylesheet" href="styles.css?v=1730365268680"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://em-tg.github.io/csborrow/">A comparison of Rust&#x27;s borrow checker to the one in C#</a> <span class="domain">(<a href="https://em-tg.github.io">em-tg.github.io</a>)</span></div><div class="subtext"><span>SkiFire13</span> | <span>43 comments</span></div><br/><div><div id="42004362" class="c"><input type="checkbox" id="c-42004362" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#42004139">next</a><span>|</span><label class="collapse" for="c-42004362">[-]</label><label class="expand" for="c-42004362">[2 more]</label></div><br/><div class="children"><div class="content">&gt;How is it possible that I can write efficient and provably-safe code in C# without a degree in type theory?<p>Because Anders Hejlsberg is one of the greatest language architects and the C# team are continuing that tradition.<p>The only grudge I have against them is they promised us discriminated unions since forever and they are still discussing how to implement it. I think that is the greatest feature C# is missing.<p>For the rest C# is mostly perfect. It has a good blend of functional and OOP, you can do both low level and high level code. You can target both the VM or the bare hardware. You can write all types of code beside system programming (due to the garbage collector). But you can do web backend, web front-end, services, desktop, mobile apps, microcontroller stuff, games and all else. It has very good libraries and frameworks for whatever you need. The experience with Visual Studio is stellar.<p>And the community is great. And for most domains there is generally only one library or framework everybody uses so you not only don&#x27;t have to ask what to use for a new feature or project, but you also find very good examples and help if you need.<p>It feels like a better, more strait trough version of Java, less verbose and less boiler plate-y. So that&#x27;s why .NET didn&#x27;t need its own Kotlin.<p>Sure, it can&#x27;t meet the speed of Rust or C# for some tasks because of the garbage collector. But provided you AOT compule, disable the garbage collector and do manual memory management, it should.</div><br/><div id="42004728" class="c"><input type="checkbox" id="c-42004728" checked=""/><div class="controls bullet"><span class="by">jabwd</span><span>|</span><a href="#42004362">parent</a><span>|</span><a href="#42004139">next</a><span>|</span><label class="collapse" for="c-42004728">[-]</label><label class="expand" for="c-42004728">[1 more]</label></div><br/><div class="children"><div class="content">Except that the GC makes it exactly not viable for games and its one of the biggest problems Unity devs run into. I agree it&#x27;s a great language, but its not a do it all.</div><br/></div></div></div></div><div id="42004139" class="c"><input type="checkbox" id="c-42004139" checked=""/><div class="controls bullet"><span class="by">leosarev</span><span>|</span><a href="#42004362">prev</a><span>|</span><a href="#41968703">next</a><span>|</span><label class="collapse" for="c-42004139">[-]</label><label class="expand" for="c-42004139">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Maybe I’m bad at searching for these things, but these changes to C# seem to have gone completely under the radar in places where you read about memory safety and performance.<p>The reason is this changes are not aimed on average Joe developer writing C# microservices. This changes and whole Span&#x2F;ref dialect of C# are aimed on Dr. Smartass developer writing C# high performance libraries. It&#x27;s advance-level feature.</div><br/><div id="42004394" class="c"><input type="checkbox" id="c-42004394" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#42004139">parent</a><span>|</span><a href="#42004330">next</a><span>|</span><label class="collapse" for="c-42004394">[-]</label><label class="expand" for="c-42004394">[1 more]</label></div><br/><div class="children"><div class="content">I use low level C# constructs, mostly for fun. At current job we write backend microservices and our business domain doesn&#x27;t need too much low level stuff.<p>But before span and friends you could always use pointers. Spans just make things friendlier.<p>And C# also has built-in SIMD libraries if you need to do some high performance arithmetic stuff.</div><br/></div></div><div id="42004330" class="c"><input type="checkbox" id="c-42004330" checked=""/><div class="controls bullet"><span class="by">yread</span><span>|</span><a href="#42004139">parent</a><span>|</span><a href="#42004394">prev</a><span>|</span><a href="#41968703">next</a><span>|</span><label class="collapse" for="c-42004330">[-]</label><label class="expand" for="c-42004330">[1 more]</label></div><br/><div class="children"><div class="content">The article that introduced them talks about mainstay and is certainly not trying to hide their impact<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;archive&#x2F;msdn-magazine&#x2F;2018&#x2F;january&#x2F;csharp-all-about-span-exploring-a-new-net-mainstay" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;archive&#x2F;msdn-magazine&#x2F;2018...</a></div><br/></div></div></div></div><div id="41968703" class="c"><input type="checkbox" id="c-41968703" checked=""/><div class="controls bullet"><span class="by">zigzag312</span><span>|</span><a href="#42004139">prev</a><span>|</span><a href="#42004077">next</a><span>|</span><label class="collapse" for="c-41968703">[-]</label><label class="expand" for="c-41968703">[14 more]</label></div><br/><div class="children"><div class="content">I always felt like these features are adding a new programming paradigm to C# that allows you to bypass GC in safe code.<p>I wish more people would talk about it. Thank you for such an interesting article!</div><br/><div id="42003368" class="c"><input type="checkbox" id="c-42003368" checked=""/><div class="controls bullet"><span class="by">algorithmsRcool</span><span>|</span><a href="#41968703">parent</a><span>|</span><a href="#41969450">next</a><span>|</span><label class="collapse" for="c-42003368">[-]</label><label class="expand" for="c-42003368">[4 more]</label></div><br/><div class="children"><div class="content">Span and ref-like types enable massive changes to the way that memory is managed in C#. You can absolutely write almost GC-less code. I have been tinkering with a toy no-GC database engine in C# based on Direct I&#x2F;O and some object pooling. I have been amazed at how far i can get before resorting to GC heap allocations</div><br/><div id="42004427" class="c"><input type="checkbox" id="c-42004427" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#41968703">root</a><span>|</span><a href="#42003368">parent</a><span>|</span><a href="#41969450">next</a><span>|</span><label class="collapse" for="c-42004427">[-]</label><label class="expand" for="c-42004427">[3 more]</label></div><br/><div class="children"><div class="content">Anything that uses classes and interfaces will be memory managed by the GC. So instead of using lists, dictionaries, IEnumerable, you will have to roll your own.<p>It would be better if the GC can be turned off with a switch and just add a delete operator to manually free memory.</div><br/><div id="42004513" class="c"><input type="checkbox" id="c-42004513" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41968703">root</a><span>|</span><a href="#42004427">parent</a><span>|</span><a href="#41969450">next</a><span>|</span><label class="collapse" for="c-42004513">[-]</label><label class="expand" for="c-42004513">[2 more]</label></div><br/><div class="children"><div class="content">Given that ref structs can now be generic arguments and cannot be boxed - you have more ways to enforce that no boxing occurs at compile-time. It is true that you have to roll your own collections, but even dispatching on interfaces by making them generic constraints (which is zero-cost) instead of boxing is a good start.<p>As for delete operator, &#x27;dispose&#x27; works well enough. I have a toy native vector that I use for all sorts of one-off tasks:<p><pre><code>  &#x2F;&#x2F; A is a shorthand for default allocator, a thin wrapper on top of malloc&#x2F;realloc&#x2F;free
  &#x2F;&#x2F; this allows for Zig-style allocator specialization
  using var nums = (NVec&lt;int, A&gt;)[1, 2, 3, 4];
  nums.Add(5);
  ...
  &#x2F;&#x2F; underlying pointer is freed at the end of the scope
</code></pre>
It is very easy to implement and I assume C and C++ developers would feel right at home, except with better UX.<p>This retains full compatibility with the standard library through interfaces and being convertible to Span&lt;T&gt;, which almost everything accepts nowadays.<p>System-provided allocators are slower at small allocations than GC, but Jemalloc easily fixes that.</div><br/><div id="42004738" class="c"><input type="checkbox" id="c-42004738" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#41968703">root</a><span>|</span><a href="#42004513">parent</a><span>|</span><a href="#41969450">next</a><span>|</span><label class="collapse" for="c-42004738">[-]</label><label class="expand" for="c-42004738">[1 more]</label></div><br/><div class="children"><div class="content">I really mean using existing stuff, without rolling your own:<p>List&lt;int&gt; nums = [1, 2, 3, 4];<p>&#x2F;&#x2F;do stuff with nums<p>Delete(nums);</div><br/></div></div></div></div></div></div></div></div><div id="41969450" class="c"><input type="checkbox" id="c-41969450" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41968703">parent</a><span>|</span><a href="#42003368">prev</a><span>|</span><a href="#42004077">next</a><span>|</span><label class="collapse" for="c-41969450">[-]</label><label class="expand" for="c-41969450">[9 more]</label></div><br/><div class="children"><div class="content">Many of these features exist since .NET 1.0, given its scope of languages to support, including C++.<p>So even those that weren&#x27;t initially exposed in unsafe mode, were available at the MSIL level and could be generated via helper methods making use of &quot;System.Reflection.Emit&quot;.<p>Naturally having them as C# language features is more ergonomic and safer than a misuse of MSIL opcodes.</div><br/><div id="42003943" class="c"><input type="checkbox" id="c-42003943" checked=""/><div class="controls bullet"><span class="by">MarkSweep</span><span>|</span><a href="#41968703">root</a><span>|</span><a href="#41969450">parent</a><span>|</span><a href="#41969811">next</a><span>|</span><label class="collapse" for="c-42003943">[-]</label><label class="expand" for="c-42003943">[1 more]</label></div><br/><div class="children"><div class="content">There is a runtime (not C#) feature that has been added that is relevant to the article: ref fields in structs. Before these, only certain runtime-blessed types like Span&lt;T&gt; could contain refs directly.<p>In case anyone is interested, here is the spec about refs in structs and other lifetime features mentioned in the article:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;csharplang&#x2F;blob&#x2F;main&#x2F;proposals&#x2F;csharp-11.0&#x2F;low-level-struct-improvements.md">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;csharplang&#x2F;blob&#x2F;main&#x2F;proposals&#x2F;csh...</a><p>And here is the big list of ways .NET differs from the publish ECMA spec. Some of these differences represent new runtime features.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtime&#x2F;blob&#x2F;main&#x2F;docs&#x2F;design&#x2F;specs&#x2F;Ecma-335-Augments.md">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtime&#x2F;blob&#x2F;main&#x2F;docs&#x2F;design&#x2F;spec...</a></div><br/></div></div><div id="41969811" class="c"><input type="checkbox" id="c-41969811" checked=""/><div class="controls bullet"><span class="by">zigzag312</span><span>|</span><a href="#41968703">root</a><span>|</span><a href="#41969450">parent</a><span>|</span><a href="#42003943">prev</a><span>|</span><a href="#42004077">next</a><span>|</span><label class="collapse" for="c-41969811">[-]</label><label class="expand" for="c-41969811">[7 more]</label></div><br/><div class="children"><div class="content">&quot;System.Reflection.Emit&quot; is not compatible with NativeAOT.<p>Using C&#x2F;C++&#x2F;Rust to do the same task is probably more productive than emitting MSIL opcodes, so that solution wasn&#x27;t really that practical.<p>But with these new features being more ergonomic and practical, it becomes cost effective to just do it in C# instead of introducing another language.</div><br/><div id="41970689" class="c"><input type="checkbox" id="c-41970689" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41968703">root</a><span>|</span><a href="#41969811">parent</a><span>|</span><a href="#41970168">prev</a><span>|</span><a href="#42004077">next</a><span>|</span><label class="collapse" for="c-41970689">[-]</label><label class="expand" for="c-41970689">[5 more]</label></div><br/><div class="children"><div class="content">Yeah, but nothing of that is the point being discussed, with Native AOT still not available in GUI workloads.<p>Also P&#x2F;Invoke and CCW&#x2F;RCW do have costs cross the runtime layer, even if minor when compared with other languages.</div><br/><div id="42003734" class="c"><input type="checkbox" id="c-42003734" checked=""/><div class="controls bullet"><span class="by">Rohansi</span><span>|</span><a href="#41968703">root</a><span>|</span><a href="#41970689">parent</a><span>|</span><a href="#41971880">next</a><span>|</span><label class="collapse" for="c-42003734">[-]</label><label class="expand" for="c-42003734">[2 more]</label></div><br/><div class="children"><div class="content">I believe you can avoid most of not all of the P&#x2F;invoke overhead these days by using unmanaged function pointers and not using the automatic marshalling.</div><br/><div id="42003872" class="c"><input type="checkbox" id="c-42003872" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41968703">root</a><span>|</span><a href="#42003734">parent</a><span>|</span><a href="#41971880">next</a><span>|</span><label class="collapse" for="c-42003872">[-]</label><label class="expand" for="c-42003872">[1 more]</label></div><br/><div class="children"><div class="content">Whenever you use [DllImport], the analyzer will nudge you to auto-fix it to [LibraryImport] which source-generates a marshalling stub (if any is needed) that then calls an inner [DllImport] that does not require runtime marshalling. This is very cheap since function address gets cached into a readonly static which then gets baked into the machine code once the JIT produces Tier-1 compilation for your method.<p>On NativeAOT, you can instead use &quot;DirectPInvoke&quot; which links against specified binary and relies on system loader just like C&#x2F;C++ code would. Then, you can also statically link and embed the dependency into your binary (if .lib&#x2F;.a is available) instead which will turn pinvokes into direct calls (marshalling if applicable and GC frame transition remain, on that read below).<p>Lastly, it is beneficial to annotate short-lived PInvoke calls with [SuppressGCTransition] which avoids some deoptimizations and GC frame transition calls around interop and makes the calls as cheap as direct calls in C + GC poll (a single usually not-taken branch). With this the cost of interop effectively evaporates which is one of the features that makes .NET as a <i>relatively</i> high-level runtime so good at systems programming.<p>Unmanaged function pointers have similar overhead, and identical if you apply [SuppressGCTransition] to them in the same way.<p>* LibraryImport is not needed if pinvoke signature only has primitives, structs that satisfy &#x27;unmanaged&#x27; constraint or raw pointers since no marshalling is required for these.</div><br/></div></div></div></div><div id="41971880" class="c"><input type="checkbox" id="c-41971880" checked=""/><div class="controls bullet"><span class="by">zigzag312</span><span>|</span><a href="#41968703">root</a><span>|</span><a href="#41970689">parent</a><span>|</span><a href="#42003734">prev</a><span>|</span><a href="#42004077">next</a><span>|</span><label class="collapse" for="c-41971880">[-]</label><label class="expand" for="c-41971880">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I follow. Where are GUI workloads being discussed in the article?<p>If anything, article doesn&#x27;t talk about MSIL or CLR, but C# language features. CLR is not the only target C# supports.<p>NativeAOT is supported in Avalonia (cross-platform UI framework), Razor Slices (dynamically render HTML from Minimal APIs) and I think there is also some support for AOT in MonoGame &amp; FNA (game dev frameworks).<p>However, it&#x27;s still early and a lot of the ecosystem doesn&#x27;t support NativeAOT.</div><br/><div id="41972129" class="c"><input type="checkbox" id="c-41972129" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41968703">root</a><span>|</span><a href="#41971880">parent</a><span>|</span><a href="#42004077">next</a><span>|</span><label class="collapse" for="c-41972129">[-]</label><label class="expand" for="c-41972129">[1 more]</label></div><br/><div class="children"><div class="content">No, neither was Native AOT.<p>Native AOT depends on CLR infrastructure.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42004077" class="c"><input type="checkbox" id="c-42004077" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41968703">prev</a><span>|</span><a href="#42004061">next</a><span>|</span><label class="collapse" for="c-42004077">[-]</label><label class="expand" for="c-42004077">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This restriction is central to Rust’s safety guarantees, but C# doesn’t need it. The reason is that Rust has to account for the possibility that a reference may be invalidated at any time.<p>Is this right? I thought Rust&#x27;s reason for XOR is deeper &amp; is how it also guarantees memory safety for multi-threaded code too (&amp; not just for reference lifetimes).</div><br/><div id="42004388" class="c"><input type="checkbox" id="c-42004388" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#42004077">parent</a><span>|</span><a href="#42004061">next</a><span>|</span><label class="collapse" for="c-42004388">[-]</label><label class="expand" for="c-42004388">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s how I understood it, too</div><br/></div></div></div></div><div id="42004061" class="c"><input type="checkbox" id="c-42004061" checked=""/><div class="controls bullet"><span class="by">DonaldPShimoda</span><span>|</span><a href="#42004077">prev</a><span>|</span><a href="#42004117">next</a><span>|</span><label class="collapse" for="c-42004061">[-]</label><label class="expand" for="c-42004061">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Instead of throwing an exception, we’ve decided that this function should always return something, even if it’s not in the haystack<p>The right move at this point would be to use an optional type, surely...</div><br/></div></div><div id="42004117" class="c"><input type="checkbox" id="c-42004117" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42004061">prev</a><span>|</span><a href="#41963851">next</a><span>|</span><label class="collapse" for="c-42004117">[-]</label><label class="expand" for="c-42004117">[2 more]</label></div><br/><div class="children"><div class="content">So what are the C# compiler lifetime error messages like? It if guesses about lifetimes, the messages have to be good.</div><br/><div id="42004430" class="c"><input type="checkbox" id="c-42004430" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#42004117">parent</a><span>|</span><a href="#41963851">next</a><span>|</span><label class="collapse" for="c-42004430">[-]</label><label class="expand" for="c-42004430">[1 more]</label></div><br/><div class="children"><div class="content">The article has some examples</div><br/></div></div></div></div><div id="41963851" class="c"><input type="checkbox" id="c-41963851" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42004117">prev</a><span>|</span><a href="#42003358">next</a><span>|</span><label class="collapse" for="c-41963851">[-]</label><label class="expand" for="c-41963851">[1 more]</label></div><br/><div class="children"><div class="content">What a great article, thank you for sharing it!</div><br/></div></div><div id="42003358" class="c"><input type="checkbox" id="c-42003358" checked=""/><div class="controls bullet"><span class="by">lowbloodsugar</span><span>|</span><a href="#41963851">prev</a><span>|</span><a href="#42003134">next</a><span>|</span><label class="collapse" for="c-42003358">[-]</label><label class="expand" for="c-42003358">[7 more]</label></div><br/><div class="children"><div class="content">&gt;This restriction is central to Rust’s safety guarantees, but C# doesn’t need it. The reason is that Rust has to account for the possibility that a reference may be invalidated at any time.<p>That’s not why though. There’s lots of reasons for Rusts safety model, such as allowing for vastly faster code because aliasing can’t happen unless both references are read only, in which case it doesn’t matter.  There is lot to Rusts borrow rules that this article misses.<p>It’s like the article earlier today that was, essentially, “I don’t understand Rust and it would be better if it was Haskell”.</div><br/><div id="42003958" class="c"><input type="checkbox" id="c-42003958" checked=""/><div class="controls bullet"><span class="by">physicsguy</span><span>|</span><a href="#42003358">parent</a><span>|</span><a href="#42003941">next</a><span>|</span><label class="collapse" for="c-42003958">[-]</label><label class="expand" for="c-42003958">[4 more]</label></div><br/><div class="children"><div class="content">&gt; aliasing can’t happen unless both references are read only<p>Other languages have long had aliasing, Fortran for one. C and C++ have the restrict keyword though obviously it&#x27;s a programmer guarantee there and is less safe, since if the user of the function does pass the same memory ref offset for e.g. the optimisation is not safe.</div><br/><div id="42004072" class="c"><input type="checkbox" id="c-42004072" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42003358">root</a><span>|</span><a href="#42003958">parent</a><span>|</span><a href="#42004071">next</a><span>|</span><label class="collapse" for="c-42004072">[-]</label><label class="expand" for="c-42004072">[1 more]</label></div><br/><div class="children"><div class="content">&gt; C and C++ have the restrict keyword<p>I&#x27;d say in name only given that there were numerous aliasing bugs in llvm that only became visible when Rust tried to leverage it. I suspect similar pitfalls exist in every single C&#x2F;C++ compiler because the rules for restrict are not only difficult to understand for use but also difficult to implement correctly.</div><br/></div></div><div id="42004071" class="c"><input type="checkbox" id="c-42004071" checked=""/><div class="controls bullet"><span class="by">orangeboats</span><span>|</span><a href="#42003358">root</a><span>|</span><a href="#42003958">parent</a><span>|</span><a href="#42004072">prev</a><span>|</span><a href="#42003941">next</a><span>|</span><label class="collapse" for="c-42004071">[-]</label><label class="expand" for="c-42004071">[2 more]</label></div><br/><div class="children"><div class="content">The restrict keyword is very seldomly used in C programs. You could probably remove it and still be able to compile the majority of C programs.<p>(Otherwise, the Rust project wouldn&#x27;t have encountered all the bugs related to aliasing analysis in LLVM.)</div><br/><div id="42004075" class="c"><input type="checkbox" id="c-42004075" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42003358">root</a><span>|</span><a href="#42004071">parent</a><span>|</span><a href="#42003941">next</a><span>|</span><label class="collapse" for="c-42004075">[-]</label><label class="expand" for="c-42004075">[1 more]</label></div><br/><div class="children"><div class="content">The ISO C standard uses the restrict qualifier on some standard library function declarations in such a way that it does nothing.</div><br/></div></div></div></div></div></div><div id="42003941" class="c"><input type="checkbox" id="c-42003941" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#42003358">parent</a><span>|</span><a href="#42003958">prev</a><span>|</span><a href="#42003134">next</a><span>|</span><label class="collapse" for="c-42003941">[-]</label><label class="expand" for="c-42003941">[2 more]</label></div><br/><div class="children"><div class="content">Is there some benchmarking work that has quantified this speedup from aliasing guarantees or is this more of a sufficiently smart compiler[1] thing?<p>[1] <a href="https:&#x2F;&#x2F;kidneybone.com&#x2F;c2&#x2F;wiki&#x2F;SufficientlySmartCompiler" rel="nofollow">https:&#x2F;&#x2F;kidneybone.com&#x2F;c2&#x2F;wiki&#x2F;SufficientlySmartCompiler</a></div><br/><div id="42004017" class="c"><input type="checkbox" id="c-42004017" checked=""/><div class="controls bullet"><span class="by">DonaldPShimoda</span><span>|</span><a href="#42003358">root</a><span>|</span><a href="#42003941">parent</a><span>|</span><a href="#42003134">next</a><span>|</span><label class="collapse" for="c-42004017">[-]</label><label class="expand" for="c-42004017">[1 more]</label></div><br/><div class="children"><div class="content">The Sufficiently Smart Compiler is a hypothetical argument used in advocating for a programming language whose naive implementations might tend towards inefficient designs, whereas the aliasing argument is not itself hypothetical but it may not be backed by data. That&#x27;s a different thing altogether.<p>Whether the aliasing argument holds water does not affect whether it was used as justification for Rust&#x27;s design.</div><br/></div></div></div></div></div></div><div id="42003134" class="c"><input type="checkbox" id="c-42003134" checked=""/><div class="controls bullet"><span class="by">stonethrowaway</span><span>|</span><a href="#42003358">prev</a><span>|</span><a href="#41963395">next</a><span>|</span><label class="collapse" for="c-42003134">[-]</label><label class="expand" for="c-42003134">[1 more]</label></div><br/><div class="children"><div class="content">C# is Pragmatic [0].<p>[0] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41761346">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41761346</a></div><br/></div></div><div id="41963395" class="c"><input type="checkbox" id="c-41963395" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#42003134">prev</a><span>|</span><label class="collapse" for="c-41963395">[-]</label><label class="expand" for="c-41963395">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Maybe I’m bad at searching for these things, but these changes to C# seem to have gone completely under the radar in places where you read about memory safety and performance. Maybe it’s just because the language additions have happened super slowly, or maybe the C# and Rust communities have so little overlap that there aren’t enough people who program in both languages to notice the similarities.<p>If you are looking at this through the lens of HN, I think much of this can be attributed to a certain ideological cargo cult that actively seeks to banish any positive sentiment around effective tools. You see this <i>exact</i> same thing with SQL providers, web frameworks, etc. If the tool is useful but doesn&#x27;t have some ultra-progressive ecosystem around it (i.e., costs money or was invented before the average HN user&#x27;s DOB), you can make a winning bet that talking about it will result in negative karma outcomes.<p>Everyone working in enterprise software development has known about the power of this language for well over a decade. But, you won&#x27;t find <i>a single</i> YC startup that would admit to using it.</div><br/><div id="42004720" class="c"><input type="checkbox" id="c-42004720" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#41963395">parent</a><span>|</span><a href="#42003712">next</a><span>|</span><label class="collapse" for="c-42004720">[-]</label><label class="expand" for="c-42004720">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Everyone working in enterprise software development has known about the power of this language for well over a decade. But, you won&#x27;t find a single YC startup that would admit to using it.<p>Not sure about that. Maybe there are? If you do web or mobile apps, C# would be an excellent choice. Go would be also an excellent choice for web.<p>For AI I wouldn&#x27;t use C#. Even though it has excellent ML libraries, most research and popular stuff is done using Python and pytorch, so that&#x27;s what I would chose.<p>For very low level, I&#x27;d take C or Zig. But I don&#x27;t know many startups who are into very low level stuff.</div><br/></div></div><div id="42003712" class="c"><input type="checkbox" id="c-42003712" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#41963395">parent</a><span>|</span><a href="#42004720">prev</a><span>|</span><a href="#42004102">next</a><span>|</span><label class="collapse" for="c-42003712">[-]</label><label class="expand" for="c-42003712">[1 more]</label></div><br/><div class="children"><div class="content">Well, common lisp and some schemes and prolog tend to get a good deal of praise here, even if their commercial utilization is lower. OCaml, F# and Clojure tend to get a good deal of favorable comments as well.<p>I suspect it is less about cargo culting, and more about two separate things:<p>First, the tooling for C# and really anything dotnet has been awful on any OS other than Windows until fairly recently. Windows is (to be blunt) a very unpopular OS in every development community that isn&#x27;t dotnet.<p>Second, anthing enterprise is worth taking with a skeptical grain of salt; &quot;enterprise&quot; typically gets chosen for commercial support contracts, vendor lock-in, or astronaut architects over-engineering everything to fit best practices from 20 years ago. Saying big businesses run on it is a virtue is akin to saying that Oracle software is amazing or that WordPress engineering is amazing because so many websites run on it. Popularity and quality are entirely orthogonal.<p>I suppose there is probably another reason, which is the cluster fuck that has been the naming and churn of dot net versions for several years. ASP.NET, then core, then the core suffix got dropped at version 5, even though not everything was cross platform... So much pointless confusion.</div><br/></div></div><div id="42004102" class="c"><input type="checkbox" id="c-42004102" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#41963395">parent</a><span>|</span><a href="#42003712">prev</a><span>|</span><a href="#42004544">next</a><span>|</span><label class="collapse" for="c-42004102">[-]</label><label class="expand" for="c-42004102">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Everyone working in enterprise software development has known about the power of this language for well over a decade.<p>I think it depends on location. In my part of the world .Net is something which lives in middle sized often stagnating companies. Enterprise around here is married to the JVM and they even tend to use more Typescript on the backend than C#. I’m not going to defend the merits of that in any way, that is just the way of things.<p>There being said I do get the impression that HN does know that Rust isn’t seeing much adoption as a general purpose language. So I wouldn’t count C# out here considering how excellent it has become since the transition into Core as the main .Net. I say this a an absolute C# hater by the way, I spent a decade with it and I never want to work with it again. (After decades of SWE I have fun with Python, C&#x2F;Zig, JS&#x2F;TS, and, no other language.)</div><br/></div></div><div id="42004544" class="c"><input type="checkbox" id="c-42004544" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#41963395">parent</a><span>|</span><a href="#42004102">prev</a><span>|</span><a href="#42004517">next</a><span>|</span><label class="collapse" for="c-42004544">[-]</label><label class="expand" for="c-42004544">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get why you are downvoted. It&#x27;s true that some languages, frameworks, operating systems are more popular on HN that others. Reasons for this might be complex and we might enter into very hard and complicated sociological arguments if we try to discuss them.<p>&gt;Everyone working in enterprise software development has known about the power of this language for well over a decade.<p>What is an enterprise? Is Google not an enterprise? Is Apple not an enterprise? Is Facebook not an enterprise? What about Netflix, Uber and any other big tech company? Weren&#x27;t all enterprises start-ups at the beginning?<p>Does enterprise mean boring old company established long before the invention of Internet, which does old boring stuff, employs old boring people and use old boring languages? I imagine a grandpa with a long white beard staring at some CRTs with Cobol code and SAP Hana.</div><br/></div></div><div id="42004517" class="c"><input type="checkbox" id="c-42004517" checked=""/><div class="controls bullet"><span class="by">WD-42</span><span>|</span><a href="#41963395">parent</a><span>|</span><a href="#42004544">prev</a><span>|</span><a href="#41963591">next</a><span>|</span><label class="collapse" for="c-42004517">[-]</label><label class="expand" for="c-42004517">[1 more]</label></div><br/><div class="children"><div class="content">I think it has more to do with c# being a Windows only programming language for the majority of its life. And guess what, a lot of people don’t like Windows.<p>And don’t bring up mono, etc. it was a dumpster fire then and it’s only recently gotten better. It tough for any tech to shed a very long negative legacy.</div><br/></div></div><div id="42004580" class="c"><input type="checkbox" id="c-42004580" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#41963395">parent</a><span>|</span><a href="#41963591">prev</a><span>|</span><label class="collapse" for="c-42004580">[-]</label><label class="expand" for="c-42004580">[2 more]</label></div><br/><div class="children"><div class="content">&gt; ...actively seeks to banish any positive sentiment around effective tools<p>Effective at what?<p>Want GC lang with lots of libraries? Use Java.<p>Want GC free lang with safety? Use Rust.<p>Otherwise just use C. Or C++.<p>For me C# lies in this awkward spot. Because of past decisions it will never have quite the ecosystem of Java. And because GC -free and GC libraries mix as well as water and oil, you get somewhat of a library ecosystem bifurcation. Granted GC-less libraries are almost non-existent.</div><br/><div id="42004684" class="c"><input type="checkbox" id="c-42004684" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#41963395">root</a><span>|</span><a href="#42004580">parent</a><span>|</span><label class="collapse" for="c-42004684">[-]</label><label class="expand" for="c-42004684">[1 more]</label></div><br/><div class="children"><div class="content">I worked in both C# and Java. And other languages. Resuming C# and Java to &quot;GC languages with lots of libraries&quot; doesn&#x27;t accurately depict neither C#, nor Java.<p>Since we discuss C# here, it is a good jack of all trades language where you can do almost anything, with decent performance, low boilerplate. It&#x27;s easy to read, easy to learn and you have libraries for everything you need, excellent documentation and plenty of tutorials and examples. A great thing is that for every task and domain there is a good library or framework that most developers use, so you don&#x27;t have to ask yourself what to use and how and you find a lot of documentation, tutorials and help for everything.<p>Java it&#x27;s a bit more boiler plate-y, had a bit less features and ease of use and had many libraries and frameworks that did the same thing. Had Java been better, Kotlin wouldn&#x27;t need to be invented.<p>&gt;Want GC lang with lots of libraries? Use Java.
Want a fast to develop and easy to use language? Just use C#.<p>&gt;Want GC free lang with safety? Use Rust.
Want a language which you can use for almost eveything? Web front-end, web backend, services, microcontrollers, games, desktop and mobile? Use C#.<p>&gt;Otherwise just use C. Or C++.
Or whatever works for you. Whatever you like, find fun and makes you a productive and happy developer. There is nothing wrong in using C or C++. Or Python. Or Haskell.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>