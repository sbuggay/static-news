<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715245271374" as="style"/><link rel="stylesheet" href="styles.css?v=1715245271374"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://faultlore.com/blah/abi-puns/">Pair Your Compilers at the ABI Café</a> <span class="domain">(<a href="https://faultlore.com">faultlore.com</a>)</span></div><div class="subtext"><span>nrabulinski</span> | <span>31 comments</span></div><br/><div><div id="40300260" class="c"><input type="checkbox" id="c-40300260" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#40302195">next</a><span>|</span><label class="collapse" for="c-40300260">[-]</label><label class="expand" for="c-40300260">[7 more]</label></div><br/><div class="children"><div class="content">I can definitely feel the pain of trying to work out ABI mismatch concerns. It doesn&#x27;t help that it often isn&#x27;t clear from the output what some of the underlying assumptions are--expected stack alignment, for example, or structs being broken up into registers or not.<p>It would be nice if compilers could output some sort of metadata that basically says &quot;ah yes, here&#x27;s a struct, it requires this alignment, fields are at these offsets and have these sizes, and are present in these cases&quot; (the latter option being able to support discriminated unions) or &quot;function call, parameters are here, here, and here.&quot; You&#x27;d think this is what DWARF itself provides, but if you play around with DWARF for a bit, you discover that it actually lacks a lot of the low-level ABI details you want to uncover; instead, it&#x27;s more of a format that&#x27;s meant to be generic enough to convey to the debugger the AST of the source program along with some hint of how to map the binary code to that AST--you can&#x27;t really write a language-agnostic DWARF-based debugger.</div><br/><div id="40301049" class="c"><input type="checkbox" id="c-40301049" checked=""/><div class="controls bullet"><span class="by">orivej</span><span>|</span><a href="#40300260">parent</a><span>|</span><a href="#40300646">next</a><span>|</span><label class="collapse" for="c-40301049">[-]</label><label class="expand" for="c-40301049">[2 more]</label></div><br/><div class="children"><div class="content">Some Common Lisp FFIs have opted to coax this information out of the compiler. <a href="https:&#x2F;&#x2F;github.com&#x2F;rpav&#x2F;c2ffi">https:&#x2F;&#x2F;github.com&#x2F;rpav&#x2F;c2ffi</a> is a C++ tool that links to libclang-cpp and literally outputs JSON with sizes and alignments. (It is then used by <a href="https:&#x2F;&#x2F;github.com&#x2F;rpav&#x2F;cl-autowrap">https:&#x2F;&#x2F;github.com&#x2F;rpav&#x2F;cl-autowrap</a> to autogenerate a Lisp wrapper.) The older CFFI Groveller [1] works by generating C code which is compiled by the system C compiler (e.g. GCC or Clang) and, when executed, prints Lisp code that contains resolved values of constants, sizes, alignments, etc.<p>[1] <a href="https:&#x2F;&#x2F;cffi.common-lisp.dev&#x2F;manual&#x2F;html_node&#x2F;The-Groveller.html#The-Groveller" rel="nofollow">https:&#x2F;&#x2F;cffi.common-lisp.dev&#x2F;manual&#x2F;html_node&#x2F;The-Groveller....</a></div><br/><div id="40303706" class="c"><input type="checkbox" id="c-40303706" checked=""/><div class="controls bullet"><span class="by">ngcc_hk</span><span>|</span><a href="#40300260">root</a><span>|</span><a href="#40301049">parent</a><span>|</span><a href="#40300646">next</a><span>|</span><label class="collapse" for="c-40303706">[-]</label><label class="expand" for="c-40303706">[1 more]</label></div><br/><div class="children"><div class="content">Very lisp.  Basically reprogram itself.  Unfortunately this is not applicable to maintained code like c, rust … etc?</div><br/></div></div></div></div><div id="40300646" class="c"><input type="checkbox" id="c-40300646" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#40300260">parent</a><span>|</span><a href="#40301049">prev</a><span>|</span><a href="#40302195">next</a><span>|</span><label class="collapse" for="c-40300646">[-]</label><label class="expand" for="c-40300646">[4 more]</label></div><br/><div class="children"><div class="content">What you are asking for sounds quite a bit like what rustc does.<p>Rustc (outside `extern &quot;c&quot;`) offers no guarantees on the ordering of the fields, however, it guarantees that every instance of struct A will have the same ordering during that particular compilation. This allows rustc to compile external crates (as long as no monomorphization is needed) in a consistent manner across all crates that depend on that.</div><br/><div id="40300877" class="c"><input type="checkbox" id="c-40300877" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#40300260">root</a><span>|</span><a href="#40300646">parent</a><span>|</span><a href="#40302195">next</a><span>|</span><label class="collapse" for="c-40300877">[-]</label><label class="expand" for="c-40300877">[3 more]</label></div><br/><div class="children"><div class="content">Most of the ABI issues arise when you start to mix and match shared libaries produced by different compilers, or even the libraries produced by the different versions of the same compiler.<p>Rust has none of that, nor does support dynamic linking, so I fail to understand what is it that rustc can offer in that solution space. There is none.</div><br/><div id="40301074" class="c"><input type="checkbox" id="c-40301074" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#40300260">root</a><span>|</span><a href="#40300877">parent</a><span>|</span><a href="#40302195">next</a><span>|</span><label class="collapse" for="c-40301074">[-]</label><label class="expand" for="c-40301074">[2 more]</label></div><br/><div class="children"><div class="content">Rust works around the issue by not allowing all the useful things that get you there.  There are other useful things like sharing pointers across threads that rust will not let you do - for both better and worse. (better in that you avoid a lot of problems for something you rarely need - worse for those few cases where you actually need to do those and cannot)</div><br/><div id="40301470" class="c"><input type="checkbox" id="c-40301470" checked=""/><div class="controls bullet"><span class="by">Georgelemental</span><span>|</span><a href="#40300260">root</a><span>|</span><a href="#40301074">parent</a><span>|</span><a href="#40302195">next</a><span>|</span><label class="collapse" for="c-40301470">[-]</label><label class="expand" for="c-40301470">[1 more]</label></div><br/><div class="children"><div class="content">You can share pointers across threads in Rust, it&#x27;s just `unsafe`.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40302195" class="c"><input type="checkbox" id="c-40302195" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#40300260">prev</a><span>|</span><a href="#40299852">next</a><span>|</span><label class="collapse" for="c-40302195">[-]</label><label class="expand" for="c-40302195">[17 more]</label></div><br/><div class="children"><div class="content">I think the right way to avoid this problem is to avoid using ABI at runtime or build time.<p>At runtime, it means - don&#x27;t use shared libraries.
At build time, it means - build every library from the source, don&#x27;t use pre-built artifacts.<p>This sounds controversial... But it allows you to change compiler or compiler options at any time, and you don&#x27;t have to bother. It also enables cross-compilation, reproducible builds, and portable binaries. You no longer have to ask developers to set up a complex build environment on a specific Linux distribution because it works everywhere.<p>I use this approach for ClickHouse.</div><br/><div id="40303189" class="c"><input type="checkbox" id="c-40303189" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#40302195">parent</a><span>|</span><a href="#40302335">next</a><span>|</span><label class="collapse" for="c-40303189">[-]</label><label class="expand" for="c-40303189">[3 more]</label></div><br/><div class="children"><div class="content">This can work only if you own the entire codebase and have all external dependencies that you depend on statically link (compiled) within your product.<p>I also very much prefer this way of handling dependencies but it&#x27;s not a solution for all ABI problems since it also implies that you will need to statically link (compile) against all the transient dependencies. These are including at very minimum libc++ or libstdc++. And with this requirement in place this already isn&#x27;t possible for many of the codebases out there.<p>And it also brings another issue at the table: X version of libc++&#x2F;libstdc++ depends on Y version of libc.<p>Since you generally cannot statically link against the libc, and you don&#x27;t own it since it&#x27;s part of the OS, this becomes a hairy problem. You really need to make sure that your code works across different versions and thereof combinations of libc++&#x2F;libstdc++&#x2F;libc.<p>And then there&#x27;s ... a bunch of other different platforms which aren&#x27;t Linux.</div><br/><div id="40305079" class="c"><input type="checkbox" id="c-40305079" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#40302195">root</a><span>|</span><a href="#40303189">parent</a><span>|</span><a href="#40302335">next</a><span>|</span><label class="collapse" for="c-40305079">[-]</label><label class="expand" for="c-40305079">[2 more]</label></div><br/><div class="children"><div class="content">Glibc is obstructive to static linking but musl is not. That gives you a binary that relies on the Linux syscall interface and nothing else. I believe bsd&#x27;s libc statically links without problems as well.<p>Libc++ is set up for static linking out of the box (if you manage to find or guess the many cmake flags).<p>OSX and Windows insist on libc iirc but they&#x27;re closed systems anyway so controlling your dependency graph is unavailable.</div><br/><div id="40306403" class="c"><input type="checkbox" id="c-40306403" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#40302195">root</a><span>|</span><a href="#40305079">parent</a><span>|</span><a href="#40302335">next</a><span>|</span><label class="collapse" for="c-40306403">[-]</label><label class="expand" for="c-40306403">[1 more]</label></div><br/><div class="children"><div class="content">The problem with musl is its malloc implementation. It is subpar when compared to glibc malloc. And we know that glibc malloc is generally subpar when compared to jemalloc. For large-scale applications with many (concurrent) (small) allocations this will be a big performance problem.<p>I guess (?) it would be possible to fix this by replacing the musl inline malloc implementation by statically linking against the jemalloc.</div><br/></div></div></div></div></div></div><div id="40302335" class="c"><input type="checkbox" id="c-40302335" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#40302195">parent</a><span>|</span><a href="#40303189">prev</a><span>|</span><a href="#40302524">next</a><span>|</span><label class="collapse" for="c-40302335">[-]</label><label class="expand" for="c-40302335">[5 more]</label></div><br/><div class="children"><div class="content">Even then, you still need ABI consistency between compilers if you want to link together codebases written in different languages (e.g. C and Rust).<p>In practice this almost always &#x27;just works&#x27; because most cross-language calls simply don&#x27;t use the kinds of complicated types discussed in the blog post.  They tend to stick to simple integer and pointer types, where ABI consistency is usually a given.<p>Though you can still get into trouble when passing function pointers, especially when combined with some modern control-flow integrity systems.</div><br/><div id="40302368" class="c"><input type="checkbox" id="c-40302368" checked=""/><div class="controls bullet"><span class="by">tester756</span><span>|</span><a href="#40302195">root</a><span>|</span><a href="#40302335">parent</a><span>|</span><a href="#40302524">next</a><span>|</span><label class="collapse" for="c-40302368">[-]</label><label class="expand" for="c-40302368">[4 more]</label></div><br/><div class="children"><div class="content">&gt;Even then, you still need ABI consistency between compilers if you want to link together codebases written in different languages (e.g. C and Rust).<p>Let&#x27;s talk over http, queue or other IPC-ish way</div><br/><div id="40302882" class="c"><input type="checkbox" id="c-40302882" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#40302195">root</a><span>|</span><a href="#40302368">parent</a><span>|</span><a href="#40302459">next</a><span>|</span><label class="collapse" for="c-40302882">[-]</label><label class="expand" for="c-40302882">[2 more]</label></div><br/><div class="children"><div class="content">You _still_ need a consistent way to talk about values; IPC systems tackle the same problems under the name marshalling &amp; de&#x2F;serialisation. They just tend to take much more conservative options to deal with exactly this kind of problem (you don&#x27;t have to care about integer endian-ness if integers are expressed as strings).</div><br/></div></div><div id="40302459" class="c"><input type="checkbox" id="c-40302459" checked=""/><div class="controls bullet"><span class="by">0xdeafbeef</span><span>|</span><a href="#40302195">root</a><span>|</span><a href="#40302368">parent</a><span>|</span><a href="#40302882">prev</a><span>|</span><a href="#40302524">next</a><span>|</span><label class="collapse" for="c-40302459">[-]</label><label class="expand" for="c-40302459">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t pass values in registers using this model</div><br/></div></div></div></div></div></div><div id="40302524" class="c"><input type="checkbox" id="c-40302524" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#40302195">parent</a><span>|</span><a href="#40302335">prev</a><span>|</span><a href="#40304082">next</a><span>|</span><label class="collapse" for="c-40302524">[-]</label><label class="expand" for="c-40302524">[7 more]</label></div><br/><div class="children"><div class="content">Okay, how do you propose to talk to your kernel then?</div><br/><div id="40305040" class="c"><input type="checkbox" id="c-40305040" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40302195">root</a><span>|</span><a href="#40302524">parent</a><span>|</span><a href="#40302580">next</a><span>|</span><label class="collapse" for="c-40305040">[-]</label><label class="expand" for="c-40305040">[1 more]</label></div><br/><div class="children"><div class="content">Who wants a kernel? Distribute a bootable unikernel image that can be talked to via gRPC or something.<p>Obviously there are plenty of things you can&#x27;t build that way (e.g. drivers), but for a server application that&#x27;s intended to be accessed over the network anyway, like Clickhouse, I&#x27;m increasingly thinking that&#x27;s the way to go.</div><br/></div></div><div id="40302580" class="c"><input type="checkbox" id="c-40302580" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#40302195">root</a><span>|</span><a href="#40302524">parent</a><span>|</span><a href="#40305040">prev</a><span>|</span><a href="#40302588">next</a><span>|</span><label class="collapse" for="c-40302580">[-]</label><label class="expand" for="c-40302580">[2 more]</label></div><br/><div class="children"><div class="content">Over an spsc queue (unfortunately you cannot mmap this way yet, and you cannot set up the spsc queue itself this way)</div><br/><div id="40302791" class="c"><input type="checkbox" id="c-40302791" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40302195">root</a><span>|</span><a href="#40302580">parent</a><span>|</span><a href="#40302588">next</a><span>|</span><label class="collapse" for="c-40302791">[-]</label><label class="expand" for="c-40302791">[1 more]</label></div><br/><div class="children"><div class="content">Io_uring?</div><br/></div></div></div></div><div id="40302588" class="c"><input type="checkbox" id="c-40302588" checked=""/><div class="controls bullet"><span class="by">eddd-ddde</span><span>|</span><a href="#40302195">root</a><span>|</span><a href="#40302524">parent</a><span>|</span><a href="#40302580">prev</a><span>|</span><a href="#40304082">next</a><span>|</span><label class="collapse" for="c-40302588">[-]</label><label class="expand" for="c-40302588">[3 more]</label></div><br/><div class="children"><div class="content">Your kernel will likely have well defined interfaces. You don&#x27;t need libraries to talk to the kernel.</div><br/><div id="40302761" class="c"><input type="checkbox" id="c-40302761" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#40302195">root</a><span>|</span><a href="#40302588">parent</a><span>|</span><a href="#40302788">next</a><span>|</span><label class="collapse" for="c-40302761">[-]</label><label class="expand" for="c-40302761">[1 more]</label></div><br/><div class="children"><div class="content">But how can you use those interfaces without an ABI?<p>Fundamentally, an ABI <i>is</i> the way you define interfaces.</div><br/></div></div><div id="40302788" class="c"><input type="checkbox" id="c-40302788" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40302195">root</a><span>|</span><a href="#40302588">parent</a><span>|</span><a href="#40302761">prev</a><span>|</span><a href="#40304082">next</a><span>|</span><label class="collapse" for="c-40302788">[-]</label><label class="expand" for="c-40302788">[1 more]</label></div><br/><div class="children"><div class="content">Except for Linux, those well-defined interfaces sit behind a C API.</div><br/></div></div></div></div></div></div><div id="40304082" class="c"><input type="checkbox" id="c-40304082" checked=""/><div class="controls bullet"><span class="by">gigel82</span><span>|</span><a href="#40302195">parent</a><span>|</span><a href="#40302524">prev</a><span>|</span><a href="#40299852">next</a><span>|</span><label class="collapse" for="c-40304082">[-]</label><label class="expand" for="c-40304082">[1 more]</label></div><br/><div class="children"><div class="content">Tell me you never worked in a big codebase without telling me you never worked in a big codebase.</div><br/></div></div></div></div><div id="40299852" class="c"><input type="checkbox" id="c-40299852" checked=""/><div class="controls bullet"><span class="by">not2b</span><span>|</span><a href="#40302195">prev</a><span>|</span><a href="#40300579">next</a><span>|</span><label class="collapse" for="c-40299852">[-]</label><label class="expand" for="c-40299852">[3 more]</label></div><br/><div class="children"><div class="content">There is a specified common C++ ABI that gcc, clang, Intel&#x27;s proprietary compiler, and others use. It was originally developed for the Itanium processor but is now used by gcc and clang for everything. See<p><a href="https:&#x2F;&#x2F;itanium-cxx-abi.github.io&#x2F;cxx-abi&#x2F;abi.html" rel="nofollow">https:&#x2F;&#x2F;itanium-cxx-abi.github.io&#x2F;cxx-abi&#x2F;abi.html</a><p>Unfortunately this ABI didn&#x27;t specify how __int128 (and other nonstandard types) are to be passed.</div><br/><div id="40300002" class="c"><input type="checkbox" id="c-40300002" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#40299852">parent</a><span>|</span><a href="#40301518">next</a><span>|</span><label class="collapse" for="c-40300002">[-]</label><label class="expand" for="c-40300002">[1 more]</label></div><br/><div class="children"><div class="content">The Itanium ABI effectively specifies how to lower the C++ ABI to an assumed C ABI, and the C ABI is given by what is known as the &quot;psABI&quot; (processor-specific ABI).<p>The (not-most-recent) x86-64 ABI is here: <a href="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wiki&#x2F;hjl-tools&#x2F;x86-psABI&#x2F;x86-64-psABI-1.0.pdf" rel="nofollow">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wiki&#x2F;hjl-tools&#x2F;x86-psABI&#x2F;x...</a>, and it does actually explain how to pass __int128.</div><br/></div></div><div id="40301518" class="c"><input type="checkbox" id="c-40301518" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#40299852">parent</a><span>|</span><a href="#40300002">prev</a><span>|</span><a href="#40300579">next</a><span>|</span><label class="collapse" for="c-40301518">[-]</label><label class="expand" for="c-40301518">[1 more]</label></div><br/><div class="children"><div class="content">WebAssembly also has a de-facto standard ABI:
<a href="https:&#x2F;&#x2F;github.com&#x2F;WebAssembly&#x2F;tool-conventions&#x2F;blob&#x2F;main&#x2F;BasicCABI.md#function-signatures">https:&#x2F;&#x2F;github.com&#x2F;WebAssembly&#x2F;tool-conventions&#x2F;blob&#x2F;main&#x2F;Ba...</a></div><br/></div></div></div></div><div id="40300579" class="c"><input type="checkbox" id="c-40300579" checked=""/><div class="controls bullet"><span class="by">w10-1</span><span>|</span><a href="#40299852">prev</a><span>|</span><a href="#40299129">next</a><span>|</span><label class="collapse" for="c-40300579">[-]</label><label class="expand" for="c-40300579">[1 more]</label></div><br/><div class="children"><div class="content">Also function pointers, errors &amp; exception-handling, async&#x2F;channels&#x2F;thread-local&#x27;s, go stacks, swift @objc, @cdecl and cpp inter-op, FFI dialects...<p>It&#x27;s not really pain anymore; it&#x27;s a kind of hilarity</div><br/></div></div><div id="40299129" class="c"><input type="checkbox" id="c-40299129" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#40300579">prev</a><span>|</span><a href="#40302662">next</a><span>|</span><label class="collapse" for="c-40299129">[-]</label><label class="expand" for="c-40299129">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s Interop for compilers!</div><br/></div></div><div id="40302662" class="c"><input type="checkbox" id="c-40302662" checked=""/><div class="controls bullet"><span class="by">gigel82</span><span>|</span><a href="#40299129">prev</a><span>|</span><label class="collapse" for="c-40302662">[-]</label><label class="expand" for="c-40302662">[1 more]</label></div><br/><div class="children"><div class="content">I struggled with this many times and at the end of the day threw down the towel and just wrapped everything in plain C exports. That&#x27;s the only way I know to get ABI compatibility across different compilers&#x2F;toolsets&#x2F;versions. COM-like constructs come as a close second.<p>It&#x27;s an unfortunate state.</div><br/></div></div></div></div></div></div></div></body></html>