<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713862859130" as="style"/><link rel="stylesheet" href="styles.css?v=1713862859130"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://surfingcomplexity.blog/2024/03/26/the-problem-with-invariants-is-that-they-change-over-time/">The problem with invariants is that they change over time</a> <span class="domain">(<a href="https://surfingcomplexity.blog">surfingcomplexity.blog</a>)</span></div><div class="subtext"><span>kiyanwang</span> | <span>32 comments</span></div><br/><div><div id="40129284" class="c"><input type="checkbox" id="c-40129284" checked=""/><div class="controls bullet"><span class="by">BlackFly</span><span>|</span><a href="#40128400">next</a><span>|</span><label class="collapse" for="c-40129284">[-]</label><label class="expand" for="c-40129284">[4 more]</label></div><br/><div class="children"><div class="content">I would recommend not calling such things invariants and not thinking about them in the same way you think about invariants. If you would allow a comparison to physics then you would call such things assumptions: frictionless pulleys, small angle deflections, much slower than light speed, less than nuclear density. The physical theory developed is then correct while the assumptions hold. If you are making such an assumption and your language supports it, add a debug assertion if possible.<p>For me, invariants are constructs of the design of an algorithm. A list doesn&#x27;t change while iterating over it-by construction, not because someone else owns the reference and promises not to change it concurrently. This structure can only be instantiated via this function which ensures that that string field can always contains only numeric digits. Those are invariants, thing you enforce by design so you can rely on that later. Assumptions instead are things you do not enforce but rely on anyways.<p>Back to physics, an invariant would generally be something like conservation of energy or the speed of light being universal. Both of these things are only invariant in certain physical theories which enforce them by construction.</div><br/><div id="40129389" class="c"><input type="checkbox" id="c-40129389" checked=""/><div class="controls bullet"><span class="by">DougBTX</span><span>|</span><a href="#40129284">parent</a><span>|</span><a href="#40129526">next</a><span>|</span><label class="collapse" for="c-40129389">[-]</label><label class="expand" for="c-40129389">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, we shouldn’t use “invariant” as a shorthand for “not expected to change”.<p>We can still talk about “implicit assumptions” and “explicit assumptions”, so the article still works after that replacement. The headline isn’t as punchy though.</div><br/></div></div><div id="40129526" class="c"><input type="checkbox" id="c-40129526" checked=""/><div class="controls bullet"><span class="by">n4r9</span><span>|</span><a href="#40129284">parent</a><span>|</span><a href="#40129389">prev</a><span>|</span><a href="#40129435">next</a><span>|</span><label class="collapse" for="c-40129526">[-]</label><label class="expand" for="c-40129526">[1 more]</label></div><br/><div class="children"><div class="content">Precisely. If you asked a developer at the time whether the &quot;assumption that any loaned memory would fit into one region&quot; was static, I&#x27;m guessing they&#x27;d say &quot;no, it&#x27;s just what we&#x27;ve assumed for now. I&#x27;m hoping that no one changes that without it being discussed properly.&quot;</div><br/></div></div><div id="40129435" class="c"><input type="checkbox" id="c-40129435" checked=""/><div class="controls bullet"><span class="by">richrichie</span><span>|</span><a href="#40129284">parent</a><span>|</span><a href="#40129526">prev</a><span>|</span><a href="#40128400">next</a><span>|</span><label class="collapse" for="c-40129435">[-]</label><label class="expand" for="c-40129435">[1 more]</label></div><br/><div class="children"><div class="content">Well stated. Physics analogy is spot on.</div><br/></div></div></div></div><div id="40128400" class="c"><input type="checkbox" id="c-40128400" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#40129284">prev</a><span>|</span><a href="#40129859">next</a><span>|</span><label class="collapse" for="c-40128400">[-]</label><label class="expand" for="c-40128400">[11 more]</label></div><br/><div class="children"><div class="content">Looking back, I find it hard to offer concrete advice. So many of the &quot;things I know to be true&quot; changed over time, while so many of the &quot;doing x to allow for future y&quot; didn&#x27;t lead to anything.<p>On the other hand, I have systems being worked on and still shipping 20 years old because of fortuitous decisions in the 90s. Most of those taken because of bad experiences with earlier systems.<p>For example, I&#x27;m a big fan of surrogate keys and UUIDs, in database design. Mostly because of experience where they weren&#x27;t used which caused problems later. (By contrast, performance costs of using them become lower every year.)<p>Conversely deciding to build code libraries parallel to application development means long-term gains in performance and reliability.<p>It&#x27;s easy to view all this in hindsight, -much- harder with foresight.<p>Today I try and see everything through 2 rules.<p>1) beware of &quot;always&quot; statements, especially especially in regard to client requirements. IME &quot;always&quot; is used as a synonym for &quot;mostly&quot; and &quot;at the moment&quot;.<p>2) choose paths now that keep options open later. Will this system ever use distributed data? Probably not, but choose a primary key that leaves that option open.<p>Lastly, and this applies to data design, remember &quot;nothing is universal&quot;. Using Social Security number as an ID is great, until they outsource. Phone number is always 8 digits? Yeah right. Nobody works night shift... you get the idea.<p>If in doubt, err on the side of &quot;variant&quot;. You&#x27;ll be right more often than not.</div><br/><div id="40128660" class="c"><input type="checkbox" id="c-40128660" checked=""/><div class="controls bullet"><span class="by">abraae</span><span>|</span><a href="#40128400">parent</a><span>|</span><a href="#40129530">next</a><span>|</span><label class="collapse" for="c-40128660">[-]</label><label class="expand" for="c-40128660">[5 more]</label></div><br/><div class="children"><div class="content">&gt; For example, I&#x27;m a big fan of surrogate keys and UUIDs, in database design.<p>You would think this (using surrogate keys) would be such well worn wisdom by now that discussions about it wouldn&#x27;t be a thing. But somehow new generations of developers, weaned on nosql and on not using the god-given gifts of databases like integrity constraints, seem to love bike shedding key design and arguing vociferously that natural keys can be used as primary (and foreign) keys.</div><br/><div id="40129014" class="c"><input type="checkbox" id="c-40129014" checked=""/><div class="controls bullet"><span class="by">ThereIsNoWorry</span><span>|</span><a href="#40128400">root</a><span>|</span><a href="#40128660">parent</a><span>|</span><a href="#40129530">next</a><span>|</span><label class="collapse" for="c-40129014">[-]</label><label class="expand" for="c-40129014">[4 more]</label></div><br/><div class="children"><div class="content">You wouldn&#x27;t believe how often I have to fight for UUIDs instead of sequencing. UUIDs are great. For all practical purposes 0 possibility of collision; you can use it as an ID in a global system, it just makes so much fucking sense.<p>But the default is still a number natural number sequence. As if it matters for 99% of all cases that stuff is &quot;ordered&quot; and &quot;easily identifiable&quot; by a natural number.<p>But then you want to merge something or make double use and suddenly you have a huge problem that it isn&#x27;t unique anymore and you need more information to identify.<p>Guess what, an UUID does that job for you, across multiple databases and distributed systems, a UUID is still unique with 99.9999% probability.<p>The one counter-example every 10 years can be cared for manually.</div><br/><div id="40129678" class="c"><input type="checkbox" id="c-40129678" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#40128400">root</a><span>|</span><a href="#40129014">parent</a><span>|</span><a href="#40129087">next</a><span>|</span><label class="collapse" for="c-40129678">[-]</label><label class="expand" for="c-40129678">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using UUIDv7 a lot lately and I&#x27;ve been quite happy with the results.</div><br/></div></div><div id="40129087" class="c"><input type="checkbox" id="c-40129087" checked=""/><div class="controls bullet"><span class="by">abraae</span><span>|</span><a href="#40128400">root</a><span>|</span><a href="#40129014">parent</a><span>|</span><a href="#40129678">prev</a><span>|</span><a href="#40129530">next</a><span>|</span><label class="collapse" for="c-40129087">[-]</label><label class="expand" for="c-40129087">[2 more]</label></div><br/><div class="children"><div class="content">As far as I know the only practical downside with UUIDs in the modern age - unless you like using keys for ordering by creation time, or you have such enormous volumes that storage is a consideration - is that they are cumbersome for humans to read and compare, e.g scanning log files.<p>And in any case the German tank problem means that you often can&#x27;t use incrementing numbers as surrogate keys if they are ever exposed to the public e.g in urls.</div><br/><div id="40129132" class="c"><input type="checkbox" id="c-40129132" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40128400">root</a><span>|</span><a href="#40129087">parent</a><span>|</span><a href="#40129530">next</a><span>|</span><label class="collapse" for="c-40129132">[-]</label><label class="expand" for="c-40129132">[1 more]</label></div><br/><div class="children"><div class="content">&gt; they are cumbersome for humans to read and compare, e.g scanning log files.<p>I think the positive still outweighs the negative here: you can search your whole company&#x27;s logs for a UUID and you won&#x27;t get false positives like you would with serial integers.</div><br/></div></div></div></div></div></div></div></div><div id="40129530" class="c"><input type="checkbox" id="c-40129530" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#40128400">parent</a><span>|</span><a href="#40128660">prev</a><span>|</span><a href="#40128889">next</a><span>|</span><label class="collapse" for="c-40129530">[-]</label><label class="expand" for="c-40129530">[1 more]</label></div><br/><div class="children"><div class="content">&gt; beware of &quot;always&quot; statements, especially especially in regard to client requirements.<p>Along with its complimentary statement:<p>Beware of &quot;never&quot;, especially in regards to client requirements.<p>Been on too many projects where it turned out &quot;never&quot; meant once or twice per year once we&#x27;d gone into production...</div><br/></div></div><div id="40128889" class="c"><input type="checkbox" id="c-40128889" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#40128400">parent</a><span>|</span><a href="#40129530">prev</a><span>|</span><a href="#40129859">next</a><span>|</span><label class="collapse" for="c-40128889">[-]</label><label class="expand" for="c-40128889">[4 more]</label></div><br/><div class="children"><div class="content">I like to say &quot;design for deletion&quot;, meaning the priority is making sure code with outdated assumptions or fit can be <i>found, deleted, and replaced</i> easily.<p>This is in contrast to my how my younger-self would instead focus on making code that &quot;extensible&quot; or &quot;flexible&quot; or &quot;configurable&quot;. (With some overtones of impressing people, leaving a long-term mark upon the project, etc.)<p>Nope! Go for &quot;delete-able.&quot;</div><br/><div id="40129176" class="c"><input type="checkbox" id="c-40129176" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#40128400">root</a><span>|</span><a href="#40128889">parent</a><span>|</span><a href="#40128924">next</a><span>|</span><label class="collapse" for="c-40129176">[-]</label><label class="expand" for="c-40129176">[1 more]</label></div><br/><div class="children"><div class="content">There’s a lot of power in designing unit tests for deletion. I’d have to think about whether I feel that applies universally.</div><br/></div></div><div id="40128924" class="c"><input type="checkbox" id="c-40128924" checked=""/><div class="controls bullet"><span class="by">vsnf</span><span>|</span><a href="#40128400">root</a><span>|</span><a href="#40128889">parent</a><span>|</span><a href="#40129176">prev</a><span>|</span><a href="#40129859">next</a><span>|</span><label class="collapse" for="c-40128924">[-]</label><label class="expand" for="c-40128924">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never heard this framing before. Can you offer any examples of what you mean?</div><br/><div id="40129069" class="c"><input type="checkbox" id="c-40129069" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#40128400">root</a><span>|</span><a href="#40128924">parent</a><span>|</span><a href="#40129859">next</a><span>|</span><label class="collapse" for="c-40129069">[-]</label><label class="expand" for="c-40129069">[1 more]</label></div><br/><div class="children"><div class="content">A lot of it overlaps with Ya Ain&#x27;t Gonna Need It and avoiding strong coupling, but I think the framing makes it easier to stay on target: A developer is less-likely to end up going: &quot;Hey guys, I created a <i>decoupling framework</i> so we can swap anything for anything whenever we want!&quot;<p>If you design thinking &quot;X years from now business-requirements or staff will have changed enough that this will need to be ripped out and rewritten, and I am not good enough at predicting the future to solve it cleverly&quot;, then it sets up a different expectation of how you invest your time.<p>One might focus on code where it&#x27;s easy to trace dependencies, even if that means a bit more boilerplate and avoiding layers of indirection that aren&#x27;t (yet&#x2F;ever) needed. &quot;Greppability&quot; of code also becomes important, especially if your language&#x2F;tools aren&#x27;t <i>very</i> good at tracing usages and caller&#x2F;callee relationships.</div><br/></div></div></div></div></div></div></div></div><div id="40129859" class="c"><input type="checkbox" id="c-40129859" checked=""/><div class="controls bullet"><span class="by">tossandthrow</span><span>|</span><a href="#40128400">prev</a><span>|</span><a href="#40128575">next</a><span>|</span><label class="collapse" for="c-40129859">[-]</label><label class="expand" for="c-40129859">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That assumption became obsolete the moment that Matt implemented task packing, but we didn’t notice. This code, which was still simple and easy to read, was now also wrong.<p>It seems like Matt did not fully understand the platform he was developing for and introduced a bug as his code did not satisfy the invariants.<p>It is really nice when invariants are checked either in types or in tests so Matt would have been alerted when he introduced the bug.<p>I don&#x27;t like the discourse the article introduces. It must always be the one who writes the newest code who has the responsibility to adjust previous code. That also includes changing obselete modules (where invariants does no suffice anymore).</div><br/></div></div><div id="40128575" class="c"><input type="checkbox" id="c-40128575" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#40129859">prev</a><span>|</span><a href="#40129748">next</a><span>|</span><label class="collapse" for="c-40128575">[-]</label><label class="expand" for="c-40128575">[7 more]</label></div><br/><div class="children"><div class="content">The problem I think is that when you define an invariant, you are also defining an infinite number of &quot;implicit&quot; invariants. And it&#x27;s hard to know a priori which of those implicit invariants is not an actual invariant over time.<p>Take a simple User type<p><pre><code>  type User {
    name: string
    email: string
  }
</code></pre>
This describes some obvious invariants - that a User will have a name and an email.<p>But it&#x27;s also describing some less obvious invariants, e.g. that a User will <i>not</i> have a phone number. This has implications if a phone number ever does get added to a User type, and your system has to deal with two different versions of Users.<p>(This isn&#x27;t just an academic problem - the problem of trying to evolve fields over time is the reason why Protobufs got rid of the idea of a &quot;required&quot; field.)<p>And this is an example of a very simple implicit invariant. In practice, systems that interact with each other will give rise to emergent behaviour that one might think is always true, but is not guaranteed.</div><br/><div id="40128759" class="c"><input type="checkbox" id="c-40128759" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#40128575">parent</a><span>|</span><a href="#40128745">next</a><span>|</span><label class="collapse" for="c-40128759">[-]</label><label class="expand" for="c-40128759">[3 more]</label></div><br/><div class="children"><div class="content">This is why I tend to like to use strong type systems where possible and necessary.<p><pre><code>    struct LoginUser {
        name: UserName,
        email: Email,
        phone_number: Option&lt;PhoneNumber&gt;,
    }
</code></pre>
First the user type should reflect the function of the user. This is one that is allowed to log in (of course overly simplified). You can then also have a OnboardingUser, a ArchivedUser and so on. And if you want to transition one between those different types you need to ensure the fields are there. This is easy to test and clear.<p>The other thing is to use types for fields that have hard verification requirements. You can still have them behave mostly like strings for reading, but you can ensure that an Email in a LoginUser never contains an unverified Email, by first verifying the email string in the OnboardingUser and only converting it into the Email type once it is guaranteed to be a valid email. Because you use a special type tacking on further things like storing a date when this verification happened last is easy, just put it into the type as well.<p>Lastly the phone number is an Optional type that wraps a PhoneNumber type. This way it can either be None or Some&lt;PhoneNumber&gt; (this uses the Rust typesystem, but the principle would work elsewhere), the phone number should be verified the same way, ideally relying on a well tested method that also fixes the formatting at the same time.<p>Now in Rust if some part of the system didn&#x27;t handle a user that <i>has</i> a phoneNumber your code won&#x27;t compile, because from the standpoint of the old code this would now be an entirely new, unknown type never seen before. Sure you could step through your code and explicitly <i>not</i> handle it on purpose because you want back to a running system fast, fail to add a TODO and then later forget about having to do it, but that would be entirely on you.<p>Now those hard typesystem constraints become even more valuable when dealing with external systems. Your type should represent all assumptions you are making about the data and test those on each import. Of course you then will have import failures if the import source changed, but we <i>want</i> that to fail if it changes. What we don&#x27;t want is the thing silently chugging the input into the wrong pipe or invalid phone numbers to be stored because the source system decided to split them up into the prefix and the rest.</div><br/><div id="40128986" class="c"><input type="checkbox" id="c-40128986" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#40128575">root</a><span>|</span><a href="#40128759">parent</a><span>|</span><a href="#40128745">next</a><span>|</span><label class="collapse" for="c-40128986">[-]</label><label class="expand" for="c-40128986">[2 more]</label></div><br/><div class="children"><div class="content">Static types are really good for describing invariants, I definitely agree.<p>But it does also describe a lot of implicit invariants. The LoginUser you&#x27;ve defined has the implicit invariant that a LoginUser only has 3 fields. It is very possible for someone to write a function that relies on a LoginUser only ever having 3 fields, which then breaks if you ever extended LoginUser. This is similar to the example that the article mentions at the start, where a thing that someone assumed would always fit in one memory region no longer did, and that caused all kinds of problems.<p>Those kinds of implicit invariants are the ones that are tricky to make explicit, even in strongly-typed languages.</div><br/><div id="40129048" class="c"><input type="checkbox" id="c-40129048" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#40128575">root</a><span>|</span><a href="#40128986">parent</a><span>|</span><a href="#40128745">next</a><span>|</span><label class="collapse" for="c-40129048">[-]</label><label class="expand" for="c-40129048">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But it does also describe a lot of implicit invariants. The LoginUser you&#x27;ve defined has the implicit invariant that a LoginUser only has 3 fields. It is very possible for someone to write a function that relies on a LoginUser only ever having 3 fields, which then breaks if you ever extended LoginUse<p>Rust does actually have a good way of dealing with this specific invariant. If you mark a struct with the `non_exhaustive` attribute[0], trying to construct it with a literal will fail outside of the package that defines it (even if all fields are marked as public), and trying to pattern match it outside the package that defines it is required to use the operator to ignore any missing fields.<p>Not trying to say that it&#x27;s possible to encode every possible invariant in Rust, but I do find it useful to leverage all of the tools available, and I&#x27;ve found this one super useful (on both structs and enums) despite not being super well known from what I can tell.<p>[0]: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;attributes&#x2F;type_system.html#the-non_exhaustive-attribute" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;attributes&#x2F;type_system.h...</a></div><br/></div></div></div></div></div></div><div id="40128745" class="c"><input type="checkbox" id="c-40128745" checked=""/><div class="controls bullet"><span class="by">_ZeD_</span><span>|</span><a href="#40128575">parent</a><span>|</span><a href="#40128759">prev</a><span>|</span><a href="#40129748">next</a><span>|</span><label class="collapse" for="c-40128745">[-]</label><label class="expand" for="c-40128745">[3 more]</label></div><br/><div class="children"><div class="content">&gt;&gt;&gt; (This isn&#x27;t just an academic problem - the problem of trying to evolve fields over time is the reason why Protobufs got rid of the idea of a &quot;required&quot; field.)<p>if <i>this</i> is the reason of the drop of the required field it doesn&#x27;t seems smart to me.<p>They are conflating the definition of a scheme with the scheme evolution logic.<p>And there are multiple ways to deal with the latter (like adding a schema version, for instance)</div><br/><div id="40129402" class="c"><input type="checkbox" id="c-40129402" checked=""/><div class="controls bullet"><span class="by">larsrc</span><span>|</span><a href="#40128575">root</a><span>|</span><a href="#40128745">parent</a><span>|</span><a href="#40128939">next</a><span>|</span><label class="collapse" for="c-40129402">[-]</label><label class="expand" for="c-40129402">[1 more]</label></div><br/><div class="children"><div class="content">Some &quot;required&quot; fields in very commonly used protos ended up being unused, but everybody has to fill them out all the time. If they didn&#x27;t, the proto wouldn&#x27;t even parse, by design.<p>Protobufs explicitly do not have a built-in version system (though of course you could add an optional field for it), presumably because it is better to inspect the data than build in assumptions that a certain version overs a certain invariant.</div><br/></div></div><div id="40128939" class="c"><input type="checkbox" id="c-40128939" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#40128575">root</a><span>|</span><a href="#40128745">parent</a><span>|</span><a href="#40129402">prev</a><span>|</span><a href="#40129748">next</a><span>|</span><label class="collapse" for="c-40128939">[-]</label><label class="expand" for="c-40128939">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have a very strong opinion about that change specifically. I think they could have kept their cake and ate it too by solving the schema evolvability some other way, but I also suspect those other ways will come with tradeoffs that are also not pleasant.<p>But, the point is schema evolvability is a real problem, and it&#x27;s often not one that a lot of engineers give a lot of thought to, even those who live in very strict statically-typed worlds.</div><br/></div></div></div></div></div></div><div id="40129748" class="c"><input type="checkbox" id="c-40129748" checked=""/><div class="controls bullet"><span class="by">olivierduval</span><span>|</span><a href="#40128575">prev</a><span>|</span><a href="#40127911">next</a><span>|</span><label class="collapse" for="c-40129748">[-]</label><label class="expand" for="c-40129748">[1 more]</label></div><br/><div class="children"><div class="content">IMHO, an &quot;invariant&quot; is only relative to the current system to be build, based on a specific set of specifications. As soon as you build a new version of the system (either because you change the functionalities, the implementation or because the environment change), you&#x27;re expected to check which invariant still applies and which should be added, removed or changed...<p>In a way, &quot;invariant&quot; are the same as &quot;tests sets&quot;: they are here to help to ensure that the product will have some specific properties. Both are used during the product development and checked. And both must be updated when the specs change</div><br/></div></div><div id="40127911" class="c"><input type="checkbox" id="c-40127911" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#40129748">prev</a><span>|</span><a href="#40129347">next</a><span>|</span><label class="collapse" for="c-40127911">[-]</label><label class="expand" for="c-40127911">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m happy to see people talking about the problem posed by implicit invariants, but this post strikes me as defeatist. This line especially:<p><i>&gt; Implicit invariants are, by definition, impossible to enforce explicitly.</i><p>Yes, Hyrum&#x27;s Law (and, at the limit, Rice&#x27;s Theorem) and all that means that we won&#x27;t ever be perfect, but just because an invariant is currently implicit doesn&#x27;t mean it must remain implicit forever. We can identify classes of implicit invariants and make them explicit using things like type systems.</div><br/></div></div><div id="40129347" class="c"><input type="checkbox" id="c-40129347" checked=""/><div class="controls bullet"><span class="by">cjfd</span><span>|</span><a href="#40127911">prev</a><span>|</span><a href="#40128943">next</a><span>|</span><label class="collapse" for="c-40129347">[-]</label><label class="expand" for="c-40129347">[2 more]</label></div><br/><div class="children"><div class="content">When I read this story it leaves me wondering if these people had any automated testing. This may or may not have helped but it is not even mentioned and it does sound like a problem that an integration test might have caught.</div><br/><div id="40129394" class="c"><input type="checkbox" id="c-40129394" checked=""/><div class="controls bullet"><span class="by">dexwiz</span><span>|</span><a href="#40129347">parent</a><span>|</span><a href="#40128943">next</a><span>|</span><label class="collapse" for="c-40129394">[-]</label><label class="expand" for="c-40129394">[1 more]</label></div><br/><div class="children"><div class="content">Yeah this is the kind of thing testing is useful for. Writing tests against invariants is a great idea. That way if the invariant changes, the test starts to fail.</div><br/></div></div></div></div><div id="40128943" class="c"><input type="checkbox" id="c-40128943" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40129347">prev</a><span>|</span><a href="#40129099">next</a><span>|</span><label class="collapse" for="c-40128943">[-]</label><label class="expand" for="c-40128943">[1 more]</label></div><br/><div class="children"><div class="content">I have always used asserts to enforce invariants (sometimes not just actual &quot;assert&quot; but things like `Preconditions` in Java which are always enabled). Those will actually break during testing if they ever change.<p>I understand you cannot assert all invariants, but as far as I can see, that&#x27;s your main tool against this problem.</div><br/></div></div><div id="40129099" class="c"><input type="checkbox" id="c-40129099" checked=""/><div class="controls bullet"><span class="by">sixthDot</span><span>|</span><a href="#40128943">prev</a><span>|</span><a href="#40128183">next</a><span>|</span><label class="collapse" for="c-40129099">[-]</label><label class="expand" for="c-40129099">[1 more]</label></div><br/><div class="children"><div class="content">Sure sometimes there are deprecations and API changes. Assumptions must be revised accordingly.</div><br/></div></div><div id="40128183" class="c"><input type="checkbox" id="c-40128183" checked=""/><div class="controls bullet"><span class="by">throwaway74432</span><span>|</span><a href="#40129099">prev</a><span>|</span><label class="collapse" for="c-40128183">[-]</label><label class="expand" for="c-40128183">[2 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s called evolution. Software evolves as well as scales. Scaling is architected growth, evolution is unarchitected growth. (Sometimes scaling results in unarchitected growth, if the architecture was not reasonable.) There are many patterns for handling evolution, but they almost always involve a pattern outside of the existing architecture (a super architecture) to lean on for support. In my opinion, codifying and optimizing these super architecture patterns is one of the highest goals in software engineering because they allow for less error prone evolutions.</div><br/><div id="40129417" class="c"><input type="checkbox" id="c-40129417" checked=""/><div class="controls bullet"><span class="by">larsrc</span><span>|</span><a href="#40128183">parent</a><span>|</span><label class="collapse" for="c-40129417">[-]</label><label class="expand" for="c-40129417">[1 more]</label></div><br/><div class="children"><div class="content">Thanks to Titus Winters for the phrase &quot;Software engineering is programming integrated over time&quot;. Handling evolution of software is different from just writing it.</div><br/></div></div></div></div></div></div></div></div></div></body></html>