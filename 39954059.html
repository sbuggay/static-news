<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712480451597" as="style"/><link rel="stylesheet" href="styles.css?v=1712480451597"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://programming-journal.org/2023/7/6/">A Theory of Composing Protocols (2023)</a> <span class="domain">(<a href="https://programming-journal.org">programming-journal.org</a>)</span></div><div class="subtext"><span>mpweiher</span> | <span>16 comments</span></div><br/><div><div id="39955139" class="c"><input type="checkbox" id="c-39955139" checked=""/><div class="controls bullet"><span class="by">rdtsc</span><span>|</span><a href="#39954812">next</a><span>|</span><label class="collapse" for="c-39955139">[-]</label><label class="expand" for="c-39955139">[9 more]</label></div><br/><div class="children"><div class="content">&gt; We demonstrate our approach in the practical setting of Erlang, with a tool implementing protocol composition that both generates Erlang code from a protocol and generates a protocol from Erlang code.<p>That&#x27;s great. Erlang has gen_statem as a built-in behavior so it seems appropriate to use it. Also Joe Armstrong had been talking about protocols for the longest time. He would say something like &quot;Tell me what&#x27;s on the wire! Don&#x27;t give me some C++ API&quot;.<p>[1] <a href="https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;design_principles&#x2F;statem" rel="nofollow">https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;design_principles&#x2F;statem</a></div><br/><div id="39955153" class="c"><input type="checkbox" id="c-39955153" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#39955139">parent</a><span>|</span><a href="#39954812">next</a><span>|</span><label class="collapse" for="c-39955153">[-]</label><label class="expand" for="c-39955153">[8 more]</label></div><br/><div class="children"><div class="content">I struggle to put it into words - but I think this modern notion that we exchange language structs between processes and not arbitrary messages has lost something valuable.<p>edit - I guess true interoperability? agency?</div><br/><div id="39955310" class="c"><input type="checkbox" id="c-39955310" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#39955139">root</a><span>|</span><a href="#39955153">parent</a><span>|</span><a href="#39954812">next</a><span>|</span><label class="collapse" for="c-39955310">[-]</label><label class="expand" for="c-39955310">[7 more]</label></div><br/><div class="children"><div class="content">What would it even mean to accept an arbitrary message? All you can do in that case is record and&#x2F;or forward because the contents are unknown.</div><br/><div id="39955420" class="c"><input type="checkbox" id="c-39955420" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#39955139">root</a><span>|</span><a href="#39955310">parent</a><span>|</span><a href="#39954812">next</a><span>|</span><label class="collapse" for="c-39955420">[-]</label><label class="expand" for="c-39955420">[6 more]</label></div><br/><div class="children"><div class="content">sorry, message defined as a format, like a tcp header that&#x27;s written down and agreed upon - not message defined in some other software system like protobuf with some mapping to and from language structures</div><br/><div id="39956005" class="c"><input type="checkbox" id="c-39956005" checked=""/><div class="controls bullet"><span class="by">discreteevent</span><span>|</span><a href="#39955139">root</a><span>|</span><a href="#39955420">parent</a><span>|</span><a href="#39954812">next</a><span>|</span><label class="collapse" for="c-39956005">[-]</label><label class="expand" for="c-39956005">[5 more]</label></div><br/><div class="children"><div class="content">Protobufs are just structured messages. They don&#x27;t have anything to with language structures per se. They are semantically the same as the TCP header that&#x27;s written down and agreed upon.</div><br/><div id="39956113" class="c"><input type="checkbox" id="c-39956113" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#39955139">root</a><span>|</span><a href="#39956005">parent</a><span>|</span><a href="#39954812">next</a><span>|</span><label class="collapse" for="c-39956113">[-]</label><label class="expand" for="c-39956113">[4 more]</label></div><br/><div class="children"><div class="content">yes. but as a matter of culture one doesn&#x27;t write binary formats any longer. that&#x27;s just - silly? and its not as if I don&#x27;t think people should use abstractions to format messages.<p>and as a matter of definition, yes, protobufs are just bit strings and a schema definition in a limited type language (just like xdr and asn before it).<p>but again, as a matter of usage, we&#x27;re only really supposed to use them to map to and from structs.<p>and its not as if this doesn&#x27;t work, clearly it does. as someone who used to do protocol implementation before all this, I find unsettling. and I don&#x27;t know if I&#x27;m just being predudicial, or if we we are somehow losing something by adopting this model as essentially mandatory.<p>I do find it frustrating, that when I do want certain binary properties, or I want to encode a cyclic structure in a particular way, or use a richer schema. that I have to fight upstream to not use protobufs even if they don&#x27;t bring anything except a useless wrapper around a byte string I am defining anyways.</div><br/><div id="39956602" class="c"><input type="checkbox" id="c-39956602" checked=""/><div class="controls bullet"><span class="by">aleksiy123</span><span>|</span><a href="#39955139">root</a><span>|</span><a href="#39956113">parent</a><span>|</span><a href="#39954812">next</a><span>|</span><label class="collapse" for="c-39956602">[-]</label><label class="expand" for="c-39956602">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I understand this.<p>Isn&#x27;t protobuf just one such protocol definition. With a focus on being general.<p>If you don&#x27;t like the trade-offs it makes then you can use your own specific protocol with your own tradeoffs.<p>But yes people will push back on you if you can&#x27;t justify why that decision is better than the general solution especially if they have to use it.<p>Imo starting with an out of the box solution as a baseline and then moving to a more specialized solution when the need arises is pretty solid decision.</div><br/><div id="39957050" class="c"><input type="checkbox" id="c-39957050" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#39955139">root</a><span>|</span><a href="#39956602">parent</a><span>|</span><a href="#39954812">next</a><span>|</span><label class="collapse" for="c-39957050">[-]</label><label class="expand" for="c-39957050">[2 more]</label></div><br/><div class="children"><div class="content">I think you answered my question. I’d like to say ‘what’s the most effective way to serialize this’ and everyone else wants to say ‘use protobuf unless you can come up with a really good reason not to’</div><br/><div id="39957316" class="c"><input type="checkbox" id="c-39957316" checked=""/><div class="controls bullet"><span class="by">aleksiy123</span><span>|</span><a href="#39955139">root</a><span>|</span><a href="#39957050">parent</a><span>|</span><a href="#39954812">next</a><span>|</span><label class="collapse" for="c-39957316">[-]</label><label class="expand" for="c-39957316">[1 more]</label></div><br/><div class="children"><div class="content">Yes makes sense. I think it&#x27;s also about the context of what your goal is and what your eng skill set is.<p>If you are low-level C shop that may make sense. But if you are trying to build some rpc service for usage between multiple teams and languages. Using protobufs or something similar is gonna give you more mileage.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39954812" class="c"><input type="checkbox" id="c-39954812" checked=""/><div class="controls bullet"><span class="by">xg15</span><span>|</span><a href="#39955139">prev</a><span>|</span><a href="#39957503">next</a><span>|</span><label class="collapse" for="c-39954812">[-]</label><label class="expand" for="c-39954812">[1 more]</label></div><br/><div class="children"><div class="content">This sounds pretty cool. I think there is some kind of gap in formal modeling for languages that are interleaved with each other. Like, it&#x27;s more or less straight-forward to describe, say, javascript and HTML(5) as ASTs, but things get hairy when you embed one language into the other, e.g. HTML attributes that contain JavaScript or JavaScript strings that contain HTML. Maybe this could help?</div><br/></div></div><div id="39957503" class="c"><input type="checkbox" id="c-39957503" checked=""/><div class="controls bullet"><span class="by">hyperthesis</span><span>|</span><a href="#39954812">prev</a><span>|</span><a href="#39954558">next</a><span>|</span><label class="collapse" for="c-39957503">[-]</label><label class="expand" for="c-39957503">[2 more]</label></div><br/><div class="children"><div class="content">What exactly is a &quot;protocol&quot;?<p>I skimmed the pdf for a definition, but it seems to only give examples, then jump directly to defining compositions.</div><br/><div id="39957688" class="c"><input type="checkbox" id="c-39957688" checked=""/><div class="controls bullet"><span class="by">nathanrf</span><span>|</span><a href="#39957503">parent</a><span>|</span><a href="#39954558">next</a><span>|</span><label class="collapse" for="c-39957688">[-]</label><label class="expand" for="c-39957688">[1 more]</label></div><br/><div class="children"><div class="content">The paper defines them as programs in a process calculus (which is fairly standard as far as theory for protocols is involved):<p><pre><code>  Definition 1 (Asserted protocols) Asserted protocols, or just protocols for short, are
  ranged over by S and are defined as the following syntax rules:
  S ::=
      |p.S                action prefix
      | +{ l_i : Si }_i∈I branching
      | µt.S              fixed-point
      | t                 recursive variable
      | end               end
      | assert(n).S       assert (produce)
      | require(n).S      require
      | consume(n).S      consume

</code></pre>
Process calculi are &quot;fundamental&quot; descriptions of computation analogous to lambda calculus but oriented around communication instead of function calls. (As far as paper structure, I find that usually the important &quot;basic&quot; definitions in programming language research papers are usually in Section 2, since Section 1 serves as a high-level overview).<p>Basically, a protocol consists of a a sequence of sends&#x2F;received on a particular channel, mixed with some explicit logic and loops&#x2F;branches until you reach the end. There&#x27;s some examples in Section 2.1 which are too complicated to reproduce here.<p>As a general note on reading protocols- for (good, but industry-programmer-unfriendly) technical reasons they&#x27;re defined and written as &quot;action1.action2.action3.rest_of_program&quot; but mentally you can just rewrite this into<p><pre><code>  {
    action1();
    action2();
    action3();
    ... rest_of_program ...
  }
</code></pre>
(in particular, making &quot;the rest of the program&quot; part of each statement makes specifying scope much easier and clearer, which is why they don&#x27;t just use semicolons in the first place)</div><br/></div></div></div></div><div id="39954558" class="c"><input type="checkbox" id="c-39954558" checked=""/><div class="controls bullet"><span class="by">haskellandchill</span><span>|</span><a href="#39957503">prev</a><span>|</span><a href="#39956366">next</a><span>|</span><label class="collapse" for="c-39954558">[-]</label><label class="expand" for="c-39954558">[1 more]</label></div><br/><div class="children"><div class="content">I’m interested in how this compares to the coalgebra approach like in “Session Coalgebras: A Coalgebraic View on Session Types and Communication Protocols” (<a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2011.05712.pdf" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2011.05712.pdf</a>).</div><br/></div></div></div></div></div></div></div></body></html>