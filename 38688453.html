<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702976459616" as="style"/><link rel="stylesheet" href="styles.css?v=1702976459616"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://eliseshaffer.com/2023/12/18/i-love-ruby/">I Love Ruby</a> <span class="domain">(<a href="https://eliseshaffer.com">eliseshaffer.com</a>)</span></div><div class="subtext"><span>mooreds</span> | <span>134 comments</span></div><br/><div><div id="38693332" class="c"><input type="checkbox" id="c-38693332" checked=""/><div class="controls bullet"><span class="by">vinc</span><span>|</span><a href="#38689205">next</a><span>|</span><label class="collapse" for="c-38693332">[-]</label><label class="expand" for="c-38693332">[1 more]</label></div><br/><div class="children"><div class="content">I started with PHP many years ago for my side projects while at the university, then I switched to Python, but when I graduated there were only PHP jobs available so I took one because I had to. I was not happy with PHP, it was a pain to use it. I never want to hear again about WordPress or Drupal.<p>I discovered the Ruby community at its peak around that time and fell in love with it! I started a new project at work with Rails and all my next jobs were Ruby jobs.<p>I experimented with Node when it came out but I think I&#x27;m burn out with everything related to JavaScript at this point. And the Ruby community, while still great, seems to be dying out locally. Meanwhile I&#x27;ve been doing some Rust side projects for almost a decade, and it looks like this will be my next language. Time will tell.<p>I still love Ruby though, I wish it was more popular, it&#x27;s such a nice language.</div><br/></div></div><div id="38689205" class="c"><input type="checkbox" id="c-38689205" checked=""/><div class="controls bullet"><span class="by">bakuninsbart</span><span>|</span><a href="#38693332">prev</a><span>|</span><a href="#38693013">next</a><span>|</span><label class="collapse" for="c-38689205">[-]</label><label class="expand" for="c-38689205">[11 more]</label></div><br/><div class="children"><div class="content">I think the point about expressiveness is <i>exactly</i> what makes ruby so divisive: It is great when you are deep within the ecosystem or do exactly what the ecosystem expects you to want to do, and an absolute pain if you want to do anything non-standard.<p>The supports_feature-method is probably defined somewhere 5 abstractions deep. If you are lucky that is, it might also be  part of some library&#x27;s weird meta-programming of supports-* that no LSP can point you towards. I&#x27;ve never worked in an ecosystem that celebrates implicitness as much as ruby does, and it is driving me nuts.<p>The fact that finished code looks great and reads well doesn&#x27;t balance the scales in my book.</div><br/><div id="38691899" class="c"><input type="checkbox" id="c-38691899" checked=""/><div class="controls bullet"><span class="by">rezonant</span><span>|</span><a href="#38689205">parent</a><span>|</span><a href="#38690981">next</a><span>|</span><label class="collapse" for="c-38691899">[-]</label><label class="expand" for="c-38691899">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The supports_feature-method is probably defined somewhere 5 abstractions deep.<p>Yes, but pro tip: you can do object.method(:supports_feature).source_location to inspect where it comes from. It may be a module included into the class, the class itself or one of its super classes, or a concept built on modules like ActiveSupport &quot;concerns&quot;. But source_location works in almost all cases.<p>&gt; might also be part of some library&#x27;s weird meta-programming of supports-* that no LSP can point you towards<p>Yes, if this comes from method_missing, you can&#x27;t check it&#x27;s source_location. You need to use your knowledge that the method name works and that method_missing is how such things are done, and then you do object.method(:method_missing).source_location and read the logic there.<p>The lack of safe and reliable IDE introspection and design-time type support are my number one issue with Ruby, and why I tend to use typed languages instead.<p>However, there are workflows for inspecting a codebase that work, they just don&#x27;t fit in well to the usual LSP+IDE pattern. You are expected to use irb&#x2F;rails console to do your inspection of the structure and behavior of your programs.</div><br/></div></div><div id="38690981" class="c"><input type="checkbox" id="c-38690981" checked=""/><div class="controls bullet"><span class="by">notjoemama</span><span>|</span><a href="#38689205">parent</a><span>|</span><a href="#38691899">prev</a><span>|</span><a href="#38689295">next</a><span>|</span><label class="collapse" for="c-38690981">[-]</label><label class="expand" for="c-38690981">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The fact that finished code looks great and reads well doesn&#x27;t balance the scales in my book.<p>IMO this is because software engineers both get bored and feel a need to compete. The more abstract they can make code the better (more safe?) they feel. That lets them play chess on their terms and eliminate the competition. But that&#x27;s just my take, I may be wrong. Fortunately the most commonly used gems wrap this abstraction into usable APIs, and most have good documentation.<p>While this can be correctly attributed to ruby or the devs in its ecosystem, I&#x27;ve been on teams with staff using other languages and stacks that let their completion&#x2F;anxiety fly making it hard to read and understand their code. I guess my point is it&#x27;s a good critique, but it falls beyond the meta programming in ruby.</div><br/></div></div><div id="38689295" class="c"><input type="checkbox" id="c-38689295" checked=""/><div class="controls bullet"><span class="by">pqdbr</span><span>|</span><a href="#38689205">parent</a><span>|</span><a href="#38690981">prev</a><span>|</span><a href="#38692854">next</a><span>|</span><label class="collapse" for="c-38689295">[-]</label><label class="expand" for="c-38689295">[3 more]</label></div><br/><div class="children"><div class="content">In my experience this is almost never the case. #supports_feature? would be defined right there where you&#x27;d expect - in that Subscription model.<p>Even tough you can reach for metaprogramming (like define_method or method_missing), that&#x27;s really not how the entire ecosystem of guides and tutorials will point you.<p>Anyways, when in doubt, just plug a debugger and call  &quot;@subscription.method(:supports_feature?).source_location`, and generally that&#x27;s all it takes.</div><br/><div id="38690202" class="c"><input type="checkbox" id="c-38690202" checked=""/><div class="controls bullet"><span class="by">Fire-Dragon-DoL</span><span>|</span><a href="#38689205">root</a><span>|</span><a href="#38689295">parent</a><span>|</span><a href="#38689561">next</a><span>|</span><label class="collapse" for="c-38690202">[-]</label><label class="expand" for="c-38690202">[1 more]</label></div><br/><div class="children"><div class="content">The most common framework in ruby disagrees. It wiuld be 5 layers deep</div><br/></div></div><div id="38689561" class="c"><input type="checkbox" id="c-38689561" checked=""/><div class="controls bullet"><span class="by">mplewis</span><span>|</span><a href="#38689205">root</a><span>|</span><a href="#38689295">parent</a><span>|</span><a href="#38690202">prev</a><span>|</span><a href="#38692854">next</a><span>|</span><label class="collapse" for="c-38689561">[-]</label><label class="expand" for="c-38689561">[1 more]</label></div><br/><div class="children"><div class="content">Rails is the biggest Ruby project and it’s heavily based on metaprogramming. Even Rubymine has trouble finding the canonical definition of a named method sometimes – it has to guess. I love Ruby but I totally understand this criticism.</div><br/></div></div></div></div><div id="38689811" class="c"><input type="checkbox" id="c-38689811" checked=""/><div class="controls bullet"><span class="by">Doctor_Fegg</span><span>|</span><a href="#38689205">parent</a><span>|</span><a href="#38692854">prev</a><span>|</span><a href="#38690673">next</a><span>|</span><label class="collapse" for="c-38689811">[-]</label><label class="expand" for="c-38689811">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The supports_feature-method is probably defined somewhere 5 abstractions deep<p>This is the classic mistake of confusing Ruby with Rails. That might be true of Rails. It absolutely isn&#x27;t true of vanilla Ruby. The article was not &quot;I love Rails&quot;.</div><br/><div id="38691243" class="c"><input type="checkbox" id="c-38691243" checked=""/><div class="controls bullet"><span class="by">madeofpalk</span><span>|</span><a href="#38689205">root</a><span>|</span><a href="#38689811">parent</a><span>|</span><a href="#38690673">next</a><span>|</span><label class="collapse" for="c-38691243">[-]</label><label class="expand" for="c-38691243">[2 more]</label></div><br/><div class="children"><div class="content">Does Rails not use Ruby?</div><br/><div id="38691306" class="c"><input type="checkbox" id="c-38691306" checked=""/><div class="controls bullet"><span class="by">lstamour</span><span>|</span><a href="#38689205">root</a><span>|</span><a href="#38691243">parent</a><span>|</span><a href="#38690673">next</a><span>|</span><label class="collapse" for="c-38691306">[-]</label><label class="expand" for="c-38691306">[1 more]</label></div><br/><div class="children"><div class="content">It does, but at this point it’s like saying that JavaScript is DOM even though you can use it outside a web browser. Or it’s like blaming Python for TensorFlow. Like, yes, Rails is a use case for Ruby, and a popular one, but not the only one.</div><br/></div></div></div></div></div></div><div id="38690673" class="c"><input type="checkbox" id="c-38690673" checked=""/><div class="controls bullet"><span class="by">pdntspa</span><span>|</span><a href="#38689205">parent</a><span>|</span><a href="#38689811">prev</a><span>|</span><a href="#38693013">next</a><span>|</span><label class="collapse" for="c-38690673">[-]</label><label class="expand" for="c-38690673">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a pretty simple heuristic to track down the source of metaprogrammed functions... just check for method_missing() or define_function() or a handful of other keywords. I believe the regular syntax is just shorthand for these features anyway.<p>edit- as another comment points out, you can just do `@subscription.method(:supports_feature?).source_location` too</div><br/></div></div></div></div><div id="38693013" class="c"><input type="checkbox" id="c-38693013" checked=""/><div class="controls bullet"><span class="by">cryptos</span><span>|</span><a href="#38689205">prev</a><span>|</span><a href="#38689147">next</a><span>|</span><label class="collapse" for="c-38693013">[-]</label><label class="expand" for="c-38693013">[3 more]</label></div><br/><div class="children"><div class="content">I agree with the author that &quot;developer experience&quot; is underrated in many programming languages or frameworks. But at least for me Ruby is by far not the number one in this area. While the syntax looks nice at a first sight, lack of type information and meta-programming can make working with this language tough. And there are other factors to pick a programming language, runtime performance for example. I guess that this and the absence of static typing are the reasons why Ruby fell out of fashion.<p>For me Kotlin is the sweet spot in programming language. You get a concise, readable language with world class tool support, static typing and the excellent performance of JVM + everything available in the Java ecosystem.</div><br/><div id="38693087" class="c"><input type="checkbox" id="c-38693087" checked=""/><div class="controls bullet"><span class="by">jstummbillig</span><span>|</span><a href="#38693013">parent</a><span>|</span><a href="#38689147">next</a><span>|</span><label class="collapse" for="c-38693087">[-]</label><label class="expand" for="c-38693087">[2 more]</label></div><br/><div class="children"><div class="content">The hours I have sunk into making vscode a rails ide are substantial.</div><br/><div id="38693102" class="c"><input type="checkbox" id="c-38693102" checked=""/><div class="controls bullet"><span class="by">JelteF</span><span>|</span><a href="#38693013">root</a><span>|</span><a href="#38693087">parent</a><span>|</span><a href="#38689147">next</a><span>|</span><label class="collapse" for="c-38693102">[-]</label><label class="expand" for="c-38693102">[1 more]</label></div><br/><div class="children"><div class="content">Were you successful? I spent a lot of time too, but never got &quot;go to definition&quot; to actually work well.</div><br/></div></div></div></div></div></div><div id="38689147" class="c"><input type="checkbox" id="c-38689147" checked=""/><div class="controls bullet"><span class="by">atomicnumber3</span><span>|</span><a href="#38693013">prev</a><span>|</span><a href="#38692146">next</a><span>|</span><label class="collapse" for="c-38689147">[-]</label><label class="expand" for="c-38689147">[22 more]</label></div><br/><div class="children"><div class="content">I love Ruby too. It&#x27;s a great language, and as a language I like many things about Ruby a lot more than python. In particular, chains of functional operations like:<p><pre><code>    arr
       .map{|o| ... }
       .reject{|o| ...}
       .reduce(init_acculm){|init_acculm, o| ...}
</code></pre>
are super super clean and expressive. Very similar to what I like about Java streams.<p>And the library ecosystem is great, I like how it shares spiritual similarities with python where libraries are very &quot;no nonsense&quot; (you don&#x27;t need extensive configuration and builders and researching a million configuration items etc etc... looking at you, Java) and you typically just import and go. Rails, of course.<p>I keep picking python over ruby though, for things I&#x27;m going to have to actually maintain. And I typically pick Java over python if I smell I&#x27;m going to care even an iota about performance. (Often I don&#x27;t, though). But ruby vs python, I keep coming back to the divergent opinions they&#x27;ve taken on gradual typing. I like that python3 lets you include the types as part of the program, part of the grammar. Ruby relegates them to a separate file. I guess the intent is that it&#x27;s more for libraries, like how js libs will ship typescript type files? But I don&#x27;t like that, I want types for myself. Sorbet exists, of course, but I don&#x27;t like that it&#x27;s a) a gem and b) still not a first-class part of the grammar but is instead just operating &quot;in-language&quot;. I know it works and e.g. Stripe uses it to great effect (I worked there) but I just don&#x27;t like it, personally, and I find that python3 with its built-in type hinting tends to get typed more readily than ruby where it&#x27;s a much further reach away.<p>But I really love ruby. I hope it improves its type-hinting story because I like most other things about it. But I was pretty unenthusiastic about python prior to it getting its type hinting built-in, so apparently this is a big deal for me.</div><br/><div id="38689190" class="c"><input type="checkbox" id="c-38689190" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#38689147">parent</a><span>|</span><a href="#38690977">next</a><span>|</span><label class="collapse" for="c-38689190">[-]</label><label class="expand" for="c-38689190">[10 more]</label></div><br/><div class="children"><div class="content">Blocks and `yield` are a killer feature; I regularly pick Python over Ruby for similar reasons as you, but I consistently find myself missing those two (and all the things that get built out of them, like the `Iterator` APIs).<p>Python is a lovely language, but context managers often feel like a shabby substitute for what I can do with `yield` in Ruby :-)</div><br/><div id="38689474" class="c"><input type="checkbox" id="c-38689474" checked=""/><div class="controls bullet"><span class="by">endgame</span><span>|</span><a href="#38689147">root</a><span>|</span><a href="#38689190">parent</a><span>|</span><a href="#38692439">next</a><span>|</span><label class="collapse" for="c-38689474">[-]</label><label class="expand" for="c-38689474">[6 more]</label></div><br/><div class="children"><div class="content">This is basically how I feel about true first-class functions when I have to wrangle ruby and care about blocks, procs, and lambdas.</div><br/><div id="38689522" class="c"><input type="checkbox" id="c-38689522" checked=""/><div class="controls bullet"><span class="by">MichaelDickens</span><span>|</span><a href="#38689147">root</a><span>|</span><a href="#38689474">parent</a><span>|</span><a href="#38692439">next</a><span>|</span><label class="collapse" for="c-38689522">[-]</label><label class="expand" for="c-38689522">[5 more]</label></div><br/><div class="children"><div class="content">I love the syntax of Ruby blocks (IMO it&#x27;s the best syntax for higher-order functions in any language) but I don&#x27;t understand why they were implemented the way they are, where some things are blocks, some things are procs, and neither one is really a function. I would prefer if Ruby blocks were just functions.</div><br/><div id="38693337" class="c"><input type="checkbox" id="c-38693337" checked=""/><div class="controls bullet"><span class="by">vidarh</span><span>|</span><a href="#38689147">root</a><span>|</span><a href="#38689522">parent</a><span>|</span><a href="#38691440">next</a><span>|</span><label class="collapse" for="c-38693337">[-]</label><label class="expand" for="c-38693337">[1 more]</label></div><br/><div class="children"><div class="content">Blocks are Proc objects whenever you take their value, and it&#x27;s only an implementation dependent optimization that they are not that all the time in MRI.<p>Ruby <i>doesn&#x27;t have</i> functions <i>at all</i> - it has objects with methods, and you can treat a block as an object whenever you want.</div><br/></div></div><div id="38691440" class="c"><input type="checkbox" id="c-38691440" checked=""/><div class="controls bullet"><span class="by">jez</span><span>|</span><a href="#38689147">root</a><span>|</span><a href="#38689522">parent</a><span>|</span><a href="#38693337">prev</a><span>|</span><a href="#38691190">next</a><span>|</span><label class="collapse" for="c-38691440">[-]</label><label class="expand" for="c-38691440">[1 more]</label></div><br/><div class="children"><div class="content">Not saying it’s the optimal choice in the languages design spectrum, but it is a little defensible:<p>If you’re prototyping a new interpreted language and don’t want to have to build a JIT that can optimize code, but still want some semblance of good performance, the block approach Ruby picks can be pretty useful.<p>Ruby doesn’t haven to allocate a full-on, garbage-collected, closure object every time a function accepts a block: it only has to do this if the block gets stored to a variable. If the block is only ever yield’d to, the allocation can be skipped.<p>And when your language’s primary looping mechanism is done with blocks, the difference adds up:<p><pre><code>    xs.each do |ys|
      # with normal closures and no fancy JIT,
      # the VM has to allocate a closure once per loop:
      ys.each do |y|
      end
    end
</code></pre>
Ruby was able to get away with its closure-heavy standard library APIs without a JIT for almost 3 decades because of the affordances that blocks provide over procs&#x2F;lambdas.</div><br/></div></div><div id="38691190" class="c"><input type="checkbox" id="c-38691190" checked=""/><div class="controls bullet"><span class="by">zoky</span><span>|</span><a href="#38689147">root</a><span>|</span><a href="#38689522">parent</a><span>|</span><a href="#38691440">prev</a><span>|</span><a href="#38692439">next</a><span>|</span><label class="collapse" for="c-38691190">[-]</label><label class="expand" for="c-38691190">[2 more]</label></div><br/><div class="children"><div class="content">You can convert between blocks and Procs very easily. Ruby has several methods to let you do that, both as syntax and as methods. They are really two sides of the same coin; a block can be thought of as a Proc that is intended for immediate usage (though this is convention, and of course nothing prevents you from converting a block into a Proc and stashing it away for later).<p>As for functions, Ruby doesn’t really have them—or, rather, blocks and Procs really are the closest you get to a function. Instead, since everything is an object, Ruby has methods instead of functions. Critically, because methods are defined on objects they have inherent object context, which is why you can’t treat a defined method as an anonymous function. Of course, there are ways to extract the method as a Proc and pass it to another object (with or without its object context). But having methods be objects the way they are in, for example, JavaScript would require extra magic under the hood, and lead to all sorts of context gotchas, which is probably why it doesn’t work that way.</div><br/><div id="38692468" class="c"><input type="checkbox" id="c-38692468" checked=""/><div class="controls bullet"><span class="by">djur</span><span>|</span><a href="#38689147">root</a><span>|</span><a href="#38691190">parent</a><span>|</span><a href="#38692439">next</a><span>|</span><label class="collapse" for="c-38692468">[-]</label><label class="expand" for="c-38692468">[1 more]</label></div><br/><div class="children"><div class="content">In 15+ years of writing Ruby for production I can&#x27;t think of a single time where the distinction between blocks and procs caused a problem. Blocks are a syntactic element, procs are a data type (that you can construct with a block). I honestly don&#x27;t even know where the problem is supposed to come from.</div><br/></div></div></div></div></div></div></div></div><div id="38692439" class="c"><input type="checkbox" id="c-38692439" checked=""/><div class="controls bullet"><span class="by">nrclark</span><span>|</span><a href="#38689147">root</a><span>|</span><a href="#38689190">parent</a><span>|</span><a href="#38689474">prev</a><span>|</span><a href="#38690977">next</a><span>|</span><label class="collapse" for="c-38692439">[-]</label><label class="expand" for="c-38692439">[3 more]</label></div><br/><div class="children"><div class="content">Is Ruby&#x27;s &quot;yield&quot; different than Python&#x27;s &quot;yield&quot;? I use Python generators all the time, and I think they&#x27;re the bee&#x27;s knees.</div><br/><div id="38692530" class="c"><input type="checkbox" id="c-38692530" checked=""/><div class="controls bullet"><span class="by">NegativeLatency</span><span>|</span><a href="#38689147">root</a><span>|</span><a href="#38692439">parent</a><span>|</span><a href="#38692695">next</a><span>|</span><label class="collapse" for="c-38692530">[-]</label><label class="expand" for="c-38692530">[1 more]</label></div><br/><div class="children"><div class="content">It’s kinda different although you can do some similar things.<p>IMO the ruby one is more powerful because it effectively allows you to customize language syntax by supplying a block. And it fits nicely with the stdlib and libraries (ex map yields to a block to do the mapping). Ruby also has an enumerator that does some similar things to pythons yield: <a href="https:&#x2F;&#x2F;docs.ruby-lang.org&#x2F;en&#x2F;master&#x2F;Enumerator.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.ruby-lang.org&#x2F;en&#x2F;master&#x2F;Enumerator.html</a><p>Pythons yield is more commonly used for iteration and stuff although it does allow some neat tricks for scoping things.</div><br/></div></div><div id="38692695" class="c"><input type="checkbox" id="c-38692695" checked=""/><div class="controls bullet"><span class="by">thomasz</span><span>|</span><a href="#38689147">root</a><span>|</span><a href="#38692439">parent</a><span>|</span><a href="#38692530">prev</a><span>|</span><a href="#38690977">next</a><span>|</span><label class="collapse" for="c-38692695">[-]</label><label class="expand" for="c-38692695">[1 more]</label></div><br/><div class="children"><div class="content">Completely different. Ruby‘s yield calls a block, which is basically an anonymous method with some special syntax tacked on.</div><br/></div></div></div></div></div></div><div id="38690977" class="c"><input type="checkbox" id="c-38690977" checked=""/><div class="controls bullet"><span class="by">dbalatero</span><span>|</span><a href="#38689147">parent</a><span>|</span><a href="#38689190">prev</a><span>|</span><a href="#38690966">next</a><span>|</span><label class="collapse" for="c-38690977">[-]</label><label class="expand" for="c-38690977">[3 more]</label></div><br/><div class="children"><div class="content">I also worked at Stripe, and loved Sorbet-ified (typed) Ruby, but any time I&#x27;d recommend it to a friend it would fail to work in their project out of the box. I think it works really well on Stripe&#x27;s codebase, and might work on another one if you have what it takes to wrestle with it. And aren&#x27;t ahead of Stripe on Ruby versions…</div><br/><div id="38691873" class="c"><input type="checkbox" id="c-38691873" checked=""/><div class="controls bullet"><span class="by">ecshafer</span><span>|</span><a href="#38689147">root</a><span>|</span><a href="#38690977">parent</a><span>|</span><a href="#38690966">next</a><span>|</span><label class="collapse" for="c-38691873">[-]</label><label class="expand" for="c-38691873">[2 more]</label></div><br/><div class="children"><div class="content">Sorbet works well on Shopify&#x27;s codebase. We are basically always on the new version of Ruby and Rails both. Sorbet wasn&#x27;t a huge effort to get working on the code I work on, but its been mostly easy keeping going.</div><br/><div id="38692624" class="c"><input type="checkbox" id="c-38692624" checked=""/><div class="controls bullet"><span class="by">grogenaut</span><span>|</span><a href="#38689147">root</a><span>|</span><a href="#38691873">parent</a><span>|</span><a href="#38690966">next</a><span>|</span><label class="collapse" for="c-38692624">[-]</label><label class="expand" for="c-38692624">[1 more]</label></div><br/><div class="children"><div class="content">question, first glance sorbet looks like an awkward version of typing syntax wise that makes ruby look like other languages. At that point what still stands out about ruby that makes it still great with a lot of type overhead? I did ruby &#x2F; rails for years and enjoyed int. Just wondering.</div><br/></div></div></div></div></div></div><div id="38690966" class="c"><input type="checkbox" id="c-38690966" checked=""/><div class="controls bullet"><span class="by">cardanome</span><span>|</span><a href="#38689147">parent</a><span>|</span><a href="#38690977">prev</a><span>|</span><a href="#38691674">next</a><span>|</span><label class="collapse" for="c-38690966">[-]</label><label class="expand" for="c-38690966">[4 more]</label></div><br/><div class="children"><div class="content">Honestly, I think both Python and Ruby have a subpar gradual typing story.<p>The problem is that Python type hints are not enforced at runtime. They can can not be trusted. You have to rely on external type checkers that are relatively slow and different checker might give you different results.<p>Probably the only mainstream backend-language getting gradual typing right is PHP. Yes, good old PHP. Dead simple type system, no productivity-sucking compile step like in Typescript, actual runtime enforcement of types contrary to Python and great static linting.<p>Though PHP is also a fair bit less expressive and dynamic compared to both Python and Ruby so it can get away with an much simpler type system.  Then again, as someone who has to work with many legacy systems, sometimes I am very grateful for the lower expressiveness.</div><br/><div id="38691168" class="c"><input type="checkbox" id="c-38691168" checked=""/><div class="controls bullet"><span class="by">atomicnumber3</span><span>|</span><a href="#38689147">root</a><span>|</span><a href="#38690966">parent</a><span>|</span><a href="#38691680">next</a><span>|</span><label class="collapse" for="c-38691168">[-]</label><label class="expand" for="c-38691168">[1 more]</label></div><br/><div class="children"><div class="content">Y&#x27;know it&#x27;s weird but it&#x27;s never bothered me too much that python type hints don&#x27;t do anything at runtime. It&#x27;s enough to just know what someone, at some point, intended. (And PyCharm is pretty good about pointing out when they&#x27;re wrong, anyway). I guess when it comes down to it, given we&#x27;re not statically typing, I still get an awful lot of mileage out of just knowing when my assumptions about the code conflict with someone else&#x27;s assumptions about the code (even if that other person is subtly wrong, like anystr vs str or something).<p>Sorbet has a runtime time-checking mode I think, too, so that&#x27;s actually a point in favor to ruby for you (though again with the drawbacks I mentioned of being a gem and imo being a little clunky syntax-wise).</div><br/></div></div><div id="38691680" class="c"><input type="checkbox" id="c-38691680" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#38689147">root</a><span>|</span><a href="#38690966">parent</a><span>|</span><a href="#38691168">prev</a><span>|</span><a href="#38691674">next</a><span>|</span><label class="collapse" for="c-38691680">[-]</label><label class="expand" for="c-38691680">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Ruby have a subpar gradual typing story<p>Whether you agree with it or not Ruby&#x27;s (the language not the developers) resistance to static typing is just how Ruby wants to be written. There are no types, only messages. The whole culture surrounding Ruby is burying all the underlying data in favor of pure message-passing nirvana. I have no ducks but I must quack.</div><br/><div id="38692501" class="c"><input type="checkbox" id="c-38692501" checked=""/><div class="controls bullet"><span class="by">djur</span><span>|</span><a href="#38689147">root</a><span>|</span><a href="#38691680">parent</a><span>|</span><a href="#38691674">next</a><span>|</span><label class="collapse" for="c-38692501">[-]</label><label class="expand" for="c-38692501">[1 more]</label></div><br/><div class="children"><div class="content">This is partially true, but a pretty large chunk of idiomatic Ruby is focused on Enumerable method chaining, transforming arrays and hashes, slicing and dicing strings, etc. A language that was totally dedicated to message-passing nirvana wouldn&#x27;t have regexes as a built-in data type with a literal syntax (or dictionaries, ranges, and so on)</div><br/></div></div></div></div></div></div><div id="38691674" class="c"><input type="checkbox" id="c-38691674" checked=""/><div class="controls bullet"><span class="by">usefulcat</span><span>|</span><a href="#38689147">parent</a><span>|</span><a href="#38690966">prev</a><span>|</span><a href="#38689221">next</a><span>|</span><label class="collapse" for="c-38691674">[-]</label><label class="expand" for="c-38691674">[1 more]</label></div><br/><div class="children"><div class="content">I also love Ruby. I&#x27;ve been using it for over 20 years now, although always in a &#x27;supporting&#x27; role--like at most maybe 5-10% of the code I write, and I definitely don&#x27;t read or write it every day.<p>I&#x27;ve also never written anything particularly large in it. Like around a few thousand LOC, tops, for any one tool. And at that point, I often find myself writing a lot of things like assert { foo.is_a?(Foo) } to check parameter types, because beyond a certain size I just can&#x27;t keep all the details in my head, and I don&#x27;t want to rely only on comments.<p>Guess I&#x27;m saying that even though I really love it for small things, I&#x27;m also skeptical of its ability to scale.</div><br/></div></div><div id="38689221" class="c"><input type="checkbox" id="c-38689221" checked=""/><div class="controls bullet"><span class="by">soulbadguy</span><span>|</span><a href="#38689147">parent</a><span>|</span><a href="#38691674">prev</a><span>|</span><a href="#38689332">next</a><span>|</span><label class="collapse" for="c-38689221">[-]</label><label class="expand" for="c-38689221">[2 more]</label></div><br/><div class="children"><div class="content">I agree that pipeline functional stream processing are in many case simpler and clear than weird nested loops with early exit conditions. However, besides maybe the needs for lambda expressions, this is mainly a function of good API design as opposed to something code to the language. In particular here i don&#x27;t think the niceness of this approach is related to anything core to ruby. C# with link, F# with computational expression (and haskel monadic structures) and as you mentioned java stream do the same thing and even a bit better in my opinion</div><br/><div id="38691197" class="c"><input type="checkbox" id="c-38691197" checked=""/><div class="controls bullet"><span class="by">atomicnumber3</span><span>|</span><a href="#38689147">root</a><span>|</span><a href="#38689221">parent</a><span>|</span><a href="#38689332">next</a><span>|</span><label class="collapse" for="c-38691197">[-]</label><label class="expand" for="c-38691197">[1 more]</label></div><br/><div class="children"><div class="content">Ruby&#x27;s blocks as a way to express a HOF is pretty accessible, and I like that I can switch from &quot;arr.map{|o| ... }&quot; to &quot;arr do |o| ... multiple lines ... end&quot; seamlessly, to be terse when I want to be but then be verbose when I need to be. But that&#x27;s not exclusive to Ruby, Java&#x27;s lambda syntax behaves similarly.<p>More generally, and more to your point, I think extensive use of blocks&#x2F;HOFs lends to the &quot;spirit&quot; of Ruby being a lot more functional-style than python, which iirc got lambda support late and they&#x27;re kind of ugly (I mean, you literally type lambda! almost as bad as go!).</div><br/></div></div></div></div><div id="38689332" class="c"><input type="checkbox" id="c-38689332" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#38689147">parent</a><span>|</span><a href="#38689221">prev</a><span>|</span><a href="#38692146">next</a><span>|</span><label class="collapse" for="c-38689332">[-]</label><label class="expand" for="c-38689332">[1 more]</label></div><br/><div class="children"><div class="content">You can do this in C#, F#, Rust and many other languages too with 10x better performance (in Rust in particular those usually get completely optimized away).</div><br/></div></div></div></div><div id="38692146" class="c"><input type="checkbox" id="c-38692146" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#38689147">prev</a><span>|</span><a href="#38692806">next</a><span>|</span><label class="collapse" for="c-38692146">[-]</label><label class="expand" for="c-38692146">[4 more]</label></div><br/><div class="children"><div class="content">I hate Ruby with a passion (it&#x27;s also the language I mostly use in my day job currently).<p>It&#x27;s not necessarily the language itself, which is a reasonable language, it&#x27;s the patterns that are common in the ecosystem:<p>1. Use of inheritance for code sharing. It makes it extremely hard to reason about any piece of code I am looking at. Where does the `param` variable come from? Is it injected by any ancestors of the class I&#x27;m looking at? Who knows, I have to use the debugger to find out. I cannot reason about the code without it. Of course you can use Ruby while preferring composition over inheritance, it&#x27;s just rarely done by the community. Other modern languages like Go and Rust wisely leave out inheritance for code sharing in their object model and arguably have much more readable (albeit verbose) code.<p>2. Global mutable state is everywhere. Not sure if it&#x27;s Rails architecture that encouraged using global state as request local state (until they found out that this makes concurrency hard), but Ruby codebases are full of global mutable state. It&#x27;s everywhere and again makes it hard to reason about dependencies between objects and how they interact with each other. Again, this is nothing that the language forces people to do, it&#x27;s conventions.<p>3. Overuse of meta programming. Ruby&#x27;s metaprogramming is really well done in my opinion. The problem is that lots of people
want to use it and do so in places where it doesn&#x27;t provide enough value to justify the costs. It&#x27;s an authentication library. It doesn&#x27;t need it&#x27;s own DSL.</div><br/><div id="38692997" class="c"><input type="checkbox" id="c-38692997" checked=""/><div class="controls bullet"><span class="by">ajmurmann</span><span>|</span><a href="#38692146">parent</a><span>|</span><a href="#38692309">next</a><span>|</span><label class="collapse" for="c-38692997">[-]</label><label class="expand" for="c-38692997">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Other modern languages like Go and Rust<p>Ruby&#x27;s first release was in 1995. Go in 2009.</div><br/></div></div><div id="38692309" class="c"><input type="checkbox" id="c-38692309" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#38692146">parent</a><span>|</span><a href="#38692997">prev</a><span>|</span><a href="#38692806">next</a><span>|</span><label class="collapse" for="c-38692309">[-]</label><label class="expand" for="c-38692309">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Go and Rust wisely leave out inheritance for code sharing in their object model<p>Bad news buddy:<p><a href="https:&#x2F;&#x2F;gobyexample.com&#x2F;struct-embedding" rel="nofollow noreferrer">https:&#x2F;&#x2F;gobyexample.com&#x2F;struct-embedding</a><p>At first I loved it, then quickly realized as you did that it makes code essentially unreadable.</div><br/><div id="38692455" class="c"><input type="checkbox" id="c-38692455" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#38692146">root</a><span>|</span><a href="#38692309">parent</a><span>|</span><a href="#38692806">next</a><span>|</span><label class="collapse" for="c-38692455">[-]</label><label class="expand" for="c-38692455">[1 more]</label></div><br/><div class="children"><div class="content">That is very much not inheritance. It’s literally just sugar for delegation: calls which delegate to embedded structs execute <i>in the embedded struct’s context</i>.<p>And the embedded struct has to be part of the struct definition, it can’t be snuck in by reopening the class and include-ing new bits.</div><br/></div></div></div></div></div></div><div id="38692806" class="c"><input type="checkbox" id="c-38692806" checked=""/><div class="controls bullet"><span class="by">oglop</span><span>|</span><a href="#38692146">prev</a><span>|</span><a href="#38689083">next</a><span>|</span><label class="collapse" for="c-38692806">[-]</label><label class="expand" for="c-38692806">[1 more]</label></div><br/><div class="children"><div class="content">Maintaining Ruby is a nightmare. Trying to escape that hell now.<p>I do like Ruby for my own projects. But I hate working on Ruby with others. It becomes more messy faster and then all that supposed “getting out of your way” goes out the window and you have to know about 9 objects, one of which is an iceberg which will need to quack at some point.<p>Overall, it obliterates a programmers ability at local reasoning in code, which is where I really want speed.</div><br/></div></div><div id="38689083" class="c"><input type="checkbox" id="c-38689083" checked=""/><div class="controls bullet"><span class="by">soulbadguy</span><span>|</span><a href="#38692806">prev</a><span>|</span><a href="#38688968">next</a><span>|</span><label class="collapse" for="c-38689083">[-]</label><label class="expand" for="c-38689083">[20 more]</label></div><br/><div class="children"><div class="content">It&#x27;s interesting how different languages resonate so differently with each of us. I have tried a bunch of languages, and got pretty deep into ruby at one point in time when rails was the main web framework i was using. However ruby is probably my least favorite language. Most of the features which actually make ruby unique are exactly the one that turned me away and toward something like F# when i want funtional goodness, C++ when i feel adventurous and scheme&#x2F;racket when i want dynamic language fix.<p>&gt; Ruby is probably the most expressive programming language on Earth<p>I wonder if there is a generally accepted quantifiable definition of programming language expressiveness. Here the author seems to equate it to closeness to natural languages.<p>In my experience, ruby code is easy to write, but hard to follow without being familiar with the code base and it&#x27;s idom. A lot of the information required to understand it is passed through implicit context.</div><br/><div id="38689135" class="c"><input type="checkbox" id="c-38689135" checked=""/><div class="controls bullet"><span class="by">haolez</span><span>|</span><a href="#38689083">parent</a><span>|</span><a href="#38690853">next</a><span>|</span><label class="collapse" for="c-38689135">[-]</label><label class="expand" for="c-38689135">[11 more]</label></div><br/><div class="children"><div class="content">On the other hand, I find it extremely difficult to follow C# code. It&#x27;s a lot of type gymnastics and dependency injection noise that makes it hard to understand where&#x27;s the actual business logic.</div><br/><div id="38689260" class="c"><input type="checkbox" id="c-38689260" checked=""/><div class="controls bullet"><span class="by">soulbadguy</span><span>|</span><a href="#38689083">root</a><span>|</span><a href="#38689135">parent</a><span>|</span><a href="#38691130">next</a><span>|</span><label class="collapse" for="c-38689260">[-]</label><label class="expand" for="c-38689260">[2 more]</label></div><br/><div class="children"><div class="content">Agree. However i think this is mainly an artifact of API&#x2F;framework designed in the 2000 and 2010 with over-enginered and over used designed patterns from the GOF. Both java and C# have their root deep in enterprise land were those are still sadly too common.<p>Modern framework are a bit better.</div><br/><div id="38690701" class="c"><input type="checkbox" id="c-38690701" checked=""/><div class="controls bullet"><span class="by">haolez</span><span>|</span><a href="#38689083">root</a><span>|</span><a href="#38689260">parent</a><span>|</span><a href="#38691130">next</a><span>|</span><label class="collapse" for="c-38690701">[-]</label><label class="expand" for="c-38690701">[1 more]</label></div><br/><div class="children"><div class="content">And type gymnastics seem worth it on something like F#, but on C#, it feels a lot like bureaucracy with not a lot of benefit.</div><br/></div></div></div></div><div id="38691130" class="c"><input type="checkbox" id="c-38691130" checked=""/><div class="controls bullet"><span class="by">replwoacause</span><span>|</span><a href="#38689083">root</a><span>|</span><a href="#38689135">parent</a><span>|</span><a href="#38689260">prev</a><span>|</span><a href="#38690853">next</a><span>|</span><label class="collapse" for="c-38691130">[-]</label><label class="expand" for="c-38691130">[8 more]</label></div><br/><div class="children"><div class="content">I dislike C#. Too much ceremony for me. I want type safety without a ton of boilerplate. Is there any compiled language that offers this? Or languages built for the web? Go maybe? Not interested in a whitespace sensitive language though.</div><br/><div id="38693175" class="c"><input type="checkbox" id="c-38693175" checked=""/><div class="controls bullet"><span class="by">cryptos</span><span>|</span><a href="#38689083">root</a><span>|</span><a href="#38691130">parent</a><span>|</span><a href="#38691799">next</a><span>|</span><label class="collapse" for="c-38693175">[-]</label><label class="expand" for="c-38693175">[1 more]</label></div><br/><div class="children"><div class="content">I would suggest Kotlin. It is concise and readable and the language itself is a bit leaner than C# (delegates are, in my opinion somewhat redundant, if there are first-class functions, for example).</div><br/></div></div><div id="38691799" class="c"><input type="checkbox" id="c-38691799" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38689083">root</a><span>|</span><a href="#38691130">parent</a><span>|</span><a href="#38693175">prev</a><span>|</span><a href="#38692575">next</a><span>|</span><label class="collapse" for="c-38691799">[-]</label><label class="expand" for="c-38691799">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I dislike C#. Too much ceremony for me. I want type safety without a ton of boilerplate. Is there any compiled language that offers this? Or languages built for the web?<p>Scala might be what you&#x27;re looking for. (Or Haskell, but that&#x27;s a bigger leap). You can write code that looks like Python&#x2F;Ruby (some libraries are quite symbol-heavy, but you don&#x27;t have to use them; check out lihaoyi&#x27;s libraries for some Python-inspired simple interfaces), but everything&#x27;s fully typed. And it has an excellent JavaScript backend that integrates with typescript&#x2F;definitelytyped for using web libraries.</div><br/></div></div><div id="38692575" class="c"><input type="checkbox" id="c-38692575" checked=""/><div class="controls bullet"><span class="by">jinushaun</span><span>|</span><a href="#38689083">root</a><span>|</span><a href="#38691130">parent</a><span>|</span><a href="#38691799">prev</a><span>|</span><a href="#38691362">next</a><span>|</span><label class="collapse" for="c-38692575">[-]</label><label class="expand" for="c-38692575">[1 more]</label></div><br/><div class="children"><div class="content">What boilerplate? Just use var everywhere and the compiler will type it for you.<p>I think the main problem with C# is that even though you can write scripty “pythonic” C# since like 2010, people are still coding C# likes it’s early 2000s enterprise Java. The .NET library doesn’t help either, since it sets the “style guide” that many developers follow.</div><br/></div></div><div id="38691362" class="c"><input type="checkbox" id="c-38691362" checked=""/><div class="controls bullet"><span class="by">soulbadguy</span><span>|</span><a href="#38689083">root</a><span>|</span><a href="#38691130">parent</a><span>|</span><a href="#38692575">prev</a><span>|</span><a href="#38692115">next</a><span>|</span><label class="collapse" for="c-38691362">[-]</label><label class="expand" for="c-38691362">[1 more]</label></div><br/><div class="children"><div class="content">I would have say F#, but it&#x27;s white space sensitive, and sadly pretty much a dead language by now.<p>Pretty much all the new-ish language have less boiler plate than C#&#x2F;Java. Kotlin and swift are somewhat good.</div><br/></div></div><div id="38692115" class="c"><input type="checkbox" id="c-38692115" checked=""/><div class="controls bullet"><span class="by">rewgs</span><span>|</span><a href="#38689083">root</a><span>|</span><a href="#38691130">parent</a><span>|</span><a href="#38691362">prev</a><span>|</span><a href="#38691335">next</a><span>|</span><label class="collapse" for="c-38692115">[-]</label><label class="expand" for="c-38692115">[2 more]</label></div><br/><div class="children"><div class="content">Probably Go, yeah. I&#x27;m a big fan of Python and have really enjoyed learning Go.</div><br/><div id="38693195" class="c"><input type="checkbox" id="c-38693195" checked=""/><div class="controls bullet"><span class="by">cryptos</span><span>|</span><a href="#38689083">root</a><span>|</span><a href="#38692115">parent</a><span>|</span><a href="#38691335">next</a><span>|</span><label class="collapse" for="c-38693195">[-]</label><label class="expand" for="c-38693195">[1 more]</label></div><br/><div class="children"><div class="content">But would Go really reduce the &quot;ceremony&quot; compared to C#? I doubt it. Just look at Linq (functional programming APIs in C#) and compare this to the typical Go approach with auxiliary lists and for loops! Or what about error handling? Or null safety? Not that cool in Go, I think.</div><br/></div></div></div></div><div id="38691335" class="c"><input type="checkbox" id="c-38691335" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#38689083">root</a><span>|</span><a href="#38691130">parent</a><span>|</span><a href="#38692115">prev</a><span>|</span><a href="#38690853">next</a><span>|</span><label class="collapse" for="c-38691335">[-]</label><label class="expand" for="c-38691335">[1 more]</label></div><br/><div class="children"><div class="content">What kind of boilerplate are you seeing?<p>If it&#x27;s an old project, that&#x27;s a given but the culture is changing and community is slowly accepting terseness and performance as key factors to consider when writing new code.</div><br/></div></div></div></div></div></div><div id="38690853" class="c"><input type="checkbox" id="c-38690853" checked=""/><div class="controls bullet"><span class="by">davidw</span><span>|</span><a href="#38689083">parent</a><span>|</span><a href="#38689135">prev</a><span>|</span><a href="#38689336">next</a><span>|</span><label class="collapse" for="c-38690853">[-]</label><label class="expand" for="c-38690853">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s interesting how different languages resonate so differently with each of us<p>Because programming languages are, at the end of the day, for communicating with other people trying to make the computer do things. And people have different styles, ideas and preferences.<p>The computer doesn&#x27;t care; it just wants some binary code to execute.</div><br/></div></div><div id="38689336" class="c"><input type="checkbox" id="c-38689336" checked=""/><div class="controls bullet"><span class="by">uticus</span><span>|</span><a href="#38689083">parent</a><span>|</span><a href="#38690853">prev</a><span>|</span><a href="#38691113">next</a><span>|</span><label class="collapse" for="c-38689336">[-]</label><label class="expand" for="c-38689336">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I wonder if there is a generally accepted quantifiable definition of programming language expressiveness.<p>If there is such a definition it would not fit into these sorts of conversations. I love Ruby but every time I see someone mention Ruby &quot;expressiveness&quot; it is never mentioned as a subjective fact like syntax feature count. Instead it is always closely tied to emotional feeling, assumptions, and intuition. &quot;Ruby&#x27;s expressiveness means it just gets out of the way and lets me code.&quot; I&#x27;ve probably said that myself a hundred times.<p>OTOH it <i>is</i> great for DSLs and metaprogramming, gives a taste of what the LISPers have always had. Maybe that is a good definition of &quot;expressive&quot;.<p>[edit: added thought about DSLs]</div><br/></div></div><div id="38691113" class="c"><input type="checkbox" id="c-38691113" checked=""/><div class="controls bullet"><span class="by">jrumbut</span><span>|</span><a href="#38689083">parent</a><span>|</span><a href="#38689336">prev</a><span>|</span><a href="#38689129">next</a><span>|</span><label class="collapse" for="c-38691113">[-]</label><label class="expand" for="c-38691113">[2 more]</label></div><br/><div class="children"><div class="content">&gt; A lot of the information required to understand it is passed through implicit context.<p>This is the counterintuitive genius of Ruby&#x2F;Rails.<p>Ruby projects need an idiom and Rails gives you a good one. If a team knows Rails and its conventions they are a good ways toward developing a shared understanding of how to build (certain kinds of) software. You become acutely aware that writing code is an act of communication.<p>Other languages, ones with certain kinds of type systems and where there is more explicitness, can create an illusion that coders don&#x27;t need to do the work to develop a shared mental model of the problem and how to solve it. As long as it compiles, everything&#x27;s OK.<p>But I think there is always information being passed through implicit context and if it isn&#x27;t handled correctly then quality will suffer, one way or another.</div><br/><div id="38691320" class="c"><input type="checkbox" id="c-38691320" checked=""/><div class="controls bullet"><span class="by">soulbadguy</span><span>|</span><a href="#38689083">root</a><span>|</span><a href="#38691113">parent</a><span>|</span><a href="#38689129">next</a><span>|</span><label class="collapse" for="c-38691320">[-]</label><label class="expand" for="c-38691320">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Ruby projects need an idiom and Rails gives you a good one.<p>I can&#x27;t say i agree. Projects need idiom reflecting the particulars of said project. Rails as a framework, shouldn&#x27;t impose idioms to the whole project.<p>But more importantly from my view is that implicitness is not a requirement to any of the idiom that rails imposes.<p>&gt; Other languages, ones with certain kinds of type systems and where there is more explicitness, can create an illusion that coders don&#x27;t need to do the work to develop a shared mental model of the problem and how to solve it.<p>Here again, i don&#x27;t agree. I would be surprise to find any language designer trying to replace the need of a shared mental model. IMO, the point of a type system and explicitness is to make the sharing of the mental model easier. The type system make the space of possible software smaller and therefore eaiser to grasp. And explicitness reduce the need to keep things in one&#x27;s head.</div><br/></div></div></div></div><div id="38689129" class="c"><input type="checkbox" id="c-38689129" checked=""/><div class="controls bullet"><span class="by">philomath_mn</span><span>|</span><a href="#38689083">parent</a><span>|</span><a href="#38691113">prev</a><span>|</span><a href="#38692104">next</a><span>|</span><label class="collapse" for="c-38689129">[-]</label><label class="expand" for="c-38689129">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I wonder if there is a generally accepted quantifiable definition of programming language expressiveness<p>In my opinion, expressiveness is used as the catchall, je ne sais quoi whenever someone likes a language and needs another bullet point to put in the &quot;Pros&quot; column.</div><br/><div id="38689252" class="c"><input type="checkbox" id="c-38689252" checked=""/><div class="controls bullet"><span class="by">jjgreen</span><span>|</span><a href="#38689083">root</a><span>|</span><a href="#38689129">parent</a><span>|</span><a href="#38691727">next</a><span>|</span><label class="collapse" for="c-38689252">[-]</label><label class="expand" for="c-38689252">[1 more]</label></div><br/><div class="children"><div class="content">It has a certain <i>je ne sais quoi</i> but I don&#x27;t know what it is.</div><br/></div></div><div id="38691727" class="c"><input type="checkbox" id="c-38691727" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#38689083">root</a><span>|</span><a href="#38689129">parent</a><span>|</span><a href="#38689252">prev</a><span>|</span><a href="#38692104">next</a><span>|</span><label class="collapse" for="c-38691727">[-]</label><label class="expand" for="c-38691727">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that tracks because the reason people like Go is due to it&#x27;s lack of expressiveness.<p>It feels like expressiveness is the quality of a language to allow the programmer to change the behavior of the language constructs themselves. Python  __getitem__ would be a good example allowing the programmer to control [].</div><br/></div></div></div></div><div id="38692104" class="c"><input type="checkbox" id="c-38692104" checked=""/><div class="controls bullet"><span class="by">rewgs</span><span>|</span><a href="#38689083">parent</a><span>|</span><a href="#38689129">prev</a><span>|</span><a href="#38688968">next</a><span>|</span><label class="collapse" for="c-38692104">[-]</label><label class="expand" for="c-38692104">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I wonder if there is a generally accepted quantifiable definition of programming language expressiveness.<p>I doubt it, considering &quot;expressive&quot; tends to only ever describe something that&#x27;s subjective.</div><br/></div></div></div></div><div id="38688968" class="c"><input type="checkbox" id="c-38688968" checked=""/><div class="controls bullet"><span class="by">brink</span><span>|</span><a href="#38689083">prev</a><span>|</span><a href="#38689370">next</a><span>|</span><label class="collapse" for="c-38688968">[-]</label><label class="expand" for="c-38688968">[5 more]</label></div><br/><div class="children"><div class="content">After 10 years in Ruby, I moved onto Rust four years ago, and don&#x27;t plan on really looking back. But with that said, I&#x27;m glad you love Ruby! There are certainly things to love.<p>Personally, I just can&#x27;t do without a good type system anymore. I think Rust has spoiled me. I do miss Ruby&#x27;s powerful reflection features though.</div><br/><div id="38689183" class="c"><input type="checkbox" id="c-38689183" checked=""/><div class="controls bullet"><span class="by">graypegg</span><span>|</span><a href="#38688968">parent</a><span>|</span><a href="#38689428">next</a><span>|</span><label class="collapse" for="c-38689183">[-]</label><label class="expand" for="c-38689183">[1 more]</label></div><br/><div class="children"><div class="content">I think I have a few &quot;most favourite&quot; technologies that all max out some principle or idea that I like.<p>The author here really hits on exactly why Ruby is my favourite &quot;get things done&quot; language. Rust, Typescript, and Crystal are all things I&#x27;ve worked with, but nothing gets out of my way like Ruby. It feels like sketching? It&#x27;s very expressive thanks to it&#x27;s prose-y syntax, but also metaprogramming + reflection like you mentioned really makes forming an idea while developing possible, at least much more possible than most other careful correctness-ensuring paradigms.<p>There&#x27;s nuance to these things, and nothing is the best really. But I think satisfying a borrow handler or a type checker does slow down that flow for me. I&#x27;d pick up a brush if I know what I&#x27;m making for sure, but a piece of chalk if I&#x27;m just wanting to get something working. Personal taste of course!</div><br/></div></div><div id="38689428" class="c"><input type="checkbox" id="c-38689428" checked=""/><div class="controls bullet"><span class="by">tlrobinson</span><span>|</span><a href="#38688968">parent</a><span>|</span><a href="#38689183">prev</a><span>|</span><a href="#38691272">next</a><span>|</span><label class="collapse" for="c-38689428">[-]</label><label class="expand" for="c-38689428">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, when Ruby became popular it was primarily competing against languages with verbose and rigid static type systems like Java. That is no longer the case, and the benefits of safety and developer experience provided by a good type system outweighs the cost.</div><br/></div></div><div id="38691272" class="c"><input type="checkbox" id="c-38691272" checked=""/><div class="controls bullet"><span class="by">madeofpalk</span><span>|</span><a href="#38688968">parent</a><span>|</span><a href="#38689428">prev</a><span>|</span><a href="#38689130">next</a><span>|</span><label class="collapse" for="c-38691272">[-]</label><label class="expand" for="c-38691272">[1 more]</label></div><br/><div class="children"><div class="content">I think Rust is actually pretty similar to Ruby is regards to expressiveness (given their own models)</div><br/></div></div><div id="38689130" class="c"><input type="checkbox" id="c-38689130" checked=""/><div class="controls bullet"><span class="by">TOGoS</span><span>|</span><a href="#38688968">parent</a><span>|</span><a href="#38691272">prev</a><span>|</span><a href="#38689370">next</a><span>|</span><label class="collapse" for="c-38689130">[-]</label><label class="expand" for="c-38689130">[1 more]</label></div><br/><div class="children"><div class="content">Same.  I used to love Ruby because it just matched the way I thought, and the standard library was layed out in a way that was consistent and easy to remember (one reason I never got into Python was that, while batteries may be included, the naming conventions are all over the place and I found every step of using them surprising).  I fell out of love with it when 1.9 broke all my string manipulation code.  The Rails crowd pushed the &#x27;magic&#x27; stuff way farther than I was every comfortable with.  I rarely made use of reflection, but even so find my old programs buggy enough due to mishandling of edge cases that I just don&#x27;t really trust it anymore.  TypeScript&#x2F;Deno has mostly taken its place for me, though I don&#x27;t find it quite as ergonomic for little system admin tasks as Ruby was.</div><br/></div></div></div></div><div id="38689370" class="c"><input type="checkbox" id="c-38689370" checked=""/><div class="controls bullet"><span class="by">impulser_</span><span>|</span><a href="#38688968">prev</a><span>|</span><a href="#38689114">next</a><span>|</span><label class="collapse" for="c-38689370">[-]</label><label class="expand" for="c-38689370">[4 more]</label></div><br/><div class="children"><div class="content">Maybe this is just my experience, but the thing that sucks a lot about programming to me it that the most enjoyable programming languages are often the ones with the smallest job market.<p>My job as a programmer would be infinitely better if I could spend it programming Elixir all day, but there is basically no Elixir jobs compared to Typescript, Python, and Java.<p>But instead I hate my job working in Typescript all day solving problems that I wouldn&#x27;t have to if I could just use Elixir.<p>Ruby use to an exception to this, but almost no one is building on Rails anymore compared to how many people build on React, and NextJS.<p>I&#x27;m talking about full stack application market, this is probably different for Rust users for systems, and Python for Data&#x2F;AI.</div><br/><div id="38691315" class="c"><input type="checkbox" id="c-38691315" checked=""/><div class="controls bullet"><span class="by">jes5199</span><span>|</span><a href="#38689370">parent</a><span>|</span><a href="#38691224">next</a><span>|</span><label class="collapse" for="c-38691315">[-]</label><label class="expand" for="c-38691315">[1 more]</label></div><br/><div class="children"><div class="content">I used Ruby professionally in the early 2010s and that sucked all the joy out of it. Gigantic Rails monoliths in that era were just unmaintainable brambles. I probably would rather write Ruby again for side-projects but the ecosystem just isn’t there</div><br/></div></div><div id="38691224" class="c"><input type="checkbox" id="c-38691224" checked=""/><div class="controls bullet"><span class="by">briantakita</span><span>|</span><a href="#38689370">parent</a><span>|</span><a href="#38691315">prev</a><span>|</span><a href="#38689114">next</a><span>|</span><label class="collapse" for="c-38691224">[-]</label><label class="expand" for="c-38691224">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But instead I hate my job working in Typescript all day solving problems that I wouldn&#x27;t have to if I could just use Elixir.<p>Before I focused on iso js, I worked with EventMachine &amp; even a little bit of Erlang. Would love to hear more about an alternate timeline if I stuck with Ruby &amp; went down the Elixir route.<p>---<p>I used to work with Ruby &amp; switched to js before TS to build isomorphic libraries &amp; apps. TS has been beneficial imo though figuring out type inference for library code is a steep &amp; time consuming learning curve &amp; takes experience to figure out the edge cases. In the end though, having type inference work in library code is worthwhile for quickly developing apps. Re: expressiveness, the js&#x2F;ts ecosystem suffers from mostly using camelCase, which has variable casing depending on the position of the name segment...which makes project wide searches for composed abstractions less reliable. I distilled the &quot;tag vector&quot; name convention to address this issue. Granted, Ruby having `?` &amp; `!` available is as a terse &amp; explicit expression of intent is nice.<p>&gt; almost no one is building on Rails anymore compared to how many people build on React, and NextJS.<p>I got burnt out on Rails after the 3rd consecutive upgrade project for large codebases. I think the dominance of React has been detrimental to the js ecosystem as its bloated with the api being complex &amp; unintuitive. It also took the JS framework guys a decade to figure out the MPAs are the way to go. I hoped people would have figured that out sooner. I got tired of the complexity &amp; size of the reactive state management &amp; ui libraries &amp; recently wrote my own (rmemo &amp; relementjs). I working on a vite alternative called rebuildjs with an Elysia&#x2F;bun based app library called relysjs.<p>I loved how many Ruby community (other than Rails) had a commitment to create simple libraries. It seems like js framework communities have this drive to lock developers into their complex manifestations.<p>Sorry about the long comment. I have to get back to a major version update to ctx-core (general purpose contexts &amp; utility functions) addressing type inference...which will make developing apps with these libraries more reliable &amp; effective.<p><a href="https:&#x2F;&#x2F;www.briantakita.me&#x2F;posts&#x2F;tag-vector-1-tag-vector-convention" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.briantakita.me&#x2F;posts&#x2F;tag-vector-1-tag-vector-con...</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;ctx-core&#x2F;rmemo">https:&#x2F;&#x2F;github.com&#x2F;ctx-core&#x2F;rmemo</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;relementjs&#x2F;relementjs">https:&#x2F;&#x2F;github.com&#x2F;relementjs&#x2F;relementjs</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;rebuildjs&#x2F;rebuildjs">https:&#x2F;&#x2F;github.com&#x2F;rebuildjs&#x2F;rebuildjs</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;relysjs&#x2F;relysjs">https:&#x2F;&#x2F;github.com&#x2F;relysjs&#x2F;relysjs</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;ctx-core&#x2F;ctx-core">https:&#x2F;&#x2F;github.com&#x2F;ctx-core&#x2F;ctx-core</a></div><br/><div id="38691582" class="c"><input type="checkbox" id="c-38691582" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#38689370">root</a><span>|</span><a href="#38691224">parent</a><span>|</span><a href="#38689114">next</a><span>|</span><label class="collapse" for="c-38691582">[-]</label><label class="expand" for="c-38691582">[1 more]</label></div><br/><div class="children"><div class="content">The power of Elixir is not in the syntax, it’s the BEAM, OTP, and the fact that you can launch a million processes on a single node that all have their own soft realtime behavior with their own state. Supervision trees, processes that can crash and be restarted without taking the app down, first class messaging across nodes&#x2F;networks&#x2F;continents, rolling deploys without restarts… if you are a true systems engineer thinker there is no better runtime.</div><br/></div></div></div></div></div></div><div id="38689114" class="c"><input type="checkbox" id="c-38689114" checked=""/><div class="controls bullet"><span class="by">akprasad</span><span>|</span><a href="#38689370">prev</a><span>|</span><a href="#38689573">next</a><span>|</span><label class="collapse" for="c-38689114">[-]</label><label class="expand" for="c-38689114">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m glad that the author enjoys Ruby! As someone with limited Ruby exposure, these quotes stood out to me:<p>&gt; The language is meant be joyful to use. [...] Everything else that Ruby is stems from this value.<p>This is important and underrated. I think many programmers have a bias that working on a difficult problem entails using a &quot;real&quot; programming language with sharp edges. I had some version of this bias for a long time until I started exploring the most recent generation of systems languages.<p>&gt; Well written ruby code can often read like natural language.<p>I see where the author is coming from, but I find a healthy dollop of symbols to be very helpful for reading and understanding code at a glance.<p>&gt; Feeling recognition in the language you’re programming is so powerful.<p>This is the feeling I had the first time I used Python, and later Rust. It&#x27;s a wonderful feeling!<p>&gt; [As] Kent Beck said at RailsConf in 2020, “Software design is an exercise in human relationships.”<p>Especially true given all of the components involved in supporting a language: compiler, docs, standard library, third-party libraries, package managers, frameworks, formatters, profilers, ...</div><br/></div></div><div id="38689573" class="c"><input type="checkbox" id="c-38689573" checked=""/><div class="controls bullet"><span class="by">shaftway</span><span>|</span><a href="#38689114">prev</a><span>|</span><a href="#38691877">next</a><span>|</span><label class="collapse" for="c-38689573">[-]</label><label class="expand" for="c-38689573">[10 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know Ruby at all, and maybe some familiarity with the language would help, but the biggest example code makes absolutely zero sense to me:<p><pre><code>    RSpec.describe Ticket do
      context &#x27;when the ticket is closed&#x27; do
        it &#x27;emails the requestor with a confirmation&#x27; do
          ...
        end
      end
    end
</code></pre>
I have no idea what&#x27;s going on here.<p>I get that there are some blocks of code, though it was the indentation that told me that; &quot;do&quot; and &quot;end&quot; feel super verbose and bleed into the important parts of the code for me.<p>Why is Ticket capitalized? Is this a variable? An object that we&#x27;re about to work on that&#x27;s coming into scope?<p>`context `when the ticket is closed&#x27;` feels like it&#x27;s setting me up. Is this an if block? Or is it some fancy way to set a listener on a property? Is this setting up a callback that&#x27;ll persist across runs of the program? Or is this just a method named with spaces that could do anything?<p>`it &#x27;emails the requestor with a confirmation&#x27;` has got to just be a method name. But what is &quot;it&quot;? What was &quot;context&quot; in the previous one? And why does &quot;emails the requestor with a confirmation&quot; need to be a block? What happens in there? Is this just setting up some kind of call stack like thing that provides context all the way down?<p>None of this is intuitive. And the impression that I get is that the author is calling methods with spaces in their names and unclear block semantics &quot;expressiveness&quot;.</div><br/><div id="38689713" class="c"><input type="checkbox" id="c-38689713" checked=""/><div class="controls bullet"><span class="by">jabbawookiees</span><span>|</span><a href="#38689573">parent</a><span>|</span><a href="#38690943">next</a><span>|</span><label class="collapse" for="c-38689713">[-]</label><label class="expand" for="c-38689713">[1 more]</label></div><br/><div class="children"><div class="content">Ticket is a class<p>do ... end is how you create no-argument functions similar to  () =&gt; { ... } in JavaScript. There&#x27;s some technical nuance but that&#x27;s the spirit of it.<p>In Ruby you can call methods without needing to place parentheses.<p>So this roughly translates to the JavaScript code:<p>RSpec.describe(Ticket, () =&gt; {<p><pre><code>  context(&#x27;when...&#x27;, () =&gt; {
    ...
  });
</code></pre>
});<p>This specific code describes a test that uses the RSpec testing framework. In RSpec, &quot;context&quot; and &quot;it&quot; are just functions that you call to describe chunks of tests and individual tests respectively.<p>Some Rubyists would say that the combination of these syntax rules (do-end and optional parentheses for function calls) allow you to make &quot;domain specific languages&quot; (DSLs as they&#x27;re known in the community) without needing to write your own parser.<p>I think it&#x27;s pretty plain to see the impact in expressiveness if you look at the equivalent Python unittest suite. The Python equivalent would have classes that inherit unittest.TestCase and methods named like test_when_ticket_is_closed.<p>In Python land, classes and method declarations are repurposed because the syntax is what it is. In Ruby, you can practically make your own faux keywords by abusing do-end to accept nested blocks.</div><br/></div></div><div id="38690943" class="c"><input type="checkbox" id="c-38690943" checked=""/><div class="controls bullet"><span class="by">filleduchaos</span><span>|</span><a href="#38689573">parent</a><span>|</span><a href="#38689713">prev</a><span>|</span><a href="#38692584">next</a><span>|</span><label class="collapse" for="c-38690943">[-]</label><label class="expand" for="c-38690943">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I have no idea what&#x27;s going on here.<p>&gt; ...<p>&gt; None of this is intuitive.<p>Why would anyone expect that a highly-context-dependent code snippet (in this case, a test suite written in the testing framework&#x27;s DSL in a language that they both don&#x27;t know <i>and</i> is different from the languages they usually write) would be &quot;intuitive&quot;?<p>Frankly I feel like many programming language discussions are tainted by the participants tying their own intelligence to whether or not they can understand something at first glance (and if they can&#x27;t, it must &quot;obviously&quot; be the thing that is wrong). This makes about as much sense to me as concluding that my utter confusion when glancing at a page of Portuguese poetry is somehow a problem with the language itself.</div><br/><div id="38692069" class="c"><input type="checkbox" id="c-38692069" checked=""/><div class="controls bullet"><span class="by">shaftway</span><span>|</span><a href="#38689573">root</a><span>|</span><a href="#38690943">parent</a><span>|</span><a href="#38692584">next</a><span>|</span><label class="collapse" for="c-38692069">[-]</label><label class="expand" for="c-38692069">[2 more]</label></div><br/><div class="children"><div class="content">Oh yeah, that&#x27;s easy. I don&#x27;t expect to be able to follow &quot;highly-context-dependent&quot; code snippets.<p>The codebase I work on has a bunch of Ruby scripts with &quot;highly-context-dependent&quot; bits of code in them that I have to occasionally dive into to find out why they&#x27;re failing.<p>Elsewhere in this thread people are complaining about how few Ruby jobs there are. I&#x27;m eliminating one of those jobs.<p>I replace each script with Python, or Java &#x2F; Kotlin. I don&#x27;t have the time to learn about all of these contexts. And I can&#x27;t afford to hire people who want to specialize in Ruby. And typical engineers can&#x27;t intuit about them, so nobody can properly support them. But those engineers can typically intuit between Java and Python just fine.<p>I understand that there is Portuguese poetry and that I may not understand it. But I don&#x27;t mix it into a book of English poetry.</div><br/><div id="38692515" class="c"><input type="checkbox" id="c-38692515" checked=""/><div class="controls bullet"><span class="by">djur</span><span>|</span><a href="#38689573">root</a><span>|</span><a href="#38692069">parent</a><span>|</span><a href="#38692584">next</a><span>|</span><label class="collapse" for="c-38692515">[-]</label><label class="expand" for="c-38692515">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re replacing Ruby scripts at work but you couldn&#x27;t understand the syntax of the Ruby excerpt above?</div><br/></div></div></div></div></div></div><div id="38692584" class="c"><input type="checkbox" id="c-38692584" checked=""/><div class="controls bullet"><span class="by">phaedryx</span><span>|</span><a href="#38689573">parent</a><span>|</span><a href="#38690943">prev</a><span>|</span><a href="#38690787">next</a><span>|</span><label class="collapse" for="c-38692584">[-]</label><label class="expand" for="c-38692584">[1 more]</label></div><br/><div class="children"><div class="content">RSpec is a domain-specific language for testing written in Ruby. It isn&#x27;t a great example of vanilla Ruby, in my opinion.</div><br/></div></div><div id="38690787" class="c"><input type="checkbox" id="c-38690787" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#38689573">parent</a><span>|</span><a href="#38692584">prev</a><span>|</span><a href="#38690765">next</a><span>|</span><label class="collapse" for="c-38690787">[-]</label><label class="expand" for="c-38690787">[1 more]</label></div><br/><div class="children"><div class="content">The syntax never bothers me (I wrote a lot of Perl code in my youth, after all), but the semantics sometimes does.<p>I can mentally parse this (Ticket is a class name, context and it are methods that accept blocks, etc etc), but I have real hard time finding where this stuff is actually defined to see how it works underneath. And I always peek under the hood for the implementation nuances - documentation is always incomplete, so frameworks&#x27; and libraries&#x27; source code is my go-to documentation.<p>In other languages, imports are explicit and are local to file (and people outside of ML and quick-and-dirty one-off scripting tend to recommend breaking one&#x27;s fingers for a heresy of `from foo import *` - with some obvious exceptions, of course), so I always can see where exactly stuff comes from.<p>In Ruby world there&#x27;s this weird love for autoloaders, or some sort helper.rb with tons of require&#x2F;include directives and so on, so very rarely I see a Ruby code that links stuff explicitly. Paired with extreme commonality of metaprogramming, reopening classes to extend them, all paired with the dynamic nature of the language, this kind of irks me as ideologically &quot;wrong&quot; (as in &quot;not to my liking&quot;).<p>Surely, modern IDEs sort of figure out most of the stuff, but I was trying out Ruby quite a long time ago, before language servers and stuff became mainstream and widespread, and still can&#x27;t shake off this impression.</div><br/></div></div><div id="38690765" class="c"><input type="checkbox" id="c-38690765" checked=""/><div class="controls bullet"><span class="by">rdoherty</span><span>|</span><a href="#38689573">parent</a><span>|</span><a href="#38690787">prev</a><span>|</span><a href="#38689623">next</a><span>|</span><label class="collapse" for="c-38690765">[-]</label><label class="expand" for="c-38690765">[2 more]</label></div><br/><div class="children"><div class="content">Yeah tbh after working with Ruby for nearly 2 decades now and with a handful of other languages I think Ruby could use some parentheses and other common symbols. It really is too easy to create what are DSLs which requires learning another language and layer of abstraction.</div><br/><div id="38692521" class="c"><input type="checkbox" id="c-38692521" checked=""/><div class="controls bullet"><span class="by">djur</span><span>|</span><a href="#38689573">root</a><span>|</span><a href="#38690765">parent</a><span>|</span><a href="#38689623">next</a><span>|</span><label class="collapse" for="c-38692521">[-]</label><label class="expand" for="c-38692521">[1 more]</label></div><br/><div class="children"><div class="content">You can always use parentheses for method calls. I&#x27;ve worked on codebases that mandated it. It feels a little weird in some contexts but it&#x27;s fine.</div><br/></div></div></div></div><div id="38689623" class="c"><input type="checkbox" id="c-38689623" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#38689573">parent</a><span>|</span><a href="#38690765">prev</a><span>|</span><a href="#38691877">next</a><span>|</span><label class="collapse" for="c-38689623">[-]</label><label class="expand" for="c-38689623">[1 more]</label></div><br/><div class="children"><div class="content">It’s a unit testing DSL for setting up a tree of preconditions &#x2F; setup.</div><br/></div></div></div></div><div id="38693025" class="c"><input type="checkbox" id="c-38693025" checked=""/><div class="controls bullet"><span class="by">hschne</span><span>|</span><a href="#38691877">prev</a><span>|</span><a href="#38692043">next</a><span>|</span><label class="collapse" for="c-38693025">[-]</label><label class="expand" for="c-38693025">[1 more]</label></div><br/><div class="children"><div class="content">Interesting that the discussion here focuses so much on the actual language.<p>I think the language is fine, but the thing that really makes me stick with Ruby is the ecosystem and the culture it fosters. The article also makes that point.<p>I have yet to see a programming community (around a language) that is as encouraging and nice as the one around Ruby.</div><br/></div></div><div id="38692043" class="c"><input type="checkbox" id="c-38692043" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#38693025">prev</a><span>|</span><a href="#38689140">next</a><span>|</span><label class="collapse" for="c-38692043">[-]</label><label class="expand" for="c-38692043">[1 more]</label></div><br/><div class="children"><div class="content">I liked Ruby when I first encountered it because it felt like a scriptable Smalltalk that plays nicely with friends.<p>Then I accidentally learned Python one afternoon and never thought about Ruby again. I&#x27;m sure Ruby is better than Python in dozens of ways, much as alternate keyboard layouts are better than QWERTY (and Rails is probably better than Django.)  And I&#x27;m still mad at Python for setting fire to billions of lines of 2.7 code that people had written. But I&#x27;m still using Python.</div><br/></div></div><div id="38689140" class="c"><input type="checkbox" id="c-38689140" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#38692043">prev</a><span>|</span><a href="#38689585">next</a><span>|</span><label class="collapse" for="c-38689140">[-]</label><label class="expand" for="c-38689140">[7 more]</label></div><br/><div class="children"><div class="content">The blog post (and Ruby&#x27;s) emphasis on programmer happiness really resonates with me: other than Rust (which induces programmer happiness for fairly different reasons), I&#x27;ve seldom run into a programming language and ecosystem that tries so <i>hard</i> to make programming mirthful.<p>(Does that make Ruby a <i>good</i> programming language? That&#x27;s unclear to me; what&#x27;s clear is that I have fun writing it.)</div><br/><div id="38691355" class="c"><input type="checkbox" id="c-38691355" checked=""/><div class="controls bullet"><span class="by">imnotreallynew</span><span>|</span><a href="#38689140">parent</a><span>|</span><a href="#38690611">next</a><span>|</span><label class="collapse" for="c-38691355">[-]</label><label class="expand" for="c-38691355">[2 more]</label></div><br/><div class="children"><div class="content">There’s a lot of praise for Rust in these comments.<p>I always understood Rust to be for low level “close to the metal” sort of software. Is it at a point where it’s suitable for writing web applications?<p>I know it’s “possible” with frameworks like Rocket, but I’d like to know if Rust is at a point where it can compete in the web app space with Rails, Go, Node&#x2F;Express, etc.</div><br/><div id="38692689" class="c"><input type="checkbox" id="c-38692689" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#38689140">root</a><span>|</span><a href="#38691355">parent</a><span>|</span><a href="#38690611">next</a><span>|</span><label class="collapse" for="c-38692689">[-]</label><label class="expand" for="c-38692689">[1 more]</label></div><br/><div class="children"><div class="content">It sure can, but you can&#x27;t be as sloppy as you can be with Ruby, Python or JavaScript or Go.<p>It&#x27;s a high-level language, it just has its own rules that encourage correctness and prohibit sloppiness (which is a de-facto standard in the webdev industry, especially when prototyping rapidly by throwing shit at the wall and then letting whatever stuck live in production until it&#x27;s no longer manageable).<p>For better or worse, Rust simply doesn&#x27;t forgive a lot of things that are easy to do elsewhere, like not caring about less probable scenarios.<p>And, again, for better or worse, you also have to satisfy the borrow checker, where in other languages there&#x27;s simply no such thing. Which is sometimes easy as calling clone() (not always a good idea), but sometimes can be quite a headache thinking about value lifetimes and how you just can&#x27;t have something somewhere else (which can be super subtle so you wouldn&#x27;t normally think about it in other languages with GC).</div><br/></div></div></div></div><div id="38690611" class="c"><input type="checkbox" id="c-38690611" checked=""/><div class="controls bullet"><span class="by">drewcoo</span><span>|</span><a href="#38689140">parent</a><span>|</span><a href="#38691355">prev</a><span>|</span><a href="#38689585">next</a><span>|</span><label class="collapse" for="c-38690611">[-]</label><label class="expand" for="c-38690611">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve seldom run into a programming language and ecosystem that tries so hard to make programming mirthful.<p>Perl felt like that in the 90s. Ruby (not Rails) seemed like it was trying to do a better Perl - better OO, better functional style, better syntax, etc. Both of them inspired a lot of things in other languages. And lots of people groan and complain about both of them today.<p>From what I can tell, a lot of complaints are from people who don&#x27;t really like to code. Expressiveness means choice and that means thinking about coding instead of just following a &quot;one way to do it&quot; pattern over and over. Thoughtful coding, making something unique and making it easier than other examples, is also the kind of coding that LLMs can&#x27;t do - they only munge together mediocrity out of what exists.</div><br/><div id="38691830" class="c"><input type="checkbox" id="c-38691830" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38689140">root</a><span>|</span><a href="#38690611">parent</a><span>|</span><a href="#38691397">next</a><span>|</span><label class="collapse" for="c-38691830">[-]</label><label class="expand" for="c-38691830">[1 more]</label></div><br/><div class="children"><div class="content">&gt; From what I can tell, a lot of complaints are from people who don&#x27;t really like to code. Expressiveness means choice and that means thinking about coding instead of just following a &quot;one way to do it&quot; pattern over and over. Thoughtful coding, making something unique and making it easier than other examples...<p>The complaints are from the poor suckers who had to maintain that &quot;mirthful&quot; code after it was written. Writing greenfield code is already fun in most languages; understanding existing code is already the hard part, and having to decode the &quot;unique&quot; thoughts of whoever came before you makes it worse.</div><br/></div></div><div id="38691397" class="c"><input type="checkbox" id="c-38691397" checked=""/><div class="controls bullet"><span class="by">jes5199</span><span>|</span><a href="#38689140">root</a><span>|</span><a href="#38690611">parent</a><span>|</span><a href="#38691830">prev</a><span>|</span><a href="#38689585">next</a><span>|</span><label class="collapse" for="c-38691397">[-]</label><label class="expand" for="c-38691397">[2 more]</label></div><br/><div class="children"><div class="content">when Ruby was up and coming, people compared it to Perl a lot, but I never saw the similarities. I guess they both have first-class regexp. But ruby has very standard semantics, almost interchangeable with Python and Javascript in most cases. Perl… like, I would have to look up “how to access a nested array” because its sigils, arrows, and types form such an alien system</div><br/><div id="38691556" class="c"><input type="checkbox" id="c-38691556" checked=""/><div class="controls bullet"><span class="by">mech422</span><span>|</span><a href="#38689140">root</a><span>|</span><a href="#38691397">parent</a><span>|</span><a href="#38689585">next</a><span>|</span><label class="collapse" for="c-38691556">[-]</label><label class="expand" for="c-38691556">[1 more]</label></div><br/><div class="children"><div class="content">IIRC, the comparisons were because Ruby was supposed to be a fully object oriented &#x27;perl-like&#x27; language.  Even the name was a nod to its Perl based inspiration.</div><br/></div></div></div></div></div></div></div></div><div id="38689585" class="c"><input type="checkbox" id="c-38689585" checked=""/><div class="controls bullet"><span class="by">nickysielicki</span><span>|</span><a href="#38689140">prev</a><span>|</span><a href="#38691591">next</a><span>|</span><label class="collapse" for="c-38689585">[-]</label><label class="expand" for="c-38689585">[7 more]</label></div><br/><div class="children"><div class="content">I had to write some ruby at work recently and wasted a few hours on a bug caused by the following footgun:<p><pre><code>    irb(main):028:0&gt; value = false or true
    =&gt; true
    irb(main):029:0&gt; value
    =&gt; false
</code></pre>
That really makes me want to write it off entirely. It’s hard to think of a situation where this is the right behavior.</div><br/><div id="38691106" class="c"><input type="checkbox" id="c-38691106" checked=""/><div class="controls bullet"><span class="by">matthewowen</span><span>|</span><a href="#38689585">parent</a><span>|</span><a href="#38690940">next</a><span>|</span><label class="collapse" for="c-38691106">[-]</label><label class="expand" for="c-38691106">[2 more]</label></div><br/><div class="children"><div class="content">In python empty string is false. In ruby 0 is true. And yes, ruby has both or and || but they mean different things.<p>I’m not saying that it isnt valid to criticize these things: first time use of a language matters, people work in multiple languages, it is good to be intuitive.<p>But in practice, these things aren’t problems for people who work regularly in these languages, so I personally find them to be quite low salience.<p>I recognize that this is sort of similar to the claims the hypothetical user of php makes in “php is a fractal of bad design”, but personally I find think the issues are of a different nature.</div><br/><div id="38691408" class="c"><input type="checkbox" id="c-38691408" checked=""/><div class="controls bullet"><span class="by">jes5199</span><span>|</span><a href="#38689585">root</a><span>|</span><a href="#38691106">parent</a><span>|</span><a href="#38690940">next</a><span>|</span><label class="collapse" for="c-38691408">[-]</label><label class="expand" for="c-38691408">[1 more]</label></div><br/><div class="children"><div class="content">that’s not the bug here. they got caught by precedence rules</div><br/></div></div></div></div><div id="38690940" class="c"><input type="checkbox" id="c-38690940" checked=""/><div class="controls bullet"><span class="by">sinkwool</span><span>|</span><a href="#38689585">parent</a><span>|</span><a href="#38691106">prev</a><span>|</span><a href="#38689711">next</a><span>|</span><label class="collapse" for="c-38690940">[-]</label><label class="expand" for="c-38690940">[2 more]</label></div><br/><div class="children"><div class="content">`and`, `or`, `not` have much lower precedence than `&amp;&amp;`, `||` and `!` . I would just avoid `and` and `or` in general.<p>For some more explanation see <a href="https:&#x2F;&#x2F;graceful.dev&#x2F;courses&#x2F;the-freebies&#x2F;modules&#x2F;ruby-language&#x2F;topic&#x2F;episode-125-and-or&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;graceful.dev&#x2F;courses&#x2F;the-freebies&#x2F;modules&#x2F;ruby-langu...</a></div><br/><div id="38692573" class="c"><input type="checkbox" id="c-38692573" checked=""/><div class="controls bullet"><span class="by">djur</span><span>|</span><a href="#38689585">root</a><span>|</span><a href="#38690940">parent</a><span>|</span><a href="#38689711">next</a><span>|</span><label class="collapse" for="c-38692573">[-]</label><label class="expand" for="c-38692573">[1 more]</label></div><br/><div class="children"><div class="content">Rubocop forbids the use of `and` and `or` in a value expression for this reason, and I believe several style guides used with Rubocop ban them entirely. I like them but have come to accept that they&#x27;re more trouble than they&#x27;re worth (in a shared codebase with lots of contributors, at least).</div><br/></div></div></div></div><div id="38689711" class="c"><input type="checkbox" id="c-38689711" checked=""/><div class="controls bullet"><span class="by">jameskilton</span><span>|</span><a href="#38689585">parent</a><span>|</span><a href="#38690940">prev</a><span>|</span><a href="#38691101">next</a><span>|</span><label class="collapse" for="c-38689711">[-]</label><label class="expand" for="c-38689711">[1 more]</label></div><br/><div class="children"><div class="content">You want to use &quot;||&quot; like most languages, not &quot;or&quot;. They have different precedence rules.</div><br/></div></div><div id="38691101" class="c"><input type="checkbox" id="c-38691101" checked=""/><div class="controls bullet"><span class="by">mberning</span><span>|</span><a href="#38689585">parent</a><span>|</span><a href="#38689711">prev</a><span>|</span><a href="#38691591">next</a><span>|</span><label class="collapse" for="c-38691101">[-]</label><label class="expand" for="c-38691101">[1 more]</label></div><br/><div class="children"><div class="content">If that is enough to turn you off it’s probably for the best.</div><br/></div></div></div></div><div id="38691591" class="c"><input type="checkbox" id="c-38691591" checked=""/><div class="controls bullet"><span class="by">RagnarD</span><span>|</span><a href="#38689585">prev</a><span>|</span><a href="#38691170">next</a><span>|</span><label class="collapse" for="c-38691591">[-]</label><label class="expand" for="c-38691591">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve programmed in both Ruby and Python. I like both, but ...<p>It should never be forgotten that the ultimate purpose of programming languages is to make specific usable programs. It&#x27;s sort of fashionable to ignore performance but in reality it&#x27;s always an issue of some kind. And the fact remains that the price paid for Ruby and Python&#x27;s features is severe performance degradation. That&#x27;s improved over time but as far as I know it remains a real problem. One shouldn&#x27;t let admiration for language features supersede user experience and resource utilization.</div><br/><div id="38692021" class="c"><input type="checkbox" id="c-38692021" checked=""/><div class="controls bullet"><span class="by">eropple</span><span>|</span><a href="#38691591">parent</a><span>|</span><a href="#38691170">next</a><span>|</span><label class="collapse" for="c-38692021">[-]</label><label class="expand" for="c-38692021">[1 more]</label></div><br/><div class="children"><div class="content">The vast majority of web code is waiting on a database, written in something eye-poppingly optimized, to push a string back to the client that asked for it. It&#x27;s &quot;pick things up and put them down&quot; plumbing and the delta between a Fast Language and a Slow Language will usually be swamped by connection latency.<p>There are of course places where it isn&#x27;t appropriate to use a Ruby or a Python, sure. So don&#x27;t. There are plenty of others where sniffing at them on the grounds of performance is making up a guy to get mad at.</div><br/></div></div></div></div><div id="38691170" class="c"><input type="checkbox" id="c-38691170" checked=""/><div class="controls bullet"><span class="by">UncleOxidant</span><span>|</span><a href="#38691591">prev</a><span>|</span><a href="#38689275">next</a><span>|</span><label class="collapse" for="c-38691170">[-]</label><label class="expand" for="c-38691170">[1 more]</label></div><br/><div class="children"><div class="content">I really fell for Ruby around 2001 after liking Perl for about 5 years but then deciding that OO Perl was just seemed like a hack. Ruby was my favorite language from about 2001 till about 2010 or so. Then I found strongly typed functional languages like OCaml and F# to be more to my liking. And Python not Ruby was used in most of the jobs I had during the 2010s.<p>It seems like Rails really caused Ruby to fall out of favor around 2010 so it&#x27;s interesting to see some positive Ruby articles here lately. Looks like there&#x27;s been a good amount of performance improvements as well as new language features added over the last decade - perhaps we&#x27;re seeing a bit of a Ruby revival?</div><br/></div></div><div id="38689275" class="c"><input type="checkbox" id="c-38689275" checked=""/><div class="controls bullet"><span class="by">mattgreenrocks</span><span>|</span><a href="#38691170">prev</a><span>|</span><a href="#38689525">next</a><span>|</span><label class="collapse" for="c-38689275">[-]</label><label class="expand" for="c-38689275">[3 more]</label></div><br/><div class="children"><div class="content">Ruby’s a great language, but the cult of personality is really strong there, especially in Rails. And that ultimately led me away from the ecosystem.<p>I’m not looking for heroes to worship, just good tech.</div><br/><div id="38691014" class="c"><input type="checkbox" id="c-38691014" checked=""/><div class="controls bullet"><span class="by">andrei_says_</span><span>|</span><a href="#38689275">parent</a><span>|</span><a href="#38689525">next</a><span>|</span><label class="collapse" for="c-38691014">[-]</label><label class="expand" for="c-38691014">[2 more]</label></div><br/><div class="children"><div class="content">What are some symptoms of a cult of personality? I use Ruby and Rails and I know that DHH and Aaron Patterson are somewhat famous but don’t know much about them and certainly don’t make any decisions based on their existence or fame.</div><br/><div id="38691348" class="c"><input type="checkbox" id="c-38691348" checked=""/><div class="controls bullet"><span class="by">mattgreenrocks</span><span>|</span><a href="#38689275">root</a><span>|</span><a href="#38691014">parent</a><span>|</span><a href="#38689525">next</a><span>|</span><label class="collapse" for="c-38691348">[-]</label><label class="expand" for="c-38691348">[1 more]</label></div><br/><div class="children"><div class="content">Both of those individuals have made fantastic contributions. My beef isn’t with them.<p>It’s with the community that insists that DHH’s software design edicts are The One True Way. Instead of software design being a thing you can use to make your life better, we are to believe that Rails Is All You Need. And think at the time it was the framework to use, so it attracted a lot of people who believed software dev should be “do what the thought leader says.”<p>No idea what it’s like now, but it truly felt like people saying those things out of tribal affiliation more than technical acumen. And that is a recipe for stagnation.<p>That said, I still respect the tech and the creators a lot. I just don’t share the values at all.</div><br/></div></div></div></div></div></div><div id="38689525" class="c"><input type="checkbox" id="c-38689525" checked=""/><div class="controls bullet"><span class="by">marcrosoft</span><span>|</span><a href="#38689275">prev</a><span>|</span><a href="#38689092">next</a><span>|</span><label class="collapse" for="c-38689525">[-]</label><label class="expand" for="c-38689525">[4 more]</label></div><br/><div class="children"><div class="content">Take ruby vs go. Ruby can write expressions that resemble a sentence so you can skip commenting and it looks nice. Go is verbose and less English like. Which is easier to understand what the code actually does? Go may take a little extra time to digest but it is infinitely more clear what is going on. If you don’t need to debug the ruby code or optimize it ruby wins because it is easier to digest and reads like English. It is a trade off like many things in software.</div><br/><div id="38689662" class="c"><input type="checkbox" id="c-38689662" checked=""/><div class="controls bullet"><span class="by">PH95VuimJjqBqy</span><span>|</span><a href="#38689525">parent</a><span>|</span><a href="#38692551">next</a><span>|</span><label class="collapse" for="c-38689662">[-]</label><label class="expand" for="c-38689662">[2 more]</label></div><br/><div class="children"><div class="content">This is actually one of the reasons I dislike cucumber so much.  They try so hard to make it read like English for non-tech people but to really understand it you need to understand the underlying regex being used.</div><br/><div id="38692376" class="c"><input type="checkbox" id="c-38692376" checked=""/><div class="controls bullet"><span class="by">eliseshaffer</span><span>|</span><a href="#38689525">root</a><span>|</span><a href="#38689662">parent</a><span>|</span><a href="#38692551">next</a><span>|</span><label class="collapse" for="c-38692376">[-]</label><label class="expand" for="c-38692376">[1 more]</label></div><br/><div class="children"><div class="content">Hello! I&#x27;m Elise, the author of the post. Figured I&#x27;d jump in and say that in addition to Ruby, I really like Cucumber. But I think the non-technical people focus really cuts a lot out. For me, Cucumber gives the whole team(tech and non-tech) a shared language for what the software does.<p>I don&#x27;t use it much anymore, because most companies seem to have moved away from it. But, I do miss it and wish we had something similar that could encouraged that level of shared understanding.</div><br/></div></div></div></div><div id="38692551" class="c"><input type="checkbox" id="c-38692551" checked=""/><div class="controls bullet"><span class="by">djur</span><span>|</span><a href="#38689525">parent</a><span>|</span><a href="#38689662">prev</a><span>|</span><a href="#38689092">next</a><span>|</span><label class="collapse" for="c-38692551">[-]</label><label class="expand" for="c-38692551">[1 more]</label></div><br/><div class="children"><div class="content">I spent several years working on production Go code and I never found it particularly clear or intuitive to read or debug compared to Ruby. This seems like a &quot;your mileage may vary&quot; situation.</div><br/></div></div></div></div><div id="38689092" class="c"><input type="checkbox" id="c-38689092" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#38689525">prev</a><span>|</span><a href="#38689044">next</a><span>|</span><label class="collapse" for="c-38689092">[-]</label><label class="expand" for="c-38689092">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s positive and uplifting post and it is that too when a language works with how you think and is expressive and productive. It&#x27;s unsatisfying to work against a learning curve if you are hitting obstacles.<p>A language is one possible notation of thought.<p>I like to be productive with my thoughts. I tend to do proof of concepts in Python then port to C or in Java directly.<p>I remember learning about Ruby when posted on digg and there was a new tool coming out all the time.</div><br/></div></div><div id="38689044" class="c"><input type="checkbox" id="c-38689044" checked=""/><div class="controls bullet"><span class="by">narven</span><span>|</span><a href="#38689092">prev</a><span>|</span><a href="#38689020">next</a><span>|</span><label class="collapse" for="c-38689044">[-]</label><label class="expand" for="c-38689044">[3 more]</label></div><br/><div class="children"><div class="content">try Crystal lang (<a href="https:&#x2F;&#x2F;crystal-lang.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;crystal-lang.org&#x2F;</a>)</div><br/><div id="38689084" class="c"><input type="checkbox" id="c-38689084" checked=""/><div class="controls bullet"><span class="by">mathverse</span><span>|</span><a href="#38689044">parent</a><span>|</span><a href="#38689020">next</a><span>|</span><label class="collapse" for="c-38689084">[-]</label><label class="expand" for="c-38689084">[2 more]</label></div><br/><div class="children"><div class="content">This. I dont really need true essence of metaprogramming craziness of Ruby. I need Ruby-like, dev happiness, readability and performance. Wish Crystal would catch up and get some attention.</div><br/><div id="38690976" class="c"><input type="checkbox" id="c-38690976" checked=""/><div class="controls bullet"><span class="by">sinkwool</span><span>|</span><a href="#38689044">root</a><span>|</span><a href="#38689084">parent</a><span>|</span><a href="#38689020">next</a><span>|</span><label class="collapse" for="c-38690976">[-]</label><label class="expand" for="c-38690976">[1 more]</label></div><br/><div class="children"><div class="content">Kotlin is very ruby-like and performant, check it out. If you don&#x27;t mind using JetBrains IDEs, I&#x27;d give kotlin a try.</div><br/></div></div></div></div></div></div><div id="38689020" class="c"><input type="checkbox" id="c-38689020" checked=""/><div class="controls bullet"><span class="by">kreutz</span><span>|</span><a href="#38689044">prev</a><span>|</span><a href="#38689394">next</a><span>|</span><label class="collapse" for="c-38689020">[-]</label><label class="expand" for="c-38689020">[3 more]</label></div><br/><div class="children"><div class="content">I love Ruby too. I wish they fully embraced types. Sorbet is not fun to use.</div><br/><div id="38689262" class="c"><input type="checkbox" id="c-38689262" checked=""/><div class="controls bullet"><span class="by">revscat</span><span>|</span><a href="#38689020">parent</a><span>|</span><a href="#38689394">next</a><span>|</span><label class="collapse" for="c-38689262">[-]</label><label class="expand" for="c-38689262">[2 more]</label></div><br/><div class="children"><div class="content">Good lord, no, it is not. I tried Sorbet on a small personal project and rather quickly abandoned it. It made the code ugly and was a pain to maintain.<p>The fact that Sorbet has not seen adoption outside of Shopify is also somewhat telling.<p>It’s disappointing, because Ruby needs this. Modern tooling has moved in the direction of typed languages, and Ruby’s tooling has suffered comparatively. Outside of RubyMine it’s still difficult to get “jump to definition” to work consistently, and in 2023 this is a rather embarrassing strike against the language.</div><br/><div id="38690891" class="c"><input type="checkbox" id="c-38690891" checked=""/><div class="controls bullet"><span class="by">froydnj</span><span>|</span><a href="#38689020">root</a><span>|</span><a href="#38689262">parent</a><span>|</span><a href="#38689394">next</a><span>|</span><label class="collapse" for="c-38690891">[-]</label><label class="expand" for="c-38690891">[1 more]</label></div><br/><div class="children"><div class="content">Stripe is a huge Sorbet user.</div><br/></div></div></div></div></div></div><div id="38689663" class="c"><input type="checkbox" id="c-38689663" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38689394">prev</a><span>|</span><a href="#38689222">next</a><span>|</span><label class="collapse" for="c-38689663">[-]</label><label class="expand" for="c-38689663">[4 more]</label></div><br/><div class="children"><div class="content">supports_feature? contains gratuitous punctuation.<p>A question mark is useful on predicates when they are nouns. For instance type tests. Here is why: widget(x) looks like a constructor: it&#x27;s making a widget out of x. If we add a question mark: widget?(x) then we know it&#x27;s a test whether x is a widget. We have other choices there like is_widget(x).<p>&quot;Supports feature&quot; has a verb and object. The verb is not in imperative form; it&#x27;s in a statement form. A question mark is not required.</div><br/><div id="38692713" class="c"><input type="checkbox" id="c-38692713" checked=""/><div class="controls bullet"><span class="by">skgough</span><span>|</span><a href="#38689663">parent</a><span>|</span><a href="#38691339">next</a><span>|</span><label class="collapse" for="c-38692713">[-]</label><label class="expand" for="c-38692713">[1 more]</label></div><br/><div class="children"><div class="content">I always understood the question mark to mean that the method returns a boolean value, eg. the include? method on Arrays returns a bool.</div><br/></div></div><div id="38691339" class="c"><input type="checkbox" id="c-38691339" checked=""/><div class="controls bullet"><span class="by">graypegg</span><span>|</span><a href="#38689663">parent</a><span>|</span><a href="#38692713">prev</a><span>|</span><a href="#38689222">next</a><span>|</span><label class="collapse" for="c-38691339">[-]</label><label class="expand" for="c-38691339">[2 more]</label></div><br/><div class="children"><div class="content">I think this is a normal ruby pattern though. A ? prefix is just a best-practice habit to indicate a method returns a real TrueClass or FalseClass instance.<p>You’re always running Ruby statements in some scope, so there’s always an object you’re running methods from. That makes your constructor and reflection examples a bit odd for Ruby.<p>Constructors would be a method on a class, normally the Class instance method #new: Widget.new(x)<p>Checking if y is a Widget would mean calling a method on that instance, normally the Object instance method #is_a?: y.is_a?(Widget)<p>I think that’s adequately distinct.</div><br/></div></div></div></div><div id="38689222" class="c"><input type="checkbox" id="c-38689222" checked=""/><div class="controls bullet"><span class="by">chihuahua</span><span>|</span><a href="#38689663">prev</a><span>|</span><a href="#38689104">next</a><span>|</span><label class="collapse" for="c-38689222">[-]</label><label class="expand" for="c-38689222">[8 more]</label></div><br/><div class="children"><div class="content">It is mind-boggling to me to see all the low-value features that Ruby has, but no enums. So every time an enum is needed, there&#x27;s some ugly code that tries to emulate an enum.<p>The guiding theme for Ruby appears to be &quot;let&#x27;s give people a huge number of ways to write unreadable code&quot; and it reminds me of JWZ&#x27;s classic rant about PHP, &quot;a fractal of bad design.&quot;</div><br/><div id="38689381" class="c"><input type="checkbox" id="c-38689381" checked=""/><div class="controls bullet"><span class="by">jjgreen</span><span>|</span><a href="#38689222">parent</a><span>|</span><a href="#38689447">next</a><span>|</span><label class="collapse" for="c-38689381">[-]</label><label class="expand" for="c-38689381">[4 more]</label></div><br/><div class="children"><div class="content">I disagree, but thanks for reminding me of that article, just splendid <a href="https:&#x2F;&#x2F;eev.ee&#x2F;blog&#x2F;2012&#x2F;04&#x2F;09&#x2F;php-a-fractal-of-bad-design&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;eev.ee&#x2F;blog&#x2F;2012&#x2F;04&#x2F;09&#x2F;php-a-fractal-of-bad-design&#x2F;</a><p>You couldn&#x27;t <i>really</i> find that many quirks, edge-cases and foot-guns in Ruby, could you?</div><br/><div id="38689511" class="c"><input type="checkbox" id="c-38689511" checked=""/><div class="controls bullet"><span class="by">chihuahua</span><span>|</span><a href="#38689222">root</a><span>|</span><a href="#38689381">parent</a><span>|</span><a href="#38689447">next</a><span>|</span><label class="collapse" for="c-38689511">[-]</label><label class="expand" for="c-38689511">[3 more]</label></div><br/><div class="children"><div class="content">For me, it&#x27;s not so much that there are quirks and edge-cases, but rather that Ruby seems to have a lot of clutter (e.g. &quot;unless&quot;, punctuation as part of function names, etc) while useful features are missing.</div><br/><div id="38690047" class="c"><input type="checkbox" id="c-38690047" checked=""/><div class="controls bullet"><span class="by">sensanaty</span><span>|</span><a href="#38689222">root</a><span>|</span><a href="#38689511">parent</a><span>|</span><a href="#38689557">next</a><span>|</span><label class="collapse" for="c-38690047">[-]</label><label class="expand" for="c-38690047">[1 more]</label></div><br/><div class="children"><div class="content">I always find talking about Ruby fascinating, because it&#x27;s so divisive and for good reason.<p>It&#x27;s one of those things where you either love it or hate it. The first moment I saw a question mark denoting a boolean, I fell in love with Ruby right then and there, but I also perfectly understand why people hate that. Same with stuff like `unless`, whenever I use a different language I&#x27;m always tempted to make a small utility class with all the Ruby niceties like `unless`, and that&#x27;s another thing I can completely understand not liking.</div><br/></div></div><div id="38689557" class="c"><input type="checkbox" id="c-38689557" checked=""/><div class="controls bullet"><span class="by">jjgreen</span><span>|</span><a href="#38689222">root</a><span>|</span><a href="#38689511">parent</a><span>|</span><a href="#38690047">prev</a><span>|</span><a href="#38689447">next</a><span>|</span><label class="collapse" for="c-38689557">[-]</label><label class="expand" for="c-38689557">[1 more]</label></div><br/><div class="children"><div class="content">Fair enough, a matter of taste.  Personally I&#x27;m a fan of &quot;then&quot; which I guess would give you the horrors :-)</div><br/></div></div></div></div></div></div><div id="38689447" class="c"><input type="checkbox" id="c-38689447" checked=""/><div class="controls bullet"><span class="by">hu3</span><span>|</span><a href="#38689222">parent</a><span>|</span><a href="#38689381">prev</a><span>|</span><a href="#38691418">next</a><span>|</span><label class="collapse" for="c-38689447">[-]</label><label class="expand" for="c-38689447">[1 more]</label></div><br/><div class="children"><div class="content">Even PHP has enums now and they are pretty cool:<p><a href="https:&#x2F;&#x2F;stitcher.io&#x2F;blog&#x2F;php-enums" rel="nofollow noreferrer">https:&#x2F;&#x2F;stitcher.io&#x2F;blog&#x2F;php-enums</a></div><br/></div></div><div id="38691418" class="c"><input type="checkbox" id="c-38691418" checked=""/><div class="controls bullet"><span class="by">jes5199</span><span>|</span><a href="#38689222">parent</a><span>|</span><a href="#38689447">prev</a><span>|</span><a href="#38690698">next</a><span>|</span><label class="collapse" for="c-38691418">[-]</label><label class="expand" for="c-38691418">[1 more]</label></div><br/><div class="children"><div class="content">I think the ruby answer is “just use symbols”</div><br/></div></div><div id="38690698" class="c"><input type="checkbox" id="c-38690698" checked=""/><div class="controls bullet"><span class="by">pvg</span><span>|</span><a href="#38689222">parent</a><span>|</span><a href="#38691418">prev</a><span>|</span><a href="#38689104">next</a><span>|</span><label class="collapse" for="c-38690698">[-]</label><label class="expand" for="c-38690698">[1 more]</label></div><br/><div class="children"><div class="content">That wasn&#x27;t written by jwz.</div><br/></div></div></div></div><div id="38689104" class="c"><input type="checkbox" id="c-38689104" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#38689222">prev</a><span>|</span><a href="#38691131">next</a><span>|</span><label class="collapse" for="c-38689104">[-]</label><label class="expand" for="c-38689104">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve no opinion on Ruby, but I don&#x27;t really understand this article. People like familiar tools, and get good at them - agree. But a lot of languages can be written in fluent ways, and I didn&#x27;t really find the test example that easy to read. I wouldn&#x27;t say &quot;end end end&quot; at the end of describing the test out loud, for example.</div><br/></div></div><div id="38691131" class="c"><input type="checkbox" id="c-38691131" checked=""/><div class="controls bullet"><span class="by">mberning</span><span>|</span><a href="#38689104">prev</a><span>|</span><a href="#38692570">next</a><span>|</span><label class="collapse" for="c-38691131">[-]</label><label class="expand" for="c-38691131">[1 more]</label></div><br/><div class="children"><div class="content">It’s a shame that Ruby doesn’t have the cachet it once had. People are missing out. It’s still a fantastic language and Rails is still the goat web framework. Perhaps we’ll see a renaissance in the future. I still prefer to do all my tinkering and playing in Ruby first.</div><br/></div></div><div id="38692570" class="c"><input type="checkbox" id="c-38692570" checked=""/><div class="controls bullet"><span class="by">mgz</span><span>|</span><a href="#38691131">prev</a><span>|</span><a href="#38692332">next</a><span>|</span><label class="collapse" for="c-38692570">[-]</label><label class="expand" for="c-38692570">[1 more]</label></div><br/><div class="children"><div class="content">Ruby one love</div><br/></div></div><div id="38692332" class="c"><input type="checkbox" id="c-38692332" checked=""/><div class="controls bullet"><span class="by">rochak</span><span>|</span><a href="#38692570">prev</a><span>|</span><label class="collapse" for="c-38692332">[-]</label><label class="expand" for="c-38692332">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t.</div><br/></div></div></div></div></div></div></div></body></html>