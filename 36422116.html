<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687424459210" as="style"/><link rel="stylesheet" href="styles.css?v=1687424459210"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.mclibre.org/descargar/docs/libros/ooc-ats.pdf">Object-oriented Programming with ANSI-C (1993) [pdf]</a>Â <span class="domain">(<a href="https://www.mclibre.org">www.mclibre.org</a>)</span></div><div class="subtext"><span>Tomte</span> | <span>60 comments</span></div><br/><div><div id="36429605" class="c"><input type="checkbox" id="c-36429605" checked=""/><div class="controls bullet"><span class="by">zzbn00</span><span>|</span><a href="#36429034">next</a><span>|</span><label class="collapse" for="c-36429605">[-]</label><label class="expand" for="c-36429605">[1 more]</label></div><br/><div class="children"><div class="content">The C Object System looks like an interesting way of doing this today:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;CObjectSystem&#x2F;COS">https:&#x2F;&#x2F;github.com&#x2F;CObjectSystem&#x2F;COS</a><p>and<p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1003.2547.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1003.2547.pdf</a></div><br/></div></div><div id="36429034" class="c"><input type="checkbox" id="c-36429034" checked=""/><div class="controls bullet"><span class="by">vaughan</span><span>|</span><a href="#36429605">prev</a><span>|</span><a href="#36427020">next</a><span>|</span><label class="collapse" for="c-36429034">[-]</label><label class="expand" for="c-36429034">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve actually started preferring the `action(subject, object)` form of programming which OO in C entails, rather than `subject.action(object)`. The latter is certainly easier for discovery via auto-complete (with most current tooling).<p>OO is not a natural way of programming. Everything always starts simply with functions that take arguments. Then you have a function that calls another function with some of the old arguments and some new ones.<p>Most people go: let&#x27;s make the shared param an instance var.<p><pre><code>    const config = {}
    foo(config)
    function foo(config) { bar(&#x27;bar&#x27;, config) }
    bar(str, config) { ... }
</code></pre>
becomes...<p><pre><code>    class MyClass {
      config
      constructor(config) { this.config = config }
      foo() { this.bar(&#x27;bar&#x27;) }
      bar(str) { ... }
    }

</code></pre>
The problem with a class, is that every method of the class potentially depends on every other member of the class. What usually happens is that stuff is added to the class that doesn&#x27;t make sense. And every class needs a noun to name it. Then you have to think what is the proper name for this abstract thing you don&#x27;t even know what it is yet. Which leads to all these quirky class names that are unnecessary.<p>If you are explicit about what data dependencies each function has, it becomes easier to see the commonality that should be extracted into classes. Most people just shove everything in a class too soon. And most languages push you to use classes and methods...which usually look very different to how functions are represented.</div><br/></div></div><div id="36427020" class="c"><input type="checkbox" id="c-36427020" checked=""/><div class="controls bullet"><span class="by">1bent</span><span>|</span><a href="#36429034">prev</a><span>|</span><a href="#36427493">next</a><span>|</span><label class="collapse" for="c-36427020">[-]</label><label class="expand" for="c-36427020">[1 more]</label></div><br/><div class="children"><div class="content">OOP has always felt to me like it was inspired by writing GUI APIs; Sun&#x27;s Suntools -&gt; Sunview -&gt; xview (if I&#x27;m remembering the names right) were early-mid 1980s C, and felt beautifully OO, and very clean to write GUI programs. I enjoyed writing image analysis and manipulation in them. Never used the successor &quot;intrinsics-based&quot; Motif and CDE, the code was yucky. Didn&#x27;t write another GUI until I did a dashboard (for automated software deployment) in TCL&#x2F;Tk. But yeah, C++ never interested me for OO, C was fine.</div><br/></div></div><div id="36427493" class="c"><input type="checkbox" id="c-36427493" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#36427020">prev</a><span>|</span><a href="#36428284">next</a><span>|</span><label class="collapse" for="c-36427493">[-]</label><label class="expand" for="c-36427493">[15 more]</label></div><br/><div class="children"><div class="content">It&#x27;s weird that so much of OOP back then was centered around deep class inheritance hierarchies as a means to share code when my favorite more modern languages (Rust and Go) intentionally leave out this part of OOP (thankfully, imho).<p>An eye opener in respect to this was Sean Parent&#x27;s excellent talk &quot;Inheritance Is The Base Class of Evil&quot; at GoingNative 2013 [1].<p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=2bLkxj6EVoM">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=2bLkxj6EVoM</a></div><br/><div id="36429277" class="c"><input type="checkbox" id="c-36429277" checked=""/><div class="controls bullet"><span class="by">mikro2nd</span><span>|</span><a href="#36427493">parent</a><span>|</span><a href="#36427590">next</a><span>|</span><label class="collapse" for="c-36429277">[-]</label><label class="expand" for="c-36429277">[1 more]</label></div><br/><div class="children"><div class="content">OOP was never &quot;<i>centered</i> around deep class inheritance hierarchies&quot;. It was <i>centred</i> around message passing and dynamic method dispatch. The only significance of inheritance is to resolve the receiver of a message.<p>I feel strongly that most of the people who think OOP was bad are people who have only ever experienced C++&#x2F;C#&#x2F;Java or some even weaker instantiation of OOP.<p>What do you suppose you&#x27;re writing when you implement a (micro)service? It&#x27;s nothing different than an object -- some implementation whose details you don&#x27;t need to care about when you use it, which details can be changed at any time without disturbing clients (modulo idiocy), and an interface that you use to communicate with it via messages.<p>And don&#x27;t even get me started on the OO vs. Functional nonsense...</div><br/></div></div><div id="36427590" class="c"><input type="checkbox" id="c-36427590" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#36427493">parent</a><span>|</span><a href="#36429277">prev</a><span>|</span><a href="#36428590">next</a><span>|</span><label class="collapse" for="c-36427590">[-]</label><label class="expand" for="c-36427590">[8 more]</label></div><br/><div class="children"><div class="content">I really don&#x27;t get why people keep repeating &quot;class inheritance hierarchies are bad&quot;. If one understands Implementation vs. Interface inheritance and the intent behind each (the former strongly couples the code while the latter does not) then one can judiciously use inheritance techniques correctly.<p>I recommend a study of Bertrand Meyer&#x27;s OOSC2 and language Eiffel - <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Object-Oriented_Software_Construction" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Object-Oriented_Software_Const...</a></div><br/><div id="36428068" class="c"><input type="checkbox" id="c-36428068" checked=""/><div class="controls bullet"><span class="by">Fire-Dragon-DoL</span><span>|</span><a href="#36427493">root</a><span>|</span><a href="#36427590">parent</a><span>|</span><a href="#36429045">next</a><span>|</span><label class="collapse" for="c-36428068">[-]</label><label class="expand" for="c-36428068">[4 more]</label></div><br/><div class="children"><div class="content">The reason is implicit makes really easy to miss things and the majority of software devs have very poor understanding of coupling. Consequence is if inheritance is a thing, you&#x27;ll see monsters in the code.<p>If inheritance is not available, the problem doesn&#x27;t exist.<p>Same goes for immutability, in the end our tools are tuning for the lowest performers</div><br/><div id="36428762" class="c"><input type="checkbox" id="c-36428762" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#36427493">root</a><span>|</span><a href="#36428068">parent</a><span>|</span><a href="#36428276">next</a><span>|</span><label class="collapse" for="c-36428762">[-]</label><label class="expand" for="c-36428762">[1 more]</label></div><br/><div class="children"><div class="content">Not true.<p>The basic idea behind &quot;Inheritance&quot; is simple and can be understood by all programmers. Its realization through various language features and their combinations is what makes it somewhat confusing. Once explained and practiced with discipline, inheritance is very powerful.<p>See my other comment: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36428689">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36428689</a><p>See also: <a href="https:&#x2F;&#x2F;thevaluable.dev&#x2F;guide-inheritance-oop&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;thevaluable.dev&#x2F;guide-inheritance-oop&#x2F;</a></div><br/></div></div><div id="36428276" class="c"><input type="checkbox" id="c-36428276" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#36427493">root</a><span>|</span><a href="#36428068">parent</a><span>|</span><a href="#36428762">prev</a><span>|</span><a href="#36429045">next</a><span>|</span><label class="collapse" for="c-36428276">[-]</label><label class="expand" for="c-36428276">[2 more]</label></div><br/><div class="children"><div class="content">The ability to reason about code as you are reading it is not only important to &quot;lowest performers&quot;.</div><br/><div id="36428299" class="c"><input type="checkbox" id="c-36428299" checked=""/><div class="controls bullet"><span class="by">Fire-Dragon-DoL</span><span>|</span><a href="#36427493">root</a><span>|</span><a href="#36428276">parent</a><span>|</span><a href="#36429045">next</a><span>|</span><label class="collapse" for="c-36428299">[-]</label><label class="expand" for="c-36428299">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely agree, I very much prefer it</div><br/></div></div></div></div></div></div><div id="36429045" class="c"><input type="checkbox" id="c-36429045" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#36427493">root</a><span>|</span><a href="#36427590">parent</a><span>|</span><a href="#36428068">prev</a><span>|</span><a href="#36427619">next</a><span>|</span><label class="collapse" for="c-36429045">[-]</label><label class="expand" for="c-36429045">[1 more]</label></div><br/><div class="children"><div class="content">I think inheritance is the most convenient thing which came out of OOP, but interfaces are the most valuable one.<p>At least for business applications, you want to keep your behaviour and state separate. And people following OOP dogmatically will (ab)use encapsulation for use-cases where your data should be transparent.<p>Contrast this to interfaces, which are essentially composable specifications on code-level (and I absolutely love that Java uses interfaces to describe anonymous classes due to the power it gives you for documentation and specification).</div><br/></div></div><div id="36427619" class="c"><input type="checkbox" id="c-36427619" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#36427493">root</a><span>|</span><a href="#36427590">parent</a><span>|</span><a href="#36429045">prev</a><span>|</span><a href="#36428590">next</a><span>|</span><label class="collapse" for="c-36427619">[-]</label><label class="expand" for="c-36427619">[2 more]</label></div><br/><div class="children"><div class="content">The way I&#x27;m thinking about it (just a different expression of the exact same thought) is that inheritance as a means to share code is bad, while inheritance as a means to leverage polymorphism is good. Polymorphic classes can still share code, but this should be done using composition.</div><br/><div id="36428689" class="c"><input type="checkbox" id="c-36428689" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#36427493">root</a><span>|</span><a href="#36427619">parent</a><span>|</span><a href="#36428590">next</a><span>|</span><label class="collapse" for="c-36428689">[-]</label><label class="expand" for="c-36428689">[1 more]</label></div><br/><div class="children"><div class="content">&gt; inheritance as a means to share code is bad,<p>Not necessarily; if they are strongly coupled related concepts within the same module then it is perfectly fine (eg. <i>private</i> inheritance in C++). Here you are basically structuring for code reuse and not is-a relationship.<p>&gt;inheritance as a means to leverage polymorphism is good.<p>This is the &quot;standard&quot; idea of inheritance i.e. sub-typing using Liskov Substitution Principle.<p>&gt; Polymorphic classes can still share code, but this should be done using composition.<p>Not necessarily as a combination of the above two should make clear.</div><br/></div></div></div></div></div></div><div id="36428590" class="c"><input type="checkbox" id="c-36428590" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#36427493">parent</a><span>|</span><a href="#36427590">prev</a><span>|</span><a href="#36427649">next</a><span>|</span><label class="collapse" for="c-36428590">[-]</label><label class="expand" for="c-36428590">[1 more]</label></div><br/><div class="children"><div class="content">&gt; modern languages (Rust and Go) intentionally leave out this part of OOP (thankfully, imho).<p>Why thankfully?<p>Some solutions are a natural fit for a class hierarchy. Having to hack in workarounds using traits or receivers is, like any band-aid, ugly as hell.</div><br/></div></div><div id="36427649" class="c"><input type="checkbox" id="c-36427649" checked=""/><div class="controls bullet"><span class="by">Kamq</span><span>|</span><a href="#36427493">parent</a><span>|</span><a href="#36428590">prev</a><span>|</span><a href="#36428284">next</a><span>|</span><label class="collapse" for="c-36427649">[-]</label><label class="expand" for="c-36427649">[4 more]</label></div><br/><div class="children"><div class="content">Yeah, that still weirds me out. Especially considering the other obvious mechanism of code reuse, the function.</div><br/><div id="36427772" class="c"><input type="checkbox" id="c-36427772" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#36427493">root</a><span>|</span><a href="#36427649">parent</a><span>|</span><a href="#36428284">next</a><span>|</span><label class="collapse" for="c-36427772">[-]</label><label class="expand" for="c-36427772">[3 more]</label></div><br/><div class="children"><div class="content">State can also be shared and reused together with functions operating on it - via composition.</div><br/><div id="36427949" class="c"><input type="checkbox" id="c-36427949" checked=""/><div class="controls bullet"><span class="by">Kamq</span><span>|</span><a href="#36427493">root</a><span>|</span><a href="#36427772">parent</a><span>|</span><a href="#36428284">next</a><span>|</span><label class="collapse" for="c-36427949">[-]</label><label class="expand" for="c-36427949">[2 more]</label></div><br/><div class="children"><div class="content">Sure, but that&#x27;s desirable with, maybe, 5% of the code re-use opportunities I run across.<p>I&#x27;m not saying to never use classes. I just got really confused about them being pushed as one of the dominant forms of code-reuse.</div><br/><div id="36428330" class="c"><input type="checkbox" id="c-36428330" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#36427493">root</a><span>|</span><a href="#36427949">parent</a><span>|</span><a href="#36428284">next</a><span>|</span><label class="collapse" for="c-36428330">[-]</label><label class="expand" for="c-36428330">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, I think it&#x27;s been a hype at the beginning of OOP, then got overused in Java in the 90s and subsequently taught to every CS college student and it kind of stuck because in college, you don&#x27;t get to maintain large software projects.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36428284" class="c"><input type="checkbox" id="c-36428284" checked=""/><div class="controls bullet"><span class="by">nielsbot</span><span>|</span><a href="#36427493">prev</a><span>|</span><a href="#36429412">next</a><span>|</span><label class="collapse" for="c-36428284">[-]</label><label class="expand" for="c-36428284">[1 more]</label></div><br/><div class="children"><div class="content">If you find this kind of stuff interesting, definitely take a look at this paper by Ian Piumarta:<p><a href="https:&#x2F;&#x2F;www.piumarta.com&#x2F;software&#x2F;id-objmodel&#x2F;objmodel2.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.piumarta.com&#x2F;software&#x2F;id-objmodel&#x2F;objmodel2.pdf</a><p>An OOP object model you can implement in C where the model is open and extensible inside the user environment. It&#x27;s a very minimal yet flexible system.</div><br/></div></div><div id="36429412" class="c"><input type="checkbox" id="c-36429412" checked=""/><div class="controls bullet"><span class="by">synergy20</span><span>|</span><a href="#36428284">prev</a><span>|</span><a href="#36424553">next</a><span>|</span><label class="collapse" for="c-36429412">[-]</label><label class="expand" for="c-36429412">[1 more]</label></div><br/><div class="children"><div class="content">you can add oop to C just fine, as this paper shows.<p>it is hard or impossible to do RAII in C, or something like defer in golang.<p>we need both.</div><br/></div></div><div id="36424553" class="c"><input type="checkbox" id="c-36424553" checked=""/><div class="controls bullet"><span class="by">chmaynard</span><span>|</span><a href="#36429412">prev</a><span>|</span><a href="#36427307">next</a><span>|</span><label class="collapse" for="c-36424553">[-]</label><label class="expand" for="c-36424553">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of a course I took at Stanford around 1991. The course title was UNIX C Programming and the instructor was Dr. Eric Roberts. The programming part was to build a library of simple tools and the UI was the command-line. We didn&#x27;t call it object-oriented but it involved programming with ADTs that had well-defined APIs.</div><br/></div></div><div id="36427307" class="c"><input type="checkbox" id="c-36427307" checked=""/><div class="controls bullet"><span class="by">edgyquant</span><span>|</span><a href="#36424553">prev</a><span>|</span><a href="#36428369">next</a><span>|</span><label class="collapse" for="c-36427307">[-]</label><label class="expand" for="c-36427307">[1 more]</label></div><br/><div class="children"><div class="content">I went through an âOOP in Câ phase when I first got into C years ago.  This stack overflow[1] helped a lot as well<p>1. <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;351733&#x2F;how-would-one-write-object-oriented-code-in-c" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;351733&#x2F;how-would-one-wri...</a></div><br/></div></div><div id="36428369" class="c"><input type="checkbox" id="c-36428369" checked=""/><div class="controls bullet"><span class="by">Tomis02</span><span>|</span><a href="#36427307">prev</a><span>|</span><a href="#36428082">next</a><span>|</span><label class="collapse" for="c-36428369">[-]</label><label class="expand" for="c-36428369">[8 more]</label></div><br/><div class="children"><div class="content">As far as I can tell, the author says that &quot;ANSI-C is a full-scale object-oriented language&quot; in a slightly sarcastic tone, as there&#x27;s nothing particular to OOP languages that you can&#x27;t do in C. But I&#x27;ve heard many people say (and mean it) they do OOP in C.<p>I find it a bit dubious to claim you&#x27;re doing OOP in C, considering that C does not have objects. And I find it twice as dubious because you can translate any FP&#x2F;OOP code to procedural C; at this rate, you can start claiming that your x86 binary is OOP.<p>I often hear that &quot;FILE is an object, it&#x27;s exactly as if C++ had class FILE {...}, the class is just syntactic sugar, the result of the compilation is identical&quot;.<p>This is false, as it&#x27;s not &quot;just syntactic sugar&quot;. A C++ class binds a function to a specific struct, and the function can &quot;belong&quot; to no other struct. When doing OOP you have to choose - function F belongs to either object A or to object B. It can&#x27;t belong to both. Which is why OOP has endlessly silly discussions about whether class Car should Turn() the class Wheel, or should the class Wheel Turn() class Car. Or should we refactor it into class SteeringWheel that will Turn() both Car and Wheel.<p>This is not a thing in C. Linus Torvalds can add a function F that operates on the internals of both FILE and DIR at the same time, for example, and suddenly it&#x27;s less clear who &quot;owns&quot; F and which one is the object.<p>Which is why, personally, I don&#x27;t think doing dynamic dispatch with void* in C can be qualified as OOP, it&#x27;s just a pattern that&#x27;s been there ever since the language was introduced. It&#x27;s only after you add specific OOP features to the language that it devolves into an OOP language.</div><br/><div id="36428989" class="c"><input type="checkbox" id="c-36428989" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#36428369">parent</a><span>|</span><a href="#36428667">next</a><span>|</span><label class="collapse" for="c-36428989">[-]</label><label class="expand" for="c-36428989">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I understand the reasoning here. It seems to me that you have it the wrong way around, so maybe I&#x27;m missing something really obvious:<p>&gt; This is not a thing in C. Linus Torvalds can add a function F that operates on the internals of both FILE and DIR at the same time, for example, and suddenly it&#x27;s less clear who &quot;owns&quot; F and which one is the object.<p>In this respect C is strongly-typed and you will most definitely see compilation errors if `void F(FILE *fp)` is called as `DIR *dp; F(dp)`. If you want to make a function F that operates on both `FILE` and `DIR` types, you have to bypass the type checks <i>explicitly!</i> IOW, it is <i>always</i> clear to the reader of the code that F can take either a `FILE` or a `DIR`, or only a `FILE` or only a `DIR`. There is never any ambiguity to the reader.<p>OTOH, with C++ ...<p>&gt; A C++ class binds a function to a specific struct, and the function can &quot;belong&quot; to no other struct.<p>Unlike C above, this is <i>never clear</i> to the reader of the code though. For example, looping over an array of instances calling `.F()` on each instance: the reader cannot know which implementation of `F` is being invoked.<p>It&#x27;s literally impossible to tell just by looking at the loop. Sometimes it&#x27;s impossible to tell even by examining <i>all</i> the code because the specific method that is bound to an instance may only be determined at runtime.</div><br/></div></div><div id="36428667" class="c"><input type="checkbox" id="c-36428667" checked=""/><div class="controls bullet"><span class="by">kallistisoft</span><span>|</span><a href="#36428369">parent</a><span>|</span><a href="#36428989">prev</a><span>|</span><a href="#36428503">next</a><span>|</span><label class="collapse" for="c-36428667">[-]</label><label class="expand" for="c-36428667">[1 more]</label></div><br/><div class="children"><div class="content">You can absolutely translate object oriented C++ to vanilla C. As a young teenager I would routinely convert C++ from books I got from my parents&#x2F;library to C, because I didn&#x27;t have access to a C++ compiler. The process isn&#x27;t that difficult....<p>Take the members of the C++ object and create a struct to hold the data then create a &#x27;constructor&#x27; function for populating that data. Afterwards you just call the member functions of the original class, as simple C functions, and pass the struct as the first argument.<p>This in fact is what the actually happens at the assembly level when using a C++ compiler! The idea of an &#x27;object&#x27; is purely an abstraction!</div><br/></div></div><div id="36428503" class="c"><input type="checkbox" id="c-36428503" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#36428369">parent</a><span>|</span><a href="#36428667">prev</a><span>|</span><a href="#36428496">next</a><span>|</span><label class="collapse" for="c-36428503">[-]</label><label class="expand" for="c-36428503">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This is not a thing in C. Linus Torvalds can add a function F that operates on the internals of both FILE and DIR at the same time, for example, and suddenly it&#x27;s less clear who &quot;owns&quot; F and which one is the object.<p>It isnât a thing in a C++ either if one makes all the fields public or if one uses friend.<p>Member accessibility is not essential to the idea of OOP, since there are OOP languages which donât have it, or in which it is merely a convention, or something which can be overridden-and a person can use an OOP language which has it yet fail to use it.<p>So, I donât think âC lacks private membersâ is a good argument against C being âOOPâ. Especially when C actually has the moral equivalent of âprivateâ given APIs can be based on opaque pointers, so your compilation unit has no idea what the fields or layout of some structure controlled by another is.</div><br/><div id="36428606" class="c"><input type="checkbox" id="c-36428606" checked=""/><div class="controls bullet"><span class="by">Tomis02</span><span>|</span><a href="#36428369">root</a><span>|</span><a href="#36428503">parent</a><span>|</span><a href="#36428496">next</a><span>|</span><label class="collapse" for="c-36428606">[-]</label><label class="expand" for="c-36428606">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It isnât a thing in a C++<p>But it is a thing in OOP. That&#x27;s the point. C++ is multiparadigm. All the OOP gurus will tell you that objects shouldn&#x27;t expose their internal data, only methods.<p>That&#x27;s why the so-called encapsulation is constantly brought up. People telling you C is OOP will say &quot;FILE is an object, the FILE struct + fopen&#x2F;fclose&#x2F;fwrite constitute an object, FILE is opaque, we can only interact with its internals through the public methods&quot;. &quot;DIR is an object, ...&quot;. And so on.<p>And the problem is that when the Linux C API exposes a function that takes both a FILE and a DIR, and operates on both their internals, your whole idea of OOP-ness shatters because a method can only belong to a single object, by definition.</div><br/></div></div></div></div><div id="36428496" class="c"><input type="checkbox" id="c-36428496" checked=""/><div class="controls bullet"><span class="by">ameminator</span><span>|</span><a href="#36428369">parent</a><span>|</span><a href="#36428503">prev</a><span>|</span><a href="#36428505">next</a><span>|</span><label class="collapse" for="c-36428496">[-]</label><label class="expand" for="c-36428496">[2 more]</label></div><br/><div class="children"><div class="content">However, one CAN do &quot;object-oriented&quot; programming in C. There are ways of modeling what a piece of data <i>is</i> (a struct with its members). There are ways of modeling how a piece of data can behave (functions operating on those structs&#x2F;pointers to structs). Perhaps this is lacking in features and expressiveness compared to OOP-first languages like C#, C++ and others, but object-oriented concepts can apply in C - look to the compiler to organize private, public functions and ownership.</div><br/><div id="36428729" class="c"><input type="checkbox" id="c-36428729" checked=""/><div class="controls bullet"><span class="by">Tomis02</span><span>|</span><a href="#36428369">root</a><span>|</span><a href="#36428496">parent</a><span>|</span><a href="#36428505">next</a><span>|</span><label class="collapse" for="c-36428729">[-]</label><label class="expand" for="c-36428729">[1 more]</label></div><br/><div class="children"><div class="content">I agree that you can _imagine_ that FILE and DIR are objects, you can imagine they have behaviour, you can apply your OOP mental model to procedural code.<p>But it all breaks down the moment you add a function that operates on the internals of both FILE and DIR, because this function doesn&#x27;t belong to any one object. And if you don&#x27;t notice it, you keep thinking FILE and DIR are objects, when in fact they&#x27;re not (a method can&#x27;t &quot;belong&quot; to two objects, at least as far as objects are perceived in the software world).<p>In short, I can agree that it&#x27;s possible to write C with a OOP mindset. But (let&#x27;s call it) imaginary OOP may not be actual OOP (as when enforced by the C++ compiler).</div><br/></div></div></div></div><div id="36428505" class="c"><input type="checkbox" id="c-36428505" checked=""/><div class="controls bullet"><span class="by">G3rn0ti</span><span>|</span><a href="#36428369">parent</a><span>|</span><a href="#36428496">prev</a><span>|</span><a href="#36428082">next</a><span>|</span><label class="collapse" for="c-36428505">[-]</label><label class="expand" for="c-36428505">[1 more]</label></div><br/><div class="children"><div class="content">OOP is essentially a software architecture model. You can use this architecture in any language with a bit of discipline even if it does not give you all syntactical safety guarantees. At some point even object oriented assembler was a thing (as assembly routines may very well receive an address pointing to an object).</div><br/></div></div></div></div><div id="36428082" class="c"><input type="checkbox" id="c-36428082" checked=""/><div class="controls bullet"><span class="by">rectang</span><span>|</span><a href="#36428369">prev</a><span>|</span><a href="#36423462">next</a><span>|</span><label class="collapse" for="c-36428082">[-]</label><label class="expand" for="c-36428082">[1 more]</label></div><br/><div class="children"><div class="content">I read this whole book maybe 15 years ago.  I donât remember much detail at this point and the project I was working on at the time has been retired.  Still, I have fond memories of the learning process. Manually building up single inheritance OOP with structs and vtables using C is very educational.</div><br/></div></div><div id="36423462" class="c"><input type="checkbox" id="c-36423462" checked=""/><div class="controls bullet"><span class="by">aninteger</span><span>|</span><a href="#36428082">prev</a><span>|</span><a href="#36427062">next</a><span>|</span><label class="collapse" for="c-36423462">[-]</label><label class="expand" for="c-36423462">[7 more]</label></div><br/><div class="children"><div class="content">And for people who took this to the &quot;next level&quot; just look at GTK.</div><br/><div id="36423636" class="c"><input type="checkbox" id="c-36423636" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36423462">parent</a><span>|</span><a href="#36424216">prev</a><span>|</span><a href="#36427062">next</a><span>|</span><label class="collapse" for="c-36423636">[-]</label><label class="expand" for="c-36423636">[5 more]</label></div><br/><div class="children"><div class="content">That would have been Motif and CDE, which Gtk is based on as idea.</div><br/><div id="36423828" class="c"><input type="checkbox" id="c-36423828" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#36423462">root</a><span>|</span><a href="#36423636">parent</a><span>|</span><a href="#36427062">next</a><span>|</span><label class="collapse" for="c-36423828">[-]</label><label class="expand" for="c-36423828">[4 more]</label></div><br/><div class="children"><div class="content">No seriously, the GTK C bindings are basically written in a half-formed version of the old C++ &quot;C with preprocessor macros&quot; syntax.<p>It looks like this when you program it:<p><pre><code>    GtkWidget* grid = gtk_grid_new();
    GtkWidget* label = gtk_label_new(&quot;Hello World&quot;);
    gtk_grid_attach(GTK_GRID(grid), label, 0, 0, 1, 1);
</code></pre>
That GTK_GRID bit is a macro that evaluates at runtime and will chuck out runtime errors if the widget doesn&#x27;t match.  It supports inheritance.  If you have for example a gtk_combo_box_text, you can use gtk_combo_box_set_active(GTK_COMBO_BOX(my_combo_box_text), 0) and it will select the first entry in the gtk_combo_box_text because gtk_combo_box_text inherits from gtk_combo_box like any good object oriented system.</div><br/><div id="36425210" class="c"><input type="checkbox" id="c-36425210" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#36423462">root</a><span>|</span><a href="#36423828">parent</a><span>|</span><a href="#36426212">next</a><span>|</span><label class="collapse" for="c-36425210">[-]</label><label class="expand" for="c-36425210">[2 more]</label></div><br/><div class="children"><div class="content">Motif&#x2F;libxm is very similar to that. With two important exceptions: the user code does not use type-checking macros and âstringly-typedâ API for set a property to something is more or less a part of the overall ecosystem (well, Xm is just an layer built on top of Xt).<p>Gtk+ was originally an implementation of whatever parts of Motif were used by Gimp, built on an underlying object model that has nothing to do with Xt (which has both good and bad implications).</div><br/><div id="36427609" class="c"><input type="checkbox" id="c-36427609" checked=""/><div class="controls bullet"><span class="by">opan</span><span>|</span><a href="#36423462">root</a><span>|</span><a href="#36425210">parent</a><span>|</span><a href="#36426212">next</a><span>|</span><label class="collapse" for="c-36427609">[-]</label><label class="expand" for="c-36427609">[1 more]</label></div><br/><div class="children"><div class="content">&gt;which has both good and bad implications<p>Could you tell us what these implications are?</div><br/></div></div></div></div><div id="36426212" class="c"><input type="checkbox" id="c-36426212" checked=""/><div class="controls bullet"><span class="by">reidacdc</span><span>|</span><a href="#36423462">root</a><span>|</span><a href="#36423828">parent</a><span>|</span><a href="#36425210">prev</a><span>|</span><a href="#36427062">next</a><span>|</span><label class="collapse" for="c-36426212">[-]</label><label class="expand" for="c-36426212">[1 more]</label></div><br/><div class="children"><div class="content">I remember writing a GTK extension widget many years ago, and yes, it was very much like this. The macros end up making your very own hand-coded vtable-equivalent, so that function calls get dispatched to the appropriate point in the inheritance chain. It was pretty eye-opening!</div><br/></div></div></div></div></div></div></div></div><div id="36427062" class="c"><input type="checkbox" id="c-36427062" checked=""/><div class="controls bullet"><span class="by">WoodenChair</span><span>|</span><a href="#36423462">prev</a><span>|</span><a href="#36428185">next</a><span>|</span><label class="collapse" for="c-36427062">[-]</label><label class="expand" for="c-36427062">[3 more]</label></div><br/><div class="children"><div class="content">I skimmed the first couple of chapters and the syntax you have to go through to make this work looks painful at best. void * everywhere. Structs with C&#x27;s function pointer syntax all over the place... It looks like it can certainly work, but it&#x27;s not going to be pleasant compared to almost anything designed for OO.</div><br/><div id="36428586" class="c"><input type="checkbox" id="c-36428586" checked=""/><div class="controls bullet"><span class="by">G3rn0ti</span><span>|</span><a href="#36427062">parent</a><span>|</span><a href="#36428141">next</a><span>|</span><label class="collapse" for="c-36428586">[-]</label><label class="expand" for="c-36428586">[1 more]</label></div><br/><div class="children"><div class="content">You donât need all that to emulate objects in C. Instead use this recipe:<p>- classes &lt;-&gt; compilation units<p>- objects &lt;-&gt; structs<p>- methods &lt;-&gt; functions receiving a pointer to a struct as first argument; use name of the class as prefix e.g. Point3D_scale(Point3D *self, double factor)<p>- constructors are just methods and initialize the struct<p>- destructors are just methods and free all memory occupied by the struct<p>Inheritance is a bit more difficult this way but as others pointed out already it is way over used IMHO. But if you really want to do that you could design a child class by using a struct pointing to the parent struct and using  that to manually delegate all inherited method calls to the parent. You could probably write a fancy macro automating this delegation for you.</div><br/></div></div><div id="36428141" class="c"><input type="checkbox" id="c-36428141" checked=""/><div class="controls bullet"><span class="by">rectang</span><span>|</span><a href="#36427062">parent</a><span>|</span><a href="#36428586">prev</a><span>|</span><a href="#36428185">next</a><span>|</span><label class="collapse" for="c-36428141">[-]</label><label class="expand" for="c-36428141">[1 more]</label></div><br/><div class="children"><div class="content">Youâre right about the syntax becoming extremely tedious.  Eventually you wind up doing waaaay too many function pointer casts and typedefs.<p>The appeal of this approach, to me, is mostly pedagogic rather than practical: stuff designed for OOP isnât generally going to let you control struct layout to the degree that C will, making it harder to get your hands dirty and learn core concepts.</div><br/></div></div></div></div><div id="36428185" class="c"><input type="checkbox" id="c-36428185" checked=""/><div class="controls bullet"><span class="by">alfiedotwtf</span><span>|</span><a href="#36427062">prev</a><span>|</span><a href="#36425476">next</a><span>|</span><label class="collapse" for="c-36428185">[-]</label><label class="expand" for="c-36428185">[1 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t find the link now, but there was some malware recently (maybe under 3 years ago) that was found to directly use this book as a basis for their code.</div><br/></div></div><div id="36425476" class="c"><input type="checkbox" id="c-36425476" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36428185">prev</a><span>|</span><a href="#36422161">next</a><span>|</span><label class="collapse" for="c-36425476">[-]</label><label class="expand" for="c-36425476">[8 more]</label></div><br/><div class="children"><div class="content">&gt; I could not forge a portable implementation in C++.<p>i would like to know why not.</div><br/><div id="36425968" class="c"><input type="checkbox" id="c-36425968" checked=""/><div class="controls bullet"><span class="by">kenjackson</span><span>|</span><a href="#36425476">parent</a><span>|</span><a href="#36422161">next</a><span>|</span><label class="collapse" for="c-36425968">[-]</label><label class="expand" for="c-36425968">[7 more]</label></div><br/><div class="children"><div class="content">I suspect the state of the compilers in 1993. And maybe the standard even. When I was using C++ a lot in 2000 it was difficult to get non-trivial code working across compilers.</div><br/><div id="36426086" class="c"><input type="checkbox" id="c-36426086" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36425476">root</a><span>|</span><a href="#36425968">parent</a><span>|</span><a href="#36422161">next</a><span>|</span><label class="collapse" for="c-36426086">[-]</label><label class="expand" for="c-36426086">[6 more]</label></div><br/><div class="children"><div class="content">certainly true (first c++ standard was in 98) but i think this is more a library issue than anything else, which isn&#x27;t germain to this article. i haven&#x27;t read the article in depth, but things like new&#x2F;delete, constructors and virtual functions in wide use in 93. and let&#x27;s not forget that C itself was only standardised in 89, and it took vendors a long time to catch up with that standard.</div><br/><div id="36426913" class="c"><input type="checkbox" id="c-36426913" checked=""/><div class="controls bullet"><span class="by">jamesfinlayson</span><span>|</span><a href="#36425476">root</a><span>|</span><a href="#36426086">parent</a><span>|</span><a href="#36422161">next</a><span>|</span><label class="collapse" for="c-36426913">[-]</label><label class="expand" for="c-36426913">[5 more]</label></div><br/><div class="children"><div class="content">Library issue was my understanding - the Half-Life mod Natural Selection used the STL heavily and was built for both Windows and Linux (Linux for dedicated servers).
When the source code was released many years later the documentation said it needed a library called stlport - some third-party implementation of the STL because even in 2002 when Natural Selection was released, different compilers apparently shipped STLs of varying quality.</div><br/><div id="36427139" class="c"><input type="checkbox" id="c-36427139" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36425476">root</a><span>|</span><a href="#36426913">parent</a><span>|</span><a href="#36427957">next</a><span>|</span><label class="collapse" for="c-36427139">[-]</label><label class="expand" for="c-36427139">[2 more]</label></div><br/><div class="children"><div class="content">i don&#x27;t know about the half life stuff. stlport was (is?) a portable implemrntation of the Standard Template Library. this is far from the same as the C++ Standard Library.</div><br/><div id="36428019" class="c"><input type="checkbox" id="c-36428019" checked=""/><div class="controls bullet"><span class="by">jamesfinlayson</span><span>|</span><a href="#36425476">root</a><span>|</span><a href="#36427139">parent</a><span>|</span><a href="#36427957">next</a><span>|</span><label class="collapse" for="c-36428019">[-]</label><label class="expand" for="c-36428019">[1 more]</label></div><br/><div class="children"><div class="content">It was only used by one of the bigger Half-Life mods (nothing first party - Half-Life&#x27;s game code is very much C with classes). Possibly other mods used it but I suspect that most Half-Life mods kept to the style of the original.</div><br/></div></div></div></div><div id="36427957" class="c"><input type="checkbox" id="c-36427957" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#36425476">root</a><span>|</span><a href="#36426913">parent</a><span>|</span><a href="#36427139">prev</a><span>|</span><a href="#36422161">next</a><span>|</span><label class="collapse" for="c-36427957">[-]</label><label class="expand" for="c-36427957">[2 more]</label></div><br/><div class="children"><div class="content">STLport was the open sourcing of SGI&#x27;s STL implementation, and its existence I think kinda predated the completion of a full STL shipped with either MSVC or GCC. It got used back then because of, yeah, varying quality between compilers but also varying <i>consistency</i>. If you wanted something that could compile on both G++ and MSVC7 or earlier you were probably going to reach for stuff like that, or have a pile of #ifdefs and pain.<p>C++ is a far nicer language to work with these days. Back then everyone rolled their own string etc. library, too. Sucked.</div><br/><div id="36428006" class="c"><input type="checkbox" id="c-36428006" checked=""/><div class="controls bullet"><span class="by">jamesfinlayson</span><span>|</span><a href="#36425476">root</a><span>|</span><a href="#36427957">parent</a><span>|</span><a href="#36422161">next</a><span>|</span><label class="collapse" for="c-36428006">[-]</label><label class="expand" for="c-36428006">[1 more]</label></div><br/><div class="children"><div class="content">Ah okay - I think when I went looking for STLport at the time all I could find was an old mirror on SourceForge.
But yeah that sounds about right.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36422161" class="c"><input type="checkbox" id="c-36422161" checked=""/><div class="controls bullet"><span class="by">jjgreen</span><span>|</span><a href="#36425476">prev</a><span>|</span><label class="collapse" for="c-36422161">[-]</label><label class="expand" for="c-36422161">[9 more]</label></div><br/><div class="children"><div class="content">(1993)</div><br/><div id="36423309" class="c"><input type="checkbox" id="c-36423309" checked=""/><div class="controls bullet"><span class="by">gjvc</span><span>|</span><a href="#36422161">parent</a><span>|</span><a href="#36422229">next</a><span>|</span><label class="collapse" for="c-36423309">[-]</label><label class="expand" for="c-36423309">[7 more]</label></div><br/><div class="children"><div class="content">unlikely to be 2023, now, is it?</div><br/><div id="36426134" class="c"><input type="checkbox" id="c-36426134" checked=""/><div class="controls bullet"><span class="by">j1elo</span><span>|</span><a href="#36422161">root</a><span>|</span><a href="#36423309">parent</a><span>|</span><a href="#36425731">next</a><span>|</span><label class="collapse" for="c-36426134">[-]</label><label class="expand" for="c-36426134">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll do object-oriented programming with C in 2023 if you want to use the main official API of the GStreamer multimedia framework [1], which is C-based and heavily using GObject object model [2], which itself is part of GLib (the underlying library of GTK)<p>[1]: <a href="https:&#x2F;&#x2F;gstreamer.freedesktop.org&#x2F;documentation&#x2F;gstreamer&#x2F;gstobject.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;gstreamer.freedesktop.org&#x2F;documentation&#x2F;gstreamer&#x2F;gs...</a><p>[2]: <a href="https:&#x2F;&#x2F;docs.gtk.org&#x2F;gobject&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.gtk.org&#x2F;gobject&#x2F;</a></div><br/></div></div><div id="36425731" class="c"><input type="checkbox" id="c-36425731" checked=""/><div class="controls bullet"><span class="by">JohnFen</span><span>|</span><a href="#36422161">root</a><span>|</span><a href="#36423309">parent</a><span>|</span><a href="#36426134">prev</a><span>|</span><a href="#36425381">next</a><span>|</span><label class="collapse" for="c-36425731">[-]</label><label class="expand" for="c-36425731">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m doing OOP in C right now in my work. I&#x27;m porting a C++ program to a new platform and, for reasons, the most feasible language to use for it is C.<p>Re-engineering the code to be not object oriented is not practical, so we&#x27;re keeping its OO nature.</div><br/><div id="36427226" class="c"><input type="checkbox" id="c-36427226" checked=""/><div class="controls bullet"><span class="by">proxyon</span><span>|</span><a href="#36422161">root</a><span>|</span><a href="#36425731">parent</a><span>|</span><a href="#36425381">next</a><span>|</span><label class="collapse" for="c-36427226">[-]</label><label class="expand" for="c-36427226">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the point of refactoring C++ to C? That sounds weird and regressive.</div><br/><div id="36428603" class="c"><input type="checkbox" id="c-36428603" checked=""/><div class="controls bullet"><span class="by">acuozzo</span><span>|</span><a href="#36422161">root</a><span>|</span><a href="#36427226">parent</a><span>|</span><a href="#36425381">next</a><span>|</span><label class="collapse" for="c-36428603">[-]</label><label class="expand" for="c-36428603">[1 more]</label></div><br/><div class="children"><div class="content">No C++ compiler for the target architecture?</div><br/></div></div></div></div></div></div><div id="36425381" class="c"><input type="checkbox" id="c-36425381" checked=""/><div class="controls bullet"><span class="by">omgmajk</span><span>|</span><a href="#36422161">root</a><span>|</span><a href="#36423309">parent</a><span>|</span><a href="#36425731">prev</a><span>|</span><a href="#36422229">next</a><span>|</span><label class="collapse" for="c-36425381">[-]</label><label class="expand" for="c-36425381">[2 more]</label></div><br/><div class="children"><div class="content">Would be interesting if it was actually. Kinda feel like playing with this for fun.</div><br/><div id="36425763" class="c"><input type="checkbox" id="c-36425763" checked=""/><div class="controls bullet"><span class="by">wtetzner</span><span>|</span><a href="#36422161">root</a><span>|</span><a href="#36425381">parent</a><span>|</span><a href="#36422229">next</a><span>|</span><label class="collapse" for="c-36425763">[-]</label><label class="expand" for="c-36425763">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a new library that provides OOP in C: <a href="https:&#x2F;&#x2F;github.com&#x2F;gyrovorbis&#x2F;libgimbal">https:&#x2F;&#x2F;github.com&#x2F;gyrovorbis&#x2F;libgimbal</a></div><br/></div></div></div></div></div></div><div id="36422229" class="c"><input type="checkbox" id="c-36422229" checked=""/><div class="controls bullet"><span class="by">Tomte</span><span>|</span><a href="#36422161">parent</a><span>|</span><a href="#36423309">prev</a><span>|</span><label class="collapse" for="c-36422229">[-]</label><label class="expand" for="c-36422229">[1 more]</label></div><br/><div class="children"><div class="content">Thanks!</div><br/></div></div></div></div></div></div></div></div></div></body></html>