<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709370077097" as="style"/><link rel="stylesheet" href="styles.css?v=1709370077097"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.trailofbits.com/2024/03/01/toward-more-effective-curl-fuzzing/">How we applied fuzzing techniques to cURL</a> <span class="domain">(<a href="https://blog.trailofbits.com">blog.trailofbits.com</a>)</span></div><div class="subtext"><span>ingve</span> | <span>70 comments</span></div><br/><div><div id="39565046" class="c"><input type="checkbox" id="c-39565046" checked=""/><div class="controls bullet"><span class="by">PoignardAzur</span><span>|</span><a href="#39569950">next</a><span>|</span><label class="collapse" for="c-39565046">[-]</label><label class="expand" for="c-39565046">[6 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get the part about custom mutators:<p>&gt; <i>If the data can’t be parsed into a valid TLV, instead of throwing it away, return a syntactically correct dummy TLV. This can be anything, as long as it can be successfully unpacked.</i><p>If you&#x27;re creating a dummy value, how is that better than failing? How does that give your fuzzer better coverage?</div><br/><div id="39565299" class="c"><input type="checkbox" id="c-39565299" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#39565046">parent</a><span>|</span><a href="#39565295">next</a><span>|</span><label class="collapse" for="c-39565299">[-]</label><label class="expand" for="c-39565299">[2 more]</label></div><br/><div class="children"><div class="content">Not an expert, but I am a power user of fuzzers.<p>The problem is that the space of invalid inputs is far larger than the space of valid inputs. Sometimes orders of magnitude larger, say billions or more invalid inputs to one valid input.<p>Naive fuzzing will hit so many error cases that it will hardly produce a valid input. For the ratio that I mentioned, you might run a fuzzer for a billion runs and only get one valid input in the bunch.<p>Using a custom mutator and returning a dummy value will give the fuzzer a starting point from a valid input and makes generating other valid inputs more likely.<p>For my part, I prefer to use custom mutators to generate valid test cases most of the time, but I want some invalid inputs because error handling is where most bugs are.</div><br/><div id="39569774" class="c"><input type="checkbox" id="c-39569774" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#39565046">root</a><span>|</span><a href="#39565299">parent</a><span>|</span><a href="#39565295">next</a><span>|</span><label class="collapse" for="c-39569774">[-]</label><label class="expand" for="c-39569774">[1 more]</label></div><br/><div class="children"><div class="content">I personally would separate that into two separate fuzz cases - one that generates only valid inputs and one that generates only invalid inputs and spend more resources on verifying the latter because validating invalid inputs is more important. I didn’t read the article but I like property testing for this where your mutator takes random values and uses that to generate a valid input somehow rather than stubbing in a static value. Where I can use a static value is where I wouldn’t be fuzzing the validation of that value. Of course certs are complicated beasts so I’m sure the cURL people did what made sense to them.</div><br/></div></div></div></div><div id="39565295" class="c"><input type="checkbox" id="c-39565295" checked=""/><div class="controls bullet"><span class="by">pstrateman</span><span>|</span><a href="#39565046">parent</a><span>|</span><a href="#39565299">prev</a><span>|</span><a href="#39569602">next</a><span>|</span><label class="collapse" for="c-39565295">[-]</label><label class="expand" for="c-39565295">[1 more]</label></div><br/><div class="children"><div class="content">The file format they choose is difficult for a fuzzer to produce valid examples by random chance.<p>The file format isn&#x27;t what&#x27;s being fuzzed, so trying to accept as many things as possible as valid is useful.<p>It&#x27;s a trick to make the fuzzer faster.</div><br/></div></div><div id="39569602" class="c"><input type="checkbox" id="c-39569602" checked=""/><div class="controls bullet"><span class="by">mkj</span><span>|</span><a href="#39565046">parent</a><span>|</span><a href="#39565295">prev</a><span>|</span><a href="#39566611">next</a><span>|</span><label class="collapse" for="c-39569602">[-]</label><label class="expand" for="c-39569602">[1 more]</label></div><br/><div class="children"><div class="content">You want the failures to occur deeper in the programs so you cover more code paths.</div><br/></div></div><div id="39566611" class="c"><input type="checkbox" id="c-39566611" checked=""/><div class="controls bullet"><span class="by">stefan_</span><span>|</span><a href="#39565046">parent</a><span>|</span><a href="#39569602">prev</a><span>|</span><a href="#39569950">next</a><span>|</span><label class="collapse" for="c-39566611">[-]</label><label class="expand" for="c-39566611">[1 more]</label></div><br/><div class="children"><div class="content">Remember TLV is for &quot;Type Length Value&quot;. It&#x27;s better to take your fuzzer output for value (or possibly type and value) but generate the length and final TLV yourself than having tons of fuzzer generated sequences already fail at the very basic type&#x2F;length check that is unlikely to be vulnerable in software like cURL (but can be in many others..).</div><br/></div></div></div></div><div id="39569950" class="c"><input type="checkbox" id="c-39569950" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#39565046">prev</a><span>|</span><a href="#39568747">next</a><span>|</span><label class="collapse" for="c-39569950">[-]</label><label class="expand" for="c-39569950">[1 more]</label></div><br/><div class="children"><div class="content">Lots of good info here about how they added more fuzz tests, but no mention whether the fuzzing actually found bugs?</div><br/></div></div><div id="39564526" class="c"><input type="checkbox" id="c-39564526" checked=""/><div class="controls bullet"><span class="by">SamuelAdams</span><span>|</span><a href="#39567107">prev</a><span>|</span><a href="#39566753">next</a><span>|</span><label class="collapse" for="c-39564526">[-]</label><label class="expand" for="c-39564526">[29 more]</label></div><br/><div class="children"><div class="content">I am curious how much effort goes into creating and maintaining unit tests and fuzzing tests. Sometimes it takes longer &#x2F; more lines of code to write thorough tests than it does to implement the core feature.<p>At that point, is it worth the time invested? Every new feature can take 2-3 times longer to deliver due to adding tests.</div><br/><div id="39565824" class="c"><input type="checkbox" id="c-39565824" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#39564526">parent</a><span>|</span><a href="#39566211">next</a><span>|</span><label class="collapse" for="c-39565824">[-]</label><label class="expand" for="c-39565824">[2 more]</label></div><br/><div class="children"><div class="content">In the case of curl, the cost&#x2F;benefit analysis is probably skewed by it being deployed on a <i>massive</i> scale, such that any bugs in curl have an unusually large impact. If your company&#x27;s in-house CRM has an exploitable bug, that&#x27;s <i>bad</i> but the impact is just your company. If libcurl has an exploitable bug, that&#x27;s millions of devices affected.</div><br/><div id="39568348" class="c"><input type="checkbox" id="c-39568348" checked=""/><div class="controls bullet"><span class="by">DylanSp</span><span>|</span><a href="#39564526">root</a><span>|</span><a href="#39565824">parent</a><span>|</span><a href="#39566211">next</a><span>|</span><label class="collapse" for="c-39568348">[-]</label><label class="expand" for="c-39568348">[1 more]</label></div><br/><div class="children"><div class="content">Probably <i>billions</i> of devices at this point, honestly.</div><br/></div></div></div></div><div id="39566211" class="c"><input type="checkbox" id="c-39566211" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#39564526">parent</a><span>|</span><a href="#39565824">prev</a><span>|</span><a href="#39566256">next</a><span>|</span><label class="collapse" for="c-39566211">[-]</label><label class="expand" for="c-39566211">[4 more]</label></div><br/><div class="children"><div class="content">Code that isn&#x27;t tested, isn&#x27;t done. Tests not only verify the expectations, but also prevent future regression. Fuzzing is essential for code that accepts external inputs. Heartbleed was discoverable with a fuzzer.</div><br/><div id="39570533" class="c"><input type="checkbox" id="c-39570533" checked=""/><div class="controls bullet"><span class="by">kgeist</span><span>|</span><a href="#39564526">root</a><span>|</span><a href="#39566211">parent</a><span>|</span><a href="#39569105">next</a><span>|</span><label class="collapse" for="c-39570533">[-]</label><label class="expand" for="c-39570533">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Code that isn&#x27;t tested, isn&#x27;t done. Tests not only verify the expectations, but also prevent future regression<p>A few weeks ago someone at the company implemented a feature without tests. It worked perfectly, everyone was happy. A release of another new feature by a different team a few days later broke the previous feature :)</div><br/></div></div><div id="39569105" class="c"><input type="checkbox" id="c-39569105" checked=""/><div class="controls bullet"><span class="by">jnwatson</span><span>|</span><a href="#39564526">root</a><span>|</span><a href="#39566211">parent</a><span>|</span><a href="#39570533">prev</a><span>|</span><a href="#39566256">next</a><span>|</span><label class="collapse" for="c-39569105">[-]</label><label class="expand" for="c-39569105">[2 more]</label></div><br/><div class="children"><div class="content">In most situations, we don&#x27;t get paid to make code &quot;done&#x27;. We get paid to get it close enough to work most of the time.</div><br/><div id="39569129" class="c"><input type="checkbox" id="c-39569129" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#39564526">root</a><span>|</span><a href="#39569105">parent</a><span>|</span><a href="#39566256">next</a><span>|</span><label class="collapse" for="c-39569129">[-]</label><label class="expand" for="c-39569129">[1 more]</label></div><br/><div class="children"><div class="content">True but cURL is in a very different situation compared to your average run-of-the-mill program. It&#x27;s one of the most massively deployed open-source software out there. When you are not beholden to capricious shareholders and incompetent managers you can actually focus on quality.</div><br/></div></div></div></div></div></div><div id="39566256" class="c"><input type="checkbox" id="c-39566256" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#39564526">parent</a><span>|</span><a href="#39566211">prev</a><span>|</span><a href="#39567376">next</a><span>|</span><label class="collapse" for="c-39566256">[-]</label><label class="expand" for="c-39566256">[10 more]</label></div><br/><div class="children"><div class="content">Everyone always praises SQLite<p>&gt; As of version 3.42.0 (2023-05-16), the SQLite library consists of approximately 155.8 KSLOC of C code [...] the project has 590 times as much test code and test scripts - 92053.1 KSLOC.<p><a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;testing.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;testing.html</a></div><br/><div id="39568425" class="c"><input type="checkbox" id="c-39568425" checked=""/><div class="controls bullet"><span class="by">dkubb</span><span>|</span><a href="#39564526">root</a><span>|</span><a href="#39566256">parent</a><span>|</span><a href="#39566302">next</a><span>|</span><label class="collapse" for="c-39568425">[-]</label><label class="expand" for="c-39568425">[1 more]</label></div><br/><div class="children"><div class="content">I once found a confirmed bug in SQLite one time, and it’s the highlight of all my OSS bug reports.<p>Interestingly enough I found it while fuzz testing a query builder and cross testing it against PostgreSQL, MySQL and an in-memory filtering engine I wrote.</div><br/></div></div><div id="39566302" class="c"><input type="checkbox" id="c-39566302" checked=""/><div class="controls bullet"><span class="by">guerrilla</span><span>|</span><a href="#39564526">root</a><span>|</span><a href="#39566256">parent</a><span>|</span><a href="#39568425">prev</a><span>|</span><a href="#39567376">next</a><span>|</span><label class="collapse" for="c-39566302">[-]</label><label class="expand" for="c-39566302">[8 more]</label></div><br/><div class="children"><div class="content">What the fuck. If they&#x27;re investing that much then why don&#x27;t they just go straight to formal verification. This is what things like frama-c (or whatever&#x27;s popular now) are for.</div><br/><div id="39566363" class="c"><input type="checkbox" id="c-39566363" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#39564526">root</a><span>|</span><a href="#39566302">parent</a><span>|</span><a href="#39567422">next</a><span>|</span><label class="collapse" for="c-39566363">[-]</label><label class="expand" for="c-39566363">[5 more]</label></div><br/><div class="children"><div class="content">The problem is that effort to do formal verification goes exponential beyond a certain point.<p>seL4 is around 10-12 KLoC, and it took a decade of effort from multiple people to make it happen.<p>At the size of SQLite, especially where they have to operate on platforms with different behavior (as an OS, seL4 <i>is</i> the platform), formal verification is just too much effort.<p>All that said, your reaction is <i>totally</i> understandable.</div><br/><div id="39567097" class="c"><input type="checkbox" id="c-39567097" checked=""/><div class="controls bullet"><span class="by">tonyarkles</span><span>|</span><a href="#39564526">root</a><span>|</span><a href="#39566363">parent</a><span>|</span><a href="#39567422">next</a><span>|</span><label class="collapse" for="c-39567097">[-]</label><label class="expand" for="c-39567097">[4 more]</label></div><br/><div class="children"><div class="content">Link to how SQLite is tested, for anyone who&#x27;s curious: <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;testing.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;testing.html</a><p>There&#x27;s also an interesting thing where formal verification requires a formal specification, which afaik there isn&#x27;t one for SQLite. One of the toughest problems that someone would run into trying to put together a formal specification for code as widely deployed as SQLite boils down to Hyrum&#x27;s Law[1]: on a long enough time scale, all observable behaviours of your system become interfaces that someone, somewhere depends on.<p>That massive suite of test cases isn&#x27;t a formal specification but given that it achieves 100% branch coverage that implies to me that it:<p>- pretty tightly bounds the interface without formally specifying it<p>- also pretty tightly constrains the implementation to match the current implementation<p>Which, when you have as many users as you do with SQLite, is probably a fair way of providing guarantees to your users that upgrading from 3.44.0 to 3.45.1 isn&#x27;t going to break anything you&#x27;re using unless you were relying on explicitly-identified buggy behaviour (you&#x27;d be able to see the delta in the test cases if you looked at the Fossil diffs).<p>[1] <a href="https:&#x2F;&#x2F;www.hyrumslaw.com" rel="nofollow">https:&#x2F;&#x2F;www.hyrumslaw.com</a></div><br/><div id="39567990" class="c"><input type="checkbox" id="c-39567990" checked=""/><div class="controls bullet"><span class="by">er4hn</span><span>|</span><a href="#39564526">root</a><span>|</span><a href="#39567097">parent</a><span>|</span><a href="#39569493">next</a><span>|</span><label class="collapse" for="c-39567990">[-]</label><label class="expand" for="c-39567990">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;corecursive.com&#x2F;066-sqlite-with-richard-hipp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;corecursive.com&#x2F;066-sqlite-with-richard-hipp&#x2F;</a> is an interesting interview with the lead developer for SQLite about the inspiration and work that went into that testing as well.</div><br/></div></div><div id="39569493" class="c"><input type="checkbox" id="c-39569493" checked=""/><div class="controls bullet"><span class="by">SAI_Peregrinus</span><span>|</span><a href="#39564526">root</a><span>|</span><a href="#39567097">parent</a><span>|</span><a href="#39567990">prev</a><span>|</span><a href="#39569750">next</a><span>|</span><label class="collapse" for="c-39569493">[-]</label><label class="expand" for="c-39569493">[1 more]</label></div><br/><div class="children"><div class="content">Also a formal specification can have bugs. Formal verification checks that the code matches the spec, not that the spec implements all desired behaviors and no undesired behaviors.</div><br/></div></div><div id="39569750" class="c"><input type="checkbox" id="c-39569750" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#39564526">root</a><span>|</span><a href="#39567097">parent</a><span>|</span><a href="#39569493">prev</a><span>|</span><a href="#39567422">next</a><span>|</span><label class="collapse" for="c-39569750">[-]</label><label class="expand" for="c-39569750">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the same link I posted in the original comment, JSYK.</div><br/></div></div></div></div></div></div><div id="39567422" class="c"><input type="checkbox" id="c-39567422" checked=""/><div class="controls bullet"><span class="by">summerlight</span><span>|</span><a href="#39564526">root</a><span>|</span><a href="#39566302">parent</a><span>|</span><a href="#39566363">prev</a><span>|</span><a href="#39567585">next</a><span>|</span><label class="collapse" for="c-39567422">[-]</label><label class="expand" for="c-39567422">[1 more]</label></div><br/><div class="children"><div class="content">Because formal verification doesn&#x27;t scale at the moment. There are a relatively few number of experts on formal method around the globe and some of them need to work on SQLite indefinitely unless you&#x27;re okay with just one-off verification. Frama-C has a different background because it&#x27;s from Inria, the institution with many formal method experts.</div><br/></div></div><div id="39567585" class="c"><input type="checkbox" id="c-39567585" checked=""/><div class="controls bullet"><span class="by">datadeft</span><span>|</span><a href="#39564526">root</a><span>|</span><a href="#39566302">parent</a><span>|</span><a href="#39567422">prev</a><span>|</span><a href="#39567376">next</a><span>|</span><label class="collapse" for="c-39567585">[-]</label><label class="expand" for="c-39567585">[1 more]</label></div><br/><div class="children"><div class="content">You can do many things other than testing:<p>- use a memory safe language<p>- formal verification (multiple implementations even)<p>- build a simulator like FoundationDB did</div><br/></div></div></div></div></div></div><div id="39567376" class="c"><input type="checkbox" id="c-39567376" checked=""/><div class="controls bullet"><span class="by">dogcomplex</span><span>|</span><a href="#39564526">parent</a><span>|</span><a href="#39566256">prev</a><span>|</span><a href="#39564675">next</a><span>|</span><label class="collapse" for="c-39567376">[-]</label><label class="expand" for="c-39567376">[2 more]</label></div><br/><div class="children"><div class="content">I would generally double whatever your expectations are for the initial feature development.  Tests are essentially a second implementation from a different angle running in parallel, hoping the results match.  Every feature change means changing 2 systems now.  You save a bit of subsequent time with easier debugging when other features break tests, but that&#x27;s somewhat eaten up by maintaining a system twice the size.<p>There are reasons many MVP developers and small teams whose focus is more on rapid feature implementation than large team coordination or code stability forego writing tests.  It doesn&#x27;t make sense in all circumstances.  Generally, more complex, less grokable, more large-team-oriented or public library code is when you need testing.</div><br/><div id="39569790" class="c"><input type="checkbox" id="c-39569790" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#39564526">root</a><span>|</span><a href="#39567376">parent</a><span>|</span><a href="#39564675">next</a><span>|</span><label class="collapse" for="c-39569790">[-]</label><label class="expand" for="c-39569790">[1 more]</label></div><br/><div class="children"><div class="content">Tests are only a second implementation if you use test doubles incorrectly. Test doubles should only be used for I&#x2F;O outside of the program under test that you can’t really run locally &#x2F; is a network dependency (eg mocking a SaaS service or something) or for performance (mocking database responses vs spinning up a test database instance). If you do it write, most of your tests are just testing each layer and everything below it.<p>I have yet to see a case where omitting tests actually helps you move meaningfully faster - you’re probably generating more heat than light and that makes you feel like you’re moving faster.</div><br/></div></div></div></div><div id="39564675" class="c"><input type="checkbox" id="c-39564675" checked=""/><div class="controls bullet"><span class="by">epistasis</span><span>|</span><a href="#39564526">parent</a><span>|</span><a href="#39567376">prev</a><span>|</span><a href="#39565062">next</a><span>|</span><label class="collapse" for="c-39564675">[-]</label><label class="expand" for="c-39564675">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a tradeoff for sure, but to fully evaluate that tradeoff you must also take into account the future time spent on the code base, including the amount of time needed to debug future features, adopt a new build environment, allow new team members to muck around and see what does and does not work...<p>If it&#x27;s a small project that won&#x27;t be extended much, then perhaps then re-runnable unit tests may not make the bar as a net positive tradeoff. But some time must still be spent testing the code, even if it&#x27;s not tests that are written in code.</div><br/></div></div><div id="39565062" class="c"><input type="checkbox" id="c-39565062" checked=""/><div class="controls bullet"><span class="by">avgcorrection</span><span>|</span><a href="#39564526">parent</a><span>|</span><a href="#39564675">prev</a><span>|</span><a href="#39566015">next</a><span>|</span><label class="collapse" for="c-39565062">[-]</label><label class="expand" for="c-39565062">[1 more]</label></div><br/><div class="children"><div class="content">The best-case IMO is a test suite where writing the test is almost as easy (or maybe easier?) than doing the equivalent manual test. The test code is maybe 2–4x longer than the change.<p>The worst case is… arbitrarily bad, to the point of being impossible. Test setup is hell because there are too many dependencies. You have to mock the “real world” since (again) things depend on other things too much and you can’t really do a simple string-manipulating change without setting up a whole environment. Also you introduce bugs in your tests that take longer to debug than the real change you are making.<p>What I feel that we (current project) have fallen into the trap of is that there wasn’t a test suite from the start. Just manual testing. Then when you get to a stage where you feel you need one, the code base is not structured to make automated testing simple.</div><br/></div></div><div id="39566015" class="c"><input type="checkbox" id="c-39566015" checked=""/><div class="controls bullet"><span class="by">Attummm</span><span>|</span><a href="#39564526">parent</a><span>|</span><a href="#39565062">prev</a><span>|</span><a href="#39567756">next</a><span>|</span><label class="collapse" for="c-39566015">[-]</label><label class="expand" for="c-39566015">[1 more]</label></div><br/><div class="children"><div class="content">For libraries, tools, and frameworks, testing is crucial as it ensures that the code relying on them can address the issue at hand. Code can only be as reliable as what it&#x27;s leaning on. So, to answer your question, a lot of time.<p>In a business-oriented project(at most jobs), code may undergo frequent changes due to requests from business, thus too much focus on testing could potentially slowing down development speed if extensive testing is implemented for each change.
However, regression tests can still provide valuable insights and allow for faster development later in the life of the project.<p>While many projects only focus on happy path testing, the use of such tests might not be as high. Coupling them with Negative Testing, and even better, implementing boundary testing, compels developers to consider both valid and invalid inputs, helping to identify and address potential edge cases before they become bugs or security issues in production.<p>For instance, this [0] codebase has more tests than actual code, including fuzzing tests.<p>[0]<a href="https:&#x2F;&#x2F;github.com&#x2F;Attumm&#x2F;redis-dict&#x2F;blob&#x2F;main&#x2F;tests.py">https:&#x2F;&#x2F;github.com&#x2F;Attumm&#x2F;redis-dict&#x2F;blob&#x2F;main&#x2F;tests.py</a></div><br/></div></div><div id="39567756" class="c"><input type="checkbox" id="c-39567756" checked=""/><div class="controls bullet"><span class="by">tylerhou</span><span>|</span><a href="#39564526">parent</a><span>|</span><a href="#39566015">prev</a><span>|</span><a href="#39565350">next</a><span>|</span><label class="collapse" for="c-39567756">[-]</label><label class="expand" for="c-39567756">[1 more]</label></div><br/><div class="children"><div class="content">It depends on how risk tolerant you are. If you are at a startup, the growth of your startup is often largely dependent on how quickly you can add features &#x2F; onboard customers. In that context, writing tests not only slows you down from adding new features, it might make it harder to modify existing features. In addition, early customers also tend to be accepting of small bugs -- they themselves already have &quot;taken a risk&quot; in trusting an early startup. So testing is not really valuable -- you want to remain agile, and you won&#x27;t lose much money because of a bug.<p>On the other hand, if you are Google, you already have found a money-printing firehose, and you &#x2F;don&#x27;t&#x2F; want to take on any additional unnecessary risk. Any new code needs to &#x2F;not&#x2F; break existing functionality -- if it does, you might lose out of millions of revenue. In addition, your product becomes so large that it is impossible to manually test every feature. In this case, tests actually help you move &#x2F;faster&#x2F; because they help you at scale automatically ensure that a change does not break anything.<p>While cURL does not make any money, it is solidly on the mature&#x2F;Google end of the testing spectrum. It has found a footing in the open source tooling &quot;market&quot; and people rely on it to maintain its existing functionality. In addition, it has accumulated a fairly large surface area, so manual testing is not really feasible for every feature. So testing similarly helps cURL developers move faster (in the long run), not slower.</div><br/></div></div><div id="39565350" class="c"><input type="checkbox" id="c-39565350" checked=""/><div class="controls bullet"><span class="by">bmcniel</span><span>|</span><a href="#39564526">parent</a><span>|</span><a href="#39567756">prev</a><span>|</span><a href="#39566233">next</a><span>|</span><label class="collapse" for="c-39565350">[-]</label><label class="expand" for="c-39565350">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t test protect against future unintended regressions?<p>If all code was write-only then testing is probably a waste of time but code changes constantly.</div><br/></div></div><div id="39566233" class="c"><input type="checkbox" id="c-39566233" checked=""/><div class="controls bullet"><span class="by">1over137</span><span>|</span><a href="#39564526">parent</a><span>|</span><a href="#39565350">prev</a><span>|</span><a href="#39566388">next</a><span>|</span><label class="collapse" for="c-39566233">[-]</label><label class="expand" for="c-39566233">[1 more]</label></div><br/><div class="children"><div class="content">&gt;At that point, is it worth the time invested? Every new feature can take 2-3 times longer to deliver due to adding tests.<p>Depends if you are writing software to control a pacemaker, or writing software for some silly smartphone game.</div><br/></div></div><div id="39566388" class="c"><input type="checkbox" id="c-39566388" checked=""/><div class="controls bullet"><span class="by">burnished</span><span>|</span><a href="#39564526">parent</a><span>|</span><a href="#39566233">prev</a><span>|</span><a href="#39567478">next</a><span>|</span><label class="collapse" for="c-39566388">[-]</label><label class="expand" for="c-39566388">[1 more]</label></div><br/><div class="children"><div class="content">Generally speaking, yes. Its not like most code isn&#x27;t changed as a consequence of writing those tests, so the practice has immediate benefit, but future changes can be made swiftly and securely due to the confidence those tests should be giving you.<p>But also your time estimate does sound wonky, 2-3x sounds extreme. Maybe you need to improve your test writing process?</div><br/></div></div><div id="39567478" class="c"><input type="checkbox" id="c-39567478" checked=""/><div class="controls bullet"><span class="by">summerlight</span><span>|</span><a href="#39564526">parent</a><span>|</span><a href="#39566388">prev</a><span>|</span><a href="#39569283">next</a><span>|</span><label class="collapse" for="c-39567478">[-]</label><label class="expand" for="c-39567478">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an economical decision. If you&#x27;re developing a new indie game with $10k revenue expectation in its lifetime, then probably it&#x27;s not worth your time. But if it&#x27;s a core infrastructure of multi-billion dollar business, then yes it&#x27;s worth your time since any non-trivial security incidents may cost more than your annual salary.</div><br/></div></div><div id="39569283" class="c"><input type="checkbox" id="c-39569283" checked=""/><div class="controls bullet"><span class="by">evil-olive</span><span>|</span><a href="#39564526">parent</a><span>|</span><a href="#39567478">prev</a><span>|</span><a href="#39565947">next</a><span>|</span><label class="collapse" for="c-39569283">[-]</label><label class="expand" for="c-39569283">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Every new feature can take 2-3 times longer to deliver due to adding tests.<p>alternate framing: you can have a feature done in half or a third of the time, if you don&#x27;t care whether it actually works or not<p>...or whether it will <i>continue</i> working, as other new features are added to the system and the codebase evolves and grows. that sort of maintainability is one of the key things you get from investing in writing tests - you can refactor without fear of breaking some existing feature.<p>it also allows you to hire engineers and give them a &quot;safety net&quot; where they can make changes and be confident they&#x27;re not breaking some crucial functionality of the unfamiliar codebase.<p>done correctly (an important caveat, because lots of people do testing poorly and then conclude that all testing is bad) that time spent writing tests is not wasted effort. cutting corners by skipping tests is very much a false economy in the long term.</div><br/></div></div></div></div><div id="39568331" class="c"><input type="checkbox" id="c-39568331" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#39569469">prev</a><span>|</span><a href="#39563308">next</a><span>|</span><label class="collapse" for="c-39568331">[-]</label><label class="expand" for="c-39568331">[2 more]</label></div><br/><div class="children"><div class="content">Or a better title: &quot;We improved curl fuzzing coverage (twice), but curl didn&#x27;t apply our ossfuzz PR since 2019 yet.&quot;<p>Well, this sucks</div><br/></div></div></div></div></div></div></div></body></html>