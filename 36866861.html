<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1690362058948" as="style"/><link rel="stylesheet" href="styles.css?v=1690362058948"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/PRQL/prql">PRQL: Pipelined Relational Query Language</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>animal_spirits</span> | <span>141 comments</span></div><br/><div><div id="36867651" class="c"><input type="checkbox" id="c-36867651" checked=""/><div class="controls bullet"><span class="by">andrewl-hn</span><span>|</span><a href="#36868735">next</a><span>|</span><label class="collapse" for="c-36867651">[-]</label><label class="expand" for="c-36867651">[54 more]</label></div><br/><div class="children"><div class="content">For me the examples on the website <a href="https:&#x2F;&#x2F;prql-lang.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;prql-lang.org&#x2F;</a> are the biggest selling point for PRQL, in particular the SQL it generates. It looks clean, straightforward, something I would&#x27;ve written myself.<p>In general, I like this slightly more careful take on modern database development. 10-15 years people would start a brand new database like Mongo, or Riak, or Influx, or whatever, and would try to convince application developers to select it for new projects. But recently we started getting more conservative options like EdgeDB, TimescaleDB, or even PRQL which all expect us to run Postgres with some addons and &#x2F; or query preprocessors. Tech like this is so much easier to adopt!<p>I&#x27;m really liking what Edge folks are doing with schemas and migrations, but I do find PRQL syntax much more intuitive. My application code is littered with data transformation pipelines already: all these map &#x2F; filter chains in TYpeScript, iterators in Rust, enumerables in Ruby, streams in Java, LINQ in .net, Rx in dozens of languages etc. etc. So the concept is very, very familiar. Getting nice SQL queries out of PRQL that I can store, inspect later, see the query plans, add indices where necessary, is just great. It&#x27;s such a good tool!</div><br/><div id="36869376" class="c"><input type="checkbox" id="c-36869376" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#36867651">parent</a><span>|</span><a href="#36867919">next</a><span>|</span><label class="collapse" for="c-36869376">[-]</label><label class="expand" for="c-36869376">[19 more]</label></div><br/><div class="children"><div class="content">To me it seems quite nice, but really just trivially different from SQL - like if Ruby was &#x27;friendlier syntax that transpiles to Python&#x27;, meh? You&#x27;d use whichever you happened to learn first and not bother with the other. (That&#x27;s often true even though it&#x27;s more than that of course.)<p>The examples arbitrarily make SQL look more verbose:<p><pre><code>    SELECT
      id,
      first_name,
      age
    FROM
      employees
    ORDER BY
      age
    LIMIT
      10
</code></pre>
Yes! Of course I&#x27;d rather:<p><pre><code>    from employees
    select {id, first_name, age}
    sort age
    take 10
</code></pre>
..but wait, actually the SQL could&#x27;ve been:<p><pre><code>    select id, first_name, age
    from employees
    order by age
    limit 10
</code></pre>
and it&#x27;s more verbose by a character or two... (no braces, but &#x27;order by&#x27; vs &#x27;sort&#x27;)</div><br/><div id="36873352" class="c"><input type="checkbox" id="c-36873352" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36869376">parent</a><span>|</span><a href="#36870349">next</a><span>|</span><label class="collapse" for="c-36873352">[-]</label><label class="expand" for="c-36873352">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not the tiny changes in the syntax&#x2F;order that matter here. It&#x27;s that if you want to limit the columns or do something else with them afterwards, in PRQL you append that text to the end. In SQL you&#x27;d have to wrap it around your original query, it inject joins in the middle. It doesn&#x27;t read well anymore, because &quot;how&quot; you&#x27;re doing things eclipses &quot;what&quot; you&#x27;re doing.<p>For a simple select, this just doesn&#x27;t matter. But you also wouldn&#x27;t bother with PRQL for simple selects.</div><br/><div id="36873491" class="c"><input type="checkbox" id="c-36873491" checked=""/><div class="controls bullet"><span class="by">meitham</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36873352">parent</a><span>|</span><a href="#36870349">next</a><span>|</span><label class="collapse" for="c-36873491">[-]</label><label class="expand" for="c-36873491">[1 more]</label></div><br/><div class="children"><div class="content">In python I use sqlalchemy core to build the SQL for me, but I manage the transactions myself. Sqlalchemy query builder offers a similar role to what you described, as in I can add another select or where field after I have already added a sort criteria.  It’s clever enough to order these correctly based on the SQL dialect.</div><br/></div></div></div></div><div id="36870349" class="c"><input type="checkbox" id="c-36870349" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36869376">parent</a><span>|</span><a href="#36873352">prev</a><span>|</span><a href="#36869793">next</a><span>|</span><label class="collapse" for="c-36870349">[-]</label><label class="expand" for="c-36870349">[5 more]</label></div><br/><div class="children"><div class="content">I agree that I think the difficulty with the uptake will be &quot;it&#x27;s really just less annoying SQL&quot;, and it&#x27;s hard to overtake a technology that&#x27;s so ubiquitous when your fixes are really &quot;nice to haves&quot; vs something truly transformational.<p>That said, it&#x27;s not the succinctness that&#x27;s an improvement, it&#x27;s that the pipelined nature of PRQL really maps much better to how people should think about queries, and also how the server executes them! Something as trivially simple as putting the from clause first means I can now get much better typeahead&#x2F;autocomplete support from dev tools. Heck, I already do this now in a slightly more annoying manner: I write &quot;select * from some_table ...&quot; first, then I go and type out the actual columns I want because once the from clause is correct my IDE will autocomplete&#x2F;show errors for possible columns.</div><br/><div id="36872444" class="c"><input type="checkbox" id="c-36872444" checked=""/><div class="controls bullet"><span class="by">mikea1</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36870349">parent</a><span>|</span><a href="#36869793">next</a><span>|</span><label class="collapse" for="c-36872444">[-]</label><label class="expand" for="c-36872444">[4 more]</label></div><br/><div class="children"><div class="content">&gt; the pipelined nature of PRQL really maps much better to how people should think about queries<p>I disagree. Database engines take SQL and transform it into an execution plan that takes into consideration database metadata (size, storage, index analytics, etc.). Queries should be thought of with a _set based_ instead of _procedural_ approach to maximize the benefits of this abstraction - diving into the implementation details to guide the execution plan formation only when necessary.<p>Also, the pipeline approach could be achieved with common table expressions (CTEs), right?<p>That said, I think PRQL looks promising because it is a solid attempt to make RDBMS development more approachable. I also like that `from` comes before `select`: it is far more readable. A solid and modern IDE experience for PRQL could be a &quot;killer app&quot;.</div><br/><div id="36873287" class="c"><input type="checkbox" id="c-36873287" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36872444">parent</a><span>|</span><a href="#36869793">next</a><span>|</span><label class="collapse" for="c-36873287">[-]</label><label class="expand" for="c-36873287">[3 more]</label></div><br/><div class="children"><div class="content">I disagree. I find it extremely hard to reason about large queries as set transformations, whereas it is much easier to break it down to &quot;first this, then that&quot;. And this is long before I&#x27;ve even started writing my first line of SQL.<p>So let me write it procedurally and have the optimization engine fix it for me, just like how it fixes my SQL.<p>Even SQL queries are often better understood procedurally. Take this one [1]:<p><pre><code>    SELECT article, dealer, price
    FROM   shop s1
    WHERE  price=(SELECT MAX(s2.price)
                  FROM shop s2
                  WHERE s1.article = s2.article)
    ORDER BY article;
</code></pre>
That inner WHERE clause doesn&#x27;t make sense in my opinion, unless you think of it procedurally as for each row in s1, ask do a search for the highest price amongst all items that share article number.<p>[1] <a href="https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;8.0&#x2F;en&#x2F;example-maximum-column-group-row.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;8.0&#x2F;en&#x2F;example-maximum-colu...</a></div><br/><div id="36874114" class="c"><input type="checkbox" id="c-36874114" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36873287">parent</a><span>|</span><a href="#36873467">next</a><span>|</span><label class="collapse" for="c-36874114">[-]</label><label class="expand" for="c-36874114">[1 more]</label></div><br/><div class="children"><div class="content">Completely agree, thanks for putting it better than I could have, with an excellent example. Correlated subqueries like the example you give, or similarly lateral joins in postgres, fundamentally <i>are</i> treated like for loops by DB engines anyway.<p>Semi-related, but the example you give is also why I <i>love</i> Postgres&#x27; &quot;DISTINCT ON&quot; functionality (I don&#x27;t know if other DBs have something similar) - it makes it so much easier to reason about these &quot;give me the &#x27;first&#x27; one from each group&quot; type queries without having to resort to correlated subqueries.</div><br/></div></div><div id="36873467" class="c"><input type="checkbox" id="c-36873467" checked=""/><div class="controls bullet"><span class="by">tgulacsi</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36873287">parent</a><span>|</span><a href="#36874114">prev</a><span>|</span><a href="#36869793">next</a><span>|</span><label class="collapse" for="c-36873467">[-]</label><label class="expand" for="c-36873467">[1 more]</label></div><br/><div class="children"><div class="content">This is the &quot;set based&quot; approach for the MAX: there does not exist a bigger element:<p><pre><code>  SELECT article, dealer, price
    FROM   shop s1
    WHERE  NOT EXISTS (SELECT 1 FROM shop s2 
                         WHERE s2.price &gt; s1.price AND
                               s2.article = s2.article)
    ORDER BY article;</code></pre></div><br/></div></div></div></div></div></div></div></div><div id="36869793" class="c"><input type="checkbox" id="c-36869793" checked=""/><div class="controls bullet"><span class="by">andrewl-hn</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36869376">parent</a><span>|</span><a href="#36870349">prev</a><span>|</span><a href="#36871591">next</a><span>|</span><label class="collapse" for="c-36869793">[-]</label><label class="expand" for="c-36869793">[8 more]</label></div><br/><div class="children"><div class="content">I use CTEs, window functions, and groupings all the time when I write reporting queries. These things tend to be much more verbose in raw SQL, and ORMs &#x2F; Query Builders either do not support some of these features at all or do very poor job (like, force me to put raw SQL substrings in my code), or force to write DSLs that are even more verbose than raw SQL. Look at corresponding PRQL samples, and you may see an appeal.<p>Also, I agree, no one should write SQL like this - screaming keywords, superficial newlines, etc. I don&#x27;t think this style made sense ever, even in 1970s.</div><br/><div id="36870111" class="c"><input type="checkbox" id="c-36870111" checked=""/><div class="controls bullet"><span class="by">Pxtl</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36869793">parent</a><span>|</span><a href="#36869855">next</a><span>|</span><label class="collapse" for="c-36870111">[-]</label><label class="expand" for="c-36870111">[4 more]</label></div><br/><div class="children"><div class="content">While there&#x27;s some stuff in C#&#x2F;LINQ&#x2F;EF that&#x27;s more verbose (left joins are often a nightmare) or not-supported, I&#x27;ll always say that I prefer writing queries in EF than in SQL, at least when dealing with SQL features that are supported by EF (which is a lot of them, it&#x27;s a very expressive dialect).<p>But EF lets you start with FROM, lets you do whichever keywords you need in whichever order (instead of WHERE -&gt; GROUP BY -&gt; HAVING and you&#x27;ve got to CTE or Subquery if you want another GROUP BY).  It also lets you access the members of a group because the objects are still treated as a graph instead of being pulverized into a flat table like SQL does.  It also makes your FKs into first-class navigational properties of the table.<p>Like, if I have an addressID and I want to get its country code?<p>In MS SQL that&#x27;s<p><pre><code>    SELECT CountryCode
    FROM Country
    INNER JOIN ProvState ON ProvState.CountryID = Country.ID
    INNER JOIN Address ON Address.ProvStateID = ProvState.ID
    WHERE Address.ID = @AddressIDParam
</code></pre>
In EF that&#x27;s<p><pre><code>    db.Addresses
      .Where(a =&gt; a.ID == addressIDParam)
      .Select(a =&gt; a.ProvState.Country.CountryCode)
</code></pre>
EF has a hell of a lot of flaws, but linguistically I love it.  Yes there&#x27;s a lot of aliasing boilerplate in EF, but the ability to walk the foreign keys and the fact that you can put the select <i>after</i> the table name pays off so very well.<p>Also there&#x27;s a dialect of LINQ that looks more like SQL but it&#x27;s kind of weird and I don&#x27;t love it so I prefer to use the lambda syntax above.<p>In that dialect, it&#x27;s<p><pre><code>    from a in db.Addresses
      where a == addressIDParam
      select a.ProvState.Country.CountryCode
</code></pre>
which is even more terse and SQL-y although I find it a weird linguistic mash-up.</div><br/><div id="36870596" class="c"><input type="checkbox" id="c-36870596" checked=""/><div class="controls bullet"><span class="by">pragmatic</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36870111">parent</a><span>|</span><a href="#36869855">next</a><span>|</span><label class="collapse" for="c-36870596">[-]</label><label class="expand" for="c-36870596">[3 more]</label></div><br/><div class="children"><div class="content">The downside though is you have to grab the sql it’s generating somehow to try to optimize it, figure out what crazy cross apply madness it’s going or to figure out why it’s blowing sql servers recursion limit.<p>I prefer to avoid linq syntax now. It’s a false economy.</div><br/><div id="36871420" class="c"><input type="checkbox" id="c-36871420" checked=""/><div class="controls bullet"><span class="by">Turskarama</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36870596">parent</a><span>|</span><a href="#36871040">next</a><span>|</span><label class="collapse" for="c-36871420">[-]</label><label class="expand" for="c-36871420">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, it quite rarely uses cross apply, and typically only for functions where you&#x27;re doing complicated join filtering and trying to extract full EF entities.<p>If you don&#x27;t use linq you can&#x27;t get EF entities anyway, and if you don&#x27;t need EF entities you can can still use linq to get a projection and avoid the cross apply!
The worst case scenario often ends up being writing a linq query to get your primary keys, then loading entities just using the list of keys.<p>I&#x27;ve used linq for years and it makes the basic and intermediate stuff way simpler, and the complex stuff no more complex.  In hundreds of thousands of lines of code, we have exactly TWO queries where it ended up simpler to hand write SQL, and EF did not prevent us from doing that!</div><br/></div></div><div id="36871040" class="c"><input type="checkbox" id="c-36871040" checked=""/><div class="controls bullet"><span class="by">Pxtl</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36870596">parent</a><span>|</span><a href="#36871420">prev</a><span>|</span><a href="#36869855">next</a><span>|</span><label class="collapse" for="c-36871040">[-]</label><label class="expand" for="c-36871040">[1 more]</label></div><br/><div class="children"><div class="content">Oh I agree the actual mapping framework where it converts the EF&#x2F;LINQ is deeply flawed.  But that&#x27;s the underlying implementation.<p>I just mean on a linguistic level, I tremendously prefer EF&#x2F;LINQ&#x2F;C# to SQL.</div><br/></div></div></div></div></div></div><div id="36869855" class="c"><input type="checkbox" id="c-36869855" checked=""/><div class="controls bullet"><span class="by">pjot</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36869793">parent</a><span>|</span><a href="#36870111">prev</a><span>|</span><a href="#36871591">next</a><span>|</span><label class="collapse" for="c-36869855">[-]</label><label class="expand" for="c-36869855">[3 more]</label></div><br/><div class="children"><div class="content">At least we can all agree on leading commas though!</div><br/><div id="36870868" class="c"><input type="checkbox" id="c-36870868" checked=""/><div class="controls bullet"><span class="by">slotrans</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36869855">parent</a><span>|</span><a href="#36871591">next</a><span>|</span><label class="collapse" for="c-36870868">[-]</label><label class="expand" for="c-36870868">[2 more]</label></div><br/><div class="children"><div class="content">death before trailing commas</div><br/><div id="36871474" class="c"><input type="checkbox" id="c-36871474" checked=""/><div class="controls bullet"><span class="by">akdor1154</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36870868">parent</a><span>|</span><a href="#36871591">next</a><span>|</span><label class="collapse" for="c-36871474">[-]</label><label class="expand" for="c-36871474">[1 more]</label></div><br/><div class="children"><div class="content">Well if it was after they wouldn&#x27;t be trailing would they?</div><br/></div></div></div></div></div></div></div></div><div id="36871591" class="c"><input type="checkbox" id="c-36871591" checked=""/><div class="controls bullet"><span class="by">ravi-delia</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36869376">parent</a><span>|</span><a href="#36869793">prev</a><span>|</span><a href="#36874098">next</a><span>|</span><label class="collapse" for="c-36871591">[-]</label><label class="expand" for="c-36871591">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a really simple example though. I think the real pitch for PRQL is that the syntax is way more regular- the group operator just runs a normal pipeline on each group and multiple derivations with different operations between them don&#x27;t need to all be plotted out in advance, just as an example. SQL suffers because it&#x27;s not really composable, especially once you get outside of specific modern versions.</div><br/></div></div><div id="36874098" class="c"><input type="checkbox" id="c-36874098" checked=""/><div class="controls bullet"><span class="by">jatins</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36869376">parent</a><span>|</span><a href="#36871591">prev</a><span>|</span><a href="#36870417">next</a><span>|</span><label class="collapse" for="c-36874098">[-]</label><label class="expand" for="c-36874098">[1 more]</label></div><br/><div class="children"><div class="content">Even though a small example doesn&#x27;t highlight the advantages well, I still prefer the PRQL syntax in this because that reads like map&#x2F;filter code I&#x27;d write in some programming language.<p>So the mental model seems easier to me</div><br/></div></div><div id="36870417" class="c"><input type="checkbox" id="c-36870417" checked=""/><div class="controls bullet"><span class="by">jtsuken</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36869376">parent</a><span>|</span><a href="#36874098">prev</a><span>|</span><a href="#36867919">next</a><span>|</span><label class="collapse" for="c-36870417">[-]</label><label class="expand" for="c-36870417">[1 more]</label></div><br/><div class="children"><div class="content">Being able to pick the source (i.e. the FROM clause) first is useful in itself, as you then get the benefit of sensible auto-complete suggestions.</div><br/></div></div></div></div><div id="36867919" class="c"><input type="checkbox" id="c-36867919" checked=""/><div class="controls bullet"><span class="by">t8sr</span><span>|</span><a href="#36867651">parent</a><span>|</span><a href="#36869376">prev</a><span>|</span><a href="#36868735">next</a><span>|</span><label class="collapse" for="c-36867919">[-]</label><label class="expand" for="c-36867919">[34 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get that - to me the examples are much less readable than SQL and I don&#x27;t understand why I should want to use this. Like, yes, you can reorder the query sections, which seems to be everyone&#x27;s complaint about SQL, but then you also have multiple types of brackets, colons and other syntax for no reason, all while not really accomplishing anything SQL doesn&#x27;t already do.<p>What&#x27;s the attraction?</div><br/><div id="36868219" class="c"><input type="checkbox" id="c-36868219" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36867919">parent</a><span>|</span><a href="#36870568">next</a><span>|</span><label class="collapse" for="c-36868219">[-]</label><label class="expand" for="c-36868219">[7 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re happy with SQL then there isn&#x27;t much point.<p>For the folks building and supporting PRQL, SQL just has a few too many warts and the popularity of tools like Pandas, dplyr, Polars, LINQ, ... shows that for analytical work we often like to work with our data differently. Other frameworks and languages feel that we should throw out Relational Algebra as well but we feel that&#x27;s like throwing the baby out with the bathwater.<p>PRQL&#x27;s core tenets are that Relational Algebra is foundational and a great abstraction but what&#x27;s needed is a modern, ergonomic language that allows us to work with data the way most of us conceive of it - as pipelines of transformations.<p>Personally I feel much more productive in PRQL. I can start with a dataset and append one transformation at a time, writing from top to bottom as I go along without having to jump back and forth between the SELECT and the WHERE and the GROUP BY clause etc... .<p>Also, if I want to take out a step, I can just comment out that line and the rest of the pipeline usually still works. This might seem like a minor thing but in my experience it&#x27;s those kind of ergonomics that make the difference in actual day to day work rather than fancy theoretical features you only use once in a blue moon. It&#x27;s therefore worth noting that this was an intentional design decision. You try and take out some steps from your SQL query and see how well the rest of your query holds up.</div><br/><div id="36868537" class="c"><input type="checkbox" id="c-36868537" checked=""/><div class="controls bullet"><span class="by">aidos</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36868219">parent</a><span>|</span><a href="#36868457">next</a><span>|</span><label class="collapse" for="c-36868537">[-]</label><label class="expand" for="c-36868537">[5 more]</label></div><br/><div class="children"><div class="content">For what it’s worth, it looks really readable to me. I have decades of sql experience at this point so consider myself pretty proficient but I can see the appeal of having a terser syntax for transformations. I especially like the “it just makes sql” approach.<p>Stepping through the second example on that page I know how I could do the same in sql, and I also know that it would be harder for most people to follow.<p>Question about that example though - why is there an aggregate without an assignment to a variable (average gross_salary) like the other examples?</div><br/><div id="36868794" class="c"><input type="checkbox" id="c-36868794" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36868537">parent</a><span>|</span><a href="#36868457">next</a><span>|</span><label class="collapse" for="c-36868794">[-]</label><label class="expand" for="c-36868794">[4 more]</label></div><br/><div class="children"><div class="content">I couldn&#x27;t find that example right now but there is a similar line in the main example on the prql-lang.org homepage:<p><pre><code>    aggregate {
        average total,
        ...
    }
</code></pre>
I can&#x27;t definitively say why it is there, other than perhaps just to show that you can specify aggregations without having to give them an alias. The column name won&#x27;t be pretty but if you&#x27;re just interactively trying something out and want to see the results then you probably won&#x27;t care.<p>Does that help?</div><br/><div id="36869103" class="c"><input type="checkbox" id="c-36869103" checked=""/><div class="controls bullet"><span class="by">aidos</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36868794">parent</a><span>|</span><a href="#36868457">next</a><span>|</span><label class="collapse" for="c-36869103">[-]</label><label class="expand" for="c-36869103">[3 more]</label></div><br/><div class="children"><div class="content">Gotcha. The thing that’s not immediately clear from the syntax is which columns I’m getting out as a final result of my query. I guess the last select you ran + any derived ones since then?</div><br/><div id="36870001" class="c"><input type="checkbox" id="c-36870001" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36869103">parent</a><span>|</span><a href="#36868457">next</a><span>|</span><label class="collapse" for="c-36870001">[-]</label><label class="expand" for="c-36870001">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s right. It can be a bit hard to keep track of but the rules are quite simple. You start with all the columns from a `from`, then any `derive` just adds columns. A `select` restricts the columns to those selected and a `group + aggregate` replaces the columns with those from the `group` + those from the `aggregate`.<p>I once tabled a proposal whether each query should be forced to end with a `select` to make the final column list explicit. This could be generated by the compiler. It was felt that that wasn&#x27;t necessary though and would also be somewhat arbitrary since you also need to know what columns are available at each previous step of the pipeline if you want to be able to make modifications. As the tooling improves, you could perhaps be shown the current list of columns as you hover over each line?</div><br/><div id="36870216" class="c"><input type="checkbox" id="c-36870216" checked=""/><div class="controls bullet"><span class="by">aidos</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36870001">parent</a><span>|</span><a href="#36868457">next</a><span>|</span><label class="collapse" for="c-36870216">[-]</label><label class="expand" for="c-36870216">[1 more]</label></div><br/><div class="children"><div class="content">There’s nothing stopping people from using their own convention of selecting early to grab the stuff they need and selecting again right at the end to be explicit about what they want. Like select *, it’s better to just be explicit.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36868457" class="c"><input type="checkbox" id="c-36868457" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36868219">parent</a><span>|</span><a href="#36868537">prev</a><span>|</span><a href="#36870568">next</a><span>|</span><label class="collapse" for="c-36868457">[-]</label><label class="expand" for="c-36868457">[1 more]</label></div><br/><div class="children"><div class="content">Disclaimer: I&#x27;m a PRQL contributor.</div><br/></div></div></div></div><div id="36870568" class="c"><input type="checkbox" id="c-36870568" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36867919">parent</a><span>|</span><a href="#36868219">prev</a><span>|</span><a href="#36868073">next</a><span>|</span><label class="collapse" for="c-36870568">[-]</label><label class="expand" for="c-36870568">[3 more]</label></div><br/><div class="children"><div class="content">The attraction is that, especially for more complicated queries with complex joins, subqueries, aggregates, etc., that the structure of PRQL much more closely matches the &quot;English&quot;, mental-model of the query. I can just read PRQL linearly, from top to bottom, and at each point I know what is being &quot;pipelined&quot; into the next phase of the query.<p>With SQL I have to look all over the place. And it&#x27;s not just that FROM should come before SELECT, it&#x27;s that if I&#x27;m doing, say, an aggregation with a group by, normal SQL doesn&#x27;t really have anything to make me think about the ungrouped rows, and then merge them together to get the aggregate values. With PRQL I can just go top to bottom, and for me it&#x27;s much easier to reason about (i.e. first get all the rows, then group by some specific columns, then take aggregates, etc.)<p>And I say this as someone who spends about half my days in SQL at present.</div><br/><div id="36870606" class="c"><input type="checkbox" id="c-36870606" checked=""/><div class="controls bullet"><span class="by">pragmatic</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36870568">parent</a><span>|</span><a href="#36868073">next</a><span>|</span><label class="collapse" for="c-36870606">[-]</label><label class="expand" for="c-36870606">[2 more]</label></div><br/><div class="children"><div class="content">The downside is, debugging what actual sql this monstrosity spits out.</div><br/><div id="36870838" class="c"><input type="checkbox" id="c-36870838" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36870606">parent</a><span>|</span><a href="#36868073">next</a><span>|</span><label class="collapse" for="c-36870838">[-]</label><label class="expand" for="c-36870838">[1 more]</label></div><br/><div class="children"><div class="content">Two points:<p>1. The SQL that I&#x27;ve seen output by PRQL isn&#x27;t monstrous, at least no more than it would be coding by hand.<p>2. I do agree that I don&#x27;t think PRQL will have much uptake until it is baked in to DB systems, at least as a plugin. One reason (among many) that I hate ORM systems is that with native SQL it&#x27;s very easy for me to just capture a SQL statement from my DB logs and then search my code for an offending statement. But given how PRQL is transpiled, I don&#x27;t see any reason it couldn&#x27;t be essentially part of the query planner, so that query logs etc. are reported in PRQL and not SQL. E.g. the query planner already takes text (SQL) -&gt; Query Plan, it seems rather straightforward to go text (PRQL) -&gt; text (SQL) -&gt; Query Plan, with the SQL intermediate just being an implementation detail I don&#x27;t have to care about as a DB user.</div><br/></div></div></div></div></div></div><div id="36868073" class="c"><input type="checkbox" id="c-36868073" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36867919">parent</a><span>|</span><a href="#36870568">prev</a><span>|</span><a href="#36868048">next</a><span>|</span><label class="collapse" for="c-36868073">[-]</label><label class="expand" for="c-36868073">[1 more]</label></div><br/><div class="children"><div class="content">The attraction is something that was designed after decades of usage and PL research. Consistency of syntax is a big one for me. A favorite example of mine:<p><pre><code>  SELECT substring(&#x27;PostgreSQL&#x27; from 8 for 3);
  SELECT substring(&#x27;PostgreSQL&#x27;, 8, 3); -- PostgreSQL-only syntax
  SELECT trim(both from &#x27;yxSQLxx&#x27;, &#x27;xyz&#x27;);
  SELECT extract(day from timestamp &#x27;2001-02-16 20:38:40&#x27;);
</code></pre>
Taken from: <a href="https:&#x2F;&#x2F;www.edgedb.com&#x2F;blog&#x2F;we-can-do-better-than-sql" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.edgedb.com&#x2F;blog&#x2F;we-can-do-better-than-sql</a><p>Maybe if SQL would give me that monumental ask of trailing commas, perhaps I would hate it less.</div><br/></div></div><div id="36868048" class="c"><input type="checkbox" id="c-36868048" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36867919">parent</a><span>|</span><a href="#36868073">prev</a><span>|</span><a href="#36868745">next</a><span>|</span><label class="collapse" for="c-36868048">[-]</label><label class="expand" for="c-36868048">[3 more]</label></div><br/><div class="children"><div class="content">I think main difference is how PRQL translates into query execution plan, with SQL you need to read entirety of query to get rough understanding of order of operations (especially if you join two-three tables and have some nested and lateral queries).<p>with PRQL I see that the order will be explicit and set up by developer, so any footguns will be evident.<p>things like predicate push down, optimization fence, variable rewrite, etc are not needed to be relied upon, because pipeline of query is more explicit in PRQL<p>also since it is new lang, it can be naturally extended into ETL type data pipelines<p>also because PRQL can be translated into query execution plan - it can be converted into non-SQL languages like MongoDB or pandas &#x2F; spark &#x2F; etc, eliminating SQL altogether for distributed nosql engines</div><br/><div id="36868908" class="c"><input type="checkbox" id="c-36868908" checked=""/><div class="controls bullet"><span class="by">aidos</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36868048">parent</a><span>|</span><a href="#36868745">next</a><span>|</span><label class="collapse" for="c-36868908">[-]</label><label class="expand" for="c-36868908">[2 more]</label></div><br/><div class="children"><div class="content">Is that true? Doesn’t this just effectively translate into sql to be executed on the db as usual if you’re running on an rdbms?<p>Looking at the examples and the sql generated in the playground you’re just going to have the query planner doing its thing to decide how to execute eventually anyway.</div><br/><div id="36869082" class="c"><input type="checkbox" id="c-36869082" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36868908">parent</a><span>|</span><a href="#36868745">next</a><span>|</span><label class="collapse" for="c-36869082">[-]</label><label class="expand" for="c-36869082">[1 more]</label></div><br/><div class="children"><div class="content">It transpiles into sql currently, but my understanding it is not long term vision.<p>Language arch allows in the future to replace sql for querying data</div><br/></div></div></div></div></div></div><div id="36868745" class="c"><input type="checkbox" id="c-36868745" checked=""/><div class="controls bullet"><span class="by">dlisboa</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36867919">parent</a><span>|</span><a href="#36868048">prev</a><span>|</span><a href="#36869137">next</a><span>|</span><label class="collapse" for="c-36868745">[-]</label><label class="expand" for="c-36868745">[1 more]</label></div><br/><div class="children"><div class="content">Maybe you didn&#x27;t see the more complex examples, but some of the SQL queries it abstracts are very unintuitive to write by hand. PRQL turns it into something more readable and closer to the expected mental model.<p>For people who can write error-free and complex portable SQL queries by heart this may not be really interesting. From experience, however, that is not a skill most developers have.</div><br/></div></div><div id="36869137" class="c"><input type="checkbox" id="c-36869137" checked=""/><div class="controls bullet"><span class="by">the_mitsuhiko</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36867919">parent</a><span>|</span><a href="#36868745">prev</a><span>|</span><a href="#36871625">next</a><span>|</span><label class="collapse" for="c-36869137">[-]</label><label class="expand" for="c-36869137">[6 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t use PRQL but I absolutely get the appeal but specifically on the readability part, some things that are easy in PRQL are just awful in SQL.<p>From the website for instance this is a nightmare to do in SQL:<p><pre><code>    from employees group role (sort join_date take 1)</code></pre></div><br/><div id="36870072" class="c"><input type="checkbox" id="c-36870072" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36869137">parent</a><span>|</span><a href="#36871141">next</a><span>|</span><label class="collapse" for="c-36870072">[-]</label><label class="expand" for="c-36870072">[2 more]</label></div><br/><div class="children"><div class="content">Unfortunately the linebreaks were lost and, as shown that isn&#x27;t a valid PRQL query. It would have to be either<p><pre><code>    from employees
    group role (
        sort join_date 
        take 1
        )
</code></pre>
or<p><pre><code>    from employees | group role (sort join_date | take 1)
</code></pre>
In English:<p><pre><code>    Take the 1st employee 
    by (earliest) join_date 
    for each role 
    from the set of employees</code></pre></div><br/><div id="36870120" class="c"><input type="checkbox" id="c-36870120" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36870072">parent</a><span>|</span><a href="#36871141">next</a><span>|</span><label class="collapse" for="c-36870120">[-]</label><label class="expand" for="c-36870120">[1 more]</label></div><br/><div class="children"><div class="content">ClickHouse:<p>SELECT * FROM employees ORDER BY join_date LIMIT 1 BY role</div><br/></div></div></div></div><div id="36871141" class="c"><input type="checkbox" id="c-36871141" checked=""/><div class="controls bullet"><span class="by">virtualwhys</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36869137">parent</a><span>|</span><a href="#36870072">prev</a><span>|</span><a href="#36869829">next</a><span>|</span><label class="collapse" for="c-36871141">[-]</label><label class="expand" for="c-36871141">[1 more]</label></div><br/><div class="children"><div class="content">What is the generated SQL of that expression?<p>This is indeed a sticky problem, one that usually requires a subselect or other workaround to address the non-determinism of group by + order by; i.e. one cannot simply &quot;select * from employees group by role order by join_date limit 1&quot; and be guaranteed to get the expected ordering.</div><br/></div></div><div id="36869829" class="c"><input type="checkbox" id="c-36869829" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36869137">parent</a><span>|</span><a href="#36871141">prev</a><span>|</span><a href="#36871625">next</a><span>|</span><label class="collapse" for="c-36869829">[-]</label><label class="expand" for="c-36869829">[2 more]</label></div><br/><div class="children"><div class="content">What does it mean? Is it the same as &quot;LIMIT BY&quot; in ClickHouse?<p><a href="https:&#x2F;&#x2F;clickhouse.com&#x2F;docs&#x2F;en&#x2F;sql-reference&#x2F;statements&#x2F;select&#x2F;limit-by" rel="nofollow noreferrer">https:&#x2F;&#x2F;clickhouse.com&#x2F;docs&#x2F;en&#x2F;sql-reference&#x2F;statements&#x2F;sele...</a></div><br/><div id="36869914" class="c"><input type="checkbox" id="c-36869914" checked=""/><div class="controls bullet"><span class="by">the_mitsuhiko</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36869829">parent</a><span>|</span><a href="#36871625">next</a><span>|</span><label class="collapse" for="c-36869914">[-]</label><label class="expand" for="c-36869914">[1 more]</label></div><br/><div class="children"><div class="content">It picks the first result grouped by role and sorted by join date. I believe this can be expressed with limit by in ClickHouse.</div><br/></div></div></div></div></div></div><div id="36871625" class="c"><input type="checkbox" id="c-36871625" checked=""/><div class="controls bullet"><span class="by">ravi-delia</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36867919">parent</a><span>|</span><a href="#36869137">prev</a><span>|</span><a href="#36869641">next</a><span>|</span><label class="collapse" for="c-36871625">[-]</label><label class="expand" for="c-36871625">[1 more]</label></div><br/><div class="children"><div class="content">I mean if you can look at the &quot;expressions&quot; example on the homepage and say the SQL is more readable than PRQL, then more power to you. Hell, actually more power to you, that&#x27;s extremely impressive. But I think for many people, especially programmers more used to parsing brackets and nesting than pseudo-english, PRQL is easier in the places where you&#x27;re trying to compose.</div><br/></div></div><div id="36869641" class="c"><input type="checkbox" id="c-36869641" checked=""/><div class="controls bullet"><span class="by">andrewl-hn</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36867919">parent</a><span>|</span><a href="#36871625">prev</a><span>|</span><a href="#36873146">next</a><span>|</span><label class="collapse" for="c-36869641">[-]</label><label class="expand" for="c-36869641">[1 more]</label></div><br/><div class="children"><div class="content">Oh, I&#x27;m a big fan of raw SQL, too. There&#x27;s very little out there that can bring me same joy as a well-written 30-50 lines-long sql query! Like, I can spend an hour or two on it, but when it runs and produces the results in the desired form, it&#x27;s sooo rewarding! And realizing that producing similar results in my main language (be it Rust or TypeScript, or whatever) would take me 3-4 days instead (and it would run much longer) makes me appreciate SQL programming more and more. In terms of &quot;usefulness per minute spend&quot; nothing comes close to SQL!<p>However, the syntax can be a bit clunky from time to time. I&#x27;m very fortunate that I use Postgres only in the past 5-7 years, so CTEs, and things like Timescale or JSONB, or PlV8 &#x2F; PlRust for stored procedures are often on the menu. Yet, simple things still require repeating fragments of code from time to time, and complex grouping or window functions code often looks too convoluted.<p>And as I wrote in my GP comment: I (and many other developers) already use pipelines for data manipulation in code - beyond databases. Say, we got data from an API endpoint, or we mixing data from several data sources. SQL is familiar because I see it often, PRQL is familiar because I use similar pipelining concepts often in my no-SQL code. Would I use PRQL for super simple queries? Probably not. Would I be upset if one of my coworkers used it for simple queries? No, why would I? Would I try implementing complex reporting query using PRQL? Yeah, I would. Partially because I suspect I would get to my data in desired form quicker with pipelines, and partially because I know: if I get stuck I would convert my intermediary query to SQL and pick up from there.<p>For me PRQL looks better then most DSLs for ORMs or Query Builders in most languages. Adding a new tool to a project may be annoying, but depending on a project I&#x27;d rather pay this price once if it makes my less SQL-savvy team mates more comfortable. &quot;Yet another syntax&quot; is obviously the main point against, but from the application developer perspective ORMs &#x2F; Query Builders often force one to learn &quot;yet another syntax&quot; anyway. &quot;Don&#x27;t use ORM &#x2F; Builder&quot; is an often voiced opinion and yet in practice we work with them all the time, too.<p>So, I view PRQL not as an alternative to SQL but as a third database communication dialect in addition to SQL and my ORM &#x2F; Query Builder DSLs.</div><br/></div></div><div id="36867977" class="c"><input type="checkbox" id="c-36867977" checked=""/><div class="controls bullet"><span class="by">spullara</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36867919">parent</a><span>|</span><a href="#36873146">prev</a><span>|</span><a href="#36868735">next</a><span>|</span><label class="collapse" for="c-36867977">[-]</label><label class="expand" for="c-36867977">[9 more]</label></div><br/><div class="children"><div class="content">it seems like any SQL parser could let you put FROM first and solve a lot of the annoyances of SQL</div><br/><div id="36868333" class="c"><input type="checkbox" id="c-36868333" checked=""/><div class="controls bullet"><span class="by">mulmen</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36867977">parent</a><span>|</span><a href="#36868735">next</a><span>|</span><label class="collapse" for="c-36868333">[-]</label><label class="expand" for="c-36868333">[8 more]</label></div><br/><div class="children"><div class="content">The stiff syntax is a <i>feature</i>.  The infamous 1000 line sales report query is already a bear to maintain.  If you get a clever developer reordering syntax it will only be worse.</div><br/><div id="36870899" class="c"><input type="checkbox" id="c-36870899" checked=""/><div class="controls bullet"><span class="by">strokirk</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36868333">parent</a><span>|</span><a href="#36868735">next</a><span>|</span><label class="collapse" for="c-36870899">[-]</label><label class="expand" for="c-36870899">[7 more]</label></div><br/><div class="children"><div class="content">It’s certainly <i>not</i> a feature. A lot of important SQL usage is ad-hoc queries, and they are more annoying to type than they should be.</div><br/><div id="36871513" class="c"><input type="checkbox" id="c-36871513" checked=""/><div class="controls bullet"><span class="by">mulmen</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36870899">parent</a><span>|</span><a href="#36868735">next</a><span>|</span><label class="collapse" for="c-36871513">[-]</label><label class="expand" for="c-36871513">[6 more]</label></div><br/><div class="children"><div class="content">I don’t understand how changing the order of the clauses makes a query easier to type.</div><br/><div id="36871954" class="c"><input type="checkbox" id="c-36871954" checked=""/><div class="controls bullet"><span class="by">spullara</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36871513">parent</a><span>|</span><a href="#36868735">next</a><span>|</span><label class="collapse" for="c-36871954">[-]</label><label class="expand" for="c-36871954">[5 more]</label></div><br/><div class="children"><div class="content">If you have auto-complete it can see what table you are using and complete the column names. Starting with SELECT it could be any column in the database.</div><br/><div id="36872344" class="c"><input type="checkbox" id="c-36872344" checked=""/><div class="controls bullet"><span class="by">mulmen</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36871954">parent</a><span>|</span><a href="#36872162">next</a><span>|</span><label class="collapse" for="c-36872344">[-]</label><label class="expand" for="c-36872344">[2 more]</label></div><br/><div class="children"><div class="content">Huh.  I have been doing this for like 15 years and never have a problem.  Text editors like Sublime Text suggest names based on the content of the file.  SQL Developer, SQLWorkbench, and DataGrip all seem to handle it just fine.</div><br/><div id="36873657" class="c"><input type="checkbox" id="c-36873657" checked=""/><div class="controls bullet"><span class="by">spullara</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36872344">parent</a><span>|</span><a href="#36872162">next</a><span>|</span><label class="collapse" for="c-36873657">[-]</label><label class="expand" for="c-36873657">[1 more]</label></div><br/><div class="children"><div class="content">It will suggest names that aren&#x27;t in the table you are going to query unless it is psychic.</div><br/></div></div></div></div><div id="36872162" class="c"><input type="checkbox" id="c-36872162" checked=""/><div class="controls bullet"><span class="by">nhinck2</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36871954">parent</a><span>|</span><a href="#36872344">prev</a><span>|</span><a href="#36868735">next</a><span>|</span><label class="collapse" for="c-36872162">[-]</label><label class="expand" for="c-36872162">[2 more]</label></div><br/><div class="children"><div class="content">I see this complaint stated over and over again, how hard is it really to type SELECT * FROM x a and then go back?</div><br/><div id="36872569" class="c"><input type="checkbox" id="c-36872569" checked=""/><div class="controls bullet"><span class="by">spullara</span><span>|</span><a href="#36867651">root</a><span>|</span><a href="#36872162">parent</a><span>|</span><a href="#36868735">next</a><span>|</span><label class="collapse" for="c-36872569">[-]</label><label class="expand" for="c-36872569">[1 more]</label></div><br/><div class="children"><div class="content">Is there any downside at all to putting FROM first?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36868735" class="c"><input type="checkbox" id="c-36868735" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#36867651">prev</a><span>|</span><a href="#36867492">next</a><span>|</span><label class="collapse" for="c-36868735">[-]</label><label class="expand" for="c-36868735">[3 more]</label></div><br/><div class="children"><div class="content">We have recently merged PRQL support into ClickHouse: <a href="https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickHouse&#x2F;pull&#x2F;50686">https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickHouse&#x2F;pull&#x2F;50686</a><p>It&#x27;s currently more like an experiment - I&#x27;m not sure if it will be usable or useful. There are some concerns about Rust, although minor: <a href="https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickHouse&#x2F;issues&#x2F;52053#issuecomment-1643805521">https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickHouse&#x2F;issues&#x2F;52053#issuec...</a></div><br/><div id="36870410" class="c"><input type="checkbox" id="c-36870410" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#36868735">parent</a><span>|</span><a href="#36867492">next</a><span>|</span><label class="collapse" for="c-36870410">[-]</label><label class="expand" for="c-36870410">[2 more]</label></div><br/><div class="children"><div class="content">This is awesome! Thank you!<p>Would that mean it would also be able to use it in clickhouse-local?</div><br/><div id="36870460" class="c"><input type="checkbox" id="c-36870460" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#36868735">root</a><span>|</span><a href="#36870410">parent</a><span>|</span><a href="#36867492">next</a><span>|</span><label class="collapse" for="c-36870460">[-]</label><label class="expand" for="c-36870460">[1 more]</label></div><br/><div class="children"><div class="content">Yes:<p><pre><code>    clickhouse-local --dialect prql
</code></pre>
or:<p><pre><code>    $ clickhouse-local

    :) SET dialect = &#x27;prql&#x27;</code></pre></div><br/></div></div></div></div></div></div><div id="36867492" class="c"><input type="checkbox" id="c-36867492" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#36868735">prev</a><span>|</span><a href="#36867886">next</a><span>|</span><label class="collapse" for="c-36867492">[-]</label><label class="expand" for="c-36867492">[6 more]</label></div><br/><div class="children"><div class="content">I really want this to take off and become a first party supported language for Postgres. Yes, yes, relational algebra is beautiful and all that jazz. SQL is a garbage, first pass design that should have been replaced decades ago. Even Codd has complaints about it. It is amazing what he invented, but we have learned a lot about PL design since then.</div><br/><div id="36867851" class="c"><input type="checkbox" id="c-36867851" checked=""/><div class="controls bullet"><span class="by">aerzen</span><span>|</span><a href="#36867492">parent</a><span>|</span><a href="#36870512">next</a><span>|</span><label class="collapse" for="c-36867851">[-]</label><label class="expand" for="c-36867851">[1 more]</label></div><br/><div class="children"><div class="content">People really like to associate relational algebra with SQL, probably because they learned them one alongside another. But SQL is really terrible relational language - it breaks a few core concepts in different places, like relations being unordered sets, that you can ORDER BY. This bubbles up as relations losing ordering after being wrapped into a subquery, which is really unexpected.<p>PRQL has a data model very similar to the relational one. The only big difference is that relations are ordered - they are defined as arrays of tuples. So let&#x27;s hope that PRQL gets to be known as &quot;the relational language Mk II&quot;</div><br/></div></div><div id="36870512" class="c"><input type="checkbox" id="c-36870512" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#36867492">parent</a><span>|</span><a href="#36867851">prev</a><span>|</span><a href="#36867818">next</a><span>|</span><label class="collapse" for="c-36870512">[-]</label><label class="expand" for="c-36870512">[2 more]</label></div><br/><div class="children"><div class="content">Not quite what you&#x27;re asking for but DuckDB has both PRQL [1] and Postgres [2] extensions, so you could probably query your Postgres database with PRQL from there.<p>There&#x27;s also a DBeaver plugin [3] which we still need to document better and simplify the usage of but you could potentially also use that to query Postgres with PRQL.<p>Finally there is pyprql [4] with which you could query Postgres from a Jupyter notebook.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;ywelsch&#x2F;duckdb-prql">https:&#x2F;&#x2F;github.com&#x2F;ywelsch&#x2F;duckdb-prql</a><p>[2]: <a href="https:&#x2F;&#x2F;duckdb.org&#x2F;docs&#x2F;extensions&#x2F;postgres_scanner.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;duckdb.org&#x2F;docs&#x2F;extensions&#x2F;postgres_scanner.html</a><p>[3]: <a href="https:&#x2F;&#x2F;github.com&#x2F;PRQL&#x2F;prql&#x2F;issues&#x2F;1643">https:&#x2F;&#x2F;github.com&#x2F;PRQL&#x2F;prql&#x2F;issues&#x2F;1643</a><p>[4]: <a href="https:&#x2F;&#x2F;github.com&#x2F;PRQL&#x2F;pyprql">https:&#x2F;&#x2F;github.com&#x2F;PRQL&#x2F;pyprql</a><p>(Disclaimer: I&#x27;m a PRQL contributor.)</div><br/><div id="36871297" class="c"><input type="checkbox" id="c-36871297" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#36867492">root</a><span>|</span><a href="#36870512">parent</a><span>|</span><a href="#36867818">next</a><span>|</span><label class="collapse" for="c-36871297">[-]</label><label class="expand" for="c-36871297">[1 more]</label></div><br/><div class="children"><div class="content">By first party I assume they mean using psql and postgres&#x27;s own tooling.</div><br/></div></div></div></div><div id="36867818" class="c"><input type="checkbox" id="c-36867818" checked=""/><div class="controls bullet"><span class="by">vkazanov</span><span>|</span><a href="#36867492">parent</a><span>|</span><a href="#36870512">prev</a><span>|</span><a href="#36867877">next</a><span>|</span><label class="collapse" for="c-36867818">[-]</label><label class="expand" for="c-36867818">[1 more]</label></div><br/><div class="children"><div class="content">Relational algebra is still great, it is the sql that made an unbelievable mess out of this beautiful idea.</div><br/></div></div><div id="36867877" class="c"><input type="checkbox" id="c-36867877" checked=""/><div class="controls bullet"><span class="by">burcs</span><span>|</span><a href="#36867492">parent</a><span>|</span><a href="#36867818">prev</a><span>|</span><a href="#36867886">next</a><span>|</span><label class="collapse" for="c-36867877">[-]</label><label class="expand" for="c-36867877">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I have never liked that you choose what you are querying before you select the source. I think the formatting here is so much more intuitive.</div><br/></div></div></div></div><div id="36867886" class="c"><input type="checkbox" id="c-36867886" checked=""/><div class="controls bullet"><span class="by">t8sr</span><span>|</span><a href="#36867492">prev</a><span>|</span><a href="#36869299">next</a><span>|</span><label class="collapse" for="c-36867886">[-]</label><label class="expand" for="c-36867886">[15 more]</label></div><br/><div class="children"><div class="content">If the main complaint people have about SQL is that you can&#x27;t swap SELECT, FROM and WHERE, then that&#x27;s pretty good for a language designed in the 70s.<p>This, by contrast, looks like it has a bunch of random line noise for syntax. Why on earth should I like this:<p>`join side:left p=positions (p.id==employees.employee_id)`<p>better than this:<p>`LEFT JOIN positions AS p ON p.id = employees.employee_id` ?</div><br/><div id="36869482" class="c"><input type="checkbox" id="c-36869482" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#36867886">parent</a><span>|</span><a href="#36868710">next</a><span>|</span><label class="collapse" for="c-36869482">[-]</label><label class="expand" for="c-36869482">[1 more]</label></div><br/><div class="children"><div class="content">The main issue with SQL is that you are stuck in a very strict way of writing things, which does not clearly match to how I think. The top-down way of writing PRQL where each step is simply a transformation of the previous one makes way more sense to me. SQL is something I&#x27;d need a reference manual for, PRQL is simply writing down what I want the query to do.<p>I do agree that PRQL&#x27;s join syntax is extremely bad, though. They should&#x27;ve stuck to explicit &quot;left join&quot;-like keywords, and the alias &amp; join column shorthand could be done better.</div><br/></div></div><div id="36868710" class="c"><input type="checkbox" id="c-36868710" checked=""/><div class="controls bullet"><span class="by">jdmichal</span><span>|</span><a href="#36867886">parent</a><span>|</span><a href="#36869482">prev</a><span>|</span><a href="#36868321">next</a><span>|</span><label class="collapse" for="c-36868710">[-]</label><label class="expand" for="c-36868710">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had two real gripes with SQL.  The rest of it has been, as you said, pretty good.<p>Complaint 1:  Not being able to use selected columns later in the same select.<p><pre><code>    SELECT
        gnarly_calculation AS some_value,
        some_value * 2 AS some_value_doubled
</code></pre>
Instead:<p><pre><code>    SELECT
        subquery.*,
        some_value * 2 AS some_value_doubled
    FROM (
        gnarly_calculation AS some_value
    ) AS subquery
</code></pre>
Complaint 2:  Not being able to specify all columns <i>except</i>.  This combines with the above, where I have to pull some intermediate calculations forward from a subquery, but I don&#x27;t need them in the final output.  So I have to then enumerate all the output columns that I actually want, instead of being able to say something like `* EXCEPT some_value`.</div><br/><div id="36869885" class="c"><input type="checkbox" id="c-36869885" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#36867886">root</a><span>|</span><a href="#36868710">parent</a><span>|</span><a href="#36873890">next</a><span>|</span><label class="collapse" for="c-36869885">[-]</label><label class="expand" for="c-36869885">[2 more]</label></div><br/><div class="children"><div class="content">Both complaints are resolved by ClickHouse.<p>This video also covers many other advantages of ClickHouse&#x27;s SQL dialect:
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=zhrOYQpgvkk">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=zhrOYQpgvkk</a><p>Some may find your first complaint questionable... But I specifically designed ClickHouse SQL to allow aliases to be used and referenced in every part of SQL query.</div><br/><div id="36872264" class="c"><input type="checkbox" id="c-36872264" checked=""/><div class="controls bullet"><span class="by">jdmichal</span><span>|</span><a href="#36867886">root</a><span>|</span><a href="#36869885">parent</a><span>|</span><a href="#36873890">next</a><span>|</span><label class="collapse" for="c-36872264">[-]</label><label class="expand" for="c-36872264">[1 more]</label></div><br/><div class="children"><div class="content">So unsurprisingly based on my gripes, we are an OLAP shop.  I&#x27;ve never heard of ClickHouse before, and I&#x27;ll be looking into it.  We&#x27;re doing OK on PostgreSQL, but just OK.  A lot of learning and unlearning.</div><br/></div></div></div></div><div id="36873890" class="c"><input type="checkbox" id="c-36873890" checked=""/><div class="controls bullet"><span class="by">AtNightWeCode</span><span>|</span><a href="#36867886">root</a><span>|</span><a href="#36868710">parent</a><span>|</span><a href="#36869885">prev</a><span>|</span><a href="#36869812">next</a><span>|</span><label class="collapse" for="c-36873890">[-]</label><label class="expand" for="c-36873890">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t use *. It is a common source for all kinds of problems. Many query langs does not support it at all for that reason.</div><br/></div></div><div id="36869812" class="c"><input type="checkbox" id="c-36869812" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#36867886">root</a><span>|</span><a href="#36868710">parent</a><span>|</span><a href="#36873890">prev</a><span>|</span><a href="#36868321">next</a><span>|</span><label class="collapse" for="c-36869812">[-]</label><label class="expand" for="c-36869812">[6 more]</label></div><br/><div class="children"><div class="content">PRQL fixes this.<p>(Disclaimer: I&#x27;m a PRQL contributor.)</div><br/><div id="36869896" class="c"><input type="checkbox" id="c-36869896" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#36867886">root</a><span>|</span><a href="#36869812">parent</a><span>|</span><a href="#36868321">next</a><span>|</span><label class="collapse" for="c-36869896">[-]</label><label class="expand" for="c-36869896">[5 more]</label></div><br/><div class="children"><div class="content">Not only PQRL fixes this. It has been allowed in ClickHouse&#x27;s SQL since its inception.</div><br/><div id="36870160" class="c"><input type="checkbox" id="c-36870160" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#36867886">root</a><span>|</span><a href="#36869896">parent</a><span>|</span><a href="#36868321">next</a><span>|</span><label class="collapse" for="c-36870160">[-]</label><label class="expand" for="c-36870160">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s awesome! ClickHouse is a great system by all accounts and I&#x27;ve been meaning to try out ClickHouse Local.<p>I&#x27;m more familiar with DuckDB and they&#x27;ve also been doing some great innovation on the SQL front. I don&#x27;t know offhand if they can also do the forward referencing thing but they allow putting the FROM first and having GROUP BY ALL etc..<p>It&#x27;s great to see all this innovation happening in the SQL and Query Language space more generally at the moment.</div><br/><div id="36870437" class="c"><input type="checkbox" id="c-36870437" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#36867886">root</a><span>|</span><a href="#36870160">parent</a><span>|</span><a href="#36868321">next</a><span>|</span><label class="collapse" for="c-36870437">[-]</label><label class="expand" for="c-36870437">[3 more]</label></div><br/><div class="children"><div class="content">It is strange to hear about innovation in DuckDB - I see that they are gradually re-implementing the stuff already existing in ClickHouse. Sometimes they do a better job at promoting it.</div><br/><div id="36870717" class="c"><input type="checkbox" id="c-36870717" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#36867886">root</a><span>|</span><a href="#36870437">parent</a><span>|</span><a href="#36868321">next</a><span>|</span><label class="collapse" for="c-36870717">[-]</label><label class="expand" for="c-36870717">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s probably true but the big differentiator was that DuckDB can run in your python process so there&#x27;s very low fiction to adopt it.<p>My impression of ClickHouse was that it was more like postgresql in that regard, i.e. OLAP : OLTP as ClickHouse : Postgres as DuckDB : SQLite.<p>clickhouse-local may have closed the gap on that though. Can you embed it in Python as a library?</div><br/><div id="36871042" class="c"><input type="checkbox" id="c-36871042" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#36867886">root</a><span>|</span><a href="#36870717">parent</a><span>|</span><a href="#36868321">next</a><span>|</span><label class="collapse" for="c-36871042">[-]</label><label class="expand" for="c-36871042">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Can you embed it in Python as a library?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;chdb-io&#x2F;chdb">https:&#x2F;&#x2F;github.com&#x2F;chdb-io&#x2F;chdb</a><p><pre><code>    pip install chdb</code></pre></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36868321" class="c"><input type="checkbox" id="c-36868321" checked=""/><div class="controls bullet"><span class="by">lofatdairy</span><span>|</span><a href="#36867886">parent</a><span>|</span><a href="#36868710">prev</a><span>|</span><a href="#36874007">next</a><span>|</span><label class="collapse" for="c-36868321">[-]</label><label class="expand" for="c-36868321">[1 more]</label></div><br/><div class="children"><div class="content">Maybe it&#x27;s my familiarity with R and the tidyverse paradigm, but I think in general this paradigm and syntax is pretty readable. The example you chose is perhaps a case where brackets and commas go a long way, but that aside it&#x27;s really not too bad in context of the rest of the language. `:` seems to consistently be treated as keyword arguments, and `=` for aliasing.</div><br/></div></div><div id="36874007" class="c"><input type="checkbox" id="c-36874007" checked=""/><div class="controls bullet"><span class="by">xchkr1337</span><span>|</span><a href="#36867886">parent</a><span>|</span><a href="#36868321">prev</a><span>|</span><a href="#36868270">next</a><span>|</span><label class="collapse" for="c-36874007">[-]</label><label class="expand" for="c-36874007">[1 more]</label></div><br/><div class="children"><div class="content">The problem with SQL is the same as the problem with C-style variable declarations. It sounds slightly better than the alternatives when you say the code out loud, but in reality it causes problems with readability and parsing&#x2F;processing the code</div><br/></div></div><div id="36868270" class="c"><input type="checkbox" id="c-36868270" checked=""/><div class="controls bullet"><span class="by">kbenson</span><span>|</span><a href="#36867886">parent</a><span>|</span><a href="#36874007">prev</a><span>|</span><a href="#36869299">next</a><span>|</span><label class="collapse" for="c-36868270">[-]</label><label class="expand" for="c-36868270">[1 more]</label></div><br/><div class="children"><div class="content">Because now the type of join is an argument on the &quot;join&quot; operation, and join is the first word of that statement making it more obvious what the operation actually is?  I also prefer foo(bar) over &quot;bar to foo()&quot; as well, which seems like the equivalent in a more general purpose function call in a language example.</div><br/></div></div></div></div><div id="36869299" class="c"><input type="checkbox" id="c-36869299" checked=""/><div class="controls bullet"><span class="by">Taikonerd</span><span>|</span><a href="#36867886">prev</a><span>|</span><a href="#36868029">next</a><span>|</span><label class="collapse" for="c-36869299">[-]</label><label class="expand" for="c-36869299">[5 more]</label></div><br/><div class="children"><div class="content">The limitation of PRQL is that it only does SELECTs, by design.  If you want to insert&#x2F;update&#x2F;delete data, you&#x27;re back to SQL.<p>That means that your team&#x27;s data scientist might give you a query written in PRQL, but if you want to actually incorporate it into the data pipeline, you&#x27;ll need to translate it into SQL.<p>I wish that PRQL would support at least a limited ability to insert -- for example, maybe just the case of inserting into a new temp table.  No update or ON CONFLICT logic to worry about.  It could look like this:<p><pre><code>    from tracks
    filter artist == &quot;Bob Marley&quot;
    save bob_marley_tmp</code></pre></div><br/><div id="36871534" class="c"><input type="checkbox" id="c-36871534" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#36869299">parent</a><span>|</span><a href="#36871294">next</a><span>|</span><label class="collapse" for="c-36871534">[-]</label><label class="expand" for="c-36871534">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see why PRQL can&#x27;t support data mutation. Just have an insert&#x2F;update&#x2F;delete operator that must go at the end of a pipeline, and which takes a table name as an argument. An SQL query like this:<p><pre><code>  UPDATE counters SET value = value + 1 WHERE name LIKE &#x27;prefix.%&#x27;
</code></pre>
Could then be written in PRQL as something like this:<p><pre><code>  from counters
  filter startswith(name, &#x27;prefix.&#x27;)
  derive {
    new_value = value + 1
  }
  select {
    name, new_value
  }
  update counters</code></pre></div><br/><div id="36872172" class="c"><input type="checkbox" id="c-36872172" checked=""/><div class="controls bullet"><span class="by">BrentOzar</span><span>|</span><a href="#36869299">root</a><span>|</span><a href="#36871534">parent</a><span>|</span><a href="#36871294">next</a><span>|</span><label class="collapse" for="c-36872172">[-]</label><label class="expand" for="c-36872172">[2 more]</label></div><br/><div class="children"><div class="content">This feels <i>way</i> less intuitive than SQL:<p>UPDATE counters
SET value = value + 1
WHERE name LIKE &#x27;prefix.%&#x27;</div><br/><div id="36873291" class="c"><input type="checkbox" id="c-36873291" checked=""/><div class="controls bullet"><span class="by">strken</span><span>|</span><a href="#36869299">root</a><span>|</span><a href="#36872172">parent</a><span>|</span><a href="#36871294">next</a><span>|</span><label class="collapse" for="c-36873291">[-]</label><label class="expand" for="c-36873291">[1 more]</label></div><br/><div class="children"><div class="content">I really hate that SQL doesn&#x27;t let you do<p><pre><code>   UPDATE counters WHERE name LIKE &#x27;prefix.%&#x27; SET value = value + 1
</code></pre>
In a SELECT it&#x27;s fine, but in a mutation it&#x27;s dangerous to make updating literally everything so easy if you leave off the tail.</div><br/></div></div></div></div></div></div><div id="36871294" class="c"><input type="checkbox" id="c-36871294" checked=""/><div class="controls bullet"><span class="by">cpursley</span><span>|</span><a href="#36869299">parent</a><span>|</span><a href="#36871534">prev</a><span>|</span><a href="#36868029">next</a><span>|</span><label class="collapse" for="c-36871294">[-]</label><label class="expand" for="c-36871294">[1 more]</label></div><br/><div class="children"><div class="content">Yep, these is where I lost interest.</div><br/></div></div></div></div><div id="36868029" class="c"><input type="checkbox" id="c-36868029" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#36869299">prev</a><span>|</span><a href="#36873550">next</a><span>|</span><label class="collapse" for="c-36868029">[-]</label><label class="expand" for="c-36868029">[1 more]</label></div><br/><div class="children"><div class="content">This is well timed as PRQL 0.9 was just released a few hours ago. Have a look at the release notes here:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;PRQL&#x2F;prql&#x2F;releases&#x2F;tag&#x2F;0.9.0">https:&#x2F;&#x2F;github.com&#x2F;PRQL&#x2F;prql&#x2F;releases&#x2F;tag&#x2F;0.9.0</a><p>There is a rather large breaking change in the syntax from `[]` to `{}` for tuples. This is because initially it seemed like these were lists but over time we&#x27;ve realised that they are actually tuples. As per the release notes, freeing up `[]` clears the way to start supporting arrays soon.<p>Disclaimer: I&#x27;m a PRQL contributor.</div><br/></div></div><div id="36873550" class="c"><input type="checkbox" id="c-36873550" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#36868029">prev</a><span>|</span><a href="#36867974">next</a><span>|</span><label class="collapse" for="c-36873550">[-]</label><label class="expand" for="c-36873550">[2 more]</label></div><br/><div class="children"><div class="content">There are about 17 of these &quot;SQL but better if we start with the FROM statement at the top&quot; languages.<p>The language-integrated query (Linq) feature of .NET works the same away:<p><pre><code>    var studentsGroupByStandard = from s in studentList
                                  group s by s.StandardID into sg
                                  orderby sg.Key 
                                  select new { sg.Key, sg };
</code></pre>
Another example is Microsoft&#x27;s Kusto Query Language, which they use in Azure Log Analytics:<p><pre><code>    StormEvents
    | where State == &#x27;TEXAS&#x27; and EventType == &#x27;Flood&#x27;
    | top 5 by DamageProperty desc
    | extend Duration = EndTime - StartTime</code></pre></div><br/><div id="36874164" class="c"><input type="checkbox" id="c-36874164" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#36873550">parent</a><span>|</span><a href="#36867974">next</a><span>|</span><label class="collapse" for="c-36874164">[-]</label><label class="expand" for="c-36874164">[1 more]</label></div><br/><div class="children"><div class="content">So did QUEL, as implemented in Ingres circa 1976. Perhaps this is what happens when you go back to basics and take a good long look at Codd&#x27;s relational calculus (or, equivalently, relational algebra), to which SQL bears only a passing resemblance.</div><br/></div></div></div></div><div id="36867974" class="c"><input type="checkbox" id="c-36867974" checked=""/><div class="controls bullet"><span class="by">smartmic</span><span>|</span><a href="#36873550">prev</a><span>|</span><a href="#36867614">next</a><span>|</span><label class="collapse" for="c-36867974">[-]</label><label class="expand" for="c-36867974">[4 more]</label></div><br/><div class="children"><div class="content">This must not be missing here then: &quot;I don&#x27;t want to learn your garbage query language&quot; [1]<p>[1] <a href="https:&#x2F;&#x2F;erikbern.com&#x2F;2018&#x2F;08&#x2F;30&#x2F;i-dont-want-to-learn-your-garbage-query-language.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;erikbern.com&#x2F;2018&#x2F;08&#x2F;30&#x2F;i-dont-want-to-learn-your-ga...</a></div><br/><div id="36868339" class="c"><input type="checkbox" id="c-36868339" checked=""/><div class="controls bullet"><span class="by">maximilianroos</span><span>|</span><a href="#36867974">parent</a><span>|</span><a href="#36870156">next</a><span>|</span><label class="collapse" for="c-36868339">[-]</label><label class="expand" for="c-36868339">[2 more]</label></div><br/><div class="children"><div class="content">Big fan of this post! We link to it from PRQL website.<p>Our goal for PRQL is a great language to integrate with &amp; build on. So we don&#x27;t have N languages for N databases. Because PRQL will always be open-source, and won&#x27;t ever have a commercial product, we think that&#x27;s much more feasible than a DB-specific or product-specific language.<p>(PRQL dev here)</div><br/><div id="36872055" class="c"><input type="checkbox" id="c-36872055" checked=""/><div class="controls bullet"><span class="by">phlakaton</span><span>|</span><a href="#36867974">root</a><span>|</span><a href="#36868339">parent</a><span>|</span><a href="#36870156">next</a><span>|</span><label class="collapse" for="c-36872055">[-]</label><label class="expand" for="c-36872055">[1 more]</label></div><br/><div class="children"><div class="content">As evidenced from the poster&#x27;s ORM rant, two languages for the <i>same</i> DB seem just as offensive to them as different languages for different DBs. I suspect you&#x27;re still going to have an uphill battle converting them, unless they were hit with a blinding shaft of sunlight on the road to the SQL History Museum or something.</div><br/></div></div></div></div><div id="36870156" class="c"><input type="checkbox" id="c-36870156" checked=""/><div class="controls bullet"><span class="by">default-kramer</span><span>|</span><a href="#36867974">parent</a><span>|</span><a href="#36868339">prev</a><span>|</span><a href="#36867614">next</a><span>|</span><label class="collapse" for="c-36870156">[-]</label><label class="expand" for="c-36870156">[1 more]</label></div><br/><div class="children"><div class="content">The best rebuttal: <a href="https:&#x2F;&#x2F;www.scattered-thoughts.net&#x2F;writing&#x2F;against-sql&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.scattered-thoughts.net&#x2F;writing&#x2F;against-sql&#x2F;</a></div><br/></div></div></div></div><div id="36867614" class="c"><input type="checkbox" id="c-36867614" checked=""/><div class="controls bullet"><span class="by">samwillis</span><span>|</span><a href="#36867974">prev</a><span>|</span><a href="#36871026">next</a><span>|</span><label class="collapse" for="c-36867614">[-]</label><label class="expand" for="c-36867614">[1 more]</label></div><br/><div class="children"><div class="content">Previous Show HN: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31897430">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31897430</a><p><i>Show HN: PRQL 0.2 – a better SQL - 378 points by maximilianroos on June 27, 2022, 161 comments</i><p>Original post when it was conceived: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30060784">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30060784</a><p><i>PRQL – A proposal for a better SQL - 650 points by maximilianroos on Jan 24, 2022, 295 comments</i></div><br/></div></div><div id="36871026" class="c"><input type="checkbox" id="c-36871026" checked=""/><div class="controls bullet"><span class="by">galkk</span><span>|</span><a href="#36867614">prev</a><span>|</span><a href="#36869658">next</a><span>|</span><label class="collapse" for="c-36871026">[-]</label><label class="expand" for="c-36871026">[1 more]</label></div><br/><div class="children"><div class="content">Syntax doesn&#x27;t matter much, what in the optimizer does.<p>I think that right now a lot of SQL problems are baggage. Too many people are battle-taught to write hard to read, complex, deeply nested queries because older engines were bad at handling modern constructs (e.g. look, somebody got common table expession (CTE) here, let&#x27;s materialize it immediately). So older style was mess of<p><pre><code>     SELELT FROM (SELECT FROM (SELECT FROM A JOIN (SELECT ) B ON A.x=B.x))) etc
</code></pre>
With things like improved CTEs handling by engines, it is getting easier and easier to write understandable, composable queries of structure like below. Add modern window functions that decrease another layer of complexity, things like SELECT * EXCEPT, more complex TOP statements like TOP X FOLLOWING etc and SQL will be even more simpler.<p><pre><code>    WITH A AS (
    ),
    WITH B AS (
    ),
    WITH C AS (
       SELECT y FROM A)
    ,
    SELECT result from C
    WHERE
</code></pre>
and in new-ish world minor improvements of different syntax shape (like that PRQL) do not really bring the benefit, from my POV. Yes, you can rewrite it in imperative looking pipeline, but optimizer can throw away some of it etc<p>Yes, there are things that can and should be done better in SQL, but I have yet to see compelling case for cosmetic, syntactical differences.</div><br/></div></div><div id="36869658" class="c"><input type="checkbox" id="c-36869658" checked=""/><div class="controls bullet"><span class="by">nonethewiser</span><span>|</span><a href="#36871026">prev</a><span>|</span><a href="#36868458">next</a><span>|</span><label class="collapse" for="c-36869658">[-]</label><label class="expand" for="c-36869658">[2 more]</label></div><br/><div class="children"><div class="content">There seems to be very little support for these SQL challengers despite many people saying SQL sucks and they want a redo. Why is that?<p>Some guesses:<p>- There is some popular non-sql query language that has gained lots of momentum that I just dont know about.<p>- People are more effective with SQL because they know it so no new and especially existing databases will switch. This is definitely true to some extent, but if this is the whole reason then I guess SQL is pretty good since people rely on it to be effective.<p>- There is support for it but a few key decision makers are to blame (big data or the MYSQL lobbyists)<p>- People actually dont dislike SQL that much and&#x2F;or its not that bad and hackernews is not representative<p>- These query languages look nice but have technical or performance issues compared to SQL</div><br/><div id="36870030" class="c"><input type="checkbox" id="c-36870030" checked=""/><div class="controls bullet"><span class="by">rcme</span><span>|</span><a href="#36869658">parent</a><span>|</span><a href="#36868458">next</a><span>|</span><label class="collapse" for="c-36870030">[-]</label><label class="expand" for="c-36870030">[1 more]</label></div><br/><div class="children"><div class="content">I think the main reason mainline SQLs continue to be popular is that, unlike general purpose programming languages, the implementation of the query runner is the most important aspect, not then language spec. Take Python for instance. The official implementation objectively sucks, yet it remains extremely popular because the language implementation is only a part of a language’s success. That won’t fly for a db engine.</div><br/></div></div></div></div><div id="36868458" class="c"><input type="checkbox" id="c-36868458" checked=""/><div class="controls bullet"><span class="by">dtheodor</span><span>|</span><a href="#36869658">prev</a><span>|</span><a href="#36873356">next</a><span>|</span><label class="collapse" for="c-36868458">[-]</label><label class="expand" for="c-36868458">[2 more]</label></div><br/><div class="children"><div class="content">Reminds me of Microsoft&#x27;s KQL <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;azure&#x2F;data-explorer&#x2F;kusto&#x2F;query&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;azure&#x2F;data-explorer&#x2F;kusto&#x2F;...</a></div><br/><div id="36871477" class="c"><input type="checkbox" id="c-36871477" checked=""/><div class="controls bullet"><span class="by">joeldo</span><span>|</span><a href="#36868458">parent</a><span>|</span><a href="#36873356">next</a><span>|</span><label class="collapse" for="c-36871477">[-]</label><label class="expand" for="c-36871477">[1 more]</label></div><br/><div class="children"><div class="content">The one joy I have while using Azure :)</div><br/></div></div></div></div><div id="36873356" class="c"><input type="checkbox" id="c-36873356" checked=""/><div class="controls bullet"><span class="by">robbywashere_</span><span>|</span><a href="#36868458">prev</a><span>|</span><a href="#36870011">next</a><span>|</span><label class="collapse" for="c-36873356">[-]</label><label class="expand" for="c-36873356">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    BlaBla.io Better Tomorrow Today(tm)

    Fullstack Engineer (React, Typescript, PRQL) (100% Remote)

    What We&#x27;re Looking For:

    You’ve got 5+ years of experience in designing, building and maintaining large apps written in React, Typescript and PRQL

    ...
</code></pre>
I&#x27;ll just add it to my experience just to be safe</div><br/></div></div><div id="36870011" class="c"><input type="checkbox" id="c-36870011" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#36873356">prev</a><span>|</span><a href="#36873396">next</a><span>|</span><label class="collapse" for="c-36870011">[-]</label><label class="expand" for="c-36870011">[2 more]</label></div><br/><div class="children"><div class="content">The ergonomics could be better: <a href="https:&#x2F;&#x2F;pastila.nl&#x2F;?01359244&#x2F;9ac65f960385a02b3193778b4c6af102" rel="nofollow noreferrer">https:&#x2F;&#x2F;pastila.nl&#x2F;?01359244&#x2F;9ac65f960385a02b3193778b4c6af10...</a><p>Significant newlines. Non-obvious way to specify database&#x2F;schema.</div><br/><div id="36870356" class="c"><input type="checkbox" id="c-36870356" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#36870011">parent</a><span>|</span><a href="#36873396">next</a><span>|</span><label class="collapse" for="c-36870356">[-]</label><label class="expand" for="c-36870356">[1 more]</label></div><br/><div class="children"><div class="content">There are two symbols for separating transforms in a pipeline - \n and | so you can use | instead of \n if you prefer.<p>So for your query from the linked gist, the following should work:<p><pre><code>    from system.numbers | select number
</code></pre>
Otherwise, if you want to be really strict:<p><pre><code>    prql target:sql.clickhouse

    from `system.numbers` | select {number}
</code></pre>
You can see here for more details:
<a href="https:&#x2F;&#x2F;prql-lang.org&#x2F;book&#x2F;reference&#x2F;syntax&#x2F;keywords.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;prql-lang.org&#x2F;book&#x2F;reference&#x2F;syntax&#x2F;keywords.html</a></div><br/></div></div></div></div><div id="36873396" class="c"><input type="checkbox" id="c-36873396" checked=""/><div class="controls bullet"><span class="by">mcsoft</span><span>|</span><a href="#36870011">prev</a><span>|</span><a href="#36868504">next</a><span>|</span><label class="collapse" for="c-36873396">[-]</label><label class="expand" for="c-36873396">[1 more]</label></div><br/><div class="children"><div class="content">PRQL is a breath of fresh air. Reporting languages generally miss built-in visualization and drill-down capabilities. Ideal reporting query should define not only how to seek, join, and and aggregate data, but also how to visualize output and how to present details in reaction to user clicks. There are some limited efforts like in PowerBI and Splunk but we need a standard. I wonder if PRQL guys will address this need in the future.</div><br/></div></div><div id="36868504" class="c"><input type="checkbox" id="c-36868504" checked=""/><div class="controls bullet"><span class="by">nonethewiser</span><span>|</span><a href="#36873396">prev</a><span>|</span><a href="#36868096">next</a><span>|</span><label class="collapse" for="c-36868504">[-]</label><label class="expand" for="c-36868504">[8 more]</label></div><br/><div class="children"><div class="content">This is tangential but a new query language is inevitably based in the idea that SQL is deficient in some manner (hard, not ergonomic, whatever). More interestingly, it also implies that the countless alternatives aren&#x27;t good enough either.<p>Is there an existing query language that anyone will argue is better than SQL? I have limited exposure on this, but if SQL is really not that good then I&#x27;d expect there to be a better one at this point. All the new entrants kinda suggest that maybe SQL isn&#x27;t so bad after all. Even many noSQL db&#x27;s use an SQL-like language (see PartiQL). I&#x27;m not that familiar with alternatives though.</div><br/><div id="36868582" class="c"><input type="checkbox" id="c-36868582" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#36868504">parent</a><span>|</span><a href="#36868623">next</a><span>|</span><label class="collapse" for="c-36868582">[-]</label><label class="expand" for="c-36868582">[2 more]</label></div><br/><div class="children"><div class="content">I think of it in the same way as JavaScript. Clearly, it has issues, but if you want to work on the web, it is what you have available. If you want to speak to Oracle&#x2F;MySQL&#x2F;SQL Server&#x2F;Postgres database you are writing SQL. New entrants, could make a new language, but now they are fighting a battle on two fronts: the novel technology +query language.</div><br/><div id="36869579" class="c"><input type="checkbox" id="c-36869579" checked=""/><div class="controls bullet"><span class="by">mhink</span><span>|</span><a href="#36868504">root</a><span>|</span><a href="#36868582">parent</a><span>|</span><a href="#36868623">next</a><span>|</span><label class="collapse" for="c-36869579">[-]</label><label class="expand" for="c-36869579">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think of it in the same way as JavaScript. Clearly, it has issues, but if you want to work on the web, it is what you have available.<p>And, interestingly, the approach they&#x27;re taking here is similar to how folks have dealt with JS: introduce a transpiled language whose paradigms are close enough to the host language to feel familiar. Reminds me of CoffeeScript, actually (although if we&#x27;re being honest, I couldn&#x27;t stand CoffeeScript.)</div><br/></div></div></div></div><div id="36868623" class="c"><input type="checkbox" id="c-36868623" checked=""/><div class="controls bullet"><span class="by">animal_spirits</span><span>|</span><a href="#36868504">parent</a><span>|</span><a href="#36868582">prev</a><span>|</span><a href="#36871001">next</a><span>|</span><label class="collapse" for="c-36868623">[-]</label><label class="expand" for="c-36868623">[4 more]</label></div><br/><div class="children"><div class="content">I counter the argument that just because it is still around it is the best solution. Many things stick around just because of inertia, for example, the QWERTY keyboard.</div><br/><div id="36870211" class="c"><input type="checkbox" id="c-36870211" checked=""/><div class="controls bullet"><span class="by">halayli</span><span>|</span><a href="#36868504">root</a><span>|</span><a href="#36868623">parent</a><span>|</span><a href="#36869550">next</a><span>|</span><label class="collapse" for="c-36870211">[-]</label><label class="expand" for="c-36870211">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re comparing apples to oranges. Typing is much harder to relearn due to muscle memory. New well designed programming languages become quite popular quickly and go viral when they solve the right problems for developers.<p>SQL is a very sound querying language originally based on relational algebra and tuple relational calculus. Many attempts have been made in the past to come up with better syntax but they don&#x27;t go far which might have to do with the fact that authors realize later that SQL is just a thin layer masquerading the mathematical concepts required to retrieve relational data and make certain assumptions without breaking set theory axioms.<p>One common mistake I see is that developers attempting to create an SQL replacement often approach it in the same mindset as creating yet another general purpose programming language.<p>Edit: The above is not in reference to PRQL. It&#x27;s just my anecdotal experience working on several SQL engines, building ones from scratch and working in this domain for 15 yrs.</div><br/></div></div><div id="36869550" class="c"><input type="checkbox" id="c-36869550" checked=""/><div class="controls bullet"><span class="by">nonethewiser</span><span>|</span><a href="#36868504">root</a><span>|</span><a href="#36868623">parent</a><span>|</span><a href="#36870211">prev</a><span>|</span><a href="#36869614">next</a><span>|</span><label class="collapse" for="c-36869550">[-]</label><label class="expand" for="c-36869550">[1 more]</label></div><br/><div class="children"><div class="content">Then state the better solution.<p>Besides, I&#x27;m not saying it&#x27;s the best because it&#x27;s most common, or even that its the best at all. It just makes it difficult to understand the argument that SQL sucks when its so widely used and no one can agree on an alternative. Including in new databases which could opt for these &quot;new and improved&quot; variants.<p>I grant that there is a first-mover advantage and it&#x27;s not easy to shift paradigms. That&#x27;s a big factor. That&#x27;s why I am honestly - not rhetorically - asking which query language is clearly better than SQL? And why do people keep making new challengers instead of backing something that&#x27;s already better than SQL? There seems to be very little support for these query languages despite many people saying SQL sucks and they want a redo.</div><br/></div></div><div id="36869614" class="c"><input type="checkbox" id="c-36869614" checked=""/><div class="controls bullet"><span class="by">fijiaarone</span><span>|</span><a href="#36868504">root</a><span>|</span><a href="#36868623">parent</a><span>|</span><a href="#36869550">prev</a><span>|</span><a href="#36871001">next</a><span>|</span><label class="collapse" for="c-36869614">[-]</label><label class="expand" for="c-36869614">[1 more]</label></div><br/><div class="children"><div class="content">Big keyboard is keeping DVORAK down! 
In a fair world we’d all be typing NewQL faster with AI from our flying electric cars in a communist utopia.</div><br/></div></div></div></div><div id="36871001" class="c"><input type="checkbox" id="c-36871001" checked=""/><div class="controls bullet"><span class="by">strokirk</span><span>|</span><a href="#36868504">parent</a><span>|</span><a href="#36868623">prev</a><span>|</span><a href="#36868096">next</a><span>|</span><label class="collapse" for="c-36871001">[-]</label><label class="expand" for="c-36871001">[1 more]</label></div><br/><div class="children"><div class="content">What countless alternatives? I can’t think of many, and believe me, I’ve looked hard!</div><br/></div></div></div></div><div id="36868096" class="c"><input type="checkbox" id="c-36868096" checked=""/><div class="controls bullet"><span class="by">getmeinrn</span><span>|</span><a href="#36868504">prev</a><span>|</span><a href="#36871575">next</a><span>|</span><label class="collapse" for="c-36868096">[-]</label><label class="expand" for="c-36868096">[8 more]</label></div><br/><div class="children"><div class="content">&gt;declarative<p>An admirable ideal, but declarative languages always seem to devolve towards some frankenstein imperative&#x2F;declarative hybrid. We need to stop going down this path and embrace Pulumi&#x27;s pattern: use existing general purpose imperative languages to generate a declarative structure. Instead, people try to take their not-mature declarative language and fit a weird general purpose language inside it.<p>EDIT&gt;&gt; I&#x27;m not suggesting that SQL needs to be declarative, only that if a problem space would benefit from declarative structures, generate them imperatively instead.</div><br/><div id="36868379" class="c"><input type="checkbox" id="c-36868379" checked=""/><div class="controls bullet"><span class="by">codethief</span><span>|</span><a href="#36868096">parent</a><span>|</span><a href="#36868275">next</a><span>|</span><label class="collapse" for="c-36868379">[-]</label><label class="expand" for="c-36868379">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve silently been a big fan of this approach for years but hadn&#x27;t heard about it anywhere (most likely because I&#x27;m not familiar with Pulumi).<p>Could you provide a reference that elaborates on &quot;Pulumi&#x27;s pattern&quot;?</div><br/><div id="36868497" class="c"><input type="checkbox" id="c-36868497" checked=""/><div class="controls bullet"><span class="by">getmeinrn</span><span>|</span><a href="#36868096">root</a><span>|</span><a href="#36868379">parent</a><span>|</span><a href="#36868275">next</a><span>|</span><label class="collapse" for="c-36868497">[-]</label><label class="expand" for="c-36868497">[2 more]</label></div><br/><div class="children"><div class="content">This is the closest example I could find <a href="https:&#x2F;&#x2F;www.pulumi.com&#x2F;docs&#x2F;concepts&#x2F;how-pulumi-works&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.pulumi.com&#x2F;docs&#x2F;concepts&#x2F;how-pulumi-works&#x2F;</a><p>Pulumi serves as the strongest contender to Terraform when doing IaC (infrastructure as code). Terraform attempts to be a declarative markup language (HCL) but it has a lot of weird imperative quirks due to (understandably) trying to support common complex use cases. In the end they have a clunky custom language that tries to do what general programming languages have done well forever. Pulumi doesn&#x27;t re-invent the wheel, and lets programming languages do what they do best. Pulumi only really cares that the programming language generates a declarative spec that can be used to compare with your infrastructure. It&#x27;s the best of both worlds.</div><br/><div id="36869049" class="c"><input type="checkbox" id="c-36869049" checked=""/><div class="controls bullet"><span class="by">codethief</span><span>|</span><a href="#36868096">root</a><span>|</span><a href="#36868497">parent</a><span>|</span><a href="#36868275">next</a><span>|</span><label class="collapse" for="c-36869049">[-]</label><label class="expand" for="c-36869049">[1 more]</label></div><br/><div class="children"><div class="content">Thanks so much!<p>&gt; Pulumi only really cares that the programming language generates a declarative spec that can be used to compare with your infrastructure. It&#x27;s the best of both worlds.<p>Fully agree! I&#x27;ve called this approach &quot;imperatively generating declarations&quot;.<p>Things might get complicated, though, if you try to nest this approach. E.g. if you imperatively generate the structure of your deployment pipeline, which in turn, contains imperative code to generate your infrastructure spec. :) Or something like that[0].<p>But that&#x27;s probably just the nature of the problem.<p>[0]: I can&#x27;t come up with a fully realistic scenario right now because it&#x27;s late. Maybe tomorrow!</div><br/></div></div></div></div></div></div><div id="36868275" class="c"><input type="checkbox" id="c-36868275" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#36868096">parent</a><span>|</span><a href="#36868379">prev</a><span>|</span><a href="#36871575">next</a><span>|</span><label class="collapse" for="c-36868275">[-]</label><label class="expand" for="c-36868275">[4 more]</label></div><br/><div class="children"><div class="content">PRQL seems the most realistic evolution out of SQL. Changing the programming paradigm will never convince the SQL true believers.</div><br/><div id="36868529" class="c"><input type="checkbox" id="c-36868529" checked=""/><div class="controls bullet"><span class="by">getmeinrn</span><span>|</span><a href="#36868096">root</a><span>|</span><a href="#36868275">parent</a><span>|</span><a href="#36871575">next</a><span>|</span><label class="collapse" for="c-36868529">[-]</label><label class="expand" for="c-36868529">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really know what you&#x27;re saying, can you say it another way? &quot;Most realistic evolution&quot;... why is that needed? If the problem is different database engines implementing the SQL spec differently, that&#x27;s not something that can be papered over with another abstraction without a lot of wrinkles.</div><br/><div id="36868868" class="c"><input type="checkbox" id="c-36868868" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#36868096">root</a><span>|</span><a href="#36868529">parent</a><span>|</span><a href="#36871575">next</a><span>|</span><label class="collapse" for="c-36868868">[-]</label><label class="expand" for="c-36868868">[2 more]</label></div><br/><div class="children"><div class="content">SQL does not need to be replaced, in the same way that COBOl never needed to be replaced. It can get the job done, but we have superior tools today. Better abstractions enable more productivity.<p>That there are N flavors of SQL is annoying, but there are foundational design choices in the language which we are stuck with today. PRQL is quite readable to those with SQL experience and feels like a plausible next language in the space without reinventing paradigms.</div><br/><div id="36869805" class="c"><input type="checkbox" id="c-36869805" checked=""/><div class="controls bullet"><span class="by">getmeinrn</span><span>|</span><a href="#36868096">root</a><span>|</span><a href="#36868868">parent</a><span>|</span><a href="#36871575">next</a><span>|</span><label class="collapse" for="c-36869805">[-]</label><label class="expand" for="c-36869805">[1 more]</label></div><br/><div class="children"><div class="content">To go back to my original post, my main beef is with turning an imperative language into a declarative one. If you&#x27;ve seen enough of these types of languages degrade, you start to see a pattern.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36871575" class="c"><input type="checkbox" id="c-36871575" checked=""/><div class="controls bullet"><span class="by">abrookewood</span><span>|</span><a href="#36868096">prev</a><span>|</span><a href="#36870872">next</a><span>|</span><label class="collapse" for="c-36871575">[-]</label><label class="expand" for="c-36871575">[1 more]</label></div><br/><div class="children"><div class="content">You have to love the honesty: &quot;Why PRQL? For HackerNews enthusiasts: The PRQL compiler is written in Rust [and] We talk about “orthogonal language features” a lot&quot; (<a href="https:&#x2F;&#x2F;prql-lang.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;prql-lang.org&#x2F;</a>)</div><br/></div></div><div id="36870872" class="c"><input type="checkbox" id="c-36870872" checked=""/><div class="controls bullet"><span class="by">slotrans</span><span>|</span><a href="#36871575">prev</a><span>|</span><a href="#36871996">next</a><span>|</span><label class="collapse" for="c-36870872">[-]</label><label class="expand" for="c-36870872">[3 more]</label></div><br/><div class="children"><div class="content">Hot takes: SQL is good. Great, in fact.<p>Not just in what it&#x27;s capable of doing, but in <i>form</i>. It has warts, yeah, but over the years I&#x27;ve been writing it I&#x27;ve realized most of them are there for a reason. To me it&#x27;s more than useful, it&#x27;s <i>beautiful</i>. It&#x27;s the absolute last thing I want a replacement for.</div><br/><div id="36871038" class="c"><input type="checkbox" id="c-36871038" checked=""/><div class="controls bullet"><span class="by">Abekkus</span><span>|</span><a href="#36870872">parent</a><span>|</span><a href="#36871996">next</a><span>|</span><label class="collapse" for="c-36871038">[-]</label><label class="expand" for="c-36871038">[2 more]</label></div><br/><div class="children"><div class="content">How do we ever hope to differentiate between useful evangelism and stockholm syndrome?  Either way, I&#x27;m probably learning a lot of postgresql this year.<p>I do really wish we had at least settled on one data format instead of having enough differences between PL data and DB data to start building ORMs.</div><br/><div id="36871434" class="c"><input type="checkbox" id="c-36871434" checked=""/><div class="controls bullet"><span class="by">ellisv</span><span>|</span><a href="#36870872">root</a><span>|</span><a href="#36871038">parent</a><span>|</span><a href="#36871996">next</a><span>|</span><label class="collapse" for="c-36871434">[-]</label><label class="expand" for="c-36871434">[1 more]</label></div><br/><div class="children"><div class="content">Unsurprisingly, not everything is intuitive. There are language nuances that can surprise and frustrate users but are often well thought out. It’s exceedingly rare to have a SQL query written 20 years ago that couldn’t be run today, and written today it may be the same or very similar to one written long ago. It’s hard to say the same for other programming languages.</div><br/></div></div></div></div></div></div><div id="36871996" class="c"><input type="checkbox" id="c-36871996" checked=""/><div class="controls bullet"><span class="by">jtsuken</span><span>|</span><a href="#36870872">prev</a><span>|</span><a href="#36869882">next</a><span>|</span><label class="collapse" for="c-36871996">[-]</label><label class="expand" for="c-36871996">[1 more]</label></div><br/><div class="children"><div class="content">There is a point in moving the FROM ahead of SELECT and getting sensible auto-complete suggestions from your IDE as you type.<p>LINQ, however, attempts to solve a much bigger problem:
Use consistent code to process data and don&#x27;t worry whether it is in a remote database or in a local array.<p>If you manage to do it in a way that<p>- integrates seamlessly with e.g. Python IDE and I don&#x27;t have to pass and parse strings<p>- allows me to access graph, document and relational data<p>- allows me to pull and process the data from REST APIs, [O&#x2F;J]DBC and straight from my RAM<p>- and maybe even includes deductive (PROLOG&#x2F;DATALOG) features<p>I will be your most loyal client</div><br/></div></div><div id="36869882" class="c"><input type="checkbox" id="c-36869882" checked=""/><div class="controls bullet"><span class="by">sakras</span><span>|</span><a href="#36871996">prev</a><span>|</span><a href="#36870336">next</a><span>|</span><label class="collapse" for="c-36869882">[-]</label><label class="expand" for="c-36869882">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been really cool seeing PRQL come to life! I&#x27;m not involved with it, but I still remember the very first HN post about a year ago where it was just a proposal. And look at it now! It&#x27;s really gaining steam, I&#x27;m really excited about it!</div><br/></div></div><div id="36870336" class="c"><input type="checkbox" id="c-36870336" checked=""/><div class="controls bullet"><span class="by">evantbyrne</span><span>|</span><a href="#36869882">prev</a><span>|</span><a href="#36869126">next</a><span>|</span><label class="collapse" for="c-36870336">[-]</label><label class="expand" for="c-36870336">[1 more]</label></div><br/><div class="children"><div class="content">Has anyone benchmarked it or the bindings? SQL tends to be embedded directly in software programs, so building would likely happen on the fly in real-world cases.</div><br/></div></div><div id="36869126" class="c"><input type="checkbox" id="c-36869126" checked=""/><div class="controls bullet"><span class="by">sdesol</span><span>|</span><a href="#36870336">prev</a><span>|</span><a href="#36870058">next</a><span>|</span><label class="collapse" for="c-36869126">[-]</label><label class="expand" for="c-36869126">[3 more]</label></div><br/><div class="children"><div class="content">This is from the GitHub page<p>&gt; PRQL is being actively developed by a growing community<p>You can see this at <a href="https:&#x2F;&#x2F;devboard.gitsense.com&#x2F;PRQL" rel="nofollow noreferrer">https:&#x2F;&#x2F;devboard.gitsense.com&#x2F;PRQL</a> which shows a good mix of new and not new contributors.  Not sure why there was a spike in the last couple of days though. Maybe the maintainers that in this thread can comment on this.<p>Full Disclosure: This is my tool</div><br/><div id="36869773" class="c"><input type="checkbox" id="c-36869773" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#36869126">parent</a><span>|</span><a href="#36870058">next</a><span>|</span><label class="collapse" for="c-36869773">[-]</label><label class="expand" for="c-36869773">[2 more]</label></div><br/><div class="children"><div class="content">Great tool! Thanks for sharing that.<p>Regarding the activity, there&#x27;s been a lot of preparation for the 0.9 release. As to the new contributors, I don&#x27;t know the reasons for that but all contributions are very welcome. It&#x27;s a very welcoming community and a great way to make an impact!<p>Full Disclosure: PRQL contributor</div><br/><div id="36870788" class="c"><input type="checkbox" id="c-36870788" checked=""/><div class="controls bullet"><span class="by">sdesol</span><span>|</span><a href="#36869126">root</a><span>|</span><a href="#36869773">parent</a><span>|</span><a href="#36870058">next</a><span>|</span><label class="collapse" for="c-36870788">[-]</label><label class="expand" for="c-36870788">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the insights. You might also want to add a &quot;good-first-issue&quot; topic an&#x2F;or labels to your project to signal how open you guys are to new contributors.  In the near future, I&#x27;m going to start surfacing projects with these labels&#x2F;topics.</div><br/></div></div></div></div></div></div><div id="36870058" class="c"><input type="checkbox" id="c-36870058" checked=""/><div class="controls bullet"><span class="by">lovasoa</span><span>|</span><a href="#36869126">prev</a><span>|</span><a href="#36867637">next</a><span>|</span><label class="collapse" for="c-36870058">[-]</label><label class="expand" for="c-36870058">[1 more]</label></div><br/><div class="children"><div class="content">I am currently building a SQL-only web framework [1], and I was contacted by the prql folks to include the language by default in sqlpage. I have to say, I have mixed feelings about it: on one hand, it indeed feels more natural to query data with a clean pipeline of operators. On the other hand, it makes me think of the famous xkcd comic about standards [2]: there were too many data querying languages, so we made a new one.<p>[1] SQLPage: <a href="https:&#x2F;&#x2F;sql.ophir.dev" rel="nofollow noreferrer">https:&#x2F;&#x2F;sql.ophir.dev</a><p>[2] <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;927&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;xkcd.com&#x2F;927&#x2F;</a></div><br/></div></div><div id="36867637" class="c"><input type="checkbox" id="c-36867637" checked=""/><div class="controls bullet"><span class="by">breischl</span><span>|</span><a href="#36870058">prev</a><span>|</span><a href="#36870225">next</a><span>|</span><label class="collapse" for="c-36867637">[-]</label><label class="expand" for="c-36867637">[5 more]</label></div><br/><div class="children"><div class="content">Having spent more time in MongoDB aggregations than I&#x27;d like to lately, I really wish they&#x27;d support this. So much more sensible than the madness they&#x27;ve got going on.</div><br/><div id="36869888" class="c"><input type="checkbox" id="c-36869888" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#36867637">parent</a><span>|</span><a href="#36870225">next</a><span>|</span><label class="collapse" for="c-36869888">[-]</label><label class="expand" for="c-36869888">[4 more]</label></div><br/><div class="children"><div class="content">This sounds interesting. Could you provide a link to the MongoDB aggregations that your are referring to because they&#x27;re not something I&#x27;m familiar with?<p>(Disclaimer: I&#x27;m a PRQL contributor.)</div><br/><div id="36870073" class="c"><input type="checkbox" id="c-36870073" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#36867637">root</a><span>|</span><a href="#36869888">parent</a><span>|</span><a href="#36870225">next</a><span>|</span><label class="collapse" for="c-36870073">[-]</label><label class="expand" for="c-36870073">[3 more]</label></div><br/><div class="children"><div class="content">Here are examples of MongoDB aggregations: <a href="https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickBench&#x2F;blob&#x2F;main&#x2F;mongodb&#x2F;queries.js">https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickBench&#x2F;blob&#x2F;main&#x2F;mongodb&#x2F;q...</a><p>They are painful to write compared to SQL queries.<p>Although the commercial version of MongoDB has support for SQL, it&#x27;s not available for general MongoDB users.</div><br/><div id="36870228" class="c"><input type="checkbox" id="c-36870228" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#36867637">root</a><span>|</span><a href="#36870073">parent</a><span>|</span><a href="#36870225">next</a><span>|</span><label class="collapse" for="c-36870228">[-]</label><label class="expand" for="c-36870228">[2 more]</label></div><br/><div class="children"><div class="content">Thanks!<p>Those do look awful and more what I remember from the brief period when I used MongoDB in around 2013 or so.<p>I take it GP comment was just trolling then?</div><br/><div id="36872243" class="c"><input type="checkbox" id="c-36872243" checked=""/><div class="controls bullet"><span class="by">breischl</span><span>|</span><a href="#36867637">root</a><span>|</span><a href="#36870228">parent</a><span>|</span><a href="#36870225">next</a><span>|</span><label class="collapse" for="c-36872243">[-]</label><label class="expand" for="c-36872243">[1 more]</label></div><br/><div class="children"><div class="content">I was not trolling, I actually dislike MongoDB aggregation syntax and it seems like PRQL is something that could potentially replace it or go on top. Admittedly I only took a quick glance at PRQL though, so perhaps I misunderstood something or it&#x27;s not applicable to this case.<p>There are examples on Mongo&#x27;s page, eg <a href="https:&#x2F;&#x2F;www.mongodb.com&#x2F;docs&#x2F;manual&#x2F;core&#x2F;aggregation-pipeline&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.mongodb.com&#x2F;docs&#x2F;manual&#x2F;core&#x2F;aggregation-pipelin...</a><p>eg:<p><pre><code>  db.orders.aggregate( [
   &#x2F;&#x2F; Stage 1: Filter pizza order documents by pizza size
   {
      $match: { size: &quot;medium&quot; }
   },
   &#x2F;&#x2F; Stage 2: Group remaining documents by pizza name and calculate total quantity
   {
      $group: { _id: &quot;$name&quot;, totalQuantity: { $sum: &quot;$quantity&quot; } }
   }
  ] )</code></pre></div><br/></div></div></div></div></div></div></div></div></div></div><div id="36870225" class="c"><input type="checkbox" id="c-36870225" checked=""/><div class="controls bullet"><span class="by">soulbadguy</span><span>|</span><a href="#36867637">prev</a><span>|</span><a href="#36868287">next</a><span>|</span><label class="collapse" for="c-36870225">[-]</label><label class="expand" for="c-36870225">[1 more]</label></div><br/><div class="children"><div class="content">Naive question :<p>Isn&#x27;t something like F# computation expression or C# LINQ a simpler and more generic way of acheiving the same effect?</div><br/></div></div><div id="36868287" class="c"><input type="checkbox" id="c-36868287" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#36870225">prev</a><span>|</span><a href="#36871788">next</a><span>|</span><label class="collapse" for="c-36868287">[-]</label><label class="expand" for="c-36868287">[1 more]</label></div><br/><div class="children"><div class="content">Forwarding this to some of my team members right now.<p>We use SQL for a lot of things, almost all of them implementation of customized business rules. When attempting to develop a business rule that needs to manifest as a single SQL query, your brain is forced to work in a very particular crystalline way. Many business rules are defined in procedural terms at requirements time, so having a way to implement them in the same could be beneficial.</div><br/></div></div><div id="36871788" class="c"><input type="checkbox" id="c-36871788" checked=""/><div class="controls bullet"><span class="by">tln</span><span>|</span><a href="#36868287">prev</a><span>|</span><a href="#36867319">next</a><span>|</span><label class="collapse" for="c-36871788">[-]</label><label class="expand" for="c-36871788">[1 more]</label></div><br/><div class="children"><div class="content">Have completions been implemented at all? The language looks like it is designed to take that into account, but I don&#x27;t see that after a cursory search</div><br/></div></div><div id="36867319" class="c"><input type="checkbox" id="c-36867319" checked=""/><div class="controls bullet"><span class="by">kot-behemoth</span><span>|</span><a href="#36871788">prev</a><span>|</span><a href="#36868749">next</a><span>|</span><label class="collapse" for="c-36867319">[-]</label><label class="expand" for="c-36867319">[3 more]</label></div><br/><div class="children"><div class="content">Just a heads up that Prefect integration link on the landing page doesn&#x27;t work - 404. This is the one I was interested in!</div><br/><div id="36868384" class="c"><input type="checkbox" id="c-36868384" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#36867319">parent</a><span>|</span><a href="#36868372">next</a><span>|</span><label class="collapse" for="c-36868384">[-]</label><label class="expand" for="c-36868384">[1 more]</label></div><br/><div class="children"><div class="content">Sorry that that was your first experience. I have opened an issue for this for you: <a href="https:&#x2F;&#x2F;github.com&#x2F;PRQL&#x2F;prql&#x2F;issues&#x2F;3074">https:&#x2F;&#x2F;github.com&#x2F;PRQL&#x2F;prql&#x2F;issues&#x2F;3074</a><p>The correct link is the following: <a href="https:&#x2F;&#x2F;prql-lang.org&#x2F;book&#x2F;project&#x2F;integrations&#x2F;prefect.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;prql-lang.org&#x2F;book&#x2F;project&#x2F;integrations&#x2F;prefect.html</a><p>TBH, that one is not much of an integration yet. It essentially boils down do.<p><pre><code>    $ pip install prql-python
</code></pre>
and then<p><pre><code>    import prql_python
    PostgresExecute.run(..., query=prql_python.compile(prql))
</code></pre>
I don&#x27;t personally work with Prefect, so if you have any ideas about what you would like to see here, please comment on the issue or on Discord. We&#x27;re also very open to Pull Requests and they usually get merged fast ;-)<p>Disclaimer: I&#x27;m a PRQL contributor.</div><br/></div></div><div id="36868372" class="c"><input type="checkbox" id="c-36868372" checked=""/><div class="controls bullet"><span class="by">maximilianroos</span><span>|</span><a href="#36867319">parent</a><span>|</span><a href="#36868384">prev</a><span>|</span><a href="#36868749">next</a><span>|</span><label class="collapse" for="c-36868372">[-]</label><label class="expand" for="c-36868372">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! We just did a big refactoring so we do have some links failing in our tests. Just PR-ed a fix to this one: <a href="https:&#x2F;&#x2F;github.com&#x2F;PRQL&#x2F;prql&#x2F;pull&#x2F;3075">https:&#x2F;&#x2F;github.com&#x2F;PRQL&#x2F;prql&#x2F;pull&#x2F;3075</a><p>(PRQL dev here)</div><br/></div></div></div></div><div id="36868749" class="c"><input type="checkbox" id="c-36868749" checked=""/><div class="controls bullet"><span class="by">netcraft</span><span>|</span><a href="#36867319">prev</a><span>|</span><label class="collapse" for="c-36868749">[-]</label><label class="expand" for="c-36868749">[2 more]</label></div><br/><div class="children"><div class="content">I dont know the right words, but creating a plugin for DBT for this would give it a lot of traction I bet.</div><br/><div id="36869297" class="c"><input type="checkbox" id="c-36869297" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#36868749">parent</a><span>|</span><label class="collapse" for="c-36869297">[-]</label><label class="expand" for="c-36869297">[1 more]</label></div><br/><div class="children"><div class="content">Totally agree. This was a high priority goal for us and @maximilianroos did a lot of work putting something together. In the end, I believe it was really fighting against how dbt is set up though as it is so tightly interwoven with Jinja2. Perhaps with the introduction of the Python dbt models, things might have changed now and it&#x27;s worth taking another look.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;PRQL&#x2F;dbt-prql">https:&#x2F;&#x2F;github.com&#x2F;PRQL&#x2F;dbt-prql</a><p>(Disclaimer: I&#x27;m a PRQL contributor.)</div><br/></div></div></div></div></div></div></div></div></div></body></html>