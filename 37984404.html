<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1698138085960" as="style"/><link rel="stylesheet" href="styles.css?v=1698138085960"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/mthiim/dilithium-java">Java implementation of a quantum computing resistant cryptographic algorithm</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>mooreds</span> | <span>54 comments</span></div><br/><div><div id="37989764" class="c"><input type="checkbox" id="c-37989764" checked=""/><div class="controls bullet"><span class="by">mthiim</span><span>|</span><a href="#37985383">next</a><span>|</span><label class="collapse" for="c-37989764">[-]</label><label class="expand" for="c-37989764">[4 more]</label></div><br/><div class="children"><div class="content">Hello everyone! I&#x27;m thrilled to see my project trending here on Hacker News. It&#x27;s a pure toy implementation inspired by the paper and its reference. While it aligns with all the provided test cases, I wrote it primarily for fun and to see it work seamlessly with the standard JCE interfaces. If you have any questions or feedback, please don&#x27;t hesitate to ask. Thanks for checking it out! Best regards, the author. :-)</div><br/><div id="37995492" class="c"><input type="checkbox" id="c-37995492" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37989764">parent</a><span>|</span><a href="#37990091">next</a><span>|</span><label class="collapse" for="c-37995492">[-]</label><label class="expand" for="c-37995492">[1 more]</label></div><br/><div class="children"><div class="content">It looks great piece of work, and you even took the extra effort for JCE integration, congratulations.</div><br/></div></div><div id="37990091" class="c"><input type="checkbox" id="c-37990091" checked=""/><div class="controls bullet"><span class="by">mooreds</span><span>|</span><a href="#37989764">parent</a><span>|</span><a href="#37995492">prev</a><span>|</span><a href="#37985383">next</a><span>|</span><label class="collapse" for="c-37990091">[-]</label><label class="expand" for="c-37990091">[2 more]</label></div><br/><div class="children"><div class="content">Heya, what would it take to productionize it? Are you aware of any java libs for quantum proof cryptography that are production ready?</div><br/><div id="37990295" class="c"><input type="checkbox" id="c-37990295" checked=""/><div class="controls bullet"><span class="by">mthiim</span><span>|</span><a href="#37989764">root</a><span>|</span><a href="#37990091">parent</a><span>|</span><a href="#37985383">next</a><span>|</span><label class="collapse" for="c-37990295">[-]</label><label class="expand" for="c-37990295">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not aware of any production-grade libs of these algorithms, but they might exist. While NIST did pick Dilthium as among the winners in summer 2022, it still hasn&#x27;t been fully standardized yet. The mathematical principles are final, of course, but they still need to be documented in the form of a standard, with many other details specified, such as the ASN.1&#x2F;binary encodings of keys, signatures, etc., so they can be used in the context of a broader PKI and certificates. Some of this is specified in the Dilithium submission (primarily because some of the values need to be encoded and processed as part of the algorithms themselves), but it doesn&#x27;t cover everything and doesn&#x27;t specify other details like OIDs, etc. This specification is also necessary before validation programs like FIPS 140-2 can get off the ground.</div><br/></div></div></div></div></div></div><div id="37985383" class="c"><input type="checkbox" id="c-37985383" checked=""/><div class="controls bullet"><span class="by">simpaticoder</span><span>|</span><a href="#37989764">prev</a><span>|</span><a href="#37984957">next</a><span>|</span><label class="collapse" for="c-37985383">[-]</label><label class="expand" for="c-37985383">[2 more]</label></div><br/><div class="children"><div class="content">Most of the &quot;meat&quot; of this toy implementation of Dilithium can be found at <a href="https:&#x2F;&#x2F;github.com&#x2F;mthiim&#x2F;dilithium-java&#x2F;blob&#x2F;main&#x2F;src&#x2F;main&#x2F;java&#x2F;net&#x2F;thiim&#x2F;dilithium&#x2F;impl&#x2F;Dilithium.java">https:&#x2F;&#x2F;github.com&#x2F;mthiim&#x2F;dilithium-java&#x2F;blob&#x2F;main&#x2F;src&#x2F;main&#x2F;...</a></div><br/><div id="37992227" class="c"><input type="checkbox" id="c-37992227" checked=""/><div class="controls bullet"><span class="by">calibas</span><span>|</span><a href="#37985383">parent</a><span>|</span><a href="#37984957">next</a><span>|</span><label class="collapse" for="c-37992227">[-]</label><label class="expand" for="c-37992227">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s the Dilithium specifications too: <a href="https:&#x2F;&#x2F;pq-crystals.org&#x2F;dilithium&#x2F;data&#x2F;dilithium-specification-round3-20210208.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;pq-crystals.org&#x2F;dilithium&#x2F;data&#x2F;dilithium-specificati...</a></div><br/></div></div></div></div><div id="37984957" class="c"><input type="checkbox" id="c-37984957" checked=""/><div class="controls bullet"><span class="by">rany_</span><span>|</span><a href="#37985383">prev</a><span>|</span><a href="#37987510">next</a><span>|</span><label class="collapse" for="c-37984957">[-]</label><label class="expand" for="c-37984957">[36 more]</label></div><br/><div class="children"><div class="content">Is it a good idea to use quantum resistant crypto algorithm on-top of more established&#x2F;widespread algorithms like RSA&#x2F;ECDSA? I don&#x27;t feel comfortable using quantum resistant crypto due to how cutting edge it all is.</div><br/><div id="37985218" class="c"><input type="checkbox" id="c-37985218" checked=""/><div class="controls bullet"><span class="by">timenova</span><span>|</span><a href="#37984957">parent</a><span>|</span><a href="#37985004">next</a><span>|</span><label class="collapse" for="c-37985218">[-]</label><label class="expand" for="c-37985218">[11 more]</label></div><br/><div class="children"><div class="content">It seems that&#x27;s exactly what the community is doing.<p>Cloudflare recently enabled post-quantum cryptography, in which they&#x27;re using X25519+Kyber [0]. Similarly, Signal&#x27;s post-quantum cryptography also uses the same [1].<p>I&#x27;m guessing this spawned from the fact that a post-quantum algorithm was broken on classical computers a few years ago [2].<p>So now any attacker would have to break both the classical algorithm and the post-quantum algorithm.<p>[0] <a href="https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;post-quantum-to-origins&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;post-quantum-to-origins&#x2F;</a><p>[1] <a href="https:&#x2F;&#x2F;signal.org&#x2F;blog&#x2F;pqxdh&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;signal.org&#x2F;blog&#x2F;pqxdh&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;www.quantamagazine.org&#x2F;post-quantum-cryptography-scheme-is-cracked-on-a-laptop-20220824&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.quantamagazine.org&#x2F;post-quantum-cryptography-sch...</a></div><br/><div id="37985890" class="c"><input type="checkbox" id="c-37985890" checked=""/><div class="controls bullet"><span class="by">cbeach</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985218">parent</a><span>|</span><a href="#37985004">next</a><span>|</span><label class="collapse" for="c-37985890">[-]</label><label class="expand" for="c-37985890">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve probably missed an important detail here, but if the post-quantum algo can be broken on classical computers, what use is it, vs. a combination of classical and quantum computers?</div><br/><div id="37989953" class="c"><input type="checkbox" id="c-37989953" checked=""/><div class="controls bullet"><span class="by">mthiim</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985890">parent</a><span>|</span><a href="#37986401">next</a><span>|</span><label class="collapse" for="c-37989953">[-]</label><label class="expand" for="c-37989953">[1 more]</label></div><br/><div class="children"><div class="content">That algorithm was never chosen as a final candidate, unlike Dilithium and Kyber. Nevertheless, it remains intriguing because it advanced significantly in the competition until this vulnerability was identified, which allows for it to be cracked in just a few minutes on a standard computer. This underscores the inherent risk of rapidly introducing new algorithms, whether quantum or not. While RSA might become vulnerable to future quantum computers, its resilience since its public introduction in 1977 (aside from the need to increase key sizes) is quite an achievement. This is why new algorithms should always be paired with trusted classical algorithms to get the best of both worlds: if the new post-quantum component is flawed, at least you&#x27;re not worse off than if you had used classical algorithms. On the other hand, if quantum computers capable of breaking practical sizes of RSA or ECC emerge, there&#x27;s still the hope that the post-quantum element remains intact.</div><br/></div></div><div id="37986401" class="c"><input type="checkbox" id="c-37986401" checked=""/><div class="controls bullet"><span class="by">hannob</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985890">parent</a><span>|</span><a href="#37989953">prev</a><span>|</span><a href="#37986599">next</a><span>|</span><label class="collapse" for="c-37986401">[-]</label><label class="expand" for="c-37986401">[1 more]</label></div><br/><div class="children"><div class="content">The algorithm that was broken is of course no longer used.<p>The point is: Many of these algorithms are rather new. The fact that multiple post quantum algorithms have been broken that were seen as promising shows that there is a risk with these new algorithms.<p>However, it should be said that the broken algorithms were in, let&#x27;s say, more experimental subfields of post quantum cryptography.</div><br/></div></div><div id="37986599" class="c"><input type="checkbox" id="c-37986599" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985890">parent</a><span>|</span><a href="#37986401">prev</a><span>|</span><a href="#37989827">next</a><span>|</span><label class="collapse" for="c-37986599">[-]</label><label class="expand" for="c-37986599">[4 more]</label></div><br/><div class="children"><div class="content">At this point quantum computers aren&#x27;t breaking anything. Adding protections against them is nice because we&#x27;re theoretically safe in the future. We don&#x27;t want to compromise our safety <i>now</i> by choosing algorithms that are less battle tested though, so it&#x27;s best to layer them.<p>If it turns out that both the classical and quantum hard algorithms are weak we&#x27;re just screwed, yes. That said, at this point it&#x27;s not even clear, as far as I know, that many classical algorithms are event going to be broken under QC.</div><br/><div id="37990501" class="c"><input type="checkbox" id="c-37990501" checked=""/><div class="controls bullet"><span class="by">mthiim</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37986599">parent</a><span>|</span><a href="#37990415">next</a><span>|</span><label class="collapse" for="c-37990501">[-]</label><label class="expand" for="c-37990501">[2 more]</label></div><br/><div class="children"><div class="content">Agreed. While manufacturers do show an impressive increase in the number of noisy qubits, we still have yet to see a demonstration of quantum error correction at anywhere near the levels needed to pull of a QC that breaks e.g. RSA.</div><br/><div id="37992565" class="c"><input type="checkbox" id="c-37992565" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37990501">parent</a><span>|</span><a href="#37990415">next</a><span>|</span><label class="collapse" for="c-37992565">[-]</label><label class="expand" for="c-37992565">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also unclear (to me, perhaps not to others!) if the conversion from O(2^n) -&gt; O(2^n&#x2F;2) means it will be faster in practice on quantum hardware.<p><a href="https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2017&#x2F;811" rel="nofollow noreferrer">https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2017&#x2F;811</a><p>&gt; Reassessing Grover&#x27;s Algorithm<p>The proposal of this paper is that Grover&#x27;s does not mean we need to double the size of symmetric keys to account for QM but that just a few extra bits are enough to prevent it from being efficient.<p>Of course, there may be new QM algorithms that don&#x27;t suffer and, again, it&#x27;s best to start preparing <i>now</i> and not later. But I think it&#x27;s noteworthy for the discussion about quantum preparedness.</div><br/></div></div></div></div></div></div><div id="37989827" class="c"><input type="checkbox" id="c-37989827" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985890">parent</a><span>|</span><a href="#37986599">prev</a><span>|</span><a href="#37987164">next</a><span>|</span><label class="collapse" for="c-37989827">[-]</label><label class="expand" for="c-37989827">[1 more]</label></div><br/><div class="children"><div class="content">Secure transports are built out of asymmetric key agreement and symmetric bulk encryption, glued together with symmetric hashes. The symmetric cryptography isn&#x27;t meaningfully threatened by any QC we&#x27;re yet aware of. Hybrid PQC&#x2F;classical schemes do two key agreements (an ECC kex and a LWE kem), and then plug both results into HKDF (conceptually: a symmetric hash) to derive a shared secret.<p>In that scheme, you have to compromise both the PQC and ECC key agreements, independently.</div><br/></div></div><div id="37987164" class="c"><input type="checkbox" id="c-37987164" checked=""/><div class="controls bullet"><span class="by">aardvarkr</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985890">parent</a><span>|</span><a href="#37989827">prev</a><span>|</span><a href="#37987360">next</a><span>|</span><label class="collapse" for="c-37987164">[-]</label><label class="expand" for="c-37987164">[1 more]</label></div><br/><div class="children"><div class="content">It was âaâ post quantum proposed algorithm, not âtheâ post quantum algo. Donât judge an entire field because of one proposal that didnât work.</div><br/></div></div><div id="37987360" class="c"><input type="checkbox" id="c-37987360" checked=""/><div class="controls bullet"><span class="by">mratsim</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985890">parent</a><span>|</span><a href="#37987164">prev</a><span>|</span><a href="#37985004">next</a><span>|</span><label class="collapse" for="c-37987360">[-]</label><label class="expand" for="c-37987360">[1 more]</label></div><br/><div class="children"><div class="content">It was broken because of a mathematical breakthrough using theory lurking in the dark corners of math. The protocol itself was also using some somewhat dark corner of math.<p>Which is why having as many eyes as possible is important.<p>Now it&#x27;s very well possible that it comes back with mitigations.<p>And even the still OK candidates are using a young area of math.</div><br/></div></div></div></div></div></div><div id="37985004" class="c"><input type="checkbox" id="c-37985004" checked=""/><div class="controls bullet"><span class="by">Deukhoofd</span><span>|</span><a href="#37984957">parent</a><span>|</span><a href="#37985218">prev</a><span>|</span><a href="#37988778">next</a><span>|</span><label class="collapse" for="c-37985004">[-]</label><label class="expand" for="c-37985004">[19 more]</label></div><br/><div class="children"><div class="content">As far as I&#x27;m aware, Shor&#x27;s Algorithm is still unfeasible because it requires far more qubits than currently available to execute in any reasonable time. It&#x27;d require several million qubits, while the most cutting-edge devices currently only have a couple of hundreds at best.<p>I wouldn&#x27;t worry too much about post-quantum algorithms for any production code in the next couple of years (decades?) myself.</div><br/><div id="37985894" class="c"><input type="checkbox" id="c-37985894" checked=""/><div class="controls bullet"><span class="by">japanuspus</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985004">parent</a><span>|</span><a href="#37985163">next</a><span>|</span><label class="collapse" for="c-37985894">[-]</label><label class="expand" for="c-37985894">[1 more]</label></div><br/><div class="children"><div class="content">Quantum factoring may not be quite as far distant as you might think<p>Most importantly, Shor is not the algorithm of choice for first-gen hardware where the central challenge is likely to be circuit depth due to error correction overhead. The current front-runner is a probably proposal by Regev [0] with a space-optimization by Ragavan et al. [1], which factors an n-bit integer with O(n log n) logical qubits and a circuit depth of O(n).<p>What you should be looking for when studying quantum computing press releases is &quot;fault tolerance&quot;: A central problem in QC is that the underlying hardware needs to be better than an (architecture-specific) threshold, before error-correction can be applied without introducing more errors than it corrects.<p>Nobody has really crossed the threshold yet with scalable hardware, and when someone does, the overhead will be abysmal (2 or 3 layers of error correction, each with a factor ~100 overhead in space and time). Still, there are two reasons to be optimistic:<p>One reason is that once a system crosses the threshold, any improvement in hardware will result in exponential improvements in the encoded operations, meaning that there will be a Moore-style exponential development.<p>Another reason is that there are several &quot;dark mode&quot; VC-funded companies working towards intrinsically scalable systems based on optical QC: If any of these achieve fault tolerance, they will be scalable from day one.<p>[0]: <a href="http:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2308.06572" rel="nofollow noreferrer">http:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2308.06572</a>
[1]: <a href="http:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2310.00899" rel="nofollow noreferrer">http:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2310.00899</a></div><br/></div></div><div id="37985163" class="c"><input type="checkbox" id="c-37985163" checked=""/><div class="controls bullet"><span class="by">hypeatei</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985004">parent</a><span>|</span><a href="#37985894">prev</a><span>|</span><a href="#37985080">next</a><span>|</span><label class="collapse" for="c-37985163">[-]</label><label class="expand" for="c-37985163">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;d probably be looking at a shorter timeline, just because of the Harvest Now, Decrypt Later strategy[0].<p>[0]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Harvest_now,_decrypt_later" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Harvest_now,_decrypt_later</a></div><br/><div id="37985292" class="c"><input type="checkbox" id="c-37985292" checked=""/><div class="controls bullet"><span class="by">Frost1x</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985163">parent</a><span>|</span><a href="#37988617">next</a><span>|</span><label class="collapse" for="c-37985292">[-]</label><label class="expand" for="c-37985292">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say it ultimately depends on the information you&#x27;re encrypting. Information and secrecy around it often has some sort of temporal&#x2F;time relationship tied to the information and surrounding context. If it&#x27;s something you wish to protect indefinitely or for a long time into the future, it&#x27;s important to consider now. If n the other hand it&#x27;s some rotating fairly randomly generated password that expires monthly, quarterly, whatever or say session information that expires after a period then you don&#x27;t need to worry so much about this. Context of the information you&#x27;re protecting is important to determine time periods you wish to protect it for and you should already be considering this today when choosing protection strategies, IMO.</div><br/><div id="37987607" class="c"><input type="checkbox" id="c-37987607" checked=""/><div class="controls bullet"><span class="by">rainsford</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985292">parent</a><span>|</span><a href="#37985837">next</a><span>|</span><label class="collapse" for="c-37987607">[-]</label><label class="expand" for="c-37987607">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an approach that makes sense in theory, but in practice you&#x27;re almost certainly better off assuming a long time horizon for protecting everything.<p>For one thing, it&#x27;s not always obvious what&#x27;s short term vs long term information and you could end up applying short term protection to information that has long term value in a scenario you didn&#x27;t consider.  For example, encrypted session information that expires might not be useful in gaining access to an account, but it could potentially be used to track you in historical data.<p>The other problem is that most systems (and people) aren&#x27;t great at segregating information that needs short term vs long term protection, so it&#x27;s hard in practice to have a strategy based on applying different cryptographic protection to different information.  Most encrypted protocols and systems deal with a mix of information that ranges from inconsequential if revealed even now to requiring long term confidentiality because it&#x27;s much harder to try to deal with that information separately.  There&#x27;s also the practical argument that once I have a protocol or system to protect high value, long term info, why wouldn&#x27;t I just use that for everything?  Modern HTTPS is ridiculous overkill for the vast majority of things it protects, but there&#x27;s really no reason to use something worse even if you could get away with doing so.<p>This is basically the premise of HTTPS everywhere and similar encrypt all the things concepts.  It makes a lot more sense to just protect everything instead of trying to figure out what needs protection and what doesn&#x27;t and hoping you didn&#x27;t get it wrong or that nothing changes over the years.  Same goes for post-quantum crypto.  You might be OK not adopting it for things you think don&#x27;t need protection beyond the time a practical quantum computer comes around (good luck guessing that time horizon btw), but it&#x27;s both easier and less error prone to just post quantum all the things.</div><br/></div></div><div id="37985837" class="c"><input type="checkbox" id="c-37985837" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985292">parent</a><span>|</span><a href="#37987607">prev</a><span>|</span><a href="#37988617">next</a><span>|</span><label class="collapse" for="c-37985837">[-]</label><label class="expand" for="c-37985837">[1 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s a password, sure, rotating it every once in a while should secure your account if someone has stored a copy of the encrypted (usually hashed) version; that said, rotating passwords is no longer a recommended practice, and second, it&#x27;s more important for encrypted data, like hard drives, online e2e-encrypted chats, internet usage, images&#x2F;files, etc. You can change the password &#x2F; key on those too, but if someone already has a copy of the old password encrypted data it may be cracked later on.<p>In practice this is probsbly reserved for important people I suppose.</div><br/></div></div></div></div><div id="37988617" class="c"><input type="checkbox" id="c-37988617" checked=""/><div class="controls bullet"><span class="by">Strilanc</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985163">parent</a><span>|</span><a href="#37985292">prev</a><span>|</span><a href="#37990439">next</a><span>|</span><label class="collapse" for="c-37988617">[-]</label><label class="expand" for="c-37988617">[1 more]</label></div><br/><div class="children"><div class="content">You also probably want post-quantum crypto if you&#x27;re making anything that can be updated, and there&#x27;s a chance the thing may sit in a drawer for 10 years before being connected to the internet. The crypto you use to authenticate an update&#x27;s origin needs to still be secure at take-out-of-drawer time.</div><br/></div></div><div id="37990439" class="c"><input type="checkbox" id="c-37990439" checked=""/><div class="controls bullet"><span class="by">mthiim</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985163">parent</a><span>|</span><a href="#37988617">prev</a><span>|</span><a href="#37985080">next</a><span>|</span><label class="collapse" for="c-37990439">[-]</label><label class="expand" for="c-37990439">[1 more]</label></div><br/><div class="children"><div class="content">True - on the other hand, that fear&#x2F;principle could be applied to all algorithms that could theoretically be broke in the future. There&#x27;s a lot of uncertainty concerning the scalability of quantum computers and quantum error corrections. In the neare future it seems more likely that the post-quantum algorithms might be broken (even on normal computers) compared to quantum computers cracking RSA&#x2F;ECC (so one should at least combine to get the best of both worlds)</div><br/></div></div></div></div><div id="37985080" class="c"><input type="checkbox" id="c-37985080" checked=""/><div class="controls bullet"><span class="by">anticrymactic</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985004">parent</a><span>|</span><a href="#37985163">prev</a><span>|</span><a href="#37985824">next</a><span>|</span><label class="collapse" for="c-37985080">[-]</label><label class="expand" for="c-37985080">[4 more]</label></div><br/><div class="children"><div class="content">This exact sentiment is why passwords are still hashed Unding md5. While I wouldn&#x27;t exactly worry about Post-Quantum right now, it&#x27;s important to implement and be ready to switch.</div><br/><div id="37985957" class="c"><input type="checkbox" id="c-37985957" checked=""/><div class="controls bullet"><span class="by">KMag</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985080">parent</a><span>|</span><a href="#37985788">next</a><span>|</span><label class="collapse" for="c-37985957">[-]</label><label class="expand" for="c-37985957">[2 more]</label></div><br/><div class="children"><div class="content">Encrypted data is almost certainly being recorded now in anticipation of quantum computers being able to break it later.</div><br/><div id="37993823" class="c"><input type="checkbox" id="c-37993823" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985957">parent</a><span>|</span><a href="#37985788">next</a><span>|</span><label class="collapse" for="c-37993823">[-]</label><label class="expand" for="c-37993823">[1 more]</label></div><br/><div class="children"><div class="content">The NSA&#x27;s Utah datacenter has to store something!</div><br/></div></div></div></div></div></div><div id="37985824" class="c"><input type="checkbox" id="c-37985824" checked=""/><div class="controls bullet"><span class="by">Workaccount2</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985004">parent</a><span>|</span><a href="#37985080">prev</a><span>|</span><a href="#37989905">next</a><span>|</span><label class="collapse" for="c-37985824">[-]</label><label class="expand" for="c-37985824">[1 more]</label></div><br/><div class="children"><div class="content">I think the fear people have is an attacker storing captured encrypted data and decrypting it later. It may be five or ten years out of date by the time it is decrypted, but even then it could still prove to be fruitful for the attacker.<p>I&#x27;m sure many oppressive regimes would love to know what their citizens where privately talking about, even if it was ten years ago. I think its a valid concern that quantum computing might take off, and in ten years you could run shores algo on an AWS instance. Long con attackers could MITM chats for juicy blackmail in the future.</div><br/></div></div><div id="37989905" class="c"><input type="checkbox" id="c-37989905" checked=""/><div class="controls bullet"><span class="by">kvathupo</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985004">parent</a><span>|</span><a href="#37985824">prev</a><span>|</span><a href="#37988688">next</a><span>|</span><label class="collapse" for="c-37989905">[-]</label><label class="expand" for="c-37989905">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d agree. I&#x27;d say adversaries are unlikely to steal data now, wait a decade or two, and then decrypt on a quantum computer for _most_ private company ip. It&#x27;s only relevant to government at this stage, yet Congress is, unsurprisingly, out-of-touch (or perhaps age?) in this regard.<p>Fun fact: I emailed my senator, chair of the foreign relations committee, on concerns over China&#x27;s heavy investment here. I got a reply from an overworked intern about banning Tiktok !</div><br/></div></div><div id="37988688" class="c"><input type="checkbox" id="c-37988688" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985004">parent</a><span>|</span><a href="#37989905">prev</a><span>|</span><a href="#37993635">next</a><span>|</span><label class="collapse" for="c-37988688">[-]</label><label class="expand" for="c-37988688">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I wouldn&#x27;t worry too much about post-quantum algorithms for any production code in the next couple of years (decades?) myself.<p>For data in transit that&#x27;s probably fine, but for data at rest, you have to consider how long that data might remain at rest.  If you have 30 year old encrypted data that is now breakable, is that a problem?  It depends on the use case.<p>Also keep in mind that any data in transit could be tapped and saved and become data at rest.<p>So really you have to ask yourself, is it critical that this data remain encrypted in 20 years?</div><br/></div></div><div id="37993635" class="c"><input type="checkbox" id="c-37993635" checked=""/><div class="controls bullet"><span class="by">billti</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985004">parent</a><span>|</span><a href="#37988688">prev</a><span>|</span><a href="#37985746">next</a><span>|</span><label class="collapse" for="c-37993635">[-]</label><label class="expand" for="c-37993635">[1 more]</label></div><br/><div class="children"><div class="content">This recently released page might be of a lot of interest to this discussion regarding crypto algorithms and the size of the quantum hardware needed. (Disclaimer, I work on the Azure Quantum team that builds this).<p><a href="https:&#x2F;&#x2F;quantum.microsoft.com&#x2F;en-us&#x2F;experience&#x2F;quantum-cryptography" rel="nofollow noreferrer">https:&#x2F;&#x2F;quantum.microsoft.com&#x2F;en-us&#x2F;experience&#x2F;quantum-crypt...</a></div><br/></div></div><div id="37985746" class="c"><input type="checkbox" id="c-37985746" checked=""/><div class="controls bullet"><span class="by">sesm</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985004">parent</a><span>|</span><a href="#37993635">prev</a><span>|</span><a href="#37988778">next</a><span>|</span><label class="collapse" for="c-37985746">[-]</label><label class="expand" for="c-37985746">[3 more]</label></div><br/><div class="children"><div class="content">Also, some interpretations of Quantum Mechanics, like Dioshi-Penrose objective collapse interpretation, imply a physical limit on the number of qubits.<p>However, whether you should worry about post-quantum crypto or not is a risk assessment question, not a physical one.</div><br/><div id="37990187" class="c"><input type="checkbox" id="c-37990187" checked=""/><div class="controls bullet"><span class="by">notfed</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37985746">parent</a><span>|</span><a href="#37988778">next</a><span>|</span><label class="collapse" for="c-37990187">[-]</label><label class="expand" for="c-37990187">[2 more]</label></div><br/><div class="children"><div class="content">Do any interpretations <i>not</i> have such a limit?</div><br/><div id="37990478" class="c"><input type="checkbox" id="c-37990478" checked=""/><div class="controls bullet"><span class="by">mthiim</span><span>|</span><a href="#37984957">root</a><span>|</span><a href="#37990187">parent</a><span>|</span><a href="#37988778">next</a><span>|</span><label class="collapse" for="c-37990478">[-]</label><label class="expand" for="c-37990478">[1 more]</label></div><br/><div class="children"><div class="content">Many-worlds etc. does not have such a limit. There are interpretations that posit that collapse is triggered by the system reaching a certain size (also GRW theory etc.). Such interpretations would preclude big quantum computers. Note that such interpretations aren&#x27;t purely interpretations because they actually do posit measurable new physical phenomena. But since the relevant experiments are not currently possible to carry out and since they do have significant interpretational consequences, they are often called intepretations.</div><br/></div></div></div></div></div></div></div></div><div id="37988778" class="c"><input type="checkbox" id="c-37988778" checked=""/><div class="controls bullet"><span class="by">HillRat</span><span>|</span><a href="#37984957">parent</a><span>|</span><a href="#37985004">prev</a><span>|</span><a href="#37988463">next</a><span>|</span><label class="collapse" for="c-37988778">[-]</label><label class="expand" for="c-37988778">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the current generally-but-not-universally-accepted standard is &quot;hybrid encryption&quot; (not the same &quot;hybrid&quot; as KEM&#x2F;DEM, though you&#x27;d generally use hybrid encryption with a hybrid KEM&#x2F;DEM cryptosystem), which ensures that you&#x27;d have to break both classical and post-quantum algorithms to get at your plaintext. Whether you simply wrap encryptions or use a hybrid KEM combiner (see, e.g., Campagna and Petcher for examples) is a more subtle question better suited for more subtle minds than mine.</div><br/></div></div><div id="37988463" class="c"><input type="checkbox" id="c-37988463" checked=""/><div class="controls bullet"><span class="by">colmmacc</span><span>|</span><a href="#37984957">parent</a><span>|</span><a href="#37988778">prev</a><span>|</span><a href="#37985813">next</a><span>|</span><label class="collapse" for="c-37988463">[-]</label><label class="expand" for="c-37988463">[1 more]</label></div><br/><div class="children"><div class="content">If quantum computers become more practical in our lifetimes, we don&#x27;t want our current secrets vulnerable to that analysis. Scaling a quantum computer definitely isn&#x27;t as simple as the evolution from valves and transistors was to integrated circuits ... but estimates from experts on the difficulty vary from &quot;this is very very very difficult&quot; to &quot;this will remain physically impossible&quot;. Either way that&#x27;s still more likely than brute-forcing an encryption key with modern standards; so there&#x27;s a rationale for prioritizing post-Quantum security today.<p>That said, you are right to be wary; if there is a side-channel or implementation vulnerability in a PQ algorithm ... then you are much worse off using it. Worst-case; imagine an RCE in the PQ implementation. So it&#x27;s a good idea to be cautious and check the code rigorously.</div><br/></div></div><div id="37985813" class="c"><input type="checkbox" id="c-37985813" checked=""/><div class="controls bullet"><span class="by">johncolanduoni</span><span>|</span><a href="#37984957">parent</a><span>|</span><a href="#37988463">prev</a><span>|</span><a href="#37986899">next</a><span>|</span><label class="collapse" for="c-37985813">[-]</label><label class="expand" for="c-37985813">[1 more]</label></div><br/><div class="children"><div class="content">Thereâs no real risk to schemes that use both post-quantum and conventional crypto in such a way that a break in either is insufficient to bring down the combination. For key exchanges thatâs quite easy; you can just XOR or concatenate the outputs depending on the scheme.</div><br/></div></div><div id="37986899" class="c"><input type="checkbox" id="c-37986899" checked=""/><div class="controls bullet"><span class="by">dwheeler</span><span>|</span><a href="#37984957">parent</a><span>|</span><a href="#37985813">prev</a><span>|</span><a href="#37985271">next</a><span>|</span><label class="collapse" for="c-37986899">[-]</label><label class="expand" for="c-37986899">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I think so. More widespread algorithms have been far more thoroughly studied; they&#x27;ve been studied for longer and stood the test of time. Their weaknesses, and how to counter them, are better understood. They&#x27;re busted by general-purpose large scale quantum computers, though, if those ever happen. Combining their strengths sounds like the best approach where data is very sensitive and the overhead is acceptable.</div><br/></div></div></div></div><div id="37987510" class="c"><input type="checkbox" id="c-37987510" checked=""/><div class="controls bullet"><span class="by">slim</span><span>|</span><a href="#37984957">prev</a><span>|</span><a href="#37993496">next</a><span>|</span><label class="collapse" for="c-37987510">[-]</label><label class="expand" for="c-37987510">[3 more]</label></div><br/><div class="children"><div class="content">A few days ago Daniel Bernstein warned about effort by NSA to spread flawed implementations of post quantum crypto (can&#x27;t find the link)</div><br/><div id="37989238" class="c"><input type="checkbox" id="c-37989238" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#37987510">parent</a><span>|</span><a href="#37993496">next</a><span>|</span><label class="collapse" for="c-37989238">[-]</label><label class="expand" for="c-37989238">[2 more]</label></div><br/><div class="children"><div class="content">Here is the article you mentioned, although it addresses Kyber, not Dilithium.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37756656">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37756656</a></div><br/><div id="37993842" class="c"><input type="checkbox" id="c-37993842" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#37987510">root</a><span>|</span><a href="#37989238">parent</a><span>|</span><a href="#37993496">next</a><span>|</span><label class="collapse" for="c-37993842">[-]</label><label class="expand" for="c-37993842">[1 more]</label></div><br/><div class="children"><div class="content">There have been two posts by djb in the month of October on this topic. I&#x27;m not sure which slim was talking about but the newest one was published today:<p><a href="https:&#x2F;&#x2F;blog.cr.yp.to&#x2F;20231023-clumping.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.cr.yp.to&#x2F;20231023-clumping.html</a><p>I believe there is an HN submission on it already.</div><br/></div></div></div></div></div></div><div id="37993496" class="c"><input type="checkbox" id="c-37993496" checked=""/><div class="controls bullet"><span class="by">victor106</span><span>|</span><a href="#37987510">prev</a><span>|</span><a href="#37993269">next</a><span>|</span><label class="collapse" for="c-37993496">[-]</label><label class="expand" for="c-37993496">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  The cryptographic algorithms RSA and ECC have long been known to be vulnerable to attacks using quantum computers via Shor&#x27;s algorithm.<p>If this is true and quantum computers of that size do come into existence how does it impact Bitcoin?</div><br/><div id="37993617" class="c"><input type="checkbox" id="c-37993617" checked=""/><div class="controls bullet"><span class="by">Salgat</span><span>|</span><a href="#37993496">parent</a><span>|</span><a href="#37993269">next</a><span>|</span><label class="collapse" for="c-37993617">[-]</label><label class="expand" for="c-37993617">[1 more]</label></div><br/><div class="children"><div class="content">They would get migrated before it became an issue. And even if it happened, they&#x27;d just fork it with a quantum resistant encryption at the point of first known attack.</div><br/></div></div></div></div><div id="37993269" class="c"><input type="checkbox" id="c-37993269" checked=""/><div class="controls bullet"><span class="by">ianopolous</span><span>|</span><a href="#37993496">prev</a><span>|</span><a href="#37984495">next</a><span>|</span><label class="collapse" for="c-37993269">[-]</label><label class="expand" for="c-37993269">[1 more]</label></div><br/><div class="children"><div class="content">I wrote&#x2F;ported a single file Java implementation of another of the post quantum signature schemes - sphincs+ here:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Peergos&#x2F;sphincsplus">https:&#x2F;&#x2F;github.com&#x2F;Peergos&#x2F;sphincsplus</a></div><br/></div></div><div id="37984495" class="c"><input type="checkbox" id="c-37984495" checked=""/><div class="controls bullet"><span class="by">mooreds</span><span>|</span><a href="#37993269">prev</a><span>|</span><a href="#37989170">next</a><span>|</span><label class="collapse" for="c-37984495">[-]</label><label class="expand" for="c-37984495">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This is a &quot;for fun&quot; implementation written in a couple of days. It&#x27;s not intended to be production-grade code. No warranty or support of any kind is provided. However, it can be useful for diving into and experimenting with post-quantum algorithms. Use it at your own risk. If you don&#x27;t like those terms, you must refrain from using this software.</div><br/></div></div><div id="37989170" class="c"><input type="checkbox" id="c-37989170" checked=""/><div class="controls bullet"><span class="by">andai</span><span>|</span><a href="#37984495">prev</a><span>|</span><a href="#37984943">next</a><span>|</span><label class="collapse" for="c-37989170">[-]</label><label class="expand" for="c-37989170">[2 more]</label></div><br/><div class="children"><div class="content">Thought it was gonna be OTP ;)</div><br/></div></div></div></div></div></div></div></body></html>