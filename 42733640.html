<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737104455656" as="style"/><link rel="stylesheet" href="styles.css?v=1737104455656"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://oddlama.org/blog/bypassing-disk-encryption-with-tpm2-unlock/">Bypassing disk encryption on systems with automatic TPM2 unlock</a> <span class="domain">(<a href="https://oddlama.org">oddlama.org</a>)</span></div><div class="subtext"><span>arjvik</span> | <span>39 comments</span></div><br/><div><div id="42734364" class="c"><input type="checkbox" id="c-42734364" checked=""/><div class="controls bullet"><span class="by">ARob109</span><span>|</span><a href="#42734957">next</a><span>|</span><label class="collapse" for="c-42734364">[-]</label><label class="expand" for="c-42734364">[3 more]</label></div><br/><div class="children"><div class="content">Seems like this could be easily mitigated with a read only root filesystem using dm verity<p>Store the root hash of the dm verity formatted rootfs in the PCR. If a malicious partition is presented to initrd, its root hash will not match the trusted one stored in the TPM.<p>Or if you need a writeable rootfs, use fs verity and store the signature of init into the PCR. The trusted init signature won’t match signature of malicious init.<p>LUKS for encryption and verity for integrity&#x2F;verification.</div><br/><div id="42734409" class="c"><input type="checkbox" id="c-42734409" checked=""/><div class="controls bullet"><span class="by">yx827ha</span><span>|</span><a href="#42734364">parent</a><span>|</span><a href="#42734957">next</a><span>|</span><label class="collapse" for="c-42734409">[-]</label><label class="expand" for="c-42734409">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s how ChromeOS does it. <a href="https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=iO6cb90WiQ4" rel="nofollow">https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=iO6cb90WiQ4</a></div><br/><div id="42734493" class="c"><input type="checkbox" id="c-42734493" checked=""/><div class="controls bullet"><span class="by">ARob109</span><span>|</span><a href="#42734364">root</a><span>|</span><a href="#42734409">parent</a><span>|</span><a href="#42734957">next</a><span>|</span><label class="collapse" for="c-42734493">[-]</label><label class="expand" for="c-42734493">[1 more]</label></div><br/><div class="children"><div class="content">Android too in a way via Android Verified Boot. I think ChromeOS uses AVB as well.<p>Android Verified Boot extends the System on chip Hardware based secure boot to the kernel and rootfs.
Root of trust is fused into the SoC, and second stage bootloaders are signed. Second stage boot loader eg uboot,UEFI&#x2F;edk2 contains a public key that is used to verify a signed AVB partition. This signed partition contains signed rootfs dm verity metadata and signed hash of the kernel(+initrd). AVB validates kernel hash with expected hash and loads kernel if good. It provides the trusted rootfs verity hash to kernel via cmdline. Then when kernel reads rootfs, the dmverity system will calculate hash and check if matches the expected one. If not, the system reboots and the AVB metadata is flagged to indicate tampering&#x2F;failure of the rootfs.<p>edit to add:
If the SoC supports hardware based full disk encryption, the filesystem can be encrypted as well, with the key being stored in Androids secure key store. Android though has moved away from FDE in favor of file based encryption.</div><br/></div></div></div></div></div></div><div id="42734957" class="c"><input type="checkbox" id="c-42734957" checked=""/><div class="controls bullet"><span class="by">tommiegannert</span><span>|</span><a href="#42734364">prev</a><span>|</span><a href="#42733994">next</a><span>|</span><label class="collapse" for="c-42734957">[-]</label><label class="expand" for="c-42734957">[1 more]</label></div><br/><div class="children"><div class="content">Very nice exploit.<p>So if you use this PCR state machine, the problem is that the step before initrd doesn&#x27;t require the correct password to move the PCR forward? It accepts any password that decrypts the next stage, which didn&#x27;t have its integrity verified here.<p>Seems there are multiple ways of solving this, and adding integrity checks is only one. It could also let the TPM verify the disk decryption password (when it&#x27;s needed.)</div><br/></div></div><div id="42733994" class="c"><input type="checkbox" id="c-42733994" checked=""/><div class="controls bullet"><span class="by">acheong08</span><span>|</span><a href="#42734957">prev</a><span>|</span><a href="#42734325">next</a><span>|</span><label class="collapse" for="c-42733994">[-]</label><label class="expand" for="c-42733994">[25 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand why anyone would use passwordless disk encryption. It just seems inherently vulnerable, especially with the threat model of physical compromise.<p>Entering a password on boot isn&#x27;t even that much work</div><br/><div id="42735445" class="c"><input type="checkbox" id="c-42735445" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#42733994">parent</a><span>|</span><a href="#42734132">next</a><span>|</span><label class="collapse" for="c-42735445">[-]</label><label class="expand" for="c-42735445">[1 more]</label></div><br/><div class="children"><div class="content">Some systems need to boot without a (trusted or skilled) user present.</div><br/></div></div><div id="42734132" class="c"><input type="checkbox" id="c-42734132" checked=""/><div class="controls bullet"><span class="by">Hakkin</span><span>|</span><a href="#42733994">parent</a><span>|</span><a href="#42735445">prev</a><span>|</span><a href="#42734304">next</a><span>|</span><label class="collapse" for="c-42734132">[-]</label><label class="expand" for="c-42734132">[2 more]</label></div><br/><div class="children"><div class="content">If a disk is encrypted, you don&#x27;t have to worry about the contents if you eventually have to RMA or dispose of the disk. For this use case, it makes no difference how the encryption key is input.</div><br/><div id="42734927" class="c"><input type="checkbox" id="c-42734927" checked=""/><div class="controls bullet"><span class="by">tommiegannert</span><span>|</span><a href="#42733994">root</a><span>|</span><a href="#42734132">parent</a><span>|</span><a href="#42734304">next</a><span>|</span><label class="collapse" for="c-42734927">[-]</label><label class="expand" for="c-42734927">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d guess the most common scenario is for someone giving away the entire computer, not fiddle with components. Or theft of the full machine.<p>This feels like one of those half-security measures that makes it feel like you&#x27;re safe, but it&#x27;s mostly marketing, making you believe *this* device can be both safe and easy to use.</div><br/></div></div></div></div><div id="42734304" class="c"><input type="checkbox" id="c-42734304" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#42733994">parent</a><span>|</span><a href="#42734132">prev</a><span>|</span><a href="#42734171">next</a><span>|</span><label class="collapse" for="c-42734304">[-]</label><label class="expand" for="c-42734304">[2 more]</label></div><br/><div class="children"><div class="content">Because I don&#x27;t expect a random thief to go to the lengths of identifying OS level vulnerabilities to bypass the login prompt in order to decrypt the disk contents. The potential gains for them are marginal compared to the time and effort spent there, not to mention technical expertise needed. I expect them to steal it, and if it&#x27;s encrypted, just sell it for parts, or wipe it and sell it anew.<p>Entering a password can be a lot of work if you use a strong password (and if you don&#x27;t, why bother with a password?). Typos can take a toll too because of all the delays included.</div><br/><div id="42734854" class="c"><input type="checkbox" id="c-42734854" checked=""/><div class="controls bullet"><span class="by">_blk</span><span>|</span><a href="#42733994">root</a><span>|</span><a href="#42734304">parent</a><span>|</span><a href="#42734171">next</a><span>|</span><label class="collapse" for="c-42734854">[-]</label><label class="expand" for="c-42734854">[1 more]</label></div><br/><div class="children"><div class="content">A weak password is always better than no password. It&#x27;s like using a cheap lock on your door or not locking it. Practically, if a thief wants to get through he&#x27;ll get through but your insurance and sentencing will look different.</div><br/></div></div></div></div><div id="42734171" class="c"><input type="checkbox" id="c-42734171" checked=""/><div class="controls bullet"><span class="by">dangero</span><span>|</span><a href="#42733994">parent</a><span>|</span><a href="#42734304">prev</a><span>|</span><a href="#42734925">next</a><span>|</span><label class="collapse" for="c-42734171">[-]</label><label class="expand" for="c-42734171">[1 more]</label></div><br/><div class="children"><div class="content">Depends on the use case. If boot requires a password, the computer can never lose power or be rebooted without human presence. That’s not always practical.</div><br/></div></div><div id="42734925" class="c"><input type="checkbox" id="c-42734925" checked=""/><div class="controls bullet"><span class="by">logifail</span><span>|</span><a href="#42733994">parent</a><span>|</span><a href="#42734171">prev</a><span>|</span><a href="#42734012">next</a><span>|</span><label class="collapse" for="c-42734925">[-]</label><label class="expand" for="c-42734925">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t understand why anyone would use passwordless disk encryption<p>You want to install and operate a device at a remote site with restricted (or no) VPN access and where you don&#x27;t trust the local staff?</div><br/><div id="42735194" class="c"><input type="checkbox" id="c-42735194" checked=""/><div class="controls bullet"><span class="by">artiscode</span><span>|</span><a href="#42733994">root</a><span>|</span><a href="#42734925">parent</a><span>|</span><a href="#42734012">next</a><span>|</span><label class="collapse" for="c-42735194">[-]</label><label class="expand" for="c-42735194">[2 more]</label></div><br/><div class="children"><div class="content">A remote KVM, i.e TinyPilot will help avoid dealing with lack of trust in local staff. Additionally connection to the KVM can be done over LTE&#x2F;Cellular if you don&#x27;t trust the local connection too.</div><br/><div id="42735321" class="c"><input type="checkbox" id="c-42735321" checked=""/><div class="controls bullet"><span class="by">logifail</span><span>|</span><a href="#42733994">root</a><span>|</span><a href="#42735194">parent</a><span>|</span><a href="#42734012">next</a><span>|</span><label class="collapse" for="c-42735321">[-]</label><label class="expand" for="c-42735321">[1 more]</label></div><br/><div class="children"><div class="content">I set up a server last year which is at a remote site whic is completely air-gapped from the Internet, it&#x27;s allowed to see one local LAN and that&#x27;s all.  For any kind of admin task someone has to drive to site.<p>There is precisely zero chance that the relevant IT security goons would allow any kind of remote KVM&#x2F;LTE connection.</div><br/></div></div></div></div></div></div><div id="42734012" class="c"><input type="checkbox" id="c-42734012" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#42733994">parent</a><span>|</span><a href="#42734925">prev</a><span>|</span><a href="#42734073">next</a><span>|</span><label class="collapse" for="c-42734012">[-]</label><label class="expand" for="c-42734012">[1 more]</label></div><br/><div class="children"><div class="content">On servers, it protects against someone stealing your disks (or stealing the raw bytes from your disks) and then booting them in a copy of your machine.</div><br/></div></div><div id="42734073" class="c"><input type="checkbox" id="c-42734073" checked=""/><div class="controls bullet"><span class="by">mcny</span><span>|</span><a href="#42733994">parent</a><span>|</span><a href="#42734012">prev</a><span>|</span><a href="#42734734">next</a><span>|</span><label class="collapse" for="c-42734073">[-]</label><label class="expand" for="c-42734073">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Entering a password on boot isn&#x27;t even that much work<p>It is on fedora. I wabt the latest packages and I want to install them with dnf offline upgrade but now I need to put in password twice once for the updates d again for next boot. If it is a server, I don&#x27;t want to keep a monitor attached to it just to enter the password. I want the computer to just boot.<p>There has to be a better way.</div><br/><div id="42734307" class="c"><input type="checkbox" id="c-42734307" checked=""/><div class="controls bullet"><span class="by">keeperofdakeys</span><span>|</span><a href="#42733994">root</a><span>|</span><a href="#42734073">parent</a><span>|</span><a href="#42734871">next</a><span>|</span><label class="collapse" for="c-42734307">[-]</label><label class="expand" for="c-42734307">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There has to be a better way.<p>Probably Clevis and Tang, network disk decryption that can only decrypt if most of your servers are online.  <a href="https:&#x2F;&#x2F;github.com&#x2F;latchset&#x2F;clevis">https:&#x2F;&#x2F;github.com&#x2F;latchset&#x2F;clevis</a> <a href="https:&#x2F;&#x2F;github.com&#x2F;latchset&#x2F;tang">https:&#x2F;&#x2F;github.com&#x2F;latchset&#x2F;tang</a><p>Or network decryption (SSH into initrd). <a href="https:&#x2F;&#x2F;github.com&#x2F;gsauthof&#x2F;dracut-sshd">https:&#x2F;&#x2F;github.com&#x2F;gsauthof&#x2F;dracut-sshd</a></div><br/></div></div><div id="42734871" class="c"><input type="checkbox" id="c-42734871" checked=""/><div class="controls bullet"><span class="by">webstrand</span><span>|</span><a href="#42733994">root</a><span>|</span><a href="#42734073">parent</a><span>|</span><a href="#42734307">prev</a><span>|</span><a href="#42734160">next</a><span>|</span><label class="collapse" for="c-42734871">[-]</label><label class="expand" for="c-42734871">[1 more]</label></div><br/><div class="children"><div class="content">There is, I use kexec to boot a modified cpio containing the fde password, since cpio can be extended by concatenation. <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;webstrand&#x2F;381307348e24c28d5c4c9a5981871bd7" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;webstrand&#x2F;381307348e24c28d5c4c9a5981...</a><p>It&#x27;s the same technique grub uses to forward the FDE password to the initramfs after its own initial decryption (to read the kernel and initramfs). This works to reboot remote servers with FDE, without needing a vnc or earlyboot-sshd.</div><br/></div></div><div id="42734160" class="c"><input type="checkbox" id="c-42734160" checked=""/><div class="controls bullet"><span class="by">bpye</span><span>|</span><a href="#42733994">root</a><span>|</span><a href="#42734073">parent</a><span>|</span><a href="#42734871">prev</a><span>|</span><a href="#42734850">next</a><span>|</span><label class="collapse" for="c-42734160">[-]</label><label class="expand" for="c-42734160">[1 more]</label></div><br/><div class="children"><div class="content">Is the boot time password unlock occurring in GRUB or after the Linux kernel has started? If the latter you should be able to setup an SSH server to run in that early boot environment, that’s how I can remote unlock drives on NixOS.</div><br/></div></div><div id="42734850" class="c"><input type="checkbox" id="c-42734850" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#42733994">root</a><span>|</span><a href="#42734073">parent</a><span>|</span><a href="#42734160">prev</a><span>|</span><a href="#42734734">next</a><span>|</span><label class="collapse" for="c-42734850">[-]</label><label class="expand" for="c-42734850">[1 more]</label></div><br/><div class="children"><div class="content">There is: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42734841">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42734841</a>.</div><br/></div></div></div></div><div id="42734734" class="c"><input type="checkbox" id="c-42734734" checked=""/><div class="controls bullet"><span class="by">coppsilgold</span><span>|</span><a href="#42733994">parent</a><span>|</span><a href="#42734073">prev</a><span>|</span><a href="#42734841">next</a><span>|</span><label class="collapse" for="c-42734734">[-]</label><label class="expand" for="c-42734734">[1 more]</label></div><br/><div class="children"><div class="content">Passwordless TPM FDE effectively &quot;pairs&quot; your HDD(s) with the TPM module such that the data on the drive(s) is inaccessible without it or a strong LUKS password if added.<p>Using even a weak pin&#x2F;password will allow you to both &quot;pair&quot; and &quot;secure&quot; assuming the TPM is configured to destroy the key on multiple failed attempts.<p>You should also add a strong (high entropy) LUKS password to allow data recovery in case the TPM chip is lost or the keys are destroyed.<p>Note that the bits of the encryption keys are present somewhere in the TPM and could in theory be extracted with an exploit or with scanning probe microscopy perhaps.</div><br/></div></div><div id="42734841" class="c"><input type="checkbox" id="c-42734841" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#42733994">parent</a><span>|</span><a href="#42734734">prev</a><span>|</span><a href="#42734516">next</a><span>|</span><label class="collapse" for="c-42734841">[-]</label><label class="expand" for="c-42734841">[1 more]</label></div><br/><div class="children"><div class="content">You do not even need to enter a password.<p>Use a randomly generated key. Retrieve it from an USB drive at boot (it does it automagically), which contains everything, giving you full plausible deniability without it. It means literally everything you need to boot up is on the USB drive, and if you so want it, you can use 2 separate USB drives.<p>This is for computers you have physical access to, of course. You will need to carry the USB disk if it is a laptop, but you choose: you want to enter a password (which by itself gives you no plausible deniability BTW), or you want plausible deniability and&#x2F;or you don&#x27;t want to enter a password. And while we are at it, laptops (and even desktops) today have SSD, and encryption and plausible deniability is different for an SSD, but again, you choose. Right tool for the job.<p><a href="https:&#x2F;&#x2F;wiki.archlinux.org&#x2F;title&#x2F;Dm-crypt&#x2F;Encrypting_an_entire_system#Plain_dm-crypt" rel="nofollow">https:&#x2F;&#x2F;wiki.archlinux.org&#x2F;title&#x2F;Dm-crypt&#x2F;Encrypting_an_enti...</a></div><br/></div></div><div id="42734516" class="c"><input type="checkbox" id="c-42734516" checked=""/><div class="controls bullet"><span class="by">udev4096</span><span>|</span><a href="#42733994">parent</a><span>|</span><a href="#42734841">prev</a><span>|</span><a href="#42734892">next</a><span>|</span><label class="collapse" for="c-42734516">[-]</label><label class="expand" for="c-42734516">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s just not practical. How are you going to manually enter the password for let&#x27;s say 10 servers?</div><br/><div id="42734848" class="c"><input type="checkbox" id="c-42734848" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#42733994">root</a><span>|</span><a href="#42734516">parent</a><span>|</span><a href="#42734892">next</a><span>|</span><label class="collapse" for="c-42734848">[-]</label><label class="expand" for="c-42734848">[2 more]</label></div><br/><div class="children"><div class="content">USB pendrive with random key, no need to enter anything and is more secure and gives you plausible deniability through many different means.</div><br/><div id="42735351" class="c"><input type="checkbox" id="c-42735351" checked=""/><div class="controls bullet"><span class="by">cedilla</span><span>|</span><a href="#42733994">root</a><span>|</span><a href="#42734848">parent</a><span>|</span><a href="#42734892">next</a><span>|</span><label class="collapse" for="c-42735351">[-]</label><label class="expand" for="c-42735351">[1 more]</label></div><br/><div class="children"><div class="content">Going around 10 servers with a USB drive sounds just as tedious, and what happens when you lose the key or the attacker gets it?</div><br/></div></div></div></div></div></div><div id="42734892" class="c"><input type="checkbox" id="c-42734892" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#42733994">parent</a><span>|</span><a href="#42734516">prev</a><span>|</span><a href="#42734370">next</a><span>|</span><label class="collapse" for="c-42734892">[-]</label><label class="expand" for="c-42734892">[1 more]</label></div><br/><div class="children"><div class="content">Try having a chat with a HCI person. Or in a pinch ask a LLM to emulate one for you. It&#x27;s a useful perspective to have for a lot of stuff.</div><br/></div></div><div id="42734370" class="c"><input type="checkbox" id="c-42734370" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42733994">parent</a><span>|</span><a href="#42734892">prev</a><span>|</span><a href="#42734397">next</a><span>|</span><label class="collapse" for="c-42734370">[-]</label><label class="expand" for="c-42734370">[1 more]</label></div><br/><div class="children"><div class="content">Between consciously encrypting with a user-supplied password, and not encrypting at all, automatic encryption seems more like a nuisance&#x2F;hazard for recovery than anything else.<p>Consciously encrypting with a password implies an understanding of the risk of permanent loss. Leaving it unencrypted implies an understanding of the risk of disclosure. Having your drive silently encrypted feels like the worst of both worlds. &quot;I never encrypted or locked it, what do you mean my data is encrypted and gone forever!?&quot;</div><br/></div></div><div id="42734397" class="c"><input type="checkbox" id="c-42734397" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#42733994">parent</a><span>|</span><a href="#42734370">prev</a><span>|</span><a href="#42734375">next</a><span>|</span><label class="collapse" for="c-42734397">[-]</label><label class="expand" for="c-42734397">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t understand why anyone would use passwordless disk encryption.<p>I&#x27;m using it on my home server that I&#x27;m using for self-hosting. This way, if it&#x27;s stolen, the thief won&#x27;t be able to easily get to my data. At the same time, I don&#x27;t have to physically enter the password if my server reboots.</div><br/></div></div></div></div><div id="42734325" class="c"><input type="checkbox" id="c-42734325" checked=""/><div class="controls bullet"><span class="by">keeperofdakeys</span><span>|</span><a href="#42733994">prev</a><span>|</span><a href="#42734355">next</a><span>|</span><label class="collapse" for="c-42734325">[-]</label><label class="expand" for="c-42734325">[6 more]</label></div><br/><div class="children"><div class="content">You can mitigate this by including PCRs that sign the kernel and initrd, however it means whenever you update you need to unlock manually. On Redhat-based distros this can be done with PCRs 8 and 9, though IIRC this may change on other distros.<p>Also AFAIK there is no standard way to guess the new PCRs on reboot so you can&#x27;t pre-update them before rebooting. So you either need to unlock manually or use a network decryption like dracut-sshd.</div><br/><div id="42735303" class="c"><input type="checkbox" id="c-42735303" checked=""/><div class="controls bullet"><span class="by">Vogtinator</span><span>|</span><a href="#42734325">parent</a><span>|</span><a href="#42735137">next</a><span>|</span><label class="collapse" for="c-42735303">[-]</label><label class="expand" for="c-42735303">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can mitigate this by including PCRs that sign the kernel and initrd.<p>No, that&#x27;s not an effective mitigation. The signed kernel+initrd would still boot into the impersonated root.<p>&gt; however it means whenever you update you need to unlock manually. On Redhat-based distros this can be done with PCRs 8 and 9, though IIRC this may change on other distros.
&gt; Also AFAIK there is no standard way to guess the new PCRs on reboot so you can&#x27;t pre-update them before rebooting. So you either need to unlock manually or use a network decryption like dracut-sshd.<p>With some logic to update the values on kernel updates and re-seal the secret this can be handled transparently. That&#x27;s the design with sdbootutil in openSUSE (<a href="https:&#x2F;&#x2F;en.opensuse.org&#x2F;Systemd-fde" rel="nofollow">https:&#x2F;&#x2F;en.opensuse.org&#x2F;Systemd-fde</a>, <a href="https:&#x2F;&#x2F;github.com&#x2F;openSUSE&#x2F;sdbootutil">https:&#x2F;&#x2F;github.com&#x2F;openSUSE&#x2F;sdbootutil</a>).</div><br/></div></div><div id="42735137" class="c"><input type="checkbox" id="c-42735137" checked=""/><div class="controls bullet"><span class="by">jansommer</span><span>|</span><a href="#42734325">parent</a><span>|</span><a href="#42735303">prev</a><span>|</span><a href="#42735230">next</a><span>|</span><label class="collapse" for="c-42735137">[-]</label><label class="expand" for="c-42735137">[1 more]</label></div><br/><div class="children"><div class="content">You can use tpm2_policyauthorize and allow the PCR to change without having to manually unlock. This was not supported in TPM 1.2.<p>You can use it with Systemd.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;tpm2-software&#x2F;tpm2-tools&#x2F;blob&#x2F;master&#x2F;man&#x2F;tpm2_policyauthorize.1.md">https:&#x2F;&#x2F;github.com&#x2F;tpm2-software&#x2F;tpm2-tools&#x2F;blob&#x2F;master&#x2F;man&#x2F;...</a></div><br/></div></div><div id="42735230" class="c"><input type="checkbox" id="c-42735230" checked=""/><div class="controls bullet"><span class="by">saljam</span><span>|</span><a href="#42734325">parent</a><span>|</span><a href="#42735137">prev</a><span>|</span><a href="#42734894">next</a><span>|</span><label class="collapse" for="c-42735230">[-]</label><label class="expand" for="c-42735230">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can mitigate this by including PCRs that sign the kernel and initrd<p>nope! the trick the article is describing works even if the kernel and initrd is measured. it uses the same kernel, initrd, and command line.<p>the reason this trick works is that initrds usually fall back to password unlock if the key from the tpm doesn&#x27;t work. so the hack replaces the encrypted volume, not the kernel, with a compromised one. that is:<p>1. (temporarily) replace encrypted volume with our own, encrypted with a known password.<p>2. boot the device.<p>3. the automated tpm unlock fails, prompting for a password.<p>4. type in our password. now we&#x27;re in, using the original kernel and initrd, but it&#x27;s our special filesystem, not the one we&#x27;re trying to decrypt.<p>5. ask the tpm again for the key. since we&#x27;re still using the original kernel, initrd, and command line, we should now get the key to unlock the original encrypted volume.<p>the way to fix this is to somehow also measure encrypted volume itself. the article points to suggestions of deriving a value from the encryption key.</div><br/></div></div><div id="42734894" class="c"><input type="checkbox" id="c-42734894" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#42734325">parent</a><span>|</span><a href="#42735230">prev</a><span>|</span><a href="#42734355">next</a><span>|</span><label class="collapse" for="c-42734894">[-]</label><label class="expand" for="c-42734894">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s ridiculous that there&#x27;s no software implementation to do this, it&#x27;s a huge problem.<p>Auto update should be able to include the kernel, initrd and grub cmdline from the running system I have no idea what&#x27;s holding this back since evidently code already exists somewhere to do exactly that.</div><br/><div id="42735307" class="c"><input type="checkbox" id="c-42735307" checked=""/><div class="controls bullet"><span class="by">Vogtinator</span><span>|</span><a href="#42734325">root</a><span>|</span><a href="#42734894">parent</a><span>|</span><a href="#42734355">next</a><span>|</span><label class="collapse" for="c-42735307">[-]</label><label class="expand" for="c-42735307">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the design with sdbootutil in openSUSE (<a href="https:&#x2F;&#x2F;en.opensuse.org&#x2F;Systemd-fde" rel="nofollow">https:&#x2F;&#x2F;en.opensuse.org&#x2F;Systemd-fde</a>, <a href="https:&#x2F;&#x2F;github.com&#x2F;openSUSE&#x2F;sdbootutil">https:&#x2F;&#x2F;github.com&#x2F;openSUSE&#x2F;sdbootutil</a>).</div><br/></div></div></div></div></div></div><div id="42734355" class="c"><input type="checkbox" id="c-42734355" checked=""/><div class="controls bullet"><span class="by">staff3203</span><span>|</span><a href="#42734325">prev</a><span>|</span><a href="#42734345">next</a><span>|</span><label class="collapse" for="c-42734355">[-]</label><label class="expand" for="c-42734355">[1 more]</label></div><br/><div class="children"><div class="content">On my system, I used `tpm2-measure-pcr=yes` in `&#x2F;etc&#x2F;crypttab.initramfs`, then used `--tpm2-pcrs=0+2+7+15:sha256=0000000000000000000000000000000000000000000000000000000000000000` with `systemd-cryptenroll`.<p>As soon as a volume is decrypted, initrd will write `volume-key` to PCR 15, so any further executables can no longer access the data stored in the TPM.</div><br/></div></div><div id="42734345" class="c"><input type="checkbox" id="c-42734345" checked=""/><div class="controls bullet"><span class="by">huslage</span><span>|</span><a href="#42734355">prev</a><span>|</span><label class="collapse" for="c-42734345">[-]</label><label class="expand" for="c-42734345">[2 more]</label></div><br/><div class="children"><div class="content">The other option is to have an intrusion prevention switch or two in the case so the TPM locks itself in some way and the machine refuses to boot at all without some PKI attestation.</div><br/><div id="42734554" class="c"><input type="checkbox" id="c-42734554" checked=""/><div class="controls bullet"><span class="by">nicman23</span><span>|</span><a href="#42734345">parent</a><span>|</span><label class="collapse" for="c-42734554">[-]</label><label class="expand" for="c-42734554">[1 more]</label></div><br/><div class="children"><div class="content">depends on the threat model. a rot saw will hack it :P</div><br/></div></div></div></div></div></div></div></div></div></body></html>