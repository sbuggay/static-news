<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734771666194" as="style"/><link rel="stylesheet" href="styles.css?v=1734771666194"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.os2museum.com/wp/dos-append/">DOS APPEND</a> <span class="domain">(<a href="https://www.os2museum.com">www.os2museum.com</a>)</span></div><div class="subtext"><span>SeenNotHeard</span> | <span>48 comments</span></div><br/><div><div id="42476156" class="c"><input type="checkbox" id="c-42476156" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#42476739">next</a><span>|</span><label class="collapse" for="c-42476156">[-]</label><label class="expand" for="c-42476156">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>APPEND is one of the things that are completely irrelevant 99.99% of the time… yet can be extremely useful when the need arises.</i><p>Is it really <i>that</i> irrelevant? I mean, if you look past the specifics (directories, interrupts, DOS versions), this seems to be implementing the idea of <i>bringing something into scope</i>, in particular bringing it into scope from the outside, to modify the behavior of the consumer (here, assembler) without modifying the consumer itself. Today, we&#x27;d do the equivalent with `ln -sr ..&#x2F;..&#x2F;inc ..&#x2F;inc`.<p>I&#x27;d argue the general idea remains very important and useful today, though it&#x27;s definitely not obvious looking back from the future what this was what APPEND was going for.</div><br/><div id="42476586" class="c"><input type="checkbox" id="c-42476586" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#42476156">parent</a><span>|</span><a href="#42476739">next</a><span>|</span><label class="collapse" for="c-42476586">[-]</label><label class="expand" for="c-42476586">[2 more]</label></div><br/><div class="children"><div class="content">Yes, general idea is still very important and useful, but this is post about specific command called &quot;APPEND&quot; in MS-DOS environment. Also, it&#x27;s not an equivalent of &quot;ln -sr&quot; as &quot;ln&quot; replaces targets and not stacks them. The proper modern equivalents are environment variables like LD_LIBRARY_PATH, PYTHONPATH, PKG_CONFIG_PATH, etc... and overlayfs mounts for a generic case.<p>But back to the APPEND: in all my time working with MS-DOS, I don&#x27;t remember ever needing that, so it was 100% irrelevant to me. But this could be because I&#x27;ve worked with more &quot;modern&quot; programs (like Turb Pascal 5) which had good support for directories.</div><br/></div></div></div></div><div id="42476739" class="c"><input type="checkbox" id="c-42476739" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42476156">prev</a><span>|</span><a href="#42477015">next</a><span>|</span><label class="collapse" for="c-42476739">[-]</label><label class="expand" for="c-42476739">[2 more]</label></div><br/><div class="children"><div class="content">Always a joy when os2museum updates.<p>I, too, remember the trifecta of APPEND, JOIN, and SUBST. And while I always thought they were interesting, I was also wondering for most of them when I would ever use that. At the time, DOS versions and hence applications for it that don’t know subdirectories didn’t cross my mind, as my first DOS version was 2.11, I think.</div><br/><div id="42477011" class="c"><input type="checkbox" id="c-42477011" checked=""/><div class="controls bullet"><span class="by">Joe_Cool</span><span>|</span><a href="#42476739">parent</a><span>|</span><a href="#42477015">next</a><span>|</span><label class="collapse" for="c-42477011">[-]</label><label class="expand" for="c-42477011">[1 more]</label></div><br/><div class="children"><div class="content">When I got my fancy 1.6 GB harddisk I used `subst R: .\cd` to run my games needing the CD in the drive from a directory on the harddrive instead. Boy did load times improve a ton.</div><br/></div></div></div></div><div id="42477015" class="c"><input type="checkbox" id="c-42477015" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42476739">prev</a><span>|</span><a href="#42475572">next</a><span>|</span><label class="collapse" for="c-42477015">[-]</label><label class="expand" for="c-42477015">[5 more]</label></div><br/><div class="children"><div class="content">My favorite program in DOS was smartdrv.exe. I know it’s much more late addition, but it was a game-changer for these slow hard drives. Even a tiny cache size (I believe I tried kilobytes range) sped up things like 10-20x.<p>Even windows 3.x and 95 (surpisingly) ran faster with smartdrv preloaded. 95’s default cache for some reason was worse than smartdrv and literally produced harder sounds on my hdds.<p>The second favorite was a TSR NG viewer, can’t remember the name.</div><br/><div id="42477826" class="c"><input type="checkbox" id="c-42477826" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42477015">parent</a><span>|</span><a href="#42477198">next</a><span>|</span><label class="collapse" for="c-42477826">[-]</label><label class="expand" for="c-42477826">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and 95 (surpisingly) ran faster with smartdrv preloaded. 95’s default cache for some reason was worse than smartdrv<p>My (weak) guess is that you &quot;32 bit disk access&quot; and &quot;32 bit file access&quot; wasn&#x27;t active then, i.e. Windows 95 did not use its native 32 bit disk drivers, but 16 bit BIOS access. I have a hard time seeing how Smartdrv could have done anything otherwise, unless it really had some tight integration with 32 bit Windows (which would be very surprising, it&#x27;s a 16 bit TSR first and foremost).<p>But yeah, overall, I agree, it&#x27;s surprising what even a tiny cache does. If you just manage to eliminate the seek times to the root directory for pretty much every single access to a new file, that can probably do a lot already. Especially in the days before &quot;native command queuing&quot;, where the HD would try to reorder disk accesses to find a better (physical!) head seek path across the platter. Later HDs had some cache on board.</div><br/></div></div><div id="42477198" class="c"><input type="checkbox" id="c-42477198" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#42477015">parent</a><span>|</span><a href="#42477826">prev</a><span>|</span><a href="#42475572">next</a><span>|</span><label class="collapse" for="c-42477198">[-]</label><label class="expand" for="c-42477198">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The second favorite was a TSR NG viewer, can’t remember the name.<p>I know what a TSR is, but what&#x27;s an &quot;NG viewer&quot;?</div><br/><div id="42477494" class="c"><input type="checkbox" id="c-42477494" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42477015">root</a><span>|</span><a href="#42477198">parent</a><span>|</span><a href="#42475572">next</a><span>|</span><label class="collapse" for="c-42477494">[-]</label><label class="expand" for="c-42477494">[2 more]</label></div><br/><div class="children"><div class="content">Norton Guides, iirc. E.g. Ralf Brown Interrupt List was available in it. Reading the docs without leaving an editor made programming much easier.</div><br/><div id="42477835" class="c"><input type="checkbox" id="c-42477835" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42477015">root</a><span>|</span><a href="#42477494">parent</a><span>|</span><a href="#42475572">next</a><span>|</span><label class="collapse" for="c-42477835">[-]</label><label class="expand" for="c-42477835">[1 more]</label></div><br/><div class="children"><div class="content">I sometimes wistfully look back to the days where I had a bunch of books and printouts open on my desk for programming. Of course, that&#x27;s more than likely romanticizing things quite a lot...</div><br/></div></div></div></div></div></div></div></div><div id="42475572" class="c"><input type="checkbox" id="c-42475572" checked=""/><div class="controls bullet"><span class="by">SunlitCat</span><span>|</span><a href="#42477015">prev</a><span>|</span><a href="#42475835">next</a><span>|</span><label class="collapse" for="c-42475572">[-]</label><label class="expand" for="c-42475572">[16 more]</label></div><br/><div class="children"><div class="content">Another handy dos command, originating back to DOS is SUBST.<p>Came in pretty handy when I wanted to share a folder with Remote Desktop, but it would only let me select whole drives.<p>Made a SUBST drive letter for that folder, worked like a charm!</div><br/><div id="42475991" class="c"><input type="checkbox" id="c-42475991" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#42475572">parent</a><span>|</span><a href="#42475627">next</a><span>|</span><label class="collapse" for="c-42475991">[-]</label><label class="expand" for="c-42475991">[1 more]</label></div><br/><div class="children"><div class="content">SUBST makes use of NT Object Namespace Symbolic Links to register the drive letter.  After running SUBST, you get an object named &quot;M:&quot; (or whatever your drive letter is&quot;) sitting in the &quot;\??\&quot; directory, its full path will be &quot;\??\M:&quot;.  It will be a symbolic link that points to something like &quot;\??\C:\target_path&quot;.<p>You can either see this by using &quot;NtQuerySymbolicLinkObject&quot; on &quot;\??\M:&quot;, or calling &quot;QueryDosDeviceW&quot; on &quot;M:&quot;.  On Windows NT, you will see the result as an NT-native path &quot;\??\C:\target_path&quot; rather than a Win32-style path &quot;C:\target_path&quot;.<p>&quot;\??\&quot; is not some kind of special notation for paths or anything, it is a real NT object that exists.  It holds your drive letters and other things.<p>On Windows 9x, you won&#x27;t see an NT-native path from QueryDosDevice, you&#x27;ll instead see a Win32-style path &quot;C:\target_path&quot;.<p>Weirdly enough, Sysinternals Winobj is unable to find the symbolic link object at all, despite that it exists when you query it using NT API calls.<p>Fun fact about NT native paths, you can use them in Win32 if you prefix them with &quot;\\?\GLOBALROOT&quot;.  So &quot;\??\C:\&quot; becomes &quot;\\?\GLOBALROOT\??\C:\&quot;.  You can use it in any Win32 program that doesn&#x27;t actively block that kind of path (such as the file explorer&#x2F;open dialog)</div><br/></div></div><div id="42475627" class="c"><input type="checkbox" id="c-42475627" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#42475572">parent</a><span>|</span><a href="#42475991">prev</a><span>|</span><a href="#42475856">next</a><span>|</span><label class="collapse" for="c-42475627">[-]</label><label class="expand" for="c-42475627">[1 more]</label></div><br/><div class="children"><div class="content">IIRC originally SUBST was designed for that - early programs didn&#x27;t understand directories but did understand drives, and so you could make a directory appear to be a drive and they&#x27;d be happy - otherwise they&#x27;d dump everything in the root of C:\ (or A:\).</div><br/></div></div><div id="42475856" class="c"><input type="checkbox" id="c-42475856" checked=""/><div class="controls bullet"><span class="by">technion</span><span>|</span><a href="#42475572">parent</a><span>|</span><a href="#42475627">prev</a><span>|</span><a href="#42475701">next</a><span>|</span><label class="collapse" for="c-42475856">[-]</label><label class="expand" for="c-42475856">[2 more]</label></div><br/><div class="children"><div class="content">SUBST to this day is how you solve long file name problems. One drive for business can make a very long path if it uses your full business name. Windows has the api to let some apps apps save long sob folders, but not to let Explorer or powershell delete those folders.<p>You go on folder up and use subst to make a drive letter from which you can delete content.</div><br/><div id="42476964" class="c"><input type="checkbox" id="c-42476964" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#42475572">root</a><span>|</span><a href="#42475856">parent</a><span>|</span><a href="#42475701">next</a><span>|</span><label class="collapse" for="c-42476964">[-]</label><label class="expand" for="c-42476964">[1 more]</label></div><br/><div class="children"><div class="content">Explorer (known in MS jargon as &quot;the shell&quot;, but I&#x27;m avoiding the term because it confuses Unix users) is limited by MAX_PATH characters when it stores absolute paths.<p>Win32 allows you to use paths above MAX_PATH in length when you 1. Use the utf-16 filename apis and 2. prefix your path with \\?\.<p>But the shell doesn&#x27;t do the latter. It may also use fixed size buffers for paths, that is a common reason for such limitations.</div><br/></div></div></div></div><div id="42475701" class="c"><input type="checkbox" id="c-42475701" checked=""/><div class="controls bullet"><span class="by">mycall</span><span>|</span><a href="#42475572">parent</a><span>|</span><a href="#42475856">prev</a><span>|</span><a href="#42476106">next</a><span>|</span><label class="collapse" for="c-42475701">[-]</label><label class="expand" for="c-42475701">[9 more]</label></div><br/><div class="children"><div class="content">I still use SUBST with my team so we all have our source code on P:\ which can be mapped to wherever they want it to be.  This helps keep Visual Studio object files and project includes pointing to the same place, especially when mistakes are made (they should be relative paths but things happen).<p>It is run from a registry key upon bootup.</div><br/><div id="42476092" class="c"><input type="checkbox" id="c-42476092" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42475572">root</a><span>|</span><a href="#42475701">parent</a><span>|</span><a href="#42475823">next</a><span>|</span><label class="collapse" for="c-42476092">[-]</label><label class="expand" for="c-42476092">[3 more]</label></div><br/><div class="children"><div class="content">We do the same, except you don&#x27;t need to do it at bootup, you can set it once using the following:<p><pre><code>    Windows Registry Editor Version 5.00

    [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\DOS Devices]
    &quot;P:&quot;=&quot;\\??\\C:\\Dev\\Source&quot;
</code></pre>
Change source path accordingly, save as .reg file, import once and it&#x27;ll stay.<p>Nice thing about this vs using SUBST is that the SUBST is for your user only, so if you have a separate admin account it won&#x27;t see it. However the above registry entry is for the machine, so all users on the machine will see it.<p>Obviously makes it less useful for terminal servers and other shared machines.</div><br/><div id="42476157" class="c"><input type="checkbox" id="c-42476157" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#42475572">root</a><span>|</span><a href="#42476092">parent</a><span>|</span><a href="#42475823">next</a><span>|</span><label class="collapse" for="c-42476157">[-]</label><label class="expand" for="c-42476157">[2 more]</label></div><br/><div class="children"><div class="content">I think SUBST can break when you run as administrator (elevating your own privileges).</div><br/><div id="42477775" class="c"><input type="checkbox" id="c-42477775" checked=""/><div class="controls bullet"><span class="by">jasomill</span><span>|</span><a href="#42475572">root</a><span>|</span><a href="#42476157">parent</a><span>|</span><a href="#42475823">next</a><span>|</span><label class="collapse" for="c-42477775">[-]</label><label class="expand" for="c-42477775">[1 more]</label></div><br/><div class="children"><div class="content">It still works, but the elevated context maintains a separate list of drive letter mappings, so you need to issue the SUBST command again while elevated.<p>The same applies to network drive letter mappings.<p>Under the hood, both are implemented as NT Object Manager symbolic links, which you can see using, e.g.,<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;sysinternals&#x2F;downloads&#x2F;winobj" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;sysinternals&#x2F;downloads&#x2F;win...</a></div><br/></div></div></div></div></div></div><div id="42475823" class="c"><input type="checkbox" id="c-42475823" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#42475572">root</a><span>|</span><a href="#42475701">parent</a><span>|</span><a href="#42476092">prev</a><span>|</span><a href="#42476106">next</a><span>|</span><label class="collapse" for="c-42475823">[-]</label><label class="expand" for="c-42475823">[5 more]</label></div><br/><div class="children"><div class="content">SUBST is all fine, up until the point some tool explodes when it sees that normalizePath(&quot;P:\\whatever&quot;) == &quot;C:\\code\\whatever&quot;, and it ends up with two paths to one file, or no way to build a relative path. I’ve seen that happen with some node tooling, for example.</div><br/><div id="42476152" class="c"><input type="checkbox" id="c-42476152" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#42475572">root</a><span>|</span><a href="#42475823">parent</a><span>|</span><a href="#42475979">next</a><span>|</span><label class="collapse" for="c-42476152">[-]</label><label class="expand" for="c-42476152">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen programs blow up because they think they need to &quot;canonicalize&quot; the path, when all they actually want is a full path (a rooted path rather than a relative path).<p>Canonicalizing the path resolves all drive letters and symbolic links.  The Rust function that canonicalizes a path can fail on some mounted filesystems if the drive letter wasn&#x27;t registered using the Windows Mount Manager.</div><br/></div></div><div id="42475979" class="c"><input type="checkbox" id="c-42475979" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#42475572">root</a><span>|</span><a href="#42475823">parent</a><span>|</span><a href="#42476152">prev</a><span>|</span><a href="#42476106">next</a><span>|</span><label class="collapse" for="c-42475979">[-]</label><label class="expand" for="c-42475979">[3 more]</label></div><br/><div class="children"><div class="content">I think some of the WSL stuff refuses to deal with SUBST&#x27;d drives. And if you use voidtools&#x27;s Everything, it&#x27;s worth spending 2 minutes setting up some excluded paths so that you don&#x27;t get doubled up entries. But it seems it does generally work pretty well. I&#x27;ve recently done work for a former employer, who it seems are still using SUBST&#x27;d drive Z:, just as they&#x27;d always done when I worked there nearly 20 years ago. (Main reason: we&#x27;d found it worked well at the place we&#x27;d all worked at previously...)<p>The idea of everybody having the same paths for things never sat right with me, because it&#x27;s an easy way for absolute paths to sneak in, which can be (and occasionally was) a problem when trying to support multiple branches later in the project lifecycle. But if you&#x27;ve got a CI system, which people typically do in 2024, that&#x27;s much less of an issue (because you can arrange for the CI system to build from a random path each time). And it is pretty handy when you can paste universally-usable paths into the chat.</div><br/><div id="42476178" class="c"><input type="checkbox" id="c-42476178" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#42475572">root</a><span>|</span><a href="#42475979">parent</a><span>|</span><a href="#42476106">next</a><span>|</span><label class="collapse" for="c-42476178">[-]</label><label class="expand" for="c-42476178">[2 more]</label></div><br/><div class="children"><div class="content">&gt; you can arrange for the CI system to build from a random path each time<p>Or you can end up having to use the magic path for all builds.<p>At work, we have a subst’d drive. The way we set it up means that some &lt;evil crap&gt; requires it (by the virtue of hardcoding, or by common configuration). But I do most of my development from a fully separate, leaner copy of the repo, and consider the subst drive to be a garbage pile.</div><br/><div id="42476288" class="c"><input type="checkbox" id="c-42476288" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#42475572">root</a><span>|</span><a href="#42476178">parent</a><span>|</span><a href="#42476106">next</a><span>|</span><label class="collapse" for="c-42476288">[-]</label><label class="expand" for="c-42476288">[1 more]</label></div><br/><div class="children"><div class="content">The idea is that you set up the CI system to build from a different path as often as possible. Per build, per build machine, per build machine rebuild - whatever works for you. Just ensure it&#x27;s a different path from the standard one that the developers use. Ideally, also make sure that the path the developers use is completely inaccessible on the CI machines.<p>Now the chance of introducing dependencies on the standard path is much lower. You can do it, and it will work for you, and it will work for everybody else too when they get your change. But at some point, the CI system will get it, and it will fail, and you&#x27;ll know that you have something to fix.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42476106" class="c"><input type="checkbox" id="c-42476106" checked=""/><div class="controls bullet"><span class="by">codesnik</span><span>|</span><a href="#42475572">parent</a><span>|</span><a href="#42475701">prev</a><span>|</span><a href="#42475746">next</a><span>|</span><label class="collapse" for="c-42476106">[-]</label><label class="expand" for="c-42476106">[1 more]</label></div><br/><div class="children"><div class="content">poor man&#x27;s chroot.</div><br/></div></div><div id="42475746" class="c"><input type="checkbox" id="c-42475746" checked=""/><div class="controls bullet"><span class="by">johng</span><span>|</span><a href="#42475572">parent</a><span>|</span><a href="#42476106">prev</a><span>|</span><a href="#42475835">next</a><span>|</span><label class="collapse" for="c-42475746">[-]</label><label class="expand" for="c-42475746">[1 more]</label></div><br/><div class="children"><div class="content">Ahh yes, subst was very handy many times back in the day and it worked like magic to me!</div><br/></div></div></div></div><div id="42475835" class="c"><input type="checkbox" id="c-42475835" checked=""/><div class="controls bullet"><span class="by">pram</span><span>|</span><a href="#42475572">prev</a><span>|</span><a href="#42475770">next</a><span>|</span><label class="collapse" for="c-42475835">[-]</label><label class="expand" for="c-42475835">[4 more]</label></div><br/><div class="children"><div class="content">Is INT 2fH the DOS equivalent of PATH? What a bizarre mechanism, I&#x27;ve read it 2 times and I have no idea what it&#x27;s saying lol:<p><a href="http:&#x2F;&#x2F;vitaly_filatov.tripod.com&#x2F;ng&#x2F;asm&#x2F;asm_011.16.html" rel="nofollow">http:&#x2F;&#x2F;vitaly_filatov.tripod.com&#x2F;ng&#x2F;asm&#x2F;asm_011.16.html</a></div><br/><div id="42476303" class="c"><input type="checkbox" id="c-42476303" checked=""/><div class="controls bullet"><span class="by">SeenNotHeard</span><span>|</span><a href="#42475835">parent</a><span>|</span><a href="#42475912">next</a><span>|</span><label class="collapse" for="c-42476303">[-]</label><label class="expand" for="c-42476303">[1 more]</label></div><br/><div class="children"><div class="content">INT 2Fh was the so-called &quot;mux&quot; that various TSRs and drivers could hook into for (in essence) interprocess communication.  The half-baked idea was to solve the problem of TSRs commandeering other interrupts for one-off needs, which led to lots of collisions.<p>In order for the mux to work, each TSR had to have its own identifier code.  Other than some reserved ranges, no one organized such a namespace, meaning it was possible for two or more TSRs to intercept the same request, leading to the same collision problem.<p>This note from Ralf Brown&#x27;s Interrupt List has the gory details:<p><a href="http:&#x2F;&#x2F;www.ctyme.com&#x2F;intr&#x2F;rb-4251.htm" rel="nofollow">http:&#x2F;&#x2F;www.ctyme.com&#x2F;intr&#x2F;rb-4251.htm</a><p>Incomplete list of TSRs and drivers relying on it:<p><a href="http:&#x2F;&#x2F;www.ctyme.com&#x2F;intr&#x2F;int-2f.htm" rel="nofollow">http:&#x2F;&#x2F;www.ctyme.com&#x2F;intr&#x2F;int-2f.htm</a></div><br/></div></div><div id="42475912" class="c"><input type="checkbox" id="c-42475912" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#42475835">parent</a><span>|</span><a href="#42476303">prev</a><span>|</span><a href="#42475770">next</a><span>|</span><label class="collapse" for="c-42475912">[-]</label><label class="expand" for="c-42475912">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s just an ugly ass syscall extension mechanism (so it has no direct equivalent in Linux lets say), it definitely looks bizarre in modern times.<p>Int 2F is initially handled by DOS as a stub, but additional programs (like drivers and TSRs) can override INT 2F, put their bucket of functionality and then fallback to whatever the previous installed handler was (called chaining) for whatever they don&#x27;t handle.<p>This gives a glimpse into how much various crap could end up installed as an Int 2F handler:
<a href="https:&#x2F;&#x2F;www.minuszerodegrees.net&#x2F;websitecopies&#x2F;Linux.old&#x2F;docs&#x2F;interrupts&#x2F;int-html&#x2F;int-2f-1.htm" rel="nofollow">https:&#x2F;&#x2F;www.minuszerodegrees.net&#x2F;websitecopies&#x2F;Linux.old&#x2F;doc...</a><p>It was often used for feature&#x2F;presence checks and usually nothing time critical as that chaining setup was most definitely not timing friendly.</div><br/><div id="42477244" class="c"><input type="checkbox" id="c-42477244" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#42475835">root</a><span>|</span><a href="#42475912">parent</a><span>|</span><a href="#42475770">next</a><span>|</span><label class="collapse" for="c-42477244">[-]</label><label class="expand" for="c-42477244">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This gives a glimpse into how much various crap could end up installed as an Int 2F handler:<p>Lot&#x27;s of crap in INT 21 too: <a href="https:&#x2F;&#x2F;fd.lod.bz&#x2F;rbil&#x2F;zint&#x2F;index_21.html" rel="nofollow">https:&#x2F;&#x2F;fd.lod.bz&#x2F;rbil&#x2F;zint&#x2F;index_21.html</a> (on the whole I like this HTMLified version of Ralf Brown&#x27;s Interrupt List better)<p>But I suppose they invented INT 2F to discourage people from doing that to INT 21.<p>And then Ralf Brown also proposed an alternative multiplex interrupt, INT 2D: <a href="https:&#x2F;&#x2F;fd.lod.bz&#x2F;rbil&#x2F;interrup&#x2F;tsr&#x2F;2d.html#4258" rel="nofollow">https:&#x2F;&#x2F;fd.lod.bz&#x2F;rbil&#x2F;interrup&#x2F;tsr&#x2F;2d.html#4258</a></div><br/></div></div></div></div></div></div><div id="42475770" class="c"><input type="checkbox" id="c-42475770" checked=""/><div class="controls bullet"><span class="by">miohtama</span><span>|</span><a href="#42475835">prev</a><span>|</span><a href="#42477418">next</a><span>|</span><label class="collapse" for="c-42475770">[-]</label><label class="expand" for="c-42475770">[1 more]</label></div><br/><div class="children"><div class="content">I remember wondering APPEND as a kid three decades ago. Looks like it had a very specific legacy use case, which was no longer present in more modern DOS versions. Live and learn.</div><br/></div></div><div id="42477418" class="c"><input type="checkbox" id="c-42477418" checked=""/><div class="controls bullet"><span class="by">NotYourLawyer</span><span>|</span><a href="#42475770">prev</a><span>|</span><a href="#42475453">next</a><span>|</span><label class="collapse" for="c-42477418">[-]</label><label class="expand" for="c-42477418">[1 more]</label></div><br/><div class="children"><div class="content">Huh. I knew this command existed but never looked into it. I assumed it was like cat, just appending files together.</div><br/></div></div><div id="42475453" class="c"><input type="checkbox" id="c-42475453" checked=""/><div class="controls bullet"><span class="by">pavlov</span><span>|</span><a href="#42477418">prev</a><span>|</span><label class="collapse" for="c-42475453">[-]</label><label class="expand" for="c-42475453">[15 more]</label></div><br/><div class="children"><div class="content"><i>&gt; “In fact it is known that DOS 2.0 could not be built on PCs at all, and was built on DEC mainframes.”</i><p>Nitpick, but DEC never made a mainframe. Their products like the PDP-11 were considered minicomputers (even though the CPU was the size of a fridge) to distinguish them from IBM’s mainframes and medium sized computers.</div><br/><div id="42475636" class="c"><input type="checkbox" id="c-42475636" checked=""/><div class="controls bullet"><span class="by">mepian</span><span>|</span><a href="#42475453">parent</a><span>|</span><a href="#42475581">next</a><span>|</span><label class="collapse" for="c-42475636">[-]</label><label class="expand" for="c-42475636">[1 more]</label></div><br/><div class="children"><div class="content">The PDP-10 was a mainframe: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;PDP-10#cite_note-1" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;PDP-10#cite_note-1</a></div><br/></div></div><div id="42475581" class="c"><input type="checkbox" id="c-42475581" checked=""/><div class="controls bullet"><span class="by">retrac</span><span>|</span><a href="#42475453">parent</a><span>|</span><a href="#42475636">prev</a><span>|</span><a href="#42475808">next</a><span>|</span><label class="collapse" for="c-42475581">[-]</label><label class="expand" for="c-42475581">[7 more]</label></div><br/><div class="children"><div class="content">DEC was always finnicky about naming; the PDP series originally wasn&#x27;t supposed to be called a computer because computers were thought of as much bigger than the products DEC sold, and customers in the 50s and 60s might be put off by a name they associated with multi-million dollar expenses.<p>But the PDP-10 and VAX 9000 were basically mainframes.  Million dollars or more.  Whole large room with three phase power.  Standard building AC might suffice but that was pushing the margin.  And the faster clocked VAX 9000 was water cooled! That&#x27;s not a minicomputer.</div><br/><div id="42476148" class="c"><input type="checkbox" id="c-42476148" checked=""/><div class="controls bullet"><span class="by">brucehoult</span><span>|</span><a href="#42475453">root</a><span>|</span><a href="#42475581">parent</a><span>|</span><a href="#42475677">next</a><span>|</span><label class="collapse" for="c-42476148">[-]</label><label class="expand" for="c-42476148">[1 more]</label></div><br/><div class="children"><div class="content">My PC is water cooled.<p>However the VAX 9000 wasn&#x27;t. It was initially designed to be water cooled but during development they improved the air cooling enough that water cooling was never shipped.<p>One VAX 9000 CPU did around 70k Dhrystones&#x2F;sec, so 40 VAX MIPS (DMIPS as we call them now).<p>A modern simple RISC 5-stage in-order CPU (e.g. Berkeley RISC-V Rocket) with decent branch prediction does 1.6 DMIPS&#x2F;MHz, so will need 25 MHz to match the VAX 9000. However the December 2016 HiFive1 ran at 320 MHz, so would be around a dozen times faster than the VAX 9000 -- but without FPU or MMU. Today, a $5 Milk-V Duo running at 1 GHz (64 bit, and with MMU and FPU and vector unit) will be 40x faster than a VAX 9000.<p>The VAX 9000 has a vector unit, capable of a peak 125 MFLOPS. The Duo&#x27;s C906 VFMACC.VV instruction has 4 cycles latency, for two 64-bit multiply-adds or four 32-bit multiply-adds, so at 1 GHz that&#x27;s 1 GFLOP double precision or 2 GFLOP single precision, 8x a VAX 9000.<p>Don&#x27;t even ask what a modern i9 or Ryzen can do!</div><br/></div></div><div id="42475677" class="c"><input type="checkbox" id="c-42475677" checked=""/><div class="controls bullet"><span class="by">mmooss</span><span>|</span><a href="#42475453">root</a><span>|</span><a href="#42475581">parent</a><span>|</span><a href="#42476148">prev</a><span>|</span><a href="#42475808">next</a><span>|</span><label class="collapse" for="c-42475677">[-]</label><label class="expand" for="c-42475677">[5 more]</label></div><br/><div class="children"><div class="content">&gt; But the PDP-10 and VAX 9000 were basically mainframes. Million dollars or more. Whole large room with three phase power. Standard building AC might suffice but that was pushing the margin. And the faster clocked VAX 9000 was water cooled! That&#x27;s not a minicomputer.<p>Why is that not a minicomputer. From our perspective it&#x27;s a massive installation; from the perspective of the time, it was not necessarily.</div><br/><div id="42478050" class="c"><input type="checkbox" id="c-42478050" checked=""/><div class="controls bullet"><span class="by">somat</span><span>|</span><a href="#42475453">root</a><span>|</span><a href="#42475677">parent</a><span>|</span><a href="#42475868">next</a><span>|</span><label class="collapse" for="c-42478050">[-]</label><label class="expand" for="c-42478050">[1 more]</label></div><br/><div class="children"><div class="content">I am not exactly sure what makes a modern mainframe(same architecture as a historical mainframe I guess) but for historical machines I consider the wide machines(like the 36-bit pdp-10) mainframes, where minicomputers were usually narrower. 16 or 18 bit machines.<p>Really there is no good formal definition, dividing computers into three groups(mainframe, minicomputer, microcomputer) based on how much you payed for it, is as good a mechanism for figuring this out as any other.</div><br/></div></div><div id="42475868" class="c"><input type="checkbox" id="c-42475868" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#42475453">root</a><span>|</span><a href="#42475677">parent</a><span>|</span><a href="#42478050">prev</a><span>|</span><a href="#42476220">next</a><span>|</span><label class="collapse" for="c-42475868">[-]</label><label class="expand" for="c-42475868">[1 more]</label></div><br/><div class="children"><div class="content">Minicomputer at the time was considered a system that fits in a rack or three. Not something that requires a purpose built room with own mains, raised floor and AC.</div><br/></div></div></div></div></div></div><div id="42475808" class="c"><input type="checkbox" id="c-42475808" checked=""/><div class="controls bullet"><span class="by">Hilift</span><span>|</span><a href="#42475453">parent</a><span>|</span><a href="#42475581">prev</a><span>|</span><a href="#42475525">next</a><span>|</span><label class="collapse" for="c-42475808">[-]</label><label class="expand" for="c-42475808">[2 more]</label></div><br/><div class="children"><div class="content">It was probably a VAX 11&#x2F;780. If you were cheap you purchased an 11&#x2F;750. The 780 had a PDP-8 for a console processor. <a href="https:&#x2F;&#x2F;news.microsoft.com&#x2F;features&#x2F;the-engineers-engineer-computer-industry-luminaries-salute-dave-cutlers-five-decade-long-quest-for-quality&#x2F;" rel="nofollow">https:&#x2F;&#x2F;news.microsoft.com&#x2F;features&#x2F;the-engineers-engineer-c...</a></div><br/><div id="42477023" class="c"><input type="checkbox" id="c-42477023" checked=""/><div class="controls bullet"><span class="by">SulphurCrested</span><span>|</span><a href="#42475453">root</a><span>|</span><a href="#42475808">parent</a><span>|</span><a href="#42475525">next</a><span>|</span><label class="collapse" for="c-42477023">[-]</label><label class="expand" for="c-42477023">[1 more]</label></div><br/><div class="children"><div class="content">The console processor was an LSI-11, a PDP-11 on a chip. It hung off the inside of one of the cabinet doors. It was responsible for booting the 780 and also gave VMS access to its own 8″ floppy drive, which had a habit of overheating.<p>The 750 was later technology, IIRC MOSFET. It also lacked the 780’s “compatibility mode”, which allowed VMS to run 16 bit RSX-11 executables by implementing the PDP-11 instruction set in addition to the 32 bit VAX one, and could boot without a console processor. If you didn’t need all the users on one machine, the 750 was cheaper per user.</div><br/></div></div></div></div><div id="42475525" class="c"><input type="checkbox" id="c-42475525" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#42475453">parent</a><span>|</span><a href="#42475808">prev</a><span>|</span><a href="#42475552">next</a><span>|</span><label class="collapse" for="c-42475525">[-]</label><label class="expand" for="c-42475525">[1 more]</label></div><br/><div class="children"><div class="content">The PDP-11 was minicomputer, but PDP-10s were &quot;minis&quot; only formally, with VAX due to reasonable size and comparable performance coining the title &quot;supermini&quot; IIRC.</div><br/></div></div><div id="42475552" class="c"><input type="checkbox" id="c-42475552" checked=""/><div class="controls bullet"><span class="by">surgical_fire</span><span>|</span><a href="#42475453">parent</a><span>|</span><a href="#42475525">prev</a><span>|</span><a href="#42475554">next</a><span>|</span><label class="collapse" for="c-42475552">[-]</label><label class="expand" for="c-42475552">[2 more]</label></div><br/><div class="children"><div class="content">Nitpick, but as far as I remember, minicomputers <i>are</i> midrange computers. DEC PDP-11 would be in the same class as IBM AS&#x2F;400, so while they were distinguished from mainframes, they were &quot;medium sized computers&quot;.<p>Assuming, of course, that those &quot;medium sized computers&quot; are the midrange.</div><br/><div id="42477803" class="c"><input type="checkbox" id="c-42477803" checked=""/><div class="controls bullet"><span class="by">jasomill</span><span>|</span><a href="#42475453">root</a><span>|</span><a href="#42475552">parent</a><span>|</span><a href="#42475554">next</a><span>|</span><label class="collapse" for="c-42477803">[-]</label><label class="expand" for="c-42477803">[1 more]</label></div><br/><div class="children"><div class="content">This gets even more confusing when you consider that IBM released a number of mainframes smaller than many of their midrange systems, including both System&#x2F;370 and System&#x2F;390 systems implemented as PC expansion cards (ISA, MCA, and PCI).<p>Ultimately, within IBM at least, &quot;mainframe&quot; ended up just referring to any computer that implemented the System&#x2F;360 architecture or its descendants.<p>Outside IBM, I&#x27;ve seen the term applied to just about any multiuser system accessed primarily through a terminal interface, including x86 servers running Linux, though typically by nontechnical users.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>