<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720170065432" as="style"/><link rel="stylesheet" href="styles.css?v=1720170065432"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.brixit.nl/moving-to-a-rtos-on-the-rp2040/">Moving to a RTOS on the RP2040</a> <span class="domain">(<a href="https://blog.brixit.nl">blog.brixit.nl</a>)</span></div><div class="subtext"><span>lupyuen</span> | <span>28 comments</span></div><br/><div><div id="40880942" class="c"><input type="checkbox" id="c-40880942" checked=""/><div class="controls bullet"><span class="by">DannyBee</span><span>|</span><a href="#40880059">next</a><span>|</span><label class="collapse" for="c-40880942">[-]</label><label class="expand" for="c-40880942">[1 more]</label></div><br/><div class="children"><div class="content">This author seems like they are expecting an RTOS to be the same as Arduino environment, or at least, susceptible to just hacking around and hoping it works.  Most are not.<p>Given a lot of Arduino these days have mbed or freertos under the covers, with some way to expose it, that may have been a better route for the author&#x27;s style.<p>Zephyr is easy to use (Clion also has good support for it), but like, you can&#x27;t just choose not to install the toolchain and expect it to all work.<p>It also definitely supports the Pi Pico - i&#x27;ve used it on it before, no issues.<p>A simpler rundown of these RTOSen would be:<p>1. FreeRTOS - supported by roughly everything, but drivers and such are mostly per-SOC&#x2F;device, which is a pain in the ass.  The APIs are not very user friendly, but you get used to it.<p>To give a sense of level - if you wanted to use bluetooth with FreeRTOS, you get to find your own stack.<p>2. Zephyr - supports real hardware abstractions and supports most SOC. You may have to do a little board work.<p>If you wanted to use bluetooth with Zephyr, it has a bluetooth stack you can use, you may have to add a little support for your HCI.<p>3. NuttX - not great support, but very cool if you can get it working - not really highly supported by industry yet.<p>I never got far enough into NuttX to try bluetooth in NuttX.<p>There is also mbed, but we&#x27;ll skip it.<p>In practice, people in the RTOS world will usually go with what the SOC vendor supports.  So if you are using Nordic stuff, you are probably on Zephyr.  If you are using NXP stuff, probably FreeRTOS, etc.<p>That is how they get good support.</div><br/></div></div><div id="40880059" class="c"><input type="checkbox" id="c-40880059" checked=""/><div class="controls bullet"><span class="by">drrotmos</span><span>|</span><a href="#40880942">prev</a><span>|</span><a href="#40880954">next</a><span>|</span><label class="collapse" for="c-40880059">[-]</label><label class="expand" for="c-40880059">[8 more]</label></div><br/><div class="children"><div class="content">Personally, I&#x27;ve begun switching over my RP2040 projects to Rust using Embassy. Rust did take some getting used to, but I quite like it. Not an RTOS, but it satisfies a lot of the same requirements that&#x27;d lead you to an RTOS.</div><br/><div id="40880562" class="c"><input type="checkbox" id="c-40880562" checked=""/><div class="controls bullet"><span class="by">bschwindHN</span><span>|</span><a href="#40880059">parent</a><span>|</span><a href="#40880590">next</a><span>|</span><label class="collapse" for="c-40880562">[-]</label><label class="expand" for="c-40880562">[1 more]</label></div><br/><div class="children"><div class="content">If you go this route, I would recommend starting off with the rp2040-hal crate and once you hit a pain point of managing multiple tasks, look into embassy or RTIC.<p>Rust and Cargo take the pain out of building and flashing to the RP2040 (or STM32, for that matter) - it&#x27;s the most pleasant embedded setup I&#x27;ve ever used.</div><br/></div></div><div id="40880590" class="c"><input type="checkbox" id="c-40880590" checked=""/><div class="controls bullet"><span class="by">eloycoto</span><span>|</span><a href="#40880059">parent</a><span>|</span><a href="#40880562">prev</a><span>|</span><a href="#40880424">next</a><span>|</span><label class="collapse" for="c-40880590">[-]</label><label class="expand" for="c-40880590">[1 more]</label></div><br/><div class="children"><div class="content">100%, Embassy is great and I&#x27;m in love with it. If you add the PIO interface for RP2040 the setup makes code super simple and beatiful and difficult to achieve with another processor.</div><br/></div></div><div id="40880424" class="c"><input type="checkbox" id="c-40880424" checked=""/><div class="controls bullet"><span class="by">stockhorn</span><span>|</span><a href="#40880059">parent</a><span>|</span><a href="#40880590">prev</a><span>|</span><a href="#40880176">next</a><span>|</span><label class="collapse" for="c-40880424">[-]</label><label class="expand" for="c-40880424">[1 more]</label></div><br/><div class="children"><div class="content">I can totally second this. Embedded rust in general has been an excellent experience for me. And async with embassy-executor works really well and takes a lot of pain off the whole rtos design process.</div><br/></div></div><div id="40880176" class="c"><input type="checkbox" id="c-40880176" checked=""/><div class="controls bullet"><span class="by">chappi42</span><span>|</span><a href="#40880059">parent</a><span>|</span><a href="#40880424">prev</a><span>|</span><a href="#40880325">next</a><span>|</span><label class="collapse" for="c-40880176">[-]</label><label class="expand" for="c-40880176">[1 more]</label></div><br/><div class="children"><div class="content">Wow that looks cool. Thanks for the mention!</div><br/></div></div><div id="40880325" class="c"><input type="checkbox" id="c-40880325" checked=""/><div class="controls bullet"><span class="by">lloydatkinson</span><span>|</span><a href="#40880059">parent</a><span>|</span><a href="#40880176">prev</a><span>|</span><a href="#40880954">next</a><span>|</span><label class="collapse" for="c-40880325">[-]</label><label class="expand" for="c-40880325">[3 more]</label></div><br/><div class="children"><div class="content">I believe this has come up before but what are some of the differences between RTIC and Embassy?</div><br/><div id="40880387" class="c"><input type="checkbox" id="c-40880387" checked=""/><div class="controls bullet"><span class="by">Katzenmann</span><span>|</span><a href="#40880059">root</a><span>|</span><a href="#40880325">parent</a><span>|</span><a href="#40880954">next</a><span>|</span><label class="collapse" for="c-40880387">[-]</label><label class="expand" for="c-40880387">[2 more]</label></div><br/><div class="children"><div class="content">RTIC is really simple and doesn&#x27;t use it&#x27;s own HALs. Also it&#x27;s macro system makes it hard to modularize your code since all tasks need to be in one module. I&#x27;ve played around with it a bit and it seems like it could be great in the future, but currently not really.<p>Embassy has it&#x27;s own HALs which makes it better at async and has also nicer ergonomic IMO</div><br/><div id="40880519" class="c"><input type="checkbox" id="c-40880519" checked=""/><div class="controls bullet"><span class="by">liamkinne</span><span>|</span><a href="#40880059">root</a><span>|</span><a href="#40880387">parent</a><span>|</span><a href="#40880954">next</a><span>|</span><label class="collapse" for="c-40880519">[-]</label><label class="expand" for="c-40880519">[1 more]</label></div><br/><div class="children"><div class="content">Importantly for RP2040 users, RTIC 2.0.0 is currently single-core only.<p>I’m using RTIC for the firmware on my STM32H7 based product (<a href="https:&#x2F;&#x2F;umi.engineering" rel="nofollow">https:&#x2F;&#x2F;umi.engineering</a>) and it has been a joy.</div><br/></div></div></div></div></div></div></div></div><div id="40880954" class="c"><input type="checkbox" id="c-40880954" checked=""/><div class="controls bullet"><span class="by">bborud</span><span>|</span><a href="#40880059">prev</a><span>|</span><a href="#40880080">next</a><span>|</span><label class="collapse" for="c-40880954">[-]</label><label class="expand" for="c-40880954">[1 more]</label></div><br/><div class="children"><div class="content">Having toolchains installed system-wide in the traditional UNIX way is painful, and dare I say it, not the smartest of approaches.  If it works for you: great, but if you work on a project with multiple developers, sometimes working on multiple projects that have different targets, you will spend a lot of time trying to figure out build and configuration problems.<p>It also doesn&#x27;t help that people keep using Python for tooling.  Why would you want to insist on using a language that brings its own versioning problems and which will behave differently on each developer&#x27;s computer?  I&#x27;ve done embedded development for about a decade now (both as a hobby and professionally) and it is puzzling that people think it is okay to spend a week trying to make everyone&#x27;s setup do the same thing on a project and then not see how this is a problem.<p>It <i>is</i> a problem. It <i>is</i> annoying. It <i>does</i> waste time. It <i>is</i> unnecessary.<p>Tools should be statically linked binaries. I don&#x27;t care what language people use to write tools, be it Rust, Go, C, C++.  I just wish people would stop prioritizing ad-hoc development and start to make robust tools that can be trusted to work the same way regardless of what&#x27;s installed on your computer. Python doesn&#x27;t do that. And it doesn&#x27;t help that people get angry and defensive instead of taking this a bit more seriously.<p>That being said, things like PlatformIO are a step in the right direction. I know it is a Python project (and occasionally that turns out to be a problem, but less often that for other tools), but they have the right idea: toolchains have to be managed, SDKs have to be managed, libraries have to be managed, project configuration has to be simple, builds have to be reproducible and they have to be reproducible anywhere and anytime.<p>I wish more of the embedded industry would realize that it would be better to have some common efforts to structure things and not always invent their own stuff. I know a lot of people who work for some of the major MCU manufacturers and I am always disheartened when I talk to them because they tend to be very near-sighted: they are mostly busy trying to solve their own immediate problems and tend to not have a great deal of focus on developers&#x27; needs.</div><br/></div></div><div id="40880080" class="c"><input type="checkbox" id="c-40880080" checked=""/><div class="controls bullet"><span class="by">5ADBEEF</span><span>|</span><a href="#40880954">prev</a><span>|</span><a href="#40880381">next</a><span>|</span><label class="collapse" for="c-40880080">[-]</label><label class="expand" for="c-40880080">[1 more]</label></div><br/><div class="children"><div class="content">the pi pico is 100% supported in Zephyr. <a href="https:&#x2F;&#x2F;github.com&#x2F;zephyrproject-rtos&#x2F;zephyr&#x2F;tree&#x2F;main&#x2F;boards&#x2F;raspberrypi&#x2F;rpi_pico">https:&#x2F;&#x2F;github.com&#x2F;zephyrproject-rtos&#x2F;zephyr&#x2F;tree&#x2F;main&#x2F;board...</a> Did the author not check the docs? <a href="https:&#x2F;&#x2F;docs.zephyrproject.org&#x2F;latest&#x2F;boards&#x2F;raspberrypi&#x2F;rpi_pico&#x2F;doc&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;docs.zephyrproject.org&#x2F;latest&#x2F;boards&#x2F;raspberrypi&#x2F;rpi...</a><p>Additionally, you aren&#x27;t intended (for many situations) to use a single &quot;main&quot; Zephyr install, but to include what external modules you need in your project&#x27;s west.yml. If you have a number of projects sharing the same Zephyr install that&#x27;s a separate discussion but installing every possible toolchain&#x2F;HAL is not the only way to do things.</div><br/></div></div><div id="40880381" class="c"><input type="checkbox" id="c-40880381" checked=""/><div class="controls bullet"><span class="by">sgt</span><span>|</span><a href="#40880080">prev</a><span>|</span><a href="#40879955">next</a><span>|</span><label class="collapse" for="c-40880381">[-]</label><label class="expand" for="c-40880381">[5 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t go wrong with FreeRTOS. It&#x27;s basically an industry standard at this point.</div><br/><div id="40880665" class="c"><input type="checkbox" id="c-40880665" checked=""/><div class="controls bullet"><span class="by">alextingle</span><span>|</span><a href="#40880381">parent</a><span>|</span><a href="#40879955">next</a><span>|</span><label class="collapse" for="c-40880665">[-]</label><label class="expand" for="c-40880665">[4 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the solution to his problem getting printf() to work?<p>That does sound like a PIA.</div><br/><div id="40880811" class="c"><input type="checkbox" id="c-40880811" checked=""/><div class="controls bullet"><span class="by">TickleSteve</span><span>|</span><a href="#40880381">root</a><span>|</span><a href="#40880665">parent</a><span>|</span><a href="#40880735">next</a><span>|</span><label class="collapse" for="c-40880811">[-]</label><label class="expand" for="c-40880811">[2 more]</label></div><br/><div class="children"><div class="content">FreeRTOS has nothing to do with printf, thats a toolchain&#x2F;standard library thing for his particular board.</div><br/><div id="40880892" class="c"><input type="checkbox" id="c-40880892" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#40880381">root</a><span>|</span><a href="#40880811">parent</a><span>|</span><a href="#40880735">next</a><span>|</span><label class="collapse" for="c-40880892">[-]</label><label class="expand" for="c-40880892">[1 more]</label></div><br/><div class="children"><div class="content">You will need your printf to be written with FreeRTOS in mind: it&#x27;s often not re-entrant at all, let alone actually blocking on IO instead of busy-waiting.</div><br/></div></div></div></div><div id="40880735" class="c"><input type="checkbox" id="c-40880735" checked=""/><div class="controls bullet"><span class="by">constantcrying</span><span>|</span><a href="#40880381">root</a><span>|</span><a href="#40880665">parent</a><span>|</span><a href="#40880811">prev</a><span>|</span><a href="#40879955">next</a><span>|</span><label class="collapse" for="c-40880735">[-]</label><label class="expand" for="c-40880735">[1 more]</label></div><br/><div class="children"><div class="content">Unlikely to be a software problem. If I had to guess the serial communication bus is misconfigured.</div><br/></div></div></div></div></div></div><div id="40879955" class="c"><input type="checkbox" id="c-40879955" checked=""/><div class="controls bullet"><span class="by">GianFabien</span><span>|</span><a href="#40880381">prev</a><span>|</span><a href="#40880941">next</a><span>|</span><label class="collapse" for="c-40879955">[-]</label><label class="expand" for="c-40879955">[3 more]</label></div><br/><div class="children"><div class="content">Great comparison of RTOS choices.<p>Personally I find microPython to be an easier path. async&#x2F;await based cooperative multi-tasking works well for me.  Latest project driving 6 stepper motors and a variety of LEDS and scanning buttons - all in what appears to be real-time to the user.</div><br/><div id="40880539" class="c"><input type="checkbox" id="c-40880539" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40879955">parent</a><span>|</span><a href="#40880121">next</a><span>|</span><label class="collapse" for="c-40880539">[-]</label><label class="expand" for="c-40880539">[1 more]</label></div><br/><div class="children"><div class="content">These mini computers are much more powerful than the 8 and 16 bit home computers, microPython is more than capable to replace BASIC use cases from those early systems.<p>It is still surprises me how many don&#x27;t grasp how little we had available to us, and still managed to use high level languages.</div><br/></div></div><div id="40880121" class="c"><input type="checkbox" id="c-40880121" checked=""/><div class="controls bullet"><span class="by">nick__m</span><span>|</span><a href="#40879955">parent</a><span>|</span><a href="#40880539">prev</a><span>|</span><a href="#40880941">next</a><span>|</span><label class="collapse" for="c-40880121">[-]</label><label class="expand" for="c-40880121">[1 more]</label></div><br/><div class="children"><div class="content">For a PTZ controller (No hard real-time requirements, minimal application memory usage) microPython look like productive choice. When I tried microPython (on the esp32 but i assume that the rp2040 is equally supported) I was pleased by it&#x27;s pythonic supports of interrupts handlers !</div><br/></div></div></div></div><div id="40880941" class="c"><input type="checkbox" id="c-40880941" checked=""/><div class="controls bullet"><span class="by">a-dub</span><span>|</span><a href="#40879955">prev</a><span>|</span><a href="#40880018">next</a><span>|</span><label class="collapse" for="c-40880941">[-]</label><label class="expand" for="c-40880941">[1 more]</label></div><br/><div class="children"><div class="content">hm. haven&#x27;t seen camelCase hard real-time task definitions since the vxworks days!</div><br/></div></div><div id="40880018" class="c"><input type="checkbox" id="c-40880018" checked=""/><div class="controls bullet"><span class="by">RossBencina</span><span>|</span><a href="#40880941">prev</a><span>|</span><a href="#40880171">next</a><span>|</span><label class="collapse" for="c-40880018">[-]</label><label class="expand" for="c-40880018">[1 more]</label></div><br/><div class="children"><div class="content">No mention of ThreadX, which is open source these days<p><a href="https:&#x2F;&#x2F;github.com&#x2F;eclipse-threadx&#x2F;threadx&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;eclipse-threadx&#x2F;threadx&#x2F;</a></div><br/></div></div><div id="40880171" class="c"><input type="checkbox" id="c-40880171" checked=""/><div class="controls bullet"><span class="by">taunus</span><span>|</span><a href="#40880018">prev</a><span>|</span><a href="#40879991">next</a><span>|</span><label class="collapse" for="c-40880171">[-]</label><label class="expand" for="c-40880171">[1 more]</label></div><br/><div class="children"><div class="content">If you want to look into Rust RTIC <a href="https:&#x2F;&#x2F;rtic.rs&#x2F;2&#x2F;book&#x2F;en&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rtic.rs&#x2F;2&#x2F;book&#x2F;en&#x2F;</a> has rp2040 support and is very lightweight</div><br/></div></div><div id="40879991" class="c"><input type="checkbox" id="c-40879991" checked=""/><div class="controls bullet"><span class="by">huppeldepup</span><span>|</span><a href="#40880171">prev</a><span>|</span><a href="#40880126">next</a><span>|</span><label class="collapse" for="c-40879991">[-]</label><label class="expand" for="c-40879991">[1 more]</label></div><br/><div class="children"><div class="content">No mention of ChibiOS, unfortunately. I checked and the port still has problems installing on flash, so runs on RAM only.<p>I’d also like to suggest uC&#x2F;OS. It doesn’t take much more than setting a timer in asm to port that rtos but I haven’t had the time myself to try it.</div><br/></div></div><div id="40880126" class="c"><input type="checkbox" id="c-40880126" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#40879991">prev</a><span>|</span><label class="collapse" for="c-40880126">[-]</label><label class="expand" for="c-40880126">[4 more]</label></div><br/><div class="children"><div class="content">AIUI seL4 runs on that chip.<p>It would likely not be a bad option.</div><br/><div id="40880712" class="c"><input type="checkbox" id="c-40880712" checked=""/><div class="controls bullet"><span class="by">rmu09</span><span>|</span><a href="#40880126">parent</a><span>|</span><a href="#40880835">next</a><span>|</span><label class="collapse" for="c-40880712">[-]</label><label class="expand" for="c-40880712">[2 more]</label></div><br/><div class="children"><div class="content">Do you have more information? seL4 seems to run on raspberry pi 3&#x2F;4, but I didn&#x27;t find any mention of cortex-m class CPUs being supported.</div><br/><div id="40880854" class="c"><input type="checkbox" id="c-40880854" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#40880126">root</a><span>|</span><a href="#40880712">parent</a><span>|</span><a href="#40880835">next</a><span>|</span><label class="collapse" for="c-40880854">[-]</label><label class="expand" for="c-40880854">[1 more]</label></div><br/><div class="children"><div class="content">Nevermind, I did not realize rp2040 is M0+ thus ARMv6.<p>ARMv7 is the minimum, and MMU is required. RISC-V is recommended.</div><br/></div></div></div></div><div id="40880835" class="c"><input type="checkbox" id="c-40880835" checked=""/><div class="controls bullet"><span class="by">TickleSteve</span><span>|</span><a href="#40880126">parent</a><span>|</span><a href="#40880712">prev</a><span>|</span><label class="collapse" for="c-40880835">[-]</label><label class="expand" for="c-40880835">[1 more]</label></div><br/><div class="children"><div class="content">This is a microcontroller (Cortex-M) not an application processor (Cortex-A).</div><br/></div></div></div></div></div></div></div></div></div></body></html>