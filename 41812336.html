<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728723674136" as="style"/><link rel="stylesheet" href="styles.css?v=1728723674136"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://peq42.com/blog/gleam-a-basic-introduction/">Gleam: A Basic Introduction</a> <span class="domain">(<a href="https://peq42.com">peq42.com</a>)</span></div><div class="subtext"><span>Alupis</span> | <span>56 comments</span></div><br/><div><div id="41815746" class="c"><input type="checkbox" id="c-41815746" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#41813356">next</a><span>|</span><label class="collapse" for="c-41815746">[-]</label><label class="expand" for="c-41815746">[3 more]</label></div><br/><div class="children"><div class="content">One niche feature of Erlang that I love is live module upgrades, particularly via gen_server&#x27;s code_change&#x2F;3 callback. It&#x27;s a neat little trick that seems to be rarely used in practice, but every single time I&#x27;ve used it I just loved how everything simply clicked together, providing zero disruption with nearly minimal effort (for simple state upgrades or downgrades).<p>I wonder if it&#x27;s supported with Gleam and&#x2F;or gleam_otp? Don&#x27;t see it in the docs.</div><br/><div id="41815951" class="c"><input type="checkbox" id="c-41815951" checked=""/><div class="controls bullet"><span class="by">sbrother</span><span>|</span><a href="#41815746">parent</a><span>|</span><a href="#41813356">next</a><span>|</span><label class="collapse" for="c-41815951">[-]</label><label class="expand" for="c-41815951">[2 more]</label></div><br/><div class="children"><div class="content">Do you know the current status of gleam_otp? I’ve been in the erlang (and more recently elixir) world for a long time and am quite excited about gleam, but when I looked at it early on it didn’t seem to have a great solution for OTP. Can I write genservers in gleam now, and can they run as part of an elixir&#x2F;erlang application&#x2F;supervision tree?</div><br/><div id="41816699" class="c"><input type="checkbox" id="c-41816699" checked=""/><div class="controls bullet"><span class="by">e3bc54b2</span><span>|</span><a href="#41815746">root</a><span>|</span><a href="#41815951">parent</a><span>|</span><a href="#41813356">next</a><span>|</span><label class="collapse" for="c-41816699">[-]</label><label class="expand" for="c-41816699">[1 more]</label></div><br/><div class="children"><div class="content">Elixir directly uses OTP because it is a dynamically typed language. Gleam folks concluded that OTP isn&#x27;t really designed with static types in mind, and so set out to build their own version of OTP[0]. It is still early days, and lot of stuff is remaining, but what is already there is pretty good.<p>[0] <a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;gleam_otp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hexdocs.pm&#x2F;gleam_otp&#x2F;</a></div><br/></div></div></div></div></div></div><div id="41813356" class="c"><input type="checkbox" id="c-41813356" checked=""/><div class="controls bullet"><span class="by">cedws</span><span>|</span><a href="#41815746">prev</a><span>|</span><a href="#41815416">next</a><span>|</span><label class="collapse" for="c-41813356">[-]</label><label class="expand" for="c-41813356">[15 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been interested in Gleam, but I didn&#x27;t realise it just transpiles to Erlang, I thought it compiled directly to BEAM bytecode. Bit of a turnoff to be honest, I really don&#x27;t want to deal with transpilation.</div><br/><div id="41813476" class="c"><input type="checkbox" id="c-41813476" checked=""/><div class="controls bullet"><span class="by">Ndymium</span><span>|</span><a href="#41813356">parent</a><span>|</span><a href="#41814316">next</a><span>|</span><label class="collapse" for="c-41813476">[-]</label><label class="expand" for="c-41813476">[8 more]</label></div><br/><div class="children"><div class="content">Which part do you feel like would be an issue? When you run `gleam compile`, it will automatically call the Erlang compiler to finish the job.<p>I find it very handy that the intermediate Erlang (or JS) files are available in the build directory. It lets you easily see what form your code will take when compiled.</div><br/><div id="41813547" class="c"><input type="checkbox" id="c-41813547" checked=""/><div class="controls bullet"><span class="by">rtorr</span><span>|</span><a href="#41813356">root</a><span>|</span><a href="#41813476">parent</a><span>|</span><a href="#41813966">next</a><span>|</span><label class="collapse" for="c-41813547">[-]</label><label class="expand" for="c-41813547">[1 more]</label></div><br/><div class="children"><div class="content">Also prevents lock-in if you ever need to move away from gleam.</div><br/></div></div><div id="41813966" class="c"><input type="checkbox" id="c-41813966" checked=""/><div class="controls bullet"><span class="by">pan69</span><span>|</span><a href="#41813356">root</a><span>|</span><a href="#41813476">parent</a><span>|</span><a href="#41813547">prev</a><span>|</span><a href="#41814240">next</a><span>|</span><label class="collapse" for="c-41813966">[-]</label><label class="expand" for="c-41813966">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it&#x27;s the transpile part that would the issue, it&#x27;s the runtime aspect. If Gleam transpiles to Erlang&#x2F;Javascript that&#x27;s great but once you run the program, you have to potentially deal with runtime issues specific to those environments which you might not be familiar with.<p>It seems that Gleam is really useful for those who are already in either the Erlang&#x2F;Javascript ecosystem.</div><br/><div id="41814011" class="c"><input type="checkbox" id="c-41814011" checked=""/><div class="controls bullet"><span class="by">Alupis</span><span>|</span><a href="#41813356">root</a><span>|</span><a href="#41813966">parent</a><span>|</span><a href="#41814240">next</a><span>|</span><label class="collapse" for="c-41814011">[-]</label><label class="expand" for="c-41814011">[2 more]</label></div><br/><div class="children"><div class="content">On the contrary, it&#x27;s a great first BEAM language to learn because of it&#x27;s simplicity - both in terms of the grammar as well as it&#x27;s tooling&#x2F;compiler.<p>For me personally, the Javascript target is the least interesting bit - the BEAM&#x2F;Erlang target is where it&#x27;s at for backend work. The BEAM is fascinating and full of ideas that were once ahead-of-their-time but now are really coming into their own with compute performance having caught up.<p>Gleam is a strongly typed language, and is unapologetically very functional. Error handling in general is quite different than it would be on a normal stack-based language&#x2F;vm. In my experience, the Erlang target doesn&#x27;t make debugging any harder or more difficult than you would expect for an exception-less language.</div><br/><div id="41815015" class="c"><input type="checkbox" id="c-41815015" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#41813356">root</a><span>|</span><a href="#41814011">parent</a><span>|</span><a href="#41814240">next</a><span>|</span><label class="collapse" for="c-41815015">[-]</label><label class="expand" for="c-41815015">[1 more]</label></div><br/><div class="children"><div class="content">The JS target is also <i>very</i> interesting to me. I like erlang fine and elixir&#x27;s nascent type system is promising. But the frontend (and js fullstack for that matter) currently does not have a good alternative to typescript, and the ML type system is an especially good fit for it. Elm has too much reputational baggage and rescript&#x2F;reason&#x2F;bucklescript&#x2F;whatever squandered its momentum and is floundering.</div><br/></div></div></div></div></div></div><div id="41814240" class="c"><input type="checkbox" id="c-41814240" checked=""/><div class="controls bullet"><span class="by">cedws</span><span>|</span><a href="#41813356">root</a><span>|</span><a href="#41813476">parent</a><span>|</span><a href="#41813966">prev</a><span>|</span><a href="#41814316">next</a><span>|</span><label class="collapse" for="c-41814240">[-]</label><label class="expand" for="c-41814240">[3 more]</label></div><br/><div class="children"><div class="content">Another layer of abstraction, another thing to go wrong, another thing to rot.</div><br/><div id="41816696" class="c"><input type="checkbox" id="c-41816696" checked=""/><div class="controls bullet"><span class="by">Ndymium</span><span>|</span><a href="#41813356">root</a><span>|</span><a href="#41814240">parent</a><span>|</span><a href="#41814295">next</a><span>|</span><label class="collapse" for="c-41816696">[-]</label><label class="expand" for="c-41816696">[1 more]</label></div><br/><div class="children"><div class="content">But, you need a runtime. If Gleam had its own runtime, that would be another layer in a similar vein. Here Gleam is using Erlang (or a JS runtime) which is bound to be more supported and have a longer lifetime than something they cooked up themselves.<p>Besides, Gleam&#x27;s original aim was basically &quot;Erlang but static types&quot;, so the choice of Erlang as runtime was always there.</div><br/></div></div></div></div></div></div><div id="41814316" class="c"><input type="checkbox" id="c-41814316" checked=""/><div class="controls bullet"><span class="by">hosh</span><span>|</span><a href="#41813356">parent</a><span>|</span><a href="#41813476">prev</a><span>|</span><a href="#41816873">next</a><span>|</span><label class="collapse" for="c-41814316">[-]</label><label class="expand" for="c-41814316">[2 more]</label></div><br/><div class="children"><div class="content">Gleam used to compile to Core Erlang (Erlang Intermediate Representation) but looks like it now compiles to pretty-printed Erlang.<p><a href="https:&#x2F;&#x2F;blog.lambdaclass.com&#x2F;an-interview-with-the-creator-of-gleam-an-ml-like-language-for-the-erlang-vm-with-a-compiler&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.lambdaclass.com&#x2F;an-interview-with-the-creator-o...</a></div><br/><div id="41815123" class="c"><input type="checkbox" id="c-41815123" checked=""/><div class="controls bullet"><span class="by">Alupis</span><span>|</span><a href="#41813356">root</a><span>|</span><a href="#41814316">parent</a><span>|</span><a href="#41816873">next</a><span>|</span><label class="collapse" for="c-41815123">[-]</label><label class="expand" for="c-41815123">[1 more]</label></div><br/><div class="children"><div class="content">The relevant quote:<p>&gt; The Gleam compiler has had a few full rewrites. The previous version compiled to BEAM bytecode via Core Erlang, which is an intermediate representation with the Erlang compiler, but the current version compiles to regular Erlang source code that has been pretty-printed. This has a few nice advantages such as providing an escape hatch for people who no longer wish to use Gleam, and enabling Erlang&#x2F;Elixir&#x2F;etc projects to use libraries written in Gleam without having to install the Gleam compiler.<p>Pretty good reasoning in my opinion.</div><br/></div></div></div></div><div id="41816873" class="c"><input type="checkbox" id="c-41816873" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#41813356">parent</a><span>|</span><a href="#41814316">prev</a><span>|</span><a href="#41813844">next</a><span>|</span><label class="collapse" for="c-41816873">[-]</label><label class="expand" for="c-41816873">[2 more]</label></div><br/><div class="children"><div class="content">Yes, unfortunately transpilation comes with real downsides. Up until recently, logger events, error messages and stacktraces were displayed in Erlang formatting. It has improved in few cases, but not all, and the line numbers in stacktraces do not align with the source code. And if you want to use a REPL, you must use Erlang&#x2F;JS ones, etc.</div><br/><div id="41817528" class="c"><input type="checkbox" id="c-41817528" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#41813356">root</a><span>|</span><a href="#41816873">parent</a><span>|</span><a href="#41813844">next</a><span>|</span><label class="collapse" for="c-41817528">[-]</label><label class="expand" for="c-41817528">[1 more]</label></div><br/><div class="children"><div class="content">Although if you want to get into Erlang&#x2F;BEAM and static types are a requirement, I still strongly recommend checking it out. :)</div><br/></div></div></div></div><div id="41813844" class="c"><input type="checkbox" id="c-41813844" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41813356">parent</a><span>|</span><a href="#41816873">prev</a><span>|</span><a href="#41813905">next</a><span>|</span><label class="collapse" for="c-41813844">[-]</label><label class="expand" for="c-41813844">[1 more]</label></div><br/><div class="children"><div class="content">It makes perfect sense to target erlang and not BEAM directly as allows erlang compiler to optimize the code for the newer BEAM runtime with newer fancier opcodes.</div><br/></div></div></div></div><div id="41815416" class="c"><input type="checkbox" id="c-41815416" checked=""/><div class="controls bullet"><span class="by">jeremy_k</span><span>|</span><a href="#41813356">prev</a><span>|</span><a href="#41813317">next</a><span>|</span><label class="collapse" for="c-41815416">[-]</label><label class="expand" for="c-41815416">[1 more]</label></div><br/><div class="children"><div class="content">Gleam has been great as I&#x27;ve started messing around with it recently. Coming from primarily Ruby, it feels much different and I&#x27;m liking expanding my thought process around programming. I&#x27;m struggling a bit with learning how to think in the type system though. Without unions and a requirement that case statements all return a single type, I just haven&#x27;t quite grasped the right pattern to make it all click. Enjoying the process none the less.</div><br/></div></div><div id="41813317" class="c"><input type="checkbox" id="c-41813317" checked=""/><div class="controls bullet"><span class="by">systems</span><span>|</span><a href="#41815416">prev</a><span>|</span><a href="#41816786">next</a><span>|</span><label class="collapse" for="c-41813317">[-]</label><label class="expand" for="c-41813317">[18 more]</label></div><br/><div class="children"><div class="content">the gleam tour is also very good <a href="https:&#x2F;&#x2F;tour.gleam.run&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tour.gleam.run&#x2F;</a><p>very very good</div><br/><div id="41813587" class="c"><input type="checkbox" id="c-41813587" checked=""/><div class="controls bullet"><span class="by">xorvoid</span><span>|</span><a href="#41813317">parent</a><span>|</span><a href="#41816786">next</a><span>|</span><label class="collapse" for="c-41813587">[-]</label><label class="expand" for="c-41813587">[17 more]</label></div><br/><div class="children"><div class="content">From the tutorial:<p>&#x2F;&#x2F; Division by zero is not an error<p>io.debug(3.14 &#x2F;. 0.0)<p>It prints 0<p>Yuck. Division by zero is an unfortunate reality but basically nobody with mathematical background thinks that just defining x&#x2F;0 = 0 is a good solution.<p>Often in numerical computing, getting an NaN or Inf is a blessing in that it’s a hint that your algorithm is numerically buggy, in the same way that a crash or a exception would indicate a program bug.<p>This approach is the numeric equivalent of a program continuing on after an undefined variable, just assuming it’s 0. That was tried by scripting languages in the 90s and these days most folks think it was a bad approach.</div><br/><div id="41814041" class="c"><input type="checkbox" id="c-41814041" checked=""/><div class="controls bullet"><span class="by">Alupis</span><span>|</span><a href="#41813317">root</a><span>|</span><a href="#41813587">parent</a><span>|</span><a href="#41814085">next</a><span>|</span><label class="collapse" for="c-41814041">[-]</label><label class="expand" for="c-41814041">[2 more]</label></div><br/><div class="children"><div class="content">The divide-by-zero thing is explained here[1]. The relevant bits:<p>&gt; Gleam does not implicitly throw exceptions, so throwing an exception is not an option. The BEAM VM does not have a Infinity value, so that is not an option. Therefore Gleam returns 0 when dividing by zero.<p>&gt; The standard library provides functions which return a Result type for division by zero which you can use if that is more suitable for your program.<p>You can also use Guards[2] to prevent handle a divide-by-zero situation before you attempt it.<p>[1] <a href="https:&#x2F;&#x2F;gleam.run&#x2F;frequently-asked-questions&#x2F;#why-does-division-by-zero-return-zero" rel="nofollow">https:&#x2F;&#x2F;gleam.run&#x2F;frequently-asked-questions&#x2F;#why-does-divis...</a><p>[2] <a href="https:&#x2F;&#x2F;tour.gleam.run&#x2F;everything&#x2F;#flow-control-guards" rel="nofollow">https:&#x2F;&#x2F;tour.gleam.run&#x2F;everything&#x2F;#flow-control-guards</a></div><br/><div id="41816992" class="c"><input type="checkbox" id="c-41816992" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#41813317">root</a><span>|</span><a href="#41814041">parent</a><span>|</span><a href="#41814085">next</a><span>|</span><label class="collapse" for="c-41816992">[-]</label><label class="expand" for="c-41816992">[1 more]</label></div><br/><div class="children"><div class="content">I know you are quoting the docs, but Gleam absolutely throws implicit exceptions, for exactly the same reason why it returns 0 when dividing: the Erlang&#x2F;VM does not support Infinity&#x2F;NaN, which means floating point operations can also overflow&#x2F;underflow. For example, any division with a subnormal will raise:<p><pre><code>    1.0 &#x2F;. 5.0e-324
</code></pre>
Or addition between really large floats:<p><pre><code>    1.0e308 +. 1.0e308
</code></pre>
In fact, even the `float.divide` function, which is meant to be safe, will raise:<p><pre><code>    float.divide(1.0, 5.0e-324)
</code></pre>
In other words, most functions that returns floats have an unmapped codomain and because of how floats work, and it is not simply a matter of checking if one of the inputs is equal to 0.0.<p>If Gleam wants to be consistent with division, all float operations would have to return a `Result` type (which I assume would have a direct impact in both performance and user convenience). Plus `let assert` provides a hatch for any function to raise too, and that includes matching on unmapped floats:<p><pre><code>    let assert &lt;&lt;a:float&gt;&gt; = &lt;&lt;0x7FF0000000000000:64&gt;&gt;</code></pre></div><br/></div></div></div></div><div id="41814085" class="c"><input type="checkbox" id="c-41814085" checked=""/><div class="controls bullet"><span class="by">Ndymium</span><span>|</span><a href="#41813317">root</a><span>|</span><a href="#41813587">parent</a><span>|</span><a href="#41814041">prev</a><span>|</span><a href="#41814501">next</a><span>|</span><label class="collapse" for="c-41814085">[-]</label><label class="expand" for="c-41814085">[2 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t call myself a person with a mathematical background, but there are those people who believe it&#x27;s just fine. [0] I don&#x27;t have enough knowledge to debate that, but it would seem to disprove &quot;basically nobody&quot;. Zero is a convention, like NaN or Inf are conventions.<p>A problem that Gleam has here is that the Erlang runtime does not have NaN or Inf in its float type (or integer type for that matter). It could be represented with an atom, but that would require an atom and a float having the same type in Gleam, which is not something the type system can do (by design). The operator could, in theory, return a Result(Float, DivisionByZeroError), but that would make using it very inconvenient. Thus zero was chosen, and there is an equivalent function in the stdlib that returns a result instead, if you wish to check for division by zero.<p>[0] <a href="https:&#x2F;&#x2F;www.hillelwayne.com&#x2F;post&#x2F;divide-by-zero&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.hillelwayne.com&#x2F;post&#x2F;divide-by-zero&#x2F;</a></div><br/><div id="41815844" class="c"><input type="checkbox" id="c-41815844" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41813317">root</a><span>|</span><a href="#41814085">parent</a><span>|</span><a href="#41814501">next</a><span>|</span><label class="collapse" for="c-41815844">[-]</label><label class="expand" for="c-41815844">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but there are those people who believe it&#x27;s just fine. [0]<p>Just fine mathematically, but Hillel does specify that he&#x27;s not comfortable with the concept from a safety perspective. The whole piece is a defence against a particular type of criticism, but he leaves wide open the question of whether it&#x27;s a good idea from a PL perspective.</div><br/></div></div></div></div><div id="41814501" class="c"><input type="checkbox" id="c-41814501" checked=""/><div class="controls bullet"><span class="by">Fire-Dragon-DoL</span><span>|</span><a href="#41813317">root</a><span>|</span><a href="#41813587">parent</a><span>|</span><a href="#41814085">prev</a><span>|</span><a href="#41814683">next</a><span>|</span><label class="collapse" for="c-41814501">[-]</label><label class="expand" for="c-41814501">[5 more]</label></div><br/><div class="children"><div class="content">I have no math background but every line of code I wrote that involved a division, I just wished that division by 0 results in 0, so this actually resonated with me</div><br/><div id="41816046" class="c"><input type="checkbox" id="c-41816046" checked=""/><div class="controls bullet"><span class="by">beanjuiceII</span><span>|</span><a href="#41813317">root</a><span>|</span><a href="#41814501">parent</a><span>|</span><a href="#41814683">next</a><span>|</span><label class="collapse" for="c-41816046">[-]</label><label class="expand" for="c-41816046">[4 more]</label></div><br/><div class="children"><div class="content">why? if 0 was getting divided with i would want to know otherwise i&#x27;ll be using wrong calculations</div><br/><div id="41816129" class="c"><input type="checkbox" id="c-41816129" checked=""/><div class="controls bullet"><span class="by">Fire-Dragon-DoL</span><span>|</span><a href="#41813317">root</a><span>|</span><a href="#41816046">parent</a><span>|</span><a href="#41814683">next</a><span>|</span><label class="collapse" for="c-41816129">[-]</label><label class="expand" for="c-41816129">[3 more]</label></div><br/><div class="children"><div class="content">Because &quot;0&quot; often means &quot;show none&quot;, so when dividing by 0, I&#x27;m fine &quot;showing none&quot;.<p>I&#x27;m sure it doesn&#x27;t work for everybody, but I never had a specific need to deal with zero in the division that didn&#x27;t result with &quot;actually let&#x27;s count it as 0&quot;</div><br/><div id="41817113" class="c"><input type="checkbox" id="c-41817113" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#41813317">root</a><span>|</span><a href="#41816129">parent</a><span>|</span><a href="#41814683">next</a><span>|</span><label class="collapse" for="c-41817113">[-]</label><label class="expand" for="c-41817113">[2 more]</label></div><br/><div class="children"><div class="content">There are several domains where 0 is different from none, for example, most computations involving rates.<p>Imagine that you are running some A&#x2F;B tests and you want to track conversions. If one of the experiments received 10 users and had 5 conversions, you want to show 50%. If it received 10 users and had no conversions, you will show 0%.<p>However, if it has received 0 users, while you could show zero conversions, the correct answer is to say that you don&#x27;t know the conversion rate. Because maybe, if you had had 10 users, they could have all converted, and the rate would be 100%. You simply don&#x27;t know.<p>Same logic applies over computing ROI, interest, velocity, etc.</div><br/><div id="41817188" class="c"><input type="checkbox" id="c-41817188" checked=""/><div class="controls bullet"><span class="by">Fire-Dragon-DoL</span><span>|</span><a href="#41813317">root</a><span>|</span><a href="#41817113">parent</a><span>|</span><a href="#41814683">next</a><span>|</span><label class="collapse" for="c-41817188">[-]</label><label class="expand" for="c-41817188">[1 more]</label></div><br/><div class="children"><div class="content">Agree, I&#x27;m not saying there aren&#x27;t counter examples, I&#x27;m just stating that making the call of returning zero when dividing by zero it&#x27;s not an insane call, there are valid reasons for doing that. It&#x27;s a judgement call (and they do provide a function that does the right thing)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41814683" class="c"><input type="checkbox" id="c-41814683" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#41813317">root</a><span>|</span><a href="#41813587">parent</a><span>|</span><a href="#41814501">prev</a><span>|</span><a href="#41814291">next</a><span>|</span><label class="collapse" for="c-41814683">[-]</label><label class="expand" for="c-41814683">[5 more]</label></div><br/><div class="children"><div class="content">Regardless of what happens in the language, this needs to be handled.<p>In python for instance, the developer needs to be prepared to catch a divide by zero exception.<p>In gleam, the same consideration is required but the implementation will just differ.<p>I don&#x27;t actually see an issue here. It&#x27;s a potential gotcha, but once you are aware of this feature of the language, it&#x27;s no different than any other.</div><br/><div id="41815327" class="c"><input type="checkbox" id="c-41815327" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41813317">root</a><span>|</span><a href="#41814683">parent</a><span>|</span><a href="#41814955">next</a><span>|</span><label class="collapse" for="c-41815327">[-]</label><label class="expand" for="c-41815327">[3 more]</label></div><br/><div class="children"><div class="content">&gt; In python for instance, the developer needs to be prepared to catch a divide by zero exception.<p>&gt; In gleam, the same consideration is required but the implementation will just differ.<p>These aren&#x27;t remotely the same. If a developer fails to catch an exception or a NaN then the program either crashes or returns an obviously wrong result. If a developer fails to guard against a zero returned from division then they get a number out that&#x27;s wrong in subtle ways that may not be obvious until the wrong numbers are already in use somehow.<p>The question isn&#x27;t whether you can work around the error, it&#x27;s how likely you are to notice that you screwed something up before it&#x27;s too late.</div><br/><div id="41816050" class="c"><input type="checkbox" id="c-41816050" checked=""/><div class="controls bullet"><span class="by">beanjuiceII</span><span>|</span><a href="#41813317">root</a><span>|</span><a href="#41815327">parent</a><span>|</span><a href="#41814955">next</a><span>|</span><label class="collapse" for="c-41816050">[-]</label><label class="expand" for="c-41816050">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m with you on this for sure, seems dangerous to just use 0 how will anyone know something is going wrong?</div><br/><div id="41816617" class="c"><input type="checkbox" id="c-41816617" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#41813317">root</a><span>|</span><a href="#41816050">parent</a><span>|</span><a href="#41814955">next</a><span>|</span><label class="collapse" for="c-41816617">[-]</label><label class="expand" for="c-41816617">[1 more]</label></div><br/><div class="children"><div class="content">No it&#x27;s fine.  The 0 will just propagate to other divide by zeros and you&#x27;ll always have an answer, so it&#x27;s all good.</div><br/></div></div></div></div></div></div><div id="41814955" class="c"><input type="checkbox" id="c-41814955" checked=""/><div class="controls bullet"><span class="by">miki123211</span><span>|</span><a href="#41813317">root</a><span>|</span><a href="#41814683">parent</a><span>|</span><a href="#41815327">prev</a><span>|</span><a href="#41814291">next</a><span>|</span><label class="collapse" for="c-41814955">[-]</label><label class="expand" for="c-41814955">[1 more]</label></div><br/><div class="children"><div class="content">No.<p>In Python and languages with similar behavior, a division by 0 will immediately crash your program with a pretty stack trace, showing you exactly where the problem is and how the program got there.<p>In languages where division by 0 produces infinity, NaN, 0 or similar, your calculation just returns a nonsensical result.<p>Zero is even worse than inf or NaN, as you may not even realize that there was an error in the first place, as the result of your calculation is a number and not a strange-looking value.</div><br/></div></div></div></div><div id="41814291" class="c"><input type="checkbox" id="c-41814291" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#41813317">root</a><span>|</span><a href="#41813587">parent</a><span>|</span><a href="#41814683">prev</a><span>|</span><a href="#41813862">next</a><span>|</span><label class="collapse" for="c-41814291">[-]</label><label class="expand" for="c-41814291">[1 more]</label></div><br/><div class="children"><div class="content">Yeah you can really get yourself into trouble if you make dividing by zero zero.  It&#x27;s a strong indication that you have done something horribly wrong in your code upstream of that point.  Why would you throw away that signal?</div><br/></div></div><div id="41813862" class="c"><input type="checkbox" id="c-41813862" checked=""/><div class="controls bullet"><span class="by">Buttons840</span><span>|</span><a href="#41813317">root</a><span>|</span><a href="#41813587">parent</a><span>|</span><a href="#41814291">prev</a><span>|</span><a href="#41816786">next</a><span>|</span><label class="collapse" for="c-41813862">[-]</label><label class="expand" for="c-41813862">[1 more]</label></div><br/><div class="children"><div class="content">INTERCAL. It just skips lines if they&#x27;re syntactically invalid or cause a runtime error; it just skips them and keeps going.</div><br/></div></div></div></div></div></div><div id="41816786" class="c"><input type="checkbox" id="c-41816786" checked=""/><div class="controls bullet"><span class="by">asplake</span><span>|</span><a href="#41813317">prev</a><span>|</span><a href="#41815239">next</a><span>|</span><label class="collapse" for="c-41816786">[-]</label><label class="expand" for="c-41816786">[2 more]</label></div><br/><div class="children"><div class="content">“Gleam is a statically-typed language, meaning you must declare the type of a variable before using it.”<p>That second part is wrong. Gleam has type inference.</div><br/><div id="41816965" class="c"><input type="checkbox" id="c-41816965" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#41816786">parent</a><span>|</span><a href="#41815239">next</a><span>|</span><label class="collapse" for="c-41816965">[-]</label><label class="expand" for="c-41816965">[1 more]</label></div><br/><div class="children"><div class="content">In the era of type checkers for dynamic languages, it might be better to write<p>&gt; Gleam is a statically-typed language, meaning if you declare the type of a variable before using it, that will actually do something.<p>:)</div><br/></div></div></div></div><div id="41815239" class="c"><input type="checkbox" id="c-41815239" checked=""/><div class="controls bullet"><span class="by">floodfx</span><span>|</span><a href="#41816786">prev</a><span>|</span><a href="#41816377">next</a><span>|</span><label class="collapse" for="c-41815239">[-]</label><label class="expand" for="c-41815239">[1 more]</label></div><br/><div class="children"><div class="content">I like the look of Gleam over Elixir for sure. I’d love to see some example code showing Gleam-based LiveViews but I haven’t been able to find it anywhere. Is it possible?  Anyone have some code to point me at?</div><br/></div></div><div id="41816377" class="c"><input type="checkbox" id="c-41816377" checked=""/><div class="controls bullet"><span class="by">vivzkestrel</span><span>|</span><a href="#41815239">prev</a><span>|</span><a href="#41814458">next</a><span>|</span><label class="collapse" for="c-41816377">[-]</label><label class="expand" for="c-41816377">[1 more]</label></div><br/><div class="children"><div class="content">golang concurrency vs gleam concurrency vs rust concurrency? for a webserver?</div><br/></div></div><div id="41814458" class="c"><input type="checkbox" id="c-41814458" checked=""/><div class="controls bullet"><span class="by">written-beyond</span><span>|</span><a href="#41816377">prev</a><span>|</span><a href="#41816342">next</a><span>|</span><label class="collapse" for="c-41814458">[-]</label><label class="expand" for="c-41814458">[7 more]</label></div><br/><div class="children"><div class="content">I honestly gave gleam a serious look, considering it to build a system that might really benefit from it&#x27;s concurrency model. However the lack of Macros&#x2F;macro-style reflection capabilities really put me off. It makes working with SQL databases needlessly verbose. It&#x27;s the same with go, though go posses the capabilities to directly unmarshal SQL rows into a structure with tags, it&#x27;s far from straightforward.</div><br/><div id="41814752" class="c"><input type="checkbox" id="c-41814752" checked=""/><div class="controls bullet"><span class="by">Alupis</span><span>|</span><a href="#41814458">parent</a><span>|</span><a href="#41816342">next</a><span>|</span><label class="collapse" for="c-41814752">[-]</label><label class="expand" for="c-41814752">[6 more]</label></div><br/><div class="children"><div class="content">This is the sentiment many have when transitioning from OOP -&gt; FP paradigms.<p>That&#x27;s not to say ORM&#x27;s don&#x27;t exist in FP, but they are not nearly as common because their concept doesn&#x27;t directly translate into what you expect from a functional language.<p>That is to say this is not a Gleam problem, it is a FP problem, if we can even call it a problem (it&#x27;s mostly just different).</div><br/><div id="41815138" class="c"><input type="checkbox" id="c-41815138" checked=""/><div class="controls bullet"><span class="by">written-beyond</span><span>|</span><a href="#41814458">root</a><span>|</span><a href="#41814752">parent</a><span>|</span><a href="#41814847">next</a><span>|</span><label class="collapse" for="c-41815138">[-]</label><label class="expand" for="c-41815138">[2 more]</label></div><br/><div class="children"><div class="content">There are two ways to understand your reply, one is that you&#x27;re talking ORMs that provide query building as an alternative to writing raw SQL. The other is you&#x27;re talking just about the deserialisation into structures.<p>If what you meant was the first one then, no I&#x27;m not expecting anything like that. I honestly like using a language that gets off of the way and let&#x27;s me focus on what I want to build. I&#x27;ve done very little OOP and I&#x27;ve written a lot of Rust. There are many situations where I feel like r rusts verbosity is limiting my freedom but the grind of unmarshaling hashmaps into structures is way too much for me. Why shouldn&#x27;t I want to use my languages typing support to help me write more maintainable code?<p>I can hardly get over how dart sometimes outright refuses to cast Object types to dynamic types without some syntactical voodoo.</div><br/><div id="41815238" class="c"><input type="checkbox" id="c-41815238" checked=""/><div class="controls bullet"><span class="by">Alupis</span><span>|</span><a href="#41814458">root</a><span>|</span><a href="#41815138">parent</a><span>|</span><a href="#41814847">next</a><span>|</span><label class="collapse" for="c-41815238">[-]</label><label class="expand" for="c-41815238">[1 more]</label></div><br/><div class="children"><div class="content">You might be interested in looking at the Squirrel library for Gleam[1]. It kind of reverses the SQL problem in a very nice, elegant way I&#x27;ve found. It gets rid of some of the issues you are bringing up, which are quite valid.<p>[1] <a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;squirrel&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hexdocs.pm&#x2F;squirrel&#x2F;</a></div><br/></div></div></div></div><div id="41814847" class="c"><input type="checkbox" id="c-41814847" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#41814458">root</a><span>|</span><a href="#41814752">parent</a><span>|</span><a href="#41815138">prev</a><span>|</span><a href="#41816475">next</a><span>|</span><label class="collapse" for="c-41814847">[-]</label><label class="expand" for="c-41814847">[2 more]</label></div><br/><div class="children"><div class="content">Lisp and elixir, Julia are all fps with macros?  Hell even Erlang has macros</div><br/><div id="41814997" class="c"><input type="checkbox" id="c-41814997" checked=""/><div class="controls bullet"><span class="by">Alupis</span><span>|</span><a href="#41814458">root</a><span>|</span><a href="#41814847">parent</a><span>|</span><a href="#41816475">next</a><span>|</span><label class="collapse" for="c-41814997">[-]</label><label class="expand" for="c-41814997">[1 more]</label></div><br/><div class="children"><div class="content">I was speaking to the ORM situation, or lack-thereof the parent seemed to be expressing.<p>Regarding macros - Gleam has stated they are interested in adding metaprogramming, but it&#x27;s not a huge priority because of the goals of the language.<p>Macros, and metaprogramming in general have a tendency to complicate a language, and encourages ad-hoc DSL&#x27;s. One of Gleam&#x27;s goals is to be dead simple to pick up, read, and contribute - metaprogramming makes that much harder.<p>Macros are not necessary, even if their absence is a bit of a shock at first. I used to firmly think they were necessary, but now my mind has changed on this for the most part.</div><br/></div></div></div></div><div id="41816475" class="c"><input type="checkbox" id="c-41816475" checked=""/><div class="controls bullet"><span class="by">lawn</span><span>|</span><a href="#41814458">root</a><span>|</span><a href="#41814752">parent</a><span>|</span><a href="#41814847">prev</a><span>|</span><a href="#41816342">next</a><span>|</span><label class="collapse" for="c-41816475">[-]</label><label class="expand" for="c-41816475">[1 more]</label></div><br/><div class="children"><div class="content">Nah this is wrong. Ecto for Elixir is a big counterexample.<p>You&#x27;re focused on OO ORMs as the way to simplify working with queries, but FP approaches it slightly differently.</div><br/></div></div></div></div></div></div><div id="41816342" class="c"><input type="checkbox" id="c-41816342" checked=""/><div class="controls bullet"><span class="by">pipeline_peak</span><span>|</span><a href="#41814458">prev</a><span>|</span><a href="#41814258">next</a><span>|</span><label class="collapse" for="c-41816342">[-]</label><label class="expand" for="c-41816342">[4 more]</label></div><br/><div class="children"><div class="content">&gt; fn add(x: Int, y: Int) -&gt; Int<p>Why do language authors insist the majority of programmers want to type this way? Meaningless arrows and redundant colons.<p>Is it constructive, like it will lead us to think differently? It feels more like a contest in overcomplicating something as innocent as:<p>int add(int x, int y)</div><br/><div id="41816866" class="c"><input type="checkbox" id="c-41816866" checked=""/><div class="controls bullet"><span class="by">mcintyre1994</span><span>|</span><a href="#41816342">parent</a><span>|</span><a href="#41816353">next</a><span>|</span><label class="collapse" for="c-41816866">[-]</label><label class="expand" for="c-41816866">[1 more]</label></div><br/><div class="children"><div class="content">I think it’s because generally  the type annotations are optional and it’s much easier to parse that version. Typescript uses a colon instead of arrow for the return type so I think that’s just preference though.<p>In particular if you removed the types from yours it’d be add(x, y) and the parser wouldn’t be able to distinguish that from a function call. I think that’s why the fn keyword is really useful for the parser.</div><br/></div></div><div id="41816849" class="c"><input type="checkbox" id="c-41816849" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#41816342">parent</a><span>|</span><a href="#41816353">prev</a><span>|</span><a href="#41814258">next</a><span>|</span><label class="collapse" for="c-41816849">[-]</label><label class="expand" for="c-41816849">[1 more]</label></div><br/><div class="children"><div class="content">I think there&#x27;s a pretty good case for the arrow being easier to reason about especially with anonymous functions or if currying gets involved. The other way is lacking a &quot;verb&quot; and it becomes harder to keep track of what&#x27;s going on in some cases.<p>The arrow is also conventional in ML family languages, which are a venerable branch of programming whose traditions I respect and enjoy. That&#x27;s not enough reason alone to keep it maybe but it&#x27;s not nothing either.<p>The colon thing whatever, I truly just can&#x27;t bring myself to care about such fine-grained specifics of syntax. It sounds like a rough life honestly.</div><br/></div></div></div></div></div></div></div></div></div></body></html>