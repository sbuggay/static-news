<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685264459835" as="style"/><link rel="stylesheet" href="styles.css?v=1685264459835"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://httpwg.org/http-extensions/draft-ietf-httpbis-safe-method-w-body.html">The HTTP QUERY Method specification</a> <span class="domain">(<a href="https://httpwg.org">httpwg.org</a>)</span></div><div class="subtext"><span>andyk</span> | <span>72 comments</span></div><br/><div><div id="36102087" class="c"><input type="checkbox" id="c-36102087" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#36097753">next</a><span>|</span><label class="collapse" for="c-36102087">[-]</label><label class="expand" for="c-36102087">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Unlike POST, however, the method is explicitly safe and idempotent, allowing functions like caching and automatic retries to operate.<p>And just like with POST, whether or not this is actually the case in a given API, depends entirely on the server-side implementation.<p>Look, I get it. We want to make rules. Rules are good. Rules define things.<p>But in a world where so many &quot;REST APIs&quot; are actually &quot;RESTful&quot; or REST-ish, or <i>&quot;actually about as REST as a Pelican, but we really liked the sound of the acronym&quot;</i>, I wonder if adding one more rule to the pile is really going to substantially change anything.<p>A majority of APIs don&#x27;t even use all of the existing HTTP verbs, or HTTP response codes for that matter. And every API is free to make up their own rules. I had the dubious pleasure of consuming APIs that required GET with both a body and urlparams, and which returned 200 on error, but with an `{error: {...}}` object in the body. The crown jewel so far, was an authentication system that had me send credentials as multipart&#x2F;form-data, with a PUT request (because you inPUT the credentials, see? Not a joke, that was the rationale given to me by the dev who made it.)</div><br/><div id="36102269" class="c"><input type="checkbox" id="c-36102269" checked=""/><div class="controls bullet"><span class="by">silasdavis</span><span>|</span><a href="#36102087">parent</a><span>|</span><a href="#36102281">next</a><span>|</span><label class="collapse" for="c-36102269">[-]</label><label class="expand" for="c-36102269">[2 more]</label></div><br/><div class="children"><div class="content">If you control both ends of the pipe you are free to use the methods and conventions and maybe benefit when something gets cached.<p>That you cannot rely on consistency is not a reason to have none at all.<p>Destructive actions can and are also hidden behind a GET. When such an endpoint gets called indiscriminately by the rest of the internet it  usually becomes the faulty implementation&#x27;s problem.<p>Presumably the same would be true for QUERY.</div><br/><div id="36102310" class="c"><input type="checkbox" id="c-36102310" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#36102087">root</a><span>|</span><a href="#36102269">parent</a><span>|</span><a href="#36102281">next</a><span>|</span><label class="collapse" for="c-36102310">[-]</label><label class="expand" for="c-36102310">[1 more]</label></div><br/><div class="children"><div class="content"><i>If</i> I control both ends. And <i>if</i> the server side is not a legacy application that no resources get expended on to fix something that isn&#x27;t broken.<p>Those are 2 very big if&#x27;s.<p>&gt; That you cannot rely on consistency is not a reason to have none at all.<p>I want consistency. I stated as much in my post: <i>&quot;Rules are good.&quot;</i> I&#x27;m just not convinced adding more rules to a collection of rules that already isn&#x27;t consistently applied in the wild, will give me more consistency.</div><br/></div></div></div></div><div id="36102281" class="c"><input type="checkbox" id="c-36102281" checked=""/><div class="controls bullet"><span class="by">plugin-baby</span><span>|</span><a href="#36102087">parent</a><span>|</span><a href="#36102269">prev</a><span>|</span><a href="#36097753">next</a><span>|</span><label class="collapse" for="c-36102281">[-]</label><label class="expand" for="c-36102281">[1 more]</label></div><br/><div class="children"><div class="content">People try to apply rules. REST may sometimes make sense, but much of the time it’s probably simplest and most consistent to JUP - Just Use POST.</div><br/></div></div></div></div><div id="36097753" class="c"><input type="checkbox" id="c-36097753" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36102087">prev</a><span>|</span><a href="#36096368">next</a><span>|</span><label class="collapse" for="c-36097753">[-]</label><label class="expand" for="c-36097753">[20 more]</label></div><br/><div class="children"><div class="content">I see the need, and good write up, but just use this for the definition of GET body.<p>Nothing in the existing spec prevents GET from having a body, though there isn&#x27;t currently a semantic meaning to it.<p>This would fit perfectly, be more compatible and result in a simpler spec and protocol.</div><br/><div id="36098395" class="c"><input type="checkbox" id="c-36098395" checked=""/><div class="controls bullet"><span class="by">lozenge</span><span>|</span><a href="#36097753">parent</a><span>|</span><a href="#36098342">next</a><span>|</span><label class="collapse" for="c-36098395">[-]</label><label class="expand" for="c-36098395">[8 more]</label></div><br/><div class="children"><div class="content">Despite the spec, a lot of clients, load balancers, and server libraries can&#x27;t handle GET with a body.</div><br/><div id="36099367" class="c"><input type="checkbox" id="c-36099367" checked=""/><div class="controls bullet"><span class="by">silverwind</span><span>|</span><a href="#36097753">root</a><span>|</span><a href="#36098395">parent</a><span>|</span><a href="#36101078">next</a><span>|</span><label class="collapse" for="c-36099367">[-]</label><label class="expand" for="c-36099367">[4 more]</label></div><br/><div class="children"><div class="content">They won&#x27;t support a new method either.</div><br/><div id="36100065" class="c"><input type="checkbox" id="c-36100065" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#36097753">root</a><span>|</span><a href="#36099367">parent</a><span>|</span><a href="#36101078">next</a><span>|</span><label class="collapse" for="c-36100065">[-]</label><label class="expand" for="c-36100065">[3 more]</label></div><br/><div class="children"><div class="content">But it being an unsupported method will hopefully at least cause the middlebox to generate a 405 error, rather than undefined behavior.</div><br/><div id="36101893" class="c"><input type="checkbox" id="c-36101893" checked=""/><div class="controls bullet"><span class="by">water9</span><span>|</span><a href="#36097753">root</a><span>|</span><a href="#36100065">parent</a><span>|</span><a href="#36101078">next</a><span>|</span><label class="collapse" for="c-36101893">[-]</label><label class="expand" for="c-36101893">[2 more]</label></div><br/><div class="children"><div class="content">Rather than a 400 error?</div><br/><div id="36102184" class="c"><input type="checkbox" id="c-36102184" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#36097753">root</a><span>|</span><a href="#36101893">parent</a><span>|</span><a href="#36101078">next</a><span>|</span><label class="collapse" for="c-36102184">[-]</label><label class="expand" for="c-36102184">[1 more]</label></div><br/><div class="children"><div class="content">No, rather than the body being silently ignored in the caching (or even proxying!) logic of some middleboxes, because &quot;since GET will never have a body, for efficiency, we won&#x27;t bother to check for one.&quot;</div><br/></div></div></div></div></div></div></div></div><div id="36101078" class="c"><input type="checkbox" id="c-36101078" checked=""/><div class="controls bullet"><span class="by">sarthak-ag</span><span>|</span><a href="#36097753">root</a><span>|</span><a href="#36098395">parent</a><span>|</span><a href="#36099367">prev</a><span>|</span><a href="#36101824">next</a><span>|</span><label class="collapse" for="c-36101078">[-]</label><label class="expand" for="c-36101078">[1 more]</label></div><br/><div class="children"><div class="content">Yet, given enough demand, and a explicit recommending nod from the spec, these will comply. It&#x27;s not really as big as problem as everyone seems to think. And it&#x27;s literally the same amount of work of adding a new verb.</div><br/></div></div><div id="36100841" class="c"><input type="checkbox" id="c-36100841" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#36097753">root</a><span>|</span><a href="#36098395">parent</a><span>|</span><a href="#36101824">prev</a><span>|</span><a href="#36098342">next</a><span>|</span><label class="collapse" for="c-36100841">[-]</label><label class="expand" for="c-36100841">[1 more]</label></div><br/><div class="children"><div class="content">Which is somewhat surprising given that it is common enough that I&#x27;ve come across it several times in the wild.<p>So much so that I added support for it to my own server and client libraries. Which means that adding support for QUERY will be trivial (yay!)<p>As an aside, I also support DELETE with a body.</div><br/></div></div></div></div><div id="36098342" class="c"><input type="checkbox" id="c-36098342" checked=""/><div class="controls bullet"><span class="by">cientifico</span><span>|</span><a href="#36097753">parent</a><span>|</span><a href="#36098395">prev</a><span>|</span><a href="#36097801">next</a><span>|</span><label class="collapse" for="c-36098342">[-]</label><label class="expand" for="c-36098342">[5 more]</label></div><br/><div class="children"><div class="content">Caching the body scares the hell out of me.<p>If the params for the search are so many or so big that they don&#x27;t fit in a single url, how could you use that as a cache key?<p>Right now you can:<p>* Pass the arguments as parameters<p>* Pass them on the request body. I personally done it on apis for games in unity&#x2F;ios&#x2F;android for almost a decade). Other products like Elasticsearch count on that as part of the core product.<p>* Semantically create searches in the server with POST &#x2F;search<p>In the previous two examples, you can return a redirect to the search results (like &#x2F;searches&#x2F;33) with perfect caching&#x2F;indexing, and delegate to the server the cache algorithms.<p>With things like Vary, Etags, Conditional fetchs, Content-Encoding, Content-Type, Cache-Control, Expires that the spec barely grasp, adding a huge body is something that a cache server&#x2F;cdn will not implement.<p>So again. What is this spec solving?</div><br/><div id="36098518" class="c"><input type="checkbox" id="c-36098518" checked=""/><div class="controls bullet"><span class="by">thwarted</span><span>|</span><a href="#36097753">root</a><span>|</span><a href="#36098342">parent</a><span>|</span><a href="#36101837">next</a><span>|</span><label class="collapse" for="c-36098518">[-]</label><label class="expand" for="c-36098518">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If the params for the search are so many or so big that they don&#x27;t fit in a single url, how could you use that as a cache key?<p>The way many caching systems work, by hashing the body and using the hash as the cache key.</div><br/><div id="36100208" class="c"><input type="checkbox" id="c-36100208" checked=""/><div class="controls bullet"><span class="by">ezekg</span><span>|</span><a href="#36097753">root</a><span>|</span><a href="#36098518">parent</a><span>|</span><a href="#36101837">next</a><span>|</span><label class="collapse" for="c-36100208">[-]</label><label class="expand" for="c-36100208">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely. I would not recommend using raw search terms as a cache key. Good way to a) leak cache data unintentionally if an attacker were to guess at other cache keys (given the cache keys were not namespaced well), and b) leak user search terms (and users often search for some weird stuff including passwords).</div><br/></div></div></div></div><div id="36101837" class="c"><input type="checkbox" id="c-36101837" checked=""/><div class="controls bullet"><span class="by">cdogl</span><span>|</span><a href="#36097753">root</a><span>|</span><a href="#36098342">parent</a><span>|</span><a href="#36098518">prev</a><span>|</span><a href="#36101646">next</a><span>|</span><label class="collapse" for="c-36101837">[-]</label><label class="expand" for="c-36101837">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If the params for the search are so many or so big that they don&#x27;t fit in a single url, how could you use that as a cache key?<p>I think the horse has bolted here. With HTTP&#x2F;2 (and often without), URLs can be _very_ long.</div><br/></div></div><div id="36101646" class="c"><input type="checkbox" id="c-36101646" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#36097753">root</a><span>|</span><a href="#36098342">parent</a><span>|</span><a href="#36101837">prev</a><span>|</span><a href="#36097801">next</a><span>|</span><label class="collapse" for="c-36101646">[-]</label><label class="expand" for="c-36101646">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why they&#x27;re caching the body of requests with a new method.<p>New and clearly distinct type of requests, new practices.<p>It isn&#x27;t just the size of the request that makes people not want to put them in the query string, it&#x27;s use of the query string over decades.</div><br/></div></div></div></div><div id="36097801" class="c"><input type="checkbox" id="c-36097801" checked=""/><div class="controls bullet"><span class="by">rektide</span><span>|</span><a href="#36097753">parent</a><span>|</span><a href="#36098342">prev</a><span>|</span><a href="#36096368">next</a><span>|</span><label class="collapse" for="c-36097801">[-]</label><label class="expand" for="c-36097801">[6 more]</label></div><br/><div class="children"><div class="content">We&#x27;d have to change the behavior of browsers &amp; server implementations to do this. Itvs much less risky, much more managable change, to do this with a new more deliberate difference. It&#x27;ll make it clear that the new behavior is intended.</div><br/><div id="36098018" class="c"><input type="checkbox" id="c-36098018" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36097753">root</a><span>|</span><a href="#36097801">parent</a><span>|</span><a href="#36096368">next</a><span>|</span><label class="collapse" for="c-36098018">[-]</label><label class="expand" for="c-36098018">[5 more]</label></div><br/><div class="children"><div class="content">&gt; We&#x27;d have to change the behavior<p>But you wouldn&#x27;t for QUERY?<p>This is backwards compatible and in many cases will just work since GET with body is already syntactically valid.</div><br/><div id="36099431" class="c"><input type="checkbox" id="c-36099431" checked=""/><div class="controls bullet"><span class="by">treve</span><span>|</span><a href="#36097753">root</a><span>|</span><a href="#36098018">parent</a><span>|</span><a href="#36098091">next</a><span>|</span><label class="collapse" for="c-36099431">[-]</label><label class="expand" for="c-36099431">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But you wouldn&#x27;t for QUERY?<p>No, any good HTTP client or server allows unknown&#x2F;new HTTP methods. If they are not recognized, they are treated as POST. This is a requirement of the HTTP spec.<p>I&#x27;ve already used QUERY in a few places, and it basically universally <i>just works</i>. Adding a request body to GET would practically be much harder to deploy and depend on.<p>A few years ago PATCH was added, and back then there was a bit more friction with some HTTP implementations only allowing a fixed set of methods, but this is mostly not true anymore.</div><br/></div></div><div id="36098091" class="c"><input type="checkbox" id="c-36098091" checked=""/><div class="controls bullet"><span class="by">janderland</span><span>|</span><a href="#36097753">root</a><span>|</span><a href="#36098018">parent</a><span>|</span><a href="#36099431">prev</a><span>|</span><a href="#36098948">next</a><span>|</span><label class="collapse" for="c-36098091">[-]</label><label class="expand" for="c-36098091">[1 more]</label></div><br/><div class="children"><div class="content">I think they mean we’d have to modify existing features. There are probably assumptions made in code and tests around how GET will be used. Instead of breaking those assumptions and potentially implementing new bugs in an old feature, you can use a completely new HTTP method with completely new code paths. Older feature remains unchanged.</div><br/></div></div><div id="36098948" class="c"><input type="checkbox" id="c-36098948" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36097753">root</a><span>|</span><a href="#36098018">parent</a><span>|</span><a href="#36098091">prev</a><span>|</span><a href="#36098096">next</a><span>|</span><label class="collapse" for="c-36098948">[-]</label><label class="expand" for="c-36098948">[1 more]</label></div><br/><div class="children"><div class="content">middleboxes are free to drop the body of a GET request, and many do</div><br/></div></div><div id="36098096" class="c"><input type="checkbox" id="c-36098096" checked=""/><div class="controls bullet"><span class="by">rektide</span><span>|</span><a href="#36097753">root</a><span>|</span><a href="#36098018">parent</a><span>|</span><a href="#36098948">prev</a><span>|</span><a href="#36096368">next</a><span>|</span><label class="collapse" for="c-36098096">[-]</label><label class="expand" for="c-36098096">[1 more]</label></div><br/><div class="children"><div class="content">QUERY is an explicit negotiating forwards. It would need support, but nothing with existing systems would change. No web page which accidentally tried to send a http bodied GET would start having new behavior.</div><br/></div></div></div></div></div></div></div></div><div id="36096368" class="c"><input type="checkbox" id="c-36096368" checked=""/><div class="controls bullet"><span class="by">andyk</span><span>|</span><a href="#36097753">prev</a><span>|</span><a href="#36098079">next</a><span>|</span><label class="collapse" for="c-36096368">[-]</label><label class="expand" for="c-36096368">[1 more]</label></div><br/><div class="children"><div class="content">Saw this mentioned by @dragonwriter in the discussion at <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36095032" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36095032</a> but it seemed buried&#x2F;easy to miss there. Also the article that thread is discussing is from 2021, whereas this was just published yesterday.</div><br/></div></div><div id="36098079" class="c"><input type="checkbox" id="c-36098079" checked=""/><div class="controls bullet"><span class="by">bornfreddy</span><span>|</span><a href="#36096368">prev</a><span>|</span><a href="#36098019">next</a><span>|</span><label class="collapse" for="c-36098079">[-]</label><label class="expand" for="c-36098079">[8 more]</label></div><br/><div class="children"><div class="content">Requiring every proxy and web server to implement their own cache hashing algorithm, especially one that should ignore encoding-specific &quot;non-consequential&quot; parts, sounds like a monumentally bad idea.</div><br/><div id="36101812" class="c"><input type="checkbox" id="c-36101812" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#36098079">parent</a><span>|</span><a href="#36098584">next</a><span>|</span><label class="collapse" for="c-36101812">[-]</label><label class="expand" for="c-36101812">[2 more]</label></div><br/><div class="children"><div class="content">The part where a cache SHOULD have “<i>knowledge of the semantics of the content itself</i>” in combination with “<i>normalization is performed solely for the purpose of generating a cache key; it does not change the request itself</i>” is the scary part.<p>It may sound cool and efficient on paper, just trim the whitespace and sort all json dictionaries right? But in practice it adds too much complexity, eventually implementations of this semantics will start to drift between cache and real backend. Case in point: SAML XML signatures.<p>This is how one creates a cache poisoning vulnerability. If a request is normalized as a cache key, use the normalized request when sending to the backend also. If you don’t trust that process you shouldn’t trust it as the cache key either.<p>Proxies should be dumb, just hash the raw string for the cache key.</div><br/><div id="36102226" class="c"><input type="checkbox" id="c-36102226" checked=""/><div class="controls bullet"><span class="by">garganzol</span><span>|</span><a href="#36098079">root</a><span>|</span><a href="#36101812">parent</a><span>|</span><a href="#36098584">next</a><span>|</span><label class="collapse" for="c-36102226">[-]</label><label class="expand" for="c-36102226">[1 more]</label></div><br/><div class="children"><div class="content">This. Plus it is a good idea to specify the minimal recommended hash algorithm to have some manageable expectations on collisions. &quot;The cache key collision rate is guaranteed to be not worse than SHA-256&quot;.</div><br/></div></div></div></div><div id="36098584" class="c"><input type="checkbox" id="c-36098584" checked=""/><div class="controls bullet"><span class="by">thwarted</span><span>|</span><a href="#36098079">parent</a><span>|</span><a href="#36101812">prev</a><span>|</span><a href="#36098019">next</a><span>|</span><label class="collapse" for="c-36098584">[-]</label><label class="expand" for="c-36098584">[5 more]</label></div><br/><div class="children"><div class="content">The cache is local to the proxy or web server, it doesn&#x27;t matter what the hashing algorithm is as long as the cache accurately returns cached results given the same inputs.  The semantic meaning of &quot;input&quot; is different for if it&#x27;s a proxy or if it&#x27;s the origin.  The origin web server could very well cache based on the result of post processing and validation of the input, while a proxy should cache based on a much more strict (exact series of bytes) interpretation of the input.<p>This is no different than how any other caching proxy is expected to operate given a set of inputs.  It&#x27;s never been up to the proxy to interpret if the queries &quot;name=joe%20user&quot; and &quot;first=joe&amp;last=user&quot; are the same, it just passes the input along to its upstream and then locally stores the result, assuming that the same input will occur again and save a trip to upstream.</div><br/><div id="36101497" class="c"><input type="checkbox" id="c-36101497" checked=""/><div class="controls bullet"><span class="by">bornfreddy</span><span>|</span><a href="#36098079">root</a><span>|</span><a href="#36098584">parent</a><span>|</span><a href="#36098850">next</a><span>|</span><label class="collapse" for="c-36101497">[-]</label><label class="expand" for="c-36101497">[1 more]</label></div><br/><div class="children"><div class="content">You are assuming that proxies will correctly determine which content does not matter. From what I&#x27;ve seen, what will most likely happen is that we will be spending countless hours just because some box is sometimes returning wrong content, because it decides that the request is &quot;the same&quot;.<p>I don&#x27;t mind caching, but please make it deterministic.</div><br/></div></div><div id="36098850" class="c"><input type="checkbox" id="c-36098850" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36098079">root</a><span>|</span><a href="#36098584">parent</a><span>|</span><a href="#36101497">prev</a><span>|</span><a href="#36098019">next</a><span>|</span><label class="collapse" for="c-36098850">[-]</label><label class="expand" for="c-36098850">[3 more]</label></div><br/><div class="children"><div class="content">you&#x27;re papering over the important details<p>namely, urls are finite, bodies are infinite</div><br/><div id="36099891" class="c"><input type="checkbox" id="c-36099891" checked=""/><div class="controls bullet"><span class="by">kortex</span><span>|</span><a href="#36098079">root</a><span>|</span><a href="#36098850">parent</a><span>|</span><a href="#36098019">next</a><span>|</span><label class="collapse" for="c-36099891">[-]</label><label class="expand" for="c-36099891">[2 more]</label></div><br/><div class="children"><div class="content">So? Just deal with it however one would deal with unruly POST requests, slow-walked multi-part, and other protocol abuse. No matter what, you need protection against bad actors trying to get the servers to do bad things.</div><br/><div id="36100009" class="c"><input type="checkbox" id="c-36100009" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36098079">root</a><span>|</span><a href="#36099891">parent</a><span>|</span><a href="#36098019">next</a><span>|</span><label class="collapse" for="c-36100009">[-]</label><label class="expand" for="c-36100009">[1 more]</label></div><br/><div class="children"><div class="content">i&#x27;m not sure how malicious requests are relevant to this conversation<p>specifically, a URL can basically always be fully read and cached in memory in a server, a request body cannot</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36098019" class="c"><input type="checkbox" id="c-36098019" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#36098079">prev</a><span>|</span><a href="#36100762">next</a><span>|</span><label class="collapse" for="c-36098019">[-]</label><label class="expand" for="c-36098019">[3 more]</label></div><br/><div class="children"><div class="content">I was wondering which versions of HTTP will this be added to<p>Thinking, will it be possible to send HTTP&#x2F;1.1 QUERY requests? HTTP&#x2F;2 QUERY requests?<p>Or will it be for HTTP&#x2F;3 or something even higher?<p>Well the examples given in the document seems to indicate that it will be possible to use with HTTP&#x2F;1.1 even<p><pre><code>    QUERY &#x2F;contacts HTTP&#x2F;1.1
    Host: example.org
    Content-Type: example&#x2F;query
    Accept: text&#x2F;csv

    select surname, givenname, email limit 10</code></pre></div><br/><div id="36099101" class="c"><input type="checkbox" id="c-36099101" checked=""/><div class="controls bullet"><span class="by">treve</span><span>|</span><a href="#36098019">parent</a><span>|</span><a href="#36100762">next</a><span>|</span><label class="collapse" for="c-36099101">[-]</label><label class="expand" for="c-36099101">[2 more]</label></div><br/><div class="children"><div class="content">Any good HTTP implementation will support any HTTP method. If a HTTP method is not recognized, it will basically be treated as if it&#x27;s a POST method.</div><br/><div id="36099964" class="c"><input type="checkbox" id="c-36099964" checked=""/><div class="controls bullet"><span class="by">jsd1982</span><span>|</span><a href="#36098019">root</a><span>|</span><a href="#36099101">parent</a><span>|</span><a href="#36100762">next</a><span>|</span><label class="collapse" for="c-36099964">[-]</label><label class="expand" for="c-36099964">[1 more]</label></div><br/><div class="children"><div class="content">Where do you get this assertion from that methods are post by default? Most http server implementations will reply with a 405 error for an unexpected method.</div><br/></div></div></div></div></div></div><div id="36100762" class="c"><input type="checkbox" id="c-36100762" checked=""/><div class="controls bullet"><span class="by">ta-run</span><span>|</span><a href="#36098019">prev</a><span>|</span><a href="#36099927">next</a><span>|</span><label class="collapse" for="c-36100762">[-]</label><label class="expand" for="c-36100762">[6 more]</label></div><br/><div class="children"><div class="content">SQL-like queries in the request body seem like a bad idea, what are the security implications and how do we protect against it?<p>Or will the QUERY method end up with the same fate as GraphQL - wherein it&#x27;s more effective and &quot;secure&quot; in a server-to-server setup and the client only deals with REST.</div><br/><div id="36101604" class="c"><input type="checkbox" id="c-36101604" checked=""/><div class="controls bullet"><span class="by">crooked-v</span><span>|</span><a href="#36100762">parent</a><span>|</span><a href="#36101629">next</a><span>|</span><label class="collapse" for="c-36101604">[-]</label><label class="expand" for="c-36101604">[1 more]</label></div><br/><div class="children"><div class="content">QUERY has nothing to do with the actual contents of the request body beyond &quot;it is hashable text&quot;. That could be JSON, GraphQL, weird SQL cousins, or anything else.</div><br/></div></div><div id="36101629" class="c"><input type="checkbox" id="c-36101629" checked=""/><div class="controls bullet"><span class="by">9dev</span><span>|</span><a href="#36100762">parent</a><span>|</span><a href="#36101604">prev</a><span>|</span><a href="#36101061">next</a><span>|</span><label class="collapse" for="c-36101629">[-]</label><label class="expand" for="c-36101629">[1 more]</label></div><br/><div class="children"><div class="content">How is that less secure than a REST API Frontend to an SQL database, like PHPMyAdmin?<p>I don’t think anyone suggests we all open our databases to the web; but if you choose to do so, or if you happen to work on a modern database, like Elasticsearch or CouchDB, which accept queries via HTTP, now there’s a better way to implement queries in regard to caching.<p>That being said: I’ve been wondering for a long time what a backend API could look like that used SQL instead of JSON as the query format - not to pass it to the database verbatim, but with an application layer that speaks SQL, applies business logic, queries the database, and responds in SQL. That would save a lot of reinvented wheels in terms of filtering, ordering, joining, and so on, and give developers a query language they already know. And suddenly, having a QUERY method available sounds useful, too :)</div><br/></div></div><div id="36101061" class="c"><input type="checkbox" id="c-36101061" checked=""/><div class="controls bullet"><span class="by">sarthak-ag</span><span>|</span><a href="#36100762">parent</a><span>|</span><a href="#36101629">prev</a><span>|</span><a href="#36099927">next</a><span>|</span><label class="collapse" for="c-36101061">[-]</label><label class="expand" for="c-36101061">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s just an example, not a production use case.</div><br/><div id="36101131" class="c"><input type="checkbox" id="c-36101131" checked=""/><div class="controls bullet"><span class="by">ta-run</span><span>|</span><a href="#36100762">root</a><span>|</span><a href="#36101061">parent</a><span>|</span><a href="#36099927">next</a><span>|</span><label class="collapse" for="c-36101131">[-]</label><label class="expand" for="c-36101131">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, I mean, I get that but eventually? no?</div><br/><div id="36102242" class="c"><input type="checkbox" id="c-36102242" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#36100762">root</a><span>|</span><a href="#36101131">parent</a><span>|</span><a href="#36099927">next</a><span>|</span><label class="collapse" for="c-36102242">[-]</label><label class="expand" for="c-36102242">[1 more]</label></div><br/><div class="children"><div class="content">Why eventually? It’s a sad reality for quite a few of us here right now and has been for quite some time</div><br/></div></div></div></div></div></div></div></div><div id="36099927" class="c"><input type="checkbox" id="c-36099927" checked=""/><div class="controls bullet"><span class="by">kortex</span><span>|</span><a href="#36100762">prev</a><span>|</span><a href="#36099236">next</a><span>|</span><label class="collapse" for="c-36099927">[-]</label><label class="expand" for="c-36099927">[7 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t wait until this becomes a spec. I wrote a small middleware to cache sql and graphql queries and I implemented QUERY and Cache-Control. Worked great and saved a ton of bandwidth for developing and running reports, as I didn&#x27;t have to worry about caching progress. I just reran the whole job. It was like &lt;50 lines of python to pull it off.</div><br/><div id="36100738" class="c"><input type="checkbox" id="c-36100738" checked=""/><div class="controls bullet"><span class="by">ta-run</span><span>|</span><a href="#36099927">parent</a><span>|</span><a href="#36100209">next</a><span>|</span><label class="collapse" for="c-36100738">[-]</label><label class="expand" for="c-36100738">[5 more]</label></div><br/><div class="children"><div class="content">What I fail to understand is how the server interprets the query content&#x2F;body; how does the server &quot;apply&quot; the &quot;sql&quot; query in the request to the resource? is there something similar to a gql resolver that you need to write?</div><br/><div id="36101158" class="c"><input type="checkbox" id="c-36101158" checked=""/><div class="controls bullet"><span class="by">kortex</span><span>|</span><a href="#36099927">root</a><span>|</span><a href="#36100738">parent</a><span>|</span><a href="#36100209">next</a><span>|</span><label class="collapse" for="c-36101158">[-]</label><label class="expand" for="c-36101158">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s agnostic, the QUERY verb has nothing to do with the actual implementation, or the content encoding. You can use any content encoding for your query body, and you can resolve it any way you see fit.<p>In mine, I was just caching raw sql queries, so it was literally just text&#x2F;sql encoding, the query in the body, some metadata in headers, and a sqlalchemy engine to execute the query.<p>It&#x27;s <i>basically</i> a way to get around the non-idempotency of POST and URI limitations of GET.</div><br/><div id="36101203" class="c"><input type="checkbox" id="c-36101203" checked=""/><div class="controls bullet"><span class="by">ta-run</span><span>|</span><a href="#36099927">root</a><span>|</span><a href="#36101158">parent</a><span>|</span><a href="#36100209">next</a><span>|</span><label class="collapse" for="c-36101203">[-]</label><label class="expand" for="c-36101203">[3 more]</label></div><br/><div class="children"><div class="content">Aha, got it. Thanks for the explanation.<p>So, the request content&#x2F;body can have &quot;non-sql-like&quot; queries? can it be GraphQL? or even plain English? - of course, assuming that the server knows how to resolve the query.</div><br/><div id="36101280" class="c"><input type="checkbox" id="c-36101280" checked=""/><div class="controls bullet"><span class="by">kortex</span><span>|</span><a href="#36099927">root</a><span>|</span><a href="#36101203">parent</a><span>|</span><a href="#36100209">next</a><span>|</span><label class="collapse" for="c-36101280">[-]</label><label class="expand" for="c-36101280">[2 more]</label></div><br/><div class="children"><div class="content">Yep. This is valid<p><pre><code>    QUERY &#x2F;graphql
    Content-Type: text&#x2F;graphql
    {too lazy to write valid gql}
</code></pre>
so is this<p><pre><code>    QUERY &#x2F;elasticsearch
    Content-Type: application&#x2F;json
    {&quot;name&quot;: &quot;alice&quot;}
</code></pre>
Even this<p><pre><code>    QUERY &#x2F;my-ai-image-gen
    Content-Type: text&#x2F;plain
    Draw me a picture of a cat
</code></pre>
It&#x27;s entirely up to the software  to decide how to handle the request.</div><br/><div id="36101462" class="c"><input type="checkbox" id="c-36101462" checked=""/><div class="controls bullet"><span class="by">ta-run</span><span>|</span><a href="#36099927">root</a><span>|</span><a href="#36101280">parent</a><span>|</span><a href="#36100209">next</a><span>|</span><label class="collapse" for="c-36101462">[-]</label><label class="expand" for="c-36101462">[1 more]</label></div><br/><div class="children"><div class="content">Great, thank you!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36100209" class="c"><input type="checkbox" id="c-36100209" checked=""/><div class="controls bullet"><span class="by">linuxdude314</span><span>|</span><a href="#36099927">parent</a><span>|</span><a href="#36100738">prev</a><span>|</span><a href="#36099236">next</a><span>|</span><label class="collapse" for="c-36100209">[-]</label><label class="expand" for="c-36100209">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love to see JSON-RPC overhauled with this method.  It&#x27;s quite a pain to cache idempotent methods exposed over JSON-RPC as-is currently.</div><br/></div></div></div></div><div id="36099236" class="c"><input type="checkbox" id="c-36099236" checked=""/><div class="controls bullet"><span class="by">deepzn</span><span>|</span><a href="#36099927">prev</a><span>|</span><a href="#36099304">next</a><span>|</span><label class="collapse" for="c-36099236">[-]</label><label class="expand" for="c-36099236">[1 more]</label></div><br/><div class="children"><div class="content">previously it was titled SEARCH. I like query better personally, as it kind of aligns with SQL like requests.<p>Here&#x27;s a great post on it- <a href="https:&#x2F;&#x2F;httptoolkit.com&#x2F;blog&#x2F;http-search-method&#x2F;" rel="nofollow">https:&#x2F;&#x2F;httptoolkit.com&#x2F;blog&#x2F;http-search-method&#x2F;</a>
and earlier HN thread- <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36095032" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36095032</a></div><br/></div></div><div id="36099304" class="c"><input type="checkbox" id="c-36099304" checked=""/><div class="controls bullet"><span class="by">mholt</span><span>|</span><a href="#36099236">prev</a><span>|</span><a href="#36097969">next</a><span>|</span><label class="collapse" for="c-36099304">[-]</label><label class="expand" for="c-36099304">[1 more]</label></div><br/><div class="children"><div class="content">It is a little ironic that a new HTTP method called &quot;QUERY&quot; is being created largely to be able to <i>remove</i> the query from the URL.</div><br/></div></div><div id="36097969" class="c"><input type="checkbox" id="c-36097969" checked=""/><div class="controls bullet"><span class="by">paddw</span><span>|</span><a href="#36099304">prev</a><span>|</span><a href="#36097623">next</a><span>|</span><label class="collapse" for="c-36097969">[-]</label><label class="expand" for="c-36097969">[12 more]</label></div><br/><div class="children"><div class="content">This seems like it would introduce a tremendous amount of work to solve a problem that basically does not exist. You can just handle your POST request idempotently. We should just live with the semantics we have.</div><br/><div id="36101220" class="c"><input type="checkbox" id="c-36101220" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#36097969">parent</a><span>|</span><a href="#36098008">next</a><span>|</span><label class="collapse" for="c-36101220">[-]</label><label class="expand" for="c-36101220">[2 more]</label></div><br/><div class="children"><div class="content">Idempotency and safety is about how to send POST requests, rather than how to handle them.<p>You can&#x27;t pre-fetch a POST request, or re-try after a timeout. Because you have to consider that the POST request could have unintended consequences if sent too many times.</div><br/><div id="36101913" class="c"><input type="checkbox" id="c-36101913" checked=""/><div class="controls bullet"><span class="by">lacasito25</span><span>|</span><a href="#36097969">root</a><span>|</span><a href="#36101220">parent</a><span>|</span><a href="#36098008">next</a><span>|</span><label class="collapse" for="c-36101913">[-]</label><label class="expand" for="c-36101913">[1 more]</label></div><br/><div class="children"><div class="content">That looks more of a documentation problem, rather than an HTTP problem.<p>You just document that that POST endpoint doesn&#x27;t actually modify data.<p>A great example of this are OpenAI completions.</div><br/></div></div></div></div><div id="36098008" class="c"><input type="checkbox" id="c-36098008" checked=""/><div class="controls bullet"><span class="by">xrisk</span><span>|</span><a href="#36097969">parent</a><span>|</span><a href="#36101220">prev</a><span>|</span><a href="#36100068">next</a><span>|</span><label class="collapse" for="c-36098008">[-]</label><label class="expand" for="c-36098008">[1 more]</label></div><br/><div class="children"><div class="content">did you even read the article? it describes why this is a bad idea — it’s not just <i>your</i> server that’s handling the request, it’s all the other middleboxes in between.</div><br/></div></div><div id="36100068" class="c"><input type="checkbox" id="c-36100068" checked=""/><div class="controls bullet"><span class="by">kortex</span><span>|</span><a href="#36097969">parent</a><span>|</span><a href="#36098008">prev</a><span>|</span><a href="#36098010">next</a><span>|</span><label class="collapse" for="c-36100068">[-]</label><label class="expand" for="c-36100068">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s definitely not a &quot;tremendous&quot; amount of work. At the bare minimum, you copy your POST code and change the verb, that&#x27;s it. There&#x27;s no <i>need</i> to cache, so you <i>actually can</i> handle it basically as idempotent POST.<p>&gt; You can just handle your POST request idempotently<p>You actually can&#x27;t though, and you don&#x27;t usually have to look far to run into a case where this gives the wrong behavior. Better to just have a separate verb.</div><br/></div></div><div id="36098010" class="c"><input type="checkbox" id="c-36098010" checked=""/><div class="controls bullet"><span class="by">crooked-v</span><span>|</span><a href="#36097969">parent</a><span>|</span><a href="#36100068">prev</a><span>|</span><a href="#36098871">next</a><span>|</span><label class="collapse" for="c-36098010">[-]</label><label class="expand" for="c-36098010">[6 more]</label></div><br/><div class="children"><div class="content">With POST, you can&#x27;t know at a system level if it&#x27;s safe to cache the response or not.</div><br/><div id="36098026" class="c"><input type="checkbox" id="c-36098026" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#36097969">root</a><span>|</span><a href="#36098010">parent</a><span>|</span><a href="#36098871">next</a><span>|</span><label class="collapse" for="c-36098026">[-]</label><label class="expand" for="c-36098026">[5 more]</label></div><br/><div class="children"><div class="content">Cache-Control response headers?</div><br/><div id="36099602" class="c"><input type="checkbox" id="c-36099602" checked=""/><div class="controls bullet"><span class="by">mnot</span><span>|</span><a href="#36097969">root</a><span>|</span><a href="#36098026">parent</a><span>|</span><a href="#36098962">next</a><span>|</span><label class="collapse" for="c-36099602">[-]</label><label class="expand" for="c-36099602">[1 more]</label></div><br/><div class="children"><div class="content">Cache-Control and Content -Location.</div><br/></div></div><div id="36098962" class="c"><input type="checkbox" id="c-36098962" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36097969">root</a><span>|</span><a href="#36098026">parent</a><span>|</span><a href="#36099602">prev</a><span>|</span><a href="#36098871">next</a><span>|</span><label class="collapse" for="c-36098962">[-]</label><label class="expand" for="c-36098962">[3 more]</label></div><br/><div class="children"><div class="content">insufficient</div><br/><div id="36100382" class="c"><input type="checkbox" id="c-36100382" checked=""/><div class="controls bullet"><span class="by">mnot</span><span>|</span><a href="#36097969">root</a><span>|</span><a href="#36098962">parent</a><span>|</span><a href="#36098871">next</a><span>|</span><label class="collapse" for="c-36100382">[-]</label><label class="expand" for="c-36100382">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;httpwg.org&#x2F;specs&#x2F;rfc9110.html#POST" rel="nofollow">https:&#x2F;&#x2F;httpwg.org&#x2F;specs&#x2F;rfc9110.html#POST</a></div><br/><div id="36101325" class="c"><input type="checkbox" id="c-36101325" checked=""/><div class="controls bullet"><span class="by">kortex</span><span>|</span><a href="#36097969">root</a><span>|</span><a href="#36100382">parent</a><span>|</span><a href="#36098871">next</a><span>|</span><label class="collapse" for="c-36101325">[-]</label><label class="expand" for="c-36101325">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A cached POST response can be reused to satisfy a later GET or HEAD request. In contrast, a POST request cannot be satisfied by a cached POST response because POST is potentially unsafe; see Section 4 of [CACHING].<p>So if you are using POST to query, you can&#x27;t cache the response. You have to resort to POST&#x2F;GET. With QUERY, you have idempotent requests with cacheable responses you can directly return.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36098871" class="c"><input type="checkbox" id="c-36098871" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36097969">parent</a><span>|</span><a href="#36098010">prev</a><span>|</span><a href="#36097623">next</a><span>|</span><label class="collapse" for="c-36098871">[-]</label><label class="expand" for="c-36098871">[1 more]</label></div><br/><div class="children"><div class="content">HTTP defines the POST method explicitly as non-idempotent</div><br/></div></div></div></div><div id="36097623" class="c"><input type="checkbox" id="c-36097623" checked=""/><div class="controls bullet"><span class="by">franky47</span><span>|</span><a href="#36097969">prev</a><span>|</span><a href="#36098709">next</a><span>|</span><label class="collapse" for="c-36097623">[-]</label><label class="expand" for="c-36097623">[7 more]</label></div><br/><div class="children"><div class="content">While you *can* do the same with a GET (include data in the body), it&#x27;s not spec-compliant for servers to parse and interpret this data.<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;978061&#x2F;http-get-with-request-body#983458" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;978061&#x2F;http-get-with-req...</a><p>When designing an API, and if spec compliance is not key, I wonder if client-compliance would become the issue (clients refusing to emit a GET body).</div><br/><div id="36098784" class="c"><input type="checkbox" id="c-36098784" checked=""/><div class="controls bullet"><span class="by">BugsJustFindMe</span><span>|</span><a href="#36097623">parent</a><span>|</span><a href="#36097894">next</a><span>|</span><label class="collapse" for="c-36098784">[-]</label><label class="expand" for="c-36098784">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>it&#x27;s not spec-compliant for servers to parse and interpret this data.</i><p>That&#x27;s wrong. A lot of people just don&#x27;t understand the difference between SHOULD and MUST when reading standards. The standard just says that you shouldn&#x27;t rely on servers accepting it unless they tell you.</div><br/></div></div><div id="36097894" class="c"><input type="checkbox" id="c-36097894" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#36097623">parent</a><span>|</span><a href="#36098784">prev</a><span>|</span><a href="#36098709">next</a><span>|</span><label class="collapse" for="c-36097894">[-]</label><label class="expand" for="c-36097894">[5 more]</label></div><br/><div class="children"><div class="content">Parsing the body of GET can be added as an extension, same as adding this new QUERY method.</div><br/><div id="36098053" class="c"><input type="checkbox" id="c-36098053" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#36097623">root</a><span>|</span><a href="#36097894">parent</a><span>|</span><a href="#36098937">next</a><span>|</span><label class="collapse" for="c-36098053">[-]</label><label class="expand" for="c-36098053">[2 more]</label></div><br/><div class="children"><div class="content">Many “WAF” (Web-Application Firewalls) and reverse-proxies are configured to block “unusual” traffic though, including GET-with-body - but I feel that this approach is like how (around 2000-2006) everyone switched from high-performance or legacy binary protocols to XML&#x2F;SOAP-over-HTTPS to avoid corporate firewall headaches.</div><br/><div id="36098625" class="c"><input type="checkbox" id="c-36098625" checked=""/><div class="controls bullet"><span class="by">thwarted</span><span>|</span><a href="#36097623">root</a><span>|</span><a href="#36098053">parent</a><span>|</span><a href="#36098937">next</a><span>|</span><label class="collapse" for="c-36098625">[-]</label><label class="expand" for="c-36098625">[1 more]</label></div><br/><div class="children"><div class="content">There will most likely be problems with such web-application firewalls anyway, since those same firewalls will probably reject HTTP methods that they don&#x27;t know about.<p>But adding a new new method is probably overall better and matches people&#x27;s understanding of the implementation and interpretation of GET, even if (with extensions) GET <i>can</i> have a body people don&#x27;t think of it like that.  So a new method with defined semantics and interpretation avoids a whole bunch of sideshow debate about if GET with a body is possible or appropriate.</div><br/></div></div></div></div><div id="36098937" class="c"><input type="checkbox" id="c-36098937" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36097623">root</a><span>|</span><a href="#36097894">parent</a><span>|</span><a href="#36098053">prev</a><span>|</span><a href="#36098709">next</a><span>|</span><label class="collapse" for="c-36098937">[-]</label><label class="expand" for="c-36098937">[2 more]</label></div><br/><div class="children"><div class="content">middleboxes are free to drop the body of any GET request, and generally do so</div><br/><div id="36099391" class="c"><input type="checkbox" id="c-36099391" checked=""/><div class="controls bullet"><span class="by">adev_</span><span>|</span><a href="#36097623">root</a><span>|</span><a href="#36098937">parent</a><span>|</span><a href="#36098709">next</a><span>|</span><label class="collapse" for="c-36099391">[-]</label><label class="expand" for="c-36099391">[1 more]</label></div><br/><div class="children"><div class="content">&gt; middleboxes are free to drop the body of any GET request, and generally do so<p>Most middlebox will equally drop any HTTP verb which is not whitelisted.<p>Even the extension of WebDAV, which are 15 years old are still commonly blocked.</div><br/></div></div></div></div></div></div></div></div><div id="36098709" class="c"><input type="checkbox" id="c-36098709" checked=""/><div class="controls bullet"><span class="by">betimsl</span><span>|</span><a href="#36097623">prev</a><span>|</span><label class="collapse" for="c-36098709">[-]</label><label class="expand" for="c-36098709">[1 more]</label></div><br/><div class="children"><div class="content">Love it :)</div><br/></div></div></div></div></div></div></div></body></html>