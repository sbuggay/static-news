<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706000462890" as="style"/><link rel="stylesheet" href="styles.css?v=1706000462890"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://ryanbrewer.dev/posts/announcing-svm.html">SaberVM</a> <span class="domain">(<a href="https://ryanbrewer.dev">ryanbrewer.dev</a>)</span></div><div class="subtext"><span>hoping1</span> | <span>4 comments</span></div><br/><div><div id="39099152" class="c"><input type="checkbox" id="c-39099152" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#39097978">next</a><span>|</span><label class="collapse" for="c-39099152">[-]</label><label class="expand" for="c-39099152">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a language author, so I&#x27;m not getting any lightbulbs about why its nice to build regions into the VM rather than the compiler. I see the appeal of the region thing which reminds me of Vale (<a href="https:&#x2F;&#x2F;verdagon.dev&#x2F;blog&#x2F;zero-cost-borrowing-regions-overview" rel="nofollow">https:&#x2F;&#x2F;verdagon.dev&#x2F;blog&#x2F;zero-cost-borrowing-regions-overvi...</a>). I didn&#x27;t really get the exceptions thing.<p>What&#x27;s some stuff you&#x27;d like to see in a higher level language that would fit the design nicely?<p>Are those things really hard to implement on top of WebAssembly?</div><br/><div id="39100417" class="c"><input type="checkbox" id="c-39100417" checked=""/><div class="controls bullet"><span class="by">hoping1</span><span>|</span><a href="#39099152">parent</a><span>|</span><a href="#39097978">next</a><span>|</span><label class="collapse" for="c-39100417">[-]</label><label class="expand" for="c-39100417">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I wrote that targeting a more langdev audience, to be fair. Those are great questions! There’s a lot to answer there so unfortunately my answer is a bit long, I hope that’s ok.<p>1) Why have regions in the VM instead of compilers that target it?<p>SaberVM does its own analysis of the bytecode given to it to make sure its safe. That way, if you receive SaberVM bytecode, you don&#x27;t have to trust it blindly. Wasm and the JVM both do this as well, for the same reason. A big difference from those projects, though, is that SaberVM&#x27;s analysis includes memory safety, like Rust. For that, it uses regions (as well as Vale&#x27;s system, which is a big inspiration). The JVM doesn&#x27;t try to guarantee memory safety, and Wasm guarantees it by sandboxing the runtime from the rest of the computer. However, Wasm doesn&#x27;t make any memory safety guarantees about the usage of memory within the Wasm runtime. Since SaberVM is trying to be a first-class execution environment like the JVM, instead of an embedded one like Wasm, it has to make guarantees about the usage of memory within the runtime, and therefore uses regions (in tandem with something like Vale&#x27;s generational references).<p>2) I don’t really get the exceptions thing<p>The exceptions thing is meant to be a lightweight way of getting the reliability of Erlang&#x27;s BEAM VM, using a common approach to exceptions in CPS-based compilation. Having a built-in notion of exceptions means that whenever an instruction fails, it can jump to the exception handler instead of crashing. That way parts of the program can be cleaned up and even restarted during the execution, instead of just crashing.<p>3) What features could a higher-level language have that would make the most of SaberVM’s unique characteristics?<p>A higher level language that compiles to SaberVM bytecode might give more control over memory management than existing functional languages. Things like support for stack allocation, arena allocation, in-place mutation of values that are used linearly, and unboxed, nonuniform memory representations of values. I might also use an actor system for concurrency, since the CPS style makes stackless coroutines trivial to implement and the exception system and parallelism instructions should be able to do a good enough job at something BEAM-like. Lastly, I would definitely surface the exception system as a feature of the language, for the sake of writing your own exception handlers.<p>4) Are those features really hard to implement in Wasm?<p>Unfortunately Wasm isn’t a great target for functional programming at the moment. It uses structured control flow as a big part of its security, with ifs and loops and whatnot. Functional languages, on the other hand, use recursion for loops, so they often use jumps for function calls, or else they’d likely run into stack overflows. Very recently, Wasm added “tail calls,” that is, when a function returns the result of another function, that function can use the stack space of the current function, essentially freeing that space early. Wasm added this mostly to support functional languages better, since it saves stack space quite a lot. I intend to write a transpiler from SaberVM to Wasm at some point in the near future, that uses the new tail call feature. But even then, functional languages use polymorphism for their security, not structured control flow, and there’s just a number of philosophical differences that make compiling to Wasm a pain for functional languages. And lastly, Wasm doesn’t have any way to do the things the BEAM is known for, namely, massive parallelism with extremely resilient concurrency. I know there are proposals on parallelism but given the fact that Wasm is meant to run in the browser first and foremost, this will never be a big goal for it.<p>SaberVM is intended to be what functional programmers wish Wasm was: a statically typed runtime system that could be run in the browser but isn’t primarily for that, which could functional languages could easily compile to in a way that preserves the sort of polymorphism-based security reasoning that functional programs depend on.<p>5) Conclusion :)<p>As you can see from my discussion of this stuff, these ideas all precede me. My region analysis is from a Krary, Walker, and Morrisett paper. I use something like generational references from Vale. I&#x27;m taking significant inspiration from the JVM, Wasm, and the BEAM. My only contribution here is figuring out how to put these pieces together into a tight, portable little system.<p>And in the interest of executing things without a VM, I&#x27;m thinking a lot about AOT-compiling the bytecode to native binaries as well.</div><br/></div></div></div></div><div id="39097978" class="c"><input type="checkbox" id="c-39097978" checked=""/><div class="controls bullet"><span class="by">hoping1</span><span>|</span><a href="#39099152">prev</a><span>|</span><label class="collapse" for="c-39097978">[-]</label><label class="expand" for="c-39097978">[1 more]</label></div><br/><div class="children"><div class="content">In this post I announce a new abstract machine oriented towards executing functional languages in a memory-safe and portable way.</div><br/></div></div></div></div></div></div></div></body></html>