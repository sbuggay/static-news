<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1707296468241" as="style"/><link rel="stylesheet" href="styles.css?v=1707296468241"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://social.belkadan.com/@jrose/statuses/01HNRNHBQY4E5MC37KG14R50P7">Two&#x27;s complement integers with only sign bit set should be a trap representation</a>Â <span class="domain">(<a href="https://social.belkadan.com">social.belkadan.com</a>)</span></div><div class="subtext"><span>luu</span> | <span>48 comments</span></div><br/><div><div id="39286102" class="c"><input type="checkbox" id="c-39286102" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#39284983">next</a><span>|</span><label class="collapse" for="c-39286102">[-]</label><label class="expand" for="c-39286102">[1 more]</label></div><br/><div class="children"><div class="content">This is what nook:Balanced{I8,I16,I32,I64} are for. <a href="https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;nook" rel="nofollow">https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;nook</a><p>Of course today in Rust we&#x27;re not allowed to bless such types for ourselves, this is reserved to the standard library (core::num::NonZeroU32 is a 4-byte unsigned integer which can&#x27;t be zero for example) because it&#x27;s relying on a nasty permanently unstable compiler-only feature to say &quot;Hey, not all possible representations the right size for this type are valid&quot;.<p>Rust has one very obvious set of types with such a niche, the references &amp;T, but it also has not only the particular custom integers NonZero{U8,U16,U32,U64,I8,I16,I32,I64} and the Non-null pointers, but OS specific types (for Unix file descriptors, and Windows handles respectively) and of course char, it&#x27;s 4 bytes but Unicode is explicitly limited to far fewer values, so that&#x27;s a niche.<p>But today making more is not allowed in stable Rust, so while my nook crate is an interesting curiosity (and some day I&#x27;ll implement integer math traits etc.) it cannot be stabilised and I was persuaded that the path forward is a whole lot of work to deliver the Pattern Types feature which can do this stably.</div><br/></div></div><div id="39284983" class="c"><input type="checkbox" id="c-39284983" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39286102">prev</a><span>|</span><a href="#39284785">next</a><span>|</span><label class="collapse" for="c-39284983">[-]</label><label class="expand" for="c-39284983">[3 more]</label></div><br/><div class="children"><div class="content">From the linked discussion:<p>&gt; @jrose @fclc People who want NaN in their integers are welcome to do that in the privacy of their own bedrooms with new types they invent for this purpose.<p>That reminds me of OCaml&#x27;s 63 bit integers.  In the privacy of OCaml&#x27;s own bedroom, they use one bit of their integers as a flag to distinguish pointers from integers.<p>See <a href="https:&#x2F;&#x2F;blog.janestreet.com&#x2F;what-is-gained-and-lost-with-63-bit-integers&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.janestreet.com&#x2F;what-is-gained-and-lost-with-63-...</a><p>The results are quite.. interesting.  However, it does go to show that having slightly weird private integer types is actually totally workable, so the quote from the discussion might be meant as trolling, but it&#x27;s less crazy than it sounds like.</div><br/><div id="39285182" class="c"><input type="checkbox" id="c-39285182" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#39284983">parent</a><span>|</span><a href="#39286130">next</a><span>|</span><label class="collapse" for="c-39285182">[-]</label><label class="expand" for="c-39285182">[1 more]</label></div><br/><div class="children"><div class="content">The difference is that (a) that bit in OCaml has a purpose, while disregarding 0x80..00 hasn&#x27;t; and (b) I assume that it was in OCaml from the beginning, so it wouldn&#x27;t break existing software in probably very interesting ways (hence the suggestion that this should be done only &quot;in the privacy of their own bedrooms with new types&quot;, i.e. not for already-used types)...</div><br/></div></div><div id="39286130" class="c"><input type="checkbox" id="c-39286130" checked=""/><div class="controls bullet"><span class="by">hoseja</span><span>|</span><a href="#39284983">parent</a><span>|</span><a href="#39285182">prev</a><span>|</span><a href="#39284785">next</a><span>|</span><label class="collapse" for="c-39286130">[-]</label><label class="expand" for="c-39286130">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; @jrose @fclc People who want NaN in their integers are welcome to do that in the privacy of their own bedrooms with new types they invent for this purpose.<p>And yet I bet they use IEEE754 floats without second thought.</div><br/></div></div></div></div><div id="39284785" class="c"><input type="checkbox" id="c-39284785" checked=""/><div class="controls bullet"><span class="by">femto</span><span>|</span><a href="#39284983">prev</a><span>|</span><a href="#39284471">next</a><span>|</span><label class="collapse" for="c-39284785">[-]</label><label class="expand" for="c-39284785">[1 more]</label></div><br/><div class="children"><div class="content">DSPs already do something like this, offering the option of saturating arithmetic operations, in addition to the normal modulo arithmetic.  It&#x27;s the operation that&#x27;s special, not the representation in memory.<p>The normal way to do it is to use the &quot;ETSI Basic Operator&quot; library, which provides saturating arithmetic operations, among other things [1].  If the hardware supports saturated arithmetic the compiler maps the operations to the relevant instructions, otherwise it provides a software implementation.<p>Example:<p>Modulo arithmetic:  int16_t a,b,c; a = b + c;<p>Saturating 16-bit arithmetic using ETSI: int16_t a,b,c; a = add(b, c);<p>[1] <a href="https:&#x2F;&#x2F;www.itu.int&#x2F;rec&#x2F;T-REC-G.191&#x2F;en" rel="nofollow">https:&#x2F;&#x2F;www.itu.int&#x2F;rec&#x2F;T-REC-G.191&#x2F;en</a></div><br/></div></div><div id="39284471" class="c"><input type="checkbox" id="c-39284471" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39284785">prev</a><span>|</span><a href="#39284517">next</a><span>|</span><label class="collapse" for="c-39284471">[-]</label><label class="expand" for="c-39284471">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <i>should be a trap representation</i><p>In a new, green field programming language design: maybe.<p>You will have FFI interop issues: what if some foreign gives you such a value, which is correct in <i>its</i> domain. It will have to be specially handled and widened&#x2F;promoted to a type that can hold it. It looks like friction, though.<p>In an existing language, like C? Making currently correct programs blow up with a trap exception is a nonstarter.<p>I think there is no hardware support for treating 0x80... as a trap, so if you actually want it to trap, rather than leaving it at undefined behavior, your compiler has to emit check code, at least in code paths where it is not obvious whether the value is or isn&#x27;t a trap.<p>Also, it would be strangely inconsistent for the 0x80... to predictably trap wherever it occurs, but arithmetic overflow to have undefined consequences. The two want to be tied together.</div><br/><div id="39285364" class="c"><input type="checkbox" id="c-39285364" checked=""/><div class="controls bullet"><span class="by">dkjaudyeqooe</span><span>|</span><a href="#39284471">parent</a><span>|</span><a href="#39284798">next</a><span>|</span><label class="collapse" for="c-39285364">[-]</label><label class="expand" for="c-39285364">[1 more]</label></div><br/><div class="children"><div class="content">This is a simplistic view. I implement nil&#x2F;null values everywhere including integers and at the external border there is a test for that special value. It&#x27;s not like you&#x27;re using this sort of thing for just another number so it&#x27;s natural that there is an adaption.</div><br/></div></div><div id="39284798" class="c"><input type="checkbox" id="c-39284798" checked=""/><div class="controls bullet"><span class="by">owlbite</span><span>|</span><a href="#39284471">parent</a><span>|</span><a href="#39285364">prev</a><span>|</span><a href="#39285000">next</a><span>|</span><label class="collapse" for="c-39284798">[-]</label><label class="expand" for="c-39284798">[1 more]</label></div><br/><div class="children"><div class="content">Also bitfields &#x2F; any application using the hi bit as a flag for something or other is going to break now.</div><br/></div></div><div id="39285000" class="c"><input type="checkbox" id="c-39285000" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#39284471">parent</a><span>|</span><a href="#39284798">prev</a><span>|</span><a href="#39284517">next</a><span>|</span><label class="collapse" for="c-39285000">[-]</label><label class="expand" for="c-39285000">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>You will have FFI interop issues: what if some foreign gives you such a value, which is correct in its domain. It will have to be specially handled and widened&#x2F;promoted to a type that can hold it.</i><p>That&#x27;s more or less what you have to do in Java if your FFI is passing you an unsigned type.  You need to use a 64-bit signed long in Java to hold a uint32_t, and a BigInteger to hold a uint64_t.<p>I mean, you can certainly store that unsigned 32-bit int from the FFI call in a 32-bit signed Java int, but then you have to use special methods on the Integer class to do unsigned comparisons and arithmetic.<p>Agreed, this is a lot of friction, but there&#x27;s long-standing precedent, at least.</div><br/></div></div></div></div><div id="39284517" class="c"><input type="checkbox" id="c-39284517" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#39284471">prev</a><span>|</span><a href="#39284883">next</a><span>|</span><label class="collapse" for="c-39284517">[-]</label><label class="expand" for="c-39284517">[6 more]</label></div><br/><div class="children"><div class="content">Wait so we&#x27;re going to give up -fwrapv (a UB mitigation) <i>for the explicit purpose</i> of introducing <i>more</i> undefined behavior?<p>I don&#x27;t see any way this change wouldn&#x27;t lead to an enormous number of bugs, all for the (dubious) goal of having the range of signed integers be symmetrical.</div><br/><div id="39284982" class="c"><input type="checkbox" id="c-39284982" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#39284517">parent</a><span>|</span><a href="#39284988">next</a><span>|</span><label class="collapse" for="c-39284982">[-]</label><label class="expand" for="c-39284982">[1 more]</label></div><br/><div class="children"><div class="content">I think the idea is that overflowing would be a guaranteed trap of some kind, i.e. defined behavior.</div><br/></div></div><div id="39284988" class="c"><input type="checkbox" id="c-39284988" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39284517">parent</a><span>|</span><a href="#39284982">prev</a><span>|</span><a href="#39284883">next</a><span>|</span><label class="collapse" for="c-39284988">[-]</label><label class="expand" for="c-39284988">[4 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t have to introduce more undefined behaviour.  A trap could be very defined behaviour.</div><br/><div id="39285222" class="c"><input type="checkbox" id="c-39285222" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#39284517">root</a><span>|</span><a href="#39284988">parent</a><span>|</span><a href="#39284883">next</a><span>|</span><label class="collapse" for="c-39285222">[-]</label><label class="expand" for="c-39285222">[3 more]</label></div><br/><div class="children"><div class="content">No. What? No. A trap is by definition undefined behavior.<p>&quot;Certain object representations need not represent a value of the object type. If the stored value of an object has such a representation and is read by an lvalue expression that does not have character type, the behavior is undeï¬ned. If such a representation is produced by a side effect that modiï¬es all or any part of the object by an lvalue expression that does not have character type, the behavior is undeï¬ned.&quot;</div><br/><div id="39285264" class="c"><input type="checkbox" id="c-39285264" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#39284517">root</a><span>|</span><a href="#39285222">parent</a><span>|</span><a href="#39285333">next</a><span>|</span><label class="collapse" for="c-39285264">[-]</label><label class="expand" for="c-39285264">[1 more]</label></div><br/><div class="children"><div class="content">I think the idea would be to redefine &quot;the object type&quot; to make the trap value valid -- and to define the result of all operators on the trap value in some sensible way (similar to non-signalling NaNs in IEEE-754 floating point), so that, e.g., adding the trap value and any number produces the trap value again.</div><br/></div></div><div id="39285333" class="c"><input type="checkbox" id="c-39285333" checked=""/><div class="controls bullet"><span class="by">Gibbon1</span><span>|</span><a href="#39284517">root</a><span>|</span><a href="#39285222">parent</a><span>|</span><a href="#39285264">prev</a><span>|</span><a href="#39284883">next</a><span>|</span><label class="collapse" for="c-39285333">[-]</label><label class="expand" for="c-39285333">[1 more]</label></div><br/><div class="children"><div class="content">A trap is something the programmer should have to ask for not something the compiler writer thinks is suitable punishment.</div><br/></div></div></div></div></div></div></div></div><div id="39284883" class="c"><input type="checkbox" id="c-39284883" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#39284517">prev</a><span>|</span><a href="#39285397">next</a><span>|</span><label class="collapse" for="c-39284883">[-]</label><label class="expand" for="c-39284883">[1 more]</label></div><br/><div class="children"><div class="content">the version of this I&#x27;ve really wanted is hardware support for integers mod 2^64-1 with 0x1000000000000000 as a nan value. the addition and subtraction and division  would be trivial. multiplication would be a tiny bit more complicated, but should be relatively doable.<p>there are 3 main advantages with this system<p>1. ability to properly represent zero division or overflow without flags&#x2F;exceptions
2. abs(x) is always greater than 0
3. a mix of these and regular Ints could be used with the Chinese remainder theorem to provide faster (almost) 128 bit math.</div><br/></div></div><div id="39285397" class="c"><input type="checkbox" id="c-39285397" checked=""/><div class="controls bullet"><span class="by">gregfjohnson</span><span>|</span><a href="#39284883">prev</a><span>|</span><a href="#39286122">next</a><span>|</span><label class="collapse" for="c-39285397">[-]</label><label class="expand" for="c-39285397">[1 more]</label></div><br/><div class="children"><div class="content">Here is my favorite example of errors due to overflow:<p>std::vector&lt;int&gt; vec;<p>&#x2F;&#x2F; test for sorted..<p>bool sorted = true;<p>for (size_t i = 0; i &lt; vec.size() - 1ULL; ++i)<p><pre><code>    if (vec[i] &gt; vec[i+1]) {

        sorted = false;
        break;

    }
</code></pre>
I believe the google c++ style guide rues the selection of unsigned integers as the return type of size() in the standard library for reasons like the above.  Personally, my preferred behavior would be to have a compiler flag that could be used to enable a trap if unsigned arithmetic resulted in wrap-around, as in the above case when the vector is of length zero.</div><br/></div></div><div id="39286122" class="c"><input type="checkbox" id="c-39286122" checked=""/><div class="controls bullet"><span class="by">hoseja</span><span>|</span><a href="#39285397">prev</a><span>|</span><a href="#39284430">next</a><span>|</span><label class="collapse" for="c-39286122">[-]</label><label class="expand" for="c-39286122">[1 more]</label></div><br/><div class="children"><div class="content">None of signed integer representations are very good, each has severe drawbacks.</div><br/></div></div><div id="39284430" class="c"><input type="checkbox" id="c-39284430" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#39286122">prev</a><span>|</span><a href="#39286036">next</a><span>|</span><label class="collapse" for="c-39284430">[-]</label><label class="expand" for="c-39284430">[4 more]</label></div><br/><div class="children"><div class="content">Computers are implemented in hardware, not maths proofs. The Java generation is infatuated with magic numerics without realizing their performance cost.</div><br/><div id="39284976" class="c"><input type="checkbox" id="c-39284976" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#39284430">parent</a><span>|</span><a href="#39284501">next</a><span>|</span><label class="collapse" for="c-39284976">[-]</label><label class="expand" for="c-39284976">[2 more]</label></div><br/><div class="children"><div class="content">Whatâs the âJava generationâ, and why is premature optimization strictly preferred over sacrificing performance over correctness?<p>x86 offers hardware traps for integer division by zero while PowerPC returns zero â does that make x86 more wasteful&#x2F;a âJava generation CPUâ? What about CPUs that support native wrap trapping?</div><br/><div id="39285458" class="c"><input type="checkbox" id="c-39285458" checked=""/><div class="controls bullet"><span class="by">AdamH12113</span><span>|</span><a href="#39284430">root</a><span>|</span><a href="#39284976">parent</a><span>|</span><a href="#39284501">next</a><span>|</span><label class="collapse" for="c-39285458">[-]</label><label class="expand" for="c-39285458">[1 more]</label></div><br/><div class="children"><div class="content">I think the GP&#x27;s point is that this would need hardware support. Without that, it&#x27;s not something you could implement efficiently as a programming language feature -- you&#x27;d have to &quot;trap&quot; by checking the result of every arithmetic operation in software.</div><br/></div></div></div></div><div id="39284501" class="c"><input type="checkbox" id="c-39284501" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#39284430">parent</a><span>|</span><a href="#39284976">prev</a><span>|</span><a href="#39286036">next</a><span>|</span><label class="collapse" for="c-39284501">[-]</label><label class="expand" for="c-39284501">[1 more]</label></div><br/><div class="children"><div class="content">Floating-point numbers are also directly supported by hardware, but they carved a few values for NaN, negative and positive infinity, and negative and positive zero.<p>I don&#x27;t see why integers should not have something similar, especially large enough integers, like i64 or even i32. Historically they don&#x27;t though.</div><br/></div></div></div></div><div id="39286036" class="c"><input type="checkbox" id="c-39286036" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#39284430">prev</a><span>|</span><a href="#39284457">next</a><span>|</span><label class="collapse" for="c-39286036">[-]</label><label class="expand" for="c-39286036">[1 more]</label></div><br/><div class="children"><div class="content">In the past I have also been tempted by this idea that perhaps it would be better to redefine the current INT_MIN to be a NaN.<p>Nevertheless, after thinking more about it, my conclusion was that this is not useful.<p>The strongest argument in favor of it is that then an optional integer needs only the same size as an integer.<p>Against this argument is the fact that in decades of programming I have never encountered the need for an optional integer type which needs for its base integer type all possible values.<p>What I have encountered very frequently were optional integer types whose base integer type should have been defined as an integer interval a.k.a. integer range, like it is possible in languages like Ada or Pascal.<p>For such optional integers with the valid values restricted to an interval, the optional type does not require extra storage over the base type, because the NaN can be represented by any value outside the permissible interval.<p>The second argument for redefining INT_MIN to be a NaN is that this eliminates the possibility of overflows in several integer functions, like absolute value and negation.<p>This argument is weak, because overflows can still happen in the more frequent arithmetic operations, so most non-trivial programs must still provide means to handle such exceptional cases.<p>Moreover, the exceptions are avoided in absolute value and the like, by still having a (possibly implicit, i.e. inserted by the compiler) check that an integer value is not a NaN, somewhere before the code that uses negation, divide by -1, etc., perhaps in the invoking function, not in the invoked function to which integer arguments are passed, so this in the best case replaces multiple checks interspersed with the operations with a single check in the beginning, at the origin of the integer data. On the other hand, implicit checks that an integer is not a NaN would have to be added after additions and the like.<p>The same is available now, in much of the code where integer overflows are possible one can check the range of the input integer data somewhere in the beginning, verifying that there are no values that can result in an overflow, avoiding further checks at each operation.<p>The redefining of INT_MIN to be a NaN could help by relying on implicit checks added by a compiler in a few cases, but most expressions contain additions, subtractions and multiplications, so the program must still rely either on the compiler adding implicit overflow trap checks after each operation, for which adding the integer NaN does not give any improvements, or in the programmer writing explicit range checks that depend on the expressions that are computed, and for the majority of the expressions the explicit checks would still be needed.</div><br/></div></div><div id="39284457" class="c"><input type="checkbox" id="c-39284457" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39286036">prev</a><span>|</span><a href="#39284810">next</a><span>|</span><label class="collapse" for="c-39284457">[-]</label><label class="expand" for="c-39284457">[1 more]</label></div><br/><div class="children"><div class="content">I would welcome something like sNaN but actually fully enforced and widely implemented in hardwares. Otherwise it would be just a pipe dream.</div><br/></div></div><div id="39284810" class="c"><input type="checkbox" id="c-39284810" checked=""/><div class="controls bullet"><span class="by">dreamcompiler</span><span>|</span><a href="#39284457">prev</a><span>|</span><a href="#39284800">next</a><span>|</span><label class="collapse" for="c-39284810">[-]</label><label class="expand" for="c-39284810">[7 more]</label></div><br/><div class="children"><div class="content">One of the things I love about Lisp is that i+1 is always greater than i. You can work hard to make that not be true, but that&#x27;s the default and IMHO it&#x27;s the proper default.</div><br/><div id="39285009" class="c"><input type="checkbox" id="c-39285009" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39284810">parent</a><span>|</span><a href="#39284800">next</a><span>|</span><label class="collapse" for="c-39285009">[-]</label><label class="expand" for="c-39285009">[6 more]</label></div><br/><div class="children"><div class="content">Well, that&#x27;s the case for signed integers in C as well.<p>(But only on a technicality: because every program where that breaks is not technically C, and the compiler is allowed to assume this doesn&#x27;t happen.)<p>I suspect the Lisps you talk about use arbitrary sized integers by default?  Python also has that default.  It&#x27;s a good default.  If you want to optimize for size and want an integer of limited size, like a 64 bits or so, you should explicitly specify.</div><br/><div id="39285270" class="c"><input type="checkbox" id="c-39285270" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#39284810">root</a><span>|</span><a href="#39285009">parent</a><span>|</span><a href="#39285308">next</a><span>|</span><label class="collapse" for="c-39285270">[-]</label><label class="expand" for="c-39285270">[2 more]</label></div><br/><div class="children"><div class="content">Yep, the [numerical tower][1].<p>Python&#x27;s int is a bignum, but in Scheme you even have rationals built in. There&#x27;s a notion of which numeric values are &quot;exact&quot; and which ones are &quot;inexact&quot; (i.e. floating point).<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Numerical_tower" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Numerical_tower</a></div><br/><div id="39285307" class="c"><input type="checkbox" id="c-39285307" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39284810">root</a><span>|</span><a href="#39285270">parent</a><span>|</span><a href="#39285308">next</a><span>|</span><label class="collapse" for="c-39285307">[-]</label><label class="expand" for="c-39285307">[1 more]</label></div><br/><div class="children"><div class="content">I remember the numerical tower from Scheme.  That was an interesting concept.  (Though mathematically, you might want something with a more complicated structure than a tower.  Eg p-adic numbers would sit below integers, next to rational numbers, but not below them.)<p>Python has rational numbers in the standard library.  They are easy to use there, too.</div><br/></div></div></div></div><div id="39285308" class="c"><input type="checkbox" id="c-39285308" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#39284810">root</a><span>|</span><a href="#39285009">parent</a><span>|</span><a href="#39285270">prev</a><span>|</span><a href="#39284800">next</a><span>|</span><label class="collapse" for="c-39285308">[-]</label><label class="expand" for="c-39285308">[3 more]</label></div><br/><div class="children"><div class="content">This is dangerous for security, because now your math operations are no longer O(1) and might allocate memory.</div><br/><div id="39286089" class="c"><input type="checkbox" id="c-39286089" checked=""/><div class="controls bullet"><span class="by">ack_complete</span><span>|</span><a href="#39284810">root</a><span>|</span><a href="#39285308">parent</a><span>|</span><a href="#39285457">next</a><span>|</span><label class="collapse" for="c-39286089">[-]</label><label class="expand" for="c-39286089">[1 more]</label></div><br/><div class="children"><div class="content">Might allocate a _lot_ of memory. I&#x27;ve actually seen a case where some fatfingered a comparison in Python as a &lt;&lt; b instead of a &lt; b, and allocated gigabytes of memory on a server.</div><br/></div></div><div id="39285457" class="c"><input type="checkbox" id="c-39285457" checked=""/><div class="controls bullet"><span class="by">nlitened</span><span>|</span><a href="#39284810">root</a><span>|</span><a href="#39285308">parent</a><span>|</span><a href="#39286089">prev</a><span>|</span><a href="#39284800">next</a><span>|</span><label class="collapse" for="c-39285457">[-]</label><label class="expand" for="c-39285457">[1 more]</label></div><br/><div class="children"><div class="content">I think, if security is involved, one would still need to do overflow checks in the exact same places, so nothing is gained and nothing is lost.</div><br/></div></div></div></div></div></div></div></div><div id="39284800" class="c"><input type="checkbox" id="c-39284800" checked=""/><div class="controls bullet"><span class="by">nynx</span><span>|</span><a href="#39284810">prev</a><span>|</span><label class="collapse" for="c-39284800">[-]</label><label class="expand" for="c-39284800">[16 more]</label></div><br/><div class="children"><div class="content">Please no. A process dying automatically and immediately dying because of an arithmetic overflow would be terrible.</div><br/><div id="39284817" class="c"><input type="checkbox" id="c-39284817" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#39284800">parent</a><span>|</span><label class="collapse" for="c-39284817">[-]</label><label class="expand" for="c-39284817">[15 more]</label></div><br/><div class="children"><div class="content">You can have a handler.<p>But are you sure exiting is more terrible than blindly forging ahead with a known-wrong number?</div><br/><div id="39284828" class="c"><input type="checkbox" id="c-39284828" checked=""/><div class="controls bullet"><span class="by">nynx</span><span>|</span><a href="#39284800">root</a><span>|</span><a href="#39284817">parent</a><span>|</span><label class="collapse" for="c-39284828">[-]</label><label class="expand" for="c-39284828">[14 more]</label></div><br/><div class="children"><div class="content">Who said overflow was wrong? The sort of code I work on has to continue running, no matter what. Continuing on is always better than crashing, at least in my context.<p>Itâs also basically impossible to establish invariants about a system for code that is run in signal handlers</div><br/><div id="39284898" class="c"><input type="checkbox" id="c-39284898" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#39284800">root</a><span>|</span><a href="#39284828">parent</a><span>|</span><a href="#39285021">next</a><span>|</span><label class="collapse" for="c-39284898">[-]</label><label class="expand" for="c-39284898">[7 more]</label></div><br/><div class="children"><div class="content">And Iâll take a crash over a silent wraparound any day.<p>Out of curiosity, what domain is that? I canât think of many use case where silent wrapping wouldnât likely cause problems down the road.</div><br/><div id="39285057" class="c"><input type="checkbox" id="c-39285057" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#39284800">root</a><span>|</span><a href="#39284898">parent</a><span>|</span><a href="#39284945">next</a><span>|</span><label class="collapse" for="c-39285057">[-]</label><label class="expand" for="c-39285057">[4 more]</label></div><br/><div class="children"><div class="content">There are almost no circumstances where a crash in production code is preferable.<p>Can you imagine working on a complicated Excel document when you run into a 2038 bug and you lose all your work instead of just having one of your future dates calculated as being in the 1970s?<p>Or flying a plane and the system has to <i>reboot</i> midair instead of saying you&#x27;re at -32768 feet of altitude?<p>Or there are now 2.15 billion virus definitions, so your entire security suite just stops running?<p>Or your Tesla stops keeping you in your lane without warning because your odometer turned over?<p>Most things are not Therac-25. Much more software is protecting us and our data than is exposing us to danger. Loss of data, loss of navigation, loss of safety systems or life support... simply unacceptable. Turn on -ftrapv when testing and especially when fuzzing, sure, but production code should almost always be built with -fwrapv.</div><br/><div id="39285873" class="c"><input type="checkbox" id="c-39285873" checked=""/><div class="controls bullet"><span class="by">gizmo686</span><span>|</span><a href="#39284800">root</a><span>|</span><a href="#39285057">parent</a><span>|</span><a href="#39285316">next</a><span>|</span><label class="collapse" for="c-39285873">[-]</label><label class="expand" for="c-39285873">[1 more]</label></div><br/><div class="children"><div class="content">Excel maintains a recovery file of your open document. If it crashes, you can reopen Excel and will likely recover most if not all of your data. You are far more likely to corrupt data by keeping the files (primary and recovery) open in a program that is in a known-bad state.<p>If software crashes, it can simply be rebooted. I can&#x27;t get the actual requirements for airplane control softward without paying hundreds of dollars. However, I would imagine that a reboot finish quicker than a pilot could open the manual to the &quot;negative altitude indication&quot; section.</div><br/></div></div><div id="39285316" class="c"><input type="checkbox" id="c-39285316" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#39284800">root</a><span>|</span><a href="#39285057">parent</a><span>|</span><a href="#39285873">prev</a><span>|</span><a href="#39285073">next</a><span>|</span><label class="collapse" for="c-39285316">[-]</label><label class="expand" for="c-39285316">[1 more]</label></div><br/><div class="children"><div class="content">Crash-only software works for Erlang, and I think people expect telephony switches to be reliable. (Swift also crashes on overflows and runs your phone.)<p>Most of your examples would be just as bad if they started having unbounded incorrect behavior, and an overflow you didn&#x27;t know about could lead to that. So don&#x27;t get the math wrong!</div><br/></div></div><div id="39285073" class="c"><input type="checkbox" id="c-39285073" checked=""/><div class="controls bullet"><span class="by">nynx</span><span>|</span><a href="#39284800">root</a><span>|</span><a href="#39285057">parent</a><span>|</span><a href="#39285316">prev</a><span>|</span><a href="#39284945">next</a><span>|</span><label class="collapse" for="c-39285073">[-]</label><label class="expand" for="c-39285073">[1 more]</label></div><br/><div class="children"><div class="content">This is exactly right.</div><br/></div></div></div></div><div id="39284945" class="c"><input type="checkbox" id="c-39284945" checked=""/><div class="controls bullet"><span class="by">nynx</span><span>|</span><a href="#39284800">root</a><span>|</span><a href="#39284898">parent</a><span>|</span><a href="#39285057">prev</a><span>|</span><a href="#39285021">next</a><span>|</span><label class="collapse" for="c-39284945">[-]</label><label class="expand" for="c-39284945">[2 more]</label></div><br/><div class="children"><div class="content">I write software for spacecraft. Iâd much rather take my chances that the overflowed value is meant for humans or for some tertiary system than to end the mission regardless.</div><br/><div id="39285260" class="c"><input type="checkbox" id="c-39285260" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#39284800">root</a><span>|</span><a href="#39284945">parent</a><span>|</span><a href="#39285021">next</a><span>|</span><label class="collapse" for="c-39285260">[-]</label><label class="expand" for="c-39285260">[1 more]</label></div><br/><div class="children"><div class="content">Oh shi, not very reassuring knowledge spacecraft SW engineers allow signed overflow in their code.</div><br/></div></div></div></div></div></div><div id="39285021" class="c"><input type="checkbox" id="c-39285021" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39284800">root</a><span>|</span><a href="#39284828">parent</a><span>|</span><a href="#39284898">prev</a><span>|</span><a href="#39284938">next</a><span>|</span><label class="collapse" for="c-39285021">[-]</label><label class="expand" for="c-39285021">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Continuing on is always better than crashing, at least in my context.<p>In that case, you can just detect a crash (eg with an external watchdog), and replace your process with one that runs fizzbuzz.<p>Fizzbuzz is wrong, but so would be continuing-no-matter-what-happened in general.</div><br/><div id="39285347" class="c"><input type="checkbox" id="c-39285347" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#39284800">root</a><span>|</span><a href="#39285021">parent</a><span>|</span><a href="#39284938">next</a><span>|</span><label class="collapse" for="c-39285347">[-]</label><label class="expand" for="c-39285347">[1 more]</label></div><br/><div class="children"><div class="content">There are the kinds of defects that people notice, and then there are the kinds of defects that people don&#x27;t notice. Crashes are usually noticed, while nonsense calculations and undefined behavior are sometimes not noticed.<p>I worked at a company that sold a product that some customers used to make decisions involving a lot of money. A program misbehaved, or gave the wrong answer, or returned from a function too soon, or something. It didn&#x27;t crash. A customer lost a lot of money, and we were liable.<p>It turned out that the bug was a symptom of undefined behavior that would have been caught by one of the flavors of assertions built into standard releases of the core C++ libraries. The team in charge of the app in question had long ago disabled those assertions because &quot;they keep crashing the code.&quot;<p>Infrastructure within the company then went through a small internal crisis about whether to force assertions down people&#x27;s throats or to let it be wrong on prod. The compromise was to have the assertions expand to loud warnings on prod. Ops then had a tool that would list all of the &quot;your code is provably broken&quot; instances, and that went to a dashboard used the shame the relevant engineering managers.<p>Not sure if it worked, but when you have a _lot_ of C++ code, a great deal of it is broken and &quot;it&#x27;s fine.&quot; Until it isn&#x27;t.</div><br/></div></div></div></div><div id="39284938" class="c"><input type="checkbox" id="c-39284938" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#39284800">root</a><span>|</span><a href="#39284828">parent</a><span>|</span><a href="#39285021">prev</a><span>|</span><label class="collapse" for="c-39284938">[-]</label><label class="expand" for="c-39284938">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Who said overflow was wrong?<p>The word &quot;overflow&quot;.<p>&gt; Itâs also basically impossible to establish invariants about a system for code that is run in signal handlers<p>Signals are a pain but it doesn&#x27;t specifically have to be a signal.</div><br/><div id="39285024" class="c"><input type="checkbox" id="c-39285024" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#39284800">root</a><span>|</span><a href="#39284938">parent</a><span>|</span><a href="#39284957">next</a><span>|</span><label class="collapse" for="c-39285024">[-]</label><label class="expand" for="c-39285024">[1 more]</label></div><br/><div class="children"><div class="content">Overflow is fine if you&#x27;re aware of it and have code that either doesn&#x27;t need to care about it, or can work around it.<p>Consider protocols with wrapping sequence numbers.  Pretty common in the wild.  If I increment my 32-bit sequence counter and it goes from 2^32-1 back to 0, that&#x27;s likely just expected behavior.</div><br/></div></div><div id="39284957" class="c"><input type="checkbox" id="c-39284957" checked=""/><div class="controls bullet"><span class="by">nynx</span><span>|</span><a href="#39284800">root</a><span>|</span><a href="#39284938">parent</a><span>|</span><a href="#39285024">prev</a><span>|</span><label class="collapse" for="c-39284957">[-]</label><label class="expand" for="c-39284957">[2 more]</label></div><br/><div class="children"><div class="content">Overflow is perfectly well defined in most languages. What could it be other than a signal?</div><br/><div id="39285026" class="c"><input type="checkbox" id="c-39285026" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39284800">root</a><span>|</span><a href="#39284957">parent</a><span>|</span><label class="collapse" for="c-39285026">[-]</label><label class="expand" for="c-39285026">[1 more]</label></div><br/><div class="children"><div class="content">Alas, it&#x27;s not well defined for signed integers in C (and C++) which are still popular languages.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>