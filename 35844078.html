<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683536457102" as="style"/><link rel="stylesheet" href="styles.css?v=1683536457102"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.lortex.org/articles/value-speculation-ocaml/">Implementing Value Speculation in OCaml</a>Â <span class="domain">(<a href="https://www.lortex.org">www.lortex.org</a>)</span></div><div class="subtext"><span>Smaug123</span> | <span>7 comments</span></div><br/><div><div id="35856659" class="c"><input type="checkbox" id="c-35856659" checked=""/><div class="controls bullet"><span class="by">gadmm</span><span>|</span><a href="#35857114">next</a><span>|</span><label class="collapse" for="c-35856659">[-]</label><label class="expand" for="c-35856659">[2 more]</label></div><br/><div class="children"><div class="content">This is about the classic trick of speculating on values using branch prediction (if value == expected then f(expected) else f(value)), which is always fun to see. But be careful in OCaml, as the memory model relies on the memory ordering of data dependencies (e.g. on Arm) to ensure memory-safety, so I suspect that this trick might be in general memory-unsafe in the presence of data races (more precisely values from other threads might be seen before their initialization). (OCaml memory-safety claims do not apply here because it uses Obj.magic.)</div><br/><div id="35859394" class="c"><input type="checkbox" id="c-35859394" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#35856659">parent</a><span>|</span><a href="#35857114">next</a><span>|</span><label class="collapse" for="c-35859394">[-]</label><label class="expand" for="c-35859394">[1 more]</label></div><br/><div class="children"><div class="content">Forgive the silly question, but isn&#x27;t the speculative execution system responsible for making sure that speculation doesn&#x27;t break your program semantics? In general, would it not be a bug in the speculative execution system to (e.g.) dereference a null pointer if your program isn&#x27;t actually going to do that?<p>More generally, where can I read about this kind of thing to find out exactly what the speculative execution system is or isn&#x27;t allowed to do? Arm documents the speculation barrier instruction, and I&#x27;ve found a paper which models speculative execution formally, but no actual design semantics.</div><br/></div></div></div></div><div id="35857114" class="c"><input type="checkbox" id="c-35857114" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#35856659">prev</a><span>|</span><a href="#35857228">next</a><span>|</span><label class="collapse" for="c-35857114">[-]</label><label class="expand" for="c-35857114">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s very smart and shows a deep understanding of what is going on right down to the hardware.<p>That said I&#x27;d be a bit lost if I found the end result in any code that I was working with. I hope anyone using these sorts of tricks is also good at documentation and encapsulation.</div><br/></div></div><div id="35857228" class="c"><input type="checkbox" id="c-35857228" checked=""/><div class="controls bullet"><span class="by">s28l</span><span>|</span><a href="#35857114">prev</a><span>|</span><a href="#35856806">next</a><span>|</span><label class="collapse" for="c-35857228">[-]</label><label class="expand" for="c-35857228">[1 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t the unrolled version skip the speculation for three out of every four entries? If so, it seems suspicious that it does so much better when it looks like it&#x27;s a mix between the first and second version instead of just an unrolled implementation of the second version.<p>I&#x27;d also be interested in seeing how this performs when the data isn&#x27;t allocated in one chunk (which seems to be the absolute best case scenario for this trick).  Will it end up worse than the &quot;naive&quot; version due to all the branch mispredictions?</div><br/></div></div><div id="35856806" class="c"><input type="checkbox" id="c-35856806" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#35857228">prev</a><span>|</span><a href="#35857550">next</a><span>|</span><label class="collapse" for="c-35856806">[-]</label><label class="expand" for="c-35856806">[1 more]</label></div><br/><div class="children"><div class="content">Interesting, worth a read. It&#x27;s doing a little more than value speculation, it&#x27;s using unsafe to speculate on memory layout. The first thing I could think of was to unroll that loop, and they did that too. Nice :-)<p>I&#x27;d be curious what the machine code looks like.</div><br/></div></div><div id="35857550" class="c"><input type="checkbox" id="c-35857550" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#35856806">prev</a><span>|</span><label class="collapse" for="c-35857550">[-]</label><label class="expand" for="c-35857550">[1 more]</label></div><br/><div class="children"><div class="content">i didn&#x27;t know about the value speculation trick or about Obj.magic, so this is a fantastic article</div><br/></div></div></div></div></div></div></div></body></html>