<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1690880459345" as="style"/><link rel="stylesheet" href="styles.css?v=1690880459345"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://utcc.utoronto.ca/~cks/space/blog/linux/SystemdRestartHidesProblems">Systemd auto-restarts of units can hide problems from you</a>Â <span class="domain">(<a href="https://utcc.utoronto.ca">utcc.utoronto.ca</a>)</span></div><div class="subtext"><span>ingve</span> | <span>13 comments</span></div><br/><div><div id="36953849" class="c"><input type="checkbox" id="c-36953849" checked=""/><div class="controls bullet"><span class="by">crabbone</span><span>|</span><a href="#36953828">next</a><span>|</span><label class="collapse" for="c-36953849">[-]</label><label class="expand" for="c-36953849">[1 more]</label></div><br/><div class="children"><div class="content">There are plenty of similar examples out there.  Take, for instance, Kubernetes indefinitely failing to start a pod and just retrying while taking no action to notify whoever started the process (just hanging).<p>So, I can see two different aspects to this problem:<p>* Lack of alerts.<p>* Lack of RCA automation.<p>For the first one -- it would&#x27;ve been nice if systemd had a &quot;brother&quot; program that could be used for alerts, so that no custom solution was necessary and that services could properly report intermittent problems etc.<p>The second is contingent on several factors: re-envisioning error handling, declarative debugging and general popularization of the concept.  There are several major problems with error handling in system programming languages today.  Due to poor language runtime design, programmers learn to think about any and every error as essentially fatal.  Recovery is typically seen as impossible, and if there&#x27;s any sort of recovery code put in place, it&#x27;s usually the one that tries to do the cleanup and start fresh.  It&#x27;s never really about fixing the problem.  So, popularizing something like Common Lisp restart system with the ability to traverse the program stack back to the failing frame would&#x27;ve been a good first step in this direction.<p>Declarative debugging, on the other hand, could be taking another step forward, where it could be made into a separate program which describes a complex recovery scheme.  I.e. the idea of declarative debugging is that the programmer needs to describe the program in terms of constraints that should be checked when the program fails to identify the problematic place.  The step forward would be to add automation for the cases when the failed constraint is discovered.</div><br/></div></div><div id="36953828" class="c"><input type="checkbox" id="c-36953828" checked=""/><div class="controls bullet"><span class="by">evil-olive</span><span>|</span><a href="#36953849">prev</a><span>|</span><a href="#36953830">next</a><span>|</span><label class="collapse" for="c-36953828">[-]</label><label class="expand" for="c-36953828">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Whether you want to monitor for this sort of thing (and how) is an open question. It&#x27;s certainly possible that this is one of the times where your monitoring isn&#x27;t going to be comprehensive, because it&#x27;s infrequent enough, low impact enough, and hard enough to craft a specific alert.<p>my preferred way to alert on this is to use the process start time that&#x27;s included by default in most process-level Prometheus metrics (and is trivial to implement yourself, if you need to):<p><pre><code>    &gt; curl -s localhost:9100&#x2F;metrics | grep process_start_time_seconds
    # HELP process_start_time_seconds Start time of the process since unix epoch in seconds.
    # TYPE process_start_time_seconds gauge
    process_start_time_seconds 1.68957669109e+09
</code></pre>
on a stable system, this metric will be very close to static. you can feed it through the PromQL changes() function to get a count of how many restarts have happened in a given time window.<p>in my experience, for anything with an &quot;alert if it&#x27;s down for X minutes&quot; rule, you probably also want an &quot;alert if it restarts N times in Y minutes&quot; rule.</div><br/><div id="36953927" class="c"><input type="checkbox" id="c-36953927" checked=""/><div class="controls bullet"><span class="by">captn3m0</span><span>|</span><a href="#36953828">parent</a><span>|</span><a href="#36953830">next</a><span>|</span><label class="collapse" for="c-36953927">[-]</label><label class="expand" for="c-36953927">[1 more]</label></div><br/><div class="children"><div class="content">A relevant alternative is the systemd_exporter, which will export metrics for various systemd services, including restart count: <a href="https:&#x2F;&#x2F;github.com&#x2F;prometheus-community&#x2F;systemd_exporter#metrics">https:&#x2F;&#x2F;github.com&#x2F;prometheus-community&#x2F;systemd_exporter#met...</a></div><br/></div></div></div></div><div id="36953830" class="c"><input type="checkbox" id="c-36953830" checked=""/><div class="controls bullet"><span class="by">pikahumu</span><span>|</span><a href="#36953828">prev</a><span>|</span><a href="#36953547">next</a><span>|</span><label class="collapse" for="c-36953830">[-]</label><label class="expand" for="c-36953830">[1 more]</label></div><br/><div class="children"><div class="content">The reasonable way to notice is to have alerts for any unexpected restarts. Relying on noticing intermittent service disruption is bound to fail. And so is &quot;remembering to check for this&quot;:<p>&gt; in the future I&#x27;m going to want to remember to check for this<p>Whenever you think that sentence, you should notice this as a red flag and re-think your approach. You <i>will</i> forget. And if not you, then somebody else in your team. You need automation for things you can forget, otherwise your mental checklists will grow too large to handle and are just a distraction.</div><br/></div></div><div id="36953547" class="c"><input type="checkbox" id="c-36953547" checked=""/><div class="controls bullet"><span class="by">shoo</span><span>|</span><a href="#36953830">prev</a><span>|</span><a href="#36953241">next</a><span>|</span><label class="collapse" for="c-36953547">[-]</label><label class="expand" for="c-36953547">[2 more]</label></div><br/><div class="children"><div class="content">auto-restarting after a failure is a reasonable first order workaround for transient environment issues (network or external dependency goes away for a bit) or perhaps rare per-request issues that aren&#x27;t handled correctly. arguably it&#x27;d be better to understand and fix or mitigate the issue properly, but until you actually have time to do that, it&#x27;s nice for the service to autonomously attempt to be available.<p>...except when that causes even more problems!  one example i remember from a hobby project was a worker service that would make requests to an external service&#x27;s API. I&#x27;d implemented a throttle in the worker to limit the number of external requests per second made against the external service, where the throttle state was stored in process memory and not persisted anywhere -- seemed to be a pragmatic design tradeoff. you probably see where this is going.<p>there was an exciting interaction where an external API response caused the worker&#x27;s API client to throw an unhandled exception, which took down the worker service. then systemd would diligently restart the worker service immediately per the restart policy. the throttle working state had been lost, so upon being restarted the worker service immediately fired another request to the external API, which then issued the same API response, which caused the worker service to fail in the same way, ... luckily noticed by systemd and immediately restarted.<p>combine with a lack of monitoring + alerting and you get a mechanism where your worker service can make about 100,000x as many external API requests over a few days as it was meant to.</div><br/><div id="36953835" class="c"><input type="checkbox" id="c-36953835" checked=""/><div class="controls bullet"><span class="by">regecks</span><span>|</span><a href="#36953547">parent</a><span>|</span><a href="#36953241">next</a><span>|</span><label class="collapse" for="c-36953835">[-]</label><label class="expand" for="c-36953835">[1 more]</label></div><br/><div class="children"><div class="content">I always set `RestartSec`.</div><br/></div></div></div></div><div id="36953241" class="c"><input type="checkbox" id="c-36953241" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#36953547">prev</a><span>|</span><a href="#36953576">next</a><span>|</span><label class="collapse" for="c-36953241">[-]</label><label class="expand" for="c-36953241">[1 more]</label></div><br/><div class="children"><div class="content">Another interesting thing you may want to check for is coredumpctl. At $job, I&#x27;m installing a custom handler for those, extracting the stacktrace and submitting it to Rollbar with the rest of the app events. It only fired once so far, but it&#x27;s something you want to know about. (Same should be trivial to do with Sentry or other error reporting services)</div><br/></div></div><div id="36953576" class="c"><input type="checkbox" id="c-36953576" checked=""/><div class="controls bullet"><span class="by">gbraad</span><span>|</span><a href="#36953241">prev</a><span>|</span><a href="#36953233">next</a><span>|</span><label class="collapse" for="c-36953576">[-]</label><label class="expand" for="c-36953576">[1 more]</label></div><br/><div class="children"><div class="content">I think they rather received a phonecall&#x2F;pager on the weekend than having it restart. ;-)<p>This is actually part of the self-healing aspect. One way to see if a service restarts is using the following command:<p><pre><code>  sudo systemctl show [servicename].service -p NRestarts

</code></pre>
I prefer to have this set as<p><pre><code>  Restart=on-failure
</code></pre>
Also note, there are OnFailure to trigger an additional log message, or recovery service, and FailureAction to allow actions to happen, such as the suggested &#x27;reboot&#x27; ;-)<p>For reference: <a href="https:&#x2F;&#x2F;www.freedesktop.org&#x2F;software&#x2F;systemd&#x2F;man&#x2F;systemd.unit.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.freedesktop.org&#x2F;software&#x2F;systemd&#x2F;man&#x2F;systemd.uni...</a></div><br/></div></div><div id="36953233" class="c"><input type="checkbox" id="c-36953233" checked=""/><div class="controls bullet"><span class="by">KingOfCoders</span><span>|</span><a href="#36953576">prev</a><span>|</span><label class="collapse" for="c-36953233">[-]</label><label class="expand" for="c-36953233">[4 more]</label></div><br/><div class="children"><div class="content">But it can also make things more stable. I laughed when 30 years ago people recommended to restart Windows NT to make it more stable. I now have some Go websites running for a long time with daily Systemd restarts.</div><br/><div id="36953289" class="c"><input type="checkbox" id="c-36953289" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#36953233">parent</a><span>|</span><a href="#36953788">next</a><span>|</span><label class="collapse" for="c-36953289">[-]</label><label class="expand" for="c-36953289">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I now have some Go websites running for a long time with daily Systemd restarts.<p>Are the restarts needed because there&#x27;s malicious over-size content being sent to it, trying to exhaust the server resources?<p>If so, then &quot;http.MaxBytesReader&quot; <i>might</i> be helpful:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;sqlitebrowser&#x2F;dbhub.io&#x2F;blob&#x2F;5c9e1ab1cfe0f59b25fb78a576c0cac429323cad&#x2F;webui&#x2F;main.go#L5447">https:&#x2F;&#x2F;github.com&#x2F;sqlitebrowser&#x2F;dbhub.io&#x2F;blob&#x2F;5c9e1ab1cfe0f...</a></div><br/></div></div><div id="36953788" class="c"><input type="checkbox" id="c-36953788" checked=""/><div class="controls bullet"><span class="by">nonameiguess</span><span>|</span><a href="#36953233">parent</a><span>|</span><a href="#36953289">prev</a><span>|</span><a href="#36953442">next</a><span>|</span><label class="collapse" for="c-36953788">[-]</label><label class="expand" for="c-36953788">[1 more]</label></div><br/><div class="children"><div class="content">I believe this is one of the claims of chaos engineering. If you randomly restart services, you have to build them in a way that they&#x27;re resilient to random failures. If you do this to entire servers, VM, or containers, whatever your unit of OS userspace is, you can also kill an attacker&#x27;s foothold if they manage to get one. Sort of how if humans were capable of respawning in a healthy base state but with their memories intact, you could stop the spread of a disease by just killing everyone.</div><br/></div></div><div id="36953442" class="c"><input type="checkbox" id="c-36953442" checked=""/><div class="controls bullet"><span class="by">gbraad</span><span>|</span><a href="#36953233">parent</a><span>|</span><a href="#36953788">prev</a><span>|</span><label class="collapse" for="c-36953442">[-]</label><label class="expand" for="c-36953442">[1 more]</label></div><br/><div class="children"><div class="content">Edit: posted this as an independent comment</div><br/></div></div></div></div></div></div></div></div></div></body></html>