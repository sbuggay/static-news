<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1730451665107" as="style"/><link rel="stylesheet" href="styles.css?v=1730451665107"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://kaleidawave.github.io/posts/sets-types-and-type-checking/">Sets, types and type checking</a> <span class="domain">(<a href="https://kaleidawave.github.io">kaleidawave.github.io</a>)</span></div><div class="subtext"><span>kaleidawave</span> | <span>14 comments</span></div><br/><div><div id="42014486" class="c"><input type="checkbox" id="c-42014486" checked=""/><div class="controls bullet"><span class="by">nikeee</span><span>|</span><a href="#42012199">next</a><span>|</span><label class="collapse" for="c-42014486">[-]</label><label class="expand" for="c-42014486">[2 more]</label></div><br/><div class="children"><div class="content">An honorable mention is the string template literal type. It is between the string literal type (-unions); which allow a finite set of strings and the string type which, in theory, is an infinite set of strings. Template literal types can be infinite as well, but only represent a fraction. For example `foo${string}` represent all strings that start with &quot;foo&quot;.<p>Similar to this, I proposed inequality types for TS. They allow constraining a number range. For example, it is possible to have the type &quot;a number that is larger than 1&quot;. You can combine them using intersection types, forming intervals like &quot;a number between 0 and 1&quot;. Because TS has type narrowing via control flow, these types automatically come forward if you do an &quot;if (a&lt;5)&quot;. The variable will have the type &quot;(&lt;5)&quot; inside the if block.<p>You can find the proposal here [1]. Personally I think the effort for adding these isn&#x27;t worth it. But maybe someone likes it or takes it further.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;43505">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;43505</a></div><br/><div id="42015163" class="c"><input type="checkbox" id="c-42015163" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#42014486">parent</a><span>|</span><a href="#42012199">next</a><span>|</span><label class="collapse" for="c-42015163">[-]</label><label class="expand" for="c-42015163">[1 more]</label></div><br/><div class="children"><div class="content">I have no idea what I’m talking about, but it seems like these restricted cases of inequality flow control type checking are very similar in power to dependent types, but don’t require the same level of complexity. It’s nice being able to write imperative proofs of correctness guided by the compiler.</div><br/></div></div></div></div><div id="42012199" class="c"><input type="checkbox" id="c-42012199" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#42014486">prev</a><span>|</span><a href="#42012249">next</a><span>|</span><label class="collapse" for="c-42012199">[-]</label><label class="expand" for="c-42012199">[5 more]</label></div><br/><div class="children"><div class="content">I don’t think it is appropriate to say Rust has ‘union types’. Rust has sum types, implemented as Enums and (unsafe) Union types. There is a distinct difference between sum types and union types from a type theoretic perspective.</div><br/><div id="42013282" class="c"><input type="checkbox" id="c-42013282" checked=""/><div class="controls bullet"><span class="by">jasdfasd</span><span>|</span><a href="#42012199">parent</a><span>|</span><a href="#42012249">next</a><span>|</span><label class="collapse" for="c-42013282">[-]</label><label class="expand" for="c-42013282">[4 more]</label></div><br/><div class="children"><div class="content">disjoint union vs union.<p>Scala3 is the only programming language to implement both AFAIK.<p>C# has a proposal to add both unions and disjoint unions: <a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;csharplang&#x2F;blob&#x2F;main&#x2F;proposals&#x2F;TypeUnions.md">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;csharplang&#x2F;blob&#x2F;main&#x2F;proposals&#x2F;Typ...</a><p>OCaml has polymorphic variants which are open disjoint unions.<p>Kotlin is looking to add union types for errors: <a href="https:&#x2F;&#x2F;youtrack.jetbrains.com&#x2F;issue&#x2F;KT-68296&#x2F;Union-Types-for-Errors" rel="nofollow">https:&#x2F;&#x2F;youtrack.jetbrains.com&#x2F;issue&#x2F;KT-68296&#x2F;Union-Types-fo...</a><p>I believe Java&#x27;s checked exceptions behave somewhat like union types.</div><br/><div id="42014231" class="c"><input type="checkbox" id="c-42014231" checked=""/><div class="controls bullet"><span class="by">om2</span><span>|</span><a href="#42012199">root</a><span>|</span><a href="#42013282">parent</a><span>|</span><a href="#42014064">next</a><span>|</span><label class="collapse" for="c-42014231">[-]</label><label class="expand" for="c-42014231">[2 more]</label></div><br/><div class="children"><div class="content">What’s the difference between a union type and a disjoint union type? In that C# proposal I couldn’t tell which syntax was which branch of your dichotomy.</div><br/><div id="42014921" class="c"><input type="checkbox" id="c-42014921" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#42012199">root</a><span>|</span><a href="#42014231">parent</a><span>|</span><a href="#42014064">next</a><span>|</span><label class="collapse" for="c-42014921">[-]</label><label class="expand" for="c-42014921">[1 more]</label></div><br/><div class="children"><div class="content">disjoint union is sum type &#x2F; enum &#x2F; algebraic data type. Defined at the point of declaration. Each case is distinct (hence, disjoint)<p>union is what Typescript has. Defined at the point of use. Cases need not be distinct.</div><br/></div></div></div></div></div></div></div></div><div id="42012249" class="c"><input type="checkbox" id="c-42012249" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#42012199">prev</a><span>|</span><a href="#42015013">next</a><span>|</span><label class="collapse" for="c-42012249">[-]</label><label class="expand" for="c-42012249">[3 more]</label></div><br/><div class="children"><div class="content">`never` is better known as `bottom`. `noreturn` in some languages is the same thing<p>`any`, however, is not `top`, it is `break_the_type_system`. The top type in TS is `unknown`.</div><br/><div id="42014436" class="c"><input type="checkbox" id="c-42014436" checked=""/><div class="controls bullet"><span class="by">Nevermark</span><span>|</span><a href="#42012249">parent</a><span>|</span><a href="#42013064">next</a><span>|</span><label class="collapse" for="c-42014436">[-]</label><label class="expand" for="c-42014436">[1 more]</label></div><br/><div class="children"><div class="content">When someone gives you a truly completely unconstrained object, what they hand you is “unknown”.<p>You don’t even know how to query it to find anything out about it.<p>But you could pass it to someone else.<p>When someone asks you for a completely unconstrained object, the type is “any”.<p>It’s technically the same type from two perspectives.<p>(Not saying this extreme version of the concepts are how they are implemented. Never had a chance to use such types before.)</div><br/></div></div><div id="42013064" class="c"><input type="checkbox" id="c-42013064" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#42012249">parent</a><span>|</span><a href="#42014436">prev</a><span>|</span><a href="#42015013">next</a><span>|</span><label class="collapse" for="c-42013064">[-]</label><label class="expand" for="c-42013064">[1 more]</label></div><br/><div class="children"><div class="content">Adding the unknown type was such a big deal. I love it.</div><br/></div></div></div></div><div id="42015013" class="c"><input type="checkbox" id="c-42015013" checked=""/><div class="controls bullet"><span class="by">ingen0s</span><span>|</span><a href="#42012249">prev</a><span>|</span><a href="#42011528">next</a><span>|</span><label class="collapse" for="c-42015013">[-]</label><label class="expand" for="c-42015013">[1 more]</label></div><br/><div class="children"><div class="content">Finally, something useful to read</div><br/></div></div><div id="42011528" class="c"><input type="checkbox" id="c-42011528" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#42015013">prev</a><span>|</span><label class="collapse" for="c-42011528">[-]</label><label class="expand" for="c-42011528">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Like sets, types can be by description have an infinite number of distinct entries<p>I think they might have meant &quot;entities&quot; instead of &quot;entries?&quot;<p>The term &quot;diagonal identity&quot; seems to be non-standard as well?</div><br/><div id="42011980" class="c"><input type="checkbox" id="c-42011980" checked=""/><div class="controls bullet"><span class="by">dec0dedab0de</span><span>|</span><a href="#42011528">parent</a><span>|</span><label class="collapse" for="c-42011980">[-]</label><label class="expand" for="c-42011980">[1 more]</label></div><br/><div class="children"><div class="content">I usually say items or members, but entries basically means the same thing, and js set objects have an entries method, so there is precedence.</div><br/></div></div></div></div></div></div></div></div></div></body></html>