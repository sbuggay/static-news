<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692781262601" as="style"/><link rel="stylesheet" href="styles.css?v=1692781262601"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://crates.io/crates/wherr">Enhance Rust errors with file and line details</a> <span class="domain">(<a href="https://crates.io">crates.io</a>)</span></div><div class="subtext"><span>JoelJacobson</span> | <span>20 comments</span></div><br/><div><div id="37232828" class="c"><input type="checkbox" id="c-37232828" checked=""/><div class="controls bullet"><span class="by">diarrhea</span><span>|</span><a href="#37233415">next</a><span>|</span><label class="collapse" for="c-37232828">[-]</label><label class="expand" for="c-37232828">[4 more]</label></div><br/><div class="children"><div class="content">Reminds me of `diags` from [0].<p>Side note: can we make &#x27;file not found&#x27; errors that fail to mention <i>what</i> wasn&#x27;t found illegal? What&#x27;s the point of &#x27;file not found&#x27;, then keeping silent about the exact file? Seen it in various ecosystems now.<p>[0]: <a href="https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;macros.html#when-to-use-macros" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;macros.html#when-to-...</a></div><br/><div id="37233335" class="c"><input type="checkbox" id="c-37233335" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#37232828">parent</a><span>|</span><a href="#37233072">next</a><span>|</span><label class="collapse" for="c-37233335">[-]</label><label class="expand" for="c-37233335">[1 more]</label></div><br/><div class="children"><div class="content">No, because that&#x27;s not desired behavior in all cases. There can be security&#x2F;privacy issues stemming from that. Making it the default means you have to do string manipulation to cut out information you don&#x27;t otherwise want, which is way less robust and more fragile than simply not including it in the first place.</div><br/></div></div><div id="37233072" class="c"><input type="checkbox" id="c-37233072" checked=""/><div class="controls bullet"><span class="by">thristian</span><span>|</span><a href="#37232828">parent</a><span>|</span><a href="#37233335">prev</a><span>|</span><a href="#37232878">next</a><span>|</span><label class="collapse" for="c-37233072">[-]</label><label class="expand" for="c-37233072">[1 more]</label></div><br/><div class="children"><div class="content">The Unix kernel API only returns a numeric error code, no additional information. Nine times out of ten¹ the file that wasn&#x27;t found is the file that you just tried to open or rename or whatever, so a language runtime can make a copy of that and attach it to their error representation, but (a) that&#x27;s more work so it gets shunted out of the MVP, and (b) it requires allocating memory to store the copy, and some languages (like Rust) do not want silent memory allocation as a default behaviour.<p>¹: The one time out of ten is things like a script with a #! line that refers to a file that doesn&#x27;t exist. The file you asked for (the script) definitely exists, but you&#x27;ll get a file-not-found error if you ask the kernel to run it. Modern versions of bash seem to detect this situation and display a more helpful error message, but this is specific to bash, not other shells or languages.</div><br/></div></div><div id="37232878" class="c"><input type="checkbox" id="c-37232878" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#37232828">parent</a><span>|</span><a href="#37233072">prev</a><span>|</span><a href="#37233415">next</a><span>|</span><label class="collapse" for="c-37232878">[-]</label><label class="expand" for="c-37232878">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if not having `what` comes from two things:<p>1. the underlying OS error not containing what<p>2. some edge cases in which you don&#x27;t have a what, or at least not a clear one<p>3. paths, especially absolute paths, always being prone on leaking personal user information</div><br/></div></div></div></div><div id="37233415" class="c"><input type="checkbox" id="c-37233415" checked=""/><div class="controls bullet"><span class="by">lewantmontreal</span><span>|</span><a href="#37232828">prev</a><span>|</span><a href="#37232861">next</a><span>|</span><label class="collapse" for="c-37233415">[-]</label><label class="expand" for="c-37233415">[1 more]</label></div><br/><div class="children"><div class="content">I’ve always wondered why the backtrace just kind of stops midway to when you finally handle an error, instead of showing up to the `?` where the error happened. I’ve been using anyhow’s `with_context` to add helpful notes to each usage of `?` to get around it.<p>I’ll have to check if this macro is an easier solution!</div><br/></div></div><div id="37232861" class="c"><input type="checkbox" id="c-37232861" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#37233415">prev</a><span>|</span><a href="#37232809">next</a><span>|</span><label class="collapse" for="c-37232861">[-]</label><label class="expand" for="c-37232861">[3 more]</label></div><br/><div class="children"><div class="content">Note that some things, like anyhow do create backtraces (if the feature is enabled) when they are created, including by `?` auto-converting into them and including chaining the backtrace from the error they where created from.<p>Through also note that async code has  ... not so nice backtraces, for now, even if you only care about the calling location.</div><br/><div id="37233086" class="c"><input type="checkbox" id="c-37233086" checked=""/><div class="controls bullet"><span class="by">ahahahahah</span><span>|</span><a href="#37232861">parent</a><span>|</span><a href="#37232809">next</a><span>|</span><label class="collapse" for="c-37233086">[-]</label><label class="expand" for="c-37233086">[2 more]</label></div><br/><div class="children"><div class="content">anyhow&#x27;s backtraces are from where the error is created. This isn&#x27;t necessarily the same as the path through which it is propagated with &quot;?&quot;. honestly, i think the former is probably more valuable, but i really don&#x27;t know.</div><br/><div id="37233307" class="c"><input type="checkbox" id="c-37233307" checked=""/><div class="controls bullet"><span class="by">JoelJacobson</span><span>|</span><a href="#37232861">root</a><span>|</span><a href="#37233086">parent</a><span>|</span><a href="#37232809">next</a><span>|</span><label class="collapse" for="c-37233307">[-]</label><label class="expand" for="c-37233307">[1 more]</label></div><br/><div class="children"><div class="content">I like `anyhow`, it&#x27;s a great! But it doesn&#x27;t help if the existing error, wherever it is created, doesn&#x27;t already use `anyhow`.<p>For errors that you can&#x27;t find, then adding the `#[wherr]` macro to the functions, could possibly be faster, than changing all lines of code where errors are created, to use `anyhow`, to find the error.<p>`#[wherr]` is one line per function, whereas `anyhow`&#x27;s `.context()?` is one line per error.<p>Also, a backtrace could be more expensive than just wrapping the error once with file and line information as `wherr` does, and the backtrace might be overkill, if only interested in finding the line of code where the error is created.</div><br/></div></div></div></div></div></div><div id="37232809" class="c"><input type="checkbox" id="c-37232809" checked=""/><div class="controls bullet"><span class="by">imetatroll</span><span>|</span><a href="#37232861">prev</a><span>|</span><a href="#37232840">next</a><span>|</span><label class="collapse" for="c-37232809">[-]</label><label class="expand" for="c-37232809">[6 more]</label></div><br/><div class="children"><div class="content">There must be some downside to doing this?  That is, why wouldn&#x27;t the &#x27;?&#x27; operator already give us this kind of important detail?</div><br/><div id="37232825" class="c"><input type="checkbox" id="c-37232825" checked=""/><div class="controls bullet"><span class="by">vore</span><span>|</span><a href="#37232809">parent</a><span>|</span><a href="#37233013">next</a><span>|</span><label class="collapse" for="c-37232825">[-]</label><label class="expand" for="c-37232825">[2 more]</label></div><br/><div class="children"><div class="content">This boxes all errors and erases the return type at compile time.</div><br/><div id="37233095" class="c"><input type="checkbox" id="c-37233095" checked=""/><div class="controls bullet"><span class="by">ahahahahah</span><span>|</span><a href="#37232809">root</a><span>|</span><a href="#37232825">parent</a><span>|</span><a href="#37233013">next</a><span>|</span><label class="collapse" for="c-37233095">[-]</label><label class="expand" for="c-37233095">[1 more]</label></div><br/><div class="children"><div class="content">that&#x27;s pretty much a non-factor. the cost here is that dumping a bunch of file names and line numbers to users is a shit experience.</div><br/></div></div></div></div><div id="37233013" class="c"><input type="checkbox" id="c-37233013" checked=""/><div class="controls bullet"><span class="by">dannymi</span><span>|</span><a href="#37232809">parent</a><span>|</span><a href="#37232825">prev</a><span>|</span><a href="#37232840">next</a><span>|</span><label class="collapse" for="c-37233013">[-]</label><label class="expand" for="c-37233013">[3 more]</label></div><br/><div class="children"><div class="content">Imagine that you try to open your washing machine while it is washing.<p>Correctly, you will get an error that this is not possible because you would be drenched with water.<p>In addition, with this crate, you will also get the information that this error was returned in washing_machine.rs:3562. Thanks, I guess?<p>&gt;That is, why wouldn&#x27;t the &#x27;?&#x27; operator already give us this kind of important detail?<p>It&#x27;s just not very useful information to have, except for the original developer (when debugging)--and the latter is a minority use case. Rust doesn&#x27;t make you pay for things you don&#x27;t use.<p>But for this feature Rust would need to add an integer (and possible alignment bytes) and a str reference every single time there is a &quot;?&quot; (there are a lot of those) and an error is constructed, also when not debugging.<p>This crate requires you to add `#[wherr]` in order for it to change what `?` does--and you would only do that when debugging. That&#x27;s nice.</div><br/><div id="37233374" class="c"><input type="checkbox" id="c-37233374" checked=""/><div class="controls bullet"><span class="by">JoelJacobson</span><span>|</span><a href="#37232809">root</a><span>|</span><a href="#37233013">parent</a><span>|</span><a href="#37233264">next</a><span>|</span><label class="collapse" for="c-37233374">[-]</label><label class="expand" for="c-37233374">[1 more]</label></div><br/><div class="children"><div class="content">Author of `wherr` here. I agree that you wouldn&#x27;t always want to pay the extra cost for this information.<p>However, I imagine real-world use-cases when it&#x27;s preferable to pay that cost in production, allowing users to forward file and line information to the original developer via a bug report.<p>Alternatively, indirectly, for instance via some company&#x27;s customer support, that might ask the customer to include output from their program, which they in turn can let their developers analyse, who in turn can contact the developer of the library used, where the error originates from.<p>Not having this information in production, means the original developer will need to try to figure out how to reproduce the error locally, which might be necessary anyway of course, but the effort will probably be less, given the file and line information.<p>That said, I agree with you that the most likely use-case, is to enable this only when debugging, on a per-function basis, when needed.</div><br/></div></div><div id="37233264" class="c"><input type="checkbox" id="c-37233264" checked=""/><div class="controls bullet"><span class="by">yazaddaruvala</span><span>|</span><a href="#37232809">root</a><span>|</span><a href="#37233013">parent</a><span>|</span><a href="#37233374">prev</a><span>|</span><a href="#37232840">next</a><span>|</span><label class="collapse" for="c-37233264">[-]</label><label class="expand" for="c-37233264">[1 more]</label></div><br/><div class="children"><div class="content">Having the file and line number automatically added is quite useful for server logs - especially in production.<p>Very, very few end up in front of an end user. Typically only in a CLI.</div><br/></div></div></div></div></div></div><div id="37232840" class="c"><input type="checkbox" id="c-37232840" checked=""/><div class="controls bullet"><span class="by">dannymi</span><span>|</span><a href="#37232809">prev</a><span>|</span><a href="#37232734">next</a><span>|</span><label class="collapse" for="c-37232840">[-]</label><label class="expand" for="c-37232840">[4 more]</label></div><br/><div class="children"><div class="content">Errors are for the regular case when the program detected that  something wasn&#x27;t allowed or set up right and the program did everything right (by returning an error). Why then do you need the rs source code file&amp;line of the place where everything went right? What about all the other places where everything went right? Wanna log those, too? :)<p>What will the end user do with rs source code file&amp;line?<p>I read the example on the page. What they want to do is return which argument of `add` the error was with. Well, then introduce an `AddError` (or I guess it could be a more generic `BinaryOperationError`) like this: `struct AddError { argument_1: Option&lt;...&gt;, argument_2: Option&lt;...&gt; }` and return that error from `add`. Then you can even have it return errors due to both arguments at the same time.<p>One use case of the crate would be if you made a mistake and something actually shouldn&#x27;t be an error but should be a panic, and you wanna find where it is in order to change it to a panic. So, debugging.</div><br/><div id="37233150" class="c"><input type="checkbox" id="c-37233150" checked=""/><div class="controls bullet"><span class="by">JoelJacobson</span><span>|</span><a href="#37232840">parent</a><span>|</span><a href="#37232734">next</a><span>|</span><label class="collapse" for="c-37233150">[-]</label><label class="expand" for="c-37233150">[3 more]</label></div><br/><div class="children"><div class="content">Author of `wherr` here. The idea is to minimise the effort needed to debug programs that already make use of the `?` operator, when the underlying error doesn&#x27;t already contain file and line information, where the error is possibly coming from code of of your own control. Sure, you could catch such errors and return a refined error type, but that&#x27;s more code, which might be what you want in the end, but this is for the code that currently makes use of the simple `?` operator.<p>Once the file and line where the error is returned has been identified (using `wherr`), it might be a good idea, like you suggest, to introduce a new error type or refine the existing one. But maybe the error is fine as it is, and you just needed to know where it came from, to fix some bug, that when fixed, will cause the error to not happen any longer. Basically, when feeling confident an error cannot happen, some people use `.unwrap()` or `.expect()`, which *do* reveal the file and line, but then the program also panics. This might be what you want, but if you&#x27;re developing a library, you probably most times want to let the &quot;user&quot; (the developer using the library) decide what course of action to take, based on the error. However, that &quot;user&quot; might not be at all interested in the file and line information of where the error originates from in your library source code, since the user might not be capable of fixing the possible bug anyway. But maybe the user wants to file a bug report, and then it would be helpful to know the file and line information.<p>&gt; What about all the other places where everything went right? Wanna log those, too? :)<p>If everything went right, the Ok(val) is simply returned as Ok(val) unchanged, see `wherr&#x2F;src&#x2F;lib.rs`:
    match result {
        Ok(val) =&gt; Ok(val),
    ...</div><br/><div id="37233292" class="c"><input type="checkbox" id="c-37233292" checked=""/><div class="controls bullet"><span class="by">dannymi</span><span>|</span><a href="#37232840">root</a><span>|</span><a href="#37233150">parent</a><span>|</span><a href="#37233297">next</a><span>|</span><label class="collapse" for="c-37233292">[-]</label><label class="expand" for="c-37233292">[1 more]</label></div><br/><div class="children"><div class="content">This crate is nice to have for debugging. Thank you for writing it.<p>I just had the case already over the past decades where everyone wants to turn every error into Java backtraces (even when not in Java ;) ) and want to emphasize that this is almost never what one should do in regular operation.<p>As you said, unwrap() and expect() and panic!() do that for the &quot;definitely a bug&quot; case already. And, there, it&#x27;s correct.<p>&gt;probably most times want to let the &quot;user&quot; (the developer using the library) decide what course of action to take, based on the error.<p>I agree.<p>&gt;But maybe the user wants to file a bug report, and then it would be helpful to know the file and line information.<p>In my opinion this belongs in the debug information (i.e. dwarf or similar) then. You can also store dwarf debug info outside of the object file.<p>&gt;&gt; What about all the other places where everything went right? Wanna log those, too? :)<p>&gt;If everything went right, the Ok(val) is simply returned as Ok(val) unchanged, see `wherr&#x2F;src&#x2F;lib.rs`: match result { Ok(val) =&gt; Ok(val), ...<p>I see. But what I meant is that if the Err case of a regular Result value is enriched like this, why not the Ok case? After all, the programmer (user of your crate) could have erroneously returned Ok where they should have returned Err. Would only be consistent.<p>I know that that isn&#x27;t easily possible there. That brings me back to &quot;all result::Result construction sites should show up in dwarf debug info&quot;.<p>I use debuggers less than I should. But thinking about it that&#x27;s silly. We should be able to use debuggers to debug problems, including problems like this.</div><br/></div></div><div id="37233297" class="c"><input type="checkbox" id="c-37233297" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#37232840">root</a><span>|</span><a href="#37233150">parent</a><span>|</span><a href="#37233292">prev</a><span>|</span><a href="#37232734">next</a><span>|</span><label class="collapse" for="c-37233297">[-]</label><label class="expand" for="c-37233297">[1 more]</label></div><br/><div class="children"><div class="content">Excellent work! Note, this is also possible in tokio-rs&#x2F;tracing, by using `.with_file()` and `.with_line_number()` to the subscriber creation.. I&#x27;m sure you can set up filters&#x2F;layers for more granular control over this if you don&#x27;t always want file&#x2F;line info included, but it&#x27;s nice to have another option that makes it as easy as using the `#[wherr]` macro, and honestly, tokio-rs&#x2F;tracing layers and filters are a bit unwieldy.<p>If you don&#x27;t need that control though and don&#x27;t have a problem using `tracing` (which is excellent and <i>very</i> powerful btw), is there any reason to reach for wherr instead?</div><br/></div></div></div></div></div></div><div id="37232734" class="c"><input type="checkbox" id="c-37232734" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37232840">prev</a><span>|</span><label class="collapse" for="c-37232734">[-]</label><label class="expand" for="c-37232734">[1 more]</label></div><br/><div class="children"><div class="content">Ah, like automatically adding .context(&quot;msg&quot;) to Return values.</div><br/></div></div></div></div></div></div></div></body></html>