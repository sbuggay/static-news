<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722934862187" as="style"/><link rel="stylesheet" href="styles.css?v=1722934862187"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://felixk15.github.io/posts/dont-optimize-for-typing/">The human typewriter, or why optimizing for typing is short-sighted</a> <span class="domain">(<a href="https://felixk15.github.io">felixk15.github.io</a>)</span></div><div class="subtext"><span>ingve</span> | <span>31 comments</span></div><br/><div><div id="41168223" class="c"><input type="checkbox" id="c-41168223" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41168886">next</a><span>|</span><label class="collapse" for="c-41168223">[-]</label><label class="expand" for="c-41168223">[3 more]</label></div><br/><div class="children"><div class="content">This is something that seems to be settling down in language design. Local variables are usually implicitly typed, and function parameters are usually explicitly typed. This is for readability. &quot;auto&quot; was retrofitted to C&#x2F;C++ so those languages have implicit typing of locals. C# and Java added &quot;var&quot;. Rust uses &quot;let&quot;. So this is now pretty standard.<p>Type info is needed on function signatures mostly so people know how to call the thing.
That&#x27;s why Javascript and Python have acquired bolt-on typing systems. It&#x27;s also why cross-function type inference hasn&#x27;t caught on. It can be done technically, but it just confuses the humans.<p>Humans are not good at maintaining consistency between the thing right here and that other thing way over there. It&#x27;s best not to design systems which require that.</div><br/><div id="41168850" class="c"><input type="checkbox" id="c-41168850" checked=""/><div class="controls bullet"><span class="by">mattmanser</span><span>|</span><a href="#41168223">parent</a><span>|</span><a href="#41168886">next</a><span>|</span><label class="collapse" for="c-41168850">[-]</label><label class="expand" for="c-41168850">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not settling down, as C# just changed it up again.<p>They introduced some new syntaxes in recent versions, c#12 and 10(I think?):<p><pre><code>    List&lt;Foo&gt; foos = []; 
    Bar bar = new();
</code></pre>
I expect that to replace implicit var declarations as the &#x27;normal&#x27; way, especially as that&#x27;s what VS code analysis suggests now.</div><br/><div id="41168888" class="c"><input type="checkbox" id="c-41168888" checked=""/><div class="controls bullet"><span class="by">janaagaard</span><span>|</span><a href="#41168223">root</a><span>|</span><a href="#41168850">parent</a><span>|</span><a href="#41168886">next</a><span>|</span><label class="collapse" for="c-41168888">[-]</label><label class="expand" for="c-41168888">[1 more]</label></div><br/><div class="children"><div class="content">I believe &#x27;var&#x27; was introduced in C# to make it much easier to work with LINQ, where you can easily return a subset of properties - without var you would have had to declare interfaces. I think ReSharper is responsible for the rapid proliferation of using var everywhere.</div><br/></div></div></div></div></div></div><div id="41168886" class="c"><input type="checkbox" id="c-41168886" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#41168223">prev</a><span>|</span><a href="#41167609">next</a><span>|</span><label class="collapse" for="c-41168886">[-]</label><label class="expand" for="c-41168886">[2 more]</label></div><br/><div class="children"><div class="content">Using one letter variables and the such is excusable if you are new to programming and don&#x27;t know better or if you use it in such a local context that the short length helps readability or if it is a &quot;known&quot; short variable like <i>i</i> or some sort of speaking short variable like <i>db</i>.<p>I like to think of myself as a good programmer, but whenever I encounter code where I have to figure out what &quot;x&quot; means, when it could have been a speaking variable like &quot;accumulative_duration_ms&quot; I feel like someone is trying to be clever.<p>I see using auto in a similar light. Explicit return types are <i>good</i>. In fact there&#x27;s a trend to retrofit typing into languages that don&#x27;t have it. You showing me that you value not thinking about the return type over specifying explicit return types is a red flag to me.<p>If we as programmers should value anything, it is the time and mental resources of the person who has to read our code in the future — very often that person is going to be you, yourself.</div><br/><div id="41168958" class="c"><input type="checkbox" id="c-41168958" checked=""/><div class="controls bullet"><span class="by">lupusreal</span><span>|</span><a href="#41168886">parent</a><span>|</span><a href="#41167609">next</a><span>|</span><label class="collapse" for="c-41168958">[-]</label><label class="expand" for="c-41168958">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m okay with x, but <i>only</i> x.  Naming things can be hard so you get one freebie, but <i>only</i> one, so you better figure out a proper name for everything else after you use x.</div><br/></div></div></div></div><div id="41167609" class="c"><input type="checkbox" id="c-41167609" checked=""/><div class="controls bullet"><span class="by">lawn</span><span>|</span><a href="#41168886">prev</a><span>|</span><a href="#41168190">next</a><span>|</span><label class="collapse" for="c-41167609">[-]</label><label class="expand" for="c-41167609">[2 more]</label></div><br/><div class="children"><div class="content">&gt; auto lovers will say that the IDE will resolve the types for you if you really care, but would someone please think of our poor Vim &amp; Emacs users?<p>This poor Neovim user also has LSP with inline hints, hover and help like IDEs.<p>Vim&#x2F;Emacs aren&#x27;t just the dumb text editors anymore.</div><br/><div id="41168984" class="c"><input type="checkbox" id="c-41168984" checked=""/><div class="controls bullet"><span class="by">noname120</span><span>|</span><a href="#41167609">parent</a><span>|</span><a href="#41168190">next</a><span>|</span><label class="collapse" for="c-41168984">[-]</label><label class="expand" for="c-41168984">[1 more]</label></div><br/><div class="children"><div class="content">Maybe the poor Vim &amp; Emacs users should think about other developers that have better things to do than catering to their special needs.</div><br/></div></div></div></div><div id="41168190" class="c"><input type="checkbox" id="c-41168190" checked=""/><div class="controls bullet"><span class="by">jbandela1</span><span>|</span><a href="#41167609">prev</a><span>|</span><a href="#41168885">next</a><span>|</span><label class="collapse" for="c-41168190">[-]</label><label class="expand" for="c-41168190">[2 more]</label></div><br/><div class="children"><div class="content">The code presented has problems, but they are not the problems the author thinks it is.<p>The code is listed as c++. However, it is using a style that will result in problems.<p>First thing that jumped out at me is using const char* for strings. Using this muddies ownership and doesn’t store the length of the buffer which can result in all sorts of fun. Add to that that many times paths are formed by string concatenation, and it is looking like a code smell.<p>Second, there is no RAII and just manual management of resources.<p>These problems are far more likely to cause issues that the use of type deduction which by now has pretty good tooling support and is used successfully in many languages. Of course, not using RAII, using raw pointers make it tricky, but you shouldn’t be using those like that anyway.</div><br/></div></div><div id="41168885" class="c"><input type="checkbox" id="c-41168885" checked=""/><div class="controls bullet"><span class="by">hkrpnc</span><span>|</span><a href="#41168190">prev</a><span>|</span><a href="#41167324">next</a><span>|</span><label class="collapse" for="c-41168885">[-]</label><label class="expand" for="c-41168885">[1 more]</label></div><br/><div class="children"><div class="content">The author uses a code snippet that looks like the average Python code:<p>Untyped, non-descriptive objects calling each other randomly, with no chance for the reader to figure out what is going on.<p>So in this case <i>auto</i> is harmful. In many other cases it isn&#x27;t.</div><br/></div></div><div id="41167324" class="c"><input type="checkbox" id="c-41167324" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41168885">prev</a><span>|</span><a href="#41168485">next</a><span>|</span><label class="collapse" for="c-41167324">[-]</label><label class="expand" for="c-41167324">[6 more]</label></div><br/><div class="children"><div class="content">The article starts with a correct problem statement and concludes with a weird claim, because nowadays IDEs like Visual Studio Code do support the best of both worlds: inlay hints. I turn them off by default on VSCode (because it messes with columns, unfortunately) but configured them to `offUnlessPressed` so that I can quickly check inlay hints by pressing Ctrl+Alt&#x2F;Option.</div><br/><div id="41168053" class="c"><input type="checkbox" id="c-41168053" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#41167324">parent</a><span>|</span><a href="#41168485">next</a><span>|</span><label class="collapse" for="c-41168053">[-]</label><label class="expand" for="c-41168053">[5 more]</label></div><br/><div class="children"><div class="content">&gt; inlay hints<p>They are a feature of (and configured in) the LSP Server, so every editor that has LSP integration can display them. Still doesn&#x27;t help when there is no LSP around.</div><br/><div id="41168167" class="c"><input type="checkbox" id="c-41168167" checked=""/><div class="controls bullet"><span class="by">giomasce</span><span>|</span><a href="#41167324">root</a><span>|</span><a href="#41168053">parent</a><span>|</span><a href="#41168208">next</a><span>|</span><label class="collapse" for="c-41168167">[-]</label><label class="expand" for="c-41168167">[1 more]</label></div><br/><div class="children"><div class="content">I wish clangd let me configure the inlay hint elision length...</div><br/></div></div><div id="41168208" class="c"><input type="checkbox" id="c-41168208" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41167324">root</a><span>|</span><a href="#41168053">parent</a><span>|</span><a href="#41168167">prev</a><span>|</span><a href="#41168485">next</a><span>|</span><label class="collapse" for="c-41168208">[-]</label><label class="expand" for="c-41168208">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, I hope I didn&#x27;t annoy anyone using editors that have IDE supports via LSP :-p</div><br/><div id="41168340" class="c"><input type="checkbox" id="c-41168340" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#41167324">root</a><span>|</span><a href="#41168208">parent</a><span>|</span><a href="#41168485">next</a><span>|</span><label class="collapse" for="c-41168340">[-]</label><label class="expand" for="c-41168340">[2 more]</label></div><br/><div class="children"><div class="content">Well, you never know if vim users are upset because you are calling their editor an IDE or because you are calling it &quot;not an IDE&quot;.<p>I&#x27;d say &quot;vim user&quot; is already an insult in itself, so that doesn&#x27;t matter at all ;)</div><br/><div id="41168951" class="c"><input type="checkbox" id="c-41168951" checked=""/><div class="controls bullet"><span class="by">falcor84</span><span>|</span><a href="#41167324">root</a><span>|</span><a href="#41168340">parent</a><span>|</span><a href="#41168485">next</a><span>|</span><label class="collapse" for="c-41168951">[-]</label><label class="expand" for="c-41168951">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d say &quot;vim user&quot; is already an insult in itself, so that doesn&#x27;t matter at all ;)<p>I believe that the proper term is &quot;vim disciple&quot;</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41168485" class="c"><input type="checkbox" id="c-41168485" checked=""/><div class="controls bullet"><span class="by">redsaz</span><span>|</span><a href="#41167324">prev</a><span>|</span><a href="#41167893">next</a><span>|</span><label class="collapse" for="c-41168485">[-]</label><label class="expand" for="c-41168485">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This post can definitely be considered a “religious” opinion piece<p>The author certainly has that right, because the post steps on two programming religion landmines, from how I read it:<p>1. strict static typing (without type inference) is good. 
2. code should be written to <i>allow</i> IDEs to enhance navigability, rather than written on the assumption that IDEs will be the sole provider for navigability.<p>I believe there is a point to be made in the &quot;when we don&#x27;t know what we&#x27;re getting back, that harms navigability&quot; camp. But as another commenter posted,  there&#x27;s a point to be made in the &quot;when we overspecify what we&#x27;re getting back every time, that can harm readability, too&quot; camp.<p>I can&#x27;t express where this balance is. It&#x27;s somewhere between poetry and a legal document, the prose where you can really get into a good book and enjoy the world that the author presents. Some people really like the beauty of a short poem. Other people may require precise wording that leaves no room for enjoyment or interpretation. The rest of us can have the majority of fun somewhere in between.<p>Where that &quot;in between&quot; equivalent would be in my day-to-day programming, I&#x27;m not entirely sure, because what I&#x27;m writing could be a short script where brevity is vital (poetry-ish) vs some section of unfortunately highly complex code with lots of tests for edge cases (legalese), and all the other code where I&#x27;m still world-building and conveying ideas (prose). And I believe that complexity should be spelt out as precisely as it can in the code itself, rather than rely on the hope that somebody else is using the same IDEs and features as me. I&#x27;ve tried using type inference where it seems fine to use, and then spelling out the exact type that a variable wants where it isn&#x27;t clear what might get returned, all in the same app, but it comes across as sloppily inconsistent in my mind. Ah well.</div><br/></div></div><div id="41167893" class="c"><input type="checkbox" id="c-41167893" checked=""/><div class="controls bullet"><span class="by">huijzer</span><span>|</span><a href="#41168485">prev</a><span>|</span><a href="#41167135">next</a><span>|</span><label class="collapse" for="c-41167893">[-]</label><label class="expand" for="c-41167893">[1 more]</label></div><br/><div class="children"><div class="content">Although there are inline hints, I agree with you that auto makes readability worse. Especially in situations like PRs and Git forges where inline hints are not always available.<p>LLVM has a well thought out stance on auto too: <a href="https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;CodingStandards.html#id29" rel="nofollow">https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;CodingStandards.html#id29</a></div><br/></div></div><div id="41167135" class="c"><input type="checkbox" id="c-41167135" checked=""/><div class="controls bullet"><span class="by">Sytten</span><span>|</span><a href="#41167893">prev</a><span>|</span><a href="#41167997">next</a><span>|</span><label class="collapse" for="c-41167135">[-]</label><label class="expand" for="c-41167135">[2 more]</label></div><br/><div class="children"><div class="content">Rust and Kotlin would like a word. What a weird take. All editors now have LSP support now and your editor&#x2F;compiler should definitely figure this out for you.</div><br/><div id="41167184" class="c"><input type="checkbox" id="c-41167184" checked=""/><div class="controls bullet"><span class="by">QuercusMax</span><span>|</span><a href="#41167135">parent</a><span>|</span><a href="#41167997">next</a><span>|</span><label class="collapse" for="c-41167184">[-]</label><label class="expand" for="c-41167184">[1 more]</label></div><br/><div class="children"><div class="content">Also, any kind of weakly typed language.<p>I kinda liked working with pytype at Google; it let me specify types when it&#x27;s important either for correctness or documentation purposes, and ignore them when it&#x27;s obvious.<p>My experience working with modern C++ is that there are a zillion horrible templated types that mostly get in your way when you&#x27;re trying to do something boring. &#x27;auto&#x27; is a useful way to clear out that messy boilerplate garbage and make your code clearer. But if it&#x27;s not making your code clearer, then that&#x27;s what code reviews are for.</div><br/></div></div></div></div><div id="41167997" class="c"><input type="checkbox" id="c-41167997" checked=""/><div class="controls bullet"><span class="by">boxed</span><span>|</span><a href="#41167135">prev</a><span>|</span><a href="#41168404">next</a><span>|</span><label class="collapse" for="c-41167997">[-]</label><label class="expand" for="c-41167997">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny reading this coming from Python where I code without types and it&#x27;s perfectly fine.<p>That being said, there is a third option here:<p>- type `auto`<p>- have an autoformatter that replaces `auto` with `std::vector&lt;std::string&gt;::iterator` or whatever the abomination of a type you need is :P</div><br/><div id="41168078" class="c"><input type="checkbox" id="c-41168078" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41167997">parent</a><span>|</span><a href="#41168280">next</a><span>|</span><label class="collapse" for="c-41168078">[-]</label><label class="expand" for="c-41168078">[2 more]</label></div><br/><div class="children"><div class="content">&gt; have an autoformatter that replaces `auto` with `std::vector&lt;std::string&gt;::iterator` or whatever the abomination of a type you need is :P<p>I don&#x27;t know, that is obscuring a lot of details. I think we really need it to be<p><pre><code>   std::vector&lt;std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;, std::alocator&lt;std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;&gt;::iterator
</code></pre>
How would I be expected to understand the code if I didn&#x27;t know what char_traits are used in the vector&#x27;s allocator when opening the file in ed???</div><br/><div id="41168255" class="c"><input type="checkbox" id="c-41168255" checked=""/><div class="controls bullet"><span class="by">nottorp</span><span>|</span><a href="#41167997">root</a><span>|</span><a href="#41168078">parent</a><span>|</span><a href="#41168280">next</a><span>|</span><label class="collapse" for="c-41168255">[-]</label><label class="expand" for="c-41168255">[1 more]</label></div><br/><div class="children"><div class="content">You get that in the compiler error messages when you forget a ; 10 lines above ... best of both worlds ...</div><br/></div></div></div></div><div id="41168280" class="c"><input type="checkbox" id="c-41168280" checked=""/><div class="controls bullet"><span class="by">nottorp</span><span>|</span><a href="#41167997">parent</a><span>|</span><a href="#41168078">prev</a><span>|</span><a href="#41168404">next</a><span>|</span><label class="collapse" for="c-41168280">[-]</label><label class="expand" for="c-41168280">[1 more]</label></div><br/><div class="children"><div class="content">&gt; where I code without types and it&#x27;s perfectly fine<p>Is it? In my experience it goes downhill with the square of the size of the project.<p>That one 500 line glue script that does one thing and interacts with just the standard library? No types, yeah baby!<p>That 50k line app partly written by some dude who doesn&#x27;t work here any more? Now it&#x27;s getting annoying.<p>More? Even worse.</div><br/></div></div></div></div><div id="41168404" class="c"><input type="checkbox" id="c-41168404" checked=""/><div class="controls bullet"><span class="by">MeteorMarc</span><span>|</span><a href="#41167997">prev</a><span>|</span><a href="#41168303">next</a><span>|</span><label class="collapse" for="c-41168404">[-]</label><label class="expand" for="c-41168404">[1 more]</label></div><br/><div class="children"><div class="content">Optimizing for navigation is an interesting notion. Lack of navigation is also my main problem with class hierarchies. Importing a class is like import *: you do not see anymore in the module itself where some method is defined.</div><br/></div></div><div id="41168303" class="c"><input type="checkbox" id="c-41168303" checked=""/><div class="controls bullet"><span class="by">nottorp</span><span>|</span><a href="#41168404">prev</a><span>|</span><a href="#41168477">next</a><span>|</span><label class="collapse" for="c-41168303">[-]</label><label class="expand" for="c-41168303">[1 more]</label></div><br/><div class="children"><div class="content">To add to the original article&#x27;s point, even the IDEs are optimized for typing. Think how they auto complete { and &quot; and other stuff that comes in pairs for you. Great when you crank out new code, can be maddening when you&#x27;re editing.</div><br/></div></div><div id="41168477" class="c"><input type="checkbox" id="c-41168477" checked=""/><div class="controls bullet"><span class="by">dureuill</span><span>|</span><a href="#41168303">prev</a><span>|</span><a href="#41168266">next</a><span>|</span><label class="collapse" for="c-41168477">[-]</label><label class="expand" for="c-41168477">[2 more]</label></div><br/><div class="children"><div class="content">Very disappointing read.<p>Starts with an interesting claim &quot;don&#x27;t optimize for typing&quot;, but then it completely fails to prove it, and confuses itself in thinking that `auto` is an optimization for typing.<p>`auto` is:<p>- A way to express types that are impossible or truly difficult to express, such as iterators, lambdas, etc<p>- A way to optimize <i>reading</i>, by limiting the redundancy<p>- A way to optimize <i>maintenance</i>, by limiting the amount of change brought by a refactor<p>The insistence on notepad or &quot;dumb editors&quot; is also difficult to grasp. I expect people reviewing my code to be professionally equipped.<p>Lastly the example mostly fails to demonstrate the point.<p>- There&#x27;s a point made on naming (distinct from `auto`): absent a wrapping type, `dataSizeInBytes` is better than `dataSize`. The best way though is to have `dataSize` be a `Bytes` type that supports conversion at its boundaries (can be initialized from bytes, MB, etc)<p>- What&#x27;s the gain between:<p><pre><code>    auto dataSet = pDatabase-&gt;readData(queryResult.getValue());
</code></pre>
and<p><pre><code>    DatabaseDataSet dataSet = pDatabase-&gt;readData(queryResult.getValue());
</code></pre>
The `dataset` part can be inferred from the naming of the variable, it is useless to repeat it. The `Dabatase` is also clear from the fact that we read data from a db. Also, knowing the variable has this specific type brings me absolutely nothing.<p>- Their point about mutability of the db data confused me, as it is <i>not</i> clear to me if I can modify a &quot;shadow copy&quot; (I suppose not?). I suggest they use a programming language where mutating something you should not it a compile time error, it is much more failsafe than naming (which is hard)<p>I&#x27;m sad, because indeed one shouldn&#x27;t blindly optimize for <i>typing</i>, and I frequently find myself wondering when people tell me C++ is <i>faster to write</i> than Rust, when I (and others) empirically measured that <i>completing a task</i>, which is the interesting measure IMO, is twice as fast in the latter than in the former.<p>So I would have loved a defence of why more typing does not equate higher productivity. But this ain&#x27;t it.</div><br/><div id="41168611" class="c"><input type="checkbox" id="c-41168611" checked=""/><div class="controls bullet"><span class="by">redsaz</span><span>|</span><a href="#41168477">parent</a><span>|</span><a href="#41168266">next</a><span>|</span><label class="collapse" for="c-41168611">[-]</label><label class="expand" for="c-41168611">[1 more]</label></div><br/><div class="children"><div class="content">&gt; empirically measured that <i>completing a task</i>... is twice as fast in [Rust] than in [C++]<p>I have not read up on which tasks you&#x27;re referring to that are empirically measured, apologies. The reason I&#x27;m curious on what the tasks are, is that depending on the task, navigability may not matter.<p>For example, if the task is &quot;build a tool that does X&quot;, then navigability of the code does not matter. Once built, the tool does X, and there&#x27;s no reason to revisit the code, and thus no reason to navigate the code.<p>But if the task is &quot;Given a tool that already does W, X, Y, make the tool also do X&#x27;, Y&#x27;, and Z&quot;, then navigability of the code matters. This is because the coder must understand what the tool already does, and where the changes need to be made.<p>Most of my professional life, (and I&#x27;m willing to bet, most other coders here as well) I more often find myself in the second task than the first.<p>But, I&#x27;m not interested in Rust vs C++. I&#x27;d be more interested in the results of &quot;given a version that makes high use of type inference vs not, how quickly can someone new to the project add X&#x27;, Y&#x27;, and Z.&quot; That would be a more appropriate test for what the author describes here. And I&#x27;d imagine that probably, those that are using sufficiently advanced IDEs would beat out those without, regardless of if type inference used or not, and would probably be slightly faster when given the highly type-inferenced version.</div><br/></div></div></div></div><div id="41168266" class="c"><input type="checkbox" id="c-41168266" checked=""/><div class="controls bullet"><span class="by">diffuse_l</span><span>|</span><a href="#41168477">prev</a><span>|</span><label class="collapse" for="c-41168266">[-]</label><label class="expand" for="c-41168266">[2 more]</label></div><br/><div class="children"><div class="content">My take is that auto primary advantage isn&#x27;t optimizing for typing, it&#x27;s optimizing for refactoring.</div><br/><div id="41168361" class="c"><input type="checkbox" id="c-41168361" checked=""/><div class="controls bullet"><span class="by">nottorp</span><span>|</span><a href="#41168266">parent</a><span>|</span><label class="collapse" for="c-41168361">[-]</label><label class="expand" for="c-41168361">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s for job security. Your replacement won&#x27;t be able to figure out anything, will be very slow, get fired, and then they&#x27;ll rehire you at consulting rates.</div><br/></div></div></div></div></div></div></div></div></div></body></html>