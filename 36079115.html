<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685091693682" as="style"/><link rel="stylesheet" href="styles.css?v=1685091693682"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://cacm.acm.org/magazines/2023/6/273222-the-silent-revolution-of-sat/fulltext">The Silent (R)evolution of SAT</a> <span class="domain">(<a href="https://cacm.acm.org">cacm.acm.org</a>)</span></div><div class="subtext"><span>panic</span> | <span>26 comments</span></div><br/><div><div id="36079985" class="c"><input type="checkbox" id="c-36079985" checked=""/><div class="controls bullet"><span class="by">degoodm</span><span>|</span><a href="#36081515">next</a><span>|</span><label class="collapse" for="c-36079985">[-]</label><label class="expand" for="c-36079985">[6 more]</label></div><br/><div class="children"><div class="content">&quot;Is progress in SAT solving the sole result of hardware advancement? Time Leap Challenge compared 20-year-old SAT solvers on new computer hardware and modern SAT solvers on 20-year-old computer hardware. Although hardware improvements make old solvers faster, algorithmic progress dominates and drives today&#x27;s SAT solving.&quot;*<p>Pretty cool given computing progress over the last 20 years:<p><pre><code>  1. CPUs sped up 40-60x
  2. GPU FLOPS&#x2F;$ increased ~10,000x


</code></pre>
Sources:<p><pre><code>  1. https:&#x2F;&#x2F;www.cpubenchmark.net&#x2F;year-on-year.html
  2. https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FLOPS#Hardware_costs
</code></pre>
*Quote shortened for brevity</div><br/><div id="36080239" class="c"><input type="checkbox" id="c-36080239" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#36079985">parent</a><span>|</span><a href="#36081350">next</a><span>|</span><label class="collapse" for="c-36080239">[-]</label><label class="expand" for="c-36080239">[1 more]</label></div><br/><div class="children"><div class="content">You may want to read &quot;A Time Leap Challenge for SAT Solving&quot;. It&#x27;s just a really fun paper: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2008.02215" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2008.02215</a></div><br/></div></div><div id="36081350" class="c"><input type="checkbox" id="c-36081350" checked=""/><div class="controls bullet"><span class="by">bmc7505</span><span>|</span><a href="#36079985">parent</a><span>|</span><a href="#36080239">prev</a><span>|</span><a href="#36081515">next</a><span>|</span><label class="collapse" for="c-36081350">[-]</label><label class="expand" for="c-36081350">[4 more]</label></div><br/><div class="children"><div class="content">And yet, despite tremendous progress accelerating continuous optimization workloads, there are still no competitive GPU-based SAT solvers. I wonder why?</div><br/><div id="36081557" class="c"><input type="checkbox" id="c-36081557" checked=""/><div class="controls bullet"><span class="by">porcoda</span><span>|</span><a href="#36079985">root</a><span>|</span><a href="#36081350">parent</a><span>|</span><a href="#36081387">next</a><span>|</span><label class="collapse" for="c-36081557">[-]</label><label class="expand" for="c-36081557">[1 more]</label></div><br/><div class="children"><div class="content">Super short answer: SAT doesn’t exhibit the nice properties other optimization problems often have where you can tell when you’re near a correct answer.  So it doesn’t resemble most continuous optimization problems.  Regarding parallelism, there has been research into parallel SAT, but it’s hard in part due to the problem of sharing information between threads&#x2F;tasks in conflict clause learning algorithms.  I don’t remember specific papers but a quick search on google scholar or looking at past SAT competitions would turn up material if you’re interested in the topic.</div><br/></div></div><div id="36081387" class="c"><input type="checkbox" id="c-36081387" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#36079985">root</a><span>|</span><a href="#36081350">parent</a><span>|</span><a href="#36081557">prev</a><span>|</span><a href="#36081515">next</a><span>|</span><label class="collapse" for="c-36081387">[-]</label><label class="expand" for="c-36081387">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just GPU. There are not even good multicore SAT solvers. State of the art SAT algorithms are serial and they don&#x27;t parallelize.</div><br/><div id="36081480" class="c"><input type="checkbox" id="c-36081480" checked=""/><div class="controls bullet"><span class="by">bmc7505</span><span>|</span><a href="#36079985">root</a><span>|</span><a href="#36081387">parent</a><span>|</span><a href="#36081515">next</a><span>|</span><label class="collapse" for="c-36081480">[-]</label><label class="expand" for="c-36081480">[1 more]</label></div><br/><div class="children"><div class="content">I was thinking there might be some theoretical barrier to parallelization, e.g., maybe naturally-arising SAT instances have poor empirical scaling constants [1], so sequential solvers with good branch heuristics are pretty close to optimal. There are some portfolio solvers (e.g., [2]) that have shown modest, but not dramatic speedups. Or maybe we just haven&#x27;t tried hard enough.<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;NC_(complexity)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;NC_(complexity)</a><p>[2]: <a href="https:&#x2F;&#x2F;baldur.iti.kit.edu&#x2F;hordesat&#x2F;files&#x2F;horde.pdf" rel="nofollow">https:&#x2F;&#x2F;baldur.iti.kit.edu&#x2F;hordesat&#x2F;files&#x2F;horde.pdf</a></div><br/></div></div></div></div></div></div></div></div><div id="36081515" class="c"><input type="checkbox" id="c-36081515" checked=""/><div class="controls bullet"><span class="by">xavxav</span><span>|</span><a href="#36079985">prev</a><span>|</span><a href="#36081251">next</a><span>|</span><label class="collapse" for="c-36081515">[-]</label><label class="expand" for="c-36081515">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if they&#x27;ll write a followup on the SMT revolution that happened after the CDCL breakthroughs for SAT.<p>The lazy approach to SMT was a huge step forward, but itself spawned a whole lineage of refinements, alternatives and changed the state of automated reasoning entirely.<p>A lot of work today seems to be going into <i>theory combinations</i> so that you can efficiently answer problems for example involve arrays and integers in a manner that has dependencies between the two.<p>&#x27;Solving&#x27; (it&#x27;s an undecidable problem) SMT would open up a bunch of new possibilities..</div><br/></div></div><div id="36081251" class="c"><input type="checkbox" id="c-36081251" checked=""/><div class="controls bullet"><span class="by">vivegi</span><span>|</span><a href="#36081515">prev</a><span>|</span><a href="#36080431">next</a><span>|</span><label class="collapse" for="c-36081251">[-]</label><label class="expand" for="c-36081251">[1 more]</label></div><br/><div class="children"><div class="content">SAT is tantalizingly simple to describe and is an intense rabbit-hole if you are intellectually curious. I liked the article.<p>The SAT Competition [1] is a good place to find state of the art.<p>[1]: <a href="http:&#x2F;&#x2F;www.satcompetition.org&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.satcompetition.org&#x2F;</a></div><br/></div></div><div id="36080431" class="c"><input type="checkbox" id="c-36080431" checked=""/><div class="controls bullet"><span class="by">doetoe</span><span>|</span><a href="#36081251">prev</a><span>|</span><a href="#36080831">next</a><span>|</span><label class="collapse" for="c-36080431">[-]</label><label class="expand" for="c-36080431">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not an expert in any of these, but in the past few years, in addition to the success of LLM&#x27;s for natural language processing, I have repeatedly read about the impressive advances in SAT solvers and in proof assistants.
Given how impressive LLM&#x27;s are in spite of their inability to reliably perform reasoning tasks or follow instructions with logical strictness, I wonder how much more impressive it could get if such systems got integrated</div><br/><div id="36080984" class="c"><input type="checkbox" id="c-36080984" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#36080431">parent</a><span>|</span><a href="#36080831">next</a><span>|</span><label class="collapse" for="c-36080984">[-]</label><label class="expand" for="c-36080984">[1 more]</label></div><br/><div class="children"><div class="content">You will enjoy &quot;Maieutic Prompting: Logically Consistent Reasoning with Recursive Explanations&quot;. It prompts LLM to generate tree of explanations and run MAX-SAT solver over it: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2205.11822" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2205.11822</a></div><br/></div></div></div></div><div id="36080831" class="c"><input type="checkbox" id="c-36080831" checked=""/><div class="controls bullet"><span class="by">Hirrolot</span><span>|</span><a href="#36080431">prev</a><span>|</span><a href="#36080472">next</a><span>|</span><label class="collapse" for="c-36080831">[-]</label><label class="expand" for="c-36080831">[6 more]</label></div><br/><div class="children"><div class="content">I wonder what is the target audience of articles like this. I think the article is well-written, however 90-95% of the terminology make little or no sense to me who is not proficient in this field. Would the article be useful for someone who _is_ proficient in the field?</div><br/><div id="36081328" class="c"><input type="checkbox" id="c-36081328" checked=""/><div class="controls bullet"><span class="by">Jaxan</span><span>|</span><a href="#36080831">parent</a><span>|</span><a href="#36081008">next</a><span>|</span><label class="collapse" for="c-36081328">[-]</label><label class="expand" for="c-36081328">[1 more]</label></div><br/><div class="children"><div class="content">The target audience is members of the acm. So that mostly includes computer science researchers, I guess.</div><br/></div></div><div id="36081008" class="c"><input type="checkbox" id="c-36081008" checked=""/><div class="controls bullet"><span class="by">bjarneh</span><span>|</span><a href="#36080831">parent</a><span>|</span><a href="#36081328">prev</a><span>|</span><a href="#36080472">next</a><span>|</span><label class="collapse" for="c-36081008">[-]</label><label class="expand" for="c-36081008">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Would the article be useful for someone who _is_ proficient in the field?<p>Yes, it is a very well written summary of what has been going on with SAT solvers in the last decades. I personally think most of this (r)evolution can be attributed to miniSAT. A relatively easy to read (at least compared to other theorem provers), free software implementation of a SAT solver, with instantiations if I remember correctly. Since variables only have two possible valuations (true&#x2F;false) in boolean logic, they can be instantiated and the problem can be split up, and sometimes greatly simplified in doing so. I.e. we can replace each occurrence of variable &#x27;a&#x27; with &#x27;true&#x27; to make a new smaller problem, and then replace each occurrence variable &#x27;a&#x27; with &#x27;false&#x27; to make another smaller problem. I.e. split 1 problem into 2 simpler problems, and solve them in parallel etc.</div><br/><div id="36081071" class="c"><input type="checkbox" id="c-36081071" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#36080831">root</a><span>|</span><a href="#36081008">parent</a><span>|</span><a href="#36080472">next</a><span>|</span><label class="collapse" for="c-36081071">[-]</label><label class="expand" for="c-36081071">[3 more]</label></div><br/><div class="children"><div class="content">As I remember, Glucose was a larger advance than MiniSat. MiniSat was well-engineered but not exceptional. Glucose started as a hack, but the heuristic it introduced was so effective that you basically couldn&#x27;t compete without copying it.</div><br/><div id="36081384" class="c"><input type="checkbox" id="c-36081384" checked=""/><div class="controls bullet"><span class="by">bjarneh</span><span>|</span><a href="#36080831">root</a><span>|</span><a href="#36081071">parent</a><span>|</span><a href="#36080472">next</a><span>|</span><label class="collapse" for="c-36081384">[-]</label><label class="expand" for="c-36081384">[2 more]</label></div><br/><div class="children"><div class="content">You could be correct. I haven&#x27;t worked in academia for about 12 years; and I mostly worked on other types of logic. I do remember miniSAT being praised for its openness and readability, and it seems to predate the Glucose solver by some years. I.e. &quot;in my day&quot; miniSAT had all the praise, but perhaps Glucose was a more important contribution to the field.</div><br/><div id="36081519" class="c"><input type="checkbox" id="c-36081519" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#36080831">root</a><span>|</span><a href="#36081384">parent</a><span>|</span><a href="#36080472">next</a><span>|</span><label class="collapse" for="c-36081519">[-]</label><label class="expand" for="c-36081519">[1 more]</label></div><br/><div class="children"><div class="content">FWIW, Knuth&#x27;s chapter on satisfiability mentions MiniSat once for historical interest and discusses Glucose heuristic for five pages. This matches my impression of their technical contributions.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36080472" class="c"><input type="checkbox" id="c-36080472" checked=""/><div class="controls bullet"><span class="by">ComplexSystems</span><span>|</span><a href="#36080831">prev</a><span>|</span><label class="collapse" for="c-36080472">[-]</label><label class="expand" for="c-36080472">[9 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really get why people think P≠NP anymore. I mean, isn&#x27;t everyone expecting some kind of superintelligent AGI that can recursively improve itself to turn the planet into goo? Don&#x27;t people think that this kind of AGI will get so good at nonlinear optimization that it will turn all humans into paperclips as a way to maximize the output of a paperclip factory? Why do we think that this insane next-level intelligence will somehow be able to do things like that, but not be able to figure out what pattern of bits gets a bunch of AND and OR gates to output a &quot;1&quot;?<p>10-15 years ago, the basic idea was &quot;P≠NP because otherwise computers could do crazy shit.&quot; Well, looks like they can do crazy shit!</div><br/><div id="36080749" class="c"><input type="checkbox" id="c-36080749" checked=""/><div class="controls bullet"><span class="by">sirwhinesalot</span><span>|</span><a href="#36080472">parent</a><span>|</span><a href="#36080818">next</a><span>|</span><label class="collapse" for="c-36080749">[-]</label><label class="expand" for="c-36080749">[1 more]</label></div><br/><div class="children"><div class="content">There already exist local-search based algorithms that can find solutions way faster than a SAT solver can... Or they get completely stuck unable to make any progress.<p>All an LLM does is guess the next token based on the previous tokens and its training weights. For it to give you a solution to a large SAT problem it&#x27;ll have to spit out a million character long binary string.<p>The likelyhood most of that string will be entirely hallucinated is very high. LLMs are not magic.<p>Deep Learning is already used internally in some SAT solvers to heuristically pick in which direction the search should go.</div><br/></div></div><div id="36080818" class="c"><input type="checkbox" id="c-36080818" checked=""/><div class="controls bullet"><span class="by">abetusk</span><span>|</span><a href="#36080472">parent</a><span>|</span><a href="#36080749">prev</a><span>|</span><a href="#36080787">next</a><span>|</span><label class="collapse" for="c-36080818">[-]</label><label class="expand" for="c-36080818">[1 more]</label></div><br/><div class="children"><div class="content">P != NP is more likely akin to a fundamental mathematical law, like Noethers theorem [0]. No amount of self improving AI will alter the fundamental laws of physics. More provincially, in our solar system, there&#x27;s a cap on energy so that any system that uses it will eventually hit a ceiling (like a self improving AI that eats up energy resources at an exponential pace).<p>As motivation for why P != NP, one can think of it as a finite restatement of the Halting Problem [1] in the form of asking whether a (polynomially sized) Turing machine has an input that will halt in K steps.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Noether%27s_theorem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Noether%27s_theorem</a><p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Halting_problem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Halting_problem</a></div><br/></div></div><div id="36080787" class="c"><input type="checkbox" id="c-36080787" checked=""/><div class="controls bullet"><span class="by">ftxbro</span><span>|</span><a href="#36080472">parent</a><span>|</span><a href="#36080818">prev</a><span>|</span><a href="#36080702">next</a><span>|</span><label class="collapse" for="c-36080787">[-]</label><label class="expand" for="c-36080787">[5 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;10-15 years ago, the basic idea was &quot;P≠NP because otherwise computers could do crazy shit.&quot;<p>Everyone is downvoting you because that&#x27;s not the mathematical explanation, but it&#x27;s absolutely the informal explanation that the &#x27;pop science&#x27; ones were saying.</div><br/><div id="36080869" class="c"><input type="checkbox" id="c-36080869" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#36080472">root</a><span>|</span><a href="#36080787">parent</a><span>|</span><a href="#36080702">next</a><span>|</span><label class="collapse" for="c-36080869">[-]</label><label class="expand" for="c-36080869">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it was the informal explanation ever. People think that P≠NP, because they tried it hard, and did not find any NP-hard problem in P.</div><br/><div id="36081132" class="c"><input type="checkbox" id="c-36081132" checked=""/><div class="controls bullet"><span class="by">ftxbro</span><span>|</span><a href="#36080472">root</a><span>|</span><a href="#36080869">parent</a><span>|</span><a href="#36080702">next</a><span>|</span><label class="collapse" for="c-36081132">[-]</label><label class="expand" for="c-36081132">[3 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;People think that P≠NP, because they tried it hard, and did not find any NP-hard problem in P.&quot;<p>That was the informal explanation given to the computer scientists. But that&#x27;s not so convincing to non computer scientists and it&#x27;s not the informal &#x27;pop science&#x27; explanation.<p>An example (not the only one) of the kind of &#x27;pop science&#x27; explanation I mean, is Impagliazzo&#x27;s Five Worlds (<a href="https:&#x2F;&#x2F;gwern.net&#x2F;doc&#x2F;cs&#x2F;cryptography&#x2F;1995-impagliazzo.pdf" rel="nofollow">https:&#x2F;&#x2F;gwern.net&#x2F;doc&#x2F;cs&#x2F;cryptography&#x2F;1995-impagliazzo.pdf</a>). One of those hypothetical worlds he called &#x27;Algorithmica&#x27; and it&#x27;s where P = NP. One of the amazing and outlandish things that could be accomplished in such an exotic world would be the following feat: &quot;Thus, a computer could be taught to recognize and parse grammatically correct English just by having sufficiently many examples of correct and incorrect English statements, without needing any specialized knowledge of grammar or English.&quot;<p>It&#x27;s not so wild to me, to think that if someone&#x27;s understanding of P vs. NP was from that kind of pop science article, then they would think we should start considering more seriously that we are in the Algorithmica (P = NP) world where such feats are possible!</div><br/><div id="36081621" class="c"><input type="checkbox" id="c-36081621" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#36080472">root</a><span>|</span><a href="#36081132">parent</a><span>|</span><a href="#36081535">next</a><span>|</span><label class="collapse" for="c-36081621">[-]</label><label class="expand" for="c-36081621">[1 more]</label></div><br/><div class="children"><div class="content">Thank you. I stand corrected, people indeed argued &quot;10-15 years ago, the basic idea was &quot;P≠NP because otherwise computers could do crazy shit.&quot; (1 person at least).</div><br/></div></div><div id="36081535" class="c"><input type="checkbox" id="c-36081535" checked=""/><div class="controls bullet"><span class="by">eesmith</span><span>|</span><a href="#36080472">root</a><span>|</span><a href="#36081132">parent</a><span>|</span><a href="#36081621">prev</a><span>|</span><a href="#36080702">next</a><span>|</span><label class="collapse" for="c-36081535">[-]</label><label class="expand" for="c-36081535">[1 more]</label></div><br/><div class="children"><div class="content">If P = NP because there&#x27;s a O(N^{Graham&#x27;s Number}) polynomial algorithm - a &#x27;galactic algorithm&#x27; indeed - then the lay description is theoretically correct, but meaningless in practice.<p>In particular, the hand-waving is the phrase &#x27;sufficiently many examples.&#x27; This may be impossible to provide even if only a googol (10^100) examples are needed, because of mass and energy limitations of the universe - there&#x27;s only so much you can do with 10^80 atoms, and the speed of light is too slow.<p>&quot;Only a googol&quot; because Graham&#x27;s Number is mind-boggingly huge - <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Graham%27s_number" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Graham%27s_number</a><p>The Wikipedia entry for &quot;galactic algorithm&quot; at <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Galactic_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Galactic_algorithm</a> even mentions SAT: &quot;a hypothetical large but polynomial O(n^2^100) algorithm for the Boolean satisfiability problem, although unusable in practice, would settle the P versus NP problem&quot;.<p>Algorithmica may therefore be very little different than our world, other than that people no longer debate if P = NP.</div><br/></div></div></div></div></div></div></div></div><div id="36080702" class="c"><input type="checkbox" id="c-36080702" checked=""/><div class="controls bullet"><span class="by">adwn</span><span>|</span><a href="#36080472">parent</a><span>|</span><a href="#36080787">prev</a><span>|</span><label class="collapse" for="c-36080702">[-]</label><label class="expand" for="c-36080702">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>but not be able to figure out what pattern of bits gets a bunch of AND and OR gates to output a &quot;1&quot;? 10-15 years ago, the basic idea was &quot;P≠NP because otherwise computers could do crazy shit.&quot; Well, looks like they can do crazy shit!</i><p>I think you&#x27;ve fundamentally misunderstood the meaning of the P!=NP problem. In very simplified terms, it&#x27;s not about what a computer <i>can do</i>, but about <i>how long</i> it takes to do something in the worst case.</div><br/></div></div></div></div></div></div></div></div></div></body></html>