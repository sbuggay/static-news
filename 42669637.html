<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1736672473216" as="style"/><link rel="stylesheet" href="styles.css?v=1736672473216"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.digitalmars.com/articles/Cobvious.html">Obvious things C should do</a> <span class="domain">(<a href="https://www.digitalmars.com">www.digitalmars.com</a>)</span></div><div class="subtext"><span>LorenDB</span> | <span>173 comments</span></div><br/><div><div id="42671205" class="c"><input type="checkbox" id="c-42671205" checked=""/><div class="controls bullet"><span class="by">TheNewAndy</span><span>|</span><a href="#42671271">next</a><span>|</span><label class="collapse" for="c-42671205">[-]</label><label class="expand" for="c-42671205">[51 more]</label></div><br/><div class="children"><div class="content">Header files are one of the things I miss the most about languages that aren&#x27;t C. Having a very clear distinction between public and private, and interface and implementation is one of my favourite things about C code (at least the way I write it).<p>Being able to just read through a library&#x27;s .h files to know how to use it is really nice. Typically, my .h files don&#x27;t really look like my .c files because all the documentation for how to use the thing lives in the .h file (and isn&#x27;t duplicated in the .c file). It would be entirely possible to put this documentation into the .c file, but it makes reading the interface much less pleasant for someone using it.</div><br/><div id="42671397" class="c"><input type="checkbox" id="c-42671397" checked=""/><div class="controls bullet"><span class="by">kouteiheika</span><span>|</span><a href="#42671205">parent</a><span>|</span><a href="#42671400">next</a><span>|</span><label class="collapse" for="c-42671397">[-]</label><label class="expand" for="c-42671397">[29 more]</label></div><br/><div class="children"><div class="content">&gt; Header files are one of the things I miss the most about languages that aren&#x27;t C. Having a very clear distinction between public and private, and interface and implementation is one of my favourite things about C code (at least the way I write it).<p>I always found this argument baffling, because the way some other language solve this problem is with tooling, which is a much better way to do it in my opinion.<p>Take Rust for example. You want to see the interface of a given library and see how to use it? Easy. Type in `cargo doc --open` and you&#x27;re done. You get a nice interface with fully searchable API interface with the whole public API, and it&#x27;s all automatic, and you don&#x27;t have to manually maintain it nor have to duplicate code between your header and your source file.</div><br/><div id="42671516" class="c"><input type="checkbox" id="c-42671516" checked=""/><div class="controls bullet"><span class="by">TheNewAndy</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671397">parent</a><span>|</span><a href="#42671515">next</a><span>|</span><label class="collapse" for="c-42671516">[-]</label><label class="expand" for="c-42671516">[11 more]</label></div><br/><div class="children"><div class="content">This is probably something where it comes down to preference and familiarity. I would much prefer a simple text file for documentation that I can grep, open in my text editor, modify easily without switching context (oh, I should have been more explicit in the documentation I wrote - let me just fix that now), etc. All the features you mentioned &quot;nice interface, fully searchable API interface, whole public API&quot; are exactly what you get if you open a well written header file in any old text editor.<p>I used to be a big fan of doxygen etc, but for the stuff I&#x27;ve worked on, I&#x27;ve found that &quot;pretty&quot; documentation is way less important than &quot;useful&quot; documentation, and that the reformatting done by these tools tends to lead towards worse documentation with the people I have worked with (&quot;Oh, I need to make sure every function argument has documentation, so I will just reword the name of the argument&quot;). Since moving away from doxygen I have stopped seeing this behaviour from people - I haven&#x27;t tried to get a really good explanation as to why, but the quality of documentation has definitely improved, and my (unproven) theory is that keeping the presentation as plain as possible means that the focus turns to the content.<p>I don&#x27;t know if rust doc suffers the same issues, but the tooling you are mentioning just seems to add an extra step (depending on how you count steps I suppose, you could perhaps say it is the same number of steps...) and provide no obvious benefit to me (and it does provide the obvious downside that it is harder to edit documentation when you are reading it in the form you are suggesting).<p>But with all these things, different projects and teams and problem domains will probably tend towards having things that work better or worse.</div><br/><div id="42671617" class="c"><input type="checkbox" id="c-42671617" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671516">parent</a><span>|</span><a href="#42671706">next</a><span>|</span><label class="collapse" for="c-42671617">[-]</label><label class="expand" for="c-42671617">[6 more]</label></div><br/><div class="children"><div class="content">&gt; <i>well written text file</i><p>The problem with this is no one agrees on the definition of &quot;well-written&quot;, so consistency is a constant battle and struggle.  Language tooling is a better answer for quality of life.</div><br/><div id="42671664" class="c"><input type="checkbox" id="c-42671664" checked=""/><div class="controls bullet"><span class="by">TheNewAndy</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671617">parent</a><span>|</span><a href="#42671706">next</a><span>|</span><label class="collapse" for="c-42671664">[-]</label><label class="expand" for="c-42671664">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an interesting assertion, but not one that matches the experience I&#x27;ve had.<p>It is one of those things that sounds &quot;obviously true&quot;, but in practice I&#x27;ve found that it doesn&#x27;t really live up to the promise. As a concrete example of this, having a plain text header file as documentation tends to mean that when people are reading it, if they spot a mistake or see that something isn&#x27;t documented that should be documented, they are much more likely to fix it than if the documentation is displayed in a &quot;prettier&quot; form like HTML.<p>The problem with header files that aren&#x27;t &quot;well-written&quot; tends to be that the actual content you are looking for isn&#x27;t in there, and no amount of language tooling can actually fix that (and can be an impediment towards fixing it).</div><br/><div id="42671694" class="c"><input type="checkbox" id="c-42671694" checked=""/><div class="controls bullet"><span class="by">tpoacher</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671664">parent</a><span>|</span><a href="#42671870">next</a><span>|</span><label class="collapse" for="c-42671694">[-]</label><label class="expand" for="c-42671694">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll second this in Java land. I much prefer reading the sources directly than javadocs. Though jshell also comes in handy.</div><br/><div id="42671836" class="c"><input type="checkbox" id="c-42671836" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671694">parent</a><span>|</span><a href="#42671870">next</a><span>|</span><label class="collapse" for="c-42671836">[-]</label><label class="expand" for="c-42671836">[2 more]</label></div><br/><div class="children"><div class="content">I have the same experience a lot of the time with 3rd party rust crates. Doc.rs is amazing - but it’s rare that I’ll use a library without, at some point, hitting view source.</div><br/><div id="42671937" class="c"><input type="checkbox" id="c-42671937" checked=""/><div class="controls bullet"><span class="by">sim7c00</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671836">parent</a><span>|</span><a href="#42671870">next</a><span>|</span><label class="collapse" for="c-42671937">[-]</label><label class="expand" for="c-42671937">[1 more]</label></div><br/><div class="children"><div class="content">for most rust ive done (not tons) the docs were very basic as onky auto generated with minimal content. totally useless, have to read sources to find out what is in there.
auto documentation to me ia just ti satisfy people who need to tick all of these boxes and want to do with minimal effort. has dox  has tests etc. such artitude never leads to quality.</div><br/></div></div></div></div></div></div><div id="42671870" class="c"><input type="checkbox" id="c-42671870" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671664">parent</a><span>|</span><a href="#42671694">prev</a><span>|</span><a href="#42671706">next</a><span>|</span><label class="collapse" for="c-42671870">[-]</label><label class="expand" for="c-42671870">[1 more]</label></div><br/><div class="children"><div class="content">I know people look at me like I’m a heathen and a scoundrel, but I think a lot of software teams spend too much time trying to make things consistent. Where’s the ROI? There is none.<p>GitHub readmes? Bring on the weird quirks, art, rants about other software, and so on. I’ll take it all.<p>Don’t get me started on linters. Yes, there’s lots of things that should actually be consistent in a codebase (like indentation). But for every useful check, linters have 100 random pointless things they complain about. Oh, you used a ternary statement? Boo hoo! Oh, my JavaScript has a mix of semicolons and non semicolons? Who cares? The birds are singing. Don’t bother me with this shite.<p>Software is a creative discipline. Bland software reflects a bland mind.</div><br/></div></div></div></div></div></div><div id="42671706" class="c"><input type="checkbox" id="c-42671706" checked=""/><div class="controls bullet"><span class="by">kouteiheika</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671516">parent</a><span>|</span><a href="#42671617">prev</a><span>|</span><a href="#42671515">next</a><span>|</span><label class="collapse" for="c-42671706">[-]</label><label class="expand" for="c-42671706">[4 more]</label></div><br/><div class="children"><div class="content">&gt; All the features you mentioned &quot;nice interface, fully searchable API interface, whole public API&quot; are exactly what you get if you open a well written header file in any old text editor.<p>No, you can&#x27;t, and it&#x27;s not even close.<p>You have a header file that&#x27;s 2000 lines of code, and you have a function which uses type X. You want to see the definition of type X. How do you quickly jump to its definition with your &quot;any old text editor&quot;? You try to grep for it in the header? What if that identifier is used 30 times in that file? Now you have to go through all of other 29 uses and hunt for the definition. What if it&#x27;s from another header file? What if the type X is from another library altogether? Now you need to manually grep through a bunch of other header files and potentially other libraries, and due to C&#x27;s include system you often can&#x27;t even be sure where you need to grep on the filesystem.<p>Anyway, take a look at the docs for one of the most popular Rust crates:<p><a href="https:&#x2F;&#x2F;docs.rs&#x2F;regex&#x2F;1.11.1&#x2F;regex&#x2F;struct.Regex.html" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;regex&#x2F;1.11.1&#x2F;regex&#x2F;struct.Regex.html</a><p>The experience going through these docs (once you get used to it) is night and day compared to just reading header files. Everything is cross linked so you can easily cross-reference types. You can easily hide the docs if you just want to see the prototypes (click on the &quot;Summary&quot; button). You can easily see the implementation of a given function (click on &quot;source&quot; next to the prototype). You can search through the whole public API. If you click on a type from another library it will automatically show you docs for that library. You have usage examples (*which are automatically unit tested so they&#x27;re guaranteed to be correct*!). You can find non-obvious relationships between types that you wouldn&#x27;t get just by reading the source code where the thing is defined (e.g. all implementations of a given trait are listed, which are usually scattered across the codebase).<p>&gt; I don&#x27;t know if rust doc suffers the same issues, but the tooling you are mentioning just seems to add an extra step (depending on how you count steps I suppose, you could perhaps say it is the same number of steps...) and provide no obvious benefit to me (and it does provide the obvious downside that it is harder to edit documentation when you are reading it in the form you are suggesting).<p>Why would I want to edit the documentation of an external library I&#x27;m consuming when I&#x27;m reading it? And even if I do then the effort to make a PR changing those docs pales in comparison to the effort it takes to open the original source code with the docs and edit it.<p>Or did you mean editing the docs for <i>my</i> code? In that case I can also easily do it, because docs are part of my source files and are maintained alongside the implementation. If I change the implementation I have docs right there <i>in the same file</i> and I can easily edit them. Having to open the header file and hunt for the declaration to edit the docs &quot;just seems to add an extra step&quot; and &quot;and provide no obvious benefit to me&quot;, if I may use your words. (:</div><br/><div id="42672192" class="c"><input type="checkbox" id="c-42672192" checked=""/><div class="controls bullet"><span class="by">TheNewAndy</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671706">parent</a><span>|</span><a href="#42671988">next</a><span>|</span><label class="collapse" for="c-42672192">[-]</label><label class="expand" for="c-42672192">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the constructive example of the rust doc.<p>I am not making things up when I say that the very first question I had about how to use this module, either is not answered, or I couldn&#x27;t find the answer. That question was &quot;what regular expression syntax is supported?&quot;. This is such a fundamental question, yet there is no answer provided.<p>As a preference thing, I don&#x27;t really like examples in APIs (it is supposed to be a reference in my opinion) and I find them to be mostly noise.<p>&gt; Why would I want to edit the documentation of an external library 
I&#x27;m consuming when I&#x27;m reading it? And even if I do then the effort 
to make a PR changing those docs pales in comparison to the effort
it takes to open the original source code with the docs and edit it.<p>Right, this is possibly where our experiences differ. I&#x27;m frequently pulling in loads of code, some of which I&#x27;ve written, some of which other people have written, and when I pull in code to a project I take ownership of it. Doesn&#x27;t matter who wrote it - if it is in my project, then I&#x27;m going to make sure it is up to the standards I expect. A lot of the time, the code is stuff I&#x27;ve written anyway, which means that when I come back in a few months time and go to use it, I find that things that seemed obvious at the time might not be so obvious, and a simple comment can completely fix it. Sometimes it is a comment and a code change (&quot;wouldn&#x27;t it be nice if this function handled edge case X nicely? I&#x27;ll just go in there and fix it&quot;).<p>The distinction between external and internal that you have looks pretty different to me, and that could just be why we have different opinions.</div><br/></div></div><div id="42671988" class="c"><input type="checkbox" id="c-42671988" checked=""/><div class="controls bullet"><span class="by">mtlmtlmtlmtl</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671706">parent</a><span>|</span><a href="#42672192">prev</a><span>|</span><a href="#42672007">next</a><span>|</span><label class="collapse" for="c-42671988">[-]</label><label class="expand" for="c-42671988">[1 more]</label></div><br/><div class="children"><div class="content">Most decent text editors support something like go to definition. Your entire comment seems to be based on the idea that text editors only support basic search, which is simply false.<p>Personally I&#x27;m quite content with both experiences. But it really is just a matter of preference.</div><br/></div></div><div id="42672007" class="c"><input type="checkbox" id="c-42672007" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671706">parent</a><span>|</span><a href="#42671988">prev</a><span>|</span><a href="#42671515">next</a><span>|</span><label class="collapse" for="c-42672007">[-]</label><label class="expand" for="c-42672007">[1 more]</label></div><br/><div class="children"><div class="content">At least  moderately advanced text editors often interoperate with symbols tables, so you can jump to a definition.  But even with  grep, you can usually do it in a way where you differentiate between definition and use.  But I am not arguing that you should not use advanced tools if you like is, the deeper point is that you can always use advanced tools even with headers, but you can not go back in a language designed around advanced tools and work with simple tools.  So it is strictly inferior IMHO to design a language around this additional cmplexity.</div><br/></div></div></div></div></div></div><div id="42671515" class="c"><input type="checkbox" id="c-42671515" checked=""/><div class="controls bullet"><span class="by">panic</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671397">parent</a><span>|</span><a href="#42671516">prev</a><span>|</span><a href="#42671523">next</a><span>|</span><label class="collapse" for="c-42671515">[-]</label><label class="expand" for="c-42671515">[4 more]</label></div><br/><div class="children"><div class="content">As someone who likes C header files, I enjoy manually maintaining them.  Designing the interface separately from the implementation feels good to me, and a well-structured .h file is nicer to read than any auto-generated docs I&#x27;ve encountered.</div><br/><div id="42671549" class="c"><input type="checkbox" id="c-42671549" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671515">parent</a><span>|</span><a href="#42671523">next</a><span>|</span><label class="collapse" for="c-42671549">[-]</label><label class="expand" for="c-42671549">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Designing the interface separately from the implementation feels good to me<p>would you make the same argument for java then?</div><br/><div id="42671654" class="c"><input type="checkbox" id="c-42671654" checked=""/><div class="controls bullet"><span class="by">otteromkram</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671549">parent</a><span>|</span><a href="#42671523">next</a><span>|</span><label class="collapse" for="c-42671654">[-]</label><label class="expand" for="c-42671654">[2 more]</label></div><br/><div class="children"><div class="content">Absolutely not.</div><br/><div id="42671700" class="c"><input type="checkbox" id="c-42671700" checked=""/><div class="controls bullet"><span class="by">tpoacher</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671654">parent</a><span>|</span><a href="#42671523">next</a><span>|</span><label class="collapse" for="c-42671700">[-]</label><label class="expand" for="c-42671700">[1 more]</label></div><br/><div class="children"><div class="content">you don&#x27;t like java interfaces?</div><br/></div></div></div></div></div></div></div></div><div id="42671523" class="c"><input type="checkbox" id="c-42671523" checked=""/><div class="controls bullet"><span class="by">salgernon</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671397">parent</a><span>|</span><a href="#42671515">prev</a><span>|</span><a href="#42671824">next</a><span>|</span><label class="collapse" for="c-42671523">[-]</label><label class="expand" for="c-42671523">[10 more]</label></div><br/><div class="children"><div class="content">I’m with parent - what if you don’t have the tool?  What if there’s a syntax error in some implementation  or dependency such that the tool chokes early?<p>Human readable headers are accessible out of context if the implementation.  They also help provide a clear abstraction - this is the contract. This is what I support as of this version. (And hopefully with appropriate annotations across versions)</div><br/><div id="42671622" class="c"><input type="checkbox" id="c-42671622" checked=""/><div class="controls bullet"><span class="by">kouteiheika</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671523">parent</a><span>|</span><a href="#42671764">next</a><span>|</span><label class="collapse" for="c-42671622">[-]</label><label class="expand" for="c-42671622">[8 more]</label></div><br/><div class="children"><div class="content">&gt; I’m with parent - what if you don’t have the tool?<p>The &quot;what if you don&#x27;t have the tool&quot; situation never happens in case of Rust. If you have the compiler you have the tool, because it&#x27;s always included with the compiler. This isn&#x27;t some third party tool that you install manually; it&#x27;s arguably part of the language.<p>&gt; What if there’s a syntax error in some implementation or dependency such that the tool chokes early?<p>In C I can see how this can happen with its mess of a build systems; in Rust this doesn&#x27;t happen (in my 10+ years of Rust I&#x27;ve never seen it), because people don&#x27;t publish libraries with syntax errors (duh!).</div><br/><div id="42671727" class="c"><input type="checkbox" id="c-42671727" checked=""/><div class="controls bullet"><span class="by">jmb99</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671622">parent</a><span>|</span><a href="#42671683">next</a><span>|</span><label class="collapse" for="c-42671727">[-]</label><label class="expand" for="c-42671727">[5 more]</label></div><br/><div class="children"><div class="content">&gt; The &quot;what if you don&#x27;t have the tool&quot; situation never happens in case of Rust.<p>So it’s built into GitLab and GitHub? BitBucket? How easy is it to use on windows (i.e. is it is easy as opening a .h in notepad and reading it)? How easy is it to use from a command line environment with vim or emacs bindings?<p>I could go on. “Never” is doing a <i>lot</i> of heavy lifting in your assertion. I shouldn’t have to install a toolchain (let alone rely on a web browser) to read API documentation.</div><br/><div id="42671907" class="c"><input type="checkbox" id="c-42671907" checked=""/><div class="controls bullet"><span class="by">nindalf</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671727">parent</a><span>|</span><a href="#42671963">next</a><span>|</span><label class="collapse" for="c-42671907">[-]</label><label class="expand" for="c-42671907">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I could go on<p>Please do. It just sounds like you’re nitpicking.<p>If you can open a browser, open docs.rs. The GitHub repo usually contains a link to docs.rs because that’s how people prefer to read the documentation.<p>If you prefer working without the internet that’s fine too. Use cargo doc, which opens the rendered doc page in a local web browser.<p>If you prefer being in a text editor exclusively, no problem! Grep for `pub` and read the doc comments right above (these start with &#x2F;&#x2F;&#x2F;). No toolchain necessary.<p>Look, most normal people don’t have some intense phobia of web browsers, so they’d prefer docs.rs. For the people who prefer text editor, it’s still a great experience - git clone and look for the doc comments.<p>The point is, the existence of docs.rs only encourages Rust library developers to write more and better documentation, which everyone, including text editor exclusive people benefit from. That’s why your comment sounds so strange.</div><br/></div></div><div id="42671963" class="c"><input type="checkbox" id="c-42671963" checked=""/><div class="controls bullet"><span class="by">kouteiheika</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671727">parent</a><span>|</span><a href="#42671907">prev</a><span>|</span><a href="#42671850">next</a><span>|</span><label class="collapse" for="c-42671963">[-]</label><label class="expand" for="c-42671963">[2 more]</label></div><br/><div class="children"><div class="content">&gt; So it’s built into GitLab and GitHub? BitBucket?<p>No. It&#x27;s built into the toolchain which every Rust developer has installed.<p>&gt; How easy is it to use on windows (i.e. is it is easy as opening a .h in notepad and reading it)?<p>A easy as on Linux or macOS from my experience.<p>&gt; How easy is it to use from a command line environment with vim or emacs bindings?<p>Not sure I understand the question; use how exactly? You either have a binding which runs `cargo doc` and opens the docs for you, or you use an LSP server and a plugin for your editor in which case the docs are integrated into your editor.<p>&gt; I shouldn’t have to install a toolchain (let alone rely on a web browser) to read API documentation.<p>If you want you can just read the source code, just as you do for any other language, because the docs are right there in the sources.<p>For publicly available libraries you can also type in `<a href="https:&#x2F;&#x2F;docs.rs&#x2F;$name_of_library" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;$name_of_library</a>` in your web browser to open the docs. Any library available through crates.io (so 99.9% of what people use) have docs available there, so even if you don&#x27;t have the toolchain installed&#x2F;are on your phone you can still browse through the docs.<p>I know what you&#x27;re going to say - what if you don&#x27;t have the toolchain installed and the library is not public? Or, worse, you&#x27;re using a 30 year old machine that doesn&#x27;t have a web browser available?! Well, sure, tough luck, then you need to do it the old school way and browse the sources.<p>You can always find a corner case of &quot;what if...?&quot;, but I find that totally unconvincing. Making the 99.9% case harder (when you have a web browser and a toolchain installed, etc.) to make the 0.1% case (when you don&#x27;t) easier is a bad tradeoff.</div><br/><div id="42672198" class="c"><input type="checkbox" id="c-42672198" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671963">parent</a><span>|</span><a href="#42671850">next</a><span>|</span><label class="collapse" for="c-42672198">[-]</label><label class="expand" for="c-42672198">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand how you don&#x27;t understand the order of magnitude difference in flexibility, utility, availability, etc between needing to run a specific executable vs merely opening a text file in any way.<p>&quot;you always have the exe&quot; is just not even remotely a valid argument.</div><br/></div></div></div></div><div id="42671850" class="c"><input type="checkbox" id="c-42671850" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671727">parent</a><span>|</span><a href="#42671963">prev</a><span>|</span><a href="#42671683">next</a><span>|</span><label class="collapse" for="c-42671850">[-]</label><label class="expand" for="c-42671850">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I shouldn’t have to install a toolchain (let alone rely on a web browser) to read API documentation.<p>Why are you reading a library API for a language you&#x27;re not coding in?<p>I&#x27;m sure you can come up with some situation, but that situation should NOT be what we optimize for.<p>And web browsers are fine.<p>&gt; is it is easy as opening a .h in notepad and reading it<p>If you include the actual ease of reading, yeah it should be.</div><br/></div></div></div></div><div id="42671683" class="c"><input type="checkbox" id="c-42671683" checked=""/><div class="controls bullet"><span class="by">TheNewAndy</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671622">parent</a><span>|</span><a href="#42671727">prev</a><span>|</span><a href="#42671764">next</a><span>|</span><label class="collapse" for="c-42671683">[-]</label><label class="expand" for="c-42671683">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Never&quot; is a big call.<p>In this specific case, your tool requires a web browser (though I&#x27;m assuming that there is a non-web browser form of what is being sold here). Maybe you are in a situation where you only have terminal access to the machine.<p>Maybe you are on your phone just browsing github looking for a library to use<p>I&#x27;m sure people can continue to imagine more examples. It is entirely possible that we have different experiences of projects and teams.</div><br/><div id="42671927" class="c"><input type="checkbox" id="c-42671927" checked=""/><div class="controls bullet"><span class="by">nindalf</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671683">parent</a><span>|</span><a href="#42671764">next</a><span>|</span><label class="collapse" for="c-42671927">[-]</label><label class="expand" for="c-42671927">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I’m sure people can continue to imagine more examples<p>Hopefully they’ll imagine more compelling examples.<p>If the hypothetical person’s phone is capable of browsing GitHub, I don’t see why they can’t also browse docs.rs. It renders well on small screens. That’s not a hypothetical, I’ve actually read the docs for libraries on my phone.</div><br/></div></div></div></div></div></div><div id="42671764" class="c"><input type="checkbox" id="c-42671764" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671523">parent</a><span>|</span><a href="#42671622">prev</a><span>|</span><a href="#42671824">next</a><span>|</span><label class="collapse" for="c-42671764">[-]</label><label class="expand" for="c-42671764">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;what if you don&#x27;t have the software&quot; argument doesn&#x27;t hold water for me. What if you don&#x27;t have git? What if you don&#x27;t have a text editor? What if you don&#x27;t have a filesystem?<p>Most programming language communities are okay with expecting a certain amount of (modern) tooling, and C can&#x27;t rely on legacy to remain relevant forever...</div><br/></div></div></div></div><div id="42671824" class="c"><input type="checkbox" id="c-42671824" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671397">parent</a><span>|</span><a href="#42671523">prev</a><span>|</span><a href="#42672181">next</a><span>|</span><label class="collapse" for="c-42671824">[-]</label><label class="expand" for="c-42671824">[2 more]</label></div><br/><div class="children"><div class="content">Sounds like COM&#x2F;DCOM from ~1995. Every API had a public interface including a description. You could open the DCOM Inspector, browse all the APIs, and see the type signature of every function and its docs.</div><br/><div id="42671969" class="c"><input type="checkbox" id="c-42671969" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671824">parent</a><span>|</span><a href="#42672181">next</a><span>|</span><label class="collapse" for="c-42671969">[-]</label><label class="expand" for="c-42671969">[1 more]</label></div><br/><div class="children"><div class="content">Still is COM from 2025, given its relevance on Windows, even more since Vista, as all Longhorn ideas were remade in COM.<p>However the tooling experience is pretty much ~1995, with the difference IDL is at version 3.0.</div><br/></div></div></div></div><div id="42672181" class="c"><input type="checkbox" id="c-42672181" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671397">parent</a><span>|</span><a href="#42671824">prev</a><span>|</span><a href="#42671400">next</a><span>|</span><label class="collapse" for="c-42672181">[-]</label><label class="expand" for="c-42672181">[1 more]</label></div><br/><div class="children"><div class="content">headers perform the same job for all code, not just code that&#x27;s in some library.<p>Frankly your description of what you just called easy sounds terrible and pointlessly extra, indirection that doesn&#x27;t pay for itself in the form of some overwhelming huge win somewhere else. It&#x27;s easy only if the alternative was getting it by fax or something.</div><br/></div></div></div></div><div id="42671400" class="c"><input type="checkbox" id="c-42671400" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#42671205">parent</a><span>|</span><a href="#42671397">prev</a><span>|</span><a href="#42672002">next</a><span>|</span><label class="collapse" for="c-42671400">[-]</label><label class="expand" for="c-42671400">[1 more]</label></div><br/><div class="children"><div class="content">Header files are really a weak hack to deal with resource constrained platforms from the 70s. They only work if you stick to a convention and pale in comparison to languages like Ada with well architected specification for interfaces and implementation without ever needing to reparse over and over again.<p>I do enjoy using C but that is one area where it should have been better designed.</div><br/></div></div><div id="42672002" class="c"><input type="checkbox" id="c-42672002" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42671205">parent</a><span>|</span><a href="#42671400">prev</a><span>|</span><a href="#42671643">next</a><span>|</span><label class="collapse" for="c-42672002">[-]</label><label class="expand" for="c-42672002">[1 more]</label></div><br/><div class="children"><div class="content">Available in most compiled module languages, either separately, Modula-2, Modula-3, Ada, Standard ML, Caml Light, OCaml, F#, D.<p>Or it can be generated either as text, or graphical tooling, Object Pascal, D, Haskell, Java, C#, F#, Swift, Go, Rust.<p>All with stronger typing, faster compilation (Rust and Swift toolchain still need some work), proper namespacing.<p>Unfortunately C tooling has always been more primitive than what was happening outside Bell Labs, and had AT&amp;T been allowed to take commercial advantage, history would be much different, instead we got free lemons, instead of nice juicy oranges.<p>At least they did come up with TypeScript for C, and it nowadays supports proper modules, alongside bounds checked collection types.</div><br/></div></div><div id="42671643" class="c"><input type="checkbox" id="c-42671643" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#42671205">parent</a><span>|</span><a href="#42672002">prev</a><span>|</span><a href="#42671215">next</a><span>|</span><label class="collapse" for="c-42671643">[-]</label><label class="expand" for="c-42671643">[1 more]</label></div><br/><div class="children"><div class="content">I agree with you, but I don&#x27;t.<p>The way C handles header files is sort of &quot;seems-to-work&quot; by just blindly including the text inline.<p>I know this is not a much-used language, but in comparison, Ada did a pretty nice thing.  They have the concept of packages and package bodies.  The package is equivalent to the header file, and the package body is the implementation of the package.<p>I remember (long ago when I used ada) that everyone could compile against the package without having the package body implementation ready so the interfaces could all work before the implementation was ready.<p>an in another direction, I like how python does &quot;header files&quot; with &quot;import&quot;.  It maps easily to the filesystem without having to deal with files and the C include file semantics.</div><br/></div></div><div id="42671215" class="c"><input type="checkbox" id="c-42671215" checked=""/><div class="controls bullet"><span class="by">legobmw99</span><span>|</span><a href="#42671205">parent</a><span>|</span><a href="#42671643">prev</a><span>|</span><a href="#42672035">next</a><span>|</span><label class="collapse" for="c-42671215">[-]</label><label class="expand" for="c-42671215">[1 more]</label></div><br/><div class="children"><div class="content">Some other languages have equivalents (OCaml comes to mind), but usually they’re less necessary</div><br/></div></div><div id="42671674" class="c"><input type="checkbox" id="c-42671674" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#42671205">parent</a><span>|</span><a href="#42672035">prev</a><span>|</span><a href="#42671277">next</a><span>|</span><label class="collapse" for="c-42671674">[-]</label><label class="expand" for="c-42671674">[1 more]</label></div><br/><div class="children"><div class="content">Object Pascal (not the original Pascal) versions like Delphi and Free Pascal have syntax and semantics for <i>interface</i> and <i>implementation</i> sections of the module. Wouldn&#x27;t be surprised if Modula-2 and Ada had that too.</div><br/></div></div><div id="42671277" class="c"><input type="checkbox" id="c-42671277" checked=""/><div class="controls bullet"><span class="by">Lvl999Noob</span><span>|</span><a href="#42671205">parent</a><span>|</span><a href="#42671674">prev</a><span>|</span><a href="#42671409">next</a><span>|</span><label class="collapse" for="c-42671277">[-]</label><label class="expand" for="c-42671277">[9 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really program in C much so please correct me if I am wrong. There is a flaw in header files in that they work the exact same for dynamic vs static linking, right? If I am making a library in C for static linking, I need to put my internal details in the header file if I want the user&#x27;s compiler to be able to use those details. But putting them in the header files also means they are part of the public interface now and should no longer be changed.<p>Basically, I cannot do something like a struct with an opaque internal structure but a compile time known layout so that the compiler can optimise it properly but the user cannot mess with the internals (in language supported direct ways).</div><br/><div id="42671323" class="c"><input type="checkbox" id="c-42671323" checked=""/><div class="controls bullet"><span class="by">TheNewAndy</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671277">parent</a><span>|</span><a href="#42672019">next</a><span>|</span><label class="collapse" for="c-42671323">[-]</label><label class="expand" for="c-42671323">[6 more]</label></div><br/><div class="children"><div class="content">That is less about header files, and more about how machine code works.<p>If you want to have some abstract type where you don&#x27;t let people know anything about the innards, but you do have an explicit interface which enumerates what you can do with it, then yes - you can only really pass around pointers to these things and people outside your abstraction can only pass references not values.<p>If you want people to be able to pass your abstract type by value (among other things), then either you need to let them know how big the thing is (an implementation detail) or you have to expose the copy implementation in such a way that it could be inlined (more implementation details).<p>Sometimes, the &quot;pure abstraction&quot; approach is best where you only ever deal with pointers to things, and other times the &quot;let&#x27;s pretend that people do the right thing&quot; approach is best. I don&#x27;t see this as a header file thing though.</div><br/><div id="42671376" class="c"><input type="checkbox" id="c-42671376" checked=""/><div class="controls bullet"><span class="by">Lvl999Noob</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671323">parent</a><span>|</span><a href="#42671440">next</a><span>|</span><label class="collapse" for="c-42671376">[-]</label><label class="expand" for="c-42671376">[2 more]</label></div><br/><div class="children"><div class="content">I disagree with you on this. In another language with explicit public &#x2F; private separation, the compiler can have access to the internal layout of a type (and thus optimise on it) without letting the developer mess around with it directly. I am assuming static compilation of course. Across a dynamic boundary, I would expect this compiler to behave like a normal C compiler and not use that layout.<p>In a header file, the information for the compiler and the user are the exact same which means you can&#x27;t reduce your public interface without straight up hiding more of yourself.</div><br/><div id="42671545" class="c"><input type="checkbox" id="c-42671545" checked=""/><div class="controls bullet"><span class="by">TheNewAndy</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671376">parent</a><span>|</span><a href="#42671440">next</a><span>|</span><label class="collapse" for="c-42671545">[-]</label><label class="expand" for="c-42671545">[1 more]</label></div><br/><div class="children"><div class="content">Personally, I&#x27;m happy to just let a Sufficiently Advanced Compiler do link time optimizations to deal with that level of optimization and either take the hit, or make more things public while that compiler doesn&#x27;t exist.<p>Let the header files be written for people to read first, and only if there is actually a big performance issue, and the problem is the interface do you need to revisit it (and I&#x27;m not just saying this - I will frequently and happily go back and modify interfaces to allow for less data movement etc, but most of the time it really isn&#x27;t important).<p>I think you are probably right to disagree with me though - I think I should have said that it is more of a limitation on how object files work, rather than how machines work. Object files aren&#x27;t the only way things can work.</div><br/></div></div></div></div><div id="42671440" class="c"><input type="checkbox" id="c-42671440" checked=""/><div class="controls bullet"><span class="by">saidinesh5</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671323">parent</a><span>|</span><a href="#42671376">prev</a><span>|</span><a href="#42672019">next</a><span>|</span><label class="collapse" for="c-42671440">[-]</label><label class="expand" for="c-42671440">[3 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s a problem with C&#x27;s header files.<p>With C++ you have the third option where the compiler makes sure that the &quot;people will do the right thing&quot; with the private keyword - assuming they&#x27;re not doing some weird pointer math to access the private members..<p>Of course, you&#x27;ll have to deal with ABI stability now but it&#x27;s all tradeoffs for what your requirements are.</div><br/><div id="42671465" class="c"><input type="checkbox" id="c-42671465" checked=""/><div class="controls bullet"><span class="by">TheNewAndy</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671440">parent</a><span>|</span><a href="#42671730">next</a><span>|</span><label class="collapse" for="c-42671465">[-]</label><label class="expand" for="c-42671465">[1 more]</label></div><br/><div class="children"><div class="content">Right, but as soon as you have private stuff in your header file, that is leaking implementation details. Yes it is kind of true that these are compile time checked to make sure that people don&#x27;t do the wrong thing, but it is still an implementation detail that is leaking.<p>It comes down to a cost benefit thing - is the cost of poorer readability worth it for mitigating the risk of people doing the wrong thing? My experience says no, other people&#x27;s experience says yes. Probably we are working on different problems and with different teams.</div><br/></div></div><div id="42671730" class="c"><input type="checkbox" id="c-42671730" checked=""/><div class="controls bullet"><span class="by">Mankaninen</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671440">parent</a><span>|</span><a href="#42671465">prev</a><span>|</span><a href="#42672019">next</a><span>|</span><label class="collapse" for="c-42671730">[-]</label><label class="expand" for="c-42671730">[1 more]</label></div><br/><div class="children"><div class="content">Of course you should do the right thing, but if you want to break the private of C++ it is much easier to &quot;#define private public&quot; before including the header file.</div><br/></div></div></div></div></div></div><div id="42672019" class="c"><input type="checkbox" id="c-42672019" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671277">parent</a><span>|</span><a href="#42671323">prev</a><span>|</span><a href="#42671751">next</a><span>|</span><label class="collapse" for="c-42672019">[-]</label><label class="expand" for="c-42672019">[1 more]</label></div><br/><div class="children"><div class="content">In C programs only the external definition of an interface goes into the header of a library but not implementation details (there could be headers intentionally exposing details for internal use, of course).<p>The problem is real for C++.<p>Optimizers can look across translation units nowadays (link-time optimization), so there is no reason to expose internal details in a header for this.  For dynamic libraries this does not work of course, but it also shouldn&#x27;t.</div><br/></div></div><div id="42671751" class="c"><input type="checkbox" id="c-42671751" checked=""/><div class="controls bullet"><span class="by">lzsiga</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671277">parent</a><span>|</span><a href="#42672019">prev</a><span>|</span><a href="#42671409">next</a><span>|</span><label class="collapse" for="c-42671751">[-]</label><label class="expand" for="c-42671751">[1 more]</label></div><br/><div class="children"><div class="content">The proper way is not exporting implementation details at all, instead define  opaque types in your header files like this: `typedef struct ssl_st SSL;`. This comes from OpenSSL, it means users can use `SSL *` pointers, but they don&#x27;t know what those pointers point to.<p>Of course you can also have internal header-files within your own project, which you don&#x27;t share with the end-users of your product.</div><br/></div></div></div></div><div id="42671409" class="c"><input type="checkbox" id="c-42671409" checked=""/><div class="controls bullet"><span class="by">billfruit</span><span>|</span><a href="#42671205">parent</a><span>|</span><a href="#42671277">prev</a><span>|</span><a href="#42671490">next</a><span>|</span><label class="collapse" for="c-42671409">[-]</label><label class="expand" for="c-42671409">[1 more]</label></div><br/><div class="children"><div class="content">They are also somewhat of hassle and something not necessary to have.</div><br/></div></div><div id="42671490" class="c"><input type="checkbox" id="c-42671490" checked=""/><div class="controls bullet"><span class="by">ryukoposting</span><span>|</span><a href="#42671205">parent</a><span>|</span><a href="#42671409">prev</a><span>|</span><a href="#42671940">next</a><span>|</span><label class="collapse" for="c-42671490">[-]</label><label class="expand" for="c-42671490">[1 more]</label></div><br/><div class="children"><div class="content">Header files also make it a lot more obvious how you&#x27;re supposed to distribute a library as a binary, which is good.</div><br/></div></div><div id="42671940" class="c"><input type="checkbox" id="c-42671940" checked=""/><div class="controls bullet"><span class="by">trenchgun</span><span>|</span><a href="#42671205">parent</a><span>|</span><a href="#42671490">prev</a><span>|</span><a href="#42671530">next</a><span>|</span><label class="collapse" for="c-42671940">[-]</label><label class="expand" for="c-42671940">[1 more]</label></div><br/><div class="children"><div class="content">OCaml .mli interface files are the same, but better.</div><br/></div></div><div id="42671530" class="c"><input type="checkbox" id="c-42671530" checked=""/><div class="controls bullet"><span class="by">harisund1990</span><span>|</span><a href="#42671205">parent</a><span>|</span><a href="#42671940">prev</a><span>|</span><a href="#42671271">next</a><span>|</span><label class="collapse" for="c-42671530">[-]</label><label class="expand" for="c-42671530">[3 more]</label></div><br/><div class="children"><div class="content">I love headers but I wish you could split them in two so that private functions and variables can line in the c file. This would help reduce a lot of header bloat as well.</div><br/><div id="42671698" class="c"><input type="checkbox" id="c-42671698" checked=""/><div class="controls bullet"><span class="by">lzsiga</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671530">parent</a><span>|</span><a href="#42671271">next</a><span>|</span><label class="collapse" for="c-42671698">[-]</label><label class="expand" for="c-42671698">[2 more]</label></div><br/><div class="children"><div class="content">It is perfectly valid to use more than one header files: some of them can be public (meant to be seen by users of your library), others can be private or internal (only used by your own sources).</div><br/><div id="42672150" class="c"><input type="checkbox" id="c-42672150" checked=""/><div class="controls bullet"><span class="by">chikere232</span><span>|</span><a href="#42671205">root</a><span>|</span><a href="#42671698">parent</a><span>|</span><a href="#42671271">next</a><span>|</span><label class="collapse" for="c-42672150">[-]</label><label class="expand" for="c-42672150">[1 more]</label></div><br/><div class="children"><div class="content">Also, usually it&#x27;s pretty rare to have things internal to one C file that need explicit prototypes. It&#x27;s easier to just put things in the right order so the funtion definition etc is before its use.</div><br/></div></div></div></div></div></div></div></div><div id="42671271" class="c"><input type="checkbox" id="c-42671271" checked=""/><div class="controls bullet"><span class="by">bjourne</span><span>|</span><a href="#42671205">prev</a><span>|</span><a href="#42671344">next</a><span>|</span><label class="collapse" for="c-42671271">[-]</label><label class="expand" for="c-42671271">[3 more]</label></div><br/><div class="children"><div class="content">I write unit tests for my C code all that time. It&#x27;s not difficult if you use a good build system and if you are willing to stomach some boilerplate. Here is one test from    my &quot;test suite&quot; for my npy library:<p><pre><code>    void
    test_load_uint8() {
        npy_arr *arr = npy_load(&quot;tests&#x2F;npy&#x2F;uint8.npy&quot;);
        assert(arr-&gt;n_dims == 1);
        assert(arr-&gt;dims[0] == 100);
        assert(arr-&gt;type == &#x27;u&#x27;);
        npy_free(arr);
    }
    int
    main(int argc, char *argv[]) {
        PRINT_RUN(test_load_uint8);
        ...
    }
</code></pre>
I know I could have some pre-processor generate parts of the tests, but I prefer to KISS.</div><br/><div id="42671399" class="c"><input type="checkbox" id="c-42671399" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42671271">parent</a><span>|</span><a href="#42671339">next</a><span>|</span><label class="collapse" for="c-42671399">[-]</label><label class="expand" for="c-42671399">[1 more]</label></div><br/><div class="children"><div class="content">Your function looks like it&#x27;s doing I&#x2F;O, which won&#x27;t work at compile time test. Here&#x27;s an example of a unittest for the ImportC compiler:<p><pre><code>    struct S22079
    {
        int a, b, c;
    };

    _Static_assert(sizeof(struct S22079){1,2,3} == sizeof(int)*3, &quot;ok&quot;);
    _Static_assert(sizeof(struct S22079){1,2,3}.a == sizeof(int), &quot;ok&quot;);
</code></pre>
The semantics are checked at compile time, so no need to link &amp; run. With the large volume of tests, this speeds things up considerably. The faster the test suite runs, the more productive I am.</div><br/></div></div><div id="42671339" class="c"><input type="checkbox" id="c-42671339" checked=""/><div class="controls bullet"><span class="by">TheNewAndy</span><span>|</span><a href="#42671271">parent</a><span>|</span><a href="#42671399">prev</a><span>|</span><a href="#42671344">next</a><span>|</span><label class="collapse" for="c-42671339">[-]</label><label class="expand" for="c-42671339">[1 more]</label></div><br/><div class="children"><div class="content">You will be pleased to know that you are not the only one who does this.<p>I previously went down the rabbit hole of fancy unit test frameworks, and after a while I realised that they didn&#x27;t really win much and settled on something almost identical to what you have (my PRINT_RUN macro has a different name, and requires the () to be passed in - and I only ever write it if the time to run all the tests is more than a second or so, just to make it really convenient to point the finger of blame).<p>The thing that I do which are potentially looked upon poorly by other people are:<p>1) I will happily #include a .c file that is being unit tested so I can call static functions in it (I will only #include a single .c file)<p>2) I do a tiny preprocessor dance before I #include &lt;assert.h&gt; to make sure NDEBUG is not defined (in case someone builds in a &quot;release mode&quot; which disables asserts)</div><br/></div></div></div></div><div id="42671344" class="c"><input type="checkbox" id="c-42671344" checked=""/><div class="controls bullet"><span class="by">kstenerud</span><span>|</span><a href="#42671271">prev</a><span>|</span><a href="#42672074">next</a><span>|</span><label class="collapse" for="c-42671344">[-]</label><label class="expand" for="c-42671344">[6 more]</label></div><br/><div class="children"><div class="content">Compile time unit tests are as bad of an idea as &quot;unused import&#x2F;variable&#x2F;result&quot; errors (rather than warnings). They&#x27;re &quot;nanny features&quot; that take control away from the developer and inevitably cause you to jump through bureaucratic hoops just to get your work done.<p>These kinds of build-failing tests are great for your &quot;I think I&#x27;m finished now&quot; build, but not for your &quot;I&#x27;m in the middle of something&quot; builds (which are what 99% of your builds are).<p>It&#x27;s like saying &quot;You can&#x27;t use the table saw until you put the drill away!&quot;</div><br/><div id="42671557" class="c"><input type="checkbox" id="c-42671557" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#42671344">parent</a><span>|</span><a href="#42671507">next</a><span>|</span><label class="collapse" for="c-42671557">[-]</label><label class="expand" for="c-42671557">[3 more]</label></div><br/><div class="children"><div class="content">&gt; These kinds of build-failing tests are great for your &quot;I think I&#x27;m finished now&quot; build, but not for your &quot;I&#x27;m in the middle of something&quot; builds<p>i tend to disagree.<p>If you tried to express some thought but the compile time tests tells you you&#x27;re wrong, you might actually just have an incomplete thought, or have not thought through all of the consequences of said expression.<p>It&#x27;s basically what type-checking is in haskell - you cannot compile a program that does not type-check correctly. This forces you as a programmer, to always, and only, express complete thoughts. Incomplete, or contradictory thoughts cannot be expressed.<p>This should, in theory, lead to programs that are more well thought out. It also makes the program harder to write, because it forces the programmer to discover corners of their program for which they &quot;know&quot; isn&#x27;t valid but don&#x27;t care.</div><br/><div id="42671676" class="c"><input type="checkbox" id="c-42671676" checked=""/><div class="controls bullet"><span class="by">kstenerud</span><span>|</span><a href="#42671344">root</a><span>|</span><a href="#42671557">parent</a><span>|</span><a href="#42671941">next</a><span>|</span><label class="collapse" for="c-42671676">[-]</label><label class="expand" for="c-42671676">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it forces the programmer to discover corners of their program for which they &quot;know&quot; isn&#x27;t valid but don&#x27;t care.<p>And this is precisely why I disagree with forcing it upon the developer at every stage of development. Generally, while in the thick of things, I just want to get things working with one part, not worry about what other parts this breaks (yet). But the pedantic &quot;you have to fix this first&quot; enforcement breaks my concentration because now I have to split my attention to things I don&#x27;t want to even be bothered with yet. I&#x27;ll get to it, but I sure as hell don&#x27;t want you telling me WHEN I should.</div><br/></div></div><div id="42671941" class="c"><input type="checkbox" id="c-42671941" checked=""/><div class="controls bullet"><span class="by">d0mine</span><span>|</span><a href="#42671344">root</a><span>|</span><a href="#42671557">parent</a><span>|</span><a href="#42671676">prev</a><span>|</span><a href="#42671507">next</a><span>|</span><label class="collapse" for="c-42671941">[-]</label><label class="expand" for="c-42671941">[1 more]</label></div><br/><div class="children"><div class="content">Test-driven development has its uses. But it is wrong to make it mandatory. I myself run static checks&#x2F;unit tests almost all of the time. Still it is useful to skip them from time to time and just run the code to see the results (make it work before you make it &quot;right&quot; according to some linters rules).</div><br/></div></div></div></div><div id="42671507" class="c"><input type="checkbox" id="c-42671507" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#42671344">parent</a><span>|</span><a href="#42671557">prev</a><span>|</span><a href="#42672074">next</a><span>|</span><label class="collapse" for="c-42671507">[-]</label><label class="expand" for="c-42671507">[2 more]</label></div><br/><div class="children"><div class="content">Maybe these compile time tests are more like `static_assert`, which is valuable for catching incompatible uses of library functions.  Pretty good idea in my opinion.</div><br/><div id="42671540" class="c"><input type="checkbox" id="c-42671540" checked=""/><div class="controls bullet"><span class="by">kstenerud</span><span>|</span><a href="#42671344">root</a><span>|</span><a href="#42671507">parent</a><span>|</span><a href="#42672074">next</a><span>|</span><label class="collapse" for="c-42671540">[-]</label><label class="expand" for="c-42671540">[1 more]</label></div><br/><div class="children"><div class="content">Sure, enforcing invariants is a good thing to do right off the bat. But not &quot;does this code do what it says on the tin?&quot; kinds of tests. Those are better run gradually, at the (current) developer&#x27;s behest (and most certainly, not blocking compilation).</div><br/></div></div></div></div></div></div><div id="42672074" class="c"><input type="checkbox" id="c-42672074" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#42671344">prev</a><span>|</span><a href="#42670284">next</a><span>|</span><label class="collapse" for="c-42672074">[-]</label><label class="expand" for="c-42672074">[1 more]</label></div><br/><div class="children"><div class="content">I think the real question is why not everybody has already moved to D, if it is so much better and can do all the great things. The answer is that all these things have trade-offs, including implementation effort, changes in tooling, required training, backwards compatibility, etc.  some of the features are also not universally seen as better (e.g. IMHO a language which requires forward declaration is better, I also like how headers work).</div><br/></div></div><div id="42670284" class="c"><input type="checkbox" id="c-42670284" checked=""/><div class="controls bullet"><span class="by">kreco</span><span>|</span><a href="#42672074">prev</a><span>|</span><a href="#42669896">next</a><span>|</span><label class="collapse" for="c-42670284">[-]</label><label class="expand" for="c-42670284">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Evaluating Constant Expressions<p>The examples are quite simple in the article but I believe more complex cases would significantly degrade the compiler speed (and probably the memory footprint as well) and would require a VM to leverage this.<p>Which is probably assumed &quot;too complex&quot; to go into the standard.
I&#x27;m not saying it&#x27;s impossible, but I kind of understand <i>why</i> this would not go into any kind of standard.<p>&gt; Importing Declarations<p>I wish C++ (or even C) would have gone into this direction instead the weird mess of what is defined for C++20.<p>Additionally you might import module into some symbol, like:<p><pre><code>  #import &quot;string.c&quot; as str
</code></pre>
and every non-static symbols from the file can be accessed from like:<p><pre><code>  str.trim(&quot; Hello World &quot;);
</code></pre>
&gt; __import dex;<p>This is totally tangential but I don&#x27;t like when file paths are not explicit. In this specific case I don&#x27;t know if I&#x27;m importing dex.d or dex.c.</div><br/><div id="42670826" class="c"><input type="checkbox" id="c-42670826" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42670284">parent</a><span>|</span><a href="#42671391">next</a><span>|</span><label class="collapse" for="c-42670826">[-]</label><label class="expand" for="c-42670826">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I kind of understand why this would not go into any kind of standard.<p>Other popular languages can do it. That aside, it is an immensely popular and useful feature in D.<p>And yes, as one would expect, the more it is used, there&#x27;s compile time speed and memory consumption required. As for a VM, the constant folder is already a VM. This just extends it to be able to handle function calls. C has simple semantics, so it&#x27;s not that bad.<p>&gt; Additionally<p>Great minds think alike! Your suggestions are just what D imports do.
<a href="https:&#x2F;&#x2F;dlang.org&#x2F;spec&#x2F;module.html#import-declaration" rel="nofollow">https:&#x2F;&#x2F;dlang.org&#x2F;spec&#x2F;module.html#import-declaration</a><p>&gt; In this specific case I don&#x27;t know if I&#x27;m importing dex.d or dex.c<p>This issue does come up. The answer is setting up your import path. It&#x27;s analogous to the C compiler include path.</div><br/></div></div><div id="42671391" class="c"><input type="checkbox" id="c-42671391" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#42670284">parent</a><span>|</span><a href="#42670826">prev</a><span>|</span><a href="#42671156">next</a><span>|</span><label class="collapse" for="c-42671391">[-]</label><label class="expand" for="c-42671391">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  I believe more complex cases would significantly degrade the compiler speed (and probably the memory footprint as well) and would require a VM to leverage this.<p>I&#x27;m pretty sure most production grade c compilers already do some level of compiler time evaluation for optimization. And C already has constant expressions.<p>I think a bigger hurdle would be that the compiler needs access to the source code of the function, so it would probably be restricted to functions in the same translation unit.<p>And then there is the possibly even bigger people problem of getting a committee with representives from multiple compilers to agree on the semantics of such constant evaluation.</div><br/></div></div><div id="42671156" class="c"><input type="checkbox" id="c-42671156" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42670284">parent</a><span>|</span><a href="#42671391">prev</a><span>|</span><a href="#42669896">next</a><span>|</span><label class="collapse" for="c-42671156">[-]</label><label class="expand" for="c-42671156">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The examples are quite simple in the article but I believe more complex cases would significantly degrade the compiler speed (and probably the memory footprint as well) and would require a VM to leverage this.<p>&gt; Which is probably assumed &quot;too complex&quot; to go into the standard. I&#x27;m not saying it&#x27;s impossible, but I kind of understand why this would not go into any kind of standard.<p>I mean, it&#x27;s basically 1:1 with the constexpr feature in C++.  Almost every C compiler is already a C++ compiler, supporting constexpr functions and evaluation in C can&#x27;t be <i>that</i> bad, can it?</div><br/></div></div></div></div><div id="42669896" class="c"><input type="checkbox" id="c-42669896" checked=""/><div class="controls bullet"><span class="by">chacham15</span><span>|</span><a href="#42670284">prev</a><span>|</span><a href="#42671091">next</a><span>|</span><label class="collapse" for="c-42669896">[-]</label><label class="expand" for="c-42669896">[21 more]</label></div><br/><div class="children"><div class="content">While the author has WAY more knowledge&#x2F;experience than me on this and so I wonder how he would solve the following issues:<p>Evaluating Constant Expressions<p>- This seems really complicated...if you&#x27;re working within a translation unit, thats much simplified, but then you&#x27;re much more limited in what you can do without repeating a lot of code. I wonder how the author solves this.<p>Compile Time Unit Tests<p>- This is already somewhat possible if you can express your test as a macro, which if you add in the first point, then this becomes trivial.<p>Forward Referencing of Declarations<p>- I think there may be a lot of backlash to this one. The main argument against this is that it then changes the compiler from a one-pass to two pass compiler which has its own performance implications. Given the number of people who are trying to compile massive codebases and go as far as parallelizing compilation of translation units, this may be a tough pill for them to swallow. (evaluating constant expressions probably comes with a similar&#x2F;worse performance hit caveat depending on how its done)<p>Importing Declarations<p>- This is a breaking change...one of the ways I have kind of implemented templating in C is by defining a variable and importing a c file, changing the variable, and then reimporting the same c file. Another thing I&#x27;ve done is define a bunch of things and then import the SQLite C Amalgamation and then add another function (I do this to expose a SQLite internal which isnt exposed via its headers). All of these use cases would break with this change.<p>Are there any thoughts about these issues? Any ways to solve them perhaps?</div><br/><div id="42669998" class="c"><input type="checkbox" id="c-42669998" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42669896">parent</a><span>|</span><a href="#42670490">next</a><span>|</span><label class="collapse" for="c-42669998">[-]</label><label class="expand" for="c-42669998">[10 more]</label></div><br/><div class="children"><div class="content">&gt; if you&#x27;re working within a translation unit, thats much simplified, but then you&#x27;re much more limited in what you can do without repeating a lot of code. I wonder how the author solves this.<p>You are correct in that the source code to the function being evaluated must be available to the compiler. This can be done with #include. I do it in D with importing the modules with the needed code.<p>&gt; This is already somewhat possible if you can express your test as a macro, which if you add in the first point, then this becomes trivial.<p>Expressing the test as a macro doesn&#x27;t work when you want to test the function. The example I gave was trivial to make it easy to understand. Actual use can be far more complex.<p>&gt; Performance<p>D is faster at compiling than C compilers, mainly because:<p>1. the C preprocessor is a hopeless pig with its required multiple passes. I know, I implemented it from scratch multiple times. The C preprocessor was an excellent design choice when it was invented. Today it is a fossil. I&#x27;m still in awe of why C++ has never gotten around to deprecating it.<p>2. D uses import rather than #include. This is just way, way faster, as the .h files don&#x27;t need to be compiled over and over and over and over and over ...<p>D&#x27;s strategy is to separate the parse from the semantic analysis. I suppose it is a hair slower, but it also doesn&#x27;t have to recompile the duplicate declarations and fold them into one.<p>Compile time function execution can be a bottleneck, sure, but that (of course) depends on how heavily it is used. I tend to use it with a light touch and the performance is fine. If you implement a compiler using it (as people have done!) it can be slow.<p>&gt; one of the ways I have kind of implemented templating in C is by defining a variable and importing a c file, changing the variable, and then reimporting the same c file. Another thing I&#x27;ve done is define a bunch of things and then import the SQLite C Amalgamation and then add another function (I do this to expose a SQLite internal which isnt exposed via its headers). All of these use cases would break with this change.<p>I am not suggesting removing #include for C. The import thing would be additive.<p>&gt; Are there any thoughts about these issues?<p>If you&#x27;re using hacks to do templating in C, you&#x27;ve outgrown the language and need a more powerful one. D has top shelf metaprogramming - and as usual, other template languages are following in D&#x27;s path.</div><br/><div id="42670610" class="c"><input type="checkbox" id="c-42670610" checked=""/><div class="controls bullet"><span class="by">chacham15</span><span>|</span><a href="#42669896">root</a><span>|</span><a href="#42669998">parent</a><span>|</span><a href="#42670067">next</a><span>|</span><label class="collapse" for="c-42670610">[-]</label><label class="expand" for="c-42670610">[4 more]</label></div><br/><div class="children"><div class="content">Thanks for taking the time to respond! I have a few followup questions if thats ok:<p>&gt; You are correct in that the source code to the function being evaluated must be available to the compiler. This can be done with #include. I do it in D with importing the modules with the needed code.<p>&gt; D&#x27;s strategy is to separate the parse from the semantic analysis. I suppose it is a hair slower, but it also doesn&#x27;t have to recompile the duplicate declarations and fold them into one.<p>I dont quite follow all the implications that these statements have. Does the compiler have a different way of handling a translation unit?<p>- Is a translation unit the same as in C, but since you&#x27;re #including the file you would expect multiple compilations of a re-included C file? woudnt this bloat the resulting executable (&#x2F; bundle in case of a library)<p>- Are multiple translation units compiled at a time? Wouldnt this mean that the entire translation dependency graph would need to be simultaneously recompiled? Wouldnt this inhibit parallelization? How would it handle recompilation? What happens if a dependency is already compiled? Would it recompile it?<p>&gt; Performance<p>I think a lot of this is tied to my question about compilation&#x2F;translation units above, but from my past experience we have &quot;header hygene&quot; which forces us to use headers in a specific way, which if we do, we actually get really good preprocessor performance (a simple example being: dont use #include in a header), how would you compare performance in these kinds of situations vs a compiler without (i.e. either recompiled a full source file or looking up definitions from a compiled source)?<p>&gt; If you&#x27;re using hacks to do templating in C, you&#x27;ve outgrown the language and need a more powerful one. D has top shelf metaprogramming - and as usual, other template languages are following in D&#x27;s path.<p>yes, as also demonstrated in the performance question, we do a lot to work within the confines of what we have when other tools would handle a lot more of the lifting for us and this is a fair criticism, but on the flip side, I dont have the power to make large decisions on an existing codebase like &quot;lets switch languages&quot; (even if for a source file or two...I&#x27;ve tried) as much as I wish I could, so I have to work with what I have.</div><br/><div id="42670972" class="c"><input type="checkbox" id="c-42670972" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42669896">root</a><span>|</span><a href="#42670610">parent</a><span>|</span><a href="#42670913">next</a><span>|</span><label class="collapse" for="c-42670972">[-]</label><label class="expand" for="c-42670972">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I dont have the power to make large decisions on an existing codebase like &quot;lets switch languages&quot;<p>We struggled with that for a long time with D. And finally found a solution. D can compile Standard C source files and make all the C declarations available to the D code. When I proposed it, there was a lot of skepticism that this could ever work. But when it was implemented and debugged, it&#x27;s been a huge win for D.<p>&gt; Performance<p>With D you can put all your source files on one command line invocation. That means that imports are only read once, no matter how many times it is imported. This works so well D users have generally abandoned the C approach of compiling each file individually and then linking them together. A vast amount of time is lost in C&#x2F;C++ compilation with simply reading the .h files thousands of times.<p>Modules&#x2F;imports are a <i>gigantic</i> productivity booster. They&#x27;re not hard to implement, either. Except for the way C++ did it.<p>&gt; re multiple translation units compiled at a time? Wouldnt this mean that the entire translation dependency graph would need to be simultaneously recompiled? Wouldnt this inhibit parallelization? How would it handle recompilation? What happens if a dependency is already compiled? Would it recompile it?<p>Yes, yes, yes, yes. And yet, it <i>still</i> compiles faster! See what I wrote above about not needing to read the .h files thousands of times. Oh, and building one large object file is faster than building a hundred and having to link them together.</div><br/></div></div><div id="42670913" class="c"><input type="checkbox" id="c-42670913" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#42669896">root</a><span>|</span><a href="#42670610">parent</a><span>|</span><a href="#42670972">prev</a><span>|</span><a href="#42670067">next</a><span>|</span><label class="collapse" for="c-42670913">[-]</label><label class="expand" for="c-42670913">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Is a translation unit the same as in C, but since you&#x27;re #including the file you would expect multiple compilations of a re-included C file? woudnt this bloat the resulting executable (&#x2F; bundle in case of a library)<p>I think the idea is that compiling a translation unit produces two outputs, the object code (as it currently does), and an intermediate representation of the exported declarations, that could be basically a generated .h file, but it would probably be more efficient to use a different format. Then dependent translation units use those declaration files.<p>With this, you can still compile in parallel. You are constrained by the order of dependencies, but that is already kind of the case.<p>One complication is that ideally, if the signature doesn&#x27;t change, but the implementation does, you don&#x27;t need to re-compile dependent translation units. This is trivial if your build system detects changes based on content (like, say, bazel), but if it uses timestamps (like make) then the compiler needs to ensure the timestamp isn&#x27;t updated when the declarations don&#x27;t change.<p>But this really isn&#x27;t a new concept. Basically every modern compiled language works fine without needing separate header files.</div><br/><div id="42671349" class="c"><input type="checkbox" id="c-42671349" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42669896">root</a><span>|</span><a href="#42670913">parent</a><span>|</span><a href="#42670067">next</a><span>|</span><label class="collapse" for="c-42671349">[-]</label><label class="expand" for="c-42671349">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is trivial if your build system detects changes based on content (like, say, bazel), but if it uses timestamps (like make) then the compiler needs to ensure the timestamp isn&#x27;t updated when the declarations don&#x27;t change.<p>This is where the traditional distinction of &quot;compiler vs Make&quot; makes things harder; you want dependencies tracked at the &quot;declaration&quot; level, rather than the file level. If the timestamp _and_ content of the exported declarations file change, but none of the _used_ declarations changed, then there&#x27;s no more compilation to be done. At best with file level tracking your build system will invoke the compiler for every downstream dependency, and they can decide if there&#x27;s any more work to be done.<p>The build system would need to know which declarations are used (and what a declaration is) to do better.</div><br/></div></div></div></div></div></div><div id="42670067" class="c"><input type="checkbox" id="c-42670067" checked=""/><div class="controls bullet"><span class="by">daymanstep</span><span>|</span><a href="#42669896">root</a><span>|</span><a href="#42669998">parent</a><span>|</span><a href="#42670610">prev</a><span>|</span><a href="#42670490">next</a><span>|</span><label class="collapse" for="c-42670067">[-]</label><label class="expand" for="c-42670067">[5 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t you use precompiled headers?</div><br/><div id="42670101" class="c"><input type="checkbox" id="c-42670101" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42669896">root</a><span>|</span><a href="#42670067">parent</a><span>|</span><a href="#42671819">next</a><span>|</span><label class="collapse" for="c-42670101">[-]</label><label class="expand" for="c-42670101">[3 more]</label></div><br/><div class="children"><div class="content">Interesting you brought that up. I implemented them for Symantec C and C++ back in the 90s.<p>I never want to do that again!<p>They are brittle and a maintenance nightmare. They did speed up compilations, though, but did not provide any semantic advantage.<p>With D I focused on fast compilation so much that precompiled headers didn&#x27;t offer enough speedup to make them worth the agony.</div><br/><div id="42670317" class="c"><input type="checkbox" id="c-42670317" checked=""/><div class="controls bullet"><span class="by">fuhsnn</span><span>|</span><a href="#42669896">root</a><span>|</span><a href="#42670101">parent</a><span>|</span><a href="#42671819">next</a><span>|</span><label class="collapse" for="c-42670317">[-]</label><label class="expand" for="c-42670317">[2 more]</label></div><br/><div class="children"><div class="content">&gt;They are brittle and a maintenance nightmare<p>I happened to be reading DMC source this week, those hydrate&#x2F;dehydrate stuff really is everywhere (which I assume is solely used for precompiled headers?)</div><br/><div id="42670830" class="c"><input type="checkbox" id="c-42670830" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42669896">root</a><span>|</span><a href="#42670317">parent</a><span>|</span><a href="#42671819">next</a><span>|</span><label class="collapse" for="c-42670830">[-]</label><label class="expand" for="c-42670830">[1 more]</label></div><br/><div class="children"><div class="content">Yup. I spent a crazy amount of time debugging that. The tiniest mistake was a big problem to find.</div><br/></div></div></div></div></div></div><div id="42671819" class="c"><input type="checkbox" id="c-42671819" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#42669896">root</a><span>|</span><a href="#42670067">parent</a><span>|</span><a href="#42670101">prev</a><span>|</span><a href="#42670490">next</a><span>|</span><label class="collapse" for="c-42671819">[-]</label><label class="expand" for="c-42671819">[1 more]</label></div><br/><div class="children"><div class="content">I had an intern try to use precompiled headers for the Linux kernel. The road block they found was that the command line parameters used to compile the header must exactly match for all translation units which it is used. This is no the case for the Linux kernel. We could compile the header multiple times, but the build complexity was not something we could overcome during the course of one internship.</div><br/></div></div></div></div></div></div><div id="42670490" class="c"><input type="checkbox" id="c-42670490" checked=""/><div class="controls bullet"><span class="by">billfruit</span><span>|</span><a href="#42669896">parent</a><span>|</span><a href="#42669998">prev</a><span>|</span><a href="#42670024">next</a><span>|</span><label class="collapse" for="c-42670490">[-]</label><label class="expand" for="c-42670490">[3 more]</label></div><br/><div class="children"><div class="content">Every other language does seems to not require header file&#x2F;forward declarations. I don&#x27;t understand the backlash against that.<p>Are modern C compilers actually still single pass?</div><br/><div id="42670848" class="c"><input type="checkbox" id="c-42670848" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42669896">root</a><span>|</span><a href="#42670490">parent</a><span>|</span><a href="#42671253">next</a><span>|</span><label class="collapse" for="c-42670848">[-]</label><label class="expand" for="c-42670848">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Are modern C compilers actually still single pass?<p>All except ImportC, which effortlessly handles forward references. (Mainly because ImportC hijacks the D front end to do the semantics.)</div><br/></div></div><div id="42671253" class="c"><input type="checkbox" id="c-42671253" checked=""/><div class="controls bullet"><span class="by">UncleEntity</span><span>|</span><a href="#42669896">root</a><span>|</span><a href="#42670490">parent</a><span>|</span><a href="#42670848">prev</a><span>|</span><a href="#42670024">next</a><span>|</span><label class="collapse" for="c-42671253">[-]</label><label class="expand" for="c-42671253">[1 more]</label></div><br/><div class="children"><div class="content">A bit of an aside but I was poking around in the SPIR-V spec yesterday and they can do forward references because the call site contains all the information to determine the function parameter types. Just thought it was interesting and not really something I had thought about before.</div><br/></div></div></div></div><div id="42670024" class="c"><input type="checkbox" id="c-42670024" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#42669896">parent</a><span>|</span><a href="#42670490">prev</a><span>|</span><a href="#42671091">next</a><span>|</span><label class="collapse" for="c-42670024">[-]</label><label class="expand" for="c-42670024">[7 more]</label></div><br/><div class="children"><div class="content">I personally don’t like forward referencing because it makes code harder to read. You can no longer rely on the dependency graph being in topological order.</div><br/><div id="42670048" class="c"><input type="checkbox" id="c-42670048" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42669896">root</a><span>|</span><a href="#42670024">parent</a><span>|</span><a href="#42671091">next</a><span>|</span><label class="collapse" for="c-42670048">[-]</label><label class="expand" for="c-42670048">[6 more]</label></div><br/><div class="children"><div class="content">As the article writes, that forces the private leaf functions to be at the top, with the public interface at the end of the file. The normal way is the public interface at the top, and the implementation &quot;below the fold&quot;, so to speak.<p>&gt; topological order<p>You are correct. But its the reverse topological order, which is not the most readable ordering. One doesn&#x27;t read a newspaper article starting at the bottom.</div><br/><div id="42672178" class="c"><input type="checkbox" id="c-42672178" checked=""/><div class="controls bullet"><span class="by">chikere232</span><span>|</span><a href="#42669896">root</a><span>|</span><a href="#42670048">parent</a><span>|</span><a href="#42670066">next</a><span>|</span><label class="collapse" for="c-42672178">[-]</label><label class="expand" for="c-42672178">[1 more]</label></div><br/><div class="children"><div class="content">People learn the ordering. If that is their biggest hurdle learning C they have a blessed life</div><br/></div></div><div id="42670066" class="c"><input type="checkbox" id="c-42670066" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#42669896">root</a><span>|</span><a href="#42670048">parent</a><span>|</span><a href="#42672178">prev</a><span>|</span><a href="#42671091">next</a><span>|</span><label class="collapse" for="c-42670066">[-]</label><label class="expand" for="c-42670066">[4 more]</label></div><br/><div class="children"><div class="content">Maybe it’s because I’m primarily a mathematician, but I like building complex stuff up from primitives and having the most important results at the end.</div><br/><div id="42670244" class="c"><input type="checkbox" id="c-42670244" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#42669896">root</a><span>|</span><a href="#42670066">parent</a><span>|</span><a href="#42670084">next</a><span>|</span><label class="collapse" for="c-42670244">[-]</label><label class="expand" for="c-42670244">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not how I do things in math. I always need motivation first. So I start with the theorem, look at a couple of examples to see why this theorem is interesting, and then the various lemmas leading into the proof. So that means I really like declaring but not defining the public interface first, and then define the private helper functions, and finally definitions for the public interface.</div><br/></div></div><div id="42670084" class="c"><input type="checkbox" id="c-42670084" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42669896">root</a><span>|</span><a href="#42670066">parent</a><span>|</span><a href="#42670244">prev</a><span>|</span><a href="#42671260">next</a><span>|</span><label class="collapse" for="c-42670084">[-]</label><label class="expand" for="c-42670084">[1 more]</label></div><br/><div class="children"><div class="content">Vive la différence - and you&#x27;ll still be able to do it your way!</div><br/></div></div><div id="42671260" class="c"><input type="checkbox" id="c-42671260" checked=""/><div class="controls bullet"><span class="by">Lvl999Noob</span><span>|</span><a href="#42669896">root</a><span>|</span><a href="#42670066">parent</a><span>|</span><a href="#42670084">prev</a><span>|</span><a href="#42671091">next</a><span>|</span><label class="collapse" for="c-42671260">[-]</label><label class="expand" for="c-42671260">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps the difference is having algorithm in your head and just putting it into code, versus only knowing the top level work to be done and implementing the needed operations later.<p>If I am writing some kind of service, I would write the main public functions first, using undefined functions in their bodies as needed. Then I would implement those functions below.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42671091" class="c"><input type="checkbox" id="c-42671091" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#42669896">prev</a><span>|</span><a href="#42671307">next</a><span>|</span><label class="collapse" for="c-42671091">[-]</label><label class="expand" for="c-42671091">[6 more]</label></div><br/><div class="children"><div class="content">&gt; <i>the compiler only knows about what lexically precedes it. […] it drives programmers to lay out the declarations backwards. The leaf functions come first, and the global interface functions are last. It’s like reading a newspaper article from the bottom up. It makes no sense.</i><p>Defining functions on a “bottom-up” order like this is common even in languages like Python which allow forward references. [0]<p>Is that just a holdover from languages which don’t allow such references? Or does it actually make more sense for certain types of code?<p>[0] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;73131538" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;73131538</a></div><br/><div id="42672114" class="c"><input type="checkbox" id="c-42672114" checked=""/><div class="controls bullet"><span class="by">throwuxiytayq</span><span>|</span><a href="#42671091">parent</a><span>|</span><a href="#42671169">next</a><span>|</span><label class="collapse" for="c-42672114">[-]</label><label class="expand" for="c-42672114">[1 more]</label></div><br/><div class="children"><div class="content">In my code, the public interface always tends to bubble upwards, and implementation details go at the end of the file. I don’t even have a strict rule for this, it just reads more cleanly and seems to make sense. Especially if the implementation is large - you don’t want to scroll through all that before you get to the basics of what it all does. I’m curious how everyone else does things.</div><br/></div></div><div id="42671169" class="c"><input type="checkbox" id="c-42671169" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#42671091">parent</a><span>|</span><a href="#42672114">prev</a><span>|</span><a href="#42671307">next</a><span>|</span><label class="collapse" for="c-42671169">[-]</label><label class="expand" for="c-42671169">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;re confused. There are no forward references in python. It&#x27;s simply that identifiers in the body of a function aren&#x27;t resolved until the function itself is executed (if ever) and at the point everything in the module scope has been defined. You can test this yourself by just putting any name into a body and loading the module.</div><br/><div id="42671251" class="c"><input type="checkbox" id="c-42671251" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#42671091">root</a><span>|</span><a href="#42671169">parent</a><span>|</span><a href="#42671307">next</a><span>|</span><label class="collapse" for="c-42671251">[-]</label><label class="expand" for="c-42671251">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>identifiers in the body of a function aren&#x27;t resolved until the function itself is executed (if ever) and at the point everything in the module scope has been defined</i><p>Yes, so within a function you can refer to things that are defined later in the module. Isn&#x27;t that&#x27;s a &quot;forward reference&quot;, even if the details are slightly different from how they work in D?</div><br/><div id="42671263" class="c"><input type="checkbox" id="c-42671263" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#42671091">root</a><span>|</span><a href="#42671251">parent</a><span>|</span><a href="#42671307">next</a><span>|</span><label class="collapse" for="c-42671263">[-]</label><label class="expand" for="c-42671263">[2 more]</label></div><br/><div class="children"><div class="content">&gt; so within a function you can refer to things that are defined later in the module<p>Correction: you can refer to anything within a function, even things that don&#x27;t exist. What this is actually called is late binding.<p>But you can insist as much as you want even though it&#x27;s not the same mechanism and it doesn&#x27;t work at all like forward references. Feel free to redefine terms that have accepted definitions&#x2F;understandings just to be right I guess &lt;shrug&gt;</div><br/><div id="42671355" class="c"><input type="checkbox" id="c-42671355" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#42671091">root</a><span>|</span><a href="#42671263">parent</a><span>|</span><a href="#42671307">next</a><span>|</span><label class="collapse" for="c-42671355">[-]</label><label class="expand" for="c-42671355">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right, it&#x27;s not the same mechanism. But in this particular context it has the same effect - it allows you to define functions in a source file in arbitrary order.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42671307" class="c"><input type="checkbox" id="c-42671307" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#42671091">prev</a><span>|</span><a href="#42671718">next</a><span>|</span><label class="collapse" for="c-42671307">[-]</label><label class="expand" for="c-42671307">[3 more]</label></div><br/><div class="children"><div class="content">Some of my &quot;obvious things c should do&quot; for me would include things like<p>- add support for a slice type that encodes a pointer and length<p>- make re-entrant and ideally threadsafe APIs for things that currently use global state (including environment variables).<p>- standardize something like defer in go and zig, or gcc&#x27;s cleanup attribute<p>- Maybe some portable support for unicode and utf-8.</div><br/><div id="42671579" class="c"><input type="checkbox" id="c-42671579" checked=""/><div class="controls bullet"><span class="by">zffr</span><span>|</span><a href="#42671307">parent</a><span>|</span><a href="#42671718">next</a><span>|</span><label class="collapse" for="c-42671579">[-]</label><label class="expand" for="c-42671579">[2 more]</label></div><br/><div class="children"><div class="content">Aren’t most of these things you want in the standard library, and not things that the language itself should do?</div><br/><div id="42671605" class="c"><input type="checkbox" id="c-42671605" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#42671307">root</a><span>|</span><a href="#42671579">parent</a><span>|</span><a href="#42671718">next</a><span>|</span><label class="collapse" for="c-42671605">[-]</label><label class="expand" for="c-42671605">[1 more]</label></div><br/><div class="children"><div class="content">Only half of them. The first and third are language things.<p>The first could <i>almost</i> be done with macros. Except that separate declarations of an equivalent struct are considered different, so the best you cand do is a macro you can use define your owne typedef for a specific slice type. It could be done in the library if c supported something like a struct that had structural instead of nominal typing.</div><br/></div></div></div></div></div></div><div id="42671718" class="c"><input type="checkbox" id="c-42671718" checked=""/><div class="controls bullet"><span class="by">pajko</span><span>|</span><a href="#42671307">prev</a><span>|</span><a href="#42672012">next</a><span>|</span><label class="collapse" for="c-42671718">[-]</label><label class="expand" for="c-42671718">[1 more]</label></div><br/><div class="children"><div class="content">C23 has constexpr, which cannot be given for functions yet, but there&#x27;s a proposal: <a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg14&#x2F;www&#x2F;docs&#x2F;n2976.pdf" rel="nofollow">https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg14&#x2F;www&#x2F;docs&#x2F;n2976.pdf</a></div><br/></div></div><div id="42672012" class="c"><input type="checkbox" id="c-42672012" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#42671718">prev</a><span>|</span><a href="#42671319">next</a><span>|</span><label class="collapse" for="c-42672012">[-]</label><label class="expand" for="c-42672012">[2 more]</label></div><br/><div class="children"><div class="content">The most obvious thing c should do is... evolve.<p>Even Fortran seems to have added object-oriented constructs, all kinds of new types and concurrent and parallel programming</div><br/><div id="42672047" class="c"><input type="checkbox" id="c-42672047" checked=""/><div class="controls bullet"><span class="by">4gotunameagain</span><span>|</span><a href="#42672012">parent</a><span>|</span><a href="#42671319">next</a><span>|</span><label class="collapse" for="c-42672047">[-]</label><label class="expand" for="c-42672047">[1 more]</label></div><br/><div class="children"><div class="content">There has been an object-oriented evolution of c, it&#x27;s called c++ ;)</div><br/></div></div></div></div><div id="42671319" class="c"><input type="checkbox" id="c-42671319" checked=""/><div class="controls bullet"><span class="by">DarkmSparks</span><span>|</span><a href="#42672012">prev</a><span>|</span><a href="#42671780">next</a><span>|</span><label class="collapse" for="c-42671319">[-]</label><label class="expand" for="c-42671319">[1 more]</label></div><br/><div class="children"><div class="content">while this is a very interesting take, I think the premise is a little bit to simple.<p>Firstly, there are at least 3 C compilers in widespread use, from apple, microsoft and gnu, these are a long way from 1 for 1 to each other so when it says for example:<p>-&gt;In other words, while C can compute at compile time a simple expression by constant folding, it cannot execute a function at compile time.<p>Maybe the compiler he tried cannot, but another can, no idea, it wasnt tested, they can be made to (the whole point of the article), apple and microsoft cannot be made to, everything in this article could have have been submitted as a merge request to gnu.... Article doesnt even state whose C compiler they embedded afaict.<p>wrt to &quot;standard&quot; c specifically, there are for sure some hard constraints on all the wild and wacky hardware support required that must make proposing and implementing changes within the c standard extremely hard, max respect to the anonymous experts that have got it to where it is today, but imho a lot of the &quot;why doesnt c&quot; questions can be as easily answered as &quot;why doesnt V8 support 8 bit pic micros&quot;.</div><br/></div></div><div id="42671780" class="c"><input type="checkbox" id="c-42671780" checked=""/><div class="controls bullet"><span class="by">dailykoder</span><span>|</span><a href="#42671319">prev</a><span>|</span><a href="#42671599">next</a><span>|</span><label class="collapse" for="c-42671780">[-]</label><label class="expand" for="c-42671780">[1 more]</label></div><br/><div class="children"><div class="content">Maybe C should do that, but it won&#x27;t. So why complain? Just work with the language as it is</div><br/></div></div><div id="42671599" class="c"><input type="checkbox" id="c-42671599" checked=""/><div class="controls bullet"><span class="by">nitwit005</span><span>|</span><a href="#42671780">prev</a><span>|</span><a href="#42671275">next</a><span>|</span><label class="collapse" for="c-42671599">[-]</label><label class="expand" for="c-42671599">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Everywhere a C constant-expression appears in the C grammar the compiler should be able to execute functions at compile time, too, as long as the functions do not do things like I&#x2F;O, access mutable global variables, make system calls, etc.<p>They have been working on bringing constexpr, which exists in c++, to c. This is essentially a constexpr function.</div><br/></div></div><div id="42671275" class="c"><input type="checkbox" id="c-42671275" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#42671599">prev</a><span>|</span><a href="#42670509">next</a><span>|</span><label class="collapse" for="c-42671275">[-]</label><label class="expand" for="c-42671275">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a c programmer, but having unit tests automatically run at compile time seems odd. If i wanted to run tests at the same time as compiling i would put that in the makefile.</div><br/><div id="42671583" class="c"><input type="checkbox" id="c-42671583" checked=""/><div class="controls bullet"><span class="by">sixthDot</span><span>|</span><a href="#42671275">parent</a><span>|</span><a href="#42671280">next</a><span>|</span><label class="collapse" for="c-42671583">[-]</label><label class="expand" for="c-42671583">[1 more]</label></div><br/><div class="children"><div class="content">Most of D users would rather call that &quot;static contracts&quot;. I dont know why the author choose to call that &quot;unit test&quot;.</div><br/></div></div><div id="42671280" class="c"><input type="checkbox" id="c-42671280" checked=""/><div class="controls bullet"><span class="by">zeroonetwothree</span><span>|</span><a href="#42671275">parent</a><span>|</span><a href="#42671583">prev</a><span>|</span><a href="#42670509">next</a><span>|</span><label class="collapse" for="c-42671280">[-]</label><label class="expand" for="c-42671280">[2 more]</label></div><br/><div class="children"><div class="content">Why is it odd? The compiler does all sorts of other checks based on things like static assert or type information.</div><br/><div id="42671303" class="c"><input type="checkbox" id="c-42671303" checked=""/><div class="controls bullet"><span class="by">kstenerud</span><span>|</span><a href="#42671275">root</a><span>|</span><a href="#42671280">parent</a><span>|</span><a href="#42670509">next</a><span>|</span><label class="collapse" for="c-42671303">[-]</label><label class="expand" for="c-42671303">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s odd because you lose control over that aspect of compilation. It slows down the development loop because every time you do a build you have to wait for a bunch of unit tests that you don&#x27;t care about yet.<p>Every time you do exploratory work you now have to comment out all the tests that this work breaks because otherwise it won&#x27;t compile anymore.<p>That would be even more annoying than Go&#x27;s stupidly pedantic compiler.</div><br/></div></div></div></div></div></div><div id="42670509" class="c"><input type="checkbox" id="c-42670509" checked=""/><div class="controls bullet"><span class="by">EuAndreh</span><span>|</span><a href="#42671275">prev</a><span>|</span><a href="#42669893">next</a><span>|</span><label class="collapse" for="c-42670509">[-]</label><label class="expand" for="c-42670509">[7 more]</label></div><br/><div class="children"><div class="content">Good suggestions, but also meh, e.g.: forward declaration requirement enables a single-pass compiler to emit code on-the-fly.<p>I have a much better list for things to add to C: Nothing.  C isn&#x27;t perfect, or nearly as good as it could be, but simply adding things onto C gets you C++.<p>Adjusting what sircmpwn says: in C you don&#x27;t solve problems by adding features, but by writing more code in C.<p>I liked an answer on stack overflow on a question on &quot;how to write a generic function wrapper in Go&quot;, or something similar.  Many suggestions included reflection, but the author wanted something simpler with varargs without reflection.  A comment simply said: &quot;wrong language&quot;.<p>I&#x27;d rather adopt this position for some languages, instead of add more and more to C3X.  I do away with things in C23, and don&#x27;t want even more things added in to C.<p>Making a strech of OP&#x27;s arguments: &quot;look at all this cool things that C could do, and that D does!&quot;.  Well, go on and use D, nothing wrong with that.<p>(BTW, I do write test targets for every file in my C projects, but I&#x27;m not so much into jogging).<p>Those things aren&#x27;t that obvious, and I&#x27;d rather not have them added to C.<p>Wrong language.</div><br/><div id="42670706" class="c"><input type="checkbox" id="c-42670706" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42670509">parent</a><span>|</span><a href="#42670545">next</a><span>|</span><label class="collapse" for="c-42670706">[-]</label><label class="expand" for="c-42670706">[3 more]</label></div><br/><div class="children"><div class="content">&gt; forward declaration requirement enables a single-pass compiler to emit code on-the-fly.<p>True, I know all about that. My Zortech C and C++ compiler was one pass (after the multiple preprocessing passes). The ground up ImportC C compiler completed a couple years ago has a separate parse pass.<p>So I well know the tradeoffs. The parser being stand-alone means it is much simpler to understand and unittest. I found no advantage to a single pass compiler. It isn&#x27;t any faster.<p>&gt; simply adding things onto C gets you C++<p>C++ doesn&#x27;t allow forward declarations either.<p>Successfully doing a parse-only on C code doesn&#x27;t quite work. It turns out the grammar relies on a symbol table. Fortunately, only a symbol table of the typedefs. Once adding that in, ImportC worked. (I really tried to make it work without the typedef symbol table!)<p>C++ added a bunch more syntax that relies on the symbol table. I would not even try fixing it to work as parse-only.<p>&gt; in C you don&#x27;t solve problems by adding features, but by writing more code in C<p>The trouble with such sayings is like following a google map that says cross this bridge, but wasn&#x27;t updated with news that the bridge is out.<p>&gt; Those things aren&#x27;t that obvious,<p>They are once you use another language that doesn&#x27;t have those restrictions.<p>&gt; and I&#x27;d rather not have them added to C.<p>C adds new things all the time to the Standard, like normalized Unicode identifiers, which are a complete waste of time. Every C compiler also adds a boatload of extensions, some good, some wacky, many ineptly documented, all incompatible with every other C compiler extensions.</div><br/><div id="42671181" class="c"><input type="checkbox" id="c-42671181" checked=""/><div class="controls bullet"><span class="by">EuAndreh</span><span>|</span><a href="#42670509">root</a><span>|</span><a href="#42670706">parent</a><span>|</span><a href="#42670545">next</a><span>|</span><label class="collapse" for="c-42671181">[-]</label><label class="expand" for="c-42671181">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The parser being stand-alone means it is much simpler to understand and unittest.<p>Stand-aloneness and single-passness are orthogonal.<p>&gt; I found no advantage to a single pass compiler. It isn&#x27;t any faster.<p>A gigantic advantage: a single-pass-compilable language is simpler.  By definition.<p>Implementations may or may not be simpler or faster.<p>&gt; C++ doesn&#x27;t allow forward declarations either.<p>Well, that&#x27;s not what I meant.<p>C++ is &quot;C with just this thing&quot; done way too many times.<p>&gt; The trouble with such sayings is like following a google map that says cross this bridge, but wasn&#x27;t updated with news that the bridge is out.<p>TBH, I didn&#x27;t really get this.  Is this about sticking to C as is, but it is outdated as is?<p>C would be outdated if it didn&#x27;t have, say, long long for 64-bit numbers.  Having &quot;true&quot; be a keyword instead of a macro doesn&#x27;t change how outdated it is or isn&#x27;t, just like compile-time evaluation also doesn&#x27;t.<p>&gt; They are once you use another language that doesn&#x27;t have those restrictions.<p>I have used many, and I still don&#x27;t find them obvious.<p>&gt; C adds new things all the time to the Standard, like normalized Unicode identifiers, which are a complete waste of time.<p>I agree that many&#x2F;most are a waste of time, and shouldn&#x27;t be added to C.  The fact of C adding things to the standard all the time shouldn&#x27;t justify adding even more things, but make one question if those are needed at all, and how to accomplish the goal without it.<p>&gt; Every C compiler also adds a boatload of extensions, some good, some wacky, many ineptly documented, all incompatible with every other C compiler extensions.<p>I know about that, and my position is the same: just don&#x27;t.<p>I don&#x27;t use them also.</div><br/><div id="42671950" class="c"><input type="checkbox" id="c-42671950" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#42670509">root</a><span>|</span><a href="#42671181">parent</a><span>|</span><a href="#42670545">next</a><span>|</span><label class="collapse" for="c-42671950">[-]</label><label class="expand" for="c-42671950">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A gigantic advantage: a single-pass-compilable language is simpler. By definition.<p>That&#x27;s only &quot;by definition&quot; if you take a language that needs multiple passes, then remove the features that need multiple passes, and don&#x27;t replace them with anything else to compensate.<p>The &quot;by definition simpler&quot; version of C would not only disallow forward references, it would have no forward declarations either.  As-is, forward declarations add some complexity of their own.<p>(Also, if you can figure out a way to emit jump instructions in a single pass, you can probably figure out a way to call unknown functions in a single pass.)</div><br/></div></div></div></div></div></div><div id="42670545" class="c"><input type="checkbox" id="c-42670545" checked=""/><div class="controls bullet"><span class="by">EuAndreh</span><span>|</span><a href="#42670509">parent</a><span>|</span><a href="#42670706">prev</a><span>|</span><a href="#42669893">next</a><span>|</span><label class="collapse" for="c-42670545">[-]</label><label class="expand" for="c-42670545">[3 more]</label></div><br/><div class="children"><div class="content">I have my own list of things that could &quot;easily&quot; be added to C, but I&#x27;d rather them not to be.</div><br/><div id="42670707" class="c"><input type="checkbox" id="c-42670707" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42670509">root</a><span>|</span><a href="#42670545">parent</a><span>|</span><a href="#42669893">next</a><span>|</span><label class="collapse" for="c-42670707">[-]</label><label class="expand" for="c-42670707">[2 more]</label></div><br/><div class="children"><div class="content">You get them anyway in the form of extensions.</div><br/><div id="42671202" class="c"><input type="checkbox" id="c-42671202" checked=""/><div class="controls bullet"><span class="by">EuAndreh</span><span>|</span><a href="#42670509">root</a><span>|</span><a href="#42670707">parent</a><span>|</span><a href="#42669893">next</a><span>|</span><label class="collapse" for="c-42671202">[-]</label><label class="expand" for="c-42671202">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, but no thanks.</div><br/></div></div></div></div></div></div></div></div><div id="42669893" class="c"><input type="checkbox" id="c-42669893" checked=""/><div class="controls bullet"><span class="by">TinkersW</span><span>|</span><a href="#42670509">prev</a><span>|</span><a href="#42671278">next</a><span>|</span><label class="collapse" for="c-42669893">[-]</label><label class="expand" for="c-42669893">[8 more]</label></div><br/><div class="children"><div class="content">C++ has all of these except forward referencing declarations(though Importing Declarations requires modules which nobody uses yet).<p>I&#x27;m not sure why forward reference declarations is needed nowadays(or if it really is from a language standpoint).<p>C could probably copy C++&#x27;s constexpr &amp; static_assert stuff to get the first 2.</div><br/><div id="42670038" class="c"><input type="checkbox" id="c-42670038" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42669893">parent</a><span>|</span><a href="#42670248">next</a><span>|</span><label class="collapse" for="c-42670038">[-]</label><label class="expand" for="c-42670038">[2 more]</label></div><br/><div class="children"><div class="content">Nobody uses C++ modules because they are clumsy to use. D&#x27;s are easy. Note: anyone is free to copy D&#x27;s module design. It&#x27;s the best one out there.<p>&gt; I&#x27;m not sure why forward reference declarations is needed nowadays<p>The article gives reasons. Although they aren&#x27;t <i>necessary</i>, they <i>are</i> deleterious to code layout which becomes a slave to the declaration order rather than aesthetic order.<p>&gt; C++&#x27;s constexpr<p>is still lagging behind D&#x27;s, after 17 years of development. In D, the garbage collector makes memory allocation in it trivial. Furthermore, only the <i>path</i> taken through a function needs to be CTFE-compatible, the path not taken does not.</div><br/><div id="42671301" class="c"><input type="checkbox" id="c-42671301" checked=""/><div class="controls bullet"><span class="by">zeroonetwothree</span><span>|</span><a href="#42669893">root</a><span>|</span><a href="#42670038">parent</a><span>|</span><a href="#42670248">next</a><span>|</span><label class="collapse" for="c-42671301">[-]</label><label class="expand" for="c-42671301">[1 more]</label></div><br/><div class="children"><div class="content">Robert Frost would approve</div><br/></div></div></div></div><div id="42670248" class="c"><input type="checkbox" id="c-42670248" checked=""/><div class="controls bullet"><span class="by">dccsillag</span><span>|</span><a href="#42669893">parent</a><span>|</span><a href="#42670038">prev</a><span>|</span><a href="#42671172">next</a><span>|</span><label class="collapse" for="c-42670248">[-]</label><label class="expand" for="c-42670248">[4 more]</label></div><br/><div class="children"><div class="content">If I&#x27;m not mistaken, the treatment of forward declarations proposed in the article actually breaks the C standard, which would be a rather pressing concern. As far as I am aware, that is <i>the</i> reason why things are the way they are right now in C land.<p>(In the past, there were more legitimate concerns on the ease of implementation. Nowadays, as the article points out, they are pretty moot, other than having to keep backwards-compatibility.)<p>I&#x27;m also rather bothered that on the bit on const execution in the article, there was no discussion on how to deal with functions that may not terminate or take rather long to execute. Especially considering the unit tests motivation, this seems like a rather blaring omission.</div><br/><div id="42670754" class="c"><input type="checkbox" id="c-42670754" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42669893">root</a><span>|</span><a href="#42670248">parent</a><span>|</span><a href="#42671172">next</a><span>|</span><label class="collapse" for="c-42670754">[-]</label><label class="expand" for="c-42670754">[3 more]</label></div><br/><div class="children"><div class="content">How does it break the C Standard?<p>&gt; how to deal with functions that may not terminate or take rather long to execute<p>Control-C, the same as when running any executable that shouldn&#x27;t be taking that long. It doesn&#x27;t solve the halting problem :-&#x2F;</div><br/><div id="42671267" class="c"><input type="checkbox" id="c-42671267" checked=""/><div class="controls bullet"><span class="by">UncleEntity</span><span>|</span><a href="#42669893">root</a><span>|</span><a href="#42670754">parent</a><span>|</span><a href="#42671172">next</a><span>|</span><label class="collapse" for="c-42671267">[-]</label><label class="expand" for="c-42671267">[2 more]</label></div><br/><div class="children"><div class="content">So a single typo DDoSes the entire Red Hat buildbot fleet?</div><br/><div id="42671321" class="c"><input type="checkbox" id="c-42671321" checked=""/><div class="controls bullet"><span class="by">kstenerud</span><span>|</span><a href="#42669893">root</a><span>|</span><a href="#42671267">parent</a><span>|</span><a href="#42671172">next</a><span>|</span><label class="collapse" for="c-42671321">[-]</label><label class="expand" for="c-42671321">[1 more]</label></div><br/><div class="children"><div class="content">You set a timeout, like in any robust CI.</div><br/></div></div></div></div></div></div></div></div><div id="42671172" class="c"><input type="checkbox" id="c-42671172" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42669893">parent</a><span>|</span><a href="#42670248">prev</a><span>|</span><a href="#42671278">next</a><span>|</span><label class="collapse" for="c-42671172">[-]</label><label class="expand" for="c-42671172">[1 more]</label></div><br/><div class="children"><div class="content">C&#x27;s already got static_assert; just missing constexpr.</div><br/></div></div></div></div><div id="42671278" class="c"><input type="checkbox" id="c-42671278" checked=""/><div class="controls bullet"><span class="by">matt3210</span><span>|</span><a href="#42669893">prev</a><span>|</span><a href="#42671933">next</a><span>|</span><label class="collapse" for="c-42671278">[-]</label><label class="expand" for="c-42671278">[1 more]</label></div><br/><div class="children"><div class="content">Woah I haven’t seen the name “digital mars” since the late 90s looking for compilers!</div><br/></div></div><div id="42671933" class="c"><input type="checkbox" id="c-42671933" checked=""/><div class="controls bullet"><span class="by">notorandit</span><span>|</span><a href="#42671278">prev</a><span>|</span><a href="#42670086">next</a><span>|</span><label class="collapse" for="c-42671933">[-]</label><label class="expand" for="c-42671933">[2 more]</label></div><br/><div class="children"><div class="content">I wish C had a jinja2-like preprocessor!</div><br/><div id="42672201" class="c"><input type="checkbox" id="c-42672201" checked=""/><div class="controls bullet"><span class="by">chikere232</span><span>|</span><a href="#42671933">parent</a><span>|</span><a href="#42670086">next</a><span>|</span><label class="collapse" for="c-42672201">[-]</label><label class="expand" for="c-42672201">[1 more]</label></div><br/><div class="children"><div class="content">You could use whatever preprocessor you like really, just add a make step that translates your template into c. I&#x27;ve seem some crazy person use M4 for example.<p>It&#x27;s usually a bad idea, but very feasible</div><br/></div></div></div></div><div id="42670086" class="c"><input type="checkbox" id="c-42670086" checked=""/><div class="controls bullet"><span class="by">ryukoposting</span><span>|</span><a href="#42671933">prev</a><span>|</span><a href="#42669747">next</a><span>|</span><label class="collapse" for="c-42670086">[-]</label><label class="expand" for="c-42670086">[5 more]</label></div><br/><div class="children"><div class="content">Yeah... no.<p>Constexpr function evaluation sounds like a great idea until you start trying to use it, and get surprised when seemingly-constexpr-safe functions <i>aren&#x27;t</i> constexpr. Or, you tweak one function and suddenly all your fancy compile-time unit tests explode.<p>Ok, so you get around that with good code hygiene and by limiting the complexity of your constexpr functions... in other words, do the exact things we already do with preprocessor macros.<p>Alternatively, you add a constexpr keyword to the lang, but now we have red functions and blue functions. Great.<p>In another language, there&#x27;d still be an argument for the type-safety that would precipitate from constexpr function eval, but this is C we&#x27;re talking about.<p>How about container_of? Could we please standardize that already? Why is this crucial and immensely useful macro a thing we all copy-paste from that one page on kernel.org?</div><br/><div id="42670924" class="c"><input type="checkbox" id="c-42670924" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42670086">parent</a><span>|</span><a href="#42670952">next</a><span>|</span><label class="collapse" for="c-42670924">[-]</label><label class="expand" for="c-42670924">[3 more]</label></div><br/><div class="children"><div class="content">Just like constant expressions, a function run at compile time needs to be <i>pure</i>, which means no globals, no system calls, no I&#x2F;O, no undefined behavior. Yes, that does constrain it somewhat, but D users have found it to be immensely useful anyway.<p>There&#x27;s really no comparison with preprocessor macros. All the preprocessor can do is trivial expressions with long values. Not even floating point.<p>&gt; you add a constexpr keyword to the lang, but now we have red functions and blue functions<p>My proposal (and D) does not require constexpr. The same function can be used at run or compile time. There is no need for that keyword. C++ made a mistake.</div><br/><div id="42671296" class="c"><input type="checkbox" id="c-42671296" checked=""/><div class="controls bullet"><span class="by">ryukoposting</span><span>|</span><a href="#42670086">root</a><span>|</span><a href="#42670924">parent</a><span>|</span><a href="#42670952">next</a><span>|</span><label class="collapse" for="c-42671296">[-]</label><label class="expand" for="c-42671296">[2 more]</label></div><br/><div class="children"><div class="content">&gt; D users have found it to be immensely useful anyway.<p>I think you&#x27;re focused on something that D programmers found helpful, rather than focusing squarely on the needs of C programmers. C and D are both good languages. Their use cases <i>can</i> overlap, but frequently don&#x27;t.<p>&gt;=70% of the code I write for work is C, as I&#x27;m an embedded firmware dev. C meets the very particular needs of bare-metal development, a use case that continues to be underserved by Rust, Zig, and other supposed successors to C. So, I&#x27;ll be approaching this with a strong bias towards that perspective.<p>To me, the argument about unit testing rings hollow because of all the other, far more complicated and runtime-subverting things that would <i>also</i> need to become standardized before it would be feasible to unit test C programs without help from the hideous hacks we use today, like CMock. So, all of that isn&#x27;t doing anything for me.<p>&gt; My proposal (and D) does not require constexpr. The same function can be used at run or compile time.<p>Like you, I dislike the constexpr keyword. But, particularly considering your own example of defining an enum value, I don&#x27;t see how the &quot;implicit const-evaluatable&quot; approach makes my life easier. Calling functions to define an enum&#x27;s value is cute, but I can&#x27;t tell you why I&#x27;d actually want to do that. You mention that the preprocessor can&#x27;t handle floats, but, well, neither can enums!<p>Adding a single printf (or, in my case, kprintf or LOG_DBG or whatever) would become liable to nuke some constant evaluation happening somewhere far up an obscure call chain. The basic reality of C is that you <i>will</i>, at one point or another, encounter a situation where your only debugging tool is print statements (or a single LED). That&#x27;s the cold reality of C&#x27;s paper-thin runtime.<p>So, I really dislike the idea of having a feature that&#x27;s liable to make your code go &quot;boom&quot; at compile time because you put a print statement in just the wrong spot. Or a write to a memory-mapped register. Or a hard jump into a blob sitting somewhere in memory. Or inline assembly. Or a call to a function that uses any of those things, even once. Even without the keyword, you end up with red functions and blue functions. It&#x27;s just harder to tell which ones are which.<p>Defining some const floats? Sure, that&#x27;s neat. If you could use this feature to define huge matrices of floats, that&#x27;d be pretty cool! There&#x27;s just a boatload of gotchas.</div><br/><div id="42671510" class="c"><input type="checkbox" id="c-42671510" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42670086">root</a><span>|</span><a href="#42671296">parent</a><span>|</span><a href="#42670952">next</a><span>|</span><label class="collapse" for="c-42671510">[-]</label><label class="expand" for="c-42671510">[1 more]</label></div><br/><div class="children"><div class="content">&gt; your own example of defining an enum value<p>That is hardly the only place that has a constant-expression in the grammar. (BTW, D enums can also be floats, and even string literals!) You could use CTFE to initialize const floating point globals. static_assert also takes a constant-expression.<p>&gt; There&#x27;s just a boatload of gotchas.<p>The D community has 17 years experience with it. It remains an indispensable feature.<p>As for embedding a printf, that has come up. Recall elsewhere I said that only the path through a function has to be pure for CTFE to work, not the whole function?<p><pre><code>    int sum(int a, int b) {
        int s = a + b;
        if (!__ctfe) printf(&quot;sum is %d\n&quot;, s);
        return s;
    }
</code></pre>
__ctfe is a keyword that says &quot;CTFE is executing this function&quot;.<p>&gt; If you could use this feature to define huge matrices of floats, that&#x27;d be pretty cool!<p>I use it to statically initialize complicated tables at compile time. Before CTFE, I wrote a separate executable that would emit source code with the array initializer. I like the new way mucho bettero.<p>If you prefer &quot;hideous hacks&quot; (your words!) I won&#x27;t take that away from you.</div><br/></div></div></div></div></div></div><div id="42670952" class="c"><input type="checkbox" id="c-42670952" checked=""/><div class="controls bullet"><span class="by">throw16180339</span><span>|</span><a href="#42670086">parent</a><span>|</span><a href="#42670924">prev</a><span>|</span><a href="#42669747">next</a><span>|</span><label class="collapse" for="c-42670952">[-]</label><label class="expand" for="c-42670952">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re using C++ 20, you can mark functions <i>consteval</i> to force constant evaluation.</div><br/></div></div></div></div><div id="42669747" class="c"><input type="checkbox" id="c-42669747" checked=""/><div class="controls bullet"><span class="by">acheong08</span><span>|</span><a href="#42670086">prev</a><span>|</span><a href="#42671650">next</a><span>|</span><label class="collapse" for="c-42669747">[-]</label><label class="expand" for="c-42669747">[21 more]</label></div><br/><div class="children"><div class="content">It really reads like the author just wants Zig.</div><br/><div id="42669784" class="c"><input type="checkbox" id="c-42669784" checked=""/><div class="controls bullet"><span class="by">robterrell</span><span>|</span><a href="#42669747">parent</a><span>|</span><a href="#42669778">next</a><span>|</span><label class="collapse" for="c-42669784">[-]</label><label class="expand" for="c-42669784">[2 more]</label></div><br/><div class="children"><div class="content">The author is the creator of D, so he&#x27;s probably fine with D. And D is something like 25 years old. Whereas Zig is just a toddler.</div><br/><div id="42671305" class="c"><input type="checkbox" id="c-42671305" checked=""/><div class="controls bullet"><span class="by">johnnyanmac</span><span>|</span><a href="#42669747">root</a><span>|</span><a href="#42669784">parent</a><span>|</span><a href="#42669778">next</a><span>|</span><label class="collapse" for="c-42671305">[-]</label><label class="expand" for="c-42671305">[1 more]</label></div><br/><div class="children"><div class="content">ahh, that explains the ImportC comparisons. Also didn&#x27;t realize that person is also a regular on HN as well.</div><br/></div></div></div></div><div id="42669778" class="c"><input type="checkbox" id="c-42669778" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42669747">parent</a><span>|</span><a href="#42669784">prev</a><span>|</span><a href="#42669770">next</a><span>|</span><label class="collapse" for="c-42669778">[-]</label><label class="expand" for="c-42669778">[17 more]</label></div><br/><div class="children"><div class="content">Zig copies features from D!</div><br/><div id="42669819" class="c"><input type="checkbox" id="c-42669819" checked=""/><div class="controls bullet"><span class="by">koolba</span><span>|</span><a href="#42669747">root</a><span>|</span><a href="#42669778">parent</a><span>|</span><a href="#42670205">next</a><span>|</span><label class="collapse" for="c-42669819">[-]</label><label class="expand" for="c-42669819">[9 more]</label></div><br/><div class="children"><div class="content">Imitation is the sincerest form of flattery.</div><br/><div id="42669828" class="c"><input type="checkbox" id="c-42669828" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42669747">root</a><span>|</span><a href="#42669819">parent</a><span>|</span><a href="#42671480">next</a><span>|</span><label class="collapse" for="c-42669828">[-]</label><label class="expand" for="c-42669828">[7 more]</label></div><br/><div class="children"><div class="content">Yup. D is the source for a number of recent features in other languages.<p>The reason I embarked on D is because C and C++ were too reluctant to move forward.</div><br/><div id="42671498" class="c"><input type="checkbox" id="c-42671498" checked=""/><div class="controls bullet"><span class="by">ksec</span><span>|</span><a href="#42669747">root</a><span>|</span><a href="#42669828">parent</a><span>|</span><a href="#42671496">next</a><span>|</span><label class="collapse" for="c-42671498">[-]</label><label class="expand" for="c-42671498">[1 more]</label></div><br/><div class="children"><div class="content">&gt;The reason I embarked on D is because C and C++ were too reluctant to move forward.<p>I just want to take this opportunity to say thank you. While D may not taken up from the rest of the world. It has surely lived on in C, C++ and many other languages. Still wish more people would use Das C.</div><br/></div></div><div id="42670346" class="c"><input type="checkbox" id="c-42670346" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#42669747">root</a><span>|</span><a href="#42669828">parent</a><span>|</span><a href="#42671496">prev</a><span>|</span><a href="#42671659">next</a><span>|</span><label class="collapse" for="c-42670346">[-]</label><label class="expand" for="c-42670346">[3 more]</label></div><br/><div class="children"><div class="content">Do you think you will keep moving forward for the next decade or will you merge when c&#x2F;cpp becomes similar enough to D ? Maybe your group still has tons of ideas that need their own space to grow.</div><br/><div id="42670600" class="c"><input type="checkbox" id="c-42670600" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42669747">root</a><span>|</span><a href="#42670346">parent</a><span>|</span><a href="#42671659">next</a><span>|</span><label class="collapse" for="c-42670600">[-]</label><label class="expand" for="c-42670600">[2 more]</label></div><br/><div class="children"><div class="content">The ideas for advancing D come thick and fast. C and C++ will never merge with D, because we have different philosophies of what makes for a great programming language.<p>For example, D will never have a preprocessor. Or over my dead body :-&#x2F;</div><br/><div id="42670697" class="c"><input type="checkbox" id="c-42670697" checked=""/><div class="controls bullet"><span class="by">koolba</span><span>|</span><a href="#42669747">root</a><span>|</span><a href="#42670600">parent</a><span>|</span><a href="#42671659">next</a><span>|</span><label class="collapse" for="c-42670697">[-]</label><label class="expand" for="c-42670697">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For example, D will never have a preprocessor. Or over my dead body :-&#x2F;<p>Indeed. Compile time evaluation combined with a preprocessor would make for some serious head scratching when it comes to trusting trust.</div><br/></div></div></div></div></div></div><div id="42671659" class="c"><input type="checkbox" id="c-42671659" checked=""/><div class="controls bullet"><span class="by">WhereIsTheTruth</span><span>|</span><a href="#42669747">root</a><span>|</span><a href="#42669828">parent</a><span>|</span><a href="#42670346">prev</a><span>|</span><a href="#42671480">next</a><span>|</span><label class="collapse" for="c-42671659">[-]</label><label class="expand" for="c-42671659">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious, is there any features, from any language, that you wish you had implemented, or want to copy, in D?</div><br/></div></div></div></div><div id="42671480" class="c"><input type="checkbox" id="c-42671480" checked=""/><div class="controls bullet"><span class="by">ksec</span><span>|</span><a href="#42669747">root</a><span>|</span><a href="#42669819">parent</a><span>|</span><a href="#42669828">prev</a><span>|</span><a href="#42670205">next</a><span>|</span><label class="collapse" for="c-42671480">[-]</label><label class="expand" for="c-42671480">[1 more]</label></div><br/><div class="children"><div class="content">Identity theft is not a joke, millions of families suffer every year!<p>Michael!</div><br/></div></div></div></div><div id="42670205" class="c"><input type="checkbox" id="c-42670205" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#42669747">root</a><span>|</span><a href="#42669778">parent</a><span>|</span><a href="#42669819">prev</a><span>|</span><a href="#42669770">next</a><span>|</span><label class="collapse" for="c-42670205">[-]</label><label class="expand" for="c-42670205">[7 more]</label></div><br/><div class="children"><div class="content">more importantly, though, zig deliberately doesnt implement a whole TON of things that D does.<p>sometimes parsimony is called for.  zig is basically c--+ where the + is the constexpr stuff.</div><br/><div id="42670215" class="c"><input type="checkbox" id="c-42670215" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42669747">root</a><span>|</span><a href="#42670205">parent</a><span>|</span><a href="#42671678">next</a><span>|</span><label class="collapse" for="c-42670215">[-]</label><label class="expand" for="c-42670215">[5 more]</label></div><br/><div class="children"><div class="content">It keeps adding D features anyway, like constexpr.</div><br/><div id="42670223" class="c"><input type="checkbox" id="c-42670223" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#42669747">root</a><span>|</span><a href="#42670215">parent</a><span>|</span><a href="#42671678">next</a><span>|</span><label class="collapse" for="c-42670223">[-]</label><label class="expand" for="c-42670223">[4 more]</label></div><br/><div class="children"><div class="content">the constexpr stuff has been around since the beginning[0].  concretely, what other thing from D do you claim zig has added since?<p>[0] minimally 2019, 3 years in:<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;Gv2I7qTux7g?si=p0kVhtB56GvVLLNr" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;Gv2I7qTux7g?si=p0kVhtB56GvVLLNr</a></div><br/><div id="42671095" class="c"><input type="checkbox" id="c-42671095" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42669747">root</a><span>|</span><a href="#42670223">parent</a><span>|</span><a href="#42671678">next</a><span>|</span><label class="collapse" for="c-42671095">[-]</label><label class="expand" for="c-42671095">[3 more]</label></div><br/><div class="children"><div class="content">D had compile time execution of functions in 2007.<p>Order-independent top level declarations.<p>Underscores embedded in integer literals. (I stole this idea from Ada, which had been forgotten. Soon after D popularized it, it became standard in other languages.)<p>Continue or break to labeled loop.<p>Fixed sizes for ints, longs, etc.<p>Of course, I don&#x27;t know if there&#x27;s a straight line here, and Zig is welcome to use any features from D that they like. But it&#x27;s just interesting that things innovated in D pop up in subsequent designs.</div><br/><div id="42671310" class="c"><input type="checkbox" id="c-42671310" checked=""/><div class="controls bullet"><span class="by">UncleEntity</span><span>|</span><a href="#42669747">root</a><span>|</span><a href="#42671095">parent</a><span>|</span><a href="#42671678">next</a><span>|</span><label class="collapse" for="c-42671310">[-]</label><label class="expand" for="c-42671310">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; Continue or break to labeled loop.<p>Hasn&#x27;t Java had that since the beginning?<p><i>rummaging around in my grammar folder...</i><p>BreakStatement    ::= &quot;break&quot; [ IDENTIFIER ] &#x27;;&#x27;<p>ContinueStatement ::= &quot;continue&quot; [ IDENTIFIER ] &#x27;;&#x27;</div><br/><div id="42671442" class="c"><input type="checkbox" id="c-42671442" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42669747">root</a><span>|</span><a href="#42671310">parent</a><span>|</span><a href="#42671678">next</a><span>|</span><label class="collapse" for="c-42671442">[-]</label><label class="expand" for="c-42671442">[1 more]</label></div><br/><div class="children"><div class="content">And so it does. I had forgotten. Thanks for the reminder!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42671678" class="c"><input type="checkbox" id="c-42671678" checked=""/><div class="controls bullet"><span class="by">WhereIsTheTruth</span><span>|</span><a href="#42669747">root</a><span>|</span><a href="#42670205">parent</a><span>|</span><a href="#42670215">prev</a><span>|</span><a href="#42669770">next</a><span>|</span><label class="collapse" for="c-42671678">[-]</label><label class="expand" for="c-42671678">[1 more]</label></div><br/><div class="children"><div class="content">Parsimony? more like thankful for learning from other language experiments and research work<p>Zig is young, and far from 1.0, and many long promised features still not implemented</div><br/></div></div></div></div></div></div><div id="42669770" class="c"><input type="checkbox" id="c-42669770" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#42669747">parent</a><span>|</span><a href="#42669778">prev</a><span>|</span><a href="#42671650">next</a><span>|</span><label class="collapse" for="c-42669770">[-]</label><label class="expand" for="c-42669770">[1 more]</label></div><br/><div class="children"><div class="content">or maybe even D</div><br/></div></div></div></div><div id="42671650" class="c"><input type="checkbox" id="c-42671650" checked=""/><div class="controls bullet"><span class="by">WhereIsTheTruth</span><span>|</span><a href="#42669747">prev</a><span>|</span><a href="#42670320">next</a><span>|</span><label class="collapse" for="c-42671650">[-]</label><label class="expand" for="c-42671650">[1 more]</label></div><br/><div class="children"><div class="content">Another obvious things C should do:<p>- better enums (with tagged union)<p>- compile time type introspection<p>D does the latter (very well btw), but completely missed the mark with enums</div><br/></div></div><div id="42670320" class="c"><input type="checkbox" id="c-42670320" checked=""/><div class="controls bullet"><span class="by">foul</span><span>|</span><a href="#42671650">prev</a><span>|</span><a href="#42671141">next</a><span>|</span><label class="collapse" for="c-42670320">[-]</label><label class="expand" for="c-42670320">[2 more]</label></div><br/><div class="children"><div class="content">Not again, not another D thread noooooooooooooooooo (i&#x27;m joking)</div><br/><div id="42670764" class="c"><input type="checkbox" id="c-42670764" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42670320">parent</a><span>|</span><a href="#42671141">next</a><span>|</span><label class="collapse" for="c-42670764">[-]</label><label class="expand" for="c-42670764">[1 more]</label></div><br/><div class="children"><div class="content">All your base belong to D!</div><br/></div></div></div></div><div id="42671141" class="c"><input type="checkbox" id="c-42671141" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#42670320">prev</a><span>|</span><label class="collapse" for="c-42671141">[-]</label><label class="expand" for="c-42671141">[20 more]</label></div><br/><div class="children"><div class="content">[stub for offtopicness]</div><br/><div id="42669795" class="c"><input type="checkbox" id="c-42669795" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42671141">parent</a><span>|</span><a href="#42669727">next</a><span>|</span><label class="collapse" for="c-42669795">[-]</label><label class="expand" for="c-42669795">[6 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t know X put articles behind a paywall? I haven&#x27;t tried putting articles there before.<p>Anyhow, here&#x27;s the same article:<p><a href="https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;Cobvious.html" rel="nofollow">https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;Cobvious.html</a><p>Fun fact: X&#x27;s article formatter recognizes D code!</div><br/><div id="42670811" class="c"><input type="checkbox" id="c-42670811" checked=""/><div class="controls bullet"><span class="by">sixthDot</span><span>|</span><a href="#42671141">root</a><span>|</span><a href="#42669795">parent</a><span>|</span><a href="#42670154">next</a><span>|</span><label class="collapse" for="c-42670811">[-]</label><label class="expand" for="c-42670811">[1 more]</label></div><br/><div class="children"><div class="content">Haven&#x27;t you noticed that the homepage does not include the X widget anymore ? It&#x27;s been removed [1] exactly because of that, i.e the content is not public anymore.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;dlang&#x2F;dlang.org&#x2F;pull&#x2F;3714">https:&#x2F;&#x2F;github.com&#x2F;dlang&#x2F;dlang.org&#x2F;pull&#x2F;3714</a></div><br/></div></div><div id="42670154" class="c"><input type="checkbox" id="c-42670154" checked=""/><div class="controls bullet"><span class="by">wging</span><span>|</span><a href="#42671141">root</a><span>|</span><a href="#42669795">parent</a><span>|</span><a href="#42670811">prev</a><span>|</span><a href="#42671138">next</a><span>|</span><label class="collapse" for="c-42670154">[-]</label><label class="expand" for="c-42670154">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what you are seeing, but perhaps it&#x27;s just a login wall. I was able to read it; I&#x27;m logged in but have never paid for Twitter or X. X does tend to hide certain things (such as replies and replied-to tweets) if you&#x27;re not logged in.</div><br/><div id="42670761" class="c"><input type="checkbox" id="c-42670761" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42671141">root</a><span>|</span><a href="#42670154">parent</a><span>|</span><a href="#42670515">next</a><span>|</span><label class="collapse" for="c-42670761">[-]</label><label class="expand" for="c-42670761">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m already logged in, which I infer is why I didn&#x27;t see a login wall. Anyhow, I also posted an alternate link.</div><br/></div></div><div id="42670515" class="c"><input type="checkbox" id="c-42670515" checked=""/><div class="controls bullet"><span class="by">kurisufag</span><span>|</span><a href="#42671141">root</a><span>|</span><a href="#42670154">parent</a><span>|</span><a href="#42670761">prev</a><span>|</span><a href="#42671138">next</a><span>|</span><label class="collapse" for="c-42670515">[-]</label><label class="expand" for="c-42670515">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s not visible to nitter, which is annoying.</div><br/></div></div></div></div><div id="42671138" class="c"><input type="checkbox" id="c-42671138" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#42671141">root</a><span>|</span><a href="#42669795">parent</a><span>|</span><a href="#42670154">prev</a><span>|</span><a href="#42669727">next</a><span>|</span><label class="collapse" for="c-42671138">[-]</label><label class="expand" for="c-42671138">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;d always rather go with the more specific site anyhow so I&#x27;ve changed the URL to that from <a href="https:&#x2F;&#x2F;twitter.com&#x2F;WalterBright&#x2F;status&#x2F;1878209651306803406" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;WalterBright&#x2F;status&#x2F;1878209651306803406</a>. Thanks!</div><br/></div></div></div></div><div id="42669727" class="c"><input type="checkbox" id="c-42669727" checked=""/><div class="controls bullet"><span class="by">ranger_danger</span><span>|</span><a href="#42671141">parent</a><span>|</span><a href="#42669795">prev</a><span>|</span><a href="#42670437">next</a><span>|</span><label class="collapse" for="c-42669727">[-]</label><label class="expand" for="c-42669727">[8 more]</label></div><br/><div class="children"><div class="content">login-walled</div><br/><div id="42670269" class="c"><input type="checkbox" id="c-42670269" checked=""/><div class="controls bullet"><span class="by">ciupicri</span><span>|</span><a href="#42671141">root</a><span>|</span><a href="#42669727">parent</a><span>|</span><a href="#42669997">next</a><span>|</span><label class="collapse" for="c-42670269">[-]</label><label class="expand" for="c-42670269">[1 more]</label></div><br/><div class="children"><div class="content">Try <a href="https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;Cobvious.html" rel="nofollow">https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;Cobvious.html</a></div><br/></div></div><div id="42669997" class="c"><input type="checkbox" id="c-42669997" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42671141">root</a><span>|</span><a href="#42669727">parent</a><span>|</span><a href="#42670269">prev</a><span>|</span><a href="#42669740">next</a><span>|</span><label class="collapse" for="c-42669997">[-]</label><label class="expand" for="c-42669997">[1 more]</label></div><br/><div class="children"><div class="content">Curious. I don&#x27;t have an account, and I can read it.</div><br/></div></div><div id="42669740" class="c"><input type="checkbox" id="c-42669740" checked=""/><div class="controls bullet"><span class="by">acheong08</span><span>|</span><a href="#42671141">root</a><span>|</span><a href="#42669727">parent</a><span>|</span><a href="#42669997">prev</a><span>|</span><a href="#42669790">next</a><span>|</span><label class="collapse" for="c-42669740">[-]</label><label class="expand" for="c-42669740">[1 more]</label></div><br/><div class="children"><div class="content">Looks like a new feature. Articles don&#x27;t render render on xcancel</div><br/></div></div><div id="42669789" class="c"><input type="checkbox" id="c-42669789" checked=""/><div class="controls bullet"><span class="by">smitty1e</span><span>|</span><a href="#42671141">root</a><span>|</span><a href="#42669727">parent</a><span>|</span><a href="#42669790">prev</a><span>|</span><a href="#42670437">next</a><span>|</span><label class="collapse" for="c-42669789">[-]</label><label class="expand" for="c-42669789">[3 more]</label></div><br/><div class="children"><div class="content">Have a go at this =&gt; <a href="https:&#x2F;&#x2F;t.co&#x2F;KXRE5XvuoP" rel="nofollow">https:&#x2F;&#x2F;t.co&#x2F;KXRE5XvuoP</a><p>I used the <a href="https:&#x2F;&#x2F;publish.twitter.com" rel="nofollow">https:&#x2F;&#x2F;publish.twitter.com</a> thing against the Xeet, then lifted the first HREF out of the embed goo.</div><br/><div id="42669890" class="c"><input type="checkbox" id="c-42669890" checked=""/><div class="controls bullet"><span class="by">nom</span><span>|</span><a href="#42671141">root</a><span>|</span><a href="#42669789">parent</a><span>|</span><a href="#42670437">next</a><span>|</span><label class="collapse" for="c-42669890">[-]</label><label class="expand" for="c-42669890">[2 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t work, the t.co link gives me:<p>&gt; This page is not supported.
&gt; Please visit the author’s profile on the latest version of X to view this content.</div><br/><div id="42669958" class="c"><input type="checkbox" id="c-42669958" checked=""/><div class="controls bullet"><span class="by">smitty1e</span><span>|</span><a href="#42671141">root</a><span>|</span><a href="#42669890">parent</a><span>|</span><a href="#42670437">next</a><span>|</span><label class="collapse" for="c-42669958">[-]</label><label class="expand" for="c-42669958">[1 more]</label></div><br/><div class="children"><div class="content">Worth a try.</div><br/></div></div></div></div></div></div></div></div><div id="42670437" class="c"><input type="checkbox" id="c-42670437" checked=""/><div class="controls bullet"><span class="by">honestSysAdmin</span><span>|</span><a href="#42671141">parent</a><span>|</span><a href="#42669727">prev</a><span>|</span><a href="#42669771">next</a><span>|</span><label class="collapse" for="c-42670437">[-]</label><label class="expand" for="c-42670437">[2 more]</label></div><br/><div class="children"><div class="content">Perhaps I could load the Javascript and also &quot;login to X&quot;, but I&#x27;ll instead forego reading this and pay attention to what others are writing about C.</div><br/><div id="42670943" class="c"><input type="checkbox" id="c-42670943" checked=""/><div class="controls bullet"><span class="by">msm_</span><span>|</span><a href="#42671141">root</a><span>|</span><a href="#42670437">parent</a><span>|</span><a href="#42669771">next</a><span>|</span><label class="collapse" for="c-42670943">[-]</label><label class="expand" for="c-42670943">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also hosted here: <a href="https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;Cobvious.html" rel="nofollow">https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;Cobvious.html</a></div><br/></div></div></div></div><div id="42669771" class="c"><input type="checkbox" id="c-42669771" checked=""/><div class="controls bullet"><span class="by">meibo</span><span>|</span><a href="#42671141">parent</a><span>|</span><a href="#42670437">prev</a><span>|</span><label class="collapse" for="c-42669771">[-]</label><label class="expand" for="c-42669771">[3 more]</label></div><br/><div class="children"><div class="content">Sorry to be off-topic, but I&#x27;m disappointed in this being on X, it even comes with an ad built-in. We should be doing better. Spinning up a single-site blog is easier than ever for technically-minded folks - the internet needs to become independent again.</div><br/><div id="42670899" class="c"><input type="checkbox" id="c-42670899" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42671141">root</a><span>|</span><a href="#42669771">parent</a><span>|</span><a href="#42670941">next</a><span>|</span><label class="collapse" for="c-42670899">[-]</label><label class="expand" for="c-42670899">[1 more]</label></div><br/><div class="children"><div class="content">I posted it originally on digitalmars.com, and nobody noticed it. I posted it today on X, and bang! I didn&#x27;t even submit it to HackerNews.<p>I&#x27;ll be using X more for articles in the future, but will also put them on the dlang.org and digitalmars.com sites.</div><br/></div></div><div id="42670941" class="c"><input type="checkbox" id="c-42670941" checked=""/><div class="controls bullet"><span class="by">msm_</span><span>|</span><a href="#42671141">root</a><span>|</span><a href="#42669771">parent</a><span>|</span><a href="#42670899">prev</a><span>|</span><label class="collapse" for="c-42670941">[-]</label><label class="expand" for="c-42670941">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also hosted here: <a href="https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;Cobvious.html" rel="nofollow">https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;Cobvious.html</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>