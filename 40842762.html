<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719910855186" as="style"/><link rel="stylesheet" href="styles.css?v=1719910855186"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://ofcr.se/jujutsu-merge-workflow">A better merge workflow with Jujutsu</a> <span class="domain">(<a href="https://ofcr.se">ofcr.se</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>66 comments</span></div><br/><div><div id="40854779" class="c"><input type="checkbox" id="c-40854779" checked=""/><div class="controls bullet"><span class="by">dolmen</span><span>|</span><a href="#40852387">next</a><span>|</span><label class="collapse" for="c-40854779">[-]</label><label class="expand" for="c-40854779">[1 more]</label></div><br/><div class="children"><div class="content">I have lot of old local Git branches. Most were pushed on the central server. The central server also have some old branches. Some local branches have been rebased locally. Some have been rebased on the server. Some have been merged on the server (with rebase or not).<p>I need to clean-up both my local clone and the central server from the branches which contain changes that have been fully merged<p>Can Jujutsu help with that?</div><br/></div></div><div id="40852387" class="c"><input type="checkbox" id="c-40852387" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#40854779">prev</a><span>|</span><a href="#40854191">next</a><span>|</span><label class="collapse" for="c-40852387">[-]</label><label class="expand" for="c-40852387">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>GG, a GUI for Jujutsu</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39713896">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39713896</a> - March 2024 (2 comments)<p><i>jj init – getting serious about replacing Git with Jujutsu</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39232456">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39232456</a> - Feb 2024 (110 comments)<p><i>Jujutsu: A Git-compatible DVCS that is both simple and powerful</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36952796">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36952796</a> - Aug 2023 (261 comments)<p><i>Jujutsu: A Git-compatible DVCS that is both simple and powerful</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36371138">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36371138</a> - June 2023 (1 comment)<p><i>Jujutsu – A Git-compatible DVCS that is both simple and powerful</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30398662">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30398662</a> - Feb 2022 (228 comments)</div><br/></div></div><div id="40854191" class="c"><input type="checkbox" id="c-40854191" checked=""/><div class="controls bullet"><span class="by">xlii</span><span>|</span><a href="#40852387">prev</a><span>|</span><a href="#40844494">next</a><span>|</span><label class="collapse" for="c-40854191">[-]</label><label class="expand" for="c-40854191">[2 more]</label></div><br/><div class="children"><div class="content">I really tried to like jj but I couldn’t make it work for my workflow:<p>There are files that are committed to repository that I need to edit (e.g. .envrc files, which cannot be overridden). There is no way I can ignore those in Jujutsu.<p>In plain git I can do sparse checkout using negative paths and it works. jj doesn’t support it, and using positive path doesn’t work as I never know if new files are there.<p>Every push was a dance around removing my changes. I’m checking if there’s progress from time to time but there’s no so far.<p>But just yesterday I decided to check git branchless as I’m exploring stacked PR workflow and I can say it’s intriguing and even if more rough around the edges than  jj I haven’t yet found any showstoppers.</div><br/><div id="40854762" class="c"><input type="checkbox" id="c-40854762" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#40854191">parent</a><span>|</span><a href="#40844494">next</a><span>|</span><label class="collapse" for="c-40854762">[-]</label><label class="expand" for="c-40854762">[1 more]</label></div><br/><div class="children"><div class="content">can&#x27;t you just add them to gitignore? if you want it to be local only, there&#x27;s also .git&#x2F;info&#x2F;exclude or for all your repos with ~&#x2F;.config&#x2F;git&#x2F;ignore</div><br/></div></div></div></div><div id="40844494" class="c"><input type="checkbox" id="c-40844494" checked=""/><div class="controls bullet"><span class="by">aranw</span><span>|</span><a href="#40854191">prev</a><span>|</span><a href="#40843406">next</a><span>|</span><label class="collapse" for="c-40844494">[-]</label><label class="expand" for="c-40844494">[4 more]</label></div><br/><div class="children"><div class="content">I really like the idea of Jujutsu and was really keen to try it out but when I looked at it several months back I found it really hard to get going with it and ended up just ditching it. This article looks to be a explanation to some of the concepts of `jj` and how to use it in a little more depth than some of the other tutorials I have seen out there. Definitely keen to give it another try at some point</div><br/><div id="40846448" class="c"><input type="checkbox" id="c-40846448" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#40844494">parent</a><span>|</span><a href="#40844730">next</a><span>|</span><label class="collapse" for="c-40846448">[-]</label><label class="expand" for="c-40846448">[2 more]</label></div><br/><div class="children"><div class="content">On the flip side, I expected it to be a bigger migration than it was. But I was using it effectively as a complete git replacement the very first day.<p>I still had a few things I didn’t know how to do optimally, but it was close enough to be productive. Within a week I’d closed basically all of the gaps.<p>It’s been three or so months and I’m never going back. It’s been so transformative I can barely remember all the innumerable frustrations and papercuts I used to put up with daily. Rebase conflicts. Juggling the stash. Ugh.<p>I say this as someone who considered themselves extremely proficient with git. I mean, I wrote a compatible Ruby implementation of it over a decade and ago.<p>If it gains momentum, jj has a better chance than anything I’ve seen at finally dethroning git.</div><br/><div id="40854758" class="c"><input type="checkbox" id="c-40854758" checked=""/><div class="controls bullet"><span class="by">rkangel</span><span>|</span><a href="#40844494">root</a><span>|</span><a href="#40846448">parent</a><span>|</span><a href="#40844730">next</a><span>|</span><label class="collapse" for="c-40854758">[-]</label><label class="expand" for="c-40854758">[1 more]</label></div><br/><div class="children"><div class="content">&quot;New VCS, but Git is a first-class backend&quot; is an amazingly smart decision. It&#x27;s the only chance you actually have of supplanting git. It&#x27;s a new VCS with enough workflow benefit to be worth making a user switch (in contrast to most git alternate command lines) but provides an easy migration path where you don&#x27;t have to make a &quot;whole repository&quot; decision. It&#x27;s an individual engineer decision, that still allows using your existing servers (Github&#x2F;lab).</div><br/></div></div></div></div><div id="40844730" class="c"><input type="checkbox" id="c-40844730" checked=""/><div class="controls bullet"><span class="by">christianPerdu</span><span>|</span><a href="#40844494">parent</a><span>|</span><a href="#40846448">prev</a><span>|</span><a href="#40843406">next</a><span>|</span><label class="collapse" for="c-40844730">[-]</label><label class="expand" for="c-40844730">[1 more]</label></div><br/><div class="children"><div class="content">Same here, exact same here !</div><br/></div></div></div></div><div id="40843406" class="c"><input type="checkbox" id="c-40843406" checked=""/><div class="controls bullet"><span class="by">chasinglogic</span><span>|</span><a href="#40844494">prev</a><span>|</span><a href="#40854207">next</a><span>|</span><label class="collapse" for="c-40843406">[-]</label><label class="expand" for="c-40843406">[18 more]</label></div><br/><div class="children"><div class="content">&gt; Using Jujutsu, “amending a commit” also produces a new commit object, as in Git, but the new commit has the same change ID as the original.<p>This is confusing to me, though to be fair I&#x27;m a &quot;git expert&quot; by trade. If you&#x27;re amending a commit surely the &quot;change&quot; has changed so the change ID should also change? If the &quot;change&quot; isn&#x27;t tracking the actual changes then what could it be tracking?<p>Overall I think this is just more confusing than using git but I think it&#x27;s cool that people are building alternative clients. That&#x27;s definitely the way to go if you want adoption.<p>Making history manipulation easier seems like a bit of a recipe for disaster given my experience training people. That old XKCD about git comes to mind and honestly that&#x27;s where most people stay, if you bother to learn it then things like Jujitsu are probably harder to use for you. If you aren&#x27;t interested in learning git to that level then I doubt you want &#x2F; need something like Jujitsu.<p>For those curious the &quot;multiple branches&quot; at a time thing they&#x27;re selling can be done with git, IMO easily, using worktrees: <a href="https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git-worktree" rel="nofollow">https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git-worktree</a></div><br/><div id="40844077" class="c"><input type="checkbox" id="c-40844077" checked=""/><div class="controls bullet"><span class="by">KingMob</span><span>|</span><a href="#40843406">parent</a><span>|</span><a href="#40844107">next</a><span>|</span><label class="collapse" for="c-40844077">[-]</label><label class="expand" for="c-40844077">[4 more]</label></div><br/><div class="children"><div class="content">&gt; If you&#x27;re amending a commit surely the &quot;change&quot; has changed so the change ID should also change? If the &quot;change&quot; isn&#x27;t tracking the actual changes then what could it be tracking?<p>The author is using newer terminology around &quot;changes&quot;, but I prefer the older &quot;revisions&quot;, as being less overloaded. But yes, the revision&#x2F;change ID remains the same even if the commits underneath changes. `jj obslog` will show you the history of commits underlying a revision. This stability is what we want when rebasing, and git doesn&#x27;t provide it.<p>&gt; Making history manipulation easier seems like a bit of a recipe for disaster ...<p>I used to think this too, but it was really due to git and its CLI. Under jj, history manipulation is easy, consistent, and easily reversible with `jj undo`. Because it&#x27;s safer and easier, I routinely do way more rebasing, and stacked PRs are much less painful to incorporate feedback on. Basically, it makes git&#x27;s more advanced operations feel like everyday tools.<p>(Of course, jj doesn&#x27;t fix the problem of rewriting history that&#x27;s already been shared with other people, but even there, its notion of immutable commits tries to stop you from breaking other people&#x27;s histories.)<p>&gt; the &quot;multiple branches&quot; at a time thing they&#x27;re selling can be done with git, IMO easily, using worktrees<p>Worktrees aren&#x27;t quite the same thing the author is describing. Worktrees allow you to check out multiple branches at the same time to different directories, but they&#x27;re still sort of separate.<p>The author is making the working revision a merge revision where every parent is a branch they want to work on. This allows them to see what the code will do when those branches are merged. They can also add revisions to all branches simultaneously by working on the merge rev, and using `jj squash` to choose which parent branch to push work to on the fly. When done for the day, `jj abandon` the merge commit. AFAICT, it&#x27;s both lighter and more flexible than worktrees.</div><br/><div id="40845968" class="c"><input type="checkbox" id="c-40845968" checked=""/><div class="controls bullet"><span class="by">epage</span><span>|</span><a href="#40843406">root</a><span>|</span><a href="#40844077">parent</a><span>|</span><a href="#40844107">next</a><span>|</span><label class="collapse" for="c-40845968">[-]</label><label class="expand" for="c-40845968">[3 more]</label></div><br/><div class="children"><div class="content">imo revision is worse.<p>I feel like the best terms are patch id and patch revision id.</div><br/><div id="40848144" class="c"><input type="checkbox" id="c-40848144" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#40843406">root</a><span>|</span><a href="#40845968">parent</a><span>|</span><a href="#40844107">next</a><span>|</span><label class="collapse" for="c-40848144">[-]</label><label class="expand" for="c-40848144">[2 more]</label></div><br/><div class="children"><div class="content">I am sad I read this, because patch is perfect, but I doubt they will change the language again.</div><br/><div id="40854774" class="c"><input type="checkbox" id="c-40854774" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#40843406">root</a><span>|</span><a href="#40848144">parent</a><span>|</span><a href="#40844107">next</a><span>|</span><label class="collapse" for="c-40854774">[-]</label><label class="expand" for="c-40854774">[1 more]</label></div><br/><div class="children"><div class="content">patch sounds too specific... like an actual patch file tied to the actual contents of the patch.<p>change is probably the right word, you want to change something, the exact operations of the change (multiple revisions of different patches) can evolve over time.</div><br/></div></div></div></div></div></div></div></div><div id="40844107" class="c"><input type="checkbox" id="c-40844107" checked=""/><div class="controls bullet"><span class="by">kstenerud</span><span>|</span><a href="#40843406">parent</a><span>|</span><a href="#40844077">prev</a><span>|</span><a href="#40843849">next</a><span>|</span><label class="collapse" for="c-40844107">[-]</label><label class="expand" for="c-40844107">[1 more]</label></div><br/><div class="children"><div class="content">Think of the change ID as a &quot;symbolic name&quot;, as opposed to the commit ID which identifies a particular snapshot.<p>As you amend a commit, it creates a new commit ID each time. Only the commit ID of the most recent amendment is in your final graph. All the old ones are orphaned for garbage collection.<p>The change ID never changes as you make amendments (because you&#x27;re still working on the same change), and this change ID will always be in the graph. So you can refer to the change ID (which doesn&#x27;t change) instead of the commit ID (which changes with every amendment).<p>Another way to think of it would be akin to filenames vs inodes in a filesystem (it&#x27;s not 100% the same, but the concept should help you visualize). If you delete a file and create another one with the same name, its filename will be the same, but its inode number will be different because it&#x27;s technically a different file. The old inode gets marked deleted so that it can be reaped somehow. If you make a symbolic link to the file, you&#x27;ll always get the intended one (because a symbolic link refers to a path). If you make a hard link to the file, you&#x27;ll get an outdated file after something replaces it (because a hard link refers to an inode).</div><br/></div></div><div id="40843849" class="c"><input type="checkbox" id="c-40843849" checked=""/><div class="controls bullet"><span class="by">FranGro78</span><span>|</span><a href="#40843406">parent</a><span>|</span><a href="#40844107">prev</a><span>|</span><a href="#40848171">next</a><span>|</span><label class="collapse" for="c-40843849">[-]</label><label class="expand" for="c-40843849">[3 more]</label></div><br/><div class="children"><div class="content">I’ve also run into problems with tools that aren’t worktree aware so often that I’ve stopped using it.<p>I’ve been using jujutsu for about 6 months now, and the only time I’ve reached back for git was when I had to rebase and amend someone else’s branch to get it merged (when they weren’t available to do so themselves of course).<p>Switching between changes in jujutsu has been a pleasant experience for me thus far, although I’m not as good with it as I was with stacked-git to keep local only changes (things I’m hacking to match my workflow &#x2F; local setup) out of change sets.<p>The way it displays diffs is also still something I am getting used to, and have made plenty of mistakes when pulling in changes from trunk. That’s probably more of a case of “old dog new tricks” than jujutsu.</div><br/><div id="40844125" class="c"><input type="checkbox" id="c-40844125" checked=""/><div class="controls bullet"><span class="by">KingMob</span><span>|</span><a href="#40843406">root</a><span>|</span><a href="#40843849">parent</a><span>|</span><a href="#40848171">next</a><span>|</span><label class="collapse" for="c-40844125">[-]</label><label class="expand" for="c-40844125">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, after the first month of jj, I abandoned git forever, because it&#x27;s already so much better. There are <i>some</i> hiccups, though.<p>I switched over to colocation for all repos, because too many things expect git directories to be where they expect.<p>I think the revset language is cool and powerful, but if I&#x27;m honest, it&#x27;s tempting me to spend too much time trying to master, when 99% of the time all I need is, &quot;show me the nearby ancestors and descendants within k revisions&quot;.<p>I think the diffs need work. Or I need to get comfy with 3-way diffs. It&#x27;s unfamiliar, and an obstacle to fixing conflicts. Luckily I get maybe 1&#x2F;10th the conflicts I used to under git.</div><br/><div id="40844663" class="c"><input type="checkbox" id="c-40844663" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#40843406">root</a><span>|</span><a href="#40844125">parent</a><span>|</span><a href="#40848171">next</a><span>|</span><label class="collapse" for="c-40844663">[-]</label><label class="expand" for="c-40844663">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think the revset language is cool and powerful, but if I&#x27;m honest, it&#x27;s tempting me to spend too much time trying to master, when 99% of the time all I need is, &quot;show me the nearby ancestors and descendants within k revisions&quot;.<p>I just spend enough time to write a new function for what I want to do, and then just know the basics for regular day to day stuff. I feel like that gets me really far.</div><br/></div></div></div></div></div></div><div id="40848171" class="c"><input type="checkbox" id="c-40848171" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#40843406">parent</a><span>|</span><a href="#40843849">prev</a><span>|</span><a href="#40846479">next</a><span>|</span><label class="collapse" for="c-40848171">[-]</label><label class="expand" for="c-40848171">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  …can be done with git, IMO easily, using worktrees
</code></pre>
Like many things in git, the capability exists, but I would not call worktrees easy. The few times I have tried to play with worktrees resulted in enough friction that it felt safer to use a clone in a separate directory.</div><br/></div></div><div id="40846479" class="c"><input type="checkbox" id="c-40846479" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#40843406">parent</a><span>|</span><a href="#40848171">prev</a><span>|</span><a href="#40844702">next</a><span>|</span><label class="collapse" for="c-40846479">[-]</label><label class="expand" for="c-40846479">[1 more]</label></div><br/><div class="children"><div class="content">There’s still a git-compatible commit ID which changes along with the contents. There’s also an immutable revision&#x2F;change identifier that persists even as you continue working on it.<p>This works <i>extremely</i> well in practice and makes rebase-heavy workflows practical even when collaborating with others.</div><br/></div></div><div id="40844702" class="c"><input type="checkbox" id="c-40844702" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#40843406">parent</a><span>|</span><a href="#40846479">prev</a><span>|</span><a href="#40846078">next</a><span>|</span><label class="collapse" for="c-40844702">[-]</label><label class="expand" for="c-40844702">[4 more]</label></div><br/><div class="children"><div class="content">Others have explained the change IDs already in detail, but I want to try to give a short and sweet explanation: changes in Jujutsu are a mutable, high level abstraction built on gits immutable commits. Change IDs are stable across mutations.</div><br/><div id="40844925" class="c"><input type="checkbox" id="c-40844925" checked=""/><div class="controls bullet"><span class="by">roland35</span><span>|</span><a href="#40843406">root</a><span>|</span><a href="#40844702">parent</a><span>|</span><a href="#40846078">next</a><span>|</span><label class="collapse" for="c-40844925">[-]</label><label class="expand" for="c-40844925">[3 more]</label></div><br/><div class="children"><div class="content">Sounds like how Mercurial handles commits!</div><br/><div id="40845180" class="c"><input type="checkbox" id="c-40845180" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#40843406">root</a><span>|</span><a href="#40844925">parent</a><span>|</span><a href="#40845140">next</a><span>|</span><label class="collapse" for="c-40845180">[-]</label><label class="expand" for="c-40845180">[1 more]</label></div><br/><div class="children"><div class="content">The people who work on Jujutsu explicitly draw a lot of inspiration from Mercurial :)</div><br/></div></div></div></div></div></div><div id="40846078" class="c"><input type="checkbox" id="c-40846078" checked=""/><div class="controls bullet"><span class="by">michelledepeil</span><span>|</span><a href="#40843406">parent</a><span>|</span><a href="#40844702">prev</a><span>|</span><a href="#40843456">next</a><span>|</span><label class="collapse" for="c-40846078">[-]</label><label class="expand" for="c-40846078">[2 more]</label></div><br/><div class="children"><div class="content">TIL about worktrees, a feature I&#x27;ve needed in the past but didn&#x27;t expect to even exist.</div><br/><div id="40846102" class="c"><input type="checkbox" id="c-40846102" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#40843406">root</a><span>|</span><a href="#40846078">parent</a><span>|</span><a href="#40843456">next</a><span>|</span><label class="collapse" for="c-40846102">[-]</label><label class="expand" for="c-40846102">[1 more]</label></div><br/><div class="children"><div class="content">Jj also supports worktrees, though they call them workspaces.</div><br/></div></div></div></div><div id="40843456" class="c"><input type="checkbox" id="c-40843456" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#40843406">parent</a><span>|</span><a href="#40846078">prev</a><span>|</span><a href="#40854207">next</a><span>|</span><label class="collapse" for="c-40843456">[-]</label><label class="expand" for="c-40843456">[1 more]</label></div><br/><div class="children"><div class="content">worktrees are pretty great but they make some things a bit more complicated conceptually compared to just checking out two copies for some people</div><br/></div></div></div></div><div id="40854207" class="c"><input type="checkbox" id="c-40854207" checked=""/><div class="controls bullet"><span class="by">gocartStatue</span><span>|</span><a href="#40843406">prev</a><span>|</span><a href="#40850367">next</a><span>|</span><label class="collapse" for="c-40854207">[-]</label><label class="expand" for="c-40854207">[1 more]</label></div><br/><div class="children"><div class="content">A better way for suboptimal workflow to begin with („multitasking” on branches)?</div><br/></div></div><div id="40850367" class="c"><input type="checkbox" id="c-40850367" checked=""/><div class="controls bullet"><span class="by">simonmic</span><span>|</span><a href="#40854207">prev</a><span>|</span><a href="#40845215">next</a><span>|</span><label class="collapse" for="c-40850367">[-]</label><label class="expand" for="c-40850367">[5 more]</label></div><br/><div class="children"><div class="content">Are Jujutsu users all using it from the command line ? Is there anything magit-like yet ? Or do you use magit with it ? Have you run into extra complexity and messes because of having two VCSes interacting in one working copy ?</div><br/><div id="40852769" class="c"><input type="checkbox" id="c-40852769" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#40850367">parent</a><span>|</span><a href="#40853732">next</a><span>|</span><label class="collapse" for="c-40852769">[-]</label><label class="expand" for="c-40852769">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m an extremely light user (just on a few small projects), but<p>&gt; Have you run into extra complexity and messes because of having two VCSes interacting in one working copy ?<p>Well, making git commits in a colocated jujutsu repository was a very <i>confusing</i> experience, because at some point I realized I wasn&#x27;t on a git branch like I thought I was (after a few commits!). jj somehow magically did the right thing though and after switching back to it I had the commits I tried to make in jj and they worked just fine.</div><br/></div></div><div id="40853732" class="c"><input type="checkbox" id="c-40853732" checked=""/><div class="controls bullet"><span class="by">CraftThatBlock</span><span>|</span><a href="#40850367">parent</a><span>|</span><a href="#40852769">prev</a><span>|</span><a href="#40851043">next</a><span>|</span><label class="collapse" for="c-40853732">[-]</label><label class="expand" for="c-40853732">[1 more]</label></div><br/><div class="children"><div class="content">I am (slowly) working on a TUI: <a href="https:&#x2F;&#x2F;github.com&#x2F;Cretezy&#x2F;lazyjj">https:&#x2F;&#x2F;github.com&#x2F;Cretezy&#x2F;lazyjj</a></div><br/></div></div><div id="40851043" class="c"><input type="checkbox" id="c-40851043" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#40850367">parent</a><span>|</span><a href="#40853732">prev</a><span>|</span><a href="#40845215">next</a><span>|</span><label class="collapse" for="c-40851043">[-]</label><label class="expand" for="c-40851043">[2 more]</label></div><br/><div class="children"><div class="content">Most are using it from the command line, but <a href="https:&#x2F;&#x2F;github.com&#x2F;gulbanana&#x2F;gg">https:&#x2F;&#x2F;github.com&#x2F;gulbanana&#x2F;gg</a> is an in-progress GUI.<p>I don&#x27;t use collocated repositories, so I can&#x27;t speak to your second question, but I rarely hear people complain about it on their Discord.</div><br/><div id="40851498" class="c"><input type="checkbox" id="c-40851498" checked=""/><div class="controls bullet"><span class="by">simonmic</span><span>|</span><a href="#40850367">root</a><span>|</span><a href="#40851043">parent</a><span>|</span><a href="#40845215">next</a><span>|</span><label class="collapse" for="c-40851498">[-]</label><label class="expand" for="c-40851498">[1 more]</label></div><br/><div class="children"><div class="content">Very nice, thank you!</div><br/></div></div></div></div></div></div><div id="40845215" class="c"><input type="checkbox" id="c-40845215" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#40850367">prev</a><span>|</span><a href="#40843671">next</a><span>|</span><label class="collapse" for="c-40845215">[-]</label><label class="expand" for="c-40845215">[29 more]</label></div><br/><div class="children"><div class="content">All these things just remind me how depressing it is that we all use this deeply flawed tool, git, and no one can get enough critical mass for a substantially better version.</div><br/><div id="40845665" class="c"><input type="checkbox" id="c-40845665" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#40845215">parent</a><span>|</span><a href="#40847198">next</a><span>|</span><label class="collapse" for="c-40845665">[-]</label><label class="expand" for="c-40845665">[20 more]</label></div><br/><div class="children"><div class="content">the world if filled with &quot;good enough&quot; tools and I don&#x27;t foresee that ever changing tbh. You&#x27;d have to offer something really substantially better than the status quo to gain critical mass. That being said, I think the only thing about git that <i>doesn&#x27;t</i> make reasonable sense are the damn command line flags and subcommand names. The actual semantics of git are pretty much exactly what you want for source control.</div><br/><div id="40846246" class="c"><input type="checkbox" id="c-40846246" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40845665">parent</a><span>|</span><a href="#40845700">next</a><span>|</span><label class="collapse" for="c-40846246">[-]</label><label class="expand" for="c-40846246">[4 more]</label></div><br/><div class="children"><div class="content">Jujutsu tries to avoid that by being compatible with git. Quote from <a href="https:&#x2F;&#x2F;v5.chriskrycho.com&#x2F;essays&#x2F;jj-init&#x2F;" rel="nofollow">https:&#x2F;&#x2F;v5.chriskrycho.com&#x2F;essays&#x2F;jj-init&#x2F;</a>:<p>&gt; <i>I have been using the Git backend for the last seven months, full time, on every one of my personal repositories and all the open source projects I have contributed to. With the sole exception of someone watching me while we pair, no one has noticed, because the Git integration is that solid and robust. This interop means that adoption can be very low friction. Any individual can simply run jj git init --git-repo . in a given Git repository, and start doing their work with Jujutsu instead of Git, and all that work gets translated directly into operations on the Git repository.</i><p>Well that sounds... pretty good actually! Makes me want to try it too...</div><br/><div id="40846285" class="c"><input type="checkbox" id="c-40846285" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40846246">parent</a><span>|</span><a href="#40845700">next</a><span>|</span><label class="collapse" for="c-40846285">[-]</label><label class="expand" for="c-40846285">[3 more]</label></div><br/><div class="children"><div class="content">It’s been about five months of the same for me.</div><br/><div id="40852514" class="c"><input type="checkbox" id="c-40852514" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40846285">parent</a><span>|</span><a href="#40845700">next</a><span>|</span><label class="collapse" for="c-40852514">[-]</label><label class="expand" for="c-40852514">[2 more]</label></div><br/><div class="children"><div class="content">Three or four for me. Or, however long since there was a jj introduction posted here that got some traction. The only person on my team who’s even aware is the one other person I converted. The interop is that smooth.<p>I feel like you and I must have the same taste in technologies. I got into Rails (and Ruby itself) around 2007 then fell in love with Rust around 1.0. Now here I find out you’re a jj convert too!<p>Please let me know the next thing in advance ;)</div><br/><div id="40853325" class="c"><input type="checkbox" id="c-40853325" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40852514">parent</a><span>|</span><a href="#40845700">next</a><span>|</span><label class="collapse" for="c-40853325">[-]</label><label class="expand" for="c-40853325">[1 more]</label></div><br/><div class="children"><div class="content">Ha! &lt;3<p>... I <i>want</i> it to be buck2, but I&#x27;m still not quite sure how exactly stuff is shaking out. If the open source prelude was better, I&#x27;d use it over Cargo.</div><br/></div></div></div></div></div></div></div></div><div id="40845700" class="c"><input type="checkbox" id="c-40845700" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40845665">parent</a><span>|</span><a href="#40846246">prev</a><span>|</span><a href="#40845916">next</a><span>|</span><label class="collapse" for="c-40845700">[-]</label><label class="expand" for="c-40845700">[13 more]</label></div><br/><div class="children"><div class="content">Nah, git has lots of bad design choices that are deeper than UI. The index doesn&#x27;t need to exist. There is a lot of state that is not recorded anywhere - history lost forever. The rebase vs merge disaster. Etc etc.</div><br/><div id="40846019" class="c"><input type="checkbox" id="c-40846019" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40845700">parent</a><span>|</span><a href="#40845782">next</a><span>|</span><label class="collapse" for="c-40846019">[-]</label><label class="expand" for="c-40846019">[6 more]</label></div><br/><div class="children"><div class="content">&gt; git has lots of bad design choices that are deeper than UI. The index doesn&#x27;t need to exist.<p>The index is a useful tool. You can opt out with `git commit -a`<p>&gt; There is a lot of state that is not recorded anywhere<p>Examples?<p>&gt; The rebase vs merge disaster<p>??? How is this a disaster? They serve different purposes and have entirely different semantics. You <i>can</i> use rebase to force fast-forward merges (which do not create merge commits), but I fail to see how this is a disaster.</div><br/><div id="40854642" class="c"><input type="checkbox" id="c-40854642" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40846019">parent</a><span>|</span><a href="#40854666">next</a><span>|</span><label class="collapse" for="c-40854642">[-]</label><label class="expand" for="c-40854642">[1 more]</label></div><br/><div class="children"><div class="content">You cannot &quot;opt out&quot; of the index. It&#x27;s always sitting there.<p><pre><code>   $ ls -l .git&#x2F;index
</code></pre>
When it gets corrupt, though, you can blow it away. It gets rebuilt.<p>The reason it can be casually rebuilt is that there is a copy of it in the HEAD commit.<p>The git index is an intestinal appendix. It has no reason to exist.<p>There is no need to &quot;stage&quot; changes and then move them to a commit. What is called staging should just create a new commit.<p>The index creates duplicity. Many commands operate on both the work tree and index, or separately on either one.<p>Your working tree can differ from the index, which differs from the HEAD commit, so then you have &quot;git diff&quot; (tree to index), &quot;git diff --cached&quot; (index to HEAD) and &quot;git diff HEAD&quot; (tree to HEAD).<p>What&#x27;s the point of staging a commit, when a commit can be amended? You need staging for something that cannot be easily fixed once it is deployed.</div><br/></div></div><div id="40854666" class="c"><input type="checkbox" id="c-40854666" checked=""/><div class="controls bullet"><span class="by">kubanczyk</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40846019">parent</a><span>|</span><a href="#40854642">prev</a><span>|</span><a href="#40854494">next</a><span>|</span><label class="collapse" for="c-40854666">[-]</label><label class="expand" for="c-40854666">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; The rebase vs merge disaster<p>&gt; ??? How is this a disaster?<p>Not a disaster, but merge was not strictly needed. We could&#x27;ve lived with rebase only.<p>But in git (unlike in jj) rebase is deeply flawed. If you ever needed to resolve the same conflict through several commits you know it. That flawed git implementation is why people kept using merge yo solve the  problem on a single final commit.</div><br/></div></div><div id="40854494" class="c"><input type="checkbox" id="c-40854494" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40846019">parent</a><span>|</span><a href="#40854666">prev</a><span>|</span><a href="#40852952">next</a><span>|</span><label class="collapse" for="c-40854494">[-]</label><label class="expand" for="c-40854494">[1 more]</label></div><br/><div class="children"><div class="content">To my knowledge there is nothing the git index can do that Jujutsu can&#x27;t, in a more sensible fashion.</div><br/></div></div><div id="40852952" class="c"><input type="checkbox" id="c-40852952" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40846019">parent</a><span>|</span><a href="#40854494">prev</a><span>|</span><a href="#40846081">next</a><span>|</span><label class="collapse" for="c-40852952">[-]</label><label class="expand" for="c-40852952">[1 more]</label></div><br/><div class="children"><div class="content">My main issues with git are all about version control of branches.<p>Which branches were commits originally created on.<p>What commit was branch X on 2 weeks in the past?<p>(My personal biggest issue) -- there is no way to delete a branch in a version-controlled way (that is, let me un-delete it later). &#x27;reflogs&#x27; don&#x27;t count, I want to be able to version-control my branch deletions.<p>And if people (I&#x27;m not accusing you, person I&#x27;m replying to, but I get this a lot) say &quot;git isn&#x27;t for that&quot;, well then it&#x27;s really annoying that git has become &quot;the version control system for everything&quot;.</div><br/></div></div><div id="40846081" class="c"><input type="checkbox" id="c-40846081" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40846019">parent</a><span>|</span><a href="#40852952">prev</a><span>|</span><a href="#40845782">next</a><span>|</span><label class="collapse" for="c-40846081">[-]</label><label class="expand" for="c-40846081">[1 more]</label></div><br/><div class="children"><div class="content">(Not your original parent, my take)<p>&gt; The index is a useful tool<p>To be clear, jj retains the full power of the git index, without having one. To use git terms, the index is just a normal commit like any other. The index is one of my favorite features of git. I don’t miss it in jj.<p>&gt; Examples?<p>For one… the index! It’s not part of your history. The working directory can contain dirty state that’s not tracked anywhere. Those are the big two off the top of my head.<p>&gt; how is this a disaster?<p>I’m on your side with this one, and jj supports both just fine.</div><br/></div></div></div></div><div id="40845782" class="c"><input type="checkbox" id="c-40845782" checked=""/><div class="controls bullet"><span class="by">pc86</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40845700">parent</a><span>|</span><a href="#40846019">prev</a><span>|</span><a href="#40845916">next</a><span>|</span><label class="collapse" for="c-40845782">[-]</label><label class="expand" for="c-40845782">[6 more]</label></div><br/><div class="children"><div class="content">This will sound flippant but it&#x27;s an honest question: who cares?<p>I use git all day, every day. Sometimes CLI, sometimes a dedicated UI (e.g. GH desktop but have also used Tower and other dedicated tools), sometimes a UI in something else a la VSCode. I write code every day.<p>Why should I care <i>at all</i> about rebase vs. merge, whether the internals of git are optimal, whether index needs to exist at all or what it even is?<p>I think this is sort of what the other comment is getting at about a replacement needing to be <i>much</i> better and that git is good enough. I can count on one hand the number times I&#x27;ve ever needed to glean information out of old commit messages and when something got merged into something else.<p>Arguing about git workflows and whether you should rebase, merge, squash merge, trunk deployment, gitflow, etc. all seems like ultimate bikeshedding to me. If you&#x27;re shipping code and making money your git workflow is irrelevant. If your project is so convoluted and broken and you&#x27;re gaining actual useful information from a 2-year old commit message that you couldn&#x27;t get just by looking at the code it feels like something else is fundamentally broken that better git internals are not going to address.</div><br/><div id="40846063" class="c"><input type="checkbox" id="c-40846063" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40845782">parent</a><span>|</span><a href="#40845855">next</a><span>|</span><label class="collapse" for="c-40846063">[-]</label><label class="expand" for="c-40846063">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s all well and good if<p>a) you almost always work in the same repo; or
B) you are in charge of the repos you work in.<p>Often these are not true for me. I have no deal with other people&#x27;s repos, dealing with merge or rebase depending on their conventions etc.</div><br/></div></div><div id="40845855" class="c"><input type="checkbox" id="c-40845855" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40845782">parent</a><span>|</span><a href="#40846063">prev</a><span>|</span><a href="#40845996">next</a><span>|</span><label class="collapse" for="c-40845855">[-]</label><label class="expand" for="c-40845855">[3 more]</label></div><br/><div class="children"><div class="content">I would care if a new VCS would make my life easier. This quote from the linked article:<p>&gt; <i>very few working developers have a good mental model for Git. Instead, they have a handful of commands they have learned over the years: enough to get by, and little more.</i><p>...pretty much describes me TBH. I know enough of git to get by day to day, but if I need to do more than that, I have to rely on StackOverflow et al. Which is always frustrating and feels like a waste of time.</div><br/><div id="40846076" class="c"><input type="checkbox" id="c-40846076" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40845855">parent</a><span>|</span><a href="#40846236">next</a><span>|</span><label class="collapse" for="c-40846076">[-]</label><label class="expand" for="c-40846076">[1 more]</label></div><br/><div class="children"><div class="content">I have used git for many years, have over 250 repos on GitHub and have written several blog posts about it.<p>This is definitely me. I will never understand it.</div><br/></div></div><div id="40846236" class="c"><input type="checkbox" id="c-40846236" checked=""/><div class="controls bullet"><span class="by">pc86</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40845855">parent</a><span>|</span><a href="#40846076">prev</a><span>|</span><a href="#40845996">next</a><span>|</span><label class="collapse" for="c-40846236">[-]</label><label class="expand" for="c-40846236">[1 more]</label></div><br/><div class="children"><div class="content">I would try a new VCS if it made my life easier too, but I think my point is just that the quote you posted is not only accurate for most developers, but that there&#x27;s nothing wrong with that. Having a perfect mental model of how git works is going to be a waste of time for anyone who doesn&#x27;t want to actually work on git itself.</div><br/></div></div></div></div><div id="40845996" class="c"><input type="checkbox" id="c-40845996" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40845782">parent</a><span>|</span><a href="#40845855">prev</a><span>|</span><a href="#40845916">next</a><span>|</span><label class="collapse" for="c-40845996">[-]</label><label class="expand" for="c-40845996">[1 more]</label></div><br/><div class="children"><div class="content">I mean, you can use this logic to favor the status quo in any given circumstance. Some people are of course happy with that, but some folks want to try and improve. Not everyone has to care, but not everyone has to not care, either.<p>I swapped to jj because it’s both easier to use <i>and more powerful</i> than git. To me, anyway. And I was a “you can take git from my cold dead fingers” type person. A “the git cli is fine” type of person.</div><br/></div></div></div></div></div></div><div id="40845916" class="c"><input type="checkbox" id="c-40845916" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40845665">parent</a><span>|</span><a href="#40845700">prev</a><span>|</span><a href="#40847198">next</a><span>|</span><label class="collapse" for="c-40845916">[-]</label><label class="expand" for="c-40845916">[2 more]</label></div><br/><div class="children"><div class="content">There was a time when a VCS could just be a slightly better VCS and it could probably gain traction.<p>But now, for both better and worse, git is no longer just an app or a tool, it’s just a fundamental library and protocol that IDE:s, Build systems and project&#x2F;work management systems build on. It has become almost too late to change.<p>The semantics of git are “ok”, but mostly it’s just a big leap ahead of cvs and Subversion. As always in any git thread we’ll see people (including me) expressing hope that Pijul will one day be successful enough to break the git monopoly.</div><br/><div id="40845955" class="c"><input type="checkbox" id="c-40845955" checked=""/><div class="controls bullet"><span class="by">alephnerd</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40845916">parent</a><span>|</span><a href="#40847198">next</a><span>|</span><label class="collapse" for="c-40845955">[-]</label><label class="expand" for="c-40845955">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There was a time when a VCS could just be a slightly better VCS and it could probably gain traction<p>That was also a time when the entire software development industry numbered at most 50,000 globally and was still a nascent industry.</div><br/></div></div></div></div></div></div><div id="40847198" class="c"><input type="checkbox" id="c-40847198" checked=""/><div class="controls bullet"><span class="by">dxdm</span><span>|</span><a href="#40845215">parent</a><span>|</span><a href="#40845665">prev</a><span>|</span><a href="#40853580">next</a><span>|</span><label class="collapse" for="c-40847198">[-]</label><label class="expand" for="c-40847198">[1 more]</label></div><br/><div class="children"><div class="content">&gt; how depressing it is that we all use this deeply flawed tool, git<p>Maybe a change in perspective can help you be less depressed. I don&#x27;t find git &quot;deeply flawed&quot;; on the contrary, it&#x27;s an extremely useful tool with an easy to grasp data model. Some parts of it are quirky, sure, but I find it very easy to use productively in code bases small and large, private or shared.<p>It&#x27;s such a huge improvement over what was used before, it can be a little weird for me to hear people complain so hard about git. But hey, some fresher perspective than mine surely exist.<p>Anyway, instead of thinking of git as deeply flawed, try to see it as a battle tested tool without which your job would suck in ways you can&#x27;t even imagine.<p>You&#x27;re standing on the shoulders of a giant, easily wielding its power, and it sounds like the wart you found on its chin is a huge catastrophe somehow. Find a way to appreciate the giant until a worthy successor inevitably emerges, and maybe things will seem a little less depressing. :)</div><br/></div></div><div id="40853580" class="c"><input type="checkbox" id="c-40853580" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#40845215">parent</a><span>|</span><a href="#40847198">prev</a><span>|</span><a href="#40845501">next</a><span>|</span><label class="collapse" for="c-40853580">[-]</label><label class="expand" for="c-40853580">[2 more]</label></div><br/><div class="children"><div class="content">Step one is for you personally to start using jj or sapling or gitless. Step two is to convince two other people.</div><br/><div id="40854077" class="c"><input type="checkbox" id="c-40854077" checked=""/><div class="controls bullet"><span class="by">ramon156</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40853580">parent</a><span>|</span><a href="#40845501">next</a><span>|</span><label class="collapse" for="c-40854077">[-]</label><label class="expand" for="c-40854077">[1 more]</label></div><br/><div class="children"><div class="content">And since you&#x27;re early, you&#x27;ll benefit the most (:</div><br/></div></div></div></div><div id="40845501" class="c"><input type="checkbox" id="c-40845501" checked=""/><div class="controls bullet"><span class="by">jFriedensreich</span><span>|</span><a href="#40845215">parent</a><span>|</span><a href="#40853580">prev</a><span>|</span><a href="#40845343">next</a><span>|</span><label class="collapse" for="c-40845501">[-]</label><label class="expand" for="c-40845501">[3 more]</label></div><br/><div class="children"><div class="content">you can start using sapling today. its github compatible and production ready. as long as the new tools support github or whatever forge&#x2F;hub you are using, there is no need for critical mass for adoption. This is not possisble for radical approaches like pijul, but that approach is not fully proven yet.</div><br/><div id="40845868" class="c"><input type="checkbox" id="c-40845868" checked=""/><div class="controls bullet"><span class="by">epage</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40845501">parent</a><span>|</span><a href="#40845343">next</a><span>|</span><label class="collapse" for="c-40845868">[-]</label><label class="expand" for="c-40845868">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t sapling only compatible with git servers and not local repos? That is a huge impediment with so many tools expecting git. That is what i find impressive about jj is it is compatible with local repos.</div><br/><div id="40846239" class="c"><input type="checkbox" id="c-40846239" checked=""/><div class="controls bullet"><span class="by">jFriedensreich</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40845868">parent</a><span>|</span><a href="#40845343">next</a><span>|</span><label class="collapse" for="c-40846239">[-]</label><label class="expand" for="c-40846239">[1 more]</label></div><br/><div class="children"><div class="content">that is true, i have a separate clone of my repos with sapling and git and use 98% of the time the sapling one with sapling and most importantly interactive smartlog (which is 1000 times better than most git tooling so would be reason alone to do this.)   for the few times i need my git tools i sync the git clone via the git remote and then use the git tools on that repo.</div><br/></div></div></div></div></div></div><div id="40845343" class="c"><input type="checkbox" id="c-40845343" checked=""/><div class="controls bullet"><span class="by">whoomp12342</span><span>|</span><a href="#40845215">parent</a><span>|</span><a href="#40845501">prev</a><span>|</span><a href="#40843671">next</a><span>|</span><label class="collapse" for="c-40845343">[-]</label><label class="expand" for="c-40845343">[2 more]</label></div><br/><div class="children"><div class="content">humans are creatures of habit. fixing these flaws is not enough to motivate us onto something new, it has to be groundbreaking.</div><br/><div id="40846825" class="c"><input type="checkbox" id="c-40846825" checked=""/><div class="controls bullet"><span class="by">g-b-r</span><span>|</span><a href="#40845215">root</a><span>|</span><a href="#40845343">parent</a><span>|</span><a href="#40843671">next</a><span>|</span><label class="collapse" for="c-40846825">[-]</label><label class="expand" for="c-40846825">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a matter of habit but of widespread usage<p>If you&#x27;re a developer, for almost every job or open source job you&#x27;ll be required to use git, but I think most people long of moving away from it</div><br/></div></div></div></div></div></div><div id="40845350" class="c"><input type="checkbox" id="c-40845350" checked=""/><div class="controls bullet"><span class="by">whoomp12342</span><span>|</span><a href="#40843671">prev</a><span>|</span><label class="collapse" for="c-40845350">[-]</label><label class="expand" for="c-40845350">[3 more]</label></div><br/><div class="children"><div class="content">the core issue with GIT is this: it requires cognitive overhead. JJ doesn&#x27;t seem to solve that.</div><br/><div id="40846557" class="c"><input type="checkbox" id="c-40846557" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#40845350">parent</a><span>|</span><a href="#40846087">next</a><span>|</span><label class="collapse" for="c-40846557">[-]</label><label class="expand" for="c-40846557">[1 more]</label></div><br/><div class="children"><div class="content">Having used both, jj imposes dramatically less cognitive overhead.<p>I was (am?) a git expert and power user. In a month I began trusting jj to a level I never did after using git shortly after its first official releases. I “blindly” undertake repo changes that I’d double or triple check before doing in git.<p>It’s better to a degree I never would have believed before I gave it a shot.</div><br/></div></div><div id="40846087" class="c"><input type="checkbox" id="c-40846087" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#40845350">parent</a><span>|</span><a href="#40846557">prev</a><span>|</span><label class="collapse" for="c-40846087">[-]</label><label class="expand" for="c-40846087">[1 more]</label></div><br/><div class="children"><div class="content">Can you say more? I find jj to be easier to reason about, but that’s not the same thing.</div><br/></div></div></div></div></div></div></div></div></div></body></html>