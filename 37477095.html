<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694509266329" as="style"/><link rel="stylesheet" href="styles.css?v=1694509266329"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://renegadeotter.com/2023/09/10/death-by-a-thousand-microservices.html">Death by a Thousand Microservices</a>Â <span class="domain">(<a href="https://renegadeotter.com">renegadeotter.com</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>173 comments</span></div><br/><div><div id="37477361" class="c"><input type="checkbox" id="c-37477361" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#37478407">next</a><span>|</span><label class="collapse" for="c-37477361">[-]</label><label class="expand" for="c-37477361">[38 more]</label></div><br/><div class="children"><div class="content">I am one of the biggest proponents of microservices.  I helped build the platform at Netflix, I&#x27;ve literally traveled around the world extolling the virtues of microservices.<p>But I also advise a lot of startups, and you know what I tell them nearly every time?<p>Build a monolith.<p>It&#x27;s so much easier to start out with one codebase and one database, and that will scale for a while.  Especially if you use a key&#x2F;value store like DynamoDB (although you will lose relational functionality that can be helpful at the start).  And did you know that you can deploy a monolith to Lambda and still get all the benefits of Lambda without building services?<p>And then, when you start growing, that&#x27;s when you break out an independently scalable part of the system into a microservice (with it&#x27;s own data store!).  The one that may need to scale independently, or that you want to be able to deploy separately.<p>Microservices takes at least 25% of your engineering time just maintaining the platform.  It&#x27;s not worth it unless you can recoup that 25% in efficiency.</div><br/><div id="37478072" class="c"><input type="checkbox" id="c-37478072" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#37477361">parent</a><span>|</span><a href="#37477396">next</a><span>|</span><label class="collapse" for="c-37478072">[-]</label><label class="expand" for="c-37478072">[1 more]</label></div><br/><div class="children"><div class="content">Wise words. They boil down to a very simple truth that was as accurate half a century ago as it is today:<p>Make things as simple as possible, and as complex as necessary.<p>I can <i>always</i> make something more complex than it is now. As you say, we can take out things from a monolith and make them into a service. It can be hard to do so, sure. But nowhere near as hard, as trying to get complexity OUT of a system once it&#x27;s in. Everyone who ever tried to revert a bunch of microservices back into a Monolith knows exactly what I am talking about. It usually amounts to the same work as a ground-up rebuild.</div><br/></div></div><div id="37477396" class="c"><input type="checkbox" id="c-37477396" checked=""/><div class="controls bullet"><span class="by">crooked-v</span><span>|</span><a href="#37477361">parent</a><span>|</span><a href="#37478072">prev</a><span>|</span><a href="#37477424">next</a><span>|</span><label class="collapse" for="c-37477396">[-]</label><label class="expand" for="c-37477396">[18 more]</label></div><br/><div class="children"><div class="content">&quot;A while&quot; is underselling it. As long as you have people who are half-decent with SQL, &quot;just put Postgres on a big db server&quot; will get you to 50 million row tables before you have to start thinking about even hiring a real DBA.</div><br/><div id="37477638" class="c"><input type="checkbox" id="c-37477638" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477396">parent</a><span>|</span><a href="#37477497">next</a><span>|</span><label class="collapse" for="c-37477638">[-]</label><label class="expand" for="c-37477638">[10 more]</label></div><br/><div class="children"><div class="content">50M is something that can easily be done with just a dev who understands that sql is more than select, insert and update with the manual, google and chatgpt.<p>You can get <i>really damn far</i> with a fat postgres box.</div><br/><div id="37477839" class="c"><input type="checkbox" id="c-37477839" checked=""/><div class="controls bullet"><span class="by">dalbasal</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477638">parent</a><span>|</span><a href="#37478059">next</a><span>|</span><label class="collapse" for="c-37477839">[-]</label><label class="expand" for="c-37477839">[5 more]</label></div><br/><div class="children"><div class="content">The problem with these discussions is that you can <i>always</i> get a lot out of any given architecture, structure, db approach or whatnot. Can. There&#x27;s just a lot of daylight between &quot;can&quot; and &quot;likely will.&quot;<p>Ultimately, everything has its limitations and tradeoffs. If we respect them, it&#x27;s generally a smooth ride. Problem is that we rarely do... within a company (startup or otherwise) under real conditions. There&#x27;s also a dynamic where we build until the point where something stops us. Tech debt, complexity, over-engineering, under-engineering, feature bloat or antagonism between early decisions and current goals.<p>There&#x27;s a self-regulating aspect to this. If architecture is spot on, perfect for the task at hand we can move faster to reach the point where it no longer is.</div><br/><div id="37477928" class="c"><input type="checkbox" id="c-37477928" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477839">parent</a><span>|</span><a href="#37477896">next</a><span>|</span><label class="collapse" for="c-37477928">[-]</label><label class="expand" for="c-37477928">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right of course.<p>My point is that postgres is, compared to almost everything else, easy to get from &quot;can&quot; to &quot;likely will&quot; with just somebody with a brain, a manual and google. In absolute terms it of course depends, but the point is relative.</div><br/><div id="37478237" class="c"><input type="checkbox" id="c-37478237" checked=""/><div class="controls bullet"><span class="by">dalbasal</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477928">parent</a><span>|</span><a href="#37477896">next</a><span>|</span><label class="collapse" for="c-37478237">[-]</label><label class="expand" for="c-37478237">[1 more]</label></div><br/><div class="children"><div class="content">A brain, a manual and google is usually a pretty good way generally to make solid decisions, respect the limits of your chosen stack.<p>What happens when there is &gt;1 brain involved... or when brainless, manualless decisions eventually get made... or two pivots from now...<p>I&#x27;m not disagreeing with your approach. I agree with it, especially as starting point. I&#x27;m cautioning that resilience against complexity isn&#x27;t about how easy it is to make good decisions when you understand the spec, read the manual and calmly proceed. Complexity and fragility accumulate when one or all of these are absent. How easily you can (and thus inevitably will) make a mess... not how easily you can keep it clean.<p>IRL situations with regular rdbs, a very common trend seems to be long term drift between schema and spec. The flexibility and approachability of postgres often enables a lot of kludge eventually.<p>Data stores have this dichotomy between &quot;<i>look how easy</i>&quot; and &quot;<i>is limiting factor</i>&quot; that speaks to difficulties we don&#x27;t know how to articulate or isolate.</div><br/></div></div></div></div><div id="37477896" class="c"><input type="checkbox" id="c-37477896" checked=""/><div class="controls bullet"><span class="by">szundi</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477839">parent</a><span>|</span><a href="#37477928">prev</a><span>|</span><a href="#37478059">next</a><span>|</span><label class="collapse" for="c-37477896">[-]</label><label class="expand" for="c-37477896">[2 more]</label></div><br/><div class="children"><div class="content">The real tragedy is this clever people usually talking about their usecases and those present the requirements. There is no average system out there.</div><br/><div id="37478017" class="c"><input type="checkbox" id="c-37478017" checked=""/><div class="controls bullet"><span class="by">cnity</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477896">parent</a><span>|</span><a href="#37478059">next</a><span>|</span><label class="collapse" for="c-37478017">[-]</label><label class="expand" for="c-37478017">[1 more]</label></div><br/><div class="children"><div class="content">&quot;There is no average system&quot; is such a good insight.</div><br/></div></div></div></div></div></div><div id="37478059" class="c"><input type="checkbox" id="c-37478059" checked=""/><div class="controls bullet"><span class="by">pizza234</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477638">parent</a><span>|</span><a href="#37477839">prev</a><span>|</span><a href="#37477793">next</a><span>|</span><label class="collapse" for="c-37478059">[-]</label><label class="expand" for="c-37478059">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been on both the sysadmin, development, and hiring sides, and with data models at scales of 50M+ records, devs who &quot;understand that sql is more than select [...]&quot; are rare in my experience, as they&#x27;re a cross between db admins and developers.<p>Administrating (in particular, query planning and production operations) databases with tables sizes with magnitude of 10M and more records is challenging, and requires a skill set that is very different from pure development.<p>One won&#x27;t get &quot;really damn far with a fat postgres box&quot;, unless they&#x27;re doing very simple SELECTs, which is not the case with modern web apps.</div><br/><div id="37478168" class="c"><input type="checkbox" id="c-37478168" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37478059">parent</a><span>|</span><a href="#37478238">next</a><span>|</span><label class="collapse" for="c-37478168">[-]</label><label class="expand" for="c-37478168">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Administrating (in particular, query planning and production operations) databases with tables sizes with magnitude of 10M and more records is challenging, and requires a skill set that is very different from pure development.<p>Is it more or less challenging than the alternatives? Is it less challenging enough to add a new tech to your stack, add the required knowledge to the team, etc?<p>I mean, knowing &quot;enough-to-perform-CRUD&quot; SQL is table stakes for developing on the back-end, but knowing $CURRENT-FLAVOUR-NOSQL (of which there are multiple products, all with such substantial differences that there is no knowledge transfer between using them) isn&#x27;t, so there&#x27;s going to be ramp-up time for every dev, and then every dev that is added to the team.<p>I&#x27;m not disputing your argument, I&#x27;m just pointing out that, sometimes, it&#x27;s easier and faster to upskill your PostgreSQL developer to &quot;scale the DB&quot; than it is to teach them how to properly use, maintain, architect and code for DynamoDB and others.</div><br/></div></div><div id="37478238" class="c"><input type="checkbox" id="c-37478238" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37478059">parent</a><span>|</span><a href="#37478168">prev</a><span>|</span><a href="#37477793">next</a><span>|</span><label class="collapse" for="c-37478238">[-]</label><label class="expand" for="c-37478238">[1 more]</label></div><br/><div class="children"><div class="content">&gt; are rare in my experience, as they&#x27;re a cross between db admins and developers.<p>That&#x27;s fine. You only ( ;) ) need one on the team.</div><br/></div></div></div></div></div></div><div id="37477497" class="c"><input type="checkbox" id="c-37477497" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477396">parent</a><span>|</span><a href="#37477638">prev</a><span>|</span><a href="#37478025">next</a><span>|</span><label class="collapse" for="c-37477497">[-]</label><label class="expand" for="c-37477497">[4 more]</label></div><br/><div class="children"><div class="content">True.  &quot;While&quot; for some large value of time. And if you set up the auto-vacuumer correctly from the start, you can go even further!</div><br/><div id="37477736" class="c"><input type="checkbox" id="c-37477736" checked=""/><div class="controls bullet"><span class="by">turtles3</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477497">parent</a><span>|</span><a href="#37478025">next</a><span>|</span><label class="collapse" for="c-37477736">[-]</label><label class="expand" for="c-37477736">[3 more]</label></div><br/><div class="children"><div class="content">Unpopular opinion: if you&#x27;re skimping on ops&#x2F;DBA resources (as you may need to do in a startup), then MySQL is a better default. By all means use postgres if your use case demands it, but personally I find the ops story for MySQL takes less engineering overhead.</div><br/><div id="37478379" class="c"><input type="checkbox" id="c-37478379" checked=""/><div class="controls bullet"><span class="by">avereveard</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477736">parent</a><span>|</span><a href="#37477881">next</a><span>|</span><label class="collapse" for="c-37478379">[-]</label><label class="expand" for="c-37478379">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not wrong, but postgres allows for cramming a lot of functionality in the db, and it&#x27;s fast at following storage trend, i.e. with pgvector</div><br/></div></div><div id="37477881" class="c"><input type="checkbox" id="c-37477881" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477736">parent</a><span>|</span><a href="#37478379">prev</a><span>|</span><a href="#37478025">next</a><span>|</span><label class="collapse" for="c-37477881">[-]</label><label class="expand" for="c-37477881">[1 more]</label></div><br/><div class="children"><div class="content">I agree with this &quot;unpopular opinion&quot;. Worked with both MySQL and postgres based mid-scale apps of several thousands of users. Postgres is so <i>deeply</i> lauded here at HN yet requires two more magnitudes of operations work to keep it up and running. Vacuuming sucks hard.</div><br/></div></div></div></div></div></div><div id="37478025" class="c"><input type="checkbox" id="c-37478025" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477396">parent</a><span>|</span><a href="#37477497">prev</a><span>|</span><a href="#37477424">next</a><span>|</span><label class="collapse" for="c-37478025">[-]</label><label class="expand" for="c-37478025">[3 more]</label></div><br/><div class="children"><div class="content">Itâs so cute that you think 50M rows is big. Your phone can handle many times that, and update it tens of thousands of times per second.</div><br/><div id="37478133" class="c"><input type="checkbox" id="c-37478133" checked=""/><div class="controls bullet"><span class="by">dagw</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37478025">parent</a><span>|</span><a href="#37477424">next</a><span>|</span><label class="collapse" for="c-37478133">[-]</label><label class="expand" for="c-37478133">[2 more]</label></div><br/><div class="children"><div class="content">The problem isn&#x27;t storing or inserting 50M rows, it querying 50M rows in non trivial ways. And the difference in performance between doing that &#x27;right&#x27; and &#x27;wrong&#x27; is orders of magnitude.</div><br/><div id="37478275" class="c"><input type="checkbox" id="c-37478275" checked=""/><div class="controls bullet"><span class="by">omegabravo</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37478133">parent</a><span>|</span><a href="#37477424">next</a><span>|</span><label class="collapse" for="c-37478275">[-]</label><label class="expand" for="c-37478275">[1 more]</label></div><br/><div class="children"><div class="content">doing it on your phone only has one person querying it.  Scale that to several thousand and it might appear different.</div><br/></div></div></div></div></div></div></div></div><div id="37477424" class="c"><input type="checkbox" id="c-37477424" checked=""/><div class="controls bullet"><span class="by">aledalgrande</span><span>|</span><a href="#37477361">parent</a><span>|</span><a href="#37477396">prev</a><span>|</span><a href="#37477422">next</a><span>|</span><label class="collapse" for="c-37477424">[-]</label><label class="expand" for="c-37477424">[7 more]</label></div><br/><div class="children"><div class="content">&gt; And then, when you start growing, that&#x27;s when you break out an independently scalable part of the system into a microservice<p>Respectfully disagree. At this point you start refactoring your monolith into components and actually look at performance measurements via tracing.<p>Do not do microservices when you&#x27;re growing (or ever, most of the time).<p>And by the love of god, don&#x27;t split your data. Data is much more complex to manage than code.</div><br/><div id="37477534" class="c"><input type="checkbox" id="c-37477534" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477424">parent</a><span>|</span><a href="#37477878">next</a><span>|</span><label class="collapse" for="c-37477534">[-]</label><label class="expand" for="c-37477534">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And by the love of god, don&#x27;t split your data.<p>I think people feel that if they introduce a new data store, they wonât have to deal with the existing nearly unusable massive data store.<p>Of course that just exacerbates the problem.</div><br/></div></div><div id="37477878" class="c"><input type="checkbox" id="c-37477878" checked=""/><div class="controls bullet"><span class="by">theshrike79</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477424">parent</a><span>|</span><a href="#37477534">prev</a><span>|</span><a href="#37477959">next</a><span>|</span><label class="collapse" for="c-37477878">[-]</label><label class="expand" for="c-37477878">[2 more]</label></div><br/><div class="children"><div class="content">Splitting data is just a hardcore way of splitting the responsibility for the data.<p>You can&#x27;t have 42 different classes directly poking the User-table for example. You need one clear location that has the responsibility for the data.<p>If you move the User-table to a different database schema, other places CANNOT touch it because they won&#x27;t have access to it =)</div><br/><div id="37477933" class="c"><input type="checkbox" id="c-37477933" checked=""/><div class="controls bullet"><span class="by">aledalgrande</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477878">parent</a><span>|</span><a href="#37477959">next</a><span>|</span><label class="collapse" for="c-37477933">[-]</label><label class="expand" for="c-37477933">[1 more]</label></div><br/><div class="children"><div class="content">And then the order table will need to set user ids as a foreign key and you will have two sources of truth lol<p>Will be fun when you decide that you want to have organizations to be linked to orders instead of users.<p>All this to say, data management and having more than one source of truth complicates your world a lot. The responsibility for writing the data has to be solved at the appropriate layer: only one entity writing it.</div><br/></div></div></div></div><div id="37477959" class="c"><input type="checkbox" id="c-37477959" checked=""/><div class="controls bullet"><span class="by">Copenjin</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477424">parent</a><span>|</span><a href="#37477878">prev</a><span>|</span><a href="#37477745">next</a><span>|</span><label class="collapse" for="c-37477959">[-]</label><label class="expand" for="c-37477959">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And by the love of god, don&#x27;t split your data.<p>Most data problems can be fixed on the frontend with a few relatively simple graphql queries. &#x2F;s</div><br/></div></div><div id="37477745" class="c"><input type="checkbox" id="c-37477745" checked=""/><div class="controls bullet"><span class="by">ngc248</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477424">parent</a><span>|</span><a href="#37477959">prev</a><span>|</span><a href="#37477422">next</a><span>|</span><label class="collapse" for="c-37477745">[-]</label><label class="expand" for="c-37477745">[2 more]</label></div><br/><div class="children"><div class="content">There is a way to splitting data. The service which owns the data always does the writes and others who need reads on that data can store replicas. ofc the complication then will be in replicating data, but this will enable services to massively scale and eliminate SPOFs</div><br/><div id="37478239" class="c"><input type="checkbox" id="c-37478239" checked=""/><div class="controls bullet"><span class="by">code_biologist</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477745">parent</a><span>|</span><a href="#37477422">next</a><span>|</span><label class="collapse" for="c-37478239">[-]</label><label class="expand" for="c-37478239">[1 more]</label></div><br/><div class="children"><div class="content">The other part of this pattern you mention (replicating data) seems solved in many cases by the data warehouse patterns of the last few years. Stuff it all in Snowflake or BigQuery then readers can query as they see fit. Query engines like Trino can paper over data storage heterogeneity &#x2F; breakdowns in centralization. I&#x27;m not a fan of the &quot;lakehouse&quot; terminology, but it is the thing.<p>There are downsides to coupling more loosely with data consumers, but it keeps service owners moving without wasting time vending data.</div><br/></div></div></div></div></div></div><div id="37477422" class="c"><input type="checkbox" id="c-37477422" checked=""/><div class="controls bullet"><span class="by">elliotec</span><span>|</span><a href="#37477361">parent</a><span>|</span><a href="#37477424">prev</a><span>|</span><a href="#37478339">next</a><span>|</span><label class="collapse" for="c-37477422">[-]</label><label class="expand" for="c-37477422">[2 more]</label></div><br/><div class="children"><div class="content">Ah, itâs you!<p>Youâve got a hell of a resume. And been accidentally incredibly convincing in getting many people into many early messes.<p>Jokes aside, thanks for at least coming around to advise startups sanely.<p>Iâd personally never advocate for microservices until at the scale of Netflix or Amazon or Reddit, and even then only with in-house expertise at your level. Otherwise itâs a nightmare.<p>Thanks for everything, especially your contributions of sanity.</div><br/><div id="37477508" class="c"><input type="checkbox" id="c-37477508" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477422">parent</a><span>|</span><a href="#37478339">next</a><span>|</span><label class="collapse" for="c-37477508">[-]</label><label class="expand" for="c-37477508">[1 more]</label></div><br/><div class="children"><div class="content">Aww, thanks for the kind words.  I apologize if I caused you any harm with my talks.  I did in fact start out saying everyone should use microservices, but I pulled back as I saw how damaging that can be to a small startup, or even a large enterprise that doesn&#x27;t actually need it.<p>We all make mistakes!</div><br/></div></div></div></div><div id="37478339" class="c"><input type="checkbox" id="c-37478339" checked=""/><div class="controls bullet"><span class="by">johnboy123</span><span>|</span><a href="#37477361">parent</a><span>|</span><a href="#37477422">prev</a><span>|</span><a href="#37477936">next</a><span>|</span><label class="collapse" for="c-37478339">[-]</label><label class="expand" for="c-37478339">[1 more]</label></div><br/><div class="children"><div class="content">Just chipping in with thoughts on DynamoDB, (although I have worked on much smaller scale systems)<p>I am a long term dev, done lots of SQL, but for the past few years I have been using DynamoDB, and I am using it for my new startup (So I rate it).<p>Cons 
 - You have to be very aware of your query patterns, and not having ad-hoc queries is a pain.<p>Plus sides
 - With on demand billing, its free if you aren&#x27;t using it
 - Built correctly, it will scale 
 - No Schema upgrades (This one is massive for me)<p>On the last point, I really do appreciate not having to worry about keeping schemas upto date across all devs and environments.<p>We use quite a simple pattern of a table per entity, as opposed to single table design, because it allows us to just use the API at the highest level of abstraction, where you just write your objects to dynamoDB.
(You can still do lower level requests to poke values and such like)</div><br/></div></div><div id="37477936" class="c"><input type="checkbox" id="c-37477936" checked=""/><div class="controls bullet"><span class="by">Copenjin</span><span>|</span><a href="#37477361">parent</a><span>|</span><a href="#37478339">prev</a><span>|</span><a href="#37478061">next</a><span>|</span><label class="collapse" for="c-37477936">[-]</label><label class="expand" for="c-37477936">[1 more]</label></div><br/><div class="children"><div class="content">I wish you good luck with your redemption arc, every monolith counts.</div><br/></div></div><div id="37478061" class="c"><input type="checkbox" id="c-37478061" checked=""/><div class="controls bullet"><span class="by">lifeisstillgood</span><span>|</span><a href="#37477361">parent</a><span>|</span><a href="#37477936">prev</a><span>|</span><a href="#37477691">next</a><span>|</span><label class="collapse" for="c-37478061">[-]</label><label class="expand" for="c-37478061">[2 more]</label></div><br/><div class="children"><div class="content">How would you split the total overhead between monolith and monorepo?<p>(sorry this ran away with me)<p>A dumb example is that if I start with my single codebase running on a single server, I am likely to have a single git repo (foo).<p>Then I have a genius idea and put all the email handling code into foo.mail and soon I have foo.web and foo.payments.<p>All is fine as long as I am just checking out HEAD each time. The code running in the runtime is still one big set of code.<p>If I get creative and put in load balancers it&#x27;s still a monolith.<p>But if I split out the web servers from the email servers, then I kind of start to see microservices appear.<p>I am trying not to be pedantic, but I am truly interested in experienced views on where the pain really starts to appear.<p>At this point (server to server comms), I should look at mTLS, and centralised logging and all the good stuff to manage microservices.<p>But how much pain was there before?<p>What if I was a large company and so hired a dev or two per repo (you know to get that 9 women one month effect).  Co-ordinating multiple devs over different repos, even with one monolithic runtime, is painful (experience tells me).<p>So I am interested in where the break points are, and whether there are easier paths up the mountain?</div><br/><div id="37478218" class="c"><input type="checkbox" id="c-37478218" checked=""/><div class="controls bullet"><span class="by">afiori</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37478061">parent</a><span>|</span><a href="#37477691">next</a><span>|</span><label class="collapse" for="c-37478218">[-]</label><label class="expand" for="c-37478218">[1 more]</label></div><br/><div class="children"><div class="content">Splitting out the webserver (assuming it is the main entrypoint for users) seems more like an infrastructure choice than application architecture and having an independent email-sending-service looks more like replacing a third-party offer (like turboSMTP) with an in-house service.<p>I do not think that this is what people mean by microservices.</div><br/></div></div></div></div><div id="37477691" class="c"><input type="checkbox" id="c-37477691" checked=""/><div class="controls bullet"><span class="by">hliyan</span><span>|</span><a href="#37477361">parent</a><span>|</span><a href="#37478061">prev</a><span>|</span><a href="#37477737">next</a><span>|</span><label class="collapse" for="c-37477691">[-]</label><label class="expand" for="c-37477691">[3 more]</label></div><br/><div class="children"><div class="content">I wrote this 8 years ago: Microservices vs. &quot;air-gapped&quot; modules <a href="https:&#x2F;&#x2F;www.linkedin.com&#x2F;pulse&#x2F;maintainable-software-architectures-microservices-vs-air-liyanage&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.linkedin.com&#x2F;pulse&#x2F;maintainable-software-archite...</a>. You can achieve the same end as a microservice using a module, by simply having lint rules that prevent you from importing other application level modules. This way the only possible comms interface is to pass events with a payload of primitive typed parameters.</div><br/><div id="37477748" class="c"><input type="checkbox" id="c-37477748" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477691">parent</a><span>|</span><a href="#37477780">next</a><span>|</span><label class="collapse" for="c-37477748">[-]</label><label class="expand" for="c-37477748">[1 more]</label></div><br/><div class="children"><div class="content">An interesting idea. Sort of a good half way. But one issue I see is that you can still have a shared data store. That means you can accidentally (or intentionally) use the database to pass back-channel messages â- have one module store data and another read it.<p>That could lead to hard to find bugs. Did this ever come up for you?</div><br/></div></div><div id="37477780" class="c"><input type="checkbox" id="c-37477780" checked=""/><div class="controls bullet"><span class="by">3np</span><span>|</span><a href="#37477361">root</a><span>|</span><a href="#37477691">parent</a><span>|</span><a href="#37477748">prev</a><span>|</span><a href="#37477737">next</a><span>|</span><label class="collapse" for="c-37477780">[-]</label><label class="expand" for="c-37477780">[1 more]</label></div><br/><div class="children"><div class="content">I think if we also &quot;air-gap&quot; (loosely) the dependencies, we get a typical monorepo in, say, JS or Golang? That is, a module in a monorepo is a special case of your airgapped modules?</div><br/></div></div></div></div><div id="37477737" class="c"><input type="checkbox" id="c-37477737" checked=""/><div class="controls bullet"><span class="by">ddalex</span><span>|</span><a href="#37477361">parent</a><span>|</span><a href="#37477691">prev</a><span>|</span><a href="#37478101">next</a><span>|</span><label class="collapse" for="c-37477737">[-]</label><label class="expand" for="c-37477737">[1 more]</label></div><br/><div class="children"><div class="content">My go to page about this is <a href="http:&#x2F;&#x2F;widgetsandshit.com&#x2F;teddziuba&#x2F;2008&#x2F;04&#x2F;im-going-to-scale-my-foot-up-y.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;widgetsandshit.com&#x2F;teddziuba&#x2F;2008&#x2F;04&#x2F;im-going-to-scal...</a> which perfectly summarizes the problem AND solution</div><br/></div></div><div id="37478101" class="c"><input type="checkbox" id="c-37478101" checked=""/><div class="controls bullet"><span class="by">Shinchy</span><span>|</span><a href="#37477361">parent</a><span>|</span><a href="#37477737">prev</a><span>|</span><a href="#37478407">next</a><span>|</span><label class="collapse" for="c-37478101">[-]</label><label class="expand" for="c-37478101">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely agree, I&#x27;ve seen far too many companies spend far too much time working out the infrastructural relationships of microservices. Spending very little time working on the actual applications needs itself.</div><br/></div></div></div></div><div id="37478407" class="c"><input type="checkbox" id="c-37478407" checked=""/><div class="controls bullet"><span class="by">gehen88</span><span>|</span><a href="#37477361">prev</a><span>|</span><a href="#37477714">next</a><span>|</span><label class="collapse" for="c-37478407">[-]</label><label class="expand" for="c-37478407">[1 more]</label></div><br/><div class="children"><div class="content">Why this is getting blamed on JavaScript &#x2F; Node.js is beyond me. Microservices were&#x2F;are all the rage in Java&#x2F;Scala land, and seemed to initially be pushed by (Dev)Ops engineers&#x27; desire to roll their own Kubernetes cluster (or whatever came before). I&#x27;ve been on multiple such project and I always loathed the additional complexity (especially combined with actors&#x2F;event sourcing and Cassandra). Node.js was limited to some frontend tooling that only ran locally or in CI.</div><br/></div></div><div id="37477714" class="c"><input type="checkbox" id="c-37477714" checked=""/><div class="controls bullet"><span class="by">bradhe</span><span>|</span><a href="#37478407">prev</a><span>|</span><a href="#37478343">next</a><span>|</span><label class="collapse" for="c-37477714">[-]</label><label class="expand" for="c-37477714">[14 more]</label></div><br/><div class="children"><div class="content">I work on a massive monolith that has about 800 contributors and its just as complex to add something as simple as a userâs birthday, just not all the complexity is technological. It requires âorganizational alignmentâ since youâre touching everyoneâs code.<p>There will be endless iterations on design and review. Sign off required by at least 2 architects. It will get added to multiple planning iterations. The actual code will take an afternoon or less. Weâll have to ensure we hit out 90% test coverage during code review but because of all the tests, itâll be too big for one PR so it will need to be broken up into multiple PRs probably landing over multiple weekly releases. To facilitate that, weâll put it behind a feature flag (of which there are currently 13,000). Once it hits production, and the dashboards&#x2F;monitoring are put in place, it will get enabled and disabled over and over again as weâre not <i>totally</i> sure why our birthdate feature broke the metering service, but we think thatâs the root causeâneed to do a few weeks of analysis.<p>Then, finally, in a year the engineer who was tasked with it will get a good performance rating, maybe be up for a promo! Just in time for him to jump into another project thatâs failing horribly headed into its 3rd year in development: Allowing the user to set their timezone.</div><br/><div id="37478411" class="c"><input type="checkbox" id="c-37478411" checked=""/><div class="controls bullet"><span class="by">martypitt</span><span>|</span><a href="#37477714">parent</a><span>|</span><a href="#37478384">next</a><span>|</span><label class="collapse" for="c-37478411">[-]</label><label class="expand" for="c-37478411">[1 more]</label></div><br/><div class="children"><div class="content">I think this is a great point, and shouldn&#x27;t be just hand-waved away like you hit some bizarre edge case of Monoliths.<p>Monoliths can have crippling downsides -- just different flavours of downsides from Microservices. What you gain in network latency and DRYness, you can lose in Autonomy and Breadth of codebase.<p>Microservices vs Monoliths - just like everything else - is a question of tradeoffs, and making informed choices about when to apply them, and how to mitigate their downsides.<p>The slightly more nuanced point in the OP&#x27;s article is that adopting any engineering practice and blindly following as though your identity is linked to it, is a bad move. Mandalorion Dogma is rife in our trade, and everyone needs to chill TF out a bit.  (See also: JS vs TS hullabaloo)</div><br/></div></div><div id="37478384" class="c"><input type="checkbox" id="c-37478384" checked=""/><div class="controls bullet"><span class="by">srvaroa</span><span>|</span><a href="#37477714">parent</a><span>|</span><a href="#37478411">prev</a><span>|</span><a href="#37477846">next</a><span>|</span><label class="collapse" for="c-37478384">[-]</label><label class="expand" for="c-37478384">[1 more]</label></div><br/><div class="children"><div class="content">This comment shows IMO that the real issue here is not really microservices or not microservices, but what the article calls &quot;The apostles of the Church of Complexity&quot;.<p>Neither microservices or monolith are a golden hammer, silver bullet or whatever (nor the opposite). They are tools each with their tradeoffs, which combine with the many context-dependent tradeoffs of each organization. They are not the problem.<p>The problem is how organizations keep cargo-culting tools, architectural patterns, and so forth. Applying architectures, design patterns, whatever naively, based on the belief that usage alone will deliver benefits. It doesn&#x27;t.</div><br/></div></div><div id="37477846" class="c"><input type="checkbox" id="c-37477846" checked=""/><div class="controls bullet"><span class="by">ramraj07</span><span>|</span><a href="#37477714">parent</a><span>|</span><a href="#37478384">prev</a><span>|</span><a href="#37477899">next</a><span>|</span><label class="collapse" for="c-37477846">[-]</label><label class="expand" for="c-37477846">[1 more]</label></div><br/><div class="children"><div class="content">This sounds like you work at a place thatâll bungle any tech stack paradigm.</div><br/></div></div><div id="37477899" class="c"><input type="checkbox" id="c-37477899" checked=""/><div class="controls bullet"><span class="by">theshrike79</span><span>|</span><a href="#37477714">parent</a><span>|</span><a href="#37477846">prev</a><span>|</span><a href="#37478179">next</a><span>|</span><label class="collapse" for="c-37477899">[-]</label><label class="expand" for="c-37477899">[4 more]</label></div><br/><div class="children"><div class="content">Some people who advocate for huge monorepos, like Google has, tend to forget that Google has whole teams building tools just to wrangle the huge singular codebase for refactoring and testing.</div><br/><div id="37478012" class="c"><input type="checkbox" id="c-37478012" checked=""/><div class="controls bullet"><span class="by">bradhe</span><span>|</span><a href="#37477714">root</a><span>|</span><a href="#37477899">parent</a><span>|</span><a href="#37478179">next</a><span>|</span><label class="collapse" for="c-37478012">[-]</label><label class="expand" for="c-37478012">[3 more]</label></div><br/><div class="children"><div class="content">Bingo. Monorepos work because tooling makes it work. Just putting all your code in one place doesn&#x27;t make it a monorepo--just makes it a mess.</div><br/><div id="37478251" class="c"><input type="checkbox" id="c-37478251" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#37477714">root</a><span>|</span><a href="#37478012">parent</a><span>|</span><a href="#37478262">next</a><span>|</span><label class="collapse" for="c-37478251">[-]</label><label class="expand" for="c-37478251">[1 more]</label></div><br/><div class="children"><div class="content">It was a mess before, but the mess wasnât visible.  Now the code is all visible to the IDE, it all compiles together, and tests together.  You can see the mess and fix it.  Itâs possible to see enough of it to be able to change it and when you do the build stays green because you can make atomic changes.<p>Itâs less about why monorepos are good, and more about why on Earth would you split a product up over hard repo &#x2F; tooling boundaries.  Perhaps a Big Brain could get those boundaries right.  I canât,
so when I need to move the boundary I would rather it was done by editing code inside a repo than coordinating changes between micro products.<p>Iâm obviously describing one scenario.  What are the counter examples for where hard polyrepo boundaries are helpful?  When your team are all IC1s?</div><br/></div></div><div id="37478262" class="c"><input type="checkbox" id="c-37478262" checked=""/><div class="controls bullet"><span class="by">tm-guimaraes</span><span>|</span><a href="#37477714">root</a><span>|</span><a href="#37478012">parent</a><span>|</span><a href="#37478251">prev</a><span>|</span><a href="#37478179">next</a><span>|</span><label class="collapse" for="c-37478262">[-]</label><label class="expand" for="c-37478262">[1 more]</label></div><br/><div class="children"><div class="content">Bingo.<p>At $work i see lots of projects leaving the monorepo due to that very mess.<p>The problem is that services outside have other CI and maintenance issues that wouldnât happen in the monorepo. But monorepo got so messy that it got unbearable.<p>The proper solution would be to have a dev teams dedicated to tooling for it, the org has the resources, but itâs just not investing enough in that area.</div><br/></div></div></div></div></div></div><div id="37478179" class="c"><input type="checkbox" id="c-37478179" checked=""/><div class="controls bullet"><span class="by">camgunz</span><span>|</span><a href="#37477714">parent</a><span>|</span><a href="#37477899">prev</a><span>|</span><a href="#37478327">next</a><span>|</span><label class="collapse" for="c-37478179">[-]</label><label class="expand" for="c-37478179">[1 more]</label></div><br/><div class="children"><div class="content">It sounds like this company doesn&#x27;t have a competitive need to ship code changes, but when it does (i.e. a challenger appears or the moat disappears) it&#x27;ll be trouble.<p>I&#x27;ve tried--with varying levels of success--to really take to heart that software engineering is a never ending battle against complexity. You have to do it all the time and it has to be your paramount value, otherwise stuff like this happens. I don&#x27;t think there&#x27;s an architecture or ideology that ends the war; this is just the nature of the job.</div><br/></div></div><div id="37478327" class="c"><input type="checkbox" id="c-37478327" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#37477714">parent</a><span>|</span><a href="#37478179">prev</a><span>|</span><a href="#37477910">next</a><span>|</span><label class="collapse" for="c-37478327">[-]</label><label class="expand" for="c-37478327">[1 more]</label></div><br/><div class="children"><div class="content">Ugh that would make me hate software.</div><br/></div></div><div id="37477910" class="c"><input type="checkbox" id="c-37477910" checked=""/><div class="controls bullet"><span class="by">aledalgrande</span><span>|</span><a href="#37477714">parent</a><span>|</span><a href="#37478327">prev</a><span>|</span><a href="#37477892">next</a><span>|</span><label class="collapse" for="c-37477910">[-]</label><label class="expand" for="c-37477910">[2 more]</label></div><br/><div class="children"><div class="content">OMG this sounds painful ;) both in processes and state of the codebase<p>I can ship something in a couple of hours on a monolith where 3000+ engs work and deploy every day, but to be fair that&#x27;s not what I&#x27;ve seen in any other company I worked at.</div><br/><div id="37478076" class="c"><input type="checkbox" id="c-37478076" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#37477714">root</a><span>|</span><a href="#37477910">parent</a><span>|</span><a href="#37477892">next</a><span>|</span><label class="collapse" for="c-37478076">[-]</label><label class="expand" for="c-37478076">[1 more]</label></div><br/><div class="children"><div class="content">Where do you work at, and, are you hiring?</div><br/></div></div></div></div><div id="37477892" class="c"><input type="checkbox" id="c-37477892" checked=""/><div class="controls bullet"><span class="by">deterministic</span><span>|</span><a href="#37477714">parent</a><span>|</span><a href="#37477910">prev</a><span>|</span><a href="#37478343">next</a><span>|</span><label class="collapse" for="c-37477892">[-]</label><label class="expand" for="c-37477892">[2 more]</label></div><br/><div class="children"><div class="content">That sounds <i>crazy</i>. Imagine how much worse it would be if it was a microservices system!</div><br/><div id="37478069" class="c"><input type="checkbox" id="c-37478069" checked=""/><div class="controls bullet"><span class="by">scrlk</span><span>|</span><a href="#37477714">root</a><span>|</span><a href="#37477892">parent</a><span>|</span><a href="#37478343">next</a><span>|</span><label class="collapse" for="c-37478069">[-]</label><label class="expand" for="c-37478069">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Why is it so hard to display the birthday date on the settings page? Why can&#x27;t we get it done this quarter?&quot;<p>&quot;Look...I&#x27;m sorry, we&#x27;ve been over this, it&#x27;s the design of our backend.&quot;<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=y8OnoxKotPQ">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=y8OnoxKotPQ</a></div><br/></div></div></div></div></div></div><div id="37478343" class="c"><input type="checkbox" id="c-37478343" checked=""/><div class="controls bullet"><span class="by">ConcernedCoder</span><span>|</span><a href="#37477714">prev</a><span>|</span><a href="#37478387">next</a><span>|</span><label class="collapse" for="c-37478343">[-]</label><label class="expand" for="c-37478343">[1 more]</label></div><br/><div class="children"><div class="content">I find it weirdly theraputic to read things like this, and reminisce about loudly proclaiming the same a decade ago while being shushed as a non-believer...<p>Please excuse me if the paradigm of &quot;microservices&quot; has left a bad taste in my mouth, but I have real-world experience with the repercussions of whole-heartedly embracing the latest tech-dejour without completely understanding the tradeoffs...<p>Many years ago I was hired at stumbleupon around the time the leading compsci doctor decided to take a working and profitable monolithic php app and turn it into a scala&#x2F;java microservices architecture... in fact part of the newhire process was a weird one-on-one with said mad-compscientist where he extolled the many merits of microservices and skillfully dodged questions like &quot;why would you build a distributed service that just adds a list of numbers?&quot; with a bunch of &quot;you wouldn&#x27;t understand why it&#x27;s so much better...&quot; type hand-waving.  Fast-forward to 30+ new hires and 4+ long years of intense development and the no-longer profitable company was left with a new slower, buggier, impossible to debug distributed hellscape... as the main designer&#x2F;architect of it all decided it was a great time to take a &quot;sabbatical&quot;... it wasn&#x27;t long after that the Nth round of investor money ran out and we were all looking for work.</div><br/></div></div><div id="37478387" class="c"><input type="checkbox" id="c-37478387" checked=""/><div class="controls bullet"><span class="by">karles</span><span>|</span><a href="#37478343">prev</a><span>|</span><a href="#37477279">next</a><span>|</span><label class="collapse" for="c-37478387">[-]</label><label class="expand" for="c-37478387">[1 more]</label></div><br/><div class="children"><div class="content">Well, the idea of microservices would be to build some degree of flexibility into the setup, so that you can handle problems you don&#x27;t have now, but you might have later.<p>I understand that the Monolith - if done right - is a viable option as well.<p>As a consultant, our customers rarely know what they want, and they can&#x27;t really describe their vision, no matter how many workshops we throw at them. Microservices give us the opportunity to say &quot;We might not know this now, but with this architecture, we won&#x27;t be locked into a certain pattern or meet certain technical limitations by a monolithic approach&quot;.<p>It seems that what you are really paying for with microservices is flexibility and maneuverability &quot;down the line&quot;.<p>Solving only the problems you have &quot;here and now&quot; with the simplest solution will also lead to technical debt.</div><br/></div></div><div id="37477279" class="c"><input type="checkbox" id="c-37477279" checked=""/><div class="controls bullet"><span class="by">synack</span><span>|</span><a href="#37478387">prev</a><span>|</span><a href="#37477645">next</a><span>|</span><label class="collapse" for="c-37477279">[-]</label><label class="expand" for="c-37477279">[53 more]</label></div><br/><div class="children"><div class="content">Microservices are a solution to a social problem, not a technical one.<p>A team of N engineers requires NÂ² coordination. Large teams get mired in endless meetings, email, design reviews. Small teams are more effective, but struggle to maintain large systems.<p>Splitting a system into subsystems allows each team to focus on their piece of the puzzle while minimizing the amount of peer-to-peer coordination.<p>Yes, microservices add complexity and overhead, but this approach enables a large organization to build and iterate on large systems quickly.</div><br/><div id="37477335" class="c"><input type="checkbox" id="c-37477335" checked=""/><div class="controls bullet"><span class="by">brhsagain</span><span>|</span><a href="#37477279">parent</a><span>|</span><a href="#37477632">next</a><span>|</span><label class="collapse" for="c-37477335">[-]</label><label class="expand" for="c-37477335">[10 more]</label></div><br/><div class="children"><div class="content">&gt; Splitting a system into subsystems allows each team to focus on their piece of the puzzle while minimizing the amount of peer-to-peer coordination.<p>This does not happen at all. When you break a system into subsystems, all the previous connections that get remapped to new connections between subsystems still need to happen, in order to solve the fundamental problem that the system solves â except now instead of just making the connection directly, there has to be a &quot;cross-functional&quot; meeting between teams and a complicated communication layer between the systems. And if somehow you find a breakdown that requires minimal connections between subsystems, then those connections wouldn&#x27;t have existed in the original system either, and the NÂ² problem doesn&#x27;t exist.</div><br/><div id="37477729" class="c"><input type="checkbox" id="c-37477729" checked=""/><div class="controls bullet"><span class="by">devoutsalsa</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477335">parent</a><span>|</span><a href="#37477387">next</a><span>|</span><label class="collapse" for="c-37477729">[-]</label><label class="expand" for="c-37477729">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s all fun &amp; games until product wants to add a feature that doesn&#x27;t map cleanly to your micro servies architecture.  Then you end up hard coding you services into a macrolith.  Good times.</div><br/></div></div><div id="37477387" class="c"><input type="checkbox" id="c-37477387" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477335">parent</a><span>|</span><a href="#37477729">prev</a><span>|</span><a href="#37477437">next</a><span>|</span><label class="collapse" for="c-37477387">[-]</label><label class="expand" for="c-37477387">[2 more]</label></div><br/><div class="children"><div class="content">If that&#x27;s the experience then you&#x27;re doing services wrong.  Each service should have its own datastore and a single API.  The interface between services should be a single connection.<p>There should be maybe one meeting where the caller defines what they need the service to return to them.</div><br/><div id="37477802" class="c"><input type="checkbox" id="c-37477802" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477387">parent</a><span>|</span><a href="#37477437">next</a><span>|</span><label class="collapse" for="c-37477802">[-]</label><label class="expand" for="c-37477802">[1 more]</label></div><br/><div class="children"><div class="content">The problem with this is that you have to be <i>really</i> damned careful how you split things up. If your separate data stores end up having to be joined together later on because some new business feature requires them to be cross-referenced, you&#x27;re painted into one of two corners:<p>1. Merge the two services (and their data stores) into one and cause havoc downstream of either service<p>2. Burn through your network latency&#x2F;throughput budget trying to reinvent a DB join across RPC boundaries (and god forbid if you can&#x27;t batch multiple lookups in a single API call!)</div><br/></div></div></div></div><div id="37477437" class="c"><input type="checkbox" id="c-37477437" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477335">parent</a><span>|</span><a href="#37477387">prev</a><span>|</span><a href="#37477632">next</a><span>|</span><label class="collapse" for="c-37477437">[-]</label><label class="expand" for="c-37477437">[6 more]</label></div><br/><div class="children"><div class="content">&gt; there has to be a &quot;cross-functional&quot; meeting between teams and a complicated communication layer between the systems<p>Of all the things wrong with micro-services this isn&#x27;t one of them.<p>The &quot;complicated&quot; communication layer is always either REST&#x2F;JSON or GRPC.<p>Both of which are simple, easy to debug, proven and require nothing more than a simple discussion over an API contract.</div><br/><div id="37477522" class="c"><input type="checkbox" id="c-37477522" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477437">parent</a><span>|</span><a href="#37477632">next</a><span>|</span><label class="collapse" for="c-37477522">[-]</label><label class="expand" for="c-37477522">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Of all the things wrong with micro-services this isn&#x27;t one of them.<p>It is, exacerbated by the over-use.<p>&gt; The &quot;complicated&quot; communication layer is always either REST&#x2F;JSON or GRPC.<p>Going over network, which is slower, unreliable, poorly typed. It&#x27;s orders of magnitude more difficult to refactor a published REST API in comparison to e.g. Java interface within a monolith.<p>Microservices are generally far from easy to debug. In the best case scenario you have the whole stack locally and can put breakpoints, add logging immediately. But that happens rarely, debug port is often blocked (security), you can&#x27;t easily modify the code to add some diagnostics without a complex CI dance etc.</div><br/><div id="37477620" class="c"><input type="checkbox" id="c-37477620" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477522">parent</a><span>|</span><a href="#37477632">next</a><span>|</span><label class="collapse" for="c-37477620">[-]</label><label class="expand" for="c-37477620">[4 more]</label></div><br/><div class="children"><div class="content">Maybe you&#x27;ve only worked on small projects.<p>But I&#x27;ve never worked on a monolith project that I could run entirely locally.<p>And this idea that APIs are slow, unreliable and unable be to be strongly typed is nonsense. This is 2023. We have plenty of tooling and techniques to make this robust.</div><br/><div id="37477805" class="c"><input type="checkbox" id="c-37477805" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477620">parent</a><span>|</span><a href="#37477681">next</a><span>|</span><label class="collapse" for="c-37477805">[-]</label><label class="expand" for="c-37477805">[1 more]</label></div><br/><div class="children"><div class="content">The (monolith) product I currently work on has about 200 engineers working on it (backend + frontend + devops). I&#x27;d say it&#x27;s of medium size, certainly not small. And yes, we can run it locally easily. The monolith starts up in like 20 seconds which I consider quite acceptable.<p>There are few narrowly defined responsibilities which are handled by dedicated services, and it is often more awkward to get them working locally. But because they are so specialized, you need them only rarely.<p>&gt; And this idea that APIs are slow, unreliable and unable be to be strongly typed is nonsense.<p>Network APIs are inherently slower and more unreliable in comparison to an in-process method call. Some typing solutions are there, but they are way more awkward (and in some ways weaker) than statically typed monolith interfaces.</div><br/></div></div><div id="37477681" class="c"><input type="checkbox" id="c-37477681" checked=""/><div class="controls bullet"><span class="by">plugin-baby</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477620">parent</a><span>|</span><a href="#37477805">prev</a><span>|</span><a href="#37477907">next</a><span>|</span><label class="collapse" for="c-37477681">[-]</label><label class="expand" for="c-37477681">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve never worked on a monolith project that I could run entirely locally.<p>What are some examples of monolith components that couldnât be run locally?<p>Im guessing third-party integrations, but perhaps there are other things.</div><br/></div></div><div id="37477907" class="c"><input type="checkbox" id="c-37477907" checked=""/><div class="controls bullet"><span class="by">deterministic</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477620">parent</a><span>|</span><a href="#37477681">prev</a><span>|</span><a href="#37477632">next</a><span>|</span><label class="collapse" for="c-37477907">[-]</label><label class="expand" for="c-37477907">[1 more]</label></div><br/><div class="children"><div class="content">I work on very large monoliths all the time. The kind of code that runs international airlines and airports. I run it locally in a VM. No problem.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37477632" class="c"><input type="checkbox" id="c-37477632" checked=""/><div class="controls bullet"><span class="by">baobabKoodaa</span><span>|</span><a href="#37477279">parent</a><span>|</span><a href="#37477335">prev</a><span>|</span><a href="#37477673">next</a><span>|</span><label class="collapse" for="c-37477632">[-]</label><label class="expand" for="c-37477632">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never seen teams organized around microservices like that. What I&#x27;ve seen, again and again, is one huge team where &quot;everyone is responsible for all the microservices&quot; (meaning, no-one is responsible for anything).<p>On a theory level I would agree with you - I&#x27;ve just never seen that happen in practice.</div><br/><div id="37477998" class="c"><input type="checkbox" id="c-37477998" checked=""/><div class="controls bullet"><span class="by">misja111</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477632">parent</a><span>|</span><a href="#37477673">next</a><span>|</span><label class="collapse" for="c-37477998">[-]</label><label class="expand" for="c-37477998">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not that much of a supporter of microservices, but my experience is the opposite: in every company I&#x27;ve worked for that used microservices, each team had their own set of microservices they were responsible for.</div><br/></div></div></div></div><div id="37477673" class="c"><input type="checkbox" id="c-37477673" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#37477279">parent</a><span>|</span><a href="#37477632">prev</a><span>|</span><a href="#37477760">next</a><span>|</span><label class="collapse" for="c-37477673">[-]</label><label class="expand" for="c-37477673">[1 more]</label></div><br/><div class="children"><div class="content">People seem to forget they can create separate directories in their codebase.<p>They solve &quot;people problem&quot; by converting trivial technical problem into complex distributed system problem.<p>Well, now you have a _Problem_.</div><br/></div></div><div id="37477760" class="c"><input type="checkbox" id="c-37477760" checked=""/><div class="controls bullet"><span class="by">gscott</span><span>|</span><a href="#37477279">parent</a><span>|</span><a href="#37477673">prev</a><span>|</span><a href="#37477302">next</a><span>|</span><label class="collapse" for="c-37477760">[-]</label><label class="expand" for="c-37477760">[1 more]</label></div><br/><div class="children"><div class="content">Maybe a solution to an anti-social problem!<p>FT.com did a recorded seminar session on their microservices architecture and one of the benefits they extolled is if someone wanted to improve on a feature they could just make it all over again and replace the old microservice with a new one.  No need to look at the last persons code, just blow it away like it never existed.<p>I gathered their site is actually a black box filled with hundreds of black boxes of microservices.  All a mystery, they either work or they don&#x27;t and if they don&#x27;t they fail gracefully quickly.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=_qakAUjXiek">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=_qakAUjXiek</a></div><br/></div></div><div id="37477302" class="c"><input type="checkbox" id="c-37477302" checked=""/><div class="controls bullet"><span class="by">meowtimemania</span><span>|</span><a href="#37477279">parent</a><span>|</span><a href="#37477760">prev</a><span>|</span><a href="#37477351">next</a><span>|</span><label class="collapse" for="c-37477302">[-]</label><label class="expand" for="c-37477302">[13 more]</label></div><br/><div class="children"><div class="content">if you have a well modularized monolith, you can get best of both worlds.</div><br/><div id="37477569" class="c"><input type="checkbox" id="c-37477569" checked=""/><div class="controls bullet"><span class="by">croo</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477302">parent</a><span>|</span><a href="#37477349">next</a><span>|</span><label class="collapse" for="c-37477569">[-]</label><label class="expand" for="c-37477569">[1 more]</label></div><br/><div class="children"><div class="content">That is a big if that can be easily broken by a new guy who don&#x27;t know the rules or if the pace is fast enough that you cannot review everything.<p>If the codebase is different you can force the separation not just ask nicely to keep the code well modularized.</div><br/></div></div><div id="37477349" class="c"><input type="checkbox" id="c-37477349" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477302">parent</a><span>|</span><a href="#37477569">prev</a><span>|</span><a href="#37477327">next</a><span>|</span><label class="collapse" for="c-37477349">[-]</label><label class="expand" for="c-37477349">[10 more]</label></div><br/><div class="children"><div class="content">Not really.  You can&#x27;t really reduce the blast radius of crashes or bad deployments.  You need to have the discipline of a good CI&#x2F;CD instead of siloed but decoupled workflows.<p>Just keeping things neat doesn&#x27;t go nearly as far as a separate process on separate machines.  Monolith might be better but I don&#x27;t think it&#x27;s a situation where you can have it all.</div><br/><div id="37477403" class="c"><input type="checkbox" id="c-37477403" checked=""/><div class="controls bullet"><span class="by">aidos</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477349">parent</a><span>|</span><a href="#37477891">next</a><span>|</span><label class="collapse" for="c-37477403">[-]</label><label class="expand" for="c-37477403">[8 more]</label></div><br/><div class="children"><div class="content">This argument always confuses me. It depends on what youâre doing but if youâre doing web services, as most here are, the crash is limited to the request being served.<p>The blast radius is a single request, right?<p>In every likelihood it _is_ a separate process on a separate machine.</div><br/><div id="37477453" class="c"><input type="checkbox" id="c-37477453" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477403">parent</a><span>|</span><a href="#37477891">next</a><span>|</span><label class="collapse" for="c-37477453">[-]</label><label class="expand" for="c-37477453">[7 more]</label></div><br/><div class="children"><div class="content">They are talking about deployment.<p>With micro-services if you screw up a deployment the service is down and if your platform is well designed the system will be degraded but not down.<p>With a monolith the whole system is down.</div><br/><div id="37477521" class="c"><input type="checkbox" id="c-37477521" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477453">parent</a><span>|</span><a href="#37477555">next</a><span>|</span><label class="collapse" for="c-37477521">[-]</label><label class="expand" for="c-37477521">[1 more]</label></div><br/><div class="children"><div class="content">There are a lot of deployments options to mitigate that risk.</div><br/></div></div><div id="37477555" class="c"><input type="checkbox" id="c-37477555" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477453">parent</a><span>|</span><a href="#37477521">prev</a><span>|</span><a href="#37477891">next</a><span>|</span><label class="collapse" for="c-37477555">[-]</label><label class="expand" for="c-37477555">[5 more]</label></div><br/><div class="children"><div class="content">&gt;With a monolith the whole system is down.<p>No, you are just at reduced capacity.<p>The moral of the story is not to roll out to 100% right away.</div><br/><div id="37477601" class="c"><input type="checkbox" id="c-37477601" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477555">parent</a><span>|</span><a href="#37477891">next</a><span>|</span><label class="collapse" for="c-37477601">[-]</label><label class="expand" for="c-37477601">[4 more]</label></div><br/><div class="children"><div class="content">Monoliths go hand in hand with a centralised database.<p>Bit hard to do schema evolution with a staggered rollout.</div><br/><div id="37477931" class="c"><input type="checkbox" id="c-37477931" checked=""/><div class="controls bullet"><span class="by">DougBTX</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477601">parent</a><span>|</span><a href="#37477989">next</a><span>|</span><label class="collapse" for="c-37477931">[-]</label><label class="expand" for="c-37477931">[1 more]</label></div><br/><div class="children"><div class="content">If schema migrations take non-zero time and you want zero-downtime deployments, then the both service versions need to be compatible with either the new schema or the old schema, regardless of service size.</div><br/></div></div><div id="37477989" class="c"><input type="checkbox" id="c-37477989" checked=""/><div class="controls bullet"><span class="by">ownagefool</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477601">parent</a><span>|</span><a href="#37477931">prev</a><span>|</span><a href="#37477650">next</a><span>|</span><label class="collapse" for="c-37477989">[-]</label><label class="expand" for="c-37477989">[1 more]</label></div><br/><div class="children"><div class="content">The same problem exists in microservoce land, only you now have a load of separate teams managing their own database, perhaps with different solutions.</div><br/></div></div><div id="37477650" class="c"><input type="checkbox" id="c-37477650" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477601">parent</a><span>|</span><a href="#37477989">prev</a><span>|</span><a href="#37477891">next</a><span>|</span><label class="collapse" for="c-37477650">[-]</label><label class="expand" for="c-37477650">[1 more]</label></div><br/><div class="children"><div class="content">The software should be compatible with both the old and new schema until all of your database servers have moved over to the new schema. All rollouts are going to be somewhat staggered even if you go straight to 100%.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37477891" class="c"><input type="checkbox" id="c-37477891" checked=""/><div class="controls bullet"><span class="by">DougBTX</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477349">parent</a><span>|</span><a href="#37477403">prev</a><span>|</span><a href="#37477327">next</a><span>|</span><label class="collapse" for="c-37477891">[-]</label><label class="expand" for="c-37477891">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You need to have the discipline of a good CI&#x2F;CD<p>Good CD is even more important if there are more services to deploy</div><br/></div></div></div></div><div id="37477327" class="c"><input type="checkbox" id="c-37477327" checked=""/><div class="controls bullet"><span class="by">synack</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477302">parent</a><span>|</span><a href="#37477349">prev</a><span>|</span><a href="#37477351">next</a><span>|</span><label class="collapse" for="c-37477327">[-]</label><label class="expand" for="c-37477327">[1 more]</label></div><br/><div class="children"><div class="content">Agreed! Software modules and libraries can achieve the same independence of subsystems without implying a network topology.</div><br/></div></div></div></div><div id="37477397" class="c"><input type="checkbox" id="c-37477397" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37477279">parent</a><span>|</span><a href="#37477351">prev</a><span>|</span><a href="#37477317">next</a><span>|</span><label class="collapse" for="c-37477397">[-]</label><label class="expand" for="c-37477397">[1 more]</label></div><br/><div class="children"><div class="content">Yep, I work in a large org that used to be a monolith (which means single DB really). Was a mess for the reasons you&#x27;d expect. Even our subteam of 10 needs to split things up more.</div><br/></div></div><div id="37477317" class="c"><input type="checkbox" id="c-37477317" checked=""/><div class="controls bullet"><span class="by">corethree</span><span>|</span><a href="#37477279">parent</a><span>|</span><a href="#37477397">prev</a><span>|</span><a href="#37477392">next</a><span>|</span><label class="collapse" for="c-37477317">[-]</label><label class="expand" for="c-37477317">[20 more]</label></div><br/><div class="children"><div class="content">Why do you have to split things into services?<p>How about moving things into different folders. Have you thought about that?<p>Why do you have to modularize it with a whole new repo, a whole new docker set up? Just use a folder bro.</div><br/><div id="37478363" class="c"><input type="checkbox" id="c-37478363" checked=""/><div class="controls bullet"><span class="by">nroms</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477317">parent</a><span>|</span><a href="#37477580">next</a><span>|</span><label class="collapse" for="c-37478363">[-]</label><label class="expand" for="c-37478363">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Just use a folder bro<p>This will be my new go-to response when discussing microservices</div><br/></div></div><div id="37477580" class="c"><input type="checkbox" id="c-37477580" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477317">parent</a><span>|</span><a href="#37478363">prev</a><span>|</span><a href="#37477334">next</a><span>|</span><label class="collapse" for="c-37477580">[-]</label><label class="expand" for="c-37477580">[5 more]</label></div><br/><div class="children"><div class="content">The problem microservices try (tried?) to solve isn&#x27;t about namespaces, it is about too tight coupling between code. Whether that tightly coupled code sits in a subdirectory or in a different repo doesn&#x27;t matter.<p>It <i>can</i> be benefitial to maintain well defined interfaces at boundaries between certain parts of your code. It can also produce a lot of work and add complexity. But beyond a certain scale adding systemic boundaries and honoring them isn&#x27;t something you should avoid.<p>Devs who do microservices just tend to go too far too early.</div><br/><div id="37477943" class="c"><input type="checkbox" id="c-37477943" checked=""/><div class="controls bullet"><span class="by">corethree</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477580">parent</a><span>|</span><a href="#37477334">next</a><span>|</span><label class="collapse" for="c-37477943">[-]</label><label class="expand" for="c-37477943">[4 more]</label></div><br/><div class="children"><div class="content">&gt;The problem microservices try (tried?) to solve isn&#x27;t about namespaces, it is about too tight coupling between code.<p>You can use folders to decouple code by making code private within that folder. Only publicize parts of the code with your languages version of exporting.<p>Or you can make it private behind an entire new repo and behind an entire service. Only publicize parts of the code through api interfaces like http and make everything 10x harder for the sake of decoupling code.</div><br/><div id="37478050" class="c"><input type="checkbox" id="c-37478050" checked=""/><div class="controls bullet"><span class="by">tored</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477943">parent</a><span>|</span><a href="#37478234">next</a><span>|</span><label class="collapse" for="c-37478050">[-]</label><label class="expand" for="c-37478050">[2 more]</label></div><br/><div class="children"><div class="content">Many languages misses that abstraction to make things private in a folder (namespace) hierarchy to outside consumers. This is something I like to see solution to (integrated with your IDE of choice)</div><br/><div id="37478183" class="c"><input type="checkbox" id="c-37478183" checked=""/><div class="controls bullet"><span class="by">corethree</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37478050">parent</a><span>|</span><a href="#37478234">next</a><span>|</span><label class="collapse" for="c-37478183">[-]</label><label class="expand" for="c-37478183">[1 more]</label></div><br/><div class="children"><div class="content">Python is the only one that I know of that does this. Additionally python uses private by convention: Just prefix the stuff with an underscore.</div><br/></div></div></div></div><div id="37478234" class="c"><input type="checkbox" id="c-37478234" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477943">parent</a><span>|</span><a href="#37478050">prev</a><span>|</span><a href="#37477334">next</a><span>|</span><label class="collapse" for="c-37478234">[-]</label><label class="expand" for="c-37478234">[1 more]</label></div><br/><div class="children"><div class="content">Sure there are tons of ways to decouple code. My point was however, that moving code into a folder doesn&#x27;t automatically solve that coupling issue.</div><br/></div></div></div></div></div></div><div id="37477334" class="c"><input type="checkbox" id="c-37477334" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477317">parent</a><span>|</span><a href="#37477580">prev</a><span>|</span><a href="#37477330">next</a><span>|</span><label class="collapse" for="c-37477334">[-]</label><label class="expand" for="c-37477334">[12 more]</label></div><br/><div class="children"><div class="content">Usually the most important designation of the separate system is that it uses a separate database. You only have immediate consistency within one service.</div><br/><div id="37477388" class="c"><input type="checkbox" id="c-37477388" checked=""/><div class="controls bullet"><span class="by">zmmmmm</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477334">parent</a><span>|</span><a href="#37477356">next</a><span>|</span><label class="collapse" for="c-37477388">[-]</label><label class="expand" for="c-37477388">[3 more]</label></div><br/><div class="children"><div class="content">which is the main step on the pathway to hell<p>At the point where you have to write an API call instead of simply joining to a table, you have introduced orders of magnitude more complexity, failure points, testing challenges, race conditions, coherency issues, code duplication etc into your system.<p>I don&#x27;t mind stateless microservices too much. This forms more of a hub and spoke model (many services talking to 1 database). But the minute you bring separate state into the equation it&#x27;s a chaos factory.</div><br/><div id="37477568" class="c"><input type="checkbox" id="c-37477568" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477388">parent</a><span>|</span><a href="#37477426">next</a><span>|</span><label class="collapse" for="c-37477568">[-]</label><label class="expand" for="c-37477568">[1 more]</label></div><br/><div class="children"><div class="content">Joining a table is nice until that table is owned by a separate team. Becomes either gridlock or constant breakage, performance can get precarious, and testing involves populating a whole fake DB vs just mocking a few RPCs.<p>I really like relational DBs. I&#x27;ll make a system rely heavily on complex joins. But I&#x27;d rather call some other team&#x27;s API than share DBs with them.</div><br/></div></div><div id="37477426" class="c"><input type="checkbox" id="c-37477426" checked=""/><div class="controls bullet"><span class="by">corethree</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477388">parent</a><span>|</span><a href="#37477568">prev</a><span>|</span><a href="#37477356">next</a><span>|</span><label class="collapse" for="c-37477426">[-]</label><label class="expand" for="c-37477426">[1 more]</label></div><br/><div class="children"><div class="content">Nah but there are real instances where you have to use a different database for performance profiles.<p>The biggest one in web is regular entity databases vs. timeseries databases designed for analytics.<p>For this case entity data is just synced to to time series database every so often. Not super chaotic. It does make sense to divide services along those lines.<p>Though I would argue a folder still works for the web app part.</div><br/></div></div></div></div><div id="37477356" class="c"><input type="checkbox" id="c-37477356" checked=""/><div class="controls bullet"><span class="by">aledalgrande</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477334">parent</a><span>|</span><a href="#37477388">prev</a><span>|</span><a href="#37477330">next</a><span>|</span><label class="collapse" for="c-37477356">[-]</label><label class="expand" for="c-37477356">[8 more]</label></div><br/><div class="children"><div class="content">lol good luck without centralized data</div><br/><div id="37477402" class="c"><input type="checkbox" id="c-37477402" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477356">parent</a><span>|</span><a href="#37477377">next</a><span>|</span><label class="collapse" for="c-37477402">[-]</label><label class="expand" for="c-37477402">[2 more]</label></div><br/><div class="children"><div class="content">If you have centralized data then you have broken the abstraction and are in for a world of hurt.  You shouldn&#x27;t need centralized data, just a service front door where that service is the master of that part of the data.</div><br/><div id="37477790" class="c"><input type="checkbox" id="c-37477790" checked=""/><div class="controls bullet"><span class="by">aledalgrande</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477402">parent</a><span>|</span><a href="#37477377">next</a><span>|</span><label class="collapse" for="c-37477790">[-]</label><label class="expand" for="c-37477790">[1 more]</label></div><br/><div class="children"><div class="content">So what are you gonna do when you need data migrations?<p>PS: I&#x27;m not saying using one DB with microservices, it&#x27;s still with the monolith</div><br/></div></div></div></div><div id="37477377" class="c"><input type="checkbox" id="c-37477377" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477356">parent</a><span>|</span><a href="#37477402">prev</a><span>|</span><a href="#37477469">next</a><span>|</span><label class="collapse" for="c-37477377">[-]</label><label class="expand" for="c-37477377">[3 more]</label></div><br/><div class="children"><div class="content">Each service is authoritative on its own data, and it works neatly. Any medium to large size system is going to have natural places to separate that, or else will buckle under complexity or even hardware constraints if you try to keep it all in one DB. I&#x27;ve seen it repeatedly.</div><br/><div id="37477443" class="c"><input type="checkbox" id="c-37477443" checked=""/><div class="controls bullet"><span class="by">corethree</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477377">parent</a><span>|</span><a href="#37477469">next</a><span>|</span><label class="collapse" for="c-37477443">[-]</label><label class="expand" for="c-37477443">[2 more]</label></div><br/><div class="children"><div class="content">Nah this doesn&#x27;t work out. Because requirements are so chaotic and modular design isn&#x27;t an axiomatic science things will for sure go wrong with the design both because you got the design wrong and because the requirements shifted to a point where another design was better.<p>You encapsulated data under one service and you find that it&#x27;s actually utilized much more in another service. This happens a lot.<p>The longer you can centralize your storage the better and easier everything is.</div><br/><div id="37477781" class="c"><input type="checkbox" id="c-37477781" checked=""/><div class="controls bullet"><span class="by">aledalgrande</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477443">parent</a><span>|</span><a href="#37477469">next</a><span>|</span><label class="collapse" for="c-37477781">[-]</label><label class="expand" for="c-37477781">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. And having more than one source of truth for your data complicates a lot of things.<p>Where I work we run a <i>massive</i> MySQL database that has a pretty simple sharding rule, so I don&#x27;t believe that you need to split the database even at scale.</div><br/></div></div></div></div></div></div><div id="37477469" class="c"><input type="checkbox" id="c-37477469" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477356">parent</a><span>|</span><a href="#37477377">prev</a><span>|</span><a href="#37477509">next</a><span>|</span><label class="collapse" for="c-37477469">[-]</label><label class="expand" for="c-37477469">[1 more]</label></div><br/><div class="children"><div class="content">You mean like having user authentication data in AD&#x2F;LDAP and everything else in an RDBMS.<p>Because this is the standard architecture you will find for most platforms.</div><br/></div></div><div id="37477509" class="c"><input type="checkbox" id="c-37477509" checked=""/><div class="controls bullet"><span class="by">gotimo</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477356">parent</a><span>|</span><a href="#37477469">prev</a><span>|</span><a href="#37477330">next</a><span>|</span><label class="collapse" for="c-37477509">[-]</label><label class="expand" for="c-37477509">[1 more]</label></div><br/><div class="children"><div class="content">inb4 the separate &quot;data consistency service&quot;</div><br/></div></div></div></div></div></div><div id="37477330" class="c"><input type="checkbox" id="c-37477330" checked=""/><div class="controls bullet"><span class="by">abhiyerra</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477317">parent</a><span>|</span><a href="#37477334">prev</a><span>|</span><a href="#37477392">next</a><span>|</span><label class="collapse" for="c-37477330">[-]</label><label class="expand" for="c-37477330">[1 more]</label></div><br/><div class="children"><div class="content">I found Django apps to be a good middle ground.</div><br/></div></div></div></div><div id="37477392" class="c"><input type="checkbox" id="c-37477392" checked=""/><div class="controls bullet"><span class="by">politelemon</span><span>|</span><a href="#37477279">parent</a><span>|</span><a href="#37477317">prev</a><span>|</span><a href="#37477722">next</a><span>|</span><label class="collapse" for="c-37477392">[-]</label><label class="expand" for="c-37477392">[2 more]</label></div><br/><div class="children"><div class="content">Shouldn&#x27;t it be n(n-1)&#x2F;2 coordination. Assuming you mean communication channels?</div><br/><div id="37478329" class="c"><input type="checkbox" id="c-37478329" checked=""/><div class="controls bullet"><span class="by">jjgreen</span><span>|</span><a href="#37477279">root</a><span>|</span><a href="#37477392">parent</a><span>|</span><a href="#37477722">next</a><span>|</span><label class="collapse" for="c-37478329">[-]</label><label class="expand" for="c-37478329">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d assumed the OP meant O(n^2), and n(n-1)&#x2F;2 = O(n^2)</div><br/></div></div></div></div><div id="37477722" class="c"><input type="checkbox" id="c-37477722" checked=""/><div class="controls bullet"><span class="by">chalcolithic</span><span>|</span><a href="#37477279">parent</a><span>|</span><a href="#37477392">prev</a><span>|</span><a href="#37477645">next</a><span>|</span><label class="collapse" for="c-37477722">[-]</label><label class="expand" for="c-37477722">[1 more]</label></div><br/><div class="children"><div class="content">I wonder why people ever see it differently?</div><br/></div></div></div></div><div id="37477645" class="c"><input type="checkbox" id="c-37477645" checked=""/><div class="controls bullet"><span class="by">mojuba</span><span>|</span><a href="#37477279">prev</a><span>|</span><a href="#37477990">next</a><span>|</span><label class="collapse" for="c-37477645">[-]</label><label class="expand" for="c-37477645">[6 more]</label></div><br/><div class="children"><div class="content">(God, how I love confirmation bias when it&#x27;s my own bias.)<p>I&#x27;ve been saying this for years, the microservices insanity it&#x27;s just an excuse for mediocre engineers to be in demand. It is fueled by mediocrity but it is also what keeps so many tech companies going.<p>There are simply not enough competent engineers who master UNIX and who can build beautiful minimalist systems like StackOverflow&#x27;s or a bunch of others&#x27; mentioned in this article. Therefore microservices as a smoke screen for mediocrity is here to stay, it&#x27;s not going away any time soon, especially considering that cloud providers like AWS promote  themselves via all possible channels and encourage the decision makers to take that route anyway.</div><br/><div id="37478342" class="c"><input type="checkbox" id="c-37478342" checked=""/><div class="controls bullet"><span class="by">danjac</span><span>|</span><a href="#37477645">parent</a><span>|</span><a href="#37477890">next</a><span>|</span><label class="collapse" for="c-37478342">[-]</label><label class="expand" for="c-37478342">[1 more]</label></div><br/><div class="children"><div class="content">While there are definitely developers who are enthusiastic about microservices for all the wrong reasons (e.g. it looks good on the resume) I think it&#x27;s more about how companies deal with complexity.<p>Companies don&#x27;t just ship their org chart, they ship all their dysfunction and historical baggage. A beautiful, well-architected platform from 5 years ago, with an efficient, thought-out data model and API and well-written and tested code, might be a total mess after 5 years of constant pivots from the CEO, last minute customer requests the sales team have pushed through, product managers doing their hydrant-meets-dog act of adding features nobody needed or asked for, and never enough people and time to do as good a job as the developers would like.<p>One day you wake up with a big pile of tech debt and fixing bugs and adding features takes way longer than it should, and microservices are that siren call that promises a solution that doesn&#x27;t involve burning the whole thing to the ground and starting over.</div><br/></div></div><div id="37477890" class="c"><input type="checkbox" id="c-37477890" checked=""/><div class="controls bullet"><span class="by">dan_mctree</span><span>|</span><a href="#37477645">parent</a><span>|</span><a href="#37478342">prev</a><span>|</span><a href="#37477712">next</a><span>|</span><label class="collapse" for="c-37477890">[-]</label><label class="expand" for="c-37477890">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know why but no one hires or listens to the architect who recommends sticking to safe monolithic-esque systems. If you&#x27;re not talking cloud and microservices and the newest unproven frameworks, you&#x27;re an old fogey who needs to get with the times. Even though those types of systems are rarely the most efficient, powerful or safe systems<p>I work for a company that builds software to be used internally by other business. We have like 200 people tops using it simultaneously with no usage spikes, a perfect environment for regular web servers as we&#x27;ll never have unexpected scaling issues, yet everyone is dying to go to the cloud. Why? I think it&#x27;s just because our management, programmers and even customers are convinced by cloud provider marketing that the cloud is cool</div><br/><div id="37478015" class="c"><input type="checkbox" id="c-37478015" checked=""/><div class="controls bullet"><span class="by">misja111</span><span>|</span><a href="#37477645">root</a><span>|</span><a href="#37477890">parent</a><span>|</span><a href="#37477712">next</a><span>|</span><label class="collapse" for="c-37478015">[-]</label><label class="expand" for="c-37478015">[1 more]</label></div><br/><div class="children"><div class="content">Architects that propose pragmatic and boring solutions are usually not hired. It&#x27;s the emperor&#x27;s new clothes, companies like the idea of an architect who comes with some revolutionary new concept that will lead to a breakthrough that finally will make everybody rich.
If they don&#x27;t understand the architect&#x27;s idea, so much the better because then it must be really state of the art.</div><br/></div></div></div></div><div id="37477712" class="c"><input type="checkbox" id="c-37477712" checked=""/><div class="controls bullet"><span class="by">Tade0</span><span>|</span><a href="#37477645">parent</a><span>|</span><a href="#37477890">prev</a><span>|</span><a href="#37477986">next</a><span>|</span><label class="collapse" for="c-37477712">[-]</label><label class="expand" for="c-37477712">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve been saying this for years, the microservices insanity it&#x27;s just an excuse for mediocre engineers to be in demand.<p>Or just inexperienced ones who want to pad their CVs.<p>I think we failed to educate the current generation on what&#x27;s important in this job.</div><br/></div></div><div id="37477986" class="c"><input type="checkbox" id="c-37477986" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#37477645">parent</a><span>|</span><a href="#37477712">prev</a><span>|</span><a href="#37477990">next</a><span>|</span><label class="collapse" for="c-37477986">[-]</label><label class="expand" for="c-37477986">[1 more]</label></div><br/><div class="children"><div class="content">Other senior in my team and I agree with you..<p>We are wasting 20+ people&#x27;s time because we were forced to rush into something that resulted in 5-6 different microservices where a monolith written by 6 competent engineers over 6 months would have sufficed.<p>What you describe regarding microservices and AWS is also a thing internally.............</div><br/></div></div></div></div><div id="37477990" class="c"><input type="checkbox" id="c-37477990" checked=""/><div class="controls bullet"><span class="by">switch007</span><span>|</span><a href="#37477645">prev</a><span>|</span><a href="#37477415">next</a><span>|</span><label class="collapse" for="c-37477990">[-]</label><label class="expand" for="c-37477990">[3 more]</label></div><br/><div class="children"><div class="content">A common pattern I&#x27;ve seen is:<p>- CTO&#x2F;VPs built&#x2F;helped build original monolith<p>- Nobody wants to tell the CTO that their code is shit (and&#x2F;or is from a different era and needs a complete overhaul), unrelated to that fact it&#x27;s a monolith. CTOs are too busy doing marketing&#x2F;getting funding to make a decision on microservices vs monotolith, so the newly-hired architects gets to call the shots<p>- Everyone cheers on microservices because it fits within the story of a fast growing, serious, technical company and nobody wants to be that lone dissenting opinion&#x2F;criticise the CTO.<p>Nobody is seriously and truthfully recommending microservices because they believe them to be the best trade off and superior choice. It&#x27;s because they like their job, they like hiring people, and it fits within the narrative.<p>And it just so happens during the massive overhaul that you get to rewrite a ton of code and improve it, while just calling it a migration to microservices<p>So it&#x27;s a way of not hurting the feelings of the CTO, going along with the crowd and a way of rewriting a ton of old bad code with an excuse supported by almost everyone</div><br/><div id="37478401" class="c"><input type="checkbox" id="c-37478401" checked=""/><div class="controls bullet"><span class="by">ConcernedCoder</span><span>|</span><a href="#37477990">parent</a><span>|</span><a href="#37478176">next</a><span>|</span><label class="collapse" for="c-37478401">[-]</label><label class="expand" for="c-37478401">[1 more]</label></div><br/><div class="children"><div class="content">you just described the last 5 years of stumbleupon...</div><br/></div></div><div id="37478176" class="c"><input type="checkbox" id="c-37478176" checked=""/><div class="controls bullet"><span class="by">hnarayanan</span><span>|</span><a href="#37477990">parent</a><span>|</span><a href="#37478401">prev</a><span>|</span><a href="#37477415">next</a><span>|</span><label class="collapse" for="c-37478176">[-]</label><label class="expand" for="c-37478176">[1 more]</label></div><br/><div class="children"><div class="content">Oh my goodness, I feel like youâve nailed it.</div><br/></div></div></div></div><div id="37477415" class="c"><input type="checkbox" id="c-37477415" checked=""/><div class="controls bullet"><span class="by">cfeduke</span><span>|</span><a href="#37477990">prev</a><span>|</span><a href="#37477240">next</a><span>|</span><label class="collapse" for="c-37477415">[-]</label><label class="expand" for="c-37477415">[3 more]</label></div><br/><div class="children"><div class="content">I feel this, working on a small team moving things to microservices. My primary problem is observability. It&#x27;s become a huge chore figuring what, exactly, is going wrong in production when something goes wrong. It&#x27;s not enough to tail the logs of some distributed application, I need to tail the logs of several distributed applications where there messages are interspersed with one another. I suppose when we get some way to visualize these traces - tooling - it&#x27;ll be okay. But, small team, limited human bandwidth, and we don&#x27;t have this tooling in place yet.<p>The monolith, in contrast, had NewRelic integrated years ago. There were performance problems with this monolith which have been mostly solved through indexes and a couple of materialized views. Trivial to figure out what is going wrong. The code may be old and full of race conditions, but solving problems isn&#x27;t difficult.<p>I dread dealing with multiple separate database instances each backing their own microservice when it comes time to upgrade those databases instances. I was hoping for a single database instance with multiple databases, but that particular architecture isn&#x27;t on the menu. :\</div><br/><div id="37477699" class="c"><input type="checkbox" id="c-37477699" checked=""/><div class="controls bullet"><span class="by">jskrablin</span><span>|</span><a href="#37477415">parent</a><span>|</span><a href="#37477559">next</a><span>|</span><label class="collapse" for="c-37477699">[-]</label><label class="expand" for="c-37477699">[1 more]</label></div><br/><div class="children"><div class="content">Take a look at the OTEL (Open Telemetry) tooling and libraries. Or Grafana stack&#x2F;offering with Prometheus, Tempo and Loki. Centralized logging and service calls&#x2F;code execution tracing is not exactly new. It is often an afterthought.. and then you get yourself is this kinds of unpleasant situations.<p>And since you didn&#x27;t implement correct tooling from the start, your team is even smaller and more limited... because you have little to zero idea on what your services are up to.<p>As per db instances... you upgrade them one by one. Unless there&#x27;s some really bad bugs present (security or otherwise) there&#x27;s no rush in upgrading stuff just because.</div><br/></div></div><div id="37477559" class="c"><input type="checkbox" id="c-37477559" checked=""/><div class="controls bullet"><span class="by">antonvs</span><span>|</span><a href="#37477415">parent</a><span>|</span><a href="#37477699">prev</a><span>|</span><a href="#37477240">next</a><span>|</span><label class="collapse" for="c-37477559">[-]</label><label class="expand" for="c-37477559">[1 more]</label></div><br/><div class="children"><div class="content">Are you not using cloud? Because the cloud providers provide centralized logging, so all you need to do is pass a request id between services and include that Iâd in log entries, and you can trace requests across services.</div><br/></div></div></div></div><div id="37477240" class="c"><input type="checkbox" id="c-37477240" checked=""/><div class="controls bullet"><span class="by">chronid</span><span>|</span><a href="#37477415">prev</a><span>|</span><a href="#37477786">next</a><span>|</span><label class="collapse" for="c-37477240">[-]</label><label class="expand" for="c-37477240">[2 more]</label></div><br/><div class="children"><div class="content">I have been fighting this in my current position, with some success with some teams and far less success with others (who are now fighting with the distributed monolith they have created). Ironically the ex-faanmg folks are all pro-monolith.<p>I think most people fail to realize microservices are what you get from an iterative process. You pull out of the monolith the things you need to scale eventually.<p>Microservices need plenty of basic infrastructure that you don&#x27;t want to mantain unless you need to. Most companies don&#x27;t have an adequate platform to support the pattern anyway.</div><br/></div></div><div id="37477786" class="c"><input type="checkbox" id="c-37477786" checked=""/><div class="controls bullet"><span class="by">knallfrosch</span><span>|</span><a href="#37477240">prev</a><span>|</span><a href="#37477924">next</a><span>|</span><label class="collapse" for="c-37477786">[-]</label><label class="expand" for="c-37477786">[4 more]</label></div><br/><div class="children"><div class="content">I feel that. At my shop, we have given up on debugging altogether, because the tooling simply doesn&#x27;t work.<p>To run one service on our local machine would require us to adapt the other 9 to run against this one. And god forbid you build a &quot;feature&quot; for the &quot;customer.&quot; Now you have to, of course, touch at least 2 services at the same time to move more data.
A breakpoint on one end is a timeout on the other.<p>So every developer is deploying release builds (no hot reload) on a local VM, inserting console.logs, System.PrintLines() and _loggers and then reading the disparate log files. Needless to say, I&#x27;m jumping ship.</div><br/><div id="37478356" class="c"><input type="checkbox" id="c-37478356" checked=""/><div class="controls bullet"><span class="by">angio</span><span>|</span><a href="#37477786">parent</a><span>|</span><a href="#37477834">next</a><span>|</span><label class="collapse" for="c-37478356">[-]</label><label class="expand" for="c-37478356">[1 more]</label></div><br/><div class="children"><div class="content">We use mirrord together with a staging environment to run specific services without the need to bring up the rest of the stack locally (we have ~5 services so it wouldn&#x27;t even be an issue).</div><br/></div></div><div id="37477834" class="c"><input type="checkbox" id="c-37477834" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37477786">parent</a><span>|</span><a href="#37478356">prev</a><span>|</span><a href="#37478127">next</a><span>|</span><label class="collapse" for="c-37477834">[-]</label><label class="expand" for="c-37477834">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like the third paragraph could at least be somewhat improved on by switching everything to structured logging and being able to point them all to a local aggregator.<p>Moving everything to distributed tracing would be even better, but thereâs a larger investment as the tracing metadata then has to be unified across the board to properly track requests.<p>Would likely help more with ops than with dev but should help nonetheless, even just getting proper spanning information can provide a lot of insight into a clusterfuck.<p>&gt; A breakpoint on one end is a timeout on the other.<p>No dev mode to increase or disable timeouts?</div><br/></div></div><div id="37478127" class="c"><input type="checkbox" id="c-37478127" checked=""/><div class="controls bullet"><span class="by">mrelectric</span><span>|</span><a href="#37477786">parent</a><span>|</span><a href="#37477834">prev</a><span>|</span><a href="#37477924">next</a><span>|</span><label class="collapse" for="c-37478127">[-]</label><label class="expand" for="c-37478127">[1 more]</label></div><br/><div class="children"><div class="content">Telepresence!</div><br/></div></div></div></div><div id="37477924" class="c"><input type="checkbox" id="c-37477924" checked=""/><div class="controls bullet"><span class="by">bcoughlan</span><span>|</span><a href="#37477786">prev</a><span>|</span><a href="#37477400">next</a><span>|</span><label class="collapse" for="c-37477924">[-]</label><label class="expand" for="c-37477924">[2 more]</label></div><br/><div class="children"><div class="content">Starting with a monolith is nearly always great advice. However, monoliths tend towards spaghetti because it&#x27;s too easy essentially to draw new lines on the architecture diagram by importing from anywhere.<p>To scale a monolith codebase without devolving into spaghetti you need to have a well defined layered structure for modules. The other aspect is being able to hide internal code to prevent it being imported by other modules.<p>I did a write-up a while ago about how we do this on my current project [1], and published the Maven enforcer rule and ArchUnit test example as an open source project [2].<p>[1] <a href="https:&#x2F;&#x2F;bcoughlan.github.io&#x2F;posts&#x2F;modulithic-architecture&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;bcoughlan.github.io&#x2F;posts&#x2F;modulithic-architecture&#x2F;</a>
[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;bcoughlan&#x2F;base-package-enforcer-rule&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;bcoughlan&#x2F;base-package-enforcer-rule&#x2F;</a> <a href="https:&#x2F;&#x2F;github.com&#x2F;bcoughlan&#x2F;base-package-enforcer-rule&#x2F;blob&#x2F;main&#x2F;ArchUnitExampleTest.java">https:&#x2F;&#x2F;github.com&#x2F;bcoughlan&#x2F;base-package-enforcer-rule&#x2F;blob...</a></div><br/></div></div><div id="37477400" class="c"><input type="checkbox" id="c-37477400" checked=""/><div class="controls bullet"><span class="by">ansmithz42</span><span>|</span><a href="#37477924">prev</a><span>|</span><a href="#37477231">next</a><span>|</span><label class="collapse" for="c-37477400">[-]</label><label class="expand" for="c-37477400">[2 more]</label></div><br/><div class="children"><div class="content">A post like this pops up every few months arguing one way or the other.
I have lived in absolute nightmare monolith systems with so much cyclic dependency that you couldn&#x27;t move without breaking something. So monolith isn&#x27;t the answer. I have also seen many instances where people have completely missed the underlying principles of microservices and have ended up with an equal nightmare. 
Neither is a hero or panacea, what matters is to understand what you are building and why and get the interfaces correct. Then understand the principles of different architectures before moving forward.
If you fail on this, you get predictably a nightmare. There is plenty of nightmare code sitting on this planet everywhere we look. My recommendation isn&#x27;t to vilify either architecture but to understand their strengths and weaknesses.</div><br/><div id="37477572" class="c"><input type="checkbox" id="c-37477572" checked=""/><div class="controls bullet"><span class="by">antonvs</span><span>|</span><a href="#37477400">parent</a><span>|</span><a href="#37477231">next</a><span>|</span><label class="collapse" for="c-37477572">[-]</label><label class="expand" for="c-37477572">[1 more]</label></div><br/><div class="children"><div class="content">I agree. Whatâs the answer to the question âmonolith or microserviceâ? The answer is âarchitectureâ.</div><br/></div></div></div></div><div id="37477231" class="c"><input type="checkbox" id="c-37477231" checked=""/><div class="controls bullet"><span class="by">Maxion</span><span>|</span><a href="#37477400">prev</a><span>|</span><a href="#37477341">next</a><span>|</span><label class="collapse" for="c-37477231">[-]</label><label class="expand" for="c-37477231">[15 more]</label></div><br/><div class="children"><div class="content">I am literally working on a project where the backend team consists of three coders, and the backend currently consists 33 microservices. Common tasks for this platform involves calling around 7+ microservices.<p>Thankfully I am working on the frontend side of things, but this is going to be hell when when we launch.</div><br/><div id="37477413" class="c"><input type="checkbox" id="c-37477413" checked=""/><div class="controls bullet"><span class="by">kgeist</span><span>|</span><a href="#37477231">parent</a><span>|</span><a href="#37477253">next</a><span>|</span><label class="collapse" for="c-37477413">[-]</label><label class="expand" for="c-37477413">[2 more]</label></div><br/><div class="children"><div class="content">One of our projects has ~15 backend engineers and ~30 microservices. It also requires a separate platform team. A k8s cluster with several nodes. It has incidents like every week because the whole thing is like a house of cards. A small feature requires changes in ~5 microservices and a lot of coordination between the teams. They always need to think about things like circuit breakers, timeouts, APIs (schema synchronization, versioning), event queues, distributed transactions, sagas, distributed locking, k8s configs, Git repository management, distributed tracing etc. etc.<p>On the other hand, there&#x27;s another project, which is a monolith. Around ~15 engineers. Incidents happen very rarely. The infrastructure is simple: just one beefy server without k8s (but there&#x27;s a standby replica of course), so the team often does maintenance of the server on their own instead of a separate SRE&#x2F;production team. The monolith is modular so it enjoys same advantages as microservices when it comes to module isolation etc. Highload functionality is moved to separate Go services only when needed (currently 2 or 3 satellite microservices). All changes happen in the same codebase so features are released faster and it&#x27;s easier to reason about.<p>I&#x27;m currently on the second project and whenever I attend architecture reviews of the first project, I&#x27;m shocked how overcomplicated the first project has become. A simple addition of a new object property can end up in 5-10 engineers arguing for hours whose microservices are affected and how they should best communicate.</div><br/><div id="37477864" class="c"><input type="checkbox" id="c-37477864" checked=""/><div class="controls bullet"><span class="by">f4c39012</span><span>|</span><a href="#37477231">root</a><span>|</span><a href="#37477413">parent</a><span>|</span><a href="#37477253">next</a><span>|</span><label class="collapse" for="c-37477864">[-]</label><label class="expand" for="c-37477864">[1 more]</label></div><br/><div class="children"><div class="content">Has the microservice + backend project team ever observed the monolith project team?</div><br/></div></div></div></div><div id="37477253" class="c"><input type="checkbox" id="c-37477253" checked=""/><div class="controls bullet"><span class="by">guideamigo_com</span><span>|</span><a href="#37477231">parent</a><span>|</span><a href="#37477413">prev</a><span>|</span><a href="#37477245">next</a><span>|</span><label class="collapse" for="c-37477253">[-]</label><label class="expand" for="c-37477253">[2 more]</label></div><br/><div class="children"><div class="content">I once saw 5 backend engineers, 100 AWS lambdas, and 30+ GitHub repos!
Awesome job security for everyone.</div><br/><div id="37477305" class="c"><input type="checkbox" id="c-37477305" checked=""/><div class="controls bullet"><span class="by">corethree</span><span>|</span><a href="#37477231">root</a><span>|</span><a href="#37477253">parent</a><span>|</span><a href="#37477245">next</a><span>|</span><label class="collapse" for="c-37477305">[-]</label><label class="expand" for="c-37477305">[1 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t even a joke. Technology in software development has been progressing horizontally. Nothing is improving but abstractions and patterns are changing constantly.<p>Engineers need something to talk about in their OKRs. One strategy is to refactor things into microservices.</div><br/></div></div></div></div><div id="37477245" class="c"><input type="checkbox" id="c-37477245" checked=""/><div class="controls bullet"><span class="by">ttyyzz</span><span>|</span><a href="#37477231">parent</a><span>|</span><a href="#37477253">prev</a><span>|</span><a href="#37477300">next</a><span>|</span><label class="collapse" for="c-37477245">[-]</label><label class="expand" for="c-37477245">[5 more]</label></div><br/><div class="children"><div class="content">Yup. Are you using grphql+federation?</div><br/><div id="37477904" class="c"><input type="checkbox" id="c-37477904" checked=""/><div class="controls bullet"><span class="by">Maxion</span><span>|</span><a href="#37477231">root</a><span>|</span><a href="#37477245">parent</a><span>|</span><a href="#37477344">next</a><span>|</span><label class="collapse" for="c-37477904">[-]</label><label class="expand" for="c-37477904">[2 more]</label></div><br/><div class="children"><div class="content">LOL no, we&#x27;re using websockets but doing REST-like requests over it. It&#x27;s fun!</div><br/><div id="37477939" class="c"><input type="checkbox" id="c-37477939" checked=""/><div class="controls bullet"><span class="by">ttyyzz</span><span>|</span><a href="#37477231">root</a><span>|</span><a href="#37477904">parent</a><span>|</span><a href="#37477344">next</a><span>|</span><label class="collapse" for="c-37477939">[-]</label><label class="expand" for="c-37477939">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like you&#x27;re making it hard for yourselves on purpose. May I ask why you (the team) chose this over other technology and what was the decision process at the start the project?</div><br/></div></div></div></div><div id="37477344" class="c"><input type="checkbox" id="c-37477344" checked=""/><div class="controls bullet"><span class="by">no_butterscotch</span><span>|</span><a href="#37477231">root</a><span>|</span><a href="#37477245">parent</a><span>|</span><a href="#37477904">prev</a><span>|</span><a href="#37477300">next</a><span>|</span><label class="collapse" for="c-37477344">[-]</label><label class="expand" for="c-37477344">[2 more]</label></div><br/><div class="children"><div class="content">Do you think GraphQL has contributed to more microservice driven development?</div><br/><div id="37477859" class="c"><input type="checkbox" id="c-37477859" checked=""/><div class="controls bullet"><span class="by">ttyyzz</span><span>|</span><a href="#37477231">root</a><span>|</span><a href="#37477344">parent</a><span>|</span><a href="#37477300">next</a><span>|</span><label class="collapse" for="c-37477859">[-]</label><label class="expand" for="c-37477859">[1 more]</label></div><br/><div class="children"><div class="content">Yes, not in a bad way. I love graphql to be honest. Federation (using Apollo) is awesome.</div><br/></div></div></div></div></div></div><div id="37477300" class="c"><input type="checkbox" id="c-37477300" checked=""/><div class="controls bullet"><span class="by">Freedom2</span><span>|</span><a href="#37477231">parent</a><span>|</span><a href="#37477245">prev</a><span>|</span><a href="#37477341">next</a><span>|</span><label class="collapse" for="c-37477300">[-]</label><label class="expand" for="c-37477300">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Thankfully I am working on the frontend side of things<p>Honestly, given the opinion of frontend on this forum, I&#x27;m surprised that you&#x27;re thankful! I am 100% certain everyone here would take any kind of backend work over the hype-driven mess that is frontend development.</div><br/><div id="37477373" class="c"><input type="checkbox" id="c-37477373" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#37477231">root</a><span>|</span><a href="#37477300">parent</a><span>|</span><a href="#37477923">next</a><span>|</span><label class="collapse" for="c-37477373">[-]</label><label class="expand" for="c-37477373">[1 more]</label></div><br/><div class="children"><div class="content">I moved from backend to frontend years ago, when &quot;hype-driven mess&quot; was a much more accurate description of the field than it is today. There&#x27;s simply many more interesting challenges in web application front-ends than backends, especially if you need spacial design- things where canvas or webgl excel.<p>Comparatively, there are far fewer backend positions available that are more than basic CRUD, even if it those CRUD operations are gussied up with a bunch of needless complexity juggling sources of truth across a bunch of different services.<p>There&#x27;s plenty of drudgery out there, and some interesting work in every field, but on the whole I personally have found frontend product development- product configurators for engineering &#x2F; manufacturing, network visualization, visual design tool development, and data driven interfaces to be more fulfilling work.<p>To each their own, but maybe you might want to be a little more aware of the people that you work with when you feel like saying something condescending.<p>Edit: FWIW, you&#x27;d have to be blind to not see hype driven development in backend, especially in HN. &quot;Rewrite it in rust&quot; is the meme that continues to keep on giving.</div><br/></div></div><div id="37477923" class="c"><input type="checkbox" id="c-37477923" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#37477231">root</a><span>|</span><a href="#37477300">parent</a><span>|</span><a href="#37477373">prev</a><span>|</span><a href="#37477543">next</a><span>|</span><label class="collapse" for="c-37477923">[-]</label><label class="expand" for="c-37477923">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  I am 100% certain everyone here would take any kind of backend work over the hype-driven mess that is frontend development<p>The back-end is becoming an even more hype-driven mess these days. What with k8s and dozens of micro-services and controllers and telemetry-everything. And people don&#x27;t even listen nowadays if you try to propose something simpler.<p>The front-end is at-least constrained by browser limitations and the client device. One can only do hanky-panky upto to a point. But at the backend, &quot;throw another cloud machine&quot; at it has become the de-facto solution for most performance issues.</div><br/></div></div><div id="37477543" class="c"><input type="checkbox" id="c-37477543" checked=""/><div class="controls bullet"><span class="by">gherkinnn</span><span>|</span><a href="#37477231">root</a><span>|</span><a href="#37477300">parent</a><span>|</span><a href="#37477923">prev</a><span>|</span><a href="#37477341">next</a><span>|</span><label class="collapse" for="c-37477543">[-]</label><label class="expand" for="c-37477543">[2 more]</label></div><br/><div class="children"><div class="content">Isnât it obvious that it is all the same?<p>A dozen micro services per developer on rickety infrastructure serving data for a pixel generator built on top of 5 years worth of JS hype cycles. Why are we doing this to ourselves? It is just so stupid.</div><br/><div id="37477912" class="c"><input type="checkbox" id="c-37477912" checked=""/><div class="controls bullet"><span class="by">Maxion</span><span>|</span><a href="#37477231">root</a><span>|</span><a href="#37477543">parent</a><span>|</span><a href="#37477341">next</a><span>|</span><label class="collapse" for="c-37477912">[-]</label><label class="expand" for="c-37477912">[1 more]</label></div><br/><div class="children"><div class="content">We all gotta pay the mortgage somehow!</div><br/></div></div></div></div></div></div></div></div><div id="37477341" class="c"><input type="checkbox" id="c-37477341" checked=""/><div class="controls bullet"><span class="by">CraigJPerry</span><span>|</span><a href="#37477231">prev</a><span>|</span><a href="#37477925">next</a><span>|</span><label class="collapse" for="c-37477341">[-]</label><label class="expand" for="c-37477341">[2 more]</label></div><br/><div class="children"><div class="content">This article is off the rails (to borrow the authors amtrak metaphor).<p>The author posits that if you make pile of crap microservices then all you had to do instead was make a monolith and magically itâll all be fine.<p>You can put the same kind of design and engineering work in that results in a pile of crap microservices but if you target a monolith instead then youâll be golden.<p>The author enjoys stroking his own ego as he goes (the comment about full stack js devs for example). And yet, thereâs very little here in terms of actual engineering. Want some measurements or some data to back up the waffle? Well the author says tough! You just get a diatribe instead.<p>Keeping the cost to change a system low by managing complexity is a fine goal, but thatâs not whatâs being proposed here. This article could have been better if it recognised this. This article could have been better if it gave some data - hell even anecdata, a single motivating example, would have been a start.<p>On my team, Iâll take on a bright enthusiastic front end dev who decided they want to spread their wings and grow into a full stack dev over someone who believes they already know everything and has no growing left to do.</div><br/><div id="37477777" class="c"><input type="checkbox" id="c-37477777" checked=""/><div class="controls bullet"><span class="by">bradhe</span><span>|</span><a href="#37477341">parent</a><span>|</span><a href="#37477925">next</a><span>|</span><label class="collapse" for="c-37477777">[-]</label><label class="expand" for="c-37477777">[1 more]</label></div><br/><div class="children"><div class="content">Agreed the dichotomy presented is so reductive that it makes you question the authorâs credibility. Any architecture that isnât well maintained will become crushing over time.<p>Ask me how I know.</div><br/></div></div></div></div><div id="37477925" class="c"><input type="checkbox" id="c-37477925" checked=""/><div class="controls bullet"><span class="by">Sohcahtoa82</span><span>|</span><a href="#37477341">prev</a><span>|</span><a href="#37477460">next</a><span>|</span><label class="collapse" for="c-37477925">[-]</label><label class="expand" for="c-37477925">[1 more]</label></div><br/><div class="children"><div class="content">I have two huge gripes that I&#x27;ve run into when dealing with microservices:<p>1. They&#x27;re actually <i>nano</i>services.  The article touched on this.  A single function shouldn&#x27;t be its own service unless it&#x27;s something that requires a lot of processing, like a service that converts files from one type to another.  But something like handling user registration?  You don&#x27;t need separate services to handle registration, login, and the forgot password flow.<p>2. The services are poorly named.  At a previous job, we had services with names like &quot;Kafka&quot;, &quot;Avatar&quot;, and &quot;Sophos&quot; and none made sense for what they did, especially Kafka, which I expected to maybe be a wrapper around Apache Kafka?  But no.  It should have been called the User Preference Service, because it was simply a service for users to get&#x2F;set their preferences.</div><br/></div></div><div id="37477460" class="c"><input type="checkbox" id="c-37477460" checked=""/><div class="controls bullet"><span class="by">bryanph_</span><span>|</span><a href="#37477925">prev</a><span>|</span><a href="#37477996">next</a><span>|</span><label class="collapse" for="c-37477460">[-]</label><label class="expand" for="c-37477460">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t quite understand the mentioning of node at the start of the article as a cause of this. You can write a monolith in node just as well as you can write a web of microservices. That said I agree with the sentiment of this article, it&#x27;s very frustrating to deal with in any company. Especially when these microservices aren&#x27;t versioned under the same repo and&#x2F;or are hosted at different providers causing unnecessary latency.</div><br/><div id="37478118" class="c"><input type="checkbox" id="c-37478118" checked=""/><div class="controls bullet"><span class="by">weevil</span><span>|</span><a href="#37477460">parent</a><span>|</span><a href="#37477784">next</a><span>|</span><label class="collapse" for="c-37478118">[-]</label><label class="expand" for="c-37478118">[1 more]</label></div><br/><div class="children"><div class="content">They argue that Node tricks frontenders into thinking they can do server-side, then says they &#x27;huff and puff&#x27; when this is pointed out to them. It&#x27;s an incredibly patronizing argument to make.</div><br/></div></div><div id="37477784" class="c"><input type="checkbox" id="c-37477784" checked=""/><div class="controls bullet"><span class="by">bradhe</span><span>|</span><a href="#37477460">parent</a><span>|</span><a href="#37478118">prev</a><span>|</span><a href="#37477996">next</a><span>|</span><label class="collapse" for="c-37477784">[-]</label><label class="expand" for="c-37477784">[2 more]</label></div><br/><div class="children"><div class="content">Node is just the whipping boy for the old guys who are afraid of 2023. I say this as an old guy.</div><br/><div id="37477903" class="c"><input type="checkbox" id="c-37477903" checked=""/><div class="controls bullet"><span class="by">rahen</span><span>|</span><a href="#37477460">root</a><span>|</span><a href="#37477784">parent</a><span>|</span><a href="#37477996">next</a><span>|</span><label class="collapse" for="c-37477903">[-]</label><label class="expand" for="c-37477903">[1 more]</label></div><br/><div class="children"><div class="content">How would you sell Node to other old guys? Especially compared to Go.<p>I try to favor simple, efficient software. I used to dislike PHP because it was so messy and inefficient, until newer frameworks like Django made it look like it was slim and snappy.
Maybe, in this race to the bottom, Node stands out in a way I hadn&#x27;t seen, so I&#x27;m genuinely interested.</div><br/></div></div></div></div></div></div><div id="37477996" class="c"><input type="checkbox" id="c-37477996" checked=""/><div class="controls bullet"><span class="by">rawbert</span><span>|</span><a href="#37477460">prev</a><span>|</span><a href="#37477677">next</a><span>|</span><label class="collapse" for="c-37477996">[-]</label><label class="expand" for="c-37477996">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Micrsoservices are not DRY<p>Tell that my team mates putting all stuff into libraries because &quot;we made that already&quot; and building a huge distributed monolith. We combined sucessfully the worst of both worlds!</div><br/><div id="37478154" class="c"><input type="checkbox" id="c-37478154" checked=""/><div class="controls bullet"><span class="by">sjducb</span><span>|</span><a href="#37477996">parent</a><span>|</span><a href="#37477677">next</a><span>|</span><label class="collapse" for="c-37478154">[-]</label><label class="expand" for="c-37478154">[1 more]</label></div><br/><div class="children"><div class="content">Itâs the whole coupling vs DRY trade off. Coupling is worse than code duplication.</div><br/></div></div></div></div><div id="37477677" class="c"><input type="checkbox" id="c-37477677" checked=""/><div class="controls bullet"><span class="by">EMM_386</span><span>|</span><a href="#37477996">prev</a><span>|</span><a href="#37477906">next</a><span>|</span><label class="collapse" for="c-37477677">[-]</label><label class="expand" for="c-37477677">[1 more]</label></div><br/><div class="children"><div class="content">I was involved in a merger with the platform I architected on one side, and a platform that does the same thing on the other side.  We were told the company wanted one platform.<p>I do everything I can to follow KISS.  These are important enterprise systems that drive the entire company.  I went with a front-end framework in TypeScript, C# APIs, and a relational SQL DB as the gist of it.  It turned out great ... performant, reliable and the users were reporting positive feedback (this one was a recent upgrade from an older system).<p>The other side had the same number of users, but had over 100 PHP microservices, Docker containers, queuing frameworks, and all sorts of additional technologies in the mix.  It had 5 times the number of engineers on it, but was at the end of the day was functionally equivilant and had the same volume of traffic.<p>When comparing the up-time, it was clear the microservices architecture was the main source of pain.  They weren&#x27;t even comparable.  We are always talking about whether we&#x27;re at &quot;5 nines&quot;, and the other system was having major outages every other week.<p>You could argue that it was a poorly architected system, and that microservices weren&#x27;t the root cause, but that really wasn&#x27;t the case.  The entire system was based around the microservices, and they weren&#x27;t working as promised.  What originally was seen as separation of logic and concerns and everything else that microservices offer eventually over time became a tangled, inter-dependant system of services that were very high in bandwidth, slow in performance, difficult to maintain and bad in reliability.<p>This isn&#x27;t the first time I&#x27;ve seen this.  I&#x27;ve worked with microservice architectures in other companies, and I haven&#x27;t yet seen it &quot;done right&quot;, or at least how I understand it.  It always comes across as great in principle but bad in practice.</div><br/></div></div><div id="37477906" class="c"><input type="checkbox" id="c-37477906" checked=""/><div class="controls bullet"><span class="by">beaker52</span><span>|</span><a href="#37477677">prev</a><span>|</span><a href="#37478150">next</a><span>|</span><label class="collapse" for="c-37477906">[-]</label><label class="expand" for="c-37477906">[1 more]</label></div><br/><div class="children"><div class="content">Iâm currently at a place using microservices, in a monorepo, where business logic is executed in consuming services, and some business logic is in a monolithic graphql layer, that only frontend clients call. Tries all the tricks, fails at all of them.<p>Still, itâs a profitable business. The dirty truth is that the current crop of engineers are the ones paying with their blood, sweat and tears - and Iâm not sure about you, but thatâs not what I signed up for as a software engineer, so we should demand better.</div><br/></div></div><div id="37478150" class="c"><input type="checkbox" id="c-37478150" checked=""/><div class="controls bullet"><span class="by">weevil</span><span>|</span><a href="#37477906">prev</a><span>|</span><a href="#37477984">next</a><span>|</span><label class="collapse" for="c-37478150">[-]</label><label class="expand" for="c-37478150">[1 more]</label></div><br/><div class="children"><div class="content">This post reads like a cry for help. I don&#x27;t really know what they&#x27;re arguing for. Sure the broad-strokes &#x27;microservices bad monolith good&#x27; is something I can get behind in some cases, but the slightly unhinged tirades against Node developers and the &#x27;bloated farce&#x27; of the modern tech industry might as well be satire for all the value it contributes to debate.</div><br/></div></div><div id="37477984" class="c"><input type="checkbox" id="c-37477984" checked=""/><div class="controls bullet"><span class="by">simonhamp</span><span>|</span><a href="#37478150">prev</a><span>|</span><a href="#37477432">next</a><span>|</span><label class="collapse" for="c-37477984">[-]</label><label class="expand" for="c-37477984">[1 more]</label></div><br/><div class="children"><div class="content">One of the things this article alluded to (but I didn&#x27;t see it explicitly stated) as to why microservices is a default go-to architectural choice:<p>Because then a bunch of engineers can stick it on their rÃ©sumÃ© and try to get a job at a big company<p>I worked in a funded startup where we built a service-oriented architecture out of a few key Laravel monoliths. This was entirely manageable for a team of less than 10 engineers and scalable for the context.<p>Because we built it as a distributed system, each of those core services was ready to handle outages. So it was extremely easy to deploy<p>What&#x27;s more, it barely cost us $20k PER YEAR to run it all<p>But now I can&#x27;t say I&#x27;ve worked with microservices so I&#x27;ll likely not stand a chance at any of those interviews</div><br/></div></div><div id="37477432" class="c"><input type="checkbox" id="c-37477432" checked=""/><div class="controls bullet"><span class="by">molly0</span><span>|</span><a href="#37477984">prev</a><span>|</span><a href="#37477525">next</a><span>|</span><label class="collapse" for="c-37477432">[-]</label><label class="expand" for="c-37477432">[1 more]</label></div><br/><div class="children"><div class="content">Been working for 6 month at a company with ~150 engineers that uses Microservices.<p>As a simple software engineer I love it, It allowed me to easily get right in to parts of the system and conceptually understand the boundaries between different systems and business unites.<p>But it sure adds complexity - complexity that I fortunately do not need to deal with... Yet.</div><br/></div></div><div id="37477525" class="c"><input type="checkbox" id="c-37477525" checked=""/><div class="controls bullet"><span class="by">DrDroop</span><span>|</span><a href="#37477432">prev</a><span>|</span><a href="#37477660">next</a><span>|</span><label class="collapse" for="c-37477525">[-]</label><label class="expand" for="c-37477525">[2 more]</label></div><br/><div class="children"><div class="content">I also know people that spend 40k euro a month to run the database of their rails app on the biggest instance they can find on aws. The traffic is seasonal and the workload is mostly one way payment traffic. But hey, they are still making money so good for them. I&#x27;ve personally been exploring a more flexible architecture for another project using a combination of cloudflare workers, storage and k&#x2F;v store. The hardest thing about it currently is that you have to engineer everything yourself to be specific to your problem. Either way, both monolith and microservices have their challenges, I hope to find something that can avoid both but it feels like a stab in the dark.</div><br/><div id="37478134" class="c"><input type="checkbox" id="c-37478134" checked=""/><div class="controls bullet"><span class="by">sjducb</span><span>|</span><a href="#37477525">parent</a><span>|</span><a href="#37477660">next</a><span>|</span><label class="collapse" for="c-37478134">[-]</label><label class="expand" for="c-37478134">[1 more]</label></div><br/><div class="children"><div class="content">Iâve had contracting gigs bringing down the costs of SQL DBs that cost a million per year. You can usually get costs below 200k fairly easily.<p>- Performance tuning 
- Migrate old data out of the DB
- Delete unused indexes
- Improve queries so they return less unnecessary data<p>The problem is usually one massive table or 2-3 unoptimised queries.<p>No need to rewrite the application to use NoSQL<p>With seasonal load in AWS itâs really easy to change the DB instance size manually. No need for auto scaling.</div><br/></div></div></div></div><div id="37477660" class="c"><input type="checkbox" id="c-37477660" checked=""/><div class="controls bullet"><span class="by">hnpxr</span><span>|</span><a href="#37477525">prev</a><span>|</span><a href="#37477416">next</a><span>|</span><label class="collapse" for="c-37477660">[-]</label><label class="expand" for="c-37477660">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s nice to see the trend unwinding, microservices are egregiously overused as a silver bullet for any problem (not just scaling).<p>There are probably dozens (&#x2F;s) of companies that would benefit from going all-in with microservices. Some companies would benefit from having a few microservices; but most would be more than successful running a monolith.<p>The most significant problems with microservices arise when they&#x27;re adopted too early and when data separation is not properly handled, resulting of even the simplest requests ended up querying 3-5+ microservices.<p>Latest anecdata point: doing exactly that (unwinding microservices) in a team of 20 engineers (15 swe&#x2F;5 sre) and 400+ repositories (which isn&#x27;t a &quot;wrong&quot;, but having so many different places to update, for example, Python version is nuts). The whole project is nuts.<p>And persuading management was not an issue, it was enough to show current AWS bills and potential savings from moving from 50+ microservices to smaller numbers of consolidated services and deprecating&#x2F;refactoring some features. The real challenge was persuading the engineering team to prioritize and work on this issue - which is still ongoing.</div><br/></div></div><div id="37477416" class="c"><input type="checkbox" id="c-37477416" checked=""/><div class="controls bullet"><span class="by">mdtrooper</span><span>|</span><a href="#37477660">prev</a><span>|</span><a href="#37477223">next</a><span>|</span><label class="collapse" for="c-37477416">[-]</label><label class="expand" for="c-37477416">[1 more]</label></div><br/><div class="children"><div class="content">As other gifts of computers field: death by a thousand tables in DB, death by a thousand class in Java, death by a thousand tickets in Jira&#x2F;Redmine&#x2F;Bugtracker&#x2F;Gitlab..., death by a thousand &quot;go to&quot; in Basic...</div><br/></div></div><div id="37477223" class="c"><input type="checkbox" id="c-37477223" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#37477416">prev</a><span>|</span><a href="#37477257">next</a><span>|</span><label class="collapse" for="c-37477223">[-]</label><label class="expand" for="c-37477223">[5 more]</label></div><br/><div class="children"><div class="content">Microservices you trade application complexity for devops complexity.<p>My theory is to make devops as simple as possible and push complexity into application code.<p>This includes a rule to use cloud VMs but use the minimum possible cloud services, ideally none, especially not things like lambda&#x2F; cloud functions.</div><br/><div id="37477331" class="c"><input type="checkbox" id="c-37477331" checked=""/><div class="controls bullet"><span class="by">corethree</span><span>|</span><a href="#37477223">parent</a><span>|</span><a href="#37477372">next</a><span>|</span><label class="collapse" for="c-37477331">[-]</label><label class="expand" for="c-37477331">[3 more]</label></div><br/><div class="children"><div class="content">&gt;Microservices you trade application complexity for devops complexity.<p>There&#x27;s a second trade off. Overall complexity. The application as a whole is more complex when split into two than when existing as one.<p>So three things happen:<p>1. Complexity of the individual microservices goes down.<p>2. Dev ops complexity goes up.<p>3. Overall complexity of the entire system in general goes up.</div><br/><div id="37477700" class="c"><input type="checkbox" id="c-37477700" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#37477223">root</a><span>|</span><a href="#37477331">parent</a><span>|</span><a href="#37477395">next</a><span>|</span><label class="collapse" for="c-37477700">[-]</label><label class="expand" for="c-37477700">[1 more]</label></div><br/><div class="children"><div class="content">Yeah great point.<p>Then trying to work out where the problem is spans both DevOps and development and suddenly you are in a world of hurt.</div><br/></div></div><div id="37477395" class="c"><input type="checkbox" id="c-37477395" checked=""/><div class="controls bullet"><span class="by">aledalgrande</span><span>|</span><a href="#37477223">root</a><span>|</span><a href="#37477331">parent</a><span>|</span><a href="#37477700">prev</a><span>|</span><a href="#37477372">next</a><span>|</span><label class="collapse" for="c-37477395">[-]</label><label class="expand" for="c-37477395">[1 more]</label></div><br/><div class="children"><div class="content">Add data complexity to that (consistency)</div><br/></div></div></div></div><div id="37477372" class="c"><input type="checkbox" id="c-37477372" checked=""/><div class="controls bullet"><span class="by">hosh</span><span>|</span><a href="#37477223">parent</a><span>|</span><a href="#37477331">prev</a><span>|</span><a href="#37477257">next</a><span>|</span><label class="collapse" for="c-37477372">[-]</label><label class="expand" for="c-37477372">[1 more]</label></div><br/><div class="children"><div class="content">A lot of microservices introduce unnecessary complexity.<p>Erlang and Elixir are unusual in that you can have independent âmicroservicesâ running within a monolith.</div><br/></div></div></div></div><div id="37477257" class="c"><input type="checkbox" id="c-37477257" checked=""/><div class="controls bullet"><span class="by">EricDeb</span><span>|</span><a href="#37477223">prev</a><span>|</span><a href="#37478091">next</a><span>|</span><label class="collapse" for="c-37477257">[-]</label><label class="expand" for="c-37477257">[2 more]</label></div><br/><div class="children"><div class="content">As with a lot of things I find the answer is usually somewhere in the middle.  Break out larger chunks when it makes sense.</div><br/><div id="37477504" class="c"><input type="checkbox" id="c-37477504" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#37477257">parent</a><span>|</span><a href="#37478091">next</a><span>|</span><label class="collapse" for="c-37477504">[-]</label><label class="expand" for="c-37477504">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately in the middle where the answer is pragmatic and nuanced isn&#x27;t clickbait enough.</div><br/></div></div></div></div><div id="37478091" class="c"><input type="checkbox" id="c-37478091" checked=""/><div class="controls bullet"><span class="by">pulse7</span><span>|</span><a href="#37477257">prev</a><span>|</span><a href="#37478125">next</a><span>|</span><label class="collapse" for="c-37478091">[-]</label><label class="expand" for="c-37478091">[1 more]</label></div><br/><div class="children"><div class="content">Microservices are often used as an excuse to be able to write part of the system (=microservice) in own technology stack and not in the one the rest of the system is already written in...</div><br/></div></div><div id="37478125" class="c"><input type="checkbox" id="c-37478125" checked=""/><div class="controls bullet"><span class="by">CptKriechstrom</span><span>|</span><a href="#37478091">prev</a><span>|</span><label class="collapse" for="c-37478125">[-]</label><label class="expand" for="c-37478125">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get the hate about Microservices. Use Event Sourcing to eliminate the whole S2S Communication and gRPC to connect the Clients. Done.</div><br/></div></div></div></div></div></div></div></body></html>