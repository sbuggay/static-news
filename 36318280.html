<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1686733268785" as="style"/><link rel="stylesheet" href="styles.css?v=1686733268785"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html">Is Parallel Programming Hard, and, If So, What Can You Do About It? v2023.06.11a</a> <span class="domain">(<a href="https://mirrors.edge.kernel.org">mirrors.edge.kernel.org</a>)</span></div><div class="subtext"><span>nequo</span> | <span>4 comments</span></div><br/><div><div id="36323076" class="c"><input type="checkbox" id="c-36323076" checked=""/><div class="controls bullet"><span class="by">KeplerBoy</span><span>|</span><a href="#36322942">next</a><span>|</span><label class="collapse" for="c-36323076">[-]</label><label class="expand" for="c-36323076">[1 more]</label></div><br/><div class="children"><div class="content">I wish it included a big section on GPU programming.<p>Still a great read for people primary interested in GPGPU though, since a lot of knowledge transfers well.</div><br/></div></div><div id="36322942" class="c"><input type="checkbox" id="c-36322942" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#36323076">prev</a><span>|</span><label class="collapse" for="c-36322942">[-]</label><label class="expand" for="c-36322942">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for another thing I need to add to my reading list in addition to The Art of Multiprocessor Programming.<p>I am really interested in parallel, asynchronous, multithreading, coroutine, futures programming so it&#x27;s what I spend my days thinking about and blogging about it. I hope you sense my excitement in this comment about this topic. I&#x27;m looking for a programming model that parallelises easily and doesn&#x27;t require much effort, so this PDF seems relevant to me. I really should try be a user of languages like Erlang, Inko, Pony and Go but I am too interested in the mechanism of these languages!<p>I am also learning from Erlang and Go, nginx and LMAX disruptor.<p>I don&#x27;t focus on number crunching parallelisation, I let libraries and frameworks parallelise matrix multiplication such as BLAS. I&#x27;m interested in rote system parallelisation architecture. For example, PHP and nodejs is not a parallel language but how PHP is hosted in FastCGI processes means it can be executed multiple times by nginx so it is in effect parallel across requests. Unfortunately PHP and nodejs cannot create threads or use a thread pool within a request.<p>I want heavy CPU tasks of a request to not block other requests or the event loop and heavy IO requests to not block the event loop. I am a pre-beginner in Rust but I think you can use Rayon for CPU heavy tasks and Tokio for async IO parallelisation.<p>Here&#x27;s a system diagram that I&#x27;m thinking about lately:
<a href="https:&#x2F;&#x2F;github.com&#x2F;samsquire&#x2F;ideas5&#x2F;blob&#x2F;main&#x2F;NonblockingRuntime.drawio.png">https:&#x2F;&#x2F;github.com&#x2F;samsquire&#x2F;ideas5&#x2F;blob&#x2F;main&#x2F;NonblockingRun...</a><p>The design is that we have three groupings of thread types. The application starts up some application threads which are not associated with a request, these service multiconsumer multiproducer thread safe ringbuffers in lightweight threads with a Go-erlang-like lightweight process runtime. (My simple lightweight thread runtime is <a href="https:&#x2F;&#x2F;github.com&#x2F;samsquire&#x2F;preemptible-thread">https:&#x2F;&#x2F;github.com&#x2F;samsquire&#x2F;preemptible-thread</a>) We also multiplex multiple network clients sockets across a set number of kernel threads which I call control threads. Their responsibility is to dispatch work to a work stealing thread pool ASAP which has its own group of threads. So we pay a thread synchronization cost ONCE per IO which is the dispatch from the control thread to a thread pool thread. (Presumably this is fast, because the thread pool threads are all looping on a submission queue)<p>We split all IO and CPU tasks into two halves: submit and handle reply. I assume you can use liburing or epoll in the control threads. The same with CPU tasks and use ringbuffers to communicate between threads. We can always serve client&#x27;s requests because we&#x27;re never blocked on handling someone else&#x27;s request. The control thread is always unblocked.<p>I think this article is good regarding Python&#x27;s asyncio story:
<a href="https:&#x2F;&#x2F;charlesleifer.com&#x2F;blog&#x2F;asyncio&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;charlesleifer.com&#x2F;blog&#x2F;asyncio&#x2F;</a><p>I think the best multithreaded architecture is to never rely on synchronization, because it doesn&#x27;t scale. Try and separate your task so the work is more like a tree than a graph, so that you don&#x27;t need to communicate between branches. You can shard your data and work independently and merge at the end, similar to mapreduce.</div><br/><div id="36323053" class="c"><input type="checkbox" id="c-36323053" checked=""/><div class="controls bullet"><span class="by">admsmz</span><span>|</span><a href="#36322942">parent</a><span>|</span><label class="collapse" for="c-36323053">[-]</label><label class="expand" for="c-36323053">[1 more]</label></div><br/><div class="children"><div class="content">“Interaction nets” might be what you are looking for. I believe there were a couple of hackernews threads about it.</div><br/></div></div></div></div></div></div></div></div></div></body></html>