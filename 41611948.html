<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726995661575" as="style"/><link rel="stylesheet" href="styles.css?v=1726995661575"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://raymii.org/s/software/Logging_all_Cpp_destructors_poor_mans_run-time_tracing.html">Logging all C++ destructors, poor mans run-time tracing</a> <span class="domain">(<a href="https://raymii.org">raymii.org</a>)</span></div><div class="subtext"><span>jandeboevrie</span> | <span>27 comments</span></div><br/><div><div id="41613397" class="c"><input type="checkbox" id="c-41613397" checked=""/><div class="controls bullet"><span class="by">MontagFTB</span><span>|</span><a href="#41612934">next</a><span>|</span><label class="collapse" for="c-41613397">[-]</label><label class="expand" for="c-41613397">[11 more]</label></div><br/><div class="children"><div class="content">I consider Tracy the state of the art for profiling C++ applications.  It’s straightforward to integrate, toggle, gather data, analyze, and respond. It’s also open source, but rivals any product you’d have to pay for:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;wolfpld&#x2F;tracy">https:&#x2F;&#x2F;github.com&#x2F;wolfpld&#x2F;tracy</a></div><br/><div id="41613554" class="c"><input type="checkbox" id="c-41613554" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#41613397">parent</a><span>|</span><a href="#41614063">next</a><span>|</span><label class="collapse" for="c-41613554">[-]</label><label class="expand" for="c-41613554">[6 more]</label></div><br/><div class="children"><div class="content">Looks fine, but it does not look like there is a automatic full function entry&#x2F;exit trace, just sampling. The real benefit is when you do not even need to insert manual instrumentation points, you just hit run and you get a full system trace.<p>How well does the visualizer handle multi-TB traces? Usually pretty uncommon, but a 10-100 GB is not that hard to produce when doing full tracing.</div><br/><div id="41613845" class="c"><input type="checkbox" id="c-41613845" checked=""/><div class="controls bullet"><span class="by">jms55</span><span>|</span><a href="#41613397">root</a><span>|</span><a href="#41613554">parent</a><span>|</span><a href="#41614063">next</a><span>|</span><label class="collapse" for="c-41613845">[-]</label><label class="expand" for="c-41613845">[5 more]</label></div><br/><div class="children"><div class="content">Of note is that tracy is aimed at games, where sampling is often too expensive and not fine-grained enough. Hence the manual instrumenting.<p>For the Bevy game engine, we automatically insert tracy spans for each ECS system. In practice, users can just compile with the tracy feature enabled, and get a rough but very usable overview of which part of their game is taking a long time on the CPU.</div><br/><div id="41613910" class="c"><input type="checkbox" id="c-41613910" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#41613397">root</a><span>|</span><a href="#41613845">parent</a><span>|</span><a href="#41614063">next</a><span>|</span><label class="collapse" for="c-41613910">[-]</label><label class="expand" for="c-41613910">[4 more]</label></div><br/><div class="children"><div class="content">I was talking about automatic instrumentation of <i>every single function call</i> by default. No manual instrumentation needed because <i>everything</i> is already instrumented.<p>To be fair, you do still want some manual instrumentation to correlate higher level things, but full trace everywhere answers most questions. You also want to be able to manually suppress calls for small functions since that can be performance relevant or distorting, but the point is “default on, manual off” over “default off, manual on”.</div><br/><div id="41614335" class="c"><input type="checkbox" id="c-41614335" checked=""/><div class="controls bullet"><span class="by">andersa</span><span>|</span><a href="#41613397">root</a><span>|</span><a href="#41613910">parent</a><span>|</span><a href="#41615513">prev</a><span>|</span><a href="#41614063">next</a><span>|</span><label class="collapse" for="c-41614335">[-]</label><label class="expand" for="c-41614335">[2 more]</label></div><br/><div class="children"><div class="content">This would be unbelievably inefficient, game engines will be running hundreds of millions of functions per second. And if the code runs 10x slower with the trace active, then it&#x27;s no longer sensible.<p>We use sampling for the cases where this level of detail is needed as it has lower overhead.<p>What use case did you find this useful for?</div><br/><div id="41614419" class="c"><input type="checkbox" id="c-41614419" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#41613397">root</a><span>|</span><a href="#41614335">parent</a><span>|</span><a href="#41614063">next</a><span>|</span><label class="collapse" for="c-41614419">[-]</label><label class="expand" for="c-41614419">[1 more]</label></div><br/><div class="children"><div class="content">No, it is quite reasonable with efficient implementation. 10-50% overhead or so depending on function size distribution (since it is small fixed overhead per call, smaller functions result in a greater fraction of overhead). 10x for just function entry&#x2F;exit recording would be grotesquely inefficient. You can do inefficient time travel debugging recording for less than that.<p>You do need to allocate a ton of memory for the recording buffer to record sizable amounts of trace data. GB per core-second of trace or so (ring buffer so you get to see the last N seconds, not you need to run for less than N seconds) but that is fine during development on normal dev machines.<p>It is useful for everything. Why would you not want full traces for everything? It is amazing. We use it for everything internally where I work. Or rather, it is part of it. We actually prefer full time travel debugging during development and automated testing (again, overhead is low enough) but it is not available for everything. So sometimes we are stuck with just traces.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41614063" class="c"><input type="checkbox" id="c-41614063" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#41613397">parent</a><span>|</span><a href="#41613554">prev</a><span>|</span><a href="#41612934">next</a><span>|</span><label class="collapse" for="c-41614063">[-]</label><label class="expand" for="c-41614063">[4 more]</label></div><br/><div class="children"><div class="content">Alas, not for Linux. I&#x27;ve been using the unloved and mostly abandoned (and mostly awful) google perf tools on Linux. :-(</div><br/><div id="41614386" class="c"><input type="checkbox" id="c-41614386" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#41613397">root</a><span>|</span><a href="#41614063">parent</a><span>|</span><a href="#41614964">next</a><span>|</span><label class="collapse" for="c-41614386">[-]</label><label class="expand" for="c-41614386">[1 more]</label></div><br/><div class="children"><div class="content">Hmm? I haven&#x27;t used Tracy yet but the demo trace they show at the URL linked on GitHub[1] sure looks like a trace from an application running on Linux. The documentation[2] also seems to reference what you need to run it on Linux, and the NixOS derivation[3] also suggests it runs on at least Linux and macOS, and I was able to run several of the binaries including the UI and capture binary. I still hesitate to doubt you on this because I haven&#x27;t figured out how one is supposed to actually use it but it surely seems to support Linux. (I will definitely find a use for this, it looks amazing.)<p>[1]: <a href="https:&#x2F;&#x2F;tracy.nereid.pl&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tracy.nereid.pl&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;wolfpld&#x2F;tracy&#x2F;releases&#x2F;latest&#x2F;download&#x2F;tracy.pdf">https:&#x2F;&#x2F;github.com&#x2F;wolfpld&#x2F;tracy&#x2F;releases&#x2F;latest&#x2F;download&#x2F;tr...</a><p>[3]: <a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;blob&#x2F;nixos-24.05&#x2F;pkgs&#x2F;development&#x2F;tools&#x2F;tracy&#x2F;default.nix#L106">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;blob&#x2F;nixos-24.05&#x2F;pkgs&#x2F;devel...</a></div><br/></div></div><div id="41614964" class="c"><input type="checkbox" id="c-41614964" checked=""/><div class="controls bullet"><span class="by">dkersten</span><span>|</span><a href="#41613397">root</a><span>|</span><a href="#41614063">parent</a><span>|</span><a href="#41614386">prev</a><span>|</span><a href="#41614613">next</a><span>|</span><label class="collapse" for="c-41614964">[-]</label><label class="expand" for="c-41614964">[1 more]</label></div><br/><div class="children"><div class="content">I’ve used Tracy on Linux about two months ago. Works fine.</div><br/></div></div><div id="41614613" class="c"><input type="checkbox" id="c-41614613" checked=""/><div class="controls bullet"><span class="by">HellsMaddy</span><span>|</span><a href="#41613397">root</a><span>|</span><a href="#41614063">parent</a><span>|</span><a href="#41614964">prev</a><span>|</span><a href="#41612934">next</a><span>|</span><label class="collapse" for="c-41614613">[-]</label><label class="expand" for="c-41614613">[1 more]</label></div><br/><div class="children"><div class="content">Tracy works fine on Linux! Just used it today.</div><br/></div></div></div></div></div></div><div id="41612934" class="c"><input type="checkbox" id="c-41612934" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41613397">prev</a><span>|</span><a href="#41612809">next</a><span>|</span><label class="collapse" for="c-41612934">[-]</label><label class="expand" for="c-41612934">[1 more]</label></div><br/><div class="children"><div class="content">But what was the shutdown bug you were trying to identify?  Was this destructor logging actually useful?  The article teases the problem and provides detailed instructions for reproducing the logging, but doesn&#x27;t actually describe solving the problem.</div><br/></div></div><div id="41612809" class="c"><input type="checkbox" id="c-41612809" checked=""/><div class="controls bullet"><span class="by">jprete</span><span>|</span><a href="#41612934">prev</a><span>|</span><a href="#41614052">next</a><span>|</span><label class="collapse" for="c-41612809">[-]</label><label class="expand" for="c-41612809">[1 more]</label></div><br/><div class="children"><div class="content">Address&#x2F;MemorySanitizer are also meant for this kind of problem. <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;sanitizers&#x2F;wiki&#x2F;AddressSanitizer">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;sanitizers&#x2F;wiki&#x2F;AddressSanitizer</a> <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;sanitizers&#x2F;wiki&#x2F;MemorySanitizer">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;sanitizers&#x2F;wiki&#x2F;MemorySanitizer</a><p>Also valgrind, but I&#x27;m more familiar  with the first two.</div><br/></div></div><div id="41614052" class="c"><input type="checkbox" id="c-41614052" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#41612809">prev</a><span>|</span><a href="#41613261">next</a><span>|</span><label class="collapse" for="c-41614052">[-]</label><label class="expand" for="c-41614052">[1 more]</label></div><br/><div class="children"><div class="content">Just spent three days of debugging hell getting my app to shut down gracefully, so that it gracefully turns off all the things that it asynchronously turned on without performing use-after deletes). I can sympathise with that.</div><br/></div></div><div id="41613261" class="c"><input type="checkbox" id="c-41613261" checked=""/><div class="controls bullet"><span class="by">rqtwteye</span><span>|</span><a href="#41614052">prev</a><span>|</span><a href="#41612733">next</a><span>|</span><label class="collapse" for="c-41613261">[-]</label><label class="expand" for="c-41613261">[6 more]</label></div><br/><div class="children"><div class="content">I did this a long time ago with macros. It helped me to find a ton of leaks in a huge video codec codebase.<p>I still don&#x27;t understand the hate for the C preprocessor. It enables doing this like this without any overhead. Set a flag and you get constructor&#x2F;destructor logging and whatever else you want. Don&#x27;t set it and you get the regular behavior. Zero overhead.</div><br/><div id="41613296" class="c"><input type="checkbox" id="c-41613296" checked=""/><div class="controls bullet"><span class="by">jonathrg</span><span>|</span><a href="#41613261">parent</a><span>|</span><a href="#41613699">next</a><span>|</span><label class="collapse" for="c-41613296">[-]</label><label class="expand" for="c-41613296">[3 more]</label></div><br/><div class="children"><div class="content">The hate might have to do with it being such a primitive and blunt tool; doing anything moderately complex becomes extremely complicated and fragile.</div><br/><div id="41613439" class="c"><input type="checkbox" id="c-41613439" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41613261">root</a><span>|</span><a href="#41613296">parent</a><span>|</span><a href="#41615536">prev</a><span>|</span><a href="#41613699">next</a><span>|</span><label class="collapse" for="c-41613439">[-]</label><label class="expand" for="c-41613439">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, this very primitive tool easily creates the programming equivalent of the &quot;iwizard problem&quot;.<p>[You replace straight forwardly &quot;mage&quot; with &quot;wizard&quot; and oops, now your images are &quot;iwizards&quot; and your &quot;magenta&quot; is &quot;wizardnta&quot;]</div><br/></div></div></div></div><div id="41613699" class="c"><input type="checkbox" id="c-41613699" checked=""/><div class="controls bullet"><span class="by">synergy20</span><span>|</span><a href="#41613261">parent</a><span>|</span><a href="#41613296">prev</a><span>|</span><a href="#41612733">next</a><span>|</span><label class="collapse" for="c-41613699">[-]</label><label class="expand" for="c-41613699">[2 more]</label></div><br/><div class="children"><div class="content">do you have a write-up how you did it? I&#x27;m interested, thanks.</div><br/><div id="41614872" class="c"><input type="checkbox" id="c-41614872" checked=""/><div class="controls bullet"><span class="by">naruhodo</span><span>|</span><a href="#41613261">root</a><span>|</span><a href="#41613699">parent</a><span>|</span><a href="#41612733">next</a><span>|</span><label class="collapse" for="c-41614872">[-]</label><label class="expand" for="c-41614872">[1 more]</label></div><br/><div class="children"><div class="content">I did a similar thing, in C++, 3 decades ago. I used a macro, FUNC(), that I would put at the start of functions. It took no arguments and declared a local instance, using the __FUNC__ preprocessor builtin to pass the function name to the Trace constructor:<p><pre><code>    Trace trace##__LINE__(__FUNC__);
</code></pre>
The Trace instance would generate one log on construction and another on destruction. It also kept track of function call nesting (a counter) in a static member that would increment in the constructor and decrement in the destructor. It was inherently single-threaded, because I used a static member, but it could be adapted to multiple threads using thread local storage. I paired it with a LINE(&quot;Var x is &quot; &lt;&lt; x); macro for arbitrary ostreams-style logging. And building on that, EXPR(x) would do LINE(#x &quot; = &quot; &lt;&lt; (x)). The output was along the lines of:<p><pre><code>    ,- A::f()
    | ,- A::g()
    | | ,- B::B()
    | | `- B::~B()
    | | x = 12
    | | About to do a thing...
    | | ,- A::doAThing()
    | | `- A::doAThing()
    | `- A::g()
    `- A::f()
</code></pre>
The macros could be disabled (defined to do nothing) by a preprocessor symbol.</div><br/></div></div></div></div></div></div><div id="41612733" class="c"><input type="checkbox" id="c-41612733" checked=""/><div class="controls bullet"><span class="by">neverartful</span><span>|</span><a href="#41613261">prev</a><span>|</span><a href="#41614845">next</a><span>|</span><label class="collapse" for="c-41612733">[-]</label><label class="expand" for="c-41612733">[1 more]</label></div><br/><div class="children"><div class="content">I did something similar once but my implementation didn&#x27;t rely on any compiler features. I made tracing macros for constructors, destructors, and regular c++ methods. If the tracing was turned on in the macros, the information given to the macro (class name, method name, etc.) would be passed to the tracing manager. The tracing manager would serialize to a string and send it through a TCP socket. I also wrote a GUI tracing monitor that would listen on a socket for tracing messages and then display the trace messages received (including counts by class and method). The tracing monitor had filters to tweak. It was a nice tool to have and was very instrumental in finding memory leaks and obscure crashes. This was back in the late 1990s or early 2000s.</div><br/></div></div><div id="41614845" class="c"><input type="checkbox" id="c-41614845" checked=""/><div class="controls bullet"><span class="by">tempodox</span><span>|</span><a href="#41612733">prev</a><span>|</span><a href="#41612629">next</a><span>|</span><label class="collapse" for="c-41614845">[-]</label><label class="expand" for="c-41614845">[1 more]</label></div><br/><div class="children"><div class="content">Too bad, it doesn&#x27;t work like this on macOS.</div><br/></div></div><div id="41612629" class="c"><input type="checkbox" id="c-41612629" checked=""/><div class="controls bullet"><span class="by">meindnoch</span><span>|</span><a href="#41614845">prev</a><span>|</span><a href="#41613341">next</a><span>|</span><label class="collapse" for="c-41612629">[-]</label><label class="expand" for="c-41612629">[1 more]</label></div><br/><div class="children"><div class="content">And what was the bug in the end?</div><br/></div></div><div id="41613341" class="c"><input type="checkbox" id="c-41613341" checked=""/><div class="controls bullet"><span class="by">meisel</span><span>|</span><a href="#41612629">prev</a><span>|</span><a href="#41612992">next</a><span>|</span><label class="collapse" for="c-41613341">[-]</label><label class="expand" for="c-41613341">[2 more]</label></div><br/><div class="children"><div class="content">I’d say address sanitizer is a better starting point, and likely to show memory issues faster than this</div><br/><div id="41615355" class="c"><input type="checkbox" id="c-41615355" checked=""/><div class="controls bullet"><span class="by">tempodox</span><span>|</span><a href="#41613341">parent</a><span>|</span><a href="#41612992">next</a><span>|</span><label class="collapse" for="c-41615355">[-]</label><label class="expand" for="c-41615355">[1 more]</label></div><br/><div class="children"><div class="content">Yep, ASAN to find use-after-free, and valgrind memcheck to find forgotten-to-free.</div><br/></div></div></div></div></div></div></div></div></div></body></html>