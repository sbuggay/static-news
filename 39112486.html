<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706086859910" as="style"/><link rel="stylesheet" href="styles.css?v=1706086859910"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://kobzol.github.io/rust/cargo/2024/01/23/making-rust-binaries-smaller-by-default.html">Making Rust binaries smaller by default</a> <span class="domain">(<a href="https://kobzol.github.io">kobzol.github.io</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>48 comments</span></div><br/><div><div id="39114438" class="c"><input type="checkbox" id="c-39114438" checked=""/><div class="controls bullet"><span class="by">riquito</span><span>|</span><a href="#39114602">next</a><span>|</span><label class="collapse" for="c-39114438">[-]</label><label class="expand" for="c-39114438">[1 more]</label></div><br/><div class="children"><div class="content">My go to reference when I want to reduce rust binary size is the excellent <a href="https:&#x2F;&#x2F;github.com&#x2F;johnthagen&#x2F;min-sized-rust">https:&#x2F;&#x2F;github.com&#x2F;johnthagen&#x2F;min-sized-rust</a>, a set of guidelines on how to reduce size with explanations of the consequences</div><br/></div></div><div id="39114602" class="c"><input type="checkbox" id="c-39114602" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#39114438">prev</a><span>|</span><a href="#39114374">next</a><span>|</span><label class="collapse" for="c-39114602">[-]</label><label class="expand" for="c-39114602">[6 more]</label></div><br/><div class="children"><div class="content">So what&#x27;s in the remaining huge 415KB hello world program? Can we get rid of 90% of it a couple more times?</div><br/><div id="39114855" class="c"><input type="checkbox" id="c-39114855" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39114602">parent</a><span>|</span><a href="#39115157">next</a><span>|</span><label class="collapse" for="c-39114855">[-]</label><label class="expand" for="c-39114855">[3 more]</label></div><br/><div class="children"><div class="content">Buffered I&#x2F;O and synchronization primitives to avoid corrupting the buffer. The underlying vector implementation and memory allocator. Panic support and backtrace printer, which includes a Rust-specific name demangler and a not-so-small DWARF parser in Linux. Path support because backtraces would include source file paths. Zlib-compatible decompressor because ELF allows compressed sections (!). Then you have several formatters that are often pretty large (e.g. f32 and f64 would add at least 30 KB of binary, and some depend on Unicode grapheme clusters). They are all essential for edge cases that can happen even for such a simple program.</div><br/><div id="39114901" class="c"><input type="checkbox" id="c-39114901" checked=""/><div class="controls bullet"><span class="by">temac</span><span>|</span><a href="#39114602">root</a><span>|</span><a href="#39114855">parent</a><span>|</span><a href="#39115157">next</a><span>|</span><label class="collapse" for="c-39114901">[-]</label><label class="expand" for="c-39114901">[2 more]</label></div><br/><div class="children"><div class="content">Why does it need to parse elf ?</div><br/><div id="39114956" class="c"><input type="checkbox" id="c-39114956" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39114602">root</a><span>|</span><a href="#39114901">parent</a><span>|</span><a href="#39115157">next</a><span>|</span><label class="collapse" for="c-39114956">[-]</label><label class="expand" for="c-39114956">[1 more]</label></div><br/><div class="children"><div class="content">The stack frame is a list of return addresses which have to be translated to a file name and line number. Such debug information is within a specific ELF section in the predefined format. In this simple case you may be able to hard-code the offset to the section (and guarantee that it was never compressed), but any additional C or Rust library will break this assumption, so a general parser has to be included.</div><br/></div></div></div></div></div></div><div id="39115157" class="c"><input type="checkbox" id="c-39115157" checked=""/><div class="controls bullet"><span class="by">riquito</span><span>|</span><a href="#39114602">parent</a><span>|</span><a href="#39114855">prev</a><span>|</span><a href="#39114690">next</a><span>|</span><label class="collapse" for="c-39115157">[-]</label><label class="expand" for="c-39115157">[1 more]</label></div><br/><div class="children"><div class="content">32Kb with the following configuration, on a linux target. It&#x27;s not the default, you&#x27;re using nightly, it&#x27;s more complex to build and there are tradeoffs. You can even go less than that if that&#x27;s your thing<p><pre><code>  [profile.release]
  strip = true
  opt-level = &quot;z&quot;
  lto = true
  codegen-units = 1
  panic = &quot;abort&quot;
</code></pre>
cargo +nightly build -Z build-std=std,panic_abort -Z build-std-features=panic_immediate_abort --target x86_64-unknown-linux-gnu --release<p>As mentioned in another thread, I&#x27;ve simply followed <a href="https:&#x2F;&#x2F;github.com&#x2F;johnthagen&#x2F;min-sized-rust">https:&#x2F;&#x2F;github.com&#x2F;johnthagen&#x2F;min-sized-rust</a></div><br/></div></div><div id="39114690" class="c"><input type="checkbox" id="c-39114690" checked=""/><div class="controls bullet"><span class="by">kobzol</span><span>|</span><a href="#39114602">parent</a><span>|</span><a href="#39115157">prev</a><span>|</span><a href="#39114374">next</a><span>|</span><label class="collapse" for="c-39114690">[-]</label><label class="expand" for="c-39114690">[1 more]</label></div><br/><div class="children"><div class="content">Mostly the formatting machinery from stdlib. You can go sub 100 KiB or even less without it, but unless you target embedded, there&#x27;s really a reason to do that, IMO.</div><br/></div></div></div></div><div id="39114374" class="c"><input type="checkbox" id="c-39114374" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#39114602">prev</a><span>|</span><a href="#39114992">next</a><span>|</span><label class="collapse" for="c-39114374">[-]</label><label class="expand" for="c-39114374">[4 more]</label></div><br/><div class="children"><div class="content">Initial binary size, like of a hello world, is a great indicator of how much abstraction the language has that youre also paying for.<p>For example, java has to set up a constants pool, parse it from the classfile, run init and cinit, resolve references, allocatea a frame, and so on, just to get to the entrypoint.<p>Compared to C without stdlib which needs to basically just run a few bytes to syscall write().<p>There are obviously massive advantages to Java for which these steps are needed, but you do pay for it.</div><br/><div id="39115130" class="c"><input type="checkbox" id="c-39115130" checked=""/><div class="controls bullet"><span class="by">nindalf</span><span>|</span><a href="#39114374">parent</a><span>|</span><a href="#39114442">next</a><span>|</span><label class="collapse" for="c-39115130">[-]</label><label class="expand" for="c-39115130">[1 more]</label></div><br/><div class="children"><div class="content">It’s funny, because your claim that it’s a great indicator is contradicted by the article we’re discussing. Rust was widely considered to be “only pay for what you use” despite having 4MB hello world programs. And now that it’s 400KB that continues to be true. So in this case, 4MB wasn’t a good indicator was it?</div><br/></div></div><div id="39114442" class="c"><input type="checkbox" id="c-39114442" checked=""/><div class="controls bullet"><span class="by">frfl</span><span>|</span><a href="#39114374">parent</a><span>|</span><a href="#39115130">prev</a><span>|</span><a href="#39114992">next</a><span>|</span><label class="collapse" for="c-39114442">[-]</label><label class="expand" for="c-39114442">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not trying to be rude, but what does your comment have to do with the actual article linked. I suspect you&#x27;re commenting based solely on the title? If you read the article it mentions 90% reduction if you remove the debug symbols from the rust std lib that get bundled in the final hello world binary. A conversation about Java&#x27;s size and abstraction is quite irrelevant to the article.</div><br/><div id="39114455" class="c"><input type="checkbox" id="c-39114455" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#39114374">root</a><span>|</span><a href="#39114442">parent</a><span>|</span><a href="#39114992">next</a><span>|</span><label class="collapse" for="c-39114455">[-]</label><label class="expand" for="c-39114455">[1 more]</label></div><br/><div class="children"><div class="content">The article talks about how &quot;hello world&quot; binary size can be part of the first impression someone new to your language has.  Java is a nice illustration of that.  Rust probably isn&#x27;t, because many of Rust&#x27;s abstractions are zero-cost, so it&#x27;s not as obvious a comparison.</div><br/></div></div></div></div></div></div><div id="39114992" class="c"><input type="checkbox" id="c-39114992" checked=""/><div class="controls bullet"><span class="by">milianw</span><span>|</span><a href="#39114374">prev</a><span>|</span><a href="#39114817">next</a><span>|</span><label class="collapse" for="c-39114992">[-]</label><label class="expand" for="c-39114992">[3 more]</label></div><br/><div class="children"><div class="content">I applaud this initiative. yet I wonder - the ideal situation would be to not throw away the debug info (ever), but rather it should be put into an external file. even Linux supports this for many years and nowadays we even have direct support with dwarf5&#x2F;dwo. is trust taken any action towards that direction?<p>after all: without debug info (which you do not want to ship to customers necessarily), you cannot do profiling or debugging in any meaningful way...</div><br/><div id="39115042" class="c"><input type="checkbox" id="c-39115042" checked=""/><div class="controls bullet"><span class="by">emi2k01</span><span>|</span><a href="#39114992">parent</a><span>|</span><a href="#39114817">next</a><span>|</span><label class="collapse" for="c-39115042">[-]</label><label class="expand" for="c-39115042">[2 more]</label></div><br/><div class="children"><div class="content">Splitting the debug info from the executable is supported on the 3-big-OSes but only enabled by default on Windows (and maybe macOS?)</div><br/><div id="39115121" class="c"><input type="checkbox" id="c-39115121" checked=""/><div class="controls bullet"><span class="by">goku12</span><span>|</span><a href="#39114992">root</a><span>|</span><a href="#39115042">parent</a><span>|</span><a href="#39114817">next</a><span>|</span><label class="collapse" for="c-39115121">[-]</label><label class="expand" for="c-39115121">[1 more]</label></div><br/><div class="children"><div class="content">Many Linux distributions have debuginfod servers that supply split debugging symbols on demand. So one could argue that it&#x27;s implemented by default on Linux too.</div><br/></div></div></div></div></div></div><div id="39114817" class="c"><input type="checkbox" id="c-39114817" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#39114992">prev</a><span>|</span><a href="#39114406">next</a><span>|</span><label class="collapse" for="c-39114817">[-]</label><label class="expand" for="c-39114817">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;d be nice if the default was external symbols rather than none at all</div><br/></div></div><div id="39114406" class="c"><input type="checkbox" id="c-39114406" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#39114817">prev</a><span>|</span><a href="#39114553">next</a><span>|</span><label class="collapse" for="c-39114406">[-]</label><label class="expand" for="c-39114406">[2 more]</label></div><br/><div class="children"><div class="content">&gt; To reduce download bandwidth2, it does not come in two variants (with and without debug symbols), but only in the more general variant with debug symbols.<p>Why not instead only without?</div><br/><div id="39114435" class="c"><input type="checkbox" id="c-39114435" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#39114406">parent</a><span>|</span><a href="#39114553">next</a><span>|</span><label class="collapse" for="c-39114435">[-]</label><label class="expand" for="c-39114435">[1 more]</label></div><br/><div class="children"><div class="content">If you have them, but don&#x27;t want them, you can throw them out.  If you don&#x27;t have them, but want them (as does anyone who <i>doesn&#x27;t</i> build in release mode when developing), you&#x27;re out of luck.<p>Sure, you can rebuild the standard library, but it&#x27;s a lot simpler to strip the output than set things up so the first time you want debug symbols, it has to rebuild std, cache it somewhere, not rebuild it again on the next build, but be sure to invalidate that cache the next time std gets updated.<p>And in general, not wanting debug symbols is the <i>last</i> step in development, before making your first release.  Before then, you pretty much always want those debug symbols, except for when you&#x27;re benchmarking binary size or something.<p>So if they were going to ship std without debug symbols, they&#x27;d probably just be better off not shipping a prebuilt std at all, as pretty much everyone would end up having to build it on first run of &#x27;cargo build&#x27; anyway.  (Which is maybe fine, actually?)</div><br/></div></div></div></div><div id="39114553" class="c"><input type="checkbox" id="c-39114553" checked=""/><div class="controls bullet"><span class="by">mischief6</span><span>|</span><a href="#39114406">prev</a><span>|</span><a href="#39114677">next</a><span>|</span><label class="collapse" for="c-39114553">[-]</label><label class="expand" for="c-39114553">[3 more]</label></div><br/><div class="children"><div class="content">not a rust programmer. can someone explain why this is in the final binary and not in a shared library?</div><br/><div id="39114589" class="c"><input type="checkbox" id="c-39114589" checked=""/><div class="controls bullet"><span class="by">simonask</span><span>|</span><a href="#39114553">parent</a><span>|</span><a href="#39114677">next</a><span>|</span><label class="collapse" for="c-39114589">[-]</label><label class="expand" for="c-39114589">[2 more]</label></div><br/><div class="children"><div class="content">The Rust compiler statically links everything into a single binary. This can be changed, but is generally discouraged as there are no ABI stability guarantees at this point.</div><br/><div id="39114702" class="c"><input type="checkbox" id="c-39114702" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#39114553">root</a><span>|</span><a href="#39114589">parent</a><span>|</span><a href="#39114677">next</a><span>|</span><label class="collapse" for="c-39114702">[-]</label><label class="expand" for="c-39114702">[1 more]</label></div><br/><div class="children"><div class="content">You can use the C ABI if you want something stable, and there are custom crates that will help with translating from the Rust to the C ABI.  (This also helps because the resulting shared objects can potentially be FFI&#x27;d with from any language, not just Rust.  They might as well be plain C libraries as far as anyone is concerned, only with the usual Rust safety requirements.)</div><br/></div></div></div></div></div></div><div id="39114677" class="c"><input type="checkbox" id="c-39114677" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#39114553">prev</a><span>|</span><a href="#39114696">next</a><span>|</span><label class="collapse" for="c-39114677">[-]</label><label class="expand" for="c-39114677">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Even though the issue goes away with just a single strip invocation, it is still a problem in my view. Rust tries to appeal to programmers coming from many different backgrounds, and not everyone knows that something like stripping binaries even exists.&quot;</div><br/><div id="39114738" class="c"><input type="checkbox" id="c-39114738" checked=""/><div class="controls bullet"><span class="by">cybrox</span><span>|</span><a href="#39114677">parent</a><span>|</span><a href="#39114696">next</a><span>|</span><label class="collapse" for="c-39114738">[-]</label><label class="expand" for="c-39114738">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not ideally written but it&#x27;s safe to assume if someone compiles a quick test program for that purpose and it ends up being 4MB, they might just move on to other options instead of starting to think about how they can manually reduce the binary size.<p>When evaluating languages, you rarely look foor good enough results to work around.</div><br/></div></div></div></div><div id="39114696" class="c"><input type="checkbox" id="c-39114696" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#39114677">prev</a><span>|</span><a href="#39114241">next</a><span>|</span><label class="collapse" for="c-39114696">[-]</label><label class="expand" for="c-39114696">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s great to see rust maturing. That people care about binary size and work to improve it is a good sign.</div><br/><div id="39114812" class="c"><input type="checkbox" id="c-39114812" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#39114696">parent</a><span>|</span><a href="#39114241">next</a><span>|</span><label class="collapse" for="c-39114812">[-]</label><label class="expand" for="c-39114812">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a great sign that this bug existed for 7 years, people noticed, asked about it, wrote tickets, everybody agreed that it should be fixed but then nobody took the time to actually do it (and the eventual fix is a rather crude hack by just stripping the output binary instead of preventing that debug symbols slip into a release binary in the first place).<p>Looks more like a systemic issue in the Rust development process to me tbh.<p>What&#x27;s more shocking though is that even after a 90% size reduction, a vanilla hello world is still 415 KBytes. That&#x27;s about 10..100x bigger than I would expect from a low level &quot;systems programming language&quot;.</div><br/><div id="39114934" class="c"><input type="checkbox" id="c-39114934" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39114696">root</a><span>|</span><a href="#39114812">parent</a><span>|</span><a href="#39114987">next</a><span>|</span><label class="collapse" for="c-39114934">[-]</label><label class="expand" for="c-39114934">[1 more]</label></div><br/><div class="children"><div class="content">A vast majority of that 415 KB is due to the backtrace support, which is amazingly complicated. (See my other comment for specifics.) It will depend on some more machinaries from std, and a &quot;simple&quot; hello world can always panic if stdout is closed or so, therefore that part of std cannot be easily removed unless you are fine with useless backtraces.<p>Also, Rust has no direct platform support unlike C. So everything has to be statically linked to be portable. A statically linked glibc is indeed much larger than that (~800 KB in my machine). Conversely, you can sacrifice portability and link to `libstd*.so` dynamically to get a very small binary (~17 KB in my machine, both for C and Rust).</div><br/></div></div><div id="39114987" class="c"><input type="checkbox" id="c-39114987" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#39114696">root</a><span>|</span><a href="#39114812">parent</a><span>|</span><a href="#39114934">prev</a><span>|</span><a href="#39114241">next</a><span>|</span><label class="collapse" for="c-39114987">[-]</label><label class="expand" for="c-39114987">[2 more]</label></div><br/><div class="children"><div class="content">&gt; but then nobody took the time to actually do it<p>That happens all the time, it&#x27;s called prioritizing.  If you don&#x27;t let people prioritize, they will burn out and leave the project.  That&#x27;s not what you want.</div><br/><div id="39115133" class="c"><input type="checkbox" id="c-39115133" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#39114696">root</a><span>|</span><a href="#39114987">parent</a><span>|</span><a href="#39114241">next</a><span>|</span><label class="collapse" for="c-39115133">[-]</label><label class="expand" for="c-39115133">[1 more]</label></div><br/><div class="children"><div class="content">If people only pick &quot;interesting&quot; problems to work on and ignore fundamental (but boring) issues like this, then those issues will just pile up and frustration and burnout will grow even more in the long run. At some point you&#x27;ll have to stop feature development for a while and put all hands on cleaning up the accumulated cruft.</div><br/></div></div></div></div></div></div></div></div><div id="39114241" class="c"><input type="checkbox" id="c-39114241" checked=""/><div class="controls bullet"><span class="by">Humphrey</span><span>|</span><a href="#39114696">prev</a><span>|</span><a href="#39114448">next</a><span>|</span><label class="collapse" for="c-39114241">[-]</label><label class="expand" for="c-39114241">[12 more]</label></div><br/><div class="children"><div class="content">&gt; I can imagine a situation where a seasoned C or C++ programmer wants to try Rust, compiles a small program in release mode, notices the resulting binary size, and then immediately gives up on the language and goes to make fun of it on the forums.<p>While I&#x27;m not a seasoned C or C++ programmer I have definitely done this to a few new languages when playing around with them.  My thought was &quot;If helloworld.rust is this large, it&#x27;ll be huge once I&#x27;ve actually written more code&quot;.</div><br/><div id="39114391" class="c"><input type="checkbox" id="c-39114391" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#39114241">parent</a><span>|</span><a href="#39115131">next</a><span>|</span><label class="collapse" for="c-39114391">[-]</label><label class="expand" for="c-39114391">[4 more]</label></div><br/><div class="children"><div class="content">That’s almost never the case, though. Imagine if a C binary statically linked in libc. Adding a page full of more C to its code would only grow it a tiny amount.</div><br/><div id="39114573" class="c"><input type="checkbox" id="c-39114573" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#39114241">root</a><span>|</span><a href="#39114391">parent</a><span>|</span><a href="#39115131">next</a><span>|</span><label class="collapse" for="c-39114573">[-]</label><label class="expand" for="c-39114573">[3 more]</label></div><br/><div class="children"><div class="content">I would hope that it could statically link libc and exclude the unreachable portions.</div><br/><div id="39114633" class="c"><input type="checkbox" id="c-39114633" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#39114241">root</a><span>|</span><a href="#39114573">parent</a><span>|</span><a href="#39115131">next</a><span>|</span><label class="collapse" for="c-39114633">[-]</label><label class="expand" for="c-39114633">[2 more]</label></div><br/><div class="children"><div class="content">Rust can&#x27;t do this very well because it doesn&#x27;t <i>build</i> std as part of the project, that&#x27;s still an unstable option. It&#x27;s linking object code.</div><br/><div id="39115106" class="c"><input type="checkbox" id="c-39115106" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39114241">root</a><span>|</span><a href="#39114633">parent</a><span>|</span><a href="#39115131">next</a><span>|</span><label class="collapse" for="c-39115106">[-]</label><label class="expand" for="c-39115106">[1 more]</label></div><br/><div class="children"><div class="content">Link-time optimization should have been beneficial for this case... unless you absolutely needed quite a bit of `std` to print backtraces.</div><br/></div></div></div></div></div></div></div></div><div id="39115131" class="c"><input type="checkbox" id="c-39115131" checked=""/><div class="controls bullet"><span class="by">EasyMark</span><span>|</span><a href="#39114241">parent</a><span>|</span><a href="#39114391">prev</a><span>|</span><a href="#39114370">next</a><span>|</span><label class="collapse" for="c-39115131">[-]</label><label class="expand" for="c-39115131">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re really gonna panic when they deploy their first qt app then.</div><br/></div></div><div id="39114370" class="c"><input type="checkbox" id="c-39114370" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39114241">parent</a><span>|</span><a href="#39115131">prev</a><span>|</span><a href="#39115084">next</a><span>|</span><label class="collapse" for="c-39114370">[-]</label><label class="expand" for="c-39114370">[5 more]</label></div><br/><div class="children"><div class="content">Yup same. Also I hate the &quot;just strip it&quot; advice. I don&#x27;t know who on earth strips random binaries and has them actually work fine afterward 100% of the time. Stripping after linking frequently breaks binaries I try it on.</div><br/><div id="39114417" class="c"><input type="checkbox" id="c-39114417" checked=""/><div class="controls bullet"><span class="by">champtar</span><span>|</span><a href="#39114241">root</a><span>|</span><a href="#39114370">parent</a><span>|</span><a href="#39115084">next</a><span>|</span><label class="collapse" for="c-39114417">[-]</label><label class="expand" for="c-39114417">[4 more]</label></div><br/><div class="children"><div class="content">All binaries on a classic Linux distro are stripped (you can use &#x27;file&#x27; to quickly check some), so your issues might be worth reporting</div><br/><div id="39114444" class="c"><input type="checkbox" id="c-39114444" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39114241">root</a><span>|</span><a href="#39114417">parent</a><span>|</span><a href="#39115084">next</a><span>|</span><label class="collapse" for="c-39114444">[-]</label><label class="expand" for="c-39114444">[3 more]</label></div><br/><div class="children"><div class="content">Stripped via -s or via strip?</div><br/><div id="39114460" class="c"><input type="checkbox" id="c-39114460" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#39114241">root</a><span>|</span><a href="#39114444">parent</a><span>|</span><a href="#39115084">next</a><span>|</span><label class="collapse" for="c-39114460">[-]</label><label class="expand" for="c-39114460">[2 more]</label></div><br/><div class="children"><div class="content">I never understood why strip&#x27;s &quot;--strip-unneeded&quot; flag wasn&#x27;t the default.  Leaving that out can often enough give you a binary that just doesn&#x27;t work.</div><br/><div id="39114593" class="c"><input type="checkbox" id="c-39114593" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39114241">root</a><span>|</span><a href="#39114460">parent</a><span>|</span><a href="#39115084">next</a><span>|</span><label class="collapse" for="c-39114593">[-]</label><label class="expand" for="c-39114593">[1 more]</label></div><br/><div class="children"><div class="content">Yup that&#x27;s exactly what I mean. Nobody ever mentions that flag when recommending stripping, and it&#x27;s frustrating when you realize it&#x27;s broken. It&#x27;s been a few years, but even when I finally discovered and tried that flag, it still didn&#x27;t quite do the right thing. Either it failed to strip stuff that -s stripped, or it still produced a binary that didn&#x27;t work... I forget what exactly the issue was. I just remember failing to find an alternative to cc -s that was guaranteed to work.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>