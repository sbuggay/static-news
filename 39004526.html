<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705395658247" as="style"/><link rel="stylesheet" href="styles.css?v=1705395658247"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://cacm.acm.org/blogs/blog-cacm/279178-niklaus-wirth-or-the-importance-of-being-simple/fulltext">Niklaus Wirth, or the Importance of Being Simple</a>Â <span class="domain">(<a href="https://cacm.acm.org">cacm.acm.org</a>)</span></div><div class="subtext"><span>madmax108</span> | <span>33 comments</span></div><br/><div><div id="39010565" class="c"><input type="checkbox" id="c-39010565" checked=""/><div class="controls bullet"><span class="by">teleforce</span><span>|</span><a href="#39009550">next</a><span>|</span><label class="collapse" for="c-39010565">[-]</label><label class="expand" for="c-39010565">[4 more]</label></div><br/><div class="children"><div class="content">The litmus test for simplicity of a programming language design is its compilation speed, if the language compile fast it is simple but if the language compile slow it is overly complex. Modern programming languages like Go and D have fast compilation, but C++ and Rust compile much slower. Go is a direct descendent of Wirth&#x27;s languages namely Modula and Oberon, while D is not albeit some of its feature like nested function is directly taken from Pascal [1]. Interestingly both were designed by authors with engineering background, and personally I think the simplicity is not a coincident since typical engineers loath to embrace any form of complexity.<p>[1]Nested function:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Nested_function" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Nested_function</a></div><br/><div id="39010802" class="c"><input type="checkbox" id="c-39010802" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#39010565">parent</a><span>|</span><a href="#39010714">next</a><span>|</span><label class="collapse" for="c-39010802">[-]</label><label class="expand" for="c-39010802">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The litmus test for simplicity of a programming language design is its compilation speed, if the language compile fast it is simple but if the language compile slow it is overly complex<p>No. OCaml for example has a really fast compiler (like Go), but I would not call it simple. It does have PPX (PreProcessor Extensions) which are like macros, so you can&#x27;t &quot;blame&quot; the lack of them either.<p>And everything that uses LLVM is _always_ going to be _slow_, no matter the language.</div><br/><div id="39010870" class="c"><input type="checkbox" id="c-39010870" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39010565">root</a><span>|</span><a href="#39010802">parent</a><span>|</span><a href="#39010714">next</a><span>|</span><label class="collapse" for="c-39010870">[-]</label><label class="expand" for="c-39010870">[1 more]</label></div><br/><div class="children"><div class="content">More to the point, OCaml belongs to the ecosystems that has the golden root, offering multiple implementations, allowing to pick the best one for each workflow.<p>If Rust had an interpreter in the box algonside the compilers like OCaml (there are multiple ones as well), it would already make a big different in development workflows.</div><br/></div></div></div></div><div id="39010714" class="c"><input type="checkbox" id="c-39010714" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39010565">parent</a><span>|</span><a href="#39010802">prev</a><span>|</span><a href="#39009550">next</a><span>|</span><label class="collapse" for="c-39010714">[-]</label><label class="expand" for="c-39010714">[1 more]</label></div><br/><div class="children"><div class="content">Thankfully C++ modules are on the right path to improve the story on the C++ side.<p>Using C++23 standard library, alongside modules, and cargo&#x2F;vcpkg binary caches for 3rd party libs is quite fast.<p>Rust well, until cargo does offer the option to use binary libraries, it will always lag behind in what C++ tooling is capable of. Maybe if scache becomes part of it.</div><br/></div></div></div></div><div id="39009550" class="c"><input type="checkbox" id="c-39009550" checked=""/><div class="controls bullet"><span class="by">thadt</span><span>|</span><a href="#39010565">prev</a><span>|</span><a href="#39007690">next</a><span>|</span><label class="collapse" for="c-39009550">[-]</label><label class="expand" for="c-39009550">[9 more]</label></div><br/><div class="children"><div class="content">Perhaps part of the issue with the &quot;evolution of the programming language field in recent years&quot; is that &#x27;simplicity&#x27; is a high cost optimization. Most every &#x27;simple&#x27; system I&#x27;ve been a part of building started life as an oversized beast, laboriously wrestled into a more streamlined form.<p>Making complicated things is cheaper, easier, and lets you say &#x27;yes&#x27; more often to smart, persuasive, people. Simple takes a lot of time, effort, and &quot;getting to no&quot; with people that have good reasons for the things they want to add.</div><br/><div id="39010199" class="c"><input type="checkbox" id="c-39010199" checked=""/><div class="controls bullet"><span class="by">onetimeuse92304</span><span>|</span><a href="#39009550">parent</a><span>|</span><a href="#39010443">next</a><span>|</span><label class="collapse" for="c-39010199">[-]</label><label class="expand" for="c-39010199">[6 more]</label></div><br/><div class="children"><div class="content">Making complicated things may only be cheaper initially.<p>I think the problem is that to learn to make simple things you first need to learn making complicated things. This is my story and pretty much the story of every person I ever talked to that learned to make simple things. Some people get it faster, some get slower and some never learn to appreciate simplicity, but everybody first had to learn to make before they learned to make simple.<p>So now realise we were through decades of exponential growth of the number of developers and at any point in time people with experience were greatly outnumbered by people with little experience and the answer becomes easier to formulate.<p>Simplicity isn&#x27;t something that is easy to teach. The best ways to do it I found is by mentoring and working with people, but there are so many people you can meaningfully mentor on a daily basis. People with experience are so outnumbered (and also promoted up if they are any good) that it is very hard for an average apprentice programmer Joe to be able to find his master.</div><br/><div id="39010612" class="c"><input type="checkbox" id="c-39010612" checked=""/><div class="controls bullet"><span class="by">hyperthesis</span><span>|</span><a href="#39009550">root</a><span>|</span><a href="#39010199">parent</a><span>|</span><a href="#39010443">next</a><span>|</span><label class="collapse" for="c-39010612">[-]</label><label class="expand" for="c-39010612">[5 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  A complex system that works is invariably found to have evolved from a simple system that worked. A complex system designed from scratch never works and cannot be patched up to make it work. You have to start over with a working simple system. - Gall&#x27;s Law</code></pre></div><br/><div id="39010645" class="c"><input type="checkbox" id="c-39010645" checked=""/><div class="controls bullet"><span class="by">onetimeuse92304</span><span>|</span><a href="#39009550">root</a><span>|</span><a href="#39010612">parent</a><span>|</span><a href="#39010443">next</a><span>|</span><label class="collapse" for="c-39010645">[-]</label><label class="expand" for="c-39010645">[4 more]</label></div><br/><div class="children"><div class="content">No, that&#x27;s not true. Easily disproven by example: I have many times seen smart engineers with little experience design and immediately implement an extremely complex solution to a very simple problem.<p>Don&#x27;t believe everything people say. Just because somebody called something &quot;a law&quot; does not mean it is true.</div><br/><div id="39010872" class="c"><input type="checkbox" id="c-39010872" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#39009550">root</a><span>|</span><a href="#39010645">parent</a><span>|</span><a href="#39010858">next</a><span>|</span><label class="collapse" for="c-39010872">[-]</label><label class="expand" for="c-39010872">[1 more]</label></div><br/><div class="children"><div class="content">A working &quot;complex solution to a very simple problem&quot; is not a contradiction, as it can be &quot;simpler&quot; than a simple working solution to a complex problem.</div><br/></div></div><div id="39010858" class="c"><input type="checkbox" id="c-39010858" checked=""/><div class="controls bullet"><span class="by">muro</span><span>|</span><a href="#39009550">root</a><span>|</span><a href="#39010645">parent</a><span>|</span><a href="#39010872">prev</a><span>|</span><a href="#39010443">next</a><span>|</span><label class="collapse" for="c-39010858">[-]</label><label class="expand" for="c-39010858">[2 more]</label></div><br/><div class="children"><div class="content">They might have designed and implemented it, but does it work? :)</div><br/><div id="39010905" class="c"><input type="checkbox" id="c-39010905" checked=""/><div class="controls bullet"><span class="by">onetimeuse92304</span><span>|</span><a href="#39009550">root</a><span>|</span><a href="#39010858">parent</a><span>|</span><a href="#39010443">next</a><span>|</span><label class="collapse" for="c-39010905">[-]</label><label class="expand" for="c-39010905">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes it does. Depending on definition of &quot;work&quot;:)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39010443" class="c"><input type="checkbox" id="c-39010443" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#39009550">parent</a><span>|</span><a href="#39010199">prev</a><span>|</span><a href="#39007690">next</a><span>|</span><label class="collapse" for="c-39010443">[-]</label><label class="expand" for="c-39010443">[2 more]</label></div><br/><div class="children"><div class="content">The Go programming language is not only partly inspired by Wirth&#x27;s work (Robert Griesemer, one of the &quot;founding fathers&quot; of Go, studied at ETH ZÃ¼rich), it also has this goal of simplicity: it started out with fewer (but powerful and unfortunately often underestimated) features than other languages, and while it has added more complexity over the years (modules, generics, ...), this has happened at a much slower rate than with other languages.</div><br/><div id="39010808" class="c"><input type="checkbox" id="c-39010808" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39009550">root</a><span>|</span><a href="#39010443">parent</a><span>|</span><a href="#39007690">next</a><span>|</span><label class="collapse" for="c-39010808">[-]</label><label class="expand" for="c-39010808">[1 more]</label></div><br/><div class="children"><div class="content">Its &quot;simplicity&quot; is a reason why it depends so heavily on compile time code generation across the ecosystem.</div><br/></div></div></div></div></div></div><div id="39007690" class="c"><input type="checkbox" id="c-39007690" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39009550">prev</a><span>|</span><a href="#39008212">next</a><span>|</span><label class="collapse" for="c-39007690">[-]</label><label class="expand" for="c-39007690">[13 more]</label></div><br/><div class="children"><div class="content">&gt; in the sense that the limitations and exclusions of the language design were precisely what made compact implementations possible and widely successful.<p>All of the Pascals that were widely successful extended the language in key ways. I was an initial fan of Pascal, until I discovered that a large amount of my time was spent trying to work around limitations of the language.<p>With C, those workarounds disappeared and I was far more productive.<p>(I know C compilers always have numerous extensions, most of them of dubious value, but still, plain C remains a far, far more useful language than the Pascal of &quot;Pascal User Manual and Report&quot;. Which is why C buried Pascal.)</div><br/><div id="39010823" class="c"><input type="checkbox" id="c-39010823" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39007690">parent</a><span>|</span><a href="#39008729">next</a><span>|</span><label class="collapse" for="c-39010823">[-]</label><label class="expand" for="c-39010823">[1 more]</label></div><br/><div class="children"><div class="content">Pascal also has had numerous extensions.<p>No one used Pascal of &quot;Pascal User Manual and Report&quot; from 1976.<p>Strangley compiler extentions are only cool when talking about C, in fact, most C developers have no idea what ISO C is actually all about.</div><br/></div></div><div id="39008729" class="c"><input type="checkbox" id="c-39008729" checked=""/><div class="controls bullet"><span class="by">jdougan</span><span>|</span><a href="#39007690">parent</a><span>|</span><a href="#39010823">prev</a><span>|</span><a href="#39008223">next</a><span>|</span><label class="collapse" for="c-39008729">[-]</label><label class="expand" for="c-39008729">[6 more]</label></div><br/><div class="children"><div class="content">As I said in another forum earlier this week,<p>&quot;A lot of the hate centered around how it wasnât a systems programming language, when it wasnât supposed to be one. Itâs like complaining your driving instructorâs car canât be used to dig a trench without extensive modification.&quot;<p>After BASIC, I learned on Pascal (Apple and IBM). It was invaluable to clarify in my mind how programming structures work, as opposed to the (fun) chaos of early BASICs. I really didn&#x27;t need much more than the I&#x2F;O available in standard Pascal at the time. And it hid details like endianness that I was not yet ready to handle.<p>Were there problems? Of course. Among others, the vendors should have done a lot more to standardize extensions, the P1 parameterized array bounds should have been in the initial spec, and while the P-machines had many virtues, performance was not one of them. Far too many of the early implementations just ran the P-code in an interpreter.</div><br/><div id="39008765" class="c"><input type="checkbox" id="c-39008765" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39007690">root</a><span>|</span><a href="#39008729">parent</a><span>|</span><a href="#39008223">next</a><span>|</span><label class="collapse" for="c-39008765">[-]</label><label class="expand" for="c-39008765">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been well over 40 years since I wrote Wirth Pascal code, but one of the problems was one couldn&#x27;t write a line without a line ending. That&#x27;s not an activity confined to system programming!</div><br/><div id="39010044" class="c"><input type="checkbox" id="c-39010044" checked=""/><div class="controls bullet"><span class="by">andrewshadura</span><span>|</span><a href="#39007690">root</a><span>|</span><a href="#39008765">parent</a><span>|</span><a href="#39008867">next</a><span>|</span><label class="collapse" for="c-39010044">[-]</label><label class="expand" for="c-39010044">[2 more]</label></div><br/><div class="children"><div class="content">Are you saying that Pascal dialect had WriteLn but not Write?</div><br/><div id="39010344" class="c"><input type="checkbox" id="c-39010344" checked=""/><div class="controls bullet"><span class="by">jdougan</span><span>|</span><a href="#39007690">root</a><span>|</span><a href="#39010044">parent</a><span>|</span><a href="#39008867">next</a><span>|</span><label class="collapse" for="c-39010344">[-]</label><label class="expand" for="c-39010344">[1 more]</label></div><br/><div class="children"><div class="content">No, it has write(), but some versions on some OSs needed an eol to flush the buffers. In general the file ops were deliberately underspecified [1], but it was 1973 and the variety of OSs was much weirder than today.<p>[1] <a href="https:&#x2F;&#x2F;www.standardpascaline.org&#x2F;The_Programming_Language_Pascal_1973.pdf" rel="nofollow">https:&#x2F;&#x2F;www.standardpascaline.org&#x2F;The_Programming_Language_P...</a></div><br/></div></div></div></div><div id="39008867" class="c"><input type="checkbox" id="c-39008867" checked=""/><div class="controls bullet"><span class="by">jdougan</span><span>|</span><a href="#39007690">root</a><span>|</span><a href="#39008765">parent</a><span>|</span><a href="#39010044">prev</a><span>|</span><a href="#39008223">next</a><span>|</span><label class="collapse" for="c-39008867">[-]</label><label class="expand" for="c-39008867">[2 more]</label></div><br/><div class="children"><div class="content">Sure. But for the output of the tiny calculator class project we did, it just didn&#x27;t matter.</div><br/><div id="39009436" class="c"><input type="checkbox" id="c-39009436" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39007690">root</a><span>|</span><a href="#39008867">parent</a><span>|</span><a href="#39008223">next</a><span>|</span><label class="collapse" for="c-39009436">[-]</label><label class="expand" for="c-39009436">[1 more]</label></div><br/><div class="children"><div class="content">Yes, Pascal is good for that purpose.</div><br/></div></div></div></div></div></div></div></div><div id="39008223" class="c"><input type="checkbox" id="c-39008223" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#39007690">parent</a><span>|</span><a href="#39008729">prev</a><span>|</span><a href="#39008212">next</a><span>|</span><label class="collapse" for="c-39008223">[-]</label><label class="expand" for="c-39008223">[5 more]</label></div><br/><div class="children"><div class="content">One could argue that C&#x27;s success is largely because it was even simpler than Pascal and more generic --- a notable example is that Pascal has I&#x2F;O built-in to the language, while C defined them as part of the standard library (which could even not be present.)</div><br/><div id="39008267" class="c"><input type="checkbox" id="c-39008267" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39007690">root</a><span>|</span><a href="#39008223">parent</a><span>|</span><a href="#39008212">next</a><span>|</span><label class="collapse" for="c-39008267">[-]</label><label class="expand" for="c-39008267">[4 more]</label></div><br/><div class="children"><div class="content">From a compiler writer&#x27;s perspective, C is much more complex than Wirth&#x27;s Pascal.<p>Pascal&#x27;s builtin I&#x2F;O was a major impediment to its usability.<p>However, one really great feature of Wirth&#x27;s Pascal is nested functions with access to outer scopes, which D wholeheartedly embraces. They really are slick. I use them heavily.</div><br/><div id="39008345" class="c"><input type="checkbox" id="c-39008345" checked=""/><div class="controls bullet"><span class="by">dist1ll</span><span>|</span><a href="#39007690">root</a><span>|</span><a href="#39008267">parent</a><span>|</span><a href="#39008212">next</a><span>|</span><label class="collapse" for="c-39008345">[-]</label><label class="expand" for="c-39008345">[3 more]</label></div><br/><div class="children"><div class="content">&gt; one really great feature of Wirth&#x27;s Pascal is nested functions with access to outer scopes, which D wholeheartedly embraces<p>Can you give an example? What does the function access in the outer scope? Is it like an environment-capturing closure?</div><br/><div id="39008749" class="c"><input type="checkbox" id="c-39008749" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39007690">root</a><span>|</span><a href="#39008345">parent</a><span>|</span><a href="#39010984">next</a><span>|</span><label class="collapse" for="c-39008749">[-]</label><label class="expand" for="c-39008749">[1 more]</label></div><br/><div class="children"><div class="content">It can access the variables in an outer scope:<p><pre><code>    int moon(int s)
    {
        int sum(int x) { return s + x; }
        return sum(3);
    }
</code></pre>
An extra parameter is passed to the nested function, called a &quot;static link&quot;, which is a pointer to the stack frame of the statically enclosing function. This is in addition to the usual &quot;dynamic link&quot; which is a pointer to the stack frame that called the nested function.<p>Nested functions can also be nested, and can access variables in enclosing functions by walking the static links back.<p>The neato thing about this is it makes stack frames work exactly like members of a struct. In fact, a pointer to a nested function is analogous to (and binary interchangeable with) a pointer to a stack object.</div><br/></div></div><div id="39010984" class="c"><input type="checkbox" id="c-39010984" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#39007690">root</a><span>|</span><a href="#39008345">parent</a><span>|</span><a href="#39008749">prev</a><span>|</span><a href="#39008212">next</a><span>|</span><label class="collapse" for="c-39010984">[-]</label><label class="expand" for="c-39010984">[1 more]</label></div><br/><div class="children"><div class="content">Almost, the nested function goes out of scope too if the outer function finishes.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39008212" class="c"><input type="checkbox" id="c-39008212" checked=""/><div class="controls bullet"><span class="by">yawaramin</span><span>|</span><a href="#39007690">prev</a><span>|</span><a href="#39009307">next</a><span>|</span><label class="collapse" for="c-39008212">[-]</label><label class="expand" for="c-39008212">[2 more]</label></div><br/><div class="children"><div class="content">Nice tribute to Wirth. I just have some feedback :-)<p>&gt; ...modular languages offer one implementation for each interface.<p>Unfortunately, this is totally incorrect. Modular languages absolutely allow any interface to have multiple implementations which can be chosen amongst. This corresponds to how a Java &#x27;interface&#x27; can have multiple implementations. In fact programming to the interface and swapping the implementation is one of the main selling points of interfaces.<p>&gt; Some of those constraints remained long after advances in hardware and software made the insistence on one-pass compilation seem obsolete.<p>With compile speeds nowadays we can only <i>wish</i> that this insistence was obsolete. It&#x27;s needed now more than ever with the slow-as-molasses compilers (apart from a notable few) of today.</div><br/><div id="39010851" class="c"><input type="checkbox" id="c-39010851" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39008212">parent</a><span>|</span><a href="#39009307">next</a><span>|</span><label class="collapse" for="c-39010851">[-]</label><label class="expand" for="c-39010851">[1 more]</label></div><br/><div class="children"><div class="content">He is talking in the context of modules as in Modula-2 and Oberon, not language types, or the split interface&#x2F;implementation, which goes towards your point as Modula-3 and Ada allowed various interface module&#x2F;package declarations to the same implementation.<p>Still not the same as Objective-C&#x2F;Java interfaces that later on become more widely known, or Standard ML modules, CLU clusters, all of them type system based.</div><br/></div></div></div></div><div id="39009307" class="c"><input type="checkbox" id="c-39009307" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39008212">prev</a><span>|</span><a href="#39010407">next</a><span>|</span><label class="collapse" for="c-39009307">[-]</label><label class="expand" for="c-39009307">[1 more]</label></div><br/><div class="children"><div class="content">Recent and related:<p><i>Closing word at ZÃ¼rich Colloquium (1968)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38883652">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38883652</a> - Jan 2024 (28 comments)<p><i>Niklaus Wirth, 1934-2024: Geek For Life</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38871086">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38871086</a> - Jan 2024 (61 comments)<p><i>Niklaus Wirth has died</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38858012">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38858012</a> - Jan 2024 (403 comments)</div><br/></div></div><div id="39010407" class="c"><input type="checkbox" id="c-39010407" checked=""/><div class="controls bullet"><span class="by">justanotherjoe</span><span>|</span><a href="#39009307">prev</a><span>|</span><a href="#39009407">next</a><span>|</span><label class="collapse" for="c-39010407">[-]</label><label class="expand" for="c-39010407">[1 more]</label></div><br/><div class="children"><div class="content">I never like this platonic view of there being one &#x27;perfect language&#x27;, maybe yet invented, that stood above all others.  
Instead I am always more of a &#x27;classist&#x27;(i didn&#x27;t find any word for it).  I believe there is one class of language, of which it&#x27;s not hard to achieve, that for all intents and purposes are all equally good.  A bit like the notion of &#x27;turing completeness&#x27; except turing completeness is way too broad and measure another thing.  But I&#x27;m betting that the &#x27;best&#x27; language is already achieved, and there are quite a few of them.  Which ones, that&#x27;s up to debate.</div><br/></div></div><div id="39009407" class="c"><input type="checkbox" id="c-39009407" checked=""/><div class="controls bullet"><span class="by">nxobject</span><span>|</span><a href="#39010407">prev</a><span>|</span><a href="#39009235">next</a><span>|</span><label class="collapse" for="c-39009407">[-]</label><label class="expand" for="c-39009407">[1 more]</label></div><br/><div class="children"><div class="content">Huh, the article mentioned a fact that I could have never expected: Logitech was an indirect sire of Wirth, since people from ETH had wanted to commercialize Modula-2. [1] Their first product: a Modula-2 development system bundled with a 3-button mouse.<p>[1] <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20210324044010&#x2F;http:&#x2F;&#x2F;www.edm2.com&#x2F;index.php&#x2F;Logitech" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20210324044010&#x2F;http:&#x2F;&#x2F;www.edm2.c...</a></div><br/></div></div><div id="39009235" class="c"><input type="checkbox" id="c-39009235" checked=""/><div class="controls bullet"><span class="by">mark-r</span><span>|</span><a href="#39009407">prev</a><span>|</span><label class="collapse" for="c-39009235">[-]</label><label class="expand" for="c-39009235">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t believe I missed the news of his death.  Pascal was my language of choice for many years.  RIP, Niklaus.</div><br/></div></div></div></div></div></div></div></body></html>