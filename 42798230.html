<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737968469769" as="style"/><link rel="stylesheet" href="styles.css?v=1737968469769"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://ahmet.im/blog/controller-pitfalls/">So you wanna write Kubernetes controllers?</a> <span class="domain">(<a href="https://ahmet.im">ahmet.im</a>)</span></div><div class="subtext"><span>gokhan</span> | <span>83 comments</span></div><br/><div><div id="42838863" class="c"><input type="checkbox" id="c-42838863" checked=""/><div class="controls bullet"><span class="by">Havoc</span><span>|</span><a href="#42838538">next</a><span>|</span><label class="collapse" for="c-42838863">[-]</label><label class="expand" for="c-42838863">[1 more]</label></div><br/><div class="children"><div class="content">Low barrier to entry was not a phrase I was expecting in that article.<p>Either way I’m going to try my hardest to avoid this. K8s is hard enough to get right as is</div><br/></div></div><div id="42838538" class="c"><input type="checkbox" id="c-42838538" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#42838863">prev</a><span>|</span><a href="#42834049">next</a><span>|</span><label class="collapse" for="c-42838538">[-]</label><label class="expand" for="c-42838538">[1 more]</label></div><br/><div class="children"><div class="content">I used to be fascinated by the automation power of Kubernetes custom components. The declarative approach and reconciliation loop offers so many possibilities for creating higher level descriptions of domain specific infrastructure.<p>On reflection though, I think this stuff can lead to a lot of complexity layers which don&#x27;t benefit the product relative to the time investment. You are probably not Google.</div><br/></div></div><div id="42834049" class="c"><input type="checkbox" id="c-42834049" checked=""/><div class="controls bullet"><span class="by">clx75</span><span>|</span><a href="#42838538">prev</a><span>|</span><a href="#42838583">next</a><span>|</span><label class="collapse" for="c-42834049">[-]</label><label class="expand" for="c-42834049">[8 more]</label></div><br/><div class="children"><div class="content">At work we are using Metacontroller to implement our &quot;operators&quot;. Quoted because these are not real operators but rather Metacontroller plugins, written in Python. All the watch and update logic - plus the resource caching - is outsourced to Metacontroller (which is written in Go). We define - via its CompositeController or DecoratorController CRDs - what kind of resources it should watch and which web service it should call into when it detects a change. The web service speaks plain HTTP (or HTTPS if you want).<p>In case of a CompositeController, the web service gets the created&#x2F;updated&#x2F;deleted parent resource and any already existing child resources (initially none). The web service then analyzes the parent and existing children, then responds with the list of child resources whose existence and state Metacontroller should ensure in the cluster. If something is left out from the response compared to a previous response, it is deleted.<p>Things we implemented using this pattern:<p>- Project: declarative description of a company project, child resources include a namespace, service account, IAM role, SMB&#x2F;S3&#x2F;FSX PVs and PVCs generated for project volumes (defined under spec.volumes in the Project CR), ingresses for a set of standard apps<p>- Job: high-level description of a DAG of containers, the web service works as a compiler which translates this high-level description into an Argo Workflow (this will be the child)<p>- Container: defines a dev container, expands into a pod running an sshd and a Contour HTTPProxy (TCP proxy) which forwards TLS-wrapped SSH traffic to the sshd service<p>- KeycloakClient: here the web service is not pure - it talks to the Keycloak Admin REST API and creates&#x2F;updates a client in Keycloak whose parameters are given by the CRD spec<p>So far this works pretty well and makes writing controllers a breeze - at least compared to the standard kubebuilder approach.<p><a href="https:&#x2F;&#x2F;metacontroller.github.io&#x2F;metacontroller&#x2F;intro.html" rel="nofollow">https:&#x2F;&#x2F;metacontroller.github.io&#x2F;metacontroller&#x2F;intro.html</a></div><br/><div id="42837502" class="c"><input type="checkbox" id="c-42837502" checked=""/><div class="controls bullet"><span class="by">JeffMcCune</span><span>|</span><a href="#42834049">parent</a><span>|</span><a href="#42835771">next</a><span>|</span><label class="collapse" for="c-42837502">[-]</label><label class="expand" for="c-42837502">[1 more]</label></div><br/><div class="children"><div class="content">As other sibling comments suggest these use cases are better solved with a generator.<p>The rendered manifest pattern is a simpler alternative. Holos [1] is an implementation of the pattern using well typed CUE to wrap Helm and Kustomize in one unified solution.<p>It too supports Projects, they’re completely defined by the end user and result in the underlying resource configurations being fully rendered and version controlled. This allows for nice diffs for example, something difficult to achieve with plain ArgoCD and Helm.<p>[1]: <a href="https:&#x2F;&#x2F;holos.run&#x2F;docs&#x2F;overview&#x2F;" rel="nofollow">https:&#x2F;&#x2F;holos.run&#x2F;docs&#x2F;overview&#x2F;</a></div><br/></div></div><div id="42835771" class="c"><input type="checkbox" id="c-42835771" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#42834049">parent</a><span>|</span><a href="#42837502">prev</a><span>|</span><a href="#42834780">next</a><span>|</span><label class="collapse" for="c-42835771">[-]</label><label class="expand" for="c-42835771">[1 more]</label></div><br/><div class="children"><div class="content">The choice is always between a controller and a generator.<p>The advantage of a controller is that it can react to external conditions, for example nodes&#x2F;pods failing, etc. The is great for e.g. a database where you need to failover and update endpointslices. The advantage of a generator is that it can be tested easier, it can be dry-runned, and it is much simpler.<p>All of your examples seem to me like use cases that would be better implemented with a generator (e.g. Helm, or any custom script outputting YAML) than a controller. Any reason you wrote these as controllers anyway?</div><br/></div></div><div id="42834780" class="c"><input type="checkbox" id="c-42834780" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#42834049">parent</a><span>|</span><a href="#42835771">prev</a><span>|</span><a href="#42834696">next</a><span>|</span><label class="collapse" for="c-42834780">[-]</label><label class="expand" for="c-42834780">[3 more]</label></div><br/><div class="children"><div class="content">Curious why using controller for these aspects versus generating the K8s objects as part of your deployment pipeline that you just apply? The latter gives you versioned artifacts you can roll forward and back and independent deployment of these supporting pieces with each app.<p>Is there runtime dynamism that you need the control loop to handle beyond what the built-in primitives can handle?</div><br/><div id="42837737" class="c"><input type="checkbox" id="c-42837737" checked=""/><div class="controls bullet"><span class="by">clx75</span><span>|</span><a href="#42834049">root</a><span>|</span><a href="#42834780">parent</a><span>|</span><a href="#42834696">next</a><span>|</span><label class="collapse" for="c-42837737">[-]</label><label class="expand" for="c-42837737">[2 more]</label></div><br/><div class="children"><div class="content">Some of the resources are short-lived, including jobs and dev containers. The corresponding CRs are created&#x2F;updated&#x2F;deleted directly in the cluster by the project users through a REST API. For these, expansion of the CR into child resources must happen dynamically.<p>Other CRs are realized through imperative commands executed against a REST API. Prime example is KeycloakRealm and KeycloakClient which translate into API calls to Keycloak, or FSXFileSystem which needs Boto3 to talk to AWS (at least for now, until FSXFileSystem is also implemented in ACK).<p>For long-lived resources up-front (compile time?) expansion would be possible, we just don&#x27;t know where to put the expansion code. Currently long-lived resource CRs are stored in Git, deployment is handled with Flux. When projects want an extra resource, we just commit it to Git under their project-resources folder. I guess we could somehow add an extra step here - running a script? - which would do the expansion and store the children in Git before merging desired state into the nonprod&#x2F;prod branches, I&#x27;m just not clear on how to do this in a way that feels nice.<p>Currently the entire stack can be run on a developer&#x27;s laptop, thanks to the magic of Tilt. In local dev it comes really handy that you can just change a CRs and the children are synced immediately.<p>Drawbacks we identified so far:<p>If we change the expansion logic, child resources of existing parents are (eventually) regenerated using the new logic. This can be a bad thing - for example jobs (which expand into Argo Workflows) should not change while they are running. Currently the only idea we have to mitigate this problem is storing the initial expansion into a ConfigMap and returning the original expansion from this &quot;expansion cache&quot; if it exists at later syncs.<p>Sometimes the Metacontroller plugin cannot be a pure function and executing the side effects introduces latency into the sync. This didn&#x27;t cause any problems so far but maybe will as it goes against the Metacontroller design expressed in the docs.<p>Python is a memory hog, our biggest controllers can take ~200M.</div><br/><div id="42838170" class="c"><input type="checkbox" id="c-42838170" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#42834049">root</a><span>|</span><a href="#42837737">parent</a><span>|</span><a href="#42834696">next</a><span>|</span><label class="collapse" for="c-42838170">[-]</label><label class="expand" for="c-42838170">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve used an artifact store like Aritifactory to store the generated &#x2F; expanded K8s yaml files, ending up with three pieces:
  1) A versioned and packaged config generation system that your dev ops team owns. You&#x27;d have test and production versions of this that all applications use in their CI pipeline.
  2) A templated input configuration that describes the unique bits per service (this configuration file is owned by each application team)
  3) The output of #1 applied to #2, versioned in an artifact store that is generated by the CI pipeline.<p>And finally, a Kustomize step can be added at the end to support configuration that isn&#x27;t supported by #1 and #2, without requiring teams to generate all the K8s config pieces by hand.</div><br/></div></div></div></div></div></div><div id="42834696" class="c"><input type="checkbox" id="c-42834696" checked=""/><div class="controls bullet"><span class="by">fsniper</span><span>|</span><a href="#42834049">parent</a><span>|</span><a href="#42834780">prev</a><span>|</span><a href="#42838583">next</a><span>|</span><label class="collapse" for="c-42834696">[-]</label><label class="expand" for="c-42834696">[2 more]</label></div><br/><div class="children"><div class="content">At work we are using nolar&#x2F;kopf for writing controllers that provisions&#x2F;manages our kubernetes clusters. This also includes managing any infrastructure related apps that we deploy on them.<p>We were using whitebox controller at the start, which is also like  metacontroller that runs your scripts on kubernetes events. That was easy to write. However not having full control on the lifecycle of the controller code gets in the way time to time.<p>Considering you are also writing Python did you review kopf before deciding on metacontroller?</div><br/><div id="42837881" class="c"><input type="checkbox" id="c-42837881" checked=""/><div class="controls bullet"><span class="by">clx75</span><span>|</span><a href="#42834049">root</a><span>|</span><a href="#42834696">parent</a><span>|</span><a href="#42838583">next</a><span>|</span><label class="collapse" for="c-42837881">[-]</label><label class="expand" for="c-42837881">[1 more]</label></div><br/><div class="children"><div class="content">Yes, we started with Kopf.<p>As we understood it, Kopf lets you build an entire operator in Python, with the watch&#x2F;update&#x2F;cache&#x2F;expansion logic all implemented in Python. But the first operator we wrote in it just didn&#x27;t feel right. We had to talk to the K8S API from Python to do all the expansions. It was too complex. We also had aesthetic issues with the Kopf API.<p>Metacontroller gave us a small, Go binary which takes care of all the complex parts (watch&#x2F;update&#x2F;cache). Having to write only the expansion part in Python felt like a great simplification - especially now that we have Pydantic.</div><br/></div></div></div></div></div></div><div id="42838583" class="c"><input type="checkbox" id="c-42838583" checked=""/><div class="controls bullet"><span class="by">never_inline</span><span>|</span><a href="#42834049">prev</a><span>|</span><a href="#42834206">next</a><span>|</span><label class="collapse" for="c-42838583">[-]</label><label class="expand" for="c-42838583">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d please ask people to don&#x27;t write operators unless absolutely necessary.<p>I used a certain tool which had its own config format, and it&#x27;s &quot;cloudnative&quot; operator implemented CRDs of which multiple can exist and they would update the config file in some mounted volume. Such thing is a hell to debug. Why can&#x27;t we just store the config file in configmap&#x2F; secret and listen to changes?<p>(If we had a better templating solution than helm, I think quite a few operators wouldn&#x27;t need to exist.)</div><br/></div></div><div id="42834206" class="c"><input type="checkbox" id="c-42834206" checked=""/><div class="controls bullet"><span class="by">neuroelectron</span><span>|</span><a href="#42838583">prev</a><span>|</span><a href="#42833558">next</a><span>|</span><label class="collapse" for="c-42834206">[-]</label><label class="expand" for="c-42834206">[1 more]</label></div><br/><div class="children"><div class="content">No not really</div><br/></div></div><div id="42833558" class="c"><input type="checkbox" id="c-42833558" checked=""/><div class="controls bullet"><span class="by">Vampiero</span><span>|</span><a href="#42834206">prev</a><span>|</span><a href="#42838081">next</a><span>|</span><label class="collapse" for="c-42833558">[-]</label><label class="expand" for="c-42833558">[69 more]</label></div><br/><div class="children"><div class="content">Why do devops keep piling abstractions on top of abstractions?<p>There&#x27;s the machine. Then the VM. Then the container. Then the orchestrator. Then the controller.
And it&#x27;s all so complex that you need even more tools to generate the configuration files for the former tools.<p>I don&#x27;t want to write a Kubernetes controller. I don&#x27;t even know why it should exist.</div><br/><div id="42833917" class="c"><input type="checkbox" id="c-42833917" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42833558">parent</a><span>|</span><a href="#42833715">next</a><span>|</span><label class="collapse" for="c-42833917">[-]</label><label class="expand" for="c-42833917">[27 more]</label></div><br/><div class="children"><div class="content">Right now I’m typing on a glass screen that pretends to have a keyboard on it that is running a web browser developed with a UI toolkit in a programming language that compiles down to an intermediate bytecode that’s compiled to machine code that’s actually interpreted as microcode on the processor, half of it is farmed out to accelerators and coprocessors of various kinds, all assembled out of a gajillion transistors that neatly hide the fact that we’ve somehow made it possible to make sand think.<p>The number of layers of abstraction you’re already relying on just to post this comment is nigh uncountable. Abstraction is literally the only way we’ve continued to make progress in any technological endeavor.</div><br/><div id="42834038" class="c"><input type="checkbox" id="c-42834038" checked=""/><div class="controls bullet"><span class="by">zug_zug</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42833917">parent</a><span>|</span><a href="#42834110">next</a><span>|</span><label class="collapse" for="c-42834038">[-]</label><label class="expand" for="c-42834038">[17 more]</label></div><br/><div class="children"><div class="content">I think the point is that there are abstractions that require you to know almost nothing (e.g. that my laptop has a SSD with blocks that are constantly dying is abstracted to a filesystem that looks like a basic tree structure).<p>Then there are abstractions that may actually <i>increase</i> cognitive load &quot;What if instead of thinking about chairs, we philosophically think about ALL standing furniture types, stools, tables, etc. They may have 4 legs, 3, 6? What about a car seats too?&quot;<p>AFAICT writing a kubernetes controller is probably overkill challenge-yourself level exercise (e.g. a quine in BF) because odds are that any resource you&#x27;ve ever needed to manage somebody else has built an automated way to do it first.<p>Would love to hear other perspectives though if anybody has great examples of when you really couldn&#x27;t succeed without writing your own kubernetes controller.</div><br/><div id="42835309" class="c"><input type="checkbox" id="c-42835309" checked=""/><div class="controls bullet"><span class="by">root_axis</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834038">parent</a><span>|</span><a href="#42834248">next</a><span>|</span><label class="collapse" for="c-42835309">[-]</label><label class="expand" for="c-42835309">[5 more]</label></div><br/><div class="children"><div class="content">Yes, k8s is an abstraction, and it&#x27;s a useful one, even though not everyone needs it. At this new level of abstraction, your hardware becomes homogeneous, making it trivial to scale and recover from hardware failures since k8s automatically distributes your application instances across the hardware in a unified manner. It also has many other useful capabilities downstream of that (e.g. zero downtime deployment&#x2F;rollback&#x2F;restart). There&#x27;s not really any other (well supported) alternative if you want that. Of course, most organizations don&#x27;t need it, but it&#x27;s very nice to have in a service oriented system.</div><br/><div id="42835870" class="c"><input type="checkbox" id="c-42835870" checked=""/><div class="controls bullet"><span class="by">zug_zug</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42835309">parent</a><span>|</span><a href="#42834248">next</a><span>|</span><label class="collapse" for="c-42835870">[-]</label><label class="expand" for="c-42835870">[4 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s not really any other (well supported) alternative if you want that<p>You don&#x27;t think AWS autoscale groups give you both of those things?</div><br/><div id="42838698" class="c"><input type="checkbox" id="c-42838698" checked=""/><div class="controls bullet"><span class="by">enoent</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42835870">parent</a><span>|</span><a href="#42835917">next</a><span>|</span><label class="collapse" for="c-42838698">[-]</label><label class="expand" for="c-42838698">[1 more]</label></div><br/><div class="children"><div class="content">AWS autoscaling does not take your application logic into account, which means that aggresive downscaling will, at worst, lead your applications to fail.<p>I&#x27;ll give a specific example with Apache Spark: AWS provides a managed cluster via EMR. You can configure your task nodes (i.e. instances that run the bulk of your submitted jobs to Spark) to be autoscaled. If these jobs fetch data from managed databases, you might have RDS configured with autoscaling read replicas to support higher volume queries.<p>What I&#x27;ve frequently see happening: tasks fail because the task node instances were downscaled at the end of the job, because they are no longer consuming enough resources to stay up, but the tasks themselves haven&#x27;t finished. Or tasks failed because database connections were suddenly cut off, since RDS read replicas were no longer transmitting enough data to stay up.<p>The workaround is to have a fixed number of instances up, and pay the costs you were trying to avoid in the first place.<p>Or you could have an autoscaling mechanism that is aware of your application state, which is what k8s enables.</div><br/></div></div><div id="42835917" class="c"><input type="checkbox" id="c-42835917" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42835870">parent</a><span>|</span><a href="#42838698">prev</a><span>|</span><a href="#42837997">next</a><span>|</span><label class="collapse" for="c-42835917">[-]</label><label class="expand" for="c-42835917">[1 more]</label></div><br/><div class="children"><div class="content">I think you comically underestimate what Kubernetes provides.<p>Autoscaling groups give you instances, but Kubernetes automatically and transparently distributes all your running services, jobs, and other workloads <i>across</i> all those instances.<p>Amongst a laundry list of other things.</div><br/></div></div><div id="42837997" class="c"><input type="checkbox" id="c-42837997" checked=""/><div class="controls bullet"><span class="by">root_axis</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42835870">parent</a><span>|</span><a href="#42835917">prev</a><span>|</span><a href="#42834248">next</a><span>|</span><label class="collapse" for="c-42837997">[-]</label><label class="expand" for="c-42837997">[1 more]</label></div><br/><div class="children"><div class="content">Nothing wrong with ASGs, but they&#x27;re not really comparable to k8s. k8s isn&#x27;t simply &quot;scaling&quot;, it&#x27;s a higher level of abstraction that has granular control and understanding of your application instances in a manner that allows it to efficiently spread workloads across all your hardware automatically, all while managing service discovery, routing, lb, rollbacks and countless more. Comparing it to ASG suggests you may not be that familiar with k8s.<p>I think it&#x27;s fair to argue that k8s is overkill for many or even most organizations, but ASG is not even close to an alternative.</div><br/></div></div></div></div></div></div><div id="42834248" class="c"><input type="checkbox" id="c-42834248" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834038">parent</a><span>|</span><a href="#42835309">prev</a><span>|</span><a href="#42834110">next</a><span>|</span><label class="collapse" for="c-42834248">[-]</label><label class="expand" for="c-42834248">[11 more]</label></div><br/><div class="children"><div class="content">Those only require you to understand them because you’re working directly on top of them. If you were writing a filesystem driver you would <i>absolutely</i> need to know those details. If you’re writing a database backend, you probably need to know a lot about the filesystem. If you’re writing an ORM, you need to know a lot about databases.<p>Some of these abstractions are leakier than others. Web development coordinates a <i>lot</i> of different technologies so often times you need to know about a wide variety of topics, and sometimes a layer below those. Part of it is that there’s a lot less specialization in our profession than in others, so we need lots of generalists.</div><br/><div id="42834742" class="c"><input type="checkbox" id="c-42834742" checked=""/><div class="controls bullet"><span class="by">zug_zug</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834248">parent</a><span>|</span><a href="#42834738">prev</a><span>|</span><a href="#42834110">next</a><span>|</span><label class="collapse" for="c-42834742">[-]</label><label class="expand" for="c-42834742">[9 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re sort of hand-waving here.<p>I think the concrete question is -- do you need to learn more or fewer abstractions to use kubernetes versus say AWS?<p>And it looks like kubernetes is more abstractions in exchange for more customization. I can understand why somebody would roll their eyes at a system that has as much abstraction as kuberenetes does if their use-case is very concrete - they are scaling a web app based on traffic.</div><br/><div id="42835256" class="c"><input type="checkbox" id="c-42835256" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834742">parent</a><span>|</span><a href="#42834110">next</a><span>|</span><label class="collapse" for="c-42835256">[-]</label><label class="expand" for="c-42835256">[8 more]</label></div><br/><div class="children"><div class="content">Kubernetes and AWS aren’t alternatives. They occupy vastly different problem spaces.</div><br/><div id="42835856" class="c"><input type="checkbox" id="c-42835856" checked=""/><div class="controls bullet"><span class="by">zug_zug</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42835256">parent</a><span>|</span><a href="#42834110">next</a><span>|</span><label class="collapse" for="c-42835856">[-]</label><label class="expand" for="c-42835856">[7 more]</label></div><br/><div class="children"><div class="content">Not really.</div><br/><div id="42837027" class="c"><input type="checkbox" id="c-42837027" checked=""/><div class="controls bullet"><span class="by">SJC_Hacker</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42835856">parent</a><span>|</span><a href="#42835963">next</a><span>|</span><label class="collapse" for="c-42837027">[-]</label><label class="expand" for="c-42837027">[1 more]</label></div><br/><div class="children"><div class="content">Kubernetes isn&#x27;t locked to any vendor<p>Try moving your AWS solution to Google Cloud without a massive rewrite.<p>Also Kubernetes doesn&#x27;t actually deal with the underlying physical devices, directly.  That would be done something like Terraform or if you&#x27;re still hardcore, shell scripts.</div><br/></div></div><div id="42835963" class="c"><input type="checkbox" id="c-42835963" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42835856">parent</a><span>|</span><a href="#42837027">prev</a><span>|</span><a href="#42835943">next</a><span>|</span><label class="collapse" for="c-42835963">[-]</label><label class="expand" for="c-42835963">[4 more]</label></div><br/><div class="children"><div class="content">Sure, what do I know, I only operate the Kubernetes platform (on AWS) that runs most of a $50bn public company.</div><br/><div id="42836864" class="c"><input type="checkbox" id="c-42836864" checked=""/><div class="controls bullet"><span class="by">zug_zug</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42835963">parent</a><span>|</span><a href="#42838096">prev</a><span>|</span><a href="#42835943">next</a><span>|</span><label class="collapse" for="c-42836864">[-]</label><label class="expand" for="c-42836864">[2 more]</label></div><br/><div class="children"><div class="content">&quot;It is difficult to get a man to understand something when his salary depends on his not understanding it.&quot;  - Upton Sinclair</div><br/><div id="42837013" class="c"><input type="checkbox" id="c-42837013" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42836864">parent</a><span>|</span><a href="#42835943">next</a><span>|</span><label class="collapse" for="c-42837013">[-]</label><label class="expand" for="c-42837013">[1 more]</label></div><br/><div class="children"><div class="content">My salary directly depends upon me deeply understanding both AWS and Kubernetes. Better luck next time.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42834110" class="c"><input type="checkbox" id="c-42834110" checked=""/><div class="controls bullet"><span class="by">zenethian</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42833917">parent</a><span>|</span><a href="#42834038">prev</a><span>|</span><a href="#42833988">next</a><span>|</span><label class="collapse" for="c-42834110">[-]</label><label class="expand" for="c-42834110">[7 more]</label></div><br/><div class="children"><div class="content">Seemingly endlessly layered abstraction is also why phones and computers get faster and faster yet nothing seems to actually run better. Nobody wants to write native software anymore because there are too many variations of hardware and operating systems but everyone wants their apps to run on everything. Thus, we are stuck in abstraction hell.<p>I&#x27;d argue the exact opposite has happened. We have made very little progress because everything is continually abstracted out to the least common denominator, leaving accessibility high but features low. Very few actual groundbreaking leaps have been accomplished with all of this abstraction; we&#x27;ve just made it easier to put dumb software on more devices.</div><br/><div id="42834265" class="c"><input type="checkbox" id="c-42834265" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834110">parent</a><span>|</span><a href="#42837123">next</a><span>|</span><label class="collapse" for="c-42834265">[-]</label><label class="expand" for="c-42834265">[3 more]</label></div><br/><div class="children"><div class="content">I encourage you to actually work on a twenty year old piece of technology. It’s easy to forget that modern computers are doing a <i>lot</i> more. Sure, there’s waste. But the expectations from software these days are exponentially greater than what we used to ship.</div><br/><div id="42837068" class="c"><input type="checkbox" id="c-42837068" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834265">parent</a><span>|</span><a href="#42837123">next</a><span>|</span><label class="collapse" for="c-42837068">[-]</label><label class="expand" for="c-42837068">[2 more]</label></div><br/><div class="children"><div class="content">Winamp was great and there&#x27;s nothing better now. Office 2003 was feature complete IMO.</div><br/><div id="42838197" class="c"><input type="checkbox" id="c-42838197" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42837068">parent</a><span>|</span><a href="#42837123">next</a><span>|</span><label class="collapse" for="c-42838197">[-]</label><label class="expand" for="c-42838197">[1 more]</label></div><br/><div class="children"><div class="content">I can stream almost any song I can conceive of in a matter of seconds from my phone. In doing so I can play it wirelessly across every speaker in my house simultaneously as well as on my TV. The lyrics will be displayed on that TV alongside animated cover art and I can control playback with my remote. I will have other similar music suggested to me automatically when that song is finished playing. Guests at my home can add music to the queue from their phones without any additional setup or intervention on my part.<p>You don’t have to want to do any of that yourself, but if you can’t concede that that sort of experience would have been <i>utterly inconceivable</i> in the days of Winamp—while being boringly commonplace today—I’m not sure we can have a productive discussion.</div><br/></div></div></div></div></div></div><div id="42837123" class="c"><input type="checkbox" id="c-42837123" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834110">parent</a><span>|</span><a href="#42834265">prev</a><span>|</span><a href="#42837044">next</a><span>|</span><label class="collapse" for="c-42837123">[-]</label><label class="expand" for="c-42837123">[1 more]</label></div><br/><div class="children"><div class="content">Another, huge in fact, reason is that we ask them to do a lot more.<p>Just the framebuffer for one of my displays uses more memory than a computer that was very usable for all sorts of tasks back in 1998. Rendering UI to it also takes a lot more resources because of that.</div><br/></div></div><div id="42837044" class="c"><input type="checkbox" id="c-42837044" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834110">parent</a><span>|</span><a href="#42837123">prev</a><span>|</span><a href="#42838068">next</a><span>|</span><label class="collapse" for="c-42837044">[-]</label><label class="expand" for="c-42837044">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Nobody wants to write native software anymore because there are too many variations of hardware and operating systems but everyone wants their apps to run on everything.</i><p>So far we have: Android and i(pad)OS (mobile); MacOS, Windows, *nix? (desktop); And the web. That&#x27;s not a lot of platform. My theory is that no one want to properly architect their software anymore. It&#x27;s just too easy to build a ball of mud on top of electron and have a 5GB node_modules folder full of dependencies with unknown provenance.</div><br/></div></div><div id="42838068" class="c"><input type="checkbox" id="c-42838068" checked=""/><div class="controls bullet"><span class="by">root_axis</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834110">parent</a><span>|</span><a href="#42837044">prev</a><span>|</span><a href="#42833988">next</a><span>|</span><label class="collapse" for="c-42838068">[-]</label><label class="expand" for="c-42838068">[1 more]</label></div><br/><div class="children"><div class="content">This is just totally wrong. Full stop. Today&#x27;s devices are unimaginably orders of magnitude faster than the computers of old. To suggest otherwise is absolutely absurd, either pure ignorance or a denial of reality. I&#x27;m quite blown away that people so confidently state something that&#x27;s so easily demonstrated as incorrect.</div><br/></div></div></div></div><div id="42833988" class="c"><input type="checkbox" id="c-42833988" checked=""/><div class="controls bullet"><span class="by">petercooper</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42833917">parent</a><span>|</span><a href="#42834110">prev</a><span>|</span><a href="#42834011">next</a><span>|</span><label class="collapse" for="c-42833988">[-]</label><label class="expand" for="c-42833988">[1 more]</label></div><br/><div class="children"><div class="content">Then all of that data is turned into HTTP requests which turn into TCP packets distributed over IP over wifi over Ethernet over PPPoE over DSL and probably turned into light sent over fiber optics at various stages... :-)</div><br/></div></div><div id="42834011" class="c"><input type="checkbox" id="c-42834011" checked=""/><div class="controls bullet"><span class="by">ok123456</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42833917">parent</a><span>|</span><a href="#42833988">prev</a><span>|</span><a href="#42833715">next</a><span>|</span><label class="collapse" for="c-42834011">[-]</label><label class="expand" for="c-42834011">[1 more]</label></div><br/><div class="children"><div class="content">The problem isn&#x27;t abstractions. The problem is leaky abstractions that make it harder to reason about a system and add lots of hidden states and configurations of that state.<p>What could have been a static binary running a system service has become a Frankenstein mess of opaque nested environments operated by action at a distance.</div><br/></div></div></div></div><div id="42833715" class="c"><input type="checkbox" id="c-42833715" checked=""/><div class="controls bullet"><span class="by">danielklnstn</span><span>|</span><a href="#42833558">parent</a><span>|</span><a href="#42833917">prev</a><span>|</span><a href="#42834263">next</a><span>|</span><label class="collapse" for="c-42833715">[-]</label><label class="expand" for="c-42833715">[2 more]</label></div><br/><div class="children"><div class="content">CRDs and their controllers are perhaps <i>the</i> reason Kubernetes is as ubiquitous as it is today - the ability to extend clusters effortlessly is amazing and opens up the door for so many powerful capabilities.<p>&gt; I don&#x27;t want to write a Kubernetes controller. I don&#x27;t even know why it should exist.<p>You can take a look at Crossplane for a good example of the capabilities that controllers allow for. They&#x27;re usually encapsulated in Kubernetes add-ons and plugins, so much as you might never have to write an operating system driver yourself, you might never have to write a Kubernetes controller yourself.</div><br/><div id="42835002" class="c"><input type="checkbox" id="c-42835002" checked=""/><div class="controls bullet"><span class="by">raffraffraff</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42833715">parent</a><span>|</span><a href="#42834263">next</a><span>|</span><label class="collapse" for="c-42835002">[-]</label><label class="expand" for="c-42835002">[1 more]</label></div><br/><div class="children"><div class="content">One of the first really pleasant surprises I got while learning was that the kubectl command itself was extended (along with tab completion) by CRDs. So install external secrets operator and you get tab complete on those resources and actions.</div><br/></div></div></div></div><div id="42834263" class="c"><input type="checkbox" id="c-42834263" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#42833558">parent</a><span>|</span><a href="#42833715">prev</a><span>|</span><a href="#42834149">next</a><span>|</span><label class="collapse" for="c-42834263">[-]</label><label class="expand" for="c-42834263">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Why do devops keep piling abstractions on top of abstractions?<p>Mostly, because developers keep trying to replace sysadmins with higher levels of abstraction. Then when they realise that they require (some new word for) sysadmins still, they pile on more abstractions again and claim they don&#x27;t need them.<p>The abstraction du-jour is not Kubernetes at the moment, it&#x27;s FaaS. At some point managing those FaaS will require operators again and another abstraction on top of FaaS will exist, some kind of FaaS orchestrator, and the cycle will continue.</div><br/><div id="42834891" class="c"><input type="checkbox" id="c-42834891" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834263">parent</a><span>|</span><a href="#42834149">next</a><span>|</span><label class="collapse" for="c-42834891">[-]</label><label class="expand" for="c-42834891">[3 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s clear that Kubernetes et al aren&#x27;t trying to replace sysadmins. They&#x27;re trying to massively increase the ratio of sysadmin:machine.</div><br/><div id="42835170" class="c"><input type="checkbox" id="c-42835170" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834891">parent</a><span>|</span><a href="#42836571">next</a><span>|</span><label class="collapse" for="c-42835170">[-]</label><label class="expand" for="c-42835170">[1 more]</label></div><br/><div class="children"><div class="content">Fair point. Kubernetes seems to have been designed as a system to abstract across large physical machines, but instead we&#x27;re using it in &quot;right-sized&quot; VM environments, which is solving the exact same set of problems in a different way.<p>Similar to how we developed a language that could use many cores very well, and compiles to a single binary, but we use that language almost exclusively in environments that scale by running multiple instances of the same executable on the same machine, and package&#x2F;distribute that executable in a complicated tarball&#x2F;zipping process.<p>I wonder if there&#x27;s a name for this, solving the same problem twice but combining the solutions in a way that renders the benefits moot.</div><br/></div></div><div id="42836571" class="c"><input type="checkbox" id="c-42836571" checked=""/><div class="controls bullet"><span class="by">nejsjsjsbsb</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834891">parent</a><span>|</span><a href="#42835170">prev</a><span>|</span><a href="#42834149">next</a><span>|</span><label class="collapse" for="c-42836571">[-]</label><label class="expand" for="c-42836571">[1 more]</label></div><br/><div class="children"><div class="content">There are no sysadmins though in the new model. There are teams of engineers who code Go, do kubernetes stuff and go on call. They may occasionally Google some sysadmin knowledge. They replace sysadmins like drivers replace the person in front of the Model T waving a flag. Or pilots replace navigators.</div><br/></div></div></div></div></div></div><div id="42834149" class="c"><input type="checkbox" id="c-42834149" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#42833558">parent</a><span>|</span><a href="#42834263">prev</a><span>|</span><a href="#42835863">next</a><span>|</span><label class="collapse" for="c-42834149">[-]</label><label class="expand" for="c-42834149">[2 more]</label></div><br/><div class="children"><div class="content">Current example from work: an extreme single-tenant architecture, deployed for large N number of tenants, which need both logically and physically isolation; the cost of the cloud provider&#x27;s managed databases is considered Too Expensive to create one per tenant, so an open-source Kubernetes controller for the database is used instead.<p>Not all systems are small-N modern multi-tenant architectures deployed at small scale.</div><br/><div id="42838102" class="c"><input type="checkbox" id="c-42838102" checked=""/><div class="controls bullet"><span class="by">bg24</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834149">parent</a><span>|</span><a href="#42835863">next</a><span>|</span><label class="collapse" for="c-42838102">[-]</label><label class="expand" for="c-42838102">[1 more]</label></div><br/><div class="children"><div class="content">This is the point. Right tool for the job. Kubernetes was incubated at Google and designed for deployments at scale. Lot of teams are happily using it. But it is definitely not for startups or solo devs, unless you are an expert user already.</div><br/></div></div></div></div><div id="42835863" class="c"><input type="checkbox" id="c-42835863" checked=""/><div class="controls bullet"><span class="by">bshacklett</span><span>|</span><a href="#42833558">parent</a><span>|</span><a href="#42834149">prev</a><span>|</span><a href="#42833617">next</a><span>|</span><label class="collapse" for="c-42835863">[-]</label><label class="expand" for="c-42835863">[1 more]</label></div><br/><div class="children"><div class="content">K8s really isn&#x27;t about piling up abstractions. The orchestrator sits beside containers (which can be run on bare metal, btw) and handles tasks which already need to be done.  Orchestration of any system is always necessary. You can do it with K8s (or a related platform), or you can can cobble together custom shell scripts, or even perform the tasks manually.<p>One of these gives you a way to democratize the knowledge and enable self-service across your workforce. The others result in tribal knowledge being split into silos all across an organization. If you&#x27;re just running a couple of web servers and rarely have to make changes, maybe the manual way is OK for you. For organizations with many different systems that have complex interactions with each other, the time it takes to get a change through a system and the number of potential errors that manual tasks add are just infeasible.<p>Controllers are just one way to bring some level of sanity to all of the different  tasks which might be required to maintain any given system. Maybe you don&#x27;t need your own custom controllers, as there are a huge number which have already been created to solve the most common requirements. Knowing how to write them allows one to codify business rules, reduce human error, and get more certainty over the behavior of complex systems.</div><br/></div></div><div id="42833617" class="c"><input type="checkbox" id="c-42833617" checked=""/><div class="controls bullet"><span class="by">GiorgioG</span><span>|</span><a href="#42833558">parent</a><span>|</span><a href="#42835863">prev</a><span>|</span><a href="#42836557">next</a><span>|</span><label class="collapse" for="c-42833617">[-]</label><label class="expand" for="c-42833617">[22 more]</label></div><br/><div class="children"><div class="content">I don’t want Kubernetes period. Best decision we’ve made at work is to migrate away from k8s and onto AWS ECS. I just want to deploy containers! DevOps went from something you did when standing up or deploying an application, to an industry-wide jobs program. It’s the TSA of the software world.</div><br/><div id="42836299" class="c"><input type="checkbox" id="c-42836299" checked=""/><div class="controls bullet"><span class="by">nijave</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42833617">parent</a><span>|</span><a href="#42833782">next</a><span>|</span><label class="collapse" for="c-42836299">[-]</label><label class="expand" for="c-42836299">[1 more]</label></div><br/><div class="children"><div class="content">ECS is very very similar to Kubernetes and duplicates pretty much all of the functionality except AWS names and manages each piece as a separate service&#x2F;offering.<p>ECS+Route53+ALB&#x2F;ELB+EFS+Parameter Store+Secrets Manager+CloudWatch (Metrics, Logs, Events)+VPC+IAM&#x2F;STS and you&#x27;re pretty close in functionality.</div><br/></div></div><div id="42833782" class="c"><input type="checkbox" id="c-42833782" checked=""/><div class="controls bullet"><span class="by">mugsie</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42833617">parent</a><span>|</span><a href="#42836299">prev</a><span>|</span><a href="#42834192">next</a><span>|</span><label class="collapse" for="c-42833782">[-]</label><label class="expand" for="c-42833782">[9 more]</label></div><br/><div class="children"><div class="content">Thats great if that works for you, and for a lot people and teams. You have just shifted the complexity of networking, storage, firewalling, IP management, L7 proxying to AWS, but hey, you do have click ops there.<p>&gt; DevOps went from something you did when standing up or deploying an application, to an industry-wide jobs program. It’s the TSA of the software world.<p>DevOps was never a job title, or process, it was a way of working, that went beyond yeeting to prod, and ignoring it.<p>From that one line, you never did devops - you did dev, with some deployment tools (that someone else wrote?)</div><br/><div id="42834127" class="c"><input type="checkbox" id="c-42834127" checked=""/><div class="controls bullet"><span class="by">ninjha</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42833782">parent</a><span>|</span><a href="#42834192">next</a><span>|</span><label class="collapse" for="c-42834127">[-]</label><label class="expand" for="c-42834127">[8 more]</label></div><br/><div class="children"><div class="content">You can have Click-Ops on Kubernetes too! Everything has a schema so it&#x27;s possible to build a nice UI on top of it (with some effort).<p>My current project is basically this, except it edits your git-ops config repository, so you can click-ops while you git-ops.</div><br/><div id="42837584" class="c"><input type="checkbox" id="c-42837584" checked=""/><div class="controls bullet"><span class="by">potamic</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834127">parent</a><span>|</span><a href="#42834138">next</a><span>|</span><label class="collapse" for="c-42837584">[-]</label><label class="expand" for="c-42837584">[1 more]</label></div><br/><div class="children"><div class="content">Anywhere we can see your project?</div><br/></div></div><div id="42834138" class="c"><input type="checkbox" id="c-42834138" checked=""/><div class="controls bullet"><span class="by">k8sToGo</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834127">parent</a><span>|</span><a href="#42837584">prev</a><span>|</span><a href="#42834192">next</a><span>|</span><label class="collapse" for="c-42834138">[-]</label><label class="expand" for="c-42834138">[6 more]</label></div><br/><div class="children"><div class="content">You mean ArgoCD and Rancher? Both ready to do click ops!</div><br/><div id="42834172" class="c"><input type="checkbox" id="c-42834172" checked=""/><div class="controls bullet"><span class="by">ninjha</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834138">parent</a><span>|</span><a href="#42834192">next</a><span>|</span><label class="collapse" for="c-42834172">[-]</label><label class="expand" for="c-42834172">[5 more]</label></div><br/><div class="children"><div class="content">I mean you can edit a big YAML file inside ArgoCD, but what I&#x27;m building is an actual web form (e.x. `spec.rules[].http.paths[].pathType` is a dropdown of `Prefix`, `ImplementationSpecific`, `Exact`), and all your documentation inline as you&#x27;re editing.<p>People have tried this before but usually the UI version is not fully complete so you have to drop to YAML. Now that the spec is good enough it&#x27;s possible to build a complete UI for this.</div><br/><div id="42834494" class="c"><input type="checkbox" id="c-42834494" checked=""/><div class="controls bullet"><span class="by">mugsie</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834172">parent</a><span>|</span><a href="#42836779">next</a><span>|</span><label class="collapse" for="c-42834494">[-]</label><label class="expand" for="c-42834494">[2 more]</label></div><br/><div class="children"><div class="content">Yup, and it has the advantage of having a easily backed up state store to represent the actions of the GUI.<p>I always liked the octant UI autogeneration for CRDs and the way it just parsed things correctly from the beginning, if they had an edit mode that would be perfect</div><br/><div id="42834750" class="c"><input type="checkbox" id="c-42834750" checked=""/><div class="controls bullet"><span class="by">ninjha</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834494">parent</a><span>|</span><a href="#42836779">next</a><span>|</span><label class="collapse" for="c-42834750">[-]</label><label class="expand" for="c-42834750">[1 more]</label></div><br/><div class="children"><div class="content">Is there anything in particular you like about what Octant does? I don&#x27;t see anything that actually looks at the object spec, just the status fields &#x2F; etc.</div><br/></div></div></div></div><div id="42836779" class="c"><input type="checkbox" id="c-42836779" checked=""/><div class="controls bullet"><span class="by">liveoneggs</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834172">parent</a><span>|</span><a href="#42834494">prev</a><span>|</span><a href="#42834529">next</a><span>|</span><label class="collapse" for="c-42836779">[-]</label><label class="expand" for="c-42836779">[1 more]</label></div><br/><div class="children"><div class="content">ArgoCD has a &quot;New App&quot; button that opens an actual web form you fill out.</div><br/></div></div><div id="42834529" class="c"><input type="checkbox" id="c-42834529" checked=""/><div class="controls bullet"><span class="by">k8sToGo</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834172">parent</a><span>|</span><a href="#42836779">prev</a><span>|</span><a href="#42834192">next</a><span>|</span><label class="collapse" for="c-42834529">[-]</label><label class="expand" for="c-42834529">[1 more]</label></div><br/><div class="children"><div class="content">Sounds great. An interactive Spec builder, if I understand correctly.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42834192" class="c"><input type="checkbox" id="c-42834192" checked=""/><div class="controls bullet"><span class="by">blazing234</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42833617">parent</a><span>|</span><a href="#42833782">prev</a><span>|</span><a href="#42833819">next</a><span>|</span><label class="collapse" for="c-42834192">[-]</label><label class="expand" for="c-42834192">[1 more]</label></div><br/><div class="children"><div class="content">Why don&#x27;t you just deploy to cloud run on gcp and call it a day</div><br/></div></div><div id="42833819" class="c"><input type="checkbox" id="c-42833819" checked=""/><div class="controls bullet"><span class="by">frazbin</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42833617">parent</a><span>|</span><a href="#42834192">prev</a><span>|</span><a href="#42834107">next</a><span>|</span><label class="collapse" for="c-42833819">[-]</label><label class="expand" for="c-42833819">[4 more]</label></div><br/><div class="children"><div class="content">If I may ask, just to educate myself<p>where do you keep the ECS service&#x2F;task specs and how do you mutate them across your stacks?<p>How long does it take to stand up&#x2F;decomm a new instance of your software stack?<p>How do you handle application lifecycle concerns like database backup&#x2F;restore, migrations&#x2F;upgrades?<p>How have you supported developer stories like &quot;I want to test a commit against our infrastructure without interfering with other development&quot;?<p>I recognize these can all be solved for ECS but I&#x27;m curious about the details and how it&#x27;s going.<p>I have found Kubernetes most useful when maintaining lots of isolated tenants within limited (cheap) infrastructure, esp when velocity of software and deployments is high and has many stakeholders (customer needs their demo!)</div><br/><div id="42834462" class="c"><input type="checkbox" id="c-42834462" checked=""/><div class="controls bullet"><span class="by">liveoneggs</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42833819">parent</a><span>|</span><a href="#42834107">next</a><span>|</span><label class="collapse" for="c-42834462">[-]</label><label class="expand" for="c-42834462">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;AmazonECS&#x2F;latest&#x2F;developerguide&#x2F;Welcome.html" rel="nofollow">https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;AmazonECS&#x2F;latest&#x2F;developerguide&#x2F;...</a><p><a href="https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;AmazonECS&#x2F;latest&#x2F;developerguide&#x2F;example_task_definitions.html" rel="nofollow">https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;AmazonECS&#x2F;latest&#x2F;developerguide&#x2F;...</a><p><a href="https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;AmazonECS&#x2F;latest&#x2F;developerguide&#x2F;clusters.html" rel="nofollow">https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;AmazonECS&#x2F;latest&#x2F;developerguide&#x2F;...</a><p>etc</div><br/><div id="42834530" class="c"><input type="checkbox" id="c-42834530" checked=""/><div class="controls bullet"><span class="by">mugsie</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834462">parent</a><span>|</span><a href="#42834107">next</a><span>|</span><label class="collapse" for="c-42834530">[-]</label><label class="expand" for="c-42834530">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, that doesn&#x27;t really answer the question at all...
Do you just have a pile of cloudformation on your desktop? point and click? tf?
And then none of the actual questions like<p>&gt; How do you handle application lifecycle concerns like database backup&#x2F;restore, migrations&#x2F;upgrades?<p>were even touched.</div><br/><div id="42836751" class="c"><input type="checkbox" id="c-42836751" checked=""/><div class="controls bullet"><span class="by">liveoneggs</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834530">parent</a><span>|</span><a href="#42834107">next</a><span>|</span><label class="collapse" for="c-42836751">[-]</label><label class="expand" for="c-42836751">[1 more]</label></div><br/><div class="children"><div class="content">There is no difference between cloudformation, clicking, terraform, boto, awscli, pulumi, or whatever else. The platform at the other end of those tools is still ECS.<p>Backing up databases isn&#x27;t the job of the container-running platform (ECS), especially not in AWS-world where databases are managed with RDS.<p>The rest of the questions were &quot;how do I run containers on ecs?&quot; in various forms. The answers to all of them is &quot;by asking ecs to run containers in various forms.&quot;</div><br/></div></div></div></div></div></div></div></div><div id="42834107" class="c"><input type="checkbox" id="c-42834107" checked=""/><div class="controls bullet"><span class="by">k8sToGo</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42833617">parent</a><span>|</span><a href="#42833819">prev</a><span>|</span><a href="#42834609">next</a><span>|</span><label class="collapse" for="c-42834107">[-]</label><label class="expand" for="c-42834107">[5 more]</label></div><br/><div class="children"><div class="content">It is always this holier than thou attitude of Software engineers towards DevOps that is annoying. Especially if it comes from ignorance.<p>These days often DevOps is done by former Software Engineers rather than &quot;old fashioned&quot; Sys admins.<p>Just because you are ignorant on how to use AKS efficiently, doesn&#x27;t mean your alternative is better.</div><br/><div id="42835120" class="c"><input type="checkbox" id="c-42835120" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834107">parent</a><span>|</span><a href="#42834584">next</a><span>|</span><label class="collapse" for="c-42835120">[-]</label><label class="expand" for="c-42835120">[2 more]</label></div><br/><div class="children"><div class="content">&gt; These days often DevOps is done by former Software Engineers rather than &quot;old fashioned&quot; Sys admins.<p>Yes, and the world is a poorer place for it. Google’s SRE model works in part because they have _both_ Ops and SWE backgrounds.<p>The thing about traditional Ops is, while it may not scale to Google levels, it does scale quite well to the level most companies need, _and_ along the way, it forces people to learn how computers and systems work to a modicum of depth. If you’re having to ssh into a box to see why a process is dying, you’re going to learn something about that process, systemd, etc. If you drag the dev along with you to fix it, now two people have learned cross-areas.<p>If everything is in a container, and there’s an orchestrator silently replacing dying pods, that no longer needs to exist.<p>To be clear, I _love_ K8s. I run it at home, and have used it professionally at multiple jobs. What I don’t like is how it (and every other abstraction) have made it such that “infra” people haven’t the slightest clue how infra actually operates, and if you sat them down in front of an empty, physical server, they’d have no idea how to bootstrap Linux on it.</div><br/><div id="42837994" class="c"><input type="checkbox" id="c-42837994" checked=""/><div class="controls bullet"><span class="by">k8sToGo</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42835120">parent</a><span>|</span><a href="#42834584">next</a><span>|</span><label class="collapse" for="c-42837994">[-]</label><label class="expand" for="c-42837994">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a fair point I also observed.</div><br/></div></div></div></div><div id="42834584" class="c"><input type="checkbox" id="c-42834584" checked=""/><div class="controls bullet"><span class="by">mugsie</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834107">parent</a><span>|</span><a href="#42835120">prev</a><span>|</span><a href="#42836251">next</a><span>|</span><label class="collapse" for="c-42834584">[-]</label><label class="expand" for="c-42834584">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, DevOps was a culture not a job title, and then we let us software engineers in who just want to throw something into prod and go home on friday night, so they decided it was a task, and the lowest importance thing possible, but simultaniously, the devops&#x2F;sre&#x2F;prod eng teams needed to be perfect,  because its prod.<p>it is a wierd dichotomy I have seem, and it is getting worse. We let teams have access to argo manifiests, and helm charts, and even let them do custom in repo charts.<p>not one team in the last year has actually gone and looked at k8s docs to figure out how to do basic shit, they just dump questions into channels, and soak up time from people explaining the basics of the system their software runs on.</div><br/></div></div><div id="42836251" class="c"><input type="checkbox" id="c-42836251" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834107">parent</a><span>|</span><a href="#42834584">prev</a><span>|</span><a href="#42834609">next</a><span>|</span><label class="collapse" for="c-42836251">[-]</label><label class="expand" for="c-42836251">[1 more]</label></div><br/><div class="children"><div class="content">Nah, I&#x27;m delighted if someone wants to do it.<p>Not as delighted by the fact that many companies seem to want developers to do devops as well, like when the code is compiling or something.<p>It&#x27;s not being taken seriously.</div><br/></div></div></div></div><div id="42834609" class="c"><input type="checkbox" id="c-42834609" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42833617">parent</a><span>|</span><a href="#42834107">prev</a><span>|</span><a href="#42836557">next</a><span>|</span><label class="collapse" for="c-42834609">[-]</label><label class="expand" for="c-42834609">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m so confused about the jobs program thing. I&#x27;m an infra engineer who has had the title devops for parts of my career. I feel like I&#x27;ve always been <i>desperately</i> needed by teams of software devs that don&#x27;t want to concern themselves with the gritty reality of actually running software in production. The job kinda sucks but for some reason jives with my brain. I take a huge amount of work and responsibility off the plates of my devs and my work scales well to multiple teams and multiple products.<p>I&#x27;ve never seen an infra&#x2F;devops&#x2F;platform team
not swamped with work and just spinning their tires on random unnecessary projects. We&#x27;re more expensive on average than devs, harder to hire, and two degrees separated from revenue. We&#x27;re not a typically overstaffed role.</div><br/></div></div></div></div><div id="42836557" class="c"><input type="checkbox" id="c-42836557" checked=""/><div class="controls bullet"><span class="by">ryandv</span><span>|</span><a href="#42833558">parent</a><span>|</span><a href="#42833617">prev</a><span>|</span><a href="#42837168">next</a><span>|</span><label class="collapse" for="c-42836557">[-]</label><label class="expand" for="c-42836557">[1 more]</label></div><br/><div class="children"><div class="content">You have some computing resource that needs to be provisioned according to the specifications laid out in a Kubernetes manifest (YAML). Something needs to go out and actually &quot;physically&quot; create or retrieve that resource, with all the side-effects that involves, bring its state into accordance with whatever the manifest specifies, and continuously make adjustments when the resource&#x27;s state diverges from the manifest throughout the lifetime of the resource.<p>One example is a controller responsible for fulfilling ACME challenges to obtain x509 certificates. Something needs to actually publish the challenge responses somewhere on the internet, retrieve the x509 certificate, and then persist it onto the cluster so that it may be used by other applications. Something needs to handle certificate renewal on an ongoing basis. That something  is the controller.</div><br/></div></div><div id="42837168" class="c"><input type="checkbox" id="c-42837168" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#42833558">parent</a><span>|</span><a href="#42836557">prev</a><span>|</span><a href="#42835290">next</a><span>|</span><label class="collapse" for="c-42837168">[-]</label><label class="expand" for="c-42837168">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t want to write a Kubernetes controller. I don&#x27;t even know why it should exist.<p>I don&#x27;t want to write one either. Given the choice, I won&#x27;t even touch one.<p>I think I know why they exist, though. Kubernetes is a system of actors (resources) and events (state transitions). If you want to derive new state from existing state, and to maintain that new state, then you need something that observes &quot;lower&quot; state transitions and takes action on the system to achieve its desired &quot;higher&quot; state.<p>Whether we invent terminology for these things or not, controllers exist in all such systems.</div><br/></div></div><div id="42835290" class="c"><input type="checkbox" id="c-42835290" checked=""/><div class="controls bullet"><span class="by">ianburrell</span><span>|</span><a href="#42833558">parent</a><span>|</span><a href="#42837168">prev</a><span>|</span><a href="#42833742">next</a><span>|</span><label class="collapse" for="c-42835290">[-]</label><label class="expand" for="c-42835290">[1 more]</label></div><br/><div class="children"><div class="content">How do you run multiple copies of an application? How do you start new copy when one fails? How do you deploy changes to the system? That is the orchestrator.<p>What do you do when site gets really popular and needs new copies? What happens when fill the VMs?If you want to automate it, that is a controller.<p>Also, if you are running on-premise, you don&#x27;t need VM, you can use the whole machine for Kubernetes and containers for isolation. If you need more isolation, you can run VM containers; being able to switch is advantage of Kubernetes.</div><br/></div></div><div id="42833742" class="c"><input type="checkbox" id="c-42833742" checked=""/><div class="controls bullet"><span class="by">mugsie</span><span>|</span><a href="#42833558">parent</a><span>|</span><a href="#42835290">prev</a><span>|</span><a href="#42836548">next</a><span>|</span><label class="collapse" for="c-42833742">[-]</label><label class="expand" for="c-42833742">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, for a lot of companies, this is way overkill. Thats fine, don&#x27;t use it! In the places I have seen use it when it is actually needed, the controller makes a lot of work for teams disappear. It exists, because thats how K8S itself works? - how it translates from a deployment -&gt; replica set -&gt; pod -&gt; container.<p>Abstractions are useful to stop 100000s lines of boiler plate code. Same reason we have terraform providers, Ansible modules, and well, the same concepts in programming ...</div><br/></div></div><div id="42836548" class="c"><input type="checkbox" id="c-42836548" checked=""/><div class="controls bullet"><span class="by">nejsjsjsbsb</span><span>|</span><a href="#42833558">parent</a><span>|</span><a href="#42833742">prev</a><span>|</span><a href="#42835706">next</a><span>|</span><label class="collapse" for="c-42836548">[-]</label><label class="expand" for="c-42836548">[1 more]</label></div><br/><div class="children"><div class="content">Because the works on my machine meme, plus the cattle not pets lore.<p>Why do this for relational databases? Why do I need to write a pg extension and SQL and an ORM when I can just write to disk?</div><br/></div></div><div id="42835706" class="c"><input type="checkbox" id="c-42835706" checked=""/><div class="controls bullet"><span class="by">chrismarlow9</span><span>|</span><a href="#42833558">parent</a><span>|</span><a href="#42836548">prev</a><span>|</span><a href="#42834893">next</a><span>|</span><label class="collapse" for="c-42835706">[-]</label><label class="expand" for="c-42835706">[1 more]</label></div><br/><div class="children"><div class="content">Because most places never needed kubernetes but used it to put their technical debt on a credit line. So what do you do when they try to collect? Well you just take out another loan to pay off the first one.</div><br/></div></div><div id="42834893" class="c"><input type="checkbox" id="c-42834893" checked=""/><div class="controls bullet"><span class="by">antonvs</span><span>|</span><a href="#42833558">parent</a><span>|</span><a href="#42835706">prev</a><span>|</span><a href="#42838081">next</a><span>|</span><label class="collapse" for="c-42834893">[-]</label><label class="expand" for="c-42834893">[3 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re implementing a distributed system that needs to manage many custom resources (of whatever kind, not Kubernetes-specific), implementing a Kubernetes controller for it can save a great deal of development time and give you a better system in the end, with standard built-in observability, manageability, deployment automation, and a whole lot else.<p>It&#x27;s certainly true that some use of Kubernetes is overkill. But if you actually need what it offers, it can be a game-changer. That&#x27;s a big reason why it caught on so fast in big enterprises.<p>Don&#x27;t fall into the trap of thinking that because you don&#x27;t understand the need for something, that the need doesn&#x27;t exist.</div><br/><div id="42836319" class="c"><input type="checkbox" id="c-42836319" checked=""/><div class="controls bullet"><span class="by">nijave</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42834893">parent</a><span>|</span><a href="#42838081">next</a><span>|</span><label class="collapse" for="c-42836319">[-]</label><label class="expand" for="c-42836319">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m always surprised when people say Kubernetes is overkill in the context of distributed systems. You&#x27;ll end up running all the same stuff yourself but have to manage the integration yourself as well (traffic&#x2F;L7, config, storage, app instances, network&#x2F;L1-4)</div><br/><div id="42837777" class="c"><input type="checkbox" id="c-42837777" checked=""/><div class="controls bullet"><span class="by">antonvs</span><span>|</span><a href="#42833558">root</a><span>|</span><a href="#42836319">parent</a><span>|</span><a href="#42838081">next</a><span>|</span><label class="collapse" for="c-42837777">[-]</label><label class="expand" for="c-42837777">[1 more]</label></div><br/><div class="children"><div class="content">Right, the key is &quot;distributed systems&quot;. The overkill tends to come in when someone decides to use Kubernetes to run e.g. a single web application and database - which is not particularly &quot;distributed&quot; on the back end - or something that they could run with say Docker Compose on a single machine.<p>A chart of effort vs. complexity would show this nicely. Kubernetes involves a baseline level of effort that&#x27;s higher than simpler alternatives, which is the &quot;overkill&quot; part of the chart. But once complexity reaches a certain level, the effort involved in alternatives grows higher and faster.<p>&gt; (traffic&#x2F;L7, config, storage, app instances, network&#x2F;L1-4)<p>Cloud and PaaS providers can do a lot of this for you though. Of course some of the PaaS providers are built on Kubernetes, but the point is they&#x27;re the ones expending that effort for you.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>