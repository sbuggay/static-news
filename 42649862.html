<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1736845251939" as="style"/><link rel="stylesheet" href="styles.css?v=1736845251939"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.downtowndougbrown.com/2024/04/why-is-my-cpu-usage-always-100-upgrading-my-chumby-8-kernel-part-9/">Why is my CPU usage always 100%?</a> <span class="domain">(<a href="https://www.downtowndougbrown.com">www.downtowndougbrown.com</a>)</span></div><div class="subtext"><span>pncnmnp</span> | <span>138 comments</span></div><br/><div><div id="42682547" class="c"><input type="checkbox" id="c-42682547" checked=""/><div class="controls bullet"><span class="by">WediBlino</span><span>|</span><a href="#42680977">next</a><span>|</span><label class="collapse" for="c-42682547">[-]</label><label class="expand" for="c-42682547">[54 more]</label></div><br/><div class="children"><div class="content">An old manager of mine once spent the day trying to kill a process that was running at 99% on Windows box.<p>When I finally got round to see what he was doing I was disappointed to find he was attempting to kill the &#x27;system idle&#x27; process.</div><br/><div id="42685227" class="c"><input type="checkbox" id="c-42685227" checked=""/><div class="controls bullet"><span class="by">Twirrim</span><span>|</span><a href="#42682547">parent</a><span>|</span><a href="#42682856">next</a><span>|</span><label class="collapse" for="c-42685227">[-]</label><label class="expand" for="c-42685227">[7 more]</label></div><br/><div class="children"><div class="content">Years ago I worked for a company that provided managed hosting services.  That included some level of alarm watching for customers.<p>We used to rotate the &quot;person of contact&quot; (POC) each shift, and they were responsible for reaching out to customers, and doing initial ticket triage.<p>One customer kept having a CPU usage alarm go off on their Windows instances not long after midnight.  The overnight POC reached out to the customer to let them know that they had investigated and noticed that &quot;system idle processes&quot; were taking up 99% of CPU time and the customer should probably investigate, and then closed the ticket.<p>I saw the ticket within a minute or two of it reopening as the customer responded with a barely diplomatic message to the tune of &quot;WTF&quot;.  I picked up that ticket, and within 2 minutes had figured out the high CPU alarm was being caused by the backup service we provided, apologised to the customer and had that ticket closed... but not before someone not in the team saw the ticket and started sharing it around.<p>I would love to say that particular support staff never lived that incident down, but sadly that particular incident was par for the course with them, and the team spent inordinate amount of time doing damage control with customers.</div><br/><div id="42686182" class="c"><input type="checkbox" id="c-42686182" checked=""/><div class="controls bullet"><span class="by">panarky</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42685227">parent</a><span>|</span><a href="#42682856">next</a><span>|</span><label class="collapse" for="c-42686182">[-]</label><label class="expand" for="c-42686182">[6 more]</label></div><br/><div class="children"><div class="content">In the 90s I worked for a retail chain where the CIO proposed to spend millions to upgrade the point-of-sale hardware. The old hardware was only a year old, but the CPU was pegged at 100% on every device and scanning barcodes was very sluggish.<p>He justified the capex by saying if cashiers could scan products faster, customers would spend less time in line and sales would go up.<p>A little digging showed that the CIO wrote the point-of-sale software himself in an ancient version of Visual Basic.<p>I didn&#x27;t know VB, but it didn&#x27;t take long to find the loops that do nothing except count to large numbers to soak up CPU cycles since VB didn&#x27;t have a sleep() function.</div><br/><div id="42687889" class="c"><input type="checkbox" id="c-42687889" checked=""/><div class="controls bullet"><span class="by">jimt1234</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42686182">parent</a><span>|</span><a href="#42692817">next</a><span>|</span><label class="collapse" for="c-42687889">[-]</label><label class="expand" for="c-42687889">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s hilarious. I had a similar situation, also back in the 90s, when a developer shipped some code that kept pegging the CPU on a production server. He insisted it was the server, and the company should spend $$$ on a new one to fix the problem. We went back-and-forth for a while: his code was crap versus the server hardware was inadequate, and I was losing the battle, because I was just a lowly sysadmin, while he was a great software engineer. Also, it was Java code, and back then, Java was kinda new, and everyone thought it could do no wrong. I wasn&#x27;t a developer at all back then, but I decided to take a quick look at his code. It was basically this:<p>1. take input from a web form<p>2. do an expensive database lookup<p>3. do an expensive network request, wait for response<p>4. do another expensive network request, wait for response<p>5. and, of course, another expensive network request, wait for response<p>6. fuck it, another expensive network request, wait for response<p>7. a couple more database lookups for customer data<p>8. store the data in a table<p>9. store the same data in another table. and, of course, another one.<p>10. now, check to see if the form was submitted with valid data. if not, repeat all steps above to back-out the data from where it was written.<p>11. finally, check to see if the customer is a valid&#x2F;paying customer. if not, once again, repeat all the steps above to back-out the data.<p>I looked at the logs, and something like 90% of the requests were invalid data from the web form or invalid&#x2F;non-paying customers (this service was provided only to paying customers).<p>I was so upset from this dude convincing management that my server was the problem that I sent an email to pretty much everyone that said, basically, &quot;This code sucks. Here&#x27;s the problem: check for invalid data&#x2F;customers first.&quot;, and I included a snippet from the code. The dude replied-to-all immediately, claiming I didn&#x27;t know anything about Java code, and I should stay in my lane. Well, throughout the day, other emails started to trickle in, saying, &quot;Yeah, the code is the problem here. Please fit it ASAP.&quot; The dude was so upset that he just left, he went completely AWOL, he didn&#x27;t show up to work for a week or so. We were all worried, like he jumped off a bridge or something. It turned into an HR incident. When he finally returned, he complained to HR that I stabbed him in the back, that he couldn&#x27;t work with me because I was so rude. I didn&#x27;t really care; I was a kid. Oh yeah, his nickname became AWOL Wang. LOL</div><br/><div id="42688964" class="c"><input type="checkbox" id="c-42688964" checked=""/><div class="controls bullet"><span class="by">eludwig</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42687889">parent</a><span>|</span><a href="#42692817">next</a><span>|</span><label class="collapse" for="c-42688964">[-]</label><label class="expand" for="c-42688964">[2 more]</label></div><br/><div class="children"><div class="content">Hehe, being a Java dev since the late 90’s meant seeing a lot of bad code. My favorite was when I was working for a large life insurance company.<p>The company’s customer-facing website was servlet based. The main servlet was performing horribly, time outs, spinners, errors etc. Our team looked at the code and found that the original team implementing the logic had a problem they couldn’t figure out how to solve, so they decided to apply the big hammer: they synchronized the doService() method… oh dear…</div><br/><div id="42689414" class="c"><input type="checkbox" id="c-42689414" checked=""/><div class="controls bullet"><span class="by">foobazgt</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42688964">parent</a><span>|</span><a href="#42692817">next</a><span>|</span><label class="collapse" for="c-42689414">[-]</label><label class="expand" for="c-42689414">[1 more]</label></div><br/><div class="children"><div class="content">For those not familiar with servlets, this means serializing every single request to the server that hits that servlet. And a single servlet can serve many different pages. In fact, in the early days, servlet filters didn&#x27;t exist, so you would often implement cross-cutting functionality like authentication using a servlet.<p>TBF, I don&#x27;t think a lot of developers at the time (90&#x27;s) were used to the idea of having to write MT-safe callback code. Nowadays thousands of object allocations per second is nothing to sweat over, so a framework might make a different decision to instantiate callbacks per request by default.</div><br/></div></div></div></div></div></div><div id="42692817" class="c"><input type="checkbox" id="c-42692817" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42686182">parent</a><span>|</span><a href="#42687889">prev</a><span>|</span><a href="#42682856">next</a><span>|</span><label class="collapse" for="c-42692817">[-]</label><label class="expand" for="c-42692817">[2 more]</label></div><br/><div class="children"><div class="content">I am a little confused. He was intentionally sabotaging performance?</div><br/><div id="42694836" class="c"><input type="checkbox" id="c-42694836" checked=""/><div class="controls bullet"><span class="by">aoanevdus</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42692817">parent</a><span>|</span><a href="#42682856">next</a><span>|</span><label class="collapse" for="c-42694836">[-]</label><label class="expand" for="c-42694836">[1 more]</label></div><br/><div class="children"><div class="content">People write code that does sleep statements when waiting for something else to happen. It makes sense in some contexts. Think of it like async&#x2F;await with an event loop. Except you are using the OS scheduler like your “event loop”. And you sleep instead of awaiting.<p>Now, if your language lacks the sleep statement or some other way to yield execution, what should you do instead when your program has no work to do? Actually, I don’t know what the answer is.</div><br/></div></div></div></div></div></div></div></div><div id="42682856" class="c"><input type="checkbox" id="c-42682856" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#42682547">parent</a><span>|</span><a href="#42685227">prev</a><span>|</span><a href="#42682841">next</a><span>|</span><label class="collapse" for="c-42682856">[-]</label><label class="expand" for="c-42682856">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what managers do.<p>Silly idle process.<p>If you&#x27;ve got time for leanin&#x27;, you&#x27;ve got time for cleanin&#x27;</div><br/></div></div><div id="42682841" class="c"><input type="checkbox" id="c-42682841" checked=""/><div class="controls bullet"><span class="by">cassepipe</span><span>|</span><a href="#42682547">parent</a><span>|</span><a href="#42682856">prev</a><span>|</span><a href="#42685953">next</a><span>|</span><label class="collapse" for="c-42682841">[-]</label><label class="expand" for="c-42682841">[16 more]</label></div><br/><div class="children"><div class="content">I abandonned Windows 8 for linux because of an bug (?) where my HDD was showing it was 99% busy all the time. I had removed every startup program that could be and analysed thouroughly for any viruses, to no avail. Had no debugging skills at the time and wasn&#x27;t sure the hardware could stand windows 10. That&#x27;s how linux got me.</div><br/><div id="42685063" class="c"><input type="checkbox" id="c-42685063" checked=""/><div class="controls bullet"><span class="by">ryandrake</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42682841">parent</a><span>|</span><a href="#42684887">next</a><span>|</span><label class="collapse" for="c-42685063">[-]</label><label class="expand" for="c-42685063">[9 more]</label></div><br/><div class="children"><div class="content">Recent Linux distributions are quickly catching up to Windows and macOS. Do a fresh install of your favorite distribution and then use &#x27;ps&#x27; to look at what&#x27;s running. Dozens of processes doing who knows what? They&#x27;re probably not pegging your CPU at 100%, which is good, but it seems that gone are the days when you could turn on your computer and it was truly idle until you commanded it to actually do something. That&#x27;s a special use case now, I suppose.</div><br/><div id="42685555" class="c"><input type="checkbox" id="c-42685555" checked=""/><div class="controls bullet"><span class="by">ndriscoll</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42685063">parent</a><span>|</span><a href="#42687423">next</a><span>|</span><label class="collapse" for="c-42685555">[-]</label><label class="expand" for="c-42685555">[1 more]</label></div><br/><div class="children"><div class="content">IME on Linux the only things that use random CPU while idle are web browsers. Otherwise, there&#x27;s dbus and NetworkManager and bluez and oomd and stuff, but most processes have a fraction of a second used CPU over months. If they&#x27;re not using CPU, they&#x27;ll presumably swap out if needed, so they&#x27;re using ~nothing.</div><br/></div></div><div id="42687423" class="c"><input type="checkbox" id="c-42687423" checked=""/><div class="controls bullet"><span class="by">craftkiller</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42685063">parent</a><span>|</span><a href="#42685555">prev</a><span>|</span><a href="#42685561">next</a><span>|</span><label class="collapse" for="c-42687423">[-]</label><label class="expand" for="c-42687423">[1 more]</label></div><br/><div class="children"><div class="content">This is one the reasons I love FreeBSD. You boot up a fresh install of FreeBSD and there are only a couple processes running and I know what each of them does &#x2F; why they are there.</div><br/></div></div><div id="42685561" class="c"><input type="checkbox" id="c-42685561" checked=""/><div class="controls bullet"><span class="by">johnmaguire</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42685063">parent</a><span>|</span><a href="#42687423">prev</a><span>|</span><a href="#42688563">next</a><span>|</span><label class="collapse" for="c-42685561">[-]</label><label class="expand" for="c-42685561">[4 more]</label></div><br/><div class="children"><div class="content">this is why I use arch btw</div><br/><div id="42686401" class="c"><input type="checkbox" id="c-42686401" checked=""/><div class="controls bullet"><span class="by">diggan</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42685561">parent</a><span>|</span><a href="#42688064">next</a><span>|</span><label class="collapse" for="c-42686401">[-]</label><label class="expand" for="c-42686401">[1 more]</label></div><br/><div class="children"><div class="content">Add Gnome3 and you can have that too! Source: me, a arch+gnome user, who recently had to turn off the search indexer as it was stuck processing countless multi-GB binary files...</div><br/></div></div><div id="42688064" class="c"><input type="checkbox" id="c-42688064" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42685561">parent</a><span>|</span><a href="#42686401">prev</a><span>|</span><a href="#42685817">next</a><span>|</span><label class="collapse" for="c-42688064">[-]</label><label class="expand" for="c-42688064">[1 more]</label></div><br/><div class="children"><div class="content">Exactly, or Void, or Alpine, but I love pacman.</div><br/></div></div><div id="42685817" class="c"><input type="checkbox" id="c-42685817" checked=""/><div class="controls bullet"><span class="by">rirze</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42685561">parent</a><span>|</span><a href="#42688064">prev</a><span>|</span><a href="#42688563">next</a><span>|</span><label class="collapse" for="c-42685817">[-]</label><label class="expand" for="c-42685817">[1 more]</label></div><br/><div class="children"><div class="content">this guy arches</div><br/></div></div></div></div><div id="42688563" class="c"><input type="checkbox" id="c-42688563" checked=""/><div class="controls bullet"><span class="by">m3047</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42685063">parent</a><span>|</span><a href="#42685561">prev</a><span>|</span><a href="#42691939">next</a><span>|</span><label class="collapse" for="c-42688563">[-]</label><label class="expand" for="c-42688563">[1 more]</label></div><br/><div class="children"><div class="content">At least under some circumstances Linux shows (schedulable) threads as separate processes. Just be aware of that.</div><br/></div></div><div id="42691939" class="c"><input type="checkbox" id="c-42691939" checked=""/><div class="controls bullet"><span class="by">ciupicri</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42685063">parent</a><span>|</span><a href="#42688563">prev</a><span>|</span><a href="#42684887">next</a><span>|</span><label class="collapse" for="c-42691939">[-]</label><label class="expand" for="c-42691939">[1 more]</label></div><br/><div class="children"><div class="content">I recommend using systemd-cgls to get a better idea of what&#x27;s going on.</div><br/></div></div></div></div><div id="42684887" class="c"><input type="checkbox" id="c-42684887" checked=""/><div class="controls bullet"><span class="by">margana</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42682841">parent</a><span>|</span><a href="#42685063">prev</a><span>|</span><a href="#42683480">next</a><span>|</span><label class="collapse" for="c-42684887">[-]</label><label class="expand" for="c-42684887">[3 more]</label></div><br/><div class="children"><div class="content">Why is this such a huge issue if it merely shows it&#x27;s busy, but the performance of it indicates that it actually isn&#x27;t? Switching to Linux can be a good choice for a lot of people, the reason just seems a bit odd here. Maybe it was simply the straw that broke the camel&#x27;s back.</div><br/><div id="42685670" class="c"><input type="checkbox" id="c-42685670" checked=""/><div class="controls bullet"><span class="by">RHSeeger</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42684887">parent</a><span>|</span><a href="#42686332">next</a><span>|</span><label class="collapse" for="c-42685670">[-]</label><label class="expand" for="c-42685670">[1 more]</label></div><br/><div class="children"><div class="content">1. I expect that a HD that is actually doing things 100% of the time is going to have it&#x27;s lifespan significantly reduce, and<p>2. If it isn&#x27;t doing anything and it just lying to you... when there IS a problem, your tools to diagnose the problem are limited because you can&#x27;t trust what they&#x27;re telling you</div><br/></div></div><div id="42686332" class="c"><input type="checkbox" id="c-42686332" checked=""/><div class="controls bullet"><span class="by">ddingus</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42684887">parent</a><span>|</span><a href="#42685670">prev</a><span>|</span><a href="#42683480">next</a><span>|</span><label class="collapse" for="c-42686332">[-]</label><label class="expand" for="c-42686332">[1 more]</label></div><br/><div class="children"><div class="content">Over the years I have used top and friends to profile machines and identify expensive bottlenecks.  Once one comes to count on those tools, the idea of one being wrong, and actually really wrong!  --is just a bad rub.<p>Fixing it would be gratifying and reassuring too.</div><br/></div></div></div></div><div id="42683480" class="c"><input type="checkbox" id="c-42683480" checked=""/><div class="controls bullet"><span class="by">saintfire</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42682841">parent</a><span>|</span><a href="#42684887">prev</a><span>|</span><a href="#42685489">next</a><span>|</span><label class="collapse" for="c-42683480">[-]</label><label class="expand" for="c-42683480">[1 more]</label></div><br/><div class="children"><div class="content">I had this happen with an nvme drive. Tried changing just about every setting that affected the slot.<p>Everything worked fine on my Linux install ootb</div><br/></div></div><div id="42685489" class="c"><input type="checkbox" id="c-42685489" checked=""/><div class="controls bullet"><span class="by">BizarroLand</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42682841">parent</a><span>|</span><a href="#42683480">prev</a><span>|</span><a href="#42684588">next</a><span>|</span><label class="collapse" for="c-42685489">[-]</label><label class="expand" for="c-42685489">[1 more]</label></div><br/><div class="children"><div class="content">Windows 8&#x2F;8.1&#x2F;10 had an issue for a while where when it was run on spinning rust HDD it would peg it out and slow the system to a crawl.<p>The only solution was to swap over to a SSD.</div><br/></div></div></div></div><div id="42685953" class="c"><input type="checkbox" id="c-42685953" checked=""/><div class="controls bullet"><span class="by">nullhole</span><span>|</span><a href="#42682547">parent</a><span>|</span><a href="#42682841">prev</a><span>|</span><a href="#42686936">next</a><span>|</span><label class="collapse" for="c-42685953">[-]</label><label class="expand" for="c-42685953">[4 more]</label></div><br/><div class="children"><div class="content">To be fair, it is a really poorly named &quot;process&quot;. The computer equivalent of the &quot;everything&#x27;s ok&quot; alarm.</div><br/><div id="42686110" class="c"><input type="checkbox" id="c-42686110" checked=""/><div class="controls bullet"><span class="by">chowells</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42685953">parent</a><span>|</span><a href="#42686936">next</a><span>|</span><label class="collapse" for="c-42686110">[-]</label><label class="expand" for="c-42686110">[3 more]</label></div><br/><div class="children"><div class="content">Long enough ago (win95 era) it wasn&#x27;t part of Windows to sleep the CPU when there was no work to be done. It always assigned some task to the CPU. The system idle process was a way to do this that played nicely with all of the other process management systems. I don&#x27;t remember when they finally added CPU power management. SP3? Win98? Win98SE? Eh, it was somewhere in there.</div><br/><div id="42687040" class="c"><input type="checkbox" id="c-42687040" checked=""/><div class="controls bullet"><span class="by">drsopp</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42686110">parent</a><span>|</span><a href="#42693299">next</a><span>|</span><label class="collapse" for="c-42687040">[-]</label><label class="expand" for="c-42687040">[1 more]</label></div><br/><div class="children"><div class="content">I remember listening on FM radio to my 100MHz computer running FreeBSD, which sounded like calm rain, and to Windows 95, which sounded like a screaming monster.</div><br/></div></div><div id="42693299" class="c"><input type="checkbox" id="c-42693299" checked=""/><div class="controls bullet"><span class="by">eggsome</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42686110">parent</a><span>|</span><a href="#42687040">prev</a><span>|</span><a href="#42686936">next</a><span>|</span><label class="collapse" for="c-42693299">[-]</label><label class="expand" for="c-42693299">[1 more]</label></div><br/><div class="children"><div class="content">There were a number of hacks to deal with this. RAIN was very popular back in the day, but AMNHLTM appears to have better compatibility with modern CPUs.</div><br/></div></div></div></div></div></div><div id="42686936" class="c"><input type="checkbox" id="c-42686936" checked=""/><div class="controls bullet"><span class="by">Agentus</span><span>|</span><a href="#42682547">parent</a><span>|</span><a href="#42685953">prev</a><span>|</span><a href="#42689627">next</a><span>|</span><label class="collapse" for="c-42686936">[-]</label><label class="expand" for="c-42686936">[2 more]</label></div><br/><div class="children"><div class="content">reminds of when i was a kid and noticed a virus had taken over a registry.  from that point forward i attempted to delete every single registry file, not quite understanding.  Between that and excessive bad website viewing, I dunno how i ever managed to not brick my operating system, unlike my grandma who seemed to brick her desktop in a timely fashion before each of the many monthly visits to her place.</div><br/><div id="42690219" class="c"><input type="checkbox" id="c-42690219" checked=""/><div class="controls bullet"><span class="by">bornfreddy</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42686936">parent</a><span>|</span><a href="#42689627">next</a><span>|</span><label class="collapse" for="c-42690219">[-]</label><label class="expand" for="c-42690219">[1 more]</label></div><br/><div class="children"><div class="content">The things grandmas do to see their grandsons regularly. Smart. :-)</div><br/></div></div></div></div><div id="42689627" class="c"><input type="checkbox" id="c-42689627" checked=""/><div class="controls bullet"><span class="by">jsight</span><span>|</span><a href="#42682547">parent</a><span>|</span><a href="#42686936">prev</a><span>|</span><a href="#42682677">next</a><span>|</span><label class="collapse" for="c-42689627">[-]</label><label class="expand" for="c-42689627">[1 more]</label></div><br/><div class="children"><div class="content">I worked at a government site with a government machine at one time. I had an issue, so I took it to the IT desk. They were able to get that sorted, but then said I had another issue. &quot;Your CPU is running at 100% all the time, because some sort of unkillable process is consuming all your cpu&quot;.<p>Yep, that was &quot;System Idle&quot; that was doing it. They had the best people.</div><br/></div></div><div id="42682677" class="c"><input type="checkbox" id="c-42682677" checked=""/><div class="controls bullet"><span class="by">belter</span><span>|</span><a href="#42682547">parent</a><span>|</span><a href="#42689627">prev</a><span>|</span><a href="#42687956">next</a><span>|</span><label class="collapse" for="c-42682677">[-]</label><label class="expand" for="c-42682677">[1 more]</label></div><br/><div class="children"><div class="content">Did he have a pointy hair?</div><br/></div></div><div id="42687956" class="c"><input type="checkbox" id="c-42687956" checked=""/><div class="controls bullet"><span class="by">mrmuagi</span><span>|</span><a href="#42682547">parent</a><span>|</span><a href="#42682677">prev</a><span>|</span><a href="#42686896">next</a><span>|</span><label class="collapse" for="c-42687956">[-]</label><label class="expand" for="c-42687956">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if you make a process with idle in it you could end up in the reverse track where users ignore it. Is there anything preventing an executable being named System Idle.</div><br/></div></div><div id="42686896" class="c"><input type="checkbox" id="c-42686896" checked=""/><div class="controls bullet"><span class="by">fifilura</span><span>|</span><a href="#42682547">parent</a><span>|</span><a href="#42687956">prev</a><span>|</span><a href="#42682931">next</a><span>|</span><label class="collapse" for="c-42686896">[-]</label><label class="expand" for="c-42686896">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, there are worse mistakes. It does say 99% CPU.</div><br/></div></div><div id="42682931" class="c"><input type="checkbox" id="c-42682931" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#42682547">parent</a><span>|</span><a href="#42686896">prev</a><span>|</span><a href="#42689706">next</a><span>|</span><label class="collapse" for="c-42682931">[-]</label><label class="expand" for="c-42682931">[17 more]</label></div><br/><div class="children"><div class="content">Windows used to have that habit of making the processes CPU starved, and yet claiming the CPU was idle all the time.<p>Since the Microsoft response to the bug was denying and gaslighting the affected people, we can&#x27;t tell for sure what caused it. But several people were in a situation where their computer couldn&#x27;t finish any work, and the task-manager claimed all of the CPU time was spent on that line item.</div><br/><div id="42688425" class="c"><input type="checkbox" id="c-42688425" checked=""/><div class="controls bullet"><span class="by">nerdile</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42682931">parent</a><span>|</span><a href="#42684568">next</a><span>|</span><label class="collapse" for="c-42688425">[-]</label><label class="expand" for="c-42688425">[2 more]</label></div><br/><div class="children"><div class="content">As a former Windows OS engineer, based on the short statement here, my assumption would be that your programs are IO-bound, not CPU-bound, and that the next step would be to gather data (using a profiler) to investigate the bottlenecks. This is something any Win32 developer should learn how to do.<p>Although I can understand how &quot;Please provide data to demonstrate that this is an OS scheduling issue since app bottlenecks are much more likely in our experience&quot; could come across as &quot;denying and gaslighting&quot; to less experienced engineers and layfolk</div><br/><div id="42692029" class="c"><input type="checkbox" id="c-42692029" checked=""/><div class="controls bullet"><span class="by">1000100_1000101</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42688425">parent</a><span>|</span><a href="#42684568">next</a><span>|</span><label class="collapse" for="c-42692029">[-]</label><label class="expand" for="c-42692029">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not the original poster, but I ran into something similar late in Win 7 (Win 8 was in beta at the time).  We had some painting software, and we used open-MP to work on each scan-line of a brush in parallel.<p>It worked fine on Mac.  On Windows though, if you let it use as many threads as there were CPUs, it would nearly 100% of the time fail before making it through our test suite.  Something in scheduling the work would deadlock.  It was more likely to fail if anything was open besides the app.  Basically, a brush stoke that should complete in a tenth of a second would stall.  If you waited 30-60 minutes (yes minutes), it would recover and continue.<p>I vaguely recall we used the Intel compiler implementation of OpenMP, not what comes with MSVC, so the fault wasn&#x27;t necessarily a Microsoft issue, but could still be a kernel issue.<p>I left that company later that year, and MS rolled out Windows 8.  No idea how long that bug stuck around.</div><br/></div></div></div></div><div id="42684568" class="c"><input type="checkbox" id="c-42684568" checked=""/><div class="controls bullet"><span class="by">RajT88</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42682931">parent</a><span>|</span><a href="#42688425">prev</a><span>|</span><a href="#42683362">next</a><span>|</span><label class="collapse" for="c-42684568">[-]</label><label class="expand" for="c-42684568">[11 more]</label></div><br/><div class="children"><div class="content">&gt; Since the Microsoft response to the bug was denying and gaslighting the affected people<p>Well.  I wouldn&#x27;t go that far.  Any busy dev team is incentivized to make you run the gauntlet:<p>1. It&#x27;s not an issue (you have to prove to me it&#x27;s an issue)<p>2. It&#x27;s not <i>my</i> issue (you have to prove to me it&#x27;s my issue)<p>3. It&#x27;s not that important (you have to prove it has significant business value to fix it)<p>4. It&#x27;s not that time sensitive (you have to prove it&#x27;s worth fixing soon)<p>It was exactly like this at my last few companies.  Microsoft is quite a lot like this as well.<p>If you have an assigned CSAM, they can help run the gauntlet.  That&#x27;s what they are there for.<p>See also: The 6 stages of developer realization:<p><a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Panvola-Debugging-Computer-Programmer-Programming&#x2F;dp&#x2F;B0BQ76LN3T" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;Panvola-Debugging-Computer-Programmer...</a></div><br/><div id="42685320" class="c"><input type="checkbox" id="c-42685320" checked=""/><div class="controls bullet"><span class="by">Twirrim</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42684568">parent</a><span>|</span><a href="#42694572">next</a><span>|</span><label class="collapse" for="c-42685320">[-]</label><label class="expand" for="c-42685320">[1 more]</label></div><br/><div class="children"><div class="content">Even when you have an expensive contract with Microsoft and a direct account manager to help you run the gauntlet you <i>still</i> end up having to deal with awful support people.<p>Years ago at a job we were seeing issues with a network card on a VM.  One of my coworkers spent 2-3 days working his way through support engineer after support engineer until they got into a call with one.
He talked the engineer through what was happening.  Remote VM, can only access over RDP (well, we could VNC too, but that idea just confuses Microsoft support people for some reason.)<p>The support engineer decided that the way to resolve the problem was to uninstall and re-install the network card driver.  Coworker decided to give the support engineer enough rope to hang themselves with, hoping it&#x27;d help him escalate faster:  &quot;Won&#x27;t that break the RDP connection?&quot;
&quot;No sir, I&#x27;ve done this many times before, trust me&quot;
&quot;Okay then....&quot;<p>Unsurprisingly enough, when you uninstall the network card driver and cause the instance to have no network cards, RDP stops working.  Go figure.<p>Co-worker let the support engineer know that he&#x27;d now lost access, and a guess why.  &quot;Oh, yeah.  I can see why that might have been a problem&quot;<p>Co-worker was right though, it did finally let us escalate further up the chain....</div><br/></div></div><div id="42694572" class="c"><input type="checkbox" id="c-42694572" checked=""/><div class="controls bullet"><span class="by">robocat</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42684568">parent</a><span>|</span><a href="#42685320">prev</a><span>|</span><a href="#42684908">next</a><span>|</span><label class="collapse" for="c-42694572">[-]</label><label class="expand" for="c-42694572">[1 more]</label></div><br/><div class="children"><div class="content">That 1 to 4 gauntlet sounds orfully close to: <a href="https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=nb2xFvmKWRY" rel="nofollow">https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=nb2xFvmKWRY</a></div><br/></div></div><div id="42684908" class="c"><input type="checkbox" id="c-42684908" checked=""/><div class="controls bullet"><span class="by">ziddoap</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42684568">parent</a><span>|</span><a href="#42694572">prev</a><span>|</span><a href="#42684937">next</a><span>|</span><label class="collapse" for="c-42684908">[-]</label><label class="expand" for="c-42684908">[2 more]</label></div><br/><div class="children"><div class="content">&gt;<i>If you have an assigned CSAM</i><p>That&#x27;s an unfortunate acronym. I assume you mean Customer Service Account Manager.</div><br/><div id="42685379" class="c"><input type="checkbox" id="c-42685379" checked=""/><div class="controls bullet"><span class="by">RajT88</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42684908">parent</a><span>|</span><a href="#42684937">next</a><span>|</span><label class="collapse" for="c-42685379">[-]</label><label class="expand" for="c-42685379">[1 more]</label></div><br/><div class="children"><div class="content">Customer Success Account Manager.  And I would agree - it is very unfortunate.<p>Definitely in my top 5 questionable acronym choices from MSFT.</div><br/></div></div></div></div><div id="42684937" class="c"><input type="checkbox" id="c-42684937" checked=""/><div class="controls bullet"><span class="by">thatfunkymunki</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42684568">parent</a><span>|</span><a href="#42684908">prev</a><span>|</span><a href="#42683362">next</a><span>|</span><label class="collapse" for="c-42684937">[-]</label><label class="expand" for="c-42684937">[6 more]</label></div><br/><div class="children"><div class="content">Your reticence to accept the term gaslighting clearly indicates you&#x27;ve never had to interact with MSFT support.</div><br/><div id="42685369" class="c"><input type="checkbox" id="c-42685369" checked=""/><div class="controls bullet"><span class="by">RajT88</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42684937">parent</a><span>|</span><a href="#42683362">next</a><span>|</span><label class="collapse" for="c-42685369">[-]</label><label class="expand" for="c-42685369">[5 more]</label></div><br/><div class="children"><div class="content">On the contrary, I have spent thousands of hours interacting with MSFT support.<p>What I&#x27;m getting at with my post is the dev teams support has to talk to, which they just forward along their responses verbatim.<p>A lot of MSFT support does suck.  There are also some really amazing engineers in the support org.<p>I did my time in support early in my career (not at MSFT), and so I understand well it&#x27;s extremely hard to hire good support engineers, and even harder to keep them.  The skills they learn on the job makes them attractive to other parts of the org, and they get poached.<p>There is also an industry-wide tendency for developers to treat support as a bunch of knuckle-dragging idiots, but at the same time they don&#x27;t arm them with detailed information on <i>how stuff works</i>.</div><br/><div id="42685751" class="c"><input type="checkbox" id="c-42685751" checked=""/><div class="controls bullet"><span class="by">RHSeeger</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42685369">parent</a><span>|</span><a href="#42683362">next</a><span>|</span><label class="collapse" for="c-42685751">[-]</label><label class="expand" for="c-42685751">[4 more]</label></div><br/><div class="children"><div class="content">&gt; What I&#x27;m getting at with my post is the dev teams support has to talk to, which they just forward along their responses verbatim.<p>But the &quot;support&quot; that the end user sees is that combination, not two different teams (even if they know it&#x27;s two or more different teams). The point is that the end user reached out for help and was told their own experiences weren&#x27;t true. The fact that Dave had Doug actually tell them that is irrelevant.</div><br/><div id="42685962" class="c"><input type="checkbox" id="c-42685962" checked=""/><div class="controls bullet"><span class="by">RajT88</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42685751">parent</a><span>|</span><a href="#42683362">next</a><span>|</span><label class="collapse" for="c-42685962">[-]</label><label class="expand" for="c-42685962">[3 more]</label></div><br/><div class="children"><div class="content">I guess I see your point.<p>If we&#x27;re going to call it gaslighting, then gaslighting is typical dev team behavior, which of course flows back down to support.  It&#x27;s a problem with Microsoft just like it is a problem for any other company which makes software.</div><br/><div id="42687032" class="c"><input type="checkbox" id="c-42687032" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42685962">parent</a><span>|</span><a href="#42683362">next</a><span>|</span><label class="collapse" for="c-42687032">[-]</label><label class="expand" for="c-42687032">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never seen the same behavior from any other software supplier.<p>Almost every software company out there will jump into their customers complaints, and try to fix the issue even when the root cause is not on their software.</div><br/><div id="42687192" class="c"><input type="checkbox" id="c-42687192" checked=""/><div class="controls bullet"><span class="by">RajT88</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42687032">parent</a><span>|</span><a href="#42683362">next</a><span>|</span><label class="collapse" for="c-42687192">[-]</label><label class="expand" for="c-42687192">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t say I&#x27;ve seen it with every vendor.  Or even internal dev team I&#x27;ve been an internal customer of - but I&#x27;ve seen it around a lot.<p>You might be lucky in that you&#x27;ve worked at companies where you are a big enough customer they bend over backwards for you.  For example: If you work for Wal-Mart, you probably get this less often.  They are usually the biggest fish in whatever pond they are swimming in.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42683362" class="c"><input type="checkbox" id="c-42683362" checked=""/><div class="controls bullet"><span class="by">gruez</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42682931">parent</a><span>|</span><a href="#42684568">prev</a><span>|</span><a href="#42689706">next</a><span>|</span><label class="collapse" for="c-42683362">[-]</label><label class="expand" for="c-42683362">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never heard of this. How do you know it&#x27;s windows &quot;gaslighting&quot; users, and not something dumb like thermal throttling or page faults?</div><br/><div id="42683538" class="c"><input type="checkbox" id="c-42683538" checked=""/><div class="controls bullet"><span class="by">belter</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42683362">parent</a><span>|</span><a href="#42684095">next</a><span>|</span><label class="collapse" for="c-42683538">[-]</label><label class="expand" for="c-42683538">[1 more]</label></div><br/><div class="children"><div class="content">Well this is one possible scenario. Power management....<p>&quot;Windows 10 Task Manager shows 100% CPU but Performance Monitor Shows less than 2%&quot; - <a href="https:&#x2F;&#x2F;answers.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;forum&#x2F;all&#x2F;windows-10-task-manager-shows-100-cpu-but&#x2F;00c92238-9382-4946-bc6a-bbc451888b96" rel="nofollow">https:&#x2F;&#x2F;answers.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;forum&#x2F;all&#x2F;window...</a></div><br/></div></div><div id="42684095" class="c"><input type="checkbox" id="c-42684095" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#42682547">root</a><span>|</span><a href="#42683362">parent</a><span>|</span><a href="#42683538">prev</a><span>|</span><a href="#42689706">next</a><span>|</span><label class="collapse" for="c-42684095">[-]</label><label class="expand" for="c-42684095">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s gaslighting because it consists on people from Microsoft explicitly saying that it is impossible, it&#x27;s not how Windows behave, and the user&#x27;s system is idle instead of overloaded.<p>Gaslighting customers was the standard Microsoft&#x27;s reaction to bugs until at least 2007, when I last oversaw somebody interacting with them.</div><br/></div></div></div></div></div></div><div id="42689706" class="c"><input type="checkbox" id="c-42689706" checked=""/><div class="controls bullet"><span class="by">kernal</span><span>|</span><a href="#42682547">parent</a><span>|</span><a href="#42682931">prev</a><span>|</span><a href="#42682673">next</a><span>|</span><label class="collapse" for="c-42689706">[-]</label><label class="expand" for="c-42689706">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re keeping us in suspense. Did he ever manage to kill the System Idle process?</div><br/></div></div></div></div><div id="42680977" class="c"><input type="checkbox" id="c-42680977" checked=""/><div class="controls bullet"><span class="by">veltas</span><span>|</span><a href="#42682547">prev</a><span>|</span><a href="#42682404">next</a><span>|</span><label class="collapse" for="c-42680977">[-]</label><label class="expand" for="c-42680977">[9 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t feel like reading 4 times is necessarily a portable solution, if there will be more versions at different speeds and different I&#x2F;O architectures; or how this will work under more load, and whether the original change was done to fix some other performance problem OP is not aware of, but not sure what else can be done.  Unfortunately many vendors like Marvell can seriously under-document crucial features like this.  If anything it would be good to put some of this info in the comment itself, not very elegant but how else practically are we meant to keep track of this, is the mailing list part of the documentation?<p>Doesn&#x27;t look like there&#x27;s a lot of discussion on the mailing list, but I don&#x27;t know if I&#x27;m reading the thread view correctly.</div><br/><div id="42682624" class="c"><input type="checkbox" id="c-42682624" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#42680977">parent</a><span>|</span><a href="#42682836">next</a><span>|</span><label class="collapse" for="c-42682624">[-]</label><label class="expand" for="c-42682624">[4 more]</label></div><br/><div class="children"><div class="content">This is a workaround for a hardware bug of a certain CPU.<p>Therefore it cannot really be portable, because other timers in other devices will have different memory maps and different commands for reading.<p>The fault is with the designers of these timers, who have failed to provide a reliable way to read their value.<p>It in hard to believe that this still happens in this century, because reading correct values despite the fact that the timer is incremented or decremented continuously is an essential goal in the design of any timer that may be read, and how to do it has been well known for more than 3 quarters of century.<p>The only way to make such a workaround somewhat portable is to parametrize it, e.g. with the number of retries for direct reading or with the delay time when reading the auxiliary register. This may be portable between different revisions of the same buggy timer, but the buggy timers in other unrelated CPU designs will need different workarounds anyway.</div><br/><div id="42682701" class="c"><input type="checkbox" id="c-42682701" checked=""/><div class="controls bullet"><span class="by">stkdump</span><span>|</span><a href="#42680977">root</a><span>|</span><a href="#42682624">parent</a><span>|</span><a href="#42683984">next</a><span>|</span><label class="collapse" for="c-42682701">[-]</label><label class="expand" for="c-42682701">[2 more]</label></div><br/><div class="children"><div class="content">&gt; how to do it has been well known for more than 3 quarters of century<p>Don&#x27;t leave me hanging! How to do it?</div><br/><div id="42683087" class="c"><input type="checkbox" id="c-42683087" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#42680977">root</a><span>|</span><a href="#42682701">parent</a><span>|</span><a href="#42683984">next</a><span>|</span><label class="collapse" for="c-42683087">[-]</label><label class="expand" for="c-42683087">[1 more]</label></div><br/><div class="children"><div class="content">Direct reading without the risk of reading incorrect values is possible only when the timer is implemented using a synchronous counter instead of an asynchronous counter and the synchronous counter must be fast enough to ensure a stable correct value by the time when it is read, and the reading signal must be synchronized with the timer clock signal.<p>Synchronous counters are more expensive in die area than asynchronous counters, especially at high clock frequencies.  Moreover, it may be difficult to also synchronize the reading signal with the timer clock. Therefore the second solution may be preferable, which uses a separate capture register for reading the timer value.<p>This was implemented in the timer described in TFA, but it was done in a wrong way.<p>The capture register must either ensure that the capture is already complete by the time when it is possible to read its value after giving a capture command, or it must have some extra bit that indicates when its value is valid.<p>In this case, one can read the capture register until the valid bit is on, having a complete certainty that the end value is correct.<p>When adding some arbitrary delay between the capture command and reading the capture register, you can never be certain that the delay value is good.<p>Even when the chosen delay is 100% effective during testing, it can result in failures on other computers or when the ambient temperature is different.</div><br/></div></div></div></div><div id="42683984" class="c"><input type="checkbox" id="c-42683984" checked=""/><div class="controls bullet"><span class="by">veltas</span><span>|</span><a href="#42680977">root</a><span>|</span><a href="#42682624">parent</a><span>|</span><a href="#42682701">prev</a><span>|</span><a href="#42682836">next</a><span>|</span><label class="collapse" for="c-42683984">[-]</label><label class="expand" for="c-42683984">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is a workaround for a hardware bug of a certain CPU.<p>What about different variants, revisions, and speeds of this CPU?</div><br/></div></div></div></div><div id="42682836" class="c"><input type="checkbox" id="c-42682836" checked=""/><div class="controls bullet"><span class="by">Karliss</span><span>|</span><a href="#42680977">parent</a><span>|</span><a href="#42682624">prev</a><span>|</span><a href="#42681269">next</a><span>|</span><label class="collapse" for="c-42682836">[-]</label><label class="expand" for="c-42682836">[3 more]</label></div><br/><div class="children"><div class="content">The related part of doc has one more note &quot;This request requires up to three timer clock cycles. If the selected timer is working at slow clock, the request could take longer.&quot;
From the way doc is formatted it&#x27;s not fully clear what &quot;this request&quot; refers to. 
It might explain where 3-5 attempts come from, and that it might not be pulled completely out of thin air. But the part about taking up to but sometimes more clock cycles makes it impossible to have a &quot;proper&quot; solution without guesswork or further clarifications from vendor.<p>&quot;working at slow clock&quot; part, might explain why some other implementations had different code path for 32.768 KHz clocks. According to docs there are two available clock sources &quot;Fast clock&quot; and &quot;32768 Hz&quot; which could mean that &quot;slow clock&quot; refers to specific hardware functionality is not just a vague phrase.<p>As for portability concerns, this is already low level hardware specific register access. If Marvell releases new SOC not only there is no assurance that will require same timing, it might was well have different set of registers which require completely different read and setup procedure not just different timing.<p>One thing that slightly confuses me - the old implementation had 100 cycles of &quot;cpu_relax()&quot; which is unrelated to specific timer clock, but neither is reading of TMR_CVWR register. Since 3-5 of cycles of that worked better than 100 cycles of cpu_relex, it clearly takes more time unless cpu_relax part got completely optimized out. At least I didn&#x27;t find any references mentioning that timer clock affects read time of  TMR_CVWR.</div><br/><div id="42684034" class="c"><input type="checkbox" id="c-42684034" checked=""/><div class="controls bullet"><span class="by">veltas</span><span>|</span><a href="#42680977">root</a><span>|</span><a href="#42682836">parent</a><span>|</span><a href="#42681269">next</a><span>|</span><label class="collapse" for="c-42684034">[-]</label><label class="expand" for="c-42684034">[2 more]</label></div><br/><div class="children"><div class="content">It sounds like this is an old CPU(?), so no need to worry about the future here.<p>&gt; I didn&#x27;t find any references mentioning that timer clock affects read time of TMR_CVWR.<p>Reading the register might be related to the timer&#x27;s internal clock, as it would have to wait for the timer&#x27;s bus to respond.  This is essentially implied if Marvell recommend re-reading this register, or if their reference implementation did so.  My main complaint is it&#x27;s all guesswork, because Marvell&#x27;s docs aren&#x27;t that good.</div><br/><div id="42688823" class="c"><input type="checkbox" id="c-42688823" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#42680977">root</a><span>|</span><a href="#42684034">parent</a><span>|</span><a href="#42681269">next</a><span>|</span><label class="collapse" for="c-42688823">[-]</label><label class="expand" for="c-42688823">[1 more]</label></div><br/><div class="children"><div class="content">The Chumby hardware I’m thinking of is from 2010 or so. So if that’s it, it would certainly be old. And it would explain a possible relation with the OLPC having a similar chip.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Chumby" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Chumby</a></div><br/></div></div></div></div></div></div><div id="42681269" class="c"><input type="checkbox" id="c-42681269" checked=""/><div class="controls bullet"><span class="by">_nalply</span><span>|</span><a href="#42680977">parent</a><span>|</span><a href="#42682836">prev</a><span>|</span><a href="#42682404">next</a><span>|</span><label class="collapse" for="c-42681269">[-]</label><label class="expand" for="c-42681269">[1 more]</label></div><br/><div class="children"><div class="content">I also wondered about this, but there&#x27;s a crucial differnce, no idea if it matters: in that loop it reads the register, so the register is read at least 4 times.</div><br/></div></div></div></div><div id="42682404" class="c"><input type="checkbox" id="c-42682404" checked=""/><div class="controls bullet"><span class="by">rbanffy</span><span>|</span><a href="#42680977">prev</a><span>|</span><a href="#42681449">next</a><span>|</span><label class="collapse" for="c-42682404">[-]</label><label class="expand" for="c-42682404">[5 more]</label></div><br/><div class="children"><div class="content">In the late 1990&#x27;s I worked in a company that had a couple mainframes in their fleet and once I looked into a resource usage screen (Omegamon, perhaps? Is it that old?) and noticed the CPU was pegged at 100%. I asked the operator if that was normal. His answer was &quot;Of course. We paid for that CPU, might as well use it&quot;. Funny though that mainframes are designed for that - most, if not all, non-application work is offloaded to other processors in the system so that the CPU can run applications as fast as it can.</div><br/><div id="42682437" class="c"><input type="checkbox" id="c-42682437" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#42682404">parent</a><span>|</span><a href="#42681449">next</a><span>|</span><label class="collapse" for="c-42682437">[-]</label><label class="expand" for="c-42682437">[4 more]</label></div><br/><div class="children"><div class="content">Having a number of running processes take the CPU usage to 100% is one thing, have an under utilised CPU with almost no processes running <i>report</i> that usage is at 100% is another thing, the subject of the article here.</div><br/><div id="42682480" class="c"><input type="checkbox" id="c-42682480" checked=""/><div class="controls bullet"><span class="by">rbanffy</span><span>|</span><a href="#42682404">root</a><span>|</span><a href="#42682437">parent</a><span>|</span><a href="#42683187">next</a><span>|</span><label class="collapse" for="c-42682480">[-]</label><label class="expand" for="c-42682480">[2 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t intend this as an example of the issue the article mentions (a misreporting of usage because of a hardware design issue). It was just a fun example of how different hardware behaves differently.<p>One can also say Omegamon (or whatever tool) was misreporting, because it didn&#x27;t account for the processor time of the various supporting systems that dealt with peripheral operations. After all, they also paid for the disk controllers, disks, tape drives, terminal controllers and so on, so they could want to drive those to close to 100% as well.</div><br/><div id="42682644" class="c"><input type="checkbox" id="c-42682644" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#42682404">root</a><span>|</span><a href="#42682480">parent</a><span>|</span><a href="#42683187">next</a><span>|</span><label class="collapse" for="c-42682644">[-]</label><label class="expand" for="c-42682644">[1 more]</label></div><br/><div class="children"><div class="content">Sure, no drama - I came across as a little dry and clipped as I was clarifying on the fly as it were.<p>I had my time squeezing the last cycle possible from a Cyber 205 waaaay back in the day.</div><br/></div></div></div></div><div id="42683187" class="c"><input type="checkbox" id="c-42683187" checked=""/><div class="controls bullet"><span class="by">datadrivenangel</span><span>|</span><a href="#42682404">root</a><span>|</span><a href="#42682437">parent</a><span>|</span><a href="#42682480">prev</a><span>|</span><a href="#42681449">next</a><span>|</span><label class="collapse" for="c-42683187">[-]</label><label class="expand" for="c-42683187">[1 more]</label></div><br/><div class="children"><div class="content">Some mainframes have the ability to lock clock speed and always run at exactly 100%, so you can often have hard guarantees about program latency and performance.</div><br/></div></div></div></div></div></div><div id="42681449" class="c"><input type="checkbox" id="c-42681449" checked=""/><div class="controls bullet"><span class="by">sneela</span><span>|</span><a href="#42682404">prev</a><span>|</span><a href="#42693684">next</a><span>|</span><label class="collapse" for="c-42681449">[-]</label><label class="expand" for="c-42681449">[2 more]</label></div><br/><div class="children"><div class="content">This is a wonderful write-up and a very enjoyable read. Although my knowledge about systems programming on ARM is limited, I know that it isn&#x27;t easy to read hardware-based time counters; at the very least, it&#x27;s not as simple as the x86 rdtsc [1]. This is probably why the author writes:<p>&gt; This code is more complicated than what I expected to see. I was thinking it would just be a simple register read. Instead, it has to write a 1 to the register, and then delay for a while, and then read back the same register. There was also a very noticeable FIXME in the comment for the function, which definitely raised a red flag in my mind.<p>Regardless, this was a very nice read and I&#x27;m glad they got down to the issue and the problem fixed.<p>[1]: <a href="https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;rdtsc" rel="nofollow">https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;rdtsc</a>.</div><br/><div id="42681988" class="c"><input type="checkbox" id="c-42681988" checked=""/><div class="controls bullet"><span class="by">pm215</span><span>|</span><a href="#42681449">parent</a><span>|</span><a href="#42693684">next</a><span>|</span><label class="collapse" for="c-42681988">[-]</label><label class="expand" for="c-42681988">[1 more]</label></div><br/><div class="children"><div class="content">Bear in mind that the blog post is about a 32 bit SoC that&#x27;s over a decade old, and the timer it is reading is specific to that CPU implementation. In the intervening time both timers and performance counters have been architecturally standardised, so on a modern CPU there is a register roughly equivalent to the one x86 rdtsc uses and which you can just read; and kernels can use the generic timer code for timers and don&#x27;t need to have board specific functions to do it.<p>But yeah, nice writeup of the kinds of problem you can run into in embedded systems programming.</div><br/></div></div></div></div><div id="42693684" class="c"><input type="checkbox" id="c-42693684" checked=""/><div class="controls bullet"><span class="by">rbohac</span><span>|</span><a href="#42681449">prev</a><span>|</span><a href="#42688680">next</a><span>|</span><label class="collapse" for="c-42693684">[-]</label><label class="expand" for="c-42693684">[1 more]</label></div><br/><div class="children"><div class="content">This was a well written article! It was nice to read the process of troubleshooting with the rabbit holes included. Glad you stuck it out!</div><br/></div></div><div id="42688680" class="c"><input type="checkbox" id="c-42688680" checked=""/><div class="controls bullet"><span class="by">askvictor</span><span>|</span><a href="#42693684">prev</a><span>|</span><a href="#42684576">next</a><span>|</span><label class="collapse" for="c-42688680">[-]</label><label class="expand" for="c-42688680">[2 more]</label></div><br/><div class="children"><div class="content">My recurring issue (on a variety of laptops, both Linux and Windows): the fans will start going full-blast, everything slows down, then as soon as I open a task manager CPU usage drops from 100% to something negligible.</div><br/><div id="42688874" class="c"><input type="checkbox" id="c-42688874" checked=""/><div class="controls bullet"><span class="by">crazydoggers</span><span>|</span><a href="#42688680">parent</a><span>|</span><a href="#42684576">next</a><span>|</span><label class="collapse" for="c-42688874">[-]</label><label class="expand" for="c-42688874">[1 more]</label></div><br/><div class="children"><div class="content">You my friend, most likely have mining malware on your systems. They’ll shutdown when they detect task manager is opened so you don’t notice them.</div><br/></div></div></div></div><div id="42684576" class="c"><input type="checkbox" id="c-42684576" checked=""/><div class="controls bullet"><span class="by">evanjrowley</span><span>|</span><a href="#42688680">prev</a><span>|</span><a href="#42691240">next</a><span>|</span><label class="collapse" for="c-42684576">[-]</label><label class="expand" for="c-42684576">[1 more]</label></div><br/><div class="children"><div class="content">This headline reminded me of Mumptris, an implementation of Tetris in the old mainframe-oriented language MUMPS, which by design, uses 100% CPU to reduce latency: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=4085593">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=4085593</a></div><br/></div></div><div id="42691240" class="c"><input type="checkbox" id="c-42691240" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42684576">prev</a><span>|</span><a href="#42681887">next</a><span>|</span><label class="collapse" for="c-42691240">[-]</label><label class="expand" for="c-42691240">[1 more]</label></div><br/><div class="children"><div class="content">I noticed that one time. Looked at the process list, and what was running was a program that enabled streaming. But since I wasn&#x27;t streaming anything, I wondered what it was doing reading the disk drive.<p>So I uninstalled it.<p>Not having any programs that are not good citizens.</div><br/></div></div><div id="42681887" class="c"><input type="checkbox" id="c-42681887" checked=""/><div class="controls bullet"><span class="by">thrdbndndn</span><span>|</span><a href="#42691240">prev</a><span>|</span><a href="#42682844">next</a><span>|</span><label class="collapse" for="c-42681887">[-]</label><label class="expand" for="c-42681887">[14 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get the fix.<p>Why reading it multiple times will fix the issue?<p>Is it just because reading takes time, therefore reading multiple time makes the needed time from writing to reading passes? If so, it sounds like a worse solution than just extending waiting delay longer like the author did initially.<p>If not, then I would like to know the reason.<p>(Needless to say, a great article!)</div><br/><div id="42682719" class="c"><input type="checkbox" id="c-42682719" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#42681887">parent</a><span>|</span><a href="#42684209">next</a><span>|</span><label class="collapse" for="c-42682719">[-]</label><label class="expand" for="c-42682719">[3 more]</label></div><br/><div class="children"><div class="content">The article says that the buggy timer has 2 different methods for reading.<p>When reading directly, the value may be completely wrong, because the timer is incremented continuously and the updating of its bits is not synchronous with the reading signal. Therefore any bit in the value that is read may be wrong, because it has been read exactly during a transition between valid values.<p>The workaround in this case is to read multiple times and accept as good a value that is approximately the same for multiple reads. The more significant bits of the timer value change much less frequently than the least significant bits, so at most attempts of reading, only a few bits can be wrong. Only seldom the read value can be complete garbage, when comparing it with the other read values will reject it.<p>The second reading method was to use a separate capture register. After giving a timer capture command, reading an unchanging value from the capture register should have caused no problems. Except that in this buggy timer, it is unpredictable when the capture is actually completed. This requires the insertion of an empirically determined delay time before reading the capture register, hopefully allowing enough time for the capture to be complete.</div><br/><div id="42690517" class="c"><input type="checkbox" id="c-42690517" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#42681887">root</a><span>|</span><a href="#42682719">parent</a><span>|</span><a href="#42684209">next</a><span>|</span><label class="collapse" for="c-42690517">[-]</label><label class="expand" for="c-42690517">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The workaround in this case is to read multiple times and accept as good a value that is approximately the same for multiple reads.<p>It&#x27;s only incrementing at 3.25MHz, right?  Shouldn&#x27;t you be able to get exactly the same value for multiple reads?  That seems both simpler and faster than using this very slow capture register, but maybe I&#x27;m missing something.</div><br/><div id="42694656" class="c"><input type="checkbox" id="c-42694656" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#42681887">root</a><span>|</span><a href="#42690517">parent</a><span>|</span><a href="#42684209">next</a><span>|</span><label class="collapse" for="c-42694656">[-]</label><label class="expand" for="c-42694656">[1 more]</label></div><br/><div class="children"><div class="content">In this specific case, yes, if none of two successive readings is corrupted and when you did not straddle a transition, they should be the same.<p>In general, when reading a timer that increments faster, you may want to mask some of the least significant bits, to ensure that you can have the same values on successive readings.</div><br/></div></div></div></div></div></div><div id="42684209" class="c"><input type="checkbox" id="c-42684209" checked=""/><div class="controls bullet"><span class="by">dougg3</span><span>|</span><a href="#42681887">parent</a><span>|</span><a href="#42682719">prev</a><span>|</span><a href="#42682202">next</a><span>|</span><label class="collapse" for="c-42684209">[-]</label><label class="expand" for="c-42684209">[1 more]</label></div><br/><div class="children"><div class="content">Author here. Thanks! I believe the register reads are just extending the delay, although the new approach does have a side effect of reading from the hardware multiple times. I don&#x27;t think the multiple reads really matter though.<p>I went with the multiple reads because that&#x27;s what Marvell&#x27;s own kernel fork does. My reasoning was that people have been using their fork, not only on the PXA168, but on the newer PXAxxxx series, so it would be best to retain Marvell&#x27;s approach. I could have just increased the delay loop, but I didn&#x27;t have any way of knowing if the delay I chose would be correct on newer PXAxxx models as well, like the chip used in the OLPC. Really wish they had more&#x2F;better documentation!</div><br/></div></div><div id="42682202" class="c"><input type="checkbox" id="c-42682202" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#42681887">parent</a><span>|</span><a href="#42684209">prev</a><span>|</span><a href="#42689652">next</a><span>|</span><label class="collapse" for="c-42682202">[-]</label><label class="expand" for="c-42682202">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s possible that actually reading the register takes (significantly) more time than an empty countdown loop. A somewhat extreme example of that would be on x86, where accessing legacy I&#x2F;O ports for e.g. the timer goes through a much lower-clocked emulated ISA bus.<p>However, a more likely explanation is the use of &quot;volatile&quot; (which only appears in the working version of the code). Without it, the compiler might even have completely removed the loop?</div><br/><div id="42682505" class="c"><input type="checkbox" id="c-42682505" checked=""/><div class="controls bullet"><span class="by">deng</span><span>|</span><a href="#42681887">root</a><span>|</span><a href="#42682202">parent</a><span>|</span><a href="#42689652">next</a><span>|</span><label class="collapse" for="c-42682505">[-]</label><label class="expand" for="c-42682505">[6 more]</label></div><br/><div class="children"><div class="content">&gt; However, a more likely explanation is the use of &quot;volatile&quot; (which only appears in the working version of the code). Without it, the compiler might even have completely removed the loop?<p>No, because the loop calls cpu_relax(), which is a compiler barrier. It cannot be optimized away.<p>And yes, reading via the memory bus is much, much slower than a barrier. It&#x27;s absolutely likely that reading 4 times from main memory on such an old embedded system takes several hundred cycles.</div><br/><div id="42685625" class="c"><input type="checkbox" id="c-42685625" checked=""/><div class="controls bullet"><span class="by">Karliss</span><span>|</span><a href="#42681887">root</a><span>|</span><a href="#42682505">parent</a><span>|</span><a href="#42682857">next</a><span>|</span><label class="collapse" for="c-42685625">[-]</label><label class="expand" for="c-42685625">[1 more]</label></div><br/><div class="children"><div class="content">From what I understand the timer registers should be on APB(1) bus which operates at fixed 26MHz clock. That should be much closer to the scale of fast timer clocks compared to cpu_relax() and main CPU clock running somewhere in the range of 0.5-1GHz and potentially doing some dynamic frequency scaling for power saving purpose.<p>The silliest part of this mess is that 26Mhz clock for APB1 bus is derived from the same source as 13Mhz, 6.5Mhz 3.25Mhz, 1Mhz clocks usable by fast timers.</div><br/></div></div><div id="42682857" class="c"><input type="checkbox" id="c-42682857" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#42681887">root</a><span>|</span><a href="#42682505">parent</a><span>|</span><a href="#42685625">prev</a><span>|</span><a href="#42689652">next</a><span>|</span><label class="collapse" for="c-42682857">[-]</label><label class="expand" for="c-42682857">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right, didn&#x27;t account for that. Though even when declared volatile, the counter variable would be on the stack, and thus already in the CPU cache (at least 32K according to the datasheet)?<p>Looking at the assembly code for both versions of this delay loop might clear it up.</div><br/><div id="42683073" class="c"><input type="checkbox" id="c-42683073" checked=""/><div class="controls bullet"><span class="by">deng</span><span>|</span><a href="#42681887">root</a><span>|</span><a href="#42682857">parent</a><span>|</span><a href="#42689652">next</a><span>|</span><label class="collapse" for="c-42683073">[-]</label><label class="expand" for="c-42683073">[3 more]</label></div><br/><div class="children"><div class="content">The only thing volatile does is to assure that the value is read from memory each time (which implicitly also forbids optimizations). Whether that memory is in a CPU cache is purely a hardware issue and outside the C specification. If you read something like a hardware register, you yourself need to take care in some way that a hardware cache will not give you old values (by mapping it into a non-cached memory area, or by forcing a cache update). If you for-loop over something that acts as a compiler barrier, all that &#x27;volatile&#x27; on the counter variable will do is potentially make the for-loop slower.<p>There&#x27;s really just very few reasons to ever use &#x27;volatile&#x27;. In fact, the Linux kernel even has its own documentation why you should usually not use it:<p><a href="https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;process&#x2F;volatile-considered-harmful.html" rel="nofollow">https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;process&#x2F;volatile-cons...</a></div><br/><div id="42685148" class="c"><input type="checkbox" id="c-42685148" checked=""/><div class="controls bullet"><span class="by">sim7c00</span><span>|</span><a href="#42681887">root</a><span>|</span><a href="#42683073">parent</a><span>|</span><a href="#42689652">next</a><span>|</span><label class="collapse" for="c-42685148">[-]</label><label class="expand" for="c-42685148">[2 more]</label></div><br/><div class="children"><div class="content">doesnt volatile also ensure the address is not changed for the read by compiler (as it might optimise data layout otherwise)? (so you can be sure when using mmio etc. it wont read from wrong place?)</div><br/><div id="42686051" class="c"><input type="checkbox" id="c-42686051" checked=""/><div class="controls bullet"><span class="by">deng</span><span>|</span><a href="#42681887">root</a><span>|</span><a href="#42685148">parent</a><span>|</span><a href="#42689652">next</a><span>|</span><label class="collapse" for="c-42686051">[-]</label><label class="expand" for="c-42686051">[1 more]</label></div><br/><div class="children"><div class="content">&quot;volatile&quot;, according to the standard, simply is: &quot;An object that has volatile-qualified type may be modified in ways unknown to the implementation or have other unknown side effects. Therefore any expression referring to such an object shall be evaluated strictly according to the rules of the abstract machine.&quot;<p>Or simpler: don&#x27;t assume anything what you think you might know about this object, just do as you&#x27;re told.<p>And yes, that for instance prohibits putting a value from a memory address into a register for further use, which would be a simple case of data optimization. Instead, a fresh retrieval from memory must be done on each access.<p>However, if your system has caching or an MMU is outside of the spec. The compiler does not care. If you tell the compiler to give you the byte at address 0x1000, it will do so. &#x27;volatile&#x27; just forbids the compiler to deduce the value from already available knowledge. If a hardware cache or MMU messes with that, that&#x27;s your problem, not the compiler&#x27;s.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42689652" class="c"><input type="checkbox" id="c-42689652" checked=""/><div class="controls bullet"><span class="by">mastax</span><span>|</span><a href="#42681887">parent</a><span>|</span><a href="#42682202">prev</a><span>|</span><a href="#42682397">next</a><span>|</span><label class="collapse" for="c-42689652">[-]</label><label class="expand" for="c-42689652">[1 more]</label></div><br/><div class="children"><div class="content">Karliss above found docs which mention:<p>&gt; This request requires up to three timer clock cycles. If the selected timer is working at slow clock, the request could take longer.<p>Let&#x27;s ignore the weirdly ambiguous second sentence and say for pedagogical purposes it takes up to three timer clock cycles full stop. Timer clock cycles aren&#x27;t CPU clock cycles, so we can&#x27;t just do `nop; nop; nop;`. How do we wait three timer clock cycles? Well a timer register read is handled by the timer peripheral which runs at the timer clock, so reading (or writing) a timer register will take until at least the end of the next timer clock.<p>This is a very common pattern when dealing with memory mapped peripheral registers.<p>---<p>I&#x27;m making some reasonable assumptions about how the clock peripheral works. I haven&#x27;t actually dug into the Marvell documentation.</div><br/></div></div><div id="42682397" class="c"><input type="checkbox" id="c-42682397" checked=""/><div class="controls bullet"><span class="by">deng</span><span>|</span><a href="#42681887">parent</a><span>|</span><a href="#42689652">prev</a><span>|</span><a href="#42682844">next</a><span>|</span><label class="collapse" for="c-42682397">[-]</label><label class="expand" for="c-42682397">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is it just because reading takes time, therefore reading multiple time makes the needed time from writing to reading passes?<p>Yes.<p>&gt; If so, it sounds like a worse solution than just extending waiting delay longer like the author did initially.<p>Yeah, it&#x27;s a judgement call. Previously, the code called cpu_relax() for waiting, which is also dependent on how this is defined (can be simply NOP or barrier(), for instance). The reading of the timer register maybe has the advantage that it is dependent on the actual memory bus speed, but I wouldn&#x27;t know for sure. Hardware at that level is just messy, and especially niche platforms have their fair share of bugs where you need to do ugly workarounds like these.<p>What I&#x27;m rather wondering is why they didn&#x27;t try the other solution that was mentioned by the manufacturer: reading the timer directly two times and compare it, until you get a stable output.</div><br/></div></div></div></div><div id="42682844" class="c"><input type="checkbox" id="c-42682844" checked=""/><div class="controls bullet"><span class="by">a1o</span><span>|</span><a href="#42681887">prev</a><span>|</span><a href="#42686106">next</a><span>|</span><label class="collapse" for="c-42682844">[-]</label><label class="expand" for="c-42682844">[1 more]</label></div><br/><div class="children"><div class="content">This was very well written, I somehow read every single line and didn&#x27;t skip to the end. Great work too!</div><br/></div></div><div id="42686106" class="c"><input type="checkbox" id="c-42686106" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#42682844">prev</a><span>|</span><a href="#42683452">next</a><span>|</span><label class="collapse" for="c-42686106">[-]</label><label class="expand" for="c-42686106">[1 more]</label></div><br/><div class="children"><div class="content">Great read! Eerily similar to some bugs I&#x27;ve had, but the root cause has been a compiler bug. Debugging a kernel that doesn&#x27;t boot is... interesting. QEMU+GDB to the rescue.</div><br/></div></div><div id="42683452" class="c"><input type="checkbox" id="c-42683452" checked=""/><div class="controls bullet"><span class="by">RajT88</span><span>|</span><a href="#42686106">prev</a><span>|</span><a href="#42687233">next</a><span>|</span><label class="collapse" for="c-42683452">[-]</label><label class="expand" for="c-42683452">[1 more]</label></div><br/><div class="children"><div class="content">TIL there are still Chumby&#x27;s alive in the wild.  My Insignia Chumby 8 didn&#x27;t last.</div><br/></div></div><div id="42687233" class="c"><input type="checkbox" id="c-42687233" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#42683452">prev</a><span>|</span><a href="#42688307">next</a><span>|</span><label class="collapse" for="c-42687233">[-]</label><label class="expand" for="c-42687233">[1 more]</label></div><br/><div class="children"><div class="content">Curiously, instead of &quot;set capture reg, wait for clock edge, read&quot;, the &quot;read reg twice, until same result is obtained&quot; approach is ignored. This is strange as it is usually much faster - reading a 3.25MHz counter at 200MHz+ twice is very likely to see the same value twice. For a 32KHz counter, it is basically guaranteed.<p><pre><code>   u32 val;
   do {
       val = readl(...);
   } while (val != readl(...));

   return val;
</code></pre>
compiles to a nice 6-instr little function on arm&#x2F;thumb too, with no delays<p><pre><code>   readclock:
     LDR  R2, =...
   1:
     LDR  R0, [R2]
     LDR  R1, [R2]
     CMP  R0, R1
     BNE  1b
     BX   LR</code></pre></div><br/></div></div><div id="42688307" class="c"><input type="checkbox" id="c-42688307" checked=""/><div class="controls bullet"><span class="by">markhahn</span><span>|</span><a href="#42687233">prev</a><span>|</span><a href="#42683235">next</a><span>|</span><label class="collapse" for="c-42688307">[-]</label><label class="expand" for="c-42688307">[2 more]</label></div><br/><div class="children"><div class="content">very nice investigation.<p>shame about the unnecessary use of cat :)</div><br/><div id="42693991" class="c"><input type="checkbox" id="c-42693991" checked=""/><div class="controls bullet"><span class="by">dougg3</span><span>|</span><a href="#42688307">parent</a><span>|</span><a href="#42683235">next</a><span>|</span><label class="collapse" for="c-42693991">[-]</label><label class="expand" for="c-42693991">[1 more]</label></div><br/><div class="children"><div class="content">Ha! Guilty as charged. I have a coworker who&#x27;s probably very disappointed in me right now!</div><br/></div></div></div></div><div id="42683235" class="c"><input type="checkbox" id="c-42683235" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#42688307">prev</a><span>|</span><a href="#42685136">next</a><span>|</span><label class="collapse" for="c-42683235">[-]</label><label class="expand" for="c-42683235">[1 more]</label></div><br/><div class="children"><div class="content">To diagnose, why not run &quot;time top&quot; and look at the user and sys outputs?</div><br/></div></div><div id="42685136" class="c"><input type="checkbox" id="c-42685136" checked=""/><div class="controls bullet"><span class="by">NotYourLawyer</span><span>|</span><a href="#42683235">prev</a><span>|</span><a href="#42681395">next</a><span>|</span><label class="collapse" for="c-42685136">[-]</label><label class="expand" for="c-42685136">[2 more]</label></div><br/><div class="children"><div class="content">That’s an awful lot of effort to deal with an issue that was basically just cosmetic. I suspect at some point the author was just nerd sniped though.</div><br/><div id="42687940" class="c"><input type="checkbox" id="c-42687940" checked=""/><div class="controls bullet"><span class="by">dougg3</span><span>|</span><a href="#42685136">parent</a><span>|</span><a href="#42681395">next</a><span>|</span><label class="collapse" for="c-42687940">[-]</label><label class="expand" for="c-42687940">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, other non-cosmetic stuff uses the CPU percentage. This same bug was preventing fast user suspend on the OLPC until they worked around it. It was also a fun challenge.</div><br/></div></div></div></div><div id="42681395" class="c"><input type="checkbox" id="c-42681395" checked=""/><div class="controls bullet"><span class="by">g-b-r</span><span>|</span><a href="#42685136">prev</a><span>|</span><a href="#42682294">next</a><span>|</span><label class="collapse" for="c-42681395">[-]</label><label class="expand" for="c-42681395">[5 more]</label></div><br/><div class="children"><div class="content">I expected it to be about holding down the spacebar :&#x2F;</div><br/><div id="42681543" class="c"><input type="checkbox" id="c-42681543" checked=""/><div class="controls bullet"><span class="by">lohfu</span><span>|</span><a href="#42681395">parent</a><span>|</span><a href="#42681438">next</a><span>|</span><label class="collapse" for="c-42681543">[-]</label><label class="expand" for="c-42681543">[1 more]</label></div><br/><div class="children"><div class="content">He must running version 10.17 or newer</div><br/></div></div><div id="42681438" class="c"><input type="checkbox" id="c-42681438" checked=""/><div class="controls bullet"><span class="by">labster</span><span>|</span><a href="#42681395">parent</a><span>|</span><a href="#42681543">prev</a><span>|</span><a href="#42686790">next</a><span>|</span><label class="collapse" for="c-42681438">[-]</label><label class="expand" for="c-42681438">[2 more]</label></div><br/><div class="children"><div class="content">Spacebar heating was great for my workflow, please re-enable</div><br/><div id="42681592" class="c"><input type="checkbox" id="c-42681592" checked=""/><div class="controls bullet"><span class="by">smidgeon</span><span>|</span><a href="#42681395">root</a><span>|</span><a href="#42681438">parent</a><span>|</span><a href="#42686790">next</a><span>|</span><label class="collapse" for="c-42681592">[-]</label><label class="expand" for="c-42681592">[1 more]</label></div><br/><div class="children"><div class="content">For the confused: <a href="https:&#x2F;&#x2F;www.xkcd.com&#x2F;1172&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.xkcd.com&#x2F;1172&#x2F;</a></div><br/></div></div></div></div><div id="42686790" class="c"><input type="checkbox" id="c-42686790" checked=""/><div class="controls bullet"><span class="by">g-b-r</span><span>|</span><a href="#42681395">parent</a><span>|</span><a href="#42681438">prev</a><span>|</span><a href="#42682294">next</a><span>|</span><label class="collapse" for="c-42686790">[-]</label><label class="expand" for="c-42686790">[1 more]</label></div><br/><div class="children"><div class="content">Not to argue, but I don&#x27;t understand why someone downvoted it</div><br/></div></div></div></div><div id="42681680" class="c"><input type="checkbox" id="c-42681680" checked=""/><div class="controls bullet"><span class="by">InsomniacL</span><span>|</span><a href="#42682294">prev</a><span>|</span><a href="#42681956">next</a><span>|</span><label class="collapse" for="c-42681680">[-]</label><label class="expand" for="c-42681680">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Chumby’s kernel did a total of 5 reads of the CVWR register. The other two kernels did a total of 3 reads.<p>&gt; I opted to use 4 as a middle ground<p>reminded me of xkcd: Standards<p><a href="https:&#x2F;&#x2F;xkcd.com&#x2F;927&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;927&#x2F;</a></div><br/></div></div><div id="42681956" class="c"><input type="checkbox" id="c-42681956" checked=""/><div class="controls bullet"><span class="by">TrickyReturn</span><span>|</span><a href="#42681680">prev</a><span>|</span><a href="#42684691">next</a><span>|</span><label class="collapse" for="c-42681956">[-]</label><label class="expand" for="c-42681956">[1 more]</label></div><br/><div class="children"><div class="content">Probably running Slack...</div><br/></div></div><div id="42684691" class="c"><input type="checkbox" id="c-42684691" checked=""/><div class="controls bullet"><span class="by">Suppafly</span><span>|</span><a href="#42681956">prev</a><span>|</span><a href="#42681165">next</a><span>|</span><label class="collapse" for="c-42684691">[-]</label><label class="expand" for="c-42684691">[3 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t this one of those problems that switching to linux is supposed to fix?</div><br/><div id="42684696" class="c"><input type="checkbox" id="c-42684696" checked=""/><div class="controls bullet"><span class="by">DougN7</span><span>|</span><a href="#42684691">parent</a><span>|</span><a href="#42681165">next</a><span>|</span><label class="collapse" for="c-42684696">[-]</label><label class="expand" for="c-42684696">[2 more]</label></div><br/><div class="children"><div class="content">He’s on linux</div><br/><div id="42685961" class="c"><input type="checkbox" id="c-42685961" checked=""/><div class="controls bullet"><span class="by">Suppafly</span><span>|</span><a href="#42684691">root</a><span>|</span><a href="#42684696">parent</a><span>|</span><a href="#42681165">next</a><span>|</span><label class="collapse" for="c-42685961">[-]</label><label class="expand" for="c-42685961">[1 more]</label></div><br/><div class="children"><div class="content">Exactly, that&#x27;s the joke. If it had been an issue on Windows the default response from folks here would be to switch to Linux instead of trying to get to the root of the issue. Guess I should have included an &#x2F;s on my comment.</div><br/></div></div></div></div></div></div><div id="42681165" class="c"><input type="checkbox" id="c-42681165" checked=""/><div class="controls bullet"><span class="by">begueradj</span><span>|</span><a href="#42684691">prev</a><span>|</span><label class="collapse" for="c-42681165">[-]</label><label class="expand" for="c-42681165">[24 more]</label></div><br/><div class="children"><div class="content">Oops, this is not valid.</div><br/><div id="42681297" class="c"><input type="checkbox" id="c-42681297" checked=""/><div class="controls bullet"><span class="by">homebrewer</span><span>|</span><a href="#42681165">parent</a><span>|</span><a href="#42681259">next</a><span>|</span><label class="collapse" for="c-42681297">[-]</label><label class="expand" for="c-42681297">[10 more]</label></div><br/><div class="children"><div class="content">This feels like the often-repeated &quot;argument&quot; that Electron applications are fine because &quot;unused memory is wasted memory&quot;. What Linus meant by that is that the operating system should strive to use as much of the <i>free</i> RAM as possible for things like file and dentry caches. Not that memory should be wasted on millions of layers of abstraction and too-high resolution images. But it&#x27;s often misunderstood that way.</div><br/><div id="42685692" class="c"><input type="checkbox" id="c-42685692" checked=""/><div class="controls bullet"><span class="by">ack_complete</span><span>|</span><a href="#42681165">root</a><span>|</span><a href="#42681297">parent</a><span>|</span><a href="#42681850">next</a><span>|</span><label class="collapse" for="c-42685692">[-]</label><label class="expand" for="c-42685692">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s so annoying when that line is used to defend applications with poor memory usage, ignoring the fact that all modern OSes already put unallocated memory to use for caching.<p>&quot;Task Manager doesn&#x27;t report memory usage correctly&quot; is another B.S. excuse heard on Windows. It&#x27;s actually true, but the other way around -- Task Manager <i>underreports</i> the memory usage of most programs.</div><br/></div></div><div id="42681850" class="c"><input type="checkbox" id="c-42681850" checked=""/><div class="controls bullet"><span class="by">Culonavirus</span><span>|</span><a href="#42681165">root</a><span>|</span><a href="#42681297">parent</a><span>|</span><a href="#42685692">prev</a><span>|</span><a href="#42681259">next</a><span>|</span><label class="collapse" for="c-42681850">[-]</label><label class="expand" for="c-42681850">[8 more]</label></div><br/><div class="children"><div class="content">Eeeh, the Electron issue is oveblown.<p>These days the biggest hog of memory is the browser. Not everyone does this, but a lot of people, myself included, have tens of tabs open at a time (with tab groups and all of that)... all day. The browser is the primary reason I recommend a minimum of 16gb ram to F&amp;F when they ask &quot;the it guy&quot; what computer to buy.<p>When my Chrome is happily munching on many gigabytes of ram I don&#x27;t think a few hundred megs taken by your average Electron app is gonna move the needle.<p>The situation is a bit different on mobile, but Electron is not a mobile framework so that&#x27;s not relevant.<p>PS: Can I rant a bit how useless the new(ish) Chrome memory saver thing is? What is the point having tabs open if you&#x27;re gonna remove them from memory and just reload on activation? In the age of fast consumer ssds I&#x27;d expect you to intelligently hibernate the tabs on disk, otherwise what you have are silly bookmarks.</div><br/><div id="42682097" class="c"><input type="checkbox" id="c-42682097" checked=""/><div class="controls bullet"><span class="by">eadmund</span><span>|</span><a href="#42681165">root</a><span>|</span><a href="#42681850">parent</a><span>|</span><a href="#42681961">next</a><span>|</span><label class="collapse" for="c-42682097">[-]</label><label class="expand" for="c-42682097">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Eeeh, the Electron issue is oveblown.<p>&gt; These days the biggest hog of memory is the browser.<p>That’s the problem: Electron is another browser instance.<p>&gt; I don&#x27;t think a few hundred megs taken by your average Electron app is gonna move the needle.<p>Low-end machines even in 2025 still come with single-digit GB RAM sizes.  A few hundred MB is a substantial portion of an 8GB RAM bank.<p>Especially when it’s just waste.</div><br/><div id="42683644" class="c"><input type="checkbox" id="c-42683644" checked=""/><div class="controls bullet"><span class="by">p0w3n3d</span><span>|</span><a href="#42681165">root</a><span>|</span><a href="#42682097">parent</a><span>|</span><a href="#42681961">next</a><span>|</span><label class="collapse" for="c-42683644">[-]</label><label class="expand" for="c-42683644">[1 more]</label></div><br/><div class="children"><div class="content">And this company that says: let&#x27;s push to the users the installer of our brand new app, that will reside in their tray, which we have made in electron. Poof. 400MB taken for a tray notifier that also accidentally adds a browser to the memory<p>My computer: starts 5 seconds slower<p>1mln of computers in the world: start cumulatively 5mln seconds slower<p>Meanwhile a Microsoft programmer whose postgres via ssh starts 500ms slower: &quot;I think this is a rootkit installed in ssh&quot;</div><br/></div></div></div></div><div id="42681961" class="c"><input type="checkbox" id="c-42681961" checked=""/><div class="controls bullet"><span class="by">smolder</span><span>|</span><a href="#42681165">root</a><span>|</span><a href="#42681850">parent</a><span>|</span><a href="#42682097">prev</a><span>|</span><a href="#42683403">next</a><span>|</span><label class="collapse" for="c-42681961">[-]</label><label class="expand" for="c-42681961">[4 more]</label></div><br/><div class="children"><div class="content">Your argument against electron being a memory hog is that chrome is a bigger one? You are aware that electron is an instance of chromium, right?</div><br/><div id="42682431" class="c"><input type="checkbox" id="c-42682431" checked=""/><div class="controls bullet"><span class="by">rbanffy</span><span>|</span><a href="#42681165">root</a><span>|</span><a href="#42681961">parent</a><span>|</span><a href="#42683403">next</a><span>|</span><label class="collapse" for="c-42682431">[-]</label><label class="expand" for="c-42682431">[3 more]</label></div><br/><div class="children"><div class="content">This is a good point, but it would be interesting if we had a &quot;just enough&quot; rendering engine for UI elements that was a subset of a browser with enough functionality to provide a desktop app environment and that could be driven by the underlying application (or by the GUI, passing events to the underlying app).</div><br/><div id="42682579" class="c"><input type="checkbox" id="c-42682579" checked=""/><div class="controls bullet"><span class="by">nejsjsjsbsb</span><span>|</span><a href="#42681165">root</a><span>|</span><a href="#42682431">parent</a><span>|</span><a href="#42683403">next</a><span>|</span><label class="collapse" for="c-42682579">[-]</label><label class="expand" for="c-42682579">[2 more]</label></div><br/><div class="children"><div class="content">Problem there is Electron devs do it for convenience. That means esbuild, npm install react this that. If it ain&#x27;t a full browser this won&#x27;t work.</div><br/><div id="42685957" class="c"><input type="checkbox" id="c-42685957" checked=""/><div class="controls bullet"><span class="by">caspper69</span><span>|</span><a href="#42681165">root</a><span>|</span><a href="#42682579">parent</a><span>|</span><a href="#42683403">next</a><span>|</span><label class="collapse" for="c-42685957">[-]</label><label class="expand" for="c-42685957">[1 more]</label></div><br/><div class="children"><div class="content">Funny thing about all of this is that it&#x27;s just such oppressive overkill.<p>Most GUI toolkits can do layout &#x2F; graphics &#x2F; fonts in a much simpler (and sane) way. &quot;Reactive&quot; layout is not a new concept.<p>HTML&#x2F;CSS&#x2F;JS is not an efficient or clean way to do layout in an application. It only exists to shoehorn UI layout into a rich text DOCUMENT format.<p>Can you imagine if Microsoft or Apple had insisted that GUI application layout be handled the way we do it today back in the 80s and 90s? Straight up C was easier to grok that this garbage we have today. The industry as a whole should be ashamed. It&#x27;s not easier, it doesn&#x27;t make things look better, and it wastes billions in developer time and user time, not to mention slowly making the oceans boil.<p>Every time I have to use a web-based application (which is most of the time nowadays), it infuriates me. The latency is atrocious. The UIs are slow. There&#x27;s mysterious errors at least once or twice daily. WTF are we doing? When a Windows 95 application ran faster and was more responsive and more reliable than something written 30 years later, we have a serious problem.<p>Here&#x27;s some advice: stop throwing your web code into Electron, and start using a cross-platform GUI toolkit. Use local files and&#x2F;or sqlite databases for storage, and then sync to the cloud in the background. Voila, non-shit applications that stop wasting everybody&#x27;s effing time.<p>If your only tool is a hammer, something, something, nails...</div><br/></div></div></div></div></div></div></div></div><div id="42683403" class="c"><input type="checkbox" id="c-42683403" checked=""/><div class="controls bullet"><span class="by">Dalewyn</span><span>|</span><a href="#42681165">root</a><span>|</span><a href="#42681850">parent</a><span>|</span><a href="#42681961">prev</a><span>|</span><a href="#42681259">next</a><span>|</span><label class="collapse" for="c-42683403">[-]</label><label class="expand" for="c-42683403">[1 more]</label></div><br/><div class="children"><div class="content">&gt;otherwise what you have are silly bookmarks.<p>My literal <i>several hundreds</i> of tabs are silly bookmarks in practice.</div><br/></div></div></div></div></div></div><div id="42681259" class="c"><input type="checkbox" id="c-42681259" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42681165">parent</a><span>|</span><a href="#42681297">prev</a><span>|</span><a href="#42681316">next</a><span>|</span><label class="collapse" for="c-42681259">[-]</label><label class="expand" for="c-42681259">[9 more]</label></div><br/><div class="children"><div class="content">Only when your computer actually has work to do. Otherwise your CPU is just a really expensive heater.<p>Modern computers are designed to idle at 0% then temporarily boost up when you have work to do. Then once the task is done, they can drop back to idle and cool down again.</div><br/><div id="42681278" class="c"><input type="checkbox" id="c-42681278" checked=""/><div class="controls bullet"><span class="by">PUSH_AX</span><span>|</span><a href="#42681165">root</a><span>|</span><a href="#42681259">parent</a><span>|</span><a href="#42681316">next</a><span>|</span><label class="collapse" for="c-42681278">[-]</label><label class="expand" for="c-42681278">[8 more]</label></div><br/><div class="children"><div class="content">Not that I disagree, but when exactly in modern operating systems are there moments where there are zero instructions being executed? Surely there are always processes doing background things?</div><br/><div id="42681562" class="c"><input type="checkbox" id="c-42681562" checked=""/><div class="controls bullet"><span class="by">reshlo</span><span>|</span><a href="#42681165">root</a><span>|</span><a href="#42681278">parent</a><span>|</span><a href="#42682243">next</a><span>|</span><label class="collapse" for="c-42681562">[-]</label><label class="expand" for="c-42681562">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Timer Coalescing attempts to enforce some order on all this chaos. While on battery power, Mavericks will routinely scan all upcoming timers that apps have set and then apply a gentle nudge to line up any timers that will fire close to each other in time. This &quot;coalescing&quot; behavior means that the disk and CPU can awaken, perform timer-related tasks for multiple apps at once, and then return to sleep or idle for a longer period of time before the next round of timers fire.[0]<p>&gt; Specify a tolerance for the accuracy of when your timers fire. The system will use this flexibility to shift the execution of timers by small amounts of time—within their tolerances—so that multiple timers can be executed at the same time. Using this approach dramatically increases the amount of time that the processor spends idling…[1]<p>[0] <a href="https:&#x2F;&#x2F;arstechnica.com&#x2F;gadgets&#x2F;2013&#x2F;06&#x2F;how-os-x-mavericks-works-its-power-saving-magic&#x2F;" rel="nofollow">https:&#x2F;&#x2F;arstechnica.com&#x2F;gadgets&#x2F;2013&#x2F;06&#x2F;how-os-x-mavericks-w...</a><p>[1] <a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;library&#x2F;archive&#x2F;documentation&#x2F;Performance&#x2F;Conceptual&#x2F;EnergyGuide-iOS&#x2F;MinimizeTimerUse.html" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;library&#x2F;archive&#x2F;documentation&#x2F;Pe...</a></div><br/><div id="42682138" class="c"><input type="checkbox" id="c-42682138" checked=""/><div class="controls bullet"><span class="by">miki123211</span><span>|</span><a href="#42681165">root</a><span>|</span><a href="#42681562">parent</a><span>|</span><a href="#42682243">next</a><span>|</span><label class="collapse" for="c-42682138">[-]</label><label class="expand" for="c-42682138">[1 more]</label></div><br/><div class="children"><div class="content">Modern Macs also have two different kinds of cores, slow but energy-efficient e-cores and high-performance p-cores.<p>The p cores can be activated and deactivated very quickly, on the order of microseconds IIRC, which means the processor always &quot;feels&quot; fast while still conserving battery life.</div><br/></div></div></div></div><div id="42682243" class="c"><input type="checkbox" id="c-42682243" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#42681165">root</a><span>|</span><a href="#42681278">parent</a><span>|</span><a href="#42681562">prev</a><span>|</span><a href="#42681513">next</a><span>|</span><label class="collapse" for="c-42682243">[-]</label><label class="expand" for="c-42682243">[1 more]</label></div><br/><div class="children"><div class="content">We’re not talking about what humans call “a moment”. For a (modern) computer, a millisecond is “a moment”, possibly even “a long moment”. It can run millions of instructions in such a time frame.<p>A modern CPU also has multiple cores not all of which may be needed, and will be supported by hardware that can do lots of tasks.<p>For example, sending out an audio signal isn’t typically done by the main CPU. It tells some hardware to send a buffer of data at some frequency, then prepares the next buffer, and can then sleep or do other stuff until it has to send the new buffer.</div><br/></div></div><div id="42681513" class="c"><input type="checkbox" id="c-42681513" checked=""/><div class="controls bullet"><span class="by">johannes1234321</span><span>|</span><a href="#42681165">root</a><span>|</span><a href="#42681278">parent</a><span>|</span><a href="#42682243">prev</a><span>|</span><a href="#42681361">next</a><span>|</span><label class="collapse" for="c-42681513">[-]</label><label class="expand" for="c-42681513">[1 more]</label></div><br/><div class="children"><div class="content">From human perception there will &quot;always&quot; be work on a &quot;normal&quot; system.<p>However for a CPU with multiple cores, each running at 2+ GHz, there is enough room for idling while seeming active.</div><br/></div></div><div id="42681361" class="c"><input type="checkbox" id="c-42681361" checked=""/><div class="controls bullet"><span class="by">_flux</span><span>|</span><a href="#42681165">root</a><span>|</span><a href="#42681278">parent</a><span>|</span><a href="#42681513">prev</a><span>|</span><a href="#42681345">next</a><span>|</span><label class="collapse" for="c-42681361">[-]</label><label class="expand" for="c-42681361">[1 more]</label></div><br/><div class="children"><div class="content">There are a lot of such moments, but they are just short. When you&#x27;re playing music, you download a bit of data from the network or the SSD&#x2F;HDD by first issuing a request and then waiting (i.e. doing nothing) to get the short piece of data back. Then you decode it and upload a short bit of the sound to your sound card and then again you wait for new space to come up, before you send more data.<p>One of the older ways (in x86 side) to do this was to invoke the HLT instruction <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;HLT_(x86_instruction)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;HLT_(x86_instruction)</a> : you stop the processor, and then the processor wakes up when an interrupt wakes it up. An interrupt might come from the sound card, network card, keyboard, GPU, timer (e.g. 100 times a second to schedule an another process, if some process exists that is waiting for CPU), and during the time you wait for the interrupt to happen you just do nothing, thus saving energy.<p>I suspect things are more complicated in the world of multiple CPUs.</div><br/></div></div><div id="42681345" class="c"><input type="checkbox" id="c-42681345" checked=""/><div class="controls bullet"><span class="by">pintxo</span><span>|</span><a href="#42681165">root</a><span>|</span><a href="#42681278">parent</a><span>|</span><a href="#42681361">prev</a><span>|</span><a href="#42682594">next</a><span>|</span><label class="collapse" for="c-42681345">[-]</label><label class="expand" for="c-42681345">[1 more]</label></div><br/><div class="children"><div class="content">With multi-core cpus, some of them can be fully off, while others handle any background tasks.</div><br/></div></div><div id="42682594" class="c"><input type="checkbox" id="c-42682594" checked=""/><div class="controls bullet"><span class="by">nejsjsjsbsb</span><span>|</span><a href="#42681165">root</a><span>|</span><a href="#42681278">parent</a><span>|</span><a href="#42681345">prev</a><span>|</span><a href="#42681316">next</a><span>|</span><label class="collapse" for="c-42682594">[-]</label><label class="expand" for="c-42682594">[1 more]</label></div><br/><div class="children"><div class="content">My processor gets several whole nanoseconds to rest up, I am not a slave driver.</div><br/></div></div></div></div></div></div><div id="42681316" class="c"><input type="checkbox" id="c-42681316" checked=""/><div class="controls bullet"><span class="by">TonyTrapp</span><span>|</span><a href="#42681165">parent</a><span>|</span><a href="#42681259">prev</a><span>|</span><a href="#42681253">next</a><span>|</span><label class="collapse" for="c-42681316">[-]</label><label class="expand" for="c-42681316">[1 more]</label></div><br/><div class="children"><div class="content">What you are probably thinking of is &quot;race to idle&quot;. A CPU should process everything it can, as quickly it can (using all the power), and then go to an idle state, instead of processing everything slowly (potentially consuming less energy at that time) but take more time.</div><br/></div></div><div id="42681253" class="c"><input type="checkbox" id="c-42681253" checked=""/><div class="controls bullet"><span class="by">zaik</span><span>|</span><a href="#42681165">parent</a><span>|</span><a href="#42681316">prev</a><span>|</span><a href="#42681200">next</a><span>|</span><label class="collapse" for="c-42681253">[-]</label><label class="expand" for="c-42681253">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re probably thinking about memory and caching. There are no advantages to keeping the CPU at 100% when no workload needs to be done.</div><br/></div></div><div id="42681200" class="c"><input type="checkbox" id="c-42681200" checked=""/><div class="controls bullet"><span class="by">M95D</span><span>|</span><a href="#42681165">parent</a><span>|</span><a href="#42681253">prev</a><span>|</span><a href="#42681340">next</a><span>|</span><label class="collapse" for="c-42681200">[-]</label><label class="expand" for="c-42681200">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure a few more software updates will take care of this little problem...</div><br/></div></div><div id="42681340" class="c"><input type="checkbox" id="c-42681340" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#42681165">parent</a><span>|</span><a href="#42681200">prev</a><span>|</span><label class="collapse" for="c-42681340">[-]</label><label class="expand" for="c-42681340">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  computer architecture courses.<p>I guess it was some _theoretical_ task scheduling stuff.... 
When you are doing task scheduling, yes, maybe, depends on what you optimize for.<p>.... but this bug have nothing  to do with that. This bug is about some accounting error.</div><br/></div></div></div></div></div></div></div></div></div></body></html>