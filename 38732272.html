<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1703408453838" as="style"/><link rel="stylesheet" href="styles.css?v=1703408453838"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://steveklabnik.com/writing/memory-safety-is-a-red-herring">Memory safety is necessary, not sufficient</a> <span class="domain">(<a href="https://steveklabnik.com">steveklabnik.com</a>)</span></div><div class="subtext"><span>weinzierl</span> | <span>107 comments</span></div><br/><div><div id="38748950" class="c"><input type="checkbox" id="c-38748950" checked=""/><div class="controls bullet"><span class="by">dgreensp</span><span>|</span><a href="#38734975">next</a><span>|</span><label class="collapse" for="c-38748950">[-]</label><label class="expand" for="c-38748950">[43 more]</label></div><br/><div class="children"><div class="content">I think it’s worth emphasizing that the C spec’s love of undefined behavior—if you do X by accident, anything can happen—and the apparently massive amount of memory-unsafe software that has been written that will just allocate 16 bytes on the stack and then read from a file descriptor until it encounters a null byte… are examples of things that aren’t considered remotely sane or reasonable to a modern programmer or language designer.  Any vague notion of “unsafe” in the context of a modern language—like saying well, if there’s a syscall, maybe something unexpected could happen—doesn’t compare to the bad decisions made by C and C programmers&#x2F;culture that affect us today because we still use C code in our things.<p>The deep, idiosyncratic flaws of C trace back to “worse is better.”  Few people remember or look up what “worse is better” actually meant.  Wikipedia wrongly says it’s a “less is more” sort of thing, and some people think it’s about not being a perfectionist.<p>But actually… actually actually, if you read the essay, it says “worse is better” means (paraphrasing) it’s <i>more important that C compilers be easy to implement than easy to use</i>.  Also, <i>it is more important that the implementation—or the design of the implementation—of a piece of software be simple than that it be correct.  It is more important that it be simple than that it be consistent.  It is more important that it be simple than that it be “complete” (for example, handle edge cases; it just needs to work in “most situations”).</i>  This is not just anti-perfectionism, it is an objectively terrible set of engineering values.  But there were so many different kinds of computers and operating systems back then—you didn’t even know if a byte was 8 bits—that it helped a lot that C compilers could do whatever they wanted in many situations.  And making it easy for C compiler implementers enabled C to spread far and wide.  It was a very different world, and just being able to write in a higher-level language than assembly on a particular computer was a big deal.</div><br/><div id="38752230" class="c"><input type="checkbox" id="c-38752230" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#38748950">parent</a><span>|</span><a href="#38750867">next</a><span>|</span><label class="collapse" for="c-38752230">[-]</label><label class="expand" for="c-38752230">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Worse is better&quot; is much older then &quot;undefined behaviour&quot;. Undefined behaviour was invented for C standardization, when C was already mature and had been out of the Unix childhood home for a long time.</div><br/></div></div><div id="38750867" class="c"><input type="checkbox" id="c-38750867" checked=""/><div class="controls bullet"><span class="by">wavemode</span><span>|</span><a href="#38748950">parent</a><span>|</span><a href="#38752230">prev</a><span>|</span><a href="#38749239">next</a><span>|</span><label class="collapse" for="c-38750867">[-]</label><label class="expand" for="c-38750867">[1 more]</label></div><br/><div class="children"><div class="content">Software was significantly simpler in those days. I don&#x27;t find it strange that they took a simplified view of software engineering. Specifically because those exact same simplified views still exist today - talk to people who&#x27;ve never worked on large complex systems, and you will usually encounter similar &quot;anti-perfectionism&quot;.<p>People adopt simplified engineering practices when working on simple software by themselves, compared to when working on complex software within a large team.</div><br/></div></div><div id="38749239" class="c"><input type="checkbox" id="c-38749239" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38748950">parent</a><span>|</span><a href="#38750867">prev</a><span>|</span><a href="#38751603">next</a><span>|</span><label class="collapse" for="c-38749239">[-]</label><label class="expand" for="c-38749239">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not like PL&#x2F;I didn&#x27;t allow for similar flaws, so &quot;Worse is better&quot; is neither here nor there.  At least C was simple enough to learn for most programmers.  It&#x27;s still generally the case that a simple approach is more likely to be correct than an overly complicated one for which it&#x27;s not even clear what &quot;correct&quot; means.</div><br/><div id="38751013" class="c"><input type="checkbox" id="c-38751013" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38749239">parent</a><span>|</span><a href="#38751603">next</a><span>|</span><label class="collapse" for="c-38751013">[-]</label><label class="expand" for="c-38751013">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s not like PL&#x2F;I didn&#x27;t allow for similar flaws, so &quot;Worse is better&quot; is neither here nor there.<p>PL&#x2F;I is one of the reasons that Multics was not plagued by buffer overflows:<p>&quot;The net result is that a PL&#x2F;I programmer would have to work very hard to program a buffer overflow error, while a C programmer has to work very hard to avoid programming a buffer overflow error.&quot; [1]<p>[1] P. Karger, R. Schell, &quot;Thirty Years Later: Lessons from the Multics Security Evaluation&quot;</div><br/></div></div></div></div><div id="38751603" class="c"><input type="checkbox" id="c-38751603" checked=""/><div class="controls bullet"><span class="by">jules</span><span>|</span><a href="#38748950">parent</a><span>|</span><a href="#38749239">prev</a><span>|</span><a href="#38750556">next</a><span>|</span><label class="collapse" for="c-38751603">[-]</label><label class="expand" for="c-38751603">[8 more]</label></div><br/><div class="children"><div class="content">Undefined behavior is critical for performance. Without undefined behavior, C compilers would not be able to optimize at all. You&#x27;d be running everything at -O0 or worse.</div><br/><div id="38752190" class="c"><input type="checkbox" id="c-38752190" checked=""/><div class="controls bullet"><span class="by">nindalf</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38751603">parent</a><span>|</span><a href="#38752021">next</a><span>|</span><label class="collapse" for="c-38752190">[-]</label><label class="expand" for="c-38752190">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Undefined behavior is critical for performance<p>Not only is this not true, it&#x27;s trivially easy to prove it&#x27;s not true. Both rustc and clang generate LLVM IR and use LLVM to optimise and generate machine code. The code that&#x27;s generated is equally performant, as you&#x27;d expect since most of the optimisation is being done by LLVM, not the front end.<p>The difference between the two frontends is that rustc is stricter, rejecting programs where UB may arise.</div><br/></div></div><div id="38752021" class="c"><input type="checkbox" id="c-38752021" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38751603">parent</a><span>|</span><a href="#38752190">prev</a><span>|</span><a href="#38751905">next</a><span>|</span><label class="collapse" for="c-38752021">[-]</label><label class="expand" for="c-38752021">[3 more]</label></div><br/><div class="children"><div class="content">Even if that&#x27;s true (which is not given, as others have said), it would be a worthy trade to make. Software needs to <i>do what it&#x27;s meant to do</i> first and foremost. Speed doesn&#x27;t mean shit if you can&#x27;t trust that the software actually works.</div><br/><div id="38752042" class="c"><input type="checkbox" id="c-38752042" checked=""/><div class="controls bullet"><span class="by">lpapez</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38752021">parent</a><span>|</span><a href="#38751905">next</a><span>|</span><label class="collapse" for="c-38752042">[-]</label><label class="expand" for="c-38752042">[2 more]</label></div><br/><div class="children"><div class="content">But that is simply not true, and can be proved by looking at the world we live in.<p>C became the dominant language precisely due to hardware constraints, and the ability to extract every last drop from limited hardware was back in the day more important than software working perfectly always. If this wasn&#x27;t the case, other safer alternatives would have been preferred.<p>Unless in very specific domains, hardware advances have outpaced the software needs (eg. there is only so much compute power a spreadsheet user will need). That is why today we allow ourselves to think about &quot;luxuries of the past&quot; such as corectness, safety, ergonomics, composability etc.</div><br/><div id="38752057" class="c"><input type="checkbox" id="c-38752057" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38752042">parent</a><span>|</span><a href="#38751905">next</a><span>|</span><label class="collapse" for="c-38752057">[-]</label><label class="expand" for="c-38752057">[1 more]</label></div><br/><div class="children"><div class="content">&gt; [..] and the ability to extract every last drop from limited hardware was back in the day more important than software working perfectly always<p>That seems to contradict the “very simple to implement compiler”</div><br/></div></div></div></div></div></div><div id="38751905" class="c"><input type="checkbox" id="c-38751905" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38751603">parent</a><span>|</span><a href="#38752021">prev</a><span>|</span><a href="#38751963">next</a><span>|</span><label class="collapse" for="c-38751905">[-]</label><label class="expand" for="c-38751905">[1 more]</label></div><br/><div class="children"><div class="content">Undefined behaviour enables only a fairly small set of optimisations. There&#x27;s a large set of optimisations that can be implemented completely safely without having to make such dangerous assumptions. Other programming languages do this all the time, it&#x27;s not just C&#x2F;C++ that have optimisers!</div><br/></div></div><div id="38751963" class="c"><input type="checkbox" id="c-38751963" checked=""/><div class="controls bullet"><span class="by">renox</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38751603">parent</a><span>|</span><a href="#38751905">prev</a><span>|</span><a href="#38750556">next</a><span>|</span><label class="collapse" for="c-38751963">[-]</label><label class="expand" for="c-38751963">[2 more]</label></div><br/><div class="children"><div class="content">Where&#x27;s your proof?<p>Rust has far fewer UB than C yet its performance is comparable to C.</div><br/><div id="38752074" class="c"><input type="checkbox" id="c-38752074" checked=""/><div class="controls bullet"><span class="by">nindalf</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38751963">parent</a><span>|</span><a href="#38750556">next</a><span>|</span><label class="collapse" for="c-38752074">[-]</label><label class="expand" for="c-38752074">[1 more]</label></div><br/><div class="children"><div class="content">Just to add, Safe Rust should have <i>zero</i> UB, modulo bugs in the compiler. And they&#x27;re very serious about fixing such bugs. They won&#x27;t dismiss it with &quot;just be careful while programming&quot;.</div><br/></div></div></div></div></div></div><div id="38750556" class="c"><input type="checkbox" id="c-38750556" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#38748950">parent</a><span>|</span><a href="#38751603">prev</a><span>|</span><a href="#38751554">next</a><span>|</span><label class="collapse" for="c-38750556">[-]</label><label class="expand" for="c-38750556">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If you read the essay, it says “worse is better” means (paraphrasing) it’s more important that C compilers be easy to implement than easy to use. Also, it is more important that the implementation—or the design of the implementation—of a piece of software be simple than that it be correct. It is more important that it be simple than that it be consistent. It is more important that it be simple than that it be “complete” (for example, handle edge cases; it just needs to work in “most situations”).<p>This is really ironic considering C++, whose compilers may literally be the most complicated compilers to ever exist, and none of them implement the full (C++23) language spec.<p>What kind of maxim does C++ go by?</div><br/><div id="38750734" class="c"><input type="checkbox" id="c-38750734" checked=""/><div class="controls bullet"><span class="by">eschaton</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38750556">parent</a><span>|</span><a href="#38751554">next</a><span>|</span><label class="collapse" for="c-38750734">[-]</label><label class="expand" for="c-38750734">[1 more]</label></div><br/><div class="children"><div class="content">1. If you don’t use a language feature in your code, your code shouldn’t pay the cost—no matter what else might be helped, enabled or prevented by that. To this day compilers let entire features like exceptions and RTTI be disabled entirely rather than accept that there might possibly be some costs worth imposing.<p>2. Binary compatibility and dynamic linking don’t matter at all, and shouldn’t ever be considered in design or revision of anything language-related.<p>3. All areas of computer science and engineering are open to being a part of the standard library and existing language and standard library authors are the best judges of what should be in the standard and how it should be implemented than anyone else, including platform vendors or subject matter experts.</div><br/></div></div></div></div><div id="38751554" class="c"><input type="checkbox" id="c-38751554" checked=""/><div class="controls bullet"><span class="by">moody__</span><span>|</span><a href="#38748950">parent</a><span>|</span><a href="#38750556">prev</a><span>|</span><a href="#38749427">next</a><span>|</span><label class="collapse" for="c-38751554">[-]</label><label class="expand" for="c-38751554">[9 more]</label></div><br/><div class="children"><div class="content">&gt;it is more important that the implementation—or the design of the implementation—of a piece of software be simple than that it be correct.<p>This is true and when your compiler actually abides by these values it is shocking how many issues just go away. The problem is that gcc and clang are nowhere near a simple implementation, asking the question of how exactly gcc or clang arrived at some given assembly for some given input is a really complicated answer. So much so that it makes me say that the relationship between the programmer and the compiler becomes adversarial. It would be one thing to just have very complicated optimizations but the whole &quot;undefined behavior lets us to anything&quot; approach is what makes it unbearable.<p>People can (and do) point at the C spec for fault of this and it is true that if the C spec was more strict then these compilers would not have the free pass to do these crazy miscompilations. However there is nothing stopping these compilers from just not doing that, there is nothing stopping them from just defining their own sane behavior for what the C spec defines as undefined behavior. It is no longer the case where we have a dozen or so C compilers that people need to target with their programs, the spec is not the bottom line anymore.<p>The Plan 9 compilers are the perfect example of getting this right. They define sane behavior that a reasonable programmer would expect for what the C spec calls undefined behavior. They are not gargantuan, their optimizations are not crazy. It is generally easy to understand how the compiler ended up with the assembly you see in the binary. Yet they are competent enough to selfhost an entire OS. The insane complexity of these other C compilers is simply not mandatory. They are not perfect of course it is still possible to write bad code but the result is no longer pathological, which is a giant help when you&#x27;re actually trying to figure out what is going wrong.</div><br/><div id="38752087" class="c"><input type="checkbox" id="c-38752087" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38751554">parent</a><span>|</span><a href="#38751780">next</a><span>|</span><label class="collapse" for="c-38752087">[-]</label><label class="expand" for="c-38752087">[1 more]</label></div><br/><div class="children"><div class="content">With all due respect, these “adversial compiler” expression just makes zero sense, and takes a lot away from your comment.<p>Guess what, the world is complex, and software has no bound for complexity. Which is better, a multi-million lines compiler that hundreds of people worked on for decades, or a toy one in a couple thousand lines written by a single programmer? What if the former can create 2-10x faster code than the latter (I probably even underestimate it, loop unswitching, vectorization, etc. can account for even more differences).<p>It turns out that we can build abstractions on top of abstractions, and if it’s designed well, it will scale with complexity (which we require). Would you change back to an OS that didn’t handle multithreading as it’s too complicated? Or that wouldn’t use GPUs?</div><br/></div></div><div id="38751780" class="c"><input type="checkbox" id="c-38751780" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38751554">parent</a><span>|</span><a href="#38752087">prev</a><span>|</span><a href="#38751833">next</a><span>|</span><label class="collapse" for="c-38751780">[-]</label><label class="expand" for="c-38751780">[5 more]</label></div><br/><div class="children"><div class="content">&gt; <i>piece of software be simple than that it be correct</i><p>Here is the thing: which of these is more plausible or at least less far-fetched?<p>A. Write a program that is not correct now, but will eventually be.<p>B. Write a program that is complicated now, but will eventually be simpler.<p>:)<p>Simplicity isn&#x27;t something you can leave out now and add later, yet correctness can often be treated that way. Even a shop that values correctness above all else still does debugging. (If not code, then debugging their proofs, and debugging whether their formal specification actually implement the functional requirements).</div><br/><div id="38751877" class="c"><input type="checkbox" id="c-38751877" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38751780">parent</a><span>|</span><a href="#38751885">next</a><span>|</span><label class="collapse" for="c-38751877">[-]</label><label class="expand" for="c-38751877">[2 more]</label></div><br/><div class="children"><div class="content">If you simplify a correct program, it will most likely still be correct. If you &quot;correct&quot; a simple program, it probably becomes complicated.</div><br/><div id="38751936" class="c"><input type="checkbox" id="c-38751936" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38751877">parent</a><span>|</span><a href="#38751885">next</a><span>|</span><label class="collapse" for="c-38751936">[-]</label><label class="expand" for="c-38751936">[1 more]</label></div><br/><div class="children"><div class="content">If you algebraically simplify a correct program it will be correct.<p>But the simplicity which is at play in the context of &quot;worse is better&quot; is simplicity of requirement specifications themselves, before any code is written. (I think I&#x27;m the one who muddied the waters here by insinuating that correctness is a matter of debugging an incorrect program against a correct specification.)<p>In projects that value simplicity over correctness, what that means is that what is considered correct (as in the requirement we shall implement) is the simpler requirements, which are regarded as incorrect by other projects.<p>Programs that implement the complex requirements are vanishingly improbable to be simplified into programs that implement simple requirements, simply because those are breaking changes.<p>E.g. you can&#x27;t take a database engine that provides certain consistency guarantees and make it have weaker guarantees in the next version (for the sake of simplicity), without breaking all the applications that depend on the current guarantees.<p>Correctness can be added --- including at the requirements level, not only debugging. It can be because it&#x27;s often backwards compatible. E.g. adding handling for cases that were previously ignored.</div><br/></div></div></div></div><div id="38751885" class="c"><input type="checkbox" id="c-38751885" checked=""/><div class="controls bullet"><span class="by">moody__</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38751780">parent</a><span>|</span><a href="#38751877">prev</a><span>|</span><a href="#38751833">next</a><span>|</span><label class="collapse" for="c-38751885">[-]</label><label class="expand" for="c-38751885">[2 more]</label></div><br/><div class="children"><div class="content">You add in simplicity by taking out code. It is very possible (and common) to find better abstractions or methods to approach a problem that reduce the complexity of the code.</div><br/><div id="38751904" class="c"><input type="checkbox" id="c-38751904" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38751885">parent</a><span>|</span><a href="#38751833">next</a><span>|</span><label class="collapse" for="c-38751904">[-]</label><label class="expand" for="c-38751904">[1 more]</label></div><br/><div class="children"><div class="content">It is vanishingly uncommon to simplify an entire application, so that it goes from something complex to something whose number one value is simplicity, such that the simplicity is reflected in the actual functional specification.</div><br/></div></div></div></div></div></div><div id="38751833" class="c"><input type="checkbox" id="c-38751833" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38751554">parent</a><span>|</span><a href="#38751780">prev</a><span>|</span><a href="#38751723">next</a><span>|</span><label class="collapse" for="c-38751833">[-]</label><label class="expand" for="c-38751833">[1 more]</label></div><br/><div class="children"><div class="content">The main problem is this: the undefined status of one construct A in the program changes the behavior of a different, independent construct B in the program, even in cases when, say, B executes first and is correct. Everything is jumbled together in the optimizer, which establishes logical ties between the pieces that are unrelated to the network of intent.<p>If the undefined behavior of construct A causes just A to misbehave, we are still in sane waters.</div><br/></div></div><div id="38751723" class="c"><input type="checkbox" id="c-38751723" checked=""/><div class="controls bullet"><span class="by">spease</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38751554">parent</a><span>|</span><a href="#38751833">prev</a><span>|</span><a href="#38749427">next</a><span>|</span><label class="collapse" for="c-38751723">[-]</label><label class="expand" for="c-38751723">[1 more]</label></div><br/><div class="children"><div class="content">How do the Plan 9 compilers compare to gcc&#x2F;clang when it comes to performance or portability?</div><br/></div></div></div></div><div id="38749427" class="c"><input type="checkbox" id="c-38749427" checked=""/><div class="controls bullet"><span class="by">quelsolaar</span><span>|</span><a href="#38748950">parent</a><span>|</span><a href="#38751554">prev</a><span>|</span><a href="#38749181">next</a><span>|</span><label class="collapse" for="c-38749427">[-]</label><label class="expand" for="c-38749427">[2 more]</label></div><br/><div class="children"><div class="content">C gives you a level of control and responsibility not found in other languages. That&#x27;s a choice, not something that is inherently worse. It may be worse for what you are doing. Most people don&#x27;t value the level of control that C gives you and would rather chose another language and that is fine. But having a language available with this level of control is valuable, even if few people chose to use it. Most UB in the C standard is there for a very good reason.</div><br/><div id="38752105" class="c"><input type="checkbox" id="c-38752105" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38749427">parent</a><span>|</span><a href="#38749181">next</a><span>|</span><label class="collapse" for="c-38752105">[-]</label><label class="expand" for="c-38752105">[1 more]</label></div><br/><div class="children"><div class="content">C is not a particularly low-level. It has no (standard) way to control vectorization, stack usage, calling conventions, etc.<p>It just had an insane about of money spent on making its compilers optimize better.</div><br/></div></div></div></div><div id="38749181" class="c"><input type="checkbox" id="c-38749181" checked=""/><div class="controls bullet"><span class="by">nullc</span><span>|</span><a href="#38748950">parent</a><span>|</span><a href="#38749427">prev</a><span>|</span><a href="#38734975">next</a><span>|</span><label class="collapse" for="c-38749181">[-]</label><label class="expand" for="c-38749181">[17 more]</label></div><br/><div class="children"><div class="content">uh. No. Rust unsafe gives rust behavior a lot like C. If you at all break the rather subtle rules, then essentially anything can and will happen.<p>So for example, there was recently a thread where someone had code that checked if a value was in range to safely coerce it directly to an enum then did so. But because of eager evaluation of an argument the unsafe cast happened first.  From this the compiler reasoned that the variable was preconditionally range constrained to always be in range and it optimized out the in-range test (which itself was not unsafe code).<p>This is a <i>classic</i> C bug where someone implements an overflow check that itself can overflow, causing the branch for overflow to get optimized out.  But at least in C the simpler syntax at least made it clear that the triggering code got executed first.  The more complex rust syntax obscured that.<p>Rust has improved the situation by narrowing the cases where you can get into this trouble, but on the other hand it adds a lot of other complexity that contributes to faulty code (and a nearly mandatory packaging ecosystem which is a security nightmare-- it&#x27;s the norm for even simple rust utilities to pull in a million lines of unauditable (just by bulk) third party code, including multiple HTTPS libraries).<p>As a result, I don&#x27;t think it can be taken for granted that rust as a whole is an advancement in software integrity-- it may be, but it&#x27;s something that ought to be formally studied.  In some cases rust might be replacing memory safety bugs with an even greater number of other defects which, depending on the application, may be worse.  (not everything is an internet exposed service where hacks are the only failure of consequence and where input really should be assumed to be intelligently adversarial.)<p>In any case, &quot;break the rules and all bets are off&quot; is an issue that likely will continue to exist in any performant language.  Automatic code generation will generate stuff with awful performance unless an optimizer goes through and eliminates &#x27;impossible cases&#x27;, but optimization isn&#x27;t possible unless the compiler can assume the rules are followed.</div><br/><div id="38749716" class="c"><input type="checkbox" id="c-38749716" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38749181">parent</a><span>|</span><a href="#38749419">next</a><span>|</span><label class="collapse" for="c-38749716">[-]</label><label class="expand" for="c-38749716">[11 more]</label></div><br/><div class="children"><div class="content">&gt; If you at all break the rather subtle rules, then essentially anything can and will happen.<p>If by subtle rules you mean your invariants, that is missing fundamental assumptions.<p>It&#x27;s akin to making a building without foundation and load bearing structures.<p>&gt; So for example, there was recently a thread where someone had code that checked if a value was in range to safely coerce it directly to an enum then did so. But because of eager evaluation of an argument the unsafe cast happened first<p>You mean this: <a href="https:&#x2F;&#x2F;notgull.net&#x2F;cautionary-unsafe-tale&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;notgull.net&#x2F;cautionary-unsafe-tale&#x2F;</a><p>However note the UB goes away if you never use any unsafe code. Or if you expand your unsafe to encompas some safe code.<p>Issue it had was safe code was invalidating the invariants unsafe code was relying on. Iirc alignment.</div><br/><div id="38749813" class="c"><input type="checkbox" id="c-38749813" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38749716">parent</a><span>|</span><a href="#38750905">next</a><span>|</span><label class="collapse" for="c-38749813">[-]</label><label class="expand" for="c-38749813">[9 more]</label></div><br/><div class="children"><div class="content">&gt; If by subtle rules you mean your invariants, that is missing fundamental assumptions.<p>&gt; It&#x27;s akin to making a building without foundation and load bearing structures.<p>That&#x27;s exactly how C approaches UB too.<p>&gt; However note the UB goes away if you never use any unsafe code. Or if you expand your unsafe to encompas some safe code.<p>Right. The problem is that&#x27;s untenable; any nontrivial program will have unsafe <i>somewhere</i>, and unsafe can cause failures arbitrarily far away from the incorrect code. The whole point of the article is that you need to be able to draw an actual boundary between the unsafe parts and the safe parts of your program and review the unsafe parts in isolation. If Rust doesn&#x27;t give you more and better support in doing that than C does, then it&#x27;s not really making a difference.</div><br/><div id="38750770" class="c"><input type="checkbox" id="c-38750770" checked=""/><div class="controls bullet"><span class="by">couchand</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38749813">parent</a><span>|</span><a href="#38751302">next</a><span>|</span><label class="collapse" for="c-38750770">[-]</label><label class="expand" for="c-38750770">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If Rust doesn&#x27;t give you more and better support in doing that than C does, then it&#x27;s not really making a difference.<p>It does and if you&#x27;ve been missing that you&#x27;ve misunderstood this whole discussion.  Rust allows you to wrap up some unsafe code in a safe abstraction.  You use the type checker to enforce your invariants, such that the unsafe code can be reviewed in isolation.<p>Rust gives you exactly what you&#x27;re saying you want.  Steve is describing Rust as it is.</div><br/><div id="38751266" class="c"><input type="checkbox" id="c-38751266" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38750770">parent</a><span>|</span><a href="#38751302">next</a><span>|</span><label class="collapse" for="c-38751266">[-]</label><label class="expand" for="c-38751266">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It does and if you&#x27;ve been missing that you&#x27;ve misunderstood this whole discussion.<p>Don&#x27;t tell it to me, tell it to the person I was replying to.</div><br/></div></div></div></div><div id="38751302" class="c"><input type="checkbox" id="c-38751302" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38749813">parent</a><span>|</span><a href="#38750770">prev</a><span>|</span><a href="#38751242">next</a><span>|</span><label class="collapse" for="c-38751302">[-]</label><label class="expand" for="c-38751302">[1 more]</label></div><br/><div class="children"><div class="content"><i>The problem is that&#x27;s untenable; any nontrivial program will have unsafe somewhere</i><p>I&#x27;m up to 47,000 lines of Rust with no &quot;unsafe&quot;. The main program starts with<p>#![forbid(unsafe_code)]<p>and that applies to the entire program, although not external crates.
If you&#x27;re not using foreign functions, you don&#x27;t need &quot;unsafe&quot;.<p>Some published crates I use do have &quot;unsafe&quot;, more than they should. This is annoying.</div><br/></div></div><div id="38751242" class="c"><input type="checkbox" id="c-38751242" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38749813">parent</a><span>|</span><a href="#38751302">prev</a><span>|</span><a href="#38749966">next</a><span>|</span><label class="collapse" for="c-38751242">[-]</label><label class="expand" for="c-38751242">[1 more]</label></div><br/><div class="children"><div class="content">Particularly notable: due to the restrictions that Rust chooses to enforce on safe code, `unsafe` is forced in a lot of situations where other languages maintain full runtime safety. I&#x27;m not saying going full-Java is the only answer, but a language that is safer than Rust is certainly possible.</div><br/></div></div><div id="38749966" class="c"><input type="checkbox" id="c-38749966" checked=""/><div class="controls bullet"><span class="by">nullc</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38749813">parent</a><span>|</span><a href="#38751242">prev</a><span>|</span><a href="#38750905">next</a><span>|</span><label class="collapse" for="c-38749966">[-]</label><label class="expand" for="c-38749966">[4 more]</label></div><br/><div class="children"><div class="content">Exactly.  All-hope-lost behavior is possible in rust code unless there is no unsafe anywhere (and no compiler bugs, but I think its fair to ignore those when discussing the language in the abstract).<p>Rust potentially benefits from <i>fewer</i> opportunities to footgun yourself, but rust also comes with other costs (including a more complex syntax, a bad dependency culture, a lot more front-loaded cognitive load around lifetime management, etc.) which might offset those benefits.  Some of those extra complexity costs seem hard (or impossible) to avoid when trying to keep memory safety from having a disproportional runtime cost, so I&#x27;m not necessarily faulting rust.  But some of the sources of defects in rust code may also be entirely avoidable, which is why I think it&#x27;s important to actually study it rather than axiomatically assume its behavior makes programs correct. It doesn&#x27;t, even absent unsafe.</div><br/><div id="38751269" class="c"><input type="checkbox" id="c-38751269" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38749966">parent</a><span>|</span><a href="#38750905">next</a><span>|</span><label class="collapse" for="c-38751269">[-]</label><label class="expand" for="c-38751269">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>compiler bugs... its fair to ignore those when discussing the language in the abstract</i><p>When the language is defined as <i>whatever the compiler does</i>, as it is in the case of Rust, I&#x27;m not so sure.<p>If there were a Rust standard with multiple compliant compilers, I&#x27;d be more convinced, but Rust isn&#x27;t there yet.<p>(And TRF&#x27;s trademark policy may well prevent it from ever getting there.)</div><br/><div id="38751512" class="c"><input type="checkbox" id="c-38751512" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38751269">parent</a><span>|</span><a href="#38750905">next</a><span>|</span><label class="collapse" for="c-38751512">[-]</label><label class="expand" for="c-38751512">[2 more]</label></div><br/><div class="children"><div class="content">Having more implementations doesn’t really help you avoid bugs in the one you’re using.</div><br/></div></div></div></div></div></div></div></div><div id="38750905" class="c"><input type="checkbox" id="c-38750905" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38749716">parent</a><span>|</span><a href="#38749813">prev</a><span>|</span><a href="#38749419">next</a><span>|</span><label class="collapse" for="c-38750905">[-]</label><label class="expand" for="c-38750905">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Issue it had was safe code was invalidating the invariants unsafe code was relying on. Iirc alignment.<p>You do recall correctly. The safe code was producing a pointer with alignment that was off, and the unsafe code dereferenced it without checking. I felt that it was kind of a bad take when several people said that it was UB caused by safe code, because really the issue was that the unsafe code wasn&#x27;t doing its job. The Rust unsafe model is that you can&#x27;t trust safe code when inside unsafe code. It&#x27;s on the unsafe code to uphold invariants which it requires, not the safe code which calls it</div><br/></div></div></div></div><div id="38749419" class="c"><input type="checkbox" id="c-38749419" checked=""/><div class="controls bullet"><span class="by">Ar-Curunir</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38749181">parent</a><span>|</span><a href="#38749716">prev</a><span>|</span><a href="#38734975">next</a><span>|</span><label class="collapse" for="c-38749419">[-]</label><label class="expand" for="c-38749419">[5 more]</label></div><br/><div class="children"><div class="content">&gt; As a result, I don&#x27;t think it can be taken for granted that rust as a whole is an advancement in software integrity-- it may be, but it&#x27;s something that ought to be formally studied. In some cases rust might be replacing memory safety bugs with an even greater number of other defects which, depending on the application, may be worse.<p>I’m sorry, but without any supporting evidence for this claim, this is just FUD. Everything that we’ve seen in case studies of people reimplementing stuff in Rust indicates that memory safety <i>and</i> logic bugs are derived compared to something like C.</div><br/><div id="38749924" class="c"><input type="checkbox" id="c-38749924" checked=""/><div class="controls bullet"><span class="by">nullc</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38749419">parent</a><span>|</span><a href="#38734975">next</a><span>|</span><label class="collapse" for="c-38749924">[-]</label><label class="expand" for="c-38749924">[4 more]</label></div><br/><div class="children"><div class="content">Citation welcome to those case studies, because I&#x27;ve not seen them.  It&#x27;s on the advocates of rust to establish that it makes things better because it absolutely isn&#x27;t unambiguous.<p>We really seem to be in the stone age in terms of what practices lead to higher quality software.  We still have people who chant &quot;goto harmful&quot; against one simply forward jumps to on-error-cleanup code, yet still litter their C++ and java with exceptions which are a less safe and less clear version of the same thing.<p>I&#x27;ve personally found the rate of embarrassing errors in simple rust software is increased over comparable C code, but I freely admit that this experience is far from a formal study and may well be due to the lack of problem-domain competence or general haste in people participating in culty &quot;re-implement in rust&quot; exercises (and where the rust code is far more often someone&#x27;s &quot;learn rust&quot; project).  And at least where security w&#x2F; untrusted input is a concern the nature of the rust bugs is preferable to the bugs in comparable C code, but as mentioned that doesn&#x27;t apply to a lot of software.<p>Another data-point is that the vast majority of firefox crashes I experience now are rust panics, even though the amount of rust code is small compared to C++ code.  It&#x27;s hard to reason from that however, since it can be said that the rust code is more complex and more heavily used than the bulk of the rest.</div><br/><div id="38752129" class="c"><input type="checkbox" id="c-38752129" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38749924">parent</a><span>|</span><a href="#38750672">next</a><span>|</span><label class="collapse" for="c-38752129">[-]</label><label class="expand" for="c-38752129">[1 more]</label></div><br/><div class="children"><div class="content">How are exceptions less safe or less clear?<p>Also, crashing fast <i>is</i> the best way to deal with unforeseen events one can’t recover from. Your anecdotal experience with regards to firefox and rust just shows that they put more assertions into the code (good!), which makes it easier to <i>notice</i> and later fix bugs, as rust makes it mandatory to handle error cases to some degree. This is also a plus for rust.</div><br/></div></div><div id="38750672" class="c"><input type="checkbox" id="c-38750672" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38749924">parent</a><span>|</span><a href="#38752129">prev</a><span>|</span><a href="#38751952">next</a><span>|</span><label class="collapse" for="c-38750672">[-]</label><label class="expand" for="c-38750672">[1 more]</label></div><br/><div class="children"><div class="content">I appreciate your comments in this thread. They are a healthy skeptical technology-neutral take unaffected by novel-paradigm-dogma – in this case about Rust, but it really applies to any software practice. I have nothing against Rust and I believe it has advanced the space of mainstream imperative languages significantly, particular in high performance low-level coding. But you have to always keep an eye on the horizon.<p>&gt; We really seem to be in the stone age in terms of what practices lead to higher quality software.<p>I agree. What I always come back to is simplicity, or reducing total cognitive complexity. The only way I know of that actually consistently works, is modularization (in the most liberal sense of the word), in order for our human brains to work in a reduced problem domain at any given point in time. So whatever languages, protocols, tooling and design patterns help with that, I lean into, although this is (currently) a subjective measure.<p>On some problems, it’s clear Rust is amazing in this respect, taking away certain worries so that you can focus on “what matters”. But this is not a truism in all domains, because the issues that Rust addresses are merely a good list, not an exhaustive one.</div><br/></div></div><div id="38751952" class="c"><input type="checkbox" id="c-38751952" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#38748950">root</a><span>|</span><a href="#38749924">parent</a><span>|</span><a href="#38750672">prev</a><span>|</span><a href="#38734975">next</a><span>|</span><label class="collapse" for="c-38751952">[-]</label><label class="expand" for="c-38751952">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the vast majority of firefox crashes I experience now are rust panics<p>Have you considered that this might be <i>precisely</i> because Rust is <i>catching and stopping</i> something bad with a safe panic? And that the same programmer making the same mistake in C&#x2F;C++ would have resulted in silent data corruption, a security vulnerability, and possibly a portal into the space between dimensions from which optimising compilers will happily allow the Others into our world because -- and I quote -- &quot;that&#x27;s allowed by the spec&quot;?<p>I often see in the news some panic about a sudden rise in some rare disease, but it almost always turns out that the increase is just due to an improvement in detection, not a change in the actual prevalence.<p>I suspect that silent data corruption vs liberal use of asserts that trigger visible panics is in the same category.<p>Someone in this thread was complaining that they think exceptions are &quot;dangerous&quot; and gotos are &quot;safe&quot;. Their thinking is probably coloured by endless stack traces from exceptions in managed languages, comparing that to the &quot;oops I stepped over a mandatory cleanup using goto&quot; in their own C code, which they probably won&#x27;t even notice... because it&#x27;s probably just silently leaking memory. Or file handles. Or threads. But not loudly and in your face!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38734975" class="c"><input type="checkbox" id="c-38734975" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#38748950">prev</a><span>|</span><a href="#38749486">next</a><span>|</span><label class="collapse" for="c-38734975">[-]</label><label class="expand" for="c-38734975">[5 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s underappreciated that Rust&#x27;s `unsafe{}` doesn&#x27;t exist in isolation. Rust has facilities for building safe abstractions on top of it, and has a culture of taking this abstraction layer seriously.<p>Danger of unsafe features and FFI is usually conditional — you can use a pointer only until some point, or only on a single thread, etc. A use of unsafe in Rust doesn&#x27;t become &quot;be careful!&quot; kryptonite spreading around the program. It&#x27;s possible to build walls around it to contain it completely.<p>In Swift + unsafe or Java + JNI I&#x27;ve struggled building equally solid abstractions around FFI. They don&#x27;t have &quot;you can call it only once&quot; or &quot;you can&#x27;t call go() after finish()&quot; as a compile-time check. They don&#x27;t have &quot;you can use it only within this scope&quot; (they may use a closure&#x2F;callback to give access to an unsafe object, but these aren&#x27;t hermetic, so that&#x27;s a convention not a guarantee). Exposing objects to Swift or Java requires the higher level language to be in charge of their lifetime.</div><br/><div id="38752152" class="c"><input type="checkbox" id="c-38752152" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38734975">parent</a><span>|</span><a href="#38749751">next</a><span>|</span><label class="collapse" for="c-38752152">[-]</label><label class="expand" for="c-38752152">[1 more]</label></div><br/><div class="children"><div class="content">Java’s recent Foreign Function &amp; Memory API gives you temporal, spatial and thread-safety.<p>In short, foreign memory is represented as a Segment, with known bounds (it also has a possibility for unbounded “pointers”, for e.g. c strings), associated to a scope. It can only be used within that scope, and will get automatically closed at the end of it.</div><br/></div></div><div id="38749751" class="c"><input type="checkbox" id="c-38749751" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38734975">parent</a><span>|</span><a href="#38752152">prev</a><span>|</span><a href="#38749101">next</a><span>|</span><label class="collapse" for="c-38749751">[-]</label><label class="expand" for="c-38749751">[1 more]</label></div><br/><div class="children"><div class="content">&gt; They don&#x27;t have &quot;you can use it only within this scope&quot; (they may use a closure&#x2F;callback to give access to an unsafe object, but these aren&#x27;t hermetic, so that&#x27;s a convention not a guarantee).<p>You can use the same trick as Haskell&#x27;s STRef to prevent reusing a &quot;leaked&quot; unsafe object, although it&#x27;s cumbersome enough in Java that you may not want to.</div><br/></div></div><div id="38749101" class="c"><input type="checkbox" id="c-38749101" checked=""/><div class="controls bullet"><span class="by">mplewis9z</span><span>|</span><a href="#38734975">parent</a><span>|</span><a href="#38749751">prev</a><span>|</span><a href="#38750740">next</a><span>|</span><label class="collapse" for="c-38749101">[-]</label><label class="expand" for="c-38749101">[1 more]</label></div><br/><div class="children"><div class="content">I haven’t had a chance to fully explore the new features and there are probably still some sharp edges, but the addition of non-copyable types and borrowing&#x2F;consuming bindings in Swift 5.9 should bring it a lot closer to Rust in those respects, especially the hermeticity aspect. If you haven’t experimented recently, might be worth doing - this is also one of the big focuses of the language in the near term, so there should be lots more progress coming too.</div><br/></div></div></div></div><div id="38749486" class="c"><input type="checkbox" id="c-38749486" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38734975">prev</a><span>|</span><a href="#38748712">next</a><span>|</span><label class="collapse" for="c-38749486">[-]</label><label class="expand" for="c-38749486">[22 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I understand what this piece is trying to say about Python memory safety. Conventionally, in software security, Python is considered a memory-safe language. The piece makes the case that Python isn&#x27;t memory safe when you FFI into a C library. But neither is Rust, nor is it when you use `unsafe`. What matters in both case is how little unsafe code you end up writing.<p>Memory safety is a software security concern. You can squint and make it about reliability or resiliency, but the reason we talk about memory safety is (to a first approximation) browser vulnerabilities.<p>The piece goes on to discuss data races. I&#x27;m a little keyed up on software security essays that bring data race safety into the discussion. I have a hard time not reading them as shibboleths for &quot;Rust is the only safe language&quot;, which is manifestly false.<p>The vulnerabilities endemic to memory-safe languages (logic and higher-level vulnerabilities like SQLI, metacharacter quoting, filesystem traversal, and cryptography bugs) are common both to languages like Python and Java and also to Rust --- the only super-common class of vulnerability endemic to languages like Python and Java that Rust avoids is deserialization (you avoid deserialization vulnerabilities by not building hypercapable serialization formats).<p>Data races are a common source of reliability bugs. They&#x27;re a meaningful software engineering concern. In exotic scenarios (userspace-sandboxed attacker-controlled code), they can constitute practical security vulnerabilities. But in the main, data races have not empirically proved out as a source of exploited vulnerabilities. If you have a fixed budget to transition from a C codebase that would allow you to migrate to Python now, or if you saved up, to Rust next year, and all you care about is security, then <i>ceteris paribus</i> you should do the Python thing. The data races aren&#x27;t going to burn you.</div><br/><div id="38749593" class="c"><input type="checkbox" id="c-38749593" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38749486">parent</a><span>|</span><a href="#38751721">next</a><span>|</span><label class="collapse" for="c-38749593">[-]</label><label class="expand" for="c-38749593">[3 more]</label></div><br/><div class="children"><div class="content">Are you grouping kernel exploits in with user space sandboxes? Lots of local roots come from data races which I would not call exotic.<p>And there&#x27;s always <a href="https:&#x2F;&#x2F;portswigger.net&#x2F;research&#x2F;smashing-the-state-machine" rel="nofollow noreferrer">https:&#x2F;&#x2F;portswigger.net&#x2F;research&#x2F;smashing-the-state-machine</a> for web stuff.</div><br/><div id="38749811" class="c"><input type="checkbox" id="c-38749811" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38749486">root</a><span>|</span><a href="#38749593">parent</a><span>|</span><a href="#38751721">next</a><span>|</span><label class="collapse" for="c-38749811">[-]</label><label class="expand" for="c-38749811">[2 more]</label></div><br/><div class="children"><div class="content">Right, these aren&#x27;t data races; they&#x27;re distributed systems races, more akin to tempfile races from the 1990s than to memory corruption.</div><br/><div id="38749927" class="c"><input type="checkbox" id="c-38749927" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38749486">root</a><span>|</span><a href="#38749811">parent</a><span>|</span><a href="#38751721">next</a><span>|</span><label class="collapse" for="c-38749927">[-]</label><label class="expand" for="c-38749927">[1 more]</label></div><br/><div class="children"><div class="content">Okay, fair.</div><br/></div></div></div></div></div></div><div id="38751721" class="c"><input type="checkbox" id="c-38751721" checked=""/><div class="controls bullet"><span class="by">SnowflakeOnIce</span><span>|</span><a href="#38749486">parent</a><span>|</span><a href="#38749593">prev</a><span>|</span><a href="#38752216">next</a><span>|</span><label class="collapse" for="c-38751721">[-]</label><label class="expand" for="c-38751721">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Conventionally, in software security, Python is considered a memory-safe language. The piece makes the case that Python isn&#x27;t memory safe when you FFI into a C library.<p>Interesting and largely unknown trivia: it&#x27;s possible to invoke memory errors in the underlying C interpreter from pure Python code — no libraries and no imports needed!<p>One way of doing this is by creating new `code` objects with crafted bytecode. There is no bytecode verifier in Python to make sure, say, referenced stack variables in the VM are valid...</div><br/><div id="38752001" class="c"><input type="checkbox" id="c-38752001" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#38749486">root</a><span>|</span><a href="#38751721">parent</a><span>|</span><a href="#38752216">next</a><span>|</span><label class="collapse" for="c-38752001">[-]</label><label class="expand" for="c-38752001">[1 more]</label></div><br/><div class="children"><div class="content">Is this because of a bug and might be fixed in the future or is it considered an unavoidable consequence of some design decision and will stay that way for the foreseeable future?<p>From what I understand about Rust, if something similar was possible in safe Rust it would be considered a bug and eventually fixed.</div><br/></div></div></div></div><div id="38752216" class="c"><input type="checkbox" id="c-38752216" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#38749486">parent</a><span>|</span><a href="#38751721">prev</a><span>|</span><a href="#38750890">next</a><span>|</span><label class="collapse" for="c-38752216">[-]</label><label class="expand" for="c-38752216">[1 more]</label></div><br/><div class="children"><div class="content">&gt; logic bugs, SQL injection, quoting, filesystem traversal...<p>Actually Rust does go quite far in reducing the probability of these bugs, even if it doesn&#x27;t have specific features for it. This is through a combination of:<p>* really strong type system (&quot;if it compiles it works&quot;)<p>* Better ergonomics, e.g. using prepared queries is much easier than in C.<p>* Library code being generally very high quality, and easy to obtain.</div><br/></div></div><div id="38750890" class="c"><input type="checkbox" id="c-38750890" checked=""/><div class="controls bullet"><span class="by">schneems</span><span>|</span><a href="#38749486">parent</a><span>|</span><a href="#38752216">prev</a><span>|</span><a href="#38751551">next</a><span>|</span><label class="collapse" for="c-38750890">[-]</label><label class="expand" for="c-38750890">[1 more]</label></div><br/><div class="children"><div class="content">To me it’s a deep philosophical post in the vein of “what even is memory safety anyway?”<p>&gt; The piece makes the case that Python isn&#x27;t memory safe<p>It’s a philosophy argument tactic. Take something everyone considers to be true “Python is memory safe” then push it to logical extremes. The purpose of this isn’t to learn anything about Python, the purpose is to learn about the extremes. In this case about memory safety.<p>I think the overall point is that “memory safe languages don’t truly exist” in the purist sense, since every lang must touch unsafe code at some point. However some languages and tools do a better job is isolating these interactions. We call these tools “memory safe”.</div><br/></div></div><div id="38751551" class="c"><input type="checkbox" id="c-38751551" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38749486">parent</a><span>|</span><a href="#38750890">prev</a><span>|</span><a href="#38751618">next</a><span>|</span><label class="collapse" for="c-38751551">[-]</label><label class="expand" for="c-38751551">[3 more]</label></div><br/><div class="children"><div class="content">Data races are definitely exploited! If we are considering TOCTOU issues then this is a very easy way to get fairly reliable and simple exploits. If we are talking about races of the “two threads access the same value” kind then it’s easy (well, assuming reliability is an exercise for the reader) to turn this into a UAF or OOB access by having one thread work with a stale version of an object that has been modified elsewhere.</div><br/><div id="38752176" class="c"><input type="checkbox" id="c-38752176" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#38749486">root</a><span>|</span><a href="#38751551">parent</a><span>|</span><a href="#38751618">next</a><span>|</span><label class="collapse" for="c-38752176">[-]</label><label class="expand" for="c-38752176">[2 more]</label></div><br/><div class="children"><div class="content">TOCTOU isn&#x27;t a data race. It&#x27;s a race condition, but a &quot;data race&quot; is something much more specific. I think the terminology is confusing to be honest.</div><br/><div id="38752203" class="c"><input type="checkbox" id="c-38752203" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38749486">root</a><span>|</span><a href="#38752176">parent</a><span>|</span><a href="#38751618">next</a><span>|</span><label class="collapse" for="c-38752203">[-]</label><label class="expand" for="c-38752203">[1 more]</label></div><br/><div class="children"><div class="content">Right, my understanding is that a data race is the second thing I mentioned. I was just so surprised to hear this viewpoint that I figured I’d throw it in just in case we were talking about different things.</div><br/></div></div></div></div></div></div><div id="38751618" class="c"><input type="checkbox" id="c-38751618" checked=""/><div class="controls bullet"><span class="by">jules</span><span>|</span><a href="#38749486">parent</a><span>|</span><a href="#38751551">prev</a><span>|</span><a href="#38750100">next</a><span>|</span><label class="collapse" for="c-38751618">[-]</label><label class="expand" for="c-38751618">[1 more]</label></div><br/><div class="children"><div class="content">While data races may not be a top category empirically, they are undefined behavior, which means that (a future version of) the compiler is allowed to make your program do anything at all after a data race happens. We are setting the bar incredibly low for ourselves if we just accept that things like that happen on the regular.</div><br/></div></div><div id="38750100" class="c"><input type="checkbox" id="c-38750100" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#38749486">parent</a><span>|</span><a href="#38751618">prev</a><span>|</span><a href="#38749902">next</a><span>|</span><label class="collapse" for="c-38750100">[-]</label><label class="expand" for="c-38750100">[6 more]</label></div><br/><div class="children"><div class="content">&gt; But in the main, data races have not empirically proved out as a source of exploited vulnerabilities.<p>Say what? Data races, otherwise lumped under the bucket “timing attacks”, are a common source of security exploits. A basic example is racing with code that is creating a file and applying an ACL in two steps. If I can “time” things right from a concurrent thread&#x2F;process, I can get into this file before the ACL prevents me.<p>There are countless scenarios where multi-step operations that need to be treated atomically can be exploited by racing.</div><br/><div id="38750112" class="c"><input type="checkbox" id="c-38750112" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38749486">root</a><span>|</span><a href="#38750100">parent</a><span>|</span><a href="#38750877">next</a><span>|</span><label class="collapse" for="c-38750112">[-]</label><label class="expand" for="c-38750112">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not a vulnerability Rust prevents; it&#x27;s an interaction between multiple competing runtimes. I&#x27;m not denying that race conditions (or timing attacks, another bug class Rust doesn&#x27;t prevent) exist and are exploited! I&#x27;m denying that <i>in-process data races that corrupt memory</i> are a meaningful source of exploitable vulnerabilities.<p>For background, I&#x27;ve spent most of my career doing vulnerability research. I&#x27;m by no means a world expert on memory corruption vulnerabilities (I&#x27;m still impressed that I got my imapd shellcode to work with no uppercase ASCII characters), but you can safely assume I&#x27;m not just completely blowing off huge classes of exploitable vulnerabilities because I&#x27;ve never heard of them. Doesn&#x27;t mean I&#x27;m right! But like, if you&#x27;re going &quot;say what&quot;, you&#x27;re probably misconstruing me.</div><br/><div id="38750191" class="c"><input type="checkbox" id="c-38750191" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#38749486">root</a><span>|</span><a href="#38750112">parent</a><span>|</span><a href="#38750877">next</a><span>|</span><label class="collapse" for="c-38750191">[-]</label><label class="expand" for="c-38750191">[3 more]</label></div><br/><div class="children"><div class="content">OK, but I think you are moving the goal posts. You referred to “data races” and “security exploits” and suggested the two were not related. Memory corruption is only one (small) class of security exploits. Data races cause just as many in process, in memory, exploits as multi-step file operations (we are talking breaking application security models). Perhaps Rust can prevent most of these! (I don’t know rust).</div><br/><div id="38750207" class="c"><input type="checkbox" id="c-38750207" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38749486">root</a><span>|</span><a href="#38750191">parent</a><span>|</span><a href="#38750877">next</a><span>|</span><label class="collapse" for="c-38750207">[-]</label><label class="expand" for="c-38750207">[2 more]</label></div><br/><div class="children"><div class="content">What are they? Show me the vulnerabilities you&#x27;re talking about. I don&#x27;t think I&#x27;m moving the goalposts here. The major distinction between Rust and (say) Java is Rust&#x27;s type system formalisms to prevent in-process data race memory corruption. Those are real features, but they don&#x27;t mitigate a major class of vulnerabilities.</div><br/><div id="38750286" class="c"><input type="checkbox" id="c-38750286" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#38749486">root</a><span>|</span><a href="#38750207">parent</a><span>|</span><a href="#38750877">next</a><span>|</span><label class="collapse" for="c-38750286">[-]</label><label class="expand" for="c-38750286">[1 more]</label></div><br/><div class="children"><div class="content">Any multi-step code, e.g. AddUser(); SetPermissions();<p>But, fair enough, this is not what you were talking about, and I reacted to something you weren’t intending to convey.</div><br/></div></div></div></div></div></div></div></div><div id="38750877" class="c"><input type="checkbox" id="c-38750877" checked=""/><div class="controls bullet"><span class="by">yawaramin</span><span>|</span><a href="#38749486">root</a><span>|</span><a href="#38750100">parent</a><span>|</span><a href="#38750112">prev</a><span>|</span><a href="#38749902">next</a><span>|</span><label class="collapse" for="c-38750877">[-]</label><label class="expand" for="c-38750877">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t it rather trivial to prevent this by creating a file with a random filename, applying the ACL, then renaming the file to the correct name?</div><br/></div></div></div></div><div id="38749902" class="c"><input type="checkbox" id="c-38749902" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38749486">parent</a><span>|</span><a href="#38750100">prev</a><span>|</span><a href="#38748712">next</a><span>|</span><label class="collapse" for="c-38749902">[-]</label><label class="expand" for="c-38749902">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I have a hard time not reading them as shibboleths for &quot;Rust is the only safe language&quot;, which is manifestly false.<p>Given that quite simple classes of vulnerabilities are endemic to all other major languages, no, it&#x27;s not &quot;manifestly false&quot;. The state of software safety really is bad enough that &quot;all major languages that aren&#x27;t Rust are unsafe&quot; is plausible.<p>&gt; The vulnerabilities endemic to memory-safe languages (logic and higher-level vulnerabilities like SQLI, metacharacter quoting, filesystem traversal, and cryptography bugs) are common both to languages like Python and Java and also to Rust --- the only super-common class of vulnerability endemic to languages like Python and Java that Rust avoids is deserialization (you avoid deserialization vulnerabilities by not building hypercapable serialization formats).<p>SQLI at least should be a lot less common in ML-family languages like Rust where manipulating structured data is relatively easy (or at least, the ease advantage of string manipulation over structured data is smaller). Carefully distinguishing between character strings, file paths, and byte sequences, as Rust does, should also eliminate at least some common kinds of vulnerabilities.<p>&gt; The data races aren&#x27;t going to burn you.<p>Eh maybe. All we can really say so far is that they haven&#x27;t reached low-hanging fruit level yet. There have been plenty of similarly unsafe things that weren&#x27;t thought to be exploitable that have turned out to be major sources of vulnerabilities as the bar gets raised and more effort gets put in, e.g. there was a time when the conventional wisdom was that double-free() was only a reliability&#x2F;resiliency concern and not a security issue.</div><br/><div id="38750023" class="c"><input type="checkbox" id="c-38750023" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38749486">root</a><span>|</span><a href="#38749902">parent</a><span>|</span><a href="#38748712">next</a><span>|</span><label class="collapse" for="c-38750023">[-]</label><label class="expand" for="c-38750023">[3 more]</label></div><br/><div class="children"><div class="content"><i>Given that quite simple classes of vulnerabilities are endemic to all other major languages, no, it&#x27;s not &quot;manifestly false&quot;. The state of software safety really is bad enough that &quot;all major languages that aren&#x27;t Rust are unsafe&quot; is plausible.</i><p>We&#x27;re really very good at documenting vulnerabilities; the mere documentation of vulnerabilities is itself a 9-figure industry. So: cough up the examples. I can&#x27;t think of <i>any</i>, so that&#x27;s where I&#x27;m setting the bar for you.<p>A reminder that memory corruption bugs in FFI-bound libraries doesn&#x27;t count --- Rust has plenty of those --- and neither do deserialization vulnerabilities, which were discussed upthread. It also doesn&#x27;t matter if a condition makes it unsafe to run attacker-controlled code in a shared runtime; nobody does that (with native languages; they try, with Javascript, and it has been a disaster). You&#x27;re looking for vulnerabilities that are widely exploited and <i>intrinsic to a memory-safe language</i> that isn&#x27;t Rust. Not to a library, but to the language.</div><br/><div id="38751263" class="c"><input type="checkbox" id="c-38751263" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38749486">root</a><span>|</span><a href="#38750023">parent</a><span>|</span><a href="#38748712">next</a><span>|</span><label class="collapse" for="c-38751263">[-]</label><label class="expand" for="c-38751263">[2 more]</label></div><br/><div class="children"><div class="content">&gt; We&#x27;re really very good at documenting vulnerabilities; the mere documentation of vulnerabilities is itself a 9-figure industry. So: cough up the examples. I can&#x27;t think of any, so that&#x27;s where I&#x27;m setting the bar for you.<p>Your own post listed a bunch of vulnerability classes that happen in those languages (&quot;logic and higher-level vulnerabilities like SQLI, metacharacter quoting, filesystem traversal, and cryptography bugs&quot;).</div><br/><div id="38751335" class="c"><input type="checkbox" id="c-38751335" checked=""/><div class="controls bullet"><span class="by">FreakLegion</span><span>|</span><a href="#38749486">root</a><span>|</span><a href="#38751263">parent</a><span>|</span><a href="#38748712">next</a><span>|</span><label class="collapse" for="c-38751335">[-]</label><label class="expand" for="c-38751335">[1 more]</label></div><br/><div class="children"><div class="content">He says explicitly that these are endemic to memory-safe languages, <i>including Rust</i>. They aren&#x27;t something that Rust handles better than Python or Java.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38748712" class="c"><input type="checkbox" id="c-38748712" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#38749486">prev</a><span>|</span><a href="#38742594">next</a><span>|</span><label class="collapse" for="c-38748712">[-]</label><label class="expand" for="c-38748712">[1 more]</label></div><br/><div class="children"><div class="content">I agree with the sentiment. Consider a hypothetical variant of Python that requires using eval() (with the same behavior as in Python, so full Python expression support) for converting from strings to integers or floats. Or that implicitly calls eval() on list subscripts, to turn strings into integers. None of these changes impact memory safety, but it still makes it much more likely that common code has security vulnerabilities. (There is actually a widely used programming language with the eval-on-subscript feature …)<p>&gt; While a Go program may exhibit what a Rust or C++ program would consider undefined behavior, and it does also consider it an error, the consequences are very different. You don’t get time travel. You get 998 instead of 1,000.<p>This isn&#x27;t correct. Data races on multi-word objects of built-in type, such as slices and interfaces, actually have undefined behavior, in the sense that array bounds checking and type checking may break down.<p>Russ Cox&#x27;s old example still works if you disable optimizations: <a href="https:&#x2F;&#x2F;research.swtch.com&#x2F;gorace" rel="nofollow noreferrer">https:&#x2F;&#x2F;research.swtch.com&#x2F;gorace</a><p>It looks like some form of dead store elimination happens to eliminate the data race with current compilers. For now, it&#x27;s possible to bring it back by adding a pointless atomic operation, like this:<p><pre><code>    go func(){
      for !done {
        k = i
        atomic.AddUint32(&amp;global, 1)
        k = j
      }
    }()</code></pre></div><br/></div></div><div id="38742594" class="c"><input type="checkbox" id="c-38742594" checked=""/><div class="controls bullet"><span class="by">mannuch</span><span>|</span><a href="#38748712">prev</a><span>|</span><a href="#38752156">next</a><span>|</span><label class="collapse" for="c-38742594">[-]</label><label class="expand" for="c-38742594">[4 more]</label></div><br/><div class="children"><div class="content">I wonder what the author thinks about Swift’s new C++ interop story? Since the Swift compiler includes Clang, and can thus compile both your C++ and Swift into LLVM IR, without the need for an FFI later between the two, couldn’t this be the “Typescript for C++” that the author points out a space for? The Swift folks are very much thinking about Swift as a C++ successor that can be incrementally migrated to so I’m a bit surprised the author didn’t discuss it further — especially given Swift’s spiritual similarities to Rust.<p>There’s a couple great talks on this by folks on the Swift team.<p>John McCall at CppNow
<a href="https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=lgivCGdmFrw" rel="nofollow noreferrer">https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=lgivCGdmFrw</a><p>Konrad Malawski at StrangeLoop 2023
<a href="https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=ZQc9-seU-5k" rel="nofollow noreferrer">https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=ZQc9-seU-5k</a></div><br/><div id="38745782" class="c"><input type="checkbox" id="c-38745782" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#38742594">parent</a><span>|</span><a href="#38750501">next</a><span>|</span><label class="collapse" for="c-38745782">[-]</label><label class="expand" for="c-38745782">[2 more]</label></div><br/><div class="children"><div class="content">I do not know a ton about it. Thanks for the pointers.<p>I kept up with Swift more in the old days, but it doesn&#x27;t seem to have gained a ton of relevance outside of Apple platforms, which I don&#x27;t develop for. Doesn&#x27;t mean that I think that it&#x27;s bad, just that that&#x27;s why I haven&#x27;t spent a lot of time with it yet.</div><br/><div id="38750695" class="c"><input type="checkbox" id="c-38750695" checked=""/><div class="controls bullet"><span class="by">mannuch</span><span>|</span><a href="#38742594">root</a><span>|</span><a href="#38745782">parent</a><span>|</span><a href="#38750501">next</a><span>|</span><label class="collapse" for="c-38750695">[-]</label><label class="expand" for="c-38750695">[1 more]</label></div><br/><div class="children"><div class="content">For sure! Yeah I think a lot of people don’t realize that there’s actually a ton of really interesting work going on in Swift that is very relevant to the current conversation around languages these days (i.e. memory safety, data race safety, performance, development experience, etc.)<p>The cross-platform story is getting quite good with Swift, but I think a lot of people just aren’t aware of it. Linux support is good and Windows is getting better and better.<p>For example, The Browser Company is betting big on using Swift for its Windows app and talks about why they are doing it
<a href="https:&#x2F;&#x2F;open.substack.com&#x2F;pub&#x2F;speakinginswift&#x2F;p&#x2F;interoperability-swifts-super-power?utm_campaign=post&amp;utm_medium=web" rel="nofollow noreferrer">https:&#x2F;&#x2F;open.substack.com&#x2F;pub&#x2F;speakinginswift&#x2F;p&#x2F;interoperabi...</a></div><br/></div></div></div></div><div id="38750501" class="c"><input type="checkbox" id="c-38750501" checked=""/><div class="controls bullet"><span class="by">humanrebar</span><span>|</span><a href="#38742594">parent</a><span>|</span><a href="#38745782">prev</a><span>|</span><a href="#38752156">next</a><span>|</span><label class="collapse" for="c-38750501">[-]</label><label class="expand" for="c-38750501">[1 more]</label></div><br/><div class="children"><div class="content">Swift is an interesting option, though that interop requires dropping support for non-clang toolchains, and I don&#x27;t see that happening any time soon. I mean, it makes sense for code that exclusively targets Apple platforms, and maybe that&#x27;s all that Apple and the Swift team care about?</div><br/></div></div></div></div><div id="38752156" class="c"><input type="checkbox" id="c-38752156" checked=""/><div class="controls bullet"><span class="by">tempodox</span><span>|</span><a href="#38742594">prev</a><span>|</span><a href="#38752096">next</a><span>|</span><label class="collapse" for="c-38752156">[-]</label><label class="expand" for="c-38752156">[1 more]</label></div><br/><div class="children"><div class="content">&gt; threads.into_iter().for_each(|t| t.join().unwrap());<p>What a great title for the almost-last section, it made me laugh.  When I saw the title of the final section, I fell from my chair:<p>&gt; int atexit(void (*func)(void))</div><br/></div></div><div id="38752096" class="c"><input type="checkbox" id="c-38752096" checked=""/><div class="controls bullet"><span class="by">LispSporks22</span><span>|</span><a href="#38752156">prev</a><span>|</span><a href="#38733245">next</a><span>|</span><label class="collapse" for="c-38752096">[-]</label><label class="expand" for="c-38752096">[1 more]</label></div><br/><div class="children"><div class="content">&gt; coming legislation around MSLs for government procuremen<p>What’s he talking about here?</div><br/></div></div><div id="38733245" class="c"><input type="checkbox" id="c-38733245" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#38752096">prev</a><span>|</span><a href="#38734804">next</a><span>|</span><label class="collapse" for="c-38733245">[-]</label><label class="expand" for="c-38733245">[2 more]</label></div><br/><div class="children"><div class="content">Regarding <i>&quot;Now, I am not a politican, and these bills are huge, so I wasn’t able to figure out how these bills do this specifically [..]&quot;</i>, I think the relevant reference is on page 864 of [1]:<p><i>&quot;SEC. 1613. POLICY AND GUIDANCE ON MEMORY-SAFE SOFT- WARE PROGRAMMING.
(a) POLICY AND GUIDANCE.—Not later than 270 days after the date of the enactment of this Act, the Secretary of Defense shall develop a Department of Defense wide policy and guidance in the form of a directive memorandum to implement the recommendations of the National Security Agency contained in the Software Memory Safety Cybersecurity Information Sheet published by the Agency in November, 2022, regarding memory-safe software programming languages and testing to identify memory-related vulnerabilities in software developed, acquired by, and used by the Department of Defense.&quot;</i><p>The mentioned <i>&quot;Software Memory Safety Cybersecurity Information Sheet&quot;</i> is probably [2] which explicitly lists <i>&quot;C#, Go, Java®, Ruby™, Rust®, and Swift&quot;</i> as examples for memory safe languages.<p>I&#x27;m still looking for the equivalent EU document and would be grateful for any hints.<p>EDIT: I could not find any reference to memory safety in any of the EU documents but interestingly the <i>&quot;Impact Assessment Report&quot;</i> [3] mentions Rust and Go specifically.<p>[1] <a href="https:&#x2F;&#x2F;www.armed-services.senate.gov&#x2F;imo&#x2F;media&#x2F;doc&#x2F;fy24_ndaa_bill_text.pdf#page=864" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.armed-services.senate.gov&#x2F;imo&#x2F;media&#x2F;doc&#x2F;fy24_nda...</a><p>[2] <a href="https:&#x2F;&#x2F;media.defense.gov&#x2F;2022&#x2F;Nov&#x2F;10&#x2F;2003112742&#x2F;-1&#x2F;-1&#x2F;0&#x2F;CSI_SOFTWARE_MEMORY_SAFETY.PDF" rel="nofollow noreferrer">https:&#x2F;&#x2F;media.defense.gov&#x2F;2022&#x2F;Nov&#x2F;10&#x2F;2003112742&#x2F;-1&#x2F;-1&#x2F;0&#x2F;CSI...</a><p>[3] <a href="https:&#x2F;&#x2F;ec.europa.eu&#x2F;newsroom&#x2F;dae&#x2F;redirection&#x2F;document&#x2F;89545" rel="nofollow noreferrer">https:&#x2F;&#x2F;ec.europa.eu&#x2F;newsroom&#x2F;dae&#x2F;redirection&#x2F;document&#x2F;89545</a></div><br/><div id="38735747" class="c"><input type="checkbox" id="c-38735747" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#38733245">parent</a><span>|</span><a href="#38734804">next</a><span>|</span><label class="collapse" for="c-38735747">[-]</label><label class="expand" for="c-38735747">[1 more]</label></div><br/><div class="children"><div class="content">Thank you! I really appreciate it.</div><br/></div></div></div></div><div id="38734804" class="c"><input type="checkbox" id="c-38734804" checked=""/><div class="controls bullet"><span class="by">zelon88</span><span>|</span><a href="#38733245">prev</a><span>|</span><a href="#38749077">next</a><span>|</span><label class="collapse" for="c-38734804">[-]</label><label class="expand" for="c-38734804">[10 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the government&#x27;s goal in improving memory safety is because of Rust or any other particular technology.<p>The government buys technology from wherever, and until recently they never really cared where they got it from. If they need a USB Emulator, they buy the same Chinese Gotek from Ebay that you or I buy, and they get the same &quot;Driver CD&quot; full of buggy, broken English software, written by one person for $27 over the course of about 7 hours. Same thing with DVR systems, access controls, network appliances, access points. I&#x27;ve worked on government projects that were using 20 year old, broken, encryption libraries on active web servers. And when brought to their attention the people who use it don&#x27;t care, and the people who are capable of doing something about it will never find out because it&#x27;s too much work to replace and nobody wants to take that Zoom call.<p>I think the author is getting a little over-excited about Rust. Granted, they are a Rust developer. I&#x27;d love it if we could build everything in my favorite language. But the government doesn&#x27;t want to replace everything with Rust. The government wants results. Period. It is the DOD, NSA, and CISA who need to become experts on how to realize those results. And they will probably release guidance that says &quot;if you can&#x27;t program securely in a memory unsafe language, don&#x27;t use a memory unsafe language&quot;. The thing I think the author is missing is that nobody is going to mistaken &quot;Made with RUST!&quot; for &quot;Impossible to cause undefined behavior!&quot;<p>You can be a terrible programmer and still create undefined behavior, insecure code, data leaks, or any number of other problems in a memory safe language.<p>What the government is going to do is implement strict code import controls, similar to the export controls we already have. Purchasing departments will have to get software purchases signed off multiple times by qualified parties, and department leaders will have to prove that the technology they procure is adequately safe. In some situations I anticipate that means re-writing a bunch of code in Rust, and in other situations I&#x27;m sure that means hardening existing C. The majority of the government&#x27;s security holes that need to be patched are coming from low quality unvetted imported technology, low quality self-written code, and code that should have been replaced 20 years ago. While it&#x27;s exciting to think that this could mean a renaissance for the author&#x27;s technology of choice, I just don&#x27;t see it working out that way. If the government could write memory safe code, it would have. Rust isn&#x27;t safe ENOUGH to save the government from itself alone.</div><br/><div id="38736766" class="c"><input type="checkbox" id="c-38736766" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#38734804">parent</a><span>|</span><a href="#38748384">next</a><span>|</span><label class="collapse" for="c-38736766">[-]</label><label class="expand" for="c-38736766">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But the government doesn&#x27;t want to replace everything with Rust.<p>To be clear, I don&#x27;t think that they do. To be honest, I am mostly confused by your post, not because I disagree, but because I am unsure how you came to the conclusion that I believe these things.</div><br/><div id="38748805" class="c"><input type="checkbox" id="c-38748805" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#38734804">root</a><span>|</span><a href="#38736766">parent</a><span>|</span><a href="#38748384">next</a><span>|</span><label class="collapse" for="c-38748805">[-]</label><label class="expand" for="c-38748805">[1 more]</label></div><br/><div class="children"><div class="content">Funny, because I came out with the almost opposite impression: that perhaps the legislators will require something stronger than even Rust to consider something &quot;safe&quot; because Rust still allows easy access to things like `unsafe` and FFI like most other languages - and true safety may require more than that.<p>I think our biases, together with the lack of a firm conclusion in this post, leaves the door open to vastly different interpretations.</div><br/></div></div></div></div><div id="38748384" class="c"><input type="checkbox" id="c-38748384" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#38734804">parent</a><span>|</span><a href="#38736766">prev</a><span>|</span><a href="#38735043">next</a><span>|</span><label class="collapse" for="c-38748384">[-]</label><label class="expand" for="c-38748384">[2 more]</label></div><br/><div class="children"><div class="content">Just like in every other kind of engineering, for software capability pulls the requirements.<p>The only reason everybody is complaining about lack of memory safety now is because there are alternatives for every use case. Before Rust existed, it was seen as an inevitable issue that one must work with, not as a problem to solve.</div><br/><div id="38751368" class="c"><input type="checkbox" id="c-38751368" checked=""/><div class="controls bullet"><span class="by">simion314</span><span>|</span><a href="#38734804">root</a><span>|</span><a href="#38748384">parent</a><span>|</span><a href="#38735043">next</a><span>|</span><label class="collapse" for="c-38751368">[-]</label><label class="expand" for="c-38751368">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Before Rust existed, it was seen as an inevitable issue that one must work with, not as a problem to solve.<p>There were many memory safe languages before Rust, Java and C# evangelized this a lot, though at that time the accent was on memory leaks not on safety. Rust offers an alternative for low level programming and might be faster in soem scenarios then managed languages.</div><br/></div></div></div></div><div id="38735043" class="c"><input type="checkbox" id="c-38735043" checked=""/><div class="controls bullet"><span class="by">alilleybrinker</span><span>|</span><a href="#38734804">parent</a><span>|</span><a href="#38748384">prev</a><span>|</span><a href="#38748730">next</a><span>|</span><label class="collapse" for="c-38735043">[-]</label><label class="expand" for="c-38735043">[4 more]</label></div><br/><div class="children"><div class="content">Just a small clarification here. The author isn’t just a fan of Rust. Steve was a member of the Rust Core Team for years and was co-author of the book “The Rust Programming Language,” which is the main recommended introductory text for the language.</div><br/><div id="38735932" class="c"><input type="checkbox" id="c-38735932" checked=""/><div class="controls bullet"><span class="by">zelon88</span><span>|</span><a href="#38734804">root</a><span>|</span><a href="#38735043">parent</a><span>|</span><a href="#38748730">next</a><span>|</span><label class="collapse" for="c-38735932">[-]</label><label class="expand" for="c-38735932">[3 more]</label></div><br/><div class="children"><div class="content">I saw the authors credentials and I do respect them a lot. But to be fair, I&#x27;m sure the person who wrote the Go manual could have written the same blog post with the same outlook for the future only with Go in place of Rust. I&#x27;m trying to broaden the scope of conversation to a more holistic one, rather than just &quot;this is our chance to take over the world!&quot;<p>Like my Gotek USB emulator reference. The device costs $50, and it&#x27;s pretty much the ONLY option you have for emulating a floppy drive with a USB stick in a bunch of obsolete hardware. The software that it comes with was written by a Chinese high school student in C++ during a study break and it is about as insecure and sketchy as you would expect it to be.<p>If you&#x27;re the government looking to buy this, your choices are;<p>1. Buy this sketchy retroft device that is insecure and may be backdoored for a cost of $60.<p>2. Replace whatever needs the retrofit for a cost of $2m.<p>3. Write your own drivers for $100k.<p>Currently they just use the $60 device. The upcoming policy changes will take that option off the table for a lot of agencies, forcing them to make wiser purchasing decisions. It doesn&#x27;t automatically mean Rust wins the day, or that rust deserves to win the day. It means intelligent conversations must be had and difficult decisions have to be made that used to get avoided.</div><br/><div id="38752211" class="c"><input type="checkbox" id="c-38752211" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38734804">root</a><span>|</span><a href="#38735932">parent</a><span>|</span><a href="#38744679">next</a><span>|</span><label class="collapse" for="c-38752211">[-]</label><label class="expand" for="c-38752211">[1 more]</label></div><br/><div class="children"><div class="content">Go has absolutely zero interesting properties here. It has a shitty, inexpressive type system, dangerous concurrency, brain-dead error handling. It is a managed language, which provided memory-safety for many many decades now.</div><br/></div></div><div id="38744679" class="c"><input type="checkbox" id="c-38744679" checked=""/><div class="controls bullet"><span class="by">alphager</span><span>|</span><a href="#38734804">root</a><span>|</span><a href="#38735932">parent</a><span>|</span><a href="#38752211">prev</a><span>|</span><a href="#38748730">next</a><span>|</span><label class="collapse" for="c-38744679">[-]</label><label class="expand" for="c-38744679">[1 more]</label></div><br/><div class="children"><div class="content">Nobody is claiming that rust wins the day. Memory-safe languages, of which rust is one of them, will get a boost. That&#x27;s it.</div><br/></div></div></div></div></div></div><div id="38748730" class="c"><input type="checkbox" id="c-38748730" checked=""/><div class="controls bullet"><span class="by">lowbloodsugar</span><span>|</span><a href="#38734804">parent</a><span>|</span><a href="#38735043">prev</a><span>|</span><a href="#38749077">next</a><span>|</span><label class="collapse" for="c-38748730">[-]</label><label class="expand" for="c-38748730">[1 more]</label></div><br/><div class="children"><div class="content">lol. The government doesn’t want results, unless the result is siphoning as much public money into private pockets as possible.</div><br/></div></div></div></div><div id="38749077" class="c"><input type="checkbox" id="c-38749077" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#38734804">prev</a><span>|</span><a href="#38749017">next</a><span>|</span><label class="collapse" for="c-38749077">[-]</label><label class="expand" for="c-38749077">[6 more]</label></div><br/><div class="children"><div class="content">Our programs are growing so big by having so many (indirect) dependencies that we need a way to sandbox the libraries that we include from our main programs. This is the type of safety that I&#x27;m looking for, really.</div><br/><div id="38751561" class="c"><input type="checkbox" id="c-38751561" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38749077">parent</a><span>|</span><a href="#38750417">next</a><span>|</span><label class="collapse" for="c-38751561">[-]</label><label class="expand" for="c-38751561">[1 more]</label></div><br/><div class="children"><div class="content">Address spaces are typically difficult to mix things in, unfortunately. If you sandbox harder then it’s not actually very useful to have them in your process anymore.</div><br/></div></div><div id="38750417" class="c"><input type="checkbox" id="c-38750417" checked=""/><div class="controls bullet"><span class="by">mlinksva</span><span>|</span><a href="#38749077">parent</a><span>|</span><a href="#38751561">prev</a><span>|</span><a href="#38749219">next</a><span>|</span><label class="collapse" for="c-38750417">[-]</label><label class="expand" for="c-38750417">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been idly wondering, what is the relationship between memory unsafety, or more generally, undefined behavior, and ambient authority? For security purposes, is the former a special, unintended (for the most part, it&#x27;s a bug) form of the latter?</div><br/></div></div><div id="38749219" class="c"><input type="checkbox" id="c-38749219" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38749077">parent</a><span>|</span><a href="#38750417">prev</a><span>|</span><a href="#38749017">next</a><span>|</span><label class="collapse" for="c-38749219">[-]</label><label class="expand" for="c-38749219">[3 more]</label></div><br/><div class="children"><div class="content">Java can use SecurityManager to do this.</div><br/><div id="38750136" class="c"><input type="checkbox" id="c-38750136" checked=""/><div class="controls bullet"><span class="by">prosody</span><span>|</span><a href="#38749077">root</a><span>|</span><a href="#38749219">parent</a><span>|</span><a href="#38749017">next</a><span>|</span><label class="collapse" for="c-38750136">[-]</label><label class="expand" for="c-38750136">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s deprecated for removal.[0]<p>[0] <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;411" rel="nofollow noreferrer">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;411</a></div><br/><div id="38752228" class="c"><input type="checkbox" id="c-38752228" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38749077">root</a><span>|</span><a href="#38750136">parent</a><span>|</span><a href="#38749017">next</a><span>|</span><label class="collapse" for="c-38752228">[-]</label><label class="expand" for="c-38752228">[1 more]</label></div><br/><div class="children"><div class="content">GraalVM has Isolates that can do this on a much more fine-grained level and with multiple languages (it can also run LLVM-languages now).</div><br/></div></div></div></div></div></div></div></div><div id="38749017" class="c"><input type="checkbox" id="c-38749017" checked=""/><div class="controls bullet"><span class="by">angiosperm</span><span>|</span><a href="#38749077">prev</a><span>|</span><a href="#38748926">next</a><span>|</span><label class="collapse" for="c-38749017">[-]</label><label class="expand" for="c-38749017">[6 more]</label></div><br/><div class="children"><div class="content">Nobody has been able explain to me what would be lost if we defined data races to yield one of the values that had been written to the memory in the past, instead of being undefined. It is not as if any optimizer can see that you are racing and delete the code path that has it.</div><br/><div id="38749161" class="c"><input type="checkbox" id="c-38749161" checked=""/><div class="controls bullet"><span class="by">quelsolaar</span><span>|</span><a href="#38749017">parent</a><span>|</span><a href="#38749051">next</a><span>|</span><label class="collapse" for="c-38749161">[-]</label><label class="expand" for="c-38749161">[1 more]</label></div><br/><div class="children"><div class="content">Let me _try_ to explain it.<p>One reason is that non-atomic writes can be torn. So if you have a value like 0x00000000 and over write it with 0xFFFFFFFF, some hardware may do it as two separate writes. This means that another thread can read the data when its half way written and get 0xFFFF0000. I&#x27;m using a 32bit value here to illustrate In reality modern hardware is unlikely to tear it, but in other cases it may.<p>Another issue is that what you are writing may depend on something else. Consider this code:<p>x = 42;
p = &amp;x;<p>these two operations are independent, and a compiler, CPU or memory system could chose to execute them in any order. This means that even if the second operation is &quot;atomic&quot; and another thread can only read the before or after value of p, another thread could read p and access it, before 42 is written to x. This is why the p = &amp;x; needs a &quot;release&quot; barrier that guarantees that everything before it is completed before the change to p happens.<p>Atomics are complex due to the way modern computers optimize and this is just a very surface level explanation. Still, I hope this helps.</div><br/></div></div><div id="38749051" class="c"><input type="checkbox" id="c-38749051" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#38749017">parent</a><span>|</span><a href="#38749161">prev</a><span>|</span><a href="#38749441">next</a><span>|</span><label class="collapse" for="c-38749051">[-]</label><label class="expand" for="c-38749051">[1 more]</label></div><br/><div class="children"><div class="content">&quot;One of the values written to memory&quot; isn&#x27;t really a thing when memory accesses can tear (e.g. because the values are 16 bytes large and are accessed using 8 byte memory ops). So it&#x27;s not even necessarily about what would be lost, it&#x27;s about what can be reasonably defined in the first place.<p>If you restrict yourself to relaxed atomic loads and stores -- i.e., memory accesses that are atomic in the sense that they cannot tear, but don&#x27;t have much in the way of ordering guarantees -- then you do get &quot;one of the values that had been written to the memory in the past&quot;.<p>Aside from memory tearing, one other issue is that you generally want to be able to rematerialize loads (i.e., in the face of register pressure, you may want to turn one load of a value into multiple loads instead of loading it once, then spilling to the stack and reloading from the stack). But when the compiler rematerializes a load, then you don&#x27;t get &quot;one of the values written to memory&quot;. From the perspective of the original program it looks like you get some weird superposition of values.</div><br/></div></div><div id="38749441" class="c"><input type="checkbox" id="c-38749441" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#38749017">parent</a><span>|</span><a href="#38749051">prev</a><span>|</span><a href="#38749376">next</a><span>|</span><label class="collapse" for="c-38749441">[-]</label><label class="expand" for="c-38749441">[1 more]</label></div><br/><div class="children"><div class="content">The optimizer assumes that a non-atomic non-volatile value written to memory stays the same, until some code that could modify it is executed. This allows a lot of obvious optimizations, like hoisting needlessly repeated computation out of loops, removal of redundant loads, and optimizations of common subexpressions and arithmetic.<p>If a value in memory could suddenly revert to something else, then<p><pre><code>   if obj.x == 1 {
       print(obj.x)
   }
</code></pre>
could print &quot;2&quot;, and such paradoxes can lead to unsafety:<p><pre><code>   if obj.x &lt; array.len {
       array[obj.x]
   }
</code></pre>
Defining that values in memory can&#x27;t be trusted would mean giving up on a lot of optimizations, and require implementations to emit a lot of mostly-useless copying of values to protect them from being unexpectedly modified.</div><br/></div></div><div id="38749376" class="c"><input type="checkbox" id="c-38749376" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#38749017">parent</a><span>|</span><a href="#38749441">prev</a><span>|</span><a href="#38749097">next</a><span>|</span><label class="collapse" for="c-38749376">[-]</label><label class="expand" for="c-38749376">[1 more]</label></div><br/><div class="children"><div class="content">A lot of extra CPU time wasted while caches synchronize even though the other CPU isn&#x27;t running code that uses it. Most of the time the typical racey code works without locks, making everything not race means tode without a potential race still gets locks.<p>Above I&#x27;m treating atomics and mutexs above.</div><br/></div></div><div id="38749097" class="c"><input type="checkbox" id="c-38749097" checked=""/><div class="controls bullet"><span class="by">Gehinnn</span><span>|</span><a href="#38749017">parent</a><span>|</span><a href="#38749376">prev</a><span>|</span><a href="#38748926">next</a><span>|</span><label class="collapse" for="c-38749097">[-]</label><label class="expand" for="c-38749097">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure that you have either an undecidable problem or a non deterministic piece of code that sometimes computes some value, other times a different value, depending on how the threads are scheduled.
Neither is good.</div><br/></div></div></div></div><div id="38748926" class="c"><input type="checkbox" id="c-38748926" checked=""/><div class="controls bullet"><span class="by">lambdaone</span><span>|</span><a href="#38749017">prev</a><span>|</span><a href="#38732493">next</a><span>|</span><label class="collapse" for="c-38748926">[-]</label><label class="expand" for="c-38748926">[3 more]</label></div><br/><div class="children"><div class="content">Enforcing memory safety is good thing, even if it&#x27;s not perfect; it&#x27;s the first stage in the long-needed move from throw-it-in-a-bucket-and-hope-it-works &quot;software engineering&quot; toward proper formal-methods-driven actual software engineering.<p>I feel complaining about it as insufficient is not the ideal way to push things forward. Instead, let&#x27;s treat the progress on memory safety policy as a first victory in that process, and build on it.</div><br/><div id="38749107" class="c"><input type="checkbox" id="c-38749107" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#38748926">parent</a><span>|</span><a href="#38732493">next</a><span>|</span><label class="collapse" for="c-38749107">[-]</label><label class="expand" for="c-38749107">[2 more]</label></div><br/><div class="children"><div class="content">To be clear, I absolutely do as well. I&#x27;m wondering about other possibilities, but I am ecstatic that this all is going as well as it is.</div><br/><div id="38749257" class="c"><input type="checkbox" id="c-38749257" checked=""/><div class="controls bullet"><span class="by">lambdaone</span><span>|</span><a href="#38748926">root</a><span>|</span><a href="#38749107">parent</a><span>|</span><a href="#38732493">next</a><span>|</span><label class="collapse" for="c-38749257">[-]</label><label class="expand" for="c-38749257">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for all your work on Rust! If I had the option to choose just one small thing to go after next, it would be well-defined behavior and error handling for integer overflow and underflow in languages without bignums.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>