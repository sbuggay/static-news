<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723626078522" as="style"/><link rel="stylesheet" href="styles.css?v=1723626078522"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://ianthehenry.com/posts/quote-unquote-macros/">Quote-unquote &quot;macros&quot;</a> <span class="domain">(<a href="https://ianthehenry.com">ianthehenry.com</a>)</span></div><div class="subtext"><span>ianthehenry</span> | <span>54 comments</span></div><br/><div><div id="41242962" class="c"><input type="checkbox" id="c-41242962" checked=""/><div class="controls bullet"><span class="by">homedirectory</span><span>|</span><a href="#41242038">next</a><span>|</span><label class="collapse" for="c-41242962">[-]</label><label class="expand" for="c-41242962">[1 more]</label></div><br/><div class="children"><div class="content">You can achieve memoization of an expression inside a function without any global state and macros:<p><pre><code>    (defun compute-hash (key hash f)
      &quot;Get the value for KEY in HASH or compute it with F, enter into HASH and return.&quot;
      (multiple-value-bind (val win)
          (gethash key hash)
        (if win
            val
            (setf (gethash key hash) (funcall f key)))))

    (defun memoized (f)
      (let ((cache (make-hash-table)))
        (flet ((memo (x g) (compute-hash x cache g)))
          (lambda (&amp;rest args) (apply f #&#x27;memo args)))))

    (defun fib (n)
      (if (&lt;= n 1)
          n
          (+ (fib (1- n)) (fib (- n 2)))))

    ;; MEMO is a function that takes a key and a computing function.
    ;; If a key has been memoized, it returns the cached value, otherwise it calls the computing
    ;; function with the key and caches the result.
    (let ((example (memoized (lambda (memo x)
                               (format t &quot;X: ~a~%&quot; x)
                               (let ((result (funcall memo x #&#x27;fib)))
                                 (format t &quot;~a~%&quot; (* 2 result)))))))
      (trace fib)
      (funcall example 5)
      (funcall example 5)
      (funcall example 5)
      (untrace fib))</code></pre></div><br/></div></div><div id="41242038" class="c"><input type="checkbox" id="c-41242038" checked=""/><div class="controls bullet"><span class="by">tyg13</span><span>|</span><a href="#41242962">prev</a><span>|</span><a href="#41238614">next</a><span>|</span><label class="collapse" for="c-41242038">[-]</label><label class="expand" for="c-41242038">[11 more]</label></div><br/><div class="children"><div class="content">Every time I see a post from Lisp fans about macros, I want to be amazed, but I always just walk away confused. I can tell there&#x27;s something interesting in there, but the quote-unquote-quasiquote syntax is just so dense that my brain is incapable of comprehending it.</div><br/><div id="41242482" class="c"><input type="checkbox" id="c-41242482" checked=""/><div class="controls bullet"><span class="by">dualogy</span><span>|</span><a href="#41242038">parent</a><span>|</span><a href="#41242730">next</a><span>|</span><label class="collapse" for="c-41242482">[-]</label><label class="expand" for="c-41242482">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but the quote-unquote-quasiquote syntax is just so dense that my brain is incapable of comprehending it<p>Here&#x27;s JS string interpolation:<p>`OK ${10+20} == 30` &#x2F;&#x2F; result: &quot;OK 30 == 30&quot; — a JS string<p>Here&#x27;s a quasiquote-unquote:<p>`(OK ,(+ 10 20) == 30)  ; result: (OK 30 == 30) — a list of 4 atoms<p>In my toy Lisp I used $ instead of comma, which I found a tad &quot;more readable&quot; coming from today&#x27;s JS, Perl, Bash world. (And makes quasiquote... &quot;the money quote&quot;? =)</div><br/></div></div><div id="41242730" class="c"><input type="checkbox" id="c-41242730" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#41242038">parent</a><span>|</span><a href="#41242482">prev</a><span>|</span><a href="#41242463">next</a><span>|</span><label class="collapse" for="c-41242730">[-]</label><label class="expand" for="c-41242730">[3 more]</label></div><br/><div class="children"><div class="content">Focus on the problem that is being solved, not the mechanism. Consider this classic trick:<p><pre><code>    handle = (exists(file) and open(file))
</code></pre>
That uses the short-circuiting behaviour of &amp;&amp; to only open a file if it exists. Not great practice to write it in that way IMO but whatever. You can&#x27;t implement it as a function:<p><pre><code>    handle = and(exists(file), open(file))

    def and(exists, file):
       ... No viable implementation in Python afaik ...
</code></pre>
That doesn&#x27;t work because functions arguments don&#x27;t&#x2F;can&#x27;t implement short circuiting - both arguments are evaluated before our function is called (although we could make it work in this case by passing the file name in - the point is that the function signature has to change).<p>Macros however can implement something that has short circuiting behaviour. It is a mechanism for implementing new syntax - more powerful than functions but as a trade off more error prone. Quasiquoting and whatever falls out of that as implementation details once you&#x27;ve got all that as context.</div><br/><div id="41243208" class="c"><input type="checkbox" id="c-41243208" checked=""/><div class="controls bullet"><span class="by">mk12</span><span>|</span><a href="#41242038">root</a><span>|</span><a href="#41242730">parent</a><span>|</span><a href="#41242463">next</a><span>|</span><label class="collapse" for="c-41243208">[-]</label><label class="expand" for="c-41243208">[2 more]</label></div><br/><div class="children"><div class="content">I know it’s not the point of your example, but you should not check if a file exists right before opening it. It could get deleted in between exists(file) and open(file), so you still have to handle the case where opening fails with FileNotFound.</div><br/><div id="41243981" class="c"><input type="checkbox" id="c-41243981" checked=""/><div class="controls bullet"><span class="by">strogonoff</span><span>|</span><a href="#41242038">root</a><span>|</span><a href="#41243208">parent</a><span>|</span><a href="#41242463">next</a><span>|</span><label class="collapse" for="c-41243981">[-]</label><label class="expand" for="c-41243981">[1 more]</label></div><br/><div class="children"><div class="content">I find myself increasingly preferring the exists()-then-open() sequence to open()-and-catch-NotFound (not just in Python, but generally).<p>Yes, it is classically frowned upon, but:<p>1. It  is typical that there are multiple checks that need to be done in addition to exists(). It is a given that conditionals are more flexible than exceptions (even in Python).  As long as <i>some</i> checks are in conditionals, it makes the code more legible and easier to reason about when all preliminary checks are in the same fashion and in the same place.<p>2. You <i>still</i> need to handle the other possible sub-varieties of OSError and other exceptions that can arise due to, say, I&#x2F;O being famously unreliable. If  you implement that handling  gracefully, you will have the FileNotFoundError covered for free. From end user experience perspective, since a file being  deleted between exists() and immediate open() on a single system  within a single thread is an out of ordinary one-in-a-thousand-years case, it is OK if it is handled slightly less gracefully than if it occurs during the preliminary checks.</div><br/></div></div></div></div></div></div><div id="41242463" class="c"><input type="checkbox" id="c-41242463" checked=""/><div class="controls bullet"><span class="by">btilly</span><span>|</span><a href="#41242038">parent</a><span>|</span><a href="#41242730">prev</a><span>|</span><a href="#41242171">next</a><span>|</span><label class="collapse" for="c-41242463">[-]</label><label class="expand" for="c-41242463">[2 more]</label></div><br/><div class="children"><div class="content">Paul Graham&#x27;s <a href="https:&#x2F;&#x2F;paulgraham.com&#x2F;onlisp.html" rel="nofollow">https:&#x2F;&#x2F;paulgraham.com&#x2F;onlisp.html</a> is a whole book about it that really helped it click for me.<p>The challenge with the syntax is that there is no syntax. Work that we&#x27;re used to offloading to syntax is instead carried by your brain.</div><br/><div id="41244064" class="c"><input type="checkbox" id="c-41244064" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#41242038">root</a><span>|</span><a href="#41242463">parent</a><span>|</span><a href="#41242171">next</a><span>|</span><label class="collapse" for="c-41244064">[-]</label><label class="expand" for="c-41244064">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Work that we&#x27;re used to offloading to syntax is instead carried by your brain.<p>Kinda like the challenge to eating salad is all the chewing.  It&#x27;s not just that the brain needs to parse a lot more language to express a simple concept; it&#x27;s also that the fingers also need to type all that out.</div><br/></div></div></div></div><div id="41242171" class="c"><input type="checkbox" id="c-41242171" checked=""/><div class="controls bullet"><span class="by">ianthehenry</span><span>|</span><a href="#41242038">parent</a><span>|</span><a href="#41242463">prev</a><span>|</span><a href="#41242060">next</a><span>|</span><label class="collapse" for="c-41242171">[-]</label><label class="expand" for="c-41242171">[1 more]</label></div><br/><div class="children"><div class="content">Yeah this is kinda like... this is definitely an advanced topic within the topic of macro writing and not very intelligible if you haven&#x27;t written simpler macros for a while already.<p>I wrote a book whose third chapter is a much &quot;gentler&quot; introduction to macros. I don&#x27;t know if it&#x27;s actually intelligible (see: the monad tutorial fallacy) but it presents them the way that I was first able to understand them -- explicitly starting <i>without</i> quasiquote and working up to it. Easier for me than getting lost in the notation. <a href="https:&#x2F;&#x2F;janet.guide&#x2F;macros-and-metaprogramming&#x2F;" rel="nofollow">https:&#x2F;&#x2F;janet.guide&#x2F;macros-and-metaprogramming&#x2F;</a></div><br/></div></div><div id="41242060" class="c"><input type="checkbox" id="c-41242060" checked=""/><div class="controls bullet"><span class="by">fungiblecog</span><span>|</span><a href="#41242038">parent</a><span>|</span><a href="#41242171">prev</a><span>|</span><a href="#41238614">next</a><span>|</span><label class="collapse" for="c-41242060">[-]</label><label class="expand" for="c-41242060">[3 more]</label></div><br/><div class="children"><div class="content">To get it you really need to learn enough lisp (not a lot) and try implementing a non-trivial macro.</div><br/><div id="41244075" class="c"><input type="checkbox" id="c-41244075" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#41242038">root</a><span>|</span><a href="#41242060">parent</a><span>|</span><a href="#41242148">next</a><span>|</span><label class="collapse" for="c-41244075">[-]</label><label class="expand" for="c-41244075">[1 more]</label></div><br/><div class="children"><div class="content">Been there, done that.  The real challenge is not implementing a non-trivial macro; it&#x27;s coming back to that non-trivial macro a week later.</div><br/></div></div><div id="41242148" class="c"><input type="checkbox" id="c-41242148" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#41242038">root</a><span>|</span><a href="#41242060">parent</a><span>|</span><a href="#41244075">prev</a><span>|</span><a href="#41238614">next</a><span>|</span><label class="collapse" for="c-41242148">[-]</label><label class="expand" for="c-41242148">[1 more]</label></div><br/><div class="children"><div class="content">Yep, they are a foreign idea in pretty much all languages, but they are super easy once you figure them out.<p>If anyone actually wants to get their hands dirty to learn about Lisp macros, I recommend picking a Lisp implementation like SBCL, GNU Guile, Emacs, Clojure, or Hylang depending on what kind of environment you&#x27;re comfortable with. The key about each of the Lisp implementations I mentioned here is that they all support &quot;Common Lisp style macros&quot;, which are the bare bones most obvious way to do macros in Lisp.<p>Then I recommend using your choice of Lisp to implement a language feature you use in another language. It doesn&#x27;t matter if that language feature already exists in your choice of Lisp, you can still implement it yourself. For example, you can choose to implement C-style for loops or while loops, asynchronous coroutines like Go, pattern matching, lambdas, whatever. I actually implemented asnyc&#x2F;await in IronScheme and pushed it upstream[0].<p>If you want to read more about Lisp macros, I have really enjoyed the book Let over Lambda. I have also heard a lot about On Lisp by pg, but I haven&#x27;t read that myself yet. Also if you really want to dive off the deep end into the beauty of programming, I recommend SICP.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;IronScheme&#x2F;IronScheme&#x2F;pull&#x2F;141">https:&#x2F;&#x2F;github.com&#x2F;IronScheme&#x2F;IronScheme&#x2F;pull&#x2F;141</a></div><br/></div></div></div></div></div></div><div id="41238614" class="c"><input type="checkbox" id="c-41238614" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#41242038">prev</a><span>|</span><a href="#41240663">next</a><span>|</span><label class="collapse" for="c-41238614">[-]</label><label class="expand" for="c-41238614">[2 more]</label></div><br/><div class="children"><div class="content">Rust macros are sort of sufficient to do the kind of rewriting mentioned, but it&#x27;s maybe cheating because you have to annotate the function with the macro which allows the macro to mangle the whole function body.</div><br/><div id="41238934" class="c"><input type="checkbox" id="c-41238934" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41238614">parent</a><span>|</span><a href="#41240663">next</a><span>|</span><label class="collapse" for="c-41238934">[-]</label><label class="expand" for="c-41238934">[1 more]</label></div><br/><div class="children"><div class="content">yeah, i don&#x27;t think that&#x27;s valid because it turns a local transformation into a global transformation (sort of local, but only to the entire top-level function, which can be arbitrarily large)<p>if you&#x27;re willing to do the global transformation yourself instead of enlisting the computer to do it for you, you don&#x27;t even need macros at all; you can do that with henry&#x27;s example:<p><pre><code>    const resultMap = new Map();
</code></pre>
above the function</div><br/></div></div></div></div><div id="41240663" class="c"><input type="checkbox" id="c-41240663" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#41238614">prev</a><span>|</span><a href="#41238639">next</a><span>|</span><label class="collapse" for="c-41240663">[-]</label><label class="expand" for="c-41240663">[9 more]</label></div><br/><div class="children"><div class="content">In the associated article linked to at &quot;Leaving aside the absurdity of computing Fibonacci numbers recursively,&quot;[1] (which, yes, I agree), we list the various algorithms as (roughly):<p><pre><code>  how to fibonacci           space complexity  time complexity
  -------------------------  ----------------  ---------------
  insane recursion           exponential       exponential
  memoized insane recursion  linear            linear
</code></pre>
The space complexity of &quot;insane recursion&quot; without memoization is the maximum stack-depth; the worst case stack is,<p><pre><code>  fib(n)
  fib(n-1)
  fib(n-2)
  ...
  fib(1)
</code></pre>
Which is <i>n</i> stack frames (and the stack frames are of constant size); the space complexity of the whole thing is thus linear in the size of <i>n</i>. (While the call tree is itself exponential in size, the memory required is only the depth of that tree, since we can&#x27;t call fib(n-1) &amp; fib(n-2) simultaneously[2].<p>(The time complexity is, of course, exponential, and I agree with the &quot;insane&quot; moniker. I also like your comment elsewhere in this thread about people hyperfocusing on the example and missing the larger point of the article … and I&#x27;m so sorry but I&#x27;ve been sniped by this.)<p>[1]: <a href="https:&#x2F;&#x2F;ianthehenry.com&#x2F;posts&#x2F;fibonacci&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ianthehenry.com&#x2F;posts&#x2F;fibonacci&#x2F;</a><p>[2]: the little demons in my mind are now trying to scheme up an insaner recursion that attempts this. Threads maybe?</div><br/><div id="41241333" class="c"><input type="checkbox" id="c-41241333" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#41240663">parent</a><span>|</span><a href="#41241937">next</a><span>|</span><label class="collapse" for="c-41241333">[-]</label><label class="expand" for="c-41241333">[3 more]</label></div><br/><div class="children"><div class="content">&quot;the absurdity of computing Fibonacci numbers recursively&quot;<p>It&#x27;s absurd to actually compute it that way, but it&#x27;s beautiful to express it that way.<p>From the blog post:<p><pre><code>  def fib(n):
      if n &lt;= 1:
          return n
      return fib(n - 1) + fib(n - 2)
</code></pre>
Easy to read, easy to comprehend. You just need a smart compiler to do it efficiently.</div><br/><div id="41242027" class="c"><input type="checkbox" id="c-41242027" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#41240663">root</a><span>|</span><a href="#41241333">parent</a><span>|</span><a href="#41242625">next</a><span>|</span><label class="collapse" for="c-41242027">[-]</label><label class="expand" for="c-41242027">[1 more]</label></div><br/><div class="children"><div class="content">I too also appreciate the beauty of the &quot;insane&quot; algorithm, from a mathematical view. What I think gets lost on some programmers¹ is that, while that&#x27;s all good and fine, we&#x27;re not <i>just</i> doing a computation, we are doing a computation and we&#x27;re inherently expending time and space to do that computation, and the amount of time and space is inherently part of the problem, or part of the requirements. I want to compute X, but I also do want to do it before the heat death of the universe. Attempting to sweep those under the rug with a &quot;sufficiently smart compiler&quot; is fun when it works, but I think in the sense of engineering software, we need a more rigorous answer to &quot;it will not consume bonkers amounts of space&#x2F;time to compute X.&quot;<p>&quot;Accidentally Quadratic&quot; was a fun tumblr dedicate to more real world instances of this, and it&#x27;s sad they&#x27;re not longer posting, though I still use that term to name real-world sightings of O(lol) time. (O(lol) space is just called &quot;Java&quot;.)<p>¹and since you say &quot;to actually compute it that way&quot;, I think you get this, but I want to point it out here</div><br/></div></div><div id="41242625" class="c"><input type="checkbox" id="c-41242625" checked=""/><div class="controls bullet"><span class="by">ianthehenry</span><span>|</span><a href="#41240663">root</a><span>|</span><a href="#41241333">parent</a><span>|</span><a href="#41242027">prev</a><span>|</span><a href="#41241937">next</a><span>|</span><label class="collapse" for="c-41242625">[-]</label><label class="expand" for="c-41242625">[1 more]</label></div><br/><div class="children"><div class="content">Are there any existing compilers that could compile a function like this -- non-tail recursive and non-tail recursive modulo cons -- into something that executes in sub-exponential time? How would that even work? I&#x27;ve never heard of a compiler sufficiently smart to optimize a definition like this and now I&#x27;m very curious</div><br/></div></div></div></div><div id="41241937" class="c"><input type="checkbox" id="c-41241937" checked=""/><div class="controls bullet"><span class="by">sobellian</span><span>|</span><a href="#41240663">parent</a><span>|</span><a href="#41241333">prev</a><span>|</span><a href="#41240858">next</a><span>|</span><label class="collapse" for="c-41241937">[-]</label><label class="expand" for="c-41241937">[1 more]</label></div><br/><div class="children"><div class="content">If we account for arbitrary precision operations necessary for large N, I believe the memoized insane recursion is quadratic in space and time. This is actually not as bad of a pessimization as I thought it would be over just using Binet&#x27;s formula, but it&#x27;s still a hit.</div><br/></div></div><div id="41240858" class="c"><input type="checkbox" id="c-41240858" checked=""/><div class="controls bullet"><span class="by">ianthehenry</span><span>|</span><a href="#41240663">parent</a><span>|</span><a href="#41241937">prev</a><span>|</span><a href="#41241767">next</a><span>|</span><label class="collapse" for="c-41240858">[-]</label><label class="expand" for="c-41240858">[3 more]</label></div><br/><div class="children"><div class="content">ha thanks, you are absolutely right. i updated the table :)</div><br/><div id="41241166" class="c"><input type="checkbox" id="c-41241166" checked=""/><div class="controls bullet"><span class="by">lilyball</span><span>|</span><a href="#41240663">root</a><span>|</span><a href="#41240858">parent</a><span>|</span><a href="#41241767">next</a><span>|</span><label class="collapse" for="c-41241166">[-]</label><label class="expand" for="c-41241166">[2 more]</label></div><br/><div class="children"><div class="content">In that same article, you have some iterations<p><pre><code>  8 &#x2F; 41 = 0.1951219
  (8 + 41 = 49) &#x2F; 8 = 6.125
  (49 + 8 = 57) &#x2F; 49 = 1.16326531
  (57 + 49 = 106) &#x2F; 57 = 1.85964912
  (106 + 57 = 163) &#x2F; 106 = 1.53773585
</code></pre>
That second line is screwed up, which also screws up the subsequent lines. It should look like<p><pre><code>  (41 + 8 = 49) &#x2F; 41 = 1.19512195
</code></pre>
which then means the line after that should be<p><pre><code>  (49 + 41 = 90) &#x2F; 49 = 1.83673469
</code></pre>
and so on</div><br/><div id="41241418" class="c"><input type="checkbox" id="c-41241418" checked=""/><div class="controls bullet"><span class="by">ianthehenry</span><span>|</span><a href="#41240663">root</a><span>|</span><a href="#41241166">parent</a><span>|</span><a href="#41241767">next</a><span>|</span><label class="collapse" for="c-41241418">[-]</label><label class="expand" for="c-41241418">[1 more]</label></div><br/><div class="children"><div class="content">i think this is just very badly worded. the initial conditions are current=8, previous=41, not the other way around. i should make that more clear</div><br/></div></div></div></div></div></div><div id="41241767" class="c"><input type="checkbox" id="c-41241767" checked=""/><div class="controls bullet"><span class="by">norir</span><span>|</span><a href="#41240663">parent</a><span>|</span><a href="#41240858">prev</a><span>|</span><a href="#41238639">next</a><span>|</span><label class="collapse" for="c-41241767">[-]</label><label class="expand" for="c-41241767">[1 more]</label></div><br/><div class="children"><div class="content">in lua:<p><pre><code>  local fib do
    local impl impl = function(n, n1, n2)
      if n == 0 then return n1 end
      return impl(n - 1, n1 + n2, n1)
    end
    fib = function(n) return impl(n - 1, 1, 0) end
  end
  for i = 1, 10 do print(fib(i)) end</code></pre></div><br/></div></div></div></div><div id="41238639" class="c"><input type="checkbox" id="c-41238639" checked=""/><div class="controls bullet"><span class="by">crdrost</span><span>|</span><a href="#41240663">prev</a><span>|</span><a href="#41241956">next</a><span>|</span><label class="collapse" for="c-41238639">[-]</label><label class="expand" for="c-41238639">[15 more]</label></div><br/><div class="children"><div class="content">&gt; How do you implement `memoize`?<p>&gt; I <i>think</i> that you basically can’t, in JavaScript. Or, more accurately: I can’t think of a way to do it.[1]<p>Oh, this is a case for WeakMaps right?<p><pre><code>    const MemoCache = new WeakMap();
    function memoize(f, x) {
        const cache = MemoCache.get(f) || new Map()
        MemoCache.set(f, cache)
        if (!cache.has(x)) {
            cache.set(x, f(x))
        }
        return cache.get(x);
    }
</code></pre>
Oh wait:<p>&gt; 1. You could create a global memoization map keyed on the <i>function</i> that you’re calling, but this would actually have different semantics than I’m imagining. If I said `memoize(f, 1) + memoize(f, 1)` I would expect those to each invoke `f`, because instances of `memoize` shouldn’t share results. Why not? Because this is a fake example, and a global memoization is a different (easier!) thing than per-call-site memoization.<p>Like I get what you&#x27;re saying but you could just cache the call site too?<p><pre><code>    const MemoCache2 = new WeakMap();
    function memoize2(f, x) {
        const callsite = new Error().stack
        const macro_cache = MemoCache2.get(f) || {};
        const micro_cache = macro_cache[callsite] || new Map();
        macro_cache[callsite] = micro_cache;
        MemoCache2.set(f, macro_cache)

        if (!micro_cache.has(x)) {
            micro_cache.set(x, f(x))
        }
        return micro_cache.get(x);
    }
</code></pre>
I admit that this is something of a trickery though, but I mean, it&#x27;s trickery specifically to work around that this person doesn&#x27;t want to write `const my_f1 = memoize(f), my_f2 = memoize(f)` in some location on the screen. Precisely because people who write JavaScript are not accustomed to macros, they are not expecting `memoize(f, 1) + memoize(f, 1)` to be a proper memoization expression, they aren&#x27;t expecting weird stuff with weakmaps and inspecting stack traces to identify call sites and all that.</div><br/><div id="41238964" class="c"><input type="checkbox" id="c-41238964" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#41238639">parent</a><span>|</span><a href="#41238905">next</a><span>|</span><label class="collapse" for="c-41238964">[-]</label><label class="expand" for="c-41238964">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;m intrigued on why you would want those two calls to memoize separately?  I&#x27;m sure there are reasons it could be needed, such that I&#x27;m not trying to argue against it.  Genuinely curious to see a situation it would be desired.</div><br/><div id="41239009" class="c"><input type="checkbox" id="c-41239009" checked=""/><div class="controls bullet"><span class="by">ianthehenry</span><span>|</span><a href="#41238639">root</a><span>|</span><a href="#41238964">parent</a><span>|</span><a href="#41238980">next</a><span>|</span><label class="collapse" for="c-41239009">[-]</label><label class="expand" for="c-41239009">[3 more]</label></div><br/><div class="children"><div class="content">You point out a good general problem that I find when blogging -- like, you don&#x27;t want this, right? The whole premise is absurd; the point is <i>not</i> to memoize an expression, but rather to demonstrate that you can share values between compile-time and runtime. But in order to do this you need some specific example of the idea so that readers have something concrete to hold onto and generalize from. And then the difficulty is trying to present that specific example in a way that gets the general idea across, right, without the reader overfitting to the specific example you presented. It&#x27;s hard! I don&#x27;t think this one really succeeded.</div><br/><div id="41239040" class="c"><input type="checkbox" id="c-41239040" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#41238639">root</a><span>|</span><a href="#41239009">parent</a><span>|</span><a href="#41242511">next</a><span>|</span><label class="collapse" for="c-41239040">[-]</label><label class="expand" for="c-41239040">[1 more]</label></div><br/><div class="children"><div class="content">I call that the curse of examples.  Often conflated with &quot;being in the weeds.&quot;  Is frustrating, as people will jump on you with the X-Y problem style discussions.  Which, fair that that is sometimes apt.  Probably more often than makes sense, honestly.<p>Still, I did the callout that I did not mean that as an argument on if they really wanted it because I think it is fair to explore the intent as stated.  And I appreciate how hard it is to make examples.</div><br/></div></div><div id="41242511" class="c"><input type="checkbox" id="c-41242511" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#41238639">root</a><span>|</span><a href="#41239009">parent</a><span>|</span><a href="#41239040">prev</a><span>|</span><a href="#41238980">next</a><span>|</span><label class="collapse" for="c-41242511">[-]</label><label class="expand" for="c-41242511">[1 more]</label></div><br/><div class="children"><div class="content">To your credit, you did explicitly call out your example in the blog post as something you wouldn&#x27;t _actually_ want to do, so it didn&#x27;t bother me. I&#x27;ve found that I&#x27;m more receptive to contrived examples to demonstrate a point if they aren&#x27;t trying to hide the fact that they&#x27;re contrived, so if I&#x27;m trying to convey a concept via example, sometimes I&#x27;ll lean into the fact that the example is unrealistic to make it clear that the lack of utility shouldn&#x27;t distract from the idea. As a silly example of this (see what I did there?), I might implement a trait with a `len` method that always returns 0 on strings to show how to resolve ambiguity when adding a method with name that a type already has in Rust.</div><br/></div></div></div></div><div id="41238980" class="c"><input type="checkbox" id="c-41238980" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41238639">root</a><span>|</span><a href="#41238964">parent</a><span>|</span><a href="#41239009">prev</a><span>|</span><a href="#41242013">next</a><span>|</span><label class="collapse" for="c-41238980">[-]</label><label class="expand" for="c-41238980">[5 more]</label></div><br/><div class="children"><div class="content">a more plausible example than memoization is something like a polymorphic inline cache, where the cache can be very small and therefore fast to search but tends to be different at different callsites</div><br/><div id="41239011" class="c"><input type="checkbox" id="c-41239011" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#41238639">root</a><span>|</span><a href="#41238980">parent</a><span>|</span><a href="#41242013">next</a><span>|</span><label class="collapse" for="c-41239011">[-]</label><label class="expand" for="c-41239011">[4 more]</label></div><br/><div class="children"><div class="content">Makes sense, I was thinking this is largely recreating L2 caches and such.  Where you don&#x27;t mind that they would memoize the same data, but the expectation is more that each caller would have a small subset they are specifically using over and over.</div><br/><div id="41242000" class="c"><input type="checkbox" id="c-41242000" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#41238639">root</a><span>|</span><a href="#41239011">parent</a><span>|</span><a href="#41242013">next</a><span>|</span><label class="collapse" for="c-41242000">[-]</label><label class="expand" for="c-41242000">[3 more]</label></div><br/><div class="children"><div class="content">If you knew the answer, why did you ask the question?</div><br/><div id="41242532" class="c"><input type="checkbox" id="c-41242532" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#41238639">root</a><span>|</span><a href="#41242000">parent</a><span>|</span><a href="#41243137">next</a><span>|</span><label class="collapse" for="c-41242532">[-]</label><label class="expand" for="c-41242532">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes it&#x27;s nice to abstract a place where you need the answer from the way you determine the answer; that&#x27;s basically why functions exist in the first place! Later on, if you decide that you want to tweak the way the implementation works, you don&#x27;t need to do it literally everywhere.</div><br/></div></div><div id="41243137" class="c"><input type="checkbox" id="c-41243137" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#41238639">root</a><span>|</span><a href="#41242000">parent</a><span>|</span><a href="#41242532">prev</a><span>|</span><a href="#41242013">next</a><span>|</span><label class="collapse" for="c-41243137">[-]</label><label class="expand" for="c-41243137">[1 more]</label></div><br/><div class="children"><div class="content">I thought of an answer after asking.  Still curious if there are others.</div><br/></div></div></div></div></div></div></div></div><div id="41242013" class="c"><input type="checkbox" id="c-41242013" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#41238639">root</a><span>|</span><a href="#41238964">parent</a><span>|</span><a href="#41238980">prev</a><span>|</span><a href="#41238905">next</a><span>|</span><label class="collapse" for="c-41242013">[-]</label><label class="expand" for="c-41242013">[1 more]</label></div><br/><div class="children"><div class="content">fib(3), fib(2), fib(6), fib(1000000), fib(9), fib(2), fib(8),...</div><br/></div></div></div></div><div id="41238905" class="c"><input type="checkbox" id="c-41238905" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41238639">parent</a><span>|</span><a href="#41238964">prev</a><span>|</span><a href="#41238935">next</a><span>|</span><label class="collapse" for="c-41238905">[-]</label><label class="expand" for="c-41238905">[1 more]</label></div><br/><div class="children"><div class="content">i think reflecting on the stack is a valid solution to the problem and one that henry probably didn&#x27;t think of.  technically i think you need to extract just the first frame of the stack though.  also reflection is often slow so it wouldn&#x27;t be surprising if this ended up being a solution that was too slow to be useful</div><br/></div></div><div id="41238935" class="c"><input type="checkbox" id="c-41238935" checked=""/><div class="controls bullet"><span class="by">ianthehenry</span><span>|</span><a href="#41238639">parent</a><span>|</span><a href="#41238905">prev</a><span>|</span><a href="#41241201">next</a><span>|</span><label class="collapse" for="c-41238935">[-]</label><label class="expand" for="c-41238935">[2 more]</label></div><br/><div class="children"><div class="content">this is a very funny way to do this, thanks! i was thinking of using the (deprecated but still widely supported(?)) `caller` property but was sad that it wouldn&#x27;t admit multiple memoization dictionaries per calling function (also wouldn&#x27;t work at the top-level but, like, who cares). but using the stack trace is great.<p>i mean, you know, this isn&#x27;t really... this isn&#x27;t really a thing that you would ever want to do, but i am glad that life found a way</div><br/><div id="41238969" class="c"><input type="checkbox" id="c-41238969" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41238639">root</a><span>|</span><a href="#41238935">parent</a><span>|</span><a href="#41241201">next</a><span>|</span><label class="collapse" for="c-41238969">[-]</label><label class="expand" for="c-41238969">[1 more]</label></div><br/><div class="children"><div class="content">it might be; you&#x27;d have to benchmark it to be sure</div><br/></div></div></div></div><div id="41241201" class="c"><input type="checkbox" id="c-41241201" checked=""/><div class="controls bullet"><span class="by">loa_in_</span><span>|</span><a href="#41238639">parent</a><span>|</span><a href="#41238935">prev</a><span>|</span><a href="#41241956">next</a><span>|</span><label class="collapse" for="c-41241201">[-]</label><label class="expand" for="c-41241201">[1 more]</label></div><br/><div class="children"><div class="content">Wait, can&#x27;t you just set the property on the function object itself to accomplish this?</div><br/></div></div></div></div><div id="41241956" class="c"><input type="checkbox" id="c-41241956" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#41238639">prev</a><span>|</span><a href="#41243265">next</a><span>|</span><label class="collapse" for="c-41241956">[-]</label><label class="expand" for="c-41241956">[1 more]</label></div><br/><div class="children"><div class="content">Wow. I haven&#x27;t really played with Lisp since college. But I just started reading <i>The Little Schemer</i> with some friends, and hope to move on to SICP some time this year or next. This blog post made me a little dizzy, but also a little excited about what I&#x27;m hoping to explore with these lessons.</div><br/></div></div><div id="41243265" class="c"><input type="checkbox" id="c-41243265" checked=""/><div class="controls bullet"><span class="by">artemonster</span><span>|</span><a href="#41241956">prev</a><span>|</span><a href="#41238684">next</a><span>|</span><label class="collapse" for="c-41243265">[-]</label><label class="expand" for="c-41243265">[1 more]</label></div><br/><div class="children"><div class="content">Isnt this something that John Shutt solved with his Vau calculus? Basically, each &quot;macro&quot; (actually kinda like fexpr) invocation creates its own static environment, which neatly solves all hygiene problems and problems outlined in this article?</div><br/></div></div><div id="41238684" class="c"><input type="checkbox" id="c-41238684" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#41243265">prev</a><span>|</span><a href="#41241603">next</a><span>|</span><label class="collapse" for="c-41238684">[-]</label><label class="expand" for="c-41238684">[2 more]</label></div><br/><div class="children"><div class="content">Programmer uses lisp macro to invent new keyword. It&#x27;s a beautiful thing.</div><br/></div></div><div id="41241603" class="c"><input type="checkbox" id="c-41241603" checked=""/><div class="controls bullet"><span class="by">markovs_gun</span><span>|</span><a href="#41238684">prev</a><span>|</span><a href="#41241329">next</a><span>|</span><label class="collapse" for="c-41241603">[-]</label><label class="expand" for="c-41241603">[4 more]</label></div><br/><div class="children"><div class="content">I am going to be honest I didn&#x27;t really understand what an eigenvalue was until reading this. I&#x27;d read the definition but like I didn&#x27;t really understand why you&#x27;d care about that. This was a great article</div><br/><div id="41241696" class="c"><input type="checkbox" id="c-41241696" checked=""/><div class="controls bullet"><span class="by">JHonaker</span><span>|</span><a href="#41241603">parent</a><span>|</span><a href="#41241329">next</a><span>|</span><label class="collapse" for="c-41241696">[-]</label><label class="expand" for="c-41241696">[3 more]</label></div><br/><div class="children"><div class="content">Did you post this on the wrong article?</div><br/><div id="41241760" class="c"><input type="checkbox" id="c-41241760" checked=""/><div class="controls bullet"><span class="by">disconcision</span><span>|</span><a href="#41241603">root</a><span>|</span><a href="#41241696">parent</a><span>|</span><a href="#41241329">next</a><span>|</span><label class="collapse" for="c-41241760">[-]</label><label class="expand" for="c-41241760">[2 more]</label></div><br/><div class="children"><div class="content">see the first link in the article, &#x27;the absurdity of computing Fibonacci numbers recursively&#x27;</div><br/><div id="41242101" class="c"><input type="checkbox" id="c-41242101" checked=""/><div class="controls bullet"><span class="by">JHonaker</span><span>|</span><a href="#41241603">root</a><span>|</span><a href="#41241760">parent</a><span>|</span><a href="#41241329">next</a><span>|</span><label class="collapse" for="c-41242101">[-]</label><label class="expand" for="c-41242101">[1 more]</label></div><br/><div class="children"><div class="content">Ah, I see. I read the article, but not the links. I even searched for eigenvalue&#x2F;eigenvector to see if I was crazy.<p>The first linked article is very good. I always enjoy Ian’s work.</div><br/></div></div></div></div></div></div></div></div><div id="41241329" class="c"><input type="checkbox" id="c-41241329" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41241603">prev</a><span>|</span><a href="#41240611">next</a><span>|</span><label class="collapse" for="c-41241329">[-]</label><label class="expand" for="c-41241329">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Leaving aside the absurdity of computing Fibonacci numbers recursively<p>Is it really absurd?  If the compiler can turn it into iteration, then it&#x27;s a big boy compiler.  If not, then meh?</div><br/><div id="41241967" class="c"><input type="checkbox" id="c-41241967" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#41241329">parent</a><span>|</span><a href="#41240611">next</a><span>|</span><label class="collapse" for="c-41241967">[-]</label><label class="expand" for="c-41241967">[3 more]</label></div><br/><div class="children"><div class="content">Computing Fibonacci numbers iteratively is only slightly less absurd. It&#x27;s `O(n)` for what should be an `O(log(n))` problem (`fib(n) = round ((phi^n - phi^-n)&#x2F;(2phi-1))`).</div><br/><div id="41242598" class="c"><input type="checkbox" id="c-41242598" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41241329">root</a><span>|</span><a href="#41241967">parent</a><span>|</span><a href="#41240611">next</a><span>|</span><label class="collapse" for="c-41242598">[-]</label><label class="expand" for="c-41242598">[2 more]</label></div><br/><div class="children"><div class="content">Ay, yes, I was focused on the idea that I want my compilers to do TCO and other optimizations, so I missed the point.</div><br/><div id="41242669" class="c"><input type="checkbox" id="c-41242669" checked=""/><div class="controls bullet"><span class="by">ianthehenry</span><span>|</span><a href="#41241329">root</a><span>|</span><a href="#41242598">parent</a><span>|</span><a href="#41240611">next</a><span>|</span><label class="collapse" for="c-41242669">[-]</label><label class="expand" for="c-41242669">[1 more]</label></div><br/><div class="children"><div class="content">Eh, by recursion I meant specifically the exponential &quot;fib(n - 1) + fib(n - 2)&quot; flavored definition. If you&#x27;re writing the linear-time algorithm and happen to do the iteration via tail recursion, I don&#x27;t think there&#x27;s anything absurd about that</div><br/></div></div></div></div></div></div></div></div><div id="41240611" class="c"><input type="checkbox" id="c-41240611" checked=""/><div class="controls bullet"><span class="by">29athrowaway</span><span>|</span><a href="#41241329">prev</a><span>|</span><a href="#41240568">next</a><span>|</span><label class="collapse" for="c-41240611">[-]</label><label class="expand" for="c-41240611">[2 more]</label></div><br/><div class="children"><div class="content">Macros are an unmaintainable mess.</div><br/><div id="41242073" class="c"><input type="checkbox" id="c-41242073" checked=""/><div class="controls bullet"><span class="by">fungiblecog</span><span>|</span><a href="#41240611">parent</a><span>|</span><a href="#41240568">next</a><span>|</span><label class="collapse" for="c-41242073">[-]</label><label class="expand" for="c-41242073">[1 more]</label></div><br/><div class="children"><div class="content">Substitute any non-trivial programming idiom for “macros” and that is true for some subset of working programmers.</div><br/></div></div></div></div><div id="41240568" class="c"><input type="checkbox" id="c-41240568" checked=""/><div class="controls bullet"><span class="by">dools</span><span>|</span><a href="#41240611">prev</a><span>|</span><label class="collapse" for="c-41240568">[-]</label><label class="expand" for="c-41240568">[1 more]</label></div><br/><div class="children"><div class="content">&quot;&quot;macros&quot;&quot;</div><br/></div></div></div></div></div></div></div></body></html>