<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723280461035" as="style"/><link rel="stylesheet" href="styles.css?v=1723280461035"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.djhaskin.com/blog/common-lisp-community-survey-2024-results/">Common Lisp Community Survey 2024 Results</a> <span class="domain">(<a href="https://blog.djhaskin.com">blog.djhaskin.com</a>)</span></div><div class="subtext"><span>djha-skin</span> | <span>53 comments</span></div><br/><div><div id="41207649" class="c"><input type="checkbox" id="c-41207649" checked=""/><div class="controls bullet"><span class="by">lkuty</span><span>|</span><a href="#41206752">next</a><span>|</span><label class="collapse" for="c-41207649">[-]</label><label class="expand" for="c-41207649">[2 more]</label></div><br/><div class="children"><div class="content">The &quot;Steel Bank Common Lisp&quot; link points to <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;Common_Lisp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;Common_Lisp&#x2F;</a> instead of <a href="http:&#x2F;&#x2F;www.sbcl.org&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.sbcl.org&#x2F;</a></div><br/><div id="41207676" class="c"><input type="checkbox" id="c-41207676" checked=""/><div class="controls bullet"><span class="by">lkuty</span><span>|</span><a href="#41207649">parent</a><span>|</span><a href="#41206752">next</a><span>|</span><label class="collapse" for="c-41207676">[-]</label><label class="expand" for="c-41207676">[1 more]</label></div><br/><div class="children"><div class="content">The link <a href="https:&#x2F;&#x2F;edicl.github.io&#x2F;Hutchentoot&#x2F;" rel="nofollow">https:&#x2F;&#x2F;edicl.github.io&#x2F;Hutchentoot&#x2F;</a> should be with a lowercase h: <a href="http:&#x2F;&#x2F;edicl.github.io&#x2F;hunchentoot&#x2F;" rel="nofollow">http:&#x2F;&#x2F;edicl.github.io&#x2F;hunchentoot&#x2F;</a></div><br/></div></div></div></div><div id="41206752" class="c"><input type="checkbox" id="c-41206752" checked=""/><div class="controls bullet"><span class="by">smcn</span><span>|</span><a href="#41207649">prev</a><span>|</span><a href="#41206866">next</a><span>|</span><label class="collapse" for="c-41206752">[-]</label><label class="expand" for="c-41206752">[5 more]</label></div><br/><div class="children"><div class="content">Favourite time of the year!<p>I am, however, continually surprised that SLY doesn’t have more mindshare. Similarly jonathan. I guess cl-json and SLIME are _good enough_ for most people.<p>…or maybe I need to revisit them?</div><br/><div id="41206897" class="c"><input type="checkbox" id="c-41206897" checked=""/><div class="controls bullet"><span class="by">massysett</span><span>|</span><a href="#41206752">parent</a><span>|</span><a href="#41207119">next</a><span>|</span><label class="collapse" for="c-41206897">[-]</label><label class="expand" for="c-41206897">[2 more]</label></div><br/><div class="children"><div class="content">Sly is a derivative of Slime. I shy away from derivatives unless I understand exactly why the derivative is better than the original. In my view, derivatives often have poor documentation: they just copy the original docs, and I can’t tell when to do things the original way versus a special derivative way.<p>Thus I used Debian and not Ubuntu, Vim and not Neovim, Emacs and not Spacemacs (though that’s not exactly a derivative), etc.<p>I do use SBCL rather than CMUCL, as I do understand why SBCL is better for me: CMUCL won’t run on my platform.<p>I look at the Sly page and I have no idea why I would want any of the stuff it does, so I stick with Slime.</div><br/><div id="41207600" class="c"><input type="checkbox" id="c-41207600" checked=""/><div class="controls bullet"><span class="by">diogenesoft</span><span>|</span><a href="#41206752">root</a><span>|</span><a href="#41206897">parent</a><span>|</span><a href="#41207119">next</a><span>|</span><label class="collapse" for="c-41207600">[-]</label><label class="expand" for="c-41207600">[1 more]</label></div><br/><div class="children"><div class="content">Maybe TRY USING it and then you might understand. This mindset is the same reason people rarely try lisp because it is quite difficult to see somethings without actually using them.</div><br/></div></div></div></div><div id="41207119" class="c"><input type="checkbox" id="c-41207119" checked=""/><div class="controls bullet"><span class="by">reikonomusha</span><span>|</span><a href="#41206752">parent</a><span>|</span><a href="#41206897">prev</a><span>|</span><a href="#41206866">next</a><span>|</span><label class="collapse" for="c-41207119">[-]</label><label class="expand" for="c-41207119">[2 more]</label></div><br/><div class="children"><div class="content">Zulu-Inuoe&#x27;s jzon blew everything else out of the water imho. It&#x27;s a superlative example of a robust and comprehensive library to do a single job very well.</div><br/><div id="41207611" class="c"><input type="checkbox" id="c-41207611" checked=""/><div class="controls bullet"><span class="by">smcn</span><span>|</span><a href="#41206752">root</a><span>|</span><a href="#41207119">parent</a><span>|</span><a href="#41206866">next</a><span>|</span><label class="collapse" for="c-41207611">[-]</label><label class="expand" for="c-41207611">[1 more]</label></div><br/><div class="children"><div class="content">New to me! Will give it a bash.</div><br/></div></div></div></div></div></div><div id="41206866" class="c"><input type="checkbox" id="c-41206866" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#41206752">prev</a><span>|</span><label class="collapse" for="c-41206866">[-]</label><label class="expand" for="c-41206866">[45 more]</label></div><br/><div class="children"><div class="content">Common Lisp and the entire Lisp ecosystem seems like a mystical thing to me. It&#x27;s always been touted as the most powerful language (even so far as to being called God&#x27;s programming language: <a href="https:&#x2F;&#x2F;twobithistory.org&#x2F;2018&#x2F;10&#x2F;14&#x2F;lisp.html" rel="nofollow">https:&#x2F;&#x2F;twobithistory.org&#x2F;2018&#x2F;10&#x2F;14&#x2F;lisp.html</a>). But this just raises unrealistic expectations about the language. Every time people ask: &quot;Okay, if Lisp is so powerful as you say it is, then give me one example where Lisp is used? More importantly, give me one example where Lisp was used and didn&#x27;t get rewritten in another language later?&quot;, I hear no concrete example given by the Lispers. One common response is &quot;Hacker News was built in Arc, which is a Lisp&quot;. But the responders then don&#x27;t mention the second part, which is that &quot;Hacker News later got rewritten entirely in another language&quot;.<p>HN is such a simple website by all metrics, and the fact that CL&#x2F;Arc was dropped in favor of another language further confirms my belief that Lisp&#x27;s days in industry are almost over. As a hobby language it still attracts lost or curious souls, but one can&#x27;t simply say &quot;All the industry collectively is stupid not to use Lisp, that&#x27;s why Lisp is not used in prod.&quot;. There are many companies that risk using esoteric languages and Lisp is almost never one of them. Heck, even Elixir and Rust surpassed Lisp in terms of adoption. Lispers can&#x27;t just say that everyone is wrong and they&#x27;re the only ones who drank from the &quot;enlightenment&quot; potion.</div><br/><div id="41208234" class="c"><input type="checkbox" id="c-41208234" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#41206866">parent</a><span>|</span><a href="#41207129">next</a><span>|</span><label class="collapse" for="c-41208234">[-]</label><label class="expand" for="c-41208234">[1 more]</label></div><br/><div class="children"><div class="content">I have a few thoughts, but in reverence to your sincerity I will offer the example of Google Flights, which as far as I know is still written in Common Lisp.<p>Now as for my thoughts: every so often when Lisp comes up there is someone who asks &#x27;give me some examples of companies which use Lisp&#x2F;software written in Lisp&#x27; followed by someone giving some examples. That&#x27;s all good and well but then someone chimes in with the... rebuttal? &#x27;Well, if you have to stretch so much to give examples of Lisp being used that means that it&#x27;s a dead language not worth using.&#x27; ...Or, well, some variation on that theme.<p>Of course I&#x27;m not saying your question is the lead-in to another exchange like this, but after seeing it a few times I get a bit tired of that back-and-forth and it makes me less eager to engage in discussion. I also don&#x27;t really see the logic behind &#x27;which companies use Lisp?&#x27; &#x27;Here are companies that use Lisp:&#x27; &#x27;Aha! If you have to list companies that use Lisp it means it&#x27;s a dying, terrible language!&#x27; Imagine that exchange in a discussion of Rust or Python or Kotlin or whatever.<p>Anyway, sorry for the derailment, just had to get that off my chest. But yeah, Google Flights, ITA Software, just one example of CL in use at a larger player.</div><br/></div></div><div id="41207129" class="c"><input type="checkbox" id="c-41207129" checked=""/><div class="controls bullet"><span class="by">reikonomusha</span><span>|</span><a href="#41206866">parent</a><span>|</span><a href="#41208234">prev</a><span>|</span><a href="#41207374">next</a><span>|</span><label class="collapse" for="c-41207129">[-]</label><label class="expand" for="c-41207129">[5 more]</label></div><br/><div class="children"><div class="content">A state of the art compiler [1] in quantum computing has not been rewritten in its 8 years of existence. This is accompanied by a quantum computer simulator that runs on the world&#x27;s biggest supercomputers. [2] Multiple quantum computing companies use Common Lisp, and their software was written in a fraction of the time and resources taken for competing companies to do the same in either C++ or Python.<p>Things like Coalton [3] really make Lisp stand out. What other language is able to add Haskell-quality types to their language?<p>Lisp is not popular, so it doesn&#x27;t have as much labor going into it, but for the work that does, remarkable results are achieved. Lisp <i>does</i> have a lot of the dubiously claimed power, but that power still requires reasonable engineering work to achieve—work that a lot of hobbyists are unwilling to do in their free 4 hours on the weekend.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;quil-lang&#x2F;quilc">https:&#x2F;&#x2F;github.com&#x2F;quil-lang&#x2F;quilc</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;quil-lang&#x2F;qvm">https:&#x2F;&#x2F;github.com&#x2F;quil-lang&#x2F;qvm</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;coalton-lang&#x2F;coalton">https:&#x2F;&#x2F;github.com&#x2F;coalton-lang&#x2F;coalton</a></div><br/><div id="41208020" class="c"><input type="checkbox" id="c-41208020" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207129">parent</a><span>|</span><a href="#41207419">next</a><span>|</span><label class="collapse" for="c-41208020">[-]</label><label class="expand" for="c-41208020">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A state of the art compiler [1] in quantum computing<p>&gt; Multiple quantum computing companies use Common Lisp<p>so lisp is a programming language that is next to godliness but until now has only been used to implement a compiler for another programming langauge that targets a computer that doesn&#x27;t exist. is that about right? lol.<p>&gt; This is accompanied by a quantum computer simulator that runs on the world&#x27;s biggest supercomputers<p>do you have any idea how much python runs on those same supercomputers? it&#x27;s probably like 10000 to 1.</div><br/></div></div><div id="41207419" class="c"><input type="checkbox" id="c-41207419" checked=""/><div class="controls bullet"><span class="by">tumdum_</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207129">parent</a><span>|</span><a href="#41208020">prev</a><span>|</span><a href="#41207374">next</a><span>|</span><label class="collapse" for="c-41207419">[-]</label><label class="expand" for="c-41207419">[3 more]</label></div><br/><div class="children"><div class="content">&gt; their software was written in a fraction of the time and resources taken for competing companies to do the same in either C++ or Python.<p>Can you clarify what Python and LISP software (with the same scope) are you referring to?</div><br/><div id="41207440" class="c"><input type="checkbox" id="c-41207440" checked=""/><div class="controls bullet"><span class="by">reikonomusha</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207419">parent</a><span>|</span><a href="#41207374">next</a><span>|</span><label class="collapse" for="c-41207440">[-]</label><label class="expand" for="c-41207440">[2 more]</label></div><br/><div class="children"><div class="content">Lisp software like QUILC (linked) and Python software like Qiskit.<p>They have the role of taking general quantum programs (usually called &quot;quantum circuits&quot;), and translating+optimizing them for a particular quantum computer architecture (i.e., one that might only have a small number of supported quantum operations).<p>It&#x27;s analogous to a language like C having a compiler (written in Lisp or Python) for ARM and x86.</div><br/><div id="41207767" class="c"><input type="checkbox" id="c-41207767" checked=""/><div class="controls bullet"><span class="by">tumdum_</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207440">parent</a><span>|</span><a href="#41207374">next</a><span>|</span><label class="collapse" for="c-41207767">[-]</label><label class="expand" for="c-41207767">[1 more]</label></div><br/><div class="children"><div class="content">How long did it take to develop both (sorry, but quick googling doesn’t make it clear)?</div><br/></div></div></div></div></div></div></div></div><div id="41207374" class="c"><input type="checkbox" id="c-41207374" checked=""/><div class="controls bullet"><span class="by">germandiago</span><span>|</span><a href="#41206866">parent</a><span>|</span><a href="#41207129">prev</a><span>|</span><a href="#41206957">next</a><span>|</span><label class="collapse" for="c-41207374">[-]</label><label class="expand" for="c-41207374">[7 more]</label></div><br/><div class="children"><div class="content">I tried Lisp several times.<p>I really want to like it. Its interactivity is only matched by Smalltalk.<p>What are the problems I found? First, macros are nice. But they are difficult to write and potentially difficult to grasp. I think you should avoid them almost all the time.<p>Also, I found that regular Lisp (yes, I know with macros you can change that) is less readable than Python, for example. I struggle to read math with logic in Lisp (inwards-outwards) way more than left-to-right.<p>Also, the superior interactivity means you have an image. But when I create software I organize things in files, I run them from scratch. In Lisp everything becomes (or tends to become) kind of a stateful environment. It takes more reasoning to reason about current state.<p>I would say that Lisp is good at two things: DSLs and ast manipulation is way easier than in other languages. If you need that, it is nice. Also, highly experimental interactive programming to try ideas is good with this interactivity. However, creating a system where a level of interactivity for your needs can be created is not super difficult, so you can have a very interactive Python env. for example, except that the object system in Lisp is a bit more interactive. But, do you need that?<p>All in all, Lisp is a language I struggle reading, powerful for ast manipulation and DSLs, but the macro&#x2F;DSL parts are what also prevents it from being easily picked-up by teams. In fact, I would forbid macros by default unless carefully approved for &quot;regular&quot; Lisp programming as done in most software products. It can obscure the code quite a bit.<p>I like Clojure, I like Janet lang and I like Lisps for embedding. Also, I do know the power of having a running server and being able to enter and live debugging it, but, is this practical? At the end you want a commit somewhere, a CI pipeline to be run to verify your software, etc. So I am not sure if when programming in Lisp one of the problems I find is that I should change my mindset but I am not successful at it.</div><br/><div id="41208192" class="c"><input type="checkbox" id="c-41208192" checked=""/><div class="controls bullet"><span class="by">homedirectory</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207374">parent</a><span>|</span><a href="#41207824">next</a><span>|</span><label class="collapse" for="c-41208192">[-]</label><label class="expand" for="c-41208192">[1 more]</label></div><br/><div class="children"><div class="content">Your fear of macros is natural, since they are not typical for a programming language. It is expected that a newcomer to Lisp is likely to have a hard time grasping macros.<p>You should not be disregarding one of the most powerful features of Lisp due to a lack of understanding. Imagine if a Haskell programmer rejected typeclasses because they are initially difficult to write and potentially difficult to grasp.<p>If you want a taste of the power of Lisp macros, check out &quot;Monad Macros in Common Lisp&quot; by David Sorokin (<a href="https:&#x2F;&#x2F;cl-monad-macros.common-lisp.dev&#x2F;monad-macros.htm" rel="nofollow">https:&#x2F;&#x2F;cl-monad-macros.common-lisp.dev&#x2F;monad-macros.htm</a>).</div><br/></div></div><div id="41207824" class="c"><input type="checkbox" id="c-41207824" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207374">parent</a><span>|</span><a href="#41208192">prev</a><span>|</span><a href="#41206957">next</a><span>|</span><label class="collapse" for="c-41207824">[-]</label><label class="expand" for="c-41207824">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Also, the superior interactivity means you have an image. But when I create software I organize things in files, I run them from scratch. In Lisp everything becomes (or tends to become) kind of a stateful environment. It takes more reasoning to reason about current state.<p>Interactivity has nothing to do with an &quot;image&quot;. An image is a dump of the memory heap. That&#x27;s a feature found in several, but not all, Lisp implementations. There are Lisp implementation which support image-based development (like Interlisp). But I doubt that you have used that.<p>What many Lisp systems actually often are: they are interactive with a resident language environment. There are many examples for non-Lisp implementations of that idea: APL, BASIC, Prolog, Smalltalk, Python, Ruby, R, ...<p>Still, software in most Lisp projects is organized in files. Something like Common Lisp includes a compiler, which compiles files and a loader which loads files (compiled and source). But the Common Lisp runtime usually includes a compiler and an interpreter and one then can develop the application interactively while it is running. The code is still written in files.<p>&gt; but the macro&#x2F;DSL parts are what also prevents it from being easily picked-up by teams.<p>That&#x27;s a myth. Actually macros are BEST used in teams.<p>Small teams of 5 to 100 people can easily define&#x2F;use language extensions, document them and reuse them in their application software. Larger Lisp software benefits most from macro definitions, since they enable development of portable language extensions incl. embedded domain specific languages, without the need for low-level implementation hacking. -&gt; the result is very compact user level code.</div><br/><div id="41207914" class="c"><input type="checkbox" id="c-41207914" checked=""/><div class="controls bullet"><span class="by">germandiago</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207824">parent</a><span>|</span><a href="#41207933">next</a><span>|</span><label class="collapse" for="c-41207914">[-]</label><label class="expand" for="c-41207914">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Interactivity has nothing to do with an &quot;image&quot;. An image is a dump of the memory heap. That&#x27;s a feature found in several, but not all, Lisp implementations. There are Lisp implementation which support image-based development (like Interlisp). But I doubt that you have used that.<p>Actually I was unconsciously talking about the typical Common Lisp implementations I have used.<p>&gt; Still, software in most Lisp projects is organized in files.<p>Yes, sure, but I am not sure the combination of image, promoting interactive development mixes well with do a git commit and typical CI pipelines. Interactivity encourages a flow where you &quot;instantly see&quot; results and experiment, whereas a compile-edit-runtests follows more naturally with more structure in test cases, etc.<p>Of course they have their uses, and their very useful use cases. But I do think they should not be abused and I also think they should be the last thing to use, when nothing else will work.</div><br/><div id="41207943" class="c"><input type="checkbox" id="c-41207943" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207914">parent</a><span>|</span><a href="#41207933">next</a><span>|</span><label class="collapse" for="c-41207943">[-]</label><label class="expand" for="c-41207943">[1 more]</label></div><br/><div class="children"><div class="content">ECL and ABCL are Common Lisp implementations. They are both interactive and both don&#x27;t use images.<p>Unless one saves and load images, one is not using image-based development. All one is using is the interactive nature of Lisp, via a dialog interface, here a REPL. Lisp uses late binding, which makes it possible to update function definitions in interpreted and compiled software.<p>The base for interactive Lisp development is:<p>* a procedure to read data<p>* a procedure to evaluate data as code: EVAL<p>* printing<p>* a Read &#x2F; Eval &#x2F; Print loop<p>* additionally Lisp provides an incremental compiler and a file compiler<p>* LOAD to load code<p>Still a typical Common Lisp application or library consists of files. ASDF is the moral equivalent of &quot;make&quot; and runs the file compiler. Quicklisp will transfer Lisp software in the form of files to your local machine, compile the files there and load them.<p>So far we have not used &quot;images&quot;. If you check the ANSI Common Lisp standard, there is not a single word about &quot;images&quot; in the standard definition.</div><br/></div></div></div></div><div id="41207933" class="c"><input type="checkbox" id="c-41207933" checked=""/><div class="controls bullet"><span class="by">germandiago</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207824">parent</a><span>|</span><a href="#41207914">prev</a><span>|</span><a href="#41206957">next</a><span>|</span><label class="collapse" for="c-41207933">[-]</label><label class="expand" for="c-41207933">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s a myth. Actually macros are BEST used in teams.<p>When there are some and well-known, yes. Start to develop macros where you do not know how arguments are evaluated or when, half of which you do not know and good luck figuring out how to use and combine things with functions&#x2F;macros in other places.<p>They are totally double-edged and in many occasions more trouble than people would admit bc they fall in love with them and how terse they can look. However, scaling this without additional walls and freely is, in my experience, very difficult.</div><br/><div id="41207988" class="c"><input type="checkbox" id="c-41207988" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207933">parent</a><span>|</span><a href="#41206957">next</a><span>|</span><label class="collapse" for="c-41207988">[-]</label><label class="expand" for="c-41207988">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Start to develop macros where you do not know how arguments are evaluated or when, half of which you do not know and good luck figuring out how to use and combine things with functions&#x2F;macros in other places.<p>I would guess a team would be so clever to develop maintainable macros.<p>In many places it&#x27;s actually the very idea not to know how the thing is evaluated. One writes more descriptive software and does not specify execution details.<p>You can write unmaintainable software in many ways. Macros are a tool for code generation. How to write and use them can be learned, just like people learn to maintain large class libraries in Java.<p>Really, there are many of examples of Lisp code bases which make heavy use of macros and where the code was written by tens to hundreds of people.<p>For example much of the user facing Lisp functionality itself is macros.<p>Something like CLOS has much of its functionality exposed to the programmer as macros, which sit on top of functions and OOP. It&#x27;s a domain specific extension to Common Lisp for OOP.<p>GUI libraries use macros, tools for 3d modeling use macros, ...<p>Whenever groups of people use code, macros are a tool to provide common language extensions. Like any tool, it needs to be learned how to use it.</div><br/></div></div></div></div></div></div></div></div><div id="41206957" class="c"><input type="checkbox" id="c-41206957" checked=""/><div class="controls bullet"><span class="by">smabie</span><span>|</span><a href="#41206866">parent</a><span>|</span><a href="#41207374">prev</a><span>|</span><a href="#41207160">next</a><span>|</span><label class="collapse" for="c-41206957">[-]</label><label class="expand" for="c-41206957">[12 more]</label></div><br/><div class="children"><div class="content">In my experience, it&#x27;s just not that good? I programmed professionally in Lisp (Racket to be specific) for a couple years and while I was initially enthusiastic about it, my enthusiasm for it diminished over time.<p>The heavy line noise in service of an easy to understand macro system just isn&#x27;t worth it (moreover, a lot of languages have advanced macros these days without S-expressions).<p>Looking back, I think I was so into Lisp because I just wanted to feel superior and better than the dirty Java or Python programmers?</div><br/><div id="41207661" class="c"><input type="checkbox" id="c-41207661" checked=""/><div class="controls bullet"><span class="by">ashton314</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41206957">parent</a><span>|</span><a href="#41206996">next</a><span>|</span><label class="collapse" for="c-41207661">[-]</label><label class="expand" for="c-41207661">[1 more]</label></div><br/><div class="children"><div class="content">&gt; easy to use macro system<p>Just curious: what macro system were you using with Racket? There are, like, 3 big ways to build macros in Racket:<p>1. Macros by example with `syntax-rules`. This was taken from Scheme and is the original hygienic-by-construction system. Limited in power though.<p>2. `syntax-case`, which gives you full procedural macros but is a little unwieldy at times.<p>3. `syntax-parse`, the glorious, most powerful macro system of the three.<p>I know, it’s confusing.</div><br/></div></div><div id="41206996" class="c"><input type="checkbox" id="c-41206996" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41206957">parent</a><span>|</span><a href="#41207661">prev</a><span>|</span><a href="#41207160">next</a><span>|</span><label class="collapse" for="c-41206996">[-]</label><label class="expand" for="c-41206996">[10 more]</label></div><br/><div class="children"><div class="content">&gt; Looking back, I think I was so into Lisp because I just wanted to feel superior and better than the dirty Java or Python programmers?<p>tbh, Paul Graham&#x27;s articles on Lisp have done more harm than good to programmers. Calling Lisp a &quot;secret weapon&quot; that supercharges your startup and gives you immense competitive advantage is unrealistic and lacks concrete evidence.</div><br/><div id="41207016" class="c"><input type="checkbox" id="c-41207016" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41206996">parent</a><span>|</span><a href="#41207160">next</a><span>|</span><label class="collapse" for="c-41207016">[-]</label><label class="expand" for="c-41207016">[9 more]</label></div><br/><div class="children"><div class="content">The problem is that those essays were written right after the 1990s when Common Lisp was much more ahead of other languages and when static typing hadn’t yet taken the form that is popular today. Back then, your alternatives were C&#x2F;C++&#x2F;Java&#x2F;Pascal&#x2F;Perl, and Python and Ruby were the novelties that were still much slower than CL and as I understand it had inferior tooling.<p>Since then, the landscape has changed.</div><br/><div id="41207038" class="c"><input type="checkbox" id="c-41207038" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207016">parent</a><span>|</span><a href="#41207160">next</a><span>|</span><label class="collapse" for="c-41207038">[-]</label><label class="expand" for="c-41207038">[8 more]</label></div><br/><div class="children"><div class="content">I agree with this. But CL programmers seem to think Lisp is timeless and its best days are ahead of it still. I wonder if they&#x27;re already awesome programmers and that&#x27;s why they pick Lisp for maximum freedom (macros?). Most people aren&#x27;t wizards, and can&#x27;t (nor do they want to) invent small DSLs on the go.<p>With great power comes great responsibility, and most people don&#x27;t want that responsibility.</div><br/><div id="41207161" class="c"><input type="checkbox" id="c-41207161" checked=""/><div class="controls bullet"><span class="by">reikonomusha</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207038">parent</a><span>|</span><a href="#41207160">next</a><span>|</span><label class="collapse" for="c-41207161">[-]</label><label class="expand" for="c-41207161">[7 more]</label></div><br/><div class="children"><div class="content">I can assure you that most people are not considering Lisp and thinking, &quot;huh, this is too much responsibility, so not for me.&quot;<p>Lisp has a higher barrier to entry compared to Python or Rust or other languages available. For that simple reason alone, it&#x27;s not used. None of these imagined reasons about the theoretical power or anti-power of macros, or being a wizard, or whatever are part of the calculus of choosing a language.</div><br/><div id="41207178" class="c"><input type="checkbox" id="c-41207178" checked=""/><div class="controls bullet"><span class="by">hollerith</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207161">parent</a><span>|</span><a href="#41207160">next</a><span>|</span><label class="collapse" for="c-41207178">[-]</label><label class="expand" for="c-41207178">[6 more]</label></div><br/><div class="children"><div class="content">Learning Lisp has a tricky part, and one of my classmates in undergrad despaired of ever learning it, but surely Rust is harder to learn than Lisp, which makes me wonder what you mean by &quot;Lisp has a higher barrier to entry&quot;.</div><br/><div id="41207197" class="c"><input type="checkbox" id="c-41207197" checked=""/><div class="controls bullet"><span class="by">reikonomusha</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207178">parent</a><span>|</span><a href="#41208047">next</a><span>|</span><label class="collapse" for="c-41207197">[-]</label><label class="expand" for="c-41207197">[4 more]</label></div><br/><div class="children"><div class="content">You have to first install a Lisp compiler whose REPL is so spartan than even using arrow keys causes errors in your terminal. You have to learn Emacs. Figure out wtf SLIME and Paredit are from docs written in piecemeal plaintext READMEs. Then learn from a book that&#x27;s older than you that makes no reference to any of the tools you just labored over installing. Then get a bunch of conflicting information about proper Lisp style from random patches of internet.<p>Who has time for that these days, except for the very determined and dedicated?<p>I think Lisp is a superlative language with excellent tools—once learned. But it hasn&#x27;t had its UI revolution from anybody who cares enough to do the work.</div><br/><div id="41207211" class="c"><input type="checkbox" id="c-41207211" checked=""/><div class="controls bullet"><span class="by">hollerith</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207197">parent</a><span>|</span><a href="#41207416">next</a><span>|</span><label class="collapse" for="c-41207211">[-]</label><label class="expand" for="c-41207211">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been writing Lisp for 40 years, and still haven&#x27;t started using SLIME or Paredit.<p>And the reason it is called &quot;style&quot; is that it is not essential to actually getting things done.</div><br/><div id="41207238" class="c"><input type="checkbox" id="c-41207238" checked=""/><div class="controls bullet"><span class="by">reikonomusha</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207211">parent</a><span>|</span><a href="#41207416">next</a><span>|</span><label class="collapse" for="c-41207238">[-]</label><label class="expand" for="c-41207238">[1 more]</label></div><br/><div class="children"><div class="content">Style is not essential to getting things done, but it&#x27;s essential to building a community and having labor be multiplicative in its impact. Lisp is a language ripe for expressing a personal style, and that&#x27;s antithetical to collaboration in a variety of ways. It can be managed, if the community can rally around a common set of principles.<p>I likewise have written Common Lisp for decades. But I also get paid to do it, manage a team that does it, and see immense value in doing these extra things that hackers don&#x27;t much care for, such as:<p>- making Lisp compatible with other languages through ABIs<p>- developing stylistic guidelines<p>- developing systems for static typing in Lisp to assist long-term development and maintenance of Lisp code<p>- etc.<p>So does style or the lack of any of the aforementioned bullets &quot;block&quot; the ability to &quot;get things done&quot;? Strictly speaking, no, but it inhibits outside interest in your project.</div><br/></div></div></div></div><div id="41207416" class="c"><input type="checkbox" id="c-41207416" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207197">parent</a><span>|</span><a href="#41207211">prev</a><span>|</span><a href="#41208047">next</a><span>|</span><label class="collapse" for="c-41207416">[-]</label><label class="expand" for="c-41207416">[1 more]</label></div><br/><div class="children"><div class="content">IDK why you&#x27;re being downvoted. The things you mentioned are actually true and I&#x27;ve faced them too.</div><br/></div></div></div></div><div id="41208047" class="c"><input type="checkbox" id="c-41208047" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207178">parent</a><span>|</span><a href="#41207197">prev</a><span>|</span><a href="#41207160">next</a><span>|</span><label class="collapse" for="c-41208047">[-]</label><label class="expand" for="c-41208047">[1 more]</label></div><br/><div class="children"><div class="content">Lisp early on exposes its dual nature of code and data. Even in interactive environments. This ever-present meta-level is unusual.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41207160" class="c"><input type="checkbox" id="c-41207160" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#41206866">parent</a><span>|</span><a href="#41206957">prev</a><span>|</span><a href="#41207811">next</a><span>|</span><label class="collapse" for="c-41207160">[-]</label><label class="expand" for="c-41207160">[2 more]</label></div><br/><div class="children"><div class="content">Despite enjoying programming in a LISP - Clojure, I would agree that static typing and programming for the masses as opposed to programming for the ivory-tower hackers has kicked languages like Common LISP to decay in the waste bucket.<p>I wish someone invented a statically typed LISP with great ergonomics, tooling, packaging, modularization and mobile+desktop+WASM support.<p>I also think LISP missed out on data-science and ML - that was one field that LISP vendors had a chance to take the throne, but Python won the game since LISP never bothered to participate.</div><br/><div id="41207179" class="c"><input type="checkbox" id="c-41207179" checked=""/><div class="controls bullet"><span class="by">reikonomusha</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207160">parent</a><span>|</span><a href="#41207811">next</a><span>|</span><label class="collapse" for="c-41207179">[-]</label><label class="expand" for="c-41207179">[1 more]</label></div><br/><div class="children"><div class="content">How about a type system more expressive than Haskell 95, completely interoperable with Lisp? [1]<p>What you suggest exists, but it&#x27;s not the reason people turn away from Lisp. Lower hanging fruit exists. &quot;I have to learn Emacs? No thanks.&quot; itself is an impassé for a vast majority of people who might be a candidate to try Lisp.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;coalton-lang&#x2F;coalton">https:&#x2F;&#x2F;github.com&#x2F;coalton-lang&#x2F;coalton</a></div><br/></div></div></div></div><div id="41207811" class="c"><input type="checkbox" id="c-41207811" checked=""/><div class="controls bullet"><span class="by">exitb</span><span>|</span><a href="#41206866">parent</a><span>|</span><a href="#41207160">prev</a><span>|</span><a href="#41207714">next</a><span>|</span><label class="collapse" for="c-41207811">[-]</label><label class="expand" for="c-41207811">[1 more]</label></div><br/><div class="children"><div class="content">Lisps are considered powerful, as you can easily mold them into new paradigms. That’s not really much of competitive advantage in the real world, where it’s usually better to use boring and dependable tools. Especially since most good features have eventually made their way to mainstream languages.</div><br/></div></div><div id="41207714" class="c"><input type="checkbox" id="c-41207714" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#41206866">parent</a><span>|</span><a href="#41207811">prev</a><span>|</span><a href="#41206876">next</a><span>|</span><label class="collapse" for="c-41207714">[-]</label><label class="expand" for="c-41207714">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;Hacker News later got rewritten entirely in another language&quot;<p>AFAIK Hackernews is still written in Arc.<p>&gt; &quot;Okay, if Lisp is so powerful as you say it is, then give me one example where Lisp is used? More importantly, give me one example where Lisp was used and didn&#x27;t get rewritten in another language later?&quot;, I hear no concrete example given by the Lispers.<p>Maybe the problem are statements like that, which sound a bit like trolling, which people are tired of? There is more than one example of software written in Lisp and still maintained in Lisp.</div><br/></div></div><div id="41206876" class="c"><input type="checkbox" id="c-41206876" checked=""/><div class="controls bullet"><span class="by">DavidSJ</span><span>|</span><a href="#41206866">parent</a><span>|</span><a href="#41207714">prev</a><span>|</span><a href="#41207667">next</a><span>|</span><label class="collapse" for="c-41206876">[-]</label><label class="expand" for="c-41206876">[1 more]</label></div><br/><div class="children"><div class="content">I basically agree with you, but one answer to your challenge is Emacs. However, I’m sure it wouldn’t use anything like Elisp if written anew today.</div><br/></div></div><div id="41207667" class="c"><input type="checkbox" id="c-41207667" checked=""/><div class="controls bullet"><span class="by">influx</span><span>|</span><a href="#41206866">parent</a><span>|</span><a href="#41206876">prev</a><span>|</span><a href="#41208138">next</a><span>|</span><label class="collapse" for="c-41207667">[-]</label><label class="expand" for="c-41207667">[1 more]</label></div><br/><div class="children"><div class="content">I like Lisp, but if it was as powerful as the advocates say it was, they&#x27;d be running circles around everyone else shipping powerful software.  I haven&#x27;t seen many powerful pieces of software in my everyday life that is written in Lisp.</div><br/></div></div><div id="41208138" class="c"><input type="checkbox" id="c-41208138" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#41206866">parent</a><span>|</span><a href="#41207667">prev</a><span>|</span><a href="#41207946">next</a><span>|</span><label class="collapse" for="c-41208138">[-]</label><label class="expand" for="c-41208138">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Every time people ask: &quot;Okay, if Lisp is so powerful as you say it is, then give me one example where Lisp is used?<p>maybe you didn&#x27;t look enough, even on hn, let alone outside it. because, as just one example,<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;ITA_Software" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;ITA_Software</a><p>has been mentioned, maybe  multiple times before, here on HN, in reply to questions such as yours.<p>(it was sold to Google for 700 million a few years later, according to the above page.)<p>another example is by the founder of the very site that we are talking on: hn. it was founded by PG, who also co-founded Viaweb. See<p><a href="https:&#x2F;&#x2F;paulgraham.com&#x2F;avg.html" rel="nofollow">https:&#x2F;&#x2F;paulgraham.com&#x2F;avg.html</a><p>which is another article that has been mentioned many times here on hn.<p>Viaweb was later bought by Yahoo for 40 million, iirc, and became Yahoo Stores &#x2F; 
Shopping.<p>such questions as yours  have come up many times before in the past on hn.<p>so it looks like you might not have read them. you could have used the search function at the bottom of the main hn page.<p>&gt;More importantly, give me one example where Lisp was used and didn&#x27;t get rewritten in another language later?&quot;, I hear no concrete example given by the Lispers.<p>how is this point more important? it may be, but explain why. and again, did you search enough, before asking?<p>(and the argument here is about the power of the language, not about the business issues (like hiring) surrounding it.)<p>I don&#x27;t think it has to be more important.<p>an app getting rewritten in another language could be (and often is) due to non-technical reasons, such as management not understanding the power of lisp, or relative shortage of lisp  programmers. the same kind of things happen with clojure, ocaml, etc.</div><br/></div></div><div id="41207946" class="c"><input type="checkbox" id="c-41207946" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41206866">parent</a><span>|</span><a href="#41208138">prev</a><span>|</span><a href="#41206924">next</a><span>|</span><label class="collapse" for="c-41207946">[-]</label><label class="expand" for="c-41207946">[1 more]</label></div><br/><div class="children"><div class="content">We live in a world where people ship browsers with their applications, and use interpreted languages for numerical research.</div><br/></div></div><div id="41206924" class="c"><input type="checkbox" id="c-41206924" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#41206866">parent</a><span>|</span><a href="#41207946">prev</a><span>|</span><a href="#41206912">next</a><span>|</span><label class="collapse" for="c-41206924">[-]</label><label class="expand" for="c-41206924">[3 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;Hacker News later got rewritten entirely in another language&quot;.<p>When did that happen?</div><br/><div id="41207342" class="c"><input type="checkbox" id="c-41207342" checked=""/><div class="controls bullet"><span class="by">mepian</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41206924">parent</a><span>|</span><a href="#41206912">next</a><span>|</span><label class="collapse" for="c-41207342">[-]</label><label class="expand" for="c-41207342">[2 more]</label></div><br/><div class="children"><div class="content">I think behnamoh confused HN with Reddit, which was actually rewritten from Common Lisp to some other language (and the original Common Lisp version is still available in the source code form).</div><br/><div id="41207352" class="c"><input type="checkbox" id="c-41207352" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207342">parent</a><span>|</span><a href="#41206912">next</a><span>|</span><label class="collapse" for="c-41207352">[-]</label><label class="expand" for="c-41207352">[1 more]</label></div><br/><div class="children"><div class="content">That is a <i>very</i> generous interpretation considering the lead in to the claim that I quoted is:<p>&gt; &quot;Hacker News was built in Arc, which is a Lisp&quot;<p>and the follow-on is:<p>&gt; HN is such a simple website by all metrics, and the fact that CL&#x2F;Arc was dropped in favor of another language further confirms my belief that Lisp&#x27;s days in industry are almost over.<p>He gets the right language for HN (Arc, still the language of the site), and not the Reddit language (CL as you point out, which was dropped for Python, and Arc was never used).</div><br/></div></div></div></div></div></div><div id="41206912" class="c"><input type="checkbox" id="c-41206912" checked=""/><div class="controls bullet"><span class="by">massysett</span><span>|</span><a href="#41206866">parent</a><span>|</span><a href="#41206924">prev</a><span>|</span><a href="#41207364">next</a><span>|</span><label class="collapse" for="c-41206912">[-]</label><label class="expand" for="c-41206912">[6 more]</label></div><br/><div class="children"><div class="content">Emacs and Autocad.</div><br/><div id="41207885" class="c"><input type="checkbox" id="c-41207885" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41206912">parent</a><span>|</span><a href="#41207015">next</a><span>|</span><label class="collapse" for="c-41207885">[-]</label><label class="expand" for="c-41207885">[1 more]</label></div><br/><div class="children"><div class="content">AutoLISP is used as the main scripting language for AutoCAD, a popular CAD software used worldwide.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;AutoLISP" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;AutoLISP</a><p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;AutoCAD" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;AutoCAD</a></div><br/></div></div><div id="41207015" class="c"><input type="checkbox" id="c-41207015" checked=""/><div class="controls bullet"><span class="by">tra3</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41206912">parent</a><span>|</span><a href="#41207885">prev</a><span>|</span><a href="#41206935">next</a><span>|</span><label class="collapse" for="c-41207015">[-]</label><label class="expand" for="c-41207015">[1 more]</label></div><br/><div class="children"><div class="content">Been writing elisp in Emacs for a couple of years now.<p>Emacs is an amazing piece of software and its heyday lisp was revolutionary. These days though I don’t see what it offers over other general purpose languages.</div><br/></div></div><div id="41206935" class="c"><input type="checkbox" id="c-41206935" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41206912">parent</a><span>|</span><a href="#41207015">prev</a><span>|</span><a href="#41207364">next</a><span>|</span><label class="collapse" for="c-41206935">[-]</label><label class="expand" for="c-41206935">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Emacs<p>But that&#x27;s a software made in Lisp <i>for</i> Lisp. The fact that it also works for other purposes doesn&#x27;t change the fact that it&#x27;s a &quot;technology for the sake of technology&quot; product, not &quot;technology for the sake of goals&quot;.</div><br/><div id="41207864" class="c"><input type="checkbox" id="c-41207864" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41206935">parent</a><span>|</span><a href="#41207606">next</a><span>|</span><label class="collapse" for="c-41207864">[-]</label><label class="expand" for="c-41207864">[1 more]</label></div><br/><div class="children"><div class="content">GNU Emacs wasn&#x27;t written for Lisp. It was developed as an extensible text editor. Its extension language was also the implementation language for a large part of the software. Much of the application domain of GNU Emacs has nothing to do with Lisp. People edit their files with it or integrate with tools.</div><br/></div></div><div id="41207606" class="c"><input type="checkbox" id="c-41207606" checked=""/><div class="controls bullet"><span class="by">diogenesoft</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41206935">parent</a><span>|</span><a href="#41207864">prev</a><span>|</span><a href="#41207364">next</a><span>|</span><label class="collapse" for="c-41207606">[-]</label><label class="expand" for="c-41207606">[1 more]</label></div><br/><div class="children"><div class="content">Not sure this makes any sense. Not sure what emacs does could have been as easily done in other languages.</div><br/></div></div></div></div></div></div><div id="41207364" class="c"><input type="checkbox" id="c-41207364" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#41206866">parent</a><span>|</span><a href="#41206912">prev</a><span>|</span><label class="collapse" for="c-41207364">[-]</label><label class="expand" for="c-41207364">[2 more]</label></div><br/><div class="children"><div class="content">What I find most interesting about this comment of yours is the sour grapes. Can you shed a little light on where your resentment is coming from?<p>I&#x27;m uninclined to make any effort to convince you otherwise until you provide even a hint of a reason why I, or anyone else, should believe you have any willingness whatsoever to allow yourself to be convinced.</div><br/><div id="41207786" class="c"><input type="checkbox" id="c-41207786" checked=""/><div class="controls bullet"><span class="by">suby</span><span>|</span><a href="#41206866">root</a><span>|</span><a href="#41207364">parent</a><span>|</span><label class="collapse" for="c-41207786">[-]</label><label class="expand" for="c-41207786">[1 more]</label></div><br/><div class="children"><div class="content">I think you have to consider that these conversations are taking place in public. When people reply, they&#x27;re not necessarily replying to convince the person they&#x27;re speaking directly to (this is often impossible), but rather to convince the reader.<p>I also didn&#x27;t get the impression that the parent comment was being unreasonable or resentful. Lisp is often portrayed as being special and a secret weapon. It&#x27;s reasonable to question that given how little it ends up being used in comparison.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>