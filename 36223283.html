<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1686128463708" as="style"/><link rel="stylesheet" href="styles.css?v=1686128463708"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://danlark.org/2023/06/06/csinc-the-arm-instruction-you-didnt-know-you-wanted/">“csinc”, the AArch64 instruction you didn’t know you wanted</a> <span class="domain">(<a href="https://danlark.org">danlark.org</a>)</span></div><div class="subtext"><span>jandeboevrie</span> | <span>34 comments</span></div><br/><div><div id="36223911" class="c"><input type="checkbox" id="c-36223911" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#36223697">next</a><span>|</span><label class="collapse" for="c-36223911">[-]</label><label class="expand" for="c-36223911">[5 more]</label></div><br/><div class="children"><div class="content">I discovered a really cool ARM64 trick today. One thing about x86 that I&#x27;ve found useful on so many occasions is the PCMPEQB + PMOVMSKB + BSF trick that lets me scan the bytes of a string 10x faster. I couldn&#x27;t find any information on Google for doing PMOVMSKB with ARM, so I&#x27;ve been studying ARM&#x27;s &quot;Optimized Routines&quot; codebase where I stumbled upon the answer in their strnlen() implementation. It turns out the trick is to use `shrn dst.8b, src.8h, 4` which turns a 128-bit mask into a 64-bit mask. You can then get the string offset index with fmov, rbit, clz and finally shift by 2.</div><br/><div id="36224001" class="c"><input type="checkbox" id="c-36224001" checked=""/><div class="controls bullet"><span class="by">danlark</span><span>|</span><a href="#36223911">parent</a><span>|</span><a href="#36224394">next</a><span>|</span><label class="collapse" for="c-36224001">[-]</label><label class="expand" for="c-36224001">[3 more]</label></div><br/><div class="children"><div class="content">I am the author of this trick as well<p>You can read about it in <a href="https:&#x2F;&#x2F;community.arm.com&#x2F;arm-community-blogs&#x2F;b&#x2F;infrastructure-solutions-blog&#x2F;posts&#x2F;porting-x86-vector-bitmask-optimizations-to-arm-neon" rel="nofollow">https:&#x2F;&#x2F;community.arm.com&#x2F;arm-community-blogs&#x2F;b&#x2F;infrastructu...</a></div><br/><div id="36224267" class="c"><input type="checkbox" id="c-36224267" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#36223911">root</a><span>|</span><a href="#36224001">parent</a><span>|</span><a href="#36224293">next</a><span>|</span><label class="collapse" for="c-36224267">[-]</label><label class="expand" for="c-36224267">[1 more]</label></div><br/><div class="children"><div class="content">Wow. I love your work. Thank you for coming here and talking about it. You could write Hacker&#x27;s Delight 2nd edition for a new generation.</div><br/></div></div><div id="36224293" class="c"><input type="checkbox" id="c-36224293" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#36223911">root</a><span>|</span><a href="#36224001">parent</a><span>|</span><a href="#36224267">prev</a><span>|</span><a href="#36224394">next</a><span>|</span><label class="collapse" for="c-36224293">[-]</label><label class="expand" for="c-36224293">[1 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s add it to ClickHouse: <a href="https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickHouse&#x2F;blob&#x2F;master&#x2F;base&#x2F;base&#x2F;find_symbols.h">https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickHouse&#x2F;blob&#x2F;master&#x2F;base&#x2F;ba...</a><p>It should significantly improve the performance on ARM.</div><br/></div></div></div></div><div id="36224394" class="c"><input type="checkbox" id="c-36224394" checked=""/><div class="controls bullet"><span class="by">camel-cdr</span><span>|</span><a href="#36223911">parent</a><span>|</span><a href="#36224001">prev</a><span>|</span><a href="#36223697">next</a><span>|</span><label class="collapse" for="c-36224394">[-]</label><label class="expand" for="c-36224394">[1 more]</label></div><br/><div class="children"><div class="content">I found the following article about the topic really good: <a href="https:&#x2F;&#x2F;branchfree.org&#x2F;2019&#x2F;04&#x2F;01&#x2F;fitting-my-head-through-the-arm-holes-or-two-sequences-to-substitute-for-the-missing-pmovmskb-instruction-on-arm-neon&#x2F;" rel="nofollow">https:&#x2F;&#x2F;branchfree.org&#x2F;2019&#x2F;04&#x2F;01&#x2F;fitting-my-head-through-th...</a><p>In my experience using a 512 wide movemask (to uint64_t) is the fastest on both x86 and arm64.<p>With rvv you don&#x27;t really what to go from a vector mask to a general purpose non vector register, because the vector length may vary. But I found it really useful that vector masks are always packed into v0. So even with LMUL=8, you can just to a vmseq, switch to LMUL=1 and use vfirst &amp; vmsbf to iterate through all indices.</div><br/></div></div></div></div><div id="36223697" class="c"><input type="checkbox" id="c-36223697" checked=""/><div class="controls bullet"><span class="by">gpvos</span><span>|</span><a href="#36223911">prev</a><span>|</span><a href="#36224065">next</a><span>|</span><label class="collapse" for="c-36223697">[-]</label><label class="expand" for="c-36223697">[1 more]</label></div><br/><div class="children"><div class="content">I am very surprised that this is presented as something new. From the very beginning of ARM, all instructions have had a condition attached to them. Contrary to the article, it has absolutely nothing to do with making the processor more CISCy, but is instead one of its most RISCy aspects.</div><br/></div></div><div id="36224065" class="c"><input type="checkbox" id="c-36224065" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#36223697">prev</a><span>|</span><a href="#36223938">next</a><span>|</span><label class="collapse" for="c-36224065">[-]</label><label class="expand" for="c-36224065">[2 more]</label></div><br/><div class="children"><div class="content">I thought this was interesting, although of course I agree with many commenters&#x27; take that the lack of reference to the &quot;old-school&quot; ARM where everything was conditional is odd.<p>I got curious about how RISC-V handles this, but only curious enough to find [1] and not dig any further. That answer is from a year ago, so perhaps there have been changes.<p>[1]: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;72341794&#x2F;28169" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;72341794&#x2F;28169</a></div><br/><div id="36224438" class="c"><input type="checkbox" id="c-36224438" checked=""/><div class="controls bullet"><span class="by">Findecanor</span><span>|</span><a href="#36224065">parent</a><span>|</span><a href="#36223938">next</a><span>|</span><label class="collapse" for="c-36224438">[-]</label><label class="expand" for="c-36224438">[1 more]</label></div><br/><div class="children"><div class="content">&quot;cmov&quot; and several more interesting instructions in the draft RISC-V Bitmanip proposal were dropped before it reached 1.0 though.<p>There is a new proposal: Zicond, but it is quite crude, with two instructions. The &quot;czero.eqz&quot; instruction does:<p><pre><code>  rd = (rs2 == 0) ? 0 : rs1;
</code></pre>
And the other &quot;czero.nez&quot; tests for &quot;rs2 != 0&quot;. Both are supposed to be result in an operand for another instruction, where a zero operand makes it a nop: for conditional add,sub,xor, etc.
Conditional move, however, takes three instructions: two results where either is zero which get or&#x27;ed together.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;riscv&#x2F;riscv-zicond&#x2F;blob&#x2F;main&#x2F;zicondops.adoc">https:&#x2F;&#x2F;github.com&#x2F;riscv&#x2F;riscv-zicond&#x2F;blob&#x2F;main&#x2F;zicondops.ad...</a></div><br/></div></div></div></div><div id="36223938" class="c"><input type="checkbox" id="c-36223938" checked=""/><div class="controls bullet"><span class="by">franky47</span><span>|</span><a href="#36224065">prev</a><span>|</span><a href="#36224081">next</a><span>|</span><label class="collapse" for="c-36223938">[-]</label><label class="expand" for="c-36223938">[1 more]</label></div><br/><div class="children"><div class="content">Before reading the article, my former DSP engineer brain kicked in and thought: &quot;complex cardinal sine (sinc), why would you want that?&quot;<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sinc_function" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sinc_function</a></div><br/></div></div><div id="36224081" class="c"><input type="checkbox" id="c-36224081" checked=""/><div class="controls bullet"><span class="by">t8sr</span><span>|</span><a href="#36223938">prev</a><span>|</span><a href="#36223887">next</a><span>|</span><label class="collapse" for="c-36224081">[-]</label><label class="expand" for="c-36224081">[2 more]</label></div><br/><div class="children"><div class="content">The while loop in the third paragraph is easier to read in assembly than in the original C++, which either says something about how well chosen the instruction set is, or about how bad some of C++ is.</div><br/><div id="36224489" class="c"><input type="checkbox" id="c-36224489" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#36224081">parent</a><span>|</span><a href="#36223887">next</a><span>|</span><label class="collapse" for="c-36224489">[-]</label><label class="expand" for="c-36224489">[1 more]</label></div><br/><div class="children"><div class="content">Nothing to do with C++ - it&#x27;s a plain C code as a matter of fact but that&#x27;s not important at all. What the code does is that it employs low-level intrinsic knowledge about the CPU microarchitecture (x86-64) and compiler codegen ability (clang) so that they can pack as many instructions per cycle as they can so that the resulting (de)compression speed is improved. You cannot write such piece of code so that it looks &quot;beautiful&quot; to an average Joe.</div><br/></div></div></div></div><div id="36223887" class="c"><input type="checkbox" id="c-36223887" checked=""/><div class="controls bullet"><span class="by">TekMol</span><span>|</span><a href="#36224081">prev</a><span>|</span><a href="#36223685">next</a><span>|</span><label class="collapse" for="c-36223887">[-]</label><label class="expand" for="c-36223887">[14 more]</label></div><br/><div class="children"><div class="content">How does software these days target all the different CPUs with different instructions?<p>If I download, say, debian-11.7.0-amd64-netinst.iso - does it somehow dynamically adapt to all the different AMD and Intel CPUs and uses the instructions available on the users machine?</div><br/><div id="36224131" class="c"><input type="checkbox" id="c-36224131" checked=""/><div class="controls bullet"><span class="by">r2vcap</span><span>|</span><a href="#36223887">parent</a><span>|</span><a href="#36224030">next</a><span>|</span><label class="collapse" for="c-36224131">[-]</label><label class="expand" for="c-36224131">[1 more]</label></div><br/><div class="children"><div class="content">In many cases, multiple implementations are included and one is chosen to utilize the best instruction supported by the CPU.  Example code: <a href="https:&#x2F;&#x2F;source.chromium.org&#x2F;chromium&#x2F;chromium&#x2F;src&#x2F;+&#x2F;main:third_party&#x2F;libyuv&#x2F;source&#x2F;scale.cc;drc=d14bd701c83375a982fe9e237a71cc06bef056e7;l=62" rel="nofollow">https:&#x2F;&#x2F;source.chromium.org&#x2F;chromium&#x2F;chromium&#x2F;src&#x2F;+&#x2F;main:thi...</a></div><br/></div></div><div id="36224030" class="c"><input type="checkbox" id="c-36224030" checked=""/><div class="controls bullet"><span class="by">aleden</span><span>|</span><a href="#36223887">parent</a><span>|</span><a href="#36224131">prev</a><span>|</span><a href="#36223899">next</a><span>|</span><label class="collapse" for="c-36224030">[-]</label><label class="expand" for="c-36224030">[1 more]</label></div><br/><div class="children"><div class="content">IFunc relocations are how glibc dynamically chooses the best memcpy routine to use at runtime based on the CPU.<p>see <a href="https:&#x2F;&#x2F;github.com&#x2F;bminor&#x2F;glibc&#x2F;blob&#x2F;glibc-2.31&#x2F;sysdeps&#x2F;x86_64&#x2F;multiarch&#x2F;ifunc-memmove.h#L40">https:&#x2F;&#x2F;github.com&#x2F;bminor&#x2F;glibc&#x2F;blob&#x2F;glibc-2.31&#x2F;sysdeps&#x2F;x86_...</a></div><br/></div></div><div id="36223899" class="c"><input type="checkbox" id="c-36223899" checked=""/><div class="controls bullet"><span class="by">bruce343434</span><span>|</span><a href="#36223887">parent</a><span>|</span><a href="#36224030">prev</a><span>|</span><a href="#36224275">next</a><span>|</span><label class="collapse" for="c-36223899">[-]</label><label class="expand" for="c-36223899">[7 more]</label></div><br/><div class="children"><div class="content">Software compiled to be &quot;portable&quot; uses a reduced subset. You actually have to bully GCC into using the full CPU instruction set with -march=native (you can also put another target CPU arch there).<p>In short, distributed binaries tend to use &quot;least common denominator&quot; instructions.<p>I believe one of the pros touted of Gentoo, where everything is compiled locally, is that all the software uses the CPU to it&#x27;s fullest potential.</div><br/><div id="36223992" class="c"><input type="checkbox" id="c-36223992" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#36223887">root</a><span>|</span><a href="#36223899">parent</a><span>|</span><a href="#36224010">next</a><span>|</span><label class="collapse" for="c-36223992">[-]</label><label class="expand" for="c-36223992">[1 more]</label></div><br/><div class="children"><div class="content">You can also dispatch at runtime based on CPUID (x86) or getauxval(AT_HWCAP) for ARM. Also Clang and GCC seem to be moving in the direction of removing -march=native which is sad since grokking all the different microarchitectures isn&#x27;t easy.</div><br/></div></div><div id="36224010" class="c"><input type="checkbox" id="c-36224010" checked=""/><div class="controls bullet"><span class="by">ZiiS</span><span>|</span><a href="#36223887">root</a><span>|</span><a href="#36223899">parent</a><span>|</span><a href="#36223992">prev</a><span>|</span><a href="#36223937">next</a><span>|</span><label class="collapse" for="c-36224010">[-]</label><label class="expand" for="c-36224010">[1 more]</label></div><br/><div class="children"><div class="content">Lots of speed sensitive programs also ship multiple implementations they can choose at run time so they can more fully utilize a CPU without recompiling.</div><br/></div></div><div id="36223937" class="c"><input type="checkbox" id="c-36223937" checked=""/><div class="controls bullet"><span class="by">TekMol</span><span>|</span><a href="#36223887">root</a><span>|</span><a href="#36223899">parent</a><span>|</span><a href="#36224010">prev</a><span>|</span><a href="#36224275">next</a><span>|</span><label class="collapse" for="c-36223937">[-]</label><label class="expand" for="c-36223937">[4 more]</label></div><br/><div class="children"><div class="content">Afaik, Debian runs on the 386? And I think that came out in the 80s?<p>So all new CPU instructions of the last 40 years are pretty much used by nobody?</div><br/><div id="36223966" class="c"><input type="checkbox" id="c-36223966" checked=""/><div class="controls bullet"><span class="by">stephen_g</span><span>|</span><a href="#36223887">root</a><span>|</span><a href="#36223937">parent</a><span>|</span><a href="#36224230">next</a><span>|</span><label class="collapse" for="c-36223966">[-]</label><label class="expand" for="c-36223966">[1 more]</label></div><br/><div class="children"><div class="content">No, according to this [1], Debian&#x27;s i386 architecture dropped support for the 386 and 486 in versions <i>Sarge</i> and <i>Squeeze</i> respectively. Pretty amazing that it did work on the first Pentium (released 1993!) up to 2018. In Debian version after <i>Jessie</i> the Pentium (i586) has been dropped too [2].<p>Of course, I don&#x27;t think many people are using i386 builds anymore - most people would have switched to the more modern x86_64 long ago.<p>1. <a href="https:&#x2F;&#x2F;www.debian.org&#x2F;releases&#x2F;jessie&#x2F;i386&#x2F;ch02s01.html.en" rel="nofollow">https:&#x2F;&#x2F;www.debian.org&#x2F;releases&#x2F;jessie&#x2F;i386&#x2F;ch02s01.html.en</a><p>2. <a href="https:&#x2F;&#x2F;www.debian.org&#x2F;releases&#x2F;stretch&#x2F;i386&#x2F;ch02s01.html.en" rel="nofollow">https:&#x2F;&#x2F;www.debian.org&#x2F;releases&#x2F;stretch&#x2F;i386&#x2F;ch02s01.html.en</a></div><br/></div></div><div id="36224230" class="c"><input type="checkbox" id="c-36224230" checked=""/><div class="controls bullet"><span class="by">pjc50</span><span>|</span><a href="#36223887">root</a><span>|</span><a href="#36223937">parent</a><span>|</span><a href="#36223966">prev</a><span>|</span><a href="#36224024">next</a><span>|</span><label class="collapse" for="c-36224230">[-]</label><label class="expand" for="c-36224230">[1 more]</label></div><br/><div class="children"><div class="content">The dirty secret is: yes, many of the new instructions aren&#x27;t used very often. They only come into play in certain cases: encryption, signal processing, CPU graphics (e.g. paint packages), video&#x2F;jpeg decoding (when not done on GPU) and so on, most of which are packaged inside libraries which may or may not have multi-CPU implementations.</div><br/></div></div><div id="36224024" class="c"><input type="checkbox" id="c-36224024" checked=""/><div class="controls bullet"><span class="by">Arnt</span><span>|</span><a href="#36223887">root</a><span>|</span><a href="#36223937">parent</a><span>|</span><a href="#36224230">prev</a><span>|</span><a href="#36224275">next</a><span>|</span><label class="collapse" for="c-36224024">[-]</label><label class="expand" for="c-36224024">[1 more]</label></div><br/><div class="children"><div class="content">The new instructions are used often or seldom depending on whether you count invocations or occurences.<p>There are new instructions that can be used to write a constant-time SHA-256 hash function. A program that contains megabytes of code, more than a million instructions, may reasonably contain only a few of those instructions, because it contains only one or two small hash functions. The instructions are important and effective, but occur only a handful of times among a million instructions.</div><br/></div></div></div></div></div></div><div id="36224275" class="c"><input type="checkbox" id="c-36224275" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#36223887">parent</a><span>|</span><a href="#36223899">prev</a><span>|</span><a href="#36223915">next</a><span>|</span><label class="collapse" for="c-36224275">[-]</label><label class="expand" for="c-36224275">[1 more]</label></div><br/><div class="children"><div class="content">Runtime CPU dispatching: <a href="https:&#x2F;&#x2F;maksimkita.com&#x2F;blog&#x2F;cpu-dispatch-in-clickhouse.html" rel="nofollow">https:&#x2F;&#x2F;maksimkita.com&#x2F;blog&#x2F;cpu-dispatch-in-clickhouse.html</a></div><br/></div></div><div id="36223915" class="c"><input type="checkbox" id="c-36223915" checked=""/><div class="controls bullet"><span class="by">lnx01</span><span>|</span><a href="#36223887">parent</a><span>|</span><a href="#36224275">prev</a><span>|</span><a href="#36223685">next</a><span>|</span><label class="collapse" for="c-36223915">[-]</label><label class="expand" for="c-36223915">[3 more]</label></div><br/><div class="children"><div class="content">Compiler flags. You turn on&#x2F;off compiler optimisations for target architectures that are aware of all the instruction-set specific hardware level optimisations.</div><br/><div id="36223943" class="c"><input type="checkbox" id="c-36223943" checked=""/><div class="controls bullet"><span class="by">TekMol</span><span>|</span><a href="#36223887">root</a><span>|</span><a href="#36223915">parent</a><span>|</span><a href="#36223685">next</a><span>|</span><label class="collapse" for="c-36223943">[-]</label><label class="expand" for="c-36223943">[2 more]</label></div><br/><div class="children"><div class="content">But I&#x27;m not compiling. And neither are 99.9% of other software users.</div><br/><div id="36224182" class="c"><input type="checkbox" id="c-36224182" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36223887">root</a><span>|</span><a href="#36223943">parent</a><span>|</span><a href="#36223685">next</a><span>|</span><label class="collapse" for="c-36224182">[-]</label><label class="expand" for="c-36224182">[1 more]</label></div><br/><div class="children"><div class="content">Hence why JITs have some advantages when shipping software, at the cost of a few extra MBs.</div><br/></div></div></div></div></div></div></div></div><div id="36223685" class="c"><input type="checkbox" id="c-36223685" checked=""/><div class="controls bullet"><span class="by">mpweiher</span><span>|</span><a href="#36223887">prev</a><span>|</span><a href="#36223858">next</a><span>|</span><label class="collapse" for="c-36223685">[-]</label><label class="expand" for="c-36223685">[2 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t this be the ideal instruction for implementing multi-word arithmetic?  If the carry flag is set from the previous (lower order) addition, increase the next word up by one and continue adding.<p>And of course ARM 32 had conditional execution for <i>all</i> instructions.  These appear the variants that were useful enough to keep around when the general feature was removed from aarch64</div><br/><div id="36223849" class="c"><input type="checkbox" id="c-36223849" checked=""/><div class="controls bullet"><span class="by">gpvos</span><span>|</span><a href="#36223685">parent</a><span>|</span><a href="#36223858">next</a><span>|</span><label class="collapse" for="c-36223849">[-]</label><label class="expand" for="c-36223849">[1 more]</label></div><br/><div class="children"><div class="content">ARM has both add-with-carry and add-without-carry instructions, a separate increment is not necessary. (I don&#x27;t know much about AArch64, only ancient ARM2&#x2F;3, but I expect they left this in).</div><br/></div></div></div></div><div id="36223858" class="c"><input type="checkbox" id="c-36223858" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#36223685">prev</a><span>|</span><a href="#36223629">next</a><span>|</span><label class="collapse" for="c-36223858">[-]</label><label class="expand" for="c-36223858">[1 more]</label></div><br/><div class="children"><div class="content">So, a very useful and versatile instruction. Glad AArch64 got it.</div><br/></div></div><div id="36223629" class="c"><input type="checkbox" id="c-36223629" checked=""/><div class="controls bullet"><span class="by">thriftwy</span><span>|</span><a href="#36223858">prev</a><span>|</span><label class="collapse" for="c-36223629">[-]</label><label class="expand" for="c-36223629">[5 more]</label></div><br/><div class="children"><div class="content">ARM was supposed to be RISC but this sounds BISC - baroque instructions set computer.</div><br/><div id="36223987" class="c"><input type="checkbox" id="c-36223987" checked=""/><div class="controls bullet"><span class="by">Arnt</span><span>|</span><a href="#36223629">parent</a><span>|</span><label class="collapse" for="c-36223987">[-]</label><label class="expand" for="c-36223987">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;ve no idea.<p>The ARM has lots of instructions, each fairly simple. Compare this to an architecture where a single instruction can ① compute the address of its operands in main memory, ② read them, ③ carry out its main operation and eventually ④ write the result to main memory, with most of those steps optional and depending on the arguments supplied.</div><br/><div id="36224022" class="c"><input type="checkbox" id="c-36224022" checked=""/><div class="controls bullet"><span class="by">thriftwy</span><span>|</span><a href="#36223629">root</a><span>|</span><a href="#36223987">parent</a><span>|</span><label class="collapse" for="c-36224022">[-]</label><label class="expand" for="c-36224022">[3 more]</label></div><br/><div class="children"><div class="content">CSINC and even CMOVBL do not sound &quot;fairly simple&quot;.<p>Maybe it is because the mental model of higher level programmer - for an application programmer, anything that involves writing and reading main memory directly is considered simple, whereas combining a conditional, an increment and a write in a single op sounds &quot;not simple&quot;.</div><br/><div id="36224218" class="c"><input type="checkbox" id="c-36224218" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#36223629">root</a><span>|</span><a href="#36224022">parent</a><span>|</span><a href="#36224107">next</a><span>|</span><label class="collapse" for="c-36224218">[-]</label><label class="expand" for="c-36224218">[1 more]</label></div><br/><div class="children"><div class="content">FWIW, the original ARM CPU from 1985 (which was a very &#x27;pure&#x27; RISC implementation) already could execute each instruction conditionally, the condition bit mask was just part of the regular opcode structure:<p><a href="https:&#x2F;&#x2F;en.wikichip.org&#x2F;wiki&#x2F;arm&#x2F;armv1" rel="nofollow">https:&#x2F;&#x2F;en.wikichip.org&#x2F;wiki&#x2F;arm&#x2F;armv1</a></div><br/></div></div><div id="36224107" class="c"><input type="checkbox" id="c-36224107" checked=""/><div class="controls bullet"><span class="by">Arnt</span><span>|</span><a href="#36223629">root</a><span>|</span><a href="#36224022">parent</a><span>|</span><a href="#36224218">prev</a><span>|</span><label class="collapse" for="c-36224107">[-]</label><label class="expand" for="c-36224107">[1 more]</label></div><br/><div class="children"><div class="content">Modern CPUs often keep a hundred instructions in flight, and accessing main memory once can take more time than a hundred simple instructions. Accessing main memory involves cache coherency protocol logic with neighbouring cores, and it may involve locking if the program wants a read barrier, a write barrier or any kind of volatile variable.<p>Instructions like CMOVBL involve only a small number of CPU registers, nothing else, and can&#x27;t interact with instructions far ahead or behind them in the instruction stream, or with other cores&#x2F;threads at all. Very little state. They&#x27;re simple to reason about, both for the compiler authors, the CPU and the poor developer who&#x27;s chasing a threading bug.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>