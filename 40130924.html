<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713949264676" as="style"/><link rel="stylesheet" href="styles.css?v=1713949264676"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://leanprover-community.github.io/con-nf//">New Foundations is consistent – a difficult mathematical proof proved using Lean</a> <span class="domain">(<a href="https://leanprover-community.github.io">leanprover-community.github.io</a>)</span></div><div class="subtext"><span>namanyayg</span> | <span>113 comments</span></div><br/><div><div id="40134859" class="c"><input type="checkbox" id="c-40134859" checked=""/><div class="controls bullet"><span class="by">randallholmes</span><span>|</span><a href="#40132370">next</a><span>|</span><label class="collapse" for="c-40134859">[-]</label><label class="expand" for="c-40134859">[28 more]</label></div><br/><div class="children"><div class="content">I would say that there is very little danger of a proof in Lean being incorrect.<p>There is a serious danger, which has nothing to do with bugs in Lean, which is a known problem for software verification and also applies in math:  one must read the conclusions carefully to make sure that the right thing is actually proved.<p>I read Wilshaw&#x27;s final conclusions carefully, and she did indeed prove what needed to be proved.</div><br/><div id="40135419" class="c"><input type="checkbox" id="c-40135419" checked=""/><div class="controls bullet"><span class="by">btilly</span><span>|</span><a href="#40134859">parent</a><span>|</span><a href="#40134938">next</a><span>|</span><label class="collapse" for="c-40135419">[-]</label><label class="expand" for="c-40135419">[13 more]</label></div><br/><div class="children"><div class="content">The paper makes a similar point like this:<p><i>Every definition and theorem in mathlib and this project have been checked by Lean’s trusted kernel, which computationally verifies that the proofs we have constructed are indeed correct. However, Lean cannot check that the statements of the definitions and theorems match their intended English equivalents, so when drawing conclusions from the code in this project, translation to and from English must be done with care.</i></div><br/><div id="40137895" class="c"><input type="checkbox" id="c-40137895" checked=""/><div class="controls bullet"><span class="by">amw-zero</span><span>|</span><a href="#40134859">root</a><span>|</span><a href="#40135419">parent</a><span>|</span><a href="#40134938">next</a><span>|</span><label class="collapse" for="c-40137895">[-]</label><label class="expand" for="c-40137895">[12 more]</label></div><br/><div class="children"><div class="content">This is precisely why humans will always be involved with creating software.</div><br/><div id="40138609" class="c"><input type="checkbox" id="c-40138609" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40134859">root</a><span>|</span><a href="#40137895">parent</a><span>|</span><a href="#40140455">next</a><span>|</span><label class="collapse" for="c-40138609">[-]</label><label class="expand" for="c-40138609">[8 more]</label></div><br/><div class="children"><div class="content">LLMs already write English better than most native speakers. I wouldn&#x27;t bet everything on this.</div><br/><div id="40140465" class="c"><input type="checkbox" id="c-40140465" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#40134859">root</a><span>|</span><a href="#40138609">parent</a><span>|</span><a href="#40141571">next</a><span>|</span><label class="collapse" for="c-40140465">[-]</label><label class="expand" for="c-40140465">[5 more]</label></div><br/><div class="children"><div class="content">Do you trust LLM so much that you don&#x27;t check what it writes before sending the email?<p>LLMs can write better English, but the curating step is still critical, because it also produces a lot of garbage.</div><br/><div id="40140571" class="c"><input type="checkbox" id="c-40140571" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40134859">root</a><span>|</span><a href="#40140465">parent</a><span>|</span><a href="#40141571">next</a><span>|</span><label class="collapse" for="c-40140571">[-]</label><label class="expand" for="c-40140571">[4 more]</label></div><br/><div class="children"><div class="content">Would you trust a brand new assistant to write up an email for you without proof reading it? How much training would they require before you didn&#x27;t need that step? How much training &#x2F; fine-tuning would an LLM need? What about the next gen LLM?<p>Remember, we&#x27;re not talking about a static target here, and the post I replied to set no qualifications on the claim that a human will always be needed to check that a mathematical definitions in the proof match the English equivalents. That&#x27;s a long timeline on a rapidly moving target that is, as I said, already seems to be better than most humans at understanding and writing English.</div><br/><div id="40140626" class="c"><input type="checkbox" id="c-40140626" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#40134859">root</a><span>|</span><a href="#40140571">parent</a><span>|</span><a href="#40141163">next</a><span>|</span><label class="collapse" for="c-40140626">[-]</label><label class="expand" for="c-40140626">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Would you trust a brand new assistant to write up an email for you without proof reading it?<p>Depends on the complexity, but for the simpler things I think I could get confident in a day or so. For more complex things, it might take longer to assess their ability.<p>But I&#x27;m not going to trust LLM blindly for anything.<p>&gt; I replied to set no qualifications on the claim that a human will always be needed to check that a mathematical definitions in the proof match the English equivalents.<p>I don&#x27;t defend this strong claim and limit my answer to LLMs (and mostly just state of the art). OTOH I believe that trust will continue to be a big topic for any future AI tech.</div><br/></div></div><div id="40141163" class="c"><input type="checkbox" id="c-40141163" checked=""/><div class="controls bullet"><span class="by">hyperthesis</span><span>|</span><a href="#40134859">root</a><span>|</span><a href="#40140571">parent</a><span>|</span><a href="#40140626">prev</a><span>|</span><a href="#40141571">next</a><span>|</span><label class="collapse" for="c-40141163">[-]</label><label class="expand" for="c-40141163">[2 more]</label></div><br/><div class="children"><div class="content">It will eventually become as chess is now: AI will check and evaluate human translation to and from English.</div><br/><div id="40141583" class="c"><input type="checkbox" id="c-40141583" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#40134859">root</a><span>|</span><a href="#40141163">parent</a><span>|</span><a href="#40141571">next</a><span>|</span><label class="collapse" for="c-40141583">[-]</label><label class="expand" for="c-40141583">[1 more]</label></div><br/><div class="children"><div class="content">And if it says the human got it wrong, then tough luck for the human if they didn&#x27;t. :(</div><br/></div></div></div></div></div></div></div></div><div id="40141571" class="c"><input type="checkbox" id="c-40141571" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#40134859">root</a><span>|</span><a href="#40138609">parent</a><span>|</span><a href="#40140465">prev</a><span>|</span><a href="#40140814">next</a><span>|</span><label class="collapse" for="c-40141571">[-]</label><label class="expand" for="c-40141571">[1 more]</label></div><br/><div class="children"><div class="content">Apart from the whole &quot;generating bullshit&quot; thing, sure.</div><br/></div></div><div id="40140814" class="c"><input type="checkbox" id="c-40140814" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#40134859">root</a><span>|</span><a href="#40138609">parent</a><span>|</span><a href="#40141571">prev</a><span>|</span><a href="#40140455">next</a><span>|</span><label class="collapse" for="c-40140814">[-]</label><label class="expand" for="c-40140814">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>LLMs already write English better than most native speakers...</i><p>till they incorporate more of what some of your writing and loose their advantages</div><br/></div></div></div></div><div id="40140455" class="c"><input type="checkbox" id="c-40140455" checked=""/><div class="controls bullet"><span class="by">rsaarelm</span><span>|</span><a href="#40134859">root</a><span>|</span><a href="#40137895">parent</a><span>|</span><a href="#40138609">prev</a><span>|</span><a href="#40138273">next</a><span>|</span><label class="collapse" for="c-40140455">[-]</label><label class="expand" for="c-40140455">[1 more]</label></div><br/><div class="children"><div class="content">How do you think humans are doing this this if you don&#x27;t think machines can ever do anything similar?</div><br/></div></div><div id="40138273" class="c"><input type="checkbox" id="c-40138273" checked=""/><div class="controls bullet"><span class="by">nathan_compton</span><span>|</span><a href="#40134859">root</a><span>|</span><a href="#40137895">parent</a><span>|</span><a href="#40140455">prev</a><span>|</span><a href="#40134938">next</a><span>|</span><label class="collapse" for="c-40138273">[-]</label><label class="expand" for="c-40138273">[2 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t seem to follow. Why kind computers get better at doing this (anticipating what humans want or whatever) than people? Some people are better at it than others and people are not magic, so I&#x27;d guess at some point computers will get it too.</div><br/><div id="40138698" class="c"><input type="checkbox" id="c-40138698" checked=""/><div class="controls bullet"><span class="by">wolfram74</span><span>|</span><a href="#40134859">root</a><span>|</span><a href="#40138273">parent</a><span>|</span><a href="#40134938">next</a><span>|</span><label class="collapse" for="c-40138698">[-]</label><label class="expand" for="c-40138698">[1 more]</label></div><br/><div class="children"><div class="content">I think what the parent post is referring to is that clarifying human intention rather axiomatically involves a human at some stage in the process.</div><br/></div></div></div></div></div></div></div></div><div id="40134938" class="c"><input type="checkbox" id="c-40134938" checked=""/><div class="controls bullet"><span class="by">randallholmes</span><span>|</span><a href="#40134859">parent</a><span>|</span><a href="#40135419">prev</a><span>|</span><a href="#40136035">next</a><span>|</span><label class="collapse" for="c-40134938">[-]</label><label class="expand" for="c-40134938">[5 more]</label></div><br/><div class="children"><div class="content">The problem I express relates to the issues people mention about libraries:  if a defined concept is used, one has to be sure the definition is correct (i.e., that the right thing has been proved).<p>Wilshaw&#x27;s formalization is not vulnerable to this objection, though libraries were used.  What is proved is that a certain defined concept satisfies a certain suite of formulas of first order logic.  If there is a predicate satisfying that suite of formulas, NF is consistent.</div><br/><div id="40135247" class="c"><input type="checkbox" id="c-40135247" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#40134859">root</a><span>|</span><a href="#40134938">parent</a><span>|</span><a href="#40135041">next</a><span>|</span><label class="collapse" for="c-40135247">[-]</label><label class="expand" for="c-40135247">[1 more]</label></div><br/><div class="children"><div class="content">I am sure you know this, but for the audience: the danger can be mitigated somewhat with a &quot;test suite&quot; of theorems and examples about the definitions. These examples can be very simple (&quot;this particular object, with this particular operation, is a group; this other object is not&quot;) or much more sweeping and general (e.g. fundamental theorems like &quot;all objects with this property are isomorphic&quot; or &quot;all objects with this property embed canonically in this other construction&quot;). It doesn&#x27;t <i>prove</i> that your definitions are correctly capturing what your natural-language proof talks about, but it can help you be more confident.</div><br/></div></div><div id="40135041" class="c"><input type="checkbox" id="c-40135041" checked=""/><div class="controls bullet"><span class="by">randallholmes</span><span>|</span><a href="#40134859">root</a><span>|</span><a href="#40134938">parent</a><span>|</span><a href="#40135247">prev</a><span>|</span><a href="#40136035">next</a><span>|</span><label class="collapse" for="c-40135041">[-]</label><label class="expand" for="c-40135041">[3 more]</label></div><br/><div class="children"><div class="content">and it very much IS an essential part of my confidence in this proof that conversations between me and Sky Wilshaw reveal that she understands my argument  [and was able to point out errors and omissions in paper versions!]<p>human interaction helps create confidence.  But the software is extremely reliable:  a philosophical challenge based on bugs in theorem proving software just is not going to hold water.</div><br/><div id="40135481" class="c"><input type="checkbox" id="c-40135481" checked=""/><div class="controls bullet"><span class="by">pvg</span><span>|</span><a href="#40134859">root</a><span>|</span><a href="#40135041">parent</a><span>|</span><a href="#40135407">next</a><span>|</span><label class="collapse" for="c-40135481">[-]</label><label class="expand" for="c-40135481">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a (small, grey) link that reads &#x27;edit&#x27; among the links at the top of each comment you can use if you want to change or add something to a comment you&#x27;ve already written, if you prefer that to replying to yourself.</div><br/></div></div></div></div></div></div><div id="40136035" class="c"><input type="checkbox" id="c-40136035" checked=""/><div class="controls bullet"><span class="by">jpt4</span><span>|</span><a href="#40134859">parent</a><span>|</span><a href="#40134938">prev</a><span>|</span><a href="#40139822">next</a><span>|</span><label class="collapse" for="c-40136035">[-]</label><label class="expand" for="c-40136035">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Every definition and theorem in mathlib and this project have been checked by Lean’s trusted kernel, which computationally verifies that the proofs we have constructed are indeed correct.<p>From a foundational perspective, it is also important to note that this proof is one of equiconsistency between NF and the Lean kernel, which itself is handchecked. Mechanized theorem provers preserve that level of correctness imputed to them via outside injection, from humans or other out-of-band systems.</div><br/><div id="40140871" class="c"><input type="checkbox" id="c-40140871" checked=""/><div class="controls bullet"><span class="by">randallholmes</span><span>|</span><a href="#40134859">root</a><span>|</span><a href="#40136035">parent</a><span>|</span><a href="#40139822">next</a><span>|</span><label class="collapse" for="c-40140871">[-]</label><label class="expand" for="c-40140871">[1 more]</label></div><br/><div class="children"><div class="content">It certainly isnt a proof of equiconsistency between NF and the Lean kernel.  The theory implemented in the Lean kernel is considerably stronger than NF.</div><br/></div></div></div></div><div id="40139822" class="c"><input type="checkbox" id="c-40139822" checked=""/><div class="controls bullet"><span class="by">Strilanc</span><span>|</span><a href="#40134859">parent</a><span>|</span><a href="#40136035">prev</a><span>|</span><a href="#40139200">next</a><span>|</span><label class="collapse" for="c-40139822">[-]</label><label class="expand" for="c-40139822">[3 more]</label></div><br/><div class="children"><div class="content">Another danger is some sort of bug in Lean itself. This isn&#x27;t unprecedented in theorem provers [1][2]. These might be hard to hit by accident... but there are larger and larger collaborations where arbitrarily people fill in steps (like [3]). Someone trolling one of these efforts by filling a step in using a bug they found might become worth worrying about.<p>[1]: <a href="https:&#x2F;&#x2F;inutile.club&#x2F;estatis&#x2F;falso&#x2F;" rel="nofollow">https:&#x2F;&#x2F;inutile.club&#x2F;estatis&#x2F;falso&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=sv97pXplxf0" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=sv97pXplxf0</a><p>[3]: <a href="https:&#x2F;&#x2F;terrytao.wordpress.com&#x2F;2023&#x2F;11&#x2F;18&#x2F;formalizing-the-proof-of-pfr-in-lean4-using-blueprint-a-short-tour&#x2F;" rel="nofollow">https:&#x2F;&#x2F;terrytao.wordpress.com&#x2F;2023&#x2F;11&#x2F;18&#x2F;formalizing-the-pr...</a></div><br/><div id="40140240" class="c"><input type="checkbox" id="c-40140240" checked=""/><div class="controls bullet"><span class="by">sterlind</span><span>|</span><a href="#40134859">root</a><span>|</span><a href="#40139822">parent</a><span>|</span><a href="#40139200">next</a><span>|</span><label class="collapse" for="c-40140240">[-]</label><label class="expand" for="c-40140240">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s kind of a root of trust problem, isn&#x27;t it? I think the algorithm for checking proofs is relatively simple. All those fancy tactics boil down to a sequence of rewrites of an expression tree, using a small handful of axiomatic rewrite rules.<p>The trusted codebase becomes that checking algorithm, along with the &quot;compiler&quot; that translates the high-level language to term rewriting syntax. Formally verifying that codebase is a rather circular proposition (so to speak), but you could probably bootstrap your way to it from equations on a chalkboard.</div><br/><div id="40141710" class="c"><input type="checkbox" id="c-40141710" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#40134859">root</a><span>|</span><a href="#40140240">parent</a><span>|</span><a href="#40139200">next</a><span>|</span><label class="collapse" for="c-40141710">[-]</label><label class="expand" for="c-40141710">[1 more]</label></div><br/><div class="children"><div class="content">Note also that there is an independent checker <a href="https:&#x2F;&#x2F;github.com&#x2F;leanprover&#x2F;lean4checker">https:&#x2F;&#x2F;github.com&#x2F;leanprover&#x2F;lean4checker</a> to ensure that you&#x27;re not pulling any fancy tricks at the code level: that the compiled output, free of tactics, is in fact a proof.</div><br/></div></div></div></div></div></div><div id="40139200" class="c"><input type="checkbox" id="c-40139200" checked=""/><div class="controls bullet"><span class="by">mckirk</span><span>|</span><a href="#40134859">parent</a><span>|</span><a href="#40139822">prev</a><span>|</span><a href="#40139295">next</a><span>|</span><label class="collapse" for="c-40139200">[-]</label><label class="expand" for="c-40139200">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s always the problem with these pesky computers.<p>They do exactly what you tell them to.</div><br/></div></div><div id="40139295" class="c"><input type="checkbox" id="c-40139295" checked=""/><div class="controls bullet"><span class="by">sn41</span><span>|</span><a href="#40134859">parent</a><span>|</span><a href="#40139200">prev</a><span>|</span><a href="#40138924">next</a><span>|</span><label class="collapse" for="c-40139295">[-]</label><label class="expand" for="c-40139295">[1 more]</label></div><br/><div class="children"><div class="content">Congratulations on the verification of your proof! It must be great to have your research life&#x27;s crowning work being formally confirmed! Also a great victory for the new foundations of Quine.</div><br/></div></div><div id="40138924" class="c"><input type="checkbox" id="c-40138924" checked=""/><div class="controls bullet"><span class="by">spindle</span><span>|</span><a href="#40134859">parent</a><span>|</span><a href="#40139295">prev</a><span>|</span><a href="#40137862">next</a><span>|</span><label class="collapse" for="c-40138924">[-]</label><label class="expand" for="c-40138924">[1 more]</label></div><br/><div class="children"><div class="content">Many congratulations on being formally proved right, Randall!</div><br/></div></div><div id="40137862" class="c"><input type="checkbox" id="c-40137862" checked=""/><div class="controls bullet"><span class="by">amw-zero</span><span>|</span><a href="#40134859">parent</a><span>|</span><a href="#40138924">prev</a><span>|</span><a href="#40132370">next</a><span>|</span><label class="collapse" for="c-40137862">[-]</label><label class="expand" for="c-40137862">[1 more]</label></div><br/><div class="children"><div class="content">This is why specification is much more important than verification &#x2F; proof. We are bound by how accurate we make our propositions.</div><br/></div></div></div></div><div id="40132370" class="c"><input type="checkbox" id="c-40132370" checked=""/><div class="controls bullet"><span class="by">cwzwarich</span><span>|</span><a href="#40134859">prev</a><span>|</span><a href="#40140894">next</a><span>|</span><label class="collapse" for="c-40132370">[-]</label><label class="expand" for="c-40132370">[15 more]</label></div><br/><div class="children"><div class="content">If I’m not mistaken, this is the first use of a proof assistant to settle the status of a difficult proof that had been sitting in limbo for years. There were some previous projects (e.g. the Four Color Theorem in Coq) that validated existing proofs with a large computational element handled by untrusted software, but I think this is the first one where the epistemological status of the result was uncertain in the larger mathematical community.</div><br/><div id="40132714" class="c"><input type="checkbox" id="c-40132714" checked=""/><div class="controls bullet"><span class="by">hiker</span><span>|</span><a href="#40132370">parent</a><span>|</span><a href="#40134658">next</a><span>|</span><label class="collapse" for="c-40132714">[-]</label><label class="expand" for="c-40132714">[2 more]</label></div><br/><div class="children"><div class="content">Liquid Tensor Experiment also comes to mind:<p><a href="https:&#x2F;&#x2F;www.nature.com&#x2F;articles&#x2F;d41586-021-01627-2" rel="nofollow">https:&#x2F;&#x2F;www.nature.com&#x2F;articles&#x2F;d41586-021-01627-2</a><p><a href="https:&#x2F;&#x2F;leanprover-community.github.io&#x2F;blog&#x2F;posts&#x2F;lte-final&#x2F;" rel="nofollow">https:&#x2F;&#x2F;leanprover-community.github.io&#x2F;blog&#x2F;posts&#x2F;lte-final&#x2F;</a></div><br/><div id="40136340" class="c"><input type="checkbox" id="c-40136340" checked=""/><div class="controls bullet"><span class="by">Davidzheng</span><span>|</span><a href="#40132370">root</a><span>|</span><a href="#40132714">parent</a><span>|</span><a href="#40134658">next</a><span>|</span><label class="collapse" for="c-40136340">[-]</label><label class="expand" for="c-40136340">[1 more]</label></div><br/><div class="children"><div class="content">Disagree. That one was not in question for years. Only Peter Scholze proved it and said he&#x27;s not completely sure</div><br/></div></div></div></div><div id="40134658" class="c"><input type="checkbox" id="c-40134658" checked=""/><div class="controls bullet"><span class="by">OscarCunningham</span><span>|</span><a href="#40132370">parent</a><span>|</span><a href="#40132714">prev</a><span>|</span><a href="#40132529">next</a><span>|</span><label class="collapse" for="c-40134658">[-]</label><label class="expand" for="c-40134658">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a similar situation to the Kepler Conjecture (<a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Kepler_conjecture" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Kepler_conjecture</a>). The proof was already known, but people weren&#x27;t sure it was correct until it was formalised.</div><br/></div></div><div id="40132529" class="c"><input type="checkbox" id="c-40132529" checked=""/><div class="controls bullet"><span class="by">isaacfrond</span><span>|</span><a href="#40132370">parent</a><span>|</span><a href="#40134658">prev</a><span>|</span><a href="#40140894">next</a><span>|</span><label class="collapse" for="c-40132529">[-]</label><label class="expand" for="c-40132529">[11 more]</label></div><br/><div class="children"><div class="content">Next up the abc-conjecture!<p>Claimed to be proven in 2012, and to 400+ page paper is online. But I don&#x27;t many accept the proof.</div><br/><div id="40132875" class="c"><input type="checkbox" id="c-40132875" checked=""/><div class="controls bullet"><span class="by">nicklecompte</span><span>|</span><a href="#40132370">root</a><span>|</span><a href="#40132529">parent</a><span>|</span><a href="#40133707">next</a><span>|</span><label class="collapse" for="c-40132875">[-]</label><label class="expand" for="c-40132875">[3 more]</label></div><br/><div class="children"><div class="content">There is a major difference though: Holmes&#x27;s proof was broadly <i>comprehensible</i>, just extremely complicated and easy to get lost in the details. In particular Holmes really tries to make the reader understand, with a fairly gentle&#x2F;apologetic introduction.<p>But Mochizuki&#x27;s &quot;proof&quot; is completely impenetrable even to experts on, like, page 3, and makes no effort to explain what is happening.<p>Another key difference is that New Foundations is a niche field, so there simply was not a huge amount of human effort spent reading Holmes&#x27;s work. That&#x27;s not the case with Mochizuki&#x27;s proof. There&#x27;s a big difference between &quot;a small number of mathematicians didn&#x27;t understand the proof but suspect it&#x27;s correct&quot; and &quot;a large number of mathematicians didn&#x27;t understand the proof and concluded it was incorrect.&quot;<p>And, most of all: Holmes&#x27;s formulation of twisted type theory made the proof a natural candidate for dependently-typed formal verification. Mochizuki&#x27;s proof is not type-theoretic and does not seem like a great candidate for the calculus of constructions - maybe it is! I actually have no idea. I suspect Mochizuki is the only person in the world who can answer that. But it&#x27;s critical that Holmes did so much background work to simplify his proof and make this Lean program possible. Mochizuki should do the same.<p>AFAICT, both in terms of the &quot;sociology of mathematics&quot; and the amount of work required to even attempt a Lean formalization, trying to verify Mochizuki&#x27;s proof is a waste of time.</div><br/><div id="40135233" class="c"><input type="checkbox" id="c-40135233" checked=""/><div class="controls bullet"><span class="by">ducttapecrown</span><span>|</span><a href="#40132370">root</a><span>|</span><a href="#40132875">parent</a><span>|</span><a href="#40133707">next</a><span>|</span><label class="collapse" for="c-40135233">[-]</label><label class="expand" for="c-40135233">[2 more]</label></div><br/><div class="children"><div class="content">Kirti Joshi from the IAS has made very serious attempts to patch up Mochizuki&#x27;s work by developing new math and by making the exposition good. If you&#x27;re an expert in arithmetic geometry presumably he&#x27;s readable, if you&#x27;re just interested, I found it fun to skim.</div><br/><div id="40137723" class="c"><input type="checkbox" id="c-40137723" checked=""/><div class="controls bullet"><span class="by">Davidzheng</span><span>|</span><a href="#40132370">root</a><span>|</span><a href="#40135233">parent</a><span>|</span><a href="#40133707">next</a><span>|</span><label class="collapse" for="c-40137723">[-]</label><label class="expand" for="c-40137723">[1 more]</label></div><br/><div class="children"><div class="content">No comments on the correctness of his work (plenty of discussions online e.g on MO) but why do you say he&#x27;s from IAS?</div><br/></div></div></div></div></div></div><div id="40133707" class="c"><input type="checkbox" id="c-40133707" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#40132370">root</a><span>|</span><a href="#40132529">parent</a><span>|</span><a href="#40132875">prev</a><span>|</span><a href="#40137078">next</a><span>|</span><label class="collapse" for="c-40133707">[-]</label><label class="expand" for="c-40133707">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a proposed proof of abc conjecture that is supposedly more readable. Here is a discussion thread about it:<p><a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;math&#x2F;comments&#x2F;1bhiz0s&#x2F;construction_of_arithmetic_teichmuller_spaces_iv&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;math&#x2F;comments&#x2F;1bhiz0s&#x2F;construction_...</a><p>It would be nice if this one were formalized in Lean (or Coq or HOL) though.</div><br/></div></div><div id="40137078" class="c"><input type="checkbox" id="c-40137078" checked=""/><div class="controls bullet"><span class="by">toneman</span><span>|</span><a href="#40132370">root</a><span>|</span><a href="#40132529">parent</a><span>|</span><a href="#40133707">prev</a><span>|</span><a href="#40133865">next</a><span>|</span><label class="collapse" for="c-40137078">[-]</label><label class="expand" for="c-40137078">[1 more]</label></div><br/><div class="children"><div class="content">I have studied IUT since 2012, and it is indeed, totally baroque. However, Motizuki Theory, is totally rebased and admits results of much interest. I will write more on this matter if my claim is of mutual interest.<p>IRT, the topic and digression here, LLM and LEAN4 are of not much use for IUT.<p>IUT Theory is much easier understood by a hacker than by a math guy, eventually tho, monitors and tv&#x27;s did kinda become the same thing but there are, some minor differences.</div><br/></div></div><div id="40133865" class="c"><input type="checkbox" id="c-40133865" checked=""/><div class="controls bullet"><span class="by">barfbagginus</span><span>|</span><a href="#40132370">root</a><span>|</span><a href="#40132529">parent</a><span>|</span><a href="#40137078">prev</a><span>|</span><a href="#40140894">next</a><span>|</span><label class="collapse" for="c-40133865">[-]</label><label class="expand" for="c-40133865">[5 more]</label></div><br/><div class="children"><div class="content">I seriously doubt mochi&#x27;s going to be any help for the lean formalization effort.<p>But a lean-assistive llm trained on mochi&#x27;s work? Ahhh! What an intriguing possibility!</div><br/><div id="40134394" class="c"><input type="checkbox" id="c-40134394" checked=""/><div class="controls bullet"><span class="by">Chinjut</span><span>|</span><a href="#40132370">root</a><span>|</span><a href="#40133865">parent</a><span>|</span><a href="#40140894">next</a><span>|</span><label class="collapse" for="c-40134394">[-]</label><label class="expand" for="c-40134394">[4 more]</label></div><br/><div class="children"><div class="content">I do not imagine LLMs will be of any use here.</div><br/><div id="40134736" class="c"><input type="checkbox" id="c-40134736" checked=""/><div class="controls bullet"><span class="by">barfbagginus</span><span>|</span><a href="#40132370">root</a><span>|</span><a href="#40134394">parent</a><span>|</span><a href="#40140894">next</a><span>|</span><label class="collapse" for="c-40134736">[-]</label><label class="expand" for="c-40134736">[3 more]</label></div><br/><div class="children"><div class="content">Then it&#x27;s time to update your LLM reading!<p><a href="https:&#x2F;&#x2F;leandojo.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;leandojo.org&#x2F;</a>
<a href="https:&#x2F;&#x2F;github.com&#x2F;lean-dojo&#x2F;LeanCopilot">https:&#x2F;&#x2F;github.com&#x2F;lean-dojo&#x2F;LeanCopilot</a>
<a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2404.07382" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2404.07382</a></div><br/><div id="40137732" class="c"><input type="checkbox" id="c-40137732" checked=""/><div class="controls bullet"><span class="by">Davidzheng</span><span>|</span><a href="#40132370">root</a><span>|</span><a href="#40134736">parent</a><span>|</span><a href="#40140894">next</a><span>|</span><label class="collapse" for="c-40137732">[-]</label><label class="expand" for="c-40137732">[2 more]</label></div><br/><div class="children"><div class="content">These llm&#x27;s are usually only proving some trivial lemmas right now. Hopefully it changes soon but...</div><br/><div id="40138777" class="c"><input type="checkbox" id="c-40138777" checked=""/><div class="controls bullet"><span class="by">barfbagginus</span><span>|</span><a href="#40132370">root</a><span>|</span><a href="#40137732">parent</a><span>|</span><a href="#40140894">next</a><span>|</span><label class="collapse" for="c-40138777">[-]</label><label class="expand" for="c-40138777">[1 more]</label></div><br/><div class="children"><div class="content">Just bolting llms onto proof search improves the state of the art. So if you want to improve the state of the art of proof search, bolt some llms onto proof search, and enjoy!<p>As far as making LLMs understand mochi math... I&#x27;m going to go out on a limb and say it will probably take less time for us to build an AI that understands mochi than it would take to understand mochi ourselves.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40140894" class="c"><input type="checkbox" id="c-40140894" checked=""/><div class="controls bullet"><span class="by">YoshiRulz</span><span>|</span><a href="#40132370">prev</a><span>|</span><a href="#40133359">next</a><span>|</span><label class="collapse" for="c-40140894">[-]</label><label class="expand" for="c-40140894">[2 more]</label></div><br/><div class="children"><div class="content">ZFC is dead, long live NF..?<p>As an amateur mathematician whose use of sets is mostly as a lingua franca for describing other things, it&#x27;s not clear to me what implications this has for the wider mathematical field, especially if the usefulness of NF is comparable to the established ZFC and its variants. Is it expected to become as popular as ZFC in machine proofs?<p>I do find the existence of a universal set more intuitive, so if nothing else this proof has rekindled my own interest in formalisation.</div><br/><div id="40142112" class="c"><input type="checkbox" id="c-40142112" checked=""/><div class="controls bullet"><span class="by">barfbagginus</span><span>|</span><a href="#40140894">parent</a><span>|</span><a href="#40133359">next</a><span>|</span><label class="collapse" for="c-40142112">[-]</label><label class="expand" for="c-40142112">[1 more]</label></div><br/><div class="children"><div class="content">From my naive and amateur view, the relative consistency result makes NF at least as useful as ZFC, since every model of ZFC can be extended into a model of NF. But it seems it won&#x27;t make NF all that useful unless:<p>1. We prove NF is inconsistent. Then ZFC is also inconsistent (and the stars start winking out in the night sky ;)<p>2. We prove ZFC is inconsistent. Then there&#x27;s still a chance NF is consistent (fingers crossed!)<p>I&#x27;m probably ignoring more practical &quot;quality of life&quot; benefits of NF, like being able to talk about proper classes, and side stepping Russell&#x27;s paradox with stratified formulas.</div><br/></div></div></div></div><div id="40133359" class="c"><input type="checkbox" id="c-40133359" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#40140894">prev</a><span>|</span><a href="#40136207">next</a><span>|</span><label class="collapse" for="c-40133359">[-]</label><label class="expand" for="c-40133359">[15 more]</label></div><br/><div class="children"><div class="content">Can someone give a rough description of what is special, or novel, in the &quot;New Foundations&quot; set theory formulation, relative to other formulations? Or at least, link to a description readable by, say, a math undergrad student or an engineering professional?</div><br/><div id="40134284" class="c"><input type="checkbox" id="c-40134284" checked=""/><div class="controls bullet"><span class="by">Mathnerd314</span><span>|</span><a href="#40133359">parent</a><span>|</span><a href="#40135348">next</a><span>|</span><label class="collapse" for="c-40134284">[-]</label><label class="expand" for="c-40134284">[12 more]</label></div><br/><div class="children"><div class="content">I was just editing the Wikipedia article, it should be more readable now: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;New_Foundations" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;New_Foundations</a><p>I think the main thing is the existence of the universal set. For my use case, the type system of a programming language, such a universal set is very useful. There are various hacks used in existing systems like cumulative universes or type-in-type which are not as satisfying - instead, I can just check that the type signature is stratified and then forget about types having numerical levels.</div><br/><div id="40135727" class="c"><input type="checkbox" id="c-40135727" checked=""/><div class="controls bullet"><span class="by">dwheeler</span><span>|</span><a href="#40133359">root</a><span>|</span><a href="#40134284">parent</a><span>|</span><a href="#40135109">next</a><span>|</span><label class="collapse" for="c-40135727">[-]</label><label class="expand" for="c-40135727">[5 more]</label></div><br/><div class="children"><div class="content">I agree, a &quot;cool&quot; think about NF is the universal set.<p>Another way to be introduced to New Foundations, along with how one can use it, is the Metamath database for New Foundations: <a href="https:&#x2F;&#x2F;us.metamath.org&#x2F;nfeuni&#x2F;mmnf.html" rel="nofollow">https:&#x2F;&#x2F;us.metamath.org&#x2F;nfeuni&#x2F;mmnf.html</a><p>Metamath is a proof system, but unlike most alternative systems like Lean, it doesn&#x27;t have a built-in set of axioms - you need to declare your axioms, and then you can prove theorems (using only previous axioms and proven theorems). So you can declare the axioms of New Foundations, and then use them to prove other things.<p>One thing you immediately discover when you try to <i>use</i> New Foundations is that &quot;the usual definition of the ordered pair, first proposed by Kuratowski in 1921 and used in the regular Metamath Proof Explorer, has a serious drawback for NF and related theories that use stratification. The Kuratowski ordered pair is defined as &lt;&lt; x , y &gt;&gt; = { { x } , { x , y } }. This leads to the ordered pair having a type two greater than its arguments. For example, z in &lt;&lt; &lt;&lt; x , y &gt;&gt; , z &gt;&gt; would have a different type than x and y, which makes multi-argument functions extremely awkward to work with. Operations such as &quot;1st&quot; and complex &quot;+&quot; would not form sets in NF with the Kuratowski ordered pairs. In contrast, the Quine definition of ordered pairs, defined in definition df-op, is type level. That is, &lt;. x , y &gt;. has the same type as x and y, which means that the same holds of &lt;. &lt;. x , y &gt;. , z &gt;. This means that &quot;1st&quot; is a set with the Quine definition, as is complex &quot;+&quot;. The Kuratowski ordered pair is defined (as df-opk), because it is a simple definition that can be used by the set construction axioms that follow it, but for typical uses the Quine definition of ordered pairs df-op is used instead.&quot;<p>One eye-popping result is that the Axiom of Choice can be <i>disproven</i> in NF. See that site (or other pages about NF) for details.</div><br/><div id="40141043" class="c"><input type="checkbox" id="c-40141043" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#40133359">root</a><span>|</span><a href="#40135727">parent</a><span>|</span><a href="#40136937">next</a><span>|</span><label class="collapse" for="c-40141043">[-]</label><label class="expand" for="c-40141043">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Metamath is a proof system, but unlike most alternative systems like Lean, it doesn&#x27;t have a built-in set of axioms - you need to declare your axioms, and then you can prove theorems (using only previous axioms and proven theorems). So you can declare the axioms of New Foundations, and then use them to prove other things.<p>I&#x27;ve only used lean a little bit but I&#x27;m pretty sure you can start lean with a blank slate, declare whatever you want and then build up from there.  In fact the Natural Number Game[1] is basically this, you develop the Peano axioms etc and prove everything about the natural numbers from scratch without using the standard library (which obviously would have all that built in).<p>[1] <a href="https:&#x2F;&#x2F;adam.math.hhu.de&#x2F;#&#x2F;g&#x2F;leanprover-community&#x2F;NNG4" rel="nofollow">https:&#x2F;&#x2F;adam.math.hhu.de&#x2F;#&#x2F;g&#x2F;leanprover-community&#x2F;NNG4</a></div><br/><div id="40141250" class="c"><input type="checkbox" id="c-40141250" checked=""/><div class="controls bullet"><span class="by">digama0</span><span>|</span><a href="#40133359">root</a><span>|</span><a href="#40141043">parent</a><span>|</span><a href="#40136937">next</a><span>|</span><label class="collapse" for="c-40141250">[-]</label><label class="expand" for="c-40141250">[1 more]</label></div><br/><div class="children"><div class="content">No, Lean is not suitable for axiomatic investigations, it comes with too much baggage from &quot;classical foundations&quot;. As Randall said above, Lean is axiomatically much stronger than NF, and that&#x27;s even with &quot;no axioms&quot;! You can use Lean to prove things about axiom systems, but you have to model the axiom system explicitly as a &quot;deep embedding&quot; with syntax and a typing judgment. For metatheory work like the one reported on here this is exactly what you want, but if you want to actually work <i>in</i> the theory then it&#x27;s an extra layer of indirection which makes things a lot more cumbersome compared to using Lean&#x27;s own logic.<p>Metamath is much more configurable in this regard, you just directly specify the axiom system you want to work in and there is no special status given to first order logic or anything like that.</div><br/></div></div></div></div><div id="40136937" class="c"><input type="checkbox" id="c-40136937" checked=""/><div class="controls bullet"><span class="by">dkbrk</span><span>|</span><a href="#40133359">root</a><span>|</span><a href="#40135727">parent</a><span>|</span><a href="#40141043">prev</a><span>|</span><a href="#40135109">next</a><span>|</span><label class="collapse" for="c-40136937">[-]</label><label class="expand" for="c-40136937">[2 more]</label></div><br/><div class="children"><div class="content">&gt; In contrast, the Quine definition of ordered pairs, defined in definition df-op, is type level. That is, &lt;. x , y &gt;. has the same type as x and y<p>How is that not a problem? The type of a set needs to be higher than its elements to prevent the construction of a set containing itself. If a tuple is the same type as an elements, then can&#x27;t you construct a tuple that contains itself as its first element, i.e. &quot;x.0 = x&quot; is a stratified formula so x exists.</div><br/><div id="40139978" class="c"><input type="checkbox" id="c-40139978" checked=""/><div class="controls bullet"><span class="by">LudwigNagasena</span><span>|</span><a href="#40133359">root</a><span>|</span><a href="#40136937">parent</a><span>|</span><a href="#40135109">next</a><span>|</span><label class="collapse" for="c-40139978">[-]</label><label class="expand" for="c-40139978">[1 more]</label></div><br/><div class="children"><div class="content">How is that a problem that a set contains itself? It&#x27;s allowed in NF.</div><br/></div></div></div></div></div></div><div id="40135109" class="c"><input type="checkbox" id="c-40135109" checked=""/><div class="controls bullet"><span class="by">randallholmes</span><span>|</span><a href="#40133359">root</a><span>|</span><a href="#40134284">parent</a><span>|</span><a href="#40135727">prev</a><span>|</span><a href="#40135348">next</a><span>|</span><label class="collapse" for="c-40135109">[-]</label><label class="expand" for="c-40135109">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not magic:  the universe of NF and other &quot;big&quot; objects in this system must be handled with extreme care.</div><br/><div id="40135217" class="c"><input type="checkbox" id="c-40135217" checked=""/><div class="controls bullet"><span class="by">randallholmes</span><span>|</span><a href="#40133359">root</a><span>|</span><a href="#40135109">parent</a><span>|</span><a href="#40135310">next</a><span>|</span><label class="collapse" for="c-40135217">[-]</label><label class="expand" for="c-40135217">[2 more]</label></div><br/><div class="children"><div class="content">to the original poster,<p>the universe is a boolean algebra in NF:  sets have complements, there is a universe.<p>The number three is the set of all sets with three elements (this is not a circular definition;  it is Frege&#x27;s definition from way back);  in general, a cardinal number is an equivalence class under equinumerousness, defined in the usual set theoretic way, and an ordinal number is an equivalence class of well-orderings under similarity.<p>When you look at objects which lead to paradox (the cardinality of the universe, the order type of the natural well-ordering on the ordinals) then you discover the violence inherent in the system.  Very strange things happen, which are counterintuitive.  None of this depends on my proof to work:  these are all features of NFU (New Foundations with urelements) which has been known to be consistent since 1969, and one can explore what is happening by looking at its known models, which are far simpler than what I construct.</div><br/><div id="40137478" class="c"><input type="checkbox" id="c-40137478" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#40133359">root</a><span>|</span><a href="#40135217">parent</a><span>|</span><a href="#40135310">next</a><span>|</span><label class="collapse" for="c-40137478">[-]</label><label class="expand" for="c-40137478">[1 more]</label></div><br/><div class="children"><div class="content">So, is the article&#x2F;project concerned with &quot;just NF&quot;, or &quot;NF with urelements&quot;?<p>Also, now I have to go learn about urelements too :-(</div><br/></div></div></div></div><div id="40135310" class="c"><input type="checkbox" id="c-40135310" checked=""/><div class="controls bullet"><span class="by">Mathnerd314</span><span>|</span><a href="#40133359">root</a><span>|</span><a href="#40135109">parent</a><span>|</span><a href="#40135217">prev</a><span>|</span><a href="#40135232">next</a><span>|</span><label class="collapse" for="c-40135310">[-]</label><label class="expand" for="c-40135310">[2 more]</label></div><br/><div class="children"><div class="content">While you&#x27;re around, I have a question: In TST, the restriction for x^m in y^n is that n = m+1, i.e. the level must increment by 1. In TTT, the restriction is instead that m &lt; n, there is no requirement that it only be 1. Now, in NF, the restriction for set membership in stratified formulas is also +1. Is it possible to relax this to a &quot;Tangled NF&quot; where the set membership restriction is only that m &lt; n? This would resolve issues such as how many levels it takes to construct an ordered pair.</div><br/><div id="40140888" class="c"><input type="checkbox" id="c-40140888" checked=""/><div class="controls bullet"><span class="by">randallholmes</span><span>|</span><a href="#40133359">root</a><span>|</span><a href="#40135310">parent</a><span>|</span><a href="#40135232">next</a><span>|</span><label class="collapse" for="c-40140888">[-]</label><label class="expand" for="c-40140888">[1 more]</label></div><br/><div class="children"><div class="content">Jensen&#x27;s consistency proof for NFU can be read as relying on the consistency of TTTU, which is actually very easy to show.</div><br/></div></div></div></div><div id="40135232" class="c"><input type="checkbox" id="c-40135232" checked=""/><div class="controls bullet"><span class="by">randallholmes</span><span>|</span><a href="#40133359">root</a><span>|</span><a href="#40135109">parent</a><span>|</span><a href="#40135310">prev</a><span>|</span><a href="#40135348">next</a><span>|</span><label class="collapse" for="c-40135232">[-]</label><label class="expand" for="c-40135232">[1 more]</label></div><br/><div class="children"><div class="content">to clarify, when you look at objects that lead to paradox in naive set theory;  they do not lead to paradox in NF or NFU;  they exist but have unexpected properties.</div><br/></div></div></div></div></div></div><div id="40135348" class="c"><input type="checkbox" id="c-40135348" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#40133359">parent</a><span>|</span><a href="#40134284">prev</a><span>|</span><a href="#40136207">next</a><span>|</span><label class="collapse" for="c-40135348">[-]</label><label class="expand" for="c-40135348">[2 more]</label></div><br/><div class="children"><div class="content">The thing I find really aesthetically pleasing about NF is how it adjusts the axiom of subset selection so that &quot;the set of all sets&quot; doesn&#x27;t cause Russell&#x27;s paradox. Basically it requires that the predicates you use to select subsets must obey a certain very lightweight type system. &quot;x is not a member of itself&quot; is not a well-typed question under any reasonable type system, and in particular it doesn&#x27;t satisfy NF&#x27;s &quot;stratifiability&quot; requirement, so you can&#x27;t use it to construct the Russell&#x27;s-paradox set of all sets which do not contain themselves.</div><br/><div id="40141206" class="c"><input type="checkbox" id="c-40141206" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#40133359">root</a><span>|</span><a href="#40135348">parent</a><span>|</span><a href="#40136207">next</a><span>|</span><label class="collapse" for="c-40141206">[-]</label><label class="expand" for="c-40141206">[1 more]</label></div><br/><div class="children"><div class="content">You just move the sorts around, you don&#x27;t get rid of having to have sorts. I guess a rug with dirt swept under it is more aesthetically pleasing than a rug with dirt on top of it?</div><br/></div></div></div></div></div></div><div id="40136207" class="c"><input type="checkbox" id="c-40136207" checked=""/><div class="controls bullet"><span class="by">jraph</span><span>|</span><a href="#40133359">prev</a><span>|</span><a href="#40133644">next</a><span>|</span><label class="collapse" for="c-40136207">[-]</label><label class="expand" for="c-40136207">[2 more]</label></div><br/><div class="children"><div class="content">I was wondering what were the fundamental differences between Coq and Lean and if they operated on the same kind of logic and found this [1].<p>I barely understand anything from that discussion and don&#x27;t practice any of them. Feel free to chime in if you have something about this, or a comparison with other proof assistants.<p>[1] <a href="https:&#x2F;&#x2F;proofassistants.stackexchange.com&#x2F;questions&#x2F;153&#x2F;what-are-the-main-differences-between-coq-and-lean" rel="nofollow">https:&#x2F;&#x2F;proofassistants.stackexchange.com&#x2F;questions&#x2F;153&#x2F;what...</a></div><br/><div id="40138972" class="c"><input type="checkbox" id="c-40138972" checked=""/><div class="controls bullet"><span class="by">xvilka</span><span>|</span><a href="#40136207">parent</a><span>|</span><a href="#40133644">next</a><span>|</span><label class="collapse" for="c-40138972">[-]</label><label class="expand" for="c-40138972">[1 more]</label></div><br/><div class="children"><div class="content">There are, you can check this discussion [1] as well.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;coq&#x2F;coq&#x2F;issues&#x2F;10871">https:&#x2F;&#x2F;github.com&#x2F;coq&#x2F;coq&#x2F;issues&#x2F;10871</a></div><br/></div></div></div></div><div id="40133644" class="c"><input type="checkbox" id="c-40133644" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#40136207">prev</a><span>|</span><a href="#40134601">next</a><span>|</span><label class="collapse" for="c-40133644">[-]</label><label class="expand" for="c-40133644">[24 more]</label></div><br/><div class="children"><div class="content">&gt; Randall Holmes has claimed to have a proof of its consistency. In this repository, we use the interactive theorem prover Lean to verify the difficult part of his proof, thus proving that New Foundations is indeed consistent.<p>I think proponents of Lean are a little bit too strong in their use of language. Lean is not a superior method of proof, as is often implied. It is an <i>alternative</i> way of proof. If one looks into getting into Lean, one quickly realizes this situation. It is a programming language and system, with its own bugs, and you are highly reliant upon various stacks of libraries that other humans have written. These libraries have choices made in them and potentially gaps or even bugs.<p>So I think I take issue with the language here that it was Lean that said the proof was good. I think the more accurate and honest language is that the written proof was verified by human mathematicians and that the proof was translated into Lean by humans and verified there as well. I don&#x27;t think it&#x27;s necessarily accurate, or I haven&#x27;t seen explanations that say otherwise, that it&#x27;s Lean that provides the sole, golden verification, but that is often implied. I think the subtitle is the most accurate language here: &quot;A digitisation of Randall Holmes&#x27; proof&quot;.</div><br/><div id="40135647" class="c"><input type="checkbox" id="c-40135647" checked=""/><div class="controls bullet"><span class="by">dwheeler</span><span>|</span><a href="#40133644">parent</a><span>|</span><a href="#40133742">next</a><span>|</span><label class="collapse" for="c-40135647">[-]</label><label class="expand" for="c-40135647">[4 more]</label></div><br/><div class="children"><div class="content">I do think that machine-verified proofs in strong systems like Lean <i>are</i> far superior to proofs merely verified by humans. Humans are <i>amazing</i>, but they also get bored and miss details.<p>This isn&#x27;t just a theoretical claim. People read Euclid&#x27;s <i>Elements</i> for over two thousand years before noticing a missing axiom. That&#x27;s the sort of basic mistake that <i>any</i> properly-working machine proof verification system would immediately reveal. Published math proofs are often later revealed to be wrong. The increasing sophistication of math means it&#x27;s getting harder and harder for humans to properly verify every step. Machines are still not as good at <i>creating</i> proofs, but they&#x27;re unequalled at checking them.<p>There are &quot;competing&quot; systems to Lean, so I wouldn&#x27;t say that Lean is the &quot;one true way&quot;. I like Metamath, for example. But the &quot;competition&quot; between these systems needs to be in quotes, because each has different trade-offs, and many people like or use or commit to multiples of them. All of them can verify theorems to a rigor that is impractical for humans.</div><br/><div id="40136058" class="c"><input type="checkbox" id="c-40136058" checked=""/><div class="controls bullet"><span class="by">agalunar</span><span>|</span><a href="#40133644">root</a><span>|</span><a href="#40135647">parent</a><span>|</span><a href="#40133742">next</a><span>|</span><label class="collapse" for="c-40136058">[-]</label><label class="expand" for="c-40136058">[3 more]</label></div><br/><div class="children"><div class="content">For the curious: I assume the parent is referring to Pasch&#x27;s axiom.<p><a href="https:&#x2F;&#x2F;math.stackexchange.com&#x2F;questions&#x2F;1901133&#x2F;euclids-elements-missing-axiom-of-m-pasch-examples" rel="nofollow">https:&#x2F;&#x2F;math.stackexchange.com&#x2F;questions&#x2F;1901133&#x2F;euclids-ele...</a></div><br/><div id="40136771" class="c"><input type="checkbox" id="c-40136771" checked=""/><div class="controls bullet"><span class="by">dwheeler</span><span>|</span><a href="#40133644">root</a><span>|</span><a href="#40136058">parent</a><span>|</span><a href="#40133742">next</a><span>|</span><label class="collapse" for="c-40136771">[-]</label><label class="expand" for="c-40136771">[2 more]</label></div><br/><div class="children"><div class="content">Correct. The good news that <i>Elements</i> still works otherwise, you just need to add the missing axiom.<p>But many other &quot;proofs&quot; have been found to be false. The book &quot;Metamath: A Computer Language for Mathematical Proofs&quot; (by Norm Megill and yours truly) is available at: <a href="https:&#x2F;&#x2F;us.metamath.org&#x2F;downloads&#x2F;metamath.pdf" rel="nofollow">https:&#x2F;&#x2F;us.metamath.org&#x2F;downloads&#x2F;metamath.pdf</a> - see section 1.2.2, &quot;Trusting the Mathematician&quot;. We list just a few of the many examples of proofs that weren&#x27;t.<p>Sure, there can be bugs in programs, but there are ways to counter such bugs that give <i>FAR</i> more confidence than can be afforded to humans. Lean&#x27;s approach is to have a small kernel, and then review the kernel. Metamath is even more serious; the Metamath approach is to have an extremely small language, and then re-implement it many times (so that a bug is unlikely to be reproduced in all implementations). The most popular Metamath database is &quot;set.mm&quot;, which uses classical logical logic and ZFC. Every change is verified by 5 different verifiers in 5 different programming languages originally developed by 5 different people:<p>* metamath.exe aka Cmetamath (the original C verifier by Norman Megill)<p>* checkmm (a C++ verifier by Eric Schmidt)<p>* smetamath-rs (smm3) (a Rust verifier by Stefan O&#x27;Rear)<p>* mmj2 (a Java verifier by Mel L. O&#x27;Cat and Mario Carneiro)<p>* mmverify.py (a Python verifier by Raph Levien)<p>For more on these verifiers, see: <a href="https:&#x2F;&#x2F;github.com&#x2F;metamath&#x2F;set.mm&#x2F;blob&#x2F;develop&#x2F;verifiers.md">https:&#x2F;&#x2F;github.com&#x2F;metamath&#x2F;set.mm&#x2F;blob&#x2F;develop&#x2F;verifiers.md</a></div><br/></div></div></div></div></div></div><div id="40133742" class="c"><input type="checkbox" id="c-40133742" checked=""/><div class="controls bullet"><span class="by">enricozb</span><span>|</span><a href="#40133644">parent</a><span>|</span><a href="#40135647">prev</a><span>|</span><a href="#40136834">next</a><span>|</span><label class="collapse" for="c-40133742">[-]</label><label class="expand" for="c-40133742">[17 more]</label></div><br/><div class="children"><div class="content">While there indeed may be bugs, it&#x27;s my understanding that any trust needs to be placed only on the kernel.<p>&gt; various stacks of libraries that other humans have written<p>If you&#x27;re referring to mathlib here, I&#x27;m not sure this is correct. As again all mathlib code compiles down to code that is processed by the kernel.<p>Indeed this is reinforced by the draft paper on the website [0]:<p>&gt; Lean is a large project, but one need only trust its kernel to ensure that accepted proofs are correct.
If a tactic were to output an incorrect proof term, then the kernel would have the opportunity to find
this mistake before the proof were to be accepted.<p>[0]: <a href="https:&#x2F;&#x2F;zeramorphic.github.io&#x2F;con-nf-paper&#x2F;main.l.pdf" rel="nofollow">https:&#x2F;&#x2F;zeramorphic.github.io&#x2F;con-nf-paper&#x2F;main.l.pdf</a></div><br/><div id="40134473" class="c"><input type="checkbox" id="c-40134473" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#40133644">root</a><span>|</span><a href="#40133742">parent</a><span>|</span><a href="#40133844">next</a><span>|</span><label class="collapse" for="c-40134473">[-]</label><label class="expand" for="c-40134473">[8 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s an overly formalistic view by the Lean team.<p>When I looked into Lean last (sometime last year), it was a hodgepodge of libraries and constructions. The maturity of the library depended upon if someone in that area of math had spent a lot of time building one up. There were even competing libraries and approaches. To me, that implies that there&#x27;s &quot;choice&quot; there, just as there is in mathematics. And a choice could be &quot;buggy&quot;. What&#x27;s to say that the construction of a mathematical structure in Lean is the same as the mathematical structure in &quot;normal&quot; mathematics?<p>So yes, if that statement by the Lean team is accurate, you can build correct things on top of the kernel, but the use of &quot;correct&quot; is a very formal one. It&#x27;s formally correct in terms of the kernel, but it doesn&#x27;t mean that it&#x27;s necessarily mathematically correct. This is to my understanding of course, garnered from trying to get into Lean.</div><br/><div id="40136117" class="c"><input type="checkbox" id="c-40136117" checked=""/><div class="controls bullet"><span class="by">cvoss</span><span>|</span><a href="#40133644">root</a><span>|</span><a href="#40134473">parent</a><span>|</span><a href="#40134697">next</a><span>|</span><label class="collapse" for="c-40136117">[-]</label><label class="expand" for="c-40136117">[1 more]</label></div><br/><div class="children"><div class="content">I think you are misunderstanding the relationship between the theorem and the proof. You express doubt that the proof is a good one, but then you point to the libraries in Lean as a possible source of incorrectness. The libraries cannot be the source of incorrectness in the proof. They can only be the source of incorrectness in the statement of the theorem. That&#x27;s why others are challenging you to declare that you don&#x27;t trust the Lean kernel. A kernel bug is the only thing that can permit incorrectness in the proof.<p>The exact content of the proof doesn&#x27;t matter for the purposes of deciding whether you should believe the theorem. At all. What matters are two things: 1) Is the theorem correctly stated? That is, does it say what it&#x27;s supposed to say in the agreed upon (natural or programming) language? 2) Do you trust the Lean kernel (or human reviewer of the proof, if applicable)?<p>If you accept 1) and 2), then you must accept the truth of the theorem.<p>No library used in the construction of the proof, nor any library used in the expression or the proof, can make or break the result.<p>If one uses a library in the statement of the theorem, then that matters. That&#x27;s letting someone else define some of the terms. And one must investigate whether those definitions are correct in order to decide whether the theorem is stated correctly. If you wish to challenge the work on these grounds, by all means proceed. But you can&#x27;t say you don&#x27;t think the proof is a good one for such reasons.</div><br/></div></div><div id="40134697" class="c"><input type="checkbox" id="c-40134697" checked=""/><div class="controls bullet"><span class="by">vilhelm_s</span><span>|</span><a href="#40133644">root</a><span>|</span><a href="#40134473">parent</a><span>|</span><a href="#40136117">prev</a><span>|</span><a href="#40135954">next</a><span>|</span><label class="collapse" for="c-40134697">[-]</label><label class="expand" for="c-40134697">[1 more]</label></div><br/><div class="children"><div class="content">But like, you can look at what parts of Mathlib this development imports, it&#x27;s mainly stuff imported by files in this subdirectory <a href="https:&#x2F;&#x2F;github.com&#x2F;leanprover-community&#x2F;con-nf&#x2F;tree&#x2F;main&#x2F;ConNF&#x2F;Mathlib">https:&#x2F;&#x2F;github.com&#x2F;leanprover-community&#x2F;con-nf&#x2F;tree&#x2F;main&#x2F;Con...</a> , and it&#x27;s pretty basic things: the definition of a permutation, a cardinal number etc. Almost all of these are things that would feature in the first one or two years of an undergraduate math degree (from just quickly scanning it, the most advanced thing I could see is the definition of cofinality of ordinals). It seems practically impossible to me that someone would make a mistake when e.g. defining what a group is, in a way subtle enough to later break this advanced theorem. If you think that people could mess up <i>that</i>, then all of math would be in doubt.</div><br/></div></div><div id="40135954" class="c"><input type="checkbox" id="c-40135954" checked=""/><div class="controls bullet"><span class="by">Certhas</span><span>|</span><a href="#40133644">root</a><span>|</span><a href="#40134473">parent</a><span>|</span><a href="#40134697">prev</a><span>|</span><a href="#40134680">next</a><span>|</span><label class="collapse" for="c-40135954">[-]</label><label class="expand" for="c-40135954">[4 more]</label></div><br/><div class="children"><div class="content">Your analogy to buggy implementations in ordinary programming languages is deeply flawed though.<p>The things formally defined and stated are proven. There can be no bugs in a library that lead to formally stated theorems being erroneously proven.<p>Bugs at the library level can only appear in the form that formally stated theorems might not be what you think they are.<p>So I object to your characterization that they might be mathematically incorrect. The mathematical content might be different than believed though.</div><br/><div id="40138356" class="c"><input type="checkbox" id="c-40138356" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#40133644">root</a><span>|</span><a href="#40135954">parent</a><span>|</span><a href="#40134680">next</a><span>|</span><label class="collapse" for="c-40138356">[-]</label><label class="expand" for="c-40138356">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The things formally defined and stated are proven. There can be no bugs in a library that lead to formally stated theorems being erroneously proven.<p>That can&#x27;t actually be true in practice can it? These are things running on a computer, a machine, and not paper.<p>Additionally, I&#x27;m consider two types of &quot;bugs&quot;. (1) bugs in software or hardware that the stack relies on; (2) &quot;bugs&quot; in the conceptual sense of a Lean construction being something different than what was meant or what people thought it was, which is effectively the same problem that regular mathematics runs into.</div><br/><div id="40138850" class="c"><input type="checkbox" id="c-40138850" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40133644">root</a><span>|</span><a href="#40138356">parent</a><span>|</span><a href="#40141726">next</a><span>|</span><label class="collapse" for="c-40138850">[-]</label><label class="expand" for="c-40138850">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Additionally, I&#x27;m consider two types of &quot;bugs&quot;. (1) bugs in software or hardware that the stack relies on;<p>Then run the Lean proof on a non-x86 computer and on both Windows and Linux. The possibility that two independent computer architectures and two independent operating systems converge on some buggy behaviour that just so happens to allow a buggy proof through is so remote it&#x27;s not worth considering further.<p>&gt; (2) &quot;bugs&quot; in the conceptual sense of a Lean construction being something different than what was meant or what people thought it was, which is effectively the same problem that regular mathematics runs into.<p>A specification is orders of magnitude shorter than proofs, on average. So if you&#x27;re saying they managed to reduce the amount of manual verification work and possible human error by orders of magnitude, that sounds like an uncontroversial win for correctness.</div><br/></div></div><div id="40141726" class="c"><input type="checkbox" id="c-40141726" checked=""/><div class="controls bullet"><span class="by">Certhas</span><span>|</span><a href="#40133644">root</a><span>|</span><a href="#40138356">parent</a><span>|</span><a href="#40138850">prev</a><span>|</span><a href="#40134680">next</a><span>|</span><label class="collapse" for="c-40141726">[-]</label><label class="expand" for="c-40141726">[1 more]</label></div><br/><div class="children"><div class="content">Theorem provers work like this: the axioms are input, then there is a program (using libraries) that transforms them, and the output of that program is the theorem.<p>If the runtime is correctly executing the program, then the theorem is proven from the axioms.<p>Importantly, as long as there is any program that outputs the theorem from the axioms, you have a proof. So even if your program doesn&#x27;t do what you think it does, if it outputs the theorem, that doesn&#x27;t matter.<p>So do you trust the runtime? Bit flip errors can be eliminated by running things multiple times. The more human proven statements the runtime executes correctly the more you believe it&#x27;s implemented correctly. Importantly, all proofs done in lean increase the trust in the common runtime.<p>And: do you trust your ability to understand the formal theorem that is output. That&#x27;s the question discussed elsewhere in this comment section in depth.</div><br/></div></div></div></div></div></div><div id="40134680" class="c"><input type="checkbox" id="c-40134680" checked=""/><div class="controls bullet"><span class="by">fwip</span><span>|</span><a href="#40133644">root</a><span>|</span><a href="#40134473">parent</a><span>|</span><a href="#40135954">prev</a><span>|</span><a href="#40133844">next</a><span>|</span><label class="collapse" for="c-40134680">[-]</label><label class="expand" for="c-40134680">[1 more]</label></div><br/><div class="children"><div class="content">From my understanding, the libraries written in Lean are also formally proven by the kernel. They may be hodge-podge or incomplete, but they are (by construction) not &quot;buggy&quot; in a way that could lead to incorrect proofs, right?</div><br/></div></div></div></div><div id="40133844" class="c"><input type="checkbox" id="c-40133844" checked=""/><div class="controls bullet"><span class="by">appplication</span><span>|</span><a href="#40133644">root</a><span>|</span><a href="#40133742">parent</a><span>|</span><a href="#40134473">prev</a><span>|</span><a href="#40136834">next</a><span>|</span><label class="collapse" for="c-40133844">[-]</label><label class="expand" for="c-40133844">[8 more]</label></div><br/><div class="children"><div class="content">I think their point is it’s turtles all the way down. At some point you’re relying on software, kernel or otherwise, which will always have the possibility for bugs.<p>It seems like Lean is an interesting tool that maybe could help with proving, but ultimately will never be authoritative itself as a statement of proof.<p>Of course, this is ultimately a philosophical debate, which hinges on the fact to at while Lean may be demonstrably correct in any number of known applications, there are no guarantees that it is and will remain correct. Such is the nature of software.</div><br/><div id="40134827" class="c"><input type="checkbox" id="c-40134827" checked=""/><div class="controls bullet"><span class="by">konstantinua00</span><span>|</span><a href="#40133644">root</a><span>|</span><a href="#40133844">parent</a><span>|</span><a href="#40133855">next</a><span>|</span><label class="collapse" for="c-40134827">[-]</label><label class="expand" for="c-40134827">[1 more]</label></div><br/><div class="children"><div class="content">I think the counterpoint is it&#x27;s turtles all the way down. At some point you&#x27;re relying on human mind, logic or otherwise, which will always have possibility of misunderstandings and mistakes.<p>It seems like Mahematicians are interesring tools that maybe could help with proving, but ultimately will never be authorative itsel as a statement of proof.<p>Of course, this is ultimately a philosophical devate, which hinges on the fact to at while Mathematicians may be demonstrably correct in any number of known applications, there are no guarantees that they are and will remain correct. Such is the nature of wetware.<p>---<p>development of proof assistants is in noticable part fueled by the same fear - fear that wetware had a fault somewhere in the long ladder of math, causing all the layers above be a useless junk<p>and those things did happen, it isn&#x27;t just an imagined threat<p>what proof assistants propose is a clever trick - write one, simple, kernel. Stare at those 100 lines of code. Stare at mathematical definitions of intended API. Conclude that those coincide. Then use that kernel on the text files with all the proof ladder<p>All mistrust of &quot;whole mathematics&quot; gets condensed in mistrust of 100 lines of code<p>And mistrust of wetware gets replaced with mistrust of hardware - something we already do since even before computers appeared</div><br/></div></div><div id="40133855" class="c"><input type="checkbox" id="c-40133855" checked=""/><div class="controls bullet"><span class="by">enricozb</span><span>|</span><a href="#40133644">root</a><span>|</span><a href="#40133844">parent</a><span>|</span><a href="#40134827">prev</a><span>|</span><a href="#40136834">next</a><span>|</span><label class="collapse" for="c-40133855">[-]</label><label class="expand" for="c-40133855">[6 more]</label></div><br/><div class="children"><div class="content">Such is the nature of math as well.</div><br/><div id="40133932" class="c"><input type="checkbox" id="c-40133932" checked=""/><div class="controls bullet"><span class="by">appplication</span><span>|</span><a href="#40133644">root</a><span>|</span><a href="#40133855">parent</a><span>|</span><a href="#40136834">next</a><span>|</span><label class="collapse" for="c-40133932">[-]</label><label class="expand" for="c-40133932">[5 more]</label></div><br/><div class="children"><div class="content">I’m not a mathematician, so I’d be interested in any perspectives if the two are ultimately so similar in this regard, or is there is something foundationally different about the traditional mathematical approach.<p>I suppose any proof is ultimately a matter of review and consensus, and potentially would rely on some fundamentally unprovable assumptions at a basic level (e.g. the underlying laws of the universe).</div><br/><div id="40134462" class="c"><input type="checkbox" id="c-40134462" checked=""/><div class="controls bullet"><span class="by">enricozb</span><span>|</span><a href="#40133644">root</a><span>|</span><a href="#40133932">parent</a><span>|</span><a href="#40134142">next</a><span>|</span><label class="collapse" for="c-40134462">[-]</label><label class="expand" for="c-40134462">[1 more]</label></div><br/><div class="children"><div class="content">What I was referring to is that we don&#x27;t know if ZFC, for example, is consistent. And it is only consistent if there are unprovable statements. And of course, you can&#x27;t know which statements are unprovable (because then you would prove its consistency). So, in some sense you&#x27;re always chasing your own tail. Theorems might be proven true only because ZFC is inconsistent and therefore everything can be proven.<p>The Lean language is known to be equivalent to ZFC + {existence of n &lt; omega inaccessible cardinals}, which is roughly the common language of mathematics. The actual implementation of the kernel _may_ have bugs, but that&#x27;s sort of separate from the language definition.<p>The sentiment I see for the purpose of Lean now and in the near future is for more collaborative mathematics. Theorems and structures are more transparent and concrete (the code is right there). Results are more consumable. The community does not seem to see its main purpose being a way to quell doubts of a paper proof.</div><br/></div></div><div id="40134142" class="c"><input type="checkbox" id="c-40134142" checked=""/><div class="controls bullet"><span class="by">golol</span><span>|</span><a href="#40133644">root</a><span>|</span><a href="#40133932">parent</a><span>|</span><a href="#40134462">prev</a><span>|</span><a href="#40136834">next</a><span>|</span><label class="collapse" for="c-40134142">[-]</label><label class="expand" for="c-40134142">[3 more]</label></div><br/><div class="children"><div class="content">It is a fundamentally different manner. Proofs in Lean are formal all the way down. The kernel checks the validity of a proof. This is a finite program checking the validity of the kernel to high degree once is different to checking the validity of every new paper that comes out to high degree.</div><br/><div id="40134371" class="c"><input type="checkbox" id="c-40134371" checked=""/><div class="controls bullet"><span class="by">ChadNauseam</span><span>|</span><a href="#40133644">root</a><span>|</span><a href="#40134142">parent</a><span>|</span><a href="#40136834">next</a><span>|</span><label class="collapse" for="c-40134371">[-]</label><label class="expand" for="c-40134371">[2 more]</label></div><br/><div class="children"><div class="content">Yes, the human effort of checking proofs written in Lean is O(1) as you only need to verify the kernel. The human effort of checking proofs written traditionally is O(N). Of course writing proofs in Lean is much more difficult (for now) and, checking the proof is not the only interesting part. Other mathematicians also want to understand the proof, and this will always be O(n).<p>Also, while it&#x27;s true that bugs in mathlib cannot cause lean to accept invalid proofs as long as the kernel is correct, bugs in mathlib can still be annoying (I have only used lean briefly and I got stuck for a long time on a buggy tactic that was silently messing up my proof state).</div><br/><div id="40135153" class="c"><input type="checkbox" id="c-40135153" checked=""/><div class="controls bullet"><span class="by">golol</span><span>|</span><a href="#40133644">root</a><span>|</span><a href="#40134371">parent</a><span>|</span><a href="#40136834">next</a><span>|</span><label class="collapse" for="c-40135153">[-]</label><label class="expand" for="c-40135153">[1 more]</label></div><br/><div class="children"><div class="content">My personal belief is that translating an informal proof from a paper to a proof in Lean, given that the prerequisites are already formalized, is an O(n) operation where n is the length of the proof. It&#x27;s just translation. Right now the constant is something like 10-100, but I think with more work on matlib and AI assistance it can be brought down to maybe 1-3, meaning formalising proofs right as you write them becomes feasible. In fact the constant may go below 1 as formalization in Lean can prevent unseen errors from slowing your progress.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40136834" class="c"><input type="checkbox" id="c-40136834" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#40133644">parent</a><span>|</span><a href="#40133742">prev</a><span>|</span><a href="#40134361">next</a><span>|</span><label class="collapse" for="c-40136834">[-]</label><label class="expand" for="c-40136834">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It is a programming language and system, with its own bugs<p>The cool thing about theorem provers is that an invalid proof <i>won’t even compile</i> (as long as the kernel is correct). There’s no such thing as a traditional software bug that happens only at runtime in these systems when it comes to proofs, because there’s no runtime at all.<p>You can also use Lean as a “regular” programming language, with the corresponding risk of runtime bugs, but that’s not happening here.</div><br/></div></div><div id="40134361" class="c"><input type="checkbox" id="c-40134361" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#40133644">parent</a><span>|</span><a href="#40136834">prev</a><span>|</span><a href="#40134601">next</a><span>|</span><label class="collapse" for="c-40134361">[-]</label><label class="expand" for="c-40134361">[1 more]</label></div><br/><div class="children"><div class="content">The difference is that in lean you only need to trust the kernel. The rest is constructed on top. If the kernel is sound everything else is as well. This is in stark contrast with a standard programming language. Where at any time a bug can be introduced. It&#x27;s also in stark contrast with math where any lemma may contain an error.</div><br/></div></div></div></div><div id="40134601" class="c"><input type="checkbox" id="c-40134601" checked=""/><div class="controls bullet"><span class="by">Agingcoder</span><span>|</span><a href="#40133644">prev</a><span>|</span><a href="#40132900">next</a><span>|</span><label class="collapse" for="c-40134601">[-]</label><label class="expand" for="c-40134601">[3 more]</label></div><br/><div class="children"><div class="content">I very much like this.<p>I wonder whether this will eventually lead to collaborative proofs , and ‘ bug fixes’ , essentially turning maths into a process similar to code on GitHub.</div><br/><div id="40135652" class="c"><input type="checkbox" id="c-40135652" checked=""/><div class="controls bullet"><span class="by">trenchgun</span><span>|</span><a href="#40134601">parent</a><span>|</span><a href="#40138177">next</a><span>|</span><label class="collapse" for="c-40135652">[-]</label><label class="expand" for="c-40135652">[1 more]</label></div><br/><div class="children"><div class="content">Already is. Check Lean blueprints. <a href="https:&#x2F;&#x2F;terrytao.wordpress.com&#x2F;2023&#x2F;11&#x2F;18&#x2F;formalizing-the-proof-of-pfr-in-lean4-using-blueprint-a-short-tour&#x2F;" rel="nofollow">https:&#x2F;&#x2F;terrytao.wordpress.com&#x2F;2023&#x2F;11&#x2F;18&#x2F;formalizing-the-pr...</a></div><br/></div></div><div id="40138177" class="c"><input type="checkbox" id="c-40138177" checked=""/><div class="controls bullet"><span class="by">practal</span><span>|</span><a href="#40134601">parent</a><span>|</span><a href="#40135652">prev</a><span>|</span><a href="#40132900">next</a><span>|</span><label class="collapse" for="c-40138177">[-]</label><label class="expand" for="c-40138177">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this idea of collaborative proofs has been around for a while now, at least for 10 years: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1404.6186" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1404.6186</a></div><br/></div></div></div></div><div id="40132900" class="c"><input type="checkbox" id="c-40132900" checked=""/><div class="controls bullet"><span class="by">xylol</span><span>|</span><a href="#40134601">prev</a><span>|</span><a href="#40141111">next</a><span>|</span><label class="collapse" for="c-40132900">[-]</label><label class="expand" for="c-40132900">[13 more]</label></div><br/><div class="children"><div class="content">I&#x27;m really not from the field but wasn&#x27;t there some Gödel theorem showing every system strong enough cannot show its own consistency?</div><br/><div id="40133041" class="c"><input type="checkbox" id="c-40133041" checked=""/><div class="controls bullet"><span class="by">hyperpape</span><span>|</span><a href="#40132900">parent</a><span>|</span><a href="#40132991">next</a><span>|</span><label class="collapse" for="c-40133041">[-]</label><label class="expand" for="c-40133041">[1 more]</label></div><br/><div class="children"><div class="content">Gödel&#x27;s incompleteness theorems are what you&#x27;re thinking of. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;G%C3%B6del%27s_incompleteness_theorems" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;G%C3%B6del%27s_incompleteness_...</a><p>That said, if you have a system X, it can&#x27;t prove it&#x27;s own consistency, but a stronger system Y can prove its consistency (and perhaps some other stronger system can prove Y&#x27;s consistency. This gives us a chain of systems, each proving the consistency of some weaker system).<p>That doesn&#x27;t absolutely prove that the system is consistent--if Y was inconsistent, it could prove X is consistent (and also could prove that X is inconsistent). Nonetheless, it is still valuable. After all, part of our use of Y is the fact that we know of no inconsistency in it. And since formal systems often are subtly inconsistent, &quot;consistent assuming some other system is consistent&quot; is a lot better than &quot;we have no proof whatsoever of consistency&quot;.</div><br/></div></div><div id="40132991" class="c"><input type="checkbox" id="c-40132991" checked=""/><div class="controls bullet"><span class="by">pulisse</span><span>|</span><a href="#40132900">parent</a><span>|</span><a href="#40133041">prev</a><span>|</span><a href="#40133399">next</a><span>|</span><label class="collapse" for="c-40132991">[-]</label><label class="expand" for="c-40132991">[1 more]</label></div><br/><div class="children"><div class="content">The system isn&#x27;t being used to prove its own consistency. The consistency is proved in a different, stronger system.</div><br/></div></div><div id="40133399" class="c"><input type="checkbox" id="c-40133399" checked=""/><div class="controls bullet"><span class="by">skhunted</span><span>|</span><a href="#40132900">parent</a><span>|</span><a href="#40132991">prev</a><span>|</span><a href="#40133550">next</a><span>|</span><label class="collapse" for="c-40133399">[-]</label><label class="expand" for="c-40133399">[7 more]</label></div><br/><div class="children"><div class="content">What’s interesting to note is that even if a strong system could prove its own consistency then it wouldn’t tell you anything.  An inconsistent system can prove its own consistency.  So if a system has a proof that it is itself consistent then you still wouldn’t know if it is consistent.</div><br/><div id="40134376" class="c"><input type="checkbox" id="c-40134376" checked=""/><div class="controls bullet"><span class="by">libeclipse</span><span>|</span><a href="#40132900">root</a><span>|</span><a href="#40133399">parent</a><span>|</span><a href="#40133550">next</a><span>|</span><label class="collapse" for="c-40134376">[-]</label><label class="expand" for="c-40134376">[6 more]</label></div><br/><div class="children"><div class="content">It would tell you that the system is inconsistent</div><br/><div id="40134515" class="c"><input type="checkbox" id="c-40134515" checked=""/><div class="controls bullet"><span class="by">skhunted</span><span>|</span><a href="#40132900">root</a><span>|</span><a href="#40134376">parent</a><span>|</span><a href="#40133550">next</a><span>|</span><label class="collapse" for="c-40134515">[-]</label><label class="expand" for="c-40134515">[5 more]</label></div><br/><div class="children"><div class="content">It would not.  If a system can prove (I know sufficiently rich systems can’t do this but suppose it could) its own consistency you still can&#x27;t conclude it is consistent.<p>EDIT:  I&#x27;m working under the hypothetical situation in which PA could prove its consistency.  I know it can&#x27;t but assuming that it could prove it&#x27;s own consistency you still couldn&#x27;t conclude that it was consistent since an inconsistent system can prove it&#x27;s consistency.</div><br/><div id="40135161" class="c"><input type="checkbox" id="c-40135161" checked=""/><div class="controls bullet"><span class="by">roywiggins</span><span>|</span><a href="#40132900">root</a><span>|</span><a href="#40134515">parent</a><span>|</span><a href="#40133550">next</a><span>|</span><label class="collapse" for="c-40135161">[-]</label><label class="expand" for="c-40135161">[4 more]</label></div><br/><div class="children"><div class="content">GP is (I think correctly) stating that a system that can &quot;prove&quot; its own consistency is <i>definitely</i> inconsistent. Inconsistent systems can &quot;prove&quot; anything; if a system can appear to prove its own consistency, it isn&#x27;t.</div><br/><div id="40135307" class="c"><input type="checkbox" id="c-40135307" checked=""/><div class="controls bullet"><span class="by">skhunted</span><span>|</span><a href="#40132900">root</a><span>|</span><a href="#40135161">parent</a><span>|</span><a href="#40133550">next</a><span>|</span><label class="collapse" for="c-40135307">[-]</label><label class="expand" for="c-40135307">[3 more]</label></div><br/><div class="children"><div class="content">Yes.  I know this.  What I&#x27;m saying is that even if a consistent system that was strong enough could prove it&#x27;s consistency then it still wouldn&#x27;t tell you anything.  There are system that can prove their own consistency for which it is known that they are consistent.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Self-verifying_theories" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Self-verifying_theories</a></div><br/><div id="40139041" class="c"><input type="checkbox" id="c-40139041" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40132900">root</a><span>|</span><a href="#40135307">parent</a><span>|</span><a href="#40133550">next</a><span>|</span><label class="collapse" for="c-40139041">[-]</label><label class="expand" for="c-40139041">[2 more]</label></div><br/><div class="children"><div class="content">These are weaker than the systems Godel&#x27;s theorems are referring to, as discussed in the opening paragraph. Do these systems are not &quot;strong enough&quot; in the sense described in this thread.</div><br/><div id="40139737" class="c"><input type="checkbox" id="c-40139737" checked=""/><div class="controls bullet"><span class="by">skhunted</span><span>|</span><a href="#40132900">root</a><span>|</span><a href="#40139041">parent</a><span>|</span><a href="#40133550">next</a><span>|</span><label class="collapse" for="c-40139737">[-]</label><label class="expand" for="c-40139737">[1 more]</label></div><br/><div class="children"><div class="content">Obviously I’m aware of this.  As stated several times, my original comment refers to the hypothetical situation in which PA could prove its consistency without Godel’s theorems being true&#x2F;known.  One would not be able to conclude anything.<p>The point being, having PA prove its own consistency couldn’t tell you anything of value even in the case that Godel’s theorems were not true. This is an interesting phenomenon.  The only way to know a system is consistent is to know all of its theorems.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40133550" class="c"><input type="checkbox" id="c-40133550" checked=""/><div class="controls bullet"><span class="by">francasso</span><span>|</span><a href="#40132900">parent</a><span>|</span><a href="#40133399">prev</a><span>|</span><a href="#40133271">next</a><span>|</span><label class="collapse" for="c-40133550">[-]</label><label class="expand" for="c-40133550">[1 more]</label></div><br/><div class="children"><div class="content">You should take this proof as saying: if Lean 4 is consistent then New Foundations is consistent. There is no contradiction of Godel&#x27;s incompleteness theorem.</div><br/></div></div><div id="40132977" class="c"><input type="checkbox" id="c-40132977" checked=""/><div class="controls bullet"><span class="by">peteradio</span><span>|</span><a href="#40132900">parent</a><span>|</span><a href="#40133271">prev</a><span>|</span><a href="#40141111">next</a><span>|</span><label class="collapse" for="c-40132977">[-]</label><label class="expand" for="c-40132977">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the system here is trying to prove any of its underlying assumptions, just building on some set of existing ones.  I doubt the theorem you are thinking of is applicable.</div><br/></div></div></div></div><div id="40141111" class="c"><input type="checkbox" id="c-40141111" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#40132900">prev</a><span>|</span><a href="#40132338">next</a><span>|</span><label class="collapse" for="c-40141111">[-]</label><label class="expand" for="c-40141111">[1 more]</label></div><br/><div class="children"><div class="content">This is a fantastic result, congratulations!</div><br/></div></div><div id="40132338" class="c"><input type="checkbox" id="c-40132338" checked=""/><div class="controls bullet"><span class="by">_jcrossley</span><span>|</span><a href="#40141111">prev</a><span>|</span><a href="#40140483">next</a><span>|</span><label class="collapse" for="c-40132338">[-]</label><label class="expand" for="c-40132338">[7 more]</label></div><br/><div class="children"><div class="content">I wish I had the free time to keep up with the mathlib project - this is so cool. Is there any way someone can get involved in a super hands-off way?</div><br/><div id="40132732" class="c"><input type="checkbox" id="c-40132732" checked=""/><div class="controls bullet"><span class="by">isaacfrond</span><span>|</span><a href="#40132338">parent</a><span>|</span><a href="#40140483">next</a><span>|</span><label class="collapse" for="c-40132732">[-]</label><label class="expand" for="c-40132732">[6 more]</label></div><br/><div class="children"><div class="content">You could start with the Natural numbers game.<p><a href="https:&#x2F;&#x2F;adam.math.hhu.de&#x2F;#&#x2F;g&#x2F;leanprover-community&#x2F;NNG4" rel="nofollow">https:&#x2F;&#x2F;adam.math.hhu.de&#x2F;#&#x2F;g&#x2F;leanprover-community&#x2F;NNG4</a></div><br/><div id="40133970" class="c"><input type="checkbox" id="c-40133970" checked=""/><div class="controls bullet"><span class="by">gerdesj</span><span>|</span><a href="#40132338">root</a><span>|</span><a href="#40132732">parent</a><span>|</span><a href="#40135338">next</a><span>|</span><label class="collapse" for="c-40133970">[-]</label><label class="expand" for="c-40133970">[3 more]</label></div><br/><div class="children"><div class="content">Well, thanks a lot!  One minute I&#x27;m setting up a monitoring system and then ... I&#x27;ve just proved two is the number after the number after zero \o&#x2F; 8)</div><br/><div id="40135343" class="c"><input type="checkbox" id="c-40135343" checked=""/><div class="controls bullet"><span class="by">_jcrossley</span><span>|</span><a href="#40132338">root</a><span>|</span><a href="#40133970">parent</a><span>|</span><a href="#40135338">next</a><span>|</span><label class="collapse" for="c-40135343">[-]</label><label class="expand" for="c-40135343">[2 more]</label></div><br/><div class="children"><div class="content">Hope you keep going with it, it’s a blast!</div><br/><div id="40137691" class="c"><input type="checkbox" id="c-40137691" checked=""/><div class="controls bullet"><span class="by">gerdesj</span><span>|</span><a href="#40132338">root</a><span>|</span><a href="#40135343">parent</a><span>|</span><a href="#40135338">next</a><span>|</span><label class="collapse" for="c-40137691">[-]</label><label class="expand" for="c-40137691">[1 more]</label></div><br/><div class="children"><div class="content">I read &quot;GEB&quot; by Hofstadter after I finished my A levels (UK, aged 18).  I picked up a random book in the school library to fill in 20 mins before going out on a pub crawl (as you do).  Once we had finished off the Abingdon Ock Street crawl in fine style and the hangover had subsided, I devoured it.  I&#x27;d never read anything like it before - what a communicator of ideas.<p>A few unwise life style choices later and I find myself running a small IT company for the last 25 odd years.<p>I&#x27;ll never get beyond undergrad engineering maths n stats but it&#x27;s works like GEB and the Natural Numbers Game (and I see there are more) that allow civilians like me to get a glimpse into the real thing.  There is no way on earth I could possibly get to grips with the really serious stuff but then the foundations <i>are</i> the really serious stuff - the rest simply follows on (lol)<p>Whom or whoever wrote the NNG tutorials are a very good communicator.  The concepts are stripped to the bare essentials and the prose is crystal clear and the tone is suitably friendly.<p>Top stuff.</div><br/></div></div></div></div></div></div><div id="40135338" class="c"><input type="checkbox" id="c-40135338" checked=""/><div class="controls bullet"><span class="by">_jcrossley</span><span>|</span><a href="#40132338">root</a><span>|</span><a href="#40132732">parent</a><span>|</span><a href="#40133970">prev</a><span>|</span><a href="#40135953">next</a><span>|</span><label class="collapse" for="c-40135338">[-]</label><label class="expand" for="c-40135338">[1 more]</label></div><br/><div class="children"><div class="content">Yea I’ve run through that a couple of years ago - was brilliant, had a lot of fun. But I mean to stay up to date and somehow contribute from the sidelines</div><br/></div></div><div id="40135953" class="c"><input type="checkbox" id="c-40135953" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#40132338">root</a><span>|</span><a href="#40132732">parent</a><span>|</span><a href="#40135338">prev</a><span>|</span><a href="#40140483">next</a><span>|</span><label class="collapse" for="c-40135953">[-]</label><label class="expand" for="c-40135953">[1 more]</label></div><br/><div class="children"><div class="content">Wow, that&#x27;s actually really fun. Is this what &quot;proofs&quot; are in math classes?</div><br/></div></div></div></div></div></div><div id="40140483" class="c"><input type="checkbox" id="c-40140483" checked=""/><div class="controls bullet"><span class="by">stogot</span><span>|</span><a href="#40132338">prev</a><span>|</span><label class="collapse" for="c-40140483">[-]</label><label class="expand" for="c-40140483">[2 more]</label></div><br/><div class="children"><div class="content">Do the incompleteness theorems not apply here?</div><br/><div id="40140683" class="c"><input type="checkbox" id="c-40140683" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40140483">parent</a><span>|</span><label class="collapse" for="c-40140683">[-]</label><label class="expand" for="c-40140683">[1 more]</label></div><br/><div class="children"><div class="content">They start with a large cardinal assumption which is the usual workaround - you have a proof that this theory is consistent if a large cardinal like that exists, which is something you can&#x27;t prove within the theory.</div><br/></div></div></div></div></div></div></div></div></div></body></html>