<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1718614868161" as="style"/><link rel="stylesheet" href="styles.css?v=1718614868161"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://duckrabbit.tech/articles/learning-haskell.html">I learned Haskell in just 15 years</a> <span class="domain">(<a href="https://duckrabbit.tech">duckrabbit.tech</a>)</span></div><div class="subtext"><span>aranchelk</span> | <span>46 comments</span></div><br/><div><div id="40702531" class="c"><input type="checkbox" id="c-40702531" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#40702833">next</a><span>|</span><label class="collapse" for="c-40702531">[-]</label><label class="expand" for="c-40702531">[24 more]</label></div><br/><div class="children"><div class="content">Cute. All kidding aside, though, functional programming is worth the effort to learn, and it doesn&#x27;t actually take 15 years. The payoff is at the end of the article:<p>&quot;It’s quite natural to program in Haskell by building a declarative model of your domain data, writing pure functions over that data, and interacting with the real world at the program’s boundaries. That’s my favorite way to work, Haskell or not.&quot;<p>Haskell can be intimidating, though, so I would recommend F# for most beginners. It supports OOP and doesn&#x27;t require every single function to be pure, so the learning curve is less intense, but you end up absorbing the same lesson as above.</div><br/><div id="40702547" class="c"><input type="checkbox" id="c-40702547" checked=""/><div class="controls bullet"><span class="by">initplus</span><span>|</span><a href="#40702531">parent</a><span>|</span><a href="#40702586">next</a><span>|</span><label class="collapse" for="c-40702547">[-]</label><label class="expand" for="c-40702547">[8 more]</label></div><br/><div class="children"><div class="content">Yes - the value of functional programming isn&#x27;t that working in OCAML, or F#, or Haskell is 10x as productive as other languages. But that it can teach you worthwhile lessens about designing software that apply equally to imperative languages.<p>Modelling the business domain, reasoning and managing side effects, avoiding common imperative bugs, these are all valuable skills to develop.<p>F# is a great language to learn, and very approachable. Worst part about it is interacting with antiquated .NET API&#x27;s. (I can&#x27;t believe the state that .NET support for common serialization formats is still in...)</div><br/><div id="40702573" class="c"><input type="checkbox" id="c-40702573" checked=""/><div class="controls bullet"><span class="by">sidkshatriya</span><span>|</span><a href="#40702531">root</a><span>|</span><a href="#40702547">parent</a><span>|</span><a href="#40703151">next</a><span>|</span><label class="collapse" for="c-40702573">[-]</label><label class="expand" for="c-40702573">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Yes - the value of functional programming isn&#x27;t that working in OCAML, or F#, or Haskell is 10x as productive as other languages.<p>This is not true in my personal experience.<p>As has been famously said (paraphrased): Functional programming makes tough problems easy and easy problems tough.<p>In other words the value of functional programming depends on your domain.</div><br/><div id="40702620" class="c"><input type="checkbox" id="c-40702620" checked=""/><div class="controls bullet"><span class="by">initplus</span><span>|</span><a href="#40702531">root</a><span>|</span><a href="#40702573">parent</a><span>|</span><a href="#40702667">next</a><span>|</span><label class="collapse" for="c-40702620">[-]</label><label class="expand" for="c-40702620">[1 more]</label></div><br/><div class="children"><div class="content">Maybe my phrasing is not clear - I meant that these languages are indeed not significantly more productive.</div><br/></div></div><div id="40702667" class="c"><input type="checkbox" id="c-40702667" checked=""/><div class="controls bullet"><span class="by">antonvs</span><span>|</span><a href="#40702531">root</a><span>|</span><a href="#40702573">parent</a><span>|</span><a href="#40702620">prev</a><span>|</span><a href="#40702843">next</a><span>|</span><label class="collapse" for="c-40702667">[-]</label><label class="expand" for="c-40702667">[2 more]</label></div><br/><div class="children"><div class="content">&gt; easy problems tough.<p>That needs a qualifier: it can make easy problems tough if you&#x27;re not familiar with how to solve them in a functional context.<p>A big part of that is because smart people have already solved the tough problems and made them available as language features or libraries.</div><br/><div id="40703400" class="c"><input type="checkbox" id="c-40703400" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#40702531">root</a><span>|</span><a href="#40702667">parent</a><span>|</span><a href="#40702843">next</a><span>|</span><label class="collapse" for="c-40703400">[-]</label><label class="expand" for="c-40703400">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely! Any beginner can readily combine the catamorphisms and anamorphisms  in `recursion-schemes`, or use the ready-made hylomorphisms for common tasks such as setting a value in a data structure. What could be simpler? &#x2F;s<p><a href="https:&#x2F;&#x2F;wiki.haskell.org&#x2F;Zygohistomorphic_prepromorphisms" rel="nofollow">https:&#x2F;&#x2F;wiki.haskell.org&#x2F;Zygohistomorphic_prepromorphisms</a></div><br/></div></div></div></div><div id="40702843" class="c"><input type="checkbox" id="c-40702843" checked=""/><div class="controls bullet"><span class="by">kreyenborgi</span><span>|</span><a href="#40702531">root</a><span>|</span><a href="#40702573">parent</a><span>|</span><a href="#40702667">prev</a><span>|</span><a href="#40702610">next</a><span>|</span><label class="collapse" for="c-40702843">[-]</label><label class="expand" for="c-40702843">[1 more]</label></div><br/><div class="children"><div class="content">&gt; makes tough problems easy and easy problems tough<p>And because of mutual recursion, that means that tough is easy (and easy tough). In other words, if we call the class of tough problems T and easy problems NT, we have T==NT, given FP.</div><br/></div></div><div id="40702610" class="c"><input type="checkbox" id="c-40702610" checked=""/><div class="controls bullet"><span class="by">NinoScript</span><span>|</span><a href="#40702531">root</a><span>|</span><a href="#40702573">parent</a><span>|</span><a href="#40702843">prev</a><span>|</span><a href="#40703151">next</a><span>|</span><label class="collapse" for="c-40702610">[-]</label><label class="expand" for="c-40702610">[1 more]</label></div><br/><div class="children"><div class="content">So you’re saying that it does make you 10x as productive?</div><br/></div></div></div></div><div id="40703151" class="c"><input type="checkbox" id="c-40703151" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#40702531">root</a><span>|</span><a href="#40702547">parent</a><span>|</span><a href="#40702573">prev</a><span>|</span><a href="#40702586">next</a><span>|</span><label class="collapse" for="c-40703151">[-]</label><label class="expand" for="c-40703151">[1 more]</label></div><br/><div class="children"><div class="content">Hot take of the day: you learn that with imperative programming just as well.<p>I familiarized myself with fp to the point of writing scheme and haskell around 15 years ago. Read the classics, understood advanced typing, lambda calculus and so on. The best “fp” I’m using nowadays is closures, currying in the form of func.bind(this[, first]) and map&#x2F;filter. Which all are absolutely learnable by the means of closures, which are useful but I can live without. Sometimes not having these makes you write effing code instead of fiddling with its forms for hours.<p>Still waiting for the returns from arcane fp-like code I produced earlier. Cannot recognize nor understand none of my projects in this style that I bothered to save in vcs. Imperative code reads like prose, I have some of it still in production since 2010.<p>These FP talks are disguised elitism imo (not necessarily bad faith). Beta reduction and monadic transformers sound so cool, but that’s it job-wise.</div><br/></div></div></div></div><div id="40702586" class="c"><input type="checkbox" id="c-40702586" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#40702531">parent</a><span>|</span><a href="#40702547">prev</a><span>|</span><a href="#40702850">next</a><span>|</span><label class="collapse" for="c-40702586">[-]</label><label class="expand" for="c-40702586">[6 more]</label></div><br/><div class="children"><div class="content">That’s interesting because F#’s OOP, as someone who knows neither C# nor Java, makes it more intimidating to me than OCaml.<p>Also interesting that when FP is mentioned, Hindley-Milner is implicitly understood to be part of FP too even though it doesn’t have to be. Clojure emphasizes immutability and FP  but with dynamic typing and everything that comes with that.</div><br/><div id="40702808" class="c"><input type="checkbox" id="c-40702808" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#40702531">root</a><span>|</span><a href="#40702586">parent</a><span>|</span><a href="#40702757">next</a><span>|</span><label class="collapse" for="c-40702808">[-]</label><label class="expand" for="c-40702808">[2 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t the &quot;O&quot; in OCaml stand for &quot;Object&quot;, though? I think you could pick up either F# or OCaml just as easily.<p>The nuances of OOP in F# can be ignored by beginners, so I really wouldn’t let yourself be intimidated coming from Clojure.<p>[0] <a href="https:&#x2F;&#x2F;ocaml.org&#x2F;docs&#x2F;objects" rel="nofollow">https:&#x2F;&#x2F;ocaml.org&#x2F;docs&#x2F;objects</a></div><br/><div id="40703134" class="c"><input type="checkbox" id="c-40703134" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#40702531">root</a><span>|</span><a href="#40702808">parent</a><span>|</span><a href="#40702757">next</a><span>|</span><label class="collapse" for="c-40703134">[-]</label><label class="expand" for="c-40703134">[1 more]</label></div><br/><div class="children"><div class="content">OCaml classes and objects are (ironically) rarely used and generally discouraged. There are some cases where they’re practically required, such as GUI and FFI (js_of_ocaml). But otherwise, most code does encapsulation and abstraction using modules and functor modules (which are more like Haskell and Rust typeclasses than traditional OOP classes).<p>I don’t know much about F#, but last time I used it most of its standard library was in  C# and .NET, so F# code would interact with objects and classes a lot. AFAIK F# also doesn’t have functor modules, so even without the dependence on C# code, you still can’t avoid classes and objects like you can with OCaml (e.g. you can’t write a generic collection module like `List` or `Set` without functors, it would have to be a collection of a specific type or a class).</div><br/></div></div></div></div><div id="40702757" class="c"><input type="checkbox" id="c-40702757" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40702531">root</a><span>|</span><a href="#40702586">parent</a><span>|</span><a href="#40702808">prev</a><span>|</span><a href="#40702850">next</a><span>|</span><label class="collapse" for="c-40702757">[-]</label><label class="expand" for="c-40702757">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Clojure emphasizes immutability<p>Is &quot;emphasizes&quot; just another word for second-class support?<p>C++ emphasizes the importance of memory safety.</div><br/><div id="40702834" class="c"><input type="checkbox" id="c-40702834" checked=""/><div class="controls bullet"><span class="by">y1n0</span><span>|</span><a href="#40702531">root</a><span>|</span><a href="#40702757">parent</a><span>|</span><a href="#40702850">next</a><span>|</span><label class="collapse" for="c-40702834">[-]</label><label class="expand" for="c-40702834">[2 more]</label></div><br/><div class="children"><div class="content">Immutability is definitely first class in clojure, but you can work with mutable structures when you need to.</div><br/><div id="40702892" class="c"><input type="checkbox" id="c-40702892" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40702531">root</a><span>|</span><a href="#40702834">parent</a><span>|</span><a href="#40702850">next</a><span>|</span><label class="collapse" for="c-40702892">[-]</label><label class="expand" for="c-40702892">[1 more]</label></div><br/><div class="children"><div class="content">This is sounds like memory safety in C++.<p><a href="https:&#x2F;&#x2F;www.infoworld.com&#x2F;article&#x2F;3714401&#x2F;c-plus-plus-creator-rebuts-white-house-warning.html" rel="nofollow">https:&#x2F;&#x2F;www.infoworld.com&#x2F;article&#x2F;3714401&#x2F;c-plus-plus-creato...</a></div><br/></div></div></div></div></div></div></div></div><div id="40702850" class="c"><input type="checkbox" id="c-40702850" checked=""/><div class="controls bullet"><span class="by">beders</span><span>|</span><a href="#40702531">parent</a><span>|</span><a href="#40702586">prev</a><span>|</span><a href="#40703246">next</a><span>|</span><label class="collapse" for="c-40702850">[-]</label><label class="expand" for="c-40702850">[1 more]</label></div><br/><div class="children"><div class="content">I feel the same pay-off - but arrived at that point via Clojure.
Immutable-first, aim for purity, ability to drop out of it when necessary.<p>As stringent as you need it to be (static vs. dynamic types vs. specs), as flexible as you want it to be.</div><br/></div></div><div id="40703246" class="c"><input type="checkbox" id="c-40703246" checked=""/><div class="controls bullet"><span class="by">__rito__</span><span>|</span><a href="#40702531">parent</a><span>|</span><a href="#40702850">prev</a><span>|</span><a href="#40703076">next</a><span>|</span><label class="collapse" for="c-40703246">[-]</label><label class="expand" for="c-40703246">[1 more]</label></div><br/><div class="children"><div class="content">For the benefit(s) that you list, which are the best learning resources for F#?</div><br/></div></div><div id="40703076" class="c"><input type="checkbox" id="c-40703076" checked=""/><div class="controls bullet"><span class="by">realPtolemy</span><span>|</span><a href="#40702531">parent</a><span>|</span><a href="#40703246">prev</a><span>|</span><a href="#40702887">next</a><span>|</span><label class="collapse" for="c-40703076">[-]</label><label class="expand" for="c-40703076">[1 more]</label></div><br/><div class="children"><div class="content">Or Elixir! Quite easy to grasp as well.</div><br/></div></div><div id="40702887" class="c"><input type="checkbox" id="c-40702887" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40702531">parent</a><span>|</span><a href="#40703076">prev</a><span>|</span><a href="#40702624">next</a><span>|</span><label class="collapse" for="c-40702887">[-]</label><label class="expand" for="c-40702887">[3 more]</label></div><br/><div class="children"><div class="content">I feel like functional programming is pretty trivial. It&#x27;s <i>pure</i> programming that is very difficult.<p>They&#x27;re often conflated because Haskell is pure and functional and probably the most talked about heavily functional language.<p>I certainly didn&#x27;t know that impure functional languages like OCaml existed for ages.</div><br/><div id="40703086" class="c"><input type="checkbox" id="c-40703086" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#40702531">root</a><span>|</span><a href="#40702887">parent</a><span>|</span><a href="#40702624">next</a><span>|</span><label class="collapse" for="c-40703086">[-]</label><label class="expand" for="c-40703086">[2 more]</label></div><br/><div class="children"><div class="content">Is Haskell pure?<p>It has exceptions<p>You can divide by zero<p>It has unsafe IO primitives</div><br/><div id="40703216" class="c"><input type="checkbox" id="c-40703216" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#40702531">root</a><span>|</span><a href="#40703086">parent</a><span>|</span><a href="#40702624">next</a><span>|</span><label class="collapse" for="c-40703216">[-]</label><label class="expand" for="c-40703216">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right: &quot;pure&quot; is not a well-defined concept.  The well-defined concept that describes Haskell&#x27;s benefits in this regard is &quot;referential transparency&quot;. That means that this code<p><pre><code>    let x = &lt;definition of x&gt;
    in ... x ... x ... 
</code></pre>
(i.e. defining a variable x and then using it some number of times) is equivalent to<p><pre><code>    ... &lt;definition of x&gt; ... &lt;definition of x&gt; ...
</code></pre>
Seen in the opposite direction (transforming the bottom code to the top code) this means that extracting repeated code is always a valid thing to do.  It&#x27;s not valid in most other languages, and certainly no mainstream ones.</div><br/></div></div></div></div></div></div><div id="40702624" class="c"><input type="checkbox" id="c-40702624" checked=""/><div class="controls bullet"><span class="by">richrichie</span><span>|</span><a href="#40702531">parent</a><span>|</span><a href="#40702887">prev</a><span>|</span><a href="#40702833">next</a><span>|</span><label class="collapse" for="c-40702624">[-]</label><label class="expand" for="c-40702624">[3 more]</label></div><br/><div class="children"><div class="content">But why do we need Haskell for this?</div><br/><div id="40702730" class="c"><input type="checkbox" id="c-40702730" checked=""/><div class="controls bullet"><span class="by">anon291</span><span>|</span><a href="#40702531">root</a><span>|</span><a href="#40702624">parent</a><span>|</span><a href="#40702833">next</a><span>|</span><label class="collapse" for="c-40702730">[-]</label><label class="expand" for="c-40702730">[2 more]</label></div><br/><div class="children"><div class="content">Realistically we don&#x27;t but it&#x27;s very rare to meet a programmer who understands these distinctions thats not also a great functional programmer.<p>This is my experience after spending five years as a Haskell programmer and managing a Haskell team for several years and now moving back to the c++ world to play with AI.<p>I know lots of good c++ programmers working on cutting edge stuff, real experts in their field, but they sometimes still don&#x27;t have a clear way to understand how to model data<p>That is my opinion. It&#x27;s probably highly contentious.</div><br/><div id="40703185" class="c"><input type="checkbox" id="c-40703185" checked=""/><div class="controls bullet"><span class="by">cornel_io</span><span>|</span><a href="#40702531">root</a><span>|</span><a href="#40702730">parent</a><span>|</span><a href="#40702833">next</a><span>|</span><label class="collapse" for="c-40703185">[-]</label><label class="expand" for="c-40703185">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve actually had to fire a technically exceptional Haskell programmer because of the damage they did to our C# codebase (and arguably moreso, the team). Sometimes it&#x27;s not a matter of talent or skill, but culture fit.<p>In my experience FP-aligned people on non-FP projects tend to be more likely to overengineer, more prone to argue in favor of the Great Rewrite For No Reason Except Aesthetics, and more likely to abuse &quot;lesser&quot; programmers when they put up PRs. They suck as team players on teams that are not made of language nerds. I am <i>not</i> just talking about the one person here who I fired, this is a legit pattern I&#x27;ve noticed over at least a half dozen people.<p>Conversely, they are exactly the right people to deploy when you have really tough, self-contained problems to solve that you wouldn&#x27;t trust the normal Java 9-5ers to tackle.<p>No matter how they do it, you can always rewrite their working code in a more maintainable language later once it&#x27;s working, and make it integrate well with the rest of your stack. :D</div><br/></div></div></div></div></div></div></div></div><div id="40702833" class="c"><input type="checkbox" id="c-40702833" checked=""/><div class="controls bullet"><span class="by">neonate</span><span>|</span><a href="#40702531">prev</a><span>|</span><a href="#40702582">next</a><span>|</span><label class="collapse" for="c-40702833">[-]</label><label class="expand" for="c-40702833">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20240617035104&#x2F;https:&#x2F;&#x2F;duckrabbit.tech&#x2F;articles&#x2F;learning-haskell.html" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20240617035104&#x2F;https:&#x2F;&#x2F;duckrabbi...</a></div><br/></div></div><div id="40702582" class="c"><input type="checkbox" id="c-40702582" checked=""/><div class="controls bullet"><span class="by">stoorafa</span><span>|</span><a href="#40702833">prev</a><span>|</span><a href="#40702766">next</a><span>|</span><label class="collapse" for="c-40702582">[-]</label><label class="expand" for="c-40702582">[1 more]</label></div><br/><div class="children"><div class="content">Had a lot of fun reading this. I’d love to see some of the author’s code to get a sense what the journey produced, if that’s even possible</div><br/></div></div><div id="40702766" class="c"><input type="checkbox" id="c-40702766" checked=""/><div class="controls bullet"><span class="by">leononame</span><span>|</span><a href="#40702582">prev</a><span>|</span><a href="#40702725">next</a><span>|</span><label class="collapse" for="c-40702766">[-]</label><label class="expand" for="c-40702766">[5 more]</label></div><br/><div class="children"><div class="content">Great read! Can anyone here recommend a good resource for learning Haskell that&#x27;s in the style of &quot;Text-Mode Games as First Haskell Projects&quot;? Haskell has been on my radar since forever, and I&#x27;ve got some FP concepts internalized by making a side project in F#, but I have no idea what a monad really is and a fun prohect to code along might be perfect.</div><br/><div id="40702852" class="c"><input type="checkbox" id="c-40702852" checked=""/><div class="controls bullet"><span class="by">kreyenborgi</span><span>|</span><a href="#40702766">parent</a><span>|</span><a href="#40702776">next</a><span>|</span><label class="collapse" for="c-40702852">[-]</label><label class="expand" for="c-40702852">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;learn-haskell.blog&#x2F;" rel="nofollow">https:&#x2F;&#x2F;learn-haskell.blog&#x2F;</a><p>&gt; In this book, we will implement a simple static blog generator in Haskell, converting documents written in our own custom markup language to HTML.<p>&gt; We will:<p><pre><code>    Implement a tiny HTML printer library
    Define and parse our own custom markup language
    Read files and glue things together
    Add command line arguments parsing
    Write tests and documentation
</code></pre>
&gt; In each chapter of the book, we will focus on a particular task we wish to achieve, and throughout the chapter, learn just enough Haskell to complete the task.</div><br/></div></div><div id="40702776" class="c"><input type="checkbox" id="c-40702776" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40702766">parent</a><span>|</span><a href="#40702852">prev</a><span>|</span><a href="#40703102">next</a><span>|</span><label class="collapse" for="c-40702776">[-]</label><label class="expand" for="c-40702776">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been learning Unison [1] and I highly recommend. It&#x27;s a Haskell-like language, but with some really interesting ideas around how code should be managed and distributed. They also use use algebraic effects (represented with &quot;abilities&quot; in Unison) instead of Monads, which gives some interesting advantages [2].<p>[1] <a href="https:&#x2F;&#x2F;www.unison-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.unison-lang.org&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;www.unison-lang.org&#x2F;docs&#x2F;fundamentals&#x2F;abilities&#x2F;for-monadically-inclined&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.unison-lang.org&#x2F;docs&#x2F;fundamentals&#x2F;abilities&#x2F;for-...</a></div><br/></div></div><div id="40703102" class="c"><input type="checkbox" id="c-40703102" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#40702766">parent</a><span>|</span><a href="#40702776">prev</a><span>|</span><a href="#40702790">next</a><span>|</span><label class="collapse" for="c-40703102">[-]</label><label class="expand" for="c-40703102">[1 more]</label></div><br/><div class="children"><div class="content">Write a few computation Expression builders in F# and monads will quickly make sense.</div><br/></div></div><div id="40702790" class="c"><input type="checkbox" id="c-40702790" checked=""/><div class="controls bullet"><span class="by">lordwarnut</span><span>|</span><a href="#40702766">parent</a><span>|</span><a href="#40703102">prev</a><span>|</span><a href="#40702725">next</a><span>|</span><label class="collapse" for="c-40702790">[-]</label><label class="expand" for="c-40702790">[1 more]</label></div><br/><div class="children"><div class="content">Kind of ironically I&#x27;ve enjoyed the &#x27;Write Yourself a Scheme in 48 Hours&#x27;[1] which goes over how to write your own Scheme in Haskell. It introduces some of the more interesting monads although I&#x27;m not sure how idiomatic it is.<p>[1] <a href="https:&#x2F;&#x2F;en.wikibooks.org&#x2F;wiki&#x2F;Write_Yourself_a_Scheme_in_48_Hours" rel="nofollow">https:&#x2F;&#x2F;en.wikibooks.org&#x2F;wiki&#x2F;Write_Yourself_a_Scheme_in_48_...</a></div><br/></div></div></div></div><div id="40702725" class="c"><input type="checkbox" id="c-40702725" checked=""/><div class="controls bullet"><span class="by">TrackerFF</span><span>|</span><a href="#40702766">prev</a><span>|</span><a href="#40702686">next</a><span>|</span><label class="collapse" for="c-40702725">[-]</label><label class="expand" for="c-40702725">[13 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the benefit of learning a PURE functional programming language, opposed to just using a language which has adapted the best bits and pieces from the functional programming paradigm?<p>Given that you want write code that sees &quot;real world&quot; use, and is used to handle data and events from the real world. To me, sometimes the line between optimized code and intellectual curiosity blurs.</div><br/><div id="40702875" class="c"><input type="checkbox" id="c-40702875" checked=""/><div class="controls bullet"><span class="by">Skinney</span><span>|</span><a href="#40702725">parent</a><span>|</span><a href="#40702876">next</a><span>|</span><label class="collapse" for="c-40702875">[-]</label><label class="expand" for="c-40702875">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What&#x27;s the benefit of learning a PURE functional programming language<p>1. It makes it easy to learn how to structure a program in a pure way, which is hard to do in languages that offers you a easy way out.<p>2. Since &quot;everything&quot; is pure, writing tests is easier.<p>3. You know for certain that if you discard the result of a function call, all the side-effects that it would normally trigger would be stopped as well.<p>4. A program where all side-effects are guaranteed to be pushed to the boundaries, is a program that&#x27;s easy to reason about.<p>&gt; a language which has adapted the best bits and pieces [...]<p>Languages that has adapted to best bits and pieces from X, Y, Z tend to be worse than a language specifically for X, Y and Z.<p>For instance, Java supports functional programming but functional programming languages are much better at it because they were designed for that specific paradigm. In the same vein, sure you can write pure programs in F#, but not as easily as in Haskell that was designed for doing just that.<p>&gt; and is used to handle data and events from the real world<p>Pure code really only means (in practice) that side-effects are controlled, which is generally very helpful. It forces you to structure programs in a way which makes it easy to pinpoint where data is coming in, and where data is going out. It also makes for easier testing.<p>Being able to know, definetly, the answer to &quot;will calling foo perform a network request&quot; without having to read the source for foo is quite nice, especially when dealing with third-party code.<p>All this said, I probably wouldn&#x27;t begin with Haskell. A language like Elm is much better suited for learning writing pure programs.</div><br/></div></div><div id="40702876" class="c"><input type="checkbox" id="c-40702876" checked=""/><div class="controls bullet"><span class="by">elbear</span><span>|</span><a href="#40702725">parent</a><span>|</span><a href="#40702875">prev</a><span>|</span><a href="#40702878">next</a><span>|</span><label class="collapse" for="c-40702876">[-]</label><label class="expand" for="c-40702876">[5 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the benefit?<p>You start to see functions as self-contained things, as lego blocks. All the logic of the function is there in the function. It only works on values it receives as inputs (it can&#x27;t read global variables). It only outputs its results (it doesn&#x27;t assign them to some other global variable that you have to track down).<p>This makes your code modular. You can add a function in a chain of functions, if you want to perform an extra transformation. Or, you can replace a function with a different one, if you want to change something about the logic.</div><br/><div id="40703074" class="c"><input type="checkbox" id="c-40703074" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40702725">root</a><span>|</span><a href="#40702876">parent</a><span>|</span><a href="#40702878">next</a><span>|</span><label class="collapse" for="c-40703074">[-]</label><label class="expand" for="c-40703074">[4 more]</label></div><br/><div class="children"><div class="content">Is there a benefit if you&#x27;re already familiar with writing functions like that?  Is it wrong for me to expect that most programmers are already familiar with functions that only use their inputs, but treat that style as significantly more optional?<p>I wrote pure functions for a minute there but that&#x27;s not the same, a function that only uses its inputs can modify an object while a pure function would have to return a new object.  But, similarly, I bet that a lot more people know about pure functions than have any working knowledge of Haskell.</div><br/><div id="40703205" class="c"><input type="checkbox" id="c-40703205" checked=""/><div class="controls bullet"><span class="by">elbear</span><span>|</span><a href="#40702725">root</a><span>|</span><a href="#40703074">parent</a><span>|</span><a href="#40702878">next</a><span>|</span><label class="collapse" for="c-40703205">[-]</label><label class="expand" for="c-40703205">[3 more]</label></div><br/><div class="children"><div class="content">It seems you only focused on one of the conditions I mentioned.<p>You have to follow both rules: the one about inputs and the one about outputs.<p>This is like a contract. If you enforce it throughout your program, you gain some guarantees about your program as a whole.</div><br/><div id="40703392" class="c"><input type="checkbox" id="c-40703392" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40702725">root</a><span>|</span><a href="#40703205">parent</a><span>|</span><a href="#40702878">next</a><span>|</span><label class="collapse" for="c-40703392">[-]</label><label class="expand" for="c-40703392">[2 more]</label></div><br/><div class="children"><div class="content">I was looking at both rules, and specifically I was using the long version where you said &quot;it doesn&#x27;t assign them to some other global variable that you have to track down&quot;.  If you pass in a mutable object then that&#x27;s not &quot;some other global variable&quot;.<p>If I interpret &quot;It only outputs its results&quot; in a very strict way, that still allows having output and in&#x2F;out parameters.  The latter of which can break purity.<p>Though you can break purity with just inputs:<p><pre><code>  define f(o): return o.x
  let a = {x=1}
  f(a)
  a.x = 2
  f(a)
</code></pre>
If you meant to describe pure functions then that&#x27;s fine, that&#x27;s why I addressed pure functions too, but I don&#x27;t think your original description was a description of pure functions.</div><br/><div id="40703555" class="c"><input type="checkbox" id="c-40703555" checked=""/><div class="controls bullet"><span class="by">elbear</span><span>|</span><a href="#40702725">root</a><span>|</span><a href="#40703392">parent</a><span>|</span><a href="#40702878">next</a><span>|</span><label class="collapse" for="c-40703555">[-]</label><label class="expand" for="c-40703555">[1 more]</label></div><br/><div class="children"><div class="content">So, another definition of a pure function is that, for a particular input it will always return the same output.<p>Your example respects the rule:
  f({x=1}) == 1
  f({x=2}) == 2<p>But it&#x27;s true that the two rules I gave are not enough to make a function pure. Because I didn&#x27;t say anything about I&#x2F;O. So, a function that follows the rules about inputs and outputs, could still do I&#x2F;O and change its outputs based on that.<p>Starting from the question that gave birth to this whole thread: &quot;What&#x27;s the benefit of learning a PURE functional programming language...&quot;<p>The other benefit is that such a language forces you to be explicit about I&#x2F;O. It does it in such a way that even functions that do I&#x2F;O are pure. The good part is that, if you use it long enough, it can teach you the discipline to be explicit about I&#x2F;O and you can use this discipline in other languages.<p>For example, this is how I see this principles being used in Python:<p><a href="https:&#x2F;&#x2F;elbear.com&#x2F;functional-programming-principles-you-can-use-in-python" rel="nofollow">https:&#x2F;&#x2F;elbear.com&#x2F;functional-programming-principles-you-can...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="40702878" class="c"><input type="checkbox" id="c-40702878" checked=""/><div class="controls bullet"><span class="by">kreyenborgi</span><span>|</span><a href="#40702725">parent</a><span>|</span><a href="#40702876">prev</a><span>|</span><a href="#40702749">next</a><span>|</span><label class="collapse" for="c-40702878">[-]</label><label class="expand" for="c-40702878">[4 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t think of it as being all pure code, think of it as tracking in the type system which parts of your code may launch the missiles and which parts can&#x27;t. Given the following program,<p><pre><code>    main :: IO ()
    main = do
      coordinates &lt;- getCoords
      launch trajectory
      where
        trajectory = calcTrajectory coordinates
    
    getCoords :: IO Coordinates
    getCoords = -- TODO
    
    launch :: Trajectory -&gt; IO  ()
    launch = -- TODO
    
    calcTrajectory :: Coordinates -&gt; Trajectory
    calcTrajectory = -- TODO
    
</code></pre>
I can look at the types and be reasonably certain that calcTrajectory does no reads&#x2F;writes to disk or the network or anything of that sort (the part after the last arrow isn&#x27;t `IO something`), the only side effect is perhaps to heat up the CPU a bit.<p>This also nudges you in the direction of an Functional Core, Imperative Shell architecture <a href="https:&#x2F;&#x2F;www.destroyallsoftware.com&#x2F;screencasts&#x2F;catalog&#x2F;functional-core-imperative-shell" rel="nofollow">https:&#x2F;&#x2F;www.destroyallsoftware.com&#x2F;screencasts&#x2F;catalog&#x2F;funct...</a></div><br/><div id="40702932" class="c"><input type="checkbox" id="c-40702932" checked=""/><div class="controls bullet"><span class="by">foobazgt</span><span>|</span><a href="#40702725">root</a><span>|</span><a href="#40702878">parent</a><span>|</span><a href="#40703038">next</a><span>|</span><label class="collapse" for="c-40702932">[-]</label><label class="expand" for="c-40702932">[2 more]</label></div><br/><div class="children"><div class="content">FYI, I think you meant functional core, imperative shell.</div><br/><div id="40703282" class="c"><input type="checkbox" id="c-40703282" checked=""/><div class="controls bullet"><span class="by">kreyenborgi</span><span>|</span><a href="#40702725">root</a><span>|</span><a href="#40702932">parent</a><span>|</span><a href="#40703038">next</a><span>|</span><label class="collapse" for="c-40703282">[-]</label><label class="expand" for="c-40703282">[1 more]</label></div><br/><div class="children"><div class="content">haha yes, thanks!</div><br/></div></div></div></div><div id="40703038" class="c"><input type="checkbox" id="c-40703038" checked=""/><div class="controls bullet"><span class="by">Barrin92</span><span>|</span><a href="#40702725">root</a><span>|</span><a href="#40702878">parent</a><span>|</span><a href="#40702932">prev</a><span>|</span><a href="#40702749">next</a><span>|</span><label class="collapse" for="c-40703038">[-]</label><label class="expand" for="c-40703038">[1 more]</label></div><br/><div class="children"><div class="content">&gt;as tracking in the type system which parts of your code may launch the missiles<p>given that Haskell is lazy by default there&#x27;s a million ways to shoot yourself in the foot through memory leaks and performance issues (which is not unlike the problems the IO type attempts to make explicit in that domain), so I never really understand this kind of thing. Purity doesn&#x27;t say much about safety or semantics of your code. By that logic you might as well introduce a recursion type and now you&#x27;re tagging everything that is recursive because you can easily kill your program with an unexpected input in a recursive function.  To me this is just semantics you have to think through anyway, putting this into the type system just ends up creating more convoluted programs.</div><br/></div></div></div></div><div id="40702749" class="c"><input type="checkbox" id="c-40702749" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40702725">parent</a><span>|</span><a href="#40702878">prev</a><span>|</span><a href="#40702979">next</a><span>|</span><label class="collapse" for="c-40702749">[-]</label><label class="expand" for="c-40702749">[1 more]</label></div><br/><div class="children"><div class="content">This is all myth.  People don&#x27;t write Haskell, because they read why other non-Haskellers also don&#x27;t write Haskell, based on what other non-Haskellers wrote.<p>&gt; a language which has adapted the best bits and pieces from the functional programming paradigm?<p>Why write in a statically-typed language when dynamically-typed languages have adapted the best bits and pieces from statically-typed languages?</div><br/></div></div><div id="40702979" class="c"><input type="checkbox" id="c-40702979" checked=""/><div class="controls bullet"><span class="by">zogrodea</span><span>|</span><a href="#40702725">parent</a><span>|</span><a href="#40702749">prev</a><span>|</span><a href="#40702686">next</a><span>|</span><label class="collapse" for="c-40702979">[-]</label><label class="expand" for="c-40702979">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t speak for others, but I never really understood the benefits of functional programming when my language pretty much allowed unbounded mutation anywhere. I would say there&#x27;s a chance for impure languages to impede you in learning what functional programming is about (or at least my experience with F# and OCaml did not really help as much as it otherwise could have I think).<p>Your mileage might vary, but I&#x27;ve heard advice from others to learn Haskell and &quot;go off the deep-end&quot; because of people citing similar reasons.</div><br/></div></div></div></div><div id="40702686" class="c"><input type="checkbox" id="c-40702686" checked=""/><div class="controls bullet"><span class="by">colejhudson</span><span>|</span><a href="#40702725">prev</a><span>|</span><label class="collapse" for="c-40702686">[-]</label><label class="expand" for="c-40702686">[1 more]</label></div><br/><div class="children"><div class="content">lol real</div><br/></div></div></div></div></div></div></div></body></html>