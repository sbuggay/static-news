<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1730710881540" as="style"/><link rel="stylesheet" href="styles.css?v=1730710881540"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://yoric.github.io/post/programming-languages-that-blew-my-mind/">Programming languages that blew my mind (2023)</a> <span class="domain">(<a href="https://yoric.github.io">yoric.github.io</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>112 comments</span></div><br/><div><div id="42035735" class="c"><input type="checkbox" id="c-42035735" checked=""/><div class="controls bullet"><span class="by">shawa_a_a</span><span>|</span><a href="#42036491">next</a><span>|</span><label class="collapse" for="c-42035735">[-]</label><label class="expand" for="c-42035735">[9 more]</label></div><br/><div class="children"><div class="content">I would second Prolog as mind-blowing. I&#x27;ve found you&#x27;re typically confronted with fully engaging with the core of whatever problem you&#x27;re solving, and only that core. This is probably what can make it so frustrating sometimes as you have no option but to work out the hard stuff nearly immediately; not to mention that unconsidered edge cases, mistakes can cause some pretty opaquely wrong results, or the query not terminating, which can make conventional debugging pretty difficult. The guarantees you get with using the &#x27;pure&#x27; core of Prolog do open up some really interesting avenues though, for example Scryer&#x27;s debugging library is quite neat in affording _semantic_ debugging: <a href="https:&#x2F;&#x2F;www.scryer.pl&#x2F;debug" rel="nofollow">https:&#x2F;&#x2F;www.scryer.pl&#x2F;debug</a><p>Just some additional commentary too - I think this post quite misrepresents it with some of the comparisons.<p>Prolog at its core is SLD Resolution [1] (a form of search) over Horn Clauses [2] (first order logic). Queries posted to the runtime are attempts to find a set of values which will satisfy (cause to be true) the query – whilst SQL is founded on relational algebra which more closely aligned with set theory.<p>Whilst there&#x27;s probably some isomorphism between satisfying&#x2F;refuting a logical predicate, and performing various set operations, I&#x27;d say it&#x27;s a bit of a confusion of ideas to say that SQL is based on &#x27;a subset of Prolog&#x27;. The author might be thinking about Datalog [3], which is indeed a syntactic subset of Prolog.<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SLD_resolution" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SLD_resolution</a>
[2]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Horn_clause" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Horn_clause</a>
[3]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Datalog" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Datalog</a></div><br/><div id="42038214" class="c"><input type="checkbox" id="c-42038214" checked=""/><div class="controls bullet"><span class="by">Claudus</span><span>|</span><a href="#42035735">parent</a><span>|</span><a href="#42038561">next</a><span>|</span><label class="collapse" for="c-42038214">[-]</label><label class="expand" for="c-42038214">[2 more]</label></div><br/><div class="children"><div class="content">I remember learning Prolog, it was tricky to wrap my mind around it, it wasn’t like any other language. The day I finally “got it” I was very happy, until I realized all the other languages I had previously learned, no longer made any sense.</div><br/><div id="42038748" class="c"><input type="checkbox" id="c-42038748" checked=""/><div class="controls bullet"><span class="by">dtjohnnymonkey</span><span>|</span><a href="#42035735">root</a><span>|</span><a href="#42038214">parent</a><span>|</span><a href="#42038561">next</a><span>|</span><label class="collapse" for="c-42038748">[-]</label><label class="expand" for="c-42038748">[1 more]</label></div><br/><div class="children"><div class="content">I remember taking a PL class in undergrad, learning Prolog as one of a handful of languages.  During that section my brain started to want to &quot;bind&quot; variables to things as I was going about my day, it was very weird.</div><br/></div></div></div></div><div id="42038561" class="c"><input type="checkbox" id="c-42038561" checked=""/><div class="controls bullet"><span class="by">__rito__</span><span>|</span><a href="#42035735">parent</a><span>|</span><a href="#42038214">prev</a><span>|</span><a href="#42038601">next</a><span>|</span><label class="collapse" for="c-42038561">[-]</label><label class="expand" for="c-42038561">[4 more]</label></div><br/><div class="children"><div class="content">What Prolog resources would you recommend for someone to learn it and a blown mind?</div><br/><div id="42038883" class="c"><input type="checkbox" id="c-42038883" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#42035735">root</a><span>|</span><a href="#42038561">parent</a><span>|</span><a href="#42038601">next</a><span>|</span><label class="collapse" for="c-42038883">[-]</label><label class="expand" for="c-42038883">[3 more]</label></div><br/><div class="children"><div class="content">A previous HN discussion - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40994552">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40994552</a></div><br/><div id="42039204" class="c"><input type="checkbox" id="c-42039204" checked=""/><div class="controls bullet"><span class="by">__rito__</span><span>|</span><a href="#42035735">root</a><span>|</span><a href="#42038883">parent</a><span>|</span><a href="#42038601">next</a><span>|</span><label class="collapse" for="c-42039204">[-]</label><label class="expand" for="c-42039204">[2 more]</label></div><br/><div class="children"><div class="content">Thanks!</div><br/><div id="42039527" class="c"><input type="checkbox" id="c-42039527" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#42035735">root</a><span>|</span><a href="#42039204">parent</a><span>|</span><a href="#42038601">next</a><span>|</span><label class="collapse" for="c-42039527">[-]</label><label class="expand" for="c-42039527">[1 more]</label></div><br/><div class="children"><div class="content">While i am not too familiar with Prolog, i have been intending to study it in depth given that it can be used to design Languages&#x2F;DSLs&#x2F;Expert Systems&#x2F;ML.
Here are some resources which i have been collecting;<p>1) <i>Formal Syntax and Semantics of Programming Languages: A Laboratory-Based Approach</i> by Ken Slonneger uses Prolog to design&#x2F;implement languages - <a href="http:&#x2F;&#x2F;homepage.divms.uiowa.edu&#x2F;~slonnegr&#x2F;" rel="nofollow">http:&#x2F;&#x2F;homepage.divms.uiowa.edu&#x2F;~slonnegr&#x2F;</a> and <a href="https:&#x2F;&#x2F;homepage.cs.uiowa.edu&#x2F;~slonnegr&#x2F;plf&#x2F;Book&#x2F;" rel="nofollow">https:&#x2F;&#x2F;homepage.cs.uiowa.edu&#x2F;~slonnegr&#x2F;plf&#x2F;Book&#x2F;</a><p>2) <i>Defining and Implementing Domain-Specific Languages with Prolog</i> (PhD thesis of Falco Nogatz) pdf here - <a href="https:&#x2F;&#x2F;opus.bibliothek.uni-wuerzburg.de&#x2F;opus4-wuerzburg&#x2F;files&#x2F;30187&#x2F;Nogatz_Falco_Thesis.pdf" rel="nofollow">https:&#x2F;&#x2F;opus.bibliothek.uni-wuerzburg.de&#x2F;opus4-wuerzburg&#x2F;fil...</a><p>3) <i>Use Prolog to improve LLM&#x27;s reasoning</i> HN thread - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41831735">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41831735</a><p>4) User &quot;bytebach&quot; gives an example of using Prolog as an intermediate DSL in the prompt to an LLM so as to transform English declarative -&gt; Imperative code - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41549823">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41549823</a><p>5) <i>Prolog in the LLM Era</i> (a series by Eugene Asahara) - <a href="https:&#x2F;&#x2F;eugeneasahara.com&#x2F;category&#x2F;prolog-in-the-llm-era&#x2F;" rel="nofollow">https:&#x2F;&#x2F;eugeneasahara.com&#x2F;category&#x2F;prolog-in-the-llm-era&#x2F;</a></div><br/></div></div></div></div></div></div></div></div><div id="42038601" class="c"><input type="checkbox" id="c-42038601" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#42035735">parent</a><span>|</span><a href="#42038561">prev</a><span>|</span><a href="#42037625">next</a><span>|</span><label class="collapse" for="c-42038601">[-]</label><label class="expand" for="c-42038601">[1 more]</label></div><br/><div class="children"><div class="content">Would you recommend prolog over datalog for someone looking for something new that doesn&#x27;t have to be related to their work in data analytics?</div><br/></div></div><div id="42037625" class="c"><input type="checkbox" id="c-42037625" checked=""/><div class="controls bullet"><span class="by">llsf</span><span>|</span><a href="#42035735">parent</a><span>|</span><a href="#42038601">prev</a><span>|</span><a href="#42036491">next</a><span>|</span><label class="collapse" for="c-42037625">[-]</label><label class="expand" for="c-42037625">[1 more]</label></div><br/><div class="children"><div class="content">Same Prolog, and particularly Lambda Prolog literally blew my mind.  I could (physically) feel my brain, trying to think differently about the problem to solve.  It was an experience.
I need to retake that course (was 20 years ago...).  I also wonder if&#x2F;how AI could leverage lambda prolog to prove things.</div><br/></div></div></div></div><div id="42036491" class="c"><input type="checkbox" id="c-42036491" checked=""/><div class="controls bullet"><span class="by">MarkMarine</span><span>|</span><a href="#42035735">prev</a><span>|</span><a href="#42039717">next</a><span>|</span><label class="collapse" for="c-42036491">[-]</label><label class="expand" for="c-42036491">[12 more]</label></div><br/><div class="children"><div class="content">My mind blown experience was listening to a Rich Hickey talk (maybe not [1]) that flipped upside down my accepted method of thinking about types and type system paradigms. I still love writing Haskell and Rust, but I see the warts that he is so concisely pointing out. The either type really sticks out to me now, and I see the problems with overtyping what are essentially maps, and how rigid that makes every aspect of your programs. Currently I deal with a fairly large go monolith that had some clean code practices in it, and changing a single field that is going to make it into the public API ends up being hundreds or thousands of lines of changes. Such a waste of time to CRUD what is a map of strings.<p>1. <a href="https:&#x2F;&#x2F;youtu.be&#x2F;YR5WdGrpoug?si=jRsXcYlwRuz0C1IN" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;YR5WdGrpoug?si=jRsXcYlwRuz0C1IN</a></div><br/><div id="42037488" class="c"><input type="checkbox" id="c-42037488" checked=""/><div class="controls bullet"><span class="by">Jeff_Brown</span><span>|</span><a href="#42036491">parent</a><span>|</span><a href="#42037631">next</a><span>|</span><label class="collapse" for="c-42037488">[-]</label><label class="expand" for="c-42037488">[10 more]</label></div><br/><div class="children"><div class="content">I believe you that he&#x27;s being concise but don&#x27;t have time to watch an hour video even at 2x. Can you summarize? (I got to where he was talking about how introducing Maybe in breaking ways will break things, thought &quot;duh&quot; and quit watching.)</div><br/><div id="42037546" class="c"><input type="checkbox" id="c-42037546" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#42036491">root</a><span>|</span><a href="#42037488">parent</a><span>|</span><a href="#42038283">next</a><span>|</span><label class="collapse" for="c-42037546">[-]</label><label class="expand" for="c-42037546">[7 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t have half an hour to spare any time in the near future? But you do have the time to scroll HN and comment?<p>I&#x27;m not a huge fan of videos as content delivery mechanisms for simple facts, but this is a talk - an argument made with the intent of convincing you about something that you may find counter-intuitive. What&#x27;s the point of summarising that, if it loses the granularity of the argument, its persuasive power? &quot;Static types bad, Clojure good?&quot;</div><br/><div id="42038590" class="c"><input type="checkbox" id="c-42038590" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#42036491">root</a><span>|</span><a href="#42037546">parent</a><span>|</span><a href="#42037776">next</a><span>|</span><label class="collapse" for="c-42038590">[-]</label><label class="expand" for="c-42038590">[1 more]</label></div><br/><div class="children"><div class="content">What persuasive power are you going to lose if you cut out the jokes that 5-year plan is stripes? And that&#x27;s the first 3% of the talk, so pure lossless compression<p>&gt; &quot;Static types bad, Clojure good?&quot;<p>sure, this kind of summary is useless, but then is simply too short</div><br/></div></div><div id="42037776" class="c"><input type="checkbox" id="c-42037776" checked=""/><div class="controls bullet"><span class="by">albedoa</span><span>|</span><a href="#42036491">root</a><span>|</span><a href="#42037546">parent</a><span>|</span><a href="#42038590">prev</a><span>|</span><a href="#42038196">next</a><span>|</span><label class="collapse" for="c-42037776">[-]</label><label class="expand" for="c-42037776">[2 more]</label></div><br/><div class="children"><div class="content">There is no shortage of long talks that lack nuance. Just say that no, you can&#x27;t effectively summarize this video, instead of doing whatever it is that you are doing here.</div><br/><div id="42038162" class="c"><input type="checkbox" id="c-42038162" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#42036491">root</a><span>|</span><a href="#42037776">parent</a><span>|</span><a href="#42038196">next</a><span>|</span><label class="collapse" for="c-42038162">[-]</label><label class="expand" for="c-42038162">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There is no shortage of long talks that lack nuance.<p>Nuance is not the same thing as a talk designed to build an argument bit by bit and be persuasive. You <i>could</i> summarise an hour-long closing argument for the defence in a jury trial as &#x27;My client is not guilty&#x27;, but doing so is rather missing the point.<p>&gt; Just say that no, you can&#x27;t effectively summarize this video, instead of doing whatever it is that you are doing here.<p>x == y, but with the added implication that SBF&#x27;s take on longform is not actually something to <i>aspire</i> to.</div><br/></div></div></div></div><div id="42038196" class="c"><input type="checkbox" id="c-42038196" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42036491">root</a><span>|</span><a href="#42037546">parent</a><span>|</span><a href="#42037776">prev</a><span>|</span><a href="#42038283">next</a><span>|</span><label class="collapse" for="c-42038196">[-]</label><label class="expand" for="c-42038196">[3 more]</label></div><br/><div class="children"><div class="content">The point of summarizing is to condense the substance for potentially hundreds of readers into a sensible set of ideas in a couple of paragraphs. Any wise listener will stay away from talks that need full half an hour to stay “persuasive”.</div><br/><div id="42038236" class="c"><input type="checkbox" id="c-42038236" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#42036491">root</a><span>|</span><a href="#42038196">parent</a><span>|</span><a href="#42038283">next</a><span>|</span><label class="collapse" for="c-42038236">[-]</label><label class="expand" for="c-42038236">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; The point of summarizing is to condense the substance for potentially hundreds of readers into a sensible set of ideas in a couple of paragraphs. Any wise listener will stay away from talks that need full half an hour to stay “persuasive”.<p>“I don’t want to say no book is ever worth reading, but I actually do believe something pretty close to that. … If you wrote a book, you f&#x27;ed up, and it should have been a six-paragraph blog post.” -Sam Bankman-Fried</div><br/></div></div></div></div></div></div><div id="42038283" class="c"><input type="checkbox" id="c-42038283" checked=""/><div class="controls bullet"><span class="by">MarkMarine</span><span>|</span><a href="#42036491">root</a><span>|</span><a href="#42037488">parent</a><span>|</span><a href="#42037546">prev</a><span>|</span><a href="#42037507">next</a><span>|</span><label class="collapse" for="c-42038283">[-]</label><label class="expand" for="c-42038283">[1 more]</label></div><br/><div class="children"><div class="content">I’m not Rich, I think to summarize what he’s saying I’d need to have a better grasp of the subject material than he does.<p>I’ve actually struggled to get people on my team to understand what is so great about this language or the ideas behind it. Pointing people at 1 hour long YouTube videos that almost need to understand the source language to see examples of what he’s talking about haven’t been working.<p>I’ll think hard on how to summarize this without needing the context I have and come back to this comment. It won’t be what he’d say but I’ll share my view</div><br/></div></div><div id="42037507" class="c"><input type="checkbox" id="c-42037507" checked=""/><div class="controls bullet"><span class="by">rayxi271828</span><span>|</span><a href="#42036491">root</a><span>|</span><a href="#42037488">parent</a><span>|</span><a href="#42038283">prev</a><span>|</span><a href="#42037631">next</a><span>|</span><label class="collapse" for="c-42037507">[-]</label><label class="expand" for="c-42037507">[1 more]</label></div><br/><div class="children"><div class="content">Pass the link to NotebookLM and get the podcast hosts to summarize it for you?</div><br/></div></div></div></div><div id="42037631" class="c"><input type="checkbox" id="c-42037631" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#42036491">parent</a><span>|</span><a href="#42037488">prev</a><span>|</span><a href="#42039717">next</a><span>|</span><label class="collapse" for="c-42037631">[-]</label><label class="expand" for="c-42037631">[1 more]</label></div><br/><div class="children"><div class="content">My mind wasn&#x27;t exactly blown; indeed that talk and its arguments give me a sense of deja vu. And then I remembered some of the arguments behind Google&#x27;s protobuf removing required&#x2F;optional fields in proto3. It&#x27;s really the same argument. And that argument is a fairly narrow one when it comes to representing business logic data. You still need Maybe&#x2F;option types when you are dealing with computer science data. If you are implementing your own linked list, you are going to need that Maybe or option type.</div><br/></div></div></div></div><div id="42039717" class="c"><input type="checkbox" id="c-42039717" checked=""/><div class="controls bullet"><span class="by">wwwlouishinofun</span><span>|</span><a href="#42036491">prev</a><span>|</span><a href="#42037809">next</a><span>|</span><label class="collapse" for="c-42039717">[-]</label><label class="expand" for="c-42039717">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been dreaming: can the era of learning foreign languages come to an end now?<p>Are there large models that fully learn all programming language design principles and all user codes?<p>Truly achieving natural language programming.</div><br/></div></div><div id="42037809" class="c"><input type="checkbox" id="c-42037809" checked=""/><div class="controls bullet"><span class="by">archargelod</span><span>|</span><a href="#42039717">prev</a><span>|</span><a href="#42035139">next</a><span>|</span><label class="collapse" for="c-42037809">[-]</label><label class="expand" for="c-42037809">[2 more]</label></div><br/><div class="children"><div class="content">I started learning programming with modern dialect of BASIC and when I first tried Lua, I&#x27;ve had my mind blown when I discovered:<p><pre><code>  - tables (hashmap)
  - regex
  - pass by reference (caused a lot of confusion and frustrating bugs)
  - metatables
  - goto and labels
  - multiple return values
</code></pre>
After Lua I did want to try a language that&#x27;s fast, something compiled to small native binary. My choice was Nim. And Nim got my mind blown to pieces:<p><pre><code>  - static types
  - function declarations I can understand how to use without reading their code
  - functional paradigm
  - batteries included standard library
  - compile-time functions
  - generics
  - templates
  - macros
  - exploring and manipulating AST
  - const, let, var (immutability)
  - pointers and references
  - compiler optimizations
  - move semantics
  - memory management
  - I can compile code to both javascript and C?!
  - C, C++ and JS interop (ffi)
  - I can read and understand source code of standard library procedures?!
  - huh, my computer is fast, like crazy fast!!
  - and probably more, but that&#x27;s what I can recall now..</code></pre></div><br/><div id="42039079" class="c"><input type="checkbox" id="c-42039079" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42037809">parent</a><span>|</span><a href="#42035139">next</a><span>|</span><label class="collapse" for="c-42039079">[-]</label><label class="expand" for="c-42039079">[1 more]</label></div><br/><div class="children"><div class="content">Lua is absolutely pass by value. You’re probably mixing container values with by-reference, that is a common mistake. Pass by reference means that an assignment to an argument updates the variable at the call site, e.g.:<p><pre><code>  local x = 0
  function f(byref arg)
    arg = 1
  end
  f(x) -- x == 1
</code></pre>
Except that there’s no “byref” in Lua and no way to access the original argument’s location (commonly “lvalue”).<p>Passing a table to a function and not receiving a deep&#x2F;shallow copy is still “by value”, not “by reference”, because “by” here is about variables (lvalues), not values.<p>Edit: removed more confusing parts</div><br/></div></div></div></div><div id="42035139" class="c"><input type="checkbox" id="c-42035139" checked=""/><div class="controls bullet"><span class="by">freedomben</span><span>|</span><a href="#42037809">prev</a><span>|</span><a href="#42037207">next</a><span>|</span><label class="collapse" for="c-42035139">[-]</label><label class="expand" for="c-42035139">[6 more]</label></div><br/><div class="children"><div class="content">Very much agree with Erlang&#x2F;Elixir.  After years battling and hating the JVM, I was initially very put off by the existence of a VM (BEAM) and by how it forced the concurrency model on me, and it did make getting into serious development with it harder, but once I &quot;got&quot; it, it really blew my mind.  The &quot;let it fail&quot; philosophy was particularly mindblowing to me (especially once I understood that it <i>doesn&#x27;t</i> mean &quot;don&#x27;t do error handling&quot;).</div><br/><div id="42035629" class="c"><input type="checkbox" id="c-42035629" checked=""/><div class="controls bullet"><span class="by">sodapopcan</span><span>|</span><a href="#42035139">parent</a><span>|</span><a href="#42037207">next</a><span>|</span><label class="collapse" for="c-42035629">[-]</label><label class="expand" for="c-42035629">[5 more]</label></div><br/><div class="children"><div class="content">Ya, &quot;let it fail&quot; is a semi-unfortunate tag line.  A lot of people think it means literally to not handle <i>any</i> errors ever and get really frustrated.</div><br/><div id="42036013" class="c"><input type="checkbox" id="c-42036013" checked=""/><div class="controls bullet"><span class="by">spinningslate</span><span>|</span><a href="#42035139">root</a><span>|</span><a href="#42035629">parent</a><span>|</span><a href="#42036715">next</a><span>|</span><label class="collapse" for="c-42036013">[-]</label><label class="expand" for="c-42036013">[2 more]</label></div><br/><div class="children"><div class="content">Indeed.  OTOH, &quot;focus your main code on the happy path, and put your error handling in the supervisor tree&quot; is unfortunately a bit less pithy.<p>Shades of &quot;boring technology&quot;[0] which might better be described as &quot;choose technology that is a good fit for the problem, proven, reliable and proportionate.  Spend your innovation tokens sparingly and wisely&quot;.<p>[0]: <a href="https:&#x2F;&#x2F;boringtechnology.club&#x2F;" rel="nofollow">https:&#x2F;&#x2F;boringtechnology.club&#x2F;</a></div><br/><div id="42038114" class="c"><input type="checkbox" id="c-42038114" checked=""/><div class="controls bullet"><span class="by">closeparen</span><span>|</span><a href="#42035139">root</a><span>|</span><a href="#42036013">parent</a><span>|</span><a href="#42036715">next</a><span>|</span><label class="collapse" for="c-42038114">[-]</label><label class="expand" for="c-42038114">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m personally caught between my attachment to the &quot;boring technology&quot; philosophy and my desire to try Elixir, which seems like exactly the kind of obscure and exotic technology that it rejects.</div><br/></div></div></div></div><div id="42036715" class="c"><input type="checkbox" id="c-42036715" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#42035139">root</a><span>|</span><a href="#42035629">parent</a><span>|</span><a href="#42036013">prev</a><span>|</span><a href="#42037207">next</a><span>|</span><label class="collapse" for="c-42036715">[-]</label><label class="expand" for="c-42036715">[2 more]</label></div><br/><div class="children"><div class="content">Joe Armstrong distinguishes in his thesis between exceptions and errors: exceptions are when the runtime system doesn&#x27;t know what to do, and errors are when the programmer doesn&#x27;t know what to do.<p>Say your code divides by 0; the runtime system can&#x27;t handle 1&#x2F;0 but you the programmer may have anticipated this and know what to do. This is just someplace you write code right there to handle the case (catch an exception, pattern match the 0 case beforehand, whatever).<p>Your error, on the other hand, means something you expected to hold didn&#x27;t; recovery inline from unknown unknowns is a fool&#x27;s errand. Instead you give up and die, and the problem is now the exception you know how to handle &quot;my child process died&quot;.</div><br/><div id="42038504" class="c"><input type="checkbox" id="c-42038504" checked=""/><div class="controls bullet"><span class="by">dhc02</span><span>|</span><a href="#42035139">root</a><span>|</span><a href="#42036715">parent</a><span>|</span><a href="#42037207">next</a><span>|</span><label class="collapse" for="c-42038504">[-]</label><label class="expand" for="c-42038504">[1 more]</label></div><br/><div class="children"><div class="content">This really added something to my way of thinking about this. Thanks.</div><br/></div></div></div></div></div></div></div></div><div id="42037207" class="c"><input type="checkbox" id="c-42037207" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#42035139">prev</a><span>|</span><a href="#42035111">next</a><span>|</span><label class="collapse" for="c-42037207">[-]</label><label class="expand" for="c-42037207">[3 more]</label></div><br/><div class="children"><div class="content">My university had essentially a weird-languages course to blow our minds. Smalltalk (everything is a message to an object, back when C++ was the new hotness), Lisp (everything is a sexpr that you can redefine), Prolog (everything is a clause to search for known axioms).<p>Later: Lisp again, because of closures and CLOS let you program how method dispatch should work and CLCS let you resume from just before an error. Haskell, because you can lazily consume an infinite structure, and every type contains _|_ because you can&#x27;t be sure that every function will always return a value. Java, back when the language was poor but the promise was &quot;don&#x27;t send a query, send code that the backend will run securely&quot; (this was abandoned).</div><br/><div id="42037265" class="c"><input type="checkbox" id="c-42037265" checked=""/><div class="controls bullet"><span class="by">owyn</span><span>|</span><a href="#42037207">parent</a><span>|</span><a href="#42035111">next</a><span>|</span><label class="collapse" for="c-42037265">[-]</label><label class="expand" for="c-42037265">[2 more]</label></div><br/><div class="children"><div class="content"><i>the promise was &quot;don&#x27;t send a query, send code that the backend will run securely&quot;</i><p>This is back now with WASM!</div><br/><div id="42037288" class="c"><input type="checkbox" id="c-42037288" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#42037207">root</a><span>|</span><a href="#42037265">parent</a><span>|</span><a href="#42035111">next</a><span>|</span><label class="collapse" for="c-42037288">[-]</label><label class="expand" for="c-42037288">[1 more]</label></div><br/><div class="children"><div class="content">Thank you, it had not occurred to me that Node.js and Deno offered that, but of course they do.</div><br/></div></div></div></div></div></div><div id="42035111" class="c"><input type="checkbox" id="c-42035111" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#42037207">prev</a><span>|</span><a href="#42035233">next</a><span>|</span><label class="collapse" for="c-42035111">[-]</label><label class="expand" for="c-42035111">[26 more]</label></div><br/><div class="children"><div class="content">Go really blew me away with its explicit error handling. As someone who has come from the OOP cult of clean code and other useless principles that haven’t led our industry to have less messes over the past 20-30 years. Who was slowly moving into the “simplicity”, “build things that can be easily deleted”, “YAGNI” mindset it simply clicked.<p>Then Rust took it a few levels beyond Go.<p>It’s a really good list, I suspect the languages you add is going to spend on your experience. So I wouldn’t feel too sad if your favorite language is on that list. The author lists Java as a language with an amazing standard library, but something tells me a lot of people will have C#, Go or similar as their Java, and that’s fine!</div><br/><div id="42035700" class="c"><input type="checkbox" id="c-42035700" checked=""/><div class="controls bullet"><span class="by">scubbo</span><span>|</span><a href="#42035111">parent</a><span>|</span><a href="#42036098">next</a><span>|</span><label class="collapse" for="c-42035700">[-]</label><label class="expand" for="c-42035700">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m still convinced that Rust does it _right_ by allowing you to &quot;chain through&quot; errors using `Result`. Having to pepper `if err != nil { return ..., err}` repeatedly into your code is just distracting from the core logic - 99% of the time, that&#x27;s the response anyway, so being able to just write your happy-case logic and have an implicit &quot;but if there are any errors, return them immediately&quot; (but still returned as a value rather than thrown as an orthogonal Exception) is the best of both worlds.</div><br/><div id="42035895" class="c"><input type="checkbox" id="c-42035895" checked=""/><div class="controls bullet"><span class="by">ChadNauseam</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42035700">parent</a><span>|</span><a href="#42036098">next</a><span>|</span><label class="collapse" for="c-42035895">[-]</label><label class="expand" for="c-42035895">[4 more]</label></div><br/><div class="children"><div class="content">It is really great. I just wish there was a better story for combining error types. thiserror works, but it’s annoying boilerplate to have to write imo.</div><br/><div id="42036951" class="c"><input type="checkbox" id="c-42036951" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42035895">parent</a><span>|</span><a href="#42037330">next</a><span>|</span><label class="collapse" for="c-42036951">[-]</label><label class="expand" for="c-42036951">[2 more]</label></div><br/><div class="children"><div class="content">When you require that your &quot;algebraic&quot; types always be tagged, so that `type X = A + B` and `type Y = A + B` are always different, you lose most of your capacity of seamlessly composing the types.<p>In other words, Rust doesn&#x27;t have a type that means &quot;either IO Error or Network Error&quot;, so it can&#x27;t just compose those two behind the scenes into something that you can later decompose. You have to create some tag, and tell the compiler how to apply the tag, because each tag is different.</div><br/><div id="42038359" class="c"><input type="checkbox" id="c-42038359" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42036951">parent</a><span>|</span><a href="#42037330">next</a><span>|</span><label class="collapse" for="c-42038359">[-]</label><label class="expand" for="c-42038359">[1 more]</label></div><br/><div class="children"><div class="content">That’s a good way to put it. Lots about Rust is great, but the lack of anonymous union types over complicates a lot of problems. The trait system would be much less of a headache if you could define a local child types as well.</div><br/></div></div></div></div><div id="42037330" class="c"><input type="checkbox" id="c-42037330" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42035895">parent</a><span>|</span><a href="#42036951">prev</a><span>|</span><a href="#42036098">next</a><span>|</span><label class="collapse" for="c-42037330">[-]</label><label class="expand" for="c-42037330">[1 more]</label></div><br/><div class="children"><div class="content">The anyhow crate complements thiserror pretty well in my experience.  I use it &quot;top-down&quot; facing where individual errors in any component are defined with thiserror, but then we bubble them up by wrapping them in a `anyhow::Error` if we don&#x27;t know what to do with them.  It also has the nice thing of being able to produce simplified stack traces to help diagnose where things are going wrong.  And then you can downcast to component-level thiserror Errors if you want to inspect something closely from high up.</div><br/></div></div></div></div></div></div><div id="42036098" class="c"><input type="checkbox" id="c-42036098" checked=""/><div class="controls bullet"><span class="by">jasongill</span><span>|</span><a href="#42035111">parent</a><span>|</span><a href="#42035700">prev</a><span>|</span><a href="#42035233">next</a><span>|</span><label class="collapse" for="c-42036098">[-]</label><label class="expand" for="c-42036098">[20 more]</label></div><br/><div class="children"><div class="content">I have been using Golang recently and have the exact opposite feeling about it, which is likely due to my limited exposure to it. Needing to constantly check if a specific return value is not nil just seems so sloppy but I have yet to come across a &quot;better&quot; way as it appears to just be a Golang convention. Is there a good post about better ways to handle errors in Go?</div><br/><div id="42036215" class="c"><input type="checkbox" id="c-42036215" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42036098">parent</a><span>|</span><a href="#42036881">next</a><span>|</span><label class="collapse" for="c-42036215">[-]</label><label class="expand" for="c-42036215">[6 more]</label></div><br/><div class="children"><div class="content">This is the better way as far as I’m concerned. Go has a philosophy to be simple, and this is explicit error handling at its simplest. You deal with errors exactly where they occur. I think a lot of people simply prefer implicit error handling and long exception chains. There is nothing wrong with that but that’s not how Go does error handling.<p>After a couple of decades in the industry I really prefer explicit error handling because while powerful implicit error handling is also easy to get wrong. Which means I have to go through ridiculous chains of exceptions to find some error someone introduced years ago, instead of being able of heading directly to it and immediately understanding what is going on. So I guess it’s a little contradictory that I prefer the Rust approach, but I think the compromise of added complexity is small enough to make up for the added safety and “manoeuvrability”.<p>The flip-side is of course that Go’s simplicity is part of the reason it’s seeing a lot of adoption while most other “new” languages aren’t. (Depending on where you live).</div><br/><div id="42038207" class="c"><input type="checkbox" id="c-42038207" checked=""/><div class="controls bullet"><span class="by">closeparen</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42036215">parent</a><span>|</span><a href="#42039147">next</a><span>|</span><label class="collapse" for="c-42038207">[-]</label><label class="expand" for="c-42038207">[1 more]</label></div><br/><div class="children"><div class="content">Almost all error-related code in Go is just doing by hand what an exception system would do automatically: stop the current function and propagate it to the caller. The error is not being &quot;dealt with&quot; in a meaningful way except at the outermost layers of the onion (i.e. HTTP&#x2F;RPC middleware converting it to a wire protocol error response) which could have used a try&#x2F;catch anyway.</div><br/></div></div><div id="42039147" class="c"><input type="checkbox" id="c-42039147" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42036215">parent</a><span>|</span><a href="#42038207">prev</a><span>|</span><a href="#42036541">next</a><span>|</span><label class="collapse" for="c-42039147">[-]</label><label class="expand" for="c-42039147">[1 more]</label></div><br/><div class="children"><div class="content"><i>Go has a philosophy to be simple, and this is explicit error handling at its simplest. You deal with errors exactly where they occur.</i><p>“if err != nil {return nil, err}” is the opposite of this philosophy. If you find yourself passing err up the call stack most of the times and most calls may return err, it’s still exception-driven code but without ergonomics.<p>It’s not simplicity, it’s head butt deep in the sand.</div><br/></div></div><div id="42036541" class="c"><input type="checkbox" id="c-42036541" checked=""/><div class="controls bullet"><span class="by">treflop</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42036215">parent</a><span>|</span><a href="#42039147">prev</a><span>|</span><a href="#42036881">next</a><span>|</span><label class="collapse" for="c-42036541">[-]</label><label class="expand" for="c-42036541">[3 more]</label></div><br/><div class="children"><div class="content">I prefer implicit error handling if exceptions are checked and defined as part of the contract, otherwise it’s definitely hard to trace.<p>I know the biggest complaint with checked exceptions is that people tend to just use catch all exceptions, but that’s just sloppy work. If they’re a junior, that’s when you teach them. Otherwise, people who do sloppy work are just sloppy everywhere anyway.</div><br/><div id="42037663" class="c"><input type="checkbox" id="c-42037663" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42036541">parent</a><span>|</span><a href="#42036881">next</a><span>|</span><label class="collapse" for="c-42037663">[-]</label><label class="expand" for="c-42037663">[2 more]</label></div><br/><div class="children"><div class="content">My issue with a lot of the best practice principles in SWE is that they were written for a perfect world. Even the best developers are going to do sloppy work on a Thursday afternoon after a day of shitty meetings during a week of almost no sleep because their babies were crying. Then there are there times when people have to cut corners because the business demands it. A million little things like that, which eventually leads to code bases which people like Uncle Bob will tell you were made by people who “misunderstood” the principles.<p>Simplicity works because it’s made for the real world. As I said I personally think Rust did it better, but if you asked me to come help a company fix a codebase I’d rather do it for a Go one than Rust.</div><br/><div id="42038128" class="c"><input type="checkbox" id="c-42038128" checked=""/><div class="controls bullet"><span class="by">treflop</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42037663">parent</a><span>|</span><a href="#42036881">next</a><span>|</span><label class="collapse" for="c-42038128">[-]</label><label class="expand" for="c-42038128">[1 more]</label></div><br/><div class="children"><div class="content">Truthfully, I disagree. I’ve worked at a few different companies and I could absolutely rank them in the quality of their staff.<p>Been on teams where every individual was free to use their best judgement, we didn’t have a lot of documented processes, and… nothing ever went wrong. Everyone knew sloppy work would come back and bite, so they just didn’t ever do it. Deadlines were rarely a problem because everyone knew that you had to estimate in some extra time when presenting to stakeholders. And the team knew when to push back.<p>On the other hand, I’ve been on teams where you felt compelled to define every process with excruciating detail and yet experienced people somehow screwed up regularly. We didn’t even have hard deadlines so there was no excuse. The difference between implicit and explicit error handling would have not mattered.<p>At the end of the day, some of these teams got more done with far fewer failures.</div><br/></div></div></div></div></div></div></div></div><div id="42036881" class="c"><input type="checkbox" id="c-42036881" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42036098">parent</a><span>|</span><a href="#42036215">prev</a><span>|</span><a href="#42037114">next</a><span>|</span><label class="collapse" for="c-42036881">[-]</label><label class="expand" for="c-42036881">[8 more]</label></div><br/><div class="children"><div class="content">There is <i>no</i> better way.<p>The general idea is that you <i>should</i> pay the cost of handling an error right there where you receive one, even if you&#x27;re just going to return it. This reduces the <i>incremental</i> cost of actually doing something about it.<p>If you&#x27;re given an easy way out, a simpler way of just <i>not</i> handling errors, you either won&#x27;t even consider handling them, or you&#x27;ll actively avoid any and all error handling, for fear of polluting your happy path.<p>I can&#x27;t say I agree with the approach all the time, but I <i>know</i> I&#x27;m much more likely to consider the error flow doing it the Go way, even if I&#x27;m comstant annoyed by it.</div><br/><div id="42037706" class="c"><input type="checkbox" id="c-42037706" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42036881">parent</a><span>|</span><a href="#42037217">next</a><span>|</span><label class="collapse" for="c-42037706">[-]</label><label class="expand" for="c-42037706">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There is no better way.<p>Zig&#x27;s way is better.<p>Error returning is explicit, error returning is declared in the function signature.  Error returning plays nice with defer (there is errdefer) and there is limited sugar (try keyword) that makes life easier.</div><br/><div id="42039490" class="c"><input type="checkbox" id="c-42039490" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42037706">parent</a><span>|</span><a href="#42039481">next</a><span>|</span><label class="collapse" for="c-42039490">[-]</label><label class="expand" for="c-42039490">[1 more]</label></div><br/><div class="children"><div class="content">I meant in Go. This is not a pissing match.<p>I <i>personally</i> like it better than exceptions (even if it&#x27;s much noisier for the 95% common case as another poster put it), both of which <i>I&#x27;ve</i> used enough to appreciate the pros&#x2F;cons of. But that&#x27;s about it.<p>I&#x27;ll probably never use Zig enough to find out.</div><br/></div></div><div id="42039481" class="c"><input type="checkbox" id="c-42039481" checked=""/><div class="controls bullet"><span class="by">ngrilly</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42037706">parent</a><span>|</span><a href="#42039490">prev</a><span>|</span><a href="#42037217">next</a><span>|</span><label class="collapse" for="c-42039481">[-]</label><label class="expand" for="c-42039481">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. Zig has all the advantages of Go&#x27;s explicit errors as values without the drawbacks.</div><br/></div></div></div></div><div id="42037217" class="c"><input type="checkbox" id="c-42037217" checked=""/><div class="controls bullet"><span class="by">Buttons840</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42036881">parent</a><span>|</span><a href="#42037706">prev</a><span>|</span><a href="#42037114">next</a><span>|</span><label class="collapse" for="c-42037217">[-]</label><label class="expand" for="c-42037217">[4 more]</label></div><br/><div class="children"><div class="content">&gt; If you&#x27;re given an easy way out, a simpler way of just not handling errors<p>Doesn&#x27;t go offer the simplest way of all to &quot;just not handle errors&quot;? Just ignore them. It is an option. You can ignore them on purpose, you can ignore them by mistake, but you can always simply ignore them.</div><br/><div id="42038149" class="c"><input type="checkbox" id="c-42038149" checked=""/><div class="controls bullet"><span class="by">closeparen</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42037217">parent</a><span>|</span><a href="#42037406">next</a><span>|</span><label class="collapse" for="c-42038149">[-]</label><label class="expand" for="c-42038149">[1 more]</label></div><br/><div class="children"><div class="content">In practice I want the error propagated to the caller 95% of the time and swallowed 5% of the time. The problem is Go makes me explicitly spell out (and write a unit test case for!) the behavior I almost always want, while the rarely-desired behavior is default.</div><br/></div></div><div id="42037406" class="c"><input type="checkbox" id="c-42037406" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42037217">parent</a><span>|</span><a href="#42038149">prev</a><span>|</span><a href="#42037114">next</a><span>|</span><label class="collapse" for="c-42037406">[-]</label><label class="expand" for="c-42037406">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, sure.<p>But ignoring by mistake gets caught by linters, in practice.<p>And then doing it on purpose is almost as noisy as bubbling it, and sure to raise an eyebrow in code review.<p>My experience is with exceptions in Java&#x2F;C#, Go errors, and C++ absl::StatusOr. In theory, I&#x27;d favor checked exceptions. In practice, I find that I&#x27;m always running away from polluting the happy path and coming up with contrived flow when I want to handle&#x2F;decorate&#x2F;whatever some errors but not others, and that giving types to checked exceptions becomes a class hierarchy thing that I&#x27;ve also grown to dislike. Both Go and C++&#x2F;Abseil are indifferent if noisy to me (and C++ annoys me for plenty other reasons). Maybe elsewhere I&#x27;d find options better. Maybe.</div><br/><div id="42039215" class="c"><input type="checkbox" id="c-42039215" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42037406">parent</a><span>|</span><a href="#42037114">next</a><span>|</span><label class="collapse" for="c-42039215">[-]</label><label class="expand" for="c-42039215">[1 more]</label></div><br/><div class="children"><div class="content">Isn’t the reason by chance how try-catch works lexically? I find that as another overlooked billion dollar mistake. It’s not that a happy path gets a crack in it, but the absolute monstrosity of a catch ceremony together with a scope torn between two blocks. “try {} catch {} finally {}” should be “[try] { catch {} finally {} }” absolutely everywhere.</div><br/></div></div></div></div></div></div></div></div><div id="42037114" class="c"><input type="checkbox" id="c-42037114" checked=""/><div class="controls bullet"><span class="by">AdieuToLogic</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42036098">parent</a><span>|</span><a href="#42036881">prev</a><span>|</span><a href="#42038568">next</a><span>|</span><label class="collapse" for="c-42037114">[-]</label><label class="expand" for="c-42037114">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Needing to constantly check if a specific return value is not nil just seems so sloppy but I have yet to come across a &quot;better&quot; way as it appears to just be a Golang convention. Is there a good post about better ways to handle errors in Go?<p>As others have identified, not in the Go language.  In other languages which support disjoint unions with &quot;right-biased&quot; operations, such as Haskell&#x27;s Either[0], Scala&#x27;s version[1], amongst others, having to explicitly check for error conditions is not required when an Either (or equivalent) is used.<p>0 - <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;base-4.20.0.1&#x2F;docs&#x2F;Data-Either.html" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;base-4.20.0.1&#x2F;docs&#x2F;Data-...</a><p>1 - <a href="https:&#x2F;&#x2F;www.scala-lang.org&#x2F;api&#x2F;3.x&#x2F;scala&#x2F;util&#x2F;Either.html" rel="nofollow">https:&#x2F;&#x2F;www.scala-lang.org&#x2F;api&#x2F;3.x&#x2F;scala&#x2F;util&#x2F;Either.html</a></div><br/></div></div><div id="42038568" class="c"><input type="checkbox" id="c-42038568" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42036098">parent</a><span>|</span><a href="#42037114">prev</a><span>|</span><a href="#42036915">next</a><span>|</span><label class="collapse" for="c-42038568">[-]</label><label class="expand" for="c-42038568">[3 more]</label></div><br/><div class="children"><div class="content">Rob Pike once talked about dealing with this: <a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;errors-are-values" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;errors-are-values</a></div><br/><div id="42039288" class="c"><input type="checkbox" id="c-42039288" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42038568">parent</a><span>|</span><a href="#42039214">next</a><span>|</span><label class="collapse" for="c-42039288">[-]</label><label class="expand" for="c-42039288">[1 more]</label></div><br/><div class="children"><div class="content">He basically simulates jump to catch by hand. I understand the authority of Rob Pike, but don’t understand why this idea is great.<p>Processes IRL don’t look like write() three times. They look foo(); bar(); baz(); quux();, which weren’t designed to cooperate under a single context. If only there was an implicit err-ref argument which could be filled by some “throw” keyword and the rest would auto-skip to the “catch”.</div><br/></div></div><div id="42039214" class="c"><input type="checkbox" id="c-42039214" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42038568">parent</a><span>|</span><a href="#42039288">prev</a><span>|</span><a href="#42036915">next</a><span>|</span><label class="collapse" for="c-42039214">[-]</label><label class="expand" for="c-42039214">[1 more]</label></div><br/><div class="children"><div class="content">Notably this approach is basically completely nonexistent in practice.</div><br/></div></div></div></div><div id="42036915" class="c"><input type="checkbox" id="c-42036915" checked=""/><div class="controls bullet"><span class="by">Gibbon1</span><span>|</span><a href="#42035111">root</a><span>|</span><a href="#42036098">parent</a><span>|</span><a href="#42038568">prev</a><span>|</span><a href="#42035233">next</a><span>|</span><label class="collapse" for="c-42036915">[-]</label><label class="expand" for="c-42036915">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve wondered about just being able to pass an error closure to a function. And if you don&#x27;t it&#x27;ll execute a default error closure.<p><pre><code>  void oops(error_t error) { exit(1)};

  int sum = addints(a, b, .error = oops);</code></pre></div><br/></div></div></div></div></div></div><div id="42035233" class="c"><input type="checkbox" id="c-42035233" checked=""/><div class="controls bullet"><span class="by">gmuslera</span><span>|</span><a href="#42035111">prev</a><span>|</span><a href="#42035292">next</a><span>|</span><label class="collapse" for="c-42035233">[-]</label><label class="expand" for="c-42035233">[1 more]</label></div><br/><div class="children"><div class="content">Learned programming with Pascal, and Turbo Pascal (not the language itself) was what blew my mind back then. The Swag libraries weren&#x27;t the language itself neither, but for pre-internet age they were a jump forward.<p>Then had to do things in OS&#x2F;2, and then it was the REXX turn. Shell scripting didn&#x27;t had to be as basic as I knew from DOS. Some years later moved to bash, and from complex script to long but very powerful oneliners, so it was another shock.<p>Still was working with OS&#x2F;2 when learned Perl, and regexes, and its hashes, and all with some interesting semantic approach on that. And for many years it was my &quot;complex&quot; shell scripting language. Python was not as mindblowing or at least had the same kind of impact on me.</div><br/></div></div><div id="42035292" class="c"><input type="checkbox" id="c-42035292" checked=""/><div class="controls bullet"><span class="by">PaulRobinson</span><span>|</span><a href="#42035233">prev</a><span>|</span><a href="#42035691">next</a><span>|</span><label class="collapse" for="c-42035292">[-]</label><label class="expand" for="c-42035292">[3 more]</label></div><br/><div class="children"><div class="content">I’ll second Prolog as mind blowing. It is a fundamentally different way to think about problem solving using a computer. Well worth even a trivial playing with it.</div><br/><div id="42036744" class="c"><input type="checkbox" id="c-42036744" checked=""/><div class="controls bullet"><span class="by">D-Coder</span><span>|</span><a href="#42035292">parent</a><span>|</span><a href="#42035691">next</a><span>|</span><label class="collapse" for="c-42036744">[-]</label><label class="expand" for="c-42036744">[2 more]</label></div><br/><div class="children"><div class="content">Most programming languages work top-down... literally, down through the lines of code.<p>Prolog works bottom-up.<p>Emacs LISP works inside-out.</div><br/><div id="42038497" class="c"><input type="checkbox" id="c-42038497" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#42035292">root</a><span>|</span><a href="#42036744">parent</a><span>|</span><a href="#42035691">next</a><span>|</span><label class="collapse" for="c-42038497">[-]</label><label class="expand" for="c-42038497">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been doing advent of code with Uiua [0], an array and stack programming language. And it feels like playing Tower of Hanoi with data and building pipelines with functions.<p>[0]: <a href="https:&#x2F;&#x2F;www.uiua.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.uiua.org&#x2F;</a></div><br/></div></div></div></div></div></div><div id="42035691" class="c"><input type="checkbox" id="c-42035691" checked=""/><div class="controls bullet"><span class="by">vunderba</span><span>|</span><a href="#42035292">prev</a><span>|</span><a href="#42035315">next</a><span>|</span><label class="collapse" for="c-42035691">[-]</label><label class="expand" for="c-42035691">[9 more]</label></div><br/><div class="children"><div class="content">While I wouldn&#x27;t say &quot;mind blown&quot;, I really like F#&#x27;s built-in support for fluent interface style programming using the pipeline operator, e.g.<p><pre><code>  X |&gt; one |&gt; two |&gt; three

  versus the more conventional

  three(two(one(X)))</code></pre></div><br/><div id="42036480" class="c"><input type="checkbox" id="c-42036480" checked=""/><div class="controls bullet"><span class="by">fantispug</span><span>|</span><a href="#42035691">parent</a><span>|</span><a href="#42035831">next</a><span>|</span><label class="collapse" for="c-42036480">[-]</label><label class="expand" for="c-42036480">[3 more]</label></div><br/><div class="children"><div class="content">I find this style changes the way I think about and write code transformations.
It&#x27;s also in shell pipelines, R&#x27;s magrittr, and Clojure&#x27;s thread macros, and can be emulated in some OO languages with methods that return the transformed object itself.</div><br/><div id="42038890" class="c"><input type="checkbox" id="c-42038890" checked=""/><div class="controls bullet"><span class="by">fjkdlsjflkds</span><span>|</span><a href="#42035691">root</a><span>|</span><a href="#42036480">parent</a><span>|</span><a href="#42038383">next</a><span>|</span><label class="collapse" for="c-42038890">[-]</label><label class="expand" for="c-42038890">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  R&#x27;s magrittr<p>These days, base R already includes a native pipe operator (and it is literally `|&gt;`, rather than magrittr&#x27;s `%&gt;%`).</div><br/></div></div><div id="42038383" class="c"><input type="checkbox" id="c-42038383" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#42035691">root</a><span>|</span><a href="#42036480">parent</a><span>|</span><a href="#42038890">prev</a><span>|</span><a href="#42035831">next</a><span>|</span><label class="collapse" for="c-42038383">[-]</label><label class="expand" for="c-42038383">[1 more]</label></div><br/><div class="children"><div class="content">It also works with universal function call syntax line in Nim. Though aesthetically I prefer `|&gt;` for multi-line expressions.</div><br/></div></div></div></div><div id="42035831" class="c"><input type="checkbox" id="c-42035831" checked=""/><div class="controls bullet"><span class="by">leansensei</span><span>|</span><a href="#42035691">parent</a><span>|</span><a href="#42036480">prev</a><span>|</span><a href="#42036813">next</a><span>|</span><label class="collapse" for="c-42035831">[-]</label><label class="expand" for="c-42035831">[4 more]</label></div><br/><div class="children"><div class="content">Same in Elixir</div><br/><div id="42036171" class="c"><input type="checkbox" id="c-42036171" checked=""/><div class="controls bullet"><span class="by">b6dybuyv</span><span>|</span><a href="#42035691">root</a><span>|</span><a href="#42035831">parent</a><span>|</span><a href="#42038881">prev</a><span>|</span><a href="#42036813">next</a><span>|</span><label class="collapse" for="c-42036171">[-]</label><label class="expand" for="c-42036171">[2 more]</label></div><br/><div class="children"><div class="content">and in Haskel&#x2F;Elm</div><br/><div id="42036442" class="c"><input type="checkbox" id="c-42036442" checked=""/><div class="controls bullet"><span class="by">MarkMarine</span><span>|</span><a href="#42035691">root</a><span>|</span><a href="#42036171">parent</a><span>|</span><a href="#42036813">next</a><span>|</span><label class="collapse" for="c-42036442">[-]</label><label class="expand" for="c-42036442">[1 more]</label></div><br/><div class="children"><div class="content">And clojure
-&gt; or -&gt;&gt; (thread first or thread last)</div><br/></div></div></div></div></div></div><div id="42036813" class="c"><input type="checkbox" id="c-42036813" checked=""/><div class="controls bullet"><span class="by">runevault</span><span>|</span><a href="#42035691">parent</a><span>|</span><a href="#42035831">prev</a><span>|</span><a href="#42035315">next</a><span>|</span><label class="collapse" for="c-42036813">[-]</label><label class="expand" for="c-42036813">[1 more]</label></div><br/><div class="children"><div class="content">At least for me once I first encountered the pipeline operator it has made me dislike traditional inside out code a lot more.</div><br/></div></div></div></div><div id="42035315" class="c"><input type="checkbox" id="c-42035315" checked=""/><div class="controls bullet"><span class="by">skruger</span><span>|</span><a href="#42035691">prev</a><span>|</span><a href="#42035169">next</a><span>|</span><label class="collapse" for="c-42035315">[-]</label><label class="expand" for="c-42035315">[3 more]</label></div><br/><div class="children"><div class="content">APL is the perfect mind blower: <a href="https:&#x2F;&#x2F;xpqz.github.io&#x2F;learnapl&#x2F;intro.html" rel="nofollow">https:&#x2F;&#x2F;xpqz.github.io&#x2F;learnapl&#x2F;intro.html</a></div><br/><div id="42035364" class="c"><input type="checkbox" id="c-42035364" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#42035315">parent</a><span>|</span><a href="#42035169">next</a><span>|</span><label class="collapse" for="c-42035364">[-]</label><label class="expand" for="c-42035364">[2 more]</label></div><br/><div class="children"><div class="content">Unfortunately Dijkstra and Iverson took personal dislikes to each other&#x27;s approach, or we might have had a language that abstracted data flow like Iverson&#x27;s APL <i>and</i> abstracted code flow like Dijkstra&#x27;s Guarded Commands.</div><br/><div id="42039433" class="c"><input type="checkbox" id="c-42039433" checked=""/><div class="controls bullet"><span class="by">abrudz</span><span>|</span><a href="#42035315">root</a><span>|</span><a href="#42035364">parent</a><span>|</span><a href="#42035169">next</a><span>|</span><label class="collapse" for="c-42039433">[-]</label><label class="expand" for="c-42039433">[1 more]</label></div><br/><div class="children"><div class="content">Have you looked at dfns (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Direct_function" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Direct_function</a>)? They allow you something very similar. Compare Dijkstra&#x27;s GCL:<p><pre><code>  if a &lt; b → c := true
   □ a ≥ b → c := false
  fi
</code></pre>
To an APL dfn with &quot;guards&quot;:<p><pre><code>  c ← {
        a &lt; b : true
        a ≥ b : false
      }
</code></pre>
As in GCL, if none of the guards hold true, the dfn (braces) will terminate without return value, and thus the code will abort with an error.</div><br/></div></div></div></div></div></div><div id="42035169" class="c"><input type="checkbox" id="c-42035169" checked=""/><div class="controls bullet"><span class="by">card_zero</span><span>|</span><a href="#42035315">prev</a><span>|</span><a href="#42035217">next</a><span>|</span><label class="collapse" for="c-42035169">[-]</label><label class="expand" for="c-42035169">[3 more]</label></div><br/><div class="children"><div class="content">Round about the seventh language, he stops using exclamation marks. The list goes from &quot;Mind blown: Programming my own games!&quot; to &quot;Mind blown: Some support for writing my own gradual type system.&quot;</div><br/><div id="42035273" class="c"><input type="checkbox" id="c-42035273" checked=""/><div class="controls bullet"><span class="by">PaulRobinson</span><span>|</span><a href="#42035169">parent</a><span>|</span><a href="#42037771">next</a><span>|</span><label class="collapse" for="c-42035273">[-]</label><label class="expand" for="c-42035273">[1 more]</label></div><br/><div class="children"><div class="content">I think that actually happens to us all. The first time you write an infinite loop to print out that your friend is a doofus to show off is magical. 25 years in and you start to value… other things… that maybe don’t have the childish whimsy and fun.<p>That’s OK. In the same way that when you start to read books, you might like Blyton, Dahl or diving into a Hardy Boys, by the time you’ve been reading fiction for a few decades your tastes might become a bit more philosophical.<p>The trick is to introduce these things to people when they’re ready for them, and to not treat those who haven’t experienced them as in some way inferior.<p>I’m not going to shove Proust down someone’s neck or make them feel dumb for not having read any of his work, in the same way I am going to think carefully about whether somebody would benefit from seeing some Prolog.<p>What does interest me a lot about this list is that it’s not just a “well, look, I found Clojure and think it’s better than Python, YMMV”, or “if you don’t like or understand Haskell maybe you are just too dumb to grok eigenvectors” brag piece.<p>There is a thought about what you might get from that language that makes it worth exploring. As a result I might revisit OCaml after a brief and shallow flirtation some years ago, and go and take a look at Coq which I doubt I can use professionally but sounds fascinating to explore.</div><br/></div></div><div id="42037771" class="c"><input type="checkbox" id="c-42037771" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#42035169">parent</a><span>|</span><a href="#42035273">prev</a><span>|</span><a href="#42035217">next</a><span>|</span><label class="collapse" for="c-42037771">[-]</label><label class="expand" for="c-42037771">[1 more]</label></div><br/><div class="children"><div class="content">my mind was blown by how many times he said mind blown.<p>also, what happened to opalang that he mentioned? iirc i read about it back in the day.</div><br/></div></div></div></div><div id="42035217" class="c"><input type="checkbox" id="c-42035217" checked=""/><div class="controls bullet"><span class="by">liendolucas</span><span>|</span><a href="#42035169">prev</a><span>|</span><a href="#42036805">next</a><span>|</span><label class="collapse" for="c-42035217">[-]</label><label class="expand" for="c-42035217">[2 more]</label></div><br/><div class="children"><div class="content">I think that are a couple of programming langs out there that everyone needs to be in contact with at least one time. I will mention the three ones that actually changed my mind (I have taken these in a semester at uni): Haskell, Prolog and Smalltalk (even if you do not like nor use them, they will force you to think radically different). Then you should add a structured language (C or Pascal will suffice). If you like metal, try assembly. Yes there are others like APL and Forth but I can&#x27;t say anything about those as I haven&#x27;t tried them. Lastly a LISP or scheme flavour won&#x27;t be bad to experience as well.</div><br/><div id="42039463" class="c"><input type="checkbox" id="c-42039463" checked=""/><div class="controls bullet"><span class="by">abrudz</span><span>|</span><a href="#42035217">parent</a><span>|</span><a href="#42036805">next</a><span>|</span><label class="collapse" for="c-42039463">[-]</label><label class="expand" for="c-42039463">[1 more]</label></div><br/><div class="children"><div class="content">It was about APL that Alan J. Perlis said &quot;A language that doesn&#x27;t affect the way you think about programming, is not worth knowing.&quot; (number 19 of <a href="https:&#x2F;&#x2F;cpsc.yale.edu&#x2F;epigrams-programming" rel="nofollow">https:&#x2F;&#x2F;cpsc.yale.edu&#x2F;epigrams-programming</a>)</div><br/></div></div></div></div><div id="42036805" class="c"><input type="checkbox" id="c-42036805" checked=""/><div class="controls bullet"><span class="by">morning-coffee</span><span>|</span><a href="#42035217">prev</a><span>|</span><a href="#42035034">next</a><span>|</span><label class="collapse" for="c-42036805">[-]</label><label class="expand" for="c-42036805">[3 more]</label></div><br/><div class="children"><div class="content">Nice article. Amazed they came across Prolog but not Forth!?<p>Prepare to have your mind blown: <a href="https:&#x2F;&#x2F;ratfactor.com&#x2F;forth&#x2F;the_programming_language_that_writes_itself.html" rel="nofollow">https:&#x2F;&#x2F;ratfactor.com&#x2F;forth&#x2F;the_programming_language_that_wr...</a></div><br/><div id="42038397" class="c"><input type="checkbox" id="c-42038397" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#42036805">parent</a><span>|</span><a href="#42035034">next</a><span>|</span><label class="collapse" for="c-42038397">[-]</label><label class="expand" for="c-42038397">[2 more]</label></div><br/><div class="children"><div class="content">Implementing and using a Forth for a while for embedded real time scripting was a great in really re-enforcing how everything in programming really boils down to just numbers. Though practically speaking managing the stack gets old quickly.</div><br/><div id="42039113" class="c"><input type="checkbox" id="c-42039113" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#42036805">root</a><span>|</span><a href="#42038397">parent</a><span>|</span><a href="#42035034">next</a><span>|</span><label class="collapse" for="c-42039113">[-]</label><label class="expand" for="c-42039113">[1 more]</label></div><br/><div class="children"><div class="content">If you look at Moore&#x27;s forth style, he doesn&#x27;t manage the stack, he just uses variables.</div><br/></div></div></div></div></div></div><div id="42035034" class="c"><input type="checkbox" id="c-42035034" checked=""/><div class="controls bullet"><span class="by">WillAdams</span><span>|</span><a href="#42036805">prev</a><span>|</span><a href="#42036421">next</a><span>|</span><label class="collapse" for="c-42035034">[-]</label><label class="expand" for="c-42035034">[1 more]</label></div><br/><div class="children"><div class="content">Parallel track:<p>- MacBASIC: Mac GUI programming w&#x2F;o Pascal or C <a href="https:&#x2F;&#x2F;www.folklore.org&#x2F;MacBasic.html" rel="nofollow">https:&#x2F;&#x2F;www.folklore.org&#x2F;MacBasic.html</a> (which is something I&#x27;ll never forgive Bill Gates for)<p>- HyperCARD (also on that list, and agree with almost all points made): It was magic to get into Developer mode and to create stacks --- it&#x27;s unfortunate that Asymetrix Toolbook didn&#x27;t get further, nor that the Heizer stack for converting HyperCard stacks to Toolbook wasn&#x27;t more widely available, and a shame that Runtime Revolution which became Livecode reneged on their opensource effort --- hopefully someone will make good on that: <a href="https:&#x2F;&#x2F;openxtalk.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;openxtalk.org&#x2F;</a><p>Unfortunately, I never got anywhere w&#x2F; Interfacebuilder.app or Objective-C....<p>- Lua: real variables in TeX! (and latex), and one gets METAPOST as well --- even recursion becomes simple: <a href="https:&#x2F;&#x2F;tex.stackexchange.com&#x2F;questions&#x2F;723897&#x2F;breaking-out-of-recursion-in-latex-macro-using-lua&#x2F;725720#725720" rel="nofollow">https:&#x2F;&#x2F;tex.stackexchange.com&#x2F;questions&#x2F;723897&#x2F;breaking-out-...</a><p>- OpenSCAD: Make 3D things w&#x2F;o having to use a full-fledged CAD program<p>- BlockSCAD: Make 3D things w&#x2F;o typing: <a href="https:&#x2F;&#x2F;www.blockscad3d.com&#x2F;editor&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.blockscad3d.com&#x2F;editor&#x2F;</a> (though to be fair, <a href="https:&#x2F;&#x2F;github.com&#x2F;derkork&#x2F;openscad-graph-editor">https:&#x2F;&#x2F;github.com&#x2F;derkork&#x2F;openscad-graph-editor</a> also allows that)<p>- PythonSCAD: variables and file I&#x2F;O for OpenSCAD (though to be fair, RapCAD had the latter, it was just hard to use it w&#x2F;o traditional variables) <a href="https:&#x2F;&#x2F;pythonscad.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pythonscad.org&#x2F;</a><p>Still working through a re-write of my OpenSCAD library in Python: <a href="https:&#x2F;&#x2F;github.com&#x2F;WillAdams&#x2F;gcodepreview">https:&#x2F;&#x2F;github.com&#x2F;WillAdams&#x2F;gcodepreview</a> and am hopeful that a tool like to <a href="https:&#x2F;&#x2F;nodezator.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nodezator.com&#x2F;</a> will make that graphically accessible (w&#x2F;o going into OpenSCAD mode to use OSGE).</div><br/></div></div><div id="42036421" class="c"><input type="checkbox" id="c-42036421" checked=""/><div class="controls bullet"><span class="by">mapcars</span><span>|</span><a href="#42035034">prev</a><span>|</span><a href="#42038295">next</a><span>|</span><label class="collapse" for="c-42036421">[-]</label><label class="expand" for="c-42036421">[1 more]</label></div><br/><div class="children"><div class="content">Red&#x2F;Rebol has a different, powerful approach to homoiconicity and DSLs.<p>And there is this XL language that has very interesting approach to extending the language, but sadly the compiler is not in a runnable state, I could only assess it by the docs.</div><br/></div></div><div id="42038295" class="c"><input type="checkbox" id="c-42038295" checked=""/><div class="controls bullet"><span class="by">noduerme</span><span>|</span><a href="#42036421">prev</a><span>|</span><a href="#42036425">next</a><span>|</span><label class="collapse" for="c-42038295">[-]</label><label class="expand" for="c-42038295">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;d like to put a word in for  AS3. As a kid who grew up on hypercard, BASIC, pascal, proce55ing and eventually PHP and javascript, AS3 was the language that bridged the gap for me to strongly typed code. It made me a much better programmer. The graphics APIs were fantastic but they also taught me for the first time how to avoid tightly coupling graphics with logic.<p>TS + PixiJS is a reasonable replacement for some of it now, but I still sometimes miss having compile-time warnings.</div><br/><div id="42038320" class="c"><input type="checkbox" id="c-42038320" checked=""/><div class="controls bullet"><span class="by">WillAdams</span><span>|</span><a href="#42038295">parent</a><span>|</span><a href="#42036425">next</a><span>|</span><label class="collapse" for="c-42038320">[-]</label><label class="expand" for="c-42038320">[2 more]</label></div><br/><div class="children"><div class="content">One of the most amazing tools done using this was:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Jack000&#x2F;PartKAM">https:&#x2F;&#x2F;github.com&#x2F;Jack000&#x2F;PartKAM</a><p>a vector drawing tool and CAM (Computer Aided Manufacturing) program.</div><br/><div id="42039552" class="c"><input type="checkbox" id="c-42039552" checked=""/><div class="controls bullet"><span class="by">noduerme</span><span>|</span><a href="#42038295">root</a><span>|</span><a href="#42038320">parent</a><span>|</span><a href="#42036425">next</a><span>|</span><label class="collapse" for="c-42039552">[-]</label><label class="expand" for="c-42039552">[1 more]</label></div><br/><div class="children"><div class="content">Shame it&#x27;s impossible to even run the code now and see it. It was a great tool for making visual tools, not just games. Part of that was just being able to build UI components visually as raster <i>or</i> vectors, animated if you wanted, that you could then manipulate interchangeably in code without any overhead. Even though most of my software in it drew everything procedurally, that ability to dip in and out of GUI&#x2F;design mode made it possible to do beautiful things quite easily. There has been nothing else quite like it.</div><br/></div></div></div></div></div></div><div id="42036425" class="c"><input type="checkbox" id="c-42036425" checked=""/><div class="controls bullet"><span class="by">prisenco</span><span>|</span><a href="#42038295">prev</a><span>|</span><a href="#42035543">next</a><span>|</span><label class="collapse" for="c-42036425">[-]</label><label class="expand" for="c-42036425">[1 more]</label></div><br/><div class="children"><div class="content">Early on when I was learning, assembly language blew my mind. I went from Basic to Pascal but I wanted to make games so I tried my hand at C&#x2F;ASM and it was just so wild to be that close to the metal after a couple years at such a high level.<p>In recent years, Go blew my mind with it&#x27;s simplicity and how strong of a case it makes for writing boring code.<p>It&#x27;s been decades since writing C&#x2F;ASM and my guess is what little I remember isn&#x27;t applicable anymore, but I plan on diving in again at some point if only to better understand Go.</div><br/></div></div><div id="42035543" class="c"><input type="checkbox" id="c-42035543" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#42036425">prev</a><span>|</span><a href="#42037760">next</a><span>|</span><label class="collapse" for="c-42035543">[-]</label><label class="expand" for="c-42035543">[1 more]</label></div><br/><div class="children"><div class="content">There were a few times I had my mind blown. Once with Scheme when I was watching the old SICP video lectures. But also (and this may be a rather unpopular thing to say) once with C when I had coded something up and compiled it and ran it and it finished instantly. Rust didn&#x27;t really blow my mind, but I have taken some of its lessons (using error values, lifetime and ownership management) to heart.<p>Common Lisp, which at the moment is the only language I can see myself using unless I decide to make one myself, never really blew my mind, although the little things it does make it hard for me to imagine switching away from it.</div><br/></div></div><div id="42037760" class="c"><input type="checkbox" id="c-42037760" checked=""/><div class="controls bullet"><span class="by">hhhAndrew</span><span>|</span><a href="#42035543">prev</a><span>|</span><a href="#42038646">next</a><span>|</span><label class="collapse" for="c-42037760">[-]</label><label class="expand" for="c-42037760">[1 more]</label></div><br/><div class="children"><div class="content">Mathematica. Usefully homoiconic with an underlying compute model of &quot;get AST, pattern-match-and-replace within in, repeat until fixed point&quot;.</div><br/></div></div><div id="42038646" class="c"><input type="checkbox" id="c-42038646" checked=""/><div class="controls bullet"><span class="by">klausnrooster</span><span>|</span><a href="#42037760">prev</a><span>|</span><a href="#42035573">next</a><span>|</span><label class="collapse" for="c-42038646">[-]</label><label class="expand" for="c-42038646">[1 more]</label></div><br/><div class="children"><div class="content">No mention of PicoLisp (application server, embedded Prolog, etc, etc...) or Dylan. No way Teller saw them and they didn&#x27;t make the list.</div><br/></div></div><div id="42035573" class="c"><input type="checkbox" id="c-42035573" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#42038646">prev</a><span>|</span><a href="#42035852">next</a><span>|</span><label class="collapse" for="c-42035573">[-]</label><label class="expand" for="c-42035573">[3 more]</label></div><br/><div class="children"><div class="content">Regular expression is not listed in the article, but it blew my mind when I first used it in Perl.  Any of sed&#x2F;awk&#x2F;perl&#x2F;python&#x2F;ruby&#x2F;javascript could have expose the author to regular expressions, but maybe they didn&#x27;t find it as transformative as I did.</div><br/><div id="42035605" class="c"><input type="checkbox" id="c-42035605" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#42035573">parent</a><span>|</span><a href="#42035852">next</a><span>|</span><label class="collapse" for="c-42035605">[-]</label><label class="expand" for="c-42035605">[2 more]</label></div><br/><div class="children"><div class="content">&#x27;<i>&#x27; is one of the first special thing that computers made me look at. Even a simple msdos glob </i>.exe felt like a superpower. regexps were the next level but a two edged weapon as everybody knows. That said I never leveraged PCRE extended capabilities.</div><br/></div></div></div></div><div id="42035852" class="c"><input type="checkbox" id="c-42035852" checked=""/><div class="controls bullet"><span class="by">bazoom42</span><span>|</span><a href="#42035573">prev</a><span>|</span><a href="#42035239">next</a><span>|</span><label class="collapse" for="c-42035852">[-]</label><label class="expand" for="c-42035852">[1 more]</label></div><br/><div class="children"><div class="content">Call-with-current-continuation in Scheme blew my mind.</div><br/></div></div><div id="42035239" class="c"><input type="checkbox" id="c-42035239" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#42035852">prev</a><span>|</span><a href="#42035671">next</a><span>|</span><label class="collapse" for="c-42035239">[-]</label><label class="expand" for="c-42035239">[6 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t get the part about the stack in assembly, in my experience the stack is very much a thing at that level.<p>Mainstream CPUs expose one or more explicit stack pointers, and in assembly you use that all the time, right?</div><br/><div id="42035894" class="c"><input type="checkbox" id="c-42035894" checked=""/><div class="controls bullet"><span class="by">elteto</span><span>|</span><a href="#42035239">parent</a><span>|</span><a href="#42035917">next</a><span>|</span><label class="collapse" for="c-42035894">[-]</label><label class="expand" for="c-42035894">[1 more]</label></div><br/><div class="children"><div class="content">I think he means that the stack is not something that you are forced to work with when programming in assembly. You can put data wherever you want (and are allowed to), and jmp into whatever random memory address you want. You can use CPU instructions that handle stack management for you, but you don’t _have_ to.</div><br/></div></div><div id="42035917" class="c"><input type="checkbox" id="c-42035917" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#42035239">parent</a><span>|</span><a href="#42035894">prev</a><span>|</span><a href="#42035671">next</a><span>|</span><label class="collapse" for="c-42035917">[-]</label><label class="expand" for="c-42035917">[4 more]</label></div><br/><div class="children"><div class="content">I mean, that&#x27;s just a register. The memory region itself is not special in any way, a random &quot;heap&quot; region that would be similarly frequently accessed would be just as fast.</div><br/><div id="42039379" class="c"><input type="checkbox" id="c-42039379" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#42035239">root</a><span>|</span><a href="#42035917">parent</a><span>|</span><a href="#42035983">next</a><span>|</span><label class="collapse" for="c-42039379">[-]</label><label class="expand" for="c-42039379">[2 more]</label></div><br/><div class="children"><div class="content">Except of course how return addresses are typically always stored on the machine stack. It is very concretely <i>there</i> and part of the programming model, in my world.</div><br/><div id="42039609" class="c"><input type="checkbox" id="c-42039609" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#42035239">root</a><span>|</span><a href="#42039379">parent</a><span>|</span><a href="#42035983">next</a><span>|</span><label class="collapse" for="c-42039609">[-]</label><label class="expand" for="c-42039609">[1 more]</label></div><br/><div class="children"><div class="content">Technically some CPUs have a &quot;jump and link&quot; that saves the return address in a register. Then it is up to the calling convention to save that register on the, also by convention, stack.</div><br/></div></div></div></div><div id="42035983" class="c"><input type="checkbox" id="c-42035983" checked=""/><div class="controls bullet"><span class="by">gus_massa</span><span>|</span><a href="#42035239">root</a><span>|</span><a href="#42035917">parent</a><span>|</span><a href="#42039379">prev</a><span>|</span><a href="#42035671">next</a><span>|</span><label class="collapse" for="c-42035983">[-]</label><label class="expand" for="c-42035983">[1 more]</label></div><br/><div class="children"><div class="content">You also can peek and write in the wrong side of BP and mess the &quot;stack&quot; of the caller funcion and perhaps get unexpected results or nasty crashes.<p>Instead of &quot;<i>an ilusion</i>&quot;, I&#x27;d say it&#x27;s &quot;<i>a convension</i>&quot;.</div><br/></div></div></div></div></div></div><div id="42035671" class="c"><input type="checkbox" id="c-42035671" checked=""/><div class="controls bullet"><span class="by">jeffreygoesto</span><span>|</span><a href="#42035239">prev</a><span>|</span><a href="#42037520">next</a><span>|</span><label class="collapse" for="c-42035671">[-]</label><label class="expand" for="c-42035671">[3 more]</label></div><br/><div class="children"><div class="content">No Perl? cgi.pm and http requests, plus regexes blew my mind after Basic, Z80 assembler and Turbo Pascal...</div><br/><div id="42035681" class="c"><input type="checkbox" id="c-42035681" checked=""/><div class="controls bullet"><span class="by">pyrale</span><span>|</span><a href="#42035671">parent</a><span>|</span><a href="#42035702">next</a><span>|</span><label class="collapse" for="c-42035681">[-]</label><label class="expand" for="c-42035681">[1 more]</label></div><br/><div class="children"><div class="content">Near the end of the article:<p>&gt; Just that the concepts either didn’t resonate with me or, more often than not, that I had already discovered these same concepts with other languages, just by the luck of the order in which I learnt languages.</div><br/></div></div><div id="42035702" class="c"><input type="checkbox" id="c-42035702" checked=""/><div class="controls bullet"><span class="by">James_K</span><span>|</span><a href="#42035671">parent</a><span>|</span><a href="#42035681">prev</a><span>|</span><a href="#42037520">next</a><span>|</span><label class="collapse" for="c-42035702">[-]</label><label class="expand" for="c-42035702">[1 more]</label></div><br/><div class="children"><div class="content">If Perl blows your mind, Perl6&#x2F;Raku would send it to space.</div><br/></div></div></div></div><div id="42037520" class="c"><input type="checkbox" id="c-42037520" checked=""/><div class="controls bullet"><span class="by">cryptozeus</span><span>|</span><a href="#42035671">prev</a><span>|</span><a href="#42039089">next</a><span>|</span><label class="collapse" for="c-42037520">[-]</label><label class="expand" for="c-42037520">[1 more]</label></div><br/><div class="children"><div class="content">I like the article but I had to come here and say that these AI images in blogs are killing the reading experience:&#x2F;</div><br/></div></div><div id="42039089" class="c"><input type="checkbox" id="c-42039089" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#42037520">prev</a><span>|</span><a href="#42037818">next</a><span>|</span><label class="collapse" for="c-42039089">[-]</label><label class="expand" for="c-42039089">[1 more]</label></div><br/><div class="children"><div class="content">I am impressed by Haskell, Prolog, but also ... C.</div><br/></div></div><div id="42037818" class="c"><input type="checkbox" id="c-42037818" checked=""/><div class="controls bullet"><span class="by">0x1ceb00da</span><span>|</span><a href="#42039089">prev</a><span>|</span><a href="#42037141">next</a><span>|</span><label class="collapse" for="c-42037818">[-]</label><label class="expand" for="c-42037818">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Mind blown backwards: Understanding how finally was implemented in the JVM.<p>In old versions the JVM does jsr and ret. In new versions it just duplicates the code. I don&#x27;t understand what&#x27;s mind blowing about it?</div><br/></div></div><div id="42037141" class="c"><input type="checkbox" id="c-42037141" checked=""/><div class="controls bullet"><span class="by">kjellsbells</span><span>|</span><a href="#42037818">prev</a><span>|</span><a href="#42035802">next</a><span>|</span><label class="collapse" for="c-42037141">[-]</label><label class="expand" for="c-42037141">[1 more]</label></div><br/><div class="children"><div class="content">BBC BASIC. You mean I can POKE things here, and stuff shows up on the screen in a different color?!<p>Turbo Pascal. Woah this is fast. And Mum is impressed when code sells for money.<p>Visual Basic. I&#x27;m living in the future, Ma. Dentist has a side business sell flowers and needs a program that can handle root canal and roses? I got you.<p>Perl. Suddenly system administration is fun again.<p>Java. My mind is blown, in a bad way. This is what I have to write to keep a roof over my head? Ugh.<p>Go. Aaahhh. Feels like reading W. Richard Stevens again. Coming home to unix, but with the bad parts acknowledged instead of denied.</div><br/></div></div><div id="42035802" class="c"><input type="checkbox" id="c-42035802" checked=""/><div class="controls bullet"><span class="by">eminent101</span><span>|</span><a href="#42037141">prev</a><span>|</span><label class="collapse" for="c-42035802">[-]</label><label class="expand" for="c-42035802">[2 more]</label></div><br/><div class="children"><div class="content">I found Coq in the list to be very interesting. Is anyone using Coq here for serious math or programming? What kind of problems are you solving with Coq?<p>And I&#x27;d also like to know how different Coq and Lean are. I&#x27;m not a mathematician. I&#x27;m just a software developer. Is there a good reason for me to pick one over the other?</div><br/><div id="42035881" class="c"><input type="checkbox" id="c-42035881" checked=""/><div class="controls bullet"><span class="by">ChadNauseam</span><span>|</span><a href="#42035802">parent</a><span>|</span><label class="collapse" for="c-42035881">[-]</label><label class="expand" for="c-42035881">[1 more]</label></div><br/><div class="children"><div class="content">Coq is cool partially because it can be compiled to OCaml. So you can write part of your program in Coq and prove its correctness, and then write the rest in pleasant OCaml. I believe there are some popular ocaml libraries, like bigint implementations, that do this.<p>Lean is designed to be a general purpose programming language that is also useful for mathematical proofs. From that perspective it’s kind of trying to be “better haskell”. (Although most of the focus is definitely on the math side and in practice it probably isn’t actually a better haskell yet for ecosystem reasons.)<p>If you try either, you’ll likely be playing with a programming paradigm very different than anything you’ve used before: tactic oriented programming. It’s very cool and perfect for math, although I don’t think I’d want to use it for everyday tasks.<p>You won’t go wrong with either, but my recommendation is to try lean by googling “the natural number game”. It’s a cool online game that teaches you lean and the basic of proofs.<p>By the way, don’t be scared of dependent types. They are very simple. Dependent types just mean that the type of the second element of a tuple can depend on the value of the first, and the return type of a function can depend on the value passed into it. Dependent types are commonly framed as “types that have values in them” or something, which is a misleading simplification.</div><br/></div></div></div></div></div></div></div></div></div></body></html>