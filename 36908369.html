<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1690707650275" as="style"/><link rel="stylesheet" href="styles.css?v=1690707650275"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://functionallyimperative.com/p/the-bigger-the-interface-the-weaker">The bigger the interface, the weaker the abstraction</a>Â <span class="domain">(<a href="https://functionallyimperative.com">functionallyimperative.com</a>)</span></div><div class="subtext"><span>zdw</span> | <span>44 comments</span></div><br/><div><div id="36928654" class="c"><input type="checkbox" id="c-36928654" checked=""/><div class="controls bullet"><span class="by">js8</span><span>|</span><a href="#36925321">next</a><span>|</span><label class="collapse" for="c-36928654">[-]</label><label class="expand" for="c-36928654">[2 more]</label></div><br/><div class="children"><div class="content">I like Eric Meijer&#x27;s take on this. He said that the important property of interface are not the actual method signatures, but rather laws that the methods follow when being called.<p>I think it follows that with bigger interface, there are more laws to follow (for example, read() must be called after open() but not after close()), and as a consequence, utility of that abstraction gets more limited.</div><br/></div></div><div id="36925321" class="c"><input type="checkbox" id="c-36925321" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#36928654">prev</a><span>|</span><a href="#36928710">next</a><span>|</span><label class="collapse" for="c-36925321">[-]</label><label class="expand" for="c-36925321">[11 more]</label></div><br/><div class="children"><div class="content">This runs the risk of being reductionist to the point of useless.  Is akin to the idea of &quot;do one thing,&quot; or &quot;single responsibility.&quot;<p>The danger is these all fail to grow.  Or, rather, for them to work, you have to force the growth on either side.<p>Consider, you are using a writer to write data.  How much can you write before it has to slow down?  How do you signal broken data connections?  How do you resume a previously stopped writer?  How do you stop a writer?<p>Most of these do not have universal answers.  But it gets worse.  The main abstraction there was the symbolic byte.  How do you convert your code&#x27;s data to bytes?  Is that stable?  As in not changing.<p>So, you can have choke points of small interfaces to connect things.  But to make that work, you have a lot to do on both sides.</div><br/><div id="36926951" class="c"><input type="checkbox" id="c-36926951" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36925321">parent</a><span>|</span><a href="#36927830">next</a><span>|</span><label class="collapse" for="c-36926951">[-]</label><label class="expand" for="c-36926951">[2 more]</label></div><br/><div class="children"><div class="content">The principal is correct: &quot;the bigger the interface, the weaker the abstraction.&quot;<p>But perhaps you feel there is an second implicit, prescription: &quot;Your abstractions <i>should</i> be strong.&quot;<p>And that&#x27;s not necessarily true. To every thing there is a season. Excessive abstraction is astronaut architecture.<p>---<p>The principal is a good one.<p>The bigger the interface, the weaker the abstraction.<p>That&#x27;s not to say big interfaces are <i>bad</i> or <i>inappropriate</i>. It&#x27;s just to say they aren&#x27;t strong abstractions, so don&#x27;t expect them to be.</div><br/><div id="36927098" class="c"><input type="checkbox" id="c-36927098" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#36925321">root</a><span>|</span><a href="#36926951">parent</a><span>|</span><a href="#36927830">next</a><span>|</span><label class="collapse" for="c-36927098">[-]</label><label class="expand" for="c-36927098">[1 more]</label></div><br/><div class="children"><div class="content">Totally fair.  I am riffing off the idea that stronger is better.  Weaker is worse.  Fairly common framing, I thought<p>But in the spirit, how is a single method &quot;stronger?&quot;  Usable in more places, maybe?  Often hides too much, such that it really can&#x27;t be used everywhere.<p>Describes more things?  Well, yeah?  But not in meaningful way.  At this level of &quot;abstraction,&quot; a car is indistinguishable from a bike.  Certainly fair for some contexts.  Not many relevant ones, though.<p>And it is that last, that I think sticks.  What is the most you can stick to an abstract set of capabilities?  That will give you the most utility.<p>It does mean the cost of implementation raises.  But that is realistic?</div><br/></div></div></div></div><div id="36927830" class="c"><input type="checkbox" id="c-36927830" checked=""/><div class="controls bullet"><span class="by">yegle</span><span>|</span><a href="#36925321">parent</a><span>|</span><a href="#36926951">prev</a><span>|</span><a href="#36925599">next</a><span>|</span><label class="collapse" for="c-36927830">[-]</label><label class="expand" for="c-36927830">[2 more]</label></div><br/><div class="children"><div class="content">The standard solution to this problem is a so called &quot;interface smuggling&quot;.<p>You can implement more advanced interface types of the initial interface does not provide the required abstraction, and then do type switch at runtime and gradually switch your code to use the newer interface.<p>The name of this technique is from <a href="https:&#x2F;&#x2F;utcc.utoronto.ca&#x2F;~cks&#x2F;space&#x2F;blog&#x2F;programming&#x2F;GoInterfaceSmuggling" rel="nofollow noreferrer">https:&#x2F;&#x2F;utcc.utoronto.ca&#x2F;~cks&#x2F;space&#x2F;blog&#x2F;programming&#x2F;GoInter...</a></div><br/><div id="36928181" class="c"><input type="checkbox" id="c-36928181" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#36925321">root</a><span>|</span><a href="#36927830">parent</a><span>|</span><a href="#36925599">next</a><span>|</span><label class="collapse" for="c-36928181">[-]</label><label class="expand" for="c-36928181">[1 more]</label></div><br/><div class="children"><div class="content">A bit like duck typing.</div><br/></div></div></div></div><div id="36925599" class="c"><input type="checkbox" id="c-36925599" checked=""/><div class="controls bullet"><span class="by">stinkbutt</span><span>|</span><a href="#36925321">parent</a><span>|</span><a href="#36927830">prev</a><span>|</span><a href="#36928710">next</a><span>|</span><label class="collapse" for="c-36925599">[-]</label><label class="expand" for="c-36925599">[6 more]</label></div><br/><div class="children"><div class="content">its a misconception that single responsibility is about doing one thing. in fact the principle allows for a system to do many things, but the idea is that it should only serve a single actor.</div><br/><div id="36926131" class="c"><input type="checkbox" id="c-36926131" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#36925321">root</a><span>|</span><a href="#36925599">parent</a><span>|</span><a href="#36925730">next</a><span>|</span><label class="collapse" for="c-36926131">[-]</label><label class="expand" for="c-36926131">[3 more]</label></div><br/><div class="children"><div class="content">Calling it a misconception is not really fair.<p>The &quot;serve a single actor&quot; is a recent revision of the principle by Uncle Bob, from a 2018 book, AFAIK. That&#x27;s almost 20 years too late (if going by the sources I can find).<p>I can&#x27;t find mentions of &quot;actors&quot; or similar terms in <i>Agile Software Development</i> or <i>Clean Code</i>. Pretty much every pre-2018 literature says that SRP relates to modules &quot;[having a] single reason to change&quot;, or &quot;[not having] too many responsibilities&quot;. The examples are always fuzzy and imprecise, but in the books the principle essentially boils down to class&#x2F;method size. There are no examples in Clean Code or ASD relating to this new meaning, nor mentions of &quot;actors&quot; or &quot;stakeholders&quot;, and until recently there&#x27;s rarely any article contradicting the original meaning of SRP.<p>This revisionism seems to come first from backlash from part of the programming community, and also an adaptation of the more recent &quot;one team per microservice&quot; rule.<p>But the damage of almost 20 years of SRP being taught the way it was in the past was already done.</div><br/><div id="36926677" class="c"><input type="checkbox" id="c-36926677" checked=""/><div class="controls bullet"><span class="by">whynotmaybe</span><span>|</span><a href="#36925321">root</a><span>|</span><a href="#36926131">parent</a><span>|</span><a href="#36925730">next</a><span>|</span><label class="collapse" for="c-36926677">[-]</label><label class="expand" for="c-36926677">[2 more]</label></div><br/><div class="children"><div class="content">From Wikipedia, Uncle Bob made a book in 2017 and one in 2019.<p>Do you know which one you&#x27;re referring to?<p>2017. Clean Architecture: A Craftsman&#x27;s Guide to Software Structure and Design. Prentice Hall. ISBN 978-0134494166.<p>2019. Clean Agile: Back to Basics. Prentice Hall. ISBN 978-0135781869.</div><br/><div id="36926972" class="c"><input type="checkbox" id="c-36926972" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#36925321">root</a><span>|</span><a href="#36926677">parent</a><span>|</span><a href="#36925730">next</a><span>|</span><label class="collapse" for="c-36926972">[-]</label><label class="expand" for="c-36926972">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the 2017 one, thanks for the correction.</div><br/></div></div></div></div></div></div><div id="36925730" class="c"><input type="checkbox" id="c-36925730" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#36925321">root</a><span>|</span><a href="#36925599">parent</a><span>|</span><a href="#36926131">prev</a><span>|</span><a href="#36928710">next</a><span>|</span><label class="collapse" for="c-36925730">[-]</label><label class="expand" for="c-36925730">[2 more]</label></div><br/><div class="children"><div class="content">I assert it is misguided to cling to any view of these as a fundamental truth.  They are modeling tools.  As such, use them for their usefulness.  Don&#x27;t chase truths with them, at they are tools, not truths.</div><br/><div id="36925885" class="c"><input type="checkbox" id="c-36925885" checked=""/><div class="controls bullet"><span class="by">stinkbutt</span><span>|</span><a href="#36925321">root</a><span>|</span><a href="#36925730">parent</a><span>|</span><a href="#36928710">next</a><span>|</span><label class="collapse" for="c-36925885">[-]</label><label class="expand" for="c-36925885">[1 more]</label></div><br/><div class="children"><div class="content">i agree, and its important that we understand what the tools were designed to do before we use them</div><br/></div></div></div></div></div></div></div></div><div id="36928710" class="c"><input type="checkbox" id="c-36928710" checked=""/><div class="controls bullet"><span class="by">dmvdoug</span><span>|</span><a href="#36925321">prev</a><span>|</span><a href="#36924922">next</a><span>|</span><label class="collapse" for="c-36928710">[-]</label><label class="expand" for="c-36928710">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; So you list all the things that the ideal version of yourself must have and a long list of things you must do. But to make any progress on your goal, you have the cognitive load of keeping track of all the requirements youâve put on yourself. I speculate that this is why many New Yearâs resolutions fail; the abstraction for building your future self is weak.</i><p>Or people just pop them off their stack willy-nilly because itâs a vague tradition to do so. Because most people who are old enough to be serious about a âNew Yearâs resolutionâ also are old enough to understand that if you really want to accomplish something or change something, it takes time and dedication and not just pinky-swearing at midnight over champagne.<p>Also, not to nitpick, but the reason people make lists of things to get done is so that there is literally no cognitive load in keeping track of them. And itâs a weird pivot to go from people have a lot of things they think they want to accomplish to writers write and runners run (literally cases where people have only one thing they want to accomplish).<p>The framing of this piece was so weird.</div><br/></div></div><div id="36924922" class="c"><input type="checkbox" id="c-36924922" checked=""/><div class="controls bullet"><span class="by">jonahx</span><span>|</span><a href="#36928710">prev</a><span>|</span><a href="#36925367">next</a><span>|</span><label class="collapse" for="c-36924922">[-]</label><label class="expand" for="c-36924922">[20 more]</label></div><br/><div class="children"><div class="content">Slightly OT: I like Go, but the &quot;-er&quot; convention, while useful, has always bothered me because of the following inconsistency, well illustrated by two examples from the article:<p><pre><code>    Writers write.
    Readers read.

    type Reader interface {
     Read(p []byte) (n int, err error)
    }

    type Writer interface {
     Write(p []byte) (n int, err error)
    }
</code></pre>
In a Go interface, a reader doesn&#x27;t read: a reader gets <i>read from</i>.  The reader (in the English language sense) is the client code of the Reader interface (in the Go sense).<p>That said, I find the Java &quot;-able&quot; convention even uglier, though it answers my complaint.</div><br/><div id="36928771" class="c"><input type="checkbox" id="c-36928771" checked=""/><div class="controls bullet"><span class="by">mannschott</span><span>|</span><a href="#36924922">parent</a><span>|</span><a href="#36925356">next</a><span>|</span><label class="collapse" for="c-36928771">[-]</label><label class="expand" for="c-36928771">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always suspected that &#x27;Reader&#x27; and &#x27;Writer&#x27; were names borrowed from Oberon since that&#x27;s one of the influences that contributed to early Go design:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Project-Oberon&#x2F;Source-Code&#x2F;blob&#x2F;cf7f6a6cda1c5e58299726ec578ffde76ce8a6bf&#x2F;CERES%20Oberon%20V2&#x2F;ASCII&#x2F;Texts.Mod.txt#L74">https:&#x2F;&#x2F;github.com&#x2F;Project-Oberon&#x2F;Source-Code&#x2F;blob&#x2F;cf7f6a6cd...</a><p>Please enjoy this microdose of historical trivia even though it doesn&#x27;t answer the question of why those names were chosen (when designing Oberon).</div><br/></div></div><div id="36925356" class="c"><input type="checkbox" id="c-36925356" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#36924922">parent</a><span>|</span><a href="#36928771">prev</a><span>|</span><a href="#36925694">next</a><span>|</span><label class="collapse" for="c-36925356">[-]</label><label class="expand" for="c-36925356">[12 more]</label></div><br/><div class="children"><div class="content">Works if you consider the reader is what you use to do the reading.  You have a source you want to read, so you get a reader that can do that.<p>Literally, you get a reader when you want to read something.  You get a writer when you want to write something.<p>Though, beware thinking you can solve this with word choice.</div><br/><div id="36926392" class="c"><input type="checkbox" id="c-36926392" checked=""/><div class="controls bullet"><span class="by">jonahx</span><span>|</span><a href="#36924922">root</a><span>|</span><a href="#36925356">parent</a><span>|</span><a href="#36925694">next</a><span>|</span><label class="collapse" for="c-36926392">[-]</label><label class="expand" for="c-36926392">[11 more]</label></div><br/><div class="children"><div class="content">&gt; Works if you consider the reader is what you use to do the reading. You have a source you want to read, so you get a reader that can do that.<p>This strains ordinary language imo:<p>Say you have a &quot;log&quot; which implements the Reader interface.  When I call &quot;log.read()&quot; surely we are reading from the log, no?  The log itself isn&#x27;t the reader.  This matches everyday usage.<p>Perhaps your argument is that you can envisage the &quot;log&quot; object as an abstract &quot;reader&quot; of the bytes on disk, or something like that -- so the mental model is not a &quot;log being read from&quot; but instead &quot;bytes on disk, an object able to read them (the Reader), and the code using that object to do the reading&quot;.  In this worldview one never <i>does</i> anything oneself, but always uses a tool to do that thing -- the &quot;-er&quot; tool.  I dislike this as it introduces an unnecessary layer of abstraction, but I grant it resolves the issue consistently.<p>Also in this conception now I have a variable named &quot;log&quot; which does not represent the log but &quot;a reader of the log&quot;.  So you have to either ignore that inconsistency or name the variable &quot;logReader&quot;, which introduces extra verboseness everywhere.<p>The other resolution is simply to say this is a programming language, not ordinary language, and we decided that having a consistent, mnemonic way to name one method interfaces was more important than respecting natural language analogies.  So f it, we&#x27;re using &quot;-er&quot; to mean &quot;-able&quot;.<p>I would be curious to know what the actual conversation was during the development of Go.</div><br/><div id="36926948" class="c"><input type="checkbox" id="c-36926948" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#36924922">root</a><span>|</span><a href="#36926392">parent</a><span>|</span><a href="#36928602">prev</a><span>|</span><a href="#36925694">next</a><span>|</span><label class="collapse" for="c-36926948">[-]</label><label class="expand" for="c-36926948">[9 more]</label></div><br/><div class="children"><div class="content">But odds are high your code isn&#x27;t reading from any device.  It is literally using a &quot;reader of ___&quot; to get the data read into a buffer that your code will process.<p>So, still seems to work for me.</div><br/><div id="36927021" class="c"><input type="checkbox" id="c-36927021" checked=""/><div class="controls bullet"><span class="by">jonahx</span><span>|</span><a href="#36924922">root</a><span>|</span><a href="#36926948">parent</a><span>|</span><a href="#36925694">next</a><span>|</span><label class="collapse" for="c-36927021">[-]</label><label class="expand" for="c-36927021">[8 more]</label></div><br/><div class="children"><div class="content">Typically you are reading from a file, or the network.<p><pre><code>    someFile.read(dest)
    network.read(dest)
</code></pre>
I&#x27;m <i>reading from</i> a file or network in both cases.  You can say you&#x27;re using &quot;the reader&quot; to read, but as I said it a) introduces an unnecessary concept, b) is not how we naturally talk, and c) does not fit with the variable names (unless you want append &quot;Reader&quot; to all of them, which I think is ugly and bloated.)<p>It&#x27;s not the worst thing in the world, and I understand the benefits of the choice, but still it slightly grates on me.</div><br/><div id="36927211" class="c"><input type="checkbox" id="c-36927211" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#36924922">root</a><span>|</span><a href="#36927021">parent</a><span>|</span><a href="#36925694">next</a><span>|</span><label class="collapse" for="c-36927211">[-]</label><label class="expand" for="c-36927211">[7 more]</label></div><br/><div class="children"><div class="content">You are using some other code capable of reading from the file, though.  Your code can do no such thing.<p>Consider now you send a physical letter to me?  You use a mail carrier.  You have my address, but sending is through the carrier.  Same for calls, you use a service provider to make the call.</div><br/><div id="36927337" class="c"><input type="checkbox" id="c-36927337" checked=""/><div class="controls bullet"><span class="by">jonahx</span><span>|</span><a href="#36924922">root</a><span>|</span><a href="#36927211">parent</a><span>|</span><a href="#36925694">next</a><span>|</span><label class="collapse" for="c-36927337">[-]</label><label class="expand" for="c-36927337">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Consider now you send a physical letter to me? You use a mail carrier. You have my address, but sending is through the carrier. Same for calls, you use a service provider to make the call.<p>We perform some actions with tools, but not all.  Do you use a tool to run?  To read a book?  You simply run, or read.  My issue is that Go forces every situation into the tool paradigm.<p>If I have an object representing a file that I can read from, I am reading from that file.  I am not using anything to read from it.  So either the object can no longer represent the file directly (but instead a tool used to read it), or the file can keep representing the file but the language is off because the file is now also a &quot;Reader&quot; (in the Go sense) of the file.<p>&gt; You are using some other code capable of reading from the file, though.<p>We are talking about how to conceptually name pieces of our code to match our natural concepts and language. That is, the conversation we&#x27;re having is one about modeling, so this move seems illegal to me.  The &quot;other code implementing reader&quot; is not part of the model.  It would be like arguing, in regular life, that &quot;you can&#x27;t say that you read a book, because really it is your brain doing the reading&quot;.</div><br/><div id="36927391" class="c"><input type="checkbox" id="c-36927391" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#36924922">root</a><span>|</span><a href="#36927337">parent</a><span>|</span><a href="#36925694">next</a><span>|</span><label class="collapse" for="c-36927391">[-]</label><label class="expand" for="c-36927391">[5 more]</label></div><br/><div class="children"><div class="content">But you are playing into it?  If you are the one running, you are a runner.  If you used someone else to run a letter to the whatever, they were the runner.<p>It can fail if you are writing the physical contact point to the hardware, but very few of us do that.  We use code that does that.<p>Do I use a tool to read?  I have reading glasses.  And an ebook reader.  And I&#x27;ve delegated some reading to others.  Life is complicated.  Language no less so.</div><br/><div id="36927700" class="c"><input type="checkbox" id="c-36927700" checked=""/><div class="controls bullet"><span class="by">jonahx</span><span>|</span><a href="#36924922">root</a><span>|</span><a href="#36927391">parent</a><span>|</span><a href="#36925694">next</a><span>|</span><label class="collapse" for="c-36927700">[-]</label><label class="expand" for="c-36927700">[4 more]</label></div><br/><div class="children"><div class="content">&gt; And an ebook reader<p>Your ebook reader it the thing being read, not the thing that reads.  Glasses for reading are also called readers, and they are the tool helping you read.  Here, to your point, we see &quot;language being complicated&quot; -- the same convention being used for opposite things.  But this is a tangential point leading us astray.<p>I thought about this some more in the shower, and I think I can distill my objection more clearly.<p>Methods on objects act on those objects.  That is:<p><pre><code>    object.do()
</code></pre>
is equivalent, in English, to performing the action &quot;do&quot; on &quot;object&quot;.  To take a random example from Effective Go:<p><pre><code>    d, err := f.Stat()
    if err != nil {
        f.Close()
        return err
    }
</code></pre>
We &quot;Stat()&quot; the file (get statistics about it) and we &quot;Close()&quot; the file.  This pattern is well-established in both Go and nearly every language with objects.  Instance methods are actions performed on their object.<p>Now of course &quot;File&quot; also implements &quot;Reader&quot;.  Yet when I &quot;f.Read()&quot; the situation is exactly the same as in &quot;Stat&quot; and &quot;Close&quot;.  I am <i>reading</i> the file.<p>So where is the &quot;Reader&quot; now?  Well the Reader <i>is</i> also the file.  In the conceptual model, there is no other object around.  The file is both the Reader and the object of reading.  And that&#x27;s my problem.  The &quot;reader as tool&quot; is inconsistent with &quot;methods act on objects&quot;.<p>In the tool model you&#x27;ve been arguing for, I would have to write something like:<p><pre><code>    reader.read(file)
</code></pre>
The redundancy of that aside, this is not typically what you see with Go code (though you sometimes do).  You are more likely to see stuff like &quot;f.Read()&quot;<p>As I said, you can argue that Go&#x27;s &quot;File&quot; object is not meant to represent a file, but instead an abstract tool: a thing which can Read and Stat and Close files.<p>But that&#x27;s not what the documentation says: &quot;File represents an open file descriptor.&quot;<p>That is, in the intended conceptual model, the &quot;f&quot; in &quot;f.Read()&quot; <i>is</i> a file.  And we are reading it.  And that is at odds with it being a &quot;Reader&quot; -- a thing that reads.</div><br/><div id="36928240" class="c"><input type="checkbox" id="c-36928240" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#36924922">root</a><span>|</span><a href="#36927700">parent</a><span>|</span><a href="#36927799">next</a><span>|</span><label class="collapse" for="c-36928240">[-]</label><label class="expand" for="c-36928240">[2 more]</label></div><br/><div class="children"><div class="content">In this case, isn&#x27;t it kindof right though? If it says it represents a file <i>descriptor</i>, not a concrete file. The descriptor reads the file for you. You close the descriptor, not the file, etc. Though in that case you could argue the name of the object should be FileDescriptor and not File. You are onto something, often we model functions to act on objects, not objects to be tools acting on other objects.</div><br/><div id="36928442" class="c"><input type="checkbox" id="c-36928442" checked=""/><div class="controls bullet"><span class="by">jonahx</span><span>|</span><a href="#36924922">root</a><span>|</span><a href="#36928240">parent</a><span>|</span><a href="#36927799">next</a><span>|</span><label class="collapse" for="c-36928442">[-]</label><label class="expand" for="c-36928442">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s some example C using one:<p><pre><code>    bytesRead = read(fd, buf, BUF_SIZE - 1)
</code></pre>
You read the from the file descriptor into the buffer.  Just like in Go you read from a file into a byte array.  Neither the file descriptor nor the file is conceptualized as a tool for reading.  The file descriptor is merely an abstraction of the file, which extends the concept of &quot;file&quot; to include pipes, sockets, and other io.</div><br/></div></div></div></div><div id="36927799" class="c"><input type="checkbox" id="c-36927799" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#36924922">root</a><span>|</span><a href="#36927700">parent</a><span>|</span><a href="#36928240">prev</a><span>|</span><a href="#36925694">next</a><span>|</span><label class="collapse" for="c-36927799">[-]</label><label class="expand" for="c-36927799">[1 more]</label></div><br/><div class="children"><div class="content">The reader reads the file into a string. You then access or modify the string. The file is a thing on disk being read by a file reader, an implementation of the reader interface, which reads the file.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36925694" class="c"><input type="checkbox" id="c-36925694" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#36924922">parent</a><span>|</span><a href="#36925356">prev</a><span>|</span><a href="#36926868">next</a><span>|</span><label class="collapse" for="c-36925694">[-]</label><label class="expand" for="c-36925694">[1 more]</label></div><br/><div class="children"><div class="content">A diagram that made things click for me is putting different abstractions on a grid showing the different combinations of high level contracts they fulfil.<p>Every combination of push&#x2F;pull, read&#x2F;write, and sync&#x2F;async can exist and makes sense.<p>The Go interface is âsync pull readâ which is âReadableâ.<p>Then âReaderâ is âsync push readâ, etcâ¦<p>Another axis is âsingle itemâ, âsequence of itemsâ, or âcontiguous array chunks of itemsâ. These are âpropertyâ, âiteratorâ, and âstreamâ respectively of synchronous. Theyâre âtaskâ, âasynchronous iteratorâ, and âasync streamâ if non-blocking. Etcâ¦</div><br/></div></div><div id="36926868" class="c"><input type="checkbox" id="c-36926868" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36924922">parent</a><span>|</span><a href="#36925694">prev</a><span>|</span><a href="#36925086">next</a><span>|</span><label class="collapse" for="c-36926868">[-]</label><label class="expand" for="c-36926868">[2 more]</label></div><br/><div class="children"><div class="content">The Reader is doing the reading.<p><pre><code>  reader.Read(p); &#x2F;&#x2F; reader, please read into this array
</code></pre>
The caller is obtaining the result of the read operation.<p>---<p>What mows a lawn? A person, or machinery?<p>In English, either can be referred to as a &quot;lawn mover.&quot; However, most often &quot;lawn mower&quot; has the most direct meaning: the machine.</div><br/><div id="36926905" class="c"><input type="checkbox" id="c-36926905" checked=""/><div class="controls bullet"><span class="by">jonahx</span><span>|</span><a href="#36924922">root</a><span>|</span><a href="#36926868">parent</a><span>|</span><a href="#36925086">next</a><span>|</span><label class="collapse" for="c-36926905">[-]</label><label class="expand" for="c-36926905">[1 more]</label></div><br/><div class="children"><div class="content">See my reply here for the problems with that: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36926392">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36926392</a><p>EDIT:<p>To elaborate my reply there tailored to your lawn mower example...<p>&gt; What mows a lawn? A person, or machinery?<p>Yes, in this case the tool analogy matches real life (and your interpretation of Go interfaces as tools): I use a lawn mower to mow the lawn.<p>My issue is that there isn&#x27;t always a tool, but the Go worldview forces there to be one:<p><i>What reads a book?  A person, or a ...?</i></div><br/></div></div></div></div><div id="36925271" class="c"><input type="checkbox" id="c-36925271" checked=""/><div class="controls bullet"><span class="by">tareqak</span><span>|</span><a href="#36924922">parent</a><span>|</span><a href="#36925086">prev</a><span>|</span><a href="#36925367">next</a><span>|</span><label class="collapse" for="c-36925271">[-]</label><label class="expand" for="c-36925271">[2 more]</label></div><br/><div class="children"><div class="content">Why not use both? -erâs do stuff <i>to</i> things while -ableâs get stuff done to them and use them as it make sense.<p>Use the one that makes the most sense given the situation.</div><br/><div id="36926290" class="c"><input type="checkbox" id="c-36926290" checked=""/><div class="controls bullet"><span class="by">jonahx</span><span>|</span><a href="#36924922">root</a><span>|</span><a href="#36925271">parent</a><span>|</span><a href="#36925367">next</a><span>|</span><label class="collapse" for="c-36926290">[-]</label><label class="expand" for="c-36926290">[1 more]</label></div><br/><div class="children"><div class="content">You could, but this is not Go&#x27;s convention.  Go&#x27;s convention is that when you have an interface with a single method &quot;x&quot;, you name the interface &quot;xer&quot;.<p>This has the advantage of being simple and mnemonic.  It has the downside I already mentioned.</div><br/></div></div></div></div></div></div><div id="36925367" class="c"><input type="checkbox" id="c-36925367" checked=""/><div class="controls bullet"><span class="by">mayoff</span><span>|</span><a href="#36924922">prev</a><span>|</span><a href="#36927413">next</a><span>|</span><label class="collapse" for="c-36925367">[-]</label><label class="expand" for="c-36925367">[1 more]</label></div><br/><div class="children"><div class="content">This lesson is applicable to lots of languages, not just Go. For example, looking at Swift (where the equivalent of an interface is a protocol), we find many protocols in the standard library that either have one function requirement, or add one function requirement to a parent protocol:<p>- Equatable requires ==<p>- Comparable extends Equatable, requires &lt;<p>- Hashable extends Equatable, requires hash(into:)<p>- Identifiable requires id<p>- Encodable requires encode(to:)<p>- Decodable requires init(from:)<p>- CustomStringConvertible requires description<p>- LosslessStringConvertible extends CustomStringConvertible, requires init?(_:)<p>- CustomDebugStringConvertible requires debugDescription<p>- CaseIterable requires allCases<p>- Sequence requires makeIterator()<p>- IteratorProtocol requires next()<p>- TextOutputStream requires write(_:)<p>- TextOutputStreamable requires write(to:)<p>- CustomReflectable requires customMirror<p>- CustomPlaygroundDisplayConvertible requires playgroundDescription<p>- AsyncSequence requires makeAsyncIterator()<p>- AsyncIteratorProtocol requires next()<p>And Appleâs Swift-only frameworks also have major single-function protocols:<p>- SwiftUI.View requires body<p>- SwiftUI.Animatable requires animatableData<p>- SwiftUI.TimelineSchedule requires entries(from:mode:)<p>- SwiftUI.EnvironmentKey requires defaultValue<p>- Combine.Publisher requires receive(subscriber:)<p>- Combine.Cancellable requires cancel()<p>- Combine.Subscription requires request(_:)</div><br/></div></div><div id="36927413" class="c"><input type="checkbox" id="c-36927413" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#36925367">prev</a><span>|</span><a href="#36924701">next</a><span>|</span><label class="collapse" for="c-36927413">[-]</label><label class="expand" for="c-36927413">[1 more]</label></div><br/><div class="children"><div class="content">I sorta kind of agree with where the author is going, but I think thatâs because I know Go and this works quite well in that language. But if I pretended to not know Go, this doesnât make too much sense on its own, in an arbitrary context.<p>Even in Go, there isnât such a strong correlation with interface size and âabstraction strengthâ. For instance, io.Reader and io.ReadWriteCloser are subjectively similar in terms of âstrengthâ, it just depends on what youâre building. One of the âstrongestâ abstractions is net.Conn which has 8 methods, which is a lot. In fact, http.ResponseWriter was <i>too small</i> and an ongoing annoyance for years. Only recently was this flaw addressed with http.ResponseController.<p>Instead, I suspect that Go interfaces are powerful mostly because everyone and their grandma uses the same interfaces, thanks to (1) a std lib with opinionated interface definitions and (2) that the language itself is very focused on âone wayâ of representing things (no function coloring, for instance). This allows for eg a vast ecosystem of http middleware, that <i>isnât</i> tied to a specific http server.<p>Indeed, whenever you venture outside of std interfaces, their appeal really starts waning. Theyâre fine, but the being seamlessly interoperable within the larger ecosystem is, in my view, where the magic is.</div><br/></div></div><div id="36924701" class="c"><input type="checkbox" id="c-36924701" checked=""/><div class="controls bullet"><span class="by">ilrwbwrkhv</span><span>|</span><a href="#36927413">prev</a><span>|</span><a href="#36925102">next</a><span>|</span><label class="collapse" for="c-36924701">[-]</label><label class="expand" for="c-36924701">[4 more]</label></div><br/><div class="children"><div class="content">Go indeed has a simplicity and elegance that makes it really easy to write code which is highly performant and easy to maintain. That is the only reason I picked go when moving from common lisp.</div><br/><div id="36924982" class="c"><input type="checkbox" id="c-36924982" checked=""/><div class="controls bullet"><span class="by">moffkalast</span><span>|</span><a href="#36924701">parent</a><span>|</span><a href="#36925102">next</a><span>|</span><label class="collapse" for="c-36924982">[-]</label><label class="expand" for="c-36924982">[3 more]</label></div><br/><div class="children"><div class="content">&gt; from common lisp<p>Is there such a thing as uncommon or rare lisp?</div><br/><div id="36925229" class="c"><input type="checkbox" id="c-36925229" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#36924701">root</a><span>|</span><a href="#36924982">parent</a><span>|</span><a href="#36925395">next</a><span>|</span><label class="collapse" for="c-36925229">[-]</label><label class="expand" for="c-36925229">[1 more]</label></div><br/><div class="children"><div class="content">Common Lisp is the name of a programming language.</div><br/></div></div><div id="36925395" class="c"><input type="checkbox" id="c-36925395" checked=""/><div class="controls bullet"><span class="by">yellowapple</span><span>|</span><a href="#36924701">root</a><span>|</span><a href="#36924982">parent</a><span>|</span><a href="#36925229">prev</a><span>|</span><a href="#36925102">next</a><span>|</span><label class="collapse" for="c-36925395">[-]</label><label class="expand" for="c-36925395">[1 more]</label></div><br/><div class="children"><div class="content">Possibly even Epic Lisp, Legendary Lisp, or Exotic Lisp.</div><br/></div></div></div></div></div></div><div id="36925102" class="c"><input type="checkbox" id="c-36925102" checked=""/><div class="controls bullet"><span class="by">account-5</span><span>|</span><a href="#36924701">prev</a><span>|</span><a href="#36924587">next</a><span>|</span><label class="collapse" for="c-36925102">[-]</label><label class="expand" for="c-36925102">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m having a hard time understanding what the author means by interface given the context they&#x27;re using it in at the start of the article. I remember not thinking I fully understood the term when used in programming either, or why you&#x27;d use one.<p>Can someone explain for the idiot?</div><br/><div id="36925336" class="c"><input type="checkbox" id="c-36925336" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#36925102">parent</a><span>|</span><a href="#36924587">next</a><span>|</span><label class="collapse" for="c-36925336">[-]</label><label class="expand" for="c-36925336">[1 more]</label></div><br/><div class="children"><div class="content">I _think_ the idea is thinking of an &quot;interface&quot; as &quot;something that you use as a way to interact with something from outside an abstraction&quot;. I&#x27;d summarize their argument as reasoning that if the goal of an abstraction is to avoid having to care about the internal details of something, an interface is a way to expose a subset of ways to interact with it, and the more you expand it, the more it exposes the internals of the thing being abstracted. I don&#x27;t think they necessarily mean this only in terms of programming, but you could apply this argument to a programming language interface; if you use an interface for interacting with something instead of its direct functionality, each additional method you add to the interface exposes more details of the inner value, which makes it less of an abstraction.<p>Assuming my interpretation is correct, I&#x27;m not sure I totally buy this argument because there doesn&#x27;t seem to be an obvious way to define the &quot;size&quot; of an interface where it holds true. The naive way to define the size would be number of methods, but I&#x27;d argue that methods can vary so much in terms of the amount of cognitive overhead they &quot;expose&quot; to the user that it&#x27;s not very meaningful. Consider the Movfuscator compiler[0], which compiles code into binaries only using MOV x86 instructions because it happens to be Turing complete; as complex as it might be to learn x86 assembly as a whole and start writing programs directly in it, I&#x27;m dubious that trying to do so only with MOV would somehow be easier. Put another way, an x86 instruction set that only contains the MOV instruction is not a &quot;stronger&quot; abstraction than the actual one because it _introduces_ complexity that doesn&#x27;t exist in the original. Does adding an ADD instruction alongside MOV increase the strength of the abstraction, or weaken it? I don&#x27;t think there&#x27;s an answer that we&#x27;d immediately all agree on for this sort of thing.<p>Ultimately, I think trying to measure interfaces through the number of methods they expose is similar to trying to measure code by the number of lines in it; while there are some extreme cases where we&#x27;d likely all agree (e.g. for a fizzbuzz implementation, having 10 lines of code is probably better than thousands of lines of code[1]), we can&#x27;t really come up with a good objective metric because the &quot;target&quot; number is based on the complexity of what you&#x27;re trying to define, and we don&#x27;t have a way of quantifying that complexity. I think the ideas here are still super interesting though, not because they have definitive right or wrong answers, but because thinking about stuff like this overall improves one&#x27;s ability to write good software for usage by other programmers.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;xoreaxeaxeax&#x2F;movfuscator">https:&#x2F;&#x2F;github.com&#x2F;xoreaxeaxeax&#x2F;movfuscator</a>
[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;EnterpriseQualityCoding&#x2F;FizzBuzzEnterpriseEdition">https:&#x2F;&#x2F;github.com&#x2F;EnterpriseQualityCoding&#x2F;FizzBuzzEnterpris...</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>