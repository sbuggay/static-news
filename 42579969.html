<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735894856013" as="style"/><link rel="stylesheet" href="styles.css?v=1735894856013"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://tavianator.com/2025/shlx.html">The Alder Lake SHLX Anomaly</a> <span class="domain">(<a href="https://tavianator.com">tavianator.com</a>)</span></div><div class="subtext"><span>panic</span> | <span>42 comments</span></div><br/><div><div id="42580251" class="c"><input type="checkbox" id="c-42580251" checked=""/><div class="controls bullet"><span class="by">tavianator</span><span>|</span><a href="#42580376">next</a><span>|</span><label class="collapse" for="c-42580251">[-]</label><label class="expand" for="c-42580251">[4 more]</label></div><br/><div class="children"><div class="content">One fun thing about this is that spilling+restoring the register will fix it, so if any kind of context switch happens (thread switch, page fault, interrupt, etc.), the register will get pushed to the stack and popped back from it, and the code suddenly gets 3x faster.  Makes it a bit tricky to reproduce reliably, and led me down a few dead ends as I was writing this up.</div><br/><div id="42580327" class="c"><input type="checkbox" id="c-42580327" checked=""/><div class="controls bullet"><span class="by">eigenform</span><span>|</span><a href="#42580251">parent</a><span>|</span><a href="#42580376">next</a><span>|</span><label class="collapse" for="c-42580327">[-]</label><label class="expand" for="c-42580327">[3 more]</label></div><br/><div class="children"><div class="content">I wonder if this is a thing where the machine is trying to predict the actual value of the &#x27;count&#x27; operand ...</div><br/><div id="42580554" class="c"><input type="checkbox" id="c-42580554" checked=""/><div class="controls bullet"><span class="by">tavianator</span><span>|</span><a href="#42580251">root</a><span>|</span><a href="#42580327">parent</a><span>|</span><a href="#42580376">next</a><span>|</span><label class="collapse" for="c-42580554">[-]</label><label class="expand" for="c-42580554">[2 more]</label></div><br/><div class="children"><div class="content">If it were a prediction&#x2F;speculation thing, I would expect it to settle down long before 10,000 `SHLX`s are retired.</div><br/></div></div></div></div></div></div><div id="42580376" class="c"><input type="checkbox" id="c-42580376" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42580251">prev</a><span>|</span><a href="#42581246">next</a><span>|</span><label class="collapse" for="c-42580376">[-]</label><label class="expand" for="c-42580376">[17 more]</label></div><br/><div class="children"><div class="content">How about trying &quot;xor ecx, ecx; inc ecx&quot;? Or the even shorter &quot;mov cl, 1&quot;?<p><i>It is very strange to me that the instruction used to set the shift count register can make the SHLX instruction 3× slower.</i><p>I suspect this is a width restriction in the bypass&#x2F;forwarding network.<p><i>The 32-bit vs. 64-bit operand size distinction is especially surprising to me as SHLX only looks at the bottom 6 bits of the shift count.</i><p>Unfortunately the dependency analysis circuitry seems not Intel-ligent enough to make that distinction.</div><br/><div id="42580547" class="c"><input type="checkbox" id="c-42580547" checked=""/><div class="controls bullet"><span class="by">tavianator</span><span>|</span><a href="#42580376">parent</a><span>|</span><a href="#42580605">next</a><span>|</span><label class="collapse" for="c-42580547">[-]</label><label class="expand" for="c-42580547">[15 more]</label></div><br/><div class="children"><div class="content">&gt; How about trying &quot;xor ecx, ecx; inc ecx&quot;?<p>Fast.  But inc rcx is slow.<p>&gt; Or the even shorter &quot;mov cl, 1&quot;?<p>Fast.<p>&gt; I suspect this is a width restriction in the bypass&#x2F;forwarding network...<p>I think we just found the explanation on Twitter: <a href="https:&#x2F;&#x2F;x.com&#x2F;corsix&#x2F;status&#x2F;1874965887108976858" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;corsix&#x2F;status&#x2F;1874965887108976858</a><p>Alder Lake adds support for mov&#x2F;add&#x2F;sub with small immediates to the <i>register renamer</i>.  So `add rcx, 1` gets handled by the renamer, potentially with zero latency.<p>Unfortunately shifts are slow when the shift count is renamed in this way.  This leads to fun things like `mov rcx, 1024` being fast while `mov rcx, 1023` is slow.  I&#x27;ll update the blog post in a bit.</div><br/><div id="42581109" class="c"><input type="checkbox" id="c-42581109" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#42580376">root</a><span>|</span><a href="#42580547">parent</a><span>|</span><a href="#42581245">next</a><span>|</span><label class="collapse" for="c-42581109">[-]</label><label class="expand" for="c-42581109">[6 more]</label></div><br/><div class="children"><div class="content">Ok... That does make some sense.<p>Essentially, Intel have allocated a bunch of fake renaming registers to hold all small immediates. Like how MIPS had a zero register, Intel now have over 1000 constant registers. These registers don&#x27;t really exist, the immediate is just reconstituted at the execution unit.<p>And I&#x27;m guessing these small immediates predate Golden Cove; It&#x27;s probably how they have always represented shift by constant and any instructions with 8bit immediate (presumably at least as far back as Sandybridge). The only change is that now the renamer can now execute simple movs&#x2F;adds.<p>So essentially these variable shifts are being converted to constant shifts on the fly. The problem is that there is no constant shift version of shlx, so it wasn&#x27;t in the test suite. There is probably some kind of stupid implementation bug in the scheduler that simply wasn&#x27;t exposed until the renamer changes.</div><br/><div id="42581515" class="c"><input type="checkbox" id="c-42581515" checked=""/><div class="controls bullet"><span class="by">tavianator</span><span>|</span><a href="#42580376">root</a><span>|</span><a href="#42581109">parent</a><span>|</span><a href="#42581245">next</a><span>|</span><label class="collapse" for="c-42581515">[-]</label><label class="expand" for="c-42581515">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think there are a thousand constant registers.  I think the renamer just represents (reg, 10-bit offset) pairs rather than just registers.<p>Also the problem affects SHL as well as SHLX, I didn&#x27;t realize until just now.</div><br/><div id="42582361" class="c"><input type="checkbox" id="c-42582361" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#42580376">root</a><span>|</span><a href="#42581515">parent</a><span>|</span><a href="#42581245">next</a><span>|</span><label class="collapse" for="c-42582361">[-]</label><label class="expand" for="c-42582361">[4 more]</label></div><br/><div class="children"><div class="content">The speculation of a &quot;reg + 10-bit offset&quot; representation feels wrong to me.<p>That requires a whole bunch of extra 64-bit full-adders everywhere one of these pairs might be consumed (so realistically, on every single read port of the register file). 64-bit adders take quite a bit of latency, so you don&#x27;t want extra adders on all your critical paths.<p>In the case where it appears to be holding a reg + offset pair, what I think has actually happened is that renamer (and&#x2F;or uop fusion) has rewritten the uop to a 3-input add, with the offset as the third input.<p><i>&gt; Also the problem affects SHL as well as SHLX, I didn&#x27;t realize until just now.</i><p>And presumably SHR&#x2F;SHRX&#x2F;SAR&#x2F;SARX too?</div><br/><div id="42582751" class="c"><input type="checkbox" id="c-42582751" checked=""/><div class="controls bullet"><span class="by">eigenform</span><span>|</span><a href="#42580376">root</a><span>|</span><a href="#42582361">parent</a><span>|</span><a href="#42582535">next</a><span>|</span><label class="collapse" for="c-42582751">[-]</label><label class="expand" for="c-42582751">[2 more]</label></div><br/><div class="children"><div class="content">I dunno, you could imagine it happens [speculatively?] in parallel, at the cost of a read port and adder for each op that can be renamed in a single cycle:<p>1. Start PRF reads at dispatch&#x2F;rename<p>2. In the next cycle, you have the result and compute the 64-bit result. At the same time, the scheduler is sending other operands [not subject to the optimization] to read ports.<p>3. In the next cycle, the results from both sets of operands are available</div><br/><div id="42583001" class="c"><input type="checkbox" id="c-42583001" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#42580376">root</a><span>|</span><a href="#42582751">parent</a><span>|</span><a href="#42582535">next</a><span>|</span><label class="collapse" for="c-42583001">[-]</label><label class="expand" for="c-42583001">[1 more]</label></div><br/><div class="children"><div class="content">Seems rather pointless to implement it like that. You would save space in the scheduler because the uops have been fused, but execution time and execution unit usage is the same as just executing the original ops before this optimisation was implemented.<p>It also adds an extra cycle of scheduling latency, which may or may not be an issue (I really have no idea how far ahead these schedulers can schedule).<p>If you think about the &quot;1024 constant registers&quot; approach: It allows you to have a small 10bit adder in the renamer which handles long chains of mov&#x2F;add&#x2F;sub&#x2F;inc&#x2F;dec ops, as long as the chain stays in the range of 1024. This frees the main adders for bigger sums, or maybe you can power gate them.<p>And in the case where one of the inputs is larger than 1024, or it&#x27;s value is unknown during renaming, the renamer can still merge two two-input adds into a single three input add uop.</div><br/></div></div></div></div><div id="42582535" class="c"><input type="checkbox" id="c-42582535" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#42580376">root</a><span>|</span><a href="#42582361">parent</a><span>|</span><a href="#42582751">prev</a><span>|</span><a href="#42581245">next</a><span>|</span><label class="collapse" for="c-42582535">[-]</label><label class="expand" for="c-42582535">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I am pretty sure that the renamer adds the tracked immediate(s) to the emitted uop, but that&#x27;s not inconsistent with tracking &quot;reg offset pairs&quot; is it?</div><br/></div></div></div></div></div></div></div></div><div id="42581245" class="c"><input type="checkbox" id="c-42581245" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42580376">root</a><span>|</span><a href="#42580547">parent</a><span>|</span><a href="#42581109">prev</a><span>|</span><a href="#42580998">next</a><span>|</span><label class="collapse" for="c-42581245">[-]</label><label class="expand" for="c-42581245">[1 more]</label></div><br/><div class="children"><div class="content"><i>So `add rcx, 1` gets handled by the renamer, potentially with zero latency.<p>Unfortunately shifts are slow when the shift count is renamed in this way.</i><p>That&#x27;s because the value still has to make it to the shifter... and the renamer&#x27;s adder output clearly takes a different and higher-latency path than the one which doesn&#x27;t go through it, confirming my original suspicion that this is a limitation of the bypass&#x2F;forwarding network.<p>Ultimately it seems they are just playing around with where things happen; the addition can be done <i>here</i> but the value ultimately needs to go <i>there</i> for the shift, or the addition and shift can both happen <i>there</i>. One could envision a future change that puts the shifter in the renamer too. They&#x27;re really constrained by the laws of physics.</div><br/></div></div><div id="42580998" class="c"><input type="checkbox" id="c-42580998" checked=""/><div class="controls bullet"><span class="by">eigenform</span><span>|</span><a href="#42580376">root</a><span>|</span><a href="#42580547">parent</a><span>|</span><a href="#42581245">prev</a><span>|</span><a href="#42580724">next</a><span>|</span><label class="collapse" for="c-42580998">[-]</label><label class="expand" for="c-42580998">[6 more]</label></div><br/><div class="children"><div class="content">Oooh, I forgot about this. Only thing I can think of is something like:<p>1. Assume that some values can be treated internally as &quot;physical register plus a small immediate&quot;<p>2. Assume that, in some cases, a physical register is known to be zero and the value can be represented as &quot;zero plus a small immediate&quot; (without reference to a physical register?)<p>3. Since &#x27;count&#x27; is always expected to be &lt;64, you technically don&#x27;t need to use a physical register for it (since the immediate bits can always just be carried around with the name).<p>4. The 3-cycle case occurs when the physical register read cannot be optimized away??<p>(Or maybe it&#x27;s just that the whole shift operation can occur at rename in the fast case??)</div><br/><div id="42581125" class="c"><input type="checkbox" id="c-42581125" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#42580376">root</a><span>|</span><a href="#42580998">parent</a><span>|</span><a href="#42580724">next</a><span>|</span><label class="collapse" for="c-42581125">[-]</label><label class="expand" for="c-42581125">[5 more]</label></div><br/><div class="children"><div class="content"><i>&gt; 4. The 3-cycle case occurs when the physical register read cannot be optimized away??</i><p>No... the 3-cycle case seems to be when the physical register read is optimized away. I think it&#x27;s some kind of stupid implementation bug.</div><br/><div id="42581645" class="c"><input type="checkbox" id="c-42581645" checked=""/><div class="controls bullet"><span class="by">eigenform</span><span>|</span><a href="#42580376">root</a><span>|</span><a href="#42581125">parent</a><span>|</span><a href="#42580724">next</a><span>|</span><label class="collapse" for="c-42581645">[-]</label><label class="expand" for="c-42581645">[4 more]</label></div><br/><div class="children"><div class="content">Like, the scheduler is just waiting unnecessarily for both operands, despite the fact that &#x27;count&#x27; has already been resolved at rename?</div><br/><div id="42582174" class="c"><input type="checkbox" id="c-42582174" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#42580376">root</a><span>|</span><a href="#42581645">parent</a><span>|</span><a href="#42580724">next</a><span>|</span><label class="collapse" for="c-42582174">[-]</label><label class="expand" for="c-42582174">[3 more]</label></div><br/><div class="children"><div class="content">The 3 cycles latency casts massive suspicion on the bypass network. But I don&#x27;t see how the bypass network could be bugged without causing the incorrect result. So the scheduler doesn&#x27;t know how to bypass this &quot;shift with small immediate&quot; micro op.<p>Or maybe the bypass network is bugged, and what we are seeing is a chicken bit set by the microcode that disables the bypass network for this one micro op that does shift.</div><br/><div id="42582617" class="c"><input type="checkbox" id="c-42582617" checked=""/><div class="controls bullet"><span class="by">eigenform</span><span>|</span><a href="#42580376">root</a><span>|</span><a href="#42582174">parent</a><span>|</span><a href="#42580724">next</a><span>|</span><label class="collapse" for="c-42582617">[-]</label><label class="expand" for="c-42582617">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But I don&#x27;t see how the bypass network could be bugged without causing the incorrect result.<p>Maybe if they really rely on this kind of forwarding in many cases, it&#x27;s not unreasonable to expect that latency can be generated by having to recover from &quot;incorrect PRF read&quot; (like I imagine there&#x27;s also a case for recovery from &quot;incorrect forwarding&quot;)</div><br/><div id="42583066" class="c"><input type="checkbox" id="c-42583066" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#42580376">root</a><span>|</span><a href="#42582617">parent</a><span>|</span><a href="#42580724">next</a><span>|</span><label class="collapse" for="c-42583066">[-]</label><label class="expand" for="c-42583066">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, &quot;incorrect PRF read&quot; is something that might exist.<p>I know modern CPUs will sometimes schedule uops that consume the result of load instruction, with the assumption the load will hit L1 cache. If the load actually missed L1, it&#x27;s not going to find out until that uop tries to read the value coming in from L1 over the bypass network. So that uop needs to be aborted and rescheduled later. And I assume this is generic enough to catch any &quot;incorrect forwarding&quot;, because there are other variable length instructions (like division) that would benefit from this optimistic scheduling.<p>But my gut is to only have these checks on the bypass network, and only ever schedule PRF reads after you know the correct value has been stored.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42580724" class="c"><input type="checkbox" id="c-42580724" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42580376">root</a><span>|</span><a href="#42580547">parent</a><span>|</span><a href="#42580998">prev</a><span>|</span><a href="#42580605">next</a><span>|</span><label class="collapse" for="c-42580724">[-]</label><label class="expand" for="c-42580724">[1 more]</label></div><br/><div class="children"><div class="content">I got nothing here other than: this is very cool.</div><br/></div></div></div></div><div id="42580605" class="c"><input type="checkbox" id="c-42580605" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#42580376">parent</a><span>|</span><a href="#42580547">prev</a><span>|</span><a href="#42581246">next</a><span>|</span><label class="collapse" for="c-42580605">[-]</label><label class="expand" for="c-42580605">[1 more]</label></div><br/><div class="children"><div class="content">I would have thought that the movs would have been dumped right into a rob entry without even going through the bypass network, much like a zeroing idiom does.</div><br/></div></div></div></div><div id="42581246" class="c"><input type="checkbox" id="c-42581246" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#42580376">prev</a><span>|</span><a href="#42580582">next</a><span>|</span><label class="collapse" for="c-42581246">[-]</label><label class="expand" for="c-42581246">[10 more]</label></div><br/><div class="children"><div class="content">Worth noting that whether intentional or not, this would be easy to miss and unlikely to move benchmark numbers since compilers won&#x27;t generate instructions like this: they would use the eax form which is 1 byte shorter and functionally equivalent.<p>Even some assemblers will optimize this for you.</div><br/><div id="42581454" class="c"><input type="checkbox" id="c-42581454" checked=""/><div class="controls bullet"><span class="by">tavianator</span><span>|</span><a href="#42581246">parent</a><span>|</span><a href="#42582478">next</a><span>|</span><label class="collapse" for="c-42581454">[-]</label><label class="expand" for="c-42581454">[8 more]</label></div><br/><div class="children"><div class="content">It&#x27;s possible to get gcc to generate sequences that would trigger this: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;rYKqPxn7b" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;rYKqPxn7b</a></div><br/><div id="42581511" class="c"><input type="checkbox" id="c-42581511" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42581246">root</a><span>|</span><a href="#42581454">parent</a><span>|</span><a href="#42582478">next</a><span>|</span><label class="collapse" for="c-42581511">[-]</label><label class="expand" for="c-42581511">[7 more]</label></div><br/><div class="children"><div class="content">The godbolt paste I&#x27;m looking at shows GCC generating a SAL with 8 bit shift (CL), not a SHLX with 64-bit shift (RCX).</div><br/><div id="42581613" class="c"><input type="checkbox" id="c-42581613" checked=""/><div class="controls bullet"><span class="by">tjalfi</span><span>|</span><a href="#42581246">root</a><span>|</span><a href="#42581511">parent</a><span>|</span><a href="#42582098">next</a><span>|</span><label class="collapse" for="c-42581613">[-]</label><label class="expand" for="c-42581613">[2 more]</label></div><br/><div class="children"><div class="content">GCC will generate the <i>shlx</i> instruction if you add the <i>-mbmi2</i> flag to your build options. For example, you can see this in action here: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;asb1fxos5" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;asb1fxos5</a>.</div><br/><div id="42582196" class="c"><input type="checkbox" id="c-42582196" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#42581246">root</a><span>|</span><a href="#42581613">parent</a><span>|</span><a href="#42582098">next</a><span>|</span><label class="collapse" for="c-42582196">[-]</label><label class="expand" for="c-42582196">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s true, I was considering only the original mov rax, 1 case, which I&#x27;m pretty sure compilers don&#x27;t generate: it&#x27;s just a useless encoding of mov eax, 1.<p>Given that 64-bit immediate math also causes this though, compilers might generate it (I think this is a minor missed optimization by gcc though: it could have used add eax, 1 instead.</div><br/></div></div></div></div><div id="42582098" class="c"><input type="checkbox" id="c-42582098" checked=""/><div class="controls bullet"><span class="by">tavianator</span><span>|</span><a href="#42581246">root</a><span>|</span><a href="#42581511">parent</a><span>|</span><a href="#42581613">prev</a><span>|</span><a href="#42582478">next</a><span>|</span><label class="collapse" for="c-42582098">[-]</label><label class="expand" for="c-42582098">[4 more]</label></div><br/><div class="children"><div class="content">SHL suffers from the same latency issue as SHLX it turns out</div><br/><div id="42582435" class="c"><input type="checkbox" id="c-42582435" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42581246">root</a><span>|</span><a href="#42582098">parent</a><span>|</span><a href="#42582478">next</a><span>|</span><label class="collapse" for="c-42582435">[-]</label><label class="expand" for="c-42582435">[3 more]</label></div><br/><div class="children"><div class="content">SAL as well?  (And anyway this example seems to be shifting by the low 8 bits of RCX (CL), not the full width register.)</div><br/><div id="42582599" class="c"><input type="checkbox" id="c-42582599" checked=""/><div class="controls bullet"><span class="by">tavianator</span><span>|</span><a href="#42581246">root</a><span>|</span><a href="#42582435">parent</a><span>|</span><a href="#42582478">next</a><span>|</span><label class="collapse" for="c-42582599">[-]</label><label class="expand" for="c-42582599">[2 more]</label></div><br/><div class="children"><div class="content">SAL and SHL are synonyms, they have the same encoding.  SHL only accepts CL as the count register, there&#x27;s no other form that takes a variable shift count</div><br/><div id="42582642" class="c"><input type="checkbox" id="c-42582642" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42581246">root</a><span>|</span><a href="#42582599">parent</a><span>|</span><a href="#42582478">next</a><span>|</span><label class="collapse" for="c-42582642">[-]</label><label class="expand" for="c-42582642">[1 more]</label></div><br/><div class="children"><div class="content">Ahh, thanks, I didn&#x27;t make that connection.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42582478" class="c"><input type="checkbox" id="c-42582478" checked=""/><div class="controls bullet"><span class="by">eigenform</span><span>|</span><a href="#42581246">parent</a><span>|</span><a href="#42581454">prev</a><span>|</span><a href="#42580582">next</a><span>|</span><label class="collapse" for="c-42582478">[-]</label><label class="expand" for="c-42582478">[1 more]</label></div><br/><div class="children"><div class="content">Funny thing to double-check: are these encodings correctly specifying a 64-bit operand? Maybe everyone&#x27;s compilers are subtly wrong D:<p>edit: It looks like VEX.W <i>is</i> set in the encoding from the uops.info tests ¯\_(ツ)_&#x2F;¯</div><br/></div></div></div></div><div id="42580582" class="c"><input type="checkbox" id="c-42580582" checked=""/><div class="controls bullet"><span class="by">bhouston</span><span>|</span><a href="#42581246">prev</a><span>|</span><a href="#42580126">next</a><span>|</span><label class="collapse" for="c-42580582">[-]</label><label class="expand" for="c-42580582">[2 more]</label></div><br/><div class="children"><div class="content">Shifts were not always fast.  These old hacker news comments contain the details: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=2962770">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=2962770</a></div><br/><div id="42580666" class="c"><input type="checkbox" id="c-42580666" checked=""/><div class="controls bullet"><span class="by">petermcneeley</span><span>|</span><a href="#42580582">parent</a><span>|</span><a href="#42580126">next</a><span>|</span><label class="collapse" for="c-42580666">[-]</label><label class="expand" for="c-42580666">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. Dynamic shifting was microcoded (not uop!) on the power pc for gen3. However shifting with immediate values was not.<p>This leads to all sorts of strange performance workarounds.
Mike Acton refers to it here:
<a href="https:&#x2F;&#x2F;macton.smugmug.com&#x2F;Other&#x2F;2008-07-15-by-Eye-Fi&#x2F;n-xmKDH&#x2F;i-BbZPR2r&#x2F;A" rel="nofollow">https:&#x2F;&#x2F;macton.smugmug.com&#x2F;Other&#x2F;2008-07-15-by-Eye-Fi&#x2F;n-xmKD...</a></div><br/></div></div></div></div><div id="42580126" class="c"><input type="checkbox" id="c-42580126" checked=""/><div class="controls bullet"><span class="by">aftbit</span><span>|</span><a href="#42580582">prev</a><span>|</span><a href="#42581275">next</a><span>|</span><label class="collapse" for="c-42580126">[-]</label><label class="expand" for="c-42580126">[4 more]</label></div><br/><div class="children"><div class="content">Woah that&#x27;s weird. Left shifting either takes 3 cycles or 1 cycle, depending on how you initialize the cycle count register?<p>This patch from the article makes it take 1 cycle instead of 3:<p><pre><code>    -        MOV RCX, 1
    +        MOV ECX, 1
</code></pre>
&gt;It seems like SHLX performs differently depending on how the shift count register is initialized. If you use a 64-bit instruction with an immediate, performance is slow. This is also true for instructions like INC (which is similar to ADD with a 1 immediate).<p>Practically speaking, is this sort of µop-dependent optimization implemented by compilers? How do they do so?</div><br/><div id="42580194" class="c"><input type="checkbox" id="c-42580194" checked=""/><div class="controls bullet"><span class="by">tavianator</span><span>|</span><a href="#42580126">parent</a><span>|</span><a href="#42580755">next</a><span>|</span><label class="collapse" for="c-42580194">[-]</label><label class="expand" for="c-42580194">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Practically speaking, is this sort of µop-dependent optimization implemented by compilers?<p>I suspect this specific thing is not; I don&#x27;t think many people were aware of this anomaly until this week.  I doubt the compilers are modeling it.<p>But in general, compilers will have a machine model that predicts the cost of different instructions.  The backend will try to generate instruction sequences with low cost, so if you include this anomaly in the model it will probably work around it automatically.<p>This old example might interest you: a false dependency on the destination register for `popcnt` on some uarches led to compiler patches: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;q&#x2F;25078285&#x2F;502399" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;q&#x2F;25078285&#x2F;502399</a></div><br/></div></div><div id="42580755" class="c"><input type="checkbox" id="c-42580755" checked=""/><div class="controls bullet"><span class="by">RossBencina</span><span>|</span><a href="#42580126">parent</a><span>|</span><a href="#42580194">prev</a><span>|</span><a href="#42581275">next</a><span>|</span><label class="collapse" for="c-42580755">[-]</label><label class="expand" for="c-42580755">[2 more]</label></div><br/><div class="children"><div class="content">user mshockwave posted this the other day in a comment, might be of interest&#x2F;tangential relevance:<p>Scheduling Model in LLVM - Part I
<a href="https:&#x2F;&#x2F;myhsu.xyz&#x2F;llvm-sched-model-1" rel="nofollow">https:&#x2F;&#x2F;myhsu.xyz&#x2F;llvm-sched-model-1</a></div><br/><div id="42581533" class="c"><input type="checkbox" id="c-42581533" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42580126">root</a><span>|</span><a href="#42580755">parent</a><span>|</span><a href="#42581275">next</a><span>|</span><label class="collapse" for="c-42581533">[-]</label><label class="expand" for="c-42581533">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42555110">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42555110</a></div><br/></div></div></div></div></div></div><div id="42581275" class="c"><input type="checkbox" id="c-42581275" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#42580126">prev</a><span>|</span><a href="#42581316">next</a><span>|</span><label class="collapse" for="c-42581275">[-]</label><label class="expand" for="c-42581275">[2 more]</label></div><br/><div class="children"><div class="content">To rule out alignment you should adding padding to one so the two variations have the same alignment in their long run of SHLX (I don&#x27;t actually think it&#x27;s alignment related though).</div><br/><div id="42582623" class="c"><input type="checkbox" id="c-42582623" checked=""/><div class="controls bullet"><span class="by">tavianator</span><span>|</span><a href="#42581275">parent</a><span>|</span><a href="#42581316">next</a><span>|</span><label class="collapse" for="c-42582623">[-]</label><label class="expand" for="c-42582623">[1 more]</label></div><br/><div class="children"><div class="content">I did try aligning the loop, it didn&#x27;t matter</div><br/></div></div></div></div><div id="42581316" class="c"><input type="checkbox" id="c-42581316" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#42581275">prev</a><span>|</span><label class="collapse" for="c-42581316">[-]</label><label class="expand" for="c-42581316">[2 more]</label></div><br/><div class="children"><div class="content">Does this also occur with other 3-argument instructions like ANDN?</div><br/><div id="42581473" class="c"><input type="checkbox" id="c-42581473" checked=""/><div class="controls bullet"><span class="by">tavianator</span><span>|</span><a href="#42581316">parent</a><span>|</span><label class="collapse" for="c-42581473">[-]</label><label class="expand" for="c-42581473">[1 more]</label></div><br/><div class="children"><div class="content">ANDN is fast.  The issue looks specific to shift counts.  SHL is also slow.</div><br/></div></div></div></div></div></div></div></div></div></body></html>