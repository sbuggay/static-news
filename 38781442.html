<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1703926864451" as="style"/><link rel="stylesheet" href="styles.css?v=1703926864451"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://patrick.engineering/posts/postgres-internals/">PostgreSQL Internals: Things to Know About Update Statements</a> <span class="domain">(<a href="https://patrick.engineering">patrick.engineering</a>)</span></div><div class="subtext"><span>ppati000</span> | <span>22 comments</span></div><br/><div><div id="38813718" class="c"><input type="checkbox" id="c-38813718" checked=""/><div class="controls bullet"><span class="by">silvestrov</span><span>|</span><a href="#38813015">next</a><span>|</span><label class="collapse" for="c-38813718">[-]</label><label class="expand" for="c-38813718">[3 more]</label></div><br/><div class="children"><div class="content">One thing I&#x27;d really like PostgreSQL to add is LIMIT on update statement as this makes batching easier. E.g.<p><pre><code>    UPDATE user_profile
    SET followers_count = 0
    WHERE followers_count IS NULL
    LIMIT 10000
</code></pre>
I don&#x27;t care which rows gets updated, only that no more than 10000 rows get updated.  After each UPDATE I will COMMIT and then repeat as long as the UPDATE returns a positive number of rows updated.<p>This makes it much easier to make small-ish batch updates and avoid locking all rows in the table.</div><br/><div id="38813736" class="c"><input type="checkbox" id="c-38813736" checked=""/><div class="controls bullet"><span class="by">idorosen</span><span>|</span><a href="#38813718">parent</a><span>|</span><a href="#38813015">next</a><span>|</span><label class="collapse" for="c-38813736">[-]</label><label class="expand" for="c-38813736">[2 more]</label></div><br/><div class="children"><div class="content">You can already achieve this with CTEs.</div><br/><div id="38813758" class="c"><input type="checkbox" id="c-38813758" checked=""/><div class="controls bullet"><span class="by">orthoxerox</span><span>|</span><a href="#38813718">root</a><span>|</span><a href="#38813736">parent</a><span>|</span><a href="#38813015">next</a><span>|</span><label class="collapse" for="c-38813758">[-]</label><label class="expand" for="c-38813758">[1 more]</label></div><br/><div class="children"><div class="content">Can you really run updates on CTEs that are simple projections and selections? TIL.</div><br/></div></div></div></div></div></div><div id="38813015" class="c"><input type="checkbox" id="c-38813015" checked=""/><div class="controls bullet"><span class="by">rowls66</span><span>|</span><a href="#38813718">prev</a><span>|</span><a href="#38813091">next</a><span>|</span><label class="collapse" for="c-38813015">[-]</label><label class="expand" for="c-38813015">[2 more]</label></div><br/><div class="children"><div class="content">In the Lost Updates section, a more straight forward solution is to use the FOR UPDATE clause in the first select statement. This locks the record and prevents concurrent updates.</div><br/><div id="38813609" class="c"><input type="checkbox" id="c-38813609" checked=""/><div class="controls bullet"><span class="by">ComodoHacker</span><span>|</span><a href="#38813015">parent</a><span>|</span><a href="#38813091">next</a><span>|</span><label class="collapse" for="c-38813609">[-]</label><label class="expand" for="c-38813609">[1 more]</label></div><br/><div class="children"><div class="content">When you&#x27;re incrementing by using UPDATE ... SET value = value + 1, the database holds the locks for the minimum time needed. Everything else is less efficient.<p>In more complex scenarios, FOR UPDATE is the solution.</div><br/></div></div></div></div><div id="38813091" class="c"><input type="checkbox" id="c-38813091" checked=""/><div class="controls bullet"><span class="by">Rapzid</span><span>|</span><a href="#38813015">prev</a><span>|</span><a href="#38812998">next</a><span>|</span><label class="collapse" for="c-38813091">[-]</label><label class="expand" for="c-38813091">[3 more]</label></div><br/><div class="children"><div class="content">The math on #1 doesn&#x27;t check out. If you update 2 bytes in the record only 28 are still written. But are only 28 written in either case? Does Postgres not write out entire pages?<p>It gets much more complicated when you consider full page writes, checkpoints, HOT, and multiple rows being updated at once.<p>For #3 it really depends on a lot of factors what the best approach is and if it&#x27;s even worth your time.. But a typical approach that isn&#x27;t mentioned is to just make sure you acquire locks in a deterministic order between transactions you don&#x27;t want to deadlock each other. This will reduce concurrency(which is the entire point of the deadlock detection feature), but you can push the queue into the DB(behind the lock) which will minimize latency if you are done round-tripping.</div><br/><div id="38813130" class="c"><input type="checkbox" id="c-38813130" checked=""/><div class="controls bullet"><span class="by">wisty</span><span>|</span><a href="#38813091">parent</a><span>|</span><a href="#38812998">next</a><span>|</span><label class="collapse" for="c-38813130">[-]</label><label class="expand" for="c-38813130">[2 more]</label></div><br/><div class="children"><div class="content">8 bytes of new data but 8x28 = 224 bytes = 200 data + 8 date + 16 for id.<p>The 28 is a factor (×).</div><br/><div id="38813156" class="c"><input type="checkbox" id="c-38813156" checked=""/><div class="controls bullet"><span class="by">Rapzid</span><span>|</span><a href="#38813091">root</a><span>|</span><a href="#38813130">parent</a><span>|</span><a href="#38812998">next</a><span>|</span><label class="collapse" for="c-38813156">[-]</label><label class="expand" for="c-38813156">[1 more]</label></div><br/><div class="children"><div class="content">I should have used more precise language; I mean the bytes written to disk don&#x27;t work out with such a simple formula. Missed the footnote which discusses this, but there are even more things to consider such as how many rows are being updated at once and etc.</div><br/></div></div></div></div></div></div><div id="38812998" class="c"><input type="checkbox" id="c-38812998" checked=""/><div class="controls bullet"><span class="by">GauntletWizard</span><span>|</span><a href="#38813091">prev</a><span>|</span><label class="collapse" for="c-38812998">[-]</label><label class="expand" for="c-38812998">[13 more]</label></div><br/><div class="children"><div class="content">#2 is something that nearly no application I know handles, and it saddens me, but not to the extent that it seems to anger many of my fellows. It&#x27;s perfectly okay to do so for YouTube, it&#x27;s not worth bothering for many applications of less concurrency than that. Still, it fairly offends me that most applications exist in the middle, where they don&#x27;t have read isolation, or use logical additions, or have a separate process that cleans up the followers at a point-in-time, so that it&#x27;s bounded to a day&#x27;s worth of updates.</div><br/><div id="38813765" class="c"><input type="checkbox" id="c-38813765" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#38812998">parent</a><span>|</span><a href="#38813096">next</a><span>|</span><label class="collapse" for="c-38813765">[-]</label><label class="expand" for="c-38813765">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m convinced that this is due to developers over-relying on ORMs instead of delving into raw SQL.<p>I&#x27;ll give another, different but somewhat related example: consider a worker that works on a batch of rows, and wants to update each of the rows in the batch, each row with different data for that row. In raw SQL, this is simple enough with the UPDATE FROM VALUES pattern (see e.g. <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;18799497" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;18799497</a> ).<p>There&#x27;s no support for this in Prisma, for example: <a href="https:&#x2F;&#x2F;www.prisma.io&#x2F;docs&#x2F;orm&#x2F;prisma-client&#x2F;queries&#x2F;crud#update-multiple-records" rel="nofollow">https:&#x2F;&#x2F;www.prisma.io&#x2F;docs&#x2F;orm&#x2F;prisma-client&#x2F;queries&#x2F;crud#up...</a> . Most developers would wrap prisma.foo.update in an application-level loop, or possibly wrap all the individual updates in a single prisma.$transaction.</div><br/></div></div><div id="38813096" class="c"><input type="checkbox" id="c-38813096" checked=""/><div class="controls bullet"><span class="by">koolba</span><span>|</span><a href="#38812998">parent</a><span>|</span><a href="#38813765">prev</a><span>|</span><a href="#38813129">next</a><span>|</span><label class="collapse" for="c-38813096">[-]</label><label class="expand" for="c-38813096">[8 more]</label></div><br/><div class="children"><div class="content">This is transaction 101. You simply lock the row via a SELECT … FOR UPDATE when you read the value.<p>Any application that actually cares about consistency of its data must be doing this.<p>Or just do it one step so the update increments the value in place. That way you have an implicit lock.</div><br/><div id="38813631" class="c"><input type="checkbox" id="c-38813631" checked=""/><div class="controls bullet"><span class="by">ppati000</span><span>|</span><a href="#38812998">root</a><span>|</span><a href="#38813096">parent</a><span>|</span><a href="#38813734">next</a><span>|</span><label class="collapse" for="c-38813631">[-]</label><label class="expand" for="c-38813631">[1 more]</label></div><br/><div class="children"><div class="content">Author here. Thank you (and others) for mentioning SELECT FOR UPDATE. Definitely missing at least a footnote in the article.<p>Note that &quot;one step&quot; updates (e.g., SET followers_count = followers_count + 1) are still not in place. They are regular transactional updates that rewrite the entire row. Still, they can achieve higher throughput because there is no application&#x2F;database roundtrip between locking and committing.</div><br/></div></div><div id="38813734" class="c"><input type="checkbox" id="c-38813734" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#38812998">root</a><span>|</span><a href="#38813096">parent</a><span>|</span><a href="#38813631">prev</a><span>|</span><a href="#38813162">next</a><span>|</span><label class="collapse" for="c-38813734">[-]</label><label class="expand" for="c-38813734">[1 more]</label></div><br/><div class="children"><div class="content">Even better, FOR NO KEY UPDATE is probably a good option here, since no key values are updated.</div><br/></div></div><div id="38813162" class="c"><input type="checkbox" id="c-38813162" checked=""/><div class="controls bullet"><span class="by">arthurcolle</span><span>|</span><a href="#38812998">root</a><span>|</span><a href="#38813096">parent</a><span>|</span><a href="#38813734">prev</a><span>|</span><a href="#38813489">next</a><span>|</span><label class="collapse" for="c-38813162">[-]</label><label class="expand" for="c-38813162">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t used this, but I see its in Oracle and MySQL - does this exist in Postgresql or is this just the same as wrapping in a transaction where you&#x27;re selecting on the row by ID or something? Just curious</div><br/><div id="38813241" class="c"><input type="checkbox" id="c-38813241" checked=""/><div class="controls bullet"><span class="by">Rapzid</span><span>|</span><a href="#38812998">root</a><span>|</span><a href="#38813162">parent</a><span>|</span><a href="#38813489">next</a><span>|</span><label class="collapse" for="c-38813241">[-]</label><label class="expand" for="c-38813241">[1 more]</label></div><br/><div class="children"><div class="content">Pretty much every RDBMS has this: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;explicit-locking.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;explicit-locking.htm...</a><p>There are multiple flavors in PostgreSQL with different locking semantics. And the exact locking semantics may differ between database(for instance postgres does not have gap locks, while MySQL does) so you&#x27;d have to read the docs if that detail matters to you.</div><br/></div></div></div></div><div id="38813489" class="c"><input type="checkbox" id="c-38813489" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#38812998">root</a><span>|</span><a href="#38813096">parent</a><span>|</span><a href="#38813162">prev</a><span>|</span><a href="#38813251">next</a><span>|</span><label class="collapse" for="c-38813489">[-]</label><label class="expand" for="c-38813489">[1 more]</label></div><br/><div class="children"><div class="content">SELECT FOR UPDATE SKIP LOCKED is amazing</div><br/></div></div><div id="38813251" class="c"><input type="checkbox" id="c-38813251" checked=""/><div class="controls bullet"><span class="by">GauntletWizard</span><span>|</span><a href="#38812998">root</a><span>|</span><a href="#38813096">parent</a><span>|</span><a href="#38813489">prev</a><span>|</span><a href="#38813129">next</a><span>|</span><label class="collapse" for="c-38813251">[-]</label><label class="expand" for="c-38813251">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t disagree, but it&#x27;s so uncommonly used, and I don&#x27;t know any orm that will do it for you- it&#x27;d be easy enough to precompile, but that&#x27;d require compiler integration. (Or a hit to every select statement - which probably wouldn&#x27;t matter for most apps!)</div><br/><div id="38813506" class="c"><input type="checkbox" id="c-38813506" checked=""/><div class="controls bullet"><span class="by">tybit</span><span>|</span><a href="#38812998">root</a><span>|</span><a href="#38813251">parent</a><span>|</span><a href="#38813129">next</a><span>|</span><label class="collapse" for="c-38813506">[-]</label><label class="expand" for="c-38813506">[1 more]</label></div><br/><div class="children"><div class="content">JOOQ handled this nicely.<p><a href="https:&#x2F;&#x2F;www.jooq.org&#x2F;doc&#x2F;latest&#x2F;manual&#x2F;sql-execution&#x2F;crud-with-updatablerecords&#x2F;optimistic-locking&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.jooq.org&#x2F;doc&#x2F;latest&#x2F;manual&#x2F;sql-execution&#x2F;crud-wi...</a></div><br/></div></div></div></div></div></div><div id="38813129" class="c"><input type="checkbox" id="c-38813129" checked=""/><div class="controls bullet"><span class="by">chrisandchris</span><span>|</span><a href="#38812998">parent</a><span>|</span><a href="#38813096">prev</a><span>|</span><label class="collapse" for="c-38813129">[-]</label><label class="expand" for="c-38813129">[3 more]</label></div><br/><div class="children"><div class="content">While I agree, it&#x27;s a pretty bad example for demonstrating this issue, because an error on &quot;follower_count&quot; will probably not cause any harm (youtube example). Also, the value can be recalculated at all times (maybe not feasable).<p>Any other example that comes to my mind will not depend on the &quot;state of the apps memory&quot; for a sensitive value, because that would be bad design too. Then the sensitive value must be the aggregate of other values within the database and with each commit, the equation must be balanced.</div><br/><div id="38813363" class="c"><input type="checkbox" id="c-38813363" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#38812998">root</a><span>|</span><a href="#38813129">parent</a><span>|</span><a href="#38813177">next</a><span>|</span><label class="collapse" for="c-38813363">[-]</label><label class="expand" for="c-38813363">[1 more]</label></div><br/><div class="children"><div class="content">The example with follower_count shows how to use the +1 technique to do without locking. That&#x27;s OK IMHO. It&#x27;s not possible to use that technique when updating other type of data. Example<p><pre><code>  select * from issues where id = 123;
  -- do something in app
  update issues set status = &#x27;done&#x27; where id = 123;
</code></pre>
There you can lose a status update if two people happen to work on the same issue at the same time with two different ideas of how to update it.<p>Or the classic bank account balance update. Both must be solved with a SELECT FOR UPDATE. That should be in the demo page of every ORM, to be sure that people that don&#x27;t know SQL don&#x27;t make that kind of mistakes.</div><br/></div></div><div id="38813177" class="c"><input type="checkbox" id="c-38813177" checked=""/><div class="controls bullet"><span class="by">GauntletWizard</span><span>|</span><a href="#38812998">root</a><span>|</span><a href="#38813129">parent</a><span>|</span><a href="#38813363">prev</a><span>|</span><label class="collapse" for="c-38813177">[-]</label><label class="expand" for="c-38813177">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what makes it such a perfect example. It&#x27;s inconsequential, but also simple. A SQL statement `update follower_count = follower_count +1` is incredibly cheap in SQL, even as part of a transaction. Accepting that the follower counts are laggy is incredibly acceptable. Repeatable read is expensive, but cheap enough for many, many applications.<p>The problem is that most applications that I&#x27;ve worked on do none of the above - they accept the buggy behavior in the concurrency case. As part of the &quot;post reconciliation&quot; solution, that&#x27;s fine, but it&#x27;s a bug that will never get fixed.<p>Perhaps worst is that there&#x27;s an entire class of people - probably autistic, and often not people I want to work with for one obvious reason or another[1] - who simply have to be kept in the dark about long-standing minor bugs. These are known inconsistencies in the data that don&#x27;t matter but that they&#x27;ll pitch a fit to fix because they can&#x27;t see.the difference in constraints like &quot;the follower count will be an integer&quot; and &quot;The (recorded, but fundamentally cached) follower count will equal `SELECT COUNT(*) FROM followers WHERE account = ${user}`<p>[1] Really, just one reason - they reject rhetorical logic, focusing on formal logic for anything that catches their attention, to the point they are happier with atrocities than morality.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>