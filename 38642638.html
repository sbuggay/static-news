<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702630857248" as="style"/><link rel="stylesheet" href="styles.css?v=1702630857248"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://glasskube.eu/en/r/knowledge/5-helm-shortcomings/">Pitfalls of Helm – Insights from 3 years with the leading K8s package manager</a> <span class="domain">(<a href="https://glasskube.eu">glasskube.eu</a>)</span></div><div class="subtext"><span>louis_w_gk</span> | <span>127 comments</span></div><br/><div><div id="38648872" class="c"><input type="checkbox" id="c-38648872" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#38642779">next</a><span>|</span><label class="collapse" for="c-38648872">[-]</label><label class="expand" for="c-38648872">[36 more]</label></div><br/><div class="children"><div class="content">Unhygienic string templating <i>of a whitespace-sensitive language</i> is a truly new hell for those who have not experienced it before. Quite an astonishing decision.</div><br/><div id="38652256" class="c"><input type="checkbox" id="c-38652256" checked=""/><div class="controls bullet"><span class="by">CipherThrowaway</span><span>|</span><a href="#38648872">parent</a><span>|</span><a href="#38652078">next</a><span>|</span><label class="collapse" for="c-38652256">[-]</label><label class="expand" for="c-38652256">[1 more]</label></div><br/><div class="children"><div class="content">I remember being blown away by this. Unhygienic templating and lack of template and serialization boundaries has been such a consistent disaster in our field for so many decades that it is hard to believe we are <i>still</i> dealing with this kind of design error in relatively new technology.<p>My feeling is we will probably all look back at the over-use of text based DSLs and configuration languages as a giant mistake. Not just with respect to K8s, but IaC, CI&#x2F;CD config and the rest of the DevOps YAML&#x2F;config language mess. In retrospect, it has been a case of simplistic instead of simple. &quot;Declarative&quot; config languages are hello world optimized, and what looked great at the beginning of the S-curve is starting to look pretty damn bad.</div><br/></div></div><div id="38652078" class="c"><input type="checkbox" id="c-38652078" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#38648872">parent</a><span>|</span><a href="#38652256">prev</a><span>|</span><a href="#38649989">next</a><span>|</span><label class="collapse" for="c-38652078">[-]</label><label class="expand" for="c-38652078">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not really astonishing. People don&#x27;t usually have knowledge beyond a quick google search. If you google XML, you&#x27;ll see a lot of negative sentiment about XML <i>specifically related to mid-00s Java frameworks</i> and some people chunk this fact as &quot;XML old and bad&quot;. If you google YAML, you&#x27;ll see that lots of people like using it for relatively simple things (Rails config files...) and some people will chunk that fact as &quot;YAML good&quot;.</div><br/></div></div><div id="38649989" class="c"><input type="checkbox" id="c-38649989" checked=""/><div class="controls bullet"><span class="by">necubi</span><span>|</span><a href="#38648872">parent</a><span>|</span><a href="#38652078">prev</a><span>|</span><a href="#38651508">next</a><span>|</span><label class="collapse" for="c-38649989">[-]</label><label class="expand" for="c-38649989">[6 more]</label></div><br/><div class="children"><div class="content">Indeed, as someone who maintains a helm package it&#x27;s mind-boggling. When I&#x27;ve been able to build k8s tooling from scratch, I&#x27;ve been reasonably happy with jsonnet [0], which is a constrained programming language designed for configuration. It has the property that it will always produce valid JSON.<p>[0] <a href="https:&#x2F;&#x2F;jsonnet.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;jsonnet.org&#x2F;</a></div><br/><div id="38652087" class="c"><input type="checkbox" id="c-38652087" checked=""/><div class="controls bullet"><span class="by">personomas</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38649989">parent</a><span>|</span><a href="#38650169">next</a><span>|</span><label class="collapse" for="c-38652087">[-]</label><label class="expand" for="c-38652087">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, there used to be ksonnet [0], but it didn&#x27;t take off. I think the k8s world wasn&#x27;t ready for the complexity, and wanted something simpler. However, it&#x27;s definitely more powerful, could be a future solution.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;ksonnet&#x2F;ksonnet">https:&#x2F;&#x2F;github.com&#x2F;ksonnet&#x2F;ksonnet</a></div><br/></div></div><div id="38650169" class="c"><input type="checkbox" id="c-38650169" checked=""/><div class="controls bullet"><span class="by">pram</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38649989">parent</a><span>|</span><a href="#38652087">prev</a><span>|</span><a href="#38651502">next</a><span>|</span><label class="collapse" for="c-38650169">[-]</label><label class="expand" for="c-38650169">[1 more]</label></div><br/><div class="children"><div class="content">Seconded on jsonnet. I’ve started using it to generate json (that usually goes to an API) in gitlab ci pipelines. I use it to merge “gold standard” boilerplate configs with user changes.</div><br/></div></div><div id="38651502" class="c"><input type="checkbox" id="c-38651502" checked=""/><div class="controls bullet"><span class="by">mati365</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38649989">parent</a><span>|</span><a href="#38650169">prev</a><span>|</span><a href="#38651508">next</a><span>|</span><label class="collapse" for="c-38651502">[-]</label><label class="expand" for="c-38651502">[3 more]</label></div><br/><div class="children"><div class="content">Why not just plain JS or TypeScript?</div><br/><div id="38651703" class="c"><input type="checkbox" id="c-38651703" checked=""/><div class="controls bullet"><span class="by">8organicbits</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38651502">parent</a><span>|</span><a href="#38651508">next</a><span>|</span><label class="collapse" for="c-38651703">[-]</label><label class="expand" for="c-38651703">[2 more]</label></div><br/><div class="children"><div class="content">JS and TS aren&#x27;t configuration languages. If it wasn&#x27;t for JS&#x27;s early dominance and too-big-to-fail status on the web, we probably wouldn&#x27;t use it for programming much. Platform and operations engineers often don&#x27;t know JS well, favoring bash, python, and others for programming. Some exceptions exist, like full stack node shops.<p>Configuration languages like yaml, HCL, etc. are more reasonable alternatives.</div><br/><div id="38652234" class="c"><input type="checkbox" id="c-38652234" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38651703">parent</a><span>|</span><a href="#38651508">next</a><span>|</span><label class="collapse" for="c-38652234">[-]</label><label class="expand" for="c-38652234">[1 more]</label></div><br/><div class="children"><div class="content">yaml is not a configuration language!<p>yaml is a tree serialization format with some human-targeted ergonomic features like comments and multiline strings built in.<p>it&#x27;ll work for simple configuration files just as well as format-less .ini files will. for complex configurations, even xml is better, and that&#x27;s saying <i>a lot</i>.<p>in practice for object graphs of any sort of complexity, like cloudformation or k8s configs, you want a programming language which can reduce the kolmogorov complexity of your configuration, because that dominates ops in the limit. or, IOW, configuration is code is configuration is code is ...</div><br/></div></div></div></div></div></div></div></div><div id="38651508" class="c"><input type="checkbox" id="c-38651508" checked=""/><div class="controls bullet"><span class="by">smsm42</span><span>|</span><a href="#38648872">parent</a><span>|</span><a href="#38649989">prev</a><span>|</span><a href="#38649127">next</a><span>|</span><label class="collapse" for="c-38651508">[-]</label><label class="expand" for="c-38651508">[1 more]</label></div><br/><div class="children"><div class="content">That has been one of the most annoying aspects of dealing with helm templates. It&#x27;s like that USB plug you never can insert the right side up, only it has like a half-dozen sides and to cycle through them all to figure out the right one.</div><br/></div></div><div id="38649127" class="c"><input type="checkbox" id="c-38649127" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#38648872">parent</a><span>|</span><a href="#38651508">prev</a><span>|</span><a href="#38650718">next</a><span>|</span><label class="collapse" for="c-38649127">[-]</label><label class="expand" for="c-38649127">[3 more]</label></div><br/><div class="children"><div class="content">Does not beat the “BIND zone files generated by m4 macros from a shell script”, I had the honor having to modify. Comes close second, though.</div><br/><div id="38649426" class="c"><input type="checkbox" id="c-38649426" checked=""/><div class="controls bullet"><span class="by">cheekibreeki2</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38649127">parent</a><span>|</span><a href="#38650718">next</a><span>|</span><label class="collapse" for="c-38649426">[-]</label><label class="expand" for="c-38649426">[2 more]</label></div><br/><div class="children"><div class="content">No raw sendmail.cf? :)</div><br/><div id="38649742" class="c"><input type="checkbox" id="c-38649742" checked=""/><div class="controls bullet"><span class="by">doubled112</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38649426">parent</a><span>|</span><a href="#38650718">next</a><span>|</span><label class="collapse" for="c-38649742">[-]</label><label class="expand" for="c-38649742">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, that little twitch under my eye just started up.<p>I worked at an org where an admin went a little rogue and updated the config without using the macro file.  Another admin didn&#x27;t realize.  Well, didn&#x27;t realize until it was too late.</div><br/></div></div></div></div></div></div><div id="38650718" class="c"><input type="checkbox" id="c-38650718" checked=""/><div class="controls bullet"><span class="by">jscheel</span><span>|</span><a href="#38648872">parent</a><span>|</span><a href="#38649127">prev</a><span>|</span><a href="#38649220">next</a><span>|</span><label class="collapse" for="c-38650718">[-]</label><label class="expand" for="c-38650718">[1 more]</label></div><br/><div class="children"><div class="content">1000 times yes. It is <i>horrible</i> to deal with. And the error reporting when it fails is often obtuse in my experience.</div><br/></div></div><div id="38649220" class="c"><input type="checkbox" id="c-38649220" checked=""/><div class="controls bullet"><span class="by">ljm</span><span>|</span><a href="#38648872">parent</a><span>|</span><a href="#38650718">prev</a><span>|</span><a href="#38650032">next</a><span>|</span><label class="collapse" for="c-38649220">[-]</label><label class="expand" for="c-38649220">[21 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think I&#x27;ll ever understand why YAML was chosen as the language of choice for all things devops, and why so many startups have sought to augment yaml with syntactical hacks<p>I mean, as soon as you template it and need to do `{{ something | indent 4 }}` or some shit to make the template work you know you&#x27;re on a bad track.</div><br/><div id="38652114" class="c"><input type="checkbox" id="c-38652114" checked=""/><div class="controls bullet"><span class="by">nucleardog</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38649220">parent</a><span>|</span><a href="#38650244">next</a><span>|</span><label class="collapse" for="c-38652114">[-]</label><label class="expand" for="c-38652114">[1 more]</label></div><br/><div class="children"><div class="content">The other popular option would be JSON.<p>No comments and having to escape.... well, practically everything you&#x27;d commonly be entering makes JSON suck at this sort of task.</div><br/></div></div><div id="38650244" class="c"><input type="checkbox" id="c-38650244" checked=""/><div class="controls bullet"><span class="by">lukeschlather</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38649220">parent</a><span>|</span><a href="#38652114">prev</a><span>|</span><a href="#38649991">next</a><span>|</span><label class="collapse" for="c-38650244">[-]</label><label class="expand" for="c-38650244">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really think YAML is the problem, it&#x27;s the string-based templating. I&#x27;d like to see Emrichen or something like it become more common. And Emrichen is format-agnostic, you can write your stuff in json or YAML and it looks and works pretty similarly. (Although I stick to yaml.)<p><a href="https:&#x2F;&#x2F;github.com&#x2F;con2&#x2F;emrichen">https:&#x2F;&#x2F;github.com&#x2F;con2&#x2F;emrichen</a><p>If JSON had comments I might lean toward json.</div><br/><div id="38651062" class="c"><input type="checkbox" id="c-38651062" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38650244">parent</a><span>|</span><a href="#38649991">next</a><span>|</span><label class="collapse" for="c-38651062">[-]</label><label class="expand" for="c-38651062">[2 more]</label></div><br/><div class="children"><div class="content">JSON5, JSONC, and others have comments.<p>Also, there&#x27;s the old dirt hack<p><pre><code>  {&quot;item&quot;: &quot;this is a comment&quot;,
  &quot;item&quot;: &quot;&#x2F;&#x2F;so is this but more obvious&quot;,
  &quot;item&quot;: &quot;because in 99.99% of implementations, last value wins:&quot;
  &quot;item&quot;: 42}</code></pre></div><br/><div id="38651981" class="c"><input type="checkbox" id="c-38651981" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38651062">parent</a><span>|</span><a href="#38649991">next</a><span>|</span><label class="collapse" for="c-38651981">[-]</label><label class="expand" for="c-38651981">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s kinda important to keep comments on automated transformations.</div><br/></div></div></div></div></div></div><div id="38649991" class="c"><input type="checkbox" id="c-38649991" checked=""/><div class="controls bullet"><span class="by">tbrownaw</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38649220">parent</a><span>|</span><a href="#38650244">prev</a><span>|</span><a href="#38651396">next</a><span>|</span><label class="collapse" for="c-38649991">[-]</label><label class="expand" for="c-38649991">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s &quot;declarative&quot; which is supposed to be good, and you can represent complex data structures without any annoying closing braces (like json) or tags (xml).<p>Plus, well, there&#x27;s a disturbingly high number of people who think that semantic whitespace is a positive.</div><br/><div id="38650017" class="c"><input type="checkbox" id="c-38650017" checked=""/><div class="controls bullet"><span class="by">yeetcode</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38649991">parent</a><span>|</span><a href="#38651396">next</a><span>|</span><label class="collapse" for="c-38650017">[-]</label><label class="expand" for="c-38650017">[6 more]</label></div><br/><div class="children"><div class="content">When did the universe decide braces were so bad? Makes formatting so much easier.</div><br/><div id="38651156" class="c"><input type="checkbox" id="c-38651156" checked=""/><div class="controls bullet"><span class="by">tbrownaw</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38650017">parent</a><span>|</span><a href="#38650255">next</a><span>|</span><label class="collapse" for="c-38651156">[-]</label><label class="expand" for="c-38651156">[3 more]</label></div><br/><div class="children"><div class="content">Encoding the same information in both indentation and braces is redundant, and so is a violation of DRY, and so is bad.<p>(Of course the reality is that braces are how you <i>write</i> scoping information and indentation is how you <i>read</i> it, and CQRS is actually a good thing.)</div><br/><div id="38651487" class="c"><input type="checkbox" id="c-38651487" checked=""/><div class="controls bullet"><span class="by">lucasyvas</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38651156">parent</a><span>|</span><a href="#38650255">next</a><span>|</span><label class="collapse" for="c-38651487">[-]</label><label class="expand" for="c-38651487">[2 more]</label></div><br/><div class="children"><div class="content">This is ridiculous. Indentation is a visual concern for humans and braces are a semantic concern for a machine. Code only needs the latter to actually execute.<p>You can prefer them be coupled for taste reasons but they are fundamentally different. Code minification is a practical example where you can save many characters by omitting whitespace.<p>This is like tabs vs spaces. The white spaces crowd prefer the trade offs, and the tab crowd don&#x27;t. But the white space crowd can&#x27;t argue the perks of tabs - they exist.<p>disclaimer: Am braces&#x2F;whitespace camp.</div><br/><div id="38651938" class="c"><input type="checkbox" id="c-38651938" checked=""/><div class="controls bullet"><span class="by">happymellon</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38651487">parent</a><span>|</span><a href="#38650255">next</a><span>|</span><label class="collapse" for="c-38651938">[-]</label><label class="expand" for="c-38651938">[1 more]</label></div><br/><div class="children"><div class="content">The tabs&#x2F;spaces war was fought because of IDE choices that restricted your ability for sane tab rendering defaults, and simple overriding of tab size.<p>Now that terrible text editors won, I have to watch a 2 Vs 4 space war.<p>If only we could have a character that could represent indentation and people could set the rendering so they can visualise it in their own preferred way.<p>And folks who want to remove braces should be pointed to the Apple certificate snafu.</div><br/></div></div></div></div></div></div><div id="38650255" class="c"><input type="checkbox" id="c-38650255" checked=""/><div class="controls bullet"><span class="by">wizerdrobe</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38650017">parent</a><span>|</span><a href="#38651156">prev</a><span>|</span><a href="#38651396">next</a><span>|</span><label class="collapse" for="c-38650255">[-]</label><label class="expand" for="c-38650255">[2 more]</label></div><br/><div class="children"><div class="content">I’m always amazed at coworkers with a 100 WPM typing speed and IntelliSense griping about how hard it is to type.</div><br/><div id="38651021" class="c"><input type="checkbox" id="c-38651021" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38650255">parent</a><span>|</span><a href="#38651396">next</a><span>|</span><label class="collapse" for="c-38651021">[-]</label><label class="expand" for="c-38651021">[1 more]</label></div><br/><div class="children"><div class="content">Inbound links from HN blocked I think, but Tom Macwright&#x27;s proclamation that <i>typing is not the problem</i> has long stuck with me. <a href="https:&#x2F;&#x2F;macwright.com&#x2F;2015&#x2F;01&#x2F;19&#x2F;typing-is-not-the-problem" rel="nofollow noreferrer">https:&#x2F;&#x2F;macwright.com&#x2F;2015&#x2F;01&#x2F;19&#x2F;typing-is-not-the-problem</a><p>These optimizations for some perceived ergonomic win almost always make terrible tradeoffs versus using a good well established data format. And especially systems which favor human consumption but create extreme difficulties for machine handling, those are the worst!<p>Yaml being such a non-Context Free Grammar is a huge pain. There&#x27;s so much state in the parser. It only gets worse from there. Yaml has all kinds of wild crazy capabilities. References, a variety of inline content blocks, and weird ways to invoke stuff?? GitHub yesterday did a code review of Frigate, an enormously popular surveillance video analysis tool that&#x27;s heavily downloaded, and found, oh yes, a huge glaring yaml bug allowing remote execution, because executing arbitrary code is just built right in to yaml amid 3000 other crazy hacks &amp; who would have known to go look for &amp; disable that capability?! <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38630295">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38630295</a> <a href="https:&#x2F;&#x2F;github.blog&#x2F;2023-12-13-securing-our-home-labs-frigate-code-review&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;github.blog&#x2F;2023-12-13-securing-our-home-labs-frigat...</a><p><i>Typing is not the problem</i> (even though I see so many people just terrible beyond words at navigating project structures or the command line... Improve! Some day!).</div><br/></div></div></div></div></div></div></div></div><div id="38651396" class="c"><input type="checkbox" id="c-38651396" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38649220">parent</a><span>|</span><a href="#38649991">prev</a><span>|</span><a href="#38651523">next</a><span>|</span><label class="collapse" for="c-38651396">[-]</label><label class="expand" for="c-38651396">[1 more]</label></div><br/><div class="children"><div class="content">Yaml has a lot of problems, this is not one of them.<p>This more shows that one shouldn’t be using string templating to create data structures in the first place.</div><br/></div></div><div id="38651523" class="c"><input type="checkbox" id="c-38651523" checked=""/><div class="controls bullet"><span class="by">smsm42</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38649220">parent</a><span>|</span><a href="#38651396">prev</a><span>|</span><a href="#38649518">next</a><span>|</span><label class="collapse" for="c-38651523">[-]</label><label class="expand" for="c-38651523">[1 more]</label></div><br/><div class="children"><div class="content">YAML itself is not too bad, especially with a good IDE. But YAML and its ws-sensitivity combined with Go templating is horrible. Every component by itself looks kinda reasonable, but when they come together it makes an unholy mess.</div><br/></div></div><div id="38649518" class="c"><input type="checkbox" id="c-38649518" checked=""/><div class="controls bullet"><span class="by">taspeotis</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38649220">parent</a><span>|</span><a href="#38651523">prev</a><span>|</span><a href="#38649831">next</a><span>|</span><label class="collapse" for="c-38649518">[-]</label><label class="expand" for="c-38649518">[1 more]</label></div><br/><div class="children"><div class="content">Yelling At My Laptop</div><br/></div></div><div id="38649831" class="c"><input type="checkbox" id="c-38649831" checked=""/><div class="controls bullet"><span class="by">bbkane</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38649220">parent</a><span>|</span><a href="#38649518">prev</a><span>|</span><a href="#38650032">next</a><span>|</span><label class="collapse" for="c-38649831">[-]</label><label class="expand" for="c-38649831">[6 more]</label></div><br/><div class="children"><div class="content">What would you recommend instead? Personally, I think Typescript makes a great config language</div><br/><div id="38649977" class="c"><input type="checkbox" id="c-38649977" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38649831">parent</a><span>|</span><a href="#38651238">next</a><span>|</span><label class="collapse" for="c-38649977">[-]</label><label class="expand" for="c-38649977">[2 more]</label></div><br/><div class="children"><div class="content">Lua is fantastic for the config-as-code use case. Easy to read and write, with a lightweight embeddable interpreter, and it has almost universal library support across different languages&#x2F;environments.</div><br/><div id="38650566" class="c"><input type="checkbox" id="c-38650566" checked=""/><div class="controls bullet"><span class="by">ishigoemon</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38649977">parent</a><span>|</span><a href="#38651238">next</a><span>|</span><label class="collapse" for="c-38650566">[-]</label><label class="expand" for="c-38650566">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a shame that helm v3 didn&#x27;t move forward with the lua engine[0]. I don&#x27;t imagine ~=&#x2F;1-based arrays were a worse timeline... And here we are 5 years later.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;helm&#x2F;helm&#x2F;issues&#x2F;5084">https:&#x2F;&#x2F;github.com&#x2F;helm&#x2F;helm&#x2F;issues&#x2F;5084</a></div><br/></div></div></div></div><div id="38651238" class="c"><input type="checkbox" id="c-38651238" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38649831">parent</a><span>|</span><a href="#38649977">prev</a><span>|</span><a href="#38650032">next</a><span>|</span><label class="collapse" for="c-38651238">[-]</label><label class="expand" for="c-38651238">[3 more]</label></div><br/><div class="children"><div class="content">Dedicated config languages are the best usually. Jsonnet&#x2F;Cue&#x2F;friends.<p>Failing that if you actually need&#x2F;want a procedural&#x2F;non-pure language then I think Kotlin or Ruby take the cake. Both have extremely strong support for DSLs which IMO is key to reaching a modicum of usability.</div><br/><div id="38652047" class="c"><input type="checkbox" id="c-38652047" checked=""/><div class="controls bullet"><span class="by">sakjur</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38651238">parent</a><span>|</span><a href="#38650032">next</a><span>|</span><label class="collapse" for="c-38652047">[-]</label><label class="expand" for="c-38652047">[2 more]</label></div><br/><div class="children"><div class="content">Starlark is nice as well, it’s syntactically based on Python, and behaves a lot like regular procedural languages, but it’s meant to provide a pure and safe environment for configuration and be embeddable.</div><br/><div id="38652331" class="c"><input type="checkbox" id="c-38652331" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#38648872">root</a><span>|</span><a href="#38652047">parent</a><span>|</span><a href="#38650032">next</a><span>|</span><label class="collapse" for="c-38652331">[-]</label><label class="expand" for="c-38652331">[1 more]</label></div><br/><div class="children"><div class="content">Since using Bazel a bit I have grown an appreciation for Starlark also. The big thing is that list and dict comprehensions are a really nice fit for these types of tasks.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38650032" class="c"><input type="checkbox" id="c-38650032" checked=""/><div class="controls bullet"><span class="by">fivre</span><span>|</span><a href="#38648872">parent</a><span>|</span><a href="#38649220">prev</a><span>|</span><a href="#38642779">next</a><span>|</span><label class="collapse" for="c-38650032">[-]</label><label class="expand" for="c-38650032">[1 more]</label></div><br/><div class="children"><div class="content">the best part is that Helm does some sort of preprocessing to strip out comments (i think) when templating and validating, so it will report a failure at a line number that doesn&#x27;t actually correspond to the problem in the original source. tracking down template failures is infuriating because of this</div><br/></div></div></div></div><div id="38642779" class="c"><input type="checkbox" id="c-38642779" checked=""/><div class="controls bullet"><span class="by">empath-nirvana</span><span>|</span><a href="#38648872">prev</a><span>|</span><a href="#38643333">next</a><span>|</span><label class="collapse" for="c-38642779">[-]</label><label class="expand" for="c-38642779">[29 more]</label></div><br/><div class="children"><div class="content">I think helm is at it&#x27;s best when you need to _publicly distribute_ a complex application to a large number of people in a way that&#x27;s configurable through parameters.<p>For internal applications, it&#x27;s in an awkward place of being both too complex and too simple, and in a lot of cases what you really want to do is just write your own operator for the complex cases and use kustomize for the simple cases.<p>Most of the problems with updating and installing helm charts go away if you manage it with something like argocd to automatically keep everything up to date.</div><br/><div id="38643279" class="c"><input type="checkbox" id="c-38643279" checked=""/><div class="controls bullet"><span class="by">evancordell</span><span>|</span><a href="#38642779">parent</a><span>|</span><a href="#38651986">next</a><span>|</span><label class="collapse" for="c-38643279">[-]</label><label class="expand" for="c-38643279">[2 more]</label></div><br/><div class="children"><div class="content">This is interesting, I have the opposite opinion. I dislike helm for public distribution, because everyone wants _their_ thing templated, so you end up making  every field of your chart templated and it becomes a mess to maintain.<p>Internal applications don&#x27;t have this problem, so you can easily keep your chart interface simple and scoped to the different ways you need to deploy your own stack.<p>With Kustomize, you just publish the base manifests and users can override whatever they want. Not that Kustomize doesn&#x27;t have its own set of problems.</div><br/><div id="38643654" class="c"><input type="checkbox" id="c-38643654" checked=""/><div class="controls bullet"><span class="by">moondev</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38643279">parent</a><span>|</span><a href="#38651986">next</a><span>|</span><label class="collapse" for="c-38643654">[-]</label><label class="expand" for="c-38643654">[1 more]</label></div><br/><div class="children"><div class="content">Kustomize also supports helm charts as a &quot;resource&quot; which makes it handy to do last mile modifications of values and &#x27;non value exposed&quot; items without touching or forking the upstream chart.</div><br/></div></div></div></div><div id="38651986" class="c"><input type="checkbox" id="c-38651986" checked=""/><div class="controls bullet"><span class="by">zzyzxd</span><span>|</span><a href="#38642779">parent</a><span>|</span><a href="#38643279">prev</a><span>|</span><a href="#38643052">next</a><span>|</span><label class="collapse" for="c-38651986">[-]</label><label class="expand" for="c-38651986">[1 more]</label></div><br/><div class="children"><div class="content">&gt; helm is at it&#x27;s best when you need to _publicly distribute_ a complex application<p>I would say, helm is at it&#x27;s best when you need to _publicly distribute_ a complex application, AND the majority of the users on the receiving end don&#x27;t care about the complexity.<p>You don&#x27;t need Helm if your manifests are simple. But when your manifests become complex, helm will make it even more complex by turning each field in the plain k8s manifests into a toggle in a values.yaml file.</div><br/></div></div><div id="38643052" class="c"><input type="checkbox" id="c-38643052" checked=""/><div class="controls bullet"><span class="by">numbsafari</span><span>|</span><a href="#38642779">parent</a><span>|</span><a href="#38651986">prev</a><span>|</span><a href="#38648707">next</a><span>|</span><label class="collapse" for="c-38643052">[-]</label><label class="expand" for="c-38643052">[19 more]</label></div><br/><div class="children"><div class="content">Personally much prefer kustomize for the “ship an app” business.<p>Probably even better is to ship a controller and a CRD for the config.<p>Doing it that means you ship a schema for the parameters of the config, and that you have code that can handle complexities of upgrades&#x2F;migrations that tools like kustomize and helm struggle or fail at altogether.</div><br/><div id="38643311" class="c"><input type="checkbox" id="c-38643311" checked=""/><div class="controls bullet"><span class="by">cortesoft</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38643052">parent</a><span>|</span><a href="#38643286">next</a><span>|</span><label class="collapse" for="c-38643311">[-]</label><label class="expand" for="c-38643311">[8 more]</label></div><br/><div class="children"><div class="content">We switched from kustomize to helm and I really can&#x27;t understand why anyone would prefer kustomize. Having the weird syntax for replacing things, having to look at a bunch of different files to see what is going on...<p>I love how in Helm I can just look at the templates and figure out what values I need to change to get what I want, and I love each environment only needing a single values file to see all the customizations for it.<p>People complain about it being a template language, but that is exactly what you need!</div><br/><div id="38650111" class="c"><input type="checkbox" id="c-38650111" checked=""/><div class="controls bullet"><span class="by">fivre</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38643311">parent</a><span>|</span><a href="#38649274">next</a><span>|</span><label class="collapse" for="c-38650111">[-]</label><label class="expand" for="c-38650111">[1 more]</label></div><br/><div class="children"><div class="content">JSON patches aren&#x27;t the most intuitive and kustomize needs some helper tooling to generate them for you (given JSON objects A and B, generate a patch that transforms A into B), but overall the kustomize model makes more sense, and the team behind it seems to be more actively improving developer QoL stuff than Helm is<p>templates are only good if your templates can remain simple and do not need to expose most of the output fields. my experience developing a chart for wide distribution has been very much that your templates will not remain simple (and will turn into an incomprehensible mess, since you&#x27;ll need them to handle tasks templates are fundamentally poorly suited for) and that there is always someone, somewhere, that needs some particular resource field exposed in values.yaml. the<p>&gt; As a result, the number of possibilities for configuration is often unreasonably large and complicated, mimicking the actual resources they want to create, but without any schema validation!<p>bit from the op is incredibly true. values.yaml grows, over time, to have every field in the objects it generates, just organized differently, without validation, and with extra complicated relationships with other settings<p>kustomize allowing you to provide a base set of resources that users can apply their own patches to avoids that config surface bloat problem entirely</div><br/></div></div><div id="38649274" class="c"><input type="checkbox" id="c-38649274" checked=""/><div class="controls bullet"><span class="by">ljm</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38643311">parent</a><span>|</span><a href="#38650111">prev</a><span>|</span><a href="#38643601">next</a><span>|</span><label class="collapse" for="c-38649274">[-]</label><label class="expand" for="c-38649274">[2 more]</label></div><br/><div class="children"><div class="content">You shouldn&#x27;t need to read the source to configure the values how you want.<p>Helm&#x27;s problem is that `values.yml` is basically the API and every helm chart provides its own (often incomplete) interface with poorly documented defaults. Some of those can spread over 3k+ lines and it&#x27;s utterly overwhelming to figure out what to do with that.</div><br/><div id="38649836" class="c"><input type="checkbox" id="c-38649836" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38649274">parent</a><span>|</span><a href="#38643601">next</a><span>|</span><label class="collapse" for="c-38649836">[-]</label><label class="expand" for="c-38649836">[1 more]</label></div><br/><div class="children"><div class="content">There nothing better than a huge comment describing behaviors above a value: {} to ruin your day.</div><br/></div></div></div></div><div id="38643601" class="c"><input type="checkbox" id="c-38643601" checked=""/><div class="controls bullet"><span class="by">Hamuko</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38643311">parent</a><span>|</span><a href="#38649274">prev</a><span>|</span><a href="#38643286">next</a><span>|</span><label class="collapse" for="c-38643601">[-]</label><label class="expand" for="c-38643601">[4 more]</label></div><br/><div class="children"><div class="content">&gt;<i>Having the weird syntax for replacing things</i><p>Isn&#x27;t the &quot;weird syntax&quot; just either Yaml files or just JSON Patches, which is a pretty easy standard?<p>&gt;<i>having to look at a bunch of different files to see what is going on</i><p>I consider that a feature, not a bug. prod&#x2F;larger-memory-request.yaml makes it much easier for me to see what goes into deploying the prod environment instead of for example the test environment.</div><br/><div id="38644227" class="c"><input type="checkbox" id="c-38644227" checked=""/><div class="controls bullet"><span class="by">cortesoft</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38643601">parent</a><span>|</span><a href="#38643286">next</a><span>|</span><label class="collapse" for="c-38644227">[-]</label><label class="expand" for="c-38644227">[3 more]</label></div><br/><div class="children"><div class="content">By &quot;weird syntax&quot; I mean stuff like &quot;patchesJson6902&quot; or &quot;configMapGenerator&quot; or &quot;patchesStrategicMerge&quot; where you have to know what each field means and how they work.<p>A template is much easier to read. I had zero experience with go templating, but was able to figure out what it all meant just by looking at the templates... they still looked like kubernetes resources<p>As for looking at a bunch of different files, if you like having a &quot;larger-memory-request&quot; file, you can still do that with helm... you can use as many values files as you want, just include them in precedence order. You can have your &quot;larger-memory-request&quot; values file.</div><br/><div id="38650298" class="c"><input type="checkbox" id="c-38650298" checked=""/><div class="controls bullet"><span class="by">miiiiiike</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38644227">parent</a><span>|</span><a href="#38649216">next</a><span>|</span><label class="collapse" for="c-38650298">[-]</label><label class="expand" for="c-38650298">[1 more]</label></div><br/><div class="children"><div class="content">That just using Kustomize. There’s a difference between learning curve and frustration post learning curve. Kustomize isn’t that bad, Helm comes with far more headaches, especially if you need to do any kind of inheritance.<p>Keep your customizations flat and compile them to yaml+grep to find out what’s getting overridden and where.</div><br/></div></div><div id="38649216" class="c"><input type="checkbox" id="c-38649216" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38644227">parent</a><span>|</span><a href="#38650298">prev</a><span>|</span><a href="#38643286">next</a><span>|</span><label class="collapse" for="c-38649216">[-]</label><label class="expand" for="c-38649216">[1 more]</label></div><br/><div class="children"><div class="content">Do you have any really complex Helm template? It either becomes an unreadable mess or you end up with basically manifest snippets in your values file.</div><br/></div></div></div></div></div></div></div></div><div id="38643286" class="c"><input type="checkbox" id="c-38643286" checked=""/><div class="controls bullet"><span class="by">mountainriver</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38643052">parent</a><span>|</span><a href="#38643311">prev</a><span>|</span><a href="#38643631">next</a><span>|</span><label class="collapse" for="c-38643286">[-]</label><label class="expand" for="c-38643286">[3 more]</label></div><br/><div class="children"><div class="content">Controller + CRD is the way to go and seems more in line with how k8s was intended to be used.<p>The challenge has historically been that controllers are a lot harder to write, but I think that story has improved over the years</div><br/><div id="38643617" class="c"><input type="checkbox" id="c-38643617" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38643286">parent</a><span>|</span><a href="#38643631">next</a><span>|</span><label class="collapse" for="c-38643617">[-]</label><label class="expand" for="c-38643617">[2 more]</label></div><br/><div class="children"><div class="content">operators are great when you control it. less so when it&#x27;s some third party one that doesn&#x27;t support that field you need on a resource it creates<p>and all the customizations just end up being yaml merges from a configmap string or CRD if you&#x27;re lucky</div><br/><div id="38644228" class="c"><input type="checkbox" id="c-38644228" checked=""/><div class="controls bullet"><span class="by">mountainriver</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38643617">parent</a><span>|</span><a href="#38643631">next</a><span>|</span><label class="collapse" for="c-38644228">[-]</label><label class="expand" for="c-38644228">[1 more]</label></div><br/><div class="children"><div class="content">Fair enough, the UX is just so much better that I&#x27;d gamble it in most use cases</div><br/></div></div></div></div></div></div><div id="38643631" class="c"><input type="checkbox" id="c-38643631" checked=""/><div class="controls bullet"><span class="by">jpdb</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38643052">parent</a><span>|</span><a href="#38643286">prev</a><span>|</span><a href="#38643498">next</a><span>|</span><label class="collapse" for="c-38643631">[-]</label><label class="expand" for="c-38643631">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Probably even better is to ship a controller and a CRD for the config.<p>But how do you package the controller + CRD? The two leading choices are `kubectl apply -f` on a url or Helm and as soon as you need any customization to the controller itself you end up needing a tool like helm.</div><br/><div id="38643716" class="c"><input type="checkbox" id="c-38643716" checked=""/><div class="controls bullet"><span class="by">numbsafari</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38643631">parent</a><span>|</span><a href="#38643498">next</a><span>|</span><label class="collapse" for="c-38643716">[-]</label><label class="expand" for="c-38643716">[2 more]</label></div><br/><div class="children"><div class="content">Just use kustomize. It’s baked into kubectl. No need for a separate tool.</div><br/><div id="38645150" class="c"><input type="checkbox" id="c-38645150" checked=""/><div class="controls bullet"><span class="by">cassianoleal</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38643716">parent</a><span>|</span><a href="#38643498">next</a><span>|</span><label class="collapse" for="c-38645150">[-]</label><label class="expand" for="c-38645150">[1 more]</label></div><br/><div class="children"><div class="content">Agree. I&#x27;d recommend to start with static YAML though. Use kustomize for the very few customisations required for, say, different environments. Keep them to a minimum - there&#x27;s no reason for a controller&#x27;s deployment to vary too much - they&#x27;re usually deployed once per cluster.</div><br/></div></div></div></div></div></div><div id="38643498" class="c"><input type="checkbox" id="c-38643498" checked=""/><div class="controls bullet"><span class="by">morelisp</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38643052">parent</a><span>|</span><a href="#38643631">prev</a><span>|</span><a href="#38648707">next</a><span>|</span><label class="collapse" for="c-38643498">[-]</label><label class="expand" for="c-38643498">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Probably even better is to ship a controller and a CRD for the config.<p>Maybe it&#x27;s just us, but our operations team puts pretty hard restrictions on how we&#x27;re allowed to talk to the K8s API directly. We can turn a regular Deployment around as fast as we can write it, but if we needed a controller and CRD update it&#x27;d take us like three days minimum. (Which, I even sort of understand because I see the absolute garbage code in some of the operators the other teams are asking them to deploy...)</div><br/><div id="38645230" class="c"><input type="checkbox" id="c-38645230" checked=""/><div class="controls bullet"><span class="by">cassianoleal</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38643498">parent</a><span>|</span><a href="#38643700">next</a><span>|</span><label class="collapse" for="c-38645230">[-]</label><label class="expand" for="c-38645230">[1 more]</label></div><br/><div class="children"><div class="content">Generally speaking, operators and CRDs are more in the domain of your platform rather than your products. They should provide common interfaces to implement the business requirements around things like uptime, HA, healthchecking, observability, etc.<p>If a product team sees itself needing to deploy an operator, it&#x27;s likely the platform is subpar and should be improved, or the product team is overengineering something and could do with rethinking their approach.<p>As in most cases, a conversation with your platform&#x2F;ops&#x2F;devops&#x2F;sre&#x2F;infra team should help clarify things.</div><br/></div></div><div id="38643700" class="c"><input type="checkbox" id="c-38643700" checked=""/><div class="controls bullet"><span class="by">jen20</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38643498">parent</a><span>|</span><a href="#38645230">prev</a><span>|</span><a href="#38648707">next</a><span>|</span><label class="collapse" for="c-38643700">[-]</label><label class="expand" for="c-38643700">[2 more]</label></div><br/><div class="children"><div class="content">If you run a multi-tenant Kubernetes cluster at scale, operators with poor discipline spamming the API servers and taking etcd down is a leading cause of sadness.</div><br/><div id="38643898" class="c"><input type="checkbox" id="c-38643898" checked=""/><div class="controls bullet"><span class="by">morelisp</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38643700">parent</a><span>|</span><a href="#38648707">next</a><span>|</span><label class="collapse" for="c-38643898">[-]</label><label class="expand" for="c-38643898">[1 more]</label></div><br/><div class="children"><div class="content">This is the common view among our ops team, sure, but for a vocation so prima facie obsessed with postmortems&#x2F;five-whys&#x2F;root-causes&#x2F;etc it&#x27;s depressingly shallow.</div><br/></div></div></div></div></div></div></div></div><div id="38648707" class="c"><input type="checkbox" id="c-38648707" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#38642779">parent</a><span>|</span><a href="#38643052">prev</a><span>|</span><a href="#38643681">next</a><span>|</span><label class="collapse" for="c-38648707">[-]</label><label class="expand" for="c-38648707">[1 more]</label></div><br/><div class="children"><div class="content">I barely have a horse in this race, but I think what I&#x27;d like to see is more apps that behave like &#x27;npm config&#x27; or &#x27;git config&#x27; where you can imperatively change one configuration value.<p>I take your image as the FROM for my own Dockerfile, tweak a few settings, maybe alter the CMD, and then run my image instead of trying to do some sort of ad absurdum variation on a Twelve Factor App.</div><br/></div></div><div id="38643681" class="c"><input type="checkbox" id="c-38643681" checked=""/><div class="controls bullet"><span class="by">jen20</span><span>|</span><a href="#38642779">parent</a><span>|</span><a href="#38648707">prev</a><span>|</span><a href="#38643333">next</a><span>|</span><label class="collapse" for="c-38643681">[-]</label><label class="expand" for="c-38643681">[5 more]</label></div><br/><div class="children"><div class="content">The need to use something like Helm to distribute a complex application is a good indication you&#x27;ve built something which is a mess, and probably should be rethought from first principles.<p>Most of the problems associated with Helm go away if you stop using Kubernetes.</div><br/><div id="38646296" class="c"><input type="checkbox" id="c-38646296" checked=""/><div class="controls bullet"><span class="by">imglorp</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38643681">parent</a><span>|</span><a href="#38643333">next</a><span>|</span><label class="collapse" for="c-38646296">[-]</label><label class="expand" for="c-38646296">[4 more]</label></div><br/><div class="children"><div class="content">Vendors shipping things for customers to run in their clouds and prems have a very limited set of common denominators. When you add in requirements like workload scaling, availability, and durability, that set is very small.<p>So yeah we do this. Our product runs in 3 public clouds (working on 5), single VM, etc. and our customers install it themselves.  We&#x27;re helm plus Replicated. AMA.</div><br/><div id="38651477" class="c"><input type="checkbox" id="c-38651477" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38646296">parent</a><span>|</span><a href="#38650121">next</a><span>|</span><label class="collapse" for="c-38651477">[-]</label><label class="expand" for="c-38651477">[1 more]</label></div><br/><div class="children"><div class="content">Once you add in workload scaling, availability and durability, there is surely a dedicated ops team that want to control every aspect of how it’s deployed, including the security around it. They are not just going to blindly apply a chart without at least having reviewed it in great detail first.<p>What I found is that when doing such review, you realize 99 of the template variables are not relevant for you and the one place you need to template is missing a value. Just extracting the rendered manifests and modify them by hand from there becomes more maintainable. Like you say, there is a very limited set of common denominators.<p>For smaller orgs, just running a single container and increasing the Node size takes you a very long way. That doesn’t need helm.</div><br/></div></div><div id="38650121" class="c"><input type="checkbox" id="c-38650121" checked=""/><div class="controls bullet"><span class="by">dog321</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38646296">parent</a><span>|</span><a href="#38651477">prev</a><span>|</span><a href="#38643333">next</a><span>|</span><label class="collapse" for="c-38650121">[-]</label><label class="expand" for="c-38650121">[2 more]</label></div><br/><div class="children"><div class="content">When deploying into different clouds, do you require any cloud provider resources that require management with terraform etc. or is it relatively self contained?<p>Also curious what issues you&#x27;ve seen replicated prevent.</div><br/><div id="38650264" class="c"><input type="checkbox" id="c-38650264" checked=""/><div class="controls bullet"><span class="by">imglorp</span><span>|</span><a href="#38642779">root</a><span>|</span><a href="#38650121">parent</a><span>|</span><a href="#38643333">next</a><span>|</span><label class="collapse" for="c-38650264">[-]</label><label class="expand" for="c-38650264">[1 more]</label></div><br/><div class="children"><div class="content">For public cloud k8s, no we don&#x27;t provision or TF anything, we just shove in a manifest and k8s creates the workloads and it provisions persistent volumes and load balancers on your behalf. That&#x27;s either Helm or Replicated (Kots) on top of Helm. Yes, it&#x27;s basically self-contained and manages to abstract most of the cloud differences. We do have a custom storage class for each cloud but probably don&#x27;t need it. The network load balancers need a little cloud specific annotation.<p>Replicated saved work by handling a configuration gui for the end user, licensing&#x2F; entitlements, support bundle collection, private image proxy, things like that we didn&#x27;t want to deal with.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38643333" class="c"><input type="checkbox" id="c-38643333" checked=""/><div class="controls bullet"><span class="by">throwawaaarrgh</span><span>|</span><a href="#38642779">prev</a><span>|</span><a href="#38643544">next</a><span>|</span><label class="collapse" for="c-38643333">[-]</label><label class="expand" for="c-38643333">[1 more]</label></div><br/><div class="children"><div class="content">...that&#x27;s it? What about hooks being an anti pattern? What about upgrades potentially resulting in blowing away your whole deployment without warning? What about a lack of diffs or planning changes? Or the complexity&#x2F;kludginess of go template logic? Or the lack of ability to order installation of resources or processing of subcharts? Or waiting until a resource is done before continuing to the next one? Or the difficulty of generating and sharing dynamic values between subcharts? Or just a dry run (template) that can reference the K8s api?<p>There&#x27;s a ton of pitfalls and limits. It&#x27;s still a genuinely useful tool and provides value. But it&#x27;s mostly useful if you use it in the simplest possible ways with small charts.<p>I just wish the &quot;operation engine&quot; were decoupled from the &quot;generation engine&quot;, and pluggable. I like how it watches the deployment, has atomic upgrades, can do rollbacks. But if you want a complex deployment, you currently have to DIY it.</div><br/></div></div><div id="38643544" class="c"><input type="checkbox" id="c-38643544" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#38643333">prev</a><span>|</span><a href="#38650746">next</a><span>|</span><label class="collapse" for="c-38643544">[-]</label><label class="expand" for="c-38643544">[3 more]</label></div><br/><div class="children"><div class="content">Helm is a tool to use Jinja to write an object tree (or dag), in yaml.<p>This is not endorsement. This is to point out that it makes hardly any sense! Use a proper programming language and serialize the object tree&#x2F;network to whatever format is necessary.</div><br/><div id="38643606" class="c"><input type="checkbox" id="c-38643606" checked=""/><div class="controls bullet"><span class="by">BossingAround</span><span>|</span><a href="#38643544">parent</a><span>|</span><a href="#38643717">next</a><span>|</span><label class="collapse" for="c-38643606">[-]</label><label class="expand" for="c-38643606">[1 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s where the landscape is heading--language frameworks that output YAML on one end, and operators that control YAMLs through the K8s control loop on the other end.</div><br/></div></div><div id="38643717" class="c"><input type="checkbox" id="c-38643717" checked=""/><div class="controls bullet"><span class="by">jen20</span><span>|</span><a href="#38643544">parent</a><span>|</span><a href="#38643606">prev</a><span>|</span><a href="#38650746">next</a><span>|</span><label class="collapse" for="c-38643717">[-]</label><label class="expand" for="c-38643717">[1 more]</label></div><br/><div class="children"><div class="content">&gt; tool to use Jinja<p>It&#x27;s not really that. Jinja is python, Helm is written in Go and uses one of the Go template languages, which has a passing similarity to Jinja.<p>The rest of your comment is spot on, of course.</div><br/></div></div></div></div><div id="38650746" class="c"><input type="checkbox" id="c-38650746" checked=""/><div class="controls bullet"><span class="by">aliasxneo</span><span>|</span><a href="#38643544">prev</a><span>|</span><a href="#38642810">next</a><span>|</span><label class="collapse" for="c-38650746">[-]</label><label class="expand" for="c-38650746">[1 more]</label></div><br/><div class="children"><div class="content">For those not aware, there&#x27;s <a href="https:&#x2F;&#x2F;timoni.sh" rel="nofollow noreferrer">https:&#x2F;&#x2F;timoni.sh</a>. It&#x27;s similar to Helm but used CUE instead of the Go templating language. We&#x27;ve recently switched to it and are not looking back. Would be great to get some more contributors on board.</div><br/></div></div><div id="38642810" class="c"><input type="checkbox" id="c-38642810" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#38650746">prev</a><span>|</span><a href="#38642772">next</a><span>|</span><label class="collapse" for="c-38642810">[-]</label><label class="expand" for="c-38642810">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>See, there is no general schema for what goes and doesn&#x27;t go inside a values.yaml file. Thus, your development environment cannot help you beyond basic YAML syntax highlighting.</i><p>… this is just an odd complaint. Naturally, there isn&#x27;t a schema — there inherently cannot be one. Values are the options <i>for the app</i> at hand; they&#x27;re naturally dependent on the app.<p>&gt; <i>but without any schema validation!</i><p>I have seen people supply JSON schemas for values with the chart. I appreciate that.<p>Of all the pitfalls … the clunky stringly-typed &quot;manipulate YAML with unsafe string templating&quot; is the biggest pitfall, to me…</div><br/><div id="38643425" class="c"><input type="checkbox" id="c-38643425" checked=""/><div class="controls bullet"><span class="by">everforward</span><span>|</span><a href="#38642810">parent</a><span>|</span><a href="#38642772">next</a><span>|</span><label class="collapse" for="c-38643425">[-]</label><label class="expand" for="c-38643425">[1 more]</label></div><br/><div class="children"><div class="content">A lot of those values end up being used in places that <i>do</i> have schemas. I think they&#x27;re asking for what is basically inferred types.<p>They want Helm to recognize that the cpuLimit value is used as a CPU limit for a Pod and throw errors for any cpuLimit that isn&#x27;t a valid CPU limit.<p>Agreed that the user will have to write their own schema for CLI arguments.</div><br/></div></div></div></div><div id="38642772" class="c"><input type="checkbox" id="c-38642772" checked=""/><div class="controls bullet"><span class="by">aschleck</span><span>|</span><a href="#38642810">prev</a><span>|</span><a href="#38642824">next</a><span>|</span><label class="collapse" for="c-38642772">[-]</label><label class="expand" for="c-38642772">[6 more]</label></div><br/><div class="children"><div class="content">I found that using &quot;helm template&quot; to convert every Helm chart into yaml, and then using Pulumi to track changes and update my clusters (with Python transformation functions to get per-cluster configuration) made my life so much better than using Helm. Watching Pulumi or Terraform watch Helm watch Kubernetes update a deployment felt pointlessly complicated.</div><br/><div id="38652099" class="c"><input type="checkbox" id="c-38652099" checked=""/><div class="controls bullet"><span class="by">personomas</span><span>|</span><a href="#38642772">parent</a><span>|</span><a href="#38642845">next</a><span>|</span><label class="collapse" for="c-38652099">[-]</label><label class="expand" for="c-38652099">[1 more]</label></div><br/><div class="children"><div class="content">What about using terraform instead of Pulumi? Why did you pick Pulumi for this?</div><br/></div></div><div id="38642845" class="c"><input type="checkbox" id="c-38642845" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#38642772">parent</a><span>|</span><a href="#38652099">prev</a><span>|</span><a href="#38642939">next</a><span>|</span><label class="collapse" for="c-38642845">[-]</label><label class="expand" for="c-38642845">[3 more]</label></div><br/><div class="children"><div class="content">I do the same with Tanka + Jsonnet, definitely a million times better than dealing with Helm itself or god forbid, letting it apply manifests.</div><br/><div id="38652093" class="c"><input type="checkbox" id="c-38652093" checked=""/><div class="controls bullet"><span class="by">personomas</span><span>|</span><a href="#38642772">root</a><span>|</span><a href="#38642845">parent</a><span>|</span><a href="#38642939">next</a><span>|</span><label class="collapse" for="c-38652093">[-]</label><label class="expand" for="c-38652093">[2 more]</label></div><br/><div class="children"><div class="content">How does Tanka compare with Ksonnet? <a href="https:&#x2F;&#x2F;github.com&#x2F;ksonnet&#x2F;ksonnet">https:&#x2F;&#x2F;github.com&#x2F;ksonnet&#x2F;ksonnet</a></div><br/><div id="38652307" class="c"><input type="checkbox" id="c-38652307" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#38642772">root</a><span>|</span><a href="#38652093">parent</a><span>|</span><a href="#38642939">next</a><span>|</span><label class="collapse" for="c-38652307">[-]</label><label class="expand" for="c-38652307">[1 more]</label></div><br/><div class="children"><div class="content">The main thing is that it&#x27;s still kicking, Ksonnet is sadly dead.<p>In addition to that it supports importing Helm charts, has a blessed convention for multiple environments and several native Jsonnet functions that make things a bit nicer.</div><br/></div></div></div></div></div></div><div id="38642939" class="c"><input type="checkbox" id="c-38642939" checked=""/><div class="controls bullet"><span class="by">notnmeyer</span><span>|</span><a href="#38642772">parent</a><span>|</span><a href="#38642845">prev</a><span>|</span><a href="#38642824">next</a><span>|</span><label class="collapse" for="c-38642939">[-]</label><label class="expand" for="c-38642939">[1 more]</label></div><br/><div class="children"><div class="content">i am hearing this more and more from folks.</div><br/></div></div></div></div><div id="38642824" class="c"><input type="checkbox" id="c-38642824" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#38642772">prev</a><span>|</span><a href="#38648050">next</a><span>|</span><label class="collapse" for="c-38642824">[-]</label><label class="expand" for="c-38642824">[14 more]</label></div><br/><div class="children"><div class="content">Helm makes me sad.<p>What I do to remediate this sadness is use Helm from Tanka. There is still sadness but now it&#x27;s wrapped in a nice Jsonnet wrapper and I can easily mutate the output using Jsonnet features without having to mess with nasty Go templating.<p>I&#x27;ve said it a million times before but it&#x27;s always worth saying again:<p>Don&#x27;t use string templating for structured data.</div><br/><div id="38642878" class="c"><input type="checkbox" id="c-38642878" checked=""/><div class="controls bullet"><span class="by">ivan4th</span><span>|</span><a href="#38642824">parent</a><span>|</span><a href="#38643228">next</a><span>|</span><label class="collapse" for="c-38642878">[-]</label><label class="expand" for="c-38642878">[8 more]</label></div><br/><div class="children"><div class="content">Yep. Many complain that with Lisp, you need to count parentheses (spoiler: you don&#x27;t need to). And then proceed to count spaces for indent&#x2F;nindent in the charts... That&#x27;s somehow ok with almost everyone</div><br/><div id="38643157" class="c"><input type="checkbox" id="c-38643157" checked=""/><div class="controls bullet"><span class="by">morelisp</span><span>|</span><a href="#38642824">root</a><span>|</span><a href="#38642878">parent</a><span>|</span><a href="#38643228">next</a><span>|</span><label class="collapse" for="c-38643157">[-]</label><label class="expand" for="c-38643157">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s absolutely crazy to me how many tools are in common use for k8s templating which would all be wiped away with any decent macro system.</div><br/><div id="38643800" class="c"><input type="checkbox" id="c-38643800" checked=""/><div class="controls bullet"><span class="by">twelfthnight</span><span>|</span><a href="#38642824">root</a><span>|</span><a href="#38643157">parent</a><span>|</span><a href="#38643277">next</a><span>|</span><label class="collapse" for="c-38643800">[-]</label><label class="expand" for="c-38643800">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t actually put it into production at my company, but for selfish catharsis, I ran datamodel-codegen over our cluster&#x27;s jsonschema and generated Python pydantic models for all resources. I was able to rewrite all our helm using pure Python and Pydantic models, since Pydantic serializes to json and json is valid yaml.  Felt pretty good<p>We don&#x27;t have any CRD, but the approach would extend to those, plus you get auto complete.  The k8s jsonachema isn&#x27;t super easy to work directly with, though.</div><br/></div></div><div id="38643277" class="c"><input type="checkbox" id="c-38643277" checked=""/><div class="controls bullet"><span class="by">speedgoose</span><span>|</span><a href="#38642824">root</a><span>|</span><a href="#38643157">parent</a><span>|</span><a href="#38643800">prev</a><span>|</span><a href="#38643228">next</a><span>|</span><label class="collapse" for="c-38643277">[-]</label><label class="expand" for="c-38643277">[5 more]</label></div><br/><div class="children"><div class="content">The template engine is not specific to Kubernetes but Golang. I wish they used something more adapted. <a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;text&#x2F;template" rel="nofollow noreferrer">https:&#x2F;&#x2F;pkg.go.dev&#x2F;text&#x2F;template</a></div><br/><div id="38643343" class="c"><input type="checkbox" id="c-38643343" checked=""/><div class="controls bullet"><span class="by">morelisp</span><span>|</span><a href="#38642824">root</a><span>|</span><a href="#38643277">parent</a><span>|</span><a href="#38643228">next</a><span>|</span><label class="collapse" for="c-38643343">[-]</label><label class="expand" for="c-38643343">[4 more]</label></div><br/><div class="children"><div class="content">Not just helm. There are probably a half dozen tools for rendering manifests in our company, only some use text&#x2F;template, and they all suck. Text replacements are bad. Declarative structured patches are bad. Control flow in JSON is bad. We&#x27;ve had a language for dealing with generating complex nested structured data for years!</div><br/><div id="38645216" class="c"><input type="checkbox" id="c-38645216" checked=""/><div class="controls bullet"><span class="by">ianburrell</span><span>|</span><a href="#38642824">root</a><span>|</span><a href="#38643343">parent</a><span>|</span><a href="#38643455">next</a><span>|</span><label class="collapse" for="c-38645216">[-]</label><label class="expand" for="c-38645216">[1 more]</label></div><br/><div class="children"><div class="content">Have you seen Jsonnet, Dhall, and Cue? They are configuration language that are more limited than general purpose languages, more powerful that static, and designed for config files unlike templates.</div><br/></div></div><div id="38643455" class="c"><input type="checkbox" id="c-38643455" checked=""/><div class="controls bullet"><span class="by">anonacct37</span><span>|</span><a href="#38642824">root</a><span>|</span><a href="#38643343">parent</a><span>|</span><a href="#38645216">prev</a><span>|</span><a href="#38643228">next</a><span>|</span><label class="collapse" for="c-38643455">[-]</label><label class="expand" for="c-38643455">[2 more]</label></div><br/><div class="children"><div class="content">text&#x2F;template is probably ok... For  some version of text. ditto with jinja and most templating languages. The cardinal sin of DevOps is using text macros to produce structured data. It only exists because unfortunately there is no other lowest common denominator for every config file syntax.</div><br/><div id="38643693" class="c"><input type="checkbox" id="c-38643693" checked=""/><div class="controls bullet"><span class="by">morelisp</span><span>|</span><a href="#38642824">root</a><span>|</span><a href="#38643455">parent</a><span>|</span><a href="#38643228">next</a><span>|</span><label class="collapse" for="c-38643693">[-]</label><label class="expand" for="c-38643693">[1 more]</label></div><br/><div class="children"><div class="content">Sure and that forgives its use in maybe, like, Salt and Ansible. Not in Kubernetes where everything is structured in the same way, even with API-available schemas, to begin with.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38643228" class="c"><input type="checkbox" id="c-38643228" checked=""/><div class="controls bullet"><span class="by">mountainriver</span><span>|</span><a href="#38642824">parent</a><span>|</span><a href="#38642878">prev</a><span>|</span><a href="#38648050">next</a><span>|</span><label class="collapse" for="c-38643228">[-]</label><label class="expand" for="c-38643228">[5 more]</label></div><br/><div class="children"><div class="content">Jsonnet isn’t great either, and has been tried a bunch in the k8s community.<p>I’ll never understand why we don’t just use a language. I started writing all my k8s config in python and it’s great.</div><br/><div id="38652343" class="c"><input type="checkbox" id="c-38652343" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#38642824">root</a><span>|</span><a href="#38643228">parent</a><span>|</span><a href="#38646870">next</a><span>|</span><label class="collapse" for="c-38652343">[-]</label><label class="expand" for="c-38652343">[1 more]</label></div><br/><div class="children"><div class="content">I will agree that it&#x27;s not optimal but there is still a big difference between text templating and Jsonnet.<p>Something Jsonnet-esque but with more typing help, better debugging (especially error messages instead of `blah thunk, thunk thunk` would go a long way.</div><br/></div></div><div id="38646870" class="c"><input type="checkbox" id="c-38646870" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#38642824">root</a><span>|</span><a href="#38643228">parent</a><span>|</span><a href="#38652343">prev</a><span>|</span><a href="#38643564">next</a><span>|</span><label class="collapse" for="c-38646870">[-]</label><label class="expand" for="c-38646870">[1 more]</label></div><br/><div class="children"><div class="content">Jsonnet wouldn&#x27;t be as bad as it is if there was just a modicum of debugging aid.<p>I&#x27;m slowly chipping away at that problem by implementing some tooling. For example I recently added &quot;traceback&quot; functionality in <a href="https:&#x2F;&#x2F;github.com&#x2F;kubecfg&#x2F;kubecfg">https:&#x2F;&#x2F;github.com&#x2F;kubecfg&#x2F;kubecfg</a><p>Another thing that I noticed is that most people who end up writing template libraries for jsonnet are using too many functions and not leveraging the strengths of jsonnet, namely object extension.<p>I opensourced a library I&#x27;m using internally at $work. It&#x27;s far from perfect and sorely lacking docs and examples but if you want to give jsonnet another go I&#x27;d recommend you try kubecfg + <a href="https:&#x2F;&#x2F;github.com&#x2F;kubecfg&#x2F;k8s-libsonnet">https:&#x2F;&#x2F;github.com&#x2F;kubecfg&#x2F;k8s-libsonnet</a></div><br/></div></div><div id="38643564" class="c"><input type="checkbox" id="c-38643564" checked=""/><div class="controls bullet"><span class="by">mplewis</span><span>|</span><a href="#38642824">root</a><span>|</span><a href="#38643228">parent</a><span>|</span><a href="#38646870">prev</a><span>|</span><a href="#38648050">next</a><span>|</span><label class="collapse" for="c-38643564">[-]</label><label class="expand" for="c-38643564">[2 more]</label></div><br/><div class="children"><div class="content">I agree. I write all of my K8s and surrounding cloud infra specs in Pulumi using TypeScript. Never going back to Helm.</div><br/><div id="38651211" class="c"><input type="checkbox" id="c-38651211" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#38642824">root</a><span>|</span><a href="#38643564">parent</a><span>|</span><a href="#38648050">next</a><span>|</span><label class="collapse" for="c-38651211">[-]</label><label class="expand" for="c-38651211">[1 more]</label></div><br/><div class="children"><div class="content">The problem with Pulumi is that it wants to manage the state of things rather than letting the k8s server handle that. This means it&#x27;s a hell of a lot slower than the equivalent `kubectl apply`. Not to mention it&#x27;s own state persistence really sucks if you don&#x27;t use their hosted solution that supports a patched based state update protocol (which someone really should implement an OSS version of).<p>I have be working on a new project and I split the IaC stuff into two layers, essentially using Pulumi (w&#x2F;Kotlin) to spin up the k8s cluster and dependencies for Config Connector (on GCP). From there I&#x27;m just generating and applying manifests with fabric8 (more Kotlin).<p>It&#x27;s not quite as good as Jsonnet in some cases (because of lazy vs non-lazy mostly and always-supported deep-merge etc) but Kotlin is immensely powerful and has things like the `lazy` helper to help here.<p>Having the entire repo defined in Kotlin though is very nice. Build system is Gradle w&#x2F;Kotlin script, frontend is htmx only generated by Kotlin DSL, IaC all Kotlin as described.<p>We did similar at $CURRENT_JOB with Typescript but Kotlin is miles better IMO.</div><br/></div></div></div></div></div></div></div></div><div id="38648050" class="c"><input type="checkbox" id="c-38648050" checked=""/><div class="controls bullet"><span class="by">nunez</span><span>|</span><a href="#38642824">prev</a><span>|</span><a href="#38642915">next</a><span>|</span><label class="collapse" for="c-38648050">[-]</label><label class="expand" for="c-38648050">[1 more]</label></div><br/><div class="children"><div class="content">Despite its pitfalls, I&#x27;ve found that Helm is still the best way to distribute an app that&#x27;s destined for Kubernetes. It&#x27;s easy to use and understand and provides just enough for me to ship an app along with its dependencies.<p>I use kapp from Project Carvel and the &quot;helm template&quot; subcommand to work around Helm&#x27;s inability to control desired state. I&#x27;ve found that kapp does a pretty good job of converging whatever resources Helm installed.</div><br/></div></div><div id="38642915" class="c"><input type="checkbox" id="c-38642915" checked=""/><div class="controls bullet"><span class="by">markbnj</span><span>|</span><a href="#38648050">prev</a><span>|</span><a href="#38643966">next</a><span>|</span><label class="collapse" for="c-38642915">[-]</label><label class="expand" for="c-38642915">[6 more]</label></div><br/><div class="children"><div class="content">Over seven years of using a variety of deployment tooling including helm (2 and 3), kustomize and our own scripting we concluded that helm&#x27;s strength is as a package manager, akin to dpkg. Writing good packages is complex, but the tool is quite powerful if you take the time to do that. For our own deployments what we typically want to to do is: build, test and push an image, plug some context specific things into yaml, send the yaml to the control plane and maybe monitor the result for pod readiness. We have some custom tooling that does this in gitlab pipelines, relying on kustomize for the yaml-spattering bits. We still do use a lot of our own and third-party helm charts but for us there&#x27;s a clear distinction between installing packages (which tend to be longer-term stable infra things) and rapidly iterating on deployments of our own stuff.</div><br/><div id="38642953" class="c"><input type="checkbox" id="c-38642953" checked=""/><div class="controls bullet"><span class="by">degenerate</span><span>|</span><a href="#38642915">parent</a><span>|</span><a href="#38643966">next</a><span>|</span><label class="collapse" for="c-38642953">[-]</label><label class="expand" for="c-38642953">[5 more]</label></div><br/><div class="children"><div class="content">Any advice&#x2F;ideas&#x2F;articles&#x2F;references on using kustomize efficiently?<p>I love the idea of using a tool bundled with kubectl for zero dependencies, but their examples and tutorials are horrible. I can&#x27;t figure out how to use it correctly to have 1 copy of YAML that would deploy to 5 different environments. It seems I would need multiple copies of kustomization.yaml in multiple folders, if I have multiple namespaces&#x2F;pods&#x2F;etc...</div><br/><div id="38644170" class="c"><input type="checkbox" id="c-38644170" checked=""/><div class="controls bullet"><span class="by">markbnj</span><span>|</span><a href="#38642915">root</a><span>|</span><a href="#38642953">parent</a><span>|</span><a href="#38643434">next</a><span>|</span><label class="collapse" for="c-38644170">[-]</label><label class="expand" for="c-38644170">[2 more]</label></div><br/><div class="children"><div class="content">The model is base yaml with patches applied to it results in final yaml that get sent to the api, so the typical structure for us is to have the base yaml live with the service source, be maintained by the service owners and include all environment-agnostic properties. We then have one folder per targeted environment for that service which includes any patches and the kustomization.yaml manifest. Basically in line with what other replies have mentioned.</div><br/><div id="38645020" class="c"><input type="checkbox" id="c-38645020" checked=""/><div class="controls bullet"><span class="by">degenerate</span><span>|</span><a href="#38642915">root</a><span>|</span><a href="#38644170">parent</a><span>|</span><a href="#38643434">next</a><span>|</span><label class="collapse" for="c-38645020">[-]</label><label class="expand" for="c-38645020">[1 more]</label></div><br/><div class="children"><div class="content">Thanks everyone that replied, I thought I was doing something wrong!</div><br/></div></div></div></div><div id="38643434" class="c"><input type="checkbox" id="c-38643434" checked=""/><div class="controls bullet"><span class="by">leetrout</span><span>|</span><a href="#38642915">root</a><span>|</span><a href="#38642953">parent</a><span>|</span><a href="#38644170">prev</a><span>|</span><a href="#38643485">next</a><span>|</span><label class="collapse" for="c-38643434">[-]</label><label class="expand" for="c-38643434">[1 more]</label></div><br/><div class="children"><div class="content">Not a kustomize expert - but yes, you likely would have a folder for each thing you target.<p>It wasn&#x27;t bad once I got through the docs &#x2F; examples. They just assume so much existing knowledge I didn&#x27;t have.</div><br/></div></div><div id="38643485" class="c"><input type="checkbox" id="c-38643485" checked=""/><div class="controls bullet"><span class="by">Hamuko</span><span>|</span><a href="#38642915">root</a><span>|</span><a href="#38642953">parent</a><span>|</span><a href="#38643434">prev</a><span>|</span><a href="#38643966">next</a><span>|</span><label class="collapse" for="c-38643485">[-]</label><label class="expand" for="c-38643485">[1 more]</label></div><br/><div class="children"><div class="content">We use kustomize with multiple copies of kustomization.yaml and I don&#x27;t know if there is a way to do it without that. Basically, there&#x27;s a base kustomization.yaml and then there&#x27;s test&#x2F;kustomization.yaml, prod1&#x2F;kustomization.yaml, prod2&#x2F;kustomization.yaml, and so on.</div><br/></div></div></div></div></div></div><div id="38643966" class="c"><input type="checkbox" id="c-38643966" checked=""/><div class="controls bullet"><span class="by">galenmarchetti</span><span>|</span><a href="#38642915">prev</a><span>|</span><a href="#38642846">next</a><span>|</span><label class="collapse" for="c-38643966">[-]</label><label class="expand" for="c-38643966">[1 more]</label></div><br/><div class="children"><div class="content">points #3 and #4; &quot;user-friendly helm chart creation&quot; and &quot;values.yaml is an antipattern&quot;...I think we&#x27;re just all stuck in this horrible middle ground between &quot;need static declarative configurations for simplicity of change management&#x2F;fewest chances to mess it up&quot; and &quot;need dynamic, sometimes even imperative logic for flexibility, configurability, and ease of development&quot;<p>several commenters have mentioned Cue&#x2F;Jsonnet&#x2F;friends as great alternatives, others find them limiting &#x2F; prefer pulumi with a general purpose language<p>our solution at kurtosis is another, and tilt.dev took the same route we did...adopt starlark as a balanced middle-ground between general-purpose languages and static configs. you do get the lovely experience of writing in something pythonic, but without the &quot;oops this k8s deployment is not runnable&#x2F;reproducible in other clusters because I had non-deterministic evaluation &#x2F; relied on external, non-portable devices&quot;</div><br/></div></div><div id="38642846" class="c"><input type="checkbox" id="c-38642846" checked=""/><div class="controls bullet"><span class="by">clvx</span><span>|</span><a href="#38643966">prev</a><span>|</span><a href="#38649084">next</a><span>|</span><label class="collapse" for="c-38642846">[-]</label><label class="expand" for="c-38642846">[2 more]</label></div><br/><div class="children"><div class="content">Another one, when you upgrade your cluster and there&#x27;s an API that is candidate for removal, helm doesn&#x27;t have a way to update the Kind reference in their metadata which causes the inability to delete and update the release.<p>I personally like cuelang&#x27;s philosophy but it could become a little messy when you have to iterate and handle user inputs in large codebases.</div><br/><div id="38642860" class="c"><input type="checkbox" id="c-38642860" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#38642846">parent</a><span>|</span><a href="#38649084">next</a><span>|</span><label class="collapse" for="c-38642860">[-]</label><label class="expand" for="c-38642860">[1 more]</label></div><br/><div class="children"><div class="content">Cue&#x2F;Jsonnet&#x2F;friends are definitely the right tools for the job. It&#x27;s a shame they aren&#x27;t more popular.</div><br/></div></div></div></div><div id="38649084" class="c"><input type="checkbox" id="c-38649084" checked=""/><div class="controls bullet"><span class="by">octacat</span><span>|</span><a href="#38642846">prev</a><span>|</span><a href="#38643418">next</a><span>|</span><label class="collapse" for="c-38649084">[-]</label><label class="expand" for="c-38649084">[1 more]</label></div><br/><div class="children"><div class="content">Needed to install pg&#x2F;mysql using helm charts and needed to apply SQL schema.
And passing schema is so complex... (like write it into values file, but you cannot use any logic in values, so have an external script which would template values files). At least for the most popular Helm charts I&#x27;ve seen so far.<p>Kinda sad because it is trivial to do in Docker. And still possible to do in k8s with some configmaps.</div><br/></div></div><div id="38643418" class="c"><input type="checkbox" id="c-38643418" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#38649084">prev</a><span>|</span><a href="#38649057">next</a><span>|</span><label class="collapse" for="c-38643418">[-]</label><label class="expand" for="c-38643418">[6 more]</label></div><br/><div class="children"><div class="content">I got lazy and just wrote scripts that output k8s manifests.<p>The development story is much better (breakpoints! WHAT!?, loops and control flow!?), you can catch common issues quicker by adding tests, there&#x27;s one &quot;serialise&quot; step so you don&#x27;t have to deal with YAML&#x27;s quirks and you can version&#x2F;diff your generated manifests.<p>It&#x27;s dumb, and stupid, but it works and it&#x27;s far less cognitive load.<p>Now: handling <i>mildly dynamic</i> content outside of those generated manifests... that&#x27;s a massive pain, releasing a new version of a container and avoiding to touch the generated manifests: not working for me.</div><br/><div id="38644423" class="c"><input type="checkbox" id="c-38644423" checked=""/><div class="controls bullet"><span class="by">temp_praneshp</span><span>|</span><a href="#38643418">parent</a><span>|</span><a href="#38646400">next</a><span>|</span><label class="collapse" for="c-38644423">[-]</label><label class="expand" for="c-38644423">[1 more]</label></div><br/><div class="children"><div class="content">at my current place, we started off with kustomize. I rewrote everything into helm, which was good initially (at least you can force inject some common params, and others can include this in their charts).<p>But people (including me) were unhappy at yaml reading; I also grew to hate it with a passion because it&#x27;s neither go nor yaml, and super difficult to read in general. We are a typescript company, and <a href="https:&#x2F;&#x2F;cdk8s.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;cdk8s.io&#x2F;</a> has been great for us. We can unit test parts of charts without rendering the whole thing, distribute canonical pod&#x2F;deployment&#x2F;service definitions, etc.<p>In all of the cases, we combined this with config outputted by terraform, for env specific overrides, etc.</div><br/></div></div><div id="38646400" class="c"><input type="checkbox" id="c-38646400" checked=""/><div class="controls bullet"><span class="by">imglorp</span><span>|</span><a href="#38643418">parent</a><span>|</span><a href="#38644423">prev</a><span>|</span><a href="#38643466">next</a><span>|</span><label class="collapse" for="c-38646400">[-]</label><label class="expand" for="c-38646400">[3 more]</label></div><br/><div class="children"><div class="content">Found the workaround confession thread.<p>Because you effectively CAN&#x27;T dynamically configure subcharts with templating that&#x27;s done in your main chart, see eg <a href="https:&#x2F;&#x2F;github.com&#x2F;helm&#x2F;helm&#x2F;pull&#x2F;6876">https:&#x2F;&#x2F;github.com&#x2F;helm&#x2F;helm&#x2F;pull&#x2F;6876</a> here comes the hack.<p>We run helm in helm. The top chart runs post-install and post-upgrade hook job which runs helm in a pod with a lot of permissions. The outer helm creates values override yaml for the subchart into a ConfigMap, using liberal templating, which gets mounted in the helm runner pod. Then helm runs in there with the custom values and does its own thing.<p>Not proud but it lets us do a lot of dynamic things straight helm can&#x27;t.</div><br/><div id="38649120" class="c"><input type="checkbox" id="c-38649120" checked=""/><div class="controls bullet"><span class="by">crabique</span><span>|</span><a href="#38643418">root</a><span>|</span><a href="#38646400">parent</a><span>|</span><a href="#38643466">next</a><span>|</span><label class="collapse" for="c-38649120">[-]</label><label class="expand" for="c-38649120">[2 more]</label></div><br/><div class="children"><div class="content">Have you considered <a href="https:&#x2F;&#x2F;github.com&#x2F;helmfile&#x2F;helmfile">https:&#x2F;&#x2F;github.com&#x2F;helmfile&#x2F;helmfile</a> ? What you described sounds a lot like what Helmfile does, but more terrifying.</div><br/><div id="38649323" class="c"><input type="checkbox" id="c-38649323" checked=""/><div class="controls bullet"><span class="by">imglorp</span><span>|</span><a href="#38643418">root</a><span>|</span><a href="#38649120">parent</a><span>|</span><a href="#38643466">next</a><span>|</span><label class="collapse" for="c-38649323">[-]</label><label class="expand" for="c-38649323">[1 more]</label></div><br/><div class="children"><div class="content">Yes the hack is gross and yes I would love to use Helmfile. But our use case is to fit into customers&#x27; helm processes, eg ArgoCD et al.</div><br/></div></div></div></div></div></div><div id="38643466" class="c"><input type="checkbox" id="c-38643466" checked=""/><div class="controls bullet"><span class="by">leetrout</span><span>|</span><a href="#38643418">parent</a><span>|</span><a href="#38646400">prev</a><span>|</span><a href="#38649057">next</a><span>|</span><label class="collapse" for="c-38643466">[-]</label><label class="expand" for="c-38643466">[1 more]</label></div><br/><div class="children"><div class="content">I do the same with Terraform sometimes.<p>I appreciate that TF has loops and dynamic blocks, etc etc, but sometimes it&#x27;s just a lot easier to look at a Jinja2 template and run a script to generate the TF.</div><br/></div></div></div></div><div id="38649057" class="c"><input type="checkbox" id="c-38649057" checked=""/><div class="controls bullet"><span class="by">gtsteve</span><span>|</span><a href="#38643418">prev</a><span>|</span><a href="#38643712">next</a><span>|</span><label class="collapse" for="c-38649057">[-]</label><label class="expand" for="c-38649057">[6 more]</label></div><br/><div class="children"><div class="content">This is relevant to a discussion I am having at work right now. I am not a fan of using a templating language as such to generate string templates, especially for a whitespace sensitive language.<p>I would rather use Terraform&#x27;s Kubernetes or Kubectl module for this. Are there any pros or cons I should consider?<p>I think one of the key things I like about it is that Terraform will show me what it plans to change whereas Helm doesn&#x27;t (last time I checked)</div><br/><div id="38651600" class="c"><input type="checkbox" id="c-38651600" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#38649057">parent</a><span>|</span><a href="#38649371">next</a><span>|</span><label class="collapse" for="c-38651600">[-]</label><label class="expand" for="c-38651600">[1 more]</label></div><br/><div class="children"><div class="content">Cons: The provider tries to manage its own state, as terraform normally does. This makes it slow to diff and the state often get out of sync with what is really in k8s. When it does, it fails loading the manifest during diff phase, so you can’t apply, even if all you want is to overwrite.<p>The diffs are very noisy to read because they show every possible attribute, even those you didn’t write.<p>The ready-made resources can some times be a bit behind on versions but you also have a raw manifest resource as an escape hatch if you depend on bleeding edge<p>Pros: The templating capabilities are fantastic, because it leverages terraform. Bye bye string templates. This also makes it easy to use values from other data sources.<p>In conclusion, it’s good but not great.</div><br/></div></div><div id="38649371" class="c"><input type="checkbox" id="c-38649371" checked=""/><div class="controls bullet"><span class="by">willejs</span><span>|</span><a href="#38649057">parent</a><span>|</span><a href="#38651600">prev</a><span>|</span><a href="#38649143">next</a><span>|</span><label class="collapse" for="c-38649371">[-]</label><label class="expand" for="c-38649371">[1 more]</label></div><br/><div class="children"><div class="content">The kubernetes provider, and kubectl works, but its not the nicest way of making changes. Its slow, quite clunky, and its not particularly intuitive. If your just getting started, and you know terraform its ok though. Its useful to bootstrap gitops tools like Argo or FluxCD though.<p>Helm diff will show you a similar diff to terraform. Running Helmfile in CD isn&#x27;t a bad move, its really simple, and its a pattern that is easy to grok by any engineer. I think this is still a valid approach in a simple setup, its what some people call &quot;CD OPS&quot;. It&#x27;s a push model instead of pull, and there are downsides, but its not the end of the world.<p>Ultimately, at scale, i think gitops tooling like Flux and ArgoCD are some of the nicest patterns. Especially Flux&#x27;s support for OCI artifacts as a source of truth. However then you will venture into the realm of kustomize, and much more complex tooling and concepts, which is not always worth doing.</div><br/></div></div><div id="38649143" class="c"><input type="checkbox" id="c-38649143" checked=""/><div class="controls bullet"><span class="by">noamchomsky1</span><span>|</span><a href="#38649057">parent</a><span>|</span><a href="#38649371">prev</a><span>|</span><a href="#38643712">next</a><span>|</span><label class="collapse" for="c-38649143">[-]</label><label class="expand" for="c-38649143">[3 more]</label></div><br/><div class="children"><div class="content">it&#x27;s a horrible experience with terraform too.</div><br/><div id="38649739" class="c"><input type="checkbox" id="c-38649739" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#38649057">root</a><span>|</span><a href="#38649143">parent</a><span>|</span><a href="#38649692">next</a><span>|</span><label class="collapse" for="c-38649739">[-]</label><label class="expand" for="c-38649739">[1 more]</label></div><br/><div class="children"><div class="content">every time I hear someone suggest such a thing, I remind them that now you have <i>two</i> systems who believe they own the state of the world: .tfstate and etcd and let me assure you that no matter how much our dumbass TF friend thinks it knows what&#x27;s going on, etcd wins hands down every time<p>that&#x27;s why I strongly suggest that if anyone is a &quot;whole TF shop,&quot; they go the operator route, because trying any lower level management is the road to ruin</div><br/></div></div><div id="38649692" class="c"><input type="checkbox" id="c-38649692" checked=""/><div class="controls bullet"><span class="by">gtsteve</span><span>|</span><a href="#38649057">root</a><span>|</span><a href="#38649143">parent</a><span>|</span><a href="#38649739">prev</a><span>|</span><a href="#38643712">next</a><span>|</span><label class="collapse" for="c-38649692">[-]</label><label class="expand" for="c-38649692">[1 more]</label></div><br/><div class="children"><div class="content">Do tell?</div><br/></div></div></div></div></div></div><div id="38643712" class="c"><input type="checkbox" id="c-38643712" checked=""/><div class="controls bullet"><span class="by">btown</span><span>|</span><a href="#38649057">prev</a><span>|</span><a href="#38643539">next</a><span>|</span><label class="collapse" for="c-38643712">[-]</label><label class="expand" for="c-38643712">[1 more]</label></div><br/><div class="children"><div class="content">On top of what the OP mentions, Helm still doesn&#x27;t have a way to forward logs from its pre&#x2F;post-install hooks to the system calling helm upgrade (such as a Github Action) - a feature first requested in 2017 and still stuck in RFC stage.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;helm&#x2F;helm&#x2F;issues&#x2F;2298">https:&#x2F;&#x2F;github.com&#x2F;helm&#x2F;helm&#x2F;issues&#x2F;2298</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;helm&#x2F;helm&#x2F;pull&#x2F;10309">https:&#x2F;&#x2F;github.com&#x2F;helm&#x2F;helm&#x2F;pull&#x2F;10309</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;helm&#x2F;community&#x2F;pull&#x2F;301">https:&#x2F;&#x2F;github.com&#x2F;helm&#x2F;community&#x2F;pull&#x2F;301</a><p>I can understand moving cautiously, but it&#x27;s at a point where it almost feels like allowing users to understand what Helm is doing seems not to be a priority for Helm&#x27;s developers.</div><br/></div></div><div id="38643539" class="c"><input type="checkbox" id="c-38643539" checked=""/><div class="controls bullet"><span class="by">francoismassot</span><span>|</span><a href="#38643712">prev</a><span>|</span><a href="#38643030">next</a><span>|</span><label class="collapse" for="c-38643539">[-]</label><label class="expand" for="c-38643539">[1 more]</label></div><br/><div class="children"><div class="content">While I really enjoy helm when playing with k8s or kickstarting projects, I never feel &quot;safe&quot; when using it in the long run for updates&#x2F;upgrades.
&quot;values.yaml&quot; files and templating YAML files are too error-prone...</div><br/></div></div><div id="38643030" class="c"><input type="checkbox" id="c-38643030" checked=""/><div class="controls bullet"><span class="by">LittleChimera</span><span>|</span><a href="#38643539">prev</a><span>|</span><a href="#38643572">next</a><span>|</span><label class="collapse" for="c-38643030">[-]</label><label class="expand" for="c-38643030">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a good list, although I think there&#x27;s more to it even. I wrote a bit more about helm design a while ago [0]. Nowadays, I use Helm from kustomize quite a lot because some projects don&#x27;t provide any other way of deploying. However, you still need to check what helm is actually generating, especially if there&#x27;s any hooks that need to be replaced with something declarative.<p>[0]: <a href="https:&#x2F;&#x2F;littlechimera.com&#x2F;posts&#x2F;helm-design&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;littlechimera.com&#x2F;posts&#x2F;helm-design&#x2F;</a></div><br/></div></div><div id="38643572" class="c"><input type="checkbox" id="c-38643572" checked=""/><div class="controls bullet"><span class="by">jimbobimbo</span><span>|</span><a href="#38643030">prev</a><span>|</span><a href="#38648747">next</a><span>|</span><label class="collapse" for="c-38643572">[-]</label><label class="expand" for="c-38643572">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not buying the example of using the operator to figure out things dynamically. Especially that detection of the cloud in the example is done by looking at some random labels or other attributes specific to a cloud provider.<p>This is what values and templates are for: no need to guess where you are deployed, I&#x27;ll tell you that via values, template will make sense and adjustments of how resources will look like.</div><br/></div></div><div id="38648747" class="c"><input type="checkbox" id="c-38648747" checked=""/><div class="controls bullet"><span class="by">brainzap</span><span>|</span><a href="#38643572">prev</a><span>|</span><a href="#38643255">next</a><span>|</span><label class="collapse" for="c-38648747">[-]</label><label class="expand" for="c-38648747">[1 more]</label></div><br/><div class="children"><div class="content">we use helm to deploy our apps and it works. Actually to be honest the templates are generated and then deployed from disk, without uploading a chart. We try to avoid the template language.<p>What Helm can&#x27;t do currently is handle Ingress renames, and they do not allow loading files that are outside the chart.</div><br/></div></div><div id="38643255" class="c"><input type="checkbox" id="c-38643255" checked=""/><div class="controls bullet"><span class="by">cortesoft</span><span>|</span><a href="#38648747">prev</a><span>|</span><a href="#38643322">next</a><span>|</span><label class="collapse" for="c-38643255">[-]</label><label class="expand" for="c-38643255">[3 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t the last point wrong? You can query the kubernetes environment in your templates to customize the output based on cluster specific things</div><br/><div id="38643574" class="c"><input type="checkbox" id="c-38643574" checked=""/><div class="controls bullet"><span class="by">BossingAround</span><span>|</span><a href="#38643255">parent</a><span>|</span><a href="#38643322">next</a><span>|</span><label class="collapse" for="c-38643574">[-]</label><label class="expand" for="c-38643574">[2 more]</label></div><br/><div class="children"><div class="content">The point isn&#x27;t that you can never query the API, but that you can&#x27;t really use helm chart as a controller (and, e.g. restart a pod under a certain condition, which is trivial for an operator).</div><br/><div id="38644269" class="c"><input type="checkbox" id="c-38644269" checked=""/><div class="controls bullet"><span class="by">cortesoft</span><span>|</span><a href="#38643255">root</a><span>|</span><a href="#38643574">parent</a><span>|</span><a href="#38643322">next</a><span>|</span><label class="collapse" for="c-38644269">[-]</label><label class="expand" for="c-38644269">[1 more]</label></div><br/><div class="children"><div class="content">Oh... why wouldn&#x27;t you just write an operator then? Seems like a different requirement.</div><br/></div></div></div></div></div></div><div id="38643322" class="c"><input type="checkbox" id="c-38643322" checked=""/><div class="controls bullet"><span class="by">renlo</span><span>|</span><a href="#38643255">prev</a><span>|</span><a href="#38642865">next</a><span>|</span><label class="collapse" for="c-38643322">[-]</label><label class="expand" for="c-38643322">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;archive.is&#x2F;grNy4" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.is&#x2F;grNy4</a></div><br/></div></div><div id="38642865" class="c"><input type="checkbox" id="c-38642865" checked=""/><div class="controls bullet"><span class="by">notnmeyer</span><span>|</span><a href="#38643322">prev</a><span>|</span><a href="#38647204">next</a><span>|</span><label class="collapse" for="c-38642865">[-]</label><label class="expand" for="c-38642865">[1 more]</label></div><br/><div class="children"><div class="content">i generally don&#x27;t mind helm but im not sure i agree with every point. for the really simple stateless app situation, its trivial to create a chart with all the important or unique bits extracted to a values file.<p>the crd shit is borderline untenable. i learned about it during an absolutely cursed calico upgrade. oops.<p>since kustomize integrates tightly with kubectl these days though, i just use that for new things.<p>i want fewer, simpler tools.</div><br/></div></div><div id="38647204" class="c"><input type="checkbox" id="c-38647204" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#38642865">prev</a><span>|</span><label class="collapse" for="c-38647204">[-]</label><label class="expand" for="c-38647204">[1 more]</label></div><br/><div class="children"><div class="content">A few years I go I tried out an alternative approach to &quot;templating&quot;.<p>Basically the idea starts from a world without templates where you would distribute the k8s YAML in a form that is ready to be directly applied, with whatever sensible defaults you want directly present in the YAML<p>The the user would then just change the values in their copy of the file to suit their needs and apply that.<p>We all recoil in horror to such a thought, but let&#x27;s stop a moment to think about why we do:<p>The user effectively &quot;forked&quot; the YAML by placing their values there and what a nightmare would that be once the user would get a new version of the upstream file, potentially completely overhauled .<p>If the changes are very small, a simple three way merge like you&#x27;d do with git would suffice to handle that. But what about larger changes?<p>Most of the conflicts in the simple cases stem from the fact that text based diff&#x2F;merge tools are oblivious to the structure of the YAML file and can only so a so-so job with many of the changes. Unfortunately most people are familiar only with text based merge tools and so they have been primed the hard way to assume that the merges only rarely work.<p>Structural merges otoh so work much much better. But still if the upstream refractors the application in a significant way (e.g. changes a deployment into a stateful set or moves pieces of config from a configmap into a secret!) not even a structural merge can save you.<p>My idea was to bring the manifest author into play and make them &quot;annotate&quot; the pieces of the manifest forest that contain configuration that has a high level meaning to the application 
and that would be moved around in the YAML forest as it gets reshaped.<p>Another realization was that often such configuration snippets are deeply embedded in other internal &quot;languages&quot; wrapped inside string fields, subject to escaping and encodings (e.g. base64). E.g. a JSON snippet inside a TOML string value inside # base64 encoded annotation value (if you haven&#x27;t seen these abominations I&#x27;m so happy for you you innocent child)<p>So I implemented a tool that uses neated bidirectional parsers (&quot;lenses&quot;) that can perform in-place editing of structured files. The edits preserve formatting, comments, quoting styles, etc.<p>Even steing fields that are normally thought of as just strings are actually better though if as nested &quot;formats&quot;. For example the OCI image references are composed of multiple parts. If you want to just copy images to your private registry and &quot;rebase&quot; all you image references to the new base, you can do it with an update that understands the format of the OCI image references instead of just doing substring replacement.<p>Knot8 is an opinionated tool meant to help manifest authors and users manage setting&#x2F;diffing&#x2F;pulling annotated YAML k8s manifest packages<p><a href="https:&#x2F;&#x2F;github.com&#x2F;mkmik&#x2F;knot8">https:&#x2F;&#x2F;github.com&#x2F;mkmik&#x2F;knot8</a><p>I didn&#x27;t have the time to evangelize this approach much so it didn&#x27;t get any traction (and perhaps it would because it doesn&#x27;t have enough merits). But I encourage to give it a go. It might inspire you<p>I also pulled out the &quot;lens&quot; mechanism in a separate binary in case it could be useful to edit general purpose files:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;kubecfg&#x2F;lensed">https:&#x2F;&#x2F;github.com&#x2F;kubecfg&#x2F;lensed</a></div><br/></div></div></div></div></div></div></div></body></html>