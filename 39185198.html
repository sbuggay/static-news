<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706605256471" as="style"/><link rel="stylesheet" href="styles.css?v=1706605256471"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.quantamagazine.org/researchers-approach-new-speed-limit-for-seminal-problem-20240129/">Researchers have found a faster way to do integer linear programming</a> <span class="domain">(<a href="https://www.quantamagazine.org">www.quantamagazine.org</a>)</span></div><div class="subtext"><span>pseudolus</span> | <span>96 comments</span></div><br/><div><div id="39187843" class="c"><input type="checkbox" id="c-39187843" checked=""/><div class="controls bullet"><span class="by">mzl</span><span>|</span><a href="#39185828">next</a><span>|</span><label class="collapse" for="c-39187843">[-]</label><label class="expand" for="c-39187843">[1 more]</label></div><br/><div class="children"><div class="content">Lowering the algorithmic upper bound for a core NP-complete problem is always extremely interesting. However, this is not necessarily  related to improving runtime for practical implementations solving the problem in question.<p>Solvers for mixed integer programming (MIP) use a lot of algorithms in conjunction with loads of heuristics. Building up the library of heuristics and strategies is a crucial part of why the improvement in MIP solvers have outpaced Moores law. From <a href="https:&#x2F;&#x2F;www.math.uwaterloo.ca&#x2F;~hwolkowi&#x2F;henry&#x2F;teaching&#x2F;f16&#x2F;602.f16&#x2F;602miscfiles&#x2F;UF_Entrepreneurship_19November2014.pdf" rel="nofollow">https:&#x2F;&#x2F;www.math.uwaterloo.ca&#x2F;~hwolkowi&#x2F;henry&#x2F;teaching&#x2F;f16&#x2F;6...</a>, the improvements in hardware from 1990 to 2014 was 6500x. But the improvements to the software are responsible for 870000x performance improvement.<p>The referenced article may become another part of the puzzle in continuing performance improvements for MIP solvers, but it is not in any way a given.</div><br/></div></div><div id="39185828" class="c"><input type="checkbox" id="c-39185828" checked=""/><div class="controls bullet"><span class="by">nkh</span><span>|</span><a href="#39187843">prev</a><span>|</span><a href="#39185851">next</a><span>|</span><label class="collapse" for="c-39185828">[-]</label><label class="expand" for="c-39185828">[31 more]</label></div><br/><div class="children"><div class="content"><i>For now, the new algorithm hasn’t actually been used to solve any logistical problems, since it would take too much work updating today’s programs to make use of it. But for Rothvoss, that’s beside the point. “It’s about the theoretical understanding of a problem that has fundamental applications,” he said.</i><p>I don&#x27;t see how &quot;it would take to much work updating today&#x27;s programs&quot;.  Most domain specific models call out to Gurobi, CPLEX, or FICO solvers for large problems, and open source ones like SCIP for the small ones.  There is a standard MPS format where you can run exchange models between all of these solvers, and the formulation of the problem shouldn&#x27;t change, just the solving approach inside the solver.<p>Can someone enlighten me?  I could see if they are arguing, this will require a new implementation, and if so, there is a ton of benefit the world would see from doing so.</div><br/><div id="39187767" class="c"><input type="checkbox" id="c-39187767" checked=""/><div class="controls bullet"><span class="by">__alexs</span><span>|</span><a href="#39185828">parent</a><span>|</span><a href="#39185903">next</a><span>|</span><label class="collapse" for="c-39187767">[-]</label><label class="expand" for="c-39187767">[1 more]</label></div><br/><div class="children"><div class="content">The open source solvers are a mess of 30 years of PhD students random contributions. It&#x27;s amazing they work at all. If you can possibly avoid actually implementing anything using them you will.</div><br/></div></div><div id="39185903" class="c"><input type="checkbox" id="c-39185903" checked=""/><div class="controls bullet"><span class="by">math_dandy</span><span>|</span><a href="#39185828">parent</a><span>|</span><a href="#39187767">prev</a><span>|</span><a href="#39187220">next</a><span>|</span><label class="collapse" for="c-39185903">[-]</label><label class="expand" for="c-39185903">[18 more]</label></div><br/><div class="children"><div class="content">The new algorithm of R&amp;R would need to replace the algorithms at the core of Gurobi, CPlex, etc. These tools are marvels of engineering, extremely complex, results of decades of incremental improvements. If would likely take significant research effort to even figure out a way to incorporate the new discoveries into these engines.</div><br/><div id="39185953" class="c"><input type="checkbox" id="c-39185953" checked=""/><div class="controls bullet"><span class="by">nkh</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39185903">parent</a><span>|</span><a href="#39187194">next</a><span>|</span><label class="collapse" for="c-39185953">[-]</label><label class="expand" for="c-39185953">[10 more]</label></div><br/><div class="children"><div class="content">Why would it need to replace them?  From the article, they claim they have found a way to reduce the upperbound faster when searching large Integer problems.  I don&#x27;t see how that effects the current searching process.  All of these solvers you can enter in an upperbound yourself if you have knowledge of the problem and know a previous solution.  So it seems if this is just a programmatic way of reducing the upper bound, it should fit right in with current approaches.  What am I missing?</div><br/><div id="39186028" class="c"><input type="checkbox" id="c-39186028" checked=""/><div class="controls bullet"><span class="by">whatyesaid</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39185953">parent</a><span>|</span><a href="#39187341">next</a><span>|</span><label class="collapse" for="c-39186028">[-]</label><label class="expand" for="c-39186028">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a research paper. You can write a theoretical paper and let others apply it practically, which others can figure out the practical aspect and report results of benchmarks, or others can also build on the theory.<p>This paper only has 2 authors. The other solvers are probably applying technique specific tricks and speedups, and you&#x27;re working with approximate optimization, it&#x27;s not that easy to move everything over.</div><br/><div id="39186431" class="c"><input type="checkbox" id="c-39186431" checked=""/><div class="controls bullet"><span class="by">hdesh</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39186028">parent</a><span>|</span><a href="#39187341">next</a><span>|</span><label class="collapse" for="c-39186431">[-]</label><label class="expand" for="c-39186431">[4 more]</label></div><br/><div class="children"><div class="content">&gt; This paper only has 2 authors.<p>So? I don&#x27;t get the relevance of the author count.</div><br/><div id="39186500" class="c"><input type="checkbox" id="c-39186500" checked=""/><div class="controls bullet"><span class="by">black_puppydog</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39186431">parent</a><span>|</span><a href="#39187341">next</a><span>|</span><label class="collapse" for="c-39186500">[-]</label><label class="expand" for="c-39186500">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s quite easy to go tell other people what they should do with their time.<p>These researchers are in the business of improving algorithms. Implementing them in large industrial (or open source) code bases in a maintainable way -- and then actually maintaining that code -- is a different skillset, a different set of interestes, and as was pointed out, besides the point.<p>Either you believe their results, then be grateful. Someone (yoU!) can implement this.
Or you don&#x27;t. In which case, feel free to move on.<p>Your tone comes off as entitled.</div><br/><div id="39187003" class="c"><input type="checkbox" id="c-39187003" checked=""/><div class="controls bullet"><span class="by">bnegreve</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39186500">parent</a><span>|</span><a href="#39187233">next</a><span>|</span><label class="collapse" for="c-39187003">[-]</label><label class="expand" for="c-39187003">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Implementing them in large industrial (or open source) code bases in a maintainable way -- and then actually maintaining that code -- is a different skillset, a different set of interestes,<p>You&#x27;re making a very general point on how algorithm research and software development are two different things, which is of course true. However OP&#x27;s question is genuine: a lot of research in OR is very practical, and researchers often hack solvers to demonstrate that whatever idea offers a benefit over existing solving techniques. There are no reason to believe that a good new idea like this one couldn&#x27;t be demonstrated and incorporated into new solvers quickly (especially given the competition).<p>So the quoted sentence is indeed a bit mysterious. I think it just meant to avoid comment such as &quot;if it&#x27;s so good why isn&#x27;t it used in cplex?&quot;.</div><br/></div></div><div id="39187233" class="c"><input type="checkbox" id="c-39187233" checked=""/><div class="controls bullet"><span class="by">imtringued</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39186500">parent</a><span>|</span><a href="#39187003">prev</a><span>|</span><a href="#39187341">next</a><span>|</span><label class="collapse" for="c-39187233">[-]</label><label class="expand" for="c-39187233">[1 more]</label></div><br/><div class="children"><div class="content">&gt;business of improving algorithms<p>You do realize that the solver companies are in exactly the same boat, right?</div><br/></div></div></div></div></div></div></div></div><div id="39187341" class="c"><input type="checkbox" id="c-39187341" checked=""/><div class="controls bullet"><span class="by">unnah</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39185953">parent</a><span>|</span><a href="#39186028">prev</a><span>|</span><a href="#39186055">next</a><span>|</span><label class="collapse" for="c-39187341">[-]</label><label class="expand" for="c-39187341">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think they&#x27;re talking about a bound for the optimum objective value, but a theoretical upper bound for a covering radius related to a convex body and a lattice. The bound would be useful in a lattice-based algorithm for integer linear programming. I don&#x27;t think there exists an implementation of a lattice algorithm that is practical for non-toy integer linear programming problems, let alone one that is competitive with commercial ILP solvers.</div><br/></div></div><div id="39186055" class="c"><input type="checkbox" id="c-39186055" checked=""/><div class="controls bullet"><span class="by">math_dandy</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39185953">parent</a><span>|</span><a href="#39187341">prev</a><span>|</span><a href="#39187596">next</a><span>|</span><label class="collapse" for="c-39186055">[-]</label><label class="expand" for="c-39186055">[2 more]</label></div><br/><div class="children"><div class="content">Every time an integer feasible point is found during the iterative process these algorithms use (branch and bound), you get a new upper bound on the global minimum. It’s not clear to me how these dynamically generated upper bounds highly specific to the particular problem relate to the upper bounds of a more general nature that R&amp;R produce.</div><br/><div id="39186446" class="c"><input type="checkbox" id="c-39186446" checked=""/><div class="controls bullet"><span class="by">nkh</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39186055">parent</a><span>|</span><a href="#39187596">next</a><span>|</span><label class="collapse" for="c-39186446">[-]</label><label class="expand" for="c-39186446">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>upper bounds of a more general nature that R&amp;R produce</i><p>If it&#x27;s an upper bound, it should be pretty easy to plug into the existing stuff under the hood in these solvers.  Can you provide my insight into how the R&amp;R &quot;Upper bound&quot; is different and &quot;more general in nature&quot;?</div><br/></div></div></div></div><div id="39187596" class="c"><input type="checkbox" id="c-39187596" checked=""/><div class="controls bullet"><span class="by">raverbashing</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39185953">parent</a><span>|</span><a href="#39186055">prev</a><span>|</span><a href="#39187194">next</a><span>|</span><label class="collapse" for="c-39187596">[-]</label><label class="expand" for="c-39187596">[1 more]</label></div><br/><div class="children"><div class="content">Honestly?<p>The search for the &#x27;exactly optimal solution&#x27; is way overrated<p>I think you can get a moderately efficient solution using heuristics at 1&#x2F;10 of the time or less<p>Not to mention developer time and trying to figure out which constraints make your problem infeasible. Especially as they get more complicated because you want to make everything linear</div><br/></div></div></div></div><div id="39187194" class="c"><input type="checkbox" id="c-39187194" checked=""/><div class="controls bullet"><span class="by">imtringued</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39185903">parent</a><span>|</span><a href="#39185953">prev</a><span>|</span><a href="#39186282">next</a><span>|</span><label class="collapse" for="c-39187194">[-]</label><label class="expand" for="c-39187194">[1 more]</label></div><br/><div class="children"><div class="content">These solvers get faster every year, how exactly are they supposed to stay the world&#x27;s fastest if people invent better algorithms all the time that never get implemented by the commercial offerings?</div><br/></div></div><div id="39186282" class="c"><input type="checkbox" id="c-39186282" checked=""/><div class="controls bullet"><span class="by">FwarkALark</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39185903">parent</a><span>|</span><a href="#39187194">prev</a><span>|</span><a href="#39187220">next</a><span>|</span><label class="collapse" for="c-39186282">[-]</label><label class="expand" for="c-39186282">[6 more]</label></div><br/><div class="children"><div class="content">&gt; If would likely take significant research effort to even figure out a way to incorporate the new discoveries into these engines.<p>What? Have you ever used a solver before? The actual APIs exposed to the user are very simple interfaces that should allow swapping out the backend regardless of the complexity. The idea a new algorithm—short of something like &quot;updating the solution to adjust to a change in data&quot;—would not require any sort of research to slot in as an implementation for the existing interface.</div><br/><div id="39186358" class="c"><input type="checkbox" id="c-39186358" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39186282">parent</a><span>|</span><a href="#39187220">next</a><span>|</span><label class="collapse" for="c-39186358">[-]</label><label class="expand" for="c-39186358">[5 more]</label></div><br/><div class="children"><div class="content">the interface is simple, but modern solvers apply a ton of heuristics that often dramatically reduce problem size, so a naive implementation of a better algorithm that isn&#x27;t hooked deeply into the core of an existing ilp solver is likely to be very slow</div><br/><div id="39187098" class="c"><input type="checkbox" id="c-39187098" checked=""/><div class="controls bullet"><span class="by">FwarkALark</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39186358">parent</a><span>|</span><a href="#39186370">next</a><span>|</span><label class="collapse" for="c-39187098">[-]</label><label class="expand" for="c-39187098">[3 more]</label></div><br/><div class="children"><div class="content">Why is this exposed to the user? If it isn&#x27;t exposed to the user, what on earth are you talking about?</div><br/><div id="39187562" class="c"><input type="checkbox" id="c-39187562" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39187098">parent</a><span>|</span><a href="#39187188">next</a><span>|</span><label class="collapse" for="c-39187562">[-]</label><label class="expand" for="c-39187562">[1 more]</label></div><br/><div class="children"><div class="content">Why would the API expose the heuristics to the user? Because an intelligent user can make minor adjustments and turn certain features on&#x2F;off to sometimes dramatically increase performance depending on the problem.</div><br/></div></div><div id="39187188" class="c"><input type="checkbox" id="c-39187188" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39187098">parent</a><span>|</span><a href="#39187562">prev</a><span>|</span><a href="#39186370">next</a><span>|</span><label class="collapse" for="c-39187188">[-]</label><label class="expand" for="c-39187188">[1 more]</label></div><br/><div class="children"><div class="content">From what I gather the parent post is saying that it is easy to make a naive implementation of this improvement, but due to naivety of the implementation it will be slower in practice. Hence it is a lot of work (and thus difficult) to actually put this improvement into practice.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39187220" class="c"><input type="checkbox" id="c-39187220" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#39185828">parent</a><span>|</span><a href="#39185903">prev</a><span>|</span><a href="#39186108">next</a><span>|</span><label class="collapse" for="c-39187220">[-]</label><label class="expand" for="c-39187220">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t see how &quot;it would take to much work updating today&#x27;s programs&quot;.<p>I think some peeps are not reading this sentence the way you meant it to be read.<p>It seems to me you meant &quot;I don&#x27;t know what part of this research makes it especially hard to integrate into current solvers (and I would like to understand) &quot;.<p>But people seem to be interpreting &quot;why didn&#x27;t they just integrate this into existing solvers? Should be easy (what lazy authors)&quot;.<p>Just trying to clear up some misunderstanding.</div><br/></div></div><div id="39186108" class="c"><input type="checkbox" id="c-39186108" checked=""/><div class="controls bullet"><span class="by">npalli</span><span>|</span><a href="#39185828">parent</a><span>|</span><a href="#39187220">prev</a><span>|</span><a href="#39186925">next</a><span>|</span><label class="collapse" for="c-39186108">[-]</label><label class="expand" for="c-39186108">[8 more]</label></div><br/><div class="children"><div class="content">You seem to be confusing problem formulation with the problem solution. It is true there is a standard way to exchange the problem formulation through something like MPS (though it seems AML&#x27;s like AMPL etc. have taken over). All this format gives you is a standard mathematical formulation of the problem.<p>However, the solution is something very specific to the individual solver and they have their own data structures, algorithms and heuristic techniques to solve the problem. None of these are interchangeable or public (by design) and you cannot just insert some outside numbers in the middle of the solver process without being part of the solver code and having knowledge of the entire process.</div><br/><div id="39186333" class="c"><input type="checkbox" id="c-39186333" checked=""/><div class="controls bullet"><span class="by">nkh</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39186108">parent</a><span>|</span><a href="#39187572">next</a><span>|</span><label class="collapse" for="c-39186333">[-]</label><label class="expand" for="c-39186333">[4 more]</label></div><br/><div class="children"><div class="content">All these solvers use branch and bound to explore the solution space and &quot;fathom&quot; (i.e. eliminate candidate search trees if the lowest possible value for the tree is above an already found solution).  The upper bound that the solver calculates via pre-solve heuristics and other techniques does vary from solver to solver.  However, they all have a place for &quot;Upper bound&quot;, and there are mechanisms in all of these solvers for updating that value in a current solve.<p>If this paper were a complementally orthogonal implementation from everything that exists in these solvers today, if it can produce a new upper bound, faster than other techniques, it should be fairly plug and play.<p>I have an undergrad OR degree, and I have been a practitioner for 18 years in LP&#x2F;MIP problems.  So I understand the current capacities of these solvers, and have familiarity with these problems.  However, I and am out of my depth trying to understand the specifics of this paper, and would love to be corrected where I am missing something.</div><br/><div id="39187619" class="c"><input type="checkbox" id="c-39187619" checked=""/><div class="controls bullet"><span class="by">Aaronmacaron</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39186333">parent</a><span>|</span><a href="#39187572">next</a><span>|</span><label class="collapse" for="c-39187619">[-]</label><label class="expand" for="c-39187619">[3 more]</label></div><br/><div class="children"><div class="content">What is OR?</div><br/><div id="39187659" class="c"><input type="checkbox" id="c-39187659" checked=""/><div class="controls bullet"><span class="by">aix1</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39187619">parent</a><span>|</span><a href="#39187674">prev</a><span>|</span><a href="#39187572">next</a><span>|</span><label class="collapse" for="c-39187659">[-]</label><label class="expand" for="c-39187659">[1 more]</label></div><br/><div class="children"><div class="content">Operations Research: <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Operations_research" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Operations_research</a></div><br/></div></div></div></div></div></div><div id="39187572" class="c"><input type="checkbox" id="c-39187572" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39186108">parent</a><span>|</span><a href="#39186333">prev</a><span>|</span><a href="#39187155">next</a><span>|</span><label class="collapse" for="c-39187572">[-]</label><label class="expand" for="c-39187572">[1 more]</label></div><br/><div class="children"><div class="content">The math programming languages of AMPL, AIMMS, GAMS...etc are dying in my industry and being replaced by general industry languages like Python&#x2F;Java + Solver API.</div><br/></div></div><div id="39187155" class="c"><input type="checkbox" id="c-39187155" checked=""/><div class="controls bullet"><span class="by">mulmboy</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39186108">parent</a><span>|</span><a href="#39187572">prev</a><span>|</span><a href="#39186163">next</a><span>|</span><label class="collapse" for="c-39187155">[-]</label><label class="expand" for="c-39187155">[1 more]</label></div><br/><div class="children"><div class="content">In many cases you can actually insert outside numbers in the middle of the solver process via callbacks. For example see IncumbentUpdater at <a href="https:&#x2F;&#x2F;python-mip.readthedocs.io&#x2F;en&#x2F;latest&#x2F;classes.html" rel="nofollow">https:&#x2F;&#x2F;python-mip.readthedocs.io&#x2F;en&#x2F;latest&#x2F;classes.html</a><p>And various C APIs for solvers have other callbacks<p>It&#x27;s generally quite limited of course, for the reasons you mentioned.</div><br/></div></div><div id="39186163" class="c"><input type="checkbox" id="c-39186163" checked=""/><div class="controls bullet"><span class="by">soperj</span><span>|</span><a href="#39185828">root</a><span>|</span><a href="#39186108">parent</a><span>|</span><a href="#39187155">prev</a><span>|</span><a href="#39186925">next</a><span>|</span><label class="collapse" for="c-39186163">[-]</label><label class="expand" for="c-39186163">[1 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t the &quot;open source ones like SCIP for the small ones.&quot; be public by design?</div><br/></div></div></div></div><div id="39186925" class="c"><input type="checkbox" id="c-39186925" checked=""/><div class="controls bullet"><span class="by">laserbeam</span><span>|</span><a href="#39185828">parent</a><span>|</span><a href="#39186108">prev</a><span>|</span><a href="#39187561">next</a><span>|</span><label class="collapse" for="c-39186925">[-]</label><label class="expand" for="c-39186925">[1 more]</label></div><br/><div class="children"><div class="content">I honestly think that&#x27;s just journalism for &quot;no one implemented it in production yet&quot;. Which is not surprising, for an algorithm less than a year old. I don&#x27;t think it&#x27;s worth expanding and explaining &quot;too much work&quot;.<p>That being said, sometimes if an algorithm isn&#x27;t the fastest but it&#x27;s fast and cheap enough, it is hard to argue to spend money on replacing it. Which just means that will happen later.<p>Furthermore, you might not even see improvements until you implement an optimized verision of a new algorithm. Even if big O notation says it scales better... The old version may be optimized to use memory efficiently, to make good use of SIMD or other low level techniques. Sometimes getting an optimized implementation of a new algorithm takes time.</div><br/></div></div><div id="39187561" class="c"><input type="checkbox" id="c-39187561" checked=""/><div class="controls bullet"><span class="by">xkcd386</span><span>|</span><a href="#39185828">parent</a><span>|</span><a href="#39186925">prev</a><span>|</span><a href="#39185851">next</a><span>|</span><label class="collapse" for="c-39187561">[-]</label><label class="expand" for="c-39187561">[1 more]</label></div><br/><div class="children"><div class="content">The randomized algorithm that Reis &amp; Rothvoss [1] present at the end of their paper will not be implemented in Gurobi&#x2F;CPLEX&#x2F;XPRESS. It remains a fantastic result regardless (see below). But first let me explain.<p>In terms of theoretical computational complexity, the best algorithms for &quot;integer linear programming&quot; [2] (whether the variables are binary or general integers, as in the case tackled by the paper) are based on lattices. They have the best worst-case big-O complexity. Unfortunately, all current implementations need (1) arbitrary-size rational arithmetic (like provided by gmplib [3]), which is memory hungry and a bit slow in practice, and (2) some LLL-type lattice reduction step [4], which does not take advantage of matrix sparsity. As a result, those algorithms cannot even start tackling problems with matrices larger than 1000x1000, because they typically don&#x27;t fit in memory... and even if they did, they are prohibitively slow.<p>In practice instead, integer programming solver are based on branch-and-bound, a type of backtracking algorithm (like used in SAT solving), and at every iteration, they solve a &quot;linear programming&quot; problem (same as the original problem, but all variables are continuous). Each &quot;linear programming&quot; problem could be solved in polynomial time (with algorithms called interior-point methods), but instead they use the simplex method, which is exponential in the worst case!! The reason is that all those linear programming problems to solve are very similar to each other, and the simplex method can take advantage of that in practice. Moreover, all the algorithms involved greatly take advantage of sparsity in any vector or matrix involved. As a result, some people routinely solve integer programming problems with millions of variables within days or even hours.<p>As you can see, the solver implementers are not chasing the absolute best theoretical complexity. One could say that the theory and practice of discrete optimization has somewhat diverged.<p>That said, the Reis &amp; Rothvoss paper [1] is deep mathematical work. It is extremely impressive on its own to anyone with an interest in discrete maths. It settles a 10-year-old conjecture by Dadush (the length of time a conjecture remains open is a rough heuristic many mathematicians use to evaluate how hard it is to (dis)prove). Last november, it was presented at FOCS, one of the two top conferences in computer science theory (together with STOC). Direct practical applicability is besides the point; the authors will readily confess as much if asked in an informal setting (they will of course insist otherwise in grant applications -- that&#x27;s part of the game).  It does not mean it is useless: In addition to the work having tremendous value in itself because it advances our mathematical knowledge, one can imagine that practical algorithms based on its ideas could push the state-of-the-art of solvers, a few generations of researchers down the line.<p>At the end of the day, all those algorithms are exponential in the worst case anyways. In theory, one would try to slightly shrink the polynomial in the exponent of the worst-case complexity. Instead, practitioners typically want to solve one big optimization problems, not family of problems of increasing size n. They don&#x27;t care about the growth rate of the solving time trend line. They care about solving their one big instance, which typically has structure that does not make it a &quot;worst-case&quot; instance for its size. This leads to distinct engineering decisions.<p>[1] <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2303.14605" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2303.14605</a><p>[2] min { c^T x : A x &gt;= b, x in R^n, some components of x in Z }<p>[3] <a href="https:&#x2F;&#x2F;gmplib.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gmplib.org&#x2F;</a><p>[4] <a href="https:&#x2F;&#x2F;www.math.leidenuniv.nl&#x2F;~hwl&#x2F;PUBLICATIONS&#x2F;1982f&#x2F;art.pdf" rel="nofollow">https:&#x2F;&#x2F;www.math.leidenuniv.nl&#x2F;~hwl&#x2F;PUBLICATIONS&#x2F;1982f&#x2F;art.p...</a></div><br/></div></div></div></div><div id="39185851" class="c"><input type="checkbox" id="c-39185851" checked=""/><div class="controls bullet"><span class="by">ubj</span><span>|</span><a href="#39185828">prev</a><span>|</span><a href="#39185591">next</a><span>|</span><label class="collapse" for="c-39185851">[-]</label><label class="expand" for="c-39185851">[4 more]</label></div><br/><div class="children"><div class="content">Minor nitpick, but the title of this submission should specify &quot;Integer Linear Programming&quot;, since the integer part is a much bigger deal.<p>Polynomial time algorithms have been known for linear programming for decades; _integer_ linear programming is NP-hard.</div><br/><div id="39186726" class="c"><input type="checkbox" id="c-39186726" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39185851">parent</a><span>|</span><a href="#39186706">next</a><span>|</span><label class="collapse" for="c-39186726">[-]</label><label class="expand" for="c-39186726">[2 more]</label></div><br/><div class="children"><div class="content">You are right that integer linear programming is NP-hard; but faster algorithms for continuous linear programming are also super interesting and impactful.<p>Continuous linear programming is also _hard_.  Not in the sense of NP-hard, but in the sense of there being lots of algorithmic and engineering aspects that go into an efficient, modern LP solver.  Even just the numerics are complicated enough.<p>(And many integer linear programming solvers are based on continuous linear programming solvers.)</div><br/><div id="39187130" class="c"><input type="checkbox" id="c-39187130" checked=""/><div class="controls bullet"><span class="by">ubj</span><span>|</span><a href="#39185851">root</a><span>|</span><a href="#39186726">parent</a><span>|</span><a href="#39186706">next</a><span>|</span><label class="collapse" for="c-39187130">[-]</label><label class="expand" for="c-39187130">[1 more]</label></div><br/><div class="children"><div class="content">True, these are all fair points! I didn&#x27;t intend to diminish the impact or complexity of linear programming solvers. Well-written solvers are some of the most useful and powerful computational tools that exist today.</div><br/></div></div></div></div><div id="39186706" class="c"><input type="checkbox" id="c-39186706" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39185851">parent</a><span>|</span><a href="#39186726">prev</a><span>|</span><a href="#39185591">next</a><span>|</span><label class="collapse" for="c-39186706">[-]</label><label class="expand" for="c-39186706">[1 more]</label></div><br/><div class="children"><div class="content">I think we fixed that, albeit by accident when I edited the title earlier. If it needs further fixing let me know!</div><br/></div></div></div></div><div id="39185591" class="c"><input type="checkbox" id="c-39185591" checked=""/><div class="controls bullet"><span class="by">ford</span><span>|</span><a href="#39185851">prev</a><span>|</span><a href="#39185636">next</a><span>|</span><label class="collapse" for="c-39185591">[-]</label><label class="expand" for="c-39185591">[13 more]</label></div><br/><div class="children"><div class="content">Software engineers interested in ML&#x2F;algorithms should learn about linear programming.<p>It&#x27;s surprising how many problems can be formulated as linear optimization.<p>For example, in college I was talking to my Industrial Engineer friend about the average minimum number of swaps required to place billiards balls in an acceptable starting position in the rack (triangle). We both happened to write programs that used monte-carlo sampling to solve it - but my solution did BFS on the state space of a graph, and his used linear programming (which was _probably_ more efficient)</div><br/><div id="39186415" class="c"><input type="checkbox" id="c-39186415" checked=""/><div class="controls bullet"><span class="by">mp05</span><span>|</span><a href="#39185591">parent</a><span>|</span><a href="#39186403">next</a><span>|</span><label class="collapse" for="c-39186415">[-]</label><label class="expand" for="c-39186415">[7 more]</label></div><br/><div class="children"><div class="content">I foresee a future where industrial engineering and CS are combined into some super-degree. There is currently a surprising amount of overlap in the OR side of things, but I&#x27;m shocked by how few IE grads can program their way out of a box. It&#x27;s a shame, really.</div><br/><div id="39187584" class="c"><input type="checkbox" id="c-39187584" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#39185591">root</a><span>|</span><a href="#39186415">parent</a><span>|</span><a href="#39186592">next</a><span>|</span><label class="collapse" for="c-39187584">[-]</label><label class="expand" for="c-39187584">[1 more]</label></div><br/><div class="children"><div class="content">Operations Research is basically Industrial Engineering + Mathematical Optimization + programming familiarity. It&#x27;s super useful.</div><br/></div></div><div id="39186592" class="c"><input type="checkbox" id="c-39186592" checked=""/><div class="controls bullet"><span class="by">maxFlow</span><span>|</span><a href="#39185591">root</a><span>|</span><a href="#39186415">parent</a><span>|</span><a href="#39187584">prev</a><span>|</span><a href="#39186403">next</a><span>|</span><label class="collapse" for="c-39186592">[-]</label><label class="expand" for="c-39186592">[5 more]</label></div><br/><div class="children"><div class="content">CS already is the super-degree.</div><br/><div id="39186736" class="c"><input type="checkbox" id="c-39186736" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#39185591">root</a><span>|</span><a href="#39186592">parent</a><span>|</span><a href="#39186403">next</a><span>|</span><label class="collapse" for="c-39186736">[-]</label><label class="expand" for="c-39186736">[4 more]</label></div><br/><div class="children"><div class="content">How so?</div><br/><div id="39186830" class="c"><input type="checkbox" id="c-39186830" checked=""/><div class="controls bullet"><span class="by">axus</span><span>|</span><a href="#39185591">root</a><span>|</span><a href="#39186736">parent</a><span>|</span><a href="#39186403">next</a><span>|</span><label class="collapse" for="c-39186830">[-]</label><label class="expand" for="c-39186830">[3 more]</label></div><br/><div class="children"><div class="content">It qualifies you for an opinion on any subject.</div><br/><div id="39187214" class="c"><input type="checkbox" id="c-39187214" checked=""/><div class="controls bullet"><span class="by">shermantanktop</span><span>|</span><a href="#39185591">root</a><span>|</span><a href="#39186830">parent</a><span>|</span><a href="#39186403">next</a><span>|</span><label class="collapse" for="c-39187214">[-]</label><label class="expand" for="c-39187214">[2 more]</label></div><br/><div class="children"><div class="content">A CS degree also qualifies you for on-the-job training in writing code, that odious task that your professors find trivial but somehow are also terrible at it.</div><br/><div id="39187845" class="c"><input type="checkbox" id="c-39187845" checked=""/><div class="controls bullet"><span class="by">Al-Khwarizmi</span><span>|</span><a href="#39185591">root</a><span>|</span><a href="#39187214">parent</a><span>|</span><a href="#39186403">next</a><span>|</span><label class="collapse" for="c-39187845">[-]</label><label class="expand" for="c-39187845">[1 more]</label></div><br/><div class="children"><div class="content">We just don&#x27;t have time. Incentives are elsewhere. Any time devoted to writing good code for a paper is time we cannot use to work on the next paper, (shudder) grant request, or a plethora of other things that we are either forced or incentivized to do.<p>I miss coding from when I was in a more junior stage of my career and could afford time for it, and I think my fellow professors mostly feel the same, I don&#x27;t think many would dismiss it as trivial or odious.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39186403" class="c"><input type="checkbox" id="c-39186403" checked=""/><div class="controls bullet"><span class="by">tylerhou</span><span>|</span><a href="#39185591">parent</a><span>|</span><a href="#39186415">prev</a><span>|</span><a href="#39185636">next</a><span>|</span><label class="collapse" for="c-39186403">[-]</label><label class="expand" for="c-39186403">[5 more]</label></div><br/><div class="children"><div class="content">ILP is NP-complete.</div><br/><div id="39186740" class="c"><input type="checkbox" id="c-39186740" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39185591">root</a><span>|</span><a href="#39186403">parent</a><span>|</span><a href="#39186846">next</a><span>|</span><label class="collapse" for="c-39186740">[-]</label><label class="expand" for="c-39186740">[3 more]</label></div><br/><div class="children"><div class="content">Yes?  We do manage to solve ILP problems in practice quite nicely.<p>In fact, most NP problems that you come across in practice are relatively tractable for most practical instances.<p>Eg for the knapsack problem you have to actually work very hard to get a hard instance in the first place.</div><br/><div id="39187383" class="c"><input type="checkbox" id="c-39187383" checked=""/><div class="controls bullet"><span class="by">imtringued</span><span>|</span><a href="#39185591">root</a><span>|</span><a href="#39186740">parent</a><span>|</span><a href="#39186846">next</a><span>|</span><label class="collapse" for="c-39187383">[-]</label><label class="expand" for="c-39187383">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not correct.<p>First of all, you can&#x27;t solve a neoclassical economy using LP, because equilibrium constraints can only be represented as complementarity constraints. You would have to give up on some aspects, like dynamic prices.<p>The linear complementarity problem in itself is NP hard. So you&#x27;re screwed from the get go, because your problems are now LPCC problems.
Good luck finding an LPCC solver. I can confirm that an open source QPCC solver exists though, which should be even slower.<p>Next is the fact that if you wanted to build a neoclassical economy model, only global optimization will do.<p>This means that you need to simulate every time step in one large LPCC model, instead of using a finite horizon. Due to the perfect information assumption, you must know about the state of every person on the planet. You&#x27;re going to need millions of variables due to simple combinatorial explosion.<p>It&#x27;s kind of startling how these assumptions, which are supposed to make analytical solutions tractable by the way, also make non-analytical solutions literal hell.<p>And before you say that prices can be determined iteratively, as I mentioned, you would run into the problem that future prices are unknown to you, so how are you going to plug them into the second time step? The very thing you want to calculate depends on it&#x27;s future value.<p>Economics is a weird science, where experienced reality works much better than the theory.</div><br/><div id="39187610" class="c"><input type="checkbox" id="c-39187610" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#39185591">root</a><span>|</span><a href="#39187383">parent</a><span>|</span><a href="#39186846">next</a><span>|</span><label class="collapse" for="c-39187610">[-]</label><label class="expand" for="c-39187610">[1 more]</label></div><br/><div class="children"><div class="content">Computational economics is a relatively new field where intelligent agents are used with lots of runs instead of general optimization solvers I believe. Pretty nifty. One of my colleagues publishes a good bit on it.</div><br/></div></div></div></div></div></div><div id="39186846" class="c"><input type="checkbox" id="c-39186846" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#39185591">root</a><span>|</span><a href="#39186403">parent</a><span>|</span><a href="#39186740">prev</a><span>|</span><a href="#39185636">next</a><span>|</span><label class="collapse" for="c-39186846">[-]</label><label class="expand" for="c-39186846">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s not. it&#x27;s np-hard. the easiest proof is that the best known algorithm is greater than O(2^N)</div><br/></div></div></div></div></div></div><div id="39185636" class="c"><input type="checkbox" id="c-39185636" checked=""/><div class="controls bullet"><span class="by">Duanemclemore</span><span>|</span><a href="#39185591">prev</a><span>|</span><a href="#39185770">next</a><span>|</span><label class="collapse" for="c-39185636">[-]</label><label class="expand" for="c-39185636">[1 more]</label></div><br/><div class="children"><div class="content">Great short article. I haven&#x27;t looked deeply into the math behind this yet, but this looks to be a preprint [0].  It doesn&#x27;t appear they&#x27;re looking directly at the Space Groups as a way to reduce out any symmetries or repetitions that may occur (thus generalizing simplifications of the problem &quot;space&quot;), but it would be interesting to see whether those structures apply or not. I say this as someone who writes software to apply the Space Groups and describe the Voronoi cells around points (or groups of points) distributed through them, so I&#x27;m familiar with the &quot;uncanny&quot; ways effects propagate. [1]<p>I&#x27;m also not a mathematician (just a lowly architect), so I&#x27;m way out of my depth here. But it&#x27;s fascinating and as someone looking at paths across these generated honeycombs, this result bears more investigation for me as well.<p>[0] <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2303.14605.pdf" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2303.14605.pdf</a>
[1] If you know a mathematician who might be interested in collaborating on this kind work, ping me. This is ongoing work, and as I said I&#x27;m out of my depth mathematically. But have run into some interesting properties that don&#x27;t seem that deeply investigated which may bear deeper study by an actual expert.</div><br/></div></div><div id="39185770" class="c"><input type="checkbox" id="c-39185770" checked=""/><div class="controls bullet"><span class="by">fuidani</span><span>|</span><a href="#39185636">prev</a><span>|</span><a href="#39186414">next</a><span>|</span><label class="collapse" for="c-39185770">[-]</label><label class="expand" for="c-39185770">[7 more]</label></div><br/><div class="children"><div class="content">About the travelling salesperson problem, below is a quote from the latest Sapolsky&#x27;s book Determined: A Science of Life without Free Will. I am not sure how relevant this is for software developers, but still fascinating:<p>&quot;An ant forages for food, checking eight different places. Little ant legs get tired, and ideally the ant visits each site only once, and in the shortest possible path of the 5,040 possible ones (i.e., seven factorial). This is a version of the famed “traveling salesman problem,” which has kept mathematicians busy for centuries, fruitlessly searching for a general solution. One strategy for solving the problem is with brute force— examine every possible route, compare them all, and pick the best one. This takes a ton of work and computational power— by the time you’re up to ten places to visit, there are more than 360,000 possible ways to do it, more than 80 billion with fifteen places to visit. Impossible. But take the roughly ten thousand ants in a typical colony, set them loose on the eight- feeding- site version, and they’ll come up with something close to the optimal solution out of the 5,040 possibilities in a fraction of the time it would take you to brute- force it, with no ant knowing anything more than the path that it took plus two rules (which we’ll get to). This works so well that computer scientists can solve problems like this with “virtual ants,” making use of what is now known as swarm intelligence.&quot;</div><br/><div id="39186078" class="c"><input type="checkbox" id="c-39186078" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#39185770">parent</a><span>|</span><a href="#39186659">next</a><span>|</span><label class="collapse" for="c-39186078">[-]</label><label class="expand" for="c-39186078">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s been more than a few of these &quot;nature solves NP-hard problems quickly!&quot; kinds of stories, but usually, when one digs deeper, the answer is &quot;nature finds local optima for NP-hard problems quickly!&quot; and the standard response is &quot;so does pretty trivial computer algorithms.&quot;<p>In the case of TSP, when you&#x27;re trying to minimize a TSP with a Euclidean metric (i.e., each node has fixed coordinates, and the cost of the path is the Euclidean distance between these two points), then we can actually give you a polynomial-time algorithm to find a path within a factor ε of the optimal solution (albeit exponential in ε).</div><br/><div id="39186248" class="c"><input type="checkbox" id="c-39186248" checked=""/><div class="controls bullet"><span class="by">pas</span><span>|</span><a href="#39185770">root</a><span>|</span><a href="#39186078">parent</a><span>|</span><a href="#39186659">next</a><span>|</span><label class="collapse" for="c-39186248">[-]</label><label class="expand" for="c-39186248">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;scottaaronson.blog&#x2F;?p=266" rel="nofollow">https:&#x2F;&#x2F;scottaaronson.blog&#x2F;?p=266</a><p>&quot;&quot;&quot;
I went to the hardware store, bought some glass plates, liquid soap, etc., and found that, while Nature does often find a minimum Steiner tree with 4 or 5 pegs, it tends to get stuck at local optima with larger numbers of pegs.
&quot;&quot;&quot;</div><br/><div id="39186300" class="c"><input type="checkbox" id="c-39186300" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#39185770">root</a><span>|</span><a href="#39186248">parent</a><span>|</span><a href="#39186659">next</a><span>|</span><label class="collapse" for="c-39186300">[-]</label><label class="expand" for="c-39186300">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Did he try jiggling it a bit, and then less and less and less?&quot;<p>( Annealing &#x2F;s )</div><br/></div></div></div></div></div></div><div id="39186659" class="c"><input type="checkbox" id="c-39186659" checked=""/><div class="controls bullet"><span class="by">gregod</span><span>|</span><a href="#39185770">parent</a><span>|</span><a href="#39186078">prev</a><span>|</span><a href="#39186195">next</a><span>|</span><label class="collapse" for="c-39186659">[-]</label><label class="expand" for="c-39186659">[1 more]</label></div><br/><div class="children"><div class="content">The  Evolutionary Computation Bestiary [1] list a wide variety of animal behavior inspired heuristics.<p>The foreword includes this great disclaimer:
&quot;While we personally believe that the literature could do with more mathematics and less marsupials, and that we, as a community, should grow past this metaphor-rich phase in our field’s history (a bit like chemistry outgrew alchemy), please note that this list makes no claims about the scientific quality of the papers listed.&quot;<p>[1]: <a href="https:&#x2F;&#x2F;fcampelo.github.io&#x2F;EC-Bestiary&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fcampelo.github.io&#x2F;EC-Bestiary&#x2F;</a></div><br/></div></div><div id="39186195" class="c"><input type="checkbox" id="c-39186195" checked=""/><div class="controls bullet"><span class="by">FredPret</span><span>|</span><a href="#39185770">parent</a><span>|</span><a href="#39186659">prev</a><span>|</span><a href="#39185931">next</a><span>|</span><label class="collapse" for="c-39186195">[-]</label><label class="expand" for="c-39186195">[1 more]</label></div><br/><div class="children"><div class="content">If you try to make your path close to a circle, it’s obviously not guaranteed to be optimal, but it’ll probably be close enough for most small practical applications</div><br/></div></div></div></div><div id="39186414" class="c"><input type="checkbox" id="c-39186414" checked=""/><div class="controls bullet"><span class="by">whatever1</span><span>|</span><a href="#39185770">prev</a><span>|</span><a href="#39185532">next</a><span>|</span><label class="collapse" for="c-39186414">[-]</label><label class="expand" for="c-39186414">[1 more]</label></div><br/><div class="children"><div class="content">It’s great result but probably not useful. Similarly to how interior point methods have better theoretical complexity than simplex for LPs, but fine tuned  simplex in reality almost always wins.</div><br/></div></div><div id="39185532" class="c"><input type="checkbox" id="c-39185532" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#39186414">prev</a><span>|</span><a href="#39187103">next</a><span>|</span><label class="collapse" for="c-39185532">[-]</label><label class="expand" for="c-39185532">[7 more]</label></div><br/><div class="children"><div class="content">So many discrete optimization problems can be translated into linear programs. It&#x27;s a really powerful set of tools to know, kind of like SAT solvers.</div><br/><div id="39185665" class="c"><input type="checkbox" id="c-39185665" checked=""/><div class="controls bullet"><span class="by">idatum</span><span>|</span><a href="#39185532">parent</a><span>|</span><a href="#39187103">next</a><span>|</span><label class="collapse" for="c-39185665">[-]</label><label class="expand" for="c-39185665">[6 more]</label></div><br/><div class="children"><div class="content">I only recently learned about linear programming. I started with PuLP and Python to get a grasp. It was one of those &quot;How did I miss this??&quot; moments as a developer.</div><br/><div id="39186002" class="c"><input type="checkbox" id="c-39186002" checked=""/><div class="controls bullet"><span class="by">ByteMe95</span><span>|</span><a href="#39185532">root</a><span>|</span><a href="#39185665">parent</a><span>|</span><a href="#39187103">next</a><span>|</span><label class="collapse" for="c-39186002">[-]</label><label class="expand" for="c-39186002">[5 more]</label></div><br/><div class="children"><div class="content">Do you have any recommendations on where to start?</div><br/><div id="39186437" class="c"><input type="checkbox" id="c-39186437" checked=""/><div class="controls bullet"><span class="by">mp05</span><span>|</span><a href="#39185532">root</a><span>|</span><a href="#39186002">parent</a><span>|</span><a href="#39186054">next</a><span>|</span><label class="collapse" for="c-39186437">[-]</label><label class="expand" for="c-39186437">[1 more]</label></div><br/><div class="children"><div class="content">Winston&#x27;s &quot;Operations Research: Applications and Algorithms&quot; is the authority so far as I can tell. Trivial to find old editions online.</div><br/></div></div><div id="39186054" class="c"><input type="checkbox" id="c-39186054" checked=""/><div class="controls bullet"><span class="by">idatum</span><span>|</span><a href="#39185532">root</a><span>|</span><a href="#39186002">parent</a><span>|</span><a href="#39186437">prev</a><span>|</span><a href="#39186980">next</a><span>|</span><label class="collapse" for="c-39186054">[-]</label><label class="expand" for="c-39186054">[2 more]</label></div><br/><div class="children"><div class="content">I wish I can remember how I even learned LP tools existed. I started with this:
<a href="https:&#x2F;&#x2F;coin-or.github.io&#x2F;pulp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;coin-or.github.io&#x2F;pulp&#x2F;</a></div><br/><div id="39186743" class="c"><input type="checkbox" id="c-39186743" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39185532">root</a><span>|</span><a href="#39186054">parent</a><span>|</span><a href="#39186980">next</a><span>|</span><label class="collapse" for="c-39186743">[-]</label><label class="expand" for="c-39186743">[1 more]</label></div><br/><div class="children"><div class="content">The Google OR-tools library is also a good starting point.<p>I learned about linear programming in uni, but alas I don&#x27;t think a mathematician&#x27;s course on linear programming would be a good starting point for practical programmers.</div><br/></div></div></div></div><div id="39186980" class="c"><input type="checkbox" id="c-39186980" checked=""/><div class="controls bullet"><span class="by">graycat</span><span>|</span><a href="#39185532">root</a><span>|</span><a href="#39186002">parent</a><span>|</span><a href="#39186054">prev</a><span>|</span><a href="#39187103">next</a><span>|</span><label class="collapse" for="c-39186980">[-]</label><label class="expand" for="c-39186980">[1 more]</label></div><br/><div class="children"><div class="content">For positive integers m and n,
have a m x n matrix A of real numbers.  Then also have n x 1 x, 1 x n c, and m x 1 b.  Seek x to solve<p>LP1:<p>maximize z = cx<p>subject to<p>Ax = b<p>x &gt;= 0<p>Instead just as easily can do minimize.<p>Instead of =, might be given &gt;= and&#x2F;or &lt;=, but use <i>slack</i> and&#x2F;or <i>surplus</i> variables to get the problem in the form of LP1.<p>Any x so that<p>Ax = b<p>x &gt;= 0<p>is <i>feasible</i>.  If there is such an x, then LP1 is <i>feasible</i>; else LP1 is <i>infeasible</i>.  If LP1 is feasible and for any feasible x we have z bounded above, then LP1 is <i>bounded</i> and has an <i>optimal</i> x (z as large as possible) solution.  Else feasible LP1 is <i>unbounded</i> above.<p>So, LP1 is feasible or not.  If feasible, then it is bounded or not.  If bounded, then there is at least one optimal solution.<p>Regard n x 1 x as a point in R^n for the real numbers R.<p>Cute:  If all the numbers in LP1 are rational, then have no need for the reals.<p>The set of all feasible x is the <i>feasible region</i> and is <i>closed</i> (in the usual topology of R^n) and <i>convex</i>.  If LP1 is bounded, then there is at least one optimal x that is an <i>extreme</i> point of the feasible region.  So, it is sufficient to look only at the extreme points.<p>To determine if LP1 is feasible or not, and if feasible bounded or not, and 
if bounded to find an optimal x,  can use the <i>simplex</i> algorithm which is just some carefully selected linear algebra <i>elementary row operations</i> on<p>z = cx<p>Ax = b<p>The <i>iterations</i> of the simplex algorithm have x move from one extreme point to an adjacent one and as good or better on z.<p>A LOT is well known about LP1 and the simplex algorithm.  There is a simpler version for a least cost network flow problem where move from one spanning tree to another.<p>If insist that the components of x be integers, then are into <i>integer linear programming</i> and the question of P = NP.  In practice there is a lot known about ILP, e.g., via G. Nemhauser.<p>I used to teach LP at Ohio State -- there are lots of polished books from very elementary to quite advanced.<p>I attacked some practical ILP problems successfully.<p>I got into ILP (set covering, a darned clever idea since get to handle lots of goofy, highly <i>non-linear</i> constraints, costs, etc. efficiently) for scheduling the fleet at FedEx.  The head guy at FedEx wrote me a memo making that problem my work -- officially I reported to the Senior VP Planning, but for that ILP work in every real sense reported to the head guy.  The promised stock was very late, so I went for a Ph.D. and got good at lots of math, including optimization, LP, and ILP, etc.<p>Conclusion:  A career in LP or ILP is a good way to need charity or sleep on the street -- literally, no exaggeration.<p>For some of what AI is doing or trying to do now, LP&#x2F;ILP stands to be tough competition, tough to beat. And same for lots more in the now old applied math of <i>optimization</i>.  Bring a strong vacuum cleaner to get the thick dust off the best books.</div><br/></div></div></div></div></div></div></div></div><div id="39187103" class="c"><input type="checkbox" id="c-39187103" checked=""/><div class="controls bullet"><span class="by">andrewp123</span><span>|</span><a href="#39185532">prev</a><span>|</span><a href="#39187028">next</a><span>|</span><label class="collapse" for="c-39187103">[-]</label><label class="expand" for="c-39187103">[5 more]</label></div><br/><div class="children"><div class="content">It seems their result has been out for almost a year now... <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2303.14605" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2303.14605</a><p>I&#x27;m curious how this affects Traveling Salesman. I was under the impression that all NP-Complete problems take O(n!). Does this method improve it at all?</div><br/><div id="39187136" class="c"><input type="checkbox" id="c-39187136" checked=""/><div class="controls bullet"><span class="by">blackbear_</span><span>|</span><a href="#39187103">parent</a><span>|</span><a href="#39187443">prev</a><span>|</span><a href="#39187170">next</a><span>|</span><label class="collapse" for="c-39187136">[-]</label><label class="expand" for="c-39187136">[1 more]</label></div><br/><div class="children"><div class="content">Depending on the problem it can also O(2^n), but that is always the worst case scenario. Modern ILP solvers employ a variety of heuristics that in many cases significantly reduce the time needed to find a solution.<p>Anecdotally, some years back I was developing MILPs with millions of variables and constraints, and most of them could be solved within minutes to hours. But some of them could not be cracked after weeks, all depending the inputs.</div><br/></div></div><div id="39187170" class="c"><input type="checkbox" id="c-39187170" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#39187103">parent</a><span>|</span><a href="#39187136">prev</a><span>|</span><a href="#39187133">next</a><span>|</span><label class="collapse" for="c-39187170">[-]</label><label class="expand" for="c-39187170">[1 more]</label></div><br/><div class="children"><div class="content">We actually don&#x27;t know how long NP-complete problems take to solve. We conjecture that it&#x27;s superpolynomial, but that can be exponentially faster than O(n!).</div><br/></div></div><div id="39187133" class="c"><input type="checkbox" id="c-39187133" checked=""/><div class="controls bullet"><span class="by">yau8edq12i</span><span>|</span><a href="#39187103">parent</a><span>|</span><a href="#39187170">prev</a><span>|</span><a href="#39187028">next</a><span>|</span><label class="collapse" for="c-39187133">[-]</label><label class="expand" for="c-39187133">[1 more]</label></div><br/><div class="children"><div class="content">So what? It takes time for the community to digest the result, grasp its significance, and then write popularization articles about it. If you want to know what&#x27;s being discovered right this second, read arXiv preprints. If you want to know what was discovered semi-recently and you want an explanation in layman terms that puts the results in perspective, read popularization pieces a while later.</div><br/></div></div></div></div><div id="39187028" class="c"><input type="checkbox" id="c-39187028" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#39187103">prev</a><span>|</span><a href="#39186662">next</a><span>|</span><label class="collapse" for="c-39187028">[-]</label><label class="expand" for="c-39187028">[1 more]</label></div><br/><div class="children"><div class="content">So this is for the special case of non-negative and non-zero weights only, right? But those cases are the only sane ones, avoiding recursive loops winning a time-travel-alike race.</div><br/></div></div><div id="39186662" class="c"><input type="checkbox" id="c-39186662" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#39187028">prev</a><span>|</span><a href="#39186159">next</a><span>|</span><label class="collapse" for="c-39186662">[-]</label><label class="expand" for="c-39186662">[1 more]</label></div><br/><div class="children"><div class="content">I remember the news articles when Karmarkar&#x27;s algorithm for linear programming was announced.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Narendra_Karmarkar" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Narendra_Karmarkar</a><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Karmarkar%27s_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Karmarkar%27s_algorithm</a></div><br/></div></div><div id="39186159" class="c"><input type="checkbox" id="c-39186159" checked=""/><div class="controls bullet"><span class="by">coliveira</span><span>|</span><a href="#39186662">prev</a><span>|</span><a href="#39185776">next</a><span>|</span><label class="collapse" for="c-39186159">[-]</label><label class="expand" for="c-39186159">[2 more]</label></div><br/><div class="children"><div class="content">While this is an interesting theoretical result, we need to remember that they found an algorithm that is (log n)^O(n). In other words, this is not practical to solve problems with moderate to large size n.</div><br/><div id="39186385" class="c"><input type="checkbox" id="c-39186385" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#39186159">parent</a><span>|</span><a href="#39185776">next</a><span>|</span><label class="collapse" for="c-39186385">[-]</label><label class="expand" for="c-39186385">[1 more]</label></div><br/><div class="children"><div class="content">compared to the previous bound of n^n, log(n)^n looks pretty good.</div><br/></div></div></div></div><div id="39185776" class="c"><input type="checkbox" id="c-39185776" checked=""/><div class="controls bullet"><span class="by">Bimos</span><span>|</span><a href="#39186159">prev</a><span>|</span><a href="#39185988">next</a><span>|</span><label class="collapse" for="c-39185776">[-]</label><label class="expand" for="c-39185776">[4 more]</label></div><br/><div class="children"><div class="content">I have a dumb question: how long will it take before this result becoming a pratical MIP solver beating SCIP or gurobi?</div><br/><div id="39187172" class="c"><input type="checkbox" id="c-39187172" checked=""/><div class="controls bullet"><span class="by">ubj</span><span>|</span><a href="#39185776">parent</a><span>|</span><a href="#39185836">next</a><span>|</span><label class="collapse" for="c-39187172">[-]</label><label class="expand" for="c-39187172">[2 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t forget about the HiGHS solver [1]. MIT licensed and getting to the point where it&#x27;s outperforming SCIP on the Mittelmann benchmarks [2].<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;ERGO-Code&#x2F;HiGHS">https:&#x2F;&#x2F;github.com&#x2F;ERGO-Code&#x2F;HiGHS</a><p>[2]: <a href="https:&#x2F;&#x2F;mattmilten.github.io&#x2F;mittelmann-plots&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mattmilten.github.io&#x2F;mittelmann-plots&#x2F;</a></div><br/><div id="39187549" class="c"><input type="checkbox" id="c-39187549" checked=""/><div class="controls bullet"><span class="by">FreakLegion</span><span>|</span><a href="#39185776">root</a><span>|</span><a href="#39187172">parent</a><span>|</span><a href="#39185836">next</a><span>|</span><label class="collapse" for="c-39187549">[-]</label><label class="expand" for="c-39187549">[1 more]</label></div><br/><div class="children"><div class="content">HiGHS is more of an alternative to Bonmin and Minotaur than Couenne and SCIP. In my experience though the presolvers in SCIP are extremely dangerous, and it&#x27;s easy to end up with a local optimum even when that isn&#x27;t your goal.</div><br/></div></div></div></div><div id="39185836" class="c"><input type="checkbox" id="c-39185836" checked=""/><div class="controls bullet"><span class="by">_dark_matter_</span><span>|</span><a href="#39185776">parent</a><span>|</span><a href="#39187172">prev</a><span>|</span><a href="#39185988">next</a><span>|</span><label class="collapse" for="c-39185836">[-]</label><label class="expand" for="c-39185836">[1 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t either of those implement this algorithm?</div><br/></div></div></div></div><div id="39185988" class="c"><input type="checkbox" id="c-39185988" checked=""/><div class="controls bullet"><span class="by">genman</span><span>|</span><a href="#39185776">prev</a><span>|</span><a href="#39185700">next</a><span>|</span><label class="collapse" for="c-39185988">[-]</label><label class="expand" for="c-39185988">[1 more]</label></div><br/><div class="children"><div class="content">[2023] The paper was uploaded first in March <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2303.14605" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2303.14605</a></div><br/></div></div><div id="39185700" class="c"><input type="checkbox" id="c-39185700" checked=""/><div class="controls bullet"><span class="by">ken47</span><span>|</span><a href="#39185988">prev</a><span>|</span><a href="#39185901">next</a><span>|</span><label class="collapse" for="c-39185700">[-]</label><label class="expand" for="c-39185700">[2 more]</label></div><br/><div class="children"><div class="content">This discovery may change the world in unpredictable and, perhaps very big, ways. Discoveries like this put all the self-important feature &#x2F; model developers that we work with in our big tech day jobs into context.</div><br/><div id="39185781" class="c"><input type="checkbox" id="c-39185781" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#39185700">parent</a><span>|</span><a href="#39185901">next</a><span>|</span><label class="collapse" for="c-39185781">[-]</label><label class="expand" for="c-39185781">[1 more]</label></div><br/><div class="children"><div class="content">Can you explain specifically what about it you think will change the world and why?</div><br/></div></div></div></div><div id="39185901" class="c"><input type="checkbox" id="c-39185901" checked=""/><div class="controls bullet"><span class="by">aaron695</span><span>|</span><a href="#39185700">prev</a><span>|</span><a href="#39187600">next</a><span>|</span><label class="collapse" for="c-39185901">[-]</label><label class="expand" for="c-39185901">[4 more]</label></div><br/><div class="children"><div class="content">Linear programming is very cool, I loved Vasek Chvatal&#x27;s book as a kid having accidently bought it thinking it was for computers.<p>But it&#x27;s tricky to understand and   implement and it struggles with real life constraints. i.e. This whole specialty just for integers.<p>Monto Carlo is trivial to understand and implement, adapts to changes and constraints trivially and <i>should</i> be just as good.<p>I&#x27;m sure for something high end like chip design you will do both. I&#x27;d be surprised to hear of real life stories where linear programming beats Monty Carlo.</div><br/><div id="39186761" class="c"><input type="checkbox" id="c-39186761" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39185901">parent</a><span>|</span><a href="#39186613">next</a><span>|</span><label class="collapse" for="c-39186761">[-]</label><label class="expand" for="c-39186761">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But it&#x27;s tricky to understand and implement and it struggles with real life constraints. i.e. This whole specialty just for integers.<p>Integers are actually harder to deal with than rational numbers in linear programming.  Many solvers can also deal with a mixed problem that has both rational and integer variables.<p>Monte Carlo simulations are an entirely different beast.  (Though you probably mean simulated annealing?  But that&#x27;s close enough, I guess.  Linear programming is an optimization technique.  Monte Carlo by itself doesn&#x27;t have anything to do with optimization.)<p>One problem with these other approaches is that you get some answer, but you don&#x27;t know how good it is.  Linear programming solvers either give you the exact answer, or otherwise they can give you a provable upper bound estimate of how far away from the optimal answer you are.</div><br/></div></div><div id="39186613" class="c"><input type="checkbox" id="c-39186613" checked=""/><div class="controls bullet"><span class="by">anon291</span><span>|</span><a href="#39185901">parent</a><span>|</span><a href="#39186761">prev</a><span>|</span><a href="#39187600">next</a><span>|</span><label class="collapse" for="c-39186613">[-]</label><label class="expand" for="c-39186613">[2 more]</label></div><br/><div class="children"><div class="content">Linear programming on reals is &quot;easy&quot;... You can just check all the points. I believe you can follow the shell of the legal polytope and just use a greedy algorithm to choose the next point that will minimize your goal.<p>If you can get away with a continuous linear program I don&#x27;t see why you&#x27;d use monte carlo. The simplex method will get you an exact answer.</div><br/></div></div></div></div><div id="39185562" class="c"><input type="checkbox" id="c-39185562" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#39187600">prev</a><span>|</span><label class="collapse" for="c-39185562">[-]</label><label class="expand" for="c-39185562">[9 more]</label></div><br/><div class="children"><div class="content">People really need to come up with better names. &quot;Linear Programming&quot; or &quot;Integer Linear Programming&quot; mean absolutely nothing.<p>Also anything dealing with finding the minimum distance distances can be short circuited by keeping the shortest distance and not taking paths that exceed that. This is how approximate nearest neighbor works and can still speed up the full solution. Figuring out full paths that have short average distances first can also get to shorter distances sooner.<p>You can also cluster points knowing you probably don&#x27;t want to jump from one cluster to another multiple times.</div><br/><div id="39186776" class="c"><input type="checkbox" id="c-39186776" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39185562">parent</a><span>|</span><a href="#39185609">next</a><span>|</span><label class="collapse" for="c-39186776">[-]</label><label class="expand" for="c-39186776">[1 more]</label></div><br/><div class="children"><div class="content">Linear programming solvers use lots of heuristics (not entirely unlike the ones you sketched) internally.<p>The important thing to keep in mind is that their heuristic only speed up the amount of time spent finding the optimal solution.  But you still get a prove at the end, that they actually found the optimal solution.  (Or if you stop earlier, you get a provable upper bound estimate of how far you are away at worst from the optimal solution.)<p>Heuristics like the ones you sketched don&#x27;t (easily) give you those estimates.</div><br/></div></div><div id="39185609" class="c"><input type="checkbox" id="c-39185609" checked=""/><div class="controls bullet"><span class="by">ford</span><span>|</span><a href="#39185562">parent</a><span>|</span><a href="#39186776">prev</a><span>|</span><a href="#39185633">next</a><span>|</span><label class="collapse" for="c-39185609">[-]</label><label class="expand" for="c-39185609">[4 more]</label></div><br/><div class="children"><div class="content">This made me wonder why it&#x27;s called programming (since clearly it&#x27;s not the sense of the word programming most HN&#x27;ers are used to).<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mathematical_optimization#History" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mathematical_optimization#Hist...</a></div><br/><div id="39185912" class="c"><input type="checkbox" id="c-39185912" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39185562">root</a><span>|</span><a href="#39185609">parent</a><span>|</span><a href="#39185633">next</a><span>|</span><label class="collapse" for="c-39185912">[-]</label><label class="expand" for="c-39185912">[3 more]</label></div><br/><div class="children"><div class="content">From that link:<p><i>Programming in this context does not refer to computer programming, but comes from the use of program by the United States military to refer to proposed training and logistics schedules, which were the problems Dantzig studied at that time</i><p>Is that also true of &#x27;dynamic programming&#x27;?</div><br/><div id="39186301" class="c"><input type="checkbox" id="c-39186301" checked=""/><div class="controls bullet"><span class="by">mturmon</span><span>|</span><a href="#39185562">root</a><span>|</span><a href="#39185912">parent</a><span>|</span><a href="#39185633">next</a><span>|</span><label class="collapse" for="c-39186301">[-]</label><label class="expand" for="c-39186301">[2 more]</label></div><br/><div class="children"><div class="content">If you don’t know, you are in for a treat. Here is Bellman’s own description of how he came up with the term “dynamic programming “ —<p><i>I spent the Fall quarter (of 1950) at RAND. My first task was to find a name for multistage decision processes. An interesting question is, ‘Where did the name, dynamic programming, come from?’<p>The 1950s were not good years for mathematical research. We had a very interesting gentleman in Washington named Wilson. He was Secretary of Defense, and he actually had a pathological fear and hatred of the word, research. I’m not using the term lightly; I’m using it precisely. His face would suffuse, he would turn red, and he would get violent if people used the term, research, in his presence.<p>You can imagine how he felt, then, about the term, mathematical. The RAND Corporation was employed by the Air Force, and the Air Force had Wilson as its boss, essentially. Hence, I felt I had to do something to shield Wilson and the Air Force from the fact that I was really doing mathematics inside the RAND Corporation. What title, what name, could I choose?<p>In the first place I was interested in planning, in decision making, in thinking. But planning, is not a good word for various reasons. I decided therefore to use the word, ‘programming.’ I wanted to get across the idea that this was dynamic, this was multistage, this was time-varying—I thought, let’s kill two birds with one stone. Let’s take a word that has an absolutely precise meaning, namely dynamic, in the classical physical sense.<p>It also has a very interesting property as an adjective, and that is it’s impossible to use the word, dynamic, in a pejorative sense. Try thinking of some combination that will possibly give it a pejorative meaning. It’s impossible. Thus, I thought dynamic programming was a good name. It was something not even a Congressman could object to. So I used it as an umbrella for my activities (Autobiography, p. 159).</i><p>See: <a href="https:&#x2F;&#x2F;pubsonline.informs.org&#x2F;doi&#x2F;pdf&#x2F;10.1287&#x2F;opre.50.1.48.17791" rel="nofollow">https:&#x2F;&#x2F;pubsonline.informs.org&#x2F;doi&#x2F;pdf&#x2F;10.1287&#x2F;opre.50.1.48....</a><p>People up-thread have been getting cranky about the use of “programming “ in this sense.<p>Now of course, “programming“ for optimization has been well-entrenched since the 1970s at least. But perhaps Bellman’s story does give some cover to those who feel the word “programming“ has been wrongly appropriated?</div><br/><div id="39187283" class="c"><input type="checkbox" id="c-39187283" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39185562">root</a><span>|</span><a href="#39186301">parent</a><span>|</span><a href="#39185633">next</a><span>|</span><label class="collapse" for="c-39187283">[-]</label><label class="expand" for="c-39187283">[1 more]</label></div><br/><div class="children"><div class="content">Oh gosh—I was vastly out of the loop: <a href="https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=true&amp;query=%22We%20had%20a%20very%20interesting%20gentleman%20in%20Washington%22&amp;sort=byDate&amp;type=comment" rel="nofollow">https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=true&amp;que...</a><p>Thanks! That&#x27;s a classic for sure.</div><br/></div></div></div></div></div></div></div></div><div id="39185633" class="c"><input type="checkbox" id="c-39185633" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#39185562">parent</a><span>|</span><a href="#39185609">prev</a><span>|</span><a href="#39185611">next</a><span>|</span><label class="collapse" for="c-39185633">[-]</label><label class="expand" for="c-39185633">[1 more]</label></div><br/><div class="children"><div class="content">absolutely nothing?  you mean other than the relationship with linear systems and linear algebra?</div><br/></div></div><div id="39185611" class="c"><input type="checkbox" id="c-39185611" checked=""/><div class="controls bullet"><span class="by">cmrx64</span><span>|</span><a href="#39185562">parent</a><span>|</span><a href="#39185633">prev</a><span>|</span><a href="#39185664">next</a><span>|</span><label class="collapse" for="c-39185611">[-]</label><label class="expand" for="c-39185611">[1 more]</label></div><br/><div class="children"><div class="content">take &quot;programming&quot; to mean &quot;scheduling&quot; and the ancient crusty term acquires some meaning.</div><br/></div></div></div></div></div></div></div></div></div></body></html>