<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685696458384" as="style"/><link rel="stylesheet" href="styles.css?v=1685696458384"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://gaultier.github.io/blog/x11_x64.html">Learn x86-64 assembly by writing a GUI from scratch</a>Â <span class="domain">(<a href="https://gaultier.github.io">gaultier.github.io</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>117 comments</span></div><br/><div><div id="36155471" class="c"><input type="checkbox" id="c-36155471" checked=""/><div class="controls bullet"><span class="by">wudangmonk</span><span>|</span><a href="#36153609">next</a><span>|</span><label class="collapse" for="c-36155471">[-]</label><label class="expand" for="c-36155471">[13 more]</label></div><br/><div class="children"><div class="content">Being self-taugh I decided what better way to learn programming than starting with the basics?. Assembly was my first language, I could read and program in it so I considered like I knew the language.<p>It wasn&#x27;t until I created a sinple 8086 emulator where you take the raw machine code instructions and translate those into not only the assembly instructions but actually emulate what those instructions do that I finally felt like I REALLY knew assembly.<p>My suggestion to others that want to learn assembly is to skip any assembly books. Using whatever language you want first start with a translator from machine code into assembly instructions, and then do an emulator. You only need to implement a small subset of the instructions, check out godbolt and translate some simple programs to know which instructions you need to implement.<p>Other than that all you really need is the 8086 manual, it has all the information there. I also found this site useful when implementing the flags <a href="https:&#x2F;&#x2F;yassinebridi.github.io&#x2F;asm-docs&#x2F;8086_instruction_set.html" rel="nofollow">https:&#x2F;&#x2F;yassinebridi.github.io&#x2F;asm-docs&#x2F;8086_instruction_set...</a>. This takes less time than finishing a book and you learn a LOT more.<p>The goal is not to program in assembly at all but to truely understand the cost of everything and what you can expect from your hardware.</div><br/><div id="36162495" class="c"><input type="checkbox" id="c-36162495" checked=""/><div class="controls bullet"><span class="by">gyulai</span><span>|</span><a href="#36155471">parent</a><span>|</span><a href="#36162082">next</a><span>|</span><label class="collapse" for="c-36162495">[-]</label><label class="expand" for="c-36162495">[1 more]</label></div><br/><div class="children"><div class="content">Vaguely related, since a lot of people here are mentioning assembly as a first programming language for learners: Knuth&#x27;s &quot;The Art of Computer Programming&quot; and its associated fictitious &quot;MMIX&quot; processor (&quot;MIX&quot; on the volumes that aren&#x27;t yet on their new edition).<p>Knuth&#x27;s reasoning seems to be that higher-level languages go in and out of fashion all the time, but hardware and its associated assembly is quite sticky, so it&#x27;s more &quot;timeless&quot;.  It&#x27;s also a smaller set of primitives, so less overwhelming for the learner.<p>MMIX assembly is easier to understand than x86, having been designed specifically with learners in mind, and GCC even has a backend for MIX, so you can write C code and see how GCC would translate it to MIX assembly.</div><br/></div></div><div id="36162082" class="c"><input type="checkbox" id="c-36162082" checked=""/><div class="controls bullet"><span class="by">rajeevk</span><span>|</span><a href="#36155471">parent</a><span>|</span><a href="#36162495">prev</a><span>|</span><a href="#36155934">next</a><span>|</span><label class="collapse" for="c-36162082">[-]</label><label class="expand" for="c-36162082">[1 more]</label></div><br/><div class="children"><div class="content">My approach to learn assembly was to let the C compiler generate assembly (gcc -S -c) from C code and then read the assembly to see how C code is mapped to assembly code. I have written detailed article on this here <a href="https:&#x2F;&#x2F;www.avabodh.com&#x2F;cin&#x2F;cin.html" rel="nofollow">https:&#x2F;&#x2F;www.avabodh.com&#x2F;cin&#x2F;cin.html</a></div><br/></div></div><div id="36155934" class="c"><input type="checkbox" id="c-36155934" checked=""/><div class="controls bullet"><span class="by">nerpderp82</span><span>|</span><a href="#36155471">parent</a><span>|</span><a href="#36162082">prev</a><span>|</span><a href="#36158234">next</a><span>|</span><label class="collapse" for="c-36155934">[-]</label><label class="expand" for="c-36155934">[4 more]</label></div><br/><div class="children"><div class="content">Becoming skilled at GDB and knowing how to generate assembly listing from your tooling is a key skill that really helps with understanding.<p>I learned assembly by reading the assembly listings from the C compiler. It is extremely interesting to be able internalize how high level constructs are compiled and optimized.</div><br/><div id="36157566" class="c"><input type="checkbox" id="c-36157566" checked=""/><div class="controls bullet"><span class="by">BlackLotus89</span><span>|</span><a href="#36155471">root</a><span>|</span><a href="#36155934">parent</a><span>|</span><a href="#36158418">next</a><span>|</span><label class="collapse" for="c-36157566">[-]</label><label class="expand" for="c-36157566">[1 more]</label></div><br/><div class="children"><div class="content">There was a reverse engineering guide that I quite liked that introduced you to assembly by first writing c examples, compiling them and then analyzing the disassembled output.<p>It was quite a long guide, but I would recommend it to anyone starting out. I don&#x27;t have it in my bookmarks it seems, but I will try to update my comment tomorrow when&#x2F;if I find it.<p>Edit: damn I guess it was <a href="https:&#x2F;&#x2F;beginners.re&#x2F;" rel="nofollow">https:&#x2F;&#x2F;beginners.re&#x2F;</a> before it became pay-walled. Web archive still has copies of the book, but if you like it you should consider buying it even if it means signing up for patreon m-( I still got a few versions of the book somewhere as well. Have to dive in again to see if it is as good as I remember</div><br/></div></div><div id="36158418" class="c"><input type="checkbox" id="c-36158418" checked=""/><div class="controls bullet"><span class="by">circuit10</span><span>|</span><a href="#36155471">root</a><span>|</span><a href="#36155934">parent</a><span>|</span><a href="#36157566">prev</a><span>|</span><a href="#36158234">next</a><span>|</span><label class="collapse" for="c-36158418">[-]</label><label class="expand" for="c-36158418">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;</a> is great for this</div><br/><div id="36162161" class="c"><input type="checkbox" id="c-36162161" checked=""/><div class="controls bullet"><span class="by">harry8</span><span>|</span><a href="#36155471">root</a><span>|</span><a href="#36158418">parent</a><span>|</span><a href="#36158234">next</a><span>|</span><label class="collapse" for="c-36162161">[-]</label><label class="expand" for="c-36162161">[1 more]</label></div><br/><div class="children"><div class="content">Doing it locally is better, for mine.<p>eg<p><pre><code>  https:&#x2F;&#x2F;gitlab.com&#x2F;hal88&#x2F;junkcode&#x2F;-&#x2F;blob&#x2F;master&#x2F;c_template.c
</code></pre>
single file, chmod +x, compiles itself and executes the binary, can easily give the -S flag to gcc or clang (uncomment one line) or better yet run objdump on the binary.<p>The great thing is it still works if you include a bunch of local headers that are a hassle to supply to godbolt. Latency locally is a win.<p>The #if 0 trick for the compiler lines and #else for the code is a good one. Got it from Rusty Russell of iptables fame iirc. Write your script in C, why not?</div><br/></div></div></div></div></div></div><div id="36158234" class="c"><input type="checkbox" id="c-36158234" checked=""/><div class="controls bullet"><span class="by">JohnFen</span><span>|</span><a href="#36155471">parent</a><span>|</span><a href="#36155934">prev</a><span>|</span><a href="#36161205">next</a><span>|</span><label class="collapse" for="c-36158234">[-]</label><label class="expand" for="c-36158234">[1 more]</label></div><br/><div class="children"><div class="content">I did something very similar. Assembly was not my first language (it was my 4th), but I decided to learn it by writing a compiler and linker in it.<p>In for a penny, in for a pound.<p>&gt; The goal is not to program in assembly at all but to truely understand the cost of everything and what you can expect from your hardware.<p>Entirely this. Also, to help you understand more deeply how computers really work.<p>That said, being able to program in assembly is still of great use to me. I do it to this day, usually on ARM processors -- not entire programs anymore, but critical parts.</div><br/></div></div><div id="36161205" class="c"><input type="checkbox" id="c-36161205" checked=""/><div class="controls bullet"><span class="by">moreice</span><span>|</span><a href="#36155471">parent</a><span>|</span><a href="#36158234">prev</a><span>|</span><a href="#36158842">next</a><span>|</span><label class="collapse" for="c-36161205">[-]</label><label class="expand" for="c-36161205">[2 more]</label></div><br/><div class="children"><div class="content">I can see the value of writing an emulator, but what was the benefit of translating from machine code to assembly instructions?</div><br/><div id="36161650" class="c"><input type="checkbox" id="c-36161650" checked=""/><div class="controls bullet"><span class="by">shzhdbi09gv8ioi</span><span>|</span><a href="#36155471">root</a><span>|</span><a href="#36161205">parent</a><span>|</span><a href="#36158842">next</a><span>|</span><label class="collapse" for="c-36161650">[-]</label><label class="expand" for="c-36161650">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but what was the benefit of translating from machine code to assembly instructions<p>In order to read it, I suppose? There&#x27;s no reason for memorizing binary encoding schemes. I mean, you will learn that 0x90 is NOP on x86 but that doesn&#x27;t help you a whole lot.</div><br/></div></div></div></div><div id="36158842" class="c"><input type="checkbox" id="c-36158842" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#36155471">parent</a><span>|</span><a href="#36161205">prev</a><span>|</span><a href="#36158668">next</a><span>|</span><label class="collapse" for="c-36158842">[-]</label><label class="expand" for="c-36158842">[2 more]</label></div><br/><div class="children"><div class="content">Why not recommend the computer program whose docs you&#x27;re linking? Emu8086 is one of the nicest tools I&#x27;ve ever used. It&#x27;s probably unobtainable these days though since last time I checked it&#x27;s no longer for sale. I have it though if anyone wants to do a midnight rendezvous.</div><br/><div id="36159191" class="c"><input type="checkbox" id="c-36159191" checked=""/><div class="controls bullet"><span class="by">wudangmonk</span><span>|</span><a href="#36155471">root</a><span>|</span><a href="#36158842">parent</a><span>|</span><a href="#36158668">next</a><span>|</span><label class="collapse" for="c-36159191">[-]</label><label class="expand" for="c-36159191">[1 more]</label></div><br/><div class="children"><div class="content">I never realized it was a program until just now that you mentioned it. I only ever used that single page I linked when I came upon it one day while searching for how instructions affected the flags register.</div><br/></div></div></div></div><div id="36158668" class="c"><input type="checkbox" id="c-36158668" checked=""/><div class="controls bullet"><span class="by">29athrowaway</span><span>|</span><a href="#36155471">parent</a><span>|</span><a href="#36158842">prev</a><span>|</span><a href="#36153609">next</a><span>|</span><label class="collapse" for="c-36158668">[-]</label><label class="expand" for="c-36158668">[1 more]</label></div><br/><div class="children"><div class="content">I would suggest:<p>Step 1. Implement a simple calculator<p>Step 2. Create a file format that encodes sequences of instructions and operands for your calculator<p>Step 3. Create an interpreter for that file format that runs your file. Add an accumulator and flags that represent overflow and such. And a instruction pointer.<p>Step 4: Add comments support to your file format (optional)<p>Step 5. Add support for logical operators, comparisons to your file format and interpreter<p>Step 6. Add support for labels and jumps to your file format and interpreter<p>Step 7. Add support for a stack, memory and related operators to your interpreter<p>In the end you should end up with something like<p><a href="https:&#x2F;&#x2F;yjdoc2.github.io&#x2F;8086-emulator-web&#x2F;compile" rel="nofollow">https:&#x2F;&#x2F;yjdoc2.github.io&#x2F;8086-emulator-web&#x2F;compile</a></div><br/></div></div></div></div><div id="36153609" class="c"><input type="checkbox" id="c-36153609" checked=""/><div class="controls bullet"><span class="by">steppi</span><span>|</span><a href="#36155471">prev</a><span>|</span><a href="#36159313">next</a><span>|</span><label class="collapse" for="c-36153609">[-]</label><label class="expand" for="c-36153609">[2 more]</label></div><br/><div class="children"><div class="content">This is a really cool little example. I&#x27;ve been teaching myself assembly recently and have found <i>Learn to Program with Assembly</i> (2021) [0] by Johnathan Bartlett to be really valuable. I had initially looked through his freely available book <i>Programming From the Ground Up</i> (2003) [1], which covers x86 assembly, and ended up buying the updated book after finding the old one to be well written but out of date. I&#x27;ve been programming in C for a long time and it&#x27;s been very cool to dig a little deeper and understand better what&#x27;s really going on under the hood.<p>[0] <a href="https:&#x2F;&#x2F;www.bartlettpublishing.com&#x2F;site&#x2F;books&#x2F;learn-to-program-with-assembly&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.bartlettpublishing.com&#x2F;site&#x2F;books&#x2F;learn-to-progr...</a><p>[1] <a href="https:&#x2F;&#x2F;download-mirror.savannah.gnu.org&#x2F;releases&#x2F;pgubook&#x2F;ProgrammingGroundUp-1-0-booksize.pdf" rel="nofollow">https:&#x2F;&#x2F;download-mirror.savannah.gnu.org&#x2F;releases&#x2F;pgubook&#x2F;Pr...</a></div><br/><div id="36160247" class="c"><input type="checkbox" id="c-36160247" checked=""/><div class="controls bullet"><span class="by">anta40</span><span>|</span><a href="#36153609">parent</a><span>|</span><a href="#36159313">next</a><span>|</span><label class="collapse" for="c-36160247">[-]</label><label class="expand" for="c-36160247">[1 more]</label></div><br/><div class="children"><div class="content">Someone ported PGU code to MacOS:
<a href="https:&#x2F;&#x2F;github.com&#x2F;lmartinho&#x2F;pgubook-macos-x86-64">https:&#x2F;&#x2F;github.com&#x2F;lmartinho&#x2F;pgubook-macos-x86-64</a><p>Seems very handy, since most assembly tutorials nowadays are Windows&#x2F;Linux-specific.</div><br/></div></div></div></div><div id="36159313" class="c"><input type="checkbox" id="c-36159313" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#36153609">prev</a><span>|</span><a href="#36153717">next</a><span>|</span><label class="collapse" for="c-36159313">[-]</label><label class="expand" for="c-36159313">[2 more]</label></div><br/><div class="children"><div class="content"><i>Always use the standard function prologs and epilogs</i><p>This sounds like another one of those common &quot;learn Asm by acting like a compiler&quot; articles, which IMHO completely misses one of the best reasons to learn Asm: you can beat the compiler on size (relatively easy), speed (often harder), or both, precisely by <i>not</i> acting like one. I suspect the author, like so many others, also learned from only reading (some) compiler output. The complete lack of any use of static initialised data is shocking.<p><pre><code>    mov rdi, rdi
    lea rsi, [rsp]
</code></pre>
Please don&#x27;t do this. Even a compiler can do better at O0.<p><i>Stripped and OMAGIC (--omagic linker flag, from the man page: Set the text and data sections to be readable and writable. Also, do not page-align the data segment): 1776 bytes (1 KiB)</i><p>Besides being a very notable date (was that deliberate?), 1776 is closer to 2k than 1k. I suspect if you wrote it in C with inline Asm for the syscalls, it wouldn&#x27;t be much bigger (and may even be a little smaller.)<p>If you want to see what Asm can really do, the sub-1k categories in the demoscene are well worth looking at.</div><br/><div id="36159871" class="c"><input type="checkbox" id="c-36159871" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#36159313">parent</a><span>|</span><a href="#36153717">next</a><span>|</span><label class="collapse" for="c-36159871">[-]</label><label class="expand" for="c-36159871">[1 more]</label></div><br/><div class="children"><div class="content">Like the Lambda Calculus in 383 bytes. <a href="https:&#x2F;&#x2F;justine.lol&#x2F;lambda&#x2F;" rel="nofollow">https:&#x2F;&#x2F;justine.lol&#x2F;lambda&#x2F;</a></div><br/></div></div></div></div><div id="36153717" class="c"><input type="checkbox" id="c-36153717" checked=""/><div class="controls bullet"><span class="by">freedomben</span><span>|</span><a href="#36159313">prev</a><span>|</span><a href="#36156710">next</a><span>|</span><label class="collapse" for="c-36153717">[-]</label><label class="expand" for="c-36153717">[31 more]</label></div><br/><div class="children"><div class="content">What sort of jobs are there these days that use assembly?  Is anybody still using it directly?<p>These are pretty non-specific, but these are area I know about already for others who may have the same question as me:<p>1.  Compiler development<p>2.  Security research (malware analysis&#x2F;reverse engineering) - although not much if any writing assembly, just reading<p>3.  Kernel development - again mostly just reading assembly, not writing it.  Bulk of code written in C (or potentially a very recent development, rust)<p>4.  Driver development - mostly C but some devices can involve assembly</div><br/><div id="36154545" class="c"><input type="checkbox" id="c-36154545" checked=""/><div class="controls bullet"><span class="by">zxexz</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36153974">next</a><span>|</span><label class="collapse" for="c-36154545">[-]</label><label class="expand" for="c-36154545">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;d be surprised how often knowing assembly can come in useful - I certainly never expected it. I work in the healthcare sector, which is infamous for having tons of legacy software. At least a couple times a year I end up finding it useful to load some ancient binary into radare2 or Ghidra for debugging, extracting data, or just adding a jmp to avoid a problematic syscall. I&#x27;m by no means an assembly expert, but know enough to get the job done.</div><br/><div id="36161886" class="c"><input type="checkbox" id="c-36161886" checked=""/><div class="controls bullet"><span class="by">npsomaratna</span><span>|</span><a href="#36153717">root</a><span>|</span><a href="#36154545">parent</a><span>|</span><a href="#36153974">next</a><span>|</span><label class="collapse" for="c-36161886">[-]</label><label class="expand" for="c-36161886">[1 more]</label></div><br/><div class="children"><div class="content">Yup. I&#x27;ve not used assembly at work, but it&#x27;s come in useful at home. A couple of times, I&#x27;ve had to insert or adjust JMP commands to get legacy software to function.</div><br/></div></div></div></div><div id="36153974" class="c"><input type="checkbox" id="c-36153974" checked=""/><div class="controls bullet"><span class="by">retrac</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36154545">prev</a><span>|</span><a href="#36155739">next</a><span>|</span><label class="collapse" for="c-36153974">[-]</label><label class="expand" for="c-36153974">[3 more]</label></div><br/><div class="children"><div class="content">Small embedded systems.  There are microcontrollers that cost like 3 cents in bulk.  8-bit machines with a few kilobytes of PROM and perhaps just 64 bytes of RAM.  While such machines often do have C compilers (of a sort) for them, old-school optimization techniques sometimes come into play.</div><br/><div id="36156979" class="c"><input type="checkbox" id="c-36156979" checked=""/><div class="controls bullet"><span class="by">lost_tourist</span><span>|</span><a href="#36153717">root</a><span>|</span><a href="#36153974">parent</a><span>|</span><a href="#36155739">next</a><span>|</span><label class="collapse" for="c-36156979">[-]</label><label class="expand" for="c-36156979">[2 more]</label></div><br/><div class="children"><div class="content">I used to enjoy that stuff, but these days if it seems like a job requires any significant assembly, I just turn it down. I hate worrying about every single byte of memory, it takes all the fun out for me, but I do know those who love figuring out a tough problem and always having to be efficient with every bit and byte.</div><br/><div id="36158443" class="c"><input type="checkbox" id="c-36158443" checked=""/><div class="controls bullet"><span class="by">aidos</span><span>|</span><a href="#36153717">root</a><span>|</span><a href="#36156979">parent</a><span>|</span><a href="#36155739">next</a><span>|</span><label class="collapse" for="c-36158443">[-]</label><label class="expand" for="c-36158443">[1 more]</label></div><br/><div class="children"><div class="content">There are tough problems at every layer of the stack. Granted, the problems look very different, but theyâre no less challenging. I think that is one of the great things about being a software developer - wherever you look, there are interesting things to explore. I studied assembly some 20+ years ago and have barely seen it since, though Iâve worked on a lot of complex technical problems since then.</div><br/></div></div></div></div></div></div><div id="36155739" class="c"><input type="checkbox" id="c-36155739" checked=""/><div class="controls bullet"><span class="by">sfink</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36153974">prev</a><span>|</span><a href="#36153850">next</a><span>|</span><label class="collapse" for="c-36155739">[-]</label><label class="expand" for="c-36155739">[1 more]</label></div><br/><div class="children"><div class="content">Anything where you get crash reports back from the field. It is very valuable to be able to read assembly code and map registers to their purpose, and then perhaps back to the source code that generated the assembly. Debuginfo will sometimes give you some of that, but is unreliable, incomplete, and can be hard to match up to the stripped binary you&#x27;re looking at. Recognizing values that are likely to be stack vs uninitialized or poisoned vs corrupted vs nullptr or offsets to nullptr... it can turn a crash report from absolutely cryptic into something that gives you the lead you need.<p>(Also, if you are dealing with something with mass deployment, it&#x27;s good to recognize the single-bit flips that are hallmarks of bad RAM. But don&#x27;t assume too much; bit flips are also the sign of bit flag manipulations.)</div><br/></div></div><div id="36153850" class="c"><input type="checkbox" id="c-36153850" checked=""/><div class="controls bullet"><span class="by">zerkten</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36155739">prev</a><span>|</span><a href="#36154239">next</a><span>|</span><label class="collapse" for="c-36153850">[-]</label><label class="expand" for="c-36153850">[1 more]</label></div><br/><div class="children"><div class="content">According to friends reading is still fairly prevalent for Windows and other products at Microsoft. Kind of a requirement to succeed in jobs with a C&#x2F;C++ product where you might only have memory dumps to debug. It&#x27;s also expected to some extent if you are a performance guru in some areas.</div><br/></div></div><div id="36154239" class="c"><input type="checkbox" id="c-36154239" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36153850">prev</a><span>|</span><a href="#36160053">next</a><span>|</span><label class="collapse" for="c-36154239">[-]</label><label class="expand" for="c-36154239">[1 more]</label></div><br/><div class="children"><div class="content">Any sort of performance engineering will likely require competence with assembly, although direct programming in assembly may be relatively rare in such roles.</div><br/></div></div><div id="36160053" class="c"><input type="checkbox" id="c-36160053" checked=""/><div class="controls bullet"><span class="by">CodeArtisan</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36154239">prev</a><span>|</span><a href="#36153828">next</a><span>|</span><label class="collapse" for="c-36160053">[-]</label><label class="expand" for="c-36160053">[1 more]</label></div><br/><div class="children"><div class="content">Video encoders usually have a decent amount of assembly code.<p>eg:<p>x264 <a href="https:&#x2F;&#x2F;code.videolan.org&#x2F;videolan&#x2F;x264&#x2F;-&#x2F;tree&#x2F;master&#x2F;common&#x2F;x86" rel="nofollow">https:&#x2F;&#x2F;code.videolan.org&#x2F;videolan&#x2F;x264&#x2F;-&#x2F;tree&#x2F;master&#x2F;common...</a><p>ffmpeg <a href="https:&#x2F;&#x2F;git.ffmpeg.org&#x2F;gitweb&#x2F;ffmpeg.git&#x2F;tree&#x2F;HEAD:&#x2F;libavcodec&#x2F;x86" rel="nofollow">https:&#x2F;&#x2F;git.ffmpeg.org&#x2F;gitweb&#x2F;ffmpeg.git&#x2F;tree&#x2F;HEAD:&#x2F;libavcod...</a><p>if you go up, you will find folders for other architectures (ARM, MIPS, SuperH, ...)</div><br/></div></div><div id="36153828" class="c"><input type="checkbox" id="c-36153828" checked=""/><div class="controls bullet"><span class="by">steppi</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36160053">prev</a><span>|</span><a href="#36154415">next</a><span>|</span><label class="collapse" for="c-36153828">[-]</label><label class="expand" for="c-36153828">[6 more]</label></div><br/><div class="children"><div class="content">Another example is writing hand optimized matrix and vector operation routines tailored to specific hardware for BLAS libraries [0].<p>[0] <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Basic_Linear_Algebra_Subprograms" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Basic_Linear_Algebra_Subprog...</a></div><br/><div id="36154761" class="c"><input type="checkbox" id="c-36154761" checked=""/><div class="controls bullet"><span class="by">KeplerBoy</span><span>|</span><a href="#36153717">root</a><span>|</span><a href="#36153828">parent</a><span>|</span><a href="#36154415">next</a><span>|</span><label class="collapse" for="c-36154761">[-]</label><label class="expand" for="c-36154761">[5 more]</label></div><br/><div class="children"><div class="content">Is this really still a thing?<p>Do people go further than using instrinsics for let&#x27;s say AVX?</div><br/><div id="36155147" class="c"><input type="checkbox" id="c-36155147" checked=""/><div class="controls bullet"><span class="by">retrac</span><span>|</span><a href="#36153717">root</a><span>|</span><a href="#36154761">parent</a><span>|</span><a href="#36158973">next</a><span>|</span><label class="collapse" for="c-36155147">[-]</label><label class="expand" for="c-36155147">[1 more]</label></div><br/><div class="children"><div class="content">Sure.  You&#x27;ll see it very often in codec implementations.  From rav1e, a fast AV1 encoder mostly written in Rust: <a href="https:&#x2F;&#x2F;github.com&#x2F;xiph&#x2F;rav1e&#x2F;tree&#x2F;master&#x2F;src&#x2F;x86">https:&#x2F;&#x2F;github.com&#x2F;xiph&#x2F;rav1e&#x2F;tree&#x2F;master&#x2F;src&#x2F;x86</a><p>Portions of the algorithm have been translated into assembly for ARM and x86.  Shaving even a couple percent off something like motion compensation search will add up to meaningful gains.  See also the current reference implementation of JPEG: <a href="https:&#x2F;&#x2F;github.com&#x2F;libjpeg-turbo&#x2F;libjpeg-turbo&#x2F;tree&#x2F;main&#x2F;simd&#x2F;x86_64">https:&#x2F;&#x2F;github.com&#x2F;libjpeg-turbo&#x2F;libjpeg-turbo&#x2F;tree&#x2F;main&#x2F;sim...</a></div><br/></div></div><div id="36158973" class="c"><input type="checkbox" id="c-36158973" checked=""/><div class="controls bullet"><span class="by">riceart</span><span>|</span><a href="#36153717">root</a><span>|</span><a href="#36154761">parent</a><span>|</span><a href="#36155147">prev</a><span>|</span><a href="#36155349">next</a><span>|</span><label class="collapse" for="c-36158973">[-]</label><label class="expand" for="c-36158973">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is this really still a thing?<p>Why wouldnât it be?
Compilers havenât advanced tremendously in the past two decades in terms of optimizations and donât have much new to add to high performance SIMD numeric kernels.</div><br/></div></div><div id="36155349" class="c"><input type="checkbox" id="c-36155349" checked=""/><div class="controls bullet"><span class="by">steppi</span><span>|</span><a href="#36153717">root</a><span>|</span><a href="#36154761">parent</a><span>|</span><a href="#36158973">prev</a><span>|</span><a href="#36157530">next</a><span>|</span><label class="collapse" for="c-36155349">[-]</label><label class="expand" for="c-36155349">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. I&#x27;m going to be helping to work on expanding CI for OpenBLAS and have been diving into this stuff lately. See the discussion in this closed OpenBLAS issue gh-1968 [0] for instance. OpenBLASâs Skylake kernels do rely heavily on intrinsics [1] for compilers that support them, but there&#x27;s a wide range of architectures to support, and when hand-tuned assembly kernels work better, that&#x27;s what are used. For example, [2].<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;xianyi&#x2F;OpenBLAS&#x2F;issues&#x2F;1968">https:&#x2F;&#x2F;github.com&#x2F;xianyi&#x2F;OpenBLAS&#x2F;issues&#x2F;1968</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;xianyi&#x2F;OpenBLAS&#x2F;blob&#x2F;develop&#x2F;kernel&#x2F;x86_64&#x2F;cgemm_kernel_8x2_skylakex.c">https:&#x2F;&#x2F;github.com&#x2F;xianyi&#x2F;OpenBLAS&#x2F;blob&#x2F;develop&#x2F;kernel&#x2F;x86_6...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;xianyi&#x2F;OpenBLAS&#x2F;blob&#x2F;23693f09a26ffd8b60ebdfbfd79ffa5b649d1289&#x2F;kernel&#x2F;arm64&#x2F;cgemm_kernel_8x4_cortexa53.c#L76-L290">https:&#x2F;&#x2F;github.com&#x2F;xianyi&#x2F;OpenBLAS&#x2F;blob&#x2F;23693f09a26ffd8b60eb...</a></div><br/></div></div><div id="36157530" class="c"><input type="checkbox" id="c-36157530" checked=""/><div class="controls bullet"><span class="by">mikebenfield</span><span>|</span><a href="#36153717">root</a><span>|</span><a href="#36154761">parent</a><span>|</span><a href="#36155349">prev</a><span>|</span><a href="#36154415">next</a><span>|</span><label class="collapse" for="c-36157530">[-]</label><label class="expand" for="c-36157530">[1 more]</label></div><br/><div class="children"><div class="content">FWIW I&#x27;ve found that compilers&#x27; code generation around intrinsics is often suboptimal in pretty obvious ways, moving data around needlessly, so I resort to assembly. For me this has just been for hobby side projects, but I&#x27;m sure people doing it for stuff that matters run into the same issue.</div><br/></div></div></div></div></div></div><div id="36154415" class="c"><input type="checkbox" id="c-36154415" checked=""/><div class="controls bullet"><span class="by">hu3</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36153828">prev</a><span>|</span><a href="#36159394">next</a><span>|</span><label class="collapse" for="c-36154415">[-]</label><label class="expand" for="c-36154415">[3 more]</label></div><br/><div class="children"><div class="content">Example of assembly in Go source code:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;master&#x2F;src&#x2F;crypto&#x2F;md5&#x2F;md5block_amd64.s">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;master&#x2F;src&#x2F;crypto&#x2F;md5&#x2F;md5b...</a></div><br/><div id="36154805" class="c"><input type="checkbox" id="c-36154805" checked=""/><div class="controls bullet"><span class="by">sgt</span><span>|</span><a href="#36153717">root</a><span>|</span><a href="#36154415">parent</a><span>|</span><a href="#36159394">next</a><span>|</span><label class="collapse" for="c-36154805">[-]</label><label class="expand" for="c-36154805">[2 more]</label></div><br/><div class="children"><div class="content">Interestingly, I believe Go enforces the mnemonics to be UPPER CASE.</div><br/><div id="36161028" class="c"><input type="checkbox" id="c-36161028" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36153717">root</a><span>|</span><a href="#36154805">parent</a><span>|</span><a href="#36159394">next</a><span>|</span><label class="collapse" for="c-36161028">[-]</label><label class="expand" for="c-36161028">[1 more]</label></div><br/><div class="children"><div class="content">Not only that, the assembly isn&#x27;t quite the real one, that is yet another thing they took from Plan 9 compilers.<p><a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;asm" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;asm</a></div><br/></div></div></div></div></div></div><div id="36159394" class="c"><input type="checkbox" id="c-36159394" checked=""/><div class="controls bullet"><span class="by">__loam</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36154415">prev</a><span>|</span><a href="#36161174">next</a><span>|</span><label class="collapse" for="c-36159394">[-]</label><label class="expand" for="c-36159394">[1 more]</label></div><br/><div class="children"><div class="content">Apparently there&#x27;s been some renewed interest in the Game Boy Advance as a platform for indie development (as well as other retro platforms). Programming on those requires some assembly knowledge, though I&#x27;m not sure you could call that a job.</div><br/></div></div><div id="36161174" class="c"><input type="checkbox" id="c-36161174" checked=""/><div class="controls bullet"><span class="by">jamesfinlayson</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36159394">prev</a><span>|</span><a href="#36153906">next</a><span>|</span><label class="collapse" for="c-36161174">[-]</label><label class="expand" for="c-36161174">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked at a place where the core system was still 10% or so assembly (it was written in the 1970s). I&#x27;m not sure if it needed much modification but it was absolutely business critical.</div><br/></div></div><div id="36153906" class="c"><input type="checkbox" id="c-36153906" checked=""/><div class="controls bullet"><span class="by">z3t4</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36161174">prev</a><span>|</span><a href="#36155285">next</a><span>|</span><label class="collapse" for="c-36153906">[-]</label><label class="expand" for="c-36153906">[1 more]</label></div><br/><div class="children"><div class="content">For programming CPUs that cost less then 1$. Like sensors. For low power usage. Or small form factor.</div><br/></div></div><div id="36155285" class="c"><input type="checkbox" id="c-36155285" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36153906">prev</a><span>|</span><a href="#36155950">next</a><span>|</span><label class="collapse" for="c-36155285">[-]</label><label class="expand" for="c-36155285">[1 more]</label></div><br/><div class="children"><div class="content">&gt; mostly just reading assembly, not writing it<p>Not always the case. You&#x27;re not writing it <i>all the time</i> but you still have to write it. For example the trampoline I use to jump from the boot stage to the kernel entry point is common-mapped between the two memory spaces and performs the switch inside of it, and then calls the kernel. That&#x27;s all in assembly.</div><br/></div></div><div id="36155950" class="c"><input type="checkbox" id="c-36155950" checked=""/><div class="controls bullet"><span class="by">Hackbraten</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36155285">prev</a><span>|</span><a href="#36156076">next</a><span>|</span><label class="collapse" for="c-36155950">[-]</label><label class="expand" for="c-36155950">[1 more]</label></div><br/><div class="children"><div class="content">Some software packages written in assembly during the 70s and 80s are still in production today, and may be difficult and expensive to replace.
I did some contract work for a steel plant in 2018. The primary control system for the plant was written in assembly. They were in the middle of doing a full rewrite, but in the meantime, they had to do maintenance and bugfixing for the in-production system in assembly.</div><br/></div></div><div id="36156076" class="c"><input type="checkbox" id="c-36156076" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36155950">prev</a><span>|</span><a href="#36154787">next</a><span>|</span><label class="collapse" for="c-36156076">[-]</label><label class="expand" for="c-36156076">[1 more]</label></div><br/><div class="children"><div class="content">Developing hardware diagnostic utilities can be another area.<p>The kinds of utilities that come built into ROM, or that you run from a CD or USB drive,  where you test memory and disk by writing different bit patterns to them, reading them back, and checking if they match, probing the hardware, processor and peripherals, etc.</div><br/></div></div><div id="36154787" class="c"><input type="checkbox" id="c-36154787" checked=""/><div class="controls bullet"><span class="by">eschneider</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36156076">prev</a><span>|</span><a href="#36155785">next</a><span>|</span><label class="collapse" for="c-36154787">[-]</label><label class="expand" for="c-36154787">[1 more]</label></div><br/><div class="children"><div class="content">Board bring up usually needs a bit of assembly. Certainly needs some reading knowledge of assembly.</div><br/></div></div><div id="36155785" class="c"><input type="checkbox" id="c-36155785" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36154787">prev</a><span>|</span><a href="#36154567">next</a><span>|</span><label class="collapse" for="c-36155785">[-]</label><label class="expand" for="c-36155785">[1 more]</label></div><br/><div class="children"><div class="content">Writing it from scratch is not nearly as common as reading it and understanding it. I think pretty much every systems programmer will have to stare at disassembly output from time to time.</div><br/></div></div><div id="36154567" class="c"><input type="checkbox" id="c-36154567" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36155785">prev</a><span>|</span><a href="#36154890">next</a><span>|</span><label class="collapse" for="c-36154567">[-]</label><label class="expand" for="c-36154567">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d guess there are more jobs that use assembly than jobs where you write the X server protocol directly to the socket.</div><br/></div></div><div id="36154890" class="c"><input type="checkbox" id="c-36154890" checked=""/><div class="controls bullet"><span class="by">TheLoafOfBread</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36154567">prev</a><span>|</span><a href="#36153956">next</a><span>|</span><label class="collapse" for="c-36154890">[-]</label><label class="expand" for="c-36154890">[1 more]</label></div><br/><div class="children"><div class="content">5. Emulators - You will be trying to understand every instruction as deeply as possible.</div><br/></div></div><div id="36153956" class="c"><input type="checkbox" id="c-36153956" checked=""/><div class="controls bullet"><span class="by">bryanlarsen</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36154890">prev</a><span>|</span><a href="#36153936">next</a><span>|</span><label class="collapse" for="c-36153956">[-]</label><label class="expand" for="c-36153956">[1 more]</label></div><br/><div class="children"><div class="content">Also bootloader development will usually require some assembly.</div><br/></div></div><div id="36153936" class="c"><input type="checkbox" id="c-36153936" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36153717">parent</a><span>|</span><a href="#36153956">prev</a><span>|</span><a href="#36156710">next</a><span>|</span><label class="collapse" for="c-36153936">[-]</label><label class="expand" for="c-36153936">[1 more]</label></div><br/><div class="children"><div class="content">game engine development</div><br/></div></div></div></div><div id="36156710" class="c"><input type="checkbox" id="c-36156710" checked=""/><div class="controls bullet"><span class="by">jagged-chisel</span><span>|</span><a href="#36153717">prev</a><span>|</span><a href="#36153794">next</a><span>|</span><label class="collapse" for="c-36156710">[-]</label><label class="expand" for="c-36156710">[2 more]</label></div><br/><div class="children"><div class="content">Seeing the headline, one could be scared away thinking this is bare metal from scratch. It is not.<p>The app is an X11 client and will run under an OS, meaning youâll learn to make system calls and other library calls to get things on the screen. Very educational, and not scary-deep.</div><br/><div id="36158661" class="c"><input type="checkbox" id="c-36158661" checked=""/><div class="controls bullet"><span class="by">tengwar2</span><span>|</span><a href="#36156710">parent</a><span>|</span><a href="#36153794">next</a><span>|</span><label class="collapse" for="c-36158661">[-]</label><label class="expand" for="c-36158661">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also not that hard to write a simple real bare-metal GUI in assembler. I had to built some lab apparatus under OS&#x2F;2 1.0, which didn&#x27;t have a GUI, and most of it was in  assembler. It&#x27;s a while back, but from memory, the main bits I needed were lines and circle segments (using Bresenham&#x27;s algorithm);  mouse pointer draw&#x2F;refresh; writing text (I copied bitmaps for VGA text from MS&#x2F;DOS); menus; text entry; and mouse drag as a way of selecting an area or marking a circle. Apart from the mouse pointer, it was single-threaded and pretty simplistic, but good enough to be in use for several years. It had to be: it wasn&#x27;t easy to move to OS&#x2F;2 1.1 and get the Presentation Manage GUI because they changed the memory model and for performance reasons some of the bit-bashing I needed for a non-GUI part of the system was done with a large amount of wire-wrap. Anyway, the bare-metal GUI bit was really pretty simple to implement.</div><br/></div></div></div></div><div id="36153794" class="c"><input type="checkbox" id="c-36153794" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#36156710">prev</a><span>|</span><a href="#36159789">next</a><span>|</span><label class="collapse" for="c-36153794">[-]</label><label class="expand" for="c-36153794">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Note that Linux has a âfunâ difference, which is that the fourth parameter of a system call is actually passed using the register r10.<p>Why is Linux singled out there? No OS can use rcx for that, since the syscall instruction itself overwrites rcx with the return address.</div><br/><div id="36158101" class="c"><input type="checkbox" id="c-36158101" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#36153794">parent</a><span>|</span><a href="#36156059">next</a><span>|</span><label class="collapse" for="c-36158101">[-]</label><label class="expand" for="c-36158101">[2 more]</label></div><br/><div class="children"><div class="content">are you saying &quot;they couldn&#x27;t use rcx so they use r10, just like everybody else&quot;? Because the quote says r10 and you brought up rcx<p>in any case, there&#x27;s a good discussion of registers and syscalls here<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;53290932&#x2F;what-are-r10-r15-registers-used-for-in-the-windows-x64-calling-convention" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;53290932&#x2F;what-are-r10-r1...</a></div><br/><div id="36158620" class="c"><input type="checkbox" id="c-36158620" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#36153794">root</a><span>|</span><a href="#36158101">parent</a><span>|</span><a href="#36156059">next</a><span>|</span><label class="collapse" for="c-36158620">[-]</label><label class="expand" for="c-36158620">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s the full quote:<p>&gt; Following the System V ABI, which is required on Linux and other Unices for system calls, invoking a system call requires us to put the system call code in the register rax, the parameters to the syscall (up to 6) in the registers rdi, rsi, rdx, rcx, r8, r9, and additional parameters, if any, on the stack (which will not happen in this program so we can forget about it). We then use the instruction syscall and check rax for the return value, 0 usually meaning: no error.<p>&gt; Note that Linux has a âfunâ difference, which is that the fourth parameter of a system call is actually passed using the register r10.<p>That makes it sound like it&#x27;s only Linux that uses r10 and every other OS uses rcx as the 4th parameter with syscall, but really no OS uses rcx with syscall.</div><br/></div></div></div></div><div id="36156059" class="c"><input type="checkbox" id="c-36156059" checked=""/><div class="controls bullet"><span class="by">laxd</span><span>|</span><a href="#36153794">parent</a><span>|</span><a href="#36158101">prev</a><span>|</span><a href="#36159789">next</a><span>|</span><label class="collapse" for="c-36156059">[-]</label><label class="expand" for="c-36156059">[2 more]</label></div><br/><div class="children"><div class="content">Some use stack for syscall params.</div><br/><div id="36158673" class="c"><input type="checkbox" id="c-36158673" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#36153794">root</a><span>|</span><a href="#36156059">parent</a><span>|</span><a href="#36159789">next</a><span>|</span><label class="collapse" for="c-36158673">[-]</label><label class="expand" for="c-36158673">[1 more]</label></div><br/><div class="children"><div class="content">On amd64? Which ones?</div><br/></div></div></div></div></div></div><div id="36159789" class="c"><input type="checkbox" id="c-36159789" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#36153794">prev</a><span>|</span><a href="#36153928">next</a><span>|</span><label class="collapse" for="c-36159789">[-]</label><label class="expand" for="c-36159789">[2 more]</label></div><br/><div class="children"><div class="content">&gt; âportingâ this program to, say, FreeBSD, would only require to change those [system call numbers]<p>This is not correct. Only Linux has a stable kernel-userspace interface which allows you to depend on these numbers. In pretty much every other operating system, you are required to use the system libraries they provide. Compiling a program with these numbers hardcoded into them will cause them to break when the OS developers change the syscalls.<p>I wrote an article about this with more details and lots of citations:<p><a href="https:&#x2F;&#x2F;www.matheusmoreira.com&#x2F;linux&#x2F;system-calls" rel="nofollow">https:&#x2F;&#x2F;www.matheusmoreira.com&#x2F;linux&#x2F;system-calls</a></div><br/><div id="36161632" class="c"><input type="checkbox" id="c-36161632" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#36159789">parent</a><span>|</span><a href="#36153928">next</a><span>|</span><label class="collapse" for="c-36161632">[-]</label><label class="expand" for="c-36161632">[1 more]</label></div><br/><div class="children"><div class="content">FreeBSD may not promise stable system calls, but it usually delivers.<p>The documented procedure for upgrades is update the kernel, reboot, update userland, restart deamons as needed. That only works if the old userland can run on the new kernel, so usually it can. Certainly there have been exceptions, but in my experience, they&#x27;ve all been fixed.<p>FreeBSD documentation includes a guide on assembly programming [1], which means libc isn&#x27;t the only acceptable interface to the kernel.<p>Staticly linked executables are supported by the included compiler, those are expected to continue to work after kernel updates, which requires syscall stability.<p>Syscalls that take structures at risk of changing sizes generally include size as a parameter or within the structure, and the transitions to different sizes haven&#x27;t always been easy (cpuset increases were rough in the past, but the next one will be better), but the syscall interface didn&#x27;t change really.<p>[1] <a href="https:&#x2F;&#x2F;docs.freebsd.org&#x2F;en&#x2F;books&#x2F;developers-handbook&#x2F;x86&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.freebsd.org&#x2F;en&#x2F;books&#x2F;developers-handbook&#x2F;x86&#x2F;</a></div><br/></div></div></div></div><div id="36153928" class="c"><input type="checkbox" id="c-36153928" checked=""/><div class="controls bullet"><span class="by">zerkten</span><span>|</span><a href="#36159789">prev</a><span>|</span><a href="#36161980">next</a><span>|</span><label class="collapse" for="c-36153928">[-]</label><label class="expand" for="c-36153928">[5 more]</label></div><br/><div class="children"><div class="content">Writing Win32 programs in assembly was a niche in the late-90s. This post inspired me to do some googling for a project I was familiar with back then and discovered the author has brought it back to life at <a href="https:&#x2F;&#x2F;github.com&#x2F;ThomasJaeger&#x2F;VisualMASM">https:&#x2F;&#x2F;github.com&#x2F;ThomasJaeger&#x2F;VisualMASM</a>.</div><br/><div id="36160316" class="c"><input type="checkbox" id="c-36160316" checked=""/><div class="controls bullet"><span class="by">anta40</span><span>|</span><a href="#36153928">parent</a><span>|</span><a href="#36157205">next</a><span>|</span><label class="collapse" for="c-36160316">[-]</label><label class="expand" for="c-36160316">[2 more]</label></div><br/><div class="children"><div class="content">The MASM SDK project is still alive and pretty active.<p><a href="https:&#x2F;&#x2F;www.masm32.com&#x2F;download.htm" rel="nofollow">https:&#x2F;&#x2F;www.masm32.com&#x2F;download.htm</a>.<p>Nowadays I mostly work on Linux and Mac, and wonder why there&#x27;s no equivalent project exist. Perhaps those Unix coders are satisfied enough with C...</div><br/><div id="36161502" class="c"><input type="checkbox" id="c-36161502" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36153928">root</a><span>|</span><a href="#36160316">parent</a><span>|</span><a href="#36157205">next</a><span>|</span><label class="collapse" for="c-36161502">[-]</label><label class="expand" for="c-36161502">[1 more]</label></div><br/><div class="children"><div class="content">Not sure why I would use that instead of the Windows SDK proper.<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;assembler&#x2F;masm&#x2F;microsoft-macro-assembler-reference?view=msvc-170" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;assembler&#x2F;masm&#x2F;microso...</a><p>Regarding UNIX, due to macro assembler nature of K&amp;R C, and the spread of UNIX source tapes, there was never an Assembly culture like on the home computers where we had an integrated experience, of hardware and OS, that defined the platform.<p>It is similar to how John Carmack describes the IDE culture from those of us that grew up with those platforms, versus UNIX.</div><br/></div></div></div></div><div id="36157205" class="c"><input type="checkbox" id="c-36157205" checked=""/><div class="controls bullet"><span class="by">FartyMcFarter</span><span>|</span><a href="#36153928">parent</a><span>|</span><a href="#36160316">prev</a><span>|</span><a href="#36155923">next</a><span>|</span><label class="collapse" for="c-36157205">[-]</label><label class="expand" for="c-36157205">[1 more]</label></div><br/><div class="children"><div class="content">If I remember correctly there were websites with tutorials naming this style of programming &quot;win32asm&quot;. This is the one I remember:<p><a href="http:&#x2F;&#x2F;www.afturgurluk.net&#x2F;documents&#x2F;Info&#x2F;Win32ASM&#x2F;Iczelion%20tut&#x2F;index.htm" rel="nofollow">http:&#x2F;&#x2F;www.afturgurluk.net&#x2F;documents&#x2F;Info&#x2F;Win32ASM&#x2F;Iczelion%...</a></div><br/></div></div><div id="36155923" class="c"><input type="checkbox" id="c-36155923" checked=""/><div class="controls bullet"><span class="by">SeenNotHeard</span><span>|</span><a href="#36153928">parent</a><span>|</span><a href="#36157205">prev</a><span>|</span><a href="#36161980">next</a><span>|</span><label class="collapse" for="c-36155923">[-]</label><label class="expand" for="c-36155923">[1 more]</label></div><br/><div class="children"><div class="content">One of the great video games of the late 90s, Rollercoaster Tycoon, was coded in assembly.  Even back then, that was considered a feat.</div><br/></div></div></div></div><div id="36161980" class="c"><input type="checkbox" id="c-36161980" checked=""/><div class="controls bullet"><span class="by">herewulf</span><span>|</span><a href="#36153928">prev</a><span>|</span><a href="#36159072">next</a><span>|</span><label class="collapse" for="c-36161980">[-]</label><label class="expand" for="c-36161980">[1 more]</label></div><br/><div class="children"><div class="content">Excellent. Now how do I blit some pixels?<p>This takes me back about 30 years as a youngster discovering the magic ASM incantation to efficiently draw to the screen in DOS mode 0x13.</div><br/></div></div><div id="36159072" class="c"><input type="checkbox" id="c-36159072" checked=""/><div class="controls bullet"><span class="by">Havoc</span><span>|</span><a href="#36161980">prev</a><span>|</span><a href="#36157068">next</a><span>|</span><label class="collapse" for="c-36159072">[-]</label><label class="expand" for="c-36159072">[2 more]</label></div><br/><div class="children"><div class="content">I respect people doing this sort of thing but hard pass from me. Even my venturing into rust is plagued by doubts as to whether itâs too low level for productivity</div><br/><div id="36159905" class="c"><input type="checkbox" id="c-36159905" checked=""/><div class="controls bullet"><span class="by">bschwindHN</span><span>|</span><a href="#36159072">parent</a><span>|</span><a href="#36157068">next</a><span>|</span><label class="collapse" for="c-36159905">[-]</label><label class="expand" for="c-36159905">[1 more]</label></div><br/><div class="children"><div class="content">I would say Rust is quite high level. You can write entire, useful programs without once having to think about memory, pointers, allocation, etc.<p>Of course that won&#x27;t be true for every program, but it&#x27;s worlds away from asm.</div><br/></div></div></div></div><div id="36157068" class="c"><input type="checkbox" id="c-36157068" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#36159072">prev</a><span>|</span><a href="#36160510">next</a><span>|</span><label class="collapse" for="c-36157068">[-]</label><label class="expand" for="c-36157068">[1 more]</label></div><br/><div class="children"><div class="content">For anyone interested in x64 assembly, it&#x27;s worth noting that a new edition of Jeff Duntemann&#x27;s excellent and classic introductory book on assembly, now fully updated for x64, is sitting with his publishers and is likely to be out sometime around the summer.<p>Source: <a href="http:&#x2F;&#x2F;www.contrapositivediary.com&#x2F;?m=20230222" rel="nofollow">http:&#x2F;&#x2F;www.contrapositivediary.com&#x2F;?m=20230222</a></div><br/></div></div><div id="36153625" class="c"><input type="checkbox" id="c-36153625" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#36160510">prev</a><span>|</span><a href="#36153620">next</a><span>|</span><label class="collapse" for="c-36153625">[-]</label><label class="expand" for="c-36153625">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I will be using the Linux system call values, but âportingâ this program to, say, FreeBSD, would only require to change those values<p>Is that true?  I remember ~20 years ago I was looking at the i386 syscall ABIs (since amd64 wasn&#x27;t big then), and there, Linux syscalls passed arguments by register and FreeBSD passed them on the stack.  Maybe for amd64, FreeBSD switched to pass by register on Intel, but I wouldn&#x27;t assume a syscall ABI is such a quick and simple substitution.</div><br/><div id="36157879" class="c"><input type="checkbox" id="c-36157879" checked=""/><div class="controls bullet"><span class="by">bitshiffed</span><span>|</span><a href="#36153625">parent</a><span>|</span><a href="#36153620">next</a><span>|</span><label class="collapse" for="c-36157879">[-]</label><label class="expand" for="c-36157879">[1 more]</label></div><br/><div class="children"><div class="content">For amd64 they both use the same registers to pass arguments.<p>But, the BSD syscalls use the carry flag to indicate error, rather than the returned value of rax being negative. If your syscalls always succeed, and never return values within what would be a negative range as a signed value, then the code would run; but that&#x27;s not exactly &quot;portable&quot;.</div><br/></div></div></div></div><div id="36153620" class="c"><input type="checkbox" id="c-36153620" checked=""/><div class="controls bullet"><span class="by">Croftengea</span><span>|</span><a href="#36153625">prev</a><span>|</span><a href="#36154373">next</a><span>|</span><label class="collapse" for="c-36153620">[-]</label><label class="expand" for="c-36153620">[2 more]</label></div><br/><div class="children"><div class="content">TL;DR: the article explains how to open a new window in X11 and print &quot;Hello, world&quot; in assembly. The asm code to achieve this is 618 lines long.</div><br/><div id="36154006" class="c"><input type="checkbox" id="c-36154006" checked=""/><div class="controls bullet"><span class="by">ripe</span><span>|</span><a href="#36153620">parent</a><span>|</span><a href="#36154373">next</a><span>|</span><label class="collapse" for="c-36154006">[-]</label><label class="expand" for="c-36154006">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for summarizing! This adds a lot of color to the headline. I was imagining a framebuffer-based GUI.</div><br/></div></div></div></div><div id="36154373" class="c"><input type="checkbox" id="c-36154373" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#36153620">prev</a><span>|</span><a href="#36153989">next</a><span>|</span><label class="collapse" for="c-36154373">[-]</label><label class="expand" for="c-36154373">[9 more]</label></div><br/><div class="children"><div class="content">This is awesome, thanks for submitting and thanks to the author.<p>* I would like to understand the assembly used for exception handling. Does anybody know how exceptions work at an assembly level? (I am interested in algebraic effects)<p>* Need to create a closure in assembly.<p>* I have some assembly ported to GNU assembly based on a blog post whose website is down that executes coroutines.</div><br/><div id="36156685" class="c"><input type="checkbox" id="c-36156685" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#36154373">parent</a><span>|</span><a href="#36155324">next</a><span>|</span><label class="collapse" for="c-36156685">[-]</label><label class="expand" for="c-36156685">[1 more]</label></div><br/><div class="children"><div class="content">&gt; * I would like to understand the assembly used for exception handling. Does anybody know how exceptions work at an assembly level? (I am interested in algebraic effects)<p>Assembly doesn&#x27;t really have a concept of exceptions. System defined exceptions and handlers exist, like if you&#x27;re on x86 and run in protected mode, you can get a processor exception if you access a memory address that&#x27;s not mapped for the type of access you do; that functions more or less like an interrupt; if you&#x27;re running in an operating system, the operating system will handle that in some way, and maybe pass that information to your program in some way (or maybe just kill your program), but again, that&#x27;ll be defined by the system you&#x27;re on, and we can&#x27;t talk much generally. On some systems you can get an exception for math errors (divide by zero, overflow, etc), on others you have to test for them, some systems will generate an exception for unaligned data access, some won&#x27;t, etc.<p>&gt; * Need to create a closure in assembly.<p>Again, this isn&#x27;t really an assembly concept. You&#x27;ve got to define what a closure means to you, and then build that however you like. In my mind, a closure is more or less a function plus a list of variables, in assembly, I&#x27;d model that as the address of a function that takes several addresses as parameters, but passing parameters is up to you --- if you&#x27;re calling your own functions, you don&#x27;t need to follow any particular convention on parameter passing, it just needs to make sense to you, and be written in a way that does what you mean: the computer will do what you told it to, which isn&#x27;t always what you meant.</div><br/></div></div><div id="36155324" class="c"><input type="checkbox" id="c-36155324" checked=""/><div class="controls bullet"><span class="by">Findecanor</span><span>|</span><a href="#36154373">parent</a><span>|</span><a href="#36156685">prev</a><span>|</span><a href="#36155774">next</a><span>|</span><label class="collapse" for="c-36155324">[-]</label><label class="expand" for="c-36155324">[3 more]</label></div><br/><div class="children"><div class="content">Both of those topics are rabbit holes to fall down into and discover a whole lot. There is not <i>one</i> way to do either, and there are different conventions for different platforms, languages and compilers.<p>I&#x27;d suggest to start with the paper &quot;Aspects of implementing CLU&quot; from 1978 that covers both CLU&#x27;s early type of exception handling and Iterators, which are a form of closures.
To find out how modern C++ - style exception handling is done, read &quot;Itanium C++ ABI&quot; (yes, <i>Itanium</i> !), which most of the Unix world used as template for x86-64 and AArch64 later.
Then look up &quot;Zero overhead deterministic exceptions&quot; for a proposal for C++ that didn&#x27;t get picked.</div><br/><div id="36156548" class="c"><input type="checkbox" id="c-36156548" checked=""/><div class="controls bullet"><span class="by">justinhj</span><span>|</span><a href="#36154373">root</a><span>|</span><a href="#36155324">parent</a><span>|</span><a href="#36155774">next</a><span>|</span><label class="collapse" for="c-36156548">[-]</label><label class="expand" for="c-36156548">[2 more]</label></div><br/><div class="children"><div class="content">Great to see a CLU mention here. There are number of interesting papers and documents floating around but it&#x27;s rarely mentioned, presumably because it was always a research language and only used by a handful of people in industry. The parameterized type system has features only recently rediscovered in Rust and in C++23.</div><br/><div id="36161516" class="c"><input type="checkbox" id="c-36161516" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36154373">root</a><span>|</span><a href="#36156548">parent</a><span>|</span><a href="#36155774">next</a><span>|</span><label class="collapse" for="c-36161516">[-]</label><label class="expand" for="c-36161516">[1 more]</label></div><br/><div class="children"><div class="content">And that Go could have used all along, and they even acknowledged that.<p>&gt; We would have been well-served to spend more time with CLU and C++ concepts earlier.<p>From <a href="https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;master&#x2F;design&#x2F;go2draft-generics-overview.md" rel="nofollow">https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;master&#x2F;design&#x2F;go2draf...</a><p>Another feature is the checked exceptions that everyone blames on Java, which were already present in Modula-2+, Modula-3 and C++, all of them inspired by CLU.</div><br/></div></div></div></div></div></div><div id="36155774" class="c"><input type="checkbox" id="c-36155774" checked=""/><div class="controls bullet"><span class="by">sfink</span><span>|</span><a href="#36154373">parent</a><span>|</span><a href="#36155324">prev</a><span>|</span><a href="#36155367">next</a><span>|</span><label class="collapse" for="c-36155774">[-]</label><label class="expand" for="c-36155774">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Awesome description of rocks. I would like to understand the rocks used for nuclear reactors.&quot;</div><br/><div id="36156021" class="c"><input type="checkbox" id="c-36156021" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#36154373">root</a><span>|</span><a href="#36155774">parent</a><span>|</span><a href="#36155367">next</a><span>|</span><label class="collapse" for="c-36156021">[-]</label><label class="expand" for="c-36156021">[2 more]</label></div><br/><div class="children"><div class="content">This is an amusing characterisation.<p>I would like to know how high level concepts map to assembly so I can understand how to compile to it.<p>I feel low level assembly gives so much freedom to decide how to do things.<p>I should probably get better at writing assembly so that I have inspiration on how to solve the high level things. But it&#x27;s generations of technical ideas, solutions, implementation details and understanding I have to go through. I would like to understand exception handling to implement algebraic effects.<p>I also think structs are extremely useful and that it&#x27;s amazing that sum types were invented.</div><br/><div id="36157130" class="c"><input type="checkbox" id="c-36157130" checked=""/><div class="controls bullet"><span class="by">saulpw</span><span>|</span><a href="#36154373">root</a><span>|</span><a href="#36156021">parent</a><span>|</span><a href="#36155367">next</a><span>|</span><label class="collapse" for="c-36157130">[-]</label><label class="expand" for="c-36157130">[1 more]</label></div><br/><div class="children"><div class="content">I would recommend writing a simple Forth &quot;interpreter&quot;.  Assembly is the easiest language to write a Forth interpreter&#x2F;compiler in, it&#x27;s not that difficult (on the order of 10 hours to get something working your first time, and 50-100 hours to implement some of the more subtle concepts), and it will blow your mind.</div><br/></div></div></div></div></div></div></div></div><div id="36153989" class="c"><input type="checkbox" id="c-36153989" checked=""/><div class="controls bullet"><span class="by">pavlov</span><span>|</span><a href="#36154373">prev</a><span>|</span><a href="#36156486">next</a><span>|</span><label class="collapse" for="c-36153989">[-]</label><label class="expand" for="c-36153989">[7 more]</label></div><br/><div class="children"><div class="content">As a curiosity, it&#x27;s worth mentioning there have been entire GUIs written in assembly. Probably the last commercially released one was GEOS a.k.a. GeoWorks Ensemble. It was a small and efficient GUI environment for x86 PCs, briefly somewhat popular as a Windows alternative around 1990.<p>Steve Yegge worked there and tells an interesting story. 15 million lines of hand-written x86 assembly!<p><a href="http:&#x2F;&#x2F;steve-yegge.blogspot.com&#x2F;2008&#x2F;05&#x2F;dynamic-languages-strike-back.html" rel="nofollow">http:&#x2F;&#x2F;steve-yegge.blogspot.com&#x2F;2008&#x2F;05&#x2F;dynamic-languages-st...</a><p><i>&quot;OK: I went to the University of Washington and [then] I got hired by this company called Geoworks, doing assembly-language programming, and I did it for five years. To us, the Geoworkers, we wrote a whole operating system, the libraries, drivers, apps, you know: a desktop operating system in assembly. 8086 assembly! It wasn&#x27;t even good assembly! We had four registers! [Plus the] si [register] if you counted, you know, if you counted 386, right? It was horrible.</i><p><i>&quot;I mean, actually we kind of liked it. It was Object-Oriented Assembly. It&#x27;s amazing what you can talk yourself into liking, which is the real irony of all this. And to us, C++ was the ultimate in Roman decadence. I mean, it was equivalent to going and vomiting so you could eat more. They had IF! We had jump CX zero! Right? They had &quot;Objects&quot;. Well we did too, but I mean they had syntax for it, right? I mean it was all just such weeniness. And we knew that we could outperform any compiler out there because at the time, we could!</i><p><i>&quot;So what happened? Well, they went bankrupt. Why? Now I&#x27;m probably disagreeing â I know for a fact that I&#x27;m disagreeing with every Geoworker out there. I&#x27;m the only one that holds this belief. But it&#x27;s because we wrote fifteen million lines of 8086 assembly language. We had really good tools, world class tools: trust me, you need &#x27;em. But at some point, man...</i><p><i>&quot;The problem is, picture an ant walking across your garage floor, trying to make a straight line of it. It ain&#x27;t gonna make a straight line. And you know this because you have perspective. You can see the ant walking around, going hee hee hee, look at him locally optimize for that rock, and now he&#x27;s going off this way, right?</i><p><i>&quot;This is what we were, when we were writing this giant assembly-language system. Because what happened was, Microsoft eventually released a platform for mobile devices that was much faster than ours. OK? And I started going in with my debugger, going, what? What is up with this? This rendering is just really slow, it&#x27;s like sluggish, you know. And I went in and found out that some title bar was getting rendered 140 times every time you refreshed the screen. It wasn&#x27;t just the title bar. Everything was getting called multiple times.</i><p><i>&quot;Because we couldn&#x27;t see how the system worked anymore!&quot;</i><p>...I have to say, the &quot;140 redraws by accident&quot; part sounds like an ordinary day in web UI development using 2023 frameworks. The problem of not seeing the entire picture of what&#x27;s going on isn&#x27;t limited to assembly programmers. You can start from the opposite end of the abstraction spectrum and end up with the same issues.</div><br/><div id="36154624" class="c"><input type="checkbox" id="c-36154624" checked=""/><div class="controls bullet"><span class="by">jaggederest</span><span>|</span><a href="#36153989">parent</a><span>|</span><a href="#36161537">next</a><span>|</span><label class="collapse" for="c-36154624">[-]</label><label class="expand" for="c-36154624">[1 more]</label></div><br/><div class="children"><div class="content">Roller Coaster Tycoon was almost entirely written in assembler by Chris Sawyer. Pretty amazing story, and released in 1999, as well, so well past the point most people had stopped doing 100% assembler development.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;RollerCoaster_Tycoon_(video_game)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;RollerCoaster_Tycoon_(video_ga...</a></div><br/></div></div><div id="36161537" class="c"><input type="checkbox" id="c-36161537" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36153989">parent</a><span>|</span><a href="#36154624">prev</a><span>|</span><a href="#36154833">next</a><span>|</span><label class="collapse" for="c-36161537">[-]</label><label class="expand" for="c-36161537">[1 more]</label></div><br/><div class="children"><div class="content">Not only GUIs, entire operating systems.<p>Besides the early computing days, the 8 and 16 bit home computers were mostly Assembly.<p>Even if Amiga, Atari and Archimedes had their share of BCPL, C and Modula-2, MS-DOS was fully implemented in Assembly.</div><br/></div></div><div id="36154833" class="c"><input type="checkbox" id="c-36154833" checked=""/><div class="controls bullet"><span class="by">viler</span><span>|</span><a href="#36153989">parent</a><span>|</span><a href="#36161537">prev</a><span>|</span><a href="#36154117">next</a><span>|</span><label class="collapse" for="c-36154833">[-]</label><label class="expand" for="c-36154833">[1 more]</label></div><br/><div class="children"><div class="content">A couple of GUIs written in assembly this century are MenuetOS and KolibriOS.</div><br/></div></div><div id="36154117" class="c"><input type="checkbox" id="c-36154117" checked=""/><div class="controls bullet"><span class="by">cf100clunk</span><span>|</span><a href="#36153989">parent</a><span>|</span><a href="#36154833">prev</a><span>|</span><a href="#36156486">next</a><span>|</span><label class="collapse" for="c-36154117">[-]</label><label class="expand" for="c-36154117">[3 more]</label></div><br/><div class="children"><div class="content">Early in the 1990s Photodex wrote their CompuPic photo management program in assembly. The shareware version of CompuPic was popular for creating&#x2F;editing&#x2F;retouching lowball graphics when the www soon emerged.</div><br/><div id="36154621" class="c"><input type="checkbox" id="c-36154621" checked=""/><div class="controls bullet"><span class="by">masfuerte</span><span>|</span><a href="#36153989">root</a><span>|</span><a href="#36154117">parent</a><span>|</span><a href="#36156486">next</a><span>|</span><label class="collapse" for="c-36154621">[-]</label><label class="expand" for="c-36154621">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure the 90s painting app Xara Studio was also done in assembly.</div><br/><div id="36156661" class="c"><input type="checkbox" id="c-36156661" checked=""/><div class="controls bullet"><span class="by">mav88</span><span>|</span><a href="#36153989">root</a><span>|</span><a href="#36154621">parent</a><span>|</span><a href="#36156486">next</a><span>|</span><label class="collapse" for="c-36156661">[-]</label><label class="expand" for="c-36156661">[1 more]</label></div><br/><div class="children"><div class="content">That wouldn&#x27;t surprise me. The original Xara could render complex SVGs in under two seconds on a 486-66. The most optimized program I have ever used.</div><br/></div></div></div></div></div></div></div></div><div id="36156486" class="c"><input type="checkbox" id="c-36156486" checked=""/><div class="controls bullet"><span class="by">jiffygist</span><span>|</span><a href="#36153989">prev</a><span>|</span><a href="#36155936">next</a><span>|</span><label class="collapse" for="c-36156486">[-]</label><label class="expand" for="c-36156486">[1 more]</label></div><br/><div class="children"><div class="content">Some useful gui program examples for winapi<p><a href="https:&#x2F;&#x2F;www.davidgrantham.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.davidgrantham.com&#x2F;</a></div><br/></div></div><div id="36155837" class="c"><input type="checkbox" id="c-36155837" checked=""/><div class="controls bullet"><span class="by">Solvency</span><span>|</span><a href="#36155936">prev</a><span>|</span><a href="#36155477">next</a><span>|</span><label class="collapse" for="c-36155837">[-]</label><label class="expand" for="c-36155837">[6 more]</label></div><br/><div class="children"><div class="content">In 2023, does anyone who writes a compiler inherently have to know assembly?<p>Or even less recently...whoever wrote the first Rust, Zig, or insert &lt;new compiled language&gt; here?<p>Because don&#x27;t you ultimately have to know how to make your own syntax translate into efficient assembly code?<p>Or is there someway these days for programming language designers&#x2F;creators to avoid it entirely?</div><br/><div id="36155938" class="c"><input type="checkbox" id="c-36155938" checked=""/><div class="controls bullet"><span class="by">gamache</span><span>|</span><a href="#36155837">parent</a><span>|</span><a href="#36155888">next</a><span>|</span><label class="collapse" for="c-36155938">[-]</label><label class="expand" for="c-36155938">[1 more]</label></div><br/><div class="children"><div class="content">Compiler writers can target high-level languages too; it&#x27;s not uncommon to see e.g., a Blub-to-C compiler which leaves the asm parts to a different toolchain. (Lots of languages without the goal of producing native code target even higher-level languages, for example JS.)<p>Another popular way to _sort of_ avoid assembly is to target the LLVM IR (intermediate representation), in which case LLVM takes care of optimization and producing processor-specific machine code for a bunch of CPU types. But LLVM IR is basically a fancy assembly language.</div><br/></div></div><div id="36155888" class="c"><input type="checkbox" id="c-36155888" checked=""/><div class="controls bullet"><span class="by">dahfizz</span><span>|</span><a href="#36155837">parent</a><span>|</span><a href="#36155938">prev</a><span>|</span><a href="#36156758">next</a><span>|</span><label class="collapse" for="c-36155888">[-]</label><label class="expand" for="c-36155888">[3 more]</label></div><br/><div class="children"><div class="content">Llvm abstracts the &quot;backend&quot; which generates the actual assembly for each target machine. You only have to write a &quot;frontend&quot; that generates an llvm intermediate representation.<p>But in general, yes. To generate assembly you need to know assembly.</div><br/><div id="36156163" class="c"><input type="checkbox" id="c-36156163" checked=""/><div class="controls bullet"><span class="by">Solvency</span><span>|</span><a href="#36155837">root</a><span>|</span><a href="#36155888">parent</a><span>|</span><a href="#36156758">next</a><span>|</span><label class="collapse" for="c-36156163">[-]</label><label class="expand" for="c-36156163">[2 more]</label></div><br/><div class="children"><div class="content">Is LLVM sufficiently &quot;simpler&quot; to learn and wield than assembly, or does it just make it easier to compile to different systems?</div><br/><div id="36156478" class="c"><input type="checkbox" id="c-36156478" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#36155837">root</a><span>|</span><a href="#36156163">parent</a><span>|</span><a href="#36156758">next</a><span>|</span><label class="collapse" for="c-36156478">[-]</label><label class="expand" for="c-36156478">[1 more]</label></div><br/><div class="children"><div class="content">LLVM is definitely more complex than a toy assembly you might learn in an intro computer architecture course, but it&#x27;s generally somewhat less complex than working with real assembly languages. Although the complexity in LLVM is a very different kind of complexity from assembly languages; LLVM is ultimately a higher-level abstraction than machine code, and the semantics of that abstraction can be complex in its own right.</div><br/></div></div></div></div></div></div></div></div><div id="36155477" class="c"><input type="checkbox" id="c-36155477" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#36155837">prev</a><span>|</span><a href="#36154651">next</a><span>|</span><label class="collapse" for="c-36155477">[-]</label><label class="expand" for="c-36155477">[4 more]</label></div><br/><div class="children"><div class="content">Two older assembly language programming books that I had checked out earlier, and thought were good, are ones by Randal Hyde and Paul Carter.<p>Both were for 32 bit assembly, not 64 bit, IIRC.<p>Paul Carter was a professor or lecturer at a US  college.<p>I think his book was available online.</div><br/><div id="36160364" class="c"><input type="checkbox" id="c-36160364" checked=""/><div class="controls bullet"><span class="by">redsaz</span><span>|</span><a href="#36155477">parent</a><span>|</span><a href="#36155949">next</a><span>|</span><label class="collapse" for="c-36160364">[-]</label><label class="expand" for="c-36160364">[2 more]</label></div><br/><div class="children"><div class="content">Randal Hyde now has an Art of Assembly edition for 64-bit.</div><br/><div id="36161989" class="c"><input type="checkbox" id="c-36161989" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#36155477">root</a><span>|</span><a href="#36160364">parent</a><span>|</span><a href="#36155949">next</a><span>|</span><label class="collapse" for="c-36161989">[-]</label><label class="expand" for="c-36161989">[1 more]</label></div><br/><div class="children"><div class="content">Cool, good to know.</div><br/></div></div></div></div><div id="36155949" class="c"><input type="checkbox" id="c-36155949" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#36155477">parent</a><span>|</span><a href="#36160364">prev</a><span>|</span><a href="#36154651">next</a><span>|</span><label class="collapse" for="c-36155949">[-]</label><label class="expand" for="c-36155949">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I think his book was available online.<p><a href="http:&#x2F;&#x2F;pacman128.github.io&#x2F;pcasm&#x2F;#" rel="nofollow">http:&#x2F;&#x2F;pacman128.github.io&#x2F;pcasm&#x2F;#</a><p>Scroll down the page for the PDF book.</div><br/></div></div></div></div><div id="36154651" class="c"><input type="checkbox" id="c-36154651" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#36155477">prev</a><span>|</span><a href="#36154958">next</a><span>|</span><label class="collapse" for="c-36154651">[-]</label><label class="expand" for="c-36154651">[4 more]</label></div><br/><div class="children"><div class="content">This is great! I&#x27;d like to write code to interface X11 without going through libx11 but I&#x27;ve not gotten around to reading the documentation around its binary format. This is a good start!</div><br/><div id="36154825" class="c"><input type="checkbox" id="c-36154825" checked=""/><div class="controls bullet"><span class="by">eschneider</span><span>|</span><a href="#36154651">parent</a><span>|</span><a href="#36156875">next</a><span>|</span><label class="collapse" for="c-36154825">[-]</label><label class="expand" for="c-36154825">[2 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need assembly to do that. It&#x27;s just another network app. :) Check out Adrian Nye&#x27;s &quot;X Protocol Reference Manual&quot; to see how to talk X.</div><br/><div id="36155665" class="c"><input type="checkbox" id="c-36155665" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#36154651">root</a><span>|</span><a href="#36154825">parent</a><span>|</span><a href="#36156875">next</a><span>|</span><label class="collapse" for="c-36155665">[-]</label><label class="expand" for="c-36155665">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but any working starting point is a worthwhile read.</div><br/></div></div></div></div><div id="36156875" class="c"><input type="checkbox" id="c-36156875" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#36154651">parent</a><span>|</span><a href="#36154825">prev</a><span>|</span><a href="#36154958">next</a><span>|</span><label class="collapse" for="c-36156875">[-]</label><label class="expand" for="c-36156875">[1 more]</label></div><br/><div class="children"><div class="content">If you want to be closer to X without reading the protocol documentation, you might look into xcb; it&#x27;s much less abstraction than xlib.</div><br/></div></div></div></div><div id="36154958" class="c"><input type="checkbox" id="c-36154958" checked=""/><div class="controls bullet"><span class="by">maherbeg</span><span>|</span><a href="#36154651">prev</a><span>|</span><a href="#36154039">next</a><span>|</span><label class="collapse" for="c-36154958">[-]</label><label class="expand" for="c-36154958">[1 more]</label></div><br/><div class="children"><div class="content">Oh man, this brings me back to writing a hot key based application launcher in assembly for windows to learn assembly and the various tools for compiling and building things. Good times!</div><br/></div></div><div id="36154039" class="c"><input type="checkbox" id="c-36154039" checked=""/><div class="controls bullet"><span class="by">xurukefi</span><span>|</span><a href="#36154958">prev</a><span>|</span><a href="#36160229">next</a><span>|</span><label class="collapse" for="c-36154039">[-]</label><label class="expand" for="c-36154039">[2 more]</label></div><br/><div class="children"><div class="content">The &quot;xor rax, rax&quot; that I just saw at a quick glance makes me flinch. Still putting it on my reading list though. Sounds like a really interesting little toy project.</div><br/><div id="36154207" class="c"><input type="checkbox" id="c-36154207" checked=""/><div class="controls bullet"><span class="by">seritools</span><span>|</span><a href="#36154039">parent</a><span>|</span><a href="#36160229">next</a><span>|</span><label class="collapse" for="c-36154207">[-]</label><label class="expand" for="c-36154207">[1 more]</label></div><br/><div class="children"><div class="content">To explain the flinching (since I didn&#x27;t catch it immediately):<p>&gt; In 64-bit mode, still use `xor r32, r32`, because writing a 32-bit reg zeros the upper 32. `xor r64, r64` is a waste of a byte, because it needs a REX prefix.<p>(from <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;33668295&#x2F;554577" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;33668295&#x2F;554577</a> )</div><br/></div></div></div></div><div id="36160229" class="c"><input type="checkbox" id="c-36160229" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#36154039">prev</a><span>|</span><a href="#36156772">next</a><span>|</span><label class="collapse" for="c-36160229">[-]</label><label class="expand" for="c-36160229">[1 more]</label></div><br/><div class="children"><div class="content">Assembly &quot;Hello World&quot;:<p>&gt; just 600 lines of code</div><br/></div></div><div id="36156772" class="c"><input type="checkbox" id="c-36156772" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#36160229">prev</a><span>|</span><a href="#36157791">next</a><span>|</span><label class="collapse" for="c-36156772">[-]</label><label class="expand" for="c-36156772">[3 more]</label></div><br/><div class="children"><div class="content">Writing a Linux application in _Intel_ x86 assembler syntax...smh. You do not know de wey</div><br/><div id="36158345" class="c"><input type="checkbox" id="c-36158345" checked=""/><div class="controls bullet"><span class="by">qayxc</span><span>|</span><a href="#36156772">parent</a><span>|</span><a href="#36161084">next</a><span>|</span><label class="collapse" for="c-36158345">[-]</label><label class="expand" for="c-36158345">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a matter of personal taste. Some people (including myself) simply like Intel syntax better. As a sidenote, I find it quite fitting since Linux - unlike Unix - was &quot;born&quot; on Intel hardware after all :)</div><br/></div></div><div id="36161084" class="c"><input type="checkbox" id="c-36161084" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36156772">parent</a><span>|</span><a href="#36158345">prev</a><span>|</span><a href="#36157791">next</a><span>|</span><label class="collapse" for="c-36161084">[-]</label><label class="expand" for="c-36161084">[1 more]</label></div><br/><div class="children"><div class="content">Intel Assembly should be written the way Lord Intel prescribed.</div><br/></div></div></div></div><div id="36157791" class="c"><input type="checkbox" id="c-36157791" checked=""/><div class="controls bullet"><span class="by">gigel82</span><span>|</span><a href="#36156772">prev</a><span>|</span><a href="#36157316">next</a><span>|</span><label class="collapse" for="c-36157791">[-]</label><label class="expand" for="c-36157791">[1 more]</label></div><br/><div class="children"><div class="content">The title is confusing. What is a GUI from scratch? A bootloader &#x2F; mini kernel with framebuffer? A win32 application?<p>Should probably be something like &quot;Writing a Linux X11 application in assembly&quot;.</div><br/></div></div><div id="36157316" class="c"><input type="checkbox" id="c-36157316" checked=""/><div class="controls bullet"><span class="by">satiric</span><span>|</span><a href="#36157791">prev</a><span>|</span><a href="#36153596">next</a><span>|</span><label class="collapse" for="c-36157316">[-]</label><label class="expand" for="c-36157316">[1 more]</label></div><br/><div class="children"><div class="content">Is there a practical reason to do this? I don&#x27;t mean that disparagingly; it&#x27;s a cool project and I can see its value. I&#x27;m just wondering if there&#x27;s also a practical reason you might do something like this rather than just using Qt or HTML&#x2F;CSS or whatever.</div><br/></div></div><div id="36153596" class="c"><input type="checkbox" id="c-36153596" checked=""/><div class="controls bullet"><span class="by">sylware</span><span>|</span><a href="#36157316">prev</a><span>|</span><a href="#36156946">next</a><span>|</span><label class="collapse" for="c-36153596">[-]</label><label class="expand" for="c-36153596">[1 more]</label></div><br/><div class="children"><div class="content">If you write a wayland compositor in x86_64 assembly... (vulkan+drm on elf&#x2F;linux), without abusing a macro processor and without obscene code generators...</div><br/></div></div><div id="36156946" class="c"><input type="checkbox" id="c-36156946" checked=""/><div class="controls bullet"><span class="by">lost_tourist</span><span>|</span><a href="#36153596">prev</a><span>|</span><a href="#36154427">next</a><span>|</span><label class="collapse" for="c-36156946">[-]</label><label class="expand" for="c-36156946">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re going to learn assembly for the first time I would say start with arm-64 assembly first, the architecture is much more refined and the assembler much more pleasurable to code with less foot guns and complication unless you are doing only the most basic of programs.</div><br/></div></div><div id="36154427" class="c"><input type="checkbox" id="c-36154427" checked=""/><div class="controls bullet"><span class="by">voidz7</span><span>|</span><a href="#36156946">prev</a><span>|</span><label class="collapse" for="c-36154427">[-]</label><label class="expand" for="c-36154427">[2 more]</label></div><br/><div class="children"><div class="content">does this tutorial work on macos?</div><br/><div id="36154919" class="c"><input type="checkbox" id="c-36154919" checked=""/><div class="controls bullet"><span class="by">nmstoker</span><span>|</span><a href="#36154427">parent</a><span>|</span><label class="collapse" for="c-36154919">[-]</label><label class="expand" for="c-36154919">[1 more]</label></div><br/><div class="children"><div class="content">There are some pointers on that if you skim the tutorial.</div><br/></div></div></div></div></div></div></div></div></div></body></html>