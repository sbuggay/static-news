<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713089488691" as="style"/><link rel="stylesheet" href="styles.css?v=1713089488691"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/supabase/index_advisor">Show HN: PostgreSQL index advisor</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>kiwicopple</span> | <span>33 comments</span></div><br/><div><div id="40029083" class="c"><input type="checkbox" id="c-40029083" checked=""/><div class="controls bullet"><span class="by">CAP_NET_ADMIN</span><span>|</span><a href="#40029971">next</a><span>|</span><label class="collapse" for="c-40029083">[-]</label><label class="expand" for="c-40029083">[5 more]</label></div><br/><div class="children"><div class="content">If you have some PostgreSQL performance issues, I&#x27;d recommend checking out PGAnalyze - they&#x27;ve offered a much more advanced index advisor for some time now.<p>My company is a paid customer since around 2020 and we are very satisfied, easily beats the Datadog&#x27;s (which we use for the rest of our infra and apps) observability offering for PostgreSQL.</div><br/><div id="40029125" class="c"><input type="checkbox" id="c-40029125" checked=""/><div class="controls bullet"><span class="by">allan_s</span><span>|</span><a href="#40029083">parent</a><span>|</span><a href="#40029971">next</a><span>|</span><label class="collapse" for="c-40029125">[-]</label><label class="expand" for="c-40029125">[4 more]</label></div><br/><div class="children"><div class="content">Re: performance issue<p>I used to think that performance issue in relational database was always a matter of 
:<p>*  missing indexes
*  non-used indexes due to query order (where A, B instead of B, A)<p>But we had the case recently where we optimized a query in postgresql which was taking 100% of cpu during 1s (enough to trigger our alerting) by simply splitting a OR in two separate query.<p>So if you are looking for optimisation it may be good to know about &quot;OR is bad&quot;.
The two queries run in some ms both.</div><br/><div id="40029230" class="c"><input type="checkbox" id="c-40029230" checked=""/><div class="controls bullet"><span class="by">xvinci</span><span>|</span><a href="#40029083">root</a><span>|</span><a href="#40029125">parent</a><span>|</span><a href="#40029971">next</a><span>|</span><label class="collapse" for="c-40029230">[-]</label><label class="expand" for="c-40029230">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sorry but you just cannot say that &quot;OR is bad&quot; - it being a key part of SQL . It&#x27;s most likely your use that is bad (e.g. your intermediate result exceeding some cache size).<p>But &quot;bad performance always due to indexes&quot; gives a hint that you are somewhat new: No, bad performance in my experience was almost always due to developers either not understanding their ORM framework, or writing too expensive queries with or without index. Just adding indexes seldom solved the problem (maybe 1&#x2F;5 of the time).</div><br/><div id="40029810" class="c"><input type="checkbox" id="c-40029810" checked=""/><div class="controls bullet"><span class="by">mrklol</span><span>|</span><a href="#40029083">root</a><span>|</span><a href="#40029230">parent</a><span>|</span><a href="#40029971">next</a><span>|</span><label class="collapse" for="c-40029810">[-]</label><label class="expand" for="c-40029810">[2 more]</label></div><br/><div class="children"><div class="content">OR is indeed not bad, but you have to think about when to use it. It can easily make queries slower compared to other operators. That’s exactly why we have the terms &quot;ugly OR&quot; &#x2F; &quot;bad OR&quot;.</div><br/><div id="40029928" class="c"><input type="checkbox" id="c-40029928" checked=""/><div class="controls bullet"><span class="by">thom</span><span>|</span><a href="#40029083">root</a><span>|</span><a href="#40029810">parent</a><span>|</span><a href="#40029971">next</a><span>|</span><label class="collapse" for="c-40029928">[-]</label><label class="expand" for="c-40029928">[1 more]</label></div><br/><div class="children"><div class="content">It’s worth having a mental model of _why_ OR can be suboptimal. Often it’s because you’re only hitting an index on half the conditional, or forcing PG into a bitmap scan, or worse turning and index lookup into a sequential scan. Not to bang on about indexes too much but a partial index on the OR condition works if you’re lazy, although splitting into two queries is often a great solution as it gives you two fast queries to combine instead of one slow one (although sometimes that implies PG’s statistics are incorrect because it might have been able to know which side of the conditional cuts out more data).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40029971" class="c"><input type="checkbox" id="c-40029971" checked=""/><div class="controls bullet"><span class="by">fforflo</span><span>|</span><a href="#40029083">prev</a><span>|</span><a href="#40028894">next</a><span>|</span><label class="collapse" for="c-40029971">[-]</label><label class="expand" for="c-40029971">[1 more]</label></div><br/><div class="children"><div class="content">The convenient thing about this is that it&#x27;s written in vanilla Pl&#x2F;PgSQL. It can be tempting to copy the `index_advisor(text)`function in a session and start hard-coding stuff and heuristics :D .<p>Most meaningful extensions need to be compiled, installed, created dropped.</div><br/></div></div><div id="40028894" class="c"><input type="checkbox" id="c-40028894" checked=""/><div class="controls bullet"><span class="by">sbstp</span><span>|</span><a href="#40029971">prev</a><span>|</span><a href="#40028694">next</a><span>|</span><label class="collapse" for="c-40028894">[-]</label><label class="expand" for="c-40028894">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve often thought that a database that could automatically detect slow queries and create the necessary indexes would be neat. You run a load test on your application, which in turns calls the database and you collect all the queries it makes. Then the database automatically adjusts itself.</div><br/><div id="40029162" class="c"><input type="checkbox" id="c-40029162" checked=""/><div class="controls bullet"><span class="by">arronax</span><span>|</span><a href="#40028894">parent</a><span>|</span><a href="#40029013">next</a><span>|</span><label class="collapse" for="c-40029162">[-]</label><label class="expand" for="c-40029162">[1 more]</label></div><br/><div class="children"><div class="content">Oracle DB is, or was, very close to that with its query profiles, baselines, and query patches. It wasn&#x27;t automatic back in 2014 when I last worked on it, but all the tools were there. Heck, it was possible to completely rewrite a bad query on the fly and execute a re-written variant. I suppose it all stems from the fact that Oracle is regularly used under massive black boxes, including the EBS.<p>Also, the problem with automatic indexing is that it only gets you so far, and any index can, in theory, mess up another query that is perfectly fine. Optimizers aren&#x27;t omniscient. In addition, there are other knobs in the database, which affect performance. I suppose, a wider approach than just looking at indexes would be more successful. Like Ottertune, for example.</div><br/></div></div><div id="40029013" class="c"><input type="checkbox" id="c-40029013" checked=""/><div class="controls bullet"><span class="by">elric</span><span>|</span><a href="#40028894">parent</a><span>|</span><a href="#40029162">prev</a><span>|</span><a href="#40029099">next</a><span>|</span><label class="collapse" for="c-40029013">[-]</label><label class="expand" for="c-40029013">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure the database could, but it doesn&#x27;t mean the database should. Indexes come at the cost of extra disk space, slower inserts, and slower updates. In some cases, some slower queries might be an acceptable tradeoff. In other cases, maybe not. It depends.</div><br/><div id="40029293" class="c"><input type="checkbox" id="c-40029293" checked=""/><div class="controls bullet"><span class="by">kiwicopple</span><span>|</span><a href="#40028894">root</a><span>|</span><a href="#40029013">parent</a><span>|</span><a href="#40029099">next</a><span>|</span><label class="collapse" for="c-40029293">[-]</label><label class="expand" for="c-40029293">[1 more]</label></div><br/><div class="children"><div class="content">this is our posture for this extension on the supabase platform. we could automate the creation of the indexes using the Index Advisor, but we feel it would be better to expose the possible indexes to the user and let them choose</div><br/></div></div></div></div><div id="40029099" class="c"><input type="checkbox" id="c-40029099" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#40028894">parent</a><span>|</span><a href="#40029013">prev</a><span>|</span><a href="#40028982">next</a><span>|</span><label class="collapse" for="c-40029099">[-]</label><label class="expand" for="c-40029099">[1 more]</label></div><br/><div class="children"><div class="content">Because indexes have costs you need a much more complicated system which can feed back into itself and downgrade probationary indexes back to unindexed.</div><br/></div></div><div id="40028982" class="c"><input type="checkbox" id="c-40028982" checked=""/><div class="controls bullet"><span class="by">ComodoHacker</span><span>|</span><a href="#40028894">parent</a><span>|</span><a href="#40029099">prev</a><span>|</span><a href="#40028983">next</a><span>|</span><label class="collapse" for="c-40028982">[-]</label><label class="expand" for="c-40028982">[2 more]</label></div><br/><div class="children"><div class="content">Big Guys do this. For big bucks, of course.</div><br/><div id="40028995" class="c"><input type="checkbox" id="c-40028995" checked=""/><div class="controls bullet"><span class="by">tuwtuwtuwtuw</span><span>|</span><a href="#40028894">root</a><span>|</span><a href="#40028982">parent</a><span>|</span><a href="#40028983">next</a><span>|</span><label class="collapse" for="c-40028995">[-]</label><label class="expand" for="c-40028995">[1 more]</label></div><br/><div class="children"><div class="content">&gt; big bucks<p>You get that feature in Azure SQL Database for $5&#x2F;month.</div><br/></div></div></div></div><div id="40028983" class="c"><input type="checkbox" id="c-40028983" checked=""/><div class="controls bullet"><span class="by">tuwtuwtuwtuw</span><span>|</span><a href="#40028894">parent</a><span>|</span><a href="#40028982">prev</a><span>|</span><a href="#40028694">next</a><span>|</span><label class="collapse" for="c-40028983">[-]</label><label class="expand" for="c-40028983">[1 more]</label></div><br/><div class="children"><div class="content">That exists in Microsoft SQL Server. It can create new indexes, drop unused indexes, change query plans when it detect degradation and so on.</div><br/></div></div></div></div><div id="40028694" class="c"><input type="checkbox" id="c-40028694" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#40028894">prev</a><span>|</span><a href="#40029409">next</a><span>|</span><label class="collapse" for="c-40028694">[-]</label><label class="expand" for="c-40028694">[6 more]</label></div><br/><div class="children"><div class="content">I’ve been needing this and also HypoPG, which I didn’t realize had been available on RDS for a year plus!<p>The issue I’m struggling with these days is that I have an index that I want Postgres to use for one of the relations in a 3+ wide join, but unless I put a limit on a CTE of one of the tables, Postgres tries to run each join in parallel and ends up trying to join a bazillion rows like an asshole.<p>These days wrangling the query planner has me on the verge of breaking up with pg :-(</div><br/><div id="40028794" class="c"><input type="checkbox" id="c-40028794" checked=""/><div class="controls bullet"><span class="by">jaggederest</span><span>|</span><a href="#40028694">parent</a><span>|</span><a href="#40029216">next</a><span>|</span><label class="collapse" for="c-40028794">[-]</label><label class="expand" for="c-40028794">[1 more]</label></div><br/><div class="children"><div class="content">You can set max_parallel_workers_per_gather to zero in the session where you&#x27;re running the problem query, if that&#x27;s helpful. That will disable the parallel query behavior entirely. You can just reset it back to what it was once the query is complete. I&#x27;ve run into this issue before and that was my go-to fix.</div><br/></div></div><div id="40029216" class="c"><input type="checkbox" id="c-40029216" checked=""/><div class="controls bullet"><span class="by">arronax</span><span>|</span><a href="#40028694">parent</a><span>|</span><a href="#40028794">prev</a><span>|</span><a href="#40028774">next</a><span>|</span><label class="collapse" for="c-40029216">[-]</label><label class="expand" for="c-40029216">[1 more]</label></div><br/><div class="children"><div class="content">While pinning a single plan or disabling parallel operations is a valid quick fix, I&#x27;d recommend trying to actually understand why the optimizer is doing what it&#x27;s doing. It&#x27;s all &quot;just&quot; a simple math of execution node costs. The problem with plan hints, or disabling parallel, is that unless you have a perfect understanding of where the data will be in, say, a year, you may just have created another problem, just delayed. Some column will go from 10 to 10,000 unique values and your good plan will become way off. And at the end, perhaps you just need to tell PG that an index access is not 4 times as expensive as a plain heap scan.<p>ps fighting the optimizer is the worst</div><br/></div></div><div id="40028774" class="c"><input type="checkbox" id="c-40028774" checked=""/><div class="controls bullet"><span class="by">kiwicopple</span><span>|</span><a href="#40028694">parent</a><span>|</span><a href="#40029216">prev</a><span>|</span><a href="#40028799">next</a><span>|</span><label class="collapse" for="c-40028774">[-]</label><label class="expand" for="c-40028774">[1 more]</label></div><br/><div class="children"><div class="content">i don&#x27;t know how far it was developed, but I believe pg_plan_guarantee[0] was created to solve this sort of issue<p>&gt; <i>This extension provides a mechanism, using which you can set your execution plan in stone; that is, Postgres will execute the plan you give it, or it will throw an error, but it will never try to guess a plan for you.</i><p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;DrPostgres&#x2F;pg_plan_guarantee">https:&#x2F;&#x2F;github.com&#x2F;DrPostgres&#x2F;pg_plan_guarantee</a></div><br/></div></div><div id="40028799" class="c"><input type="checkbox" id="c-40028799" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#40028694">parent</a><span>|</span><a href="#40028774">prev</a><span>|</span><a href="#40028864">next</a><span>|</span><label class="collapse" for="c-40028799">[-]</label><label class="expand" for="c-40028799">[1 more]</label></div><br/><div class="children"><div class="content">Guessing you&#x27;ve seen this already and it&#x27;s not doing what you want?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ossc-db&#x2F;pg_hint_plan">https:&#x2F;&#x2F;github.com&#x2F;ossc-db&#x2F;pg_hint_plan</a></div><br/></div></div><div id="40028864" class="c"><input type="checkbox" id="c-40028864" checked=""/><div class="controls bullet"><span class="by">polishdude20</span><span>|</span><a href="#40028694">parent</a><span>|</span><a href="#40028799">prev</a><span>|</span><a href="#40029409">next</a><span>|</span><label class="collapse" for="c-40028864">[-]</label><label class="expand" for="c-40028864">[1 more]</label></div><br/><div class="children"><div class="content">Have you tried changing the order of the joins? I know it shouldn&#x27;t matter but I&#x27;ve found sometimes it tricks the query planner into doing the right things!</div><br/></div></div></div></div><div id="40029409" class="c"><input type="checkbox" id="c-40029409" checked=""/><div class="controls bullet"><span class="by">dveeden2</span><span>|</span><a href="#40028694">prev</a><span>|</span><a href="#40029335">next</a><span>|</span><label class="collapse" for="c-40029409">[-]</label><label class="expand" for="c-40029409">[1 more]</label></div><br/><div class="children"><div class="content">This is somewhat similar to TiAdvisor for TiDB, which also uses a hypothetical method.<p><a href="https:&#x2F;&#x2F;www.pingcap.com&#x2F;blog&#x2F;introducing-tiadvisor-automated-tidb-index-discovery&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.pingcap.com&#x2F;blog&#x2F;introducing-tiadvisor-automated...</a></div><br/></div></div><div id="40029335" class="c"><input type="checkbox" id="c-40029335" checked=""/><div class="controls bullet"><span class="by">PikachuEXE</span><span>|</span><a href="#40029409">prev</a><span>|</span><a href="#40029226">next</a><span>|</span><label class="collapse" for="c-40029335">[-]</label><label class="expand" for="c-40029335">[2 more]</label></div><br/><div class="children"><div class="content">I am using <a href="https:&#x2F;&#x2F;github.com&#x2F;ankane&#x2F;pghero&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;ankane&#x2F;pghero&#x2F;</a> and this is one of its features with GUI</div><br/><div id="40029407" class="c"><input type="checkbox" id="c-40029407" checked=""/><div class="controls bullet"><span class="by">kiwicopple</span><span>|</span><a href="#40029335">parent</a><span>|</span><a href="#40029226">next</a><span>|</span><label class="collapse" for="c-40029407">[-]</label><label class="expand" for="c-40029407">[1 more]</label></div><br/><div class="children"><div class="content">Andrew builds some amazing tools for the postgres ecosystem (he is also the creator of pgvector)</div><br/></div></div></div></div><div id="40029226" class="c"><input type="checkbox" id="c-40029226" checked=""/><div class="controls bullet"><span class="by">crorella</span><span>|</span><a href="#40029335">prev</a><span>|</span><a href="#40029004">next</a><span>|</span><label class="collapse" for="c-40029226">[-]</label><label class="expand" for="c-40029226">[1 more]</label></div><br/><div class="children"><div class="content">Interesting! We did something similar for distributed query engines like presto and Spark, instead of indexes we use partitions and buckets, the benefits are less compute, time and money.</div><br/></div></div><div id="40029004" class="c"><input type="checkbox" id="c-40029004" checked=""/><div class="controls bullet"><span class="by">ComodoHacker</span><span>|</span><a href="#40029226">prev</a><span>|</span><a href="#40029276">next</a><span>|</span><label class="collapse" for="c-40029004">[-]</label><label class="expand" for="c-40029004">[1 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t seem to consider or give insight on any tradeoffs involved.<p>Also, the underlying extension, HypoPG, doesn&#x27;t seem to collect any statistics on data to influence query planner.</div><br/></div></div><div id="40029276" class="c"><input type="checkbox" id="c-40029276" checked=""/><div class="controls bullet"><span class="by">jensenbox</span><span>|</span><a href="#40029004">prev</a><span>|</span><a href="#40029209">next</a><span>|</span><label class="collapse" for="c-40029276">[-]</label><label class="expand" for="c-40029276">[1 more]</label></div><br/><div class="children"><div class="content">dexter uses a similar premise with hypog.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ankane&#x2F;dexter">https:&#x2F;&#x2F;github.com&#x2F;ankane&#x2F;dexter</a></div><br/></div></div><div id="40029209" class="c"><input type="checkbox" id="c-40029209" checked=""/><div class="controls bullet"><span class="by">Bishonen88</span><span>|</span><a href="#40029276">prev</a><span>|</span><a href="#40028821">next</a><span>|</span><label class="collapse" for="c-40029209">[-]</label><label class="expand" for="c-40029209">[2 more]</label></div><br/><div class="children"><div class="content">How does one install this on a aws rds instance?</div><br/><div id="40029305" class="c"><input type="checkbox" id="c-40029305" checked=""/><div class="controls bullet"><span class="by">kiwicopple</span><span>|</span><a href="#40029209">parent</a><span>|</span><a href="#40028821">next</a><span>|</span><label class="collapse" for="c-40029305">[-]</label><label class="expand" for="c-40029305">[1 more]</label></div><br/><div class="children"><div class="content">hypopg is now supported in RDS so the steps would be:<p>1. Enable hypopg<p><pre><code>    create extension if not exists hypopg;
</code></pre>
2. Copy&#x2F;paste the plpgsql file:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;supabase&#x2F;index_advisor&#x2F;blob&#x2F;main&#x2F;index_advisor--0.2.0.sql">https:&#x2F;&#x2F;github.com&#x2F;supabase&#x2F;index_advisor&#x2F;blob&#x2F;main&#x2F;index_ad...</a><p>We are also developing the Trusted Language Extension with the RDS team, so at some point it should be easier to do this through database.dev:<p><a href="https:&#x2F;&#x2F;database.dev&#x2F;olirice&#x2F;index_advisor" rel="nofollow">https:&#x2F;&#x2F;database.dev&#x2F;olirice&#x2F;index_advisor</a></div><br/></div></div></div></div><div id="40028821" class="c"><input type="checkbox" id="c-40028821" checked=""/><div class="controls bullet"><span class="by">itsgrimetime</span><span>|</span><a href="#40029209">prev</a><span>|</span><a href="#40028879">next</a><span>|</span><label class="collapse" for="c-40028821">[-]</label><label class="expand" for="c-40028821">[2 more]</label></div><br/><div class="children"><div class="content">Does something like this for MongoDB? Searching hasn’t turned up anything useful.</div><br/><div id="40028971" class="c"><input type="checkbox" id="c-40028971" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#40028821">parent</a><span>|</span><a href="#40028879">next</a><span>|</span><label class="collapse" for="c-40028971">[-]</label><label class="expand" for="c-40028971">[1 more]</label></div><br/><div class="children"><div class="content">Ops Manager (paid tool) kinda supports this but in my experience it misses a lot of obvious suggestions.</div><br/></div></div></div></div><div id="40028879" class="c"><input type="checkbox" id="c-40028879" checked=""/><div class="controls bullet"><span class="by">pkiv</span><span>|</span><a href="#40028821">prev</a><span>|</span><a href="#40028112">next</a><span>|</span><label class="collapse" for="c-40028879">[-]</label><label class="expand" for="c-40028879">[1 more]</label></div><br/><div class="children"><div class="content">The supabase team always delivers. Excited to give this a try!</div><br/></div></div></div></div></div></div></div></body></html>