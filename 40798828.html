<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719565266066" as="style"/><link rel="stylesheet" href="styles.css?v=1719565266066"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://tech.popdata.org/Flame-Graphs-Performance-Tuning-Made-Easy/">Flame Graphs: Making the opaque obvious (2017)</a> <span class="domain">(<a href="https://tech.popdata.org">tech.popdata.org</a>)</span></div><div class="subtext"><span>davikr</span> | <span>38 comments</span></div><br/><div><div id="40813229" class="c"><input type="checkbox" id="c-40813229" checked=""/><div class="controls bullet"><span class="by">zlurkerz</span><span>|</span><a href="#40812339">next</a><span>|</span><label class="collapse" for="c-40813229">[-]</label><label class="expand" for="c-40813229">[6 more]</label></div><br/><div class="children"><div class="content">How do flame graphs handle the case where most of the time is spent in some leaf function that is called from all over the program? In this case, each individual stack would not take much time but in aggregate, a lot of time is spent in the function at the top of all of the call stacks. This should not be that uncommon to have hotspots in things like copying routines, compression, encryption etc that are not associated with any particular stack.<p>pprof from <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;pprof">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;pprof</a> can produce a DAG view of a profile where nodes are sized proportional to their cumulative time, e.g.,
<a href="https:&#x2F;&#x2F;slcjordan.github.io&#x2F;images&#x2F;pprof&#x2F;graphviz.png" rel="nofollow">https:&#x2F;&#x2F;slcjordan.github.io&#x2F;images&#x2F;pprof&#x2F;graphviz.png</a> and such a view would seem to cover the case above and subsume the usual use cases for a flame graph, would it not?<p>Although I guess a flat text profile of functions sorted by time would also highlight these kinds of hot spots. Still, if we want a single graphical view as a go-to, it&#x27;s not clear that flame graphs are all that much better than pprof DAGs.</div><br/><div id="40813668" class="c"><input type="checkbox" id="c-40813668" checked=""/><div class="controls bullet"><span class="by">nemetroid</span><span>|</span><a href="#40813229">parent</a><span>|</span><a href="#40814252">next</a><span>|</span><label class="collapse" for="c-40813668">[-]</label><label class="expand" for="c-40813668">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How do flame graphs handle the case where most of the time is spent in some leaf function that is called from all over the program?<p>In my experience, they don&#x27;t really. They&#x27;re very good for finding easy wins where a high&#x2F;medium-level operation takes much longer than you&#x27;d expect it to, not so much for finding low-level hotspots in the code.<p>&gt; such a view would [...] subsume the usual use cases for a flame graph, would it not?<p>I don&#x27;t think it does. A flame graph gives you a good idea of the hierarchical structure (and quickly). Sometimes you can work that out from a DAG, but not necessarily:<p>Let&#x27;s say that A and B call M, and M calls X and Y. All four edges have roughly the same value. A flame graph can show you that 90% of the time spent in X started with A and that 90% of the time spent in Y started with B, but the DAG can&#x27;t.</div><br/></div></div><div id="40814252" class="c"><input type="checkbox" id="c-40814252" checked=""/><div class="controls bullet"><span class="by">tanelpoder</span><span>|</span><a href="#40813229">parent</a><span>|</span><a href="#40813668">prev</a><span>|</span><a href="#40818590">next</a><span>|</span><label class="collapse" for="c-40814252">[-]</label><label class="expand" for="c-40814252">[1 more]</label></div><br/><div class="children"><div class="content">I had the same experience&#x2F;question at some point when I noticed (and investigated), why didn&#x27;t a new Ubuntu Linux install break out interrupt usage in vmstat anymore. [1]<p>Perf+flamegraphs were able to catch in-interrupt-handling samples as I was on a bare metal machine with PMU counters accessible. But the various NVMe I&#x2F;O completion interrupts happened all over the place, even when the CPUs were in random userspace code sections. Neither the bottom-up &amp; top-down FlameGraph approach made it visually clear in this case.<p>But since interrupt time <i>did</i> show up and since the FlameGraph JS tool had a text search box, I searched for &quot;interrupt&quot; or &quot;irq&quot; in the search box - and the JS code highlighted all matching sections with purple color (completely distinct from the classic color range of flamegraphs). And seeing that purple color all over the place made me smile and gave me a strong visual &quot;a-ha&quot; moment. Probably with some extra JS tinkering, these kinds of &quot;events scattered all over the place&quot; scenarios could be made even clearer.<p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26139611">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26139611</a> (2021)</div><br/></div></div><div id="40818590" class="c"><input type="checkbox" id="c-40818590" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#40813229">parent</a><span>|</span><a href="#40814252">prev</a><span>|</span><a href="#40813343">next</a><span>|</span><label class="collapse" for="c-40818590">[-]</label><label class="expand" for="c-40818590">[1 more]</label></div><br/><div class="children"><div class="content">They don&#x27;t. The best way to visualize that, that I&#x27;ve seen is the DHAT tool of Valgrind, that basically builds a trie from the roots based on how much allocations happens in them (the tool measures allocations, but the visualization could just as well be used for time spent).</div><br/></div></div><div id="40813343" class="c"><input type="checkbox" id="c-40813343" checked=""/><div class="controls bullet"><span class="by">mandarax8</span><span>|</span><a href="#40813229">parent</a><span>|</span><a href="#40818590">prev</a><span>|</span><a href="#40812339">next</a><span>|</span><label class="collapse" for="c-40813343">[-]</label><label class="expand" for="c-40813343">[2 more]</label></div><br/><div class="children"><div class="content">My flame graph tool (KDAB hotspot) has a bottom-up flame graph for that purpose.</div><br/><div id="40813666" class="c"><input type="checkbox" id="c-40813666" checked=""/><div class="controls bullet"><span class="by">zlurkerz</span><span>|</span><a href="#40813229">root</a><span>|</span><a href="#40813343">parent</a><span>|</span><a href="#40812339">next</a><span>|</span><label class="collapse" for="c-40813666">[-]</label><label class="expand" for="c-40813666">[1 more]</label></div><br/><div class="children"><div class="content">Right, but then you have to know to consult both top-down and bottom-up. Seems like a DAG is a union of these views.</div><br/></div></div></div></div></div></div><div id="40812339" class="c"><input type="checkbox" id="c-40812339" checked=""/><div class="controls bullet"><span class="by">PreInternet01</span><span>|</span><a href="#40813229">prev</a><span>|</span><a href="#40814480">next</a><span>|</span><label class="collapse" for="c-40812339">[-]</label><label class="expand" for="c-40812339">[30 more]</label></div><br/><div class="children"><div class="content">OK, shameful confession time here: I just <i>cannot</i> grasp flame charts, no matter how hard I try. And yes: that&#x27;s just me, I&#x27;m dumb, etc. etc. (and I freely admit all of that, including the et-ceteras!)<p>I tried to follow along with things that are relevant to my job, like <a href="https:&#x2F;&#x2F;randomascii.wordpress.com&#x2F;2016&#x2F;09&#x2F;05&#x2F;etw-flame-graphs-made-easy&#x2F;" rel="nofollow">https:&#x2F;&#x2F;randomascii.wordpress.com&#x2F;2016&#x2F;09&#x2F;05&#x2F;etw-flame-graph...</a> ...And totally failed? I look at the reddest part of the chart, I look at the peaks, and none of that matches the conclusion reached in the blog post?<p>And then I tried to grok all the knowledge conveyed in <a href="https:&#x2F;&#x2F;www.brendangregg.com&#x2F;flamegraphs.html" rel="nofollow">https:&#x2F;&#x2F;www.brendangregg.com&#x2F;flamegraphs.html</a> and... came away similarly confused? Sure, I see patterns, but when asked to identify which of those patterns indicate problems, I would still score &lt;50%?<p>And, I mean, I do memory&#x2F;CPU traces like all day every day, and I fix code all the time based on that, but that&#x27;s all just based on hierarchical bar charts, which are NOT the same as inverted flame graphs, as far as I can tell?<p>Anyway, thanks for coming to my therapy session, and feel free to leave your helpful-comment-that-will-finally-enlighten-me and&#x2F;or downvote at the door.</div><br/><div id="40812621" class="c"><input type="checkbox" id="c-40812621" checked=""/><div class="controls bullet"><span class="by">rkallos</span><span>|</span><a href="#40812339">parent</a><span>|</span><a href="#40812929">next</a><span>|</span><label class="collapse" for="c-40812621">[-]</label><label class="expand" for="c-40812621">[5 more]</label></div><br/><div class="children"><div class="content">&gt; I look at the reddest part of the chart, I look at the peaks<p>Neither of these are really the places I look at when examining flame graphs. I tend to look at the bottom, and work my way up.<p>The key thing (imo) to look for are wide pieces that are not a core part of what the code you&#x27;re profiling is supposed to do.<p>In the first example of your first link, you have a flame graph of code that seems to draw an image. There are a bunch of functions like &#x27;CopyPixels&#x27; and &#x27;RasterizeEdges&#x27;. Those seem to be a core part of drawing an image. In contrast, there&#x27;s a &#x27;KiPageFault&#x27; function that&#x27;s pretty wide that does not seem to be important to the code&#x27;s overall goal. I think a bit more context is needed to arrive at the author&#x27;s conclusion, though.<p>I think flame graphs, like all graphs, are more helpful when the reader has a lot of context about what&#x27;s supposed to happen, or some intuition about how the chart is supposed to look.</div><br/><div id="40813027" class="c"><input type="checkbox" id="c-40813027" checked=""/><div class="controls bullet"><span class="by">PreInternet01</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40812621">parent</a><span>|</span><a href="#40812929">next</a><span>|</span><label class="collapse" for="c-40813027">[-]</label><label class="expand" for="c-40813027">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I think flame graphs, like all graphs, are more helpful when the reader has a lot of context about what&#x27;s supposed to happen, or some intuition about how the chart is supposed to look.<p>Yeah, and then your comment... just ends? So, what I get here is that, in a flame graph, the reddest part isn&#x27;t the most interesting, and neither is the widest part, nor the part with the most peaks.<p>So, what, <i>exactly</i>, am I looking for? &quot;You know what this graph should look like in case all was OK&quot; is not exactly helpful, right, because I <i>might</i> just lack that baseline?</div><br/><div id="40815905" class="c"><input type="checkbox" id="c-40815905" checked=""/><div class="controls bullet"><span class="by">SassyBird</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40813027">parent</a><span>|</span><a href="#40813096">next</a><span>|</span><label class="collapse" for="c-40815905">[-]</label><label class="expand" for="c-40815905">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; So, what, exactly, am I looking for?</i><p>This can’t be answered in general. Flamegraphs are measurements of what happened. But just like a ruler doesn’t tell you whether a given human is atypically short or tall for its species, a flamegraph can’t tell you which portion of the program takes too long a time. You need to have prior knowledge about data structures, algorithms, memory bandwidth etc in order to confront your justified expectations with the reality and be surprised with something. And it will all depend on the particular program you profile.</div><br/></div></div><div id="40813096" class="c"><input type="checkbox" id="c-40813096" checked=""/><div class="controls bullet"><span class="by">spencerflem</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40813027">parent</a><span>|</span><a href="#40815905">prev</a><span>|</span><a href="#40812929">next</a><span>|</span><label class="collapse" for="c-40813096">[-]</label><label class="expand" for="c-40813096">[2 more]</label></div><br/><div class="children"><div class="content">As I understand it, flame graphs add to normal x-axis-as-time ones by merging repeated calls to the same function, so if one function is called a lot it shows up as one wide chunk and not many small chunks spread out.<p>So yes, height doesn&#x27;t matter much, you read bottom to top to get context, and width is what you&#x27;re looking for.<p>But like any chart, it can&#x27;t tell you what to optimise, or what Can be optimized. It just tells you what parts of the code are taking up the most time, in a hierarchical way. Asking for a complete description of what to see here is like asking for a complete description of what to look for in a histogram. Like, ofc it matters what the histogram is of!</div><br/><div id="40818633" class="c"><input type="checkbox" id="c-40818633" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40813096">parent</a><span>|</span><a href="#40812929">next</a><span>|</span><label class="collapse" for="c-40818633">[-]</label><label class="expand" for="c-40818633">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As I understand it, flame graphs add to normal x-axis-as-time ones by merging repeated calls to the same function, so if one function is called a lot it shows up as one wide chunk and not many small chunks spread out.<p>Not if the graph is sorted on time axis. Not if the callstacks look different in different cases. Not if the program is recursive and thus have different depth all over the place. There is a lot of places that merging can fall over and not happen.</div><br/></div></div></div></div></div></div></div></div><div id="40812929" class="c"><input type="checkbox" id="c-40812929" checked=""/><div class="controls bullet"><span class="by">simscitizen</span><span>|</span><a href="#40812339">parent</a><span>|</span><a href="#40812621">prev</a><span>|</span><a href="#40812437">next</a><span>|</span><label class="collapse" for="c-40812929">[-]</label><label class="expand" for="c-40812929">[7 more]</label></div><br/><div class="children"><div class="content">&gt; I do memory&#x2F;CPU traces like all day every day, and I fix code all the time based on that<p>So I take it you understand one of the standard visualizations produced by a CPU profiling tool, e.g. it takes a call stack sample every millisecond. The x-axis is time (one sample per ms, if you have only one CPU), and the y-axis is the call stack.<p>Now for a flamegraph, you basically have the same visualization, but you sort the samples across the x-axis so that callstacks that start with the same prefixes are grouped together.<p>Incidentally, the sorting of samples across the x-axis destroys the time information which is often critical. I constantly see engineers who don&#x27;t understand flamegraphs looking at the entire flamegraph of a say 3 second trace, and then trying to use that whole flamegraph to optimize a 100 ms critical path within the trace, which is totally nonsensical.</div><br/><div id="40813219" class="c"><input type="checkbox" id="c-40813219" checked=""/><div class="controls bullet"><span class="by">simscitizen</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40812929">parent</a><span>|</span><a href="#40812437">next</a><span>|</span><label class="collapse" for="c-40813219">[-]</label><label class="expand" for="c-40813219">[6 more]</label></div><br/><div class="children"><div class="content">As an example, imagine you sampled a program and got 5 CPU call stack samples.<p><pre><code>  c               c
  b               b               d
  a       a       a       a       a
  main    main    main    main    main
</code></pre>
In a flamegraph, you would see:<p><pre><code>  [c              ]
  [b              ][d     ]
  [a                                     ]
  [main                                  ]</code></pre></div><br/><div id="40813567" class="c"><input type="checkbox" id="c-40813567" checked=""/><div class="controls bullet"><span class="by">PreInternet01</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40813219">parent</a><span>|</span><a href="#40812437">next</a><span>|</span><label class="collapse" for="c-40813567">[-]</label><label class="expand" for="c-40813567">[5 more]</label></div><br/><div class="children"><div class="content">Yeah, I imagine it, and still don&#x27;t see how the flame graph would help?<p>Shown as a hierarchical bar chart, this would suggest &#x27;b&#x27; is problematic.<p>Where, color-wise (because peak-wise, &#x27;c&#x27; would be the culprit here) do I see this issue in a flame graph? Because I fear that either &#x27;main&#x27; or &#x27;a&#x27; would have the most dominant shade of red here?</div><br/><div id="40813991" class="c"><input type="checkbox" id="c-40813991" checked=""/><div class="controls bullet"><span class="by">simscitizen</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40813567">parent</a><span>|</span><a href="#40812437">next</a><span>|</span><label class="collapse" for="c-40813991">[-]</label><label class="expand" for="c-40813991">[4 more]</label></div><br/><div class="children"><div class="content">Peaks don&#x27;t matter, they just correspond to the depth of the call stack.<p>Probably the simplest way to use the flame graph is work from the bottom of the flamegraph and walk upwards until you find something interesting you optimize. Ideally you find something wide to optimize that makes sense. (The widest thing here is &quot;main&quot; which is obviously probably not the interesting thing to optimize, so you would work upwards from there.) The basic idea is that things that are wide in the flamegraph are expensive and potential things to optimize.<p>Where I work, we have tools that can produce diffed flamegraphs which can be really useful in figuring out why one trace uses so much more&#x2F;less CPU than another.</div><br/><div id="40814156" class="c"><input type="checkbox" id="c-40814156" checked=""/><div class="controls bullet"><span class="by">PreInternet01</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40813991">parent</a><span>|</span><a href="#40812437">next</a><span>|</span><label class="collapse" for="c-40814156">[-]</label><label class="expand" for="c-40814156">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Probably the simplest way to use the flame graph is work from the bottom of the flamegraph and walk upwards until you find something interesting you optimize<p>OK, so going by what is apparently the &#x27;simple example&#x27; in the linked article: <a href="https:&#x2F;&#x2F;tech.popdata.org&#x2F;images&#x2F;cps1970_before_fix_dwarf_gcc53.svg" rel="nofollow">https:&#x2F;&#x2F;tech.popdata.org&#x2F;images&#x2F;cps1970_before_fix_dwarf_gcc...</a><p>I work my way up. First thing that is really red is Conversion::Process::Run, but that probably wraps a lot of things, so I keep going up.<p>Next is Cps::Editor::relate_edits, or possibly EditingAPI::Rules::countPeopleMatching, because it&#x27;s a darker red?<p>And then there is another red-ish function, followed(?) by some yellow-colored (and thus unimportant?) stack entries, and then the apparent culprit: Record::hasVariable.<p>So, and I&#x27;m truly not trying to be difficult or argumentative here: how was I supposed to pick out &#x27;Record::hasVariable&#x27; right away from &#x27;<a href="https:&#x2F;&#x2F;tech.popdata.org&#x2F;images&#x2F;cps1970_before_fix_dwarf_gcc53.svg" rel="nofollow">https:&#x2F;&#x2F;tech.popdata.org&#x2F;images&#x2F;cps1970_before_fix_dwarf_gcc...</a>&#x27;?<p>The first function that is red being called from yellow-colored functions with about the same duration (width)? And if so, why is Metadata::Cache::getVarsByName not a more likely optimization target?</div><br/><div id="40814947" class="c"><input type="checkbox" id="c-40814947" checked=""/><div class="controls bullet"><span class="by">eterm</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40814156">parent</a><span>|</span><a href="#40814910">next</a><span>|</span><label class="collapse" for="c-40814947">[-]</label><label class="expand" for="c-40814947">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, the flame chart can&#x27;t tell you that.<p>The solution provided in the article seems to rip out `Metadata::Cache::getVarsByName` entirely. If it were easy to optimise `Metadata::Cache::getVarsByName` instead, then that would also have been a suitable optimisation.<p>I guess domain knowledge and experience let them know which optimisation was more suitable here.</div><br/></div></div><div id="40814910" class="c"><input type="checkbox" id="c-40814910" checked=""/><div class="controls bullet"><span class="by">fwip</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40814156">parent</a><span>|</span><a href="#40814947">prev</a><span>|</span><a href="#40812437">next</a><span>|</span><label class="collapse" for="c-40814910">[-]</label><label class="expand" for="c-40814910">[1 more]</label></div><br/><div class="children"><div class="content">Other user here: Confession - I don&#x27;t actually know what, if anything, the colors mean in a flamegraph. They seem random to me.<p>The way I&#x27;d personally hone in on Record::hasVariable is that it&#x27;s a relatively-simple sounding function (from the name) that is taking a large portion of the X-axis.  Starting at the bottom, I&#x27;d go &quot;main -&gt; editInOrder -&gt; relateEdits -&gt; countPeopleMatching -&gt; getSourceDataAsLong -&gt; hasVariable.&quot; Then I&#x27;d be like &quot;we really spend 47% of our time in this simple-sounding function? What&#x27;s it doing?&quot;<p>Basically, I look for the functions that have an outsized complexity&#x2F;time ratio. A function with a simple task is usually easier to optimize, and a function that only runs for 2% of your program isn&#x27;t worth spending the time to optimize.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40812437" class="c"><input type="checkbox" id="c-40812437" checked=""/><div class="controls bullet"><span class="by">eterm</span><span>|</span><a href="#40812339">parent</a><span>|</span><a href="#40812929">prev</a><span>|</span><a href="#40818304">next</a><span>|</span><label class="collapse" for="c-40812437">[-]</label><label class="expand" for="c-40812437">[4 more]</label></div><br/><div class="children"><div class="content">I think I&#x27;m the same as you, I much prefer the style where you get an interactive profile and can hit &quot;show me the hot path&quot; and it&#x27;ll expand down the hot path.<p>The overall flame charts just don&#x27;t provide the immediate &quot;Here&#x27;s what&#x27;s wrong&quot; you need from a chart.<p>Charts should be simple enough to quickly get an idea of whether the thing you&#x27;re looking at is &quot;Good&quot; or &quot;bad&quot; and if &quot;Bad&quot;, quickly see where the problem is.</div><br/><div id="40812521" class="c"><input type="checkbox" id="c-40812521" checked=""/><div class="controls bullet"><span class="by">PreInternet01</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40812437">parent</a><span>|</span><a href="#40818304">next</a><span>|</span><label class="collapse" for="c-40812521">[-]</label><label class="expand" for="c-40812521">[3 more]</label></div><br/><div class="children"><div class="content">Well, thank you for pointing out that hierarchical bar charts do a pretty good job at showing the hot path.<p>So my (and I guess your) workflow is then to fix the top-X hot paths, and then re-profile, etc.<p>The attraction of flame graphs, as I understand it, is that you can get the same information <i>without</i> the need to iterate. Which is obviously very valuable if you&#x27;re operating on single-shot bug reports, but... <i>how</i> exactly? (Not a question directed at you, obviously, but more towards the general discussion)</div><br/><div id="40813003" class="c"><input type="checkbox" id="c-40813003" checked=""/><div class="controls bullet"><span class="by">eterm</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40812521">parent</a><span>|</span><a href="#40812616">next</a><span>|</span><label class="collapse" for="c-40813003">[-]</label><label class="expand" for="c-40813003">[1 more]</label></div><br/><div class="children"><div class="content">The jetbrains profiler lets you quickly &quot;Scope to X&quot;, so you can scope to the second or third highest ranked functions and see their breakdown too, so you don&#x27;t need to fix the highest to get a full understanding.</div><br/></div></div><div id="40812616" class="c"><input type="checkbox" id="c-40812616" checked=""/><div class="controls bullet"><span class="by">hobs</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40812521">parent</a><span>|</span><a href="#40813003">prev</a><span>|</span><a href="#40818304">next</a><span>|</span><label class="collapse" for="c-40812616">[-]</label><label class="expand" for="c-40812616">[1 more]</label></div><br/><div class="children"><div class="content">I recommend writing your own flame graph generator, the syntax is super simple and it will help you understand the span&#x2F;subspan nesting.<p>In some cases it&#x27;s not that helpful if you don&#x27;t have the right type of problem, eg I was troubleshooting some higher level stuff (SQL) and looking at stored procedure invocations and a two depth invocation doesn&#x27;t tell you very much.<p>For me a FG is more about sounding out the problem and understanding what the scope of what is possible more than fixing an immediate and obvious issue.</div><br/></div></div></div></div></div></div><div id="40818304" class="c"><input type="checkbox" id="c-40818304" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40812339">parent</a><span>|</span><a href="#40812437">prev</a><span>|</span><a href="#40812534">next</a><span>|</span><label class="collapse" for="c-40818304">[-]</label><label class="expand" for="c-40818304">[1 more]</label></div><br/><div class="children"><div class="content">You can use them pretty much the same as hierarchical bar charts - at least I do. The two things to look for are a) entries with a big flat surface on top - these are functions with a lot of intrinsic time (i.e. stuff that would show up as &quot;most time in function&quot; in a traditional profiler) b) entries that are wider than they should be - the things that you&#x27;d look into by repeatedly expanding the hierarchical bar chart, you can look into by going from the bottom of the flamegraph up.<p>For me when using a traditional profiler I often find myself switching back and forth between those two views (functions with most intrinstic time versus tree of function calls by time) and having to expand and contract different parts of that tree breakdown. So the advantage of a flamegraph is putting all that information on one page.</div><br/></div></div><div id="40812534" class="c"><input type="checkbox" id="c-40812534" checked=""/><div class="controls bullet"><span class="by">throw0101b</span><span>|</span><a href="#40812339">parent</a><span>|</span><a href="#40818304">prev</a><span>|</span><a href="#40817593">next</a><span>|</span><label class="collapse" for="c-40812534">[-]</label><label class="expand" for="c-40812534">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>And then I tried to grok all the knowledge conveyed in <a href="https:&#x2F;&#x2F;www.brendangregg.com&#x2F;flamegraphs.html" rel="nofollow">https:&#x2F;&#x2F;www.brendangregg.com&#x2F;flamegraphs.html</a></i><p>Have you watched the LISA 2013 presentation video?<p>* <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=nZfNehCzGdw" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=nZfNehCzGdw</a><p>* <a href="https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;lisa13&#x2F;technical-sessions&#x2F;plenary&#x2F;gregg" rel="nofollow">https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;lisa13&#x2F;technical-sessions&#x2F;...</a><p>Some follow-on presentations from him, I found the first one useful:<p>* <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=D53T1Ejig1Q&amp;t=12m50s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=D53T1Ejig1Q&amp;t=12m50s</a><p>* <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=VMpTU15rIZY&amp;t=8m9s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=VMpTU15rIZY&amp;t=8m9s</a></div><br/></div></div><div id="40817593" class="c"><input type="checkbox" id="c-40817593" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#40812339">parent</a><span>|</span><a href="#40812534">prev</a><span>|</span><a href="#40814298">next</a><span>|</span><label class="collapse" for="c-40817593">[-]</label><label class="expand" for="c-40817593">[1 more]</label></div><br/><div class="children"><div class="content">You often want to look at the widest stuff as close to the bottom as you have appropriate context for, then follow up by working upward from that to try to arrive at an explanation.<p>Some recent-ish examples:<p>- I was optimizing some code whose main tasks should have been networking and ML. There was a suspiciously wide chunk with a name indicating something about date times. An bit later we had a solid 10% improvement win.<p>- I had some code with strange behavior under load, undergoing some kind of a performance phase transition before the CPU (or other normal resources) were anywhere near maxed out. I grabbed a flamegraph under normal conditions and under load. The `main` loop was wider, but that&#x27;s not helpful. Walking up the graph a little bit, next to some function the code was supposed to be calling there was a block named sched_yield which was huge and didn&#x27;t exist in the normal trace. The root cause was just a strange (broken) concurrency mechanism in some underlying logging code, causing logging to pile up and hog all the resources past a certain request threshold.<p>The colors are a red herring. They exist just to make it easier to keep track of where you are in the graph, much like how ragged text is easier to read than justified.<p>Height is sometimes interesting. It represents a deep call stack. I find that happens most frequently in error handling code, and if something is called enough to make its way into a sampling-based flamegraph it&#x27;s often worth taking a peek at for other reasons. Runtime is a function of width though, and height doesn&#x27;t play a role.<p>Another point worth keeping in mind is that a lot of the benefit is in being able to quickly fine a plausible explanation for the performance issue. If you find that your application is spending most of its time in `read` calls, perhaps you&#x27;ll want to do less of that, perhaps you&#x27;ll want to submit a perf improvement to the kernel (unlikely?), but what you definitely want to do is look at the next level above the offending code, then the level above that, .... What you&#x27;ll find depends on your application, but the difference between being slow because of locking and synchronization is very different from error handling or just executing the happy path a ton of times, and that insight will help govern your next actions.</div><br/></div></div><div id="40814298" class="c"><input type="checkbox" id="c-40814298" checked=""/><div class="controls bullet"><span class="by">starkrights</span><span>|</span><a href="#40812339">parent</a><span>|</span><a href="#40817593">prev</a><span>|</span><a href="#40813165">next</a><span>|</span><label class="collapse" for="c-40814298">[-]</label><label class="expand" for="c-40814298">[1 more]</label></div><br/><div class="children"><div class="content">I don’t know if it helps, but this is how I read through the graph from the first article after reading the authors conclusion. (I’m an idiot)<p>- okay, we’re analyzing DvrDrawImage
- Let’s analyze the function on the left, GpBitmap::PipeLockBits
- Up through ::Decode, takes up 100% of the time from PipeLockBits, so we’re just racing down the call stack to get to that point, and <i>then</i> other stuff starts taking up time
- Lots of WindowsCodecs calls, I guess we kind of expect those to be valid since image processing needs codecs and stuff and things 
- Okay, now there’s a bar taking up ~45-50% of the ::Decode call, that’s not a codec or drawing related thing- it’s an os level pagefault. That’s fucky. 
- Since the ::Decode call is ~55-65% of the ::DvrDrawImage call, that pagefault is (~40% of ~60% =)~25% of this draw image call<p>So essentially I looked and saw a stack of bars altogether and went ‘okay, the call at the top of this is the only reason the call 6 bars up the stack (ie, 6 bars down on the flamegraph) is taking time, why?’, and start applying the same process recursively from there.<p>That is, until $why == ‘due to codec calls and an ntkernel call’, and the question becomes ‘is that valid?’ Then the question becomes “are these codec calls taking the amount of time I would expect?”, and “<p>iiuc peaks and colors don’t matter. Tbf I think the colorscheming on this chart is shit- afaik flamegraph coloring is just a way of marking the same (or from the same library? Implementation dependent?) function for easy spotting. Like why not make the functions wildly different colors. Redness != hotness of a certain codepath.<p>The only thing peaks indicate is calls that have deeply nested function calls, which I guess would be important if you’re having recursion issues.</div><br/></div></div><div id="40813165" class="c"><input type="checkbox" id="c-40813165" checked=""/><div class="controls bullet"><span class="by">nemetroid</span><span>|</span><a href="#40812339">parent</a><span>|</span><a href="#40814298">prev</a><span>|</span><a href="#40814480">next</a><span>|</span><label class="collapse" for="c-40813165">[-]</label><label class="expand" for="c-40813165">[9 more]</label></div><br/><div class="children"><div class="content">Did you read the linked article? It starts with a very simple example and then builds up to a real-world case, unlike the articles you linked, which both start off with an advanced case.</div><br/><div id="40813522" class="c"><input type="checkbox" id="c-40813522" checked=""/><div class="controls bullet"><span class="by">PreInternet01</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40813165">parent</a><span>|</span><a href="#40814480">next</a><span>|</span><label class="collapse" for="c-40813522">[-]</label><label class="expand" for="c-40813522">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Did you read the linked article?<p>From <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html</a>: &quot;Please don&#x27;t comment on whether someone read an article&quot;<p>And yes, I did, and I truly don&#x27;t grasp even the &#x27;simple&#x27; explanation. I already admitted I&#x27;m dumb.<p>Do you have <i>anything</i> to add to the discussion?</div><br/><div id="40813610" class="c"><input type="checkbox" id="c-40813610" checked=""/><div class="controls bullet"><span class="by">nemetroid</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40813522">parent</a><span>|</span><a href="#40814480">next</a><span>|</span><label class="collapse" for="c-40813610">[-]</label><label class="expand" for="c-40813610">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Do you have anything to add to the discussion?<p>Do <i>you</i>? Can you point out where it (edit: the simple example) breaks down, instead of just repeating that you&#x27;re dumb?</div><br/><div id="40813972" class="c"><input type="checkbox" id="c-40813972" checked=""/><div class="controls bullet"><span class="by">PreInternet01</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40813610">parent</a><span>|</span><a href="#40814480">next</a><span>|</span><label class="collapse" for="c-40813972">[-]</label><label class="expand" for="c-40813972">[6 more]</label></div><br/><div class="children"><div class="content">By the &#x27;simple example&#x27;, I assume you mean <a href="https:&#x2F;&#x2F;tech.popdata.org&#x2F;images&#x2F;cps1970_before_fix_dwarf_gcc53.svg" rel="nofollow">https:&#x2F;&#x2F;tech.popdata.org&#x2F;images&#x2F;cps1970_before_fix_dwarf_gcc...</a>?<p>If so, the widest, reddest, and highest-magnitude function I see there is __int__malloc. Right?<p>Yet, reading on, it seems that has nothing to do with anything, and the actual culprit is Record::hasVariable, which is somewhere in the middle of the graph, and not any redder or less red, or wider or less wide, than <i>many</i> other functions.<p>So, looking at just the first graph, how am I supposed to immediately spot the culprit?</div><br/><div id="40814240" class="c"><input type="checkbox" id="c-40814240" checked=""/><div class="controls bullet"><span class="by">nemetroid</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40813972">parent</a><span>|</span><a href="#40814097">next</a><span>|</span><label class="collapse" for="c-40814240">[-]</label><label class="expand" for="c-40814240">[3 more]</label></div><br/><div class="children"><div class="content">By simple example, I mean this: <a href="https:&#x2F;&#x2F;tech.popdata.org&#x2F;images&#x2F;flamegraph-example.svg" rel="nofollow">https:&#x2F;&#x2F;tech.popdata.org&#x2F;images&#x2F;flamegraph-example.svg</a><p>But looking at the one you&#x27;re referencing, slightly out of order:<p>&gt; highest-magnitude function I see there is __int__malloc.<p>Height shows stack depth, not magnitude.<p>&gt; the actual culprit is Record::hasVariable, which is somewhere in the middle of the graph, and not any redder or less red, or wider or less wide, than many other functions.<p>&gt; not any redder or less red<p>The colors are randomized to help with contrast (Brendan&#x27;s website mentions this practice), so they aren&#x27;t conveying any information.<p>&gt; or wider or less wide<p>That&#x27;s not really true. Hovering over Record::hasVariable tells that this bar covers 45.6% of the runtime. The only bars wider than that are the callers of Record::hasVariable (edit: rather, the stack through which Record::hasVariable is being called), i.e. the bars on which Record::hasVariable is resting.<p>&gt; somewhere in the middle of the graph<p>Sure - being in the middle height-wise means that it&#x27;s somewhere in the middle of the call stack. But there are some clues to its relevance:<p>1. It&#x27;s close to the boundary between application code and standard library code. It does call MetaData::Cache::getVarsByName, which (going by the name) also is part of the application, but everything deeper in the stack (i.e. on top of those bars) is purely std:: stuff.<p>2. Domain knowledge. The text alludes to this: Record::hasVariable is a conceptually simple operation that&#x27;s not expected to be a major part of the runtime.<p>This does not mean that Record::hasVariable must be the culprit. Maybe some function higher in the call stack (e.g. EditingAPI::Rules::getSourceDataAsLong) is calling Record::hasVariable way too many times? But it&#x27;s a good place to start looking.</div><br/><div id="40814310" class="c"><input type="checkbox" id="c-40814310" checked=""/><div class="controls bullet"><span class="by">PreInternet01</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40814240">parent</a><span>|</span><a href="#40814097">next</a><span>|</span><label class="collapse" for="c-40814310">[-]</label><label class="expand" for="c-40814310">[2 more]</label></div><br/><div class="children"><div class="content">Ah, OK, so there is a graph, where magnitude is meaningless, colors are meaningless, runtime is relative, yet, with &quot;enough domain knowledge&quot; you can &quot;see where the problem is right away&quot;...<p>I&#x27;m pretty sure we&#x27;re done here.</div><br/><div id="40814391" class="c"><input type="checkbox" id="c-40814391" checked=""/><div class="controls bullet"><span class="by">nemetroid</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40814310">parent</a><span>|</span><a href="#40814097">next</a><span>|</span><label class="collapse" for="c-40814391">[-]</label><label class="expand" for="c-40814391">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m pretty sure we&#x27;re done here.<p>Sorry to hear.</div><br/></div></div></div></div></div></div><div id="40814097" class="c"><input type="checkbox" id="c-40814097" checked=""/><div class="controls bullet"><span class="by">vessenes</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40813972">parent</a><span>|</span><a href="#40814240">prev</a><span>|</span><a href="#40814480">next</a><span>|</span><label class="collapse" for="c-40814097">[-]</label><label class="expand" for="c-40814097">[2 more]</label></div><br/><div class="children"><div class="content">I haven’t read the article. However, here is how I read the chart:<p>Record::hasVariable takes a long time. You can see that because it’s wide and red. The immediate ones below it on the chart don’t do anything but call it; you can see that because they are basically the same width. hasVariable splits into two calls (the row above). I’m going from memory here because I don’t have the chart here, but I think it should be clear from the trace:<p>A) hasVariable takes a lot of compute time<p>B) from the name, this seems surprising &#x2F; non optimal.<p>C) Digging into the functions above it will yield chances to optimize.<p>I do agree that the malloc is sort of a surprising amount of the total percentage of hasVariable. Again, just from the flame graph and function names, I’d bet that some memory allocations are being done in a loop inside and would be much faster to allocate outside the hasVariable call, and get reused.</div><br/><div id="40814270" class="c"><input type="checkbox" id="c-40814270" checked=""/><div class="controls bullet"><span class="by">PreInternet01</span><span>|</span><a href="#40812339">root</a><span>|</span><a href="#40814097">parent</a><span>|</span><a href="#40814480">next</a><span>|</span><label class="collapse" for="c-40814270">[-]</label><label class="expand" for="c-40814270">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Record::hasVariable takes a long time<p>As does Memdata::Cache::getVarsByName[blah] right above it, and many functions below (unsurprisingly, but still...), and they all have pretty much the same width and color.<p>The point of flame graph proponents is that &quot;you see where the problem is right away.&quot;<p>My question is: &quot;how, exactly?&quot; And the answers so far seems to be mostly... lacking, to the point that I now officially declare flame graphs a cargo cult that is in no way superior to my &quot;hierarchical bar charts&quot; religion...</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40814480" class="c"><input type="checkbox" id="c-40814480" checked=""/><div class="controls bullet"><span class="by">irogers</span><span>|</span><a href="#40812339">prev</a><span>|</span><label class="collapse" for="c-40814480">[-]</label><label class="expand" for="c-40814480">[1 more]</label></div><br/><div class="children"><div class="content">Just to advertise the perf tool has inbuilt flamegraph generation code these days (well leaning on D3.js). So `perf script report flamegraph` will convert a perf.data file into a flamegraph.html. Similarly there is `perf script report gecko` to write out the firefox profiler&#x27;s json format.</div><br/></div></div></div></div></div></div></div></body></html>