<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717405251202" as="style"/><link rel="stylesheet" href="styles.css?v=1717405251202"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://arxiv.org/abs/2011.13127">Copy-and-Patch: Fast compilation for high-level languages and bytecode (2020)</a> <span class="domain">(<a href="https://arxiv.org">arxiv.org</a>)</span></div><div class="subtext"><span>tosh</span> | <span>33 comments</span></div><br/><div><div id="40555796" class="c"><input type="checkbox" id="c-40555796" checked=""/><div class="controls bullet"><span class="by">alserio</span><span>|</span><a href="#40556095">next</a><span>|</span><label class="collapse" for="c-40555796">[-]</label><label class="expand" for="c-40555796">[1 more]</label></div><br/><div class="children"><div class="content">Link to the HTML version for those who need it and to help spread the knowledge of the wonderful arxiv ar5iv tool:
<a href="https:&#x2F;&#x2F;ar5iv.labs.arxiv.org&#x2F;html&#x2F;2011.13127" rel="nofollow">https:&#x2F;&#x2F;ar5iv.labs.arxiv.org&#x2F;html&#x2F;2011.13127</a></div><br/></div></div><div id="40556095" class="c"><input type="checkbox" id="c-40556095" checked=""/><div class="controls bullet"><span class="by">philzook</span><span>|</span><a href="#40555796">prev</a><span>|</span><a href="#40555839">next</a><span>|</span><label class="collapse" for="c-40556095">[-]</label><label class="expand" for="c-40556095">[1 more]</label></div><br/><div class="children"><div class="content">We found these ideas very useful for doing micropatches, post hoc intrafunction binary patches, using off the shelf compilers. At the least, a voice of support that these kinds of calling convention control is useful.<p>-  Copy and Micropatch: Writing Binary Patches in C with Clang preserve_none <a href="https:&#x2F;&#x2F;www.philipzucker.com&#x2F;permutation_compile&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.philipzucker.com&#x2F;permutation_compile&#x2F;</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;purseclab&#x2F;Patcherex2&#x2F;pull&#x2F;31">https:&#x2F;&#x2F;github.com&#x2F;purseclab&#x2F;Patcherex2&#x2F;pull&#x2F;31</a> A pull request to the PatcherEx2 library</div><br/></div></div><div id="40555839" class="c"><input type="checkbox" id="c-40555839" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#40556095">prev</a><span>|</span><a href="#40554921">next</a><span>|</span><label class="collapse" for="c-40555839">[-]</label><label class="expand" for="c-40555839">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s some related discussion here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40406194">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40406194</a></div><br/><div id="40556814" class="c"><input type="checkbox" id="c-40556814" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#40555839">parent</a><span>|</span><a href="#40554921">next</a><span>|</span><label class="collapse" for="c-40556814">[-]</label><label class="expand" for="c-40556814">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! Also related:<p><i>A copy-and-patch JIT compiler for CPython</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38769874">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38769874</a> - Dec 2023 (68 comments)<p><i>Copy-and-Patch: Fast JIT Compilation for SQL, WebAssembly, and Others</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28547057">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28547057</a> - Sept 2021 (7 comments)</div><br/></div></div></div></div><div id="40554921" class="c"><input type="checkbox" id="c-40554921" checked=""/><div class="controls bullet"><span class="by">sambeau</span><span>|</span><a href="#40555839">prev</a><span>|</span><a href="#40559643">next</a><span>|</span><label class="collapse" for="c-40554921">[-]</label><label class="expand" for="c-40554921">[3 more]</label></div><br/><div class="children"><div class="content">This is interesting. I came up with a very similar idea in the late 1990s to JIT a lazy functional language. The idea was to only compile the code that you needed to execute next, so you could run lazy code without needing to compile it (recursing across infinite lists, etc). It had templates with holes (for things like cons etc.)<p>I stuck my paper on it under Prof Phil Wadler&#x27;s office door and ran away. I have no idea if he ever read it :D</div><br/><div id="40556451" class="c"><input type="checkbox" id="c-40556451" checked=""/><div class="controls bullet"><span class="by">pompino</span><span>|</span><a href="#40554921">parent</a><span>|</span><a href="#40559643">next</a><span>|</span><label class="collapse" for="c-40556451">[-]</label><label class="expand" for="c-40556451">[2 more]</label></div><br/><div class="children"><div class="content">If you post a link, we all can read it :)</div><br/><div id="40560571" class="c"><input type="checkbox" id="c-40560571" checked=""/><div class="controls bullet"><span class="by">sambeau</span><span>|</span><a href="#40554921">root</a><span>|</span><a href="#40556451">parent</a><span>|</span><a href="#40559643">next</a><span>|</span><label class="collapse" for="c-40560571">[-]</label><label class="expand" for="c-40560571">[1 more]</label></div><br/><div class="children"><div class="content">If only I still had it. It was literally printed out and put in a plastic binder. I think it was written on a Sun Sparcstation in LaTeX.</div><br/></div></div></div></div></div></div><div id="40559643" class="c"><input type="checkbox" id="c-40559643" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#40554921">prev</a><span>|</span><a href="#40554172">next</a><span>|</span><label class="collapse" for="c-40559643">[-]</label><label class="expand" for="c-40559643">[1 more]</label></div><br/><div class="children"><div class="content">I would still call this a traditional template jit. The new things have nothing to do with copy&amp;paste, but with using continuations and TCE (tail-call elimination), which I haven&#x27;t seen in a simple template jit (or sometimes called method jit) before. Plus the register variants, to avoid moving them too much, but this is also very pedestrian, low tech. Low tech is good!</div><br/></div></div><div id="40554172" class="c"><input type="checkbox" id="c-40554172" checked=""/><div class="controls bullet"><span class="by">lumpa</span><span>|</span><a href="#40559643">prev</a><span>|</span><a href="#40556483">next</a><span>|</span><label class="collapse" for="c-40554172">[-]</label><label class="expand" for="c-40554172">[2 more]</label></div><br/><div class="children"><div class="content">Is this the technique they are using in Python&#x27;s new JIT?</div><br/><div id="40554218" class="c"><input type="checkbox" id="c-40554218" checked=""/><div class="controls bullet"><span class="by">Qem</span><span>|</span><a href="#40554172">parent</a><span>|</span><a href="#40556483">next</a><span>|</span><label class="collapse" for="c-40554218">[-]</label><label class="expand" for="c-40554218">[1 more]</label></div><br/><div class="children"><div class="content">Yes. This is the algorithm chosen for the CPython JIT under development, scheduled for inclusion from 3.13 onwards. See <a href="https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=HxSHIpEQRjs" rel="nofollow">https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=HxSHIpEQRjs</a></div><br/></div></div></div></div><div id="40556483" class="c"><input type="checkbox" id="c-40556483" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40554172">prev</a><span>|</span><a href="#40554206">next</a><span>|</span><label class="collapse" for="c-40556483">[-]</label><label class="expand" for="c-40556483">[7 more]</label></div><br/><div class="children"><div class="content">It’s kind of annoying how static compilers insist on figuring out everything from scratch. Even in an LTO build, the amount of code that changes between two consecutive commits is typically minimal - rather than the very coarse ccache-style, it would be nice if compilers had nicer ways to cache state across execution so that unchanged code constructs could just emit the same assembly as last time without needing to do anything else.</div><br/><div id="40558793" class="c"><input type="checkbox" id="c-40558793" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#40556483">parent</a><span>|</span><a href="#40556629">next</a><span>|</span><label class="collapse" for="c-40558793">[-]</label><label class="expand" for="c-40558793">[2 more]</label></div><br/><div class="children"><div class="content">The very first objection that immediately have sprung up to my mind it that this approach gives up on (chances of) inlining <i>a lot</i> of stuff (or de-inlining, for that matter). The second thought is that it also heavily interferes with any code motion transformations, including instruction scheduling, loop unrolling and auto-vectorization. Granted, this second objection can probably be dealt with by using some clever fine-guided techniques... but at this point I&#x27;d wager they&#x27;d be both a) about as slow as doing all the work it from the clean slate; b) have incredibly large surface for obscure bugs — and those steps are already one of the most finicky ones.<p>And back in the 70s, when the microcomputers and interactive computing were becoming the norm, and people <i>really</i> cared about the compilation times — still nobody bothered to implement that kind caching, AFAIK, even when the compiler performed way less complex kinds optimizations than they do today (heck, even register allocation was not done as graph colouring back then).</div><br/><div id="40559636" class="c"><input type="checkbox" id="c-40559636" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#40556483">root</a><span>|</span><a href="#40558793">parent</a><span>|</span><a href="#40556629">next</a><span>|</span><label class="collapse" for="c-40559636">[-]</label><label class="expand" for="c-40559636">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s an incredibly minimalistic example:<p><pre><code>    int f(double x, int y) {
        return x * y;
    }

    int g(int x, int y) {
        return x * y;
    }
</code></pre>
These two functions differ by a single token, yet their assembly translations have only one common instruction, and this instruction is &quot;ret&quot;:<p><pre><code>    f:
        movapd      xmm1, xmm0
        pxor        xmm0, xmm0
        cvtsi2sd    xmm0, edi
        mulsd       xmm0, xmm1
        cvttsd2si   eax, xmm0
        ret
    g:
        mov         eax, edi
        imul        eax, esi
        ret</code></pre></div><br/></div></div></div></div><div id="40556629" class="c"><input type="checkbox" id="c-40556629" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#40556483">parent</a><span>|</span><a href="#40558793">prev</a><span>|</span><a href="#40557746">next</a><span>|</span><label class="collapse" for="c-40556629">[-]</label><label class="expand" for="c-40556629">[2 more]</label></div><br/><div class="children"><div class="content">Rust&#x27;s incremental compilation does this. Unfortunately, it doesn&#x27;t help with linking, but it speeds up compilation by reusing everything that didn&#x27;t change.</div><br/><div id="40556736" class="c"><input type="checkbox" id="c-40556736" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40556483">root</a><span>|</span><a href="#40556629">parent</a><span>|</span><a href="#40557746">next</a><span>|</span><label class="collapse" for="c-40556736">[-]</label><label class="expand" for="c-40556736">[1 more]</label></div><br/><div class="children"><div class="content">I could be wrong but I think Rust’s incremental compilation is still pretty coarse. LLVM is where this would need to be implemented and that’s a tall ask (i.e. skipping expensive computation when the AST is the same or close enough to a previously computed result). And Rust’s incremental compilation doesn’t apply to LTO. There’s only so much you can do from outside the compiler toolchain.</div><br/></div></div></div></div><div id="40557746" class="c"><input type="checkbox" id="c-40557746" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40556483">parent</a><span>|</span><a href="#40556629">prev</a><span>|</span><a href="#40558215">next</a><span>|</span><label class="collapse" for="c-40557746">[-]</label><label class="expand" for="c-40557746">[1 more]</label></div><br/><div class="children"><div class="content">If you’re going for very fast codegen, sure. But in a production build typically you have problems like “this shifted by one instruction so every non-relative branch beyond it needs to be patched”.</div><br/></div></div></div></div><div id="40556232" class="c"><input type="checkbox" id="c-40556232" checked=""/><div class="controls bullet"><span class="by">boywitharupee</span><span>|</span><a href="#40554206">prev</a><span>|</span><a href="#40554824">next</a><span>|</span><label class="collapse" for="c-40556232">[-]</label><label class="expand" for="c-40556232">[3 more]</label></div><br/><div class="children"><div class="content">&gt; At runtime, C&amp;P generates executable code by copying the object code and patching the holes with runtime known values.<p>how would this work on OSs under hardened runtime rules?</div><br/><div id="40556362" class="c"><input type="checkbox" id="c-40556362" checked=""/><div class="controls bullet"><span class="by">mrugiero</span><span>|</span><a href="#40556232">parent</a><span>|</span><a href="#40554824">next</a><span>|</span><label class="collapse" for="c-40556362">[-]</label><label class="expand" for="c-40556362">[2 more]</label></div><br/><div class="children"><div class="content">The same as with any other JIT runtime: you do your transformations first, and then you do the `mprotect` call that turns write permissions off and execution permissions on. The only caveats I can think of (`pledge`d not to use `mprotect`, marked most of the address space with `mimmutable`) apply to all other JITs too. The gist is that you operate on a copy of code, and that copy is in a writable page until it&#x27;s ready to run, so you never violate the W^X rule.</div><br/><div id="40558978" class="c"><input type="checkbox" id="c-40558978" checked=""/><div class="controls bullet"><span class="by">IAmLiterallyAB</span><span>|</span><a href="#40556232">root</a><span>|</span><a href="#40556362">parent</a><span>|</span><a href="#40554824">next</a><span>|</span><label class="collapse" for="c-40558978">[-]</label><label class="expand" for="c-40558978">[1 more]</label></div><br/><div class="children"><div class="content">Or you do what V8 does with WebAssembly and just use WX pages because doing it correctly is &quot;too hard&quot; to do without losing performance.</div><br/></div></div></div></div></div></div><div id="40554824" class="c"><input type="checkbox" id="c-40554824" checked=""/><div class="controls bullet"><span class="by">thrtythreeforty</span><span>|</span><a href="#40556232">prev</a><span>|</span><a href="#40554679">next</a><span>|</span><label class="collapse" for="c-40554824">[-]</label><label class="expand" for="c-40554824">[8 more]</label></div><br/><div class="children"><div class="content">I love this approach. Has any independent toolkit evolved to help do this? Or have all projects rolled their own?</div><br/><div id="40555340" class="c"><input type="checkbox" id="c-40555340" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#40554824">parent</a><span>|</span><a href="#40555054">next</a><span>|</span><label class="collapse" for="c-40555340">[-]</label><label class="expand" for="c-40555340">[1 more]</label></div><br/><div class="children"><div class="content">I think libgccjit uses this technique or can use it: it reminds me of things I read about the elisp JIT in newer versions of emacs</div><br/></div></div><div id="40555054" class="c"><input type="checkbox" id="c-40555054" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40554824">parent</a><span>|</span><a href="#40555340">prev</a><span>|</span><a href="#40554886">next</a><span>|</span><label class="collapse" for="c-40555054">[-]</label><label class="expand" for="c-40555054">[4 more]</label></div><br/><div class="children"><div class="content">There&#x27;s Deegen, which is being used to build a LuaJIT successor. <a href="https:&#x2F;&#x2F;github.com&#x2F;luajit-remake&#x2F;luajit-remake">https:&#x2F;&#x2F;github.com&#x2F;luajit-remake&#x2F;luajit-remake</a><p>From what I gather, Deegen is independent of the VM in that repo, but lives there afaik.</div><br/><div id="40555165" class="c"><input type="checkbox" id="c-40555165" checked=""/><div class="controls bullet"><span class="by">mrugiero</span><span>|</span><a href="#40554824">root</a><span>|</span><a href="#40555054">parent</a><span>|</span><a href="#40558846">next</a><span>|</span><label class="collapse" for="c-40555165">[-]</label><label class="expand" for="c-40555165">[1 more]</label></div><br/><div class="children"><div class="content">I mailed the authors a few months ago and indeed, it lives there but is independent-ish. They don&#x27;t consider it ready to use for anything else other than experiments, though.</div><br/></div></div><div id="40558846" class="c"><input type="checkbox" id="c-40558846" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#40554824">root</a><span>|</span><a href="#40555054">parent</a><span>|</span><a href="#40555165">prev</a><span>|</span><a href="#40557047">next</a><span>|</span><label class="collapse" for="c-40558846">[-]</label><label class="expand" for="c-40558846">[1 more]</label></div><br/><div class="children"><div class="content">Blog post about the approach here: <a href="https:&#x2F;&#x2F;sillycross.github.io&#x2F;2023&#x2F;05&#x2F;12&#x2F;2023-05-12&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sillycross.github.io&#x2F;2023&#x2F;05&#x2F;12&#x2F;2023-05-12&#x2F;</a></div><br/></div></div><div id="40557047" class="c"><input type="checkbox" id="c-40557047" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40554824">root</a><span>|</span><a href="#40555054">parent</a><span>|</span><a href="#40558846">prev</a><span>|</span><a href="#40554886">next</a><span>|</span><label class="collapse" for="c-40557047">[-]</label><label class="expand" for="c-40557047">[1 more]</label></div><br/><div class="children"><div class="content">It is utterly baffling that people are downvoting this comment.<p>The repo I link to here is by Haoran Xu, one of the authors of the paper.<p>Y&#x27;all need to chill out.</div><br/></div></div></div></div><div id="40554886" class="c"><input type="checkbox" id="c-40554886" checked=""/><div class="controls bullet"><span class="by">Iwan-Zotow</span><span>|</span><a href="#40554824">parent</a><span>|</span><a href="#40555054">prev</a><span>|</span><a href="#40554679">next</a><span>|</span><label class="collapse" for="c-40554886">[-]</label><label class="expand" for="c-40554886">[2 more]</label></div><br/><div class="children"><div class="content">Cpython in beta</div><br/><div id="40554976" class="c"><input type="checkbox" id="c-40554976" checked=""/><div class="controls bullet"><span class="by">thrtythreeforty</span><span>|</span><a href="#40554824">root</a><span>|</span><a href="#40554886">parent</a><span>|</span><a href="#40554679">next</a><span>|</span><label class="collapse" for="c-40554976">[-]</label><label class="expand" for="c-40554976">[1 more]</label></div><br/><div class="children"><div class="content">Sure but from looking at the patches, it seems like theirs is tied into the CPython build and infrastructure. I am talking about a dedicated library which can be dropped into a variety of superprojects to help them implement a JIT.</div><br/></div></div></div></div></div></div><div id="40554679" class="c"><input type="checkbox" id="c-40554679" checked=""/><div class="controls bullet"><span class="by">djoldman</span><span>|</span><a href="#40554824">prev</a><span>|</span><a href="#40556640">next</a><span>|</span><label class="collapse" for="c-40554679">[-]</label><label class="expand" for="c-40554679">[1 more]</label></div><br/><div class="children"><div class="content">(2020)</div><br/></div></div><div id="40556640" class="c"><input type="checkbox" id="c-40556640" checked=""/><div class="controls bullet"><span class="by">bjourne</span><span>|</span><a href="#40554679">prev</a><span>|</span><label class="collapse" for="c-40556640">[-]</label><label class="expand" for="c-40556640">[2 more]</label></div><br/><div class="children"><div class="content">Afaik, this technique is called threading (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Threaded_code" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Threaded_code</a>) and has been used in most bootstrap compilers for decades.</div><br/><div id="40556753" class="c"><input type="checkbox" id="c-40556753" checked=""/><div class="controls bullet"><span class="by">mrugiero</span><span>|</span><a href="#40556640">parent</a><span>|</span><label class="collapse" for="c-40556753">[-]</label><label class="expand" for="c-40556753">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think this counts as threading, though it makes use of it. Threading mostly removes the dispatch overhead, but you still have a general function per instruction, a function call, and an inability to inline constants. Copy and patch could be thought of as a generalization of threading in the sense that you still precompile code for your instructions, but instead of calling that code you poke holes in it to replace constants you only know at runtime, then make a single callable program out of those instead of jumping around for every instruction.<p>There is a prior, very similar approach in GNU Jitter, but it uses only the compiler and some magic rather than the linker for marking spots to replace. I read about it by mention of moonchild in a thread[0] linked by foota here.<p>[0]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40410420">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40410420</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>