<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713089488691" as="style"/><link rel="stylesheet" href="styles.css?v=1713089488691"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://tspeterkim.github.io/posts/cuda-1brc">The One Billion Row Challenge in CUDA</a> <span class="domain">(<a href="https://tspeterkim.github.io">tspeterkim.github.io</a>)</span></div><div class="subtext"><span>tspeterkim</span> | <span>9 comments</span></div><br/><div><div id="40025145" class="c"><input type="checkbox" id="c-40025145" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#40023996">next</a><span>|</span><label class="collapse" for="c-40025145">[-]</label><label class="expand" for="c-40025145">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  These offsets are obtained iteratively, stepping through the entire file buffer by the desired split size (= total file size &#x2F; desired number of parts), and marking the position of a new line character:<p>In many cases it is better to just pass the raw byte offsets to the workers, then they can skip to the first newline and progress until the next newline after their &quot;end offset&quot;. This way the launcher doesn&#x27;t need to access the input data at all.<p>This can be ineffective when boundaries are not self-describing or when the minimum processable chunk is near the expected batch size (as you will have significant swings in batch size) but I think would work quite well for this case.</div><br/><div id="40028578" class="c"><input type="checkbox" id="c-40028578" checked=""/><div class="controls bullet"><span class="by">tspeterkim</span><span>|</span><a href="#40025145">parent</a><span>|</span><a href="#40023996">next</a><span>|</span><label class="collapse" for="c-40028578">[-]</label><label class="expand" for="c-40028578">[1 more]</label></div><br/><div class="children"><div class="content">By &quot;launcher&quot;, do you mean the CUDA kernel? How can it avoid accessing the input data since it needs access to the characters based on the offsets?<p>I also already pass these offsets to the threads as `Part* parts`.<p>I also probably didn&#x27;t understand your suggestion and am drawing a blank here. So pls feel free to elaborate and correct me.</div><br/></div></div></div></div><div id="40023996" class="c"><input type="checkbox" id="c-40023996" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#40025145">prev</a><span>|</span><a href="#40024542">next</a><span>|</span><label class="collapse" for="c-40023996">[-]</label><label class="expand" for="c-40023996">[2 more]</label></div><br/><div class="children"><div class="content">&gt; GPU Hash Table?<p>How bad would performance have suffered if you sha256&#x27;d the lines to build the map? I&#x27;m going to guess &quot;badly&quot;?<p>Maybe something like this in CUDA: <a href="https:&#x2F;&#x2F;github.com&#x2F;Cyan4973&#x2F;xxHash">https:&#x2F;&#x2F;github.com&#x2F;Cyan4973&#x2F;xxHash</a> ?</div><br/><div id="40028476" class="c"><input type="checkbox" id="c-40028476" checked=""/><div class="controls bullet"><span class="by">tspeterkim</span><span>|</span><a href="#40023996">parent</a><span>|</span><a href="#40024542">next</a><span>|</span><label class="collapse" for="c-40028476">[-]</label><label class="expand" for="c-40028476">[1 more]</label></div><br/><div class="children"><div class="content">So performance would increase since hashing is faster than binary-searching.<p>However, the problem of collisions across threads and dealing with concurrent map key insertions still remains. e.g. when two different cities produce the same hash (one at each thread), how can we atomically compare 100 byte city strings and correctly do collision-solving (using linear probe, for example -  <a href="https:&#x2F;&#x2F;nosferalatu.com&#x2F;SimpleGPUHashTable.html" rel="nofollow">https:&#x2F;&#x2F;nosferalatu.com&#x2F;SimpleGPUHashTable.html</a>)<p>Atomic operations are limited to 32-bits.</div><br/></div></div></div></div><div id="40024542" class="c"><input type="checkbox" id="c-40024542" checked=""/><div class="controls bullet"><span class="by">cavisne</span><span>|</span><a href="#40023996">prev</a><span>|</span><a href="#40024026">next</a><span>|</span><label class="collapse" for="c-40024542">[-]</label><label class="expand" for="c-40024542">[2 more]</label></div><br/><div class="children"><div class="content">The Programming Massively Parallel Processors textbook has a chapter on histograms. You have basically mentioned the main trick though (privatization).<p>For this problem I think coursening would also help (so everything isn’t queued up on the copy to global memory)</div><br/><div id="40028524" class="c"><input type="checkbox" id="c-40028524" checked=""/><div class="controls bullet"><span class="by">tspeterkim</span><span>|</span><a href="#40024542">parent</a><span>|</span><a href="#40024026">next</a><span>|</span><label class="collapse" for="c-40028524">[-]</label><label class="expand" for="c-40028524">[1 more]</label></div><br/><div class="children"><div class="content">The PMPP book is great. I reread the histogram chapter after finishing the blog, and realized I could use privatization. You got me!<p>By coarsening, do you mean making the threads handle more file parts, and reducing the number of private copies (of histogram or stats here) to globally commit at the end?</div><br/></div></div></div></div><div id="40024026" class="c"><input type="checkbox" id="c-40024026" checked=""/><div class="controls bullet"><span class="by">bhouston</span><span>|</span><a href="#40024542">prev</a><span>|</span><label class="collapse" for="c-40024026">[-]</label><label class="expand" for="c-40024026">[2 more]</label></div><br/><div class="children"><div class="content">Interesting approach.<p>I wonder if one could use a reduce operation across the cities or similar rather than atomic operations?  GPUs are amazing at reduce operations.</div><br/><div id="40028408" class="c"><input type="checkbox" id="c-40028408" checked=""/><div class="controls bullet"><span class="by">tspeterkim</span><span>|</span><a href="#40024026">parent</a><span>|</span><label class="collapse" for="c-40028408">[-]</label><label class="expand" for="c-40028408">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. I tried reducing across cities first.<p>The problem was that the work of gathering all the temperatures for each city (before I could launch the reduction CUDA kernels) required a full parsing through the input data.<p>My final solution would be slower than the C++ baseline since the baseline already does the full parsing anyways.</div><br/></div></div></div></div></div></div></div></div></div></body></html>