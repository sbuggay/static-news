<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737277254133" as="style"/><link rel="stylesheet" href="styles.css?v=1737277254133"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.codingconfessions.com/p/how-unix-spell-ran-in-64kb-ram">How Unix spell ran in 64kb RAM</a> <span class="domain">(<a href="https://blog.codingconfessions.com">blog.codingconfessions.com</a>)</span></div><div class="subtext"><span>madmax108</span> | <span>29 comments</span></div><br/><div><div id="42753170" class="c"><input type="checkbox" id="c-42753170" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42755211">next</a><span>|</span><label class="collapse" for="c-42753170">[-]</label><label class="expand" for="c-42753170">[5 more]</label></div><br/><div class="children"><div class="content">You can write an external memory spell checker with a tiny amount of RAM:  something like<p><pre><code>   - sort the words in the document
   - eliminate unique words (they sort together)
   - merge the sorted words with the sorted dictionary and keep only the missing words
</code></pre>
I saw this in BASIC in <i>Creative Computing</i> and got it working in on my TRS-80 Color Computer which had much less than 32k of available RAM,  so that was the first thing I thought when I saw the headline.<p>Now this blew people away when it came out<p><a href="https:&#x2F;&#x2F;winworldpc.com&#x2F;product&#x2F;turbo-lightning&#x2F;1x" rel="nofollow">https:&#x2F;&#x2F;winworldpc.com&#x2F;product&#x2F;turbo-lightning&#x2F;1x</a><p>it had a compressed dictionary that would fit together with the other programs you were running on a PC and spell check <i>as you typed</i>;  there was a 640k limit for the PC but it could only use a fraction of that so as not to interfere and in the early days of the PC you couldn&#x27;t actually afford to fill it out.</div><br/><div id="42753823" class="c"><input type="checkbox" id="c-42753823" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#42753170">parent</a><span>|</span><a href="#42753334">next</a><span>|</span><label class="collapse" for="c-42753823">[-]</label><label class="expand" for="c-42753823">[2 more]</label></div><br/><div class="children"><div class="content">I guess you really used the fact that most words are repeated to keep the byte count in check?  On the old C=64 I had it was a bit of a problem not to blow out the memory with just the text of the document once you started using it for more than a 1 or 2 page paper.  Keeping a second sorted copy seems almost luxurious.<p>I guess you could save the working copy to disk first, then do the sort, then compare, then reload the working copy.  I think the C=64 developers probably avoided that strategy because the disk interface was so damn slow.</div><br/><div id="42754431" class="c"><input type="checkbox" id="c-42754431" checked=""/><div class="controls bullet"><span class="by">tczMUFlmoNk</span><span>|</span><a href="#42753170">root</a><span>|</span><a href="#42753823">parent</a><span>|</span><a href="#42753334">next</a><span>|</span><label class="collapse" for="c-42754431">[-]</label><label class="expand" for="c-42754431">[1 more]</label></div><br/><div class="children"><div class="content">I may be wrong, but from &quot;external memory&quot; in the description I think the idea is that each of those steps can be done on disk, not RAM. An external merge sort is a pretty standard database primitive, and the other two only require purely sequential access, so are friendly to spinning disks and the like.</div><br/></div></div></div></div><div id="42753334" class="c"><input type="checkbox" id="c-42753334" checked=""/><div class="controls bullet"><span class="by">bongodongobob</span><span>|</span><a href="#42753170">parent</a><span>|</span><a href="#42753823">prev</a><span>|</span><a href="#42755211">next</a><span>|</span><label class="collapse" for="c-42753334">[-]</label><label class="expand" for="c-42753334">[2 more]</label></div><br/><div class="children"><div class="content">Link seems to be broken.</div><br/><div id="42754084" class="c"><input type="checkbox" id="c-42754084" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#42753170">root</a><span>|</span><a href="#42753334">parent</a><span>|</span><a href="#42755211">next</a><span>|</span><label class="collapse" for="c-42754084">[-]</label><label class="expand" for="c-42754084">[1 more]</label></div><br/><div class="children"><div class="content">works4me</div><br/></div></div></div></div></div></div><div id="42755211" class="c"><input type="checkbox" id="c-42755211" checked=""/><div class="controls bullet"><span class="by">daantje</span><span>|</span><a href="#42753170">prev</a><span>|</span><a href="#42755160">next</a><span>|</span><label class="collapse" for="c-42755211">[-]</label><label class="expand" for="c-42755211">[1 more]</label></div><br/><div class="children"><div class="content">Reading about this and similar techniques in Programming Pearls (Second Edition) by Jon Bentley left the younger me spellbound. Similar to the evolution of linkers up to mold.</div><br/></div></div><div id="42755160" class="c"><input type="checkbox" id="c-42755160" checked=""/><div class="controls bullet"><span class="by">ronjakoi</span><span>|</span><a href="#42755211">prev</a><span>|</span><a href="#42753677">next</a><span>|</span><label class="collapse" for="c-42755160">[-]</label><label class="expand" for="c-42755160">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But 27-bit hash codes were too big: with 2^15 words, they needed 2^15 * 27 bits of memory, while the PDP-11 had only 2^15 * 16 bits (64kB) of RAM—compression was essential.<p>I&#x27;m frustrated when people put this kind of typography on the web. HTML can do superscript.</div><br/></div></div><div id="42753677" class="c"><input type="checkbox" id="c-42753677" checked=""/><div class="controls bullet"><span class="by">LeoPanthera</span><span>|</span><a href="#42755160">prev</a><span>|</span><a href="#42753420">next</a><span>|</span><label class="collapse" for="c-42753677">[-]</label><label class="expand" for="c-42753677">[3 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t remember the name of the product but in the 80s there was a <i>hardware</i> spell checker for the IBM PC. It was a box that connected between your keyboard and your PC, and if you ever typed a string of letters that it did not recognize as a dictionary word, it would beep to let you know.</div><br/><div id="42754554" class="c"><input type="checkbox" id="c-42754554" checked=""/><div class="controls bullet"><span class="by">jadamson</span><span>|</span><a href="#42753677">parent</a><span>|</span><a href="#42753420">next</a><span>|</span><label class="collapse" for="c-42754554">[-]</label><label class="expand" for="c-42754554">[2 more]</label></div><br/><div class="children"><div class="content">Xerox PC Type Right<p><a href="https:&#x2F;&#x2F;vintageapple.org&#x2F;pcworld&#x2F;pdf&#x2F;PC_World_8711_November_1987.pdf" rel="nofollow">https:&#x2F;&#x2F;vintageapple.org&#x2F;pcworld&#x2F;pdf&#x2F;PC_World_8711_November_...</a> page 237 has a review (big PDF warning)</div><br/><div id="42754956" class="c"><input type="checkbox" id="c-42754956" checked=""/><div class="controls bullet"><span class="by">eurleif</span><span>|</span><a href="#42753677">root</a><span>|</span><a href="#42754554">parent</a><span>|</span><a href="#42753420">next</a><span>|</span><label class="collapse" for="c-42754956">[-]</label><label class="expand" for="c-42754956">[1 more]</label></div><br/><div class="children"><div class="content">&gt;You can even set the device to recognize your password and beep if you mistype it, thereby eliminating a bevy of incorrect sign-on messages.<p>Wow, what a thing for a tech publication to suggest doing! Different times.</div><br/></div></div></div></div></div></div><div id="42753420" class="c"><input type="checkbox" id="c-42753420" checked=""/><div class="controls bullet"><span class="by">eichin</span><span>|</span><a href="#42753677">prev</a><span>|</span><a href="#42753073">next</a><span>|</span><label class="collapse" for="c-42753420">[-]</label><label class="expand" for="c-42753420">[2 more]</label></div><br/><div class="children"><div class="content">One of the things that got me intrigued by Unix was an early 1980s(ish) Byte article which walked through building a (trivial example, not the &quot;real&quot; one) spell checker out of a split&#x2F;sort&#x2F;comm pipeline, something like 7 commands? 8-bit PCs didn&#x27;t have anything like that, and yet it didn&#x27;t look like it needed <i>that</i> much sophistication...</div><br/><div id="42754014" class="c"><input type="checkbox" id="c-42754014" checked=""/><div class="controls bullet"><span class="by">MarkSweep</span><span>|</span><a href="#42753420">parent</a><span>|</span><a href="#42753073">next</a><span>|</span><label class="collapse" for="c-42754014">[-]</label><label class="expand" for="c-42754014">[1 more]</label></div><br/><div class="children"><div class="content">One a similar note, there is this period video where Brian Kernighan shows how to construct a spell checker using a UNIX shell one-liner:<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;tc4ROCJYbm0?t=4m56s" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;tc4ROCJYbm0?t=4m56s</a></div><br/></div></div></div></div><div id="42753073" class="c"><input type="checkbox" id="c-42753073" checked=""/><div class="controls bullet"><span class="by">Scaevolus</span><span>|</span><a href="#42753420">prev</a><span>|</span><a href="#42752983">next</a><span>|</span><label class="collapse" for="c-42753073">[-]</label><label class="expand" for="c-42753073">[1 more]</label></div><br/><div class="children"><div class="content">I wonder what common typos this misses thanks to the hashing?<p>Related, a contest about compressing the  Wordle dictionary: <a href="http:&#x2F;&#x2F;golf.horse&#x2F;wordle&#x2F;" rel="nofollow">http:&#x2F;&#x2F;golf.horse&#x2F;wordle&#x2F;</a></div><br/></div></div><div id="42752983" class="c"><input type="checkbox" id="c-42752983" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#42753073">prev</a><span>|</span><a href="#42753406">next</a><span>|</span><label class="collapse" for="c-42752983">[-]</label><label class="expand" for="c-42752983">[1 more]</label></div><br/><div class="children"><div class="content">Way too smart for worse is better. Think Worser!<p>The main memory bandwidth and the disk bandwidth were about the same, a little of 1MB&#x2F;s.<p>I would have done this in multiple passes (but still used the Bloom Filters, those are cool).<p><a href="https:&#x2F;&#x2F;github.com&#x2F;arnoldrobbins&#x2F;v10spell">https:&#x2F;&#x2F;github.com&#x2F;arnoldrobbins&#x2F;v10spell</a><p><a href="https:&#x2F;&#x2F;code.google.com&#x2F;archive&#x2F;p&#x2F;unix-spell&#x2F;" rel="nofollow">https:&#x2F;&#x2F;code.google.com&#x2F;archive&#x2F;p&#x2F;unix-spell&#x2F;</a><p>The original paper is great <a href="https:&#x2F;&#x2F;www.semanticscholar.org&#x2F;paper&#x2F;Development-of-a-Spelling-List-McIlroy&#x2F;e08c8a4c17f23c41616649ca73a908d06828d67f" rel="nofollow">https:&#x2F;&#x2F;www.semanticscholar.org&#x2F;paper&#x2F;Development-of-a-Spell...</a><p>It is hosted on his web page <a href="https:&#x2F;&#x2F;www.cs.dartmouth.edu&#x2F;~doug&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cs.dartmouth.edu&#x2F;~doug&#x2F;</a><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Douglas_McIlroy" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Douglas_McIlroy</a><p>If you are a word nerd, you will have found obovate and there, this chart.<p><a href="https:&#x2F;&#x2F;upload.wikimedia.org&#x2F;wikipedia&#x2F;commons&#x2F;e&#x2F;e8&#x2F;Leaf_morphology.svg" rel="nofollow">https:&#x2F;&#x2F;upload.wikimedia.org&#x2F;wikipedia&#x2F;commons&#x2F;e&#x2F;e8&#x2F;Leaf_mor...</a></div><br/></div></div><div id="42753406" class="c"><input type="checkbox" id="c-42753406" checked=""/><div class="controls bullet"><span class="by">eichin</span><span>|</span><a href="#42752983">prev</a><span>|</span><a href="#42753022">next</a><span>|</span><label class="collapse" for="c-42753406">[-]</label><label class="expand" for="c-42753406">[2 more]</label></div><br/><div class="children"><div class="content">For perspective, in 1983 or so, Grammatik on CP&#x2F;M ran in under 64k and did &quot;grammar checking&quot; (spell checking, plus a bunch of expert system rules) on an 8-bit system.  (It sticks in my memory because of the time spent poking at the <i>really</i> interesting part: that it was so compact because it was in Forth, and there was enough of an outer interpreter in the product that with a little hex editing you could just use it as a Forth interpreter - with a <i>very</i> specialized set of functions preloaded :-)</div><br/><div id="42755164" class="c"><input type="checkbox" id="c-42755164" checked=""/><div class="controls bullet"><span class="by">stevekemp</span><span>|</span><a href="#42753406">parent</a><span>|</span><a href="#42753022">next</a><span>|</span><label class="collapse" for="c-42755164">[-]</label><label class="expand" for="c-42755164">[1 more]</label></div><br/><div class="children"><div class="content">The Wordstar editor I run on my own CP&#x2F;M system, with 64k of RAM, contains the 2023-byte long &quot;SPELL.COM&quot; spell-checker.<p>I&#x27;ve not decompiled it to see how it works, but it&#x27;s small and fast, and works well.</div><br/></div></div></div></div><div id="42753022" class="c"><input type="checkbox" id="c-42753022" checked=""/><div class="controls bullet"><span class="by">WaitWaitWha</span><span>|</span><a href="#42753406">prev</a><span>|</span><a href="#42753153">next</a><span>|</span><label class="collapse" for="c-42753022">[-]</label><label class="expand" for="c-42753022">[1 more]</label></div><br/><div class="children"><div class="content">in the mid 80&#x27;s  i ran into something similar.  Fast is relative.<p>I had a lot of data, 640KB RAM, 64KB of heap, and 64KB of stack.  I had hundreds of megabytes that I had to search extract data from and then combine some of them.<p>I experimented with data index structured into ternary trees.  Conceptually it made sense, but implementation-wise the relationships and paths were still too big to keep in 64KB.<p>Instead of compression, I did swapping.  I wrote a TSR (think service), a piece of code that would process a chunk of the data, extract the results, store it n the stack, dump the original data, make an interrupt call to the TSR, which in turn destroy the heap, and read in the next chunk from storage, return control to the program, process, combine with stack data, and continue until finished the entire process.<p>Originally this process took about a week for three data entry persons (think about a dozen 3&quot; ring binders filled with tables), and an specialist combining the information.  The program completed the work in just a few hours.  It was amazingly &quot;fast&quot;.<p>This was on a single threaded system.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Terminate-and-stay-resident_program" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Terminate-and-stay-resident_pr...</a></div><br/></div></div><div id="42753153" class="c"><input type="checkbox" id="c-42753153" checked=""/><div class="controls bullet"><span class="by">msephton</span><span>|</span><a href="#42753022">prev</a><span>|</span><a href="#42752833">next</a><span>|</span><label class="collapse" for="c-42753153">[-]</label><label class="expand" for="c-42753153">[3 more]</label></div><br/><div class="children"><div class="content">How about 39kB for a video game with physics, dynamic graphics, two music tracks, sound effects, online high scores, and built-in instructions? <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38372936">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38372936</a></div><br/><div id="42753410" class="c"><input type="checkbox" id="c-42753410" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#42753153">parent</a><span>|</span><a href="#42753306">next</a><span>|</span><label class="collapse" for="c-42753410">[-]</label><label class="expand" for="c-42753410">[1 more]</label></div><br/><div class="children"><div class="content">Sizecoding is a thing. .kkrieger is a rather famous 96kB FPS game. There is even an entire demoparty called Lovebyte that is dedicated to it, the biggest category is 1k, but all demoscene events I can think of have a sizecoding competition of some kind.<p>And it is a completely different thing. In general, it is more about procedural generation and tricks then good packing. Runtime packers are used, like crinkler and kkrunchy, but actually they use a <i>lot</i> of RAM, like hundreds of MB, which is a bit surprising considering that the decompressed executable is in the tens of kB. But that&#x27;s because they use very powerful but slow compression algorithms.<p>Sizecoding usually doesn&#x27;t care about RAM, unless the platform requires it, the only think that matters is the size of the executable file and its data. For that 39kB Playdate game, I guess that&#x27;s the same idea. The Playdate has 16MB of RAM, I bet the game took full advantage of it.</div><br/></div></div><div id="42753306" class="c"><input type="checkbox" id="c-42753306" checked=""/><div class="controls bullet"><span class="by">fallat</span><span>|</span><a href="#42753153">parent</a><span>|</span><a href="#42753410">prev</a><span>|</span><a href="#42752833">next</a><span>|</span><label class="collapse" for="c-42753306">[-]</label><label class="expand" for="c-42753306">[1 more]</label></div><br/><div class="children"><div class="content">Not the same when the machines in question are not on the same level...</div><br/></div></div></div></div><div id="42752833" class="c"><input type="checkbox" id="c-42752833" checked=""/><div class="controls bullet"><span class="by">Koshkin</span><span>|</span><a href="#42753153">prev</a><span>|</span><a href="#42753064">next</a><span>|</span><label class="collapse" for="c-42752833">[-]</label><label class="expand" for="c-42752833">[1 more]</label></div><br/><div class="children"><div class="content">64kB was huge. The first version of UNIX needed 24kB (half of which was taken by the kernel).</div><br/></div></div><div id="42753064" class="c"><input type="checkbox" id="c-42753064" checked=""/><div class="controls bullet"><span class="by">vandyswa</span><span>|</span><a href="#42752833">prev</a><span>|</span><a href="#42752835">next</a><span>|</span><label class="collapse" for="c-42753064">[-]</label><label class="expand" for="c-42753064">[1 more]</label></div><br/><div class="children"><div class="content">This spell check must have come later.  The original spell check burst the words of the document, and sort -u&#x27;d them:<p>makewords sentence | lowercase | sort | unique | mismatch</div><br/></div></div><div id="42752835" class="c"><input type="checkbox" id="c-42752835" checked=""/><div class="controls bullet"><span class="by">MarkusWandel</span><span>|</span><a href="#42753064">prev</a><span>|</span><a href="#42753035">next</a><span>|</span><label class="collapse" for="c-42752835">[-]</label><label class="expand" for="c-42752835">[3 more]</label></div><br/><div class="children"><div class="content">Marginally related... has anyone ever ported the &quot;typo&quot; program to modern C?</div><br/><div id="42752971" class="c"><input type="checkbox" id="c-42752971" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#42752835">parent</a><span>|</span><a href="#42753035">next</a><span>|</span><label class="collapse" for="c-42752971">[-]</label><label class="expand" for="c-42752971">[2 more]</label></div><br/><div class="children"><div class="content">For reference, <a href="https:&#x2F;&#x2F;github.com&#x2F;robpike&#x2F;typo&#x2F;blob&#x2F;master&#x2F;unix&#x2F;typo.c">https:&#x2F;&#x2F;github.com&#x2F;robpike&#x2F;typo&#x2F;blob&#x2F;master&#x2F;unix&#x2F;typo.c</a></div><br/><div id="42753530" class="c"><input type="checkbox" id="c-42753530" checked=""/><div class="controls bullet"><span class="by">MikeTheGreat</span><span>|</span><a href="#42752835">root</a><span>|</span><a href="#42752971">parent</a><span>|</span><a href="#42753035">next</a><span>|</span><label class="collapse" for="c-42753530">[-]</label><label class="expand" for="c-42753530">[1 more]</label></div><br/><div class="children"><div class="content">Also for reference, for those who aren&#x27;t familiar with typo and don&#x27;t want to read the C source code listed above (side-comment: citing the comment-free source code &#x27;for reference&#x27; is hilarious.  Thank you for the laugh :) )<p><a href="https:&#x2F;&#x2F;github.com&#x2F;robpike&#x2F;typo&#x2F;blob&#x2F;master&#x2F;typo.png">https:&#x2F;&#x2F;github.com&#x2F;robpike&#x2F;typo&#x2F;blob&#x2F;master&#x2F;typo.png</a></div><br/></div></div></div></div></div></div><div id="42753035" class="c"><input type="checkbox" id="c-42753035" checked=""/><div class="controls bullet"><span class="by">fortran77</span><span>|</span><a href="#42752835">prev</a><span>|</span><a href="#42753248">next</a><span>|</span><label class="collapse" for="c-42753035">[-]</label><label class="expand" for="c-42753035">[2 more]</label></div><br/><div class="children"><div class="content">I had spelling checkers on the Apple ][ that ran in 48K!</div><br/><div id="42753293" class="c"><input type="checkbox" id="c-42753293" checked=""/><div class="controls bullet"><span class="by">jhbadger</span><span>|</span><a href="#42753035">parent</a><span>|</span><a href="#42753248">next</a><span>|</span><label class="collapse" for="c-42753293">[-]</label><label class="expand" for="c-42753293">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. 64K only seems tiny to people who didn&#x27;t use home computers in the 1980s.</div><br/></div></div></div></div><div id="42753248" class="c"><input type="checkbox" id="c-42753248" checked=""/><div class="controls bullet"><span class="by">paulg2222</span><span>|</span><a href="#42753035">prev</a><span>|</span><label class="collapse" for="c-42753248">[-]</label><label class="expand" for="c-42753248">[1 more]</label></div><br/><div class="children"><div class="content">Cool. Now move forward.</div><br/></div></div></div></div></div></div></div></body></html>