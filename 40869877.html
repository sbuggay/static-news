<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720170065432" as="style"/><link rel="stylesheet" href="styles.css?v=1720170065432"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://0x.tools/">Show HN: Xcapture-BPF – like Linux top, but with Xray vision</a> <span class="domain">(<a href="https://0x.tools">0x.tools</a>)</span></div><div class="subtext"><span>tanelpoder</span> | <span>41 comments</span></div><br/><div><div id="40871028" class="c"><input type="checkbox" id="c-40871028" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#40871581">next</a><span>|</span><label class="collapse" for="c-40871028">[-]</label><label class="expand" for="c-40871028">[8 more]</label></div><br/><div class="children"><div class="content">I use BCC tools weekly to debug production issues. Recently I found we were massively pressuring page caches due to having a large number of loopback devices with their own page cache. Enabling direct io on the loopback devices fixed the issue.<p>eBPF is really a superpower, it lets you do things which are incomprehensible if you don’t know about it.</div><br/><div id="40871623" class="c"><input type="checkbox" id="c-40871623" checked=""/><div class="controls bullet"><span class="by">jyxent</span><span>|</span><a href="#40871028">parent</a><span>|</span><a href="#40871264">next</a><span>|</span><label class="collapse" for="c-40871623">[-]</label><label class="expand" for="c-40871623">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been learning BCC &#x2F; bpftrace recently to debug a memory leak issue on a customer&#x27;s system, and it has been super useful.</div><br/></div></div><div id="40871264" class="c"><input type="checkbox" id="c-40871264" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40871028">parent</a><span>|</span><a href="#40871623">prev</a><span>|</span><a href="#40871581">next</a><span>|</span><label class="collapse" for="c-40871264">[-]</label><label class="expand" for="c-40871264">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love to hear more of this debugging story!</div><br/><div id="40871962" class="c"><input type="checkbox" id="c-40871962" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#40871028">root</a><span>|</span><a href="#40871264">parent</a><span>|</span><a href="#40871581">next</a><span>|</span><label class="collapse" for="c-40871962">[-]</label><label class="expand" for="c-40871962">[5 more]</label></div><br/><div class="children"><div class="content">Containers are offered block storage by creating a loopback device with a backing file on the kubelet’s file system. We noticed that on some very heavily utilized nodes that iowait was using 60% of all the available cores on the node.<p>I first confirmed that nvme drives were healthy according to SMART, I then worked up the stack and used BCC tools to look at block io latency. Block io latency was quite low for the NVME drives (microseconds) but was hundreds of milliseconds for the loopback block devices.<p>This lead me to believe that something was wrong with the loopback devices and not the underlying NVMEs. I used cachestat&#x2F;cachetop and found that the page cache miss rate was very high and that we were thrashing the page cache constantly paging in and out data. From there I inspected the loopback devices using losetup and found that direct io was disabled and the sector size of the loopback device did not match the sector size of the backing filesystem.<p>I modified the loopback devices to use the same sector size as the block size of the underlying file system and enabled direct io. Instantly, the majority of the page cache was freed, iowait went way down, and io throughout went way up.<p>Without BCC tools I would have never been able to figure this out.<p>Double caching loopback devices is quite the footgun.<p>Another interesting thing we hit is that our version of losetup would happily fail to enable direct io but still give you a loopback device, this has since been fixed: <a href="https:&#x2F;&#x2F;github.com&#x2F;util-linux&#x2F;util-linux&#x2F;commit&#x2F;d53346ed082db8717df7a76d2df9fd657d3e23e9">https:&#x2F;&#x2F;github.com&#x2F;util-linux&#x2F;util-linux&#x2F;commit&#x2F;d53346ed082d...</a></div><br/><div id="40872403" class="c"><input type="checkbox" id="c-40872403" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#40871028">root</a><span>|</span><a href="#40871962">parent</a><span>|</span><a href="#40876588">next</a><span>|</span><label class="collapse" for="c-40872403">[-]</label><label class="expand" for="c-40872403">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also either Composefs or Puzzlefs, both of which attempt to let the page cache work across containers!<p><a href="https:&#x2F;&#x2F;github.com&#x2F;containers&#x2F;composefs">https:&#x2F;&#x2F;github.com&#x2F;containers&#x2F;composefs</a> <a href="https:&#x2F;&#x2F;github.com&#x2F;project-machine&#x2F;puzzlefs">https:&#x2F;&#x2F;github.com&#x2F;project-machine&#x2F;puzzlefs</a></div><br/></div></div><div id="40876588" class="c"><input type="checkbox" id="c-40876588" checked=""/><div class="controls bullet"><span class="by">M_bara</span><span>|</span><a href="#40871028">root</a><span>|</span><a href="#40871962">parent</a><span>|</span><a href="#40872403">prev</a><span>|</span><a href="#40873775">next</a><span>|</span><label class="collapse" for="c-40876588">[-]</label><label class="expand" for="c-40876588">[1 more]</label></div><br/><div class="children"><div class="content">We had something similar about 10 years ago where I worked. Customer instances were backed via loopback devices to local disks. We didn’t think of this - face palm - on the loop back devices. What we ended up doing was writing a small daemon to posix fadvise the kernel to skip the page cache… your solution is way simpler and more elegant… hats off to you</div><br/></div></div><div id="40873775" class="c"><input type="checkbox" id="c-40873775" checked=""/><div class="controls bullet"><span class="by">FooBarWidget</span><span>|</span><a href="#40871028">root</a><span>|</span><a href="#40871962">parent</a><span>|</span><a href="#40876588">prev</a><span>|</span><a href="#40871581">next</a><span>|</span><label class="collapse" for="c-40873775">[-]</label><label class="expand" for="c-40873775">[2 more]</label></div><br/><div class="children"><div class="content">Which container runtime are you using? As far as I know both Docker and containerd use overlay filesystems instead of loopback devices.<p>And how did you know that tweaking the sector size to equal the underlying filesystem&#x27;s block size would prevent double caching? Where can one get this sort of knowledge?</div><br/><div id="40875426" class="c"><input type="checkbox" id="c-40875426" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#40871028">root</a><span>|</span><a href="#40873775">parent</a><span>|</span><a href="#40871581">next</a><span>|</span><label class="collapse" for="c-40875426">[-]</label><label class="expand" for="c-40875426">[1 more]</label></div><br/><div class="children"><div class="content">The loopback devices came from a CSI which creates a backing file on the kubelet’s filesystem and mounts it into the container as a block device. We use containerd.<p>I knew that enabling direct io would most likely disable double caching because that is literally the point of enabling direct io on a loopback device. Initially I just tried enabling direct io on the loopback devices, but that failed with a cryptic “invalid argument” error. After some more research I found that direct IO needs the sector size to match the filesystems block size in some cases to work.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40871581" class="c"><input type="checkbox" id="c-40871581" checked=""/><div class="controls bullet"><span class="by">metroholografix</span><span>|</span><a href="#40871028">prev</a><span>|</span><a href="#40871177">next</a><span>|</span><label class="collapse" for="c-40871581">[-]</label><label class="expand" for="c-40871581">[5 more]</label></div><br/><div class="children"><div class="content">Folks who find this useful might also be interested in otel-profiling-agent [1] which Elastic recently opensourced and donated to OpenTelemetry. It&#x27;s a low-overhead eBPF-based continuous profiler which, besides native code, can unwind stacks from other widely used runtimes (Hotspot, V8, Python, .NET, Ruby, Perl, PHP).<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;elastic&#x2F;otel-profiling-agent">https:&#x2F;&#x2F;github.com&#x2F;elastic&#x2F;otel-profiling-agent</a></div><br/><div id="40873018" class="c"><input type="checkbox" id="c-40873018" checked=""/><div class="controls bullet"><span class="by">kbouck</span><span>|</span><a href="#40871581">parent</a><span>|</span><a href="#40872822">next</a><span>|</span><label class="collapse" for="c-40873018">[-]</label><label class="expand" for="c-40873018">[1 more]</label></div><br/><div class="children"><div class="content">Grafana has one too called Beyla.<p><a href="https:&#x2F;&#x2F;grafana.com&#x2F;oss&#x2F;beyla-ebpf&#x2F;" rel="nofollow">https:&#x2F;&#x2F;grafana.com&#x2F;oss&#x2F;beyla-ebpf&#x2F;</a></div><br/></div></div><div id="40872822" class="c"><input type="checkbox" id="c-40872822" checked=""/><div class="controls bullet"><span class="by">3abiton</span><span>|</span><a href="#40871581">parent</a><span>|</span><a href="#40873018">prev</a><span>|</span><a href="#40871607">next</a><span>|</span><label class="collapse" for="c-40872822">[-]</label><label class="expand" for="c-40872822">[2 more]</label></div><br/><div class="children"><div class="content">I am trying to wrap my head around it, still unclear what it does l.</div><br/><div id="40876831" class="c"><input type="checkbox" id="c-40876831" checked=""/><div class="controls bullet"><span class="by">zikohh</span><span>|</span><a href="#40871581">root</a><span>|</span><a href="#40872822">parent</a><span>|</span><a href="#40871607">next</a><span>|</span><label class="collapse" for="c-40876831">[-]</label><label class="expand" for="c-40876831">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s like most of Grafana&#x27;s documentation</div><br/></div></div></div></div></div></div><div id="40871177" class="c"><input type="checkbox" id="c-40871177" checked=""/><div class="controls bullet"><span class="by">malkia</span><span>|</span><a href="#40871581">prev</a><span>|</span><a href="#40870300">next</a><span>|</span><label class="collapse" for="c-40871177">[-]</label><label class="expand" for="c-40871177">[3 more]</label></div><br/><div class="children"><div class="content">Relatively how expensive is to capture the callstack when doing sample profiling?<p>With Intel CET&#x27;s tech there should be way to capture a shadow stack, that really just contains entry points, but wondering if that&#x27;s going to be used...</div><br/><div id="40871271" class="c"><input type="checkbox" id="c-40871271" checked=""/><div class="controls bullet"><span class="by">tanelpoder</span><span>|</span><a href="#40871177">parent</a><span>|</span><a href="#40870300">next</a><span>|</span><label class="collapse" for="c-40871271">[-]</label><label class="expand" for="c-40871271">[2 more]</label></div><br/><div class="children"><div class="content">The on-cpu sample profiling is not a big deal for my use cases as I don&#x27;t need the &quot;perf&quot; sampling to happen at 10kHz or anything (more like 10-1Hz, but always on).<p>But the sched_switch tracepoint is the hottest event, without stack sampling it&#x27;s 200-500ns per event (on my Xeon 63xx CPUs), depending on what data is collected. I use #ifdefs to compile in only the fields that are actually used (smaller thread_state struct, fewer branches and instructions to decode &amp; cache). Surprisingly when I collect kernel stack, the overhead jumps higher up compared to user stack (kstack goes from say 400ns to 3200ns, while ustack jumps to 2800ns per event or so).<p>I have done almost zero optimizations (and I figure using libbpf&#x2F;BTF&#x2F;CO-RE will help too). But I&#x27;m ok with these numbers for most of <i>my</i> workloads of interest, and since eBPF programs are not cast in stone, can do further reductions, like actually sampling stacks in the sched_switch probe on every 10th occurrence or something.<p>So in worst case, this full-visibility approach might not be usable as always-on instrumentation for <i>some</i> workloads (like some redis&#x2F;memcached&#x2F;mysql lookups doing 10M context switches&#x2F;s on a big server), but even with such workloads, a temporary increase in instrumentation overhead might be ok, when there are known recurring problems to troubleshoot.</div><br/><div id="40877106" class="c"><input type="checkbox" id="c-40877106" checked=""/><div class="controls bullet"><span class="by">malkia</span><span>|</span><a href="#40871177">root</a><span>|</span><a href="#40871271">parent</a><span>|</span><a href="#40870300">next</a><span>|</span><label class="collapse" for="c-40877106">[-]</label><label class="expand" for="c-40877106">[1 more]</label></div><br/><div class="children"><div class="content">Awesome info!!! Thanks a lot!</div><br/></div></div></div></div></div></div><div id="40870273" class="c"><input type="checkbox" id="c-40870273" checked=""/><div class="controls bullet"><span class="by">jamesy0ung</span><span>|</span><a href="#40870300">prev</a><span>|</span><label class="collapse" for="c-40870273">[-]</label><label class="expand" for="c-40870273">[23 more]</label></div><br/><div class="children"><div class="content">I’ve never used eBPF, does anyone have some good resources for learning it?</div><br/><div id="40870305" class="c"><input type="checkbox" id="c-40870305" checked=""/><div class="controls bullet"><span class="by">tanelpoder</span><span>|</span><a href="#40870273">parent</a><span>|</span><a href="#40870353">next</a><span>|</span><label class="collapse" for="c-40870305">[-]</label><label class="expand" for="c-40870305">[9 more]</label></div><br/><div class="children"><div class="content">Brendan Gregg&#x27;s site (and book) is probably the best starting point (he was involved in DTrace work &amp; rollout 20 years ago when at Sun) and was&#x2F;is instrumental in pushing eBPF in Linux even further than DTrace ever went:<p><a href="https:&#x2F;&#x2F;brendangregg.com&#x2F;ebpf.html" rel="nofollow">https:&#x2F;&#x2F;brendangregg.com&#x2F;ebpf.html</a></div><br/><div id="40871300" class="c"><input type="checkbox" id="c-40871300" checked=""/><div class="controls bullet"><span class="by">bcantrill</span><span>|</span><a href="#40870273">root</a><span>|</span><a href="#40870305">parent</a><span>|</span><a href="#40870353">next</a><span>|</span><label class="collapse" for="c-40871300">[-]</label><label class="expand" for="c-40871300">[8 more]</label></div><br/><div class="children"><div class="content">Just a quick clarification: while Brendan was certainly an active DTrace user and evangelist, he wasn&#x27;t involved in the development of DTrace itself -- or its rollout. (Brendan came to Sun in 2006; DTrace was released in 2003.)  As for eBPF with respect to DTrace, I would say that they are different systems with different goals and approaches rather than one eclipsing the other.  (There are certainly many things that DTrace can do that eBPF&#x2F;BCC cannot, some of the details of which we elaborated on in our 20th anniversary of DTrace&#x27;s initial integration.[0])<p>Edit: We actually went into much more specific detail on eBPF&#x2F;BCC in contrast to DTrace a few weeks after the 20th anniversary podcast.[1]<p>[0] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=IeUFzBBRilM" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=IeUFzBBRilM</a><p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=mqvVmYhclAg#t=12m7s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=mqvVmYhclAg#t=12m7s</a></div><br/><div id="40871365" class="c"><input type="checkbox" id="c-40871365" checked=""/><div class="controls bullet"><span class="by">tanelpoder</span><span>|</span><a href="#40870273">root</a><span>|</span><a href="#40871300">parent</a><span>|</span><a href="#40871376">next</a><span>|</span><label class="collapse" for="c-40871365">[-]</label><label class="expand" for="c-40871365">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, yes I was more or less aware of that (I&#x27;d been using DTrace since Solaris 10 beta in 2004 or 2003?)... By rollout I really meant &quot;getting the word out there&quot;... that&#x27;s half the battle in my experience (that&#x27;s why this post here! :-)<p>What I loved about DTrace was that once it was out, even in beta, it was pretty complete and worked - all the DTrace ports that I&#x27;ve tried, including on Windows (!) a few years ago were very limited or had some showstopper issues. I guess eBPF was like that too some years ago, but by now it&#x27;s pretty sweet even for more regular consumer who don&#x27;t keep track of its development.<p>Edit: Oh, wasn&#x27;t aware of the timeline, I may have some dates (years) wrong in my memory</div><br/></div></div><div id="40871376" class="c"><input type="checkbox" id="c-40871376" checked=""/><div class="controls bullet"><span class="by">abrookewood</span><span>|</span><a href="#40870273">root</a><span>|</span><a href="#40871300">parent</a><span>|</span><a href="#40871365">prev</a><span>|</span><a href="#40872532">next</a><span>|</span><label class="collapse" for="c-40871376">[-]</label><label class="expand" for="c-40871376">[1 more]</label></div><br/><div class="children"><div class="content">Yes, not involved in DTrace itself, but he did write a bunch of DTrace Tools which led to an interesting meeting with a Sun exec: <a href="https:&#x2F;&#x2F;www.brendangregg.com&#x2F;blog&#x2F;2021-06-04&#x2F;an-unbelievable-demo.html" rel="nofollow">https:&#x2F;&#x2F;www.brendangregg.com&#x2F;blog&#x2F;2021-06-04&#x2F;an-unbelievable...</a></div><br/></div></div><div id="40872532" class="c"><input type="checkbox" id="c-40872532" checked=""/><div class="controls bullet"><span class="by">anonfordays</span><span>|</span><a href="#40870273">root</a><span>|</span><a href="#40871300">parent</a><span>|</span><a href="#40871376">prev</a><span>|</span><a href="#40870353">next</a><span>|</span><label class="collapse" for="c-40872532">[-]</label><label class="expand" for="c-40872532">[5 more]</label></div><br/><div class="children"><div class="content">&gt;As for eBPF with respect to DTrace, I would say that they are different systems with different goals and approaches<p>For sure. Different systems, different times.<p>&gt;rather than one eclipsing the other.<p>It does seem that DTrace has been eclipsed though, at least in Linux (which runs the vast majority of the world&#x27;s compute). Is there a reason to use DTrace over eBPF for tracing and observability in Linux?<p>&gt;There are certainly many things that DTrace can do that eBPF&#x2F;BCC cannot<p>This may be true, but that gap is closing. There are certainly many things that eBPF can do that DTrace cannot, like Cilium.</div><br/><div id="40872559" class="c"><input type="checkbox" id="c-40872559" checked=""/><div class="controls bullet"><span class="by">tanelpoder</span><span>|</span><a href="#40870273">root</a><span>|</span><a href="#40872532">parent</a><span>|</span><a href="#40870353">next</a><span>|</span><label class="collapse" for="c-40872559">[-]</label><label class="expand" for="c-40872559">[4 more]</label></div><br/><div class="children"><div class="content">Perhaps familiarity with the syntax of DTrace if coming from Solaris-heavy enterprise background. But then again, too many years have passed since Solaris was a major mainstream platform. Oracle ships and supports DTrace on (Oracle) Linux by the way, but DTrace 2.0 on Linux is a scripting frontend that gets compiled to eBPF under the hood.<p>Back when I tried to build xcapture with DTrace, I could launch the script and use something like &#x2F;pid$oracle::func:entry&#x2F; but IIRC the probe was attached only to the processes that already existed and not any new ones that were started after loading the DTrace probes. Maybe I should have used some lower level APIs or something - but eBPF on Linux automatically handles both existing and new processes.</div><br/><div id="40876034" class="c"><input type="checkbox" id="c-40876034" checked=""/><div class="controls bullet"><span class="by">bch</span><span>|</span><a href="#40870273">root</a><span>|</span><a href="#40872559">parent</a><span>|</span><a href="#40870353">next</a><span>|</span><label class="collapse" for="c-40876034">[-]</label><label class="expand" for="c-40876034">[3 more]</label></div><br/><div class="children"><div class="content">&gt; eBPF on Linux automatically handles both existing and new processes<p>Without knowing your particular case, DTrace does too - it’d certainly be tricky to use if you’re trying to debug software that “instantly crashes on startup” if it couldn’t do that. “execname” (not “pid”) is where I’d look, or perhaps that part of the predicate is skipable; regardless, should be possible.</div><br/><div id="40877590" class="c"><input type="checkbox" id="c-40877590" checked=""/><div class="controls bullet"><span class="by">tanelpoder</span><span>|</span><a href="#40870273">root</a><span>|</span><a href="#40876034">parent</a><span>|</span><a href="#40870353">next</a><span>|</span><label class="collapse" for="c-40877590">[-]</label><label class="expand" for="c-40877590">[2 more]</label></div><br/><div class="children"><div class="content">For example I used something like &quot;pid:module:funcname:entry&quot; probe for userspace things (not pid$123 or pid$target, just pid to catch all PIDs using the module&#x2F;funcname of interest). And back when I tested, it didn&#x27;t automatically catch any new PIDs so these probes were not fired for them unless I restarted my DTrace script (but it was probably year &lt;2010 when I last tested it).<p>Execname is a variable in DTrace and not a probe (?), so how would it help with automatically attaching to new PIDs? Now that I recall more details, there was no issue with statically defined kernel &quot;fbt&quot; probes nor &quot;profile&quot;, but the userspace pid one was where I hit this limitation.</div><br/><div id="40878028" class="c"><input type="checkbox" id="c-40878028" checked=""/><div class="controls bullet"><span class="by">bch</span><span>|</span><a href="#40870273">root</a><span>|</span><a href="#40877590">parent</a><span>|</span><a href="#40870353">next</a><span>|</span><label class="collapse" for="c-40878028">[-]</label><label class="expand" for="c-40878028">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Execname is a variable in DTrace and not a probe (?), so how would it help with automatically attaching to new PIDs?<p>You&#x27;re correct, and I may have provided &quot;a solution&quot; to a misunderstanding of your problem - I don&#x27;t think the &quot;not matching new procs&#x2F;pids&quot; is inherent in DTrace, so indeed you might have run into an implementation issue (as it was 15 years ago). I misunderstood you as perhaps using a predicate matching a specific pid; my fault.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40870353" class="c"><input type="checkbox" id="c-40870353" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40870273">parent</a><span>|</span><a href="#40870305">prev</a><span>|</span><a href="#40871565">next</a><span>|</span><label class="collapse" for="c-40870353">[-]</label><label class="expand" for="c-40870353">[9 more]</label></div><br/><div class="children"><div class="content">It lets you hook into various points in the kernel; ultimately you need to learn how the Linux kernel is structured to make the most of it.<p>Unlike a module, it can only really read data, not modify data structures, so it&#x27;s nice for things like tracing kernel events.<p>The XDP subsystem is particularly designed for you to apply filters to network data before it makes it to the network stack, but it still doesn&#x27;t give you the same level of control or performance as DPDK, since you still need the data to go to the kernel.</div><br/><div id="40870391" class="c"><input type="checkbox" id="c-40870391" checked=""/><div class="controls bullet"><span class="by">tanelpoder</span><span>|</span><a href="#40870273">root</a><span>|</span><a href="#40870353">parent</a><span>|</span><a href="#40871135">next</a><span>|</span><label class="collapse" for="c-40870391">[-]</label><label class="expand" for="c-40870391">[5 more]</label></div><br/><div class="children"><div class="content">Yep (the 0x.tools author here). If you look into my code, you&#x27;ll see that I&#x27;m <i>not</i> a good developer :-) But I have a decent understanding of Linux kernel flow and kernel&#x2F;app interaction dynamics, thanks to many years of troubleshooting large (Oracle) database workloads. So I knew exactly what I wanted to measure and how, just had to learn the eBPF parts. That&#x27;s why I picked BCC instead of libbpf as I was somewhat familiar with it already, but fully dynamic and &quot;self-updating&quot; libbpf loading approach is the goal for v3 (help appreciated!)</div><br/><div id="40871261" class="c"><input type="checkbox" id="c-40871261" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40870273">root</a><span>|</span><a href="#40870391">parent</a><span>|</span><a href="#40870478">next</a><span>|</span><label class="collapse" for="c-40871261">[-]</label><label class="expand" for="c-40871261">[2 more]</label></div><br/><div class="children"><div class="content">I was going to ask &quot;why BCC&quot; (BCC is super clunky) but you&#x27;re way ahead of us. This is great work, thanks for posting it.</div><br/><div id="40871331" class="c"><input type="checkbox" id="c-40871331" checked=""/><div class="controls bullet"><span class="by">tanelpoder</span><span>|</span><a href="#40870273">root</a><span>|</span><a href="#40871261">parent</a><span>|</span><a href="#40870478">next</a><span>|</span><label class="collapse" for="c-40871331">[-]</label><label class="expand" for="c-40871331">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I already see limitations, the last one was yesterday when I installed earlier Ubuntu versions to see how far back this can go - and even Ubuntu 22.04 didn&#x27;t work out of the box, ended up with some BCC&#x2F;kernel header mismatch issue [1] although the kernel itself supported it. A workaround was to download &amp; compile the latest BCC yourself, but I don&#x27;t want to go there as the customers&#x2F;systems I work on wouldn&#x27;t go there anyway.<p>But libbpf with CO-RE will solve these issues as I understand, so as long as the <i>kernel</i> supports what you need, the CO-RE binary will work.<p>This raises another issue for me though, it&#x27;s not easy, but <i>easier</i>, for enterprises to download and run a single python + single C source file (with &lt;500 code lines to review) than a compiled CO-RE binary, but my long term plan&#x2F;hope is that I (we) get the RedHats and AWSes of this world to just provide the eventual mature release as a standard package.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;iovisor&#x2F;bcc&#x2F;issues&#x2F;3993">https:&#x2F;&#x2F;github.com&#x2F;iovisor&#x2F;bcc&#x2F;issues&#x2F;3993</a></div><br/></div></div></div></div><div id="40870478" class="c"><input type="checkbox" id="c-40870478" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40870273">root</a><span>|</span><a href="#40870391">parent</a><span>|</span><a href="#40871261">prev</a><span>|</span><a href="#40871135">next</a><span>|</span><label class="collapse" for="c-40870478">[-]</label><label class="expand" for="c-40870478">[2 more]</label></div><br/><div class="children"><div class="content">Myself I&#x27;ve only built simple things, like tracing sched switch events for certain threads, and killing the process if they happen (specifically designed as a safety for pinned threads).</div><br/><div id="40870552" class="c"><input type="checkbox" id="c-40870552" checked=""/><div class="controls bullet"><span class="by">tanelpoder</span><span>|</span><a href="#40870273">root</a><span>|</span><a href="#40870478">parent</a><span>|</span><a href="#40871135">next</a><span>|</span><label class="collapse" for="c-40870552">[-]</label><label class="expand" for="c-40870552">[1 more]</label></div><br/><div class="children"><div class="content">Same here, until now. I built the earlier xcapture v1 (also in the repo) about 5 years ago and it just samples various &#x2F;proc&#x2F;PID&#x2F;task&#x2F;TID pseudofiles regularly, it also allows you get pretty far with the thread-level activity measurement approach, especially when combined with always-on low frequency on-CPU sampling with perf.</div><br/></div></div></div></div></div></div><div id="40871135" class="c"><input type="checkbox" id="c-40871135" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40870273">root</a><span>|</span><a href="#40870353">parent</a><span>|</span><a href="#40870391">prev</a><span>|</span><a href="#40871565">next</a><span>|</span><label class="collapse" for="c-40871135">[-]</label><label class="expand" for="c-40871135">[3 more]</label></div><br/><div class="children"><div class="content">XDP, in its intended configuration, passes pointers to packets still on the driver DMA rings (or whatever) directly to BPF code, which can modify packets and forward them to other devices, bypassing the kernel stack completely. You can XDP_PASS a packet if you&#x27;d like it to hit the kernel, creating an skbuff, and bouncing it through all the kernel&#x27;s network stack code, but the idea is that you don&#x27;t want to do that; if you do, just use TC BPF, which is equivalently powerful and more flexible.</div><br/><div id="40874058" class="c"><input type="checkbox" id="c-40874058" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40870273">root</a><span>|</span><a href="#40871135">parent</a><span>|</span><a href="#40871565">next</a><span>|</span><label class="collapse" for="c-40874058">[-]</label><label class="expand" for="c-40874058">[2 more]</label></div><br/><div class="children"><div class="content">Yes for XDP there is a dedicated API, but for any of the other hooks like tracepoints, it&#x27;s all designed to give you read-only access.<p>The whole CO-RE thing is about having a kernel-version-agnostic way of reading fields from kernel data structures.</div><br/><div id="40876389" class="c"><input type="checkbox" id="c-40876389" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40870273">root</a><span>|</span><a href="#40874058">parent</a><span>|</span><a href="#40871565">next</a><span>|</span><label class="collapse" for="c-40876389">[-]</label><label class="expand" for="c-40876389">[1 more]</label></div><br/><div class="children"><div class="content">Right, I&#x27;m just pushing back on the DPDK thing.</div><br/></div></div></div></div></div></div></div></div><div id="40871565" class="c"><input type="checkbox" id="c-40871565" checked=""/><div class="controls bullet"><span class="by">lathiat</span><span>|</span><a href="#40870273">parent</a><span>|</span><a href="#40870353">prev</a><span>|</span><a href="#40870375">next</a><span>|</span><label class="collapse" for="c-40871565">[-]</label><label class="expand" for="c-40871565">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll toot my own horn here. But there are plenty of presentations about it, Brendan Gregg&#x27;s are usually pretty great.<p>&quot;bpftrace recipes: 5 real problems solved&quot; - Trent Lloyd (Everything Open 2023)
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ZDTfcrp9pJI" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ZDTfcrp9pJI</a></div><br/></div></div><div id="40870375" class="c"><input type="checkbox" id="c-40870375" checked=""/><div class="controls bullet"><span class="by">jiripospisil</span><span>|</span><a href="#40870273">parent</a><span>|</span><a href="#40871565">prev</a><span>|</span><a href="#40870559">next</a><span>|</span><label class="collapse" for="c-40870375">[-]</label><label class="expand" for="c-40870375">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a bunch of examples over at <a href="https:&#x2F;&#x2F;github.com&#x2F;iovisor&#x2F;bcc">https:&#x2F;&#x2F;github.com&#x2F;iovisor&#x2F;bcc</a></div><br/></div></div><div id="40870559" class="c"><input type="checkbox" id="c-40870559" checked=""/><div class="controls bullet"><span class="by">rascul</span><span>|</span><a href="#40870273">parent</a><span>|</span><a href="#40870375">prev</a><span>|</span><a href="#40870683">next</a><span>|</span><label class="collapse" for="c-40870559">[-]</label><label class="expand" for="c-40870559">[1 more]</label></div><br/><div class="children"><div class="content">You might find some interesting stuff here<p><a href="https:&#x2F;&#x2F;ebpf.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ebpf.io&#x2F;</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>