<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724576472774" as="style"/><link rel="stylesheet" href="styles.css?v=1724576472774"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://amodernist.com/texts/fun-c.html">Consistently Making Wrong Decisions Whilst Writing Recreational C</a> <span class="domain">(<a href="https://amodernist.com">amodernist.com</a>)</span></div><div class="subtext"><span>luu</span> | <span>19 comments</span></div><br/><div><div id="41345085" class="c"><input type="checkbox" id="c-41345085" checked=""/><div class="controls bullet"><span class="by">nneonneo</span><span>|</span><a href="#41342813">next</a><span>|</span><label class="collapse" for="c-41345085">[-]</label><label class="expand" for="c-41345085">[1 more]</label></div><br/><div class="children"><div class="content">This is cute! It’s worth pointing out that strace ships a similar feature (-e fault) which works for any syscall, even if the binary is statically linked. It works using ptrace, which is lower level than LD_PRELOAD. Although -e fault doesn’t support probabilistic failure, it does provide a flexible way to target specific invocations of a syscall. For example, to fail every second fork() call: -e fault=fork,errno=ENOMEM,when=1+2.</div><br/></div></div><div id="41342813" class="c"><input type="checkbox" id="c-41342813" checked=""/><div class="controls bullet"><span class="by">dmlorenzetti</span><span>|</span><a href="#41345085">prev</a><span>|</span><a href="#41344401">next</a><span>|</span><label class="collapse" for="c-41342813">[-]</label><label class="expand" for="c-41342813">[2 more]</label></div><br/><div class="children"><div class="content">It seems like it would be a lot easier to just have students call, e.g., `ta_fork()` rather than `fork()`, and then provide an implementing file to be linked with their program.  Then `ta_fork()` allows the TA to trigger errors, either probabilistically or deterministically (say, by setting environment variables).<p>This approach would also give students insight into testing strategies like mocking, plus it would work on more operating systems.<p>[Edit: Not to disparage this project.  It seems like it would have lots of uses, and it was probably a lot of fun to develop.]</div><br/><div id="41343474" class="c"><input type="checkbox" id="c-41343474" checked=""/><div class="controls bullet"><span class="by">l33t7332273</span><span>|</span><a href="#41342813">parent</a><span>|</span><a href="#41344401">next</a><span>|</span><label class="collapse" for="c-41343474">[-]</label><label class="expand" for="c-41343474">[1 more]</label></div><br/><div class="children"><div class="content">My intro to systems course did something similar with shared memory calls if I recall correctly</div><br/></div></div></div></div><div id="41344401" class="c"><input type="checkbox" id="c-41344401" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41342813">prev</a><span>|</span><a href="#41344783">next</a><span>|</span><label class="collapse" for="c-41344401">[-]</label><label class="expand" for="c-41344401">[1 more]</label></div><br/><div class="children"><div class="content">Nice writeup! One limitation to this approach is that the fault injections happen at the dynamic linkage to libc layer, meaning that an enterprising student who either statically links their binary or invokes syscalls directly will circumvent the interposed functions. But in a teaching setting I could imagine this isn’t a practical concern :-)<p>(I built a similar tool[1] a few years ago, but at the syscall layer to ensure that statically linked binaries could also have faults injected into them reliably. My colleagues used it to find a handful of bugs on prominent Go codebases.)<p>[1]: <a href="https:&#x2F;&#x2F;blog.trailofbits.com&#x2F;2019&#x2F;01&#x2F;17&#x2F;how-to-write-a-rootkit-without-really-trying&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.trailofbits.com&#x2F;2019&#x2F;01&#x2F;17&#x2F;how-to-write-a-rootk...</a></div><br/></div></div><div id="41344783" class="c"><input type="checkbox" id="c-41344783" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#41344401">prev</a><span>|</span><a href="#41345499">next</a><span>|</span><label class="collapse" for="c-41344783">[-]</label><label class="expand" for="c-41344783">[1 more]</label></div><br/><div class="children"><div class="content">You can use pthread_once() to simplify the initialization part: <a href="https:&#x2F;&#x2F;man.archlinux.org&#x2F;man&#x2F;pthread_once.3.en" rel="nofollow">https:&#x2F;&#x2F;man.archlinux.org&#x2F;man&#x2F;pthread_once.3.en</a><p>I don&#x27;t understand the desire not to link to pthread, it&#x27;s about as ubiquitous as a library can be.<p>I doubt it&#x27;s really a problem in this application... but naive userspace spinlocks are absolutely horrendous, see NOTES here: <a href="https:&#x2F;&#x2F;man.archlinux.org&#x2F;man&#x2F;pthread_spin_init.3.en" rel="nofollow">https:&#x2F;&#x2F;man.archlinux.org&#x2F;man&#x2F;pthread_spin_init.3.en</a><p><pre><code>  User-space spin locks [...] are, by definition, prone to priority inversion and unbounded spin times. A programmer using spin locks must be exceptionally careful not only in the code, but also in terms of system configuration, thread placement, and priority assignment.</code></pre></div><br/></div></div><div id="41345499" class="c"><input type="checkbox" id="c-41345499" checked=""/><div class="controls bullet"><span class="by">petters</span><span>|</span><a href="#41344783">prev</a><span>|</span><a href="#41342797">next</a><span>|</span><label class="collapse" for="c-41345499">[-]</label><label class="expand" for="c-41345499">[2 more]</label></div><br/><div class="children"><div class="content">&gt; and parsing it out of the man pages is not something I’d like to imagine doing reliably. So I must satisfy myself by manually writing these facts down. And this turns out to be the bottleneck of the entire operation.<p>You can probably use an LLM for this.</div><br/><div id="41345637" class="c"><input type="checkbox" id="c-41345637" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#41345499">parent</a><span>|</span><a href="#41342797">next</a><span>|</span><label class="collapse" for="c-41345637">[-]</label><label class="expand" for="c-41345637">[1 more]</label></div><br/><div class="children"><div class="content">If you do, you must unit-test the LLM stage. How do you do that without wasting a lot of time and resources? If the unit tests run through a few thousand times, would you bet your life on it never failing? I would if it was any other code.</div><br/></div></div></div></div><div id="41342797" class="c"><input type="checkbox" id="c-41342797" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#41345499">prev</a><span>|</span><a href="#41343336">next</a><span>|</span><label class="collapse" for="c-41342797">[-]</label><label class="expand" for="c-41342797">[1 more]</label></div><br/><div class="children"><div class="content">Very cool! I&#x27;ve started a similar project around `LD_PRELOAD` a few months ago to profile the time different programs spend on LibC calls. Provoking failures was the next step :)<p>Logging nicely was also an issue. I decided to avoid linking to any other symbols and implemented it with inline Assembly for x86&#x2F;64 and aarch64: <a href="https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;LibSee&#x2F;blob&#x2F;fdae92e71c449c9196a7d3b7d547bdbd6417e481&#x2F;libsee.c#L425-L542">https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;LibSee&#x2F;blob&#x2F;fdae92e71c449c91...</a></div><br/></div></div><div id="41343336" class="c"><input type="checkbox" id="c-41343336" checked=""/><div class="controls bullet"><span class="by">fuhsnn</span><span>|</span><a href="#41342797">prev</a><span>|</span><a href="#41343061">next</a><span>|</span><label class="collapse" for="c-41343336">[-]</label><label class="expand" for="c-41343336">[1 more]</label></div><br/><div class="children"><div class="content">Perl, at build time, get errno numbers of the system in a similar way[0]: preprocess errno.h with `$CC -E` and recursively scan all files in # markers for macro defines.<p>The configure script even checks the existence of several system headers this way, so if your C compiler don&#x27;t support # markers in -E output, you get missing includes everywhere.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;Perl&#x2F;perl5&#x2F;blob&#x2F;blead&#x2F;ext&#x2F;Errno&#x2F;Errno_pm.PL">https:&#x2F;&#x2F;github.com&#x2F;Perl&#x2F;perl5&#x2F;blob&#x2F;blead&#x2F;ext&#x2F;Errno&#x2F;Errno_pm....</a></div><br/></div></div><div id="41343061" class="c"><input type="checkbox" id="c-41343061" checked=""/><div class="controls bullet"><span class="by">jrpelkonen</span><span>|</span><a href="#41343336">prev</a><span>|</span><a href="#41344109">next</a><span>|</span><label class="collapse" for="c-41343061">[-]</label><label class="expand" for="c-41343061">[6 more]</label></div><br/><div class="children"><div class="content">Great article. Although I’ve been a Linux user since the time when stack of Slackware floppies was the prevailing installation media, I just recently learned that libc.so is also an executable.</div><br/><div id="41344287" class="c"><input type="checkbox" id="c-41344287" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#41343061">parent</a><span>|</span><a href="#41343267">next</a><span>|</span><label class="collapse" for="c-41344287">[-]</label><label class="expand" for="c-41344287">[1 more]</label></div><br/><div class="children"><div class="content">Fun trivia: so is &#x2F;lib&#x2F;ld-*.so*. I busted that out in an interview at a FAANG when the question was &quot;how could you recover from accidentally running &#x27;chmod a-x &#x2F;bin&#x2F;*&#x27;&quot;? My answer: &#x27;&#x2F;lib&#x2F;ld.so &#x2F;bin&#x2F;chmod a+x &#x2F;bin&#x2F;*&#x27;. The interviewer paused to get out his laptop and confirm it because he had never heard of it. After a fun detour of geeking out over something new an interesting, the followup question was modified to &quot;How <i>else</i> would you do it?&quot;<p>It&#x27;s spelled &quot;&#x2F;lib&#x2F;ld-linux-aarch64.so.1&quot; on my nearest Linux box but is still executable today.</div><br/></div></div><div id="41343267" class="c"><input type="checkbox" id="c-41343267" checked=""/><div class="controls bullet"><span class="by">jagged-chisel</span><span>|</span><a href="#41343061">parent</a><span>|</span><a href="#41344287">prev</a><span>|</span><a href="#41344109">next</a><span>|</span><label class="collapse" for="c-41343267">[-]</label><label class="expand" for="c-41343267">[4 more]</label></div><br/><div class="children"><div class="content">In what sense do you mean “executable?” Does it include a main() and can you launch it? Or do you mean because its code is invoked before your own executable’s code?</div><br/><div id="41343369" class="c"><input type="checkbox" id="c-41343369" checked=""/><div class="controls bullet"><span class="by">olalonde</span><span>|</span><a href="#41343061">root</a><span>|</span><a href="#41343267">parent</a><span>|</span><a href="#41344109">next</a><span>|</span><label class="collapse" for="c-41343369">[-]</label><label class="expand" for="c-41343369">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s in the article, it includes a main():<p><pre><code>    icterid$ &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6
    GNU C Library (Debian GLIBC 2.36-9+deb12u7) stable release version 2.36.
    Copyright (C) 2022 Free Software Foundation, Inc.
    This is free software; see the source for copying conditions.
    There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
    PARTICULAR PURPOSE.
    Compiled by GNU CC version 12.2.0.
    libc ABIs: UNIQUE IFUNC ABSOLUTE
    Minimum supported kernel: 3.2.0
    For bug reporting instructions, please see:
    &lt;http:&#x2F;&#x2F;www.debian.org&#x2F;Bugs&#x2F;&gt;.</code></pre></div><br/><div id="41345589" class="c"><input type="checkbox" id="c-41345589" checked=""/><div class="controls bullet"><span class="by">rzzzt</span><span>|</span><a href="#41343061">root</a><span>|</span><a href="#41343369">parent</a><span>|</span><a href="#41343500">next</a><span>|</span><label class="collapse" for="c-41345589">[-]</label><label class="expand" for="c-41345589">[1 more]</label></div><br/><div class="children"><div class="content">Both the Makefile as well as the source file were linked from the article, ld&#x27;s &quot;-e&quot; flag is used to set a custom entry point to &quot;__libc_main&quot;.</div><br/></div></div></div></div></div></div></div></div><div id="41344109" class="c"><input type="checkbox" id="c-41344109" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#41343061">prev</a><span>|</span><label class="collapse" for="c-41344109">[-]</label><label class="expand" for="c-41344109">[3 more]</label></div><br/><div class="children"><div class="content">&gt; (cannot dynamically load position-independent executable)<p>...why though? I mean, it&#x27;s position-independent, just load and relocate it wherever? Or does &quot;PIE&quot; mean something different in Linux from what it does in Windows?</div><br/><div id="41345163" class="c"><input type="checkbox" id="c-41345163" checked=""/><div class="controls bullet"><span class="by">pkal</span><span>|</span><a href="#41344109">parent</a><span>|</span><label class="collapse" for="c-41345163">[-]</label><label class="expand" for="c-41345163">[2 more]</label></div><br/><div class="children"><div class="content">I am not sure what the rationale was (probably security), but this was a concious upstream change: <a href="https:&#x2F;&#x2F;bugzilla.redhat.com&#x2F;show_bug.cgi?id=1764223" rel="nofollow">https:&#x2F;&#x2F;bugzilla.redhat.com&#x2F;show_bug.cgi?id=1764223</a></div><br/><div id="41345450" class="c"><input type="checkbox" id="c-41345450" checked=""/><div class="controls bullet"><span class="by">d110af5ccf</span><span>|</span><a href="#41344109">root</a><span>|</span><a href="#41345163">parent</a><span>|</span><label class="collapse" for="c-41345450">[-]</label><label class="expand" for="c-41345450">[1 more]</label></div><br/><div class="children"><div class="content">The upstream bug: <a href="https:&#x2F;&#x2F;sourceware.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=24323" rel="nofollow">https:&#x2F;&#x2F;sourceware.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=24323</a><p>An example of a problem provided in a different bug: <a href="https:&#x2F;&#x2F;sourceware.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=11754#c15" rel="nofollow">https:&#x2F;&#x2F;sourceware.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=11754#c15</a><p>But I don&#x27;t really understand what&#x27;s going on in that example.<p>Aside, it only took 9 years for that patch to get conclusively rejected.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>