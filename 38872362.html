<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704445253794" as="style"/><link rel="stylesheet" href="styles.css?v=1704445253794"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://commandcenter.blogspot.com/2024/01/what-we-got-right-what-we-got-wrong.html">Go: What we got right, what we got wrong</a> <span class="domain">(<a href="https://commandcenter.blogspot.com">commandcenter.blogspot.com</a>)</span></div><div class="subtext"><span>veqq</span> | <span>407 comments</span></div><br/><div><div id="38873111" class="c"><input type="checkbox" id="c-38873111" checked=""/><div class="controls bullet"><span class="by">w10-1</span><span>|</span><a href="#38872757">next</a><span>|</span><label class="collapse" for="c-38873111">[-]</label><label class="expand" for="c-38873111">[155 more]</label></div><br/><div class="children"><div class="content">I really, really appreciate key people taking the time for retrospectives.  It makes a huge difference to people now who want to make a real difference.<p>But I&#x27;m not sure Rob Pike states clearly enough what they got right (IMO): they managed the forces on the project as well as the language, by:<p>- Restricting the language to its target use: systems programming, not applications or data science or AI...<p>- Defining the language and its principles clearly.  This avoids eons of waste in implementing ambiguity and designing at cross-purposes.<p>- Putting quality first: it&#x27;s always cheaper for all concerned to fix problems before deploying, even if it&#x27;s harder for the community or OS contributors or people waiting for new features.<p>- Sharing the community.  They maintained strict control over the language and release and core messaging, but they also allowed others to lead in many downstream aspects.<p>Stated but under-appreciated is the degree to which Google itself didn&#x27;t interfere.  I suspect it&#x27;s because Go actually served its objectives and is critical to Google.  I wonder if that could be true today for a new project.  It&#x27;s interesting to compare Dart, which has zero uptake outside Flutter even though there are orders of magnitude more application code than systems code.<p>Go was probably the key technology that migrated server-side software off Java bloatware to native containers.  It dominates back-end infrastructure and underlies most of the web application infrastructure of the last 10 years.  The benefit to Google and the community from that alternative has been huge.  Somehow amidst all that growth, the team remained small and kept all its key players.<p>Will that change?</div><br/><div id="38873903" class="c"><input type="checkbox" id="c-38873903" checked=""/><div class="controls bullet"><span class="by">the_duke</span><span>|</span><a href="#38873111">parent</a><span>|</span><a href="#38873271">next</a><span>|</span><label class="collapse" for="c-38873903">[-]</label><label class="expand" for="c-38873903">[70 more]</label></div><br/><div class="children"><div class="content">&gt; - Restricting the language to its target use: systems programming, not applications or data science or AI...<p>Go has a GC and a very heavy runtime with green threads, leading to cumbersome&#x2F;slow C interop.<p>It certainly isn&#x27;t viable as systems programming language , which is by design. That&#x27;s an odd myth that has persisted ever since the language called itself as such in the beginning. They removed that wording years ago I think.<p>It&#x27;s primarily a competitor to Java et al, not to C or Rust, and  you see that when looking at the domains it is primarily used in, although it tends to sit a bit lower on the stack due to the limited nature of the type system and the great support for concurrency.</div><br/><div id="38876754" class="c"><input type="checkbox" id="c-38876754" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873903">parent</a><span>|</span><a href="#38874033">next</a><span>|</span><label class="collapse" for="c-38876754">[-]</label><label class="expand" for="c-38876754">[1 more]</label></div><br/><div class="children"><div class="content">Niklaus Wirth, rest his soul, would disagree.<p>Like would the folks at WithSecure, selling the USB Armory with Go written firmware.<p><a href="https:&#x2F;&#x2F;www.withsecure.com&#x2F;en&#x2F;solutions&#x2F;innovative-security-hardware&#x2F;usb-armory" rel="nofollow">https:&#x2F;&#x2F;www.withsecure.com&#x2F;en&#x2F;solutions&#x2F;innovative-security-...</a><p>Back in my day, writing compilers and OS services were also systems programming.</div><br/></div></div><div id="38874033" class="c"><input type="checkbox" id="c-38874033" checked=""/><div class="controls bullet"><span class="by">wredcoll</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873903">parent</a><span>|</span><a href="#38876754">prev</a><span>|</span><a href="#38876821">next</a><span>|</span><label class="collapse" for="c-38874033">[-]</label><label class="expand" for="c-38874033">[8 more]</label></div><br/><div class="children"><div class="content">Man, arguments about the definition of &quot;systems programming&quot; are almost as much fun as the old &quot;dynamic&quot; vs &quot;static&quot; language wars.</div><br/><div id="38874183" class="c"><input type="checkbox" id="c-38874183" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874033">parent</a><span>|</span><a href="#38876385">next</a><span>|</span><label class="collapse" for="c-38874183">[-]</label><label class="expand" for="c-38874183">[4 more]</label></div><br/><div class="children"><div class="content"><i>&gt; the old &quot;dynamic&quot; vs &quot;static&quot; language wars.</i><p>We used to argue about dynamic vs static languages. We still do, but we used to, too.</div><br/><div id="38874797" class="c"><input type="checkbox" id="c-38874797" checked=""/><div class="controls bullet"><span class="by">ysofunny</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874183">parent</a><span>|</span><a href="#38876144">next</a><span>|</span><label class="collapse" for="c-38874797">[-]</label><label class="expand" for="c-38874797">[2 more]</label></div><br/><div class="children"><div class="content">then there&#x27;s this <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dynamic_programming" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dynamic_programming</a><p>which has nothing to do with types nor variables but with algorithm optimization</div><br/><div id="38874956" class="c"><input type="checkbox" id="c-38874956" checked=""/><div class="controls bullet"><span class="by">jfoutz</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874797">parent</a><span>|</span><a href="#38876144">next</a><span>|</span><label class="collapse" for="c-38874956">[-]</label><label class="expand" for="c-38874956">[1 more]</label></div><br/><div class="children"><div class="content">The trick is to throw memory at it. if memoization helps, that’ll work without the memory hit!</div><br/></div></div></div></div><div id="38876144" class="c"><input type="checkbox" id="c-38876144" checked=""/><div class="controls bullet"><span class="by">klausnrooster</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874183">parent</a><span>|</span><a href="#38874797">prev</a><span>|</span><a href="#38876385">next</a><span>|</span><label class="collapse" for="c-38876144">[-]</label><label class="expand" for="c-38876144">[1 more]</label></div><br/><div class="children"><div class="content">:) ...Mitch</div><br/></div></div></div></div><div id="38876385" class="c"><input type="checkbox" id="c-38876385" checked=""/><div class="controls bullet"><span class="by">fractalb</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874033">parent</a><span>|</span><a href="#38874183">prev</a><span>|</span><a href="#38875824">next</a><span>|</span><label class="collapse" for="c-38876385">[-]</label><label class="expand" for="c-38876385">[2 more]</label></div><br/><div class="children"><div class="content">IIRC, Google tried to use Go for their Fuchsia TCP stack and then backtracked. Not a systems programming language for sure.</div><br/><div id="38876779" class="c"><input type="checkbox" id="c-38876779" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38876385">parent</a><span>|</span><a href="#38875824">next</a><span>|</span><label class="collapse" for="c-38876779">[-]</label><label class="expand" for="c-38876779">[1 more]</label></div><br/><div class="children"><div class="content">Sure it backtracked, because the guy pushing for Go left the team, and the rest is history.<p>Is writing compilers, linkers, IoT and bare metal firmware systems programming?</div><br/></div></div></div></div><div id="38875824" class="c"><input type="checkbox" id="c-38875824" checked=""/><div class="controls bullet"><span class="by">pohl</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874033">parent</a><span>|</span><a href="#38876385">prev</a><span>|</span><a href="#38876821">next</a><span>|</span><label class="collapse" for="c-38875824">[-]</label><label class="expand" for="c-38875824">[1 more]</label></div><br/><div class="children"><div class="content">I don’t recall anything but a single definition of the term until Google muddied the waters.</div><br/></div></div></div></div><div id="38876821" class="c"><input type="checkbox" id="c-38876821" checked=""/><div class="controls bullet"><span class="by">Matl</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873903">parent</a><span>|</span><a href="#38874033">prev</a><span>|</span><a href="#38874040">next</a><span>|</span><label class="collapse" for="c-38876821">[-]</label><label class="expand" for="c-38876821">[2 more]</label></div><br/><div class="children"><div class="content">&quot;systems&quot; can mean &quot;distributed systems&quot;, &quot;network systems&quot; etc. both of which Go is suitable for. It&#x27;s obviously not a great choice for &quot;operating systems&quot; which is well known.</div><br/></div></div><div id="38874040" class="c"><input type="checkbox" id="c-38874040" checked=""/><div class="controls bullet"><span class="by">sapiogram</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873903">parent</a><span>|</span><a href="#38876821">prev</a><span>|</span><a href="#38874086">next</a><span>|</span><label class="collapse" for="c-38874040">[-]</label><label class="expand" for="c-38874040">[29 more]</label></div><br/><div class="children"><div class="content">I totally agree that Go is best suited outside of systems programming, but to me that always seemed like a complete accident - its creators explicitly said their goal was to replace C++. But somehow it completely failed to do so, while simultaneously finding enormous success as a statically typed (and an order of magnitude faster) alternative to Python.</div><br/><div id="38874350" class="c"><input type="checkbox" id="c-38874350" checked=""/><div class="controls bullet"><span class="by">usrusr</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874040">parent</a><span>|</span><a href="#38874882">next</a><span>|</span><label class="collapse" for="c-38874350">[-]</label><label class="expand" for="c-38874350">[1 more]</label></div><br/><div class="children"><div class="content">Go appears to be made with radical focus on a niche that isn&#x27;t particularly well specified outside the heads of its benevolent directorate for life. Opinionated to the point of &quot;if you use Go outside that unnamed niche you got no-one to blame but yourself&quot;. Could almost be called a solution looking for a problem. But it also appears to be quite successful at finding problem-fit, no doubt helped by the clarity of that focus. They&#x27;ve been very open about what they consider Go no to be or ever become. Unlike practically every other language, they all seem to eventually fall into the trap of advertising themselves with what boils down to &quot;in a pinch you could also use it for everything else&quot;.<p>It&#x27;s quite plausible that before Go, its creators would have chosen C++ for problems they consider in &quot;The Go Niche&quot;. That would be perfectly sufficient to declare it a C++ replacement <i>in that niche</i>. Just not a <i>universal</i> C++ replacement.</div><br/></div></div><div id="38874882" class="c"><input type="checkbox" id="c-38874882" checked=""/><div class="controls bullet"><span class="by">fishywang</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874040">parent</a><span>|</span><a href="#38874350">prev</a><span>|</span><a href="#38875346">next</a><span>|</span><label class="collapse" for="c-38874882">[-]</label><label class="expand" for="c-38874882">[6 more]</label></div><br/><div class="children"><div class="content">&gt;its creators explicitly said their goal was to replace C++<p>so nowadays when we say &quot;c++&quot; we mostly mean the works should be replaced by rust, but back then, it&#x27;s not like that.<p>I would argue that go successfully replaced c++ in specific domains (network, etc.), and changed your perspective on what &quot;c++&quot; means.</div><br/><div id="38874903" class="c"><input type="checkbox" id="c-38874903" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874882">parent</a><span>|</span><a href="#38875346">next</a><span>|</span><label class="collapse" for="c-38874903">[-]</label><label class="expand" for="c-38874903">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s nothing new, Java successfully replaced C++ in enterprise code in the mid-to-late 1990s.  Because it was safe from memory bugs.</div><br/><div id="38875041" class="c"><input type="checkbox" id="c-38875041" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874903">parent</a><span>|</span><a href="#38875346">next</a><span>|</span><label class="collapse" for="c-38875041">[-]</label><label class="expand" for="c-38875041">[4 more]</label></div><br/><div class="children"><div class="content">Mid 2000s in my experience. And not because it was safe from memory bugs so much as safe from memory leaks. Still had plenty of NPEs.</div><br/><div id="38876793" class="c"><input type="checkbox" id="c-38876793" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875041">parent</a><span>|</span><a href="#38876485">next</a><span>|</span><label class="collapse" for="c-38876793">[-]</label><label class="expand" for="c-38876793">[1 more]</label></div><br/><div class="children"><div class="content">NPE isn&#x27;t a memory corruption bug.</div><br/></div></div><div id="38876485" class="c"><input type="checkbox" id="c-38876485" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875041">parent</a><span>|</span><a href="#38876793">prev</a><span>|</span><a href="#38875346">next</a><span>|</span><label class="collapse" for="c-38876485">[-]</label><label class="expand" for="c-38876485">[2 more]</label></div><br/><div class="children"><div class="content">Java kind of gets around the memory leak problem by allocating all of the leak up front for the JVM. ;)</div><br/><div id="38876604" class="c"><input type="checkbox" id="c-38876604" checked=""/><div class="controls bullet"><span class="by">cryptos</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38876485">parent</a><span>|</span><a href="#38875346">next</a><span>|</span><label class="collapse" for="c-38876604">[-]</label><label class="expand" for="c-38876604">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a JVM guy, but this is a good one :-)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38875346" class="c"><input type="checkbox" id="c-38875346" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874040">parent</a><span>|</span><a href="#38874882">prev</a><span>|</span><a href="#38876812">next</a><span>|</span><label class="collapse" for="c-38875346">[-]</label><label class="expand" for="c-38875346">[8 more]</label></div><br/><div class="children"><div class="content">Except it <i>did</i> replace C++ in the domains it claimed it would replace C++ in. It made clear from day one that you wouldn&#x27;t write something like a kernel in it. It was never trying to replace every last use of C++.<p>You may have a point that Python would have replaced C++ in those places instead if Go had never materialized. It was clear C++ was already on the way out, with Python among those starting to push into its place around the time Go was conceived. Go found its success in the places where Python was also trying to replace C++.</div><br/><div id="38876303" class="c"><input type="checkbox" id="c-38876303" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875346">parent</a><span>|</span><a href="#38875476">next</a><span>|</span><label class="collapse" for="c-38876303">[-]</label><label class="expand" for="c-38876303">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what you were meaning by &quot;it&quot;.<p>The main domain the original team behind Go were aiming at was clearly network software, especially servers.<p>But there was no consensus whether kernel could be a goal one day. Rob Pike originally thought Go could be a good language for writing kernels, if they made just a few tweaks to the runtime[1], but Ian Lance Taylor didn&#x27;t see real kernels ever being written in Go[2]. In the pre-release versions of Go, Russ Cox  wrote an example minimalistic kernel[3] that can directly run Go (the kernel itself is written in C and x86 Assembly) - it never really went beyond running a few toy programs and eventually became broken and unmaintained so it was removed.<p>[1]: <a href="https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;6vvOzYyDkWQ&#x2F;m&#x2F;3T1DD47AHKcJ" rel="nofollow">https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;6vvOzYyDkWQ&#x2F;m&#x2F;3T1D...</a><p>[2]: <a href="https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;UgbTmOXZ_yw&#x2F;m&#x2F;NH0jskB_xF0J" rel="nofollow">https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;UgbTmOXZ_yw&#x2F;m&#x2F;NH0j...</a><p>[3]: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;tree&#x2F;weekly.2011-01-12&#x2F;src&#x2F;pkg&#x2F;runtime&#x2F;tiny">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;tree&#x2F;weekly.2011-01-12&#x2F;src&#x2F;pkg&#x2F;...</a></div><br/></div></div><div id="38875476" class="c"><input type="checkbox" id="c-38875476" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875346">parent</a><span>|</span><a href="#38876303">prev</a><span>|</span><a href="#38875533">next</a><span>|</span><label class="collapse" for="c-38875476">[-]</label><label class="expand" for="c-38875476">[2 more]</label></div><br/><div class="children"><div class="content">What domains are those? It seems to mostly be an alternative to what people have use(d) Java or C# for.</div><br/><div id="38875480" class="c"><input type="checkbox" id="c-38875480" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875476">parent</a><span>|</span><a href="#38875533">next</a><span>|</span><label class="collapse" for="c-38875480">[-]</label><label class="expand" for="c-38875480">[1 more]</label></div><br/><div class="children"><div class="content">The original Go announcement spells it all out pretty nicely.</div><br/></div></div></div></div><div id="38875533" class="c"><input type="checkbox" id="c-38875533" checked=""/><div class="controls bullet"><span class="by">jeswin</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875346">parent</a><span>|</span><a href="#38875476">prev</a><span>|</span><a href="#38875447">next</a><span>|</span><label class="collapse" for="c-38875533">[-]</label><label class="expand" for="c-38875533">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You may have a point that Python would have replaced C++ in those places instead if Go had never materialized.<p>I don&#x27;t think Python was starting to occupy C++ space; they have entirely different abilities. Of course, I am also glad it didn&#x27;t happen.</div><br/><div id="38875615" class="c"><input type="checkbox" id="c-38875615" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875533">parent</a><span>|</span><a href="#38875447">next</a><span>|</span><label class="collapse" for="c-38875615">[-]</label><label class="expand" for="c-38875615">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think so either, but as we move past that side tangent and return to the discussion, there was the battle of the &#x27;event systems&#x27;. Node.js was also created in this timeframe to compete on much the same ground. And then came Go, after which most contenders, including Python, backed down. If you are writing these kinds of programs today, it is highly likely that you are using Go, Node.js, or some language that is even newer than Go (e.g. Rust or Elixir). C++ isn&#x27;t even on the consideration list anymore.</div><br/></div></div></div></div></div></div><div id="38876812" class="c"><input type="checkbox" id="c-38876812" checked=""/><div class="controls bullet"><span class="by">Merovius</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874040">parent</a><span>|</span><a href="#38875346">prev</a><span>|</span><a href="#38875489">next</a><span>|</span><label class="collapse" for="c-38876812">[-]</label><label class="expand" for="c-38876812">[1 more]</label></div><br/><div class="children"><div class="content">&gt; its creators explicitly said their goal was to replace C++<p>I think that is a far clearer goal if you look at C++ <i>as it is used inside Google</i>. If you combine the Google C++ style guide and Abseil, you can see the heritage of Go very clearly.</div><br/></div></div><div id="38875489" class="c"><input type="checkbox" id="c-38875489" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874040">parent</a><span>|</span><a href="#38876812">prev</a><span>|</span><a href="#38875374">next</a><span>|</span><label class="collapse" for="c-38875489">[-]</label><label class="expand" for="c-38875489">[5 more]</label></div><br/><div class="children"><div class="content">&gt; (and an order of magnitude faster) alternative to Python<p>Python is increasingly an easy to use wrapper over low-level C&#x2F;C++ code.<p>So in many use cases it is faster than Go.</div><br/><div id="38876497" class="c"><input type="checkbox" id="c-38876497" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875489">parent</a><span>|</span><a href="#38875374">next</a><span>|</span><label class="collapse" for="c-38876497">[-]</label><label class="expand" for="c-38876497">[4 more]</label></div><br/><div class="children"><div class="content">Than pure Go code, sure.  But not really faster than Go code that&#x27;s a wrapper over the same low-level C&#x2F;C++ code.</div><br/><div id="38876840" class="c"><input type="checkbox" id="c-38876840" checked=""/><div class="controls bullet"><span class="by">Merovius</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38876497">parent</a><span>|</span><a href="#38876845">next</a><span>|</span><label class="collapse" for="c-38876840">[-]</label><label class="expand" for="c-38876840">[1 more]</label></div><br/><div class="children"><div class="content">That depends. C function call overhead for Go is quite large (it needs to allocate a larger stack, put it on its own thread and prevent pre-emption) and possibly larger than for CPython, which relies on calling into C for pretty much everything it does, so obviously has that path well-optimized.<p>So I wouldn&#x27;t be surprised if, for some use cases, Python calling C in a tight loop could outperform Go.</div><br/></div></div><div id="38876845" class="c"><input type="checkbox" id="c-38876845" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38876497">parent</a><span>|</span><a href="#38876840">prev</a><span>|</span><a href="#38875374">next</a><span>|</span><label class="collapse" for="c-38876845">[-]</label><label class="expand" for="c-38876845">[2 more]</label></div><br/><div class="children"><div class="content">Do you have an example of that? What I’ve heard over and over in comments here is that a) C interop in Go is slow, and b) Go devs discourage using it.<p>(Java is a similar story in my experience.)<p>In Python, (b) at least is definitely <i>not</i> true.</div><br/></div></div></div></div></div></div><div id="38875374" class="c"><input type="checkbox" id="c-38875374" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874040">parent</a><span>|</span><a href="#38875489">prev</a><span>|</span><a href="#38876118">next</a><span>|</span><label class="collapse" for="c-38875374">[-]</label><label class="expand" for="c-38875374">[2 more]</label></div><br/><div class="children"><div class="content">And yet most popular tools written in Go used to be written in C++, Kubernetes, Databases and the like.</div><br/><div id="38876021" class="c"><input type="checkbox" id="c-38876021" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875374">parent</a><span>|</span><a href="#38876118">next</a><span>|</span><label class="collapse" for="c-38876021">[-]</label><label class="expand" for="c-38876021">[1 more]</label></div><br/><div class="children"><div class="content">Kubernetes mostly displaced tools written in Ruby (Puppet, Chef, Vagrant) or Python (Ansible, Fabric?). While a lot of older datastores are written in C++, new ones that were started post-2000ish tended to be written in Java or similar.</div><br/></div></div></div></div><div id="38876118" class="c"><input type="checkbox" id="c-38876118" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874040">parent</a><span>|</span><a href="#38875374">prev</a><span>|</span><a href="#38874086">next</a><span>|</span><label class="collapse" for="c-38876118">[-]</label><label class="expand" for="c-38876118">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not at &quot;an accident&quot; and Go didn&#x27;t &quot;somehow&quot; fail to replace C++ at its systems programming domain. The reason why go failed to replace C and C++ is not a mystery to anyone: Mandatory GC and a rather heavyweight runtime.<p>When the performance overhead of having a GC is less significant than the cognitive overhead of dealing with manual memory management (or the Rust borrow checker), Go was quite successful: Command line tools and network programs.<p>Around the time Go was released, it was certainly touted by its creators as a &quot;systems programming language&quot;[1] and a &quot;replacement for C++&quot;[2], but re-evaluating the Go team&#x27;s claims, I think they didn&#x27;t quite mean in the way most of us interpreted them.<p>1. The Go Team members were using &quot;systems programming language&quot; in a very wide sense, that include everything that is not scripting or web. I hate this defintion with passion, since it relies on nothing but pure elitism (&quot;Systems language are languages that REAL programmers uses, unlike those &quot;Scripting Languages&quot;). Ironically, this usage seems to originate from John Ousterhout[3], who is himself famous for designing a scripting language (Tcl).<p>Ousterhout&#x27;s definition of &quot;system programming language&quot; is: Designed to write applications from scratch (not just &quot;glue code&quot;), performant, strongly typed, designed for building data structures and algorithms from scratch, often provide higher-level facilities such as objects and threads.<p>Ousterhout&#x27;s definition was outdated even back in 2009, when Go was released, let alone today. Some dynamic languages (such as Python with type hints or TypeScript) are more strongly typed than C or even Java (with its type erasure). Typing is optional, but so it is in Java (Object), and C (void*, casting). When we talk about the archetypical &quot;strongly typed&quot; language today we would refer to  Haskell or Scala rather than C. Scripting languages like Python and JavaScript were already commonly used &quot;for writing applications from scratch&quot; back in 2009, and far from being ill-adapted for writing data structures and algorithms from scratch, Python became the most common language that universities are using for teaching data structures and algorithms! The most popular dynamic languages nowadays (Ruby, Python, JavaScript) all have objects, and 2 out of 3 (Python and Ruby) have threads (although GIL makes using threads problematic in the mainstream runtimes). The only real differentiator that remains is raw performance.<p>The widely accepted definition of a &quot;systems language&quot; today is &quot;a language that can be used to systems software&quot;. Systems software are either operating systems or OS-adjacent software such as device drivers, debuggers, hypervisors or even complex beasts like a web browser. The closest software that Go can claim in this category is Docker, but Docker itself is just a complex wrapper around Linux kernel features such as namespaces and cgroups. The actual containerization is done by these features which are implemented in C.<p>During the first years of Go, the Go language team was confronted on golang-nuts by people who wanted to use go for writing systems software and they usually evaded directly answering these questions. When pressed, they would admit that Go is not ready for writing OS kernels, at least not now[4][5][6], but GC could be disabled if you want to[7] (of course, there isn&#x27;t any way to free memory then, so it&#x27;s kinda moot). Eventually, the team came to a conclusion that disabling GC is not meant for production use[8][9], but that was not apparent in the early days.<p>Eventually the references for &quot;systems language&quot; disappeared from Go&#x27;s official homepage and one team member (Andrew Gerrand) even admitted this branding was a mistake[10].<p>In hindsight, I think the main &quot;systems programming task&quot; that Rob Pike and other members at the Go team envisioned was the main task that Google needed: writing highly concurrent server code.<p>2. The Go Team members sometimes mentioned replacing C and C++, but only in the context of specific pain points that made &quot;programming in the large&quot; cumbersome with C++: build speed, dependency management and different programmers using different subsets. I couldn&#x27;t find any claim that go was meant as a general replacement for C and C++ anywhere from the Go Team, but the media and the wider programming community generally took Go as a replacement language for C and C++.<p>When you read through the lines, it becomes clear that the C++ replacement angle is more about Google than it is about Go. It seems that in 2009, Google was using C++ as the primary language for writing web servers. For the rest of the industry, Java was (and perhaps still is) the most popular language for this task, with some companies opting for dynamic languages like Python, PHP and Ruby where performance allowed.<p>Go was a great fit for high-concurrency servers, especially back in 2009. Dynamic languages were slower and lacked native support for concurrency (if you put aside Lua, which never got popular for server programming for other reasons). Some of these languages had threads, but these were unworkable due to GIL. The closest thing was frameworks Twisted, but they were fully asynchronous and quite hard to use.<p>Popular static languages like Java and C# were also inconvenient, but in a different way. Both of these languages were fully capable of writing high-performance servers, but they were not properly tuned for this use case by default. The common frameworks of the day (Spring, Java EE and ASP.net) introduced copious amounts of overhead, and the GC was optimized for high throughput, but it had very bad tail latency (GC pauses) and generally required large heap sizes to be efficient. Dependency management, build and deployment was also an afterthought. Java had Maven and Ivy and .Net had NuGet (in 2010) and MSBuild, but these where quite cumbersome to use. Deployment was quite messy, with different packaging methods (multiple JAR files with classpath, WAR files, EAR files) and making sure the runtime on the server is compatible with your application. Most enthusiasts and many startups just gave up on Java entirely.<p>The mass migration of dynamic language programmers to Go was surprising for the Go team, but in hindsight it&#x27;s pretty obvious. They were concerned about performance, but didn&#x27;t feel like they had a choice: Java was just too complex and Enterprisey for them, and eeking out performance out of Java was not an task easy either. Go, on the other hand, had the simplest deployment model (a single binary), no need for fine tuning and it had a lot of built-in tooling from day one (&quot;gofmt&quot;, &quot;godoc&quot;, &quot;gotest&quot;, cross compilation) and other important tools (&quot;govet&quot;, &quot;goprof&quot; and &quot;goinstall&quot; which was later broken into &quot;go get&quot; and &quot;go install&quot;) were added within one year of its initial release.<p>The Go team did expect server programs to be the main use for Go and this is what they were targeting at Google. They just missed that the bulk of new servers outside of Google were being written in dynamic languages or Java.<p>The other &quot;surprising use&quot; of Go was for writing command-line utilities. I&#x27;m not sure if the original Go team were thinking about that, but it is also quite obvious in hindsight. Go was just so much easier to distribute than any alternative available at the time. Scripting languages like Python, Ruby or Perl had great libraries for writing CLI programs, but distributing your program along with its dependencies and making sure the runtime and dependencies match what you needed was practically impossible without essentially packaging your app for every single OS and distro out there or relying on the user to be a to install the correct version of Python or Ruby and then use gem or pip to install your package. Java and .NET had slow start times due to their VM, so they were horrible candidates even if you&#x27;d solve the dependency issues. So the best solution was usually C or C++ with either the &quot;.&#x2F;configure &amp;&amp; .&#x2F;make install&quot; pattern or making a static binary - both solutions were quite horrible. Go was a winner again: it produced fully static binaries by default and had easy-to-use cross compilation out of the box. Even creating a native package for Linux distros was a lot easier, so all you add to do is package a static binary.<p>[1]: <a href="https:&#x2F;&#x2F;opensource.googleblog.com&#x2F;2009&#x2F;11&#x2F;hey-ho-lets-go.html" rel="nofollow">https:&#x2F;&#x2F;opensource.googleblog.com&#x2F;2009&#x2F;11&#x2F;hey-ho-lets-go.htm...</a><p>[2]: <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20091114043422&#x2F;http:&#x2F;&#x2F;www.golang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20091114043422&#x2F;http:&#x2F;&#x2F;www.golang...</a><p>[3]: <a href="https:&#x2F;&#x2F;users.ece.utexas.edu&#x2F;~adnan&#x2F;top&#x2F;ousterhout-scripting.pdf" rel="nofollow">https:&#x2F;&#x2F;users.ece.utexas.edu&#x2F;~adnan&#x2F;top&#x2F;ousterhout-scripting...</a><p>[4]: <a href="https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;6vvOzYyDkWQ&#x2F;m&#x2F;3T1DD47AHKcJ" rel="nofollow">https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;6vvOzYyDkWQ&#x2F;m&#x2F;3T1D...</a><p>[5]: <a href="https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;BO1vBge4L-o&#x2F;m&#x2F;lU1_LQp_tpIJ" rel="nofollow">https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;BO1vBge4L-o&#x2F;m&#x2F;lU1_...</a><p>[6]: <a href="https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;UgbTmOXZ_yw&#x2F;m&#x2F;NH0jskB_xF0J" rel="nofollow">https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;UgbTmOXZ_yw&#x2F;m&#x2F;NH0j...</a><p>[7]: <a href="https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;UgbTmOXZ_yw&#x2F;m&#x2F;M9r1D4ch3ukJ" rel="nofollow">https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;UgbTmOXZ_yw&#x2F;m&#x2F;M9r1...</a><p>[8]: <a href="https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;qKB9h_pS1p8&#x2F;m&#x2F;1NlO-vg8V5cJ" rel="nofollow">https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;qKB9h_pS1p8&#x2F;m&#x2F;1NlO...</a><p>[9]: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;13761#issuecomment-167721220">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;13761#issuecomment-16772...</a><p>[10]: <a href="https:&#x2F;&#x2F;go.dev&#x2F;talks&#x2F;2011&#x2F;Real_World_Go.pdf" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;talks&#x2F;2011&#x2F;Real_World_Go.pdf</a> (Slide #25)</div><br/><div id="38876605" class="c"><input type="checkbox" id="c-38876605" checked=""/><div class="controls bullet"><span class="by">zogrodea</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38876118">parent</a><span>|</span><a href="#38876819">next</a><span>|</span><label class="collapse" for="c-38876605">[-]</label><label class="expand" for="c-38876605">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m impressed. That&#x27;s the most thorough and well-researched comment I&#x27;ve seen on Hackernews, ever. Thank you for taking the time and effort in writing it up.</div><br/><div id="38876759" class="c"><input type="checkbox" id="c-38876759" checked=""/><div class="controls bullet"><span class="by">lenova</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38876605">parent</a><span>|</span><a href="#38876826">next</a><span>|</span><label class="collapse" for="c-38876759">[-]</label><label class="expand" for="c-38876759">[1 more]</label></div><br/><div class="children"><div class="content">I agree. As someone unfamiliar with Go&#x27;s history, that was incredibly well written. It felt like I cathartically followed Go&#x27;s entire journey.</div><br/></div></div><div id="38876826" class="c"><input type="checkbox" id="c-38876826" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38876605">parent</a><span>|</span><a href="#38876759">prev</a><span>|</span><a href="#38876819">next</a><span>|</span><label class="collapse" for="c-38876826">[-]</label><label class="expand" for="c-38876826">[1 more]</label></div><br/><div class="children"><div class="content">It compares NuGet with Maven calling the former cumbersome. It&#x27;s a tell of gaps in research made but also a showcase of overarching problem where C# is held back by people bundling it together with Java and the issues of its ecosystem (because NuGet is excellent and on par with Cargo crates).</div><br/></div></div></div></div><div id="38876819" class="c"><input type="checkbox" id="c-38876819" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38876118">parent</a><span>|</span><a href="#38876605">prev</a><span>|</span><a href="#38874086">next</a><span>|</span><label class="collapse" for="c-38876819">[-]</label><label class="expand" for="c-38876819">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Systems software are either operating systems or OS-adjacent software such as device drivers, debuggers, hypervisors or even complex beasts like a web browser. The closest software that Go can claim in this category is Docker, but Docker itself is just a complex wrapper around Linux kernel features such as namespaces and cgroups. The actual containerization is done by these features which are implemented in C.<p>Android GPU debugger, USB Armory bare metal unikernel firmware, Go compiler, Go linker, bare metal on maker boards like Arduino and ESP32<p>&gt; Popular static languages like Java and C# were also inconvenient, but in a different way. Both of these languages were fully capable of writing high-performance servers, but they were not properly tuned for this use case by default. The common frameworks of the day (Spring, Java EE and ASP.net) introduced copious amounts of overhead, and the GC was optimized for high throughput, but it had very bad tail latency (GC pauses) and generally required large heap sizes to be efficient. Dependency management, build and deployment was also an afterthought. Java had Maven and Ivy and .Net had NuGet (in 2010) and MSBuild, but these where quite cumbersome to use. Deployment was quite messy, with different packaging methods (multiple JAR files with classpath, WAR files, EAR files) and making sure the runtime on the server is compatible with your application. Most enthusiasts and many startups just gave up on Java entirely.<p>Usually a problem only for those that refuse to actually learn about Java and .NET ecosystems.<p>Still doing great after 25 years, now being copied with the VC ideas to sponsor Kubernetes + WASM selling startups.</div><br/></div></div></div></div></div></div><div id="38874086" class="c"><input type="checkbox" id="c-38874086" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873903">parent</a><span>|</span><a href="#38874040">prev</a><span>|</span><a href="#38876043">next</a><span>|</span><label class="collapse" for="c-38874086">[-]</label><label class="expand" for="c-38874086">[2 more]</label></div><br/><div class="children"><div class="content">Early versions of Rust were a lot like Golang with some added OCaml flavor.  Complete with general GC, green threading etc.  They pivoted to current Rust with its focus on static borrowcheck and zero-overhead abstractions very late in the language&#x27;s evolution (though still pre-1.0 obviously) because they weren&#x27;t OK with the heavy runtime and cumbersome interop with C FFI. So there&#x27;s that.</div><br/><div id="38874226" class="c"><input type="checkbox" id="c-38874226" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874086">parent</a><span>|</span><a href="#38876043">next</a><span>|</span><label class="collapse" for="c-38874226">[-]</label><label class="expand" for="c-38874226">[1 more]</label></div><br/><div class="children"><div class="content">Both Rust and Go are descendants of Limbo, Pike&#x27;s prior language, although while Limbo&#x27;s DNA remains strong in Go it&#x27;s much more diffuse in Rust.</div><br/></div></div></div></div><div id="38876043" class="c"><input type="checkbox" id="c-38876043" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873903">parent</a><span>|</span><a href="#38874086">prev</a><span>|</span><a href="#38876123">next</a><span>|</span><label class="collapse" for="c-38876043">[-]</label><label class="expand" for="c-38876043">[1 more]</label></div><br/><div class="children"><div class="content">The shells scripts that bring up a machine are also &quot;systems programming&quot;.</div><br/></div></div><div id="38876123" class="c"><input type="checkbox" id="c-38876123" checked=""/><div class="controls bullet"><span class="by">0xpgm</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873903">parent</a><span>|</span><a href="#38876043">prev</a><span>|</span><a href="#38874788">next</a><span>|</span><label class="collapse" for="c-38876123">[-]</label><label class="expand" for="c-38876123">[1 more]</label></div><br/><div class="children"><div class="content">Maybe the better term for go would be server-systems programming.</div><br/></div></div><div id="38874788" class="c"><input type="checkbox" id="c-38874788" checked=""/><div class="controls bullet"><span class="by">ysofunny</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873903">parent</a><span>|</span><a href="#38876123">prev</a><span>|</span><a href="#38874952">next</a><span>|</span><label class="collapse" for="c-38874788">[-]</label><label class="expand" for="c-38874788">[5 more]</label></div><br/><div class="children"><div class="content">let&#x27;s just pretend that when go lang people say &quot;systems programing&quot; they mean smething closer to &quot;network (systems) programming&quot; which is where go shines the brightest</div><br/><div id="38875515" class="c"><input type="checkbox" id="c-38875515" checked=""/><div class="controls bullet"><span class="by">kernal</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874788">parent</a><span>|</span><a href="#38874952">next</a><span>|</span><label class="collapse" for="c-38875515">[-]</label><label class="expand" for="c-38875515">[4 more]</label></div><br/><div class="children"><div class="content">And yet Google replaced the go based network stack in Fuchsia with rust for performance reasons.</div><br/><div id="38875745" class="c"><input type="checkbox" id="c-38875745" checked=""/><div class="controls bullet"><span class="by">howenterprisey</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875515">parent</a><span>|</span><a href="#38876829">next</a><span>|</span><label class="collapse" for="c-38875745">[-]</label><label class="expand" for="c-38875745">[1 more]</label></div><br/><div class="children"><div class="content">I understand ysofunny&#x27;s comment to have meant basically microservices&#x2F;contemporary web backend.</div><br/></div></div><div id="38876829" class="c"><input type="checkbox" id="c-38876829" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875515">parent</a><span>|</span><a href="#38875745">prev</a><span>|</span><a href="#38874952">next</a><span>|</span><label class="collapse" for="c-38876829">[-]</label><label class="expand" for="c-38876829">[2 more]</label></div><br/><div class="children"><div class="content">After the guy responsible for it left the team.</div><br/><div id="38877040" class="c"><input type="checkbox" id="c-38877040" checked=""/><div class="controls bullet"><span class="by">ikiris</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38876829">parent</a><span>|</span><a href="#38874952">next</a><span>|</span><label class="collapse" for="c-38877040">[-]</label><label class="expand" for="c-38877040">[1 more]</label></div><br/><div class="children"><div class="content">This sounds more like for perf reasons that for performance reasons.</div><br/></div></div></div></div></div></div></div></div><div id="38874952" class="c"><input type="checkbox" id="c-38874952" checked=""/><div class="controls bullet"><span class="by">veqq</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873903">parent</a><span>|</span><a href="#38874788">prev</a><span>|</span><a href="#38875299">next</a><span>|</span><label class="collapse" for="c-38874952">[-]</label><label class="expand" for="c-38874952">[1 more]</label></div><br/><div class="children"><div class="content">&gt; runtime ... GC ... not viable as systems programming language<p>A GC can work fine. At the lower levels, people want to save every flop, but at the higher levels uncounted millions are wasted by JS, Electron apps etc. etc. We can sacrifice a little on the bottom (in the kernel) for great comfort, without a difference. But you don&#x27;t even have to make sacrifices. A high performance kernel only needs to allocate at startup, without freeing memory, allowing you to e.g. skip GC completely (turn it off with a compiler flag). This does require the kernel to implement specific optimizations though, which aren&#x27;t typically party to a language spec.<p>Anyway, some OS implemented with a GC: Oberon&#x2F;Bluebottle (the Oberon language was designed specifically to implement the Oberon OS), JavaOS, JX, JNode, Smalltalk (was the OS for the first Smalltalk systems), Lisp in old Lisp machines... Interval Research even worked on a real time OS written in Smalltalk.<p>Indeed, GC can work in hard real time systems e.g. the Aonix PERC Ultra, embedded real time Java for missile control (but Go&#x27;s current runtime&#x27; GC stops are unpredictable....)<p>Particularly when we consider modern hardware problems (basic OS research already basically stopped in the 90s, yay risc processor design...), with minimal hardware support for high speed context switching because of processor speed vs. memory access latency... Well, it&#x27;s not like we can utilize such minuscule operations anyway. Why don&#x27;t we just have sensible processors which don&#x27;t encourage us to unroll loops, which have die space to store context...<p>There were Java processors [2] which implement the JVM in hardware, with Java bytecode as machine code. Before llvm gained dominance, there were processors optimized to many languages (even Forths!)<p>David Chisnell, a RTOS and FreeBSD contributor recently went into quite a bit of depth [1] ending with:<p>&gt; everything that isn’t an allocator, a context-switch routine, or an ISR, can be written in a fully type-safe GC’d language<p>[1] <a href="https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;e6tz0r&#x2F;memory_safety_is_red_herring#c_gf5fyy" rel="nofollow">https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;e6tz0r&#x2F;memory_safety_is_red_herring#c_gf...</a><p>[2] <a href="https:&#x2F;&#x2F;www.electronicdesign.com&#x2F;technologies&#x2F;embedded&#x2F;article&#x2F;21772568&#x2F;java-processors" rel="nofollow">https:&#x2F;&#x2F;www.electronicdesign.com&#x2F;technologies&#x2F;embedded&#x2F;artic...</a></div><br/></div></div><div id="38875299" class="c"><input type="checkbox" id="c-38875299" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873903">parent</a><span>|</span><a href="#38874952">prev</a><span>|</span><a href="#38874802">next</a><span>|</span><label class="collapse" for="c-38875299">[-]</label><label class="expand" for="c-38875299">[4 more]</label></div><br/><div class="children"><div class="content">For people of Pike&#x27;s generation, &quot;systems programming&quot; means, roughly, the OS plus the utilities that would come with an OS.  Well, Go may not be useful for writing the OS, but for the OS-level utilities, it works just fine.</div><br/><div id="38876708" class="c"><input type="checkbox" id="c-38876708" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875299">parent</a><span>|</span><a href="#38874802">next</a><span>|</span><label class="collapse" for="c-38876708">[-]</label><label class="expand" for="c-38876708">[3 more]</label></div><br/><div class="children"><div class="content">Has it found success in OS-level utilities?  What popular utilities are written in Go?</div><br/><div id="38877025" class="c"><input type="checkbox" id="c-38877025" checked=""/><div class="controls bullet"><span class="by">ziotom78</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38876708">parent</a><span>|</span><a href="#38876833">next</a><span>|</span><label class="collapse" for="c-38877025">[-]</label><label class="expand" for="c-38877025">[1 more]</label></div><br/><div class="children"><div class="content">Not sure these are really popular, but I cannot resist advertising a few utilities written in Go that I regularly use in my daily workflow:<p>- gdu: a NCDU clone, much faster on SSD mounts [1]<p>- duf: a `df` clone with a nicer interface [2]<p>- massren: a `vidir` clone (simpler to use but with fewer options) [3]<p>- gotop: a `top` clone [4]<p>- micro: a nice TUI editor [5]<p>Building this kind of tools in Go makes sense, as the executables are statically compiled and are thus easy to install on remote servers.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;dundee&#x2F;gdu">https:&#x2F;&#x2F;github.com&#x2F;dundee&#x2F;gdu</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;muesli&#x2F;duf">https:&#x2F;&#x2F;github.com&#x2F;muesli&#x2F;duf</a><p>[3]: <a href="https:&#x2F;&#x2F;github.com&#x2F;laurent22&#x2F;massren">https:&#x2F;&#x2F;github.com&#x2F;laurent22&#x2F;massren</a><p>[4]: <a href="https:&#x2F;&#x2F;github.com&#x2F;xxxserxxx&#x2F;gotop">https:&#x2F;&#x2F;github.com&#x2F;xxxserxxx&#x2F;gotop</a><p>[5]: <a href="https:&#x2F;&#x2F;github.com&#x2F;zyedidia&#x2F;micro">https:&#x2F;&#x2F;github.com&#x2F;zyedidia&#x2F;micro</a></div><br/></div></div><div id="38876833" class="c"><input type="checkbox" id="c-38876833" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38876708">parent</a><span>|</span><a href="#38877025">prev</a><span>|</span><a href="#38874802">next</a><span>|</span><label class="collapse" for="c-38876833">[-]</label><label class="expand" for="c-38876833">[1 more]</label></div><br/><div class="children"><div class="content">Being self hosted?<p>Gokrazy userspace?<p>gVisor?</div><br/></div></div></div></div></div></div><div id="38874802" class="c"><input type="checkbox" id="c-38874802" checked=""/><div class="controls bullet"><span class="by">opportune</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873903">parent</a><span>|</span><a href="#38875299">prev</a><span>|</span><a href="#38874045">next</a><span>|</span><label class="collapse" for="c-38874802">[-]</label><label class="expand" for="c-38874802">[8 more]</label></div><br/><div class="children"><div class="content">Seconding this. Go also has some opinionated standard libraries (want to differentiate between header casings in http requests because your clients&#x2F;downstream services do? Go fuck yourself!) and shies you away from doing hacky, ugly, dangerous things you need in a systems language.<p>It’s absolutely an applications language.</div><br/><div id="38875664" class="c"><input type="checkbox" id="c-38875664" checked=""/><div class="controls bullet"><span class="by">aatd86</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874802">parent</a><span>|</span><a href="#38875853">next</a><span>|</span><label class="collapse" for="c-38875664">[-]</label><label class="expand" for="c-38875664">[6 more]</label></div><br/><div class="children"><div class="content">Headers are case-sensitive?</div><br/><div id="38875747" class="c"><input type="checkbox" id="c-38875747" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875664">parent</a><span>|</span><a href="#38876431">next</a><span>|</span><label class="collapse" for="c-38875747">[-]</label><label class="expand" for="c-38875747">[1 more]</label></div><br/><div class="children"><div class="content">They aren&#x27;t, but because you can send Foo-Bar as fOo-BaR on the wire, someone somewhere depends on it.  People don&#x27;t read the specs, they look at the example data, and decide that&#x27;s how their program works now.<p>Postel&#x27;s Law allows this.  A different law might say &quot;if anything is invalid or weird, reject it instantly&quot; and there would be a lot less security bugs.  But we also wouldn&#x27;t have TCP or HTTP.</div><br/></div></div><div id="38876431" class="c"><input type="checkbox" id="c-38876431" checked=""/><div class="controls bullet"><span class="by">opportune</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875664">parent</a><span>|</span><a href="#38875747">prev</a><span>|</span><a href="#38875772">next</a><span>|</span><label class="collapse" for="c-38876431">[-]</label><label class="expand" for="c-38876431">[3 more]</label></div><br/><div class="children"><div class="content">Only per the HTTP spec, and this is the same misunderstanding that the golang developers have. Because it&#x27;s so common to preserve header casing as requests traverse networks in the real world, many users&#x27; applications or even developers&#x27; APIs depend on header casing whether intentionally or not. So if you want to interact with them, or proxy them, you probably can&#x27;t use Go to do so (ok, actually you can, but you have to go down to the TCP level and abandon their http request library).<p>Go makes the argument that they can format your headers in canonicalized casing because casing shouldn&#x27;t matter per the HTTP spec. That&#x27;s fine for applications I guess, though still kind of an overreach given they have added code to modify your headers in a particular way you might not want to spend cycles on - but unacceptable for a systems language&#x2F;infrastructure implementation.</div><br/><div id="38876825" class="c"><input type="checkbox" id="c-38876825" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38876431">parent</a><span>|</span><a href="#38875772">next</a><span>|</span><label class="collapse" for="c-38876825">[-]</label><label class="expand" for="c-38876825">[2 more]</label></div><br/><div class="children"><div class="content">I thin you wanted to say that headers are <i>not</i> case sensitive according to the HTTP spec, but some clients and servers do treat header names as case-sensitive in practice.<p>What Go does here is kinda moot nowadays, since HTTP&#x2F;2.0 and HTTP&#x2F;3.0 force all header names into lower-case, so they would also break non-conformant clients and servers.</div><br/><div id="38876961" class="c"><input type="checkbox" id="c-38876961" checked=""/><div class="controls bullet"><span class="by">opportune</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38876825">parent</a><span>|</span><a href="#38875772">next</a><span>|</span><label class="collapse" for="c-38876961">[-]</label><label class="expand" for="c-38876961">[1 more]</label></div><br/><div class="children"><div class="content">That is in fact what I meant to say, and I thought I said it. Anyway, HTTP&#x2F;1.1 is still in use a lot of places.<p>I think most people here don’t have any experience building for the kind of use cases I’m considering here (imagine a proxy like Envoy, which btw does give you at least the option to configure header casing transformations). When you have customers that can’t be forced to behave in a certain way up&#x2F;down stream, you have to deal with this kind of stuff.</div><br/></div></div></div></div></div></div><div id="38875772" class="c"><input type="checkbox" id="c-38875772" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875664">parent</a><span>|</span><a href="#38876431">prev</a><span>|</span><a href="#38875853">next</a><span>|</span><label class="collapse" for="c-38875772">[-]</label><label class="expand" for="c-38875772">[1 more]</label></div><br/><div class="children"><div class="content">No, and that wasn&#x27;t the claim being made. The claim being made was that there can be engineering value in <i>preserving</i> the case of existing headers.<p>Example: An HTTP proxy that preserves the case of HTTP headers is going to cause less breakage than one that changes them. In a perfect world, it would make no difference, but that isn&#x27;t the world we live in.</div><br/></div></div></div></div><div id="38875853" class="c"><input type="checkbox" id="c-38875853" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874802">parent</a><span>|</span><a href="#38875664">prev</a><span>|</span><a href="#38874045">next</a><span>|</span><label class="collapse" for="c-38875853">[-]</label><label class="expand" for="c-38875853">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and shies you away from doing hacky, ugly, dangerous things you need in a systems language.<p>But... You end up doing hacky and ugly things all the time because Go is such a restricted language with so many opinions about what should and should not be done. Generics alone...</div><br/></div></div></div></div><div id="38874045" class="c"><input type="checkbox" id="c-38874045" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873903">parent</a><span>|</span><a href="#38874802">prev</a><span>|</span><a href="#38873271">next</a><span>|</span><label class="collapse" for="c-38874045">[-]</label><label class="expand" for="c-38874045">[7 more]</label></div><br/><div class="children"><div class="content"><i>&gt; It certainly isn&#x27;t viable as systems programming language</i><p>It is perfectly viable as a systems programming language. Remember, systems are the alternative to scripts. Go is in no way a scripting language...<p>You must be involved in Rust circles? They somehow became confused about what systems are, just as they became confused about what enums are. That is where you will find the odd myths.</div><br/><div id="38874291" class="c"><input type="checkbox" id="c-38874291" checked=""/><div class="controls bullet"><span class="by">leoc</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874045">parent</a><span>|</span><a href="#38874087">next</a><span>|</span><label class="collapse" for="c-38874291">[-]</label><label class="expand" for="c-38874291">[5 more]</label></div><br/><div class="children"><div class="content">It’s all admittedly a somewhat handwaving discussion, but in ‘systems programming’ ‘systems’ is generally understood to be opposite to ‘applications’, not ‘scripts’.</div><br/><div id="38874334" class="c"><input type="checkbox" id="c-38874334" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874291">parent</a><span>|</span><a href="#38874087">next</a><span>|</span><label class="collapse" for="c-38874334">[-]</label><label class="expand" for="c-38874334">[4 more]</label></div><br/><div class="children"><div class="content">All software is application. That’s what software is for!</div><br/><div id="38874596" class="c"><input type="checkbox" id="c-38874596" checked=""/><div class="controls bullet"><span class="by">bmicraft</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874334">parent</a><span>|</span><a href="#38874087">next</a><span>|</span><label class="collapse" for="c-38874596">[-]</label><label class="expand" for="c-38874596">[3 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t consider a driver an application</div><br/><div id="38876517" class="c"><input type="checkbox" id="c-38876517" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874596">parent</a><span>|</span><a href="#38874620">next</a><span>|</span><label class="collapse" for="c-38876517">[-]</label><label class="expand" for="c-38876517">[1 more]</label></div><br/><div class="children"><div class="content">We live in an age in which a PC running an OS, which has drivers in it, is something that can be done by Javascript in a browser.</div><br/></div></div><div id="38874620" class="c"><input type="checkbox" id="c-38874620" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874596">parent</a><span>|</span><a href="#38876517">prev</a><span>|</span><a href="#38874087">next</a><span>|</span><label class="collapse" for="c-38874620">[-]</label><label class="expand" for="c-38874620">[1 more]</label></div><br/><div class="children"><div class="content">application: the action of putting something into operation<p>What&#x27;s a driver if not something that carries out an action of putting something (an electronic device, typically) into operation?</div><br/></div></div></div></div></div></div></div></div><div id="38874087" class="c"><input type="checkbox" id="c-38874087" checked=""/><div class="controls bullet"><span class="by">cdogl</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874045">parent</a><span>|</span><a href="#38874291">prev</a><span>|</span><a href="#38873271">next</a><span>|</span><label class="collapse" for="c-38874087">[-]</label><label class="expand" for="c-38874087">[1 more]</label></div><br/><div class="children"><div class="content">Indeed - I’ve seen this refrain about “systems programming” countless times. I’m not sure how one can sustain the argument that a “system” is only an OS kernel, network stack or graphics driver.</div><br/></div></div></div></div></div></div><div id="38873271" class="c"><input type="checkbox" id="c-38873271" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#38873111">parent</a><span>|</span><a href="#38873903">prev</a><span>|</span><a href="#38875559">next</a><span>|</span><label class="collapse" for="c-38873271">[-]</label><label class="expand" for="c-38873271">[18 more]</label></div><br/><div class="children"><div class="content">Not sure I would agree with the community leading aspect. It still feels like Google decides.<p>My particular point would be versioning. At first Go refused to acknowledge the problem. Then, when there was finally growing community consensus, Go said forget everything else, now we are doing modules.<p>I also recall the refusal to make montatomicly-increasing-time a public API until cloudflare had a daylight savings time outage.</div><br/><div id="38875060" class="c"><input type="checkbox" id="c-38875060" checked=""/><div class="controls bullet"><span class="by">voidhorse</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873271">parent</a><span>|</span><a href="#38873346">next</a><span>|</span><label class="collapse" for="c-38875060">[-]</label><label class="expand" for="c-38875060">[2 more]</label></div><br/><div class="children"><div class="content">I think Go&#x27;s language leadership is one of the worst if not the worst I&#x27;ve ever seen when it comes to managing a language community&#x2F;PR. Both Ian and Rob come off as dismissive of the community and sometimes outright abrasive in some of the interactions I&#x27;ve seen. Russ Cox seems like a good person, though.<p>They probably think being hardheaded &quot;protects&quot; the language from feature creep and bad design, but it has also significantly delayed progress (see generics) and generally made me completely turned off from participating in language development or community in any meaningful way, even though I actually like the language. I think there are ways to prevent feature creep and steer the language well without being dismissive or a jerk.</div><br/><div id="38875675" class="c"><input type="checkbox" id="c-38875675" checked=""/><div class="controls bullet"><span class="by">aatd86</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875060">parent</a><span>|</span><a href="#38873346">next</a><span>|</span><label class="collapse" for="c-38875675">[-]</label><label class="expand" for="c-38875675">[1 more]</label></div><br/><div class="children"><div class="content">Not my experience (except for the Russ bit :o)<p>I&#x27;ve actually been quite impressed by Ian&#x27;s patience.<p>People are at different levels of understanding and sometimes it&#x27;s hard to communicate.</div><br/></div></div></div></div><div id="38873346" class="c"><input type="checkbox" id="c-38873346" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873271">parent</a><span>|</span><a href="#38875060">prev</a><span>|</span><a href="#38875559">next</a><span>|</span><label class="collapse" for="c-38873346">[-]</label><label class="expand" for="c-38873346">[15 more]</label></div><br/><div class="children"><div class="content">Personally their handling of versioning, generics and ESPECIALLY monotonic time (in all 3 cases, seemingly treating everyone raising concerns about the lack of a good solution as if they were cranks and&#x2F;or saying fix it yourself) definitely soured me on Go and I would never choose it for a project or choose to work for a company that uses it as language #1 or language #2.<p>It just left a bad taste in my mouth to see the needs and expertise of actual customers ignored by the Go team that way since the people in charge happened to be deploying in environments (i.e. Google) where those problems weren&#x27;t &#x27;real&#x27; problems<p>Undeniable that people have built and shipped incredible software with it, though.</div><br/><div id="38873820" class="c"><input type="checkbox" id="c-38873820" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873346">parent</a><span>|</span><a href="#38874423">next</a><span>|</span><label class="collapse" for="c-38873820">[-]</label><label class="expand" for="c-38873820">[7 more]</label></div><br/><div class="children"><div class="content">Package management is a very blatant entry for this list too.</div><br/><div id="38874206" class="c"><input type="checkbox" id="c-38874206" checked=""/><div class="controls bullet"><span class="by">okanat</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873820">parent</a><span>|</span><a href="#38874423">next</a><span>|</span><label class="collapse" for="c-38874206">[-]</label><label class="expand" for="c-38874206">[6 more]</label></div><br/><div class="children"><div class="content">Backend people use Go in my company. They do great things with it. It works well enough when the interface between a Go program and another one is a socket kind of thing.<p>But we also have a couple system utilities for embedded computers written in Go. I still get frustrated that I have to go and break my git configuration to enable ssh-based git clones and set a bunch of environment variables for private repos. Then there is CGO stuff like reading comments as code interfaces. Those things are incredible waste of time of the embedded developers and it makes harder for no reason to onboard people. Go generally spits out cryptic errors when building private repos like those.<p>I always wanted and still want to create a wrapper that lauches a container, makes whatever &quot;broken&quot; configuration that makes Go compiler happy, figures out file permissions and runs the compiler. The wrapper should be the only go executable in my host system and each repo should come with a config file for it.</div><br/><div id="38874454" class="c"><input type="checkbox" id="c-38874454" checked=""/><div class="controls bullet"><span class="by">starttoaster</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874206">parent</a><span>|</span><a href="#38874423">next</a><span>|</span><label class="collapse" for="c-38874454">[-]</label><label class="expand" for="c-38874454">[5 more]</label></div><br/><div class="children"><div class="content">&gt; I still get frustrated that I have to go and break my git configuration to enable ssh-based git clones and<p>Just curious.. But why would you disable ssh-based git authentication? It&#x27;s significantly more convenient when interacting with private repositories than supplying a username and password to https git endpoints.<p>&gt; set a bunch of environment variables for private repos.<p>Set up a private Go module proxy. Use something like Athens. The module proxy can handle authentication to your private module repositories itself, then you just add a line in your personal bashrc that specifies your proxy.<p>In general I don&#x27;t have complaints with the things you take issue with so I&#x27;ll digress on those.</div><br/><div id="38876881" class="c"><input type="checkbox" id="c-38876881" checked=""/><div class="controls bullet"><span class="by">okanat</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874454">parent</a><span>|</span><a href="#38874810">next</a><span>|</span><label class="collapse" for="c-38876881">[-]</label><label class="expand" for="c-38876881">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Just curious.. But why would you disable ssh-based git authentication?<p>I don&#x27;t disable it. However, not every git repo requires ssh to pull. When working with other languages, if there is a library that I purely depend on, it is perfectly okay to use https only and I use https.<p>However to use private repos with Golang, one has to modify their <i>global</i> git configuration to reroute <i>all</i> https traffic into ssh because Golang&#x27;s module system uses only https and the private repos are ssh-authenticated. There is no way to specify which repo is ssh and which repo is https. Last time I used Go, it was at 1.19.<p>&gt; Set up a private Go module proxy. Use something like Athens. The module proxy can handle authentication to your private module repositories itself, then you just add a line in your personal bashrc that specifies your proxy.<p>Why should we put more things on our stack just to make a language, which claims to be modern, work? Why do we have to change the global configuration of a build server to make it work? Rust doesn&#x27;t require this. Heck our Yocto bitbake recipes for C++ can do crazy things with url including automatically fetching the submodules.<p>Maybe it would make sense to make that change if we used Go everyday but we don&#x27;t.</div><br/></div></div><div id="38874810" class="c"><input type="checkbox" id="c-38874810" checked=""/><div class="controls bullet"><span class="by">shakow</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874454">parent</a><span>|</span><a href="#38876881">prev</a><span>|</span><a href="#38874423">next</a><span>|</span><label class="collapse" for="c-38874810">[-]</label><label class="expand" for="c-38874810">[3 more]</label></div><br/><div class="children"><div class="content">&gt; But why would you disable ssh-based git authentication?<p>Ask the Go developers. AFAIK the only package manager where I have to change my global git configuration to make it work. Even the venerable CPAN and tlmgr behave better.<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;27500861&#x2F;whats-the-proper-way-to-go-get-a-private-repository" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;27500861&#x2F;whats-the-prope...</a></div><br/><div id="38875457" class="c"><input type="checkbox" id="c-38875457" checked=""/><div class="controls bullet"><span class="by">starttoaster</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874810">parent</a><span>|</span><a href="#38874423">next</a><span>|</span><label class="collapse" for="c-38875457">[-]</label><label class="expand" for="c-38875457">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, this isn&#x27;t at all necessary. It might work for you but it&#x27;s not how we accomplish the same thing. See my original comment for what we do.</div><br/><div id="38876589" class="c"><input type="checkbox" id="c-38876589" checked=""/><div class="controls bullet"><span class="by">shakow</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875457">parent</a><span>|</span><a href="#38874423">next</a><span>|</span><label class="collapse" for="c-38876589">[-]</label><label class="expand" for="c-38876589">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sorry, but I didn&#x27;t catch it; how exactly do you `go get` private github repos?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38874423" class="c"><input type="checkbox" id="c-38874423" checked=""/><div class="controls bullet"><span class="by">starttoaster</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873346">parent</a><span>|</span><a href="#38873820">prev</a><span>|</span><a href="#38874000">next</a><span>|</span><label class="collapse" for="c-38874423">[-]</label><label class="expand" for="c-38874423">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It just left a bad taste in my mouth to see the needs and expertise of actual customers ignored by the Go team that way since the people in charge happened to be deploying in environments (i.e. Google) where those problems weren&#x27;t &#x27;real&#x27; problems<p>I feel for this, but only to an extent. It&#x27;s hard to work in any service industry and retain any notion of, &quot;the customer intelligently knows what they want,&quot; as a part of your personal beliefs. At the end of the day, you had an idea for a product, and you have to trust your gut on that product&#x27;s direction, which is going to make some group of people feel a little unheard.</div><br/></div></div><div id="38874000" class="c"><input type="checkbox" id="c-38874000" checked=""/><div class="controls bullet"><span class="by">pa7ch</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873346">parent</a><span>|</span><a href="#38874423">prev</a><span>|</span><a href="#38873749">next</a><span>|</span><label class="collapse" for="c-38874000">[-]</label><label class="expand" for="c-38874000">[3 more]</label></div><br/><div class="children"><div class="content">I mostly loved what they did with with modules&#x2F;package mgmt. I think SIV was a mistake but modules was miles better then the previous projects even with SIV. Some people seemed to take it very personally that the Go team didn&#x27;t adopt their prior solution but idk why they expected the go team to use their package manager. I think the SAT style package manager proposed would have created a lot more usability problems for developers and would have been much harder to maintain.</div><br/><div id="38876808" class="c"><input type="checkbox" id="c-38876808" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874000">parent</a><span>|</span><a href="#38873749">next</a><span>|</span><label class="collapse" for="c-38876808">[-]</label><label class="expand" for="c-38876808">[2 more]</label></div><br/><div class="children"><div class="content">They took it personally because Go led the community and those project leaders on for <i>years</i> that it would be looking, learning, and communicating...<p>And then dropped the module spec and implementation and mandated it all in about two days.  With no warning or feedback rounds or really any listening at all, just &quot;here it is, we&#x27;re done&quot;, out of nowhere.<p>They have every right to be personally insulted by that.</div><br/><div id="38877003" class="c"><input type="checkbox" id="c-38877003" checked=""/><div class="controls bullet"><span class="by">kitd</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38876808">parent</a><span>|</span><a href="#38873749">next</a><span>|</span><label class="collapse" for="c-38877003">[-]</label><label class="expand" for="c-38877003">[1 more]</label></div><br/><div class="children"><div class="content">2 days? ISTR discussions going on for at least 6 months comparing dep with what the &#x27;official&#x27; one would do.</div><br/></div></div></div></div></div></div><div id="38873749" class="c"><input type="checkbox" id="c-38873749" checked=""/><div class="controls bullet"><span class="by">hnarn</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873346">parent</a><span>|</span><a href="#38874000">prev</a><span>|</span><a href="#38875559">next</a><span>|</span><label class="collapse" for="c-38873749">[-]</label><label class="expand" for="c-38873749">[3 more]</label></div><br/><div class="children"><div class="content">&gt; the needs and expertise of actual customers<p>What is an ”actual customer” in the context of the Go programming language?</div><br/><div id="38875484" class="c"><input type="checkbox" id="c-38875484" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873749">parent</a><span>|</span><a href="#38875559">next</a><span>|</span><label class="collapse" for="c-38875484">[-]</label><label class="expand" for="c-38875484">[2 more]</label></div><br/><div class="children"><div class="content">Anyone who&#x27;s run an open source project is used to getting feature requests or complaints from groups like:<p>* people who are merely interested but have no plans to use your project<p>* people with strong opinions not backed by actual experience<p>* people with a specific interest (like a new API or feature) who want to integrate it into as many projects as possible<p>From a naive perspective, it makes sense to treat a request like &#x27;we need monotonic time&#x27; as something that doesn&#x27;t necessarily have any merit. The Go team are very experienced and opinionated, and it seems like it was a request that ran against their own instincts. The design complication probably was distasteful as well.<p>The problem is, the only reason they never needed monotonic time in the past was that many of them spent all their time working in special environments that didn&#x27;t need it (Google doesn&#x27;t do leap seconds). In practice other people shipping software in the wider world <i>do</i> need it, and that&#x27;s why they were asking for it. Their expertise was loudly disregarded even though the requests came with justification and problem scenarios.</div><br/><div id="38876796" class="c"><input type="checkbox" id="c-38876796" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875484">parent</a><span>|</span><a href="#38875559">next</a><span>|</span><label class="collapse" for="c-38876796">[-]</label><label class="expand" for="c-38876796">[1 more]</label></div><br/><div class="children"><div class="content">For anyone not familiar with the monotonic time issue, the implementation was found to be incorrect, and the go devs basically closed it and went “just use google smear time like we do lol, not an issue, bye”.<p>It did eventually get fixed I believe, but it was a shitty way of handling it.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38875559" class="c"><input type="checkbox" id="c-38875559" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#38873111">parent</a><span>|</span><a href="#38873271">prev</a><span>|</span><a href="#38873439">next</a><span>|</span><label class="collapse" for="c-38875559">[-]</label><label class="expand" for="c-38875559">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; It&#x27;s interesting to compare Dart, which has zero uptake outside Flutter</i><p>Caveat: I work on Dart.<p>I don&#x27;t see that that&#x27;s a very damning critique of Dart. Every language needs libraries&#x2F;frameworks to be suited for a domain. Flutter is a framework for writing client apps in Dart. Without Flutter, no matter how much you like Dart the language, you&#x27;d be spending a hell of a lot of time just figuring out how to get pixels on screen on Android and iOS. Few people have the desire or time for that.<p>Anyone writing applications builds on a stack of libraries and frameworks. The only difference I see between Go and Dart with Flutter is that Go&#x27;s domain libraries for networking, serialization, crypto and other stuff you need for servers are in the standard library.<p>Dart has a bunch of basics in the built in libraries like collections and asynchrony, but the domain-specific stuff relies on external packages like Flutter.<p>That&#x27;s in large part because Dart has had a robust package management story from very early on: many &quot;core&quot; libraries written and maintained by the Dart team are still shipped using the package manager instead of being built-in libraries because it makes them much easier to evolve.<p>I <i>prefer</i> that Flutter isn&#x27;t baked into Dart&#x27;s standard libraries, because UI frameworks tend to be shorter-lived than languages. Flutter is wonderful, but I wouldn&#x27;t be surprised if twenty years from now something better comes along. When that happens, it will be easier for Dart users to adopt it and not use Flutter because Flutter isn&#x27;t baked in.</div><br/><div id="38876937" class="c"><input type="checkbox" id="c-38876937" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875559">parent</a><span>|</span><a href="#38873439">next</a><span>|</span><label class="collapse" for="c-38876937">[-]</label><label class="expand" for="c-38876937">[1 more]</label></div><br/><div class="children"><div class="content">I don’t disagree with all that but it seems tangential to the point being made, that people just aren’t using Dart except for Flutter apps. So compared to Go it’s very much a niche language (although maybe it’s a really big niche, I don’t know).</div><br/></div></div></div></div><div id="38873439" class="c"><input type="checkbox" id="c-38873439" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#38873111">parent</a><span>|</span><a href="#38875559">prev</a><span>|</span><a href="#38873200">next</a><span>|</span><label class="collapse" for="c-38873439">[-]</label><label class="expand" for="c-38873439">[16 more]</label></div><br/><div class="children"><div class="content">I was a Java dev and love using Go now, but I have to say I&#x27;m not sure if many of my Ex-Java-Colleagues would like Go. Go is kind of odd in that even when it was new, it was kind of boring.<p>I think a lot of people in the Java world (not least myself) enjoy trying to refactor a codebase for new Java features (e.g. streams, which are amazing). In the Go world, the enjoyment comes from trying to find the simplest, plainest abstractions.</div><br/><div id="38873801" class="c"><input type="checkbox" id="c-38873801" checked=""/><div class="controls bullet"><span class="by">groestl</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873439">parent</a><span>|</span><a href="#38873826">next</a><span>|</span><label class="collapse" for="c-38873801">[-]</label><label class="expand" for="c-38873801">[9 more]</label></div><br/><div class="children"><div class="content">&gt; it was kind of boring.<p>As a Java dev, I love boring. That&#x27;s why I picked Java. Boring means less outages.<p>&gt; find the simplest, plainest abstractions.<p>Not sure I&#x27;d give that medal to Go.</div><br/><div id="38874245" class="c"><input type="checkbox" id="c-38874245" checked=""/><div class="controls bullet"><span class="by">techdragon</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873801">parent</a><span>|</span><a href="#38876459">next</a><span>|</span><label class="collapse" for="c-38874245">[-]</label><label class="expand" for="c-38874245">[7 more]</label></div><br/><div class="children"><div class="content">When did go get abstractions? (Only half joking)<p>Isn’t the entire language designed explicitly to prevent programmers from building their own sophisticated abstractions that could confuse other programmers who don’t understand that other persons code… as I understand it, if you can read go and understand basic programming you should be competent with go, and if you know your algorithms you should be proficient.<p>I hated old Java but the modern language isn’t as bad now some people have added some better syntax shortcuts the libraries are nearly twenty years more polished, and the IDE can nearly half write my code for me so the boilerplate and mind numbing aspect isn’t so bad… I <i>loathe</i> go because using it feels like programming with my hands tied behind my back trying on a keyboard with sandpaper keycaps, despite that, I didn’t bother “learning” go, I could just read it based on my Python&#x2F;C&#x2F;Basic&#x2F;Java&#x2F;C# experience instead of needing any extra learning.</div><br/><div id="38874332" class="c"><input type="checkbox" id="c-38874332" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874245">parent</a><span>|</span><a href="#38874881">next</a><span>|</span><label class="collapse" for="c-38874332">[-]</label><label class="expand" for="c-38874332">[1 more]</label></div><br/><div class="children"><div class="content">K8s just so happens to be coded in Golang.  A quick look at that overall codebase should be enough to disabuse people of this notion that Golang developers cannot possibly come up with confusing or overly sophisticated abstractions.</div><br/></div></div><div id="38874881" class="c"><input type="checkbox" id="c-38874881" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874245">parent</a><span>|</span><a href="#38874332">prev</a><span>|</span><a href="#38876175">next</a><span>|</span><label class="collapse" for="c-38874881">[-]</label><label class="expand" for="c-38874881">[4 more]</label></div><br/><div class="children"><div class="content">My experience with reading Go is that the language not giving tools to build good abstractions has failed to stop developers from trying to do so anyway. There&#x27;s never a line of code where I just plain don&#x27;t know what&#x27;s even going on syntactically as some languages can have, but understanding what it&#x27;s actually doing can still require hopping through several files.</div><br/><div id="38875997" class="c"><input type="checkbox" id="c-38875997" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874881">parent</a><span>|</span><a href="#38876175">next</a><span>|</span><label class="collapse" for="c-38875997">[-]</label><label class="expand" for="c-38875997">[3 more]</label></div><br/><div class="children"><div class="content">In short: a simple (programming) language does means that every small part&#x2F;line is simple. But it doesn&#x27;t mean that the combination of all parts&#x2F;lines is simple. Rather the opposite.</div><br/><div id="38876680" class="c"><input type="checkbox" id="c-38876680" checked=""/><div class="controls bullet"><span class="by">cryptos</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875997">parent</a><span>|</span><a href="#38876175">next</a><span>|</span><label class="collapse" for="c-38876680">[-]</label><label class="expand" for="c-38876680">[2 more]</label></div><br/><div class="children"><div class="content">Very true! I think a lot of the accidental complexity of early Java systems were rooted in the not so powerful language. If the language is too powerful (like Scala 2) developers do insane things with it. If the language is not powerful enough, developers create their own helpers and tricks everywhere and have to write a lot of additional code to do so.<p>Just compare Java streams with how collections are handled in Go and scratch your head how someone can come up with such a restricted language in this century.</div><br/><div id="38876782" class="c"><input type="checkbox" id="c-38876782" checked=""/><div class="controls bullet"><span class="by">groestl</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38876680">parent</a><span>|</span><a href="#38876175">next</a><span>|</span><label class="collapse" for="c-38876782">[-]</label><label class="expand" for="c-38876782">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and have to write a lot of additional code to do so.<p>And most importantly: you have to read a lot of code like this, and understand it&#x27;s assumptions, failure modes, runtime behavior and bugs, which are different every time. Instead of just reading &quot;ConcurrentHashMap&quot;, and be done with your day.</div><br/></div></div></div></div></div></div></div></div><div id="38876175" class="c"><input type="checkbox" id="c-38876175" checked=""/><div class="controls bullet"><span class="by">sidlls</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874245">parent</a><span>|</span><a href="#38874881">prev</a><span>|</span><a href="#38876459">next</a><span>|</span><label class="collapse" for="c-38876175">[-]</label><label class="expand" for="c-38876175">[1 more]</label></div><br/><div class="children"><div class="content">Eh, not really. Go’s philosophy around abstractions is quite poor. Duck typing begs engineers to create poor abstractions that simply reading a codebase does not necessarily lead to understanding. The bolted-on generics implementation actually makes this worse.</div><br/></div></div></div></div><div id="38876459" class="c"><input type="checkbox" id="c-38876459" checked=""/><div class="controls bullet"><span class="by">theshrike79</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873801">parent</a><span>|</span><a href="#38874245">prev</a><span>|</span><a href="#38873826">next</a><span>|</span><label class="collapse" for="c-38876459">[-]</label><label class="expand" for="c-38876459">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As a Java dev, I love boring. That&#x27;s why I picked Java. Boring means less outages.<p>This is why I personally love Go too :)<p>There&#x27;s very little room for fancy tricks, in most cases there is just one way to do things. It might be verbose, but writing code is the least time consuming part of my job anyway.</div><br/></div></div></div></div><div id="38873826" class="c"><input type="checkbox" id="c-38873826" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873439">parent</a><span>|</span><a href="#38873801">prev</a><span>|</span><a href="#38874353">next</a><span>|</span><label class="collapse" for="c-38873826">[-]</label><label class="expand" for="c-38873826">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Go is kind of odd in that even when it was new, it was kind of boring.<p>Java was designed to be boring, too. That’s why, for example, it doesn’t have unsigned integers: it means programmers need not spend time choosing between signed and unsigned integers.<p>It evolved away from that.</div><br/><div id="38876823" class="c"><input type="checkbox" id="c-38876823" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873826">parent</a><span>|</span><a href="#38874353">next</a><span>|</span><label class="collapse" for="c-38876823">[-]</label><label class="expand" for="c-38876823">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, Java has been trying to add every feature under the Sun recently and it&#x27;s definitely not a boring language anymore (since Java 21 at least, it&#x27;s impossible to claim otherwise with things like pattern matching being in the language).<p>As a Java guy, I think this is looking like a desperate attempt to remain relevant while forgetting why the language succeeded in the first place.</div><br/></div></div></div></div><div id="38874353" class="c"><input type="checkbox" id="c-38874353" checked=""/><div class="controls bullet"><span class="by">davewritescode</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873439">parent</a><span>|</span><a href="#38873826">prev</a><span>|</span><a href="#38874193">next</a><span>|</span><label class="collapse" for="c-38874353">[-]</label><label class="expand" for="c-38874353">[1 more]</label></div><br/><div class="children"><div class="content">Working with deeply nested data structures in Go is still frustrating, it’s one place where the Java still wins thanks to the streams API.</div><br/></div></div><div id="38874193" class="c"><input type="checkbox" id="c-38874193" checked=""/><div class="controls bullet"><span class="by">resource0x</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873439">parent</a><span>|</span><a href="#38874353">prev</a><span>|</span><a href="#38873200">next</a><span>|</span><label class="collapse" for="c-38874193">[-]</label><label class="expand" for="c-38874193">[3 more]</label></div><br/><div class="children"><div class="content">Almost every golang program I&#x27;ve seen was ugly. It&#x27;s strange given that they designed the language from scratch with all the ugliness ingrained in its structure from day one.</div><br/><div id="38874304" class="c"><input type="checkbox" id="c-38874304" checked=""/><div class="controls bullet"><span class="by">geodel</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874193">parent</a><span>|</span><a href="#38873200">next</a><span>|</span><label class="collapse" for="c-38874304">[-]</label><label class="expand" for="c-38874304">[2 more]</label></div><br/><div class="children"><div class="content">Different people different taste, different context, different standards of beauty.<p>Only thing strange seems here is you are putting opinion as some kind of fact.</div><br/><div id="38874638" class="c"><input type="checkbox" id="c-38874638" checked=""/><div class="controls bullet"><span class="by">resource0x</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874304">parent</a><span>|</span><a href="#38873200">next</a><span>|</span><label class="collapse" for="c-38874638">[-]</label><label class="expand" for="c-38874638">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Different people different taste, different context, different standards of beauty.<p>Every statement about aesthetics is subjective, you don&#x27;t have to remind me of that. BTW, what did YOU write about Amazon shows 6 days ago?
No one was pontificating about your opinion, right?<p>Please repent :-)</div><br/></div></div></div></div></div></div></div></div><div id="38873200" class="c"><input type="checkbox" id="c-38873200" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38873111">parent</a><span>|</span><a href="#38873439">prev</a><span>|</span><a href="#38874694">next</a><span>|</span><label class="collapse" for="c-38873200">[-]</label><label class="expand" for="c-38873200">[25 more]</label></div><br/><div class="children"><div class="content">&gt; Go was probably the key technology that migrated server-side software off Java bloatware to native containers<p>Interesting point of view - Golang might be pithily described as &quot;Java done right&quot;.  That has little to do with &quot;systems programming&quot; per se but can be quite valuable in its own terms.</div><br/><div id="38873364" class="c"><input type="checkbox" id="c-38873364" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873200">parent</a><span>|</span><a href="#38875031">next</a><span>|</span><label class="collapse" for="c-38873364">[-]</label><label class="expand" for="c-38873364">[23 more]</label></div><br/><div class="children"><div class="content">Java has a culture of over-engineering, to the point where even a logging library contains a string interpolator capable of executing remote code. Go successfully jettisoned this culture, even if the language itself repeated many of the same old mistakes that Java originally did.</div><br/><div id="38873628" class="c"><input type="checkbox" id="c-38873628" checked=""/><div class="controls bullet"><span class="by">zimpenfish</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873364">parent</a><span>|</span><a href="#38876856">next</a><span>|</span><label class="collapse" for="c-38873628">[-]</label><label class="expand" for="c-38873628">[11 more]</label></div><br/><div class="children"><div class="content">&gt; Java has a culture of over-engineering [which] Go successfully jettisoned<p>[looks at the code bases of several recent jobs]
[shakes head in violent disagreement]<p>If I&#x27;m having to open 6-8 different files just to follow what a HTTP handler does because it calls into an interface which calls into an interface which calls into an interface (and there&#x27;s no possibility that any of these will ever have a different implementation) ... I think we&#x27;re firmly into over-engineering territory.<p>(Anecdata, obviously)</div><br/><div id="38874477" class="c"><input type="checkbox" id="c-38874477" checked=""/><div class="controls bullet"><span class="by">evantbyrne</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873628">parent</a><span>|</span><a href="#38873787">next</a><span>|</span><label class="collapse" for="c-38874477">[-]</label><label class="expand" for="c-38874477">[1 more]</label></div><br/><div class="children"><div class="content">Java is a beautiful and capable language. I have written ORMs in both Java and Go, and the former was much easier to implement. Java has a culture problem though where developers seem to somehow enjoy discovering new ways to complicate their codebases. Beans are injected into codebases in waves like artillery at the Somme. Errors become inscrutable requiring breakpoints in an IDE to determine origin. What you describe with debugging a HTTP handler in your Go project is the norm in every commercial Java project I have ever contributed to. It&#x27;s a real shame that you are seeing these same kinds of issues in Go codebases.</div><br/></div></div><div id="38873787" class="c"><input type="checkbox" id="c-38873787" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873628">parent</a><span>|</span><a href="#38874477">prev</a><span>|</span><a href="#38873648">next</a><span>|</span><label class="collapse" for="c-38873787">[-]</label><label class="expand" for="c-38873787">[6 more]</label></div><br/><div class="children"><div class="content">But don&#x27;t those exist primarily for unit testing?  That was my understanding of why interfaces were there.<p>If you wanted a mock, you needed an interface, even if there would ever only be one implementation of it in production.</div><br/><div id="38877087" class="c"><input type="checkbox" id="c-38877087" checked=""/><div class="controls bullet"><span class="by">zimpenfish</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873787">parent</a><span>|</span><a href="#38875268">next</a><span>|</span><label class="collapse" for="c-38877087">[-]</label><label class="expand" for="c-38877087">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But don&#x27;t those exist primarily for unit testing?<p>I believe that&#x27;s why people insert them everywhere, yes, but in the codebases I&#x27;m talking about, many (I&#x27;d say the majority, to be honest) of the interfaces aren&#x27;t used for testing because they&#x27;ve just been cargo-culted rather than actually considered.<p>(Obviously this is with hindsight - they may well have been considered at the time but the end result doesn&#x27;t reflect that.)</div><br/></div></div><div id="38875268" class="c"><input type="checkbox" id="c-38875268" checked=""/><div class="controls bullet"><span class="by">tormeh</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873787">parent</a><span>|</span><a href="#38877087">prev</a><span>|</span><a href="#38873648">next</a><span>|</span><label class="collapse" for="c-38875268">[-]</label><label class="expand" for="c-38875268">[4 more]</label></div><br/><div class="children"><div class="content">I hate this pattern. Needless indirection for insignificant benefit.</div><br/><div id="38875780" class="c"><input type="checkbox" id="c-38875780" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875268">parent</a><span>|</span><a href="#38875877">next</a><span>|</span><label class="collapse" for="c-38875780">[-]</label><label class="expand" for="c-38875780">[2 more]</label></div><br/><div class="children"><div class="content">Golang &quot;punishes&quot; you for wanting to write a unit test around code.<p>You need to refactor it to use an interface just to unit test it.</div><br/><div id="38876187" class="c"><input type="checkbox" id="c-38876187" checked=""/><div class="controls bullet"><span class="by">sidlls</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875780">parent</a><span>|</span><a href="#38875877">next</a><span>|</span><label class="collapse" for="c-38876187">[-]</label><label class="expand" for="c-38876187">[1 more]</label></div><br/><div class="children"><div class="content">No, you don’t, unless you’re of the opinion that actual data structures with test data should not be used in a unit test.</div><br/></div></div></div></div><div id="38875877" class="c"><input type="checkbox" id="c-38875877" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875268">parent</a><span>|</span><a href="#38875780">prev</a><span>|</span><a href="#38873648">next</a><span>|</span><label class="collapse" for="c-38875877">[-]</label><label class="expand" for="c-38875877">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s indeed horrible when debugging. OTOH, there&#x27;s merit to the idea that better testing means less overall time spent (on either testing or debugging), so design choices that make testing easier provide a gain -- provided that <i>good</i> tests are actually implemented.</div><br/></div></div></div></div></div></div><div id="38873648" class="c"><input type="checkbox" id="c-38873648" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873628">parent</a><span>|</span><a href="#38873787">prev</a><span>|</span><a href="#38874007">next</a><span>|</span><label class="collapse" for="c-38873648">[-]</label><label class="expand" for="c-38873648">[1 more]</label></div><br/><div class="children"><div class="content">I stand corrected!</div><br/></div></div><div id="38874007" class="c"><input type="checkbox" id="c-38874007" checked=""/><div class="controls bullet"><span class="by">dharmab</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873628">parent</a><span>|</span><a href="#38873648">prev</a><span>|</span><a href="#38876856">next</a><span>|</span><label class="collapse" for="c-38874007">[-]</label><label class="expand" for="c-38874007">[2 more]</label></div><br/><div class="children"><div class="content">Why would those require 6 separate files?</div><br/><div id="38876767" class="c"><input type="checkbox" id="c-38876767" checked=""/><div class="controls bullet"><span class="by">theshrike79</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874007">parent</a><span>|</span><a href="#38876856">next</a><span>|</span><label class="collapse" for="c-38876767">[-]</label><label class="expand" for="c-38876767">[1 more]</label></div><br/><div class="children"><div class="content">Interface, actual implementation, Factory, FactoryImpl, you get the idea.<p>Java lends itself to over-engineering more than most languages. Especially since it seems that every project has that one committer who must be getting paid per line and creates the most complex structures for stuff that should&#x27;ve been a single static function.</div><br/></div></div></div></div></div></div><div id="38876856" class="c"><input type="checkbox" id="c-38876856" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873364">parent</a><span>|</span><a href="#38873628">prev</a><span>|</span><a href="#38873510">next</a><span>|</span><label class="collapse" for="c-38876856">[-]</label><label class="expand" for="c-38876856">[1 more]</label></div><br/><div class="children"><div class="content">Go code is equally over-engineered when taken into the hands enterprise architects.<p>You just happen to be looking at the wrong spot, see Kubernetes, YAML spaghetti, and plenty of stuff originated from Go in the enterprise space.</div><br/></div></div><div id="38873510" class="c"><input type="checkbox" id="c-38873510" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873364">parent</a><span>|</span><a href="#38876856">prev</a><span>|</span><a href="#38873858">next</a><span>|</span><label class="collapse" for="c-38873510">[-]</label><label class="expand" for="c-38873510">[9 more]</label></div><br/><div class="children"><div class="content">I asked Rob why he didn&#x27;t like Java (Gosling was standing nearby) and he said &quot;public static void main&quot;</div><br/><div id="38873610" class="c"><input type="checkbox" id="c-38873610" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873510">parent</a><span>|</span><a href="#38873929">next</a><span>|</span><label class="collapse" for="c-38873610">[-]</label><label class="expand" for="c-38873610">[4 more]</label></div><br/><div class="children"><div class="content">Nice. My reply would have been something like: it combines the performance of Lisp with the productivity of C++. These days Java the language is much better though, thanks to Brian Goetz.</div><br/><div id="38874843" class="c"><input type="checkbox" id="c-38874843" checked=""/><div class="controls bullet"><span class="by">shakow</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873610">parent</a><span>|</span><a href="#38873929">next</a><span>|</span><label class="collapse" for="c-38874843">[-]</label><label class="expand" for="c-38874843">[3 more]</label></div><br/><div class="children"><div class="content">&gt; it combines the performance of Lisp with the productivity of C++<p>Is that supposed to be a jab? Because IME SBCL Lisp is in the same ballpark as Go (albeit offering a fully interactive development environment), and C++ is far from being the worst choice when it comes down to productivity.</div><br/><div id="38876333" class="c"><input type="checkbox" id="c-38876333" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874843">parent</a><span>|</span><a href="#38873929">next</a><span>|</span><label class="collapse" for="c-38876333">[-]</label><label class="expand" for="c-38876333">[2 more]</label></div><br/><div class="children"><div class="content">Hopefully you agree Lisp is more productive than C++? Lisp is however not quite fast or efficient enough to displace C++ completely, mainly because, like Java and Go, it has a garbage collector. C++ was very much the language in Java&#x27;s crosshairs. Java made programming a bit safer, nulls and threads not withstanding, but was certainly not as productive as Lisp. Meanwhile Lisp evolved into Haskell and OCaml, two very productive languages which thankfully are inspiring everyone else to improve. Phil Wadler (from the original Haskell committee) has even been helping the Go team.</div><br/><div id="38876864" class="c"><input type="checkbox" id="c-38876864" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38876333">parent</a><span>|</span><a href="#38873929">next</a><span>|</span><label class="collapse" for="c-38876864">[-]</label><label class="expand" for="c-38876864">[1 more]</label></div><br/><div class="children"><div class="content">Common Lisp, is also among the GC based languages that offer mechanisms to do GC free allocations and has value types.<p>The only reason is the AI winter, and companies moving away from Lisp.</div><br/></div></div></div></div></div></div></div></div><div id="38873929" class="c"><input type="checkbox" id="c-38873929" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873510">parent</a><span>|</span><a href="#38873610">prev</a><span>|</span><a href="#38874132">next</a><span>|</span><label class="collapse" for="c-38873929">[-]</label><label class="expand" for="c-38873929">[1 more]</label></div><br/><div class="children"><div class="content">Well, that&#x27;s taken care of: <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;463" rel="nofollow">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;463</a> (well you need `void main`)</div><br/></div></div><div id="38874132" class="c"><input type="checkbox" id="c-38874132" checked=""/><div class="controls bullet"><span class="by">blibble</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873510">parent</a><span>|</span><a href="#38873929">prev</a><span>|</span><a href="#38873858">next</a><span>|</span><label class="collapse" for="c-38874132">[-]</label><label class="expand" for="c-38874132">[3 more]</label></div><br/><div class="children"><div class="content">still better than case deciding visibility</div><br/><div id="38875529" class="c"><input type="checkbox" id="c-38875529" checked=""/><div class="controls bullet"><span class="by">nyolfen</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874132">parent</a><span>|</span><a href="#38873858">next</a><span>|</span><label class="collapse" for="c-38875529">[-]</label><label class="expand" for="c-38875529">[2 more]</label></div><br/><div class="children"><div class="content">i love this feature to be honest</div><br/><div id="38876765" class="c"><input type="checkbox" id="c-38876765" checked=""/><div class="controls bullet"><span class="by">cryptos</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875529">parent</a><span>|</span><a href="#38873858">next</a><span>|</span><label class="collapse" for="c-38876765">[-]</label><label class="expand" for="c-38876765">[1 more]</label></div><br/><div class="children"><div class="content">I consider that a bad practice, because it doesn&#x27;t make things obvious. I guess it works so well in Go, because the language itself is small, so that you don&#x27;t have to remember much of these &quot;syntax tricks&quot;. Making things explicit, but not too verbose, is the best way in my opinion. JetBrains has done amazing work in this area with Kotlin.<p><pre><code>    for (item in collection) {
        ...
    }

    list.map { it + 1 }

    fun printAll(vararg strings: String)

    constructor(...)

    companion object
</code></pre>
I like the `for..in` which reads like plain English. Or `vararg` is pretty clear - compare that to &quot;*&quot; and the like in other languages. Or `constructor` can not be more explicit, there is no need to teach anyone that the name must be the same as the class name (and changed accordingly). Same is true for companion object (compare with Scala).</div><br/></div></div></div></div></div></div></div></div><div id="38873858" class="c"><input type="checkbox" id="c-38873858" checked=""/><div class="controls bullet"><span class="by">smitty1e</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873364">parent</a><span>|</span><a href="#38873510">prev</a><span>|</span><a href="#38875031">next</a><span>|</span><label class="collapse" for="c-38873858">[-]</label><label class="expand" for="c-38873858">[1 more]</label></div><br/><div class="children"><div class="content">It seems the goal of Java is to have one executable line of code per file.<p>Thus, the Java exception trace in the log file is almost like an interactive debug trace.<p>Whether that is a bug or a feature is an exercise for the reader.</div><br/></div></div></div></div><div id="38875031" class="c"><input type="checkbox" id="c-38875031" checked=""/><div class="controls bullet"><span class="by">sigzero</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873200">parent</a><span>|</span><a href="#38873364">prev</a><span>|</span><a href="#38874694">next</a><span>|</span><label class="collapse" for="c-38875031">[-]</label><label class="expand" for="c-38875031">[1 more]</label></div><br/><div class="children"><div class="content">No, not even &quot;pithily&quot; is it &quot;Java done right&quot;.</div><br/></div></div></div></div><div id="38874694" class="c"><input type="checkbox" id="c-38874694" checked=""/><div class="controls bullet"><span class="by">sjwhevvvvvsj</span><span>|</span><a href="#38873111">parent</a><span>|</span><a href="#38873200">prev</a><span>|</span><a href="#38876766">next</a><span>|</span><label class="collapse" for="c-38874694">[-]</label><label class="expand" for="c-38874694">[4 more]</label></div><br/><div class="children"><div class="content">They gutted the key FOSS teams during the layoffs, the c-suite hates real FOSS, it doesn’t look good on Ruth’s spreadsheet.<p>Of course, pretend FOSS like Android they strategically tolerate, but beyond that unless it results in an ad click it’s useless.</div><br/><div id="38874970" class="c"><input type="checkbox" id="c-38874970" checked=""/><div class="controls bullet"><span class="by">LispSporks22</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874694">parent</a><span>|</span><a href="#38876766">next</a><span>|</span><label class="collapse" for="c-38874970">[-]</label><label class="expand" for="c-38874970">[3 more]</label></div><br/><div class="children"><div class="content">Who is Ruth?</div><br/><div id="38875054" class="c"><input type="checkbox" id="c-38875054" checked=""/><div class="controls bullet"><span class="by">vajrabum</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874970">parent</a><span>|</span><a href="#38876766">next</a><span>|</span><label class="collapse" for="c-38875054">[-]</label><label class="expand" for="c-38875054">[2 more]</label></div><br/><div class="children"><div class="content">Google CFO</div><br/><div id="38875141" class="c"><input type="checkbox" id="c-38875141" checked=""/><div class="controls bullet"><span class="by">sjwhevvvvvsj</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38875054">parent</a><span>|</span><a href="#38876766">next</a><span>|</span><label class="collapse" for="c-38875141">[-]</label><label class="expand" for="c-38875141">[1 more]</label></div><br/><div class="children"><div class="content">Most employees think she’s the CEO to be fair.</div><br/></div></div></div></div></div></div></div></div><div id="38876766" class="c"><input type="checkbox" id="c-38876766" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38873111">parent</a><span>|</span><a href="#38874694">prev</a><span>|</span><a href="#38873496">next</a><span>|</span><label class="collapse" for="c-38876766">[-]</label><label class="expand" for="c-38876766">[1 more]</label></div><br/><div class="children"><div class="content">Where I stand, we keep enjoying Java and .NET bloatware, with powerful programming languages, thank you very much.<p>Go is only used in DevOps scenarios where there is no way around it.<p>The only place I advocate for it, is a C replacement, for the same role as Limbo in Inferno, or Oberon in 1992, not Java or .NET ecosystems.</div><br/></div></div><div id="38873496" class="c"><input type="checkbox" id="c-38873496" checked=""/><div class="controls bullet"><span class="by">closeparen</span><span>|</span><a href="#38873111">parent</a><span>|</span><a href="#38876766">prev</a><span>|</span><a href="#38875088">next</a><span>|</span><label class="collapse" for="c-38873496">[-]</label><label class="expand" for="c-38873496">[11 more]</label></div><br/><div class="children"><div class="content">&gt; Restricting the language to its target use: systems programming, not applications or data science or AI...<p>Go is used extensively in server-side business applications. Arguably it shouldn&#x27;t be, but it is.</div><br/><div id="38873758" class="c"><input type="checkbox" id="c-38873758" checked=""/><div class="controls bullet"><span class="by">hnarn</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873496">parent</a><span>|</span><a href="#38875088">next</a><span>|</span><label class="collapse" for="c-38873758">[-]</label><label class="expand" for="c-38873758">[10 more]</label></div><br/><div class="children"><div class="content">Why shouldn’t it be?</div><br/><div id="38874025" class="c"><input type="checkbox" id="c-38874025" checked=""/><div class="controls bullet"><span class="by">wavemode</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873758">parent</a><span>|</span><a href="#38873850">next</a><span>|</span><label class="collapse" for="c-38874025">[-]</label><label class="expand" for="c-38874025">[2 more]</label></div><br/><div class="children"><div class="content">I believe even the language&#x27;s own designers would agree with that sentiment. There&#x27;s just generally a lot of things about Go that are great for low-level microservices but not great for 1M+ line of code business applications maintained by large teams.<p>I can&#x27;t speak for others, but personally if I&#x27;m writing software with complex business logic, I&#x27;d want null safety, better error handling, a richer type system, easier testing&#x2F;mocking... I&#x27;ve also never liked that a panic in one goroutine crashes the whole application (you can recover if it&#x27;s your own code, sure, but not if it happened in a goroutine launched by some library).</div><br/><div id="38877090" class="c"><input type="checkbox" id="c-38877090" checked=""/><div class="controls bullet"><span class="by">dx034</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874025">parent</a><span>|</span><a href="#38873850">next</a><span>|</span><label class="collapse" for="c-38877090">[-]</label><label class="expand" for="c-38877090">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d disagree with most of that, but the panic in goroutines really hits home. It&#x27;s so annoying to remember implementing recover in every goroutine started to avoid crashing your application. I don&#x27;t get why there&#x27;s no global recover option that can recover from panic&#x27;s in goroutines as well.</div><br/></div></div></div></div><div id="38873850" class="c"><input type="checkbox" id="c-38873850" checked=""/><div class="controls bullet"><span class="by">eweise</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873758">parent</a><span>|</span><a href="#38874025">prev</a><span>|</span><a href="#38875088">next</a><span>|</span><label class="collapse" for="c-38873850">[-]</label><label class="expand" for="c-38873850">[7 more]</label></div><br/><div class="children"><div class="content">Too low level and lacks the power to cleanly model the business domain.</div><br/><div id="38874018" class="c"><input type="checkbox" id="c-38874018" checked=""/><div class="controls bullet"><span class="by">dharmab</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873850">parent</a><span>|</span><a href="#38873867">next</a><span>|</span><label class="collapse" for="c-38874018">[-]</label><label class="expand" for="c-38874018">[5 more]</label></div><br/><div class="children"><div class="content">&quot;Too low level&quot; &quot;lacks the power&quot; - I don&#x27;t understand what this means. What are things that are hard to do in Go business applications that other languages do better?</div><br/><div id="38874856" class="c"><input type="checkbox" id="c-38874856" checked=""/><div class="controls bullet"><span class="by">shakow</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874018">parent</a><span>|</span><a href="#38874538">next</a><span>|</span><label class="collapse" for="c-38874856">[-]</label><label class="expand" for="c-38874856">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What are things that are hard to do in Go business applications that other languages do better?<p>Streams, meta-programming, enums, ‶modern″ switches, generators, portable types in CGo, streamlined error handling, safer concurrency primitives, nil, partial struct initialization, ...</div><br/></div></div><div id="38874538" class="c"><input type="checkbox" id="c-38874538" checked=""/><div class="controls bullet"><span class="by">rowls66</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874018">parent</a><span>|</span><a href="#38874856">prev</a><span>|</span><a href="#38874598">next</a><span>|</span><label class="collapse" for="c-38874538">[-]</label><label class="expand" for="c-38874538">[1 more]</label></div><br/><div class="children"><div class="content">Here is an example. Go let’s structs be passed by value or by reference. The programmer needs to decide, and that adds complexity that is largely irrelevant for modeling complex business logic. Java does not provide a choice, which keeps it simple.</div><br/></div></div><div id="38874598" class="c"><input type="checkbox" id="c-38874598" checked=""/><div class="controls bullet"><span class="by">za3faran</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38874018">parent</a><span>|</span><a href="#38874538">prev</a><span>|</span><a href="#38873867">next</a><span>|</span><label class="collapse" for="c-38874598">[-]</label><label class="expand" for="c-38874598">[2 more]</label></div><br/><div class="children"><div class="content">It lacks modeling capability that you&#x27;d find even in languages like Java and C#. Enums, records, pattern matching, switch expressions, and yes even inheritance where it makes sense.</div><br/></div></div></div></div><div id="38873867" class="c"><input type="checkbox" id="c-38873867" checked=""/><div class="controls bullet"><span class="by">closeparen</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873850">parent</a><span>|</span><a href="#38874018">prev</a><span>|</span><a href="#38875088">next</a><span>|</span><label class="collapse" for="c-38873867">[-]</label><label class="expand" for="c-38873867">[1 more]</label></div><br/><div class="children"><div class="content">Go has pretty powerful composition, reuse, higher-order functions etc. for dealing with byte arrays and streams. Not so much for business domain entities.</div><br/></div></div></div></div></div></div></div></div><div id="38875088" class="c"><input type="checkbox" id="c-38875088" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38873111">parent</a><span>|</span><a href="#38873496">prev</a><span>|</span><a href="#38873369">next</a><span>|</span><label class="collapse" for="c-38875088">[-]</label><label class="expand" for="c-38875088">[1 more]</label></div><br/><div class="children"><div class="content">What they really got right in my opinion: show, don&#x27;t tell and modesty.</div><br/></div></div><div id="38873369" class="c"><input type="checkbox" id="c-38873369" checked=""/><div class="controls bullet"><span class="by">scythe</span><span>|</span><a href="#38873111">parent</a><span>|</span><a href="#38875088">prev</a><span>|</span><a href="#38872757">next</a><span>|</span><label class="collapse" for="c-38873369">[-]</label><label class="expand" for="c-38873369">[6 more]</label></div><br/><div class="children"><div class="content">&gt;Restricting the language to its target use: systems programming, not applications or data science or AI...<p>The only Go I ever touched in industry was the backend of a web-app at Salesforce. I&#x27;m not sure this counts as &quot;systems programming&quot;.<p><a href="https:&#x2F;&#x2F;engineering.salesforce.com&#x2F;einstein-analytics-and-go-24e5aed2981f&#x2F;" rel="nofollow">https:&#x2F;&#x2F;engineering.salesforce.com&#x2F;einstein-analytics-and-go...</a></div><br/><div id="38873464" class="c"><input type="checkbox" id="c-38873464" checked=""/><div class="controls bullet"><span class="by">WatchDog</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873369">parent</a><span>|</span><a href="#38872757">next</a><span>|</span><label class="collapse" for="c-38873464">[-]</label><label class="expand" for="c-38873464">[5 more]</label></div><br/><div class="children"><div class="content">Rob describes go as a language for writing server applications, and I think that is a much more applicable term than systems programming.</div><br/><div id="38873832" class="c"><input type="checkbox" id="c-38873832" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873464">parent</a><span>|</span><a href="#38873987">next</a><span>|</span><label class="collapse" for="c-38873832">[-]</label><label class="expand" for="c-38873832">[3 more]</label></div><br/><div class="children"><div class="content">Drew DeVault called it an &quot;internet&quot; language back in 2021.  And to that I more or less agree.<p>Read footnote 1 for context.<p><a href="https:&#x2F;&#x2F;drewdevault.com&#x2F;2021&#x2F;04&#x2F;02&#x2F;Go-is-a-great-language.html" rel="nofollow">https:&#x2F;&#x2F;drewdevault.com&#x2F;2021&#x2F;04&#x2F;02&#x2F;Go-is-a-great-language.ht...</a></div><br/><div id="38876788" class="c"><input type="checkbox" id="c-38876788" checked=""/><div class="controls bullet"><span class="by">cryptos</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873832">parent</a><span>|</span><a href="#38873987">next</a><span>|</span><label class="collapse" for="c-38876788">[-]</label><label class="expand" for="c-38876788">[2 more]</label></div><br/><div class="children"><div class="content">But then again the internet is everywhere now: desktop, servers, watches, washing machines, industrial systems, sensors ... So &quot;internet language&quot; is a somewhat pointless term.</div><br/><div id="38876963" class="c"><input type="checkbox" id="c-38876963" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38876788">parent</a><span>|</span><a href="#38873987">next</a><span>|</span><label class="collapse" for="c-38876963">[-]</label><label class="expand" for="c-38876963">[1 more]</label></div><br/><div class="children"><div class="content">That term isn’t meant to include mobile apps, desktop apps, web apps (even though those all use the internet, of course). Nobody is using Go for any of those, as far as I know.<p>So I think it is a useful term, and captures the things Go is good at surprisingly well.</div><br/></div></div></div></div></div></div><div id="38873987" class="c"><input type="checkbox" id="c-38873987" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#38873111">root</a><span>|</span><a href="#38873464">parent</a><span>|</span><a href="#38873832">prev</a><span>|</span><a href="#38872757">next</a><span>|</span><label class="collapse" for="c-38873987">[-]</label><label class="expand" for="c-38873987">[1 more]</label></div><br/><div class="children"><div class="content">Yep, I&#x27;d say one of the things they could have done better is in making this distinction more clear to people. I spent multiple years being confused about what made go a &quot;systems&quot; language, when it didn&#x27;t seem very good for that at all. When all the devops &#x2F; infrastructure tooling started being written in it, its niche suddenly became more clear to me.</div><br/></div></div></div></div></div></div></div></div><div id="38872757" class="c"><input type="checkbox" id="c-38872757" checked=""/><div class="controls bullet"><span class="by">leetrout</span><span>|</span><a href="#38873111">prev</a><span>|</span><a href="#38873511">next</a><span>|</span><label class="collapse" for="c-38872757">[-]</label><label class="expand" for="c-38872757">[18 more]</label></div><br/><div class="children"><div class="content">I picked up Go in 2012 as a Python dev in need to doing some bit twiddling over the wire for Modbus. I never shipped that code but it blew my mind how easy it was to just twiddle those bits and bytes and it just worked.<p>A decade later and a couple almost full time Go jobs under my belt and it still surprises me how well most things Just Work™.<p>I love the Go language and I love the Go community.<p>I appreciate what Rob, Ian, Russ and the others do for Go and I appreciate that this talk &#x2F; blog is honest about the &quot;bumps in the road&quot; working with the community. There&#x27;s not much point in beating a dead horse around this but having lived through it I find it very hard to believe they didn&#x27;t know exactly how they were behaving, especially in regards to the package management debacle. Never the less the blog is also correct that we have landed at a very good solution (Drew&#x27;s legitimate complaints aside).<p>Here&#x27;s to another 10 years of Go and the inspired &#x2F; similar languages (Zig, Deno, etc) and hoping we continue to grow as a healthy community.</div><br/><div id="38873239" class="c"><input type="checkbox" id="c-38873239" checked=""/><div class="controls bullet"><span class="by">biomcgary</span><span>|</span><a href="#38872757">parent</a><span>|</span><a href="#38876905">next</a><span>|</span><label class="collapse" for="c-38873239">[-]</label><label class="expand" for="c-38873239">[14 more]</label></div><br/><div class="children"><div class="content">My favorite thing about the core Go team is their willingness to say &quot;No&quot; (to all sorts of stuff) and &quot;Wait for the right implementation&quot; (for generics).<p>I&#x27;m a computational biologist rather than a programmer, so my use of Go waxes and wanes, but when I come back to Go, my code compiles and the language works the way I expect.<p>That being said, I do appreciate Rob Pike&#x27;s willingness to admit mistakes on the learning curve on community engagement without capitulating on adding all the shiny objects.</div><br/><div id="38873275" class="c"><input type="checkbox" id="c-38873275" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38872757">root</a><span>|</span><a href="#38873239">parent</a><span>|</span><a href="#38874611">next</a><span>|</span><label class="collapse" for="c-38873275">[-]</label><label class="expand" for="c-38873275">[11 more]</label></div><br/><div class="children"><div class="content">Wrt. generics they followed in Java&#x27;s footsteps: they asked the PLT community to come up with a reasonably elegant model that would mesh well with the rest of the language, and then largely stuck to that.</div><br/><div id="38873545" class="c"><input type="checkbox" id="c-38873545" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#38872757">root</a><span>|</span><a href="#38873275">parent</a><span>|</span><a href="#38875961">next</a><span>|</span><label class="collapse" for="c-38873545">[-]</label><label class="expand" for="c-38873545">[9 more]</label></div><br/><div class="children"><div class="content">It took years to root out and torch flawed APIs from the JVM ecosystem. After that example, it’s hard to defend neglecting the problem again and launching with no solution.</div><br/><div id="38873779" class="c"><input type="checkbox" id="c-38873779" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#38872757">root</a><span>|</span><a href="#38873545">parent</a><span>|</span><a href="#38874280">next</a><span>|</span><label class="collapse" for="c-38873779">[-]</label><label class="expand" for="c-38873779">[1 more]</label></div><br/><div class="children"><div class="content">No language launches perfectly.<p>If the cost of adding generics later is &quot;existing code still works, and now this can work too&quot; versus &quot;the old version of genetics is flawed, burn everything down and use this version instead&quot; or &quot;generics didn&#x27;t work out the way we wanted, use this new thing that&#x27;s totally-not-generics-wink-wink&quot;...<p>Well, I&#x27;d say waiting is the right call. You&#x27;re already used to adding three extra lines of boilerplate after every single line of code for error handling, living without generics wasn&#x27;t that hard.<p>Hell, I recall half the go community was convinced they weren&#x27;t needed at all by the time they came around.</div><br/></div></div><div id="38874280" class="c"><input type="checkbox" id="c-38874280" checked=""/><div class="controls bullet"><span class="by">philosopher1234</span><span>|</span><a href="#38872757">root</a><span>|</span><a href="#38873545">parent</a><span>|</span><a href="#38873779">prev</a><span>|</span><a href="#38875961">next</a><span>|</span><label class="collapse" for="c-38874280">[-]</label><label class="expand" for="c-38874280">[7 more]</label></div><br/><div class="children"><div class="content">The idea that it would be better if go waited an additional year or two to launch with generics is laughable. That extra year probably makes the difference for the languages success.</div><br/><div id="38874636" class="c"><input type="checkbox" id="c-38874636" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#38872757">root</a><span>|</span><a href="#38874280">parent</a><span>|</span><a href="#38875961">next</a><span>|</span><label class="collapse" for="c-38874636">[-]</label><label class="expand" for="c-38874636">[6 more]</label></div><br/><div class="children"><div class="content">If you mean that another language with more planning might have caught on, I think that would have been a better outcome.</div><br/><div id="38874850" class="c"><input type="checkbox" id="c-38874850" checked=""/><div class="controls bullet"><span class="by">philosopher1234</span><span>|</span><a href="#38872757">root</a><span>|</span><a href="#38874636">parent</a><span>|</span><a href="#38875961">next</a><span>|</span><label class="collapse" for="c-38874850">[-]</label><label class="expand" for="c-38874850">[5 more]</label></div><br/><div class="children"><div class="content">Why would a better planned language win and not one that rushed and beat go to the finish?</div><br/><div id="38876012" class="c"><input type="checkbox" id="c-38876012" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#38872757">root</a><span>|</span><a href="#38874850">parent</a><span>|</span><a href="#38875961">next</a><span>|</span><label class="collapse" for="c-38876012">[-]</label><label class="expand" for="c-38876012">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not what he said. He said IF that WOULD have happened, it would have been  better for everyone except for the Go designers.</div><br/><div id="38876158" class="c"><input type="checkbox" id="c-38876158" checked=""/><div class="controls bullet"><span class="by">philosopher1234</span><span>|</span><a href="#38872757">root</a><span>|</span><a href="#38876012">parent</a><span>|</span><a href="#38875961">next</a><span>|</span><label class="collapse" for="c-38876158">[-]</label><label class="expand" for="c-38876158">[3 more]</label></div><br/><div class="children"><div class="content">My point is that if you delayed the release of Go, there’s no reason to believe you end up with a better world. So his argument is bunk.</div><br/><div id="38876204" class="c"><input type="checkbox" id="c-38876204" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#38872757">root</a><span>|</span><a href="#38876158">parent</a><span>|</span><a href="#38875961">next</a><span>|</span><label class="collapse" for="c-38876204">[-]</label><label class="expand" for="c-38876204">[2 more]</label></div><br/><div class="children"><div class="content">Why not? I think his reasoning makes sense. Unless you mean that having a language with better design (but being released later) is not an improvement.</div><br/><div id="38876724" class="c"><input type="checkbox" id="c-38876724" checked=""/><div class="controls bullet"><span class="by">philosopher1234</span><span>|</span><a href="#38872757">root</a><span>|</span><a href="#38876204">parent</a><span>|</span><a href="#38875961">next</a><span>|</span><label class="collapse" for="c-38876724">[-]</label><label class="expand" for="c-38876724">[1 more]</label></div><br/><div class="children"><div class="content">My argument is that timing is very important to adoption. Unix is not the best OS to have been designed by far, but it was the first free one. If go had been delayed, something else may have filled the slot, and there’s no reason to believe it would have been a better something else. I.e when Go did release 2 years later, but with generics, it’d be too late, and no one would care.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="38875961" class="c"><input type="checkbox" id="c-38875961" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#38872757">root</a><span>|</span><a href="#38873275">parent</a><span>|</span><a href="#38873545">prev</a><span>|</span><a href="#38874611">next</a><span>|</span><label class="collapse" for="c-38875961">[-]</label><label class="expand" for="c-38875961">[1 more]</label></div><br/><div class="children"><div class="content">I think that generics is really difficult to do well when added to a language later. At the very least you will have a lot of pre-existing code, including the standard library, that would have benefitted from generics, but doesn&#x27;t because it was written before generics existed. And you will almost certainly have cases where generics don&#x27;t mesh well with other features. I think that if go was designed from the beginning with generics, then generics probably would have worked better in go (and similarly for java).</div><br/></div></div></div></div><div id="38874611" class="c"><input type="checkbox" id="c-38874611" checked=""/><div class="controls bullet"><span class="by">za3faran</span><span>|</span><a href="#38872757">root</a><span>|</span><a href="#38873239">parent</a><span>|</span><a href="#38873275">prev</a><span>|</span><a href="#38876905">next</a><span>|</span><label class="collapse" for="c-38874611">[-]</label><label class="expand" for="c-38874611">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;Wait for the right implementation&quot; (for generics).<p>Ironically, they still don&#x27;t have it right. Last time I checked you couldn&#x27;t have generics on &quot;methods&quot;.</div><br/><div id="38875234" class="c"><input type="checkbox" id="c-38875234" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38872757">root</a><span>|</span><a href="#38874611">parent</a><span>|</span><a href="#38876905">next</a><span>|</span><label class="collapse" for="c-38875234">[-]</label><label class="expand" for="c-38875234">[1 more]</label></div><br/><div class="children"><div class="content">There shouldn&#x27;t be anything in the chosen implementation that prevents generics on methods. The work just hasn&#x27;t been done yet. There are only so many hours in the day. Feel free to jump in if you have some to spare.<p>A wrong implementation would hamstring making such improvements in the future. It is possible that will still happen in some unforeseen way anyway, but the earlier proposals visibly exhibited problems from the get-go. They were clearly wrong. So far, this one does look right.</div><br/></div></div></div></div></div></div><div id="38876905" class="c"><input type="checkbox" id="c-38876905" checked=""/><div class="controls bullet"><span class="by">theshrike79</span><span>|</span><a href="#38872757">parent</a><span>|</span><a href="#38873239">prev</a><span>|</span><a href="#38873222">next</a><span>|</span><label class="collapse" for="c-38876905">[-]</label><label class="expand" for="c-38876905">[1 more]</label></div><br/><div class="children"><div class="content">A Python convert here too.<p>Currently I&#x27;ve been using different AI tools (Bard, GPT-4) to just straight-up convert my old python utilities to Go.<p>There are a few that worked right out of the box, for a few I&#x27;ve had to adjust stuff mostly because of the AI model&#x27;s information about APIs being a bit out of date.<p>But the fact that I can just scp a program to a server and it Just Works is amazing compared to the &quot;what&#x27;s the current venv system du jour&quot; dance I had to do with Python every time.</div><br/></div></div><div id="38873222" class="c"><input type="checkbox" id="c-38873222" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38872757">parent</a><span>|</span><a href="#38876905">prev</a><span>|</span><a href="#38873511">next</a><span>|</span><label class="collapse" for="c-38873222">[-]</label><label class="expand" for="c-38873222">[2 more]</label></div><br/><div class="children"><div class="content">Zig and Deno are not very comparable to Golang I think.  Elixir and ReasonML would be more like it.  From Google themselves there&#x27;s also Dart.</div><br/><div id="38874028" class="c"><input type="checkbox" id="c-38874028" checked=""/><div class="controls bullet"><span class="by">antod</span><span>|</span><a href="#38872757">root</a><span>|</span><a href="#38873222">parent</a><span>|</span><a href="#38873511">next</a><span>|</span><label class="collapse" for="c-38874028">[-]</label><label class="expand" for="c-38874028">[1 more]</label></div><br/><div class="children"><div class="content">Being that Deno is tooling rather than a language, I think it is safe to say it is inspired by &#x2F; comparable to Go tooling. To me it feels like writing JS&#x2F;TS with Go tooling.</div><br/></div></div></div></div></div></div><div id="38873511" class="c"><input type="checkbox" id="c-38873511" checked=""/><div class="controls bullet"><span class="by">cangeroo</span><span>|</span><a href="#38872757">prev</a><span>|</span><a href="#38873203">next</a><span>|</span><label class="collapse" for="c-38873511">[-]</label><label class="expand" for="c-38873511">[16 more]</label></div><br/><div class="children"><div class="content">(rant)<p>That&#x27;s nice, but also rather self-congratulatory.
I was expecting some kind of acknowledgment of the deeper issues in the language.
But perhaps that&#x27;s the central issue, that the language is perfect in their eyes.
I&#x27;m the problem.<p>Well, okay then.<p>I can&#x27;t recommend the language, because of its type system, the error handling, the unsafe concurrency, the simplistic syntax, nil, default zero, and a large number of mainstream packages are abandoned.<p>I now use Rust as my main language. It has a flourishing ecosystem and is visionary in so many ways that Go is not.<p>Put more pointedly, I&#x27;m sure Go had its day, when it was competing with PHP as a backend language.</div><br/><div id="38874988" class="c"><input type="checkbox" id="c-38874988" checked=""/><div class="controls bullet"><span class="by">demizer</span><span>|</span><a href="#38873511">parent</a><span>|</span><a href="#38874260">next</a><span>|</span><label class="collapse" for="c-38874988">[-]</label><label class="expand" for="c-38874988">[2 more]</label></div><br/><div class="children"><div class="content">All these plan9 scientists love their own brand. I started using Go in 2012, but after they killed deps.dev I gave it up. Some years later when I wanted to get work done at work I tried to introduce it on my team and another engineer spent a good amount of time looking into the language and listed all the reasons why it sucked, and he was right. The main takeaway was, yeah it&#x27;s simple, but it does silly things that makes it a pain to use (error handling and unused imports) to name a few. I personally like the error handling but hated the type  system.</div><br/><div id="38875264" class="c"><input type="checkbox" id="c-38875264" checked=""/><div class="controls bullet"><span class="by">cwbriscoe</span><span>|</span><a href="#38873511">root</a><span>|</span><a href="#38874988">parent</a><span>|</span><a href="#38874260">next</a><span>|</span><label class="collapse" for="c-38875264">[-]</label><label class="expand" for="c-38875264">[1 more]</label></div><br/><div class="children"><div class="content">Just run goimports on save then there would be no issue with unused imports.  I would take go&#x27;s error handling over try&#x2F;catch any day of the week.</div><br/></div></div></div></div><div id="38874260" class="c"><input type="checkbox" id="c-38874260" checked=""/><div class="controls bullet"><span class="by">zik</span><span>|</span><a href="#38873511">parent</a><span>|</span><a href="#38874988">prev</a><span>|</span><a href="#38874864">next</a><span>|</span><label class="collapse" for="c-38874260">[-]</label><label class="expand" for="c-38874260">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think this comment really contributes to the discussion. It comes across as Rust advocacy without having any tangible points to make.<p>First paragraph: &quot;I don&#x27;t like it&quot;. Second paragraph: snide comment. Third paragraph: &quot;I don&#x27;t like it&quot;. Fourth paragraph: &quot;Rust is better&quot;. Fifth paragraph: snide comment.</div><br/><div id="38874800" class="c"><input type="checkbox" id="c-38874800" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#38873511">root</a><span>|</span><a href="#38874260">parent</a><span>|</span><a href="#38874864">next</a><span>|</span><label class="collapse" for="c-38874800">[-]</label><label class="expand" for="c-38874800">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s one thing in there worth discussing IMO: the focus on zero values (incl. nil).<p>That&#x27;s the Go mistake, the one that causes most of the issues for the intended audience, the one that can&#x27;t really be fixed. It&#x27;s a shame Pike doesn&#x27;t really discuss this, even if it&#x27;s hopeless now.<p>The rest is just people projecting and self-selecting outside of the intended audience. Don&#x27;t like it, don&#x27;t use it, we don&#x27;t all need to agree with you.</div><br/><div id="38875827" class="c"><input type="checkbox" id="c-38875827" checked=""/><div class="controls bullet"><span class="by">campbel</span><span>|</span><a href="#38873511">root</a><span>|</span><a href="#38874800">parent</a><span>|</span><a href="#38874864">next</a><span>|</span><label class="collapse" for="c-38875827">[-]</label><label class="expand" for="c-38875827">[2 more]</label></div><br/><div class="children"><div class="content">Zero values are fine, some benefits, some drawbacks. Workarounds exist for when you need to identify the difference between unset and zero.</div><br/><div id="38876855" class="c"><input type="checkbox" id="c-38876855" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#38873511">root</a><span>|</span><a href="#38875827">parent</a><span>|</span><a href="#38874864">next</a><span>|</span><label class="collapse" for="c-38876855">[-]</label><label class="expand" for="c-38876855">[1 more]</label></div><br/><div class="children"><div class="content">No they’re not, they’re a horrible decision, and some of the “solutions” I’ve seen for working around them are band-aid-code at best.<p>The design decisions around zero values infect protobufs too, and they suck to work around. The fact that an empty message can successfully deserialise into <i>any</i> valid protobuf is an insane decision and should have been thrown out long ago.</div><br/></div></div></div></div></div></div></div></div><div id="38874864" class="c"><input type="checkbox" id="c-38874864" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#38873511">parent</a><span>|</span><a href="#38874260">prev</a><span>|</span><a href="#38876742">next</a><span>|</span><label class="collapse" for="c-38874864">[-]</label><label class="expand" for="c-38874864">[5 more]</label></div><br/><div class="children"><div class="content">I agree, I&#x27;ve used Go before I learned Rust and seeing the differences really changed my mind. I used to use OCaml before so I understood the value of Option and Result types over try&#x2F;catch and `nil`, but I used Go because it was easy. However, that easiness comes at a cost, namely maintenance over time. You want to get it right the first time around and not have to face challenges later on.<p>Not to be flippant, but I&#x27;ve often heard Go described as taking the programming language advances over the last 50 years and throwing them away.</div><br/><div id="38875732" class="c"><input type="checkbox" id="c-38875732" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#38873511">root</a><span>|</span><a href="#38874864">parent</a><span>|</span><a href="#38876742">next</a><span>|</span><label class="collapse" for="c-38875732">[-]</label><label class="expand" for="c-38875732">[4 more]</label></div><br/><div class="children"><div class="content">&gt; but I&#x27;ve often heard Go described as taking the programming language advances over the last 50 years and throwing them away.<p>That&#x27;s by design, right?  Go is very opinionated.  They looked at other languages that they hated, e.g., C++&#x2F;Java and didn&#x27;t want to replicate them.  But then adding their own mistakes along the way.<p>The brand new mistake that surprised me was that nil does not always equal nil.  So just checking for nil is not enough sometimes, one has to &quot;cast&quot; as nil to the type you&#x27;re expecting.  And goland doesn&#x27;t catch it.  C++&#x2F;Java&#x2F;Python&#x2F;C, null always equals null.  But not in golang. <i>shrug</i><p>The primary issue I have is that go doesn&#x27;t make it very easy to write unit tests.  You have to use interfaces everywhere just to inject your mocks.<p>I feel like that&#x27;s the big mistake they made.  Any new language needs to make it super easy to write unit tests without forcing major design decisions that affects development.</div><br/><div id="38876860" class="c"><input type="checkbox" id="c-38876860" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#38873511">root</a><span>|</span><a href="#38875732">parent</a><span>|</span><a href="#38876134">next</a><span>|</span><label class="collapse" for="c-38876860">[-]</label><label class="expand" for="c-38876860">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s by design, right? Go is very opinionated. They looked at other languages that they hated, e.g., C++&#x2F;Java and didn&#x27;t want to replicate them.<p>It’s a pity there’s no other languages in the world that they could have taken <i>good</i> design from, rather than looking at a handful of languages they didn’t like and basically throwing the baby out with the bath water.</div><br/></div></div><div id="38876134" class="c"><input type="checkbox" id="c-38876134" checked=""/><div class="controls bullet"><span class="by">earthboundkid</span><span>|</span><a href="#38873511">root</a><span>|</span><a href="#38875732">parent</a><span>|</span><a href="#38876860">prev</a><span>|</span><a href="#38876742">next</a><span>|</span><label class="collapse" for="c-38876134">[-]</label><label class="expand" for="c-38876134">[2 more]</label></div><br/><div class="children"><div class="content">I’ve never seen a real bug from the interface nil != concrete nil thing. When does it come up?</div><br/><div id="38876342" class="c"><input type="checkbox" id="c-38876342" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#38873511">root</a><span>|</span><a href="#38876134">parent</a><span>|</span><a href="#38876742">next</a><span>|</span><label class="collapse" for="c-38876342">[-]</label><label class="expand" for="c-38876342">[1 more]</label></div><br/><div class="children"><div class="content">People have raised dozens of issues on the Go tracker because they got stumped by this. You don&#x27;t really need to look hard on a search engine to see thousands of questions&#x2F;issues.<p>If you don&#x27;t believe me, take a project like k8s and starting from its inception, you can see dozens of issues where people have to explain function returns a nil interface and not a nil value. This is explained a stupendous number of times.<p>Now repeat this for thousands of Go projects.<p>Of-course you can claim this is not an issue in the same way  that anyone can claim that buffer overflows are not an issue in C&#x2F;C++ for &quot;real&quot; programmers.</div><br/></div></div></div></div></div></div></div></div><div id="38876742" class="c"><input type="checkbox" id="c-38876742" checked=""/><div class="controls bullet"><span class="by">hardwaregeek</span><span>|</span><a href="#38873511">parent</a><span>|</span><a href="#38874864">prev</a><span>|</span><a href="#38876992">next</a><span>|</span><label class="collapse" for="c-38876742">[-]</label><label class="expand" for="c-38876742">[1 more]</label></div><br/><div class="children"><div class="content">I agree with the programming language sentiments, but in its defense, Go is very much a language for and by people who don&#x27;t care about programming languages. I mean this in the nicest way. Rob Pike doesn&#x27;t care that the concurrency is unsafe or that nil is the billion dollar mistake. Neither do most users of Go. Does that make Go a good language? No. But that&#x27;s besides the point. It&#x27;s a convenient, good enough language combined with a compelling set of tools that make it easy to use. It&#x27;s the crocs of programming languages.</div><br/></div></div><div id="38876992" class="c"><input type="checkbox" id="c-38876992" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#38873511">parent</a><span>|</span><a href="#38876742">prev</a><span>|</span><a href="#38876338">next</a><span>|</span><label class="collapse" for="c-38876992">[-]</label><label class="expand" for="c-38876992">[1 more]</label></div><br/><div class="children"><div class="content">I am pretty sure Go is not going anywhere. Pretty much anyone can read Go and understand what is going on which is def. not true for Rust. It&#x27;s very possible that if Mojo pans out it might be the &quot;mass market&quot; lang. that brings a lot of the Rust goodness to the avg. dev.</div><br/></div></div><div id="38876338" class="c"><input type="checkbox" id="c-38876338" checked=""/><div class="controls bullet"><span class="by">SPBS</span><span>|</span><a href="#38873511">parent</a><span>|</span><a href="#38876992">prev</a><span>|</span><a href="#38875353">next</a><span>|</span><label class="collapse" for="c-38876338">[-]</label><label class="expand" for="c-38876338">[1 more]</label></div><br/><div class="children"><div class="content">&gt; First, what&#x27;s good and bad in a programming language is largely a matter of opinion rather than fact, despite the certainty with which many people argue about even the most trivial features of Go or any other language.<p>&gt; Also, there has already been plenty of discussion about things such as where the newlines go, how nil works, using upper case for export, garbage collection, error handling, and so on.  There are certainly things to say there, but little that hasn&#x27;t already been said.</div><br/></div></div><div id="38875353" class="c"><input type="checkbox" id="c-38875353" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#38873511">parent</a><span>|</span><a href="#38876338">prev</a><span>|</span><a href="#38873203">next</a><span>|</span><label class="collapse" for="c-38875353">[-]</label><label class="expand" for="c-38875353">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re misreading the article.  Pike doesn&#x27;t say that the language is perfect at all.  He says that they did better on the community aspects, but they admit the flaws in the language.</div><br/></div></div></div></div><div id="38873203" class="c"><input type="checkbox" id="c-38873203" checked=""/><div class="controls bullet"><span class="by">kitsune_</span><span>|</span><a href="#38873511">prev</a><span>|</span><a href="#38875626">next</a><span>|</span><label class="collapse" for="c-38873203">[-]</label><label class="expand" for="c-38873203">[8 more]</label></div><br/><div class="children"><div class="content">I know I sound salty here, but 10 years ago I got ridiculed on go-nuts, with dismissive comments from Rob Pike, because I dared to suggest that the way go get and module imports over the wire 1. worked, 2. were advertised in all their docs for beginners, and 3. how they were subsequently used throughout the community was ultimately harmful &#x2F; shortsighted.</div><br/><div id="38873238" class="c"><input type="checkbox" id="c-38873238" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#38873203">parent</a><span>|</span><a href="#38873354">next</a><span>|</span><label class="collapse" for="c-38873238">[-]</label><label class="expand" for="c-38873238">[3 more]</label></div><br/><div class="children"><div class="content">The way Go&#x27;s package system works, especially before modules, really feels like it was a hack over an earlier and even more limited system that was designed to be used entirely inside the Google monorepo that was made to work outside.  The weird global namespace tree makes sense there, and the emphasis on checked-in codegen also make sense there when you consider that Google also includes build artifacts in their monorepo.</div><br/><div id="38874727" class="c"><input type="checkbox" id="c-38874727" checked=""/><div class="controls bullet"><span class="by">capital_guy</span><span>|</span><a href="#38873203">root</a><span>|</span><a href="#38873238">parent</a><span>|</span><a href="#38873354">next</a><span>|</span><label class="collapse" for="c-38874727">[-]</label><label class="expand" for="c-38874727">[2 more]</label></div><br/><div class="children"><div class="content">This was exactly what happened. Rob Pike mentioned in another talk that they overfitted the pre-module system to how Google deals with packages. So I think he&#x2F;they have conceded this was a mistake</div><br/><div id="38876610" class="c"><input type="checkbox" id="c-38876610" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#38873203">root</a><span>|</span><a href="#38874727">parent</a><span>|</span><a href="#38873354">next</a><span>|</span><label class="collapse" for="c-38876610">[-]</label><label class="expand" for="c-38876610">[1 more]</label></div><br/><div class="children"><div class="content">If one used Plan9, it becomes quite clear how the module system happened (it also matches nicely with google monorepo).</div><br/></div></div></div></div></div></div><div id="38873354" class="c"><input type="checkbox" id="c-38873354" checked=""/><div class="controls bullet"><span class="by">shp0ngle</span><span>|</span><a href="#38873203">parent</a><span>|</span><a href="#38873238">prev</a><span>|</span><a href="#38875872">next</a><span>|</span><label class="collapse" for="c-38873354">[-]</label><label class="expand" for="c-38873354">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s interesting that what they came up with is better than what&#x27;s out there for other languages.<p>Yeah, you have the &quot;v2&quot; &#x2F; forever v0 problem. But it&#x27;s still better than what I need to deal with when using npm or (doing sign of the cross) anything with python.</div><br/><div id="38875279" class="c"><input type="checkbox" id="c-38875279" checked=""/><div class="controls bullet"><span class="by">djha-skin</span><span>|</span><a href="#38873203">root</a><span>|</span><a href="#38873354">parent</a><span>|</span><a href="#38875872">next</a><span>|</span><label class="collapse" for="c-38875279">[-]</label><label class="expand" for="c-38875279">[2 more]</label></div><br/><div class="children"><div class="content">Russ Cox&#x27;s &quot;minimum version selection&quot; was a complete reinvention of Apache Ivy&#x27;s &quot;Latest&quot; version resolver.<p>They basically reinvented maven, if you examine the version resolution plumbing of both tools.</div><br/><div id="38876272" class="c"><input type="checkbox" id="c-38876272" checked=""/><div class="controls bullet"><span class="by">nulltype</span><span>|</span><a href="#38873203">root</a><span>|</span><a href="#38875279">parent</a><span>|</span><a href="#38875872">next</a><span>|</span><label class="collapse" for="c-38876272">[-]</label><label class="expand" for="c-38876272">[1 more]</label></div><br/><div class="children"><div class="content">Looking at <a href="https:&#x2F;&#x2F;ant.apache.org&#x2F;ivy&#x2F;history&#x2F;latest-milestone&#x2F;ivyfile&#x2F;dependency.html" rel="nofollow">https:&#x2F;&#x2F;ant.apache.org&#x2F;ivy&#x2F;history&#x2F;latest-milestone&#x2F;ivyfile&#x2F;...</a> I don&#x27;t see how this is the same as minimal version selection.</div><br/></div></div></div></div></div></div><div id="38875872" class="c"><input type="checkbox" id="c-38875872" checked=""/><div class="controls bullet"><span class="by">hota_mazi</span><span>|</span><a href="#38873203">parent</a><span>|</span><a href="#38873354">prev</a><span>|</span><a href="#38875626">next</a><span>|</span><label class="collapse" for="c-38875872">[-]</label><label class="expand" for="c-38875872">[1 more]</label></div><br/><div class="children"><div class="content">Just Rob Pike expressing to the world how ignorant he is of programming language theory that was discovered after 2000.</div><br/></div></div></div></div><div id="38875626" class="c"><input type="checkbox" id="c-38875626" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#38873203">prev</a><span>|</span><a href="#38875061">next</a><span>|</span><label class="collapse" for="c-38875626">[-]</label><label class="expand" for="c-38875626">[3 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Critics often complained we should just do generics, because they are &quot;easy&quot;, and perhaps they can be in some languages, but the existence of interfaces meant that any new form of polymorphism had to take them into account.</i><p>I&#x27;ve been noodling on a statically typed hobby language and one of the things I&#x27;m trying to tackle is something like interfaces plus generics. And I have certainly found first-hand that Rob is right. It is really hard to get them to play nicely together.<p>I still think it&#x27;s worth doing. Personally, I&#x27;d find it pretty unrewarding to use a statically-typed language that doesn&#x27;t let me define my own generic types. I used to program in BASIC where you had GOSUB for subroutines but there was no way to write subroutines where you passed arguments to them. I don&#x27;t care to repeat that experience at the type system level.<p>But I can definitely sympathize with the Go team for taking a long time to find a good design. Designing a good language is hard. Designing a good language with a type system is 10x harder. Designing a good type system with generics is 10x harder than that.</div><br/><div id="38876873" class="c"><input type="checkbox" id="c-38876873" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#38875626">parent</a><span>|</span><a href="#38875843">next</a><span>|</span><label class="collapse" for="c-38876873">[-]</label><label class="expand" for="c-38876873">[1 more]</label></div><br/><div class="children"><div class="content">All the ML and functional languages don’t seem to have this problem, and a lot of them have Type Systems that are far more sophisticated and capable that go’s.</div><br/></div></div><div id="38875843" class="c"><input type="checkbox" id="c-38875843" checked=""/><div class="controls bullet"><span class="by">hota_mazi</span><span>|</span><a href="#38875626">parent</a><span>|</span><a href="#38876873">prev</a><span>|</span><a href="#38875061">next</a><span>|</span><label class="collapse" for="c-38875843">[-]</label><label class="expand" for="c-38875843">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But I can definitely sympathize with the Go team<p>I don&#x27;t.<p>The hardest part in implementing generics is when you support inheritance of implementation.<p>Go doesn&#x27;t.<p>Go had the easiest job in implementing generics.<p>The only reason why they didn&#x27;t was not technical: it was ideological and purely based in ignorance, and the fact that most Go designers stopped paying attention to the field of PLT in the late 90s.</div><br/></div></div></div></div><div id="38875061" class="c"><input type="checkbox" id="c-38875061" checked=""/><div class="controls bullet"><span class="by">gregwebs</span><span>|</span><a href="#38875626">prev</a><span>|</span><a href="#38876017">next</a><span>|</span><label class="collapse" for="c-38875061">[-]</label><label class="expand" for="c-38875061">[6 more]</label></div><br/><div class="children"><div class="content">This seems like a more personal account of the ACM article they published [1]. In both they recognize that they didn&#x27;t make a great new programming language in terms of a language specification but instead did a great job building up all the things around programming languages that may end up being even more important.<p>In the submitted article they talk about inventing an approach to using interfaces and also an approach to concurrency. Go routines are identical to Haskell threads and interfaces are very similar to Haskell typeclasses (now that they support generic arguments). Haskell&#x27;s preceded Go- it&#x27;s interesting to see procedural programmers independently discover the power of ideas from functional programming.<p>Go&#x27;s one language innovation is to not require an interface implementation to declare the interface it implements. This is awful from a safety perspective but in practice it causes few issues and gets rid of awful circular dependency issues experienced in Haskell and now Rust.<p>[1] <a href="https:&#x2F;&#x2F;cacm.acm.org&#x2F;magazines&#x2F;2022&#x2F;5&#x2F;260357-the-go-programming-language-and-environment&#x2F;fulltext" rel="nofollow">https:&#x2F;&#x2F;cacm.acm.org&#x2F;magazines&#x2F;2022&#x2F;5&#x2F;260357-the-go-programm...</a></div><br/><div id="38875565" class="c"><input type="checkbox" id="c-38875565" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#38875061">parent</a><span>|</span><a href="#38876614">next</a><span>|</span><label class="collapse" for="c-38875565">[-]</label><label class="expand" for="c-38875565">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re understating how important the fact that interfaces are structurally typed is to the overall effect of the feature on the language and—even more—its idioms and ecosystem.<p>Go would be a deeply different language if types had to declare the interfaces they implement ahead of time. It&#x27;s one of Go&#x27;s main distinguishing features (or at least was until TypeScript came out and also had structurally typed inferfaces, for different reasons).</div><br/></div></div><div id="38876614" class="c"><input type="checkbox" id="c-38876614" checked=""/><div class="controls bullet"><span class="by">shakow</span><span>|</span><a href="#38875061">parent</a><span>|</span><a href="#38875565">prev</a><span>|</span><a href="#38875868">next</a><span>|</span><label class="collapse" for="c-38876614">[-]</label><label class="expand" for="c-38876614">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Go&#x27;s one language innovation<p>Structural typing is already more than 25 y.o., and was already used e.g. in OCaml and Scala.</div><br/></div></div><div id="38875868" class="c"><input type="checkbox" id="c-38875868" checked=""/><div class="controls bullet"><span class="by">hota_mazi</span><span>|</span><a href="#38875061">parent</a><span>|</span><a href="#38876614">prev</a><span>|</span><a href="#38876017">next</a><span>|</span><label class="collapse" for="c-38875868">[-]</label><label class="expand" for="c-38875868">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Go&#x27;s one language innovation is to not require an interface implementation to declare the interface it implements.<p>Uh? How is that innovation? 100% of mainstream languages that I can think of that predate Go do this.<p>Can you name one programming language that we should care about which, once you define an interface, FORCES YOU to provide an implementation of said interface?</div><br/><div id="38876454" class="c"><input type="checkbox" id="c-38876454" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38875061">root</a><span>|</span><a href="#38875868">parent</a><span>|</span><a href="#38876266">next</a><span>|</span><label class="collapse" for="c-38876454">[-]</label><label class="expand" for="c-38876454">[1 more]</label></div><br/><div class="children"><div class="content">The point is that in most languages something doesn&#x27;t implement an interface unless it declares that it does so; in Java or C# if you don&#x27;t explicitly write &quot;extends Writer&quot; then your type doesn&#x27;t implement Writer, even if you implemented all the methods of Writer. Whereas Go offers something similar to e.g. Python&#x27;s behaviour where things are &quot;duck typed&quot;: you don&#x27;t have to explicitly reference a particular interface, you just implement the right methods. Of course in (traditional) Python that works because the language doesn&#x27;t have real (&quot;static&quot;) types at all. Having &quot;static duck typing&quot; is pretty rare - TypeScript now has it (and Python itself sort of has it), but when Go did it it was something that was pretty much new for mainstream languages.<p>(IMO it&#x27;s a misfeature; having explicit interfaces communicates intent and allows you to do things like AutoCloseable vs Closeable in Java - but that&#x27;s a matter of judgement)</div><br/></div></div><div id="38876266" class="c"><input type="checkbox" id="c-38876266" checked=""/><div class="controls bullet"><span class="by">mb7733</span><span>|</span><a href="#38875061">root</a><span>|</span><a href="#38875868">parent</a><span>|</span><a href="#38876454">prev</a><span>|</span><a href="#38876017">next</a><span>|</span><label class="collapse" for="c-38876266">[-]</label><label class="expand" for="c-38876266">[1 more]</label></div><br/><div class="children"><div class="content">I think you misread the sentence you quoted.</div><br/></div></div></div></div></div></div><div id="38876017" class="c"><input type="checkbox" id="c-38876017" checked=""/><div class="controls bullet"><span class="by">oconnor663</span><span>|</span><a href="#38875061">prev</a><span>|</span><a href="#38874888">next</a><span>|</span><label class="collapse" for="c-38876017">[-]</label><label class="expand" for="c-38876017">[2 more]</label></div><br/><div class="children"><div class="content">The post mentioned a few things that Go has done that seem to be &quot;obvious&quot; choices today:<p>- automatic formatting<p>- unified tooling<p>- module&#x2F;library support<p>I&#x27;d add more items to that list, which aren&#x27;t unique to Go of course, but where Go has clearly contributed to the new consensus:<p>- composition over inheritance<p>- compiling to native binaries<p>- error values over exceptions<p>- array slicing<p>- no automatic integer type conversions<p>There&#x27;s plenty I don&#x27;t like about Go, and I rant about it sometimes, but I also respect it. It moved the art forward.<p>...now can I please compile my code with unused variables when I&#x27;m deliberately trying to make my tests fail? :-D</div><br/><div id="38876054" class="c"><input type="checkbox" id="c-38876054" checked=""/><div class="controls bullet"><span class="by">pitaj</span><span>|</span><a href="#38876017">parent</a><span>|</span><a href="#38874888">next</a><span>|</span><label class="collapse" for="c-38876054">[-]</label><label class="expand" for="c-38876054">[1 more]</label></div><br/><div class="children"><div class="content">Interestingly, all of those (except for automatic formatting) also apply equally to Rust. Maybe that&#x27;s why there&#x27;s such a &quot;Go vs Rust&quot; culture.</div><br/></div></div></div></div><div id="38874888" class="c"><input type="checkbox" id="c-38874888" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#38876017">prev</a><span>|</span><a href="#38874721">next</a><span>|</span><label class="collapse" for="c-38874888">[-]</label><label class="expand" for="c-38874888">[2 more]</label></div><br/><div class="children"><div class="content">This mentions gofmt as a &quot;what we got right&quot; and I think that&#x27;s especially worth underscoring.<p>This seems to many language inventors and proponents like a small thing but it delivers huge value because it eliminates one common bike shedding opportunity entirely from day zero of a Go project. I&#x27;ve seen several newer languages embrace this, either copying it quite intentionally or just figuring hey Go has one so we should make one as well.<p>I&#x27;ve seen some pretty weird formatting rules but I have <i>very rarely</i> seen rules I couldn&#x27;t get used to, whereas I have worked on plenty of codebases without enforced formatting rules where as a result it was harder to understand the code.</div><br/><div id="38874905" class="c"><input type="checkbox" id="c-38874905" checked=""/><div class="controls bullet"><span class="by">onionisafruit</span><span>|</span><a href="#38874888">parent</a><span>|</span><a href="#38874721">next</a><span>|</span><label class="collapse" for="c-38874905">[-]</label><label class="expand" for="c-38874905">[1 more]</label></div><br/><div class="children"><div class="content">I have a tendency to futz around with code formatting. I like that go fmt makes that moot for the most part.</div><br/></div></div></div></div><div id="38874721" class="c"><input type="checkbox" id="c-38874721" checked=""/><div class="controls bullet"><span class="by">MaKey</span><span>|</span><a href="#38874888">prev</a><span>|</span><a href="#38875361">next</a><span>|</span><label class="collapse" for="c-38874721">[-]</label><label class="expand" for="c-38874721">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t seen someone mentioning Go&#x27;s issues with crypto yet. After OpenSSH deprecated SHA1, the Go team took a year (!) to add support for SHA2 to x&#x2F;crypto&#x2F;ssh [1]. Gitea was one famous victim [2]. Furthermore it doesn&#x27;t instill confidence to see a crypto maintainer bashing on GnuPG [3] and trying to discredit Dan Bernstein [4].<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;49269">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;49269</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;go-gitea&#x2F;gitea&#x2F;issues&#x2F;17798">https:&#x2F;&#x2F;github.com&#x2F;go-gitea&#x2F;gitea&#x2F;issues&#x2F;17798</a><p>[3]: <a href="https:&#x2F;&#x2F;twitter.com&#x2F;FiloSottile&#x2F;status&#x2F;1127643698676797441" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;FiloSottile&#x2F;status&#x2F;1127643698676797441</a><p>[4]: <a href="https:&#x2F;&#x2F;twitter.com&#x2F;FiloSottile&#x2F;status&#x2F;1555669786826244096" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;FiloSottile&#x2F;status&#x2F;1555669786826244096</a></div><br/></div></div><div id="38875361" class="c"><input type="checkbox" id="c-38875361" checked=""/><div class="controls bullet"><span class="by">vrnvu</span><span>|</span><a href="#38874721">prev</a><span>|</span><a href="#38873289">next</a><span>|</span><label class="collapse" for="c-38875361">[-]</label><label class="expand" for="c-38875361">[7 more]</label></div><br/><div class="children"><div class="content">The biggest win for Go is its approach based on composition rather than inheritance.<p>There isn’t any “architect engineer” building cathedrals with interfaces and abstract classes. There’s no cult behind needing to follow DDD in an event-driven architecture powered by a hexagonal architecture in all projects, or you are tagged as a bad engineer. We don’t have thousands of traits to define every possible code interaction, yes. From a type system point of view, Go is lacking compared to HM based type system, yes. Yes, it’s all pros and cons with this decision. We can agree on that.<p>I’ve seen that the predominant enemy for a software project is software engineers. Go keeps them in line for the sake of the project.</div><br/><div id="38876474" class="c"><input type="checkbox" id="c-38876474" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38875361">parent</a><span>|</span><a href="#38875637">next</a><span>|</span><label class="collapse" for="c-38876474">[-]</label><label class="expand" for="c-38876474">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There isn’t any “architect engineer” building cathedrals with interfaces and abstract classes. There’s no cult behind needing to follow DDD in an event-driven architecture powered by a hexagonal architecture in all projects, or you are tagged as a bad engineer.<p>Isn&#x27;t Go the big driver of Kubernetes? It feels like overarchitecturing is still there in Go projects, they&#x27;ve just made it distributed.</div><br/><div id="38876929" class="c"><input type="checkbox" id="c-38876929" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#38875361">root</a><span>|</span><a href="#38876474">parent</a><span>|</span><a href="#38876955">next</a><span>|</span><label class="collapse" for="c-38876929">[-]</label><label class="expand" for="c-38876929">[1 more]</label></div><br/><div class="children"><div class="content">(Anecdote up to the eyeballs)<p>I’ve read comments from people before about how go’s lack of generics has caused significant amounts of extra code to be written in the K8s codebase. I do wonder if we could snap our fingers and magically have a K8s written in Rust, a lisp, Zig tomorrow, what that would look like, what it would be like to maintain and build and what the codebases would be like in comparison. Would make an interesting intellectual exercise.</div><br/></div></div><div id="38876955" class="c"><input type="checkbox" id="c-38876955" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#38875361">root</a><span>|</span><a href="#38876474">parent</a><span>|</span><a href="#38876929">prev</a><span>|</span><a href="#38875637">next</a><span>|</span><label class="collapse" for="c-38876955">[-]</label><label class="expand" for="c-38876955">[1 more]</label></div><br/><div class="children"><div class="content">Kubernetes is a complex behemoth, and would be even if it was written in another language.</div><br/></div></div></div></div><div id="38875637" class="c"><input type="checkbox" id="c-38875637" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#38875361">parent</a><span>|</span><a href="#38876474">prev</a><span>|</span><a href="#38875833">next</a><span>|</span><label class="collapse" for="c-38875637">[-]</label><label class="expand" for="c-38875637">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; There isn’t any “architect engineer” building cathedrals with interfaces and abstract classes. There’s no cult behind needing to follow DDD in an event-driven architecture powered by a hexagonal architecture in all projects, or you are tagged as a bad engineer.</i><p>My experience is that you can also write simple non-over-engineered code in other languages too. Yes, it can require pushing against the wind of the prevailing culture sometimes but it&#x27;s not, like, impossible.</div><br/></div></div><div id="38875833" class="c"><input type="checkbox" id="c-38875833" checked=""/><div class="controls bullet"><span class="by">campbel</span><span>|</span><a href="#38875361">parent</a><span>|</span><a href="#38875637">prev</a><span>|</span><a href="#38875756">next</a><span>|</span><label class="collapse" for="c-38875833">[-]</label><label class="expand" for="c-38875833">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I’ve seen that the predominant enemy for a software project is software engineers. Go keeps them in line for the sake of the project.<p>Brilliant</div><br/></div></div><div id="38875756" class="c"><input type="checkbox" id="c-38875756" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#38875361">parent</a><span>|</span><a href="#38875833">prev</a><span>|</span><a href="#38873289">next</a><span>|</span><label class="collapse" for="c-38875756">[-]</label><label class="expand" for="c-38875756">[1 more]</label></div><br/><div class="children"><div class="content">If one chunk of code depends upon one and only one other chunk of code, then forcing the programmer to put an interface between them for unit testing does a disservice to the programmer.<p>I really do prefer languages that make it easy to write unit tests.</div><br/></div></div></div></div><div id="38873289" class="c"><input type="checkbox" id="c-38873289" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38875361">prev</a><span>|</span><a href="#38876858">next</a><span>|</span><label class="collapse" for="c-38873289">[-]</label><label class="expand" for="c-38873289">[10 more]</label></div><br/><div class="children"><div class="content">Interesting bit here about the decision to use Ken Thompson&#x27;s C compiler rather than LLVM --- something that people grumbled about, and that resulted in (especially earlier versions) less optimal generated code. The flip side of that decision is that they were able to do segmented stacks quickly; they might not have done them at all if they&#x27;d had to implement them in LLVM and fit the LLVM ABI.<p>(He cites this as an example of the benefit of that decision, not the only benefit).</div><br/><div id="38873462" class="c"><input type="checkbox" id="c-38873462" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#38873289">parent</a><span>|</span><a href="#38873492">next</a><span>|</span><label class="collapse" for="c-38873462">[-]</label><label class="expand" for="c-38873462">[8 more]</label></div><br/><div class="children"><div class="content">That part of the interview is incorrect about LLVM. I implemented segmented stacks via LLVM for Rust. It&#x27;s actually pretty easy, because there is support for them in X86FrameLowering already (and it was there at the time of Go&#x27;s release too). If you enable stack segmentation, then LLVM emits checks in the function prolog to call into __morestack to allocate more stack as needed. (The Windows MSVC ABI needs very similar code in order to support _chkstk, which is a requirement on that platform, so the __morestack support goes naturally together with it.)<p>Actually, getting GDB to understand segmented stacks was harder than any part of the compiler implementation. That&#x27;s independent of the backend.<p>What I think the author might be confusing it with is <i>relocatable</i> stacks. That <i>was</i> hard to implement at the time, because it requires precise GC, though Azul has implemented it now in LLVM. Back then, the easiest way to implement precise GC would have been to spill all registers across function calls, which requires some more implementation effort, though not an inordinate amount. (Note that I think the Plan 9 compiler does this anyway, so that wouldn&#x27;t be a performance regression over 6g&#x2F;8g.) In any case, Azul&#x27;s GC support now has the proper implementation which allows roots to be stored in registers.</div><br/><div id="38873978" class="c"><input type="checkbox" id="c-38873978" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#38873289">root</a><span>|</span><a href="#38873462">parent</a><span>|</span><a href="#38873492">next</a><span>|</span><label class="collapse" for="c-38873978">[-]</label><label class="expand" for="c-38873978">[7 more]</label></div><br/><div class="children"><div class="content">&gt; is incorrect about LLVM.<p>He didn&#x27;t say it was not possible,  but that it would have required too much effort in modifying the ABI and the garbage collector.<p>&gt; because it requires precise GC<p>Which is why they avoided LLVM for a much smaller and easier to manipulate existing compiler.  Their point is that it would have slowed things down too much to even try it inside someone else&#x27;s project.  Sometimes &quot;roll your own&quot; is the best idea.</div><br/><div id="38874062" class="c"><input type="checkbox" id="c-38874062" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#38873289">root</a><span>|</span><a href="#38873978">parent</a><span>|</span><a href="#38873492">next</a><span>|</span><label class="collapse" for="c-38874062">[-]</label><label class="expand" for="c-38874062">[6 more]</label></div><br/><div class="children"><div class="content">&gt; He didn&#x27;t say it was not possible, but that it would have required too much effort in modifying the ABI and the garbage collector.<p>__morestack doesn&#x27;t really have an ABI. It&#x27;s just a call to an address emitted in the function prolog. LLVM and 6g&#x2F;8g emit calls to it the exact same way. I suppose you could consider the stack limit part of the ABI, but it&#x27;s trivial: it&#x27;s just [gs:0x18] or something like that (also it is trivial to change in LLVM).<p>The garbage collector is irrelevant here as the GC only needs to be able to unwind the stack and find metadata. Only the runtime implementation of __morestack has any effect on this; the compiler isn&#x27;t involved at all.<p>&gt; Which is why they avoided LLVM for a much smaller and easier to manipulate existing compiler. Their point is that it would have slowed things down too much to even try it inside someone else&#x27;s project.<p>I was suggesting that Rob Pike possibly confused segmented stacks with relocatable stacks. Segmented stacks have only minimal interaction with the GC, while relocatable stacks have major interaction.<p>Assuming good faith, either (1) Rob misremembered the problem being relocatable stacks instead of segmented stacks; or (2) the Go team didn&#x27;t realize that LLVM had segmented stack support, so this part of the reasoning was mistaken. (Not saying there weren&#x27;t other reasons; I&#x27;m only talking about this specific one.)</div><br/><div id="38874121" class="c"><input type="checkbox" id="c-38874121" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#38873289">root</a><span>|</span><a href="#38874062">parent</a><span>|</span><a href="#38873492">next</a><span>|</span><label class="collapse" for="c-38874121">[-]</label><label class="expand" for="c-38874121">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Segmented stacks have only minimal interaction with the GC, while relocatable stacks have major interaction.<p>Okay..  this is where I&#x27;m losing your argument.  Can you quantify the difference here between &#x27;minimal&#x27; and &#x27;major&#x27; from the 2012 perspective this was framed in?</div><br/><div id="38874327" class="c"><input type="checkbox" id="c-38874327" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#38873289">root</a><span>|</span><a href="#38874121">parent</a><span>|</span><a href="#38873492">next</a><span>|</span><label class="collapse" for="c-38874327">[-]</label><label class="expand" for="c-38874327">[4 more]</label></div><br/><div class="children"><div class="content">The GC needs to unwind the stack to find roots. The only difference between segmented stacks and contiguous stacks as far as unwinding the stack is concerned is that in segmented stacks the stack pointer isn&#x27;t monotonically increasing as you go up. This is usually not a problem. (The only time I&#x27;ve seen it be a problem is in GDB, where some versions have a &quot;stack corruption check&quot; that ensures that the stack pointer is monotonically increasing and assumes the stack has been corrupted if it isn&#x27;t. To make such versions of GDB compatible with segmented stacks, you just need to remove that check.)<p>Relocatable stacks are a different beast. With relocatable stacks, pointers into the stack move when the stack resizes. This means that you must be able to find those pointers, which may be anywhere in the stack or the heap, and update them. The garbage collector already knows how to do that--walking the heap is its job, after all--so typically resizable stacks are implemented by having the stack resizing machinery call into the GC to perform the pointer updates.<p>Note that, as an alternative implementation of relocatable stacks, you can simply forbid pointers into the stack. This means that your GC doesn&#x27;t need to be moving. I believe that&#x27;s what Go does, as as far as I&#x27;m aware Go doesn&#x27;t have moving GC (though I&#x27;m not up to date and very much could be wrong here). This doesn&#x27;t help Pike&#x27;s argument, though, because in that scenario the impact of relocatable stacks on the GC is much less.<p>As an aside, in my view the legitimate reasons to not use LLVM would have been (1) compile times and (2) that precise GC, which Go didn&#x27;t ship with but which was added not too long thereafter, was hard in LLVM at the time due to SelectionDAG and lower layers losing the difference between integer and pointer.</div><br/><div id="38875648" class="c"><input type="checkbox" id="c-38875648" checked=""/><div class="controls bullet"><span class="by">typical182</span><span>|</span><a href="#38873289">root</a><span>|</span><a href="#38874327">parent</a><span>|</span><a href="#38874490">next</a><span>|</span><label class="collapse" for="c-38875648">[-]</label><label class="expand" for="c-38875648">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you can simply forbid pointers into the stack. This means that your GC doesn&#x27;t need to be moving. I believe that&#x27;s what Go does<p>I might have misunderstood your comment, but FWIW, Go does allow pointers into the stack from the stack.<p>When resizing&#x2F;moving&#x2F;copying a stack, the Go runtime does indeed find those pointers (via a stack map) and adjust them to point to the new stack locations. For example:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;b25f5558c69140deb652337afaab5c1186cd0ff1&#x2F;src&#x2F;runtime&#x2F;stack.go#L678-L684">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;b25f5558c69140deb652337afa...</a><p>(The growable stacks I think replaced the segmented stacks circa Go 1.3 or so; I can&#x27;t speak to whether they were contemplating growable stacks in the early days whilst considering whether to start their project with the Plan 9 toolchain, LLVM, or GCC, but to your broader point, they were likely considering multiple factors, including how quickly they could adapt the Plan 9 toolchain).</div><br/></div></div><div id="38874490" class="c"><input type="checkbox" id="c-38874490" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38873289">root</a><span>|</span><a href="#38874327">parent</a><span>|</span><a href="#38875648">prev</a><span>|</span><a href="#38873492">next</a><span>|</span><label class="collapse" for="c-38874490">[-]</label><label class="expand" for="c-38874490">[2 more]</label></div><br/><div class="children"><div class="content">&gt; SelectionDAG and lower layers losing the difference between integer and pointer<p>Doesn&#x27;t pointer-provenance support address this point nowadays?  AIUI, a barebones version of what amounts to provenance (&quot;pointer safety&quot; IIRC) was even included in the C++ standard as a gesture towards GC support.  It&#x27;s been removed from the upcoming version of the standard, having become redundant.</div><br/><div id="38874550" class="c"><input type="checkbox" id="c-38874550" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#38873289">root</a><span>|</span><a href="#38874490">parent</a><span>|</span><a href="#38873492">next</a><span>|</span><label class="collapse" for="c-38874550">[-]</label><label class="expand" for="c-38874550">[1 more]</label></div><br/><div class="children"><div class="content">I think CHERI addresses the issue, but I don&#x27;t know how much of that is in upstream LLVM. Pointer provenance as used for optimization mostly affects the IR-level optimizations, not CodeGen ones.<p>In any case, Azul&#x27;s work addresses the GC metadata problem nowadays.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="38873492" class="c"><input type="checkbox" id="c-38873492" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#38873289">parent</a><span>|</span><a href="#38873462">prev</a><span>|</span><a href="#38876858">next</a><span>|</span><label class="collapse" for="c-38873492">[-]</label><label class="expand" for="c-38873492">[1 more]</label></div><br/><div class="children"><div class="content">They eventually moved away from segmented stacks, right?  In Go 1.3, released 2014.  (Due to the &quot;hot spot&quot; issue.[1])  So while the ability to experiment was valuable, this specific example is not, like, perfect.<p>[1]: <a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;go1.3#:~:text=Go%201.3%20has%20changed%20the%20implementation%20of%20goroutine%20stacks%20away%20from%20the%20old%2C%20%E2%80%9Csegmented%E2%80%9D%20model%20to%20a%20contiguous%20model" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;go1.3#:~:text=Go%201.3%20has%20changed%20...</a></div><br/></div></div></div></div><div id="38876858" class="c"><input type="checkbox" id="c-38876858" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#38873289">prev</a><span>|</span><a href="#38873488">next</a><span>|</span><label class="collapse" for="c-38876858">[-]</label><label class="expand" for="c-38876858">[1 more]</label></div><br/><div class="children"><div class="content">&gt; First, he was generalizing beyond the domain he was interested in [...]<p>And then they proceed to dump on async&#x2F;await.  It&#x27;s not a target concern for Go but often you want to run code specifically on a UI thread or call into a foreign function on some specific OS thread.  AFAICT that&#x27;s most easily done with async&#x2F;await.</div><br/></div></div><div id="38873488" class="c"><input type="checkbox" id="c-38873488" checked=""/><div class="controls bullet"><span class="by">chewxy</span><span>|</span><a href="#38876858">prev</a><span>|</span><a href="#38876470">next</a><span>|</span><label class="collapse" for="c-38873488">[-]</label><label class="expand" for="c-38873488">[1 more]</label></div><br/><div class="children"><div class="content">GopherConAU organizer here. Here&#x27;s the whole playlist. I am not sure why I cannot make it public. <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;playlist?list=PLN_36A3Rw5hFsJqqs7olOAxxU-WJGlXS0" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;playlist?list=PLN_36A3Rw5hFsJqqs7olO...</a></div><br/></div></div><div id="38876470" class="c"><input type="checkbox" id="c-38876470" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#38873488">prev</a><span>|</span><a href="#38877015">next</a><span>|</span><label class="collapse" for="c-38876470">[-]</label><label class="expand" for="c-38876470">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And of course, today there is an LLVM-hosted compiler for Go, and many others, as there should be.<p>Isn&#x27;t that the dead llgo effort?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;go-llvm&#x2F;llgo">https:&#x2F;&#x2F;github.com&#x2F;go-llvm&#x2F;llgo</a>  (now archived)<p>Its readme points to a dead link on the LLVM website, and it looks like there&#x27;s no matching Go project under the LLVM org.<p>Does anyone know if there really is still a working LLVM based Go toolchain (other than TinyGo)?</div><br/></div></div><div id="38877015" class="c"><input type="checkbox" id="c-38877015" checked=""/><div class="controls bullet"><span class="by">pharmakom</span><span>|</span><a href="#38876470">prev</a><span>|</span><a href="#38874535">next</a><span>|</span><label class="collapse" for="c-38877015">[-]</label><label class="expand" for="c-38877015">[1 more]</label></div><br/><div class="children"><div class="content">I am not a Go user and the language has never appealed to me. On paper, it offers less than more established ecosystems for generalist backend development, such as C# and Java.<p>Perhaps some Go users can weigh in?</div><br/></div></div><div id="38874535" class="c"><input type="checkbox" id="c-38874535" checked=""/><div class="controls bullet"><span class="by">leafmeal</span><span>|</span><a href="#38877015">prev</a><span>|</span><a href="#38873155">next</a><span>|</span><label class="collapse" for="c-38874535">[-]</label><label class="expand" for="c-38874535">[5 more]</label></div><br/><div class="children"><div class="content">Maybe I&#x27;m misunderstanding here, but it sounds like he&#x27;s claiming they invented &quot;interfaces&quot;. The Go interfaces seem like the same thing as a Haskell typeclass which predates them by a long shot. Either way a great invention that should be in more languages.</div><br/><div id="38874932" class="c"><input type="checkbox" id="c-38874932" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#38874535">parent</a><span>|</span><a href="#38875462">next</a><span>|</span><label class="collapse" for="c-38874932">[-]</label><label class="expand" for="c-38874932">[3 more]</label></div><br/><div class="children"><div class="content">The early days of Go appeared to be the work of a group of people who had not ventured out of their bubble in a very long time and were unaware of several decades of PL research, so it would be somewhat surprising if any of them knew what a typeclass was at the time.<p>This is significantly less true now.</div><br/><div id="38875002" class="c"><input type="checkbox" id="c-38875002" checked=""/><div class="controls bullet"><span class="by">LispSporks22</span><span>|</span><a href="#38874535">root</a><span>|</span><a href="#38874932">parent</a><span>|</span><a href="#38875462">next</a><span>|</span><label class="collapse" for="c-38875002">[-]</label><label class="expand" for="c-38875002">[2 more]</label></div><br/><div class="children"><div class="content">As I recall the Go GC is a primitive 70s design as well. No idea if it still is.</div><br/><div id="38875956" class="c"><input type="checkbox" id="c-38875956" checked=""/><div class="controls bullet"><span class="by">geodel</span><span>|</span><a href="#38874535">root</a><span>|</span><a href="#38875002">parent</a><span>|</span><a href="#38875462">next</a><span>|</span><label class="collapse" for="c-38875956">[-]</label><label class="expand" for="c-38875956">[1 more]</label></div><br/><div class="children"><div class="content">No, it went back to 30s now.</div><br/></div></div></div></div></div></div><div id="38875462" class="c"><input type="checkbox" id="c-38875462" checked=""/><div class="controls bullet"><span class="by">philosopher1234</span><span>|</span><a href="#38874535">parent</a><span>|</span><a href="#38874932">prev</a><span>|</span><a href="#38873155">next</a><span>|</span><label class="collapse" for="c-38875462">[-]</label><label class="expand" for="c-38875462">[1 more]</label></div><br/><div class="children"><div class="content">Go interfaces are unique in that they are implicit. Duck typed, if you will. That is not present in Haskell.</div><br/></div></div></div></div><div id="38873155" class="c"><input type="checkbox" id="c-38873155" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#38874535">prev</a><span>|</span><a href="#38873672">next</a><span>|</span><label class="collapse" for="c-38873155">[-]</label><label class="expand" for="c-38873155">[1 more]</label></div><br/><div class="children"><div class="content">Something that I really like about go is how easy it is to make a monorepo, and how quick and easy it is to build all of the contained apps (go build .&#x2F;...).<p>I also find it really easy to make CLI tools in Go that can form part of unix pipelines, since: you just need a single go file and app-named folder to get started, it gives you a self-contained binary as output, and the Reader&#x2F;Writer interfaces make it easy to stream and handle data line-by-line. We have a couple of CLIs at work that analyze multi-gig logs in a couple of seconds for common error patterns - Go is very handy for such things.</div><br/></div></div><div id="38873672" class="c"><input type="checkbox" id="c-38873672" checked=""/><div class="controls bullet"><span class="by">robaato</span><span>|</span><a href="#38873155">prev</a><span>|</span><a href="#38873373">next</a><span>|</span><label class="collapse" for="c-38873672">[-]</label><label class="expand" for="c-38873672">[3 more]</label></div><br/><div class="children"><div class="content">Curious as to no mention of the choices around interoperability and C FFI.<p>&quot;Rewrite in go&quot; as the answer closes off a whole chunk of options.</div><br/><div id="38873932" class="c"><input type="checkbox" id="c-38873932" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#38873672">parent</a><span>|</span><a href="#38875175">next</a><span>|</span><label class="collapse" for="c-38873932">[-]</label><label class="expand" for="c-38873932">[1 more]</label></div><br/><div class="children"><div class="content">That was the Java solution as well circa late 1990&#x27;s.  But in many cases that&#x27;s true of python, and other languages.<p>It&#x27;s just easier if you can install a native library rather than one with a cumbersome build process.</div><br/></div></div><div id="38875175" class="c"><input type="checkbox" id="c-38875175" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38873672">parent</a><span>|</span><a href="#38873932">prev</a><span>|</span><a href="#38873373">next</a><span>|</span><label class="collapse" for="c-38875175">[-]</label><label class="expand" for="c-38875175">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps because there isn&#x27;t just one choice? The Go team maintains two compilers, and each treat that interoperability differently. You have even more options if you reach out into the larger Go ecosystem (e.g. tinygo does things differently again).</div><br/></div></div></div></div><div id="38873373" class="c"><input type="checkbox" id="c-38873373" checked=""/><div class="controls bullet"><span class="by">statquontrarian</span><span>|</span><a href="#38873672">prev</a><span>|</span><a href="#38873707">next</a><span>|</span><label class="collapse" for="c-38873373">[-]</label><label class="expand" for="c-38873373">[2 more]</label></div><br/><div class="children"><div class="content">I was surprised at the poor quality of serviceability given its enterprise deployment with k8s. No thread dumps without killing the process (or writing a SIGUSR1 handler). No heapdump reader so you have to use the memory sampler and hope you catch the problem (and that requires adding code), and viewcore is broken in new versions (and it doesn&#x27;t work with a stripped binary which is most production binaries).</div><br/></div></div><div id="38873707" class="c"><input type="checkbox" id="c-38873707" checked=""/><div class="controls bullet"><span class="by">msie</span><span>|</span><a href="#38873373">prev</a><span>|</span><a href="#38874285">next</a><span>|</span><label class="collapse" for="c-38873707">[-]</label><label class="expand" for="c-38873707">[1 more]</label></div><br/><div class="children"><div class="content">I appreciate that he talked about examples in api documentation. I can&#x27;t believe people are still writing documentation nowadays without examples.</div><br/></div></div><div id="38874285" class="c"><input type="checkbox" id="c-38874285" checked=""/><div class="controls bullet"><span class="by">4death4</span><span>|</span><a href="#38873707">prev</a><span>|</span><a href="#38874518">next</a><span>|</span><label class="collapse" for="c-38874285">[-]</label><label class="expand" for="c-38874285">[1 more]</label></div><br/><div class="children"><div class="content">The anecdote about writing the compiler in C is very interesting. LLVM is obviously very popular these days, so it’s refreshing to see a counter example. I also love that the compiler was decidedly mediocre. It just goes to show that often the user ((or developer) experience is typically more important than the technical merits of a product.</div><br/></div></div><div id="38874518" class="c"><input type="checkbox" id="c-38874518" checked=""/><div class="controls bullet"><span class="by">norir</span><span>|</span><a href="#38874285">prev</a><span>|</span><a href="#38872709">next</a><span>|</span><label class="collapse" for="c-38874518">[-]</label><label class="expand" for="c-38874518">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Also, writing a compiler in its own language, while simultaneously developing the language, tends to result in a language that is good for writing compilers, but that was not the kind of language we were after.<p>I have seen this sentiment a few times recently. First of all, it raises the question is a language that is not compiled in itself a bad language for writing compilers? My intuition is usually yes. Secondly, the implication is that a good language for compilers will not be good for other applications. I really don&#x27;t understand this because a compiler will use most of the same building blocks that are used for other programs.<p>I would really like more context into what the author is trying to say though.</div><br/><div id="38875650" class="c"><input type="checkbox" id="c-38875650" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#38874518">parent</a><span>|</span><a href="#38875345">next</a><span>|</span><label class="collapse" for="c-38875650">[-]</label><label class="expand" for="c-38875650">[2 more]</label></div><br/><div class="children"><div class="content">For what it&#x27;s worth, Dart&#x27;s intended domain (client UI apps) is much farther from compilers than Go&#x27;s intended domain (servers and &quot;systems programming&quot;) but we write almost all of our tools and compilers in Dart.<p>Dart isn&#x27;t always the <i>best</i> language for compilers (we have a lot of Visitor patterns floating around, which are always tedious), but it&#x27;s plenty good enough and it keeps the whole team working in our own language eight hours a day, which I think is invaluable.<p>Also, it means that when we make our implementations or compilers faster, we get a compounding effect because our tools get faster too.</div><br/><div id="38876095" class="c"><input type="checkbox" id="c-38876095" checked=""/><div class="controls bullet"><span class="by">jtasdlfj234</span><span>|</span><a href="#38874518">root</a><span>|</span><a href="#38875650">parent</a><span>|</span><a href="#38875345">next</a><span>|</span><label class="collapse" for="c-38876095">[-]</label><label class="expand" for="c-38876095">[1 more]</label></div><br/><div class="children"><div class="content">Dart evolved into a nice language with null-safety and exhaustive patterns.<p>Hopefully in Go 3, we could see these features added as well.</div><br/></div></div></div></div><div id="38875345" class="c"><input type="checkbox" id="c-38875345" checked=""/><div class="controls bullet"><span class="by">tmerr</span><span>|</span><a href="#38874518">parent</a><span>|</span><a href="#38875650">prev</a><span>|</span><a href="#38874899">next</a><span>|</span><label class="collapse" for="c-38875345">[-]</label><label class="expand" for="c-38875345">[1 more]</label></div><br/><div class="children"><div class="content">The ideal set of building blocks depends on the problem.<p>If the building blocks make it easy to write concurrent code (Go, Erlang), then it becomes easier to write a server. If they make it easy to represent &quot;A or B or C&quot; and pattern match on trees (ML-like languages), then it becomes easier to write a compiler.<p>Add to that: if you are trying to make an easy to onboard language, you want to look at how beginners use it, not experts. Someone writing a compiler for language X is certainly an expert in X.</div><br/></div></div><div id="38874899" class="c"><input type="checkbox" id="c-38874899" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#38874518">parent</a><span>|</span><a href="#38875345">prev</a><span>|</span><a href="#38872709">next</a><span>|</span><label class="collapse" for="c-38874899">[-]</label><label class="expand" for="c-38874899">[1 more]</label></div><br/><div class="children"><div class="content">Writing compilers is mostly aided by having a robust type-system and elegant tooling for parsers and AST transformation and so on.<p>Writing a compiler requires computer science knowledge, requires thought.<p>Haskell I think is a perfect example. It is a language that is well suited for writing compilers, but also very well suited for building services, backend applications, really anything if your developers are of average intelligence.<p>Go, however, wants to optimize for developers who think a for loop is easier to understand than an applicative functor, who think that generics are unnecessarily complex.<p>If you&#x27;re trying to build a language for &quot;the lowest common denominator, the average googler&quot;, that&#x27;s the opposite of building a language for compiler writers, so in that case building a language that can represent such a hard CS problem well is counter productive.</div><br/></div></div></div></div><div id="38872709" class="c"><input type="checkbox" id="c-38872709" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#38874518">prev</a><span>|</span><a href="#38873225">next</a><span>|</span><label class="collapse" for="c-38872709">[-]</label><label class="expand" for="c-38872709">[62 more]</label></div><br/><div class="children"><div class="content">This is a retrospective written by Rob Pike, one of the creators of the Go language.<p>I worked at Google at the time go was created and had coffee with Rob from time to time and got to understand the reasons Go was created.  Rob hates Bjarne Stroustrup and everything C++ (this goes back decades).  C++-as-used at Google (which used far more threads that he says) had definitely reached a point where it was extremely cumbersome to work with.<p>I can think of some other things that they got wrong.<p>For example, when I first started talking to Rob and his team about go, I pointed out that scientific computing in FORTRAN and C++ was a somewhat painful process and they had an opportunity to make a language that was great for high performance computing.  Not concurrent&#x2F;parallel servers, but the sorts of codes that HPC people run: heavily multi-threaded, heavily multi-machine, sophsticated algorithms, hairy numerical routines, and typically some sort of interface to a scripting language with a REPL.<p>The answers I got were: Go is a systems programming language, not for scientific computing (I believe they have now relaxed this opinion but the damage was already done).<p>And a REPL wasn&#x27;t necessary because Go compiled so quickly you could just write a program and run it (no, that misses the point of a repl, which is that it builds up state and lets you call new functions with that built-up state).<p>And scripting language integration was also not a desirable goal, because Go was  intended for you to write all your code in Go, rather than invoking FFIs.<p>A number of other folks who used Go in the early days inside Google complained: it was hard to call ioctl, which is often necessary for configuring system resources.  They got a big &quot;FU&quot; from the go team for quite some time.  IIUC ioctls are still fairly messy in Go (but I&#x27;m not an expert).<p>I think Go spent a lot of time implying that goroutines were some sort of special language magic, but I think everybody knows now that they are basically a really good implementation of green threads that can take advantage of some internal knowledge to do optimal scheduling to avoid context switches.  It took me a while to work this out, and I got a lot of pushback from the go team when I pointed this out internally.<p>IN short, I think go could have become a first-class HPC language but the go team alienated that community early on and lost the opportunity to take a large market share at a time when Python was exploding in ML.</div><br/><div id="38873230" class="c"><input type="checkbox" id="c-38873230" checked=""/><div class="controls bullet"><span class="by">rdtsc</span><span>|</span><a href="#38872709">parent</a><span>|</span><a href="#38872825">next</a><span>|</span><label class="collapse" for="c-38873230">[-]</label><label class="expand" for="c-38873230">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Go is a systems programming language,<p>I remember that being a meme of sorts. Most people understood that as a C&#x2F;C++ replacement with operating systems and drivers being written in Go. System programmers laughed, of course. Eventually when it didn&#x27;t look like it wasn&#x27;t going happen, the token reply from Go devs became &quot;Well not those kind of systems, we always meant a different kind of systems programming language, not what you all thought&quot;.</div><br/><div id="38877065" class="c"><input type="checkbox" id="c-38877065" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873230">parent</a><span>|</span><a href="#38875285">next</a><span>|</span><label class="collapse" for="c-38877065">[-]</label><label class="expand" for="c-38877065">[1 more]</label></div><br/><div class="children"><div class="content">rob pike&#x27;s definition of &#x27;systems software&#x27; from 02000 is in <a href="http:&#x2F;&#x2F;doc.cat-v.org&#x2F;bell_labs&#x2F;utah2000&#x2F;utah2000.html" rel="nofollow">http:&#x2F;&#x2F;doc.cat-v.org&#x2F;bell_labs&#x2F;utah2000&#x2F;utah2000.html</a><p>&gt; <i>Systems:
    Operating systems, networking, languages; the things that connect programs together.
Software:
    As you expect. (...) What is Systems Research these days?  Web caches, Web servers, file systems, network packet delays, all that stuff. Performance, peripherals, and applications, but not kernels or even user-level applications.</i><p>he goes into a lot more detail there on the things he sees in &#x27;systems software research&#x27;, and it goes pretty far beyond kernels and drivers.  this is not a definition he retconned onto golang in 02014 or, i would claim, a definition unique to him</div><br/></div></div><div id="38875285" class="c"><input type="checkbox" id="c-38875285" checked=""/><div class="controls bullet"><span class="by">sevagh</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873230">parent</a><span>|</span><a href="#38877065">prev</a><span>|</span><a href="#38872825">next</a><span>|</span><label class="collapse" for="c-38875285">[-]</label><label class="expand" for="c-38875285">[1 more]</label></div><br/><div class="children"><div class="content">From the same team that came up with the unique, searchable, and identifiable word &quot;Go&quot; for a programming language.</div><br/></div></div></div></div><div id="38872825" class="c"><input type="checkbox" id="c-38872825" checked=""/><div class="controls bullet"><span class="by">mattbee</span><span>|</span><a href="#38872709">parent</a><span>|</span><a href="#38873230">prev</a><span>|</span><a href="#38877034">next</a><span>|</span><label class="collapse" for="c-38872825">[-]</label><label class="expand" for="c-38872825">[10 more]</label></div><br/><div class="children"><div class="content">I think Java&#x27;s &quot;green&quot; threads only ran on a single core, a stop-gap for 90s machines that only had one.<p>Goroutines use OS threads, but only create one OS thread per core. Go does the scheduling internally on top of those few &quot;real&quot; threads.<p>Java itself now provides a goroutine-type model with Virtual Threads, but as the programmer you&#x27;ve got to ask for it.<p>Well, I just felt like &quot;green&quot; is a confusing moniker in that context.</div><br/><div id="38876671" class="c"><input type="checkbox" id="c-38876671" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38872825">parent</a><span>|</span><a href="#38873101">next</a><span>|</span><label class="collapse" for="c-38876671">[-]</label><label class="expand" for="c-38876671">[1 more]</label></div><br/><div class="children"><div class="content">Back when Java had green threads (the late 1990s), there was no such thing as &quot;multi-core machines&quot;. Some top-of-the-line servers had SMP (i.e. two or more <i>physical</i> processors running together on the same bus and sharing the same memory), but very few programs were built to take advantage that option yet.<p>So Java&#x27;s green threads was not a stop-gap for the 90s machine which only had one core. That&#x27;s preposterous. Does Go need to disable its goroutines to support the Raspberry Pi Zero that has only one core? Obviously not! The reason Java didn&#x27;t support multi-core scheduling is that multi-core processors still weren&#x27;t a thing, and SMP was too high-end for them to bother (and by the time they did start caring about high-end systems, they&#x27;ve already moved to kernel threads).<p>Nothing prevents green threads from supporting multi-core (Java 21&#x27;s Virtual Threads obviously do that, but Erlang&#x27;s processes also had SMP support well before Go).<p>I think the terms &quot;green threads&quot; or &quot;user-space threads&quot; are really not that confusing. Definitely not confusing enough to warrant inventing a new term like &quot;goroutines&quot;. <i>THAT</i> is confusing. I&#x27;m happy the Project Loom team resisted the urge to give the Virtual Threads a fun name like &quot;Jorutines&quot;.</div><br/></div></div><div id="38873101" class="c"><input type="checkbox" id="c-38873101" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38872825">parent</a><span>|</span><a href="#38876671">prev</a><span>|</span><a href="#38873884">next</a><span>|</span><label class="collapse" for="c-38873101">[-]</label><label class="expand" for="c-38873101">[7 more]</label></div><br/><div class="children"><div class="content">Goroutines use thread-per-core but run stackful fibers on top of that. (A similar model is sometimes known as &quot;Virtual Processors&quot; or &quot;Light-weight processes&quot;.) This is unlike the use of stackless async-await in other languages.  This peculiar use of fibers in Go is also what gets in the way of conventional C FFI and leads to quirks like cgo.</div><br/><div id="38873293" class="c"><input type="checkbox" id="c-38873293" checked=""/><div class="controls bullet"><span class="by">jtasdlfj234</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873101">parent</a><span>|</span><a href="#38873497">next</a><span>|</span><label class="collapse" for="c-38873293">[-]</label><label class="expand" for="c-38873293">[1 more]</label></div><br/><div class="children"><div class="content">Excellently described.<p>I&#x27;d love to see a resource that highlights these all on a table across programming languages as well as the associated strengths and weaknesses of such threading &amp; concurrency models.<p>Perhaps a ByteByteGo graphic, if you will.</div><br/></div></div><div id="38873497" class="c"><input type="checkbox" id="c-38873497" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873101">parent</a><span>|</span><a href="#38873293">prev</a><span>|</span><a href="#38873884">next</a><span>|</span><label class="collapse" for="c-38873497">[-]</label><label class="expand" for="c-38873497">[5 more]</label></div><br/><div class="children"><div class="content">In the future, I think thats what I&#x27;ll say.  Thanks.</div><br/><div id="38873526" class="c"><input type="checkbox" id="c-38873526" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873497">parent</a><span>|</span><a href="#38873884">next</a><span>|</span><label class="collapse" for="c-38873526">[-]</label><label class="expand" for="c-38873526">[4 more]</label></div><br/><div class="children"><div class="content">I usually just say that Go implements &quot;userspace threading&quot;, since that&#x27;s really what it is. Some early, pre-pthreads, implementations of Linux threads worked the same way as Go does and they usually called such implementations &quot;M:N&quot;, to indicate M userspace threads mapped onto N kernel threads, so &quot;M:N&quot; is a good descriptor too.</div><br/><div id="38873719" class="c"><input type="checkbox" id="c-38873719" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873526">parent</a><span>|</span><a href="#38873884">next</a><span>|</span><label class="collapse" for="c-38873719">[-]</label><label class="expand" for="c-38873719">[3 more]</label></div><br/><div class="children"><div class="content">but that&#x27;s not really accurate.  It uses system threads.  Userspace threading doesn&#x27;t make a transition to kernel (IIUC).</div><br/><div id="38873784" class="c"><input type="checkbox" id="c-38873784" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873719">parent</a><span>|</span><a href="#38873884">next</a><span>|</span><label class="collapse" for="c-38873784">[-]</label><label class="expand" for="c-38873784">[2 more]</label></div><br/><div class="children"><div class="content">Go doesn&#x27;t need to transition to the kernel to switch threads, does it? It just saves and loads the register state in userland.</div><br/><div id="38873871" class="c"><input type="checkbox" id="c-38873871" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873784">parent</a><span>|</span><a href="#38873884">next</a><span>|</span><label class="collapse" for="c-38873871">[-]</label><label class="expand" for="c-38873871">[1 more]</label></div><br/><div class="children"><div class="content">IIUC it can, sometimes, avoid a kernel transition when it knows it can schedule the recipient of a message, but I believe that golang creates a threadpool for running goroutines on platforms that use thread primitives.<p>From
<a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;c7d6c6000a84b61ac8bb2e38e855ad120914658a&#x2F;src&#x2F;runtime&#x2F;proc.go#L19">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;c7d6c6000a84b61ac8bb2e38e8...</a>
I believe &quot;worker threads&quot; are OS threads.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38873884" class="c"><input type="checkbox" id="c-38873884" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38872825">parent</a><span>|</span><a href="#38873101">prev</a><span>|</span><a href="#38877034">next</a><span>|</span><label class="collapse" for="c-38873884">[-]</label><label class="expand" for="c-38873884">[1 more]</label></div><br/><div class="children"><div class="content">The Go runtime can create more that one thread per core, especially when there is some blocking syscall.</div><br/></div></div></div></div><div id="38877034" class="c"><input type="checkbox" id="c-38877034" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#38872709">parent</a><span>|</span><a href="#38872825">prev</a><span>|</span><a href="#38872772">next</a><span>|</span><label class="collapse" for="c-38877034">[-]</label><label class="expand" for="c-38877034">[2 more]</label></div><br/><div class="children"><div class="content">Are there a lot of HPC workloads at Google compared to concurrent&#x2F;parallel servers?</div><br/><div id="38877067" class="c"><input type="checkbox" id="c-38877067" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38877034">parent</a><span>|</span><a href="#38872772">next</a><span>|</span><label class="collapse" for="c-38877067">[-]</label><label class="expand" for="c-38877067">[1 more]</label></div><br/><div class="children"><div class="content">well, <i>now</i> there are.  but pagerank was one from the beginning</div><br/></div></div></div></div><div id="38872772" class="c"><input type="checkbox" id="c-38872772" checked=""/><div class="controls bullet"><span class="by">leeoniya</span><span>|</span><a href="#38872709">parent</a><span>|</span><a href="#38877034">prev</a><span>|</span><a href="#38872892">next</a><span>|</span><label class="collapse" for="c-38872772">[-]</label><label class="expand" for="c-38872772">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And scripting language integration was also not a desirable goal, because Go was intended for you to write all your code in Go, rather than invoking FFIs.<p>&quot;just avoid cgo&quot; is a something i&#x27;ve heard many times from all Go devs</div><br/></div></div><div id="38872892" class="c"><input type="checkbox" id="c-38872892" checked=""/><div class="controls bullet"><span class="by">npalli</span><span>|</span><a href="#38872709">parent</a><span>|</span><a href="#38872772">prev</a><span>|</span><a href="#38872779">next</a><span>|</span><label class="collapse" for="c-38872892">[-]</label><label class="expand" for="c-38872892">[1 more]</label></div><br/><div class="children"><div class="content">Good historical perspective thanks for it. Your comments on scientific computing&#x2F;HPC are interesting. Golang could indeed have solved the two-language problem and taken off like a rocket in comparison to where it is (hovering in the top 15). However, I think it would have to tackle some very orthogonal concepts - to the systems language creators like Rob and others on the go team - like vectorization as first class concept, parallelism (not green threads) etc. which might have limited some of the initial implementation efficiencies, not sure. There is still room for such a language (Julia is getting there...) perhaps some disgruntled FORTRAN elder who is sick of C++ will create such a new language :-)</div><br/></div></div><div id="38872779" class="c"><input type="checkbox" id="c-38872779" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#38872709">parent</a><span>|</span><a href="#38872892">prev</a><span>|</span><a href="#38872784">next</a><span>|</span><label class="collapse" for="c-38872779">[-]</label><label class="expand" for="c-38872779">[1 more]</label></div><br/><div class="children"><div class="content">Interesting context. I use Go a lot for enterprise backend type work and I have to say I&#x27;m glad its not geared towards being an HPC language, but to each their own.</div><br/></div></div><div id="38872784" class="c"><input type="checkbox" id="c-38872784" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38872709">parent</a><span>|</span><a href="#38872779">prev</a><span>|</span><a href="#38873066">next</a><span>|</span><label class="collapse" for="c-38872784">[-]</label><label class="expand" for="c-38872784">[14 more]</label></div><br/><div class="children"><div class="content"><i>&gt; I believe they have now relaxed this opinion</i><p>Or is it that scientific computing is starting to realize that it can benefit from a systems programming language?<p>Scripting langages are great for exploratory work, but if you want to put to work into production, scripting starts to really show its limitations. There is a reason systems languages exist. There is good reason why they both exist. They are different tools for different jobs.</div><br/><div id="38872945" class="c"><input type="checkbox" id="c-38872945" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38872784">parent</a><span>|</span><a href="#38873209">next</a><span>|</span><label class="collapse" for="c-38872945">[-]</label><label class="expand" for="c-38872945">[6 more]</label></div><br/><div class="children"><div class="content">&gt;<i>Or is it that scientific computing is starting to realize that it can benefit from a systems programming language?</i><p>Can&#x27;t be it, since a huge percentage of scientific computing is done with a scripting language.<p>A systems programming language is still good for the backend libraries of scientific computing - but Go has zero share of that.</div><br/><div id="38872967" class="c"><input type="checkbox" id="c-38872967" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38872945">parent</a><span>|</span><a href="#38873209">next</a><span>|</span><label class="collapse" for="c-38872967">[-]</label><label class="expand" for="c-38872967">[5 more]</label></div><br/><div class="children"><div class="content">A huge percentage of scientific computing is scripting in nature. It would be silly to use anything other than a scripting language.<p>But not all. Whether or not it is Go that gets the job, a systems language of some kind would be beneficial in those circumstances.</div><br/><div id="38876298" class="c"><input type="checkbox" id="c-38876298" checked=""/><div class="controls bullet"><span class="by">aragilar</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38872967">parent</a><span>|</span><a href="#38873337">next</a><span>|</span><label class="collapse" for="c-38876298">[-]</label><label class="expand" for="c-38876298">[2 more]</label></div><br/><div class="children"><div class="content">But Go lacks a good FFI story (see CGo discussions), so Go has no hope here.</div><br/><div id="38876356" class="c"><input type="checkbox" id="c-38876356" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38876298">parent</a><span>|</span><a href="#38873337">next</a><span>|</span><label class="collapse" for="c-38876356">[-]</label><label class="expand" for="c-38876356">[1 more]</label></div><br/><div class="children"><div class="content">What are you referring to?<p>The only active, related discussion I am aware of is about the high call overhead imposed by the gc compiler. Of course, other Go compilers have different calling conventions. tinygo, for example, can call C functions from Go about as fast as C can call C functions. So that isn&#x27;t really a Go issue, just a specific compiler implementation issue. And as you know (it&#x27;s in the link!), the Go team themselves maintain two different compilers and pride themselves on Go not being defined by one compiler. To equate gc and Go as being one and the same would be quite faulty.<p>So obviously you are not talking about that one. What else are people discussing?</div><br/></div></div></div></div><div id="38873337" class="c"><input type="checkbox" id="c-38873337" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38872967">parent</a><span>|</span><a href="#38876298">prev</a><span>|</span><a href="#38873209">next</a><span>|</span><label class="collapse" for="c-38873337">[-]</label><label class="expand" for="c-38873337">[2 more]</label></div><br/><div class="children"><div class="content">There are 2 conflicting goals:  1) Having a language in which it is easy to express and try out ideas and 2) Producing fast and safe programs.<p>A scripting language would seem to be good for the exploratory scientific research, because of that. Whereas when you need to create a performant library that can do heavy crunching with reproducible results on any platform you need the other.  The questions is: Do you know what you want to implement, or is that still an open question?</div><br/><div id="38873853" class="c"><input type="checkbox" id="c-38873853" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873337">parent</a><span>|</span><a href="#38873209">next</a><span>|</span><label class="collapse" for="c-38873853">[-]</label><label class="expand" for="c-38873853">[1 more]</label></div><br/><div class="children"><div class="content">No doubt it starts as an open question and slowly moves towards knowing.<p>Which isn&#x27;t really much of a conflict. You can prove out your thoughts in a scripting language, and after the dust has settled you can move the workload to a systems language. Different jobs, different tools.<p>I guess if you&#x27;re one of those weird religious types that insist there is only one true God (read: programming language) you might feel conflict, but nobody else cares.</div><br/></div></div></div></div></div></div></div></div><div id="38873209" class="c"><input type="checkbox" id="c-38873209" checked=""/><div class="controls bullet"><span class="by">Guvante</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38872784">parent</a><span>|</span><a href="#38872945">prev</a><span>|</span><a href="#38873066">next</a><span>|</span><label class="collapse" for="c-38873209">[-]</label><label class="expand" for="c-38873209">[7 more]</label></div><br/><div class="children"><div class="content">Except what does Go get for ditching the REPL?<p>It already has a substantial runtime (the usual pain of an REPL)</div><br/><div id="38874668" class="c"><input type="checkbox" id="c-38874668" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873209">parent</a><span>|</span><a href="#38873235">next</a><span>|</span><label class="collapse" for="c-38874668">[-]</label><label class="expand" for="c-38874668">[2 more]</label></div><br/><div class="children"><div class="content">Not being able to create new code at runtime is a pretty huge freepass for the compiler to implement stuff a certain way.<p>You can bet the Go compiler and runtime leverage that assumption.</div><br/><div id="38876566" class="c"><input type="checkbox" id="c-38876566" checked=""/><div class="controls bullet"><span class="by">Guvante</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38874668">parent</a><span>|</span><a href="#38873235">next</a><span>|</span><label class="collapse" for="c-38876566">[-]</label><label class="expand" for="c-38876566">[1 more]</label></div><br/><div class="children"><div class="content">Even without optimizations?</div><br/></div></div></div></div><div id="38873235" class="c"><input type="checkbox" id="c-38873235" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873209">parent</a><span>|</span><a href="#38874668">prev</a><span>|</span><a href="#38873066">next</a><span>|</span><label class="collapse" for="c-38873235">[-]</label><label class="expand" for="c-38873235">[4 more]</label></div><br/><div class="children"><div class="content">What would it gain? REPLs make perfect sense for scripting problems, but when you would you ever use it for systems problems?</div><br/><div id="38876572" class="c"><input type="checkbox" id="c-38876572" checked=""/><div class="controls bullet"><span class="by">Guvante</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873235">parent</a><span>|</span><a href="#38873891">next</a><span>|</span><label class="collapse" for="c-38876572">[-]</label><label class="expand" for="c-38876572">[1 more]</label></div><br/><div class="children"><div class="content">You say systems problems like Go is for embedded work.<p>Half the things I have seen replaced Python scripts. Seeing what your internal state is after taking X action is exactly what REPLs are good at...</div><br/></div></div><div id="38873891" class="c"><input type="checkbox" id="c-38873891" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873235">parent</a><span>|</span><a href="#38876572">prev</a><span>|</span><a href="#38873066">next</a><span>|</span><label class="collapse" for="c-38873891">[-]</label><label class="expand" for="c-38873891">[2 more]</label></div><br/><div class="children"><div class="content">often when I am developing systems code or RPC client code, I sit in a REPL and make repeated ad-hoc calls to various functions, building up various bits of state (I started using python long before Jupyter). I find this much more intuitive than writing code, compiling it, executing it, going back to the editor, changing the code, re-running it with something that loads a bunch of data, just so I can answer a question about the runtime behavior of the system I&#x27;m working with.</div><br/><div id="38873947" class="c"><input type="checkbox" id="c-38873947" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873891">parent</a><span>|</span><a href="#38873066">next</a><span>|</span><label class="collapse" for="c-38873947">[-]</label><label class="expand" for="c-38873947">[1 more]</label></div><br/><div class="children"><div class="content">There is certainly something to be said about being able to answer questions about another system by poking at it, but that is a scripting task. You would be better served by a scripting language. And, as it happens, most scripting languages come with REPLs. That is a solved problem that was solved long before Go was ever imagined.<p>Just because you are building a particular systems program does not mean everything you do has to be a systems problem. And, really, if you don&#x27;t exactly know what you&#x27;re building, it is probably too soon to consider any of it a systems problem.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38873066" class="c"><input type="checkbox" id="c-38873066" checked=""/><div class="controls bullet"><span class="by">tejohnso</span><span>|</span><a href="#38872709">parent</a><span>|</span><a href="#38872784">prev</a><span>|</span><a href="#38872881">next</a><span>|</span><label class="collapse" for="c-38873066">[-]</label><label class="expand" for="c-38873066">[17 more]</label></div><br/><div class="children"><div class="content">&gt; Rob hates Bjarne Stroustrup<p>That sounds extreme. What did Bjarne do to him?</div><br/><div id="38873548" class="c"><input type="checkbox" id="c-38873548" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873066">parent</a><span>|</span><a href="#38873123">next</a><span>|</span><label class="collapse" for="c-38873548">[-]</label><label class="expand" for="c-38873548">[3 more]</label></div><br/><div class="children"><div class="content">Bjarne took the wonderful thing that was C and made C++.  Rob is not a fan of C++: he thinks the language evolved badly and added poor concepts from the beginning (IIRC iostreams and templates were two of the concepts), and it embedded a number of design decisions that led to extremely slow compiles and links (like, 45 minutes to link a Google binary).  Ian Taylor even wrote a better linker (gold) for Google to deal with that.</div><br/><div id="38873751" class="c"><input type="checkbox" id="c-38873751" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873548">parent</a><span>|</span><a href="#38873123">next</a><span>|</span><label class="collapse" for="c-38873751">[-]</label><label class="expand" for="c-38873751">[2 more]</label></div><br/><div class="children"><div class="content">Compare the designs of iostreams (Stroustrup) and  the STL (Stepanov), conclusions left as an exercise for the reader.</div><br/><div id="38874163" class="c"><input type="checkbox" id="c-38874163" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873751">parent</a><span>|</span><a href="#38873123">next</a><span>|</span><label class="collapse" for="c-38874163">[-]</label><label class="expand" for="c-38874163">[1 more]</label></div><br/><div class="children"><div class="content">when I discovered STLport around 2001, it was a real revelation and very convenient because I was finally able to compile the code my coworkers wrote on &quot;real UNIX&quot; with &quot;real C++ compilers&quot; (lol cfront) 
In researching my answer I came across 
<a href="http:&#x2F;&#x2F;www.stlport.org&#x2F;resources&#x2F;StepanovUSA.html#" rel="nofollow">http:&#x2F;&#x2F;www.stlport.org&#x2F;resources&#x2F;StepanovUSA.html#</a>
&quot;putting it simply, STL is the result of a bacterial infection.&quot;</div><br/></div></div></div></div></div></div><div id="38873123" class="c"><input type="checkbox" id="c-38873123" checked=""/><div class="controls bullet"><span class="by">aragonite</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873066">parent</a><span>|</span><a href="#38873548">prev</a><span>|</span><a href="#38873160">next</a><span>|</span><label class="collapse" for="c-38873123">[-]</label><label class="expand" for="c-38873123">[3 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t know about Rob Pike in particular but Ken Thompson, who probably had the same reasons for &quot;hating&quot; Stroustrup, had this to say about him (from Coders at Work):<p>Seibel: You were at AT&amp;T with Bjarne Stroustrup. Were you involved at all in the development of C++?<p>Thompson: I&#x27;m gonna get in trouble.<p>Seibel: That&#x27;s fine.<p>Thompson: I would try out the language as it was being developed and make comments on it. It was part of the work atmosphere there. And you&#x27;d write something and then the next day it wouldn&#x27;t work because the language changed. It was very unstable for a very long period of time. At some point I said, no, no more.<p>In an interview I said exactly that, that I didn&#x27;t use it just because it wouldn&#x27;t stay still for two days in a row. When Stroustrup read the interview he came screaming into my room about how I was undermining him and what I said mattered and I said it was a bad language. I never said it was a bad language. On and on and on. Since then I kind of avoid that kind of stuff.<p>Seibel: Can you say now whether you think it&#x27;s a good or bad language?<p>Thompson: It certainly has its good points. But by and large I think it&#x27;s a bad language. It does a lot of things half well and it&#x27;s just a garbage heap of ideas that are mutually exclusive. Everybody I know, whether it&#x27;s personal or corporate, selects a subset and these subsets are different. So it&#x27;s not a good language to transport an algorithm—to say, “I wrote it; here, take it.” It&#x27;s way too big, way too complex. And it&#x27;s obviously built by a committee.<p>Stroustrup campaigned for years and years and years, way beyond any sort of technical contributions he made to the language, to get it adopted and used. And he sort of ran all the standards committees with a whip and a chair. And he said “no” to no one. He put every feature in that language that ever existed. It wasn&#x27;t cleanly designed—it was just the union of everything that came along. And I think it suffered drastically from that.<p>Seibel: Do you think that was just because he likes all ideas or was it a way to get the language adopted, by giving everyone what they wanted?<p>Thompson: I think it&#x27;s more the latter than the former.</div><br/><div id="38874790" class="c"><input type="checkbox" id="c-38874790" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873123">parent</a><span>|</span><a href="#38874558">next</a><span>|</span><label class="collapse" for="c-38874790">[-]</label><label class="expand" for="c-38874790">[1 more]</label></div><br/><div class="children"><div class="content">Interesting opinion, it certainly shows the broad mindset behind Golang (and its predecessors Alef and Limbo).  Also let&#x27;s face it, it really took Cyclone and Rust to prove that a broadly C++ish language could be made both safe for large-scale systems and developer-friendly.  If your only point of reference is C++ itself, these remarks are not wrong per se.</div><br/></div></div><div id="38874558" class="c"><input type="checkbox" id="c-38874558" checked=""/><div class="controls bullet"><span class="by">aragonite</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873123">parent</a><span>|</span><a href="#38874790">prev</a><span>|</span><a href="#38873160">next</a><span>|</span><label class="collapse" for="c-38874558">[-]</label><label class="expand" for="c-38874558">[1 more]</label></div><br/><div class="children"><div class="content">But also see previous discussion of these remarks on HN:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27938122">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27938122</a></div><br/></div></div></div></div><div id="38873160" class="c"><input type="checkbox" id="c-38873160" checked=""/><div class="controls bullet"><span class="by">el-dude-arino</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873066">parent</a><span>|</span><a href="#38873123">prev</a><span>|</span><a href="#38872881">next</a><span>|</span><label class="collapse" for="c-38873160">[-]</label><label class="expand" for="c-38873160">[10 more]</label></div><br/><div class="children"><div class="content">99% of programmers, but especially the brilliant&#x2F;well known ones, are insufferable egotists. Many cannot have a technical disagreement without despising the person they disagree with.<p>Professionalism and the tech industry are just starting to get acquainted.</div><br/><div id="38876253" class="c"><input type="checkbox" id="c-38876253" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873160">parent</a><span>|</span><a href="#38873732">next</a><span>|</span><label class="collapse" for="c-38876253">[-]</label><label class="expand" for="c-38876253">[1 more]</label></div><br/><div class="children"><div class="content">To paraphrase more generally;<p><i>99% of [people], but especially the brilliant&#x2F;well known ones [in any domain], are insufferable egotists.</i><p>IMHO this is normal. When somebody puts in a lot of effort in mastering something they <i>intrinsically know</i> that they are better than most people in that something. As social animals, getting &quot;noticed&quot; is a form of being conferred &quot;status&quot; in the group. Thus you tend to &quot;act out&quot; to acknowledge&#x2F;confirm that recognition. It is fine as long as it is within acceptable social bounds and not out of touch with reality.</div><br/></div></div><div id="38873732" class="c"><input type="checkbox" id="c-38873732" checked=""/><div class="controls bullet"><span class="by">anotherevan</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873160">parent</a><span>|</span><a href="#38876253">prev</a><span>|</span><a href="#38873990">next</a><span>|</span><label class="collapse" for="c-38873732">[-]</label><label class="expand" for="c-38873732">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 99% of programmers, […] are insufferable egotists.<p>As I read this while sipping my turmeric latte my monocle popped right out!</div><br/></div></div><div id="38873351" class="c"><input type="checkbox" id="c-38873351" checked=""/><div class="controls bullet"><span class="by">1attice</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873160">parent</a><span>|</span><a href="#38873990">prev</a><span>|</span><a href="#38872881">next</a><span>|</span><label class="collapse" for="c-38873351">[-]</label><label class="expand" for="c-38873351">[6 more]</label></div><br/><div class="children"><div class="content">Most professions, quietly, are currently like this. Architects and scientists and doctors and surgeons and lawyers all develop strong opinions about each other based on their positions.<p>For instance: ask a lawyer what they think about the overturning of Roe v Wade. Now ask them what they think about their colleagues who disagree. Don&#x27;t forget to duck.<p>Which isn&#x27;t to say that we wouldn&#x27;t all be much better off with more distance between our opinions and our identities. But the thing you&#x27;re looking for is a cultivated practice that is often not at odds with &#x27;egotism&#x27; (what is that, precisely, anyway?) but _entailed by_ it: the not-wanting-to-be-the-kind-of-person-who-does-XYZ.<p>Not all vanities are risible.<p>What you&#x27;re looking for is a long-cultivated, inward practice that can be supported or hindered by all the usual forces, local context (culture, practice, etc) chief among them.<p>Put another way: your claim isn&#x27;t that most programmers are unprofessional. It&#x27;s that they&#x27;re _uncollegial_. And you&#x27;re right. So are a lot of other contemporary professionals. It&#x27;s a shouty era.</div><br/><div id="38876265" class="c"><input type="checkbox" id="c-38876265" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873351">parent</a><span>|</span><a href="#38874191">next</a><span>|</span><label class="collapse" for="c-38876265">[-]</label><label class="expand" for="c-38876265">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38876253">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38876253</a></div><br/></div></div><div id="38874191" class="c"><input type="checkbox" id="c-38874191" checked=""/><div class="controls bullet"><span class="by">zik</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873351">parent</a><span>|</span><a href="#38876265">prev</a><span>|</span><a href="#38872881">next</a><span>|</span><label class="collapse" for="c-38874191">[-]</label><label class="expand" for="c-38874191">[4 more]</label></div><br/><div class="children"><div class="content">That kind of behaviour leads to a lot of valuable people abandoning workplaces because they can&#x27;t stand the abusive atmosphere. In the end all that&#x27;s left are the shouty arseholes and that doesn&#x27;t do anyone any favors.</div><br/><div id="38875998" class="c"><input type="checkbox" id="c-38875998" checked=""/><div class="controls bullet"><span class="by">geodel</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38874191">parent</a><span>|</span><a href="#38874960">next</a><span>|</span><label class="collapse" for="c-38875998">[-]</label><label class="expand" for="c-38875998">[2 more]</label></div><br/><div class="children"><div class="content">So where do those valuable people end up then?</div><br/><div id="38876122" class="c"><input type="checkbox" id="c-38876122" checked=""/><div class="controls bullet"><span class="by">1attice</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38875998">parent</a><span>|</span><a href="#38874960">next</a><span>|</span><label class="collapse" for="c-38876122">[-]</label><label class="expand" for="c-38876122">[1 more]</label></div><br/><div class="children"><div class="content">Well, a shockingly high percentage drop out of their profession, and get stuck somewhere doing something like CSR.</div><br/></div></div></div></div><div id="38874960" class="c"><input type="checkbox" id="c-38874960" checked=""/><div class="controls bullet"><span class="by">1attice</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38874191">parent</a><span>|</span><a href="#38875998">prev</a><span>|</span><a href="#38872881">next</a><span>|</span><label class="collapse" for="c-38874960">[-]</label><label class="expand" for="c-38874960">[1 more]</label></div><br/><div class="children"><div class="content">Correct. But my original post is not normative, but rather descriptive. Despite how things <i>should</i> be, this is how they <i>are</i>.<p>I&#x27;ve found that it&#x27;s extraordinarily valuable to separate these two cognitive modes wherever possible.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38872881" class="c"><input type="checkbox" id="c-38872881" checked=""/><div class="controls bullet"><span class="by">pphysch</span><span>|</span><a href="#38872709">parent</a><span>|</span><a href="#38873066">prev</a><span>|</span><a href="#38873154">next</a><span>|</span><label class="collapse" for="c-38872881">[-]</label><label class="expand" for="c-38872881">[6 more]</label></div><br/><div class="children"><div class="content">This seems misdirected. Go clearly wasn&#x27;t designed for scientific computing, and that&#x27;s okay. I&#x27;ve successfully written some multi-node MPI codes in Go, but there&#x27;s not much advantage over C, and likely some disadvantages relating to the Go runtime and linking behavior.<p>Python (largely) is the present and future of scientific computing because people realized you can write the mathy kernels in something low-level and just orchestrate it with ergonomic Python and its bountiful ecosystem&#x2F;mindshare. Python adequately checks all the boxes and I don&#x27;t see how a newcomer like &quot;Scientific Go&quot; or R or Julia will ever unseat it. Not to mention curmudgeonly researchers have little desire to learn new tricks.<p>But I do use Go when needed as a systems language, and it is fantastic for whipping out the occasional necessary microservice (due to network boundaries, etc).</div><br/><div id="38873096" class="c"><input type="checkbox" id="c-38873096" checked=""/><div class="controls bullet"><span class="by">theLiminator</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38872881">parent</a><span>|</span><a href="#38874296">next</a><span>|</span><label class="collapse" for="c-38873096">[-]</label><label class="expand" for="c-38873096">[3 more]</label></div><br/><div class="children"><div class="content">I think the main issue with Python tends to not be performance (though it can be hard to speed up certain bottlenecks), but rather there&#x27;s a point where maintaining it goes from very easy to very difficult due to lack of static typing. Where this occurs can be pushed further back with very careful programming discipline (or by adopting mypy et. al from the start). But I could see a world where something go-like with a little more expressivity could&#x27;ve become that glue language instead of python.</div><br/><div id="38873166" class="c"><input type="checkbox" id="c-38873166" checked=""/><div class="controls bullet"><span class="by">pphysch</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873096">parent</a><span>|</span><a href="#38874296">next</a><span>|</span><label class="collapse" for="c-38873166">[-]</label><label class="expand" for="c-38873166">[2 more]</label></div><br/><div class="children"><div class="content">This is a software engineering practices problem rather than a Python problem. Python has great tooling and language support for type annotations. I work on large Python codebases with ease because I leverage these things. My IDE is able to do static analysis and catch potential typing errors before runtime.<p>The problem is we have researchers with no SWE expertise writing huge codebases in Jupyter notebooks inside a bespoke, possibly unreproducible Anaconda environment. That is going to be a maintenance disaster no matter which language is being used.<p>And if you force your researchers, who are using to being productive prototyping in Python, R, etc. to use a statically-typed language, they are going to complain and be a lot less productive at their job.</div><br/><div id="38873199" class="c"><input type="checkbox" id="c-38873199" checked=""/><div class="controls bullet"><span class="by">theLiminator</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38873166">parent</a><span>|</span><a href="#38874296">next</a><span>|</span><label class="collapse" for="c-38873199">[-]</label><label class="expand" for="c-38873199">[1 more]</label></div><br/><div class="children"><div class="content">I find mypy and the other type checkers I&#x27;ve used kinda painful due to false positives.<p>I think with proper type inference, there would be a lot less pain around static typing.<p>Ideally users should be forced to type their function signatures and everything else can be inferred.<p>Definitely I do agree with you that the situation today is much superior to even just 4-5 years ago.</div><br/></div></div></div></div></div></div><div id="38874296" class="c"><input type="checkbox" id="c-38874296" checked=""/><div class="controls bullet"><span class="by">truculent</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38872881">parent</a><span>|</span><a href="#38873096">prev</a><span>|</span><a href="#38873181">next</a><span>|</span><label class="collapse" for="c-38874296">[-]</label><label class="expand" for="c-38874296">[1 more]</label></div><br/><div class="children"><div class="content">&gt; newcomer like ... R<p>R is only 2 years younger than Python (32 years old)</div><br/></div></div><div id="38873181" class="c"><input type="checkbox" id="c-38873181" checked=""/><div class="controls bullet"><span class="by">lamontcg</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38872881">parent</a><span>|</span><a href="#38874296">prev</a><span>|</span><a href="#38873154">next</a><span>|</span><label class="collapse" for="c-38873181">[-]</label><label class="expand" for="c-38873181">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t see how a newcomer like &quot;Scientific Go&quot; or R or Julia will ever unseat it.<p>Julia&#x27;s support for Autodiff</div><br/></div></div></div></div><div id="38873154" class="c"><input type="checkbox" id="c-38873154" checked=""/><div class="controls bullet"><span class="by">chaxor</span><span>|</span><a href="#38872709">parent</a><span>|</span><a href="#38872881">prev</a><span>|</span><a href="#38872794">next</a><span>|</span><label class="collapse" for="c-38873154">[-]</label><label class="expand" for="c-38873154">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s ok that Go didn&#x27;t work out for scientific crowds, since Julia works better for the scientific community as a replacement for hacky Matlab&#x2F;c++&#x2F;Fortran conbled-together scripts.</div><br/></div></div><div id="38872794" class="c"><input type="checkbox" id="c-38872794" checked=""/><div class="controls bullet"><span class="by">leetrout</span><span>|</span><a href="#38872709">parent</a><span>|</span><a href="#38873154">prev</a><span>|</span><a href="#38874551">next</a><span>|</span><label class="collapse" for="c-38872794">[-]</label><label class="expand" for="c-38872794">[3 more]</label></div><br/><div class="children"><div class="content">I dream of a world where we have Go or something similar with the same &#x2F; similar UX of Jupyter Notebooks. I keep an eye on Julia but I never make the leap to use it and still pickup Python (or Go).</div><br/><div id="38873782" class="c"><input type="checkbox" id="c-38873782" checked=""/><div class="controls bullet"><span class="by">Art9681</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38872794">parent</a><span>|</span><a href="#38873037">next</a><span>|</span><label class="collapse" for="c-38873782">[-]</label><label class="expand" for="c-38873782">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;gopherdata&#x2F;gophernotes">https:&#x2F;&#x2F;github.com&#x2F;gopherdata&#x2F;gophernotes</a><p>I&#x27;ve had this bookmarked for some time and just havent gotten around to it.</div><br/></div></div><div id="38873037" class="c"><input type="checkbox" id="c-38873037" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38872709">root</a><span>|</span><a href="#38872794">parent</a><span>|</span><a href="#38873782">prev</a><span>|</span><a href="#38874551">next</a><span>|</span><label class="collapse" for="c-38873037">[-]</label><label class="expand" for="c-38873037">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;evcxr&#x2F;evcxr">https:&#x2F;&#x2F;github.com&#x2F;evcxr&#x2F;evcxr</a> can run Rust in a Jupyter notebook. It&#x27;s not Golang but close enough.</div><br/></div></div></div></div><div id="38874551" class="c"><input type="checkbox" id="c-38874551" checked=""/><div class="controls bullet"><span class="by">norir</span><span>|</span><a href="#38872709">parent</a><span>|</span><a href="#38872794">prev</a><span>|</span><a href="#38872823">next</a><span>|</span><label class="collapse" for="c-38874551">[-]</label><label class="expand" for="c-38874551">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And a REPL wasn&#x27;t necessary because Go compiled so quickly you could just write a program and run it (no, that misses the point of a repl, which is that it builds up state and lets you call new functions with that built-up state).<p>He&#x27;d have had a point if the go compiler could reliably compile programs in faster than 50-100ms. The claims that go is a fast compiler always seem to be relative to c++ or something. Last time I checked just compiling hello world took over 200ms which was shocking to me given how I&#x27;d heard that one of the language&#x27;s claims to fame was a fast compiler.</div><br/></div></div><div id="38872823" class="c"><input type="checkbox" id="c-38872823" checked=""/><div class="controls bullet"><span class="by">google234123</span><span>|</span><a href="#38872709">parent</a><span>|</span><a href="#38874551">prev</a><span>|</span><a href="#38873225">next</a><span>|</span><label class="collapse" for="c-38872823">[-]</label><label class="expand" for="c-38872823">[1 more]</label></div><br/><div class="children"><div class="content">There’s  engineers at Google trying to get things done, and ones trying to create new languages… they don’t talk to each other too much</div><br/></div></div></div></div><div id="38873225" class="c"><input type="checkbox" id="c-38873225" checked=""/><div class="controls bullet"><span class="by">bsaul</span><span>|</span><a href="#38872709">prev</a><span>|</span><a href="#38872837">next</a><span>|</span><label class="collapse" for="c-38873225">[-]</label><label class="expand" for="c-38873225">[2 more]</label></div><br/><div class="children"><div class="content">I’m surprised the fact that they manage to keep the language small and minimal isn’t mentionned as a huge success. To me that is the number one reason to use this language : it forces you to not be distracted by language constructs (there aren’t enough for that), and focus on what is it exactly you’re trying to build. Even as an educationnal tool, this is excellent. Maybe they don’t realize it because they come from C, but when you come from more recent languages that include everything and the kitchen sin, this is a godsend.<p>It’s now to the point that whenever i develop a feature in a language, i ask myself « how would i do that in go » to ensure i don’t go fancy with the type system for no good reasons.</div><br/><div id="38875895" class="c"><input type="checkbox" id="c-38875895" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#38873225">parent</a><span>|</span><a href="#38872837">next</a><span>|</span><label class="collapse" for="c-38875895">[-]</label><label class="expand" for="c-38875895">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and focus on what is it exactly you’re trying to build.<p>Instead, you&#x27;re focusing on fighting the language limitations on your way to build what you want ;)</div><br/></div></div></div></div><div id="38872837" class="c"><input type="checkbox" id="c-38872837" checked=""/><div class="controls bullet"><span class="by">knorker</span><span>|</span><a href="#38873225">prev</a><span>|</span><a href="#38875668">next</a><span>|</span><label class="collapse" for="c-38872837">[-]</label><label class="expand" for="c-38872837">[39 more]</label></div><br/><div class="children"><div class="content">I think two big failures were:<p>1. Nil pointers (two types of them, even!). We knew better even then.<p>2. Insisting that the language doesn&#x27;t have exceptions, when it does. User code must be exception safe, yet basically never use exceptions. The standard library swallows exceptions (fmt and http)<p>Those are the biggest day to day concrete problems. There are many more that are more abstract, but also hurt.</div><br/><div id="38875063" class="c"><input type="checkbox" id="c-38875063" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#38872837">parent</a><span>|</span><a href="#38876354">next</a><span>|</span><label class="collapse" for="c-38875063">[-]</label><label class="expand" for="c-38875063">[1 more]</label></div><br/><div class="children"><div class="content">Right, people really need to take Tony&#x27;s Billion Dollar Mistake more seriously, which means no you can&#x27;t have &quot;null&quot; or &quot;nil&quot; or whatever you&#x27;re calling it. We know that&#x27;s a bad mistake so you shouldn&#x27;t repeat it.<p>Just as I can excuse using a fat pointer to some bytes as your &quot;string&quot; type in a very close to the metal language. I can excuse the possibility of a null pointer or reference in such a language, just above the level where we&#x27;re doing machine code. It&#x27;s not nice, but you&#x27;re banging rocks together and there&#x27;s a zero value in this register and so fine, let&#x27;s have a &quot;null&quot; pointer. This is not something to be proud of, it shouldn&#x27;t make its way into code that can avoid it, but it will need to exist in the very heart of the fire.<p>Go is far above that level, so it needs to just not expose Go programmers to Tony&#x27;s mistake at all. It should have been defined out of existence.</div><br/></div></div><div id="38876354" class="c"><input type="checkbox" id="c-38876354" checked=""/><div class="controls bullet"><span class="by">015a</span><span>|</span><a href="#38872837">parent</a><span>|</span><a href="#38875063">prev</a><span>|</span><a href="#38873308">next</a><span>|</span><label class="collapse" for="c-38876354">[-]</label><label class="expand" for="c-38876354">[1 more]</label></div><br/><div class="children"><div class="content">I tend to feel, just error handling in general. Its not even something I&#x27;d care so much about, if it didn&#x27;t seem like everyone else felt like the way Go does errors is great.<p>You can&#x27;t&#x2F;shouldn&#x27;t do custom error types, even though its an enticing sexy interface, because of things related to the massive nil&#x2F;nil mistake you&#x27;ve covered. We had errors-as-values in popular, large languages (Javascript callbacks?), and by the mid-10s everyone recognized that they&#x27;re kinda whatever, mostly just a different way of doing the same thing less conveniently, and that community got rid of them (as a side-effect of the more general push to get rid of callback hell, but certainly no effort was made to keep errors-as-values around). We say &quot;being forced to handle errors is great in Go&quot;, but (1) you don&#x27;t have to handle them, you just have to <i>acknowledge</i> them with `_`, and (2) Java has had checked exceptions for years, and everyone <i>also</i> recognizes that those are ish. And, as you say, Go has two fundamentally different kinds of errors functions can throw (what color is your function?), except the facilities for handling panics are essentially a goto (which, I love pointing out lest we all forget, <i>go also has literal goto</i>). Sure, working code shouldn&#x27;t panic; but all that asserts is that Go wasn&#x27;t designed to be fault tolerant.<p>To be clear, I don&#x27;t feel as much passion for hating on Ruby, because I don&#x27;t use Ruby. I use Go. I don&#x27;t wish to hate on the language for the purpose of hate; I wish that more people would agree that the situation is quite poor, rather than good, and that we could make meaningful positive change to the language.</div><br/></div></div><div id="38873308" class="c"><input type="checkbox" id="c-38873308" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#38872837">parent</a><span>|</span><a href="#38876354">prev</a><span>|</span><a href="#38873212">next</a><span>|</span><label class="collapse" for="c-38873308">[-]</label><label class="expand" for="c-38873308">[2 more]</label></div><br/><div class="children"><div class="content">Panicing on nil pointers is definitely the thing which I have seen cause the most pain.</div><br/><div id="38873426" class="c"><input type="checkbox" id="c-38873426" checked=""/><div class="controls bullet"><span class="by">silvestrov</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873308">parent</a><span>|</span><a href="#38873212">next</a><span>|</span><label class="collapse" for="c-38873426">[-]</label><label class="expand" for="c-38873426">[1 more]</label></div><br/><div class="children"><div class="content">The ?. (optional chaining) operator in Javascript is really a godsend for this.<p><a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Operators&#x2F;Optional_chaining" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a></div><br/></div></div></div></div><div id="38873212" class="c"><input type="checkbox" id="c-38873212" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38872837">parent</a><span>|</span><a href="#38873308">prev</a><span>|</span><a href="#38872875">next</a><span>|</span><label class="collapse" for="c-38873212">[-]</label><label class="expand" for="c-38873212">[8 more]</label></div><br/><div class="children"><div class="content">Go has been my daily driver for over a decade. I was in the past a C++ programmer. In what ways am I writing exception-safe code when I write ordinary Go code?</div><br/><div id="38873278" class="c"><input type="checkbox" id="c-38873278" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873212">parent</a><span>|</span><a href="#38872875">next</a><span>|</span><label class="collapse" for="c-38873278">[-]</label><label class="expand" for="c-38873278">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve run into issues where panics cause half of what should be a multistep but assumed to be atomic transaction to occur, putting the system into a goofy state that required fairly manual intervention.  In my case a system daemon that required someone to manually fix up system state on the CLI and restart the system.</div><br/><div id="38873305" class="c"><input type="checkbox" id="c-38873305" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873278">parent</a><span>|</span><a href="#38873823">next</a><span>|</span><label class="collapse" for="c-38873305">[-]</label><label class="expand" for="c-38873305">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s like, strong-form exception safety, a problem in most mainstream languages. But when C++ people talk about &quot;exception safety&quot;, they&#x27;re talking about basic or weak-form exception safety: not leaving dangling pointers and resources as a result of unexpected control transfer. That style of defensiveness is not common in Go code.</div><br/><div id="38873428" class="c"><input type="checkbox" id="c-38873428" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873305">parent</a><span>|</span><a href="#38873823">next</a><span>|</span><label class="collapse" for="c-38873428">[-]</label><label class="expand" for="c-38873428">[2 more]</label></div><br/><div class="children"><div class="content">Well that&#x27;s the thing, I am talking about resources left &#x27;open&#x27; since they didn&#x27;t complete their lifecycle due to the unexpected control flow.  Yes, it&#x27;s not common in go code, but I think that&#x27;s more a combo of the GC making dangling memory not a problem, and the environment that most go code lives in (ie. kubernetes clusters or some equivalent) where the other resources leaked are eventually reclaimed by the autoscaler and other devops automation.<p>The GC is ubiquitous, and definitely a point in favor for go for the vast majority of use cases, but I&#x27;ve found it more difficult than anticipated to write go code that manipulates resources other than memory that the environment you&#x27;re running in won&#x27;t clean up for you.  And that&#x27;s coming from C++ code originally including the exception safety issues.</div><br/><div id="38873706" class="c"><input type="checkbox" id="c-38873706" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873428">parent</a><span>|</span><a href="#38873823">next</a><span>|</span><label class="collapse" for="c-38873706">[-]</label><label class="expand" for="c-38873706">[1 more]</label></div><br/><div class="children"><div class="content">(By the way, [the Austral spec](<a href="https:&#x2F;&#x2F;austral-lang.org&#x2F;spec&#x2F;spec.html#rationale-errors" rel="nofollow">https:&#x2F;&#x2F;austral-lang.org&#x2F;spec&#x2F;spec.html#rationale-errors</a>) discusses in great detail the available tradeoffs in this area of language design.)</div><br/></div></div></div></div></div></div><div id="38873823" class="c"><input type="checkbox" id="c-38873823" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873278">parent</a><span>|</span><a href="#38873305">prev</a><span>|</span><a href="#38872875">next</a><span>|</span><label class="collapse" for="c-38873823">[-]</label><label class="expand" for="c-38873823">[3 more]</label></div><br/><div class="children"><div class="content">Well panic = very serious problem, what do you expect? You can catch them and handle them but it does not means the system is stable.<p>Also defer() will run even if there is a panic.</div><br/><div id="38874828" class="c"><input type="checkbox" id="c-38874828" checked=""/><div class="controls bullet"><span class="by">skitter</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873823">parent</a><span>|</span><a href="#38874173">next</a><span>|</span><label class="collapse" for="c-38874828">[-]</label><label class="expand" for="c-38874828">[1 more]</label></div><br/><div class="children"><div class="content">&gt; panic = very serious problem, what do you expect?<p>Even the Go standard library itself panics (and recovers) when you try to e.g. json-encode a NaN, which doesn&#x27;t seem like something that should make the system unstable.</div><br/></div></div><div id="38874173" class="c"><input type="checkbox" id="c-38874173" checked=""/><div class="controls bullet"><span class="by">groestl</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873823">parent</a><span>|</span><a href="#38874828">prev</a><span>|</span><a href="#38872875">next</a><span>|</span><label class="collapse" for="c-38874173">[-]</label><label class="expand" for="c-38874173">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but it does not means the system is stable.<p>This is a direct result of Go&#x27;s lacking error handling, and would not be necessary if they&#x27;d have learned from C++ and Java&#x27;s mistakes, instead of just repeating them.</div><br/></div></div></div></div></div></div></div></div><div id="38872875" class="c"><input type="checkbox" id="c-38872875" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38872837">parent</a><span>|</span><a href="#38873212">prev</a><span>|</span><a href="#38875668">next</a><span>|</span><label class="collapse" for="c-38872875">[-]</label><label class="expand" for="c-38872875">[26 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Insisting that the language doesn&#x27;t have exceptions</i><p>Insist in what way? The Go website insists that Go has actual exceptions, unlike the pretend exceptions that are actually errors passed around using goto like you find in Java and other languages inspired by it.</div><br/><div id="38873356" class="c"><input type="checkbox" id="c-38873356" checked=""/><div class="controls bullet"><span class="by">stonemetal12</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38872875">parent</a><span>|</span><a href="#38873174">next</a><span>|</span><label class="collapse" for="c-38873356">[-]</label><label class="expand" for="c-38873356">[5 more]</label></div><br/><div class="children"><div class="content">Other than the fact that they spelled &quot;throw&quot; &quot;panic&quot;, &quot;catch&quot; &quot;recover&quot;, and &quot;finally&quot; &quot;defer&quot; how are go exceptions different than what you find in java?<p>I get that Go devs like to claim they are completely different because you are supposed to use them differently, but under the hood they are identical as far as I can tell.</div><br/><div id="38873763" class="c"><input type="checkbox" id="c-38873763" checked=""/><div class="controls bullet"><span class="by">eweise</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873356">parent</a><span>|</span><a href="#38873174">next</a><span>|</span><label class="collapse" for="c-38873763">[-]</label><label class="expand" for="c-38873763">[4 more]</label></div><br/><div class="children"><div class="content">Not sure why people downvote instead of answering the question.</div><br/><div id="38873808" class="c"><input type="checkbox" id="c-38873808" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873763">parent</a><span>|</span><a href="#38873174">next</a><span>|</span><label class="collapse" for="c-38873808">[-]</label><label class="expand" for="c-38873808">[3 more]</label></div><br/><div class="children"><div class="content">The comment answers its own question.<p>As to why press a button that does nothing? For the same reason fidget spinners were all the rage a few years back: Bored people like to do something with their hands.<p>Perhaps if the comment had a question that was left unanswered, people wouldn&#x27;t have become so bored?</div><br/><div id="38874012" class="c"><input type="checkbox" id="c-38874012" checked=""/><div class="controls bullet"><span class="by">eweise</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873808">parent</a><span>|</span><a href="#38873174">next</a><span>|</span><label class="collapse" for="c-38874012">[-]</label><label class="expand" for="c-38874012">[2 more]</label></div><br/><div class="children"><div class="content">&quot;how are go exceptions different than what you find in java?&quot; They are not the same. Thought someone might be helpful and list the differences.</div><br/><div id="38874088" class="c"><input type="checkbox" id="c-38874088" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38874012">parent</a><span>|</span><a href="#38873174">next</a><span>|</span><label class="collapse" for="c-38874088">[-]</label><label class="expand" for="c-38874088">[1 more]</label></div><br/><div class="children"><div class="content">Why not lead by example?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38873174" class="c"><input type="checkbox" id="c-38873174" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38872875">parent</a><span>|</span><a href="#38873356">prev</a><span>|</span><a href="#38872971">next</a><span>|</span><label class="collapse" for="c-38873174">[-]</label><label class="expand" for="c-38873174">[16 more]</label></div><br/><div class="children"><div class="content">Given how they being up how fmt and http swallow them, I believe the parent is referring to panics rather the errors returned via standard control flow.</div><br/><div id="38873195" class="c"><input type="checkbox" id="c-38873195" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873174">parent</a><span>|</span><a href="#38872971">next</a><span>|</span><label class="collapse" for="c-38873195">[-]</label><label class="expand" for="c-38873195">[15 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s what we&#x27;re talking about (exceptions, or panics if that&#x27;s what you want to call them). That&#x27;s what exceptions are.</div><br/><div id="38873236" class="c"><input type="checkbox" id="c-38873236" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873195">parent</a><span>|</span><a href="#38872971">next</a><span>|</span><label class="collapse" for="c-38873236">[-]</label><label class="expand" for="c-38873236">[14 more]</label></div><br/><div class="children"><div class="content">I guess I&#x27;m confused since panics are equally errors passed around by gotos as much as java exceptions are.  Probably more so since at least with java it ends up being part of the the function type signature the vast majority of the time.</div><br/><div id="38873470" class="c"><input type="checkbox" id="c-38873470" checked=""/><div class="controls bullet"><span class="by">everforward</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873236">parent</a><span>|</span><a href="#38873596">next</a><span>|</span><label class="collapse" for="c-38873470">[-]</label><label class="expand" for="c-38873470">[12 more]</label></div><br/><div class="children"><div class="content">It creates 2 disparate types of error handling that don&#x27;t neatly mesh together.  You have to handle error return values, but you also have to handle exceptions (panics) because they still exist.<p>My issue is mostly implementing both ways of bubbling up an error to somewhere it can be handled.  I think having either error return values or exceptions is preferable to having both.  I don&#x27;t think exceptions are perfect, but if panic() absolutely has to exist then I&#x27;d rather have an entirely exception-based language than a language that uses both systems simultaneously.<p>E.g. if I write a function that accesses an element of an array without bounds-checking, it could panic and I have to handle that exception.  Bounds-checking basically just becomes finding things that would throw exceptions and converting them to errors so we can pretend that exceptions don&#x27;t exist.</div><br/><div id="38873586" class="c"><input type="checkbox" id="c-38873586" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873470">parent</a><span>|</span><a href="#38873616">next</a><span>|</span><label class="collapse" for="c-38873586">[-]</label><label class="expand" for="c-38873586">[7 more]</label></div><br/><div class="children"><div class="content"><i>&gt; It creates 2 disparate types of error handling</i><p>They are disparate conditions. Errors happen in response to conditions that occur during the execution of the application. Exceptions happen in response to conditions that occurred when the code was written. Very different things.<p>It is highly unlikely that you want to handle an exception. It&#x27;s the runtime equivalent of a compiler error. Do you also want to handle compiler errors so that your faulty code still compiles? Of course not, so why would you want to do the same when your coding mistakes are noticed at runtime?<p>There are, uh, exceptions to that when it is necessary to handle exceptions, but if it you see it as routine you&#x27;re doing something wrong. If you overloaded that with errors, forcing it to be routine, you&#x27;d have a nightmare on your hands (like in those other languages that have tried it).</div><br/><div id="38874268" class="c"><input type="checkbox" id="c-38874268" checked=""/><div class="controls bullet"><span class="by">groestl</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873586">parent</a><span>|</span><a href="#38875942">next</a><span>|</span><label class="collapse" for="c-38874268">[-]</label><label class="expand" for="c-38874268">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Exceptions happen in response to conditions that occurred when the code was written.<p>Huh? Stack overflow? Out of memory?<p>&gt; It is highly unlikely that you want to handle an exception<p>It is very likely that I want to handle an exception. In fact, I want to handle all exceptions and keep my process and all other concurrent requests to it running. And don&#x27;t tell me, that&#x27;s not possible, because I&#x27;ve been doing that for decades. In Java that is.</div><br/><div id="38874508" class="c"><input type="checkbox" id="c-38874508" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38874268">parent</a><span>|</span><a href="#38875942">next</a><span>|</span><label class="collapse" for="c-38874508">[-]</label><label class="expand" for="c-38874508">[4 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Stack overflow?</i><p>Exception. The minimum available stack space is a known quantity. Exceeding it means you made a mistake.<p><i>&gt; Out of memory?</i><p>Error. The available heap is typically not predictable. Your allocation function should provide an error state; and, indeed, malloc and friends do.<p><i>&gt; And don&#x27;t tell me, that&#x27;s not possible</i><p>It is perfectly possible. Probably not a good idea, though, as you have proven that your code is fundamentally broken. Would you put your code in production if there was a way to ignore compiler failure?</div><br/><div id="38876624" class="c"><input type="checkbox" id="c-38876624" checked=""/><div class="controls bullet"><span class="by">groestl</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38874508">parent</a><span>|</span><a href="#38874845">next</a><span>|</span><label class="collapse" for="c-38876624">[-]</label><label class="expand" for="c-38876624">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The minimum available stack space is a known quantity.<p>It is. Tracking and erroring out on it to avoid the exception means replicating your runtime environment&#x27;s mechanism for tracking and erroring out on stack overflow (system in a system &#x2F; inner platform anti-pattern). Your runtime environment&#x27;s implementors know that, so it&#x27;s unlikely you&#x27;ll find the APIs necessary to avoid an exception (i.e. a maxRecursion param and equivalent error result).<p>&gt; Exceeding it means you made a mistake.<p>No, it can be just a part of processing a request. Depending on the particular runtime environment, it does not have any impact on other parts of the process.</div><br/></div></div><div id="38874845" class="c"><input type="checkbox" id="c-38874845" checked=""/><div class="controls bullet"><span class="by">quaunaut</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38874508">parent</a><span>|</span><a href="#38876624">prev</a><span>|</span><a href="#38875942">next</a><span>|</span><label class="collapse" for="c-38874845">[-]</label><label class="expand" for="c-38874845">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Would you put your code in production if there was a way to ignore compiler failure?<p>What compiler failure? Go literally does not warn you until it hits the error at runtime for these exceptions.</div><br/><div id="38874908" class="c"><input type="checkbox" id="c-38874908" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38874845">parent</a><span>|</span><a href="#38875942">next</a><span>|</span><label class="collapse" for="c-38874908">[-]</label><label class="expand" for="c-38874908">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; What compiler failure?</i><p>Pick something. I don&#x27;t care. Let&#x27;s say failure for reasons of having no return statement in a function that declares itself to return something. If you could flip a switch to see that code still compile somehow, knowing that the program is not correct, would you deploy it to production?<p><i>&gt; Go literally does not warn you until it hits the error at runtime for these exceptions.</i><p>True, but only because the Go compiler isn&#x27;t very smart. It trades having a simpler compiler for allowing some programmer faults to not be caught until runtime. But if there was such a thing as an ideal Go compiler, those exceptions would be caught at compile time.<p>When it comes to exceptions, the fault is in the code itself, unlike errors where the fault is external to the program. Theoretically, those faults could be found before runtime. But it is a really hard problem to solve; hence why we accept exceptions as a practical tradeoff. We are just engineers at the end of the day.</div><br/></div></div></div></div></div></div></div></div><div id="38875942" class="c"><input type="checkbox" id="c-38875942" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873586">parent</a><span>|</span><a href="#38874268">prev</a><span>|</span><a href="#38873616">next</a><span>|</span><label class="collapse" for="c-38875942">[-]</label><label class="expand" for="c-38875942">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Errors happen in response to conditions that occur during the execution of the application. Exceptions happen in response to conditions that occurred when the code was written.<p>wat.<p>You have code that ends up dividing by zero, and boom, you have an exception while the app is running.<p>&gt; It is highly unlikely that you want to handle an exception.<p>You <i>always</i> want to handle an exception. That is how actual resilient systems are written</div><br/></div></div></div></div><div id="38873616" class="c"><input type="checkbox" id="c-38873616" checked=""/><div class="controls bullet"><span class="by">abtinf</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873470">parent</a><span>|</span><a href="#38873586">prev</a><span>|</span><a href="#38874898">next</a><span>|</span><label class="collapse" for="c-38873616">[-]</label><label class="expand" for="c-38873616">[3 more]</label></div><br/><div class="children"><div class="content">I cannot conceive of the scenario where it makes sense to recover a bounds-checking induced panic. The process <i>should</i> crash; the alternative is to continue operating in an unknown, irrecoverable, and potentially security compromised state.</div><br/><div id="38873726" class="c"><input type="checkbox" id="c-38873726" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873616">parent</a><span>|</span><a href="#38873746">next</a><span>|</span><label class="collapse" for="c-38873726">[-]</label><label class="expand" for="c-38873726">[1 more]</label></div><br/><div class="children"><div class="content">Rust shares Go&#x27;s &quot;errors as values + panics&quot; philosophy. Rust also has a standard library API for catching panics. Its addition was controversial, but there are two major cases that were specifically enumerated as reasons to add this API: <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;blob&#x2F;master&#x2F;text&#x2F;1236-stabilize-catch-panic.md">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;blob&#x2F;master&#x2F;text&#x2F;1236-stab...</a><p>&gt; It is currently defined as undefined behavior to have a Rust program panic across an FFI boundary. For example if C calls into Rust and Rust panics, then this is undefined behavior. Being able to catch a panic will allow writing C APIs in Rust that do not risk aborting the process they are embedded into.<p>&gt; Abstractions like thread pools want to catch the panics of tasks being run instead of having the thread torn down (and having to spawn a new thread).<p>The latter has a few other similar examples, like say, a web server that wants to protect against user code bringing the entire system down.<p>That said, for various reasons, you don&#x27;t see catch_unwind used in Rust very often. These are very limited cases.</div><br/></div></div><div id="38873746" class="c"><input type="checkbox" id="c-38873746" checked=""/><div class="controls bullet"><span class="by">everforward</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873616">parent</a><span>|</span><a href="#38873726">prev</a><span>|</span><a href="#38874898">next</a><span>|</span><label class="collapse" for="c-38873746">[-]</label><label class="expand" for="c-38873746">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I cannot conceive of the scenario where it makes sense to recover a bounds-checking induced panic.<p>A bog-standard HTTP server (or likely any kind of request-serving daemon).  If a client causes a bounds-checking panic, I do not want that to crash the entire server.<p>It&#x27;s not even really particular to bounds-checking.  If I push a change that causes a nil pointer dereference on a particular handler, I would vastly prefer that it 500&#x27;s those specific requests rather than crashing the entire server every time it happens.<p>The Go HTTP server does this internally (though there is talk about not doing it, deferred til Go 2 <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;5465">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;5465</a>).<p>&gt; The process should crash; the alternative is to continue operating in an unknown, irrecoverable, and potentially security compromised state.<p>The <i>goroutine</i> should probably crash, but that doesn&#x27;t necessarily imply that the entire program should crash.  For some applications the process and the goroutine are one and the same, but that&#x27;s not universally true.  A lot of applications have some kind of request scope where it&#x27;s desirable to be able to crash the thread a request is running on without crashing the entire server.</div><br/></div></div></div></div><div id="38874898" class="c"><input type="checkbox" id="c-38874898" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873470">parent</a><span>|</span><a href="#38873616">prev</a><span>|</span><a href="#38873596">next</a><span>|</span><label class="collapse" for="c-38874898">[-]</label><label class="expand" for="c-38874898">[1 more]</label></div><br/><div class="children"><div class="content">There are two types of errors and Java&#x27;s mistake was making them all the same.</div><br/></div></div></div></div><div id="38873596" class="c"><input type="checkbox" id="c-38873596" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38873236">parent</a><span>|</span><a href="#38873470">prev</a><span>|</span><a href="#38872971">next</a><span>|</span><label class="collapse" for="c-38873596">[-]</label><label class="expand" for="c-38873596">[1 more]</label></div><br/><div class="children"><div class="content">Only at the level of Java source. The JVM (and several other languages) doesn’t actually care or enforce which exceptions a method might throw, which is what makes tricks like <a href="https:&#x2F;&#x2F;projectlombok.org&#x2F;features&#x2F;SneakyThrows" rel="nofollow">https:&#x2F;&#x2F;projectlombok.org&#x2F;features&#x2F;SneakyThrows</a> possible.</div><br/></div></div></div></div></div></div></div></div><div id="38872971" class="c"><input type="checkbox" id="c-38872971" checked=""/><div class="controls bullet"><span class="by">lokar</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38872875">parent</a><span>|</span><a href="#38873174">prev</a><span>|</span><a href="#38875668">next</a><span>|</span><label class="collapse" for="c-38872971">[-]</label><label class="expand" for="c-38872971">[4 more]</label></div><br/><div class="children"><div class="content">So many people confuse errors with exceptions</div><br/><div id="38874209" class="c"><input type="checkbox" id="c-38874209" checked=""/><div class="controls bullet"><span class="by">groestl</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38872971">parent</a><span>|</span><a href="#38875668">next</a><span>|</span><label class="collapse" for="c-38874209">[-]</label><label class="expand" for="c-38874209">[3 more]</label></div><br/><div class="children"><div class="content">Errors are just checked exceptions where you get the chance to introduce bugs, by unrolling the stack manually.</div><br/><div id="38874581" class="c"><input type="checkbox" id="c-38874581" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38874209">parent</a><span>|</span><a href="#38875668">next</a><span>|</span><label class="collapse" for="c-38874581">[-]</label><label class="expand" for="c-38874581">[2 more]</label></div><br/><div class="children"><div class="content">Errors are things that can fail after the program is written (hard drive crash, network failure, etc.).<p>Exceptions are things that were already broken when you wrote the code (null pointer access, index out of bounds, etc.)<p>To put it another way, exceptions are failures that a sufficiently smart compiler would have been able to catch at compile time. Of course, creating a compiler that smart is a monumental task, so we accept catching some programmer mistakes at runtime as a reasonable tradeoff.</div><br/><div id="38876649" class="c"><input type="checkbox" id="c-38876649" checked=""/><div class="controls bullet"><span class="by">groestl</span><span>|</span><a href="#38872837">root</a><span>|</span><a href="#38874581">parent</a><span>|</span><a href="#38875668">next</a><span>|</span><label class="collapse" for="c-38876649">[-]</label><label class="expand" for="c-38876649">[1 more]</label></div><br/><div class="children"><div class="content">&gt; exceptions are failures that a sufficiently smart compiler would have been able to catch at compile time<p>Would love to see your proof of this for stack overflow exceptions. You could become very famous.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38875668" class="c"><input type="checkbox" id="c-38875668" checked=""/><div class="controls bullet"><span class="by">slowhadoken</span><span>|</span><a href="#38872837">prev</a><span>|</span><a href="#38872874">next</a><span>|</span><label class="collapse" for="c-38875668">[-]</label><label class="expand" for="c-38875668">[1 more]</label></div><br/><div class="children"><div class="content">I’ve never used golang in production but I toyed with it when it was first released and I enjoyed it. I just wish Google didn’t control it.</div><br/></div></div><div id="38872874" class="c"><input type="checkbox" id="c-38872874" checked=""/><div class="controls bullet"><span class="by">VirusNewbie</span><span>|</span><a href="#38875668">prev</a><span>|</span><a href="#38874542">next</a><span>|</span><label class="collapse" for="c-38872874">[-]</label><label class="expand" for="c-38872874">[15 more]</label></div><br/><div class="children"><div class="content">I’m surprised they didn’t mention the horrible error handling as something they regret…</div><br/><div id="38872908" class="c"><input type="checkbox" id="c-38872908" checked=""/><div class="controls bullet"><span class="by">righthand</span><span>|</span><a href="#38872874">parent</a><span>|</span><a href="#38872946">next</a><span>|</span><label class="collapse" for="c-38872908">[-]</label><label class="expand" for="c-38872908">[6 more]</label></div><br/><div class="children"><div class="content">Because it’s neither horrible nor regrettable, it just doesn’t cater to your perfect idea of what it should be. It’s a smart way to encourage people to handle errors.</div><br/><div id="38876710" class="c"><input type="checkbox" id="c-38876710" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#38872874">root</a><span>|</span><a href="#38872908">parent</a><span>|</span><a href="#38875810">next</a><span>|</span><label class="collapse" for="c-38876710">[-]</label><label class="expand" for="c-38876710">[1 more]</label></div><br/><div class="children"><div class="content">More precisely because &quot;they&quot; are Rob Pike, and Rob Pike doesn&#x27;t seem to think error handling in Go is horrible.<p>Other members of the Go Team (Robert Griesemer, Russ Cox) trialed out several solutions for this problem, but this issue was just too controversial within the community.</div><br/></div></div><div id="38875810" class="c"><input type="checkbox" id="c-38875810" checked=""/><div class="controls bullet"><span class="by">bananapub</span><span>|</span><a href="#38872874">root</a><span>|</span><a href="#38872908">parent</a><span>|</span><a href="#38876710">prev</a><span>|</span><a href="#38872946">next</a><span>|</span><label class="collapse" for="c-38875810">[-]</label><label class="expand" for="c-38875810">[4 more]</label></div><br/><div class="children"><div class="content">you think it&#x27;s &quot;smart&quot; to encourage a large fraction of function calls to have<p><pre><code>  if err != nil {
    return nil, err
  }
</code></pre>
after it?  really?  you don&#x27;t think it&#x27;s just a very simple way to do it without having to do a lot of work in the language?  and then make everyone use a linter to avoid bugs?  oh and you can&#x27;t always literally do &#x27;return nil, err&#x27; because strings have to be &quot;&quot;?<p>it&#x27;s certainly defensible as a minimalist approach, claiming it&#x27;s actually good or smart or ideal is a pretty weird take.</div><br/><div id="38876571" class="c"><input type="checkbox" id="c-38876571" checked=""/><div class="controls bullet"><span class="by">righthand</span><span>|</span><a href="#38872874">root</a><span>|</span><a href="#38875810">parent</a><span>|</span><a href="#38872946">next</a><span>|</span><label class="collapse" for="c-38876571">[-]</label><label class="expand" for="c-38876571">[3 more]</label></div><br/><div class="children"><div class="content">You think it’s “a lot of work” to write an if statement? Any of the proposed variations have shown to be either different syntax (weak valueless change) or would allow people to ignore handling errors.<p>You can’t always return nil? is that a complaint that you are required to do things differently for data types that require it inside of a complaint about doing things the same?<p>It’s not a weird take, things have tradeoffs, this is a tradeoff of using Go.</div><br/><div id="38876728" class="c"><input type="checkbox" id="c-38876728" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#38872874">root</a><span>|</span><a href="#38876571">parent</a><span>|</span><a href="#38872946">next</a><span>|</span><label class="collapse" for="c-38876728">[-]</label><label class="expand" for="c-38876728">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a lot of work, you can just let the IDE spew it off for you and feel like a certified J2EE programmer circa 2003 who lets the IDE write everything for them. But yeah, <i>writing</i> code is not the problem. <i>Reading</i> the code is.<p>I think having 60% of your lines of code being:<p><pre><code>  if err != nil {
    return err
  }
</code></pre>
Does make the code a tad bit less readable.</div><br/><div id="38876768" class="c"><input type="checkbox" id="c-38876768" checked=""/><div class="controls bullet"><span class="by">righthand</span><span>|</span><a href="#38872874">root</a><span>|</span><a href="#38876728">parent</a><span>|</span><a href="#38872946">next</a><span>|</span><label class="collapse" for="c-38876768">[-]</label><label class="expand" for="c-38876768">[1 more]</label></div><br/><div class="children"><div class="content">So then it’s less readable because you have to process a simple error return? I won’t even comment on the 60% of code is error handling, that sounds like code that needs refactoring.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38872946" class="c"><input type="checkbox" id="c-38872946" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#38872874">parent</a><span>|</span><a href="#38872908">prev</a><span>|</span><a href="#38875560">next</a><span>|</span><label class="collapse" for="c-38872946">[-]</label><label class="expand" for="c-38872946">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not horrible, it&#x27;s ok and a bit repetitive. Really the whole thing about error handling in Go is overblown.</div><br/><div id="38873188" class="c"><input type="checkbox" id="c-38873188" checked=""/><div class="controls bullet"><span class="by">eweise</span><span>|</span><a href="#38872874">root</a><span>|</span><a href="#38872946">parent</a><span>|</span><a href="#38873013">next</a><span>|</span><label class="collapse" for="c-38873188">[-]</label><label class="expand" for="c-38873188">[2 more]</label></div><br/><div class="children"><div class="content">Because its repetitive its leads to incorrect code. I&#x27;ve seen more swallowed errors in Go than other languages.</div><br/><div id="38873355" class="c"><input type="checkbox" id="c-38873355" checked=""/><div class="controls bullet"><span class="by">13415</span><span>|</span><a href="#38872874">root</a><span>|</span><a href="#38873188">parent</a><span>|</span><a href="#38873013">next</a><span>|</span><label class="collapse" for="c-38873355">[-]</label><label class="expand" for="c-38873355">[1 more]</label></div><br/><div class="children"><div class="content">Honestly, I&#x27;ve seen way more problems with global exception handlers, which often lead to incomprehensible end user messages.</div><br/></div></div></div></div><div id="38873013" class="c"><input type="checkbox" id="c-38873013" checked=""/><div class="controls bullet"><span class="by">righthand</span><span>|</span><a href="#38872874">root</a><span>|</span><a href="#38872946">parent</a><span>|</span><a href="#38873188">prev</a><span>|</span><a href="#38875560">next</a><span>|</span><label class="collapse" for="c-38873013">[-]</label><label class="expand" for="c-38873013">[4 more]</label></div><br/><div class="children"><div class="content">It’s a bit repetitive but so is writing `for i, v := range n {}` everywhere. Code loops and repeats syntax all the time, so what? Argument doesn’t hold water for me (not attacking).</div><br/><div id="38874321" class="c"><input type="checkbox" id="c-38874321" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38872874">root</a><span>|</span><a href="#38873013">parent</a><span>|</span><a href="#38875560">next</a><span>|</span><label class="collapse" for="c-38874321">[-]</label><label class="expand" for="c-38874321">[3 more]</label></div><br/><div class="children"><div class="content">Repetitive code is a language flaw IMO. There are certainly more concise alternatives to the common case of that loop construct in many languages.</div><br/><div id="38875817" class="c"><input type="checkbox" id="c-38875817" checked=""/><div class="controls bullet"><span class="by">aatd86</span><span>|</span><a href="#38872874">root</a><span>|</span><a href="#38874321">parent</a><span>|</span><a href="#38874691">next</a><span>|</span><label class="collapse" for="c-38875817">[-]</label><label class="expand" for="c-38875817">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an interesting opinion.
I tend to believe there can be value in repetitive code patterns for recognition.<p>It can make a language easier to read and understand although a bit more tedious to write.<p>It&#x27;s especially interesting nowadays when LLM models can write parts of it. It alleviates the writing part.</div><br/></div></div><div id="38874691" class="c"><input type="checkbox" id="c-38874691" checked=""/><div class="controls bullet"><span class="by">righthand</span><span>|</span><a href="#38872874">root</a><span>|</span><a href="#38874321">parent</a><span>|</span><a href="#38875817">prev</a><span>|</span><a href="#38875560">next</a><span>|</span><label class="collapse" for="c-38874691">[-]</label><label class="expand" for="c-38874691">[1 more]</label></div><br/><div class="children"><div class="content">Then people should use those languages. From the beginning Go has been about simplicity and utility, not about providing multiple patterns and alternate syntax.<p>I would also argue that repetitive code is a failure of the engineer who implemented it. If writing code is repetitive then people may want to look into generating it instead.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38874542" class="c"><input type="checkbox" id="c-38874542" checked=""/><div class="controls bullet"><span class="by">jmyeet</span><span>|</span><a href="#38872874">prev</a><span>|</span><a href="#38873839">next</a><span>|</span><label class="collapse" for="c-38874542">[-]</label><label class="expand" for="c-38874542">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A key point was the use of a plain string to specify the path in an import statement, giving a flexibility that we were correct in believing would be important.<p><i>Wrong.</i><p>Importing a string is like a touchscreen UI in a car: it&#x27;s deferring the problem. It&#x27;s lazy.<p>&gt; But we didn&#x27;t have enough experience using a package manager with lots of versions of packages and the very difficult problems trying to resolve the dependency graph.<p>No one on the team had ever used Java? Really? Maven was ~8 yeras old when Go was released. It came from previous learnings and errors with Ant. Maven did other things too that aren&#x27;t necessarily relevant or necessary (eg standardized directory structure). But the dependency system was really solid even if it was verbose because it was XML.<p>&gt; Second, the business of engaging the community to help solve the dependency management problem was well-intentioned<p>This feels ahistorical. It felt more like the problem wasn&#x27;t understood and&#x2F;or thought important. This fits in with the importing a string: it&#x27;s a way of not solving the problem, of kicking the can down the street.</div><br/></div></div><div id="38873839" class="c"><input type="checkbox" id="c-38873839" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#38874542">prev</a><span>|</span><a href="#38872959">next</a><span>|</span><label class="collapse" for="c-38873839">[-]</label><label class="expand" for="c-38873839">[3 more]</label></div><br/><div class="children"><div class="content">I gotta say, reading this tells me exactly why Go struggles to evolve as a language.<p>Go ahead, skimming the article tell me what go got wrong?  Stumped?  Yeah, well I was too.  That&#x27;s because a lead designer can certainly write paragraphs on paragraphs of &quot;Look at how amazing and kool we are for being so smart&quot; but doesn&#x27;t seem capable of writing more than a half a sentence of &quot;we got this wrong&quot;.<p>I saw 2 things Pike believes go got wrong.  Documentation and packaging.  The rest is a lot of self congratulatory &quot;Look at how smart we are and how dumb our critics are&quot;.<p>No language is perfect, every language has it&#x27;s own weaknesses (and go has plenty).  Yet for some reason Pike can&#x27;t help but gush over how perfect it is.  Even with the 2 faults listed, the documentation fault very much has an undertone of &quot;our functions are so simple but the dumb users weren&#x27;t smart enough to understand the amazingness of our elegant code and libraries.&quot;<p>&gt; The key missing piece was examples of even the simplest functions. We thought that all you needed to do was say what something did; it took us too long to accept that showing how to use it was even more valuable.<p>Go is a language designed in the last 20 years that decided &quot;You know what wasn&#x27;t bad about C? Pointers and null&quot;.  Yet the only part pike can really fault is &quot;well, we didn&#x27;t know how to do package management so we sort of messed that up&quot;.<p>He even goes so far as to talk about how interfaces are so good and generics are dumb even though go has the notorious `interface {}` used to try, in an type unsafe way, to pass around random objects. (But hey, pike hand waves that away with &quot;the dumb community just isn&#x27;t smart enough to accept the brilliance of our type system&quot;.)<p>How can a language evolve when the lead designer puts on blinders to the community raising faults?  When a &quot;what we got right, what we got wrong&quot; post is filled with how awesome the language is with scant reference to what is wrong?  Even just openly dismissing concerns with the language?<p>Contrast that with a lead language architect I really like, Brian Goetz (seriously, go watch his talks about evolving Java).  His approach is nearly the polar opposite.  It&#x27;s &quot;Ok, we&#x27;ve seen that a lot of people using java run into problem X, so we are going work hard to find language or library solutions which help improve things for the developers&quot;.  They very rarely just dismiss problems and when they do it&#x27;s more along the lines of &quot;Well, we&#x27;d love to have it but ultimately there&#x27;s not a good way we can think of to do this which is also backwards compatible.&quot;<p>And you can really see that in the way java has evolved from 8-&gt;21.  From adopting  a faster release process, a ton of new language features, and a LOT of active development into the most painful parts of dev work.  Virtual threads is a shining example of this.  Java now has go like concurrency even though it took several iterations and trials to bring that in, they worked hard to evolve the language in a way that fits perfectly.  Valhalla is another great example of the language working hard to solve real problems.  A 10 year project open to the community working to fundamentally redefine the JVM memory model because the one designed in the 90s doesn&#x27;t fit with modern hardware.<p>But hey, if you like go, that&#x27;s great.  Just don&#x27;t expect even an iota of evolution.  Barring a change in leadership, generics is almost certainly the last new language feature (at least in this decade).  A feature that landed primarily because of over a decade of articles and community screaming about how horrible the lack of generics impacts everything.</div><br/><div id="38876756" class="c"><input type="checkbox" id="c-38876756" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#38873839">parent</a><span>|</span><a href="#38875569">next</a><span>|</span><label class="collapse" for="c-38876756">[-]</label><label class="expand" for="c-38876756">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, Go pointers do not allow pointer arithmetic and unsafe casting. They are really not much different than Java&#x27;s references.<p>The main issue is null. And you can&#x27;t even say Rob Pike is not deeply familiar with Tony Hoare, and yet the billion dollar mistake was very eagerly repeated.</div><br/></div></div><div id="38875569" class="c"><input type="checkbox" id="c-38875569" checked=""/><div class="controls bullet"><span class="by">booleandilemma</span><span>|</span><a href="#38873839">parent</a><span>|</span><a href="#38876756">prev</a><span>|</span><a href="#38872959">next</a><span>|</span><label class="collapse" for="c-38875569">[-]</label><label class="expand" for="c-38875569">[1 more]</label></div><br/><div class="children"><div class="content"><i>Just don&#x27;t expect even an iota of evolution. Barring a change in leadership, generics is almost certainly the last new language feature (at least in this decade)</i><p>Great! :)</div><br/></div></div></div></div><div id="38872959" class="c"><input type="checkbox" id="c-38872959" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#38873839">prev</a><span>|</span><label class="collapse" for="c-38872959">[-]</label><label class="expand" for="c-38872959">[33 more]</label></div><br/><div class="children"><div class="content">He’s claiming go popularised concurrency and invented interfaces? I’m sorry but that’s laughable.<p>I mean, congratulations, you created a new popular programming language, and that’s not nothing, but let’s not rewrite history here.</div><br/><div id="38873072" class="c"><input type="checkbox" id="c-38873072" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#38872959">parent</a><span>|</span><a href="#38872981">next</a><span>|</span><label class="collapse" for="c-38873072">[-]</label><label class="expand" for="c-38873072">[11 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you read the Interfaces section properly. Rob is not claiming go invented interfaces.<p>If you want to level such a charge that he is rewriting history, you need to take special care yourself in representing his views accurately.</div><br/><div id="38873252" class="c"><input type="checkbox" id="c-38873252" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873072">parent</a><span>|</span><a href="#38873476">next</a><span>|</span><label class="collapse" for="c-38873252">[-]</label><label class="expand" for="c-38873252">[8 more]</label></div><br/><div class="children"><div class="content">I came away with the impression they were saying they&#x27;d invented interfaces, so I reread it:<p>&gt; That idea was exciting for us, and the possibility that this could become a foundational programming construct was intoxicating.<p>Talking about interfaces as an idea that could become a foundational programming construct definitely sounds like they&#x27;re saying they invented it.</div><br/><div id="38874001" class="c"><input type="checkbox" id="c-38874001" checked=""/><div class="controls bullet"><span class="by">PH95VuimJjqBqy</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873252">parent</a><span>|</span><a href="#38873718">next</a><span>|</span><label class="collapse" for="c-38874001">[-]</label><label class="expand" for="c-38874001">[3 more]</label></div><br/><div class="children"><div class="content">go&#x27;s version of interfaces is fairly unique, if you read that as them inventing interfaces you misread.  If you read it as them having a unique twist on interfaces they felt was powerful, then you read it correctly.<p>It never even occurred to me that someone would suggest they&#x27;re claiming to have invented interfaces, mostly because obviously they didn&#x27;t.</div><br/><div id="38874315" class="c"><input type="checkbox" id="c-38874315" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38874001">parent</a><span>|</span><a href="#38873718">next</a><span>|</span><label class="collapse" for="c-38874315">[-]</label><label class="expand" for="c-38874315">[2 more]</label></div><br/><div class="children"><div class="content">I was careful to try read what was said; the language might be a bit loose because it&#x27;s a transcript of a live talk. That said, the example they gave, and their motivating problem of the qsort API in C don&#x27;t show anything about using nominal interfaces, and instead look like a normal use of interfaces, combined with language about being wowed of how powerful they could be.</div><br/><div id="38876237" class="c"><input type="checkbox" id="c-38876237" checked=""/><div class="controls bullet"><span class="by">PH95VuimJjqBqy</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38874315">parent</a><span>|</span><a href="#38873718">next</a><span>|</span><label class="collapse" for="c-38876237">[-]</label><label class="expand" for="c-38876237">[1 more]</label></div><br/><div class="children"><div class="content">The text is recreated below:<p>&gt; It&#x27;s clear that interfaces are, with concurrency, a distinguishing idea in Go. They are Go&#x27;s answer to objected-oriented design, in the original, behavior-focused style, despite a continuing push by newcomers to make structs carry that load.<p>&gt; Making interfaces dynamic, with no need to announce ahead of time which types implement them, bothered some early critics, and still irritates a few, but it&#x27;s important to the style of programming that Go fostered.  Much of the standard library is built upon their foundation, and broader subjects such as testing and managing dependencies rely heavily on their generous, &quot;all are welcome&quot; nature.<p>&gt; I feel that interfaces are one of the best-designed things in Go.<p>&gt; Other than a few early conversations about whether data should be included in their definition, they arrived fully formed on literally the first day of discussions.<p>&gt; And there is a story to tell there.<p>&gt; On that famous first day in Robert&#x27;s and my office, we asked the question of what to do about polymorphism. Ken and I knew from C that qsort could serve as a difficult test case, so the three of us started to talk about how our embryonic language could implement a type-safe sort routine.<p>&gt; Robert and I came up with the same idea pretty much simultaneously: using methods on types to provide the operations that sort needed. That notion quickly grew into the idea that value types had behaviors, defined as methods, and that sets of methods could provide interfaces that functions could operate on. Go&#x27;s interfaces arose pretty much right away.<p>&gt; That&#x27;s something that is not often not acknowledged: Go&#x27;s sort is implemented as a function that operates on an interface. This is not the style of object-oriented programming most people were familiar with, but it&#x27;s a very powerful idea.<p>&gt; That idea was exciting for us, and the possibility that this could become a foundational<p>&gt; programming construct was intoxicating.  When Russ joined, he soon pointed out how I&#x2F;O would fit beautifully into this idea, and the library took place rapidly, based in large part on the three famous interfaces: empty, Writer, and Reader, holding an average of two thirds of a method each.  Those tiny methods are idiomatic to Go, and ubiquitous.<p>&gt; _THE WAY INTERFACES WORKED became not only a distinguishing feature of Go, they became the way we thought about libraries, and generality, and composition. It was heady stuff.<p>emphasis at the end there is mine.<p>how the hell _anyone_ reads that and comes away with the idea that they&#x27;re claiming they invented the idea of interfaces is beyond me.<p>my only guess here is that many people are not familiar with the sort problem they&#x27;re describing.<p>very famously, C++&#x27;s sort is more performant than C&#x27;s sort because C uses a void pointer and C++ uses templates.  The extra type information allows C++ to optimize the sort in a way that C cannot, so while C is generally more performant than C++ in a lot of ways, this is one particular area where C++ shines.<p>So it&#x27;s no surprise that Rob Pike, et al, paid close attention to sort as something to improve over C and the way to do that is having more type information available (C++ very clearly has shown this).</div><br/></div></div></div></div></div></div><div id="38873718" class="c"><input type="checkbox" id="c-38873718" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873252">parent</a><span>|</span><a href="#38874001">prev</a><span>|</span><a href="#38873476">next</a><span>|</span><label class="collapse" for="c-38873718">[-]</label><label class="expand" for="c-38873718">[4 more]</label></div><br/><div class="children"><div class="content">In his defence, their interfaces do work somewhat differently to Java&#x27;s, because they don&#x27;t need to be explicitly implemented. I don&#x27;t know if that matters enough to make them a novel invention, though.</div><br/><div id="38874968" class="c"><input type="checkbox" id="c-38874968" checked=""/><div class="controls bullet"><span class="by">shakow</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873718">parent</a><span>|</span><a href="#38874764">next</a><span>|</span><label class="collapse" for="c-38874968">[-]</label><label class="expand" for="c-38874968">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  I don&#x27;t know if that matters enough to make them a novel invention, though.<p>That&#x27;s called structural typing, which is at least as old as OCaml, i.e. 25+ y.o.</div><br/></div></div><div id="38874764" class="c"><input type="checkbox" id="c-38874764" checked=""/><div class="controls bullet"><span class="by">za3faran</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873718">parent</a><span>|</span><a href="#38874968">prev</a><span>|</span><a href="#38874224">next</a><span>|</span><label class="collapse" for="c-38874764">[-]</label><label class="expand" for="c-38874764">[1 more]</label></div><br/><div class="children"><div class="content">Java&#x27;s interfaces are nominal. What you&#x27;re describing is called structural interfaces, and they exist in other languages like Scala.</div><br/></div></div></div></div></div></div><div id="38873476" class="c"><input type="checkbox" id="c-38873476" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873072">parent</a><span>|</span><a href="#38873252">prev</a><span>|</span><a href="#38872981">next</a><span>|</span><label class="collapse" for="c-38873476">[-]</label><label class="expand" for="c-38873476">[2 more]</label></div><br/><div class="children"><div class="content">It sounded like it to me.  I kept thinking didn&#x27;t java have interfaces to prevent multiple inheritance?  All go did was replace all inheritance with interfaces</div><br/><div id="38873686" class="c"><input type="checkbox" id="c-38873686" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873476">parent</a><span>|</span><a href="#38872981">next</a><span>|</span><label class="collapse" for="c-38873686">[-]</label><label class="expand" for="c-38873686">[1 more]</label></div><br/><div class="children"><div class="content">Which I’m pretty sure CLU did first (honestly, I’m pretty sure nearly every good idea was in CLU first).</div><br/></div></div></div></div></div></div><div id="38872981" class="c"><input type="checkbox" id="c-38872981" checked=""/><div class="controls bullet"><span class="by">tomp</span><span>|</span><a href="#38872959">parent</a><span>|</span><a href="#38873072">prev</a><span>|</span><label class="collapse" for="c-38872981">[-]</label><label class="expand" for="c-38872981">[21 more]</label></div><br/><div class="children"><div class="content">What other languages of comparable popularity do you know that had concurrency similar to Go&#x27;s, and interfaces?<p>Actually, name just one that has either, even today!</div><br/><div id="38873193" class="c"><input type="checkbox" id="c-38873193" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38872981">parent</a><span>|</span><a href="#38874288">next</a><span>|</span><label class="collapse" for="c-38873193">[-]</label><label class="expand" for="c-38873193">[7 more]</label></div><br/><div class="children"><div class="content">Java has had interfaces for a _long_ time, and it definitely meets the popularity requirement.<p>EDIT: Since its 1.0 release in 1996</div><br/><div id="38873525" class="c"><input type="checkbox" id="c-38873525" checked=""/><div class="controls bullet"><span class="by">tomp</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873193">parent</a><span>|</span><a href="#38874288">next</a><span>|</span><label class="collapse" for="c-38873525">[-]</label><label class="expand" for="c-38873525">[6 more]</label></div><br/><div class="children"><div class="content">There&#x27;s nothing similar about Java&#x27;s and Go&#x27;s interfaces, except the name.<p>Java interfaces must be implemented explicitly (they&#x27;re <i>nominal</i>).<p>Go interfaces are automatically satisfied by any type that declares matching methods (similar to <i>protocols</i> in other languages) (they&#x27;re <i>structural</i>).</div><br/><div id="38873759" class="c"><input type="checkbox" id="c-38873759" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873525">parent</a><span>|</span><a href="#38873766">next</a><span>|</span><label class="collapse" for="c-38873759">[-]</label><label class="expand" for="c-38873759">[1 more]</label></div><br/><div class="children"><div class="content">They are certainly different, but to say there is nothing similar is plainly untrue - apart from nominal vs structural, they are pretty much the same.<p>I&#x27;m not sure how significant the nominal vs structural distinction even is. In Go, a struct can implement an interface without declaring it, but the programmer still needs to deliberately write the struct to conform to the definition of the interface, so they&#x27;re still coupled, just not explicitly [1]. Yes, it is possible to define a new interface which fits existing structs which weren&#x27;t designed for it - but how common is that? That is, how common is it for two or more structs to have a meaningful overlapping set of methods without being designed to conform to some pre-existing interface?<p>[1] which is obviously a bad thing</div><br/></div></div><div id="38873766" class="c"><input type="checkbox" id="c-38873766" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873525">parent</a><span>|</span><a href="#38873759">prev</a><span>|</span><a href="#38874330">next</a><span>|</span><label class="collapse" for="c-38873766">[-]</label><label class="expand" for="c-38873766">[2 more]</label></div><br/><div class="children"><div class="content">Go&#x27;s nominal interface feature is definitely interesting, but that section doesn&#x27;t talk about how amazing it was to implement interfaces implicitly:<p>&gt; That notion quickly grew into the idea that value types had behaviors, defined as methods, and that sets of methods could provide interfaces that functions could operate on. Go&#x27;s interfaces arose pretty much right away.<p>If you replace Go with Java, this would&#x27;ve accurately described Java ~30 years ago.</div><br/><div id="38873780" class="c"><input type="checkbox" id="c-38873780" checked=""/><div class="controls bullet"><span class="by">tomp</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873766">parent</a><span>|</span><a href="#38874330">next</a><span>|</span><label class="collapse" for="c-38873780">[-]</label><label class="expand" for="c-38873780">[1 more]</label></div><br/><div class="children"><div class="content">You missed this:<p><i>&gt; Making interfaces dynamic, with no need to announce ahead of time which types implement them</i></div><br/></div></div></div></div><div id="38874330" class="c"><input type="checkbox" id="c-38874330" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873525">parent</a><span>|</span><a href="#38873766">prev</a><span>|</span><a href="#38874055">next</a><span>|</span><label class="collapse" for="c-38874330">[-]</label><label class="expand" for="c-38874330">[1 more]</label></div><br/><div class="children"><div class="content">So they&#x27;re like python&#x27;s Abstract Base Classes?  (No idea which came first)</div><br/></div></div><div id="38874055" class="c"><input type="checkbox" id="c-38874055" checked=""/><div class="controls bullet"><span class="by">marwis</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873525">parent</a><span>|</span><a href="#38874330">prev</a><span>|</span><a href="#38874288">next</a><span>|</span><label class="collapse" for="c-38874055">[-]</label><label class="expand" for="c-38874055">[1 more]</label></div><br/><div class="children"><div class="content">Scala had it 2 years before golang, OCaml more than decade.
<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Structural_type_system" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Structural_type_system</a></div><br/></div></div></div></div></div></div><div id="38874288" class="c"><input type="checkbox" id="c-38874288" checked=""/><div class="controls bullet"><span class="by">OkayPhysicist</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38872981">parent</a><span>|</span><a href="#38873193">prev</a><span>|</span><a href="#38873191">next</a><span>|</span><label class="collapse" for="c-38874288">[-]</label><label class="expand" for="c-38874288">[1 more]</label></div><br/><div class="children"><div class="content">Elixir and Erlang have both, and Go&#x27;s concurrency model is just a poor imitation of what you get from Erlang, that&#x27;s been around since the 80&#x27;s.</div><br/></div></div><div id="38873191" class="c"><input type="checkbox" id="c-38873191" checked=""/><div class="controls bullet"><span class="by">easton</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38872981">parent</a><span>|</span><a href="#38874288">prev</a><span>|</span><a href="#38873033">next</a><span>|</span><label class="collapse" for="c-38873191">[-]</label><label class="expand" for="c-38873191">[1 more]</label></div><br/><div class="children"><div class="content">C#? It has channels and good concurrency stuff. I don’t know if it was as mature in 2007 when they did this work.<p>edit: Concurrency, not the language itself. That was mature.</div><br/></div></div><div id="38873033" class="c"><input type="checkbox" id="c-38873033" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38872981">parent</a><span>|</span><a href="#38873191">prev</a><span>|</span><a href="#38874097">next</a><span>|</span><label class="collapse" for="c-38873033">[-]</label><label class="expand" for="c-38873033">[5 more]</label></div><br/><div class="children"><div class="content">Erlang</div><br/><div id="38873053" class="c"><input type="checkbox" id="c-38873053" checked=""/><div class="controls bullet"><span class="by">phinnaeus</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873033">parent</a><span>|</span><a href="#38873541">next</a><span>|</span><label class="collapse" for="c-38873053">[-]</label><label class="expand" for="c-38873053">[2 more]</label></div><br/><div class="children"><div class="content">&gt; of comparable popularity</div><br/><div id="38873498" class="c"><input type="checkbox" id="c-38873498" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873053">parent</a><span>|</span><a href="#38873541">next</a><span>|</span><label class="collapse" for="c-38873498">[-]</label><label class="expand" for="c-38873498">[1 more]</label></div><br/><div class="children"><div class="content">It was more popular than go in 2009</div><br/></div></div></div></div><div id="38873541" class="c"><input type="checkbox" id="c-38873541" checked=""/><div class="controls bullet"><span class="by">tomp</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873033">parent</a><span>|</span><a href="#38873053">prev</a><span>|</span><a href="#38873059">next</a><span>|</span><label class="collapse" for="c-38873541">[-]</label><label class="expand" for="c-38873541">[1 more]</label></div><br/><div class="children"><div class="content">Erlang&#x27;s processes might have similar semantics to Go&#x27;s goroutines (green threads) but Erlang is a much simpler language, because it doesn&#x27;t have shared state.<p>A lot of work went into optimizing Go&#x27;s GC to be able to cope with concurrency.</div><br/></div></div><div id="38873059" class="c"><input type="checkbox" id="c-38873059" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873033">parent</a><span>|</span><a href="#38873541">prev</a><span>|</span><a href="#38874097">next</a><span>|</span><label class="collapse" for="c-38873059">[-]</label><label class="expand" for="c-38873059">[1 more]</label></div><br/><div class="children"><div class="content">Erlang is not a popular language.</div><br/></div></div></div></div><div id="38874097" class="c"><input type="checkbox" id="c-38874097" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38872981">parent</a><span>|</span><a href="#38873033">prev</a><span>|</span><a href="#38873338">next</a><span>|</span><label class="collapse" for="c-38874097">[-]</label><label class="expand" for="c-38874097">[1 more]</label></div><br/><div class="children"><div class="content">Go&#x27;s concurrency isn&#x27;t even that good. It just looks good for anyone coming from the languages which don&#x27;t have that (which are the majority).<p>One of the earliest high level languages with powerful concurrency and parallelism APIs are C# and F# (TPL and Parallel&#x2F;PLINQ, some of which was available back in 2010).</div><br/></div></div><div id="38873338" class="c"><input type="checkbox" id="c-38873338" checked=""/><div class="controls bullet"><span class="by">scythe</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38872981">parent</a><span>|</span><a href="#38874097">prev</a><span>|</span><label class="collapse" for="c-38873338">[-]</label><label class="expand" for="c-38873338">[5 more]</label></div><br/><div class="children"><div class="content">Fibers were implemented by Microsoft in Win32 API in 1996:<p><a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20191011-00&#x2F;?p=102989" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20191011-00&#x2F;?p=10...</a><p>As the review Chen links discusses, it turns out that M:N threading (i.e. goroutines) and good C compatibility are mutually exclusive. Go went one way, every other language went the other way. The most common alternative is stackless coroutines, which are much more widely implemented than the Go model.</div><br/><div id="38873521" class="c"><input type="checkbox" id="c-38873521" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873338">parent</a><span>|</span><a href="#38873602">next</a><span>|</span><label class="collapse" for="c-38873521">[-]</label><label class="expand" for="c-38873521">[1 more]</label></div><br/><div class="children"><div class="content">That review is by Gor Nishanov: <a href="http:&#x2F;&#x2F;www.open-std.org&#x2F;JTC1&#x2F;SC22&#x2F;WG21&#x2F;docs&#x2F;papers&#x2F;2018&#x2F;p1364r0.pdf" rel="nofollow">http:&#x2F;&#x2F;www.open-std.org&#x2F;JTC1&#x2F;SC22&#x2F;WG21&#x2F;docs&#x2F;papers&#x2F;2018&#x2F;p136...</a>  The most relevant quote:<p>&gt; <i>DO NOT USE FIBERS!</i></div><br/></div></div><div id="38873602" class="c"><input type="checkbox" id="c-38873602" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873338">parent</a><span>|</span><a href="#38873521">prev</a><span>|</span><a href="#38873554">next</a><span>|</span><label class="collapse" for="c-38873602">[-]</label><label class="expand" for="c-38873602">[1 more]</label></div><br/><div class="children"><div class="content">And COM interfaces. They could be clunky in C&#x2F;C++ but Delphi implemented interfaces quite nicely[1] back in 1999[2].<p>And being for Windows, Delphi had full access to Win32 API.<p>[1]: <a href="https:&#x2F;&#x2F;docwiki.embarcadero.com&#x2F;RADStudio&#x2F;Sydney&#x2F;en&#x2F;Using_Interfaces_Across_the_Hierarchy" rel="nofollow">https:&#x2F;&#x2F;docwiki.embarcadero.com&#x2F;RADStudio&#x2F;Sydney&#x2F;en&#x2F;Using_In...</a><p>[2]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;History_of_Delphi_(software)#Borland_Delphi_5" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;History_of_Delphi_(software)#B...</a></div><br/></div></div><div id="38873554" class="c"><input type="checkbox" id="c-38873554" checked=""/><div class="controls bullet"><span class="by">tomp</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873338">parent</a><span>|</span><a href="#38873602">prev</a><span>|</span><label class="collapse" for="c-38873554">[-]</label><label class="expand" for="c-38873554">[2 more]</label></div><br/><div class="children"><div class="content">Even stackless coroutines aren&#x27;t very popular. No other <i>popular</i> language <i>specification</i> has them (except maybe Haskell&#x2F;GHC, but it&#x27;s not that popular).</div><br/><div id="38873975" class="c"><input type="checkbox" id="c-38873975" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#38872959">root</a><span>|</span><a href="#38873554">parent</a><span>|</span><label class="collapse" for="c-38873975">[-]</label><label class="expand" for="c-38873975">[1 more]</label></div><br/><div class="children"><div class="content">JavaScript?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>