<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715763670889" as="style"/><link rel="stylesheet" href="styles.css?v=1715763670889"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.cs.cmu.edu/~aldrich/papers/objects-essay.pdf">The power of interoperability: Why objects are inevitable (2013) [pdf]</a> <span class="domain">(<a href="https://www.cs.cmu.edu">www.cs.cmu.edu</a>)</span></div><div class="subtext"><span>pramodbiligiri</span> | <span>5 comments</span></div><br/><div><div id="40364632" class="c"><input type="checkbox" id="c-40364632" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40364630">next</a><span>|</span><label class="collapse" for="c-40364632">[-]</label><label class="expand" for="c-40364632">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 3). Alternative mechanisms can provide interoperable extension only by using service abstraction themselves—and thus are equivalent to what we consider the essence of objects.<p>Since virtually any language can delegate behaviour this way, the above claim is really saying that every language carries the essence of objects.  (And I agree - for <i>this</i> definition of objects).<p>So the follow-up question becomes &quot;What&#x27;s so special about about languages which brand themselves as OOP - as opposed to another paradigm?&quot;</div><br/></div></div><div id="40364630" class="c"><input type="checkbox" id="c-40364630" checked=""/><div class="controls bullet"><span class="by">KingOfCoders</span><span>|</span><a href="#40364632">prev</a><span>|</span><a href="#40364372">next</a><span>|</span><label class="collapse" for="c-40364630">[-]</label><label class="expand" for="c-40364630">[1 more]</label></div><br/><div class="children"><div class="content">Today we have no interoperability compared to 20 years ago (that existed in Windows or Macos applications).<p>Most applications people use are on the web or mobile today. Every application on the web or mobile (Figma, Notion, ...) is basically a silo or one way street.</div><br/></div></div><div id="40364372" class="c"><input type="checkbox" id="c-40364372" checked=""/><div class="controls bullet"><span class="by">GuestHNUser</span><span>|</span><a href="#40364630">prev</a><span>|</span><label class="collapse" for="c-40364372">[-]</label><label class="expand" for="c-40364372">[2 more]</label></div><br/><div class="children"><div class="content">I find it sad that this paper mentions two valid critiques of OOP[0][1], yet makes no effort to engage with their specific criticisms. Also, citing Microsoft&#x27;s COM object system as _the_ example of OOP&#x27;s great success must mean that the authors are simply ignorant to how bad COM is and why Microsft has ceased anything beyond legacy support for it.<p>Ultimately, I find the thesis of the paper fundamentally wrong for presuming that OOP is somehow more beneficial than other approaches to dynamic dispatch. Moreover, the use of interfaces in thr paper are more restrictive to code structure, and in turn, are more likely hurt code reuse than help it.<p>Interfaces are an inherently weaker form of the age old Operation Code and data packet paradigm. Take the Widget interface the paper gives as an example (page 5). This interface has now been set in stone. Any additions that would be useful for the widget interface, say OnClick(), will require a breaking change. This is because all code using the old interface will have to be updated and recompiled to satisfy the new interface requirements (even if a widget won&#x27;t functionally change from using said new interface). Meanwhile for code using op codes, a new op code value is defined and nothing in the old code is required to change. (This assumes that this old code will perform a no operation for the new opcode, which historically has been the case for systems that use this method).<p>In fact, Win32 did exactly this opcode and data packet protocol for its message loop to great long term success. They have regularly extended their existing code without breaking backwards compatibility of older versions. The longevity of code in typical OO systems pales in comparison.<p>[0] <a href="https:&#x2F;&#x2F;harmful.cat-v.org&#x2F;software&#x2F;OO_programming&#x2F;why_oo_sucks" rel="nofollow">https:&#x2F;&#x2F;harmful.cat-v.org&#x2F;software&#x2F;OO_programming&#x2F;why_oo_suc...</a>
[1] <a href="http:&#x2F;&#x2F;stlport.org&#x2F;resources&#x2F;StepanovUSA.html" rel="nofollow">http:&#x2F;&#x2F;stlport.org&#x2F;resources&#x2F;StepanovUSA.html</a></div><br/><div id="40364461" class="c"><input type="checkbox" id="c-40364461" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#40364372">parent</a><span>|</span><label class="collapse" for="c-40364461">[-]</label><label class="expand" for="c-40364461">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  I think that object orientedness is almost as much of a hoax as Artificial Intelligence<p>Oof, killing two hypes with one stone!</div><br/></div></div></div></div></div></div></div></div></div></body></html>