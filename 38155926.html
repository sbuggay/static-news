<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699434060476" as="style"/><link rel="stylesheet" href="styles.css?v=1699434060476"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://newcome.wordpress.com/2022/11/28/the-quest-for-modularity/">The quest for modularity (2022)</a>Â <span class="domain">(<a href="https://newcome.wordpress.com">newcome.wordpress.com</a>)</span></div><div class="subtext"><span>mooreds</span> | <span>3 comments</span></div><br/><div><div id="38186465" class="c"><input type="checkbox" id="c-38186465" checked=""/><div class="controls bullet"><span class="by">shoo</span><span>|</span><a href="#38186576">next</a><span>|</span><label class="collapse" for="c-38186465">[-]</label><label class="expand" for="c-38186465">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think that the most important part of a system design is the logical decomposition initially, and secondarily the topology (servers and pods, networks, etc). If the aspects of the logical design (domain?) are correct we should be able to arrange things in different topologies as we grow.<p>That sounds reasonable, but defining a good decomposition initially is perhaps very hard!<p>One concrete rule of thumb to define a decomposition is to apply Parnas&#x27; criteria:<p>&gt; We have tried to demonstrate by these examples that it is almost always incorrect to begin the decomposition of a system into modules on the basis of a flowchart. We propose instead that one begins with a list of difficult design decisions or design decisions which are likely to change. Each module is then designed to hide such a decision from the others. [...]<p>-- Parnas, 1972<p>But, for a new domain, it&#x27;s still going to be challenging to be able to identify an a effective decomposition up front. Maybe once you&#x27;ve built 2 or 3 instances of a similar application in a similar problem domain, it starts to be easier to figure out what an effective decomposition is likely to be up front.<p>Another approach is to embrace the fact that you&#x27;re not going to be able to decompose the system correctly up front, and figure out how to structure development to accomodate that. I.e., how do you set things up to create the flexibility to change the decomposition mid way through delivery taking into account what you&#x27;ve learned.  E.g. if you&#x27;re tossing up between a mess in 1 git repo owned by one team vs carving up the problem and handing out the spoils chunk by chunk to teams scattered across a fixed org chart, prefer the thing that makes it easier to rapidly and flexibly adapt and cheaply change decomposition: e.g. everything in a big mess owned by 1 team in 1 repo where it&#x27;s possible to adjust decompositions without handoffs or external dependencies.<p>see also<p>&gt; one thing grug come to believe: not factor your application too early!<p>&gt; early on in project everything very abstract and like water: very little solid holds for grug&#x27;s struggling brain to hang on to. take time to develop &quot;shape&quot; of system and learn what even doing. grug try not to factor in early part of project and then, at some point, good cut-points emerge from code base<p>-- <a href="https:&#x2F;&#x2F;grugbrain.dev&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;grugbrain.dev&#x2F;</a></div><br/></div></div><div id="38186576" class="c"><input type="checkbox" id="c-38186576" checked=""/><div class="controls bullet"><span class="by">corethree</span><span>|</span><a href="#38186465">prev</a><span>|</span><label class="collapse" for="c-38186576">[-]</label><label class="expand" for="c-38186576">[1 more]</label></div><br/><div class="children"><div class="content">I think he&#x27;s getting lost in the complexity of infrastructure. Not realizing the true key of what modularity is. The truth is we don&#x27;t fully have a theory around all of it yet but we have a good idea about parts of it and how to maximize modularity of certain aspects of your program.<p>The segregation of state away from pure functions is the &quot;state&quot; of the art right now in terms of modularity. By doing this you are maximizing modularity of your program to the greatest extent that we know of in theory.<p>The segregation of computer logic into containers, servers, files, folders and all that other stuff are just illusions and arbitrary boxes that serve only to confuse. The most modular abstraction is the pure combinator. Once your program is in itself a combinator composed from other combinators, then and you can arbitrarily choose where you want to put them. Put one set of combinators in a container on one server or another set in a folder split among arbitrary files. Put em in libraries or don&#x27;t... up to you. Again it doesn&#x27;t matter... because your combinators flexible enough that you can move your combinators anywhere.<p>The infrastructure is irrelevant and an arbitrary choice in terms of the initial design. You must choose your code abstractions such that you have the flexibility to make ANY arbitrary infra choice and the pure combinator is the one such abstraction that maximizes the amount of choices you have.<p>The flaw with this pattern is that it doesn&#x27;t include state. Hence why you need to segregate it away using a pattern called: functional core, imperative shell. The IO monad in haskell actually forces you to program with the pattern.<p>We don&#x27;t fully know how to maximize modularity when we have state and functions working together so what we do is we just try to segregate the two concepts as much as possible. By doing this we have large sections of the program that are extremely modular and small singularities of the program where we have to combine state and function.<p>This is the front line in the quest for modularity. All the infra stuff is just fluff.<p>What the author talks about is largely inline with what I&#x27;m saying here but he&#x27;s getting a bit lost and not driving home to the key insight here that&#x27;s been formalized by languages like haskell.</div><br/></div></div></div></div></div></div></div></body></html>