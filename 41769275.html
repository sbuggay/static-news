<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728637262492" as="style"/><link rel="stylesheet" href="styles.css?v=1728637262492"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://xnacly.me/posts/2024/fun-with-iterators/">Fun with Go Iterators</a> <span class="domain">(<a href="https://xnacly.me">xnacly.me</a>)</span></div><div class="subtext"><span>xnacly</span> | <span>124 comments</span></div><br/><div><div id="41799810" class="c"><input type="checkbox" id="c-41799810" checked=""/><div class="controls bullet"><span class="by">openasocket</span><span>|</span><a href="#41799304">next</a><span>|</span><label class="collapse" for="c-41799810">[-]</label><label class="expand" for="c-41799810">[11 more]</label></div><br/><div class="children"><div class="content">I work with Go a lot at my job, and I definitely prefer functional programming so I chafe at the language a bit. I was excited to incorporate iterators into our code. Unfortunately, I&#x27;m also working in an environment where we are memory constrained, so on our hot path we need to not allocate at all. I tried playing with the iterators a bit, and couldn&#x27;t get it to produce something that didn&#x27;t allocate. I got close, but as much as a tried I couldn&#x27;t get below 1 allocation per loop (not per loop iteration, per loop). Which in any other setting would be fine, but not for our use case.</div><br/><div id="41801496" class="c"><input type="checkbox" id="c-41801496" checked=""/><div class="controls bullet"><span class="by">acheong08</span><span>|</span><a href="#41799810">parent</a><span>|</span><a href="#41803162">next</a><span>|</span><label class="collapse" for="c-41801496">[-]</label><label class="expand" for="c-41801496">[4 more]</label></div><br/><div class="children"><div class="content">This is probably one of the areas where Zig shines. I&#x27;m mostly a Gopher but reading Zig is just as easy while ensuring that no allocations are hidden</div><br/><div id="41805612" class="c"><input type="checkbox" id="c-41805612" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#41799810">root</a><span>|</span><a href="#41801496">parent</a><span>|</span><a href="#41803838">next</a><span>|</span><label class="collapse" for="c-41805612">[-]</label><label class="expand" for="c-41805612">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen issues in Go codebases a couple times where a _lot_ of effort has been spend trying to track down allocations and optimize memory usage. It sounds like the parent comment is describing writing new code striving to avoid allocations, which probably isn&#x27;t something that Go is that much harder for than similar languages, but I feel like it&#x27;s one of the more ambiguous languages in terms of the amount of context needed to be able to identify if a given variable is allocated on the heap or not. A pointer might be a pointer to the stack, or a pointer to the heap, or a pointer to an interface that might _also_ have a heap allocation on the concrete-typed value behind that. If you see a slice, it might be a heap allocation, or it might be a reference to a static array, or it might be a reference to another slice...which has the same possibility to be either a heap allocation, a reference to a static array, or just be another link in the chain to a different slice.<p>This is a place where I feel like the type of simplicity that Go touts doesn&#x27;t actually feel like it&#x27;s optimizing for the right thing. Having a single type for all pointers certainly has a sort of abstract simplicity to it, but I feel like it doesn&#x27;t actually make things simpler when using it in the long run. My perspective is that &quot;conceptual&quot; simplicity is a balancing act between not having too many concepts but also not having concepts being too confusing individually, and I&#x27;m surprised that Go is used for domains like needing to completely avoid allocations in a hot path when the language doesn&#x27;t really feel like it&#x27;s designed to make easy.</div><br/></div></div><div id="41803838" class="c"><input type="checkbox" id="c-41803838" checked=""/><div class="controls bullet"><span class="by">atomic128</span><span>|</span><a href="#41799810">root</a><span>|</span><a href="#41801496">parent</a><span>|</span><a href="#41805612">prev</a><span>|</span><a href="#41802409">next</a><span>|</span><label class="collapse" for="c-41803838">[-]</label><label class="expand" for="c-41803838">[1 more]</label></div><br/><div class="children"><div class="content">I have not looked at Go&#x27;s iterator range loop implementation yet. So somebody tell me if I&#x27;m wrong here.<p>My guess is that Go is probably wrapping the body of the range loop into a closure, and passing that closure into the iterator function as the yield function. A break in the body of the loop becomes a &quot;return false&quot; in the closure.<p>The allocation is probably the closure environment struct (giving access to variables prior to the range loop).<p>This closure might escape through the iterator function so Go can&#x27;t just put the environment struct onto the stack, it has to escape to the heap.<p>The cost is small but it&#x27;s not free. Usually, not having to think about the allocation is an advantage. In the rare case can&#x27;t afford the iterator, do it differently.<p>Go is great.</div><br/></div></div><div id="41802409" class="c"><input type="checkbox" id="c-41802409" checked=""/><div class="controls bullet"><span class="by">kunley</span><span>|</span><a href="#41799810">root</a><span>|</span><a href="#41801496">parent</a><span>|</span><a href="#41803838">prev</a><span>|</span><a href="#41803162">next</a><span>|</span><label class="collapse" for="c-41802409">[-]</label><label class="expand" for="c-41802409">[1 more]</label></div><br/><div class="children"><div class="content">I know complaining about downvote is not the right thing, but the above is someone else&#x27;s comment, not mine. Why was it downvoted (I see it grayed) ? It&#x27;s an useful information without zealotry or &quot;we-know-betterism&quot;.</div><br/></div></div></div></div><div id="41803162" class="c"><input type="checkbox" id="c-41803162" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#41799810">parent</a><span>|</span><a href="#41801496">prev</a><span>|</span><a href="#41803542">next</a><span>|</span><label class="collapse" for="c-41803162">[-]</label><label class="expand" for="c-41803162">[4 more]</label></div><br/><div class="children"><div class="content">Same, I work in Go most of the time in performance and memory sensitive areas and the lack of usable abstractions grates so hard. I’m increasingly fed up of long hand everywhere and the bug volume and frequency it inherently produces particularly under change. I was worried this would be the outcome of the iterator proposal and am not surprised at all to find that yes, it is in practice. I was similarly disappointed with rand&#x2F;v2 where I provided feedback thah the interface in the middle of it had been seldom used and could have been eradicated and the choice was to preserve that part of the API because the compiler should in the future eradicate these costs. I see no actual plan for how that will be done though, and I’m skeptical it will happen in practice. I’ll finish with the comment that will lead to comment downvoting, but I derive tons of value for resource constrained work from rusts lazy iterator design combined with the aggressively optimizing compiler folding nice low cost of maintenance abstraction here into tight sometimes even vectorized or unrolled loops - it makes work I do demonstrably easier.</div><br/><div id="41804065" class="c"><input type="checkbox" id="c-41804065" checked=""/><div class="controls bullet"><span class="by">glenjamin</span><span>|</span><a href="#41799810">root</a><span>|</span><a href="#41803162">parent</a><span>|</span><a href="#41803542">next</a><span>|</span><label class="collapse" for="c-41804065">[-]</label><label class="expand" for="c-41804065">[3 more]</label></div><br/><div class="children"><div class="content">A question for both you and the parent:
If you are heavily performance and memory constrained, why are you using a language that gives you relatively little control over allocations?</div><br/><div id="41804321" class="c"><input type="checkbox" id="c-41804321" checked=""/><div class="controls bullet"><span class="by">openasocket</span><span>|</span><a href="#41799810">root</a><span>|</span><a href="#41804065">parent</a><span>|</span><a href="#41806928">next</a><span>|</span><label class="collapse" for="c-41804321">[-]</label><label class="expand" for="c-41804321">[1 more]</label></div><br/><div class="children"><div class="content">In my case it was a choice made long ago, when the exact consequences weren’t fully apparent. I don’t think when making those initial decisions people understood how important low memory usage would turn out to be, or that Go would be an obstacle to that. And we’ve got so much code in Go at this point it would be a huge lift to switch languages. The language does have some nice features that make things easier. It’s just in certain portions of the code, in the really hot loops.</div><br/></div></div><div id="41806928" class="c"><input type="checkbox" id="c-41806928" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#41799810">root</a><span>|</span><a href="#41804065">parent</a><span>|</span><a href="#41804321">prev</a><span>|</span><a href="#41803542">next</a><span>|</span><label class="collapse" for="c-41806928">[-]</label><label class="expand" for="c-41806928">[1 more]</label></div><br/><div class="children"><div class="content">Preexisting choice and strong holding bias in the organization</div><br/></div></div></div></div></div></div><div id="41803542" class="c"><input type="checkbox" id="c-41803542" checked=""/><div class="controls bullet"><span class="by">zmj</span><span>|</span><a href="#41799810">parent</a><span>|</span><a href="#41803162">prev</a><span>|</span><a href="#41799304">next</a><span>|</span><label class="collapse" for="c-41803542">[-]</label><label class="expand" for="c-41803542">[2 more]</label></div><br/><div class="children"><div class="content">This is usually the case with C#&#x27;s equivalent as well. Enumerables and LINQ are nice options to concisely express logic, but you won&#x27;t see them in hot paths.</div><br/><div id="41803688" class="c"><input type="checkbox" id="c-41803688" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41799810">root</a><span>|</span><a href="#41803542">parent</a><span>|</span><a href="#41799304">next</a><span>|</span><label class="collapse" for="c-41803688">[-]</label><label class="expand" for="c-41803688">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately, the baseline allocation cost is hard to avoid due to IEnumerable&lt;T&gt; being an interface which all LINQ methods return save for scalar values, and IEnumerable&lt;T&gt; itself returning an interface-typed IEnumerator&lt;T&gt;. Even with escape analysis, the iterator implementation selection logic is quite complex, which ends up being opaque to compiler so at most it can get rid of the IEnumerable&lt;T&gt; allocation but not the enumerator itself, and only when inlining allows so.<p>There are community libraries that implement similar API surface with structs that can be completely allocation-free and frequently dispatched statically.<p>Moreover, with the advent of `T where T : allows ref struct` you can finally write proper LINQ-like abstraction for Span&lt;T&gt;s, even if it&#x27;s a bit less pretty. I have been playing with a small toy prototype[0] recently and it looks like this:<p><pre><code>    &#x2F;&#x2F; Efectively C&#x27;s array constant
    var numbers = (ReadOnlySpan&lt;int&gt;)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    var iter = numbers
        .Where((int n) =&gt; n % 2 == 0)
        .Select((int n) =&gt; n * 2);

    &#x2F;&#x2F; Inspired by Zig :)
    using var vec = NVec&lt;int, Global&gt;.Collect(iter);
</code></pre>
The argument types for lambdas need to be provided to work around C# lacking full Hindler-Milner type inference, but this iterator expression is fully statically dispatched and monomorphized save for the lambdas themselves. Luckily, JIT can profile the exact method types passed to Funcs and perform further guarded devirtualization, putting this code painfully close to the way Rust&#x27;s iterators are compiled.<p>At the end of the day, .NET&#x27;s GC implementations can sustain 4-10x allocation throughput when compared to Go one (it&#x27;s not strictly better - just different tradeoffs), with further tuning options available, so one allocation here and there is not the end of the world, and not all LINQ methods allocate in the first place, and many of them allocate very little thanks to optimizations made in that area in all recent releases.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;neon-sunset&#x2F;project-anvil&#x2F;blob&#x2F;master&#x2F;Sources&#x2F;Playground&#x2F;Program.cs">https:&#x2F;&#x2F;github.com&#x2F;neon-sunset&#x2F;project-anvil&#x2F;blob&#x2F;master&#x2F;Sou...</a></div><br/></div></div></div></div></div></div><div id="41799304" class="c"><input type="checkbox" id="c-41799304" checked=""/><div class="controls bullet"><span class="by">integrii</span><span>|</span><a href="#41799810">prev</a><span>|</span><a href="#41800265">next</a><span>|</span><label class="collapse" for="c-41799304">[-]</label><label class="expand" for="c-41799304">[11 more]</label></div><br/><div class="children"><div class="content">Call me crazy, but I don&#x27;t like any of this. Make more named functions. Keep your logic flat and explicit. I believe go wants you to code this way as well. Imagine the horrors this kind of function chaining creates. Actually, you don&#x27;t have to. It&#x27;s JavaScript.</div><br/><div id="41805577" class="c"><input type="checkbox" id="c-41805577" checked=""/><div class="controls bullet"><span class="by">vineyardmike</span><span>|</span><a href="#41799304">parent</a><span>|</span><a href="#41800732">next</a><span>|</span><label class="collapse" for="c-41805577">[-]</label><label class="expand" for="c-41805577">[2 more]</label></div><br/><div class="children"><div class="content">Since you asked, I’ll call you crazy.<p>This sort of “chaining” syntax is pretty standard in many languages (Java, JS, Elixir, etc). Especially for streams&#x2F;iterators&#x2F;lists. You can have pretty well named and flat logic too. I think it’s just poorly written demo code. To me, this “functional” style of chaining is great. It highlights intent when reading the chain (you read “filter” as a step instead of a for loop with a conditional inside). It’s also really easy to recompose or reorder, and the code-review diffs are super easy to reason about when that happens.<p>I don’t think it really generates anything conventionally called “horrors” either - you can still use named functions and everything you love, this just makes it easier to use. It may encourage more well-written code too.<p>Imagine a simple example - get all files in some directory, filter out non-json files, perform some name-manipulation (map) function, and then return a new list. The “old” way would require a series of for loops that make and fill slices passed to each. You then wrap that whole thing in a new method called “GetRenamedJsonFiles(path string) []File”.<p>With the iterator chaining, you can still wrap it in a named method, but now you can replace the repeated for loops and intermediary slices with: “return GetFiles(path).Filter(isJsonFunc).Map(updateFileNameFunc).Collect()”. It’s probably easier to read, easier to change up later if requirements change, and easier to validate intent when reviewing, etc. It even encourages smaller, dedicated, easy to update or share methods - it encourages named methods for the intermediary steps (getFiles, isJson, updateName).</div><br/><div id="41807320" class="c"><input type="checkbox" id="c-41807320" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41799304">root</a><span>|</span><a href="#41805577">parent</a><span>|</span><a href="#41800732">next</a><span>|</span><label class="collapse" for="c-41807320">[-]</label><label class="expand" for="c-41807320">[1 more]</label></div><br/><div class="children"><div class="content">You can still refactor the original function:<p><pre><code>    func GetRenamedJsonFiles(path string) []File {
        files := GetFiles(path)
        jsonFiles := KeepJson(files)            &#x2F;&#x2F; or `Filter(files, IsJson)`
        renamedFiles := RenameFiles(jsonFiles)  &#x2F;&#x2F; or `Map(jsonFiles, RenameFile)`
        return renamedFiles
    }
</code></pre>
In fact, a long chain of function calls is often hard to read and has to be splitted into several parts anyway. I can even claim that this &quot;old&quot; style forces you to name the outcome of each step. Also it is unclear whether `GetFiles` returns a lazy iterator or a plain slice from its name (I guess it&#x27;s lazy, but only because you have said `Collect()` there).<p>It is not even like that &quot;map&quot; and &quot;filter&quot; don&#x27;t have their places in this style. In fact function chaining is just a concise way to rephrase that! You can write in a functional style without having any function chaining, because the style is all about immutability and resulting composability. Mutability tends to not mix together---any such combination results in something more complex. As long as that can be eliminated, anything would work.</div><br/></div></div></div></div><div id="41800732" class="c"><input type="checkbox" id="c-41800732" checked=""/><div class="controls bullet"><span class="by">bilinguliar</span><span>|</span><a href="#41799304">parent</a><span>|</span><a href="#41805577">prev</a><span>|</span><a href="#41799400">next</a><span>|</span><label class="collapse" for="c-41800732">[-]</label><label class="expand" for="c-41800732">[1 more]</label></div><br/><div class="children"><div class="content">When Go eventually lets all this horrible syntax sugar into the standard library, we will meet again in the Zig community.</div><br/></div></div><div id="41799400" class="c"><input type="checkbox" id="c-41799400" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41799304">parent</a><span>|</span><a href="#41800732">prev</a><span>|</span><a href="#41804499">next</a><span>|</span><label class="collapse" for="c-41799400">[-]</label><label class="expand" for="c-41799400">[1 more]</label></div><br/><div class="children"><div class="content">Even JS doesn&#x27;t really use functional styles that much. In fact, the whole reason for functional styles is the decomposability: any language with easy function chaining like `x |&gt; f |&gt; g |&gt; h` will also have an easy extraction of any part of the chain (say, `x |&gt; fg |&gt; h where fg = f . g`). It is not a good idea to use chaining when the language supports no such feature, as it would be much harder to work with such chains then.</div><br/></div></div><div id="41804499" class="c"><input type="checkbox" id="c-41804499" checked=""/><div class="controls bullet"><span class="by">cedws</span><span>|</span><a href="#41799304">parent</a><span>|</span><a href="#41799400">prev</a><span>|</span><a href="#41800248">next</a><span>|</span><label class="collapse" for="c-41804499">[-]</label><label class="expand" for="c-41804499">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right, this functional style &#x27;clever&#x27; programming is exactly what Go discourages (or did discourage... historically...) This is the exactly the kind of code I don&#x27;t want to see. I want to see clear, easy to read, obvious functions that do exactly what they say on the tin.</div><br/><div id="41805850" class="c"><input type="checkbox" id="c-41805850" checked=""/><div class="controls bullet"><span class="by">coin</span><span>|</span><a href="#41799304">root</a><span>|</span><a href="#41804499">parent</a><span>|</span><a href="#41806731">next</a><span>|</span><label class="collapse" for="c-41805850">[-]</label><label class="expand" for="c-41805850">[1 more]</label></div><br/><div class="children"><div class="content">For lots of people, unnecessary for loops makes the code less readable. When using filter and map, all the looping is abstracted out so the reader can concentrate on what&#x27;s being filtered and transferred. The loops and their temporary variables just clutters up the code.</div><br/></div></div><div id="41806731" class="c"><input type="checkbox" id="c-41806731" checked=""/><div class="controls bullet"><span class="by">snypox</span><span>|</span><a href="#41799304">root</a><span>|</span><a href="#41804499">parent</a><span>|</span><a href="#41805850">prev</a><span>|</span><a href="#41800248">next</a><span>|</span><label class="collapse" for="c-41806731">[-]</label><label class="expand" for="c-41806731">[1 more]</label></div><br/><div class="children"><div class="content">For me, the JS&#x2F;LINQ style is much more readable than a bunch of for loops.</div><br/></div></div></div></div><div id="41800248" class="c"><input type="checkbox" id="c-41800248" checked=""/><div class="controls bullet"><span class="by">arethuza</span><span>|</span><a href="#41799304">parent</a><span>|</span><a href="#41804499">prev</a><span>|</span><a href="#41801131">next</a><span>|</span><label class="collapse" for="c-41800248">[-]</label><label class="expand" for="c-41800248">[2 more]</label></div><br/><div class="children"><div class="content">.Net seems to handle it pretty well with LINQ?<p><a href="https:&#x2F;&#x2F;medium.com&#x2F;@sanjanasw99&#x2F;an-in-depth-guide-to-linq-in-net-understanding-implementing-and-utilizing-22eddc92b13a" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;@sanjanasw99&#x2F;an-in-depth-guide-to-linq-in...</a></div><br/><div id="41807223" class="c"><input type="checkbox" id="c-41807223" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41799304">root</a><span>|</span><a href="#41800248">parent</a><span>|</span><a href="#41801131">next</a><span>|</span><label class="collapse" for="c-41807223">[-]</label><label class="expand" for="c-41807223">[1 more]</label></div><br/><div class="children"><div class="content">LINQ is a very dense syntactic sugar for some selected `IEnumerable` methods. It will surely look like chaining in typical uses and thus is useful, but different from an arbitrary chaining.</div><br/></div></div></div></div><div id="41801131" class="c"><input type="checkbox" id="c-41801131" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#41799304">parent</a><span>|</span><a href="#41800248">prev</a><span>|</span><a href="#41800265">next</a><span>|</span><label class="collapse" for="c-41801131">[-]</label><label class="expand" for="c-41801131">[1 more]</label></div><br/><div class="children"><div class="content">It is a sad fact that Go is becoming more and more like JavaScript (and deviating from C).</div><br/></div></div></div></div><div id="41800265" class="c"><input type="checkbox" id="c-41800265" checked=""/><div class="controls bullet"><span class="by">pragma_x</span><span>|</span><a href="#41799304">prev</a><span>|</span><a href="#41800460">next</a><span>|</span><label class="collapse" for="c-41800265">[-]</label><label class="expand" for="c-41800265">[4 more]</label></div><br/><div class="children"><div class="content">I absolutely love it when we can take advantage of Go&#x27;s type system and add additional traits and behaviors to existing types like this.<p>That said, I noticed something odd here.  In order for a module like this to really shine, I think all these operations need to be functionally pure.  Right now, some of these mutate the iterator&#x27;s `iter` method mid-stream, which is about as side-effect-ful as you can get.<p>```<p>func (i <i>Iterator[V]) Map(f func(V) V) </i>Iterator[V] {<p>cpy := i.iter<p>i.iter = func(yield func(V) bool) {<p><pre><code>  for v := range cpy {

   v = f(v)

   if !yield(v) {

    return

   }

  }

 }

 return i
</code></pre>
}
```<p>Unless I&#x27;m misreading that, `i.iter` has new behavior after this call.  A better way would be to return a new _iterator_ with the custom iter behavior instead.<p>```
func (i <i>Iterator[V]) Map(f func(V) V) </i>Iterator[V] {<p><pre><code>        &#x2F;&#x2F; create a fresh iterator around a custom closure (NewIterator() is hypothetical in this case)

 return NewIterator(func(yield func(V) bool) {

  for v := range i.iter {

   v = f(v)

   if !yield(v) {

    return

   }

  }

 })
</code></pre>
}
```</div><br/><div id="41802383" class="c"><input type="checkbox" id="c-41802383" checked=""/><div class="controls bullet"><span class="by">kunley</span><span>|</span><a href="#41800265">parent</a><span>|</span><a href="#41800724">next</a><span>|</span><label class="collapse" for="c-41802383">[-]</label><label class="expand" for="c-41802383">[2 more]</label></div><br/><div class="children"><div class="content">Might be written in a hurry and maybe the author was thinking that not allocating new Iterator, which is in fact wrapper around iter.Seq, will produce less heap garbage. But I guess it&#x27;s the same amount of garbage, because the size of Iterator is the same as iter.Seq which is allocated anyway, it&#x27;s just different type of the object being discarded</div><br/><div id="41807283" class="c"><input type="checkbox" id="c-41807283" checked=""/><div class="controls bullet"><span class="by">relistan</span><span>|</span><a href="#41800265">root</a><span>|</span><a href="#41802383">parent</a><span>|</span><a href="#41800724">next</a><span>|</span><label class="collapse" for="c-41807283">[-]</label><label class="expand" for="c-41807283">[1 more]</label></div><br/><div class="children"><div class="content">If they allocated, people would complain about that. If they don’t, people complain about mutation. :shrug:<p>Personally, the article’s implementation seems fine to me. The iter is a private field of a throwaway struct created on the fly in order to support chaining. If anyone is then relying on the (private) contents of that struct, I think that’s user error. I can’t see personally why you’d do that.</div><br/></div></div></div></div><div id="41800724" class="c"><input type="checkbox" id="c-41800724" checked=""/><div class="controls bullet"><span class="by">tantivy</span><span>|</span><a href="#41800265">parent</a><span>|</span><a href="#41802383">prev</a><span>|</span><a href="#41800460">next</a><span>|</span><label class="collapse" for="c-41800724">[-]</label><label class="expand" for="c-41800724">[1 more]</label></div><br/><div class="children"><div class="content">This flagged for me right away too. I would be badly surprised if a Map-style chained method mutated the memory of the receiver.</div><br/></div></div></div></div><div id="41800460" class="c"><input type="checkbox" id="c-41800460" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#41800265">prev</a><span>|</span><a href="#41807471">next</a><span>|</span><label class="collapse" for="c-41800460">[-]</label><label class="expand" for="c-41800460">[40 more]</label></div><br/><div class="children"><div class="content">Go people will do this and they&#x27;ll be content:<p><pre><code>  a := []int{1,2,3,4}
  it := slices.All(a)
  it = slices.Reverse(it)
  it = slices.Map(it)
  it = slices.Filter(it, func(i int) bool { return i % 2 == 0 })
  slices.ForEach(it, func(i int) { fmt.Println(i) })
</code></pre>
I don&#x27;t judge the Go enjoyers, but I prefer writing TypeScript to Go which says it all.<p>Type-inferred arrow lambda for function arguments would go such a long way in making this code nicer... And not make compilation slower at all.<p><pre><code>  it = slices.Filter(it, i =&gt; i % 2 == 0)
  slices.ForEach(it, i =&gt; fmt.Println(i))</code></pre></div><br/><div id="41800546" class="c"><input type="checkbox" id="c-41800546" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41800460">parent</a><span>|</span><a href="#41802335">next</a><span>|</span><label class="collapse" for="c-41800546">[-]</label><label class="expand" for="c-41800546">[33 more]</label></div><br/><div class="children"><div class="content">No, Go programmers would write<p><pre><code>    a := []int{1, 2, 3, 4}
    out := []int{}

    for idx := range a {
        val := a[len(a)-idx-1]
        if mappedVal := Map(val); mappedVal % 2 == 0 {
            out = append(out, mappedVal)
            fmt.Println(mappedVal)
        }
    }
</code></pre>
In modern Go I might write a reverse iterator, that index is a bit hairy, which would cut out the &#x27;val :=&#x27; line, but as there is not yet a standard library option for that I&#x27;ll leave it out.</div><br/><div id="41800621" class="c"><input type="checkbox" id="c-41800621" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800546">parent</a><span>|</span><a href="#41800567">next</a><span>|</span><label class="collapse" for="c-41800621">[-]</label><label class="expand" for="c-41800621">[15 more]</label></div><br/><div class="children"><div class="content">I think the killer case for this is not hiding the computational complexity of mapping&#x2F;reversing&#x2F;etc.<p>I write a lot of typescript and golang and I often notice in typescript my chains end up iterating the same array N times when it couldbe been done in one smarter iteration.<p>I don&#x27;t think I care though -- both styles are way more than performant enough. You can be more careful about it in cases it is not.</div><br/><div id="41806118" class="c"><input type="checkbox" id="c-41806118" checked=""/><div class="controls bullet"><span class="by">amarshall</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800621">parent</a><span>|</span><a href="#41800682">next</a><span>|</span><label class="collapse" for="c-41806118">[-]</label><label class="expand" for="c-41806118">[1 more]</label></div><br/><div class="children"><div class="content">By that logic, calling any function with a loop or recursion should be forbidden, as it hides computational complexity at the call site. I.e. should we get rid of `slices.Sort` (etc.) because it hides computational complexity?</div><br/></div></div><div id="41800682" class="c"><input type="checkbox" id="c-41800682" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800621">parent</a><span>|</span><a href="#41806118">prev</a><span>|</span><a href="#41800567">next</a><span>|</span><label class="collapse" for="c-41800682">[-]</label><label class="expand" for="c-41800682">[13 more]</label></div><br/><div class="children"><div class="content">Iterating an array 10 times doing 1 operation on each element each time is equivalent to iterating it 1 time while doing 10 operations on each element.</div><br/><div id="41800810" class="c"><input type="checkbox" id="c-41800810" checked=""/><div class="controls bullet"><span class="by">thrww120956</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800682">parent</a><span>|</span><a href="#41800848">next</a><span>|</span><label class="collapse" for="c-41800810">[-]</label><label class="expand" for="c-41800810">[5 more]</label></div><br/><div class="children"><div class="content">Found the theoretical informatician... Nope, not in real world software engineering. Especially not in JIT runtimes like V8. Try it!<p>I tried it, code: <a href="https:&#x2F;&#x2F;pastebin.com&#x2F;cA8YkE8R" rel="nofollow">https:&#x2F;&#x2F;pastebin.com&#x2F;cA8YkE8R</a><p>Result:<p><pre><code>   process1: 2s 251.327833ms
   process2: 1s 537.721625ms</code></pre></div><br/><div id="41804818" class="c"><input type="checkbox" id="c-41804818" checked=""/><div class="controls bullet"><span class="by">bschwindHN</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800810">parent</a><span>|</span><a href="#41801404">next</a><span>|</span><label class="collapse" for="c-41804818">[-]</label><label class="expand" for="c-41804818">[1 more]</label></div><br/><div class="children"><div class="content">Funny enough, the iterator version is much faster in rust because the compiler can more easily optimize iterator chains than custom for loops:<p><a href="https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=release&amp;edition=2021&amp;gist=e4b11bda65cd43ba77678284c28e7f76" rel="nofollow">https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=release&amp;edit...</a><p>(I&#x27;d recommend running it on your own machine as the rust playground limits memory and will likely kill this program)<p>Output from my machine:<p><pre><code>    $ cargo run --release
        Finished `release` profile [optimized] target(s) in 0.05s
         Running `target&#x2F;release&#x2F;iterator`
    Process 1 returned 18270843109002848788 and took 64.58175ms
    Process 2 returned 18270843109002848788 and took 308.969083ms</code></pre></div><br/></div></div><div id="41801404" class="c"><input type="checkbox" id="c-41801404" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800810">parent</a><span>|</span><a href="#41804818">prev</a><span>|</span><a href="#41801337">next</a><span>|</span><label class="collapse" for="c-41801404">[-]</label><label class="expand" for="c-41801404">[2 more]</label></div><br/><div class="children"><div class="content">But this is apples and oranges. Process 1 creates and calls lambdas, etc.<p>A proper comparison could be:<p><pre><code>  # Case 1.
  for n in range(len(data)):
    data[n] = transform1(data[n])
    data[n] = transform2(data[n])

  # Case 2.
  for n in range(len(data)):
    data[n] = transform1(data[n])
  for n in range(len(data)):
    data[n] = transform2(data[n])</code></pre></div><br/><div id="41807573" class="c"><input type="checkbox" id="c-41807573" checked=""/><div class="controls bullet"><span class="by">thrww120956</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41801404">parent</a><span>|</span><a href="#41801337">next</a><span>|</span><label class="collapse" for="c-41807573">[-]</label><label class="expand" for="c-41807573">[1 more]</label></div><br/><div class="children"><div class="content">It illustrates how this kind of code is used in the wild - array functions vs a for loop. What you did is not even a fruit, if I go along with your metaphor.</div><br/></div></div></div></div><div id="41801337" class="c"><input type="checkbox" id="c-41801337" checked=""/><div class="controls bullet"><span class="by">throwitaway1123</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800810">parent</a><span>|</span><a href="#41801404">prev</a><span>|</span><a href="#41800848">next</a><span>|</span><label class="collapse" for="c-41801337">[-]</label><label class="expand" for="c-41801337">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a little bit faster (on my machine at least) if you combine the filter and map into a flatMap (it&#x27;s still not as performant as the imperative solution though).<p><pre><code>  function process3(input) {
    return input
      .flatMap((n) =&gt; (n % 2 === 0 ? n * 2 : []))
      .reduce((a, b) =&gt; a + b, 0)
  }</code></pre></div><br/></div></div></div></div><div id="41800848" class="c"><input type="checkbox" id="c-41800848" checked=""/><div class="controls bullet"><span class="by">nick__m</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800682">parent</a><span>|</span><a href="#41800810">prev</a><span>|</span><a href="#41800790">next</a><span>|</span><label class="collapse" for="c-41800848">[-]</label><label class="expand" for="c-41800848">[2 more]</label></div><br/><div class="children"><div class="content">In an ideal machine you are absolutely correct! But when executed by a real physical CPU, if the array doesn&#x27;t fit I the cache, iteration strategies matters!</div><br/><div id="41806311" class="c"><input type="checkbox" id="c-41806311" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800848">parent</a><span>|</span><a href="#41800790">next</a><span>|</span><label class="collapse" for="c-41806311">[-]</label><label class="expand" for="c-41806311">[1 more]</label></div><br/><div class="children"><div class="content">Not in this way, not significantly. At worse, for each new loop through the array you have an extra cache miss. If the array is large enough, 10 extra cache misses will barely even be measurable.<p>It&#x27;s only for small arrays actually that the cost of the loop infra and the extra cache miss per loop matters.</div><br/></div></div></div></div><div id="41800790" class="c"><input type="checkbox" id="c-41800790" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800682">parent</a><span>|</span><a href="#41800848">prev</a><span>|</span><a href="#41801320">next</a><span>|</span><label class="collapse" for="c-41800790">[-]</label><label class="expand" for="c-41800790">[3 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t true outside the theoretical best case. Definitely not true in most interpreted languages. Consider the performance difference of .reverse() (in-place or copy) vs using a descending for loop. Generally with interpreter chaining there are more &quot;hidden&quot; allocations&#x2F;operations.</div><br/><div id="41806326" class="c"><input type="checkbox" id="c-41806326" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800790">parent</a><span>|</span><a href="#41801320">next</a><span>|</span><label class="collapse" for="c-41806326">[-]</label><label class="expand" for="c-41806326">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re comparing apples and oranges. Of course modifying an array or copying it takes way more time than looping. The comparison was not about that, it&#x27;s about one loop with 10 instructions VS 10 loops each with a single instruction, for the exact same instructions.</div><br/><div id="41807658" class="c"><input type="checkbox" id="c-41807658" checked=""/><div class="controls bullet"><span class="by">thrww120956</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41806326">parent</a><span>|</span><a href="#41801320">next</a><span>|</span><label class="collapse" for="c-41807658">[-]</label><label class="expand" for="c-41807658">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no way to do this (a single instruction loop vs 10 loops with a single instruction) in JS or Golang.</div><br/></div></div></div></div></div></div><div id="41801320" class="c"><input type="checkbox" id="c-41801320" checked=""/><div class="controls bullet"><span class="by">ehaliewicz2</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800682">parent</a><span>|</span><a href="#41800790">prev</a><span>|</span><a href="#41801017">next</a><span>|</span><label class="collapse" for="c-41801320">[-]</label><label class="expand" for="c-41801320">[1 more]</label></div><br/><div class="children"><div class="content">Until the array no longer fits in your cache :)</div><br/></div></div><div id="41801017" class="c"><input type="checkbox" id="c-41801017" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800682">parent</a><span>|</span><a href="#41801320">prev</a><span>|</span><a href="#41800567">next</a><span>|</span><label class="collapse" for="c-41801017">[-]</label><label class="expand" for="c-41801017">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Loop_fission_and_fusion" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Loop_fission_and_fusion</a></div><br/></div></div></div></div></div></div><div id="41800567" class="c"><input type="checkbox" id="c-41800567" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800546">parent</a><span>|</span><a href="#41800621">prev</a><span>|</span><a href="#41802335">next</a><span>|</span><label class="collapse" for="c-41800567">[-]</label><label class="expand" for="c-41800567">[17 more]</label></div><br/><div class="children"><div class="content">Many Go programmers would claim this is cleaner and more understandable, unfortunately I&#x27;m not one of them.</div><br/><div id="41801275" class="c"><input type="checkbox" id="c-41801275" checked=""/><div class="controls bullet"><span class="by">margalabargala</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800567">parent</a><span>|</span><a href="#41805892">next</a><span>|</span><label class="collapse" for="c-41801275">[-]</label><label class="expand" for="c-41801275">[7 more]</label></div><br/><div class="children"><div class="content">The original version relied on no fewer than five different imported functions from a package that, if you&#x27;re not already familiar with them, you would have to go read to see exactly what they do.<p>The updated version has just one such function.<p>A function gets less readable as you have to go context switch to more and more different functions to understand what it&#x27;s doing.<p>Yes, the `slices` functions are named such that you can make a decent educated guess as to what they&#x27;re doing, but if there&#x27;s a problem you&#x27;re trying to debug that doesn&#x27;t save you from having to dive into each one.</div><br/><div id="41803401" class="c"><input type="checkbox" id="c-41803401" checked=""/><div class="controls bullet"><span class="by">scubbo</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41801275">parent</a><span>|</span><a href="#41801327">next</a><span>|</span><label class="collapse" for="c-41803401">[-]</label><label class="expand" for="c-41803401">[5 more]</label></div><br/><div class="children"><div class="content">&gt; A function gets less readable as you have to go context switch to more and more different functions to understand what it&#x27;s doing.<p>This is true.<p>A function also gets less readable every time you have to mentally translate from low-level implementation code, to a high-&#x2F;human-level description of &quot;what is this actually doing?&quot; (e.g. `val := a[len(a)-idx-1]` - &quot;ohhh, ok, that&#x27;s iterating in reverse&quot;). Extracting out common patterns to methods with well-known names like `Filter` or `Map` or `ForEach` short-circuits that repeated parsing.<p>&gt; that doesn&#x27;t save you from having to dive into each one.<p>99% of the time, it really does. If you can&#x27;t trust something as basic and well-defined as `Map` to do what you expect it to do, you&#x27;ve chosen a poor library on which to take a dependency.</div><br/><div id="41803527" class="c"><input type="checkbox" id="c-41803527" checked=""/><div class="controls bullet"><span class="by">margalabargala</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41803401">parent</a><span>|</span><a href="#41801327">next</a><span>|</span><label class="collapse" for="c-41803527">[-]</label><label class="expand" for="c-41803527">[4 more]</label></div><br/><div class="children"><div class="content">&gt; 99% of the time, it really does. If you can&#x27;t trust something as basic and well-defined as `Map` to do what you expect it to do, you&#x27;ve chosen a poor library on which to take a dependency.<p>The original comment said:<p><pre><code>     it = slices.Map(it)
</code></pre>
I understand Map taking an array and a function, as in the article. I don&#x27;t understand Map taking simply an array.<p>Then I went to look it up, and turns out that slices.Map does not in fact exist. <a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;slices" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;slices</a><p>Personally I feel like this exchange is a vivid illustration of exactly my original point.</div><br/><div id="41804045" class="c"><input type="checkbox" id="c-41804045" checked=""/><div class="controls bullet"><span class="by">scubbo</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41803527">parent</a><span>|</span><a href="#41801327">next</a><span>|</span><label class="collapse" for="c-41804045">[-]</label><label class="expand" for="c-41804045">[3 more]</label></div><br/><div class="children"><div class="content">The facts that GoLang is missing such a fundamental tool from its standard library, and that it&#x27;s easy to make typos when coding not in an IDE, hardly support your point.<p>In fact, the very fact that you originally thought of the correct interpretation despite the fact that it had been misrepresented is a great example of why common shorthands are useful.</div><br/><div id="41804615" class="c"><input type="checkbox" id="c-41804615" checked=""/><div class="controls bullet"><span class="by">margalabargala</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41804045">parent</a><span>|</span><a href="#41801327">next</a><span>|</span><label class="collapse" for="c-41804615">[-]</label><label class="expand" for="c-41804615">[2 more]</label></div><br/><div class="children"><div class="content">I suppose there are different sorts of programmers who prefer different levels of guardrails pre-made for them.<p>Some people consider `Map` to be a fundamental tool. Like the original commenter mentioned, some people also prefer Typescript to Go.<p>If I was interviewing someone for my (primarily golang) company and they mentioned that not having `Map` to be a downside of Go that hindered its readability, that would be a strong mark against them. I would not want to try to dig through the N levels of abstraction they would create in the codebase to hide what was happening with all its bugs.<p>Other companies don&#x27;t mind this, and use other languages, like Javascript or the latest versions of Python.<p>Python in particular is great for what you mention, as nearly every slightly common programming idiom has its own keyword with its own special usage, so you can always use that instead of writing the fundamentals yourself.<p>Personally I hate Python because I prefer not to have to learn a dozen new obscure tools and keywords with each minor language release. I dislike trying to read packages written in Python, because they use whatever 20% subset of the language the author was aware of. I like Go because I can look at the source code for nearly any function in nearly any library and understand it immediately. Nobody would import &quot;leftpad&quot; in Go.<p>Different languages for different people.</div><br/><div id="41805057" class="c"><input type="checkbox" id="c-41805057" checked=""/><div class="controls bullet"><span class="by">scubbo</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41804615">parent</a><span>|</span><a href="#41801327">next</a><span>|</span><label class="collapse" for="c-41805057">[-]</label><label class="expand" for="c-41805057">[1 more]</label></div><br/><div class="children"><div class="content">I really like how you&#x27;ve presented this (despite disagreeing as a point of personal preference on almost every point you make :) ). I&#x27;m baffled by the level of repetition and verbosity that Gophers seem to prefer - but I also can&#x27;t deny that they&#x27;ve created some truly astonishing tools and projects, despite having to reimplement core concepts over and over again! Clearly, it works for them.<p>As you say, different languages for different people. Best of luck to you, and thank you for an insightful and civil discussion :)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41805892" class="c"><input type="checkbox" id="c-41805892" checked=""/><div class="controls bullet"><span class="by">coin</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800567">parent</a><span>|</span><a href="#41801275">prev</a><span>|</span><a href="#41800684">next</a><span>|</span><label class="collapse" for="c-41805892">[-]</label><label class="expand" for="c-41805892">[1 more]</label></div><br/><div class="children"><div class="content">Go programming style is like programming in 2005 before functional programming because widespread (Google Guava, Clojure). If you showed functional programming to programmers in 2005 many of them would find it difficult to read.</div><br/></div></div><div id="41800684" class="c"><input type="checkbox" id="c-41800684" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800567">parent</a><span>|</span><a href="#41805892">prev</a><span>|</span><a href="#41802335">next</a><span>|</span><label class="collapse" for="c-41800684">[-]</label><label class="expand" for="c-41800684">[8 more]</label></div><br/><div class="children"><div class="content">The bigger problem is that it&#x27;s not efficiently composable. If your caller needs to additionally filter `out`, that&#x27;s another loop with a copy.</div><br/><div id="41801041" class="c"><input type="checkbox" id="c-41801041" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800684">parent</a><span>|</span><a href="#41800798">next</a><span>|</span><label class="collapse" for="c-41801041">[-]</label><label class="expand" for="c-41801041">[4 more]</label></div><br/><div class="children"><div class="content">In most imperative languages, writing .Map().Map().Filter().Map() is another full copy for <i>each call</i> anyhow. As a sibling notes, it is possible to &quot;fix&quot; that, but the fix is not even remotely free. It is quite complicated to do it generically. (Although there are other benefits; the most natural approach to that largely fixes my grumblings about refactoring I mentioned in another post.)<p>Plus, in a for loop approach, it is not true that the caller may need another loop with a copy. They may just loop over the result and skip over the things they don&#x27;t need. They only need a copy if they are going to pass that on to something else.<p>A drum I can not stop banging on is that you can not just take a neat technique out of one language and slam it into another without examining the end result to make sure that you haven&#x27;t murdered the cost&#x2F;benefits tradeoff. You can slam together all the maps and filters and reduces you want in Haskell, and applicatives and monads and all the fun, due to a combination of the laziness and various safe optimizations like loop fusion. In an eager context that lacks loop fusion, going .Map().Map().Map().Map() has <i>radically</i> different performance implications. For instance, &quot;take 10 $ map f list&quot; in Haskell will only call &quot;f&quot; 10 times. .Map().Take(10) in most implementations will create the full array, however large it is, and slice ten off the end after that.<p>In imperative languages, contrary to frequent claims from the functional programming crowd, for loops are actually often better in practice. The solution to their pathologies is to be aware of them and not do them. But it is far, <i>far</i> easier to get good performance out of a for loop in an imperative language than to contort one&#x27;s code into a pale parody of functional programming.</div><br/><div id="41801345" class="c"><input type="checkbox" id="c-41801345" checked=""/><div class="controls bullet"><span class="by">akkad33</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41801041">parent</a><span>|</span><a href="#41800798">next</a><span>|</span><label class="collapse" for="c-41801345">[-]</label><label class="expand" for="c-41801345">[3 more]</label></div><br/><div class="children"><div class="content">&gt; In most imperative languages, writing .Map().Map().Filter().Map() is another full copy for each call anyhow.<p>Which imperative language? In Java and rust, two languages I know, all these operations are lazy until the final collect. So no copy is made</div><br/><div id="41801558" class="c"><input type="checkbox" id="c-41801558" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41801345">parent</a><span>|</span><a href="#41801556">next</a><span>|</span><label class="collapse" for="c-41801558">[-]</label><label class="expand" for="c-41801558">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why I specified the code. If you&#x27;re writing .Map().Map().Map().Map(), you are usually getting a lot of intermediate arrays.<p>If you have a .Collect() call, you&#x27;re in the deforestation branch. This has its own issues with stressing the inliner (turning simple, direct for loops over large collections into traversals that include several indirect method calls per item in addition to the payload is pretty easy), but that&#x27;s still generally better than stressing the RAM.<p>Rust&#x27;s map doesn&#x27;t operate on arrays at all from what I can see but operates on iterators directly. This is good and generally more correct. However there&#x27;s a lot of languages that don&#x27;t support that. Rust is generally also going to be more reliable about compiling it all away than a lot of other languages where it will be really easy to spill over what the inliner can handle. Those long compile times in Rust do have their benefits.<p>There&#x27;s also languages that sort of split the difference, e.g., it is not that difficult in Python to use itertools and generators to correctly write something that will not generate a lot of intermediate arrays, <i>but</i> it is also easy to write a series of calls and list comprehensions to write otherwise equivalent code that <i>will</i> create a lot of intermediate arrays.<p>I expect as we continue to build new languages over time they&#x27;re going to all look like Rust here. It&#x27;s pretty obvious that conceiving of loops as iteration over some sequence is the way to go. However, that is a result that we got to precisely because of our experiences with a lot of languages that don&#x27;t support it as well, or support it inconsistently, or as is actually quite common, the language nominally supports it but the ecosystem tends to assume concrete values a lot more often than it should, and all these languages are still around.<p>Writing in this style <i>correctly</i> in imperative code is more difficult than a lot of people jumping up and down about how we should rewrite all our loops as maps and filters tend to account for. It can be done, but it&#x27;s often harder than it looks, in at least one of the writing and the performance if not both, and the harder it is, the more the costs stack up on the costs side, and the harder the costs&#x2F;benefits analysis becomes. And I still don&#x27;t like how it refactors in most cases.</div><br/></div></div><div id="41801556" class="c"><input type="checkbox" id="c-41801556" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41801345">parent</a><span>|</span><a href="#41801558">prev</a><span>|</span><a href="#41800798">next</a><span>|</span><label class="collapse" for="c-41801556">[-]</label><label class="expand" for="c-41801556">[1 more]</label></div><br/><div class="children"><div class="content">Nor in Python. Nor in C++20&#x27;s std::views. The very point of iterators us to proceed by one element, avoiding intermediate copies of collections.<p>One case where the for-loop would be much more efficient is a simple transformation like incrementing each element of an array, or adding two arrays element-wise. A serious C compiler could unroll such a loop into several vector instructions which work on several elements at once. Maybe even LLVM can recognize something like that in Go code.</div><br/></div></div></div></div></div></div><div id="41800935" class="c"><input type="checkbox" id="c-41800935" checked=""/><div class="controls bullet"><span class="by">thegeekpirate</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800684">parent</a><span>|</span><a href="#41800798">prev</a><span>|</span><a href="#41802335">next</a><span>|</span><label class="collapse" for="c-41800935">[-]</label><label class="expand" for="c-41800935">[2 more]</label></div><br/><div class="children"><div class="content">The proper term is deforestation <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Deforestation_(computer_science)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Deforestation_(computer_scienc...</a>, and I have seen Go libraries which do this</div><br/><div id="41804207" class="c"><input type="checkbox" id="c-41804207" checked=""/><div class="controls bullet"><span class="by">nemo1618</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41800935">parent</a><span>|</span><a href="#41802335">next</a><span>|</span><label class="collapse" for="c-41804207">[-]</label><label class="expand" for="c-41804207">[1 more]</label></div><br/><div class="children"><div class="content">ah, <i>that&#x27;s</i> what it&#x27;s called! I did this in my compile-to-Go language, but I didn&#x27;t know the name for it: <a href="https:&#x2F;&#x2F;github.com&#x2F;lukechampine&#x2F;ply?tab=readme-ov-file#supported-optimizations">https:&#x2F;&#x2F;github.com&#x2F;lukechampine&#x2F;ply?tab=readme-ov-file#suppo...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="41802335" class="c"><input type="checkbox" id="c-41802335" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#41800460">parent</a><span>|</span><a href="#41800546">prev</a><span>|</span><a href="#41801224">next</a><span>|</span><label class="collapse" for="c-41802335">[-]</label><label class="expand" for="c-41802335">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t judge the Go enjoyers, but I prefer writing TypeScript to Go which says it all.<p>The functional style is fine for simple filter&#x2F;map algorithms, but once you get into zipping multiple iterators together, classic for-loops are often easier.<p>My company&#x27;s hiring coding task had this &quot;trap&quot;, at one point you needed to write an algorithm to merge consecutive &quot;empty&quot; cells in a data structure that is used to represent a simple table. This is dead easy with a regular for-loop, but writing it in a &quot;functional&quot; style could easily become extremely hairy and&#x2F;or have O(N^2) complexity.</div><br/><div id="41804074" class="c"><input type="checkbox" id="c-41804074" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41802335">parent</a><span>|</span><a href="#41801224">next</a><span>|</span><label class="collapse" for="c-41804074">[-]</label><label class="expand" for="c-41804074">[2 more]</label></div><br/><div class="children"><div class="content">You can use loops in typescript if you need to.</div><br/><div id="41805229" class="c"><input type="checkbox" id="c-41805229" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41804074">parent</a><span>|</span><a href="#41801224">next</a><span>|</span><label class="collapse" for="c-41805229">[-]</label><label class="expand" for="c-41805229">[1 more]</label></div><br/><div class="children"><div class="content">Sure. I&#x27;m just saying that the functional style is not always the best.</div><br/></div></div></div></div></div></div><div id="41801224" class="c"><input type="checkbox" id="c-41801224" checked=""/><div class="controls bullet"><span class="by">everybodyknows</span><span>|</span><a href="#41800460">parent</a><span>|</span><a href="#41802335">prev</a><span>|</span><a href="#41803422">next</a><span>|</span><label class="collapse" for="c-41801224">[-]</label><label class="expand" for="c-41801224">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it = slices.Map(it)<p>There is no such function as &quot;slices.Map()&quot;.<p><a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;slices@go1.23.2" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;slices@go1.23.2</a></div><br/></div></div><div id="41803422" class="c"><input type="checkbox" id="c-41803422" checked=""/><div class="controls bullet"><span class="by">scubbo</span><span>|</span><a href="#41800460">parent</a><span>|</span><a href="#41801224">prev</a><span>|</span><a href="#41807471">next</a><span>|</span><label class="collapse" for="c-41803422">[-]</label><label class="expand" for="c-41803422">[2 more]</label></div><br/><div class="children"><div class="content">Nit - I think you&#x27;ve missed the `func` argument in the `slices.Map` line.<p>(But - yes, bravo, correct, you&#x27;re right and you should say it)</div><br/><div id="41804085" class="c"><input type="checkbox" id="c-41804085" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#41800460">root</a><span>|</span><a href="#41803422">parent</a><span>|</span><a href="#41807471">next</a><span>|</span><label class="collapse" for="c-41804085">[-]</label><label class="expand" for="c-41804085">[1 more]</label></div><br/><div class="children"><div class="content">I did, but I believe some people understood what I meant anyway.</div><br/></div></div></div></div></div></div><div id="41807471" class="c"><input type="checkbox" id="c-41807471" checked=""/><div class="controls bullet"><span class="by">icar</span><span>|</span><a href="#41800460">prev</a><span>|</span><a href="#41807076">next</a><span>|</span><label class="collapse" for="c-41807471">[-]</label><label class="expand" for="c-41807471">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of RxJS (<a href="https:&#x2F;&#x2F;rxjs.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rxjs.dev&#x2F;</a>)</div><br/></div></div><div id="41807076" class="c"><input type="checkbox" id="c-41807076" checked=""/><div class="controls bullet"><span class="by">tpoacher</span><span>|</span><a href="#41807471">prev</a><span>|</span><a href="#41798757">next</a><span>|</span><label class="collapse" for="c-41807076">[-]</label><label class="expand" for="c-41807076">[1 more]</label></div><br/><div class="children"><div class="content">Since the article is making a not-so-subtle jab at python being unable to do chain operations, I&#x27;m making my annual rounds to point out that implementing simple, straightforward chain functionality in python is as simple as a two-line function definition:<p><pre><code>  def chain( Accumulant, *Functions_list ):
      for f in Functions_list: Accumulant = f( Accumulant )
      return Accumulant
</code></pre>
<a href="https:&#x2F;&#x2F;sr.ht&#x2F;~tpapastylianou&#x2F;chain-ops-python&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sr.ht&#x2F;~tpapastylianou&#x2F;chain-ops-python&#x2F;</a></div><br/></div></div><div id="41798757" class="c"><input type="checkbox" id="c-41798757" checked=""/><div class="controls bullet"><span class="by">gtramont</span><span>|</span><a href="#41807076">prev</a><span>|</span><a href="#41798487">next</a><span>|</span><label class="collapse" for="c-41798757">[-]</label><label class="expand" for="c-41798757">[11 more]</label></div><br/><div class="children"><div class="content">Unfortunately the chain approach breaks down when if you need to `map` to a different type, for example. Go does not allow generic typed methods.</div><br/><div id="41799500" class="c"><input type="checkbox" id="c-41799500" checked=""/><div class="controls bullet"><span class="by">simiones</span><span>|</span><a href="#41798757">parent</a><span>|</span><a href="#41798834">next</a><span>|</span><label class="collapse" for="c-41799500">[-]</label><label class="expand" for="c-41799500">[1 more]</label></div><br/><div class="children"><div class="content">You can actually (almost) make it work, you just need to add an extra type parameter to keep Go&#x27;s silly limitations happy [0]:<p><pre><code>  strs := []string{&quot;abc&quot;, &quot;defgh&quot;, &quot;klmnopqrst&quot;}
  ints := From[string, int](strs).
           Map(func(a string) int { return len(a) }).
           Filter(func(a int) bool { return a &gt;= 4 })
  Iterator[int, float32](ints).
           Map(func(a int) float32 { return float32(a) }).
           Each(func(a float32) { fmt.Printf(&quot;%v\n&quot;, a) })
  &#x2F;&#x2F;prints 5, then 10
</code></pre>
If they allowed the postfix cast syntax to work for non-interface types too, it could have been a single chain, actually (you could do `.(Iterator[int, float32])` inline instead of needing the extra variable.<p>Note that the original implementation in the article modifies the collections in place, in which case this issue doesn&#x27;t come up at all: you can&#x27;t put strings in an array of ints. My implementation creates copies of these collections so that the concept of mapping to a new type actually makes sense.<p>[0] <a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;ggWrokAk7nS" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;ggWrokAk7nS</a></div><br/></div></div><div id="41798834" class="c"><input type="checkbox" id="c-41798834" checked=""/><div class="controls bullet"><span class="by">daghamm</span><span>|</span><a href="#41798757">parent</a><span>|</span><a href="#41799500">prev</a><span>|</span><a href="#41798487">next</a><span>|</span><label class="collapse" for="c-41798834">[-]</label><label class="expand" for="c-41798834">[9 more]</label></div><br/><div class="children"><div class="content">I never understood why that limitation exist.<p>Can someone explain the reason for this?</div><br/><div id="41798894" class="c"><input type="checkbox" id="c-41798894" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41798757">root</a><span>|</span><a href="#41798834">parent</a><span>|</span><a href="#41804998">next</a><span>|</span><label class="collapse" for="c-41798894">[-]</label><label class="expand" for="c-41798894">[1 more]</label></div><br/><div class="children"><div class="content">Straight from the designers: <a href="https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;refs&#x2F;heads&#x2F;master&#x2F;design&#x2F;43651-type-parameters.md#no-parameterized-methods" rel="nofollow">https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;refs&#x2F;heads&#x2F;master&#x2F;des...</a></div><br/></div></div><div id="41804998" class="c"><input type="checkbox" id="c-41804998" checked=""/><div class="controls bullet"><span class="by">adonovan</span><span>|</span><a href="#41798757">root</a><span>|</span><a href="#41798834">parent</a><span>|</span><a href="#41798894">prev</a><span>|</span><a href="#41798925">next</a><span>|</span><label class="collapse" for="c-41804998">[-]</label><label class="expand" for="c-41804998">[1 more]</label></div><br/><div class="children"><div class="content">It is a consequence of (a) Go&#x27;s implicit relationship between a concrete type and the interfaces it implements and (b) Go&#x27;s &quot;heterogenous&quot; translation of generics (like C++, unlike Java). Together, this means you can&#x27;t know which methods you need a priori. All proposed solutions to date essentially compromise on (a) by limiting the generic &quot;implements&quot; relation to things known at build time, or on (b) by making generic methods &quot;homegenous&quot; (aka boxed) and thus slow (see <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;49085#issuecomment-2316352221">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;49085#issuecomment-23163...</a> for an elaboration of this approach); or, they involve dynamic code generation.</div><br/></div></div><div id="41798925" class="c"><input type="checkbox" id="c-41798925" checked=""/><div class="controls bullet"><span class="by">thefounder</span><span>|</span><a href="#41798757">root</a><span>|</span><a href="#41798834">parent</a><span>|</span><a href="#41804998">prev</a><span>|</span><a href="#41799008">next</a><span>|</span><label class="collapse" for="c-41798925">[-]</label><label class="expand" for="c-41798925">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;refs&#x2F;heads&#x2F;master&#x2F;design&#x2F;43651-type-parameters.md#No-parameterized-methods" rel="nofollow">https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;refs&#x2F;heads&#x2F;master&#x2F;des...</a></div><br/></div></div><div id="41799008" class="c"><input type="checkbox" id="c-41799008" checked=""/><div class="controls bullet"><span class="by">mihaitodor</span><span>|</span><a href="#41798757">root</a><span>|</span><a href="#41798834">parent</a><span>|</span><a href="#41798925">prev</a><span>|</span><a href="#41801188">next</a><span>|</span><label class="collapse" for="c-41799008">[-]</label><label class="expand" for="c-41799008">[1 more]</label></div><br/><div class="children"><div class="content">I recall reading some details around this on <a href="https:&#x2F;&#x2F;blog.merovius.de" rel="nofollow">https:&#x2F;&#x2F;blog.merovius.de</a>. Maybe it was this article: <a href="https:&#x2F;&#x2F;blog.merovius.de&#x2F;posts&#x2F;2018-06-03-why-doesnt-go-have-variance-in" rel="nofollow">https:&#x2F;&#x2F;blog.merovius.de&#x2F;posts&#x2F;2018-06-03-why-doesnt-go-have...</a>. Compilation speed plays a big factor when deciding which features are added to Golang and I think they&#x27;d have a hard time maintaining the current compilation speed if they remove this limitation.</div><br/></div></div><div id="41801188" class="c"><input type="checkbox" id="c-41801188" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#41798757">root</a><span>|</span><a href="#41798834">parent</a><span>|</span><a href="#41799008">prev</a><span>|</span><a href="#41799389">next</a><span>|</span><label class="collapse" for="c-41801188">[-]</label><label class="expand" for="c-41801188">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;49085">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;49085</a></div><br/></div></div><div id="41799389" class="c"><input type="checkbox" id="c-41799389" checked=""/><div class="controls bullet"><span class="by">mseepgood</span><span>|</span><a href="#41798757">root</a><span>|</span><a href="#41798834">parent</a><span>|</span><a href="#41801188">prev</a><span>|</span><a href="#41799963">next</a><span>|</span><label class="collapse" for="c-41799389">[-]</label><label class="expand" for="c-41799389">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;faq#generic_methods" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;faq#generic_methods</a></div><br/></div></div><div id="41799963" class="c"><input type="checkbox" id="c-41799963" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#41798757">root</a><span>|</span><a href="#41798834">parent</a><span>|</span><a href="#41799389">prev</a><span>|</span><a href="#41798487">next</a><span>|</span><label class="collapse" for="c-41799963">[-]</label><label class="expand" for="c-41799963">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s broadly similar to the reason why Rust won&#x27;t allow generic methods on traits used to construct trait objects. It seems superficially like a reasonable thing to want, but actually isn&#x27;t when you consider the details. (The sister comments link to the specific reasons why in the case of Go.)</div><br/></div></div></div></div></div></div><div id="41798487" class="c"><input type="checkbox" id="c-41798487" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#41798757">prev</a><span>|</span><a href="#41798809">next</a><span>|</span><label class="collapse" for="c-41798487">[-]</label><label class="expand" for="c-41798487">[6 more]</label></div><br/><div class="children"><div class="content">Might be interesting to make a library that competes with <a href="https:&#x2F;&#x2F;github.com&#x2F;samber&#x2F;lo">https:&#x2F;&#x2F;github.com&#x2F;samber&#x2F;lo</a>?</div><br/><div id="41799475" class="c"><input type="checkbox" id="c-41799475" checked=""/><div class="controls bullet"><span class="by">mseepgood</span><span>|</span><a href="#41798487">parent</a><span>|</span><a href="#41801521">next</a><span>|</span><label class="collapse" for="c-41799475">[-]</label><label class="expand" for="c-41799475">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not interesting. Boring people did this a million times, the result is always the same: just use for loops.</div><br/></div></div><div id="41801521" class="c"><input type="checkbox" id="c-41801521" checked=""/><div class="controls bullet"><span class="by">acheong08</span><span>|</span><a href="#41798487">parent</a><span>|</span><a href="#41799475">prev</a><span>|</span><a href="#41798723">next</a><span>|</span><label class="collapse" for="c-41801521">[-]</label><label class="expand" for="c-41801521">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Tips for lazy developers
&gt; I cannot recommend it, but in case you are too lazy for repeating lo. everywhere, you can import the entire library into the namespace.<p><pre><code>    import (
        . &quot;github.com&#x2F;samber&#x2F;lo&quot;
    )
</code></pre>
TIL. Crazy</div><br/><div id="41807217" class="c"><input type="checkbox" id="c-41807217" checked=""/><div class="controls bullet"><span class="by">s6af7ygt</span><span>|</span><a href="#41798487">root</a><span>|</span><a href="#41801521">parent</a><span>|</span><a href="#41798723">next</a><span>|</span><label class="collapse" for="c-41807217">[-]</label><label class="expand" for="c-41807217">[1 more]</label></div><br/><div class="children"><div class="content">I just hate the fact that Go is super simple and clear but people try to make it complex with this kind of stuff. :(  Makes me sad.</div><br/></div></div></div></div><div id="41798723" class="c"><input type="checkbox" id="c-41798723" checked=""/><div class="controls bullet"><span class="by">gtramont</span><span>|</span><a href="#41798487">parent</a><span>|</span><a href="#41801521">prev</a><span>|</span><a href="#41798798">next</a><span>|</span><label class="collapse" for="c-41798723">[-]</label><label class="expand" for="c-41798723">[1 more]</label></div><br/><div class="children"><div class="content">Back when the Go team announced generics, I had a go (pun intended) at it: <a href="https:&#x2F;&#x2F;github.com&#x2F;gtramontina&#x2F;go-extlib">https:&#x2F;&#x2F;github.com&#x2F;gtramontina&#x2F;go-extlib</a> -- might resurrect it one day. `lo` is pretty comprehensive though.</div><br/></div></div><div id="41798798" class="c"><input type="checkbox" id="c-41798798" checked=""/><div class="controls bullet"><span class="by">mihaitodor</span><span>|</span><a href="#41798487">parent</a><span>|</span><a href="#41798723">prev</a><span>|</span><a href="#41798809">next</a><span>|</span><label class="collapse" for="c-41798798">[-]</label><label class="expand" for="c-41798798">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s one: <a href="https:&#x2F;&#x2F;github.com&#x2F;szmcdull&#x2F;glinq">https:&#x2F;&#x2F;github.com&#x2F;szmcdull&#x2F;glinq</a> It doesn&#x27;t do function chaining though.</div><br/></div></div></div></div><div id="41798809" class="c"><input type="checkbox" id="c-41798809" checked=""/><div class="controls bullet"><span class="by">dilap</span><span>|</span><a href="#41798487">prev</a><span>|</span><a href="#41799956">next</a><span>|</span><label class="collapse" for="c-41798809">[-]</label><label class="expand" for="c-41798809">[10 more]</label></div><br/><div class="children"><div class="content">The Reverse implementation seems off to me -- it runs through the iterator twice, once collecting into a slice, and then a second time filling the same slice in reverse. (So basically the first Collect call is only being used to find the length of the iterated sequence.) I&#x27;m not sure about Go conventions†, but I imagine it would be considered better form to only run through the iterator once, reversing the collected slice in-place via a series of swaps.<p>(† Are iterators even expected&#x2F;required to be reusable? If they are reusable, are they expected to be stable?)</div><br/><div id="41798929" class="c"><input type="checkbox" id="c-41798929" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41798809">parent</a><span>|</span><a href="#41799258">next</a><span>|</span><label class="collapse" for="c-41798929">[-]</label><label class="expand" for="c-41798929">[6 more]</label></div><br/><div class="children"><div class="content">That eliminates one of the main reasons to use this approach. Function chaining as most people write is awful for performance because it involves creating a separate array for each step in the chain. Given that most programs are actually more memory-blocked than CPU blocked, this is a bad tradeoff. Composing Go iterators, and composing iterators in general, is preferable because it doesn&#x27;t have to create all the intermediate arrays. A bad reverse wrecks that back up.<p>Still, you need the option, and while reverse is one of the more common iterators, it&#x27;s still usually avoidable if you need to. But if at all possible I&#x27;d suggest a &quot;reverse&quot; type-specialized to slices, and as necessary and possible, type-specialized to whatever other types you are using to <i>actually</i> crawl a value &quot;backwards&quot; rather than collecting a full iterator into a slice.<p>(Then again, I&#x27;m not a fan of this approach in imperative languages in general, due to the generalized difficulty in refactoring code written in this style and the fact that observationally, people just don&#x27;t refactor it once written and it affords a style rife with repetition. One of <i>the</i> most important considerations about code is how easily it can be refactored. In Haskell, this approach is excellent, precisely <i>because</i> it refactors very, very well in Haskell. In imperative languages, it tends not to, thus, serving as another example of why you can&#x27;t just blindly bring over nice things from one language into another without verifying they haven&#x27;t become sour in the process.)</div><br/><div id="41805779" class="c"><input type="checkbox" id="c-41805779" checked=""/><div class="controls bullet"><span class="by">coin</span><span>|</span><a href="#41798809">root</a><span>|</span><a href="#41798929">parent</a><span>|</span><a href="#41801821">next</a><span>|</span><label class="collapse" for="c-41805779">[-]</label><label class="expand" for="c-41805779">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Function chaining as most people write is awful for performance because it involves creating a separate array for each step in the chain<p>Not in some languages. Clojure and Google Guava are lazy, nothing is created, only transformed and only as needed. Swift has lazy but it doesn&#x27;t default to lazy.</div><br/></div></div><div id="41801821" class="c"><input type="checkbox" id="c-41801821" checked=""/><div class="controls bullet"><span class="by">wwalexander</span><span>|</span><a href="#41798809">root</a><span>|</span><a href="#41798929">parent</a><span>|</span><a href="#41805779">prev</a><span>|</span><a href="#41799081">next</a><span>|</span><label class="collapse" for="c-41801821">[-]</label><label class="expand" for="c-41801821">[1 more]</label></div><br/><div class="children"><div class="content">Worth comparing to Swift’s LazySequenceProtocol [0]. Various Sequences have a .lazy property that returns some LazySequenceProtocol&lt;Element&gt;, so you can opt in to this sort of fluent-style method chaining where it makes sense.<p>[0] <a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;swift&#x2F;lazysequenceprotocol" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;swift&#x2F;lazysequence...</a></div><br/></div></div><div id="41799081" class="c"><input type="checkbox" id="c-41799081" checked=""/><div class="controls bullet"><span class="by">dilap</span><span>|</span><a href="#41798809">root</a><span>|</span><a href="#41798929">parent</a><span>|</span><a href="#41801821">prev</a><span>|</span><a href="#41799258">next</a><span>|</span><label class="collapse" for="c-41799081">[-]</label><label class="expand" for="c-41799081">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, that all makes sense!, but I think it&#x27;s not relevent to the code in question, which is this:<p><pre><code>    func (i *Iterator[V]) Reverse() *Iterator[V] {
     collect := i.Collect()
     counter := len(collect) - 1
     for e := range i.iter {
      collect[counter] = e
      counter--
     }
     return From(collect)
    }
</code></pre>
So this code creates a slice from the iterator in the call to Collect(), and then fills the slice <i>again</i> in reverse by running the iterator <i>again</i>, which I think is wrong (or at least not-ideal).<p>(Your broader point about wanting to avoid creating an intermediate array at all for iterators and using type information to intelligently reverse &quot;at the source&quot; definitely still stands, in a broader context, though.)</div><br/><div id="41799336" class="c"><input type="checkbox" id="c-41799336" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41798809">root</a><span>|</span><a href="#41799081">parent</a><span>|</span><a href="#41799258">next</a><span>|</span><label class="collapse" for="c-41799336">[-]</label><label class="expand" for="c-41799336">[2 more]</label></div><br/><div class="children"><div class="content">Oh, yes, sorry. The level of error was more than I expected.<p>Edit: I should add that a &quot;Reverse&quot; that takes an iterator has no choice but to manifest the list and then reverse on the list. (Goodness help you if you try to reverse an infinite list.) But you can do type-dependent reverse iterators that don&#x27;t have to if the data structure doesn&#x27;t force it, and if you can do that you should, in general. This paragraph isn&#x27;t about Go; this is the iterator protocol itself.</div><br/><div id="41803047" class="c"><input type="checkbox" id="c-41803047" checked=""/><div class="controls bullet"><span class="by">dilap</span><span>|</span><a href="#41798809">root</a><span>|</span><a href="#41799336">parent</a><span>|</span><a href="#41799258">next</a><span>|</span><label class="collapse" for="c-41803047">[-]</label><label class="expand" for="c-41803047">[1 more]</label></div><br/><div class="children"><div class="content">I guess if you&#x27;re doing something like the original post&#x27;s &quot;type Iterator[V] struct&quot; you could somehow extend it capture the extra information to make an efficient Reverse work.<p>(FWIW, in C#, the IEnumerable extension method Reverse() just captures the whole sequence to an array and then iterates it in reverse. And yeah, woe unto you if you try to reverse an infinite sequence.)</div><br/></div></div></div></div></div></div></div></div><div id="41799258" class="c"><input type="checkbox" id="c-41799258" checked=""/><div class="controls bullet"><span class="by">atombender</span><span>|</span><a href="#41798809">parent</a><span>|</span><a href="#41798929">prev</a><span>|</span><a href="#41799956">next</a><span>|</span><label class="collapse" for="c-41799258">[-]</label><label class="expand" for="c-41799258">[3 more]</label></div><br/><div class="children"><div class="content">Why reverse the slice at all? Collect the input into a slice, then return an iterator that navigates the slice in backward order.<p>What this sort of thing lacks is any ability to optimize. For example, let&#x27;s say the operation is Reverse().Take(20). There&#x27;s no reason for the reverser to keep more than 20 elements in its buffer. But to express that, you have to make sure the iterator can be introspected and then rewritten to merge the operators and maybe unroll some of the loops to get better cache locality. This is what Haskell can achieve via Stream Fusion, which is pretty neat. But not so viable in Go.</div><br/><div id="41800173" class="c"><input type="checkbox" id="c-41800173" checked=""/><div class="controls bullet"><span class="by">ted_dunning</span><span>|</span><a href="#41798809">root</a><span>|</span><a href="#41799258">parent</a><span>|</span><a href="#41799456">next</a><span>|</span><label class="collapse" for="c-41800173">[-]</label><label class="expand" for="c-41800173">[1 more]</label></div><br/><div class="children"><div class="content">Julia does similar optimizations with the broadcast operator. The results can be mind bogglingly fast.</div><br/></div></div><div id="41799456" class="c"><input type="checkbox" id="c-41799456" checked=""/><div class="controls bullet"><span class="by">dilap</span><span>|</span><a href="#41798809">root</a><span>|</span><a href="#41799258">parent</a><span>|</span><a href="#41800173">prev</a><span>|</span><a href="#41799956">next</a><span>|</span><label class="collapse" for="c-41799456">[-]</label><label class="expand" for="c-41799456">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, good points.</div><br/></div></div></div></div></div></div><div id="41799956" class="c"><input type="checkbox" id="c-41799956" checked=""/><div class="controls bullet"><span class="by">mbrumlow</span><span>|</span><a href="#41798809">prev</a><span>|</span><a href="#41800576">next</a><span>|</span><label class="collapse" for="c-41799956">[-]</label><label class="expand" for="c-41799956">[4 more]</label></div><br/><div class="children"><div class="content">&gt; My issue with the go way of iterators is, you can’t chain them like you would in JavaScrip<p>Because it’s not JavaScript, and that is a good thing.</div><br/><div id="41801239" class="c"><input type="checkbox" id="c-41801239" checked=""/><div class="controls bullet"><span class="by">Varriount</span><span>|</span><a href="#41799956">parent</a><span>|</span><a href="#41800245">next</a><span>|</span><label class="collapse" for="c-41801239">[-]</label><label class="expand" for="c-41801239">[1 more]</label></div><br/><div class="children"><div class="content">It always bugs me when I see that pattern in JavaScript, because <i>each</i> `map`, etc. call is an array allocation. Yeah, yeah, I know that the VM&#x27;s memory allocators are likely optimized for fast allocation, but that doesn&#x27;t make the allocation completely free.</div><br/></div></div><div id="41800245" class="c"><input type="checkbox" id="c-41800245" checked=""/><div class="controls bullet"><span class="by">eweise</span><span>|</span><a href="#41799956">parent</a><span>|</span><a href="#41801239">prev</a><span>|</span><a href="#41800576">next</a><span>|</span><label class="collapse" for="c-41800245">[-]</label><label class="expand" for="c-41800245">[2 more]</label></div><br/><div class="children"><div class="content">But not because you can&#x27;t easily chain functions. That&#x27;s just a deficiency in the language design.</div><br/><div id="41804440" class="c"><input type="checkbox" id="c-41804440" checked=""/><div class="controls bullet"><span class="by">mbrumlow</span><span>|</span><a href="#41799956">root</a><span>|</span><a href="#41800245">parent</a><span>|</span><a href="#41800576">next</a><span>|</span><label class="collapse" for="c-41804440">[-]</label><label class="expand" for="c-41804440">[1 more]</label></div><br/><div class="children"><div class="content">No. It’s a feature.  Chaining makes some of the worst unreadable code.</div><br/></div></div></div></div></div></div><div id="41800576" class="c"><input type="checkbox" id="c-41800576" checked=""/><div class="controls bullet"><span class="by">vyskocilm</span><span>|</span><a href="#41799956">prev</a><span>|</span><a href="#41799965">next</a><span>|</span><label class="collapse" for="c-41800576">[-]</label><label class="expand" for="c-41800576">[2 more]</label></div><br/><div class="children"><div class="content">Shameless plug. I had experimented with Go iterators a while ago and did a <a href="https:&#x2F;&#x2F;github.com&#x2F;gomoni&#x2F;it">https:&#x2F;&#x2F;github.com&#x2F;gomoni&#x2F;it</a><p>It was updated to 1.23, so it is as idiomatic as I can get. And yes it has a map method between two types. Just a single simple trick used.</div><br/><div id="41803179" class="c"><input type="checkbox" id="c-41803179" checked=""/><div class="controls bullet"><span class="by">kunley</span><span>|</span><a href="#41800576">parent</a><span>|</span><a href="#41799965">next</a><span>|</span><label class="collapse" for="c-41803179">[-]</label><label class="expand" for="c-41803179">[1 more]</label></div><br/><div class="children"><div class="content">Nice rewrite for 1.23. Btw, just sent you a PR for a typo in the readme.</div><br/></div></div></div></div><div id="41799965" class="c"><input type="checkbox" id="c-41799965" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#41800576">prev</a><span>|</span><a href="#41804046">next</a><span>|</span><label class="collapse" for="c-41799965">[-]</label><label class="expand" for="c-41799965">[4 more]</label></div><br/><div class="children"><div class="content">I’m trying to understand whether this is intended to make Go seem bad or whether it’s just coming across that way to me.</div><br/><div id="41800230" class="c"><input type="checkbox" id="c-41800230" checked=""/><div class="controls bullet"><span class="by">ugjka</span><span>|</span><a href="#41799965">parent</a><span>|</span><a href="#41804046">next</a><span>|</span><label class="collapse" for="c-41800230">[-]</label><label class="expand" for="c-41800230">[3 more]</label></div><br/><div class="children"><div class="content">I looked at the code and it was giving me a headache, been messing around with Go for a decade, i do not like this</div><br/><div id="41800667" class="c"><input type="checkbox" id="c-41800667" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#41799965">root</a><span>|</span><a href="#41800230">parent</a><span>|</span><a href="#41804046">next</a><span>|</span><label class="collapse" for="c-41800667">[-]</label><label class="expand" for="c-41800667">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, same, used Go fulltime professionally for 10 years, not into this newer stuff.</div><br/><div id="41804293" class="c"><input type="checkbox" id="c-41804293" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#41799965">root</a><span>|</span><a href="#41800667">parent</a><span>|</span><a href="#41804046">next</a><span>|</span><label class="collapse" for="c-41804293">[-]</label><label class="expand" for="c-41804293">[1 more]</label></div><br/><div class="children"><div class="content">People have been trying to do this sort of thing in Go for as long as I remember; it&#x27;s nothing new and has not and most likely never will gain much uptake.<p>The stages of learning a language are something along the lines of:<p>1. Force language patterns from previous language<p>2. Frustration<p>3. Write library to make it easier<p>4. Anger<p>5. Acceptance</div><br/></div></div></div></div></div></div></div></div><div id="41804046" class="c"><input type="checkbox" id="c-41804046" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#41799965">prev</a><span>|</span><a href="#41798649">next</a><span>|</span><label class="collapse" for="c-41804046">[-]</label><label class="expand" for="c-41804046">[1 more]</label></div><br/><div class="children"><div class="content">We just released a go pkg that uses the new iter pkg. We were so excited by the interface in large part because of how simple iterators are to use.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;picosh&#x2F;pubsub&#x2F;blob&#x2F;main&#x2F;pubsub.go#L18">https:&#x2F;&#x2F;github.com&#x2F;picosh&#x2F;pubsub&#x2F;blob&#x2F;main&#x2F;pubsub.go#L18</a><p>We have seen in other languages like JS and python the power of iterators and we are happy to see it in Go</div><br/></div></div><div id="41798649" class="c"><input type="checkbox" id="c-41798649" checked=""/><div class="controls bullet"><span class="by">Savageman</span><span>|</span><a href="#41804046">prev</a><span>|</span><a href="#41802436">next</a><span>|</span><label class="collapse" for="c-41798649">[-]</label><label class="expand" for="c-41798649">[2 more]</label></div><br/><div class="children"><div class="content">I like how the author uses a test to run arbitrary code, this is exactly how I do it too!</div><br/><div id="41807290" class="c"><input type="checkbox" id="c-41807290" checked=""/><div class="controls bullet"><span class="by">TurboHaskal</span><span>|</span><a href="#41798649">parent</a><span>|</span><a href="#41802436">next</a><span>|</span><label class="collapse" for="c-41807290">[-]</label><label class="expand" for="c-41807290">[1 more]</label></div><br/><div class="children"><div class="content">Life without REPLs.</div><br/></div></div></div></div><div id="41802436" class="c"><input type="checkbox" id="c-41802436" checked=""/><div class="controls bullet"><span class="by">AndyKluger</span><span>|</span><a href="#41798649">prev</a><span>|</span><a href="#41799176">next</a><span>|</span><label class="collapse" for="c-41802436">[-]</label><label class="expand" for="c-41802436">[1 more]</label></div><br/><div class="children"><div class="content">1. That&#x27;s a good looking Hugo theme!<p>2. Implicitly chain everything all the time!<p>In Factor, you might do it as:<p><pre><code>    reverse [ sq ] [ even? ] map-filter [ . ] each
</code></pre>
Or with a little less optimizing:<p><pre><code>    reverse [ sq ] map [ even? ] filter [ . ] each
</code></pre>
The least obvious thing is that the period is the pretty-print function.</div><br/></div></div><div id="41799176" class="c"><input type="checkbox" id="c-41799176" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41802436">prev</a><span>|</span><a href="#41800292">next</a><span>|</span><label class="collapse" for="c-41799176">[-]</label><label class="expand" for="c-41799176">[4 more]</label></div><br/><div class="children"><div class="content">I think it would be more idiomatic to use statements, not expressions. That is, it’s ok to use local variables for intermediate values in a pipeline.</div><br/><div id="41799517" class="c"><input type="checkbox" id="c-41799517" checked=""/><div class="controls bullet"><span class="by">simiones</span><span>|</span><a href="#41799176">parent</a><span>|</span><a href="#41800292">next</a><span>|</span><label class="collapse" for="c-41799517">[-]</label><label class="expand" for="c-41799517">[3 more]</label></div><br/><div class="children"><div class="content">You often end up with a lot of extraneous variables with no useful names if you do that. A lot of the time the intermediate results in a pipeline are almost meaningless.</div><br/><div id="41799723" class="c"><input type="checkbox" id="c-41799723" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41799176">root</a><span>|</span><a href="#41799517">parent</a><span>|</span><a href="#41800292">next</a><span>|</span><label class="collapse" for="c-41799723">[-]</label><label class="expand" for="c-41799723">[2 more]</label></div><br/><div class="children"><div class="content">The main thing is not to do things that would be fine in other languages when they result in complications in the one you’re using. Some people want to write an entire library rather than writing statements. Why?<p>Also, local names can sometimes be useful documentation when the function names don’t really get the point across (perhaps because they’re at a different level of abstraction). Or alternatively, in Go it’s idiomatic to keep them short.</div><br/><div id="41800129" class="c"><input type="checkbox" id="c-41800129" checked=""/><div class="controls bullet"><span class="by">simiones</span><span>|</span><a href="#41799176">root</a><span>|</span><a href="#41799723">parent</a><span>|</span><a href="#41800292">next</a><span>|</span><label class="collapse" for="c-41800129">[-]</label><label class="expand" for="c-41800129">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Some people want to write an entire library rather than writing statements. Why?<p>Because you want to make code more readable, and getting rid of extraneous intermediate results is one way of achieving that.</div><br/></div></div></div></div></div></div></div></div><div id="41801265" class="c"><input type="checkbox" id="c-41801265" checked=""/><div class="controls bullet"><span class="by">indulona</span><span>|</span><a href="#41800292">prev</a><span>|</span><a href="#41799902">next</a><span>|</span><label class="collapse" for="c-41801265">[-]</label><label class="expand" for="c-41801265">[2 more]</label></div><br/><div class="children"><div class="content">&gt; My issue with the go way of iterators is, you can’t chain them like you would in JavaScript<p>You are not supposed to chain them. This addiction to try and chain everything everywhere all the time is so freaking weird and has been for a very long time.<p>Not only you are completely losing grasp on what is going on and write code prone to errors, but you are making it unreadable for other people that will be maintaining or just reading your code who will come long after you are gone from the company or abandon your library.<p>This is where Go&#x27;s simplicity approach and splitting each action into its own for loop or block of code is a godsend for maintainability.</div><br/><div id="41805816" class="c"><input type="checkbox" id="c-41805816" checked=""/><div class="controls bullet"><span class="by">eweise</span><span>|</span><a href="#41801265">parent</a><span>|</span><a href="#41799902">next</a><span>|</span><label class="collapse" for="c-41805816">[-]</label><label class="expand" for="c-41805816">[1 more]</label></div><br/><div class="children"><div class="content">Its really not. For example, a map function tells you that there will be the exact number of outputs as inputs. A for loop doesn&#x27;t have any guarantees. You have to read each line inside the loop to understand what its doing. In practice, having to be so explicit causes many more issues. I&#x27;ve never experienced as many mishandled errors on java projects as I have in Go.</div><br/></div></div></div></div><div id="41799902" class="c"><input type="checkbox" id="c-41799902" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#41801265">prev</a><span>|</span><a href="#41798621">next</a><span>|</span><label class="collapse" for="c-41799902">[-]</label><label class="expand" for="c-41799902">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny the author throws a dig at Python for its syntax that actively discourages this kind of code. Like… my guy you&#x27;re not taking the hint. Python makes things it doesn&#x27;t want you to do ugly as sin. It&#x27;s why lambda is so awkward and clunky.</div><br/><div id="41800986" class="c"><input type="checkbox" id="c-41800986" checked=""/><div class="controls bullet"><span class="by">xnacly</span><span>|</span><a href="#41799902">parent</a><span>|</span><a href="#41800627">next</a><span>|</span><label class="collapse" for="c-41800986">[-]</label><label class="expand" for="c-41800986">[1 more]</label></div><br/><div class="children"><div class="content">I get that, i still dont like to write f5(f4(f3(f2(f1())))) instead of writing f1().f2().f3().f4().f5()</div><br/></div></div><div id="41800627" class="c"><input type="checkbox" id="c-41800627" checked=""/><div class="controls bullet"><span class="by">rolux</span><span>|</span><a href="#41799902">parent</a><span>|</span><a href="#41800986">prev</a><span>|</span><a href="#41800606">next</a><span>|</span><label class="collapse" for="c-41800627">[-]</label><label class="expand" for="c-41800627">[3 more]</label></div><br/><div class="children"><div class="content">Yes. The following is a lot more concise:<p><pre><code>    a = [1, 2, 3, 4]
    print([v*v for v in reversed(a) if v*v % 2 == 0])</code></pre></div><br/><div id="41802498" class="c"><input type="checkbox" id="c-41802498" checked=""/><div class="controls bullet"><span class="by">libria</span><span>|</span><a href="#41799902">root</a><span>|</span><a href="#41800627">parent</a><span>|</span><a href="#41800606">next</a><span>|</span><label class="collapse" for="c-41802498">[-]</label><label class="expand" for="c-41802498">[2 more]</label></div><br/><div class="children"><div class="content">I think the above is a good idea of what&#x27;s wrong with python (and Go), because in your example the list comp is evaluated in what seems to be this order:<p><pre><code>    FOURTH-&gt; print([THIRD-&gt; v*v for v in FIRST-&gt; reversed(a) if SECOND-&gt; v*v % 2 == 0])
</code></pre>
Which is all over the place.  I&#x27;d rather see:<p><pre><code>    a = [1, 2, 3, 4]
    a = reversed(a)
    a = [v*v for v in a]
    a = [w for w in a if a % 2 == 0]
    print(a)</code></pre></div><br/><div id="41803384" class="c"><input type="checkbox" id="c-41803384" checked=""/><div class="controls bullet"><span class="by">alfons_foobar</span><span>|</span><a href="#41799902">root</a><span>|</span><a href="#41802498">parent</a><span>|</span><a href="#41800606">next</a><span>|</span><label class="collapse" for="c-41803384">[-]</label><label class="expand" for="c-41803384">[1 more]</label></div><br/><div class="children"><div class="content">This.<p>I often use generator expressions for the intermediate values (so I don&#x27;t allocate a new list for each step), but I find this to be much more readable.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>