<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1691830860179" as="style"/><link rel="stylesheet" href="styles.css?v=1691830860179"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.youtube.com/watch?v=7MpdZkGj5AI">Pijul: Version-Control Post-Git [video]</a> <span class="domain">(<a href="https://www.youtube.com">www.youtube.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>106 comments</span></div><br/><div><div id="37098298" class="c"><input type="checkbox" id="c-37098298" checked=""/><div class="controls bullet"><span class="by">evgpbfhnr</span><span>|</span><a href="#37096358">next</a><span>|</span><label class="collapse" for="c-37098298">[-]</label><label class="expand" for="c-37098298">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know if it&#x27;s the server being slow, or inherent to the protocol, but `pijul clone <a href="https:&#x2F;&#x2F;nest.pijul.com&#x2F;pijul&#x2F;pijul" rel="nofollow noreferrer">https:&#x2F;&#x2F;nest.pijul.com&#x2F;pijul&#x2F;pijul</a>` took an awefully long time (it doesn&#x27;t say how much it downloaded, but the .pijul directory is 28MB -- which isn&#x27;t a lot assuming it contains things similar to .git (gathering from the talk said it should contain diff + snapshot of each &#x27;commit&#x27;))</div><br/></div></div><div id="37096358" class="c"><input type="checkbox" id="c-37096358" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#37098298">prev</a><span>|</span><a href="#37097523">next</a><span>|</span><label class="collapse" for="c-37096358">[-]</label><label class="expand" for="c-37096358">[27 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not familiar with Pijul, and haven&#x27;t finished watching this presentation, but IME the problems with modern version control tools is that they still rely on comparing lines of plain text, something we&#x27;ve been doing for decades. Merge conflicts are an issue because our tools are agnostic about the actual content they&#x27;re tracking.<p>Instead, the tools should be smarter and work on the level of functions, classes, packages, sentences, paragraphs, or whatever primitive makes sense for the project and file that is being changed. In the case of code bases, they need to be aware of the language and the AST of the program. For binary files, they need to be aware of the file format and its binary structure. This would allow them to show actually meaningful diffs, and minimize the chances of conflicts, and of producing a corrupt file after an automatic merge.<p>There has been some research in this area, and there are a few semantic diffing tools[1,2,3], but I&#x27;m not aware of this being widely used in any VCS.<p>Nowadays, with all the machine learning advances, the ideal VCS should also use ML to understand the change at a deeper level, and maybe even suggest improvements. If AI can write code for me, it could surely understand what I&#x27;m trying to do, and help me so that version control is entirely hands-free, instead of having to fight with it, and be constantly aware of it, as I have to do now.<p>Or, since it&#x27;s more than likely that humans won&#x27;t be writing code or text in the near future, we&#x27;ll skip the next revolution in VCS tools, and AI will be able to version its own software. &#x2F;sigh<p>I just finished watching the presentation, and Pijul seems like an iterative improvement over Git. Nothing jumped out at me like a killer feature that would make me want to give it a try. It might be because the author focuses too much on technical details and fixing Git&#x27;s shortcomings, instead of taking a step back and rethinking what a modern VCS tool should look like today.<p>[1]: <a href="https:&#x2F;&#x2F;semanticdiff.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;semanticdiff.com&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;trailofbits&#x2F;graphtage">https:&#x2F;&#x2F;github.com&#x2F;trailofbits&#x2F;graphtage</a><p>[3]: <a href="https:&#x2F;&#x2F;github.com&#x2F;GumTreeDiff&#x2F;gumtree">https:&#x2F;&#x2F;github.com&#x2F;GumTreeDiff&#x2F;gumtree</a></div><br/><div id="37097903" class="c"><input type="checkbox" id="c-37097903" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#37096358">parent</a><span>|</span><a href="#37097171">next</a><span>|</span><label class="collapse" for="c-37097903">[-]</label><label class="expand" for="c-37097903">[4 more]</label></div><br/><div class="children"><div class="content">These ideas have mileage but as long as the source code is plain text, the way we represent changes is always going to be text based too.<p>Wouldn’t a better starting point be to change the way we represent source code, then let the patch tools follow?<p>Your editor knows exactly what steps you took to make your change.  A semantic VCS like you describe sounds very similar to reaching eventual consistency in a distributed data structure by sharing streams of edits between peers.<p>Personally, I’m a firm believer in text.  Auto formatting code so that changes are line oriented helps a lot.  So does a good culture of namespaces and separation of concerns.  Conflicts happen when two people working on different things have to edit the same code.  You can dodge that by more carefully structuring your project.<p>There’s a reason why software projects aren’t just single-file piles of symbols.  Code is primarily supposed to be human readable, and the more legible the project the better shape it is in for good ole line oriented diffing and patching.</div><br/><div id="37098295" class="c"><input type="checkbox" id="c-37098295" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#37096358">root</a><span>|</span><a href="#37097903">parent</a><span>|</span><a href="#37098191">next</a><span>|</span><label class="collapse" for="c-37098295">[-]</label><label class="expand" for="c-37098295">[1 more]</label></div><br/><div class="children"><div class="content">Plain text is only storage, I happily posit plain text as storage is not the issue.<p>It&#x27;s the tooling above that&#x27;s lacking. From editors to
source control, it&#x27;s all text&#x2F;buffer&#x2F;line&#x2F;character oriented,
which does have its benefits. Sure there&#x27;s syntax highlight, folding, symbol search and whatnot but semantically these tools only superficially understand code itself and certainly don&#x27;t operate on code, they only pretend to and are fundamentally text editors. We&#x27;re getting there with LSPs and error-tolerant parsers but they still map back to text for us to interact.<p>Tools like gofmt, black, ruby standard and such already kind of abstract away text as storage: you write code in whatever way and it gets transformed right under your feet. In some way as a dev you already don&#x27;t care about the text, it gets handled for you, but it still maps back to text because editors can&#x27;t handle anything else.<p>Similarly LSPs are in my mind quite nerfed because they have to do a whole back and forth to text dance. Vim text objects kind of goes into that direction as well, where you think about higher level constituents than text (arguments, methods, etc). Imagine being able to bind the understanding of LSPs right into semantic Vim language objects without them having to go through text!<p>I dream of an editor where I can open a bunch of functions or classes or namespaces (not files) in buffers that have understanding of the constituents, and it would all map back to files for storage behind the scenes. I believe it doesn&#x27;t have to go full tilt Smalltalk-like; the Closure conf Overtone demo from years ago is almost there, although not quite.</div><br/></div></div><div id="37098191" class="c"><input type="checkbox" id="c-37098191" checked=""/><div class="controls bullet"><span class="by">calgoo</span><span>|</span><a href="#37096358">root</a><span>|</span><a href="#37097903">parent</a><span>|</span><a href="#37098295">prev</a><span>|</span><a href="#37098134">next</a><span>|</span><label class="collapse" for="c-37098191">[-]</label><label class="expand" for="c-37098191">[1 more]</label></div><br/><div class="children"><div class="content">I think it’s possible to go to a function level, but you basically need to stop using the file system. We come back to the question of storing code in some sort of db based storage, which can then contain all these tools built in.  I can see this type of system being used more and more with the lambda &#x2F; edge &#x2F; micro service systems where it simplifies data synchronization. However git &#x2F; nextBestThing will keep on being used as long as we write code in text files.</div><br/></div></div><div id="37098134" class="c"><input type="checkbox" id="c-37098134" checked=""/><div class="controls bullet"><span class="by">pasc1878</span><span>|</span><a href="#37096358">root</a><span>|</span><a href="#37097903">parent</a><span>|</span><a href="#37098191">prev</a><span>|</span><a href="#37097171">next</a><span>|</span><label class="collapse" for="c-37098134">[-]</label><label class="expand" for="c-37098134">[1 more]</label></div><br/><div class="children"><div class="content">Hasn&quot;t that been done 30 years ago - didn&quot;t Envy work on the program structure.<p>But it is Smalltalk so code was not stored as plain text.<p>Now if only Smalltalk had changed with the times, e.g. added typing, used native GUIs and not set itself off in a walled expensive garden.</div><br/></div></div></div></div><div id="37097171" class="c"><input type="checkbox" id="c-37097171" checked=""/><div class="controls bullet"><span class="by">Wilfred</span><span>|</span><a href="#37096358">parent</a><span>|</span><a href="#37097903">prev</a><span>|</span><a href="#37097152">next</a><span>|</span><label class="collapse" for="c-37097171">[-]</label><label class="expand" for="c-37097171">[4 more]</label></div><br/><div class="children"><div class="content">Shameless plug: I&#x27;ve written difftastic[1], a tool that builds ASTs and then does a structural diff of them. You can use it with git too.<p>It&#x27;s an incredibly hard problem though, both from a computational complexity point of view, and trying to build a comprehensible UI once you&#x27;ve done the structural AST diff.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;wilfred&#x2F;difftastic">https:&#x2F;&#x2F;github.com&#x2F;wilfred&#x2F;difftastic</a></div><br/><div id="37098299" class="c"><input type="checkbox" id="c-37098299" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#37096358">root</a><span>|</span><a href="#37097171">parent</a><span>|</span><a href="#37097935">next</a><span>|</span><label class="collapse" for="c-37098299">[-]</label><label class="expand" for="c-37098299">[1 more]</label></div><br/><div class="children"><div class="content">Ah, yes, I knew I was forgetting one project. difftastic is very cool, thanks for writing it!<p>How well do existing VCSs integrate with it? Did you feel restricted at any point by writing a diffing tool, instead of basing a new VCS around this concept? Do you think a deeper integration would allow supporting other functionality beyond diffing, like automatic merging, conflict resolution, etc.?<p>I agree that it&#x27;s a very difficult problem. But as an industry, we have more than enough smart people and resources to work on it, which if solved would greatly improve our collective QoL. I can&#x27;t imagine the amount of time and effort we&#x27;ve wasted fighting with version control tools over the years, and a tool that solved these issues in a smarter way would make our lives much easier.</div><br/></div></div><div id="37097935" class="c"><input type="checkbox" id="c-37097935" checked=""/><div class="controls bullet"><span class="by">willow8349</span><span>|</span><a href="#37096358">root</a><span>|</span><a href="#37097171">parent</a><span>|</span><a href="#37098299">prev</a><span>|</span><a href="#37097152">next</a><span>|</span><label class="collapse" for="c-37097935">[-]</label><label class="expand" for="c-37097935">[2 more]</label></div><br/><div class="children"><div class="content">I think part of the problem is it seems everyone is trying to make a version control tool that is agnostic to all languages. Both computationally and UI wise. But C++ users expect to see different things than JavaScript users and so forth.<p>I’m surprised at the lack of hyper-specific language version control tools. I thought about making a side project for one in Julia a while back but not quite sure how it would look. Some random thoughts:<p>- info on type, name, constant changes<p>- let me checkout older revisions of individual functions &#x2F; objects &#x2F; whatever<p>- on unit test result changes for functions that have unit tests<p>- when changes are simply a refactor and are functionally the same</div><br/><div id="37098333" class="c"><input type="checkbox" id="c-37098333" checked=""/><div class="controls bullet"><span class="by">pastage</span><span>|</span><a href="#37096358">root</a><span>|</span><a href="#37097935">parent</a><span>|</span><a href="#37097152">next</a><span>|</span><label class="collapse" for="c-37098333">[-]</label><label class="expand" for="c-37098333">[1 more]</label></div><br/><div class="children"><div class="content">Every change is different in the same way every program is unique, the change of a couple of characters will alter the meaning. I think you have to try to write a diff UI to understand why it is hard.<p>Difftastic, Meld, diff -u, Word and other tools are amazing because they are usefull in many scenarios.  Getting the UI right has been a long process, beingable to grok the changes is still hard even with thw best tooling. It is also a question of tool adoption it takes a long time to understand how a tool works.</div><br/></div></div></div></div></div></div><div id="37097152" class="c"><input type="checkbox" id="c-37097152" checked=""/><div class="controls bullet"><span class="by">globalreset</span><span>|</span><a href="#37096358">parent</a><span>|</span><a href="#37097171">prev</a><span>|</span><a href="#37096995">next</a><span>|</span><label class="collapse" for="c-37097152">[-]</label><label class="expand" for="c-37097152">[7 more]</label></div><br/><div class="children"><div class="content">I disagree. Merge conflicts are just a fact of life, and line-granularity has good usability properties (displaying and editing). `git` has issues, but I don&#x27;t see merge conflict granularity being an issue, especially when project enforce consistent&amp;automatic formatting.<p>I agree however that while Pijul is technically very interesting, it doesn&#x27;t seem to have any killer features that would overcome the cost of switching to a niche version control.</div><br/><div id="37097329" class="c"><input type="checkbox" id="c-37097329" checked=""/><div class="controls bullet"><span class="by">appplication</span><span>|</span><a href="#37096358">root</a><span>|</span><a href="#37097152">parent</a><span>|</span><a href="#37097967">next</a><span>|</span><label class="collapse" for="c-37097329">[-]</label><label class="expand" for="c-37097329">[5 more]</label></div><br/><div class="children"><div class="content">&gt; line-granularity has good usability properties<p>I was reviewing a PR today and have to disagree with you. There was a single value change in a jsonl test data file. This is nightmarish to read in regular git diffs, as the change gif thought was happening was (with text wrapping) an full page worth of json rather than identifying it was a single word change. And because it is jsonl, the file could not be split into different lines without altering it’s semantics.<p>I don’t think it’s unreasonable we could be a little smarter here.</div><br/><div id="37097963" class="c"><input type="checkbox" id="c-37097963" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#37096358">root</a><span>|</span><a href="#37097329">parent</a><span>|</span><a href="#37097557">next</a><span>|</span><label class="collapse" for="c-37097963">[-]</label><label class="expand" for="c-37097963">[1 more]</label></div><br/><div class="children"><div class="content">JSONL and line-oriented version control are never going to play nicely together.<p>Imagine doing code review in a language where every function had to be written on one line!<p>The two techniques I use to dodge this:<p>1&#x2F; Switch from JSONL to a list of objects then pretty print it to be line oriented.<p>2&#x2F; Compress the test data to discourage viewing it altogether, and make people describe what’s being changed rather than leaving it up to the diff to show it.</div><br/></div></div><div id="37097557" class="c"><input type="checkbox" id="c-37097557" checked=""/><div class="controls bullet"><span class="by">hurril</span><span>|</span><a href="#37096358">root</a><span>|</span><a href="#37097329">parent</a><span>|</span><a href="#37097963">prev</a><span>|</span><a href="#37097850">next</a><span>|</span><label class="collapse" for="c-37097557">[-]</label><label class="expand" for="c-37097557">[2 more]</label></div><br/><div class="children"><div class="content">Diffs come with column offset coordinates, though, so perhaps it&#x27;s your diff editor that needs some more muscle?</div><br/><div id="37097800" class="c"><input type="checkbox" id="c-37097800" checked=""/><div class="controls bullet"><span class="by">nsajko</span><span>|</span><a href="#37096358">root</a><span>|</span><a href="#37097557">parent</a><span>|</span><a href="#37097850">next</a><span>|</span><label class="collapse" for="c-37097800">[-]</label><label class="expand" for="c-37097800">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, meld handles this fine.</div><br/></div></div></div></div><div id="37097850" class="c"><input type="checkbox" id="c-37097850" checked=""/><div class="controls bullet"><span class="by">heavenlyblue</span><span>|</span><a href="#37096358">root</a><span>|</span><a href="#37097329">parent</a><span>|</span><a href="#37097557">prev</a><span>|</span><a href="#37097967">next</a><span>|</span><label class="collapse" for="c-37097850">[-]</label><label class="expand" for="c-37097850">[1 more]</label></div><br/><div class="children"><div class="content">Simply auto-format that jsonl file and your git is going to be happy.</div><br/></div></div></div></div></div></div><div id="37096995" class="c"><input type="checkbox" id="c-37096995" checked=""/><div class="controls bullet"><span class="by">bogota</span><span>|</span><a href="#37096358">parent</a><span>|</span><a href="#37097152">prev</a><span>|</span><a href="#37096864">next</a><span>|</span><label class="collapse" for="c-37096995">[-]</label><label class="expand" for="c-37096995">[1 more]</label></div><br/><div class="children"><div class="content">Not sure how i feel about “ML” that would likely change over time being used in a VCS. This would make commits or whatever unit of work you want to save at non deterministic. Also as people we still care about file format and likely want to track it. If anything what you are talking about would just be a different view in a VCS that would still want to track file level changes if it was ever adopted.<p>For what your talking about though I don’t think the fundamental VCS really matters. You can do everything you are talking about with a tool that uses the diff from git.</div><br/></div></div><div id="37096864" class="c"><input type="checkbox" id="c-37096864" checked=""/><div class="controls bullet"><span class="by">KETpXDDzR</span><span>|</span><a href="#37096358">parent</a><span>|</span><a href="#37096995">prev</a><span>|</span><a href="#37096899">next</a><span>|</span><label class="collapse" for="c-37096864">[-]</label><label class="expand" for="c-37096864">[1 more]</label></div><br/><div class="children"><div class="content">You can tell git to use a different executable as diff tool. I agree, and I&#x27;m curious if such a tool satisfies my needs.
I think this problem is particularly hard since the diff tool needs to understand the coding language. We should have one diff tool per language IMO.<p>Edit: Related SO <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;523307&#x2F;semantic-diff-utilities" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;523307&#x2F;semantic-diff-uti...</a></div><br/></div></div><div id="37096899" class="c"><input type="checkbox" id="c-37096899" checked=""/><div class="controls bullet"><span class="by">ufo</span><span>|</span><a href="#37096358">parent</a><span>|</span><a href="#37096864">prev</a><span>|</span><a href="#37098160">next</a><span>|</span><label class="collapse" for="c-37096899">[-]</label><label class="expand" for="c-37096899">[1 more]</label></div><br/><div class="children"><div class="content">I while back I saw a paper[1] from someone who integrated semantic diff for VCS. They said that it works well for toplevel changes to the file (movind classes around, etc), but it doesn&#x27;t work as well for changes inside functions. For changes at the statement level, text diff worked better. [1] Unfortunately, I don&#x27;t remember the name of the paper though :(</div><br/></div></div><div id="37098160" class="c"><input type="checkbox" id="c-37098160" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#37096358">parent</a><span>|</span><a href="#37096899">prev</a><span>|</span><a href="#37098128">next</a><span>|</span><label class="collapse" for="c-37098160">[-]</label><label class="expand" for="c-37098160">[1 more]</label></div><br/><div class="children"><div class="content">Merge conflicts don&#x27;t go away when a diff tool understands syntax.<p>Semantic conflicts happen even when there are no textual conflicts. E.g. one developer removes a function and all calls to it. In parallel, another developer adds a new use of the removed function somewhere, in a file that the other developer didn&#x27;t even touch. Cherry pick those changes and you have a broken program.</div><br/></div></div><div id="37098128" class="c"><input type="checkbox" id="c-37098128" checked=""/><div class="controls bullet"><span class="by">CorrectHorseBat</span><span>|</span><a href="#37096358">parent</a><span>|</span><a href="#37098160">prev</a><span>|</span><a href="#37096849">next</a><span>|</span><label class="collapse" for="c-37098128">[-]</label><label class="expand" for="c-37098128">[1 more]</label></div><br/><div class="children"><div class="content">I think the problem with that is that&#x27;s it&#x27;s a massive amount of work after which you get a fragile system (What if the AST changes?) which doesn&#x27;t really mean much less work. Merge conflicts will still happen if two people change the same thing.</div><br/></div></div><div id="37096849" class="c"><input type="checkbox" id="c-37096849" checked=""/><div class="controls bullet"><span class="by">JohnBooty</span><span>|</span><a href="#37096358">parent</a><span>|</span><a href="#37098128">prev</a><span>|</span><a href="#37096716">next</a><span>|</span><label class="collapse" for="c-37096849">[-]</label><label class="expand" for="c-37096849">[3 more]</label></div><br/><div class="children"><div class="content">What (if anything) would we lose if we&#x27;re just shipping around AST&#x27;s and their associated deltas?<p>Would we lose formatting, etc?</div><br/><div id="37097400" class="c"><input type="checkbox" id="c-37097400" checked=""/><div class="controls bullet"><span class="by">Klaster_1</span><span>|</span><a href="#37096358">root</a><span>|</span><a href="#37096849">parent</a><span>|</span><a href="#37096716">next</a><span>|</span><label class="collapse" for="c-37097400">[-]</label><label class="expand" for="c-37097400">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the difference between shipping AST with formatting stripped and shipping code that&#x27;s been automatically formatted? I feel like the only difference is the configuration required to enforce the latter and different modes of failure. Adopting Prettier in my team was the best decision ever, so liberating. More languages should have a single, mandatory way to format code, without any ways to opt out.</div><br/><div id="37097943" class="c"><input type="checkbox" id="c-37097943" checked=""/><div class="controls bullet"><span class="by">strangetortoise</span><span>|</span><a href="#37096358">root</a><span>|</span><a href="#37097400">parent</a><span>|</span><a href="#37096716">next</a><span>|</span><label class="collapse" for="c-37097943">[-]</label><label class="expand" for="c-37097943">[1 more]</label></div><br/><div class="children"><div class="content">&gt; More languages should have a single, mandatory way to format code, without any ways to opt out.<p>Strongly disagree. Maybe if you&#x27;re in a very domain constrained environment, i vould see this being valuable. But i write graphics and simulation code all day, which involves a lot of translating math expressions. A compiler insisting on me using PascalCase (like for example .net uses) leads to very unreadable translations of formulas. And I&#x27;m not of the opinion that a system making me rewrite variable names to &quot;meaningful names&quot; helps understanding of the underlying math much, if you need to do symbol manipulation, or read backgrounds papers anyway.<p>Trust your users. Give them the tools to enforce safety barriers for themselves. Give them sensible defaults, sure. But give them ways to opt-out if they know that they need to break the conventions.</div><br/></div></div></div></div></div></div><div id="37096716" class="c"><input type="checkbox" id="c-37096716" checked=""/><div class="controls bullet"><span class="by">zaphirplane</span><span>|</span><a href="#37096358">parent</a><span>|</span><a href="#37096849">prev</a><span>|</span><a href="#37096971">next</a><span>|</span><label class="collapse" for="c-37096716">[-]</label><label class="expand" for="c-37096716">[2 more]</label></div><br/><div class="children"><div class="content">How about a few for examples of how this semantic &#x2F; AST is a game changer.<p>An extra parameter is added to an existing function, how does this look<p>Similar functionality are extracted to a parameterised new function, how does this look<p>I’m sure diff and code review tools will evolve but it’s helpful for people to talk about how it looks like to make it less nebulous matrix second life</div><br/><div id="37097613" class="c"><input type="checkbox" id="c-37097613" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#37096358">root</a><span>|</span><a href="#37096716">parent</a><span>|</span><a href="#37096971">next</a><span>|</span><label class="collapse" for="c-37097613">[-]</label><label class="expand" for="c-37097613">[1 more]</label></div><br/><div class="children"><div class="content">Coccinelle is an interesting project, relatively widely used by the Linux kernel developers.  Some examples on their website:<p><a href="https:&#x2F;&#x2F;coccinelle.gitlabpages.inria.fr&#x2F;website&#x2F;sp.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;coccinelle.gitlabpages.inria.fr&#x2F;website&#x2F;sp.html</a><p><a href="https:&#x2F;&#x2F;coccinelle.gitlabpages.inria.fr&#x2F;website&#x2F;rules&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;coccinelle.gitlabpages.inria.fr&#x2F;website&#x2F;rules&#x2F;</a></div><br/></div></div></div></div><div id="37096971" class="c"><input type="checkbox" id="c-37096971" checked=""/><div class="controls bullet"><span class="by">malkia</span><span>|</span><a href="#37096358">parent</a><span>|</span><a href="#37096716">prev</a><span>|</span><a href="#37097523">next</a><span>|</span><label class="collapse" for="c-37096971">[-]</label><label class="expand" for="c-37096971">[1 more]</label></div><br/><div class="children"><div class="content">This would work only if the language is suitable to do so (lisp, smalltalk comes to mind, but even there - having a comment can screw things up)</div><br/></div></div></div></div><div id="37097523" class="c"><input type="checkbox" id="c-37097523" checked=""/><div class="controls bullet"><span class="by">hobofan</span><span>|</span><a href="#37096358">prev</a><span>|</span><a href="#37095273">next</a><span>|</span><label class="collapse" for="c-37097523">[-]</label><label class="expand" for="c-37097523">[1 more]</label></div><br/><div class="children"><div class="content">I really like Pijul and its underlying libraries, both from a conceptual and implementation perspective.<p>However over the 6 years of its existence I&#x27;ve lost hope of it ever becoming something that I&#x27;ll use in my day-to-day, the same way I lost hope on rocket (the Rust web framework). After all those years it&#x27;s still essentially a single-maintainer side project who is stretched too thin across 3 big projects (Pijul, Sanakirja, Nest).<p>I really hope that at some point a maintainer&#x2F;team constellation emerges that can put all the lessons learned from Pijul into something that has a shot at being a successor to git.</div><br/></div></div><div id="37095273" class="c"><input type="checkbox" id="c-37095273" checked=""/><div class="controls bullet"><span class="by">MarkSweep</span><span>|</span><a href="#37097523">prev</a><span>|</span><a href="#37095352">next</a><span>|</span><label class="collapse" for="c-37095273">[-]</label><label class="expand" for="c-37095273">[5 more]</label></div><br/><div class="children"><div class="content">I don’t know much about using Pijul, but one nice thing about it compared to Git is its implementation is mostly defined in a library while the command line executable is separate:<p><a href="https:&#x2F;&#x2F;nest.pijul.com&#x2F;pijul&#x2F;pijul" rel="nofollow noreferrer">https:&#x2F;&#x2F;nest.pijul.com&#x2F;pijul&#x2F;pijul</a><p>Git can be annoying to integrate into a larger system without resorting to shelling out to the Git executable. There are alternatives like libgit2 and jgit, but they only have a subset of functionality.</div><br/><div id="37095721" class="c"><input type="checkbox" id="c-37095721" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#37095273">parent</a><span>|</span><a href="#37096823">next</a><span>|</span><label class="collapse" for="c-37095721">[-]</label><label class="expand" for="c-37095721">[3 more]</label></div><br/><div class="children"><div class="content">This causes a lot of grief for IDEs like Visual Studio, where updating Git breaks the IDE because there is no &quot;API contract&quot;. The text output changes, VS fails to parse it, and just crashes out with inscrutable errors.<p>I&#x27;ve become very opinionated in my old age, and I now firmly believe that:<p>1. All command-line tools should be &quot;library first, cli second&quot;.<p>2. All text-based formats should include a parser and formatter as a <i>function</i>. Never specify a text format you can&#x27;t round-trip. In other words, always include an &quot;escape&quot; function and an &quot;unescape&quot; function, or better yet, a parser and serializer. Random config files in Linux are notorious for not doing this. I want to be able to parse them, modify the object in memory, and then write them back out without having to worry about how strings are quoted or dates are formatted.<p>3. Protocols should always come with a non-executable and machine-readable spec. Think ANTLR grammar file, Open API spec, or something. Never use English only to describe a protocol. Make sure client code can be 100% automatically generated by a tool, in multiple languages.</div><br/><div id="37096994" class="c"><input type="checkbox" id="c-37096994" checked=""/><div class="controls bullet"><span class="by">pydave</span><span>|</span><a href="#37095273">root</a><span>|</span><a href="#37095721">parent</a><span>|</span><a href="#37096823">next</a><span>|</span><label class="collapse" for="c-37096994">[-]</label><label class="expand" for="c-37096994">[2 more]</label></div><br/><div class="children"><div class="content">Is that because they&#x27;re parsing porcelain output? Or is git&#x27;s <i>plumbing</i> machine-readable but not well specified?<p>But git users are more familiar with porcelain so I wouldn&#x27;t be surprised if they parsed that for an initial implementation.<p>It sounds like plumbing shouldn&#x27;t break as often as you imply:<p>&gt; The interface (input, output, set of options and the semantics) to these low-level commands are meant to be a lot more stable than Porcelain level commands, because these commands are primarily for scripted use.<p><a href="https:&#x2F;&#x2F;schacon.github.io&#x2F;git&#x2F;git.html#_low_level_commands_plumbing" rel="nofollow noreferrer">https:&#x2F;&#x2F;schacon.github.io&#x2F;git&#x2F;git.html#_low_level_commands_p...</a><p>However, doesn&#x27;t seem like they&#x27;re nearly as rigorous as you hope.</div><br/><div id="37097107" class="c"><input type="checkbox" id="c-37097107" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#37095273">root</a><span>|</span><a href="#37096994">parent</a><span>|</span><a href="#37096823">next</a><span>|</span><label class="collapse" for="c-37097107">[-]</label><label class="expand" for="c-37097107">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is that because they&#x27;re parsing porcelain output? Or is git&#x27;s plumbing machine-readable but not well specified?<p>From what I&#x27;ve seen, they&#x27;re using the latter, but breaking changes are still introduced.<p>Either way, the output of UNIX-like command-line tools is inherently weakly typed and often completely unspecified.<p>PowerShell for comparison ships every module as both a user-interactive CLI command (with parameter tab-complete!) <i>and</i> as a programatically usable dynamic library. They&#x27;re inherently one and the same, there&#x27;s only one interface that does both. The API returns .NET objects and is strongly typed. There is no parsing step at all. If you load a given version of a library, you&#x27;ll always get the expected types in the results.<p>Speaking of which, PowerShell uses semantic versioning for modules and can have multiple running side-by-side.<p>The future is here, it&#x27;s just not very evenly distributed.</div><br/></div></div></div></div></div></div><div id="37096823" class="c"><input type="checkbox" id="c-37096823" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#37095273">parent</a><span>|</span><a href="#37095721">prev</a><span>|</span><a href="#37095352">next</a><span>|</span><label class="collapse" for="c-37096823">[-]</label><label class="expand" for="c-37096823">[1 more]</label></div><br/><div class="children"><div class="content">I was actually looking into libpijul earlier this week, but unfortunately it seems like it&#x27;s still suffering from some growing pains in terms of friendliness to external devs; after spending over a half an hour delving into the API docs, I couldn&#x27;t even figure out where the &quot;entrypoint&quot; was, much less how to use the large number of pieces that interacted with each other.<p>From looking at the implementation of the executable, I think the library could really use some higher-level constructions like `Repository` here[0], or at least some higher-level prose docs explaining how to put the pieces together manually, maybe with a disclaimer like ripgrep&#x27;s backing library[1] has.<p>I really like what Pijul is doing from a design standpoint, but unfortunately it&#x27;s far from the level  of polish I would want to be able to consider it as a realistic alternative to git. If I&#x27;m going to have to put in effort to work around warts either way, I&#x27;m going to pick the tool with warts that I already know how to work around over the one where I&#x27;d have to learn from scratch and wouldn&#x27;t have nearly as many resources to help me learn them.<p>[0]: Not sure how to link to a specific line on the Pijul hosting site, but it&#x27;s in <a href="https:&#x2F;&#x2F;nest.pijul.com&#x2F;pijul&#x2F;pijul:main&#x2F;SXEYMYF7P4RZM.W5JQA" rel="nofollow noreferrer">https:&#x2F;&#x2F;nest.pijul.com&#x2F;pijul&#x2F;pijul:main&#x2F;SXEYMYF7P4RZM.W5JQA</a></div><br/></div></div></div></div><div id="37095352" class="c"><input type="checkbox" id="c-37095352" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#37095273">prev</a><span>|</span><a href="#37095243">next</a><span>|</span><label class="collapse" for="c-37095352">[-]</label><label class="expand" for="c-37095352">[16 more]</label></div><br/><div class="children"><div class="content">Within the first 5 minutes, the presentation claims that &quot;the tools are unusable without a global central server&quot;.<p>I really don&#x27;t know what that is supposed to mean. Plemty of people do in fact use github, but I don&#x27;t know why anyone would say that git in particular is &quot;unusable&quot; without a global central server.<p>Github (etc.) are conveniences for people who don&#x27;t want to self-host. They provide some additional tools that can be useful in some situations. But nothing more.</div><br/><div id="37095437" class="c"><input type="checkbox" id="c-37095437" checked=""/><div class="controls bullet"><span class="by">reilly3000</span><span>|</span><a href="#37095352">parent</a><span>|</span><a href="#37095783">next</a><span>|</span><label class="collapse" for="c-37095437">[-]</label><label class="expand" for="c-37095437">[12 more]</label></div><br/><div class="children"><div class="content">There are vast swaths of devs who are not aware people still use mailing lists, nor that git has first class support for applying patches from emails.</div><br/><div id="37095458" class="c"><input type="checkbox" id="c-37095458" checked=""/><div class="controls bullet"><span class="by">crdrost</span><span>|</span><a href="#37095352">root</a><span>|</span><a href="#37095437">parent</a><span>|</span><a href="#37095630">next</a><span>|</span><label class="collapse" for="c-37095458">[-]</label><label class="expand" for="c-37095458">[7 more]</label></div><br/><div class="children"><div class="content">And that this is not just a minor niche use case, &quot;the largest and oldest Git project that is, Linux, uses a mailing list and patch files to develop.&quot;</div><br/><div id="37097073" class="c"><input type="checkbox" id="c-37097073" checked=""/><div class="controls bullet"><span class="by">electroly</span><span>|</span><a href="#37095352">root</a><span>|</span><a href="#37095458">parent</a><span>|</span><a href="#37096529">next</a><span>|</span><label class="collapse" for="c-37097073">[-]</label><label class="expand" for="c-37097073">[1 more]</label></div><br/><div class="children"><div class="content">Note that Linux, today, is far from the largest Git project. Oldest, yes. Biggest, not even close. FAANG monorepos are vastly bigger with much higher commit rates. The Linux kernel is quaint, small, and moves glacially slow in comparison. Even if we consider only public open source codebases, Chromium&#x27;s repo is bigger than Linux by any reasonable metric.</div><br/></div></div><div id="37096529" class="c"><input type="checkbox" id="c-37096529" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37095352">root</a><span>|</span><a href="#37095458">parent</a><span>|</span><a href="#37097073">prev</a><span>|</span><a href="#37095656">next</a><span>|</span><label class="collapse" for="c-37096529">[-]</label><label class="expand" for="c-37096529">[1 more]</label></div><br/><div class="children"><div class="content">TBH I definitely consider Linux a niche use case. It’s an outlier relative to 99.99% of projects.</div><br/></div></div><div id="37095656" class="c"><input type="checkbox" id="c-37095656" checked=""/><div class="controls bullet"><span class="by">bananapub</span><span>|</span><a href="#37095352">root</a><span>|</span><a href="#37095458">parent</a><span>|</span><a href="#37096529">prev</a><span>|</span><a href="#37095630">next</a><span>|</span><label class="collapse" for="c-37095656">[-]</label><label class="expand" for="c-37095656">[4 more]</label></div><br/><div class="children"><div class="content">it is definitely not the oldest</div><br/><div id="37095682" class="c"><input type="checkbox" id="c-37095682" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#37095352">root</a><span>|</span><a href="#37095656">parent</a><span>|</span><a href="#37095768">next</a><span>|</span><label class="collapse" for="c-37095682">[-]</label><label class="expand" for="c-37095682">[1 more]</label></div><br/><div class="children"><div class="content">In the sense that it was the <i>first</i> project to use git (has been using git the longest), not in the sense that it&#x27;s the oldest project that <i>switched</i> to git.</div><br/></div></div><div id="37095768" class="c"><input type="checkbox" id="c-37095768" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#37095352">root</a><span>|</span><a href="#37095656">parent</a><span>|</span><a href="#37095682">prev</a><span>|</span><a href="#37095728">next</a><span>|</span><label class="collapse" for="c-37095768">[-]</label><label class="expand" for="c-37095768">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it is definitely not the oldest<p>IIRC, the oldest was git itself (it self-hosted early on its development history); git, linux, and sparse are IIRC the three projects that have been using git the longest.</div><br/></div></div></div></div></div></div><div id="37095630" class="c"><input type="checkbox" id="c-37095630" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#37095352">root</a><span>|</span><a href="#37095437">parent</a><span>|</span><a href="#37095458">prev</a><span>|</span><a href="#37095515">next</a><span>|</span><label class="collapse" for="c-37095630">[-]</label><label class="expand" for="c-37095630">[2 more]</label></div><br/><div class="children"><div class="content">We don&#x27;t even do that. ardour.org self-hosts gitea, and that allows for PRs etc. We don&#x27;t expose that to &quot;the public&quot;, for now, just because github is familiar to more people. But we could.</div><br/><div id="37096387" class="c"><input type="checkbox" id="c-37096387" checked=""/><div class="controls bullet"><span class="by">mcronce</span><span>|</span><a href="#37095352">root</a><span>|</span><a href="#37095630">parent</a><span>|</span><a href="#37095515">next</a><span>|</span><label class="collapse" for="c-37096387">[-]</label><label class="expand" for="c-37096387">[1 more]</label></div><br/><div class="children"><div class="content">I self-host Gitlab, which is pretty familiar to people, but I still mirror repos for which I&#x27;m hoping to get contributions to GitHub for the same reason</div><br/></div></div></div></div><div id="37095515" class="c"><input type="checkbox" id="c-37095515" checked=""/><div class="controls bullet"><span class="by">tiffanyg</span><span>|</span><a href="#37095352">root</a><span>|</span><a href="#37095437">parent</a><span>|</span><a href="#37095630">prev</a><span>|</span><a href="#37096412">next</a><span>|</span><label class="collapse" for="c-37095515">[-]</label><label class="expand" for="c-37095515">[1 more]</label></div><br/><div class="children"><div class="content">... apparently ... that&#x27;s rather absurd ... perhaps I won&#x27;t listen to this presentation when time might allow, for the moment.<p><i><a href="https:&#x2F;&#x2F;youtu.be&#x2F;1Npo0cmp-VY" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;1Npo0cmp-VY</a></i><p><i>On second thought, let&#x27;s not go to Camelot, tis a silly place.</i></div><br/></div></div><div id="37096412" class="c"><input type="checkbox" id="c-37096412" checked=""/><div class="controls bullet"><span class="by">da39a3ee</span><span>|</span><a href="#37095352">root</a><span>|</span><a href="#37095437">parent</a><span>|</span><a href="#37095515">prev</a><span>|</span><a href="#37095783">next</a><span>|</span><label class="collapse" for="c-37096412">[-]</label><label class="expand" for="c-37096412">[1 more]</label></div><br/><div class="children"><div class="content">&gt; git has first class support for applying patches from emails.<p>You say that like it&#x27;s a good thing.</div><br/></div></div></div></div><div id="37095783" class="c"><input type="checkbox" id="c-37095783" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#37095352">parent</a><span>|</span><a href="#37095437">prev</a><span>|</span><a href="#37096237">next</a><span>|</span><label class="collapse" for="c-37095783">[-]</label><label class="expand" for="c-37095783">[1 more]</label></div><br/><div class="children"><div class="content">I have used git without a central server many, many times. Passing bundles by email or USB sticks, and pushing and pulling between workspaces. At work, it is because we have often have different networks, isolated for security reasons. For personal use, I don&#x27;t really have a central server. I may use GitHub, because it offers free hosting and serves as a backup, but it isn&#x27;t central in the sense that it is not always the git-remote &quot;origin&quot;.<p>It may not be the most typical workflow, and it requires some getting used to but it is 100% usable. In fact, I am not aware of a &quot;central server&quot; for the Linux kernel. For all I know, the closest thing to it could be Linus Torvalds&#x27;s PC.</div><br/></div></div></div></div><div id="37095243" class="c"><input type="checkbox" id="c-37095243" checked=""/><div class="controls bullet"><span class="by">crickey</span><span>|</span><a href="#37095352">prev</a><span>|</span><a href="#37095429">next</a><span>|</span><label class="collapse" for="c-37095243">[-]</label><label class="expand" for="c-37095243">[8 more]</label></div><br/><div class="children"><div class="content">Nothing against the project or talk itself. But kinda funny when a talk starts with “i bet many of you thought X was a solved problem, well im here to tell u it isnt.” 
Git was populare not because its somehow revolutionary, its popular because the previous options where so increadibly shit. Any alternative to git is gonna have a hard time without that advantage</div><br/><div id="37095487" class="c"><input type="checkbox" id="c-37095487" checked=""/><div class="controls bullet"><span class="by">tiffanyg</span><span>|</span><a href="#37095243">parent</a><span>|</span><a href="#37095925">next</a><span>|</span><label class="collapse" for="c-37095487">[-]</label><label class="expand" for="c-37095487">[3 more]</label></div><br/><div class="children"><div class="content">Haha - in enough ways, git is shit.<p>I&#x27;m not disagreeing, though. I think you&#x27;re right (for the &quot;foreseeable future&quot;). CVS, SVN, etc., really became serious obstacles once you moved to larger projects and more distributed teams etc. Hell, they caused problems even with small colocated teams.<p>I think it&#x27;s clear that git (and its forerunners, esp. &quot;BitKeeper&quot;) meets a solid &quot;good enough&quot; standard. Potential competitors from that era, including, in particular, &quot;Mercurial&quot;, largely fall into categories of &quot;trade-offs&quot;.<p>But, I am, personally, very happy to see the work that&#x27;s been done with &quot;Pijul&quot;, including completing a &quot;theory of merging&quot;.<p>I don&#x27;t think Pijul has much of a chance in even 10+ years of <i>replacing</i> git (and &quot;GitHub&quot;, part of the success story of git). But, I do think it&#x27;ll see some use, become a solid foundation for some projects, and, there&#x27;s a reasonable chance it will influence or become the foundation of some &quot;next git&quot; and&#x2F;or future versions of git.<p>With the caveat, of course, that forecasting anything on those kinds of timeframes is even more of a fools errand now than it was even ~15+ years ago (about when git was first developed).</div><br/><div id="37096048" class="c"><input type="checkbox" id="c-37096048" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#37095243">root</a><span>|</span><a href="#37095487">parent</a><span>|</span><a href="#37095960">next</a><span>|</span><label class="collapse" for="c-37096048">[-]</label><label class="expand" for="c-37096048">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Potential competitors from that era, including, in particular, &quot;Mercurial&quot;, largely fall into categories of &quot;trade-offs&quot;.<p>Which &quot;trade-offs&quot; are you referring to?<p>Mercurial was, and still is, a solid DVCS. It&#x27;s not often used today because it lost the popularity contest, due to several reasons[0], but technically it&#x27;s as good as Git, and functionally it&#x27;s even better. It has a much saner and friendlier UI, which is the main complaint about Git.<p>[0]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37095925">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37095925</a></div><br/></div></div></div></div><div id="37095925" class="c"><input type="checkbox" id="c-37095925" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#37095243">parent</a><span>|</span><a href="#37095487">prev</a><span>|</span><a href="#37097764">next</a><span>|</span><label class="collapse" for="c-37095925">[-]</label><label class="expand" for="c-37095925">[1 more]</label></div><br/><div class="children"><div class="content">Git itself might not have been revolutionary, but the concept of distributed version control certainly was. Git wasn&#x27;t the only tool from that era to adopt this model, but it&#x27;s fair to say that it has won the popularity contest, and is the modern standard in most projects.<p>Mercurial, Darcs and Fossil are also interesting, and in some ways better than Git, but Git won because it had the persona of Linus behind it, one of the most popular and influential OSS projects using it as proving ground, and a successful and user friendly commercial service built directly around it, that included it even in its name. All of this was enough for Git to gain traction and pull ahead of other DVCSs, even though in the early days Mercurial and Bitbucket were also solid and popular choices.<p>I used and preferred Mercurial for a long time, but ultimately Git was more prevalent, and it felt like swimming against the current. I feel like that also happened with Docker (Swarm) and Kubernetes, where k8s is now the de facto container orchestration standard, much to my own chagrin.</div><br/></div></div><div id="37097764" class="c"><input type="checkbox" id="c-37097764" checked=""/><div class="controls bullet"><span class="by">stakhanov</span><span>|</span><a href="#37095243">parent</a><span>|</span><a href="#37095925">prev</a><span>|</span><a href="#37096317">next</a><span>|</span><label class="collapse" for="c-37097764">[-]</label><label class="expand" for="c-37097764">[1 more]</label></div><br/><div class="children"><div class="content">&gt; previous options where so increadibly shit<p>I entirely disagree.  Git was not an okayish solution to a problem that previously didn&#x27;t have any okayish solutions.  Git was trying to solve a new problem, and, as it turns out, it&#x27;s a problem that a majority of git users don&#x27;t have, and don&#x27;t intend to have in the future.<p>I use SVN to this day, because I seriously believe that it&#x27;s a better solution to the centralized version control problem than GIT.  After SVN, <i>centralized</i> version control was basically a solved problem (or, at least, we had an okayish solution), so the next generation of tools (GIT, BZR, HG, FOSSIL) tried to solve a <i>different</i> problem, namely <i>distributed</i> version control.<p>But they made a complete mess of it (at least git did, I don&#x27;t know the other distributed ones particularly well).  A majority of git projects use centralized workflow and are subsetting the use of git features to only the ones that straightforwardly correspond to things that svn can do as well, and can do more easily.  And the cost was a much more complex&#x2F;convoluted mental model that a majority of git users don&#x27;t truly understand in full detail, which gets them in trouble if edge cases turn up.  Hence this joke [1].  With things like [2], you&#x27;re basically seeing git becoming a parody on itself.<p>[1] <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1597&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;xkcd.com&#x2F;1597&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;westling.dev&#x2F;b&#x2F;extremely-linear-git" rel="nofollow noreferrer">https:&#x2F;&#x2F;westling.dev&#x2F;b&#x2F;extremely-linear-git</a></div><br/></div></div><div id="37096317" class="c"><input type="checkbox" id="c-37096317" checked=""/><div class="controls bullet"><span class="by">fasterik</span><span>|</span><a href="#37095243">parent</a><span>|</span><a href="#37097764">prev</a><span>|</span><a href="#37096197">next</a><span>|</span><label class="collapse" for="c-37096317">[-]</label><label class="expand" for="c-37096317">[1 more]</label></div><br/><div class="children"><div class="content">Git works well enough for projects that are essentially similar to the Linux kernel, i.e. it&#x27;s designed to be used by programmers working primarily on text files. For projects that have non-technical people collaborating with programmers, or frequently changing binary assets, there is plenty of room for improvement over git.</div><br/></div></div></div></div><div id="37095429" class="c"><input type="checkbox" id="c-37095429" checked=""/><div class="controls bullet"><span class="by">wyldfire</span><span>|</span><a href="#37095243">prev</a><span>|</span><a href="#37095891">next</a><span>|</span><label class="collapse" for="c-37095429">[-]</label><label class="expand" for="c-37095429">[14 more]</label></div><br/><div class="children"><div class="content">Jujutsu was discussed recently - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36952796">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36952796</a><p>IIRC it&#x27;s inspired by Pijul and mercurial and uses git database underneath?  or it&#x27;s git-compatible at least.</div><br/><div id="37095534" class="c"><input type="checkbox" id="c-37095534" checked=""/><div class="controls bullet"><span class="by">macawfish</span><span>|</span><a href="#37095429">parent</a><span>|</span><a href="#37095891">next</a><span>|</span><label class="collapse" for="c-37095534">[-]</label><label class="expand" for="c-37095534">[13 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t support patch commutation, which in my mind is the whole point of using Pijul.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29792092">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29792092</a><p>Imagine being able to &quot;toggle&quot; features or changes quickly and easily without worrying about which order they were implemented in.  Patch commutation makes that easier.</div><br/><div id="37095893" class="c"><input type="checkbox" id="c-37095893" checked=""/><div class="controls bullet"><span class="by">fl0ki</span><span>|</span><a href="#37095429">root</a><span>|</span><a href="#37095534">parent</a><span>|</span><a href="#37095859">next</a><span>|</span><label class="collapse" for="c-37095893">[-]</label><label class="expand" for="c-37095893">[6 more]</label></div><br/><div class="children"><div class="content">Sure, but in any case where the patches were independent enough to automatically apply in any order, `git rebase --interactive` would have worked just as well and has done for about two decades. It can reorder, drop, squash, amend, etc. all in your $EDITOR. The much more common limitation that hits every VCS is that patches are rarely that independent and manual merges are tedious and error-prone, but when that&#x27;s not a blocker, interactive rebase is hard to beat.<p>The biggest problem, in my experience, is that 99% of people using git have no idea just how powerful it actually is. That is a mark against git, but it is what it is, and it&#x27;s a mark against engineers who refuse to learn the tools they use every day for years.<p>Weirdest case was when I asked someone to fix up a bad merge they did that resulted in duplicate commits they didn&#x27;t even notice in the log. I said just do an interactive rebase, the dude said &quot;that is outside my operating parameters&quot;, yes really, I couldn&#x27;t make that up if I tried. Dude boasted 25+ years experience and didn&#x27;t know about this incredible feature, and apart from the weird robot response, this is consistent with almost everyone I talk to about almost any semi-advanced git feature.</div><br/><div id="37096060" class="c"><input type="checkbox" id="c-37096060" checked=""/><div class="controls bullet"><span class="by">macawfish</span><span>|</span><a href="#37095429">root</a><span>|</span><a href="#37095893">parent</a><span>|</span><a href="#37098051">next</a><span>|</span><label class="collapse" for="c-37096060">[-]</label><label class="expand" for="c-37096060">[4 more]</label></div><br/><div class="children"><div class="content">I use `git rebase -i` all the time and it&#x27;s great but it involves rewriting history, which essentially means the result is almost guaranteed to give you conflicts in any case where you want to merge or rebase it with another branch that shares some of the commits in your rebase.<p>Whereas in Pijul history is preserved. In Pijul a &quot;branch&quot; (called a &quot;channel&quot;) is just a set of applied patches. I&#x27;m still a little ignorant but if I&#x27;m not mistaken the way Pijul encodes patches, in a big graph, also means that they&#x27;re more likely to be composable without conflicts in the first place. And when conflicts do arise their resolutions will be more reusable.<p>Just today I was performance profiling various subsets of a set of changes using &quot;git cherry-pick&quot; and &quot;git revert&quot;, to understand how these changes interacted and which ones gave the best results. It was fine but I had to do quite a bit of conflict resolution because some of them were based on one branch and some on another, and the resulting  wouldn&#x27;t even be easily mergable&#x2F;reusable anyway.<p>What if I could instead just pick a few patches I wanted to mix &amp; match and run some benchmarks over every combination of them? Then I could pick the fastest combo without needing to worry about messing up my history? With Pijul I imagine this would be a breeze.<p>I&#x27;m looking forward to trying it now that it&#x27;s getting stable.</div><br/><div id="37097571" class="c"><input type="checkbox" id="c-37097571" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#37095429">root</a><span>|</span><a href="#37096060">parent</a><span>|</span><a href="#37098051">next</a><span>|</span><label class="collapse" for="c-37097571">[-]</label><label class="expand" for="c-37097571">[3 more]</label></div><br/><div class="children"><div class="content">Those commits you were having issues with in git, have you tried putting them into pijul to be sure it doesn&#x27;t have the same problem?<p>Because so far I have yet to understand why pijul&#x27;s &quot;set of applied patches&quot; would do anything different than git rebase&#x2F;cherry-pick.  Those work by applying the diffs of each commit to the new tree.  Sounds like the same thing to me, or at least close enough to result in the same conflicts.</div><br/><div id="37098162" class="c"><input type="checkbox" id="c-37098162" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#37095429">root</a><span>|</span><a href="#37097571">parent</a><span>|</span><a href="#37098051">next</a><span>|</span><label class="collapse" for="c-37098162">[-]</label><label class="expand" for="c-37098162">[2 more]</label></div><br/><div class="children"><div class="content">Git does not work with patches internally. Pijul does. This is where all the differences in merging happen.<p>If git worked with patches, git rerere wouldn’t be a thing.<p><a href="https:&#x2F;&#x2F;pijul.org&#x2F;manual&#x2F;why_pijul.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;pijul.org&#x2F;manual&#x2F;why_pijul.html</a></div><br/></div></div></div></div></div></div><div id="37098051" class="c"><input type="checkbox" id="c-37098051" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#37095429">root</a><span>|</span><a href="#37095893">parent</a><span>|</span><a href="#37096060">prev</a><span>|</span><a href="#37095859">next</a><span>|</span><label class="collapse" for="c-37098051">[-]</label><label class="expand" for="c-37098051">[1 more]</label></div><br/><div class="children"><div class="content">Patch commutation gives more than just interactive rebase.<p>It gives you partial checkout with the horrible hacks like subtree.</div><br/></div></div></div></div><div id="37095859" class="c"><input type="checkbox" id="c-37095859" checked=""/><div class="controls bullet"><span class="by">wyldfire</span><span>|</span><a href="#37095429">root</a><span>|</span><a href="#37095534">parent</a><span>|</span><a href="#37095893">prev</a><span>|</span><a href="#37095891">next</a><span>|</span><label class="collapse" for="c-37095859">[-]</label><label class="expand" for="c-37095859">[6 more]</label></div><br/><div class="children"><div class="content">If we can get rid of the &quot;staging area&quot; and resolve the ambiguities of &quot;checkout&quot; it would be a great step in the right direction.</div><br/><div id="37095952" class="c"><input type="checkbox" id="c-37095952" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#37095429">root</a><span>|</span><a href="#37095859">parent</a><span>|</span><a href="#37095891">next</a><span>|</span><label class="collapse" for="c-37095952">[-]</label><label class="expand" for="c-37095952">[5 more]</label></div><br/><div class="children"><div class="content">Having come from subversion, the staging area is by far my favorite part of git in day-to-day use.</div><br/><div id="37096504" class="c"><input type="checkbox" id="c-37096504" checked=""/><div class="controls bullet"><span class="by">pseudalopex</span><span>|</span><a href="#37095429">root</a><span>|</span><a href="#37095952">parent</a><span>|</span><a href="#37096497">next</a><span>|</span><label class="collapse" for="c-37096504">[-]</label><label class="expand" for="c-37096504">[1 more]</label></div><br/><div class="children"><div class="content">Mercurial and others use commits how Git uses the staging area. Same benefits. Simpler interface. Fewer ways to shoot yourself in the foot.</div><br/></div></div><div id="37096497" class="c"><input type="checkbox" id="c-37096497" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37095429">root</a><span>|</span><a href="#37095952">parent</a><span>|</span><a href="#37096504">prev</a><span>|</span><a href="#37095891">next</a><span>|</span><label class="collapse" for="c-37096497">[-]</label><label class="expand" for="c-37096497">[3 more]</label></div><br/><div class="children"><div class="content">Why is that? I work regularly with Mercurial and Git. The stage isn’t a huge problem or anything, but it’s super annoying and gives me zero value.<p>TBH I think the stage is kinda dirty. Because it means you’re making a commit that has never actually existed on your machine and thus can’t have possibly been tested.</div><br/><div id="37097473" class="c"><input type="checkbox" id="c-37097473" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#37095429">root</a><span>|</span><a href="#37096497">parent</a><span>|</span><a href="#37097538">next</a><span>|</span><label class="collapse" for="c-37097473">[-]</label><label class="expand" for="c-37097473">[1 more]</label></div><br/><div class="children"><div class="content">Two things:  To review the changes piece by piece before commit (git add -p) in case there&#x27;s something temporary in there I forgot, and to easily exclude any such thing I never intended to commit (usually todo-style comments, sometimes hardcoding a value to trigger a bug or a popup, etc)<p>I remember a decade ago trying mercurial and git at the same time when subversion was all I knew, and that there was something about mercurial that I found really confusing.  It&#x27;s long enough ago I don&#x27;t remember what it was, and it may be better now, but git clicked immediately.  I wouldn&#x27;t be surprised if it was the way they handle commits instead of having a staging area.<p>Also compared to subversion, the staging area is an explicit form of something that half-exists in how it tracks files for committing.</div><br/></div></div><div id="37097538" class="c"><input type="checkbox" id="c-37097538" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#37095429">root</a><span>|</span><a href="#37096497">parent</a><span>|</span><a href="#37097473">prev</a><span>|</span><a href="#37095891">next</a><span>|</span><label class="collapse" for="c-37097538">[-]</label><label class="expand" for="c-37097538">[1 more]</label></div><br/><div class="children"><div class="content">The work around is that I stash after commit and then test the newly made patch before pushing to the repo.<p>That describes git in a nutshell. It lives up to its name by providing stupid roundabout ways to get things done, but otherwise mostly doesn’t get in your way. Pijul is in theory better, but GitHub prevents any competition from being serious.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37095891" class="c"><input type="checkbox" id="c-37095891" checked=""/><div class="controls bullet"><span class="by">nemetroid</span><span>|</span><a href="#37095429">prev</a><span>|</span><a href="#37096037">next</a><span>|</span><label class="collapse" for="c-37095891">[-]</label><label class="expand" for="c-37095891">[7 more]</label></div><br/><div class="children"><div class="content">I really like the idea of a version control system based on commutative patches but I&#x27;m just not seeing how it&#x27;s going to translate to a system that&#x27;s intuitive and easy to use not just for programmers, but also for lawyers and artists.<p>Consider a patch like this one, titled &quot;Solving conflicts&quot;:<p><a href="https:&#x2F;&#x2F;nest.pijul.com&#x2F;pijul&#x2F;pijul&#x2F;changes&#x2F;2MLOE3FPVT4ZXC4L74VC7GV2IXATZQNFLJECDPZZ7MTSW4A6XT5QC" rel="nofollow noreferrer">https:&#x2F;&#x2F;nest.pijul.com&#x2F;pijul&#x2F;pijul&#x2F;changes&#x2F;2MLOE3FPVT4ZXC4L7...</a><p>&quot;Solving an order conflict&quot; and &quot;Resurrecting zombie bytes&quot; sound like the tricky parts of the patch-based workflow. I would very much like to understand how to work with these parts of Pijul. How are these actions performed? How does the user interact with the graph to perform these actions? Is the conflict state rendered into the file? It&#x27;s not mentioned in the video, and I cannot find it in the documentation or in blog posts.<p>I cannot be the only one that&#x27;s interested in learning about those things, and I think it would be more effective than anything else in raising interest for Pijul.<p>My best guess is that the workflow is still rough around the edges and requires the user to have a good understanding of the underlying graph, and therefore it&#x27;s not ready to be presented yet. And my hot take is that it&#x27;s still rough around the edges because there is no easy way, and maybe no way at all, to make it polished and intuitive for a new user. But I want to be proven wrong.</div><br/><div id="37096156" class="c"><input type="checkbox" id="c-37096156" checked=""/><div class="controls bullet"><span class="by">kadoban</span><span>|</span><a href="#37095891">parent</a><span>|</span><a href="#37096148">next</a><span>|</span><label class="collapse" for="c-37096156">[-]</label><label class="expand" for="c-37096156">[5 more]</label></div><br/><div class="children"><div class="content">Is git conflict resolution &quot;intuitive and easy to use not just for programmers, but also for lawyers and artists&quot;? Several programmers I know can barely manage it. I think we might be setting our bar a little high here.</div><br/><div id="37096175" class="c"><input type="checkbox" id="c-37096175" checked=""/><div class="controls bullet"><span class="by">jsunderland323</span><span>|</span><a href="#37095891">root</a><span>|</span><a href="#37096156">parent</a><span>|</span><a href="#37096148">next</a><span>|</span><label class="collapse" for="c-37096175">[-]</label><label class="expand" for="c-37096175">[4 more]</label></div><br/><div class="children"><div class="content">Yes. That’s the whole problem. If you don’t crack that it’s useless</div><br/><div id="37096653" class="c"><input type="checkbox" id="c-37096653" checked=""/><div class="controls bullet"><span class="by">kadoban</span><span>|</span><a href="#37095891">root</a><span>|</span><a href="#37096175">parent</a><span>|</span><a href="#37096148">next</a><span>|</span><label class="collapse" for="c-37096653">[-]</label><label class="expand" for="c-37096653">[3 more]</label></div><br/><div class="children"><div class="content">Hmm, that doesn&#x27;t really seem fair. That&#x27;s _a_ problem, and an incredibly difficult one.<p>There are several other problems though, with git and other contemporaries that one could try to usefully solve.</div><br/><div id="37096678" class="c"><input type="checkbox" id="c-37096678" checked=""/><div class="controls bullet"><span class="by">jsunderland323</span><span>|</span><a href="#37095891">root</a><span>|</span><a href="#37096653">parent</a><span>|</span><a href="#37096148">next</a><span>|</span><label class="collapse" for="c-37096678">[-]</label><label class="expand" for="c-37096678">[2 more]</label></div><br/><div class="children"><div class="content">Sorry, I was replying in the context of GP’s original comment with regards to general accessibility. Agreed git has a lot of other problems.</div><br/><div id="37097189" class="c"><input type="checkbox" id="c-37097189" checked=""/><div class="controls bullet"><span class="by">kadoban</span><span>|</span><a href="#37095891">root</a><span>|</span><a href="#37096678">parent</a><span>|</span><a href="#37096148">next</a><span>|</span><label class="collapse" for="c-37097189">[-]</label><label class="expand" for="c-37097189">[1 more]</label></div><br/><div class="children"><div class="content">Ah, fair. Sorry, I bet I missed the context.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37096148" class="c"><input type="checkbox" id="c-37096148" checked=""/><div class="controls bullet"><span class="by">jsunderland323</span><span>|</span><a href="#37095891">parent</a><span>|</span><a href="#37096156">prev</a><span>|</span><a href="#37096037">next</a><span>|</span><label class="collapse" for="c-37096148">[-]</label><label class="expand" for="c-37096148">[1 more]</label></div><br/><div class="children"><div class="content">I’d be happy to demo a work in progress if you want to see a structured dvcs. This is a surprisingly tricky problem. There’ve been quite a few attempts throughout the years at a structured&#x2F;visual dcvs but it’s almost impossible to solve without also building a schema language, an offline browser, and a package manager&#x2F;app registry. There’s murmurs in some of the offline first&#x2F;CRDT communities that suggest other solutions but I haven’t seen anything structured and viable emerge. Anyway, let me know if you want to chat. I’ll put my email in my bio</div><br/></div></div></div></div><div id="37096037" class="c"><input type="checkbox" id="c-37096037" checked=""/><div class="controls bullet"><span class="by">mk12</span><span>|</span><a href="#37095891">prev</a><span>|</span><a href="#37095591">next</a><span>|</span><label class="collapse" for="c-37096037">[-]</label><label class="expand" for="c-37096037">[1 more]</label></div><br/><div class="children"><div class="content">I recently found out about another project called jj: <a href="https:&#x2F;&#x2F;github.com&#x2F;martinvonz&#x2F;jj">https:&#x2F;&#x2F;github.com&#x2F;martinvonz&#x2F;jj</a>. It takes inspiration from Pijul and others but is git-compatible.</div><br/></div></div><div id="37095591" class="c"><input type="checkbox" id="c-37095591" checked=""/><div class="controls bullet"><span class="by">MattyRad</span><span>|</span><a href="#37096037">prev</a><span>|</span><a href="#37096467">next</a><span>|</span><label class="collapse" for="c-37095591">[-]</label><label class="expand" for="c-37095591">[4 more]</label></div><br/><div class="children"><div class="content">That was very in depth! As far as Pijul as a tool goes, I&#x27;m not seeing a git compatibility layer? So I think it&#x27;s a neat project, but I probably won&#x27;t try it because nearly all code is rooted squarely in git. Even if Pijul is perfect, you&#x27;d need to convince everyone else to use it.<p>Nevertheless, the increased interest in moving to patch based workflows from branch based ones is great. There&#x27;s a lot of similar tools here (<a href="https:&#x2F;&#x2F;github.com&#x2F;gitext-rs&#x2F;git-stack&#x2F;blob&#x2F;main&#x2F;docs&#x2F;comparison.md">https:&#x2F;&#x2F;github.com&#x2F;gitext-rs&#x2F;git-stack&#x2F;blob&#x2F;main&#x2F;docs&#x2F;compar...</a>)  which I refer to infrequently.<p>Personally my favorite tool for living-with-the-reality-that-is-branches is git-machete (<a href="https:&#x2F;&#x2F;github.com&#x2F;VirtusLab&#x2F;git-machete">https:&#x2F;&#x2F;github.com&#x2F;VirtusLab&#x2F;git-machete</a>).</div><br/><div id="37096462" class="c"><input type="checkbox" id="c-37096462" checked=""/><div class="controls bullet"><span class="by">aozgaa</span><span>|</span><a href="#37095591">parent</a><span>|</span><a href="#37096832">next</a><span>|</span><label class="collapse" for="c-37096462">[-]</label><label class="expand" for="c-37096462">[1 more]</label></div><br/><div class="children"><div class="content">See “Import a Git Repository” at <a href="https:&#x2F;&#x2F;nest.pijul.com&#x2F;pijul&#x2F;pijul" rel="nofollow noreferrer">https:&#x2F;&#x2F;nest.pijul.com&#x2F;pijul&#x2F;pijul</a></div><br/></div></div><div id="37096832" class="c"><input type="checkbox" id="c-37096832" checked=""/><div class="controls bullet"><span class="by">Tempest1981</span><span>|</span><a href="#37095591">parent</a><span>|</span><a href="#37096462">prev</a><span>|</span><a href="#37096467">next</a><span>|</span><label class="collapse" for="c-37096832">[-]</label><label class="expand" for="c-37096832">[2 more]</label></div><br/><div class="children"><div class="content">Looks cool -- What does machete do when it hits a merge conflict that requires manual resolution?</div><br/><div id="37097335" class="c"><input type="checkbox" id="c-37097335" checked=""/><div class="controls bullet"><span class="by">_ikke_</span><span>|</span><a href="#37095591">root</a><span>|</span><a href="#37096832">parent</a><span>|</span><a href="#37096467">next</a><span>|</span><label class="collapse" for="c-37097335">[-]</label><label class="expand" for="c-37097335">[1 more]</label></div><br/><div class="children"><div class="content">It stops and asks you to resolve it and then you&#x27;d use the regular git commands to continue that operation (like git rebase --continue)</div><br/></div></div></div></div></div></div><div id="37096467" class="c"><input type="checkbox" id="c-37096467" checked=""/><div class="controls bullet"><span class="by">vhodges</span><span>|</span><a href="#37095591">prev</a><span>|</span><a href="#37095221">next</a><span>|</span><label class="collapse" for="c-37096467">[-]</label><label class="expand" for="c-37096467">[1 more]</label></div><br/><div class="children"><div class="content">On the theory of patches I found this set of posts helpful: <a href="https:&#x2F;&#x2F;jneem.github.io&#x2F;merging&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;jneem.github.io&#x2F;merging&#x2F;</a><p>TIL from the first 10 minutes (I didn&#x27;t have time to watch the whole thing):  I&#x27;ve been mis-pronouncing the name of pijul :)</div><br/></div></div><div id="37095221" class="c"><input type="checkbox" id="c-37095221" checked=""/><div class="controls bullet"><span class="by">tiberriver256</span><span>|</span><a href="#37096467">prev</a><span>|</span><a href="#37097289">next</a><span>|</span><label class="collapse" for="c-37095221">[-]</label><label class="expand" for="c-37095221">[2 more]</label></div><br/><div class="children"><div class="content">This is supposed to be easier to use than git but the getting started guide is mostly mathematic algorithms.<p>I think maybe they need someone to help write some user friendly documentation.</div><br/><div id="37095236" class="c"><input type="checkbox" id="c-37095236" checked=""/><div class="controls bullet"><span class="by">dharmab</span><span>|</span><a href="#37095221">parent</a><span>|</span><a href="#37097289">next</a><span>|</span><label class="collapse" for="c-37095236">[-]</label><label class="expand" for="c-37095236">[1 more]</label></div><br/><div class="children"><div class="content">Which page are you looking at? <a href="https:&#x2F;&#x2F;pijul.org&#x2F;manual&#x2F;getting_started.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;pijul.org&#x2F;manual&#x2F;getting_started.html</a> is mostly some shell commands, similar to a Git beginner&#x27;s guide.</div><br/></div></div></div></div><div id="37097289" class="c"><input type="checkbox" id="c-37097289" checked=""/><div class="controls bullet"><span class="by">beefman</span><span>|</span><a href="#37095221">prev</a><span>|</span><a href="#37097464">next</a><span>|</span><label class="collapse" for="c-37097289">[-]</label><label class="expand" for="c-37097289">[2 more]</label></div><br/><div class="children"><div class="content">This product was announced at the end of the talk: <a href="https:&#x2F;&#x2F;nest.pijul.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;nest.pijul.org&#x2F;</a></div><br/><div id="37098303" class="c"><input type="checkbox" id="c-37098303" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#37097289">parent</a><span>|</span><a href="#37097464">next</a><span>|</span><label class="collapse" for="c-37098303">[-]</label><label class="expand" for="c-37098303">[1 more]</label></div><br/><div class="children"><div class="content">The nest has been around for some 5-ish years. Has anything changed?</div><br/></div></div></div></div><div id="37097464" class="c"><input type="checkbox" id="c-37097464" checked=""/><div class="controls bullet"><span class="by">Nathanba</span><span>|</span><a href="#37097289">prev</a><span>|</span><a href="#37096066">next</a><span>|</span><label class="collapse" for="c-37097464">[-]</label><label class="expand" for="c-37097464">[1 more]</label></div><br/><div class="children"><div class="content">The problem with pijul is that the command line interface is not really better than what git has. I tried pijul several times over the years and last month I couldn&#x27;t even figure out how to make a commit and push it. I think it should be far more intuitive.</div><br/></div></div><div id="37096066" class="c"><input type="checkbox" id="c-37096066" checked=""/><div class="controls bullet"><span class="by">TheAceOfHearts</span><span>|</span><a href="#37097464">prev</a><span>|</span><a href="#37095303">next</a><span>|</span><label class="collapse" for="c-37096066">[-]</label><label class="expand" for="c-37096066">[1 more]</label></div><br/><div class="children"><div class="content">To the author: you should include a parragraph on the repo README explaining how pijul compares to git.<p>Learning git kinda sucks, but once you learn it there&#x27;s very little incentive to invest time in learning other version control tools. The extra features rarely justify the additional effort. Like I thought Fossil was kinda neat, but I still stuck with git.</div><br/></div></div><div id="37095303" class="c"><input type="checkbox" id="c-37095303" checked=""/><div class="controls bullet"><span class="by">est31</span><span>|</span><a href="#37096066">prev</a><span>|</span><a href="#37095237">next</a><span>|</span><label class="collapse" for="c-37095303">[-]</label><label class="expand" for="c-37095303">[6 more]</label></div><br/><div class="children"><div class="content">See also: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25032956">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25032956</a><p>Pijul is definitely a nice research project, and maybe some of the technology behind it could be integrated into better git tooling. But I doubt that exposing users to the raw &quot;everything is just a bucket of patches, you have no history of repo state&quot; idea is good. People want to be able to bisect, or check out some older version at a given time point. There are benefits of pijul&#x27;s model, but I don&#x27;t think they are worth as much as losing that.</div><br/><div id="37095781" class="c"><input type="checkbox" id="c-37095781" checked=""/><div class="controls bullet"><span class="by">h0l0cube</span><span>|</span><a href="#37095303">parent</a><span>|</span><a href="#37095434">next</a><span>|</span><label class="collapse" for="c-37095781">[-]</label><label class="expand" for="c-37095781">[3 more]</label></div><br/><div class="children"><div class="content">&quot;bucket of patches&quot; doesn&#x27;t imply the patches couldn&#x27;t be replayed to a point in time.  Looking at the docs, you could probably use `log` and `unrecord` to go back to an earlier state.  Or use `change` to view a particular change.<p><a href="https:&#x2F;&#x2F;pijul.org&#x2F;manual&#x2F;reference.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;pijul.org&#x2F;manual&#x2F;reference.html</a></div><br/><div id="37096210" class="c"><input type="checkbox" id="c-37096210" checked=""/><div class="controls bullet"><span class="by">est31</span><span>|</span><a href="#37095303">root</a><span>|</span><a href="#37095781">parent</a><span>|</span><a href="#37095434">next</a><span>|</span><label class="collapse" for="c-37096210">[-]</label><label class="expand" for="c-37096210">[2 more]</label></div><br/><div class="children"><div class="content">The issue is that `log` orders the patches by when they were made, not by when they were merged (in reality it might be a bit more detailed, probably a patch will always be ordered after the patches it depends on).<p>git log also has parameters to configure it in that fashion, and it&#x27;s also what github uses. However, importantly, git bisect does not use it. It uses the DAG of commits that git maintains.<p>Yes, also git also only has a weak notion of a history of a branch: it is somewhat inside the titles of merge commits, and merge commits also have an order of their parents, so often you can just walk the first parent and always get to commits that used to be state of the master branch at a specific point in time. Sometimes it&#x27;s even easier when merged PRs get squashed. But yeah, it&#x27;s a bit implicit and if you e.g. rebase a PR then some of the commits in it have never been the tip of the master branch.<p>But very importantly, every commit in git depends on every single commit that has contributed to that commit&#x27;s tree.<p>In pijul, they break up that property, and patches only depend on those patches which have directly modified the pieces of code that the change is editing. IIRC you can also manually introduce dependencies but those are rare. There isn&#x27;t even a notion of a &quot;patch&#x27;s tree&quot;. You could construct a branch with only the patch and its dependencies but probably that wouldn&#x27;t compile, and it will definitely not reflect the state of the branch at that point in time.<p>You can make new branches in pijul that you don&#x27;t modify and use like tags, but it is an explicitly requested thing.<p>I mean, I see the elegance in pijul. Reverting a patch that has no conflicts and un-reverting it is trivial. But on the other hand, how often do you do that?<p>Some workflows need patch based thinking, others need snapshot based thinking, and VCS tools need to master both, whether they start out with a snapshot history (like git) and then build diff based workflows on it (diff, rebase, etc), or whether they start out with a patch tree, and then build snapshot based workflows on it. pijul has weak snapshot based workflows, this part is still missing.</div><br/><div id="37097909" class="c"><input type="checkbox" id="c-37097909" checked=""/><div class="controls bullet"><span class="by">h0l0cube</span><span>|</span><a href="#37095303">root</a><span>|</span><a href="#37096210">parent</a><span>|</span><a href="#37095434">next</a><span>|</span><label class="collapse" for="c-37097909">[-]</label><label class="expand" for="c-37097909">[1 more]</label></div><br/><div class="children"><div class="content">The use cases define whether pijul is sufficient for your needs. For bisecting to find a bug, it seems you could easily bisect along a history of patches. Maybe there are patches that may alter the history that haven’t yet been merged, but that’s really an agreement between you and your collaborators that they should commit often. A similar constraint is required if you need to tag a commit for a release (where a snapshot can have  meaningful implications for legal compliance, reproducible builds etc.)</div><br/></div></div></div></div></div></div><div id="37095503" class="c"><input type="checkbox" id="c-37095503" checked=""/><div class="controls bullet"><span class="by">pkulak</span><span>|</span><a href="#37095303">parent</a><span>|</span><a href="#37095434">prev</a><span>|</span><a href="#37095237">next</a><span>|</span><label class="collapse" for="c-37095503">[-]</label><label class="expand" for="c-37095503">[1 more]</label></div><br/><div class="children"><div class="content">Wait, you can&#x27;t see the state of the repository at an arbitrary point in time?</div><br/></div></div></div></div><div id="37095237" class="c"><input type="checkbox" id="c-37095237" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#37095303">prev</a><span>|</span><a href="#37095838">next</a><span>|</span><label class="collapse" for="c-37095237">[-]</label><label class="expand" for="c-37095237">[2 more]</label></div><br/><div class="children"><div class="content">Needs [video] in the title!</div><br/><div id="37096905" class="c"><input type="checkbox" id="c-37096905" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#37095237">parent</a><span>|</span><a href="#37095838">next</a><span>|</span><label class="collapse" for="c-37096905">[-]</label><label class="expand" for="c-37096905">[1 more]</label></div><br/><div class="children"><div class="content">It says &quot;youtube.com&quot; on the side of the title.  The main content type at YouTube is video content.  It&#x27;s clear enough.</div><br/></div></div></div></div><div id="37095838" class="c"><input type="checkbox" id="c-37095838" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#37095237">prev</a><span>|</span><a href="#37096033">next</a><span>|</span><label class="collapse" for="c-37095838">[-]</label><label class="expand" for="c-37095838">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t buy (as sold) the argument that we need associative and commutative merges, and I believe that this constraint when applied by the software makes resolving merge requirements harder on the user, rather than easier. It&#x27;s punting the slightly more solved part of the problem back on the user, when it&#x27;s one of the least favorite parts of the problem for the user.<p>The solution that he writes up is basically &quot;git merge&quot; and part of the reason that we have such a bad time with git is that the industry largely standardized on &quot;git rebase&quot;, which destroys many of the properties listed:<p>changes are partially ordered: if you merge, this is true, if you rebase, this is not, your change is strictly reodered atop the merge base, and you dear user are responsible for the hell of fixing the constant conflict this produces, even if an alternative merge order would implicitly fix this. when pijul says &quot;partial ordering&quot; here, it means (in slightly abstract and minutely different terms) it&#x27;s doing what git merge does, because it&#x27;s better. As it happens one of the various reasons rebase became popular was that `git log` order shifts around for efficiency and correctness reasons, when people mostly want the output of `git log --topo-order` by default, which for the common case of &quot;merge right onto left&quot; presents &quot;right first, then left&quot; in linearized history, unless there&#x27;s a content defined order. Pijul dodges the presentation problem by just not presenting this information at all. Git&#x27;s mistake was in many ways not hiding enough from users - but it came from kernel engineers, who don&#x27;t want things being hidden.<p>No git rerere: rerere is a hack to try to make rebase pretend that it doesn&#x27;t drop usable merge information on the floor, if you stop imposing rebase on yourself you don&#x27;t need the rerere hack.<p>Partial clones &amp; large files: these are storage structure optimizations, and yes, a problem for git, though for example git lfs approach is similar in solution to the described pijul solution: &quot;we only need a description of operations&quot; - that&#x27;s how you would describe lfs changes. As it happens, that&#x27;s also how you would describe subproject updates, and yes, sure subproject UX isn&#x27;t great, but now we&#x27;re back to a UX problem, not a storage problem.<p>Working with large graphs: cache snapshots and index deltas, um, yeah. You don&#x27;t have to squint very hard to draw equivalence here either.<p>I&#x27;m not apologizing for git, but there&#x27;s a lot of &quot;here&#x27;s some non-ascii literals on a slide, it&#x27;s science&quot; presented, but not actually a very substantial shift in trade-offs when applied in practice. There are some pathologies improved, and some worsened, and there are some more onus put on the user for some cases, and some removed for other cases. It&#x27;s a very different (at the minute level) structure, sure, but I&#x27;ve not been sold that it makes a set of trade-offs that substantially change the game, it&#x27;s just the other side of the field, not all that dissimilar from choosing between two different database engines.<p>An example of it not being that different in practice: can you conflict with yourself in pijul? Absolutely, and you end up with the pijul version of merge commits, e.g. <a href="https:&#x2F;&#x2F;nest.pijul.com&#x2F;pijul&#x2F;thrussh&#x2F;changes&#x2F;7S7FHFDVSSRB4DCBZINHNWM3QJS6KYAR2L2HADDBDN4IHKN6KGLAC" rel="nofollow noreferrer">https:&#x2F;&#x2F;nest.pijul.com&#x2F;pijul&#x2F;thrussh&#x2F;changes&#x2F;7S7FHFDVSSRB4DC...</a>, more than that you can conflict with yourself multiple times (which is basically the rerere problem but actually distributed, which was somewhat erroneously claimed to be eradicated). It hasn&#x27;t substantially moved the needle on merging history quality _in practice_. The manual is very incomplete on this, i.e. <a href="https:&#x2F;&#x2F;pijul.org&#x2F;manual&#x2F;conflicts.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;pijul.org&#x2F;manual&#x2F;conflicts.html</a> and there are some nascent but very slow tools to unhide the totality of conflicts in a repo <a href="https:&#x2F;&#x2F;nest.pijul.com&#x2F;laumann&#x2F;pijul-conflicts" rel="nofollow noreferrer">https:&#x2F;&#x2F;nest.pijul.com&#x2F;laumann&#x2F;pijul-conflicts</a> which would bring the rerereal problem (couldn&#x27;t resist, sorry) into the light.<p>What&#x27;s the largest team concurrently working on one project full time using pijul today? I ask because small numbers of users don&#x27;t create many interesting conflicts often, and don&#x27;t provide a good insight for the properties of a VCS at scale&#x2F;in practice. You can use CVS with zero problems when you&#x27;re on your own. There&#x27;s an embedded theory which is that you can do very lazy conflict resolution requirement and that it&#x27;ll pay off. I&#x27;d like to see that theory tested at scale.</div><br/><div id="37096944" class="c"><input type="checkbox" id="c-37096944" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#37095838">parent</a><span>|</span><a href="#37096033">next</a><span>|</span><label class="collapse" for="c-37096944">[-]</label><label class="expand" for="c-37096944">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really buy the commutative patch thing either (yet!), but I&#x27;m willing to believe that it&#x27;s because I&#x27;m so happy to `git rebase` all the time, but also because I have a tool for fast rebasing across many commits[0].<p>&gt; The solution that he writes up is basically &quot;git merge&quot; and part of the reason that we have such a bad time with git is that the industry largely standardized on &quot;git rebase&quot;, [...]<p>I wish.  So many people still use `git merge` workflows!<p>&gt; No git rerere: rerere is a hack to try to make rebase pretend that it doesn&#x27;t drop usable merge information on the floor, if you stop imposing rebase on yourself you don&#x27;t need the rerere hack.<p>Whether you cherry-pick (rebase) or merge, you still only commit the conflict-resolved state.  Merge commits document what were the two HEADs you conflict-resolved, but so what, if you lose the merge commits at upstream integration time no one loses anything useful.<p>I&#x27;ve worked on very large systems using rebase workflows.  I have written about that many times here on HN in the comments.  Rebase workflows are definitely far better than merge workflows.<p>Perhaps the Jujutsu approach to rebase (automate it!) is the right solution for all those who can&#x27;t stand rebasing.<p>[0] <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;nicowilliams&#x2F;ea2fa2b445c2db50d2ee6509c3526297" rel="nofollow noreferrer">https:&#x2F;&#x2F;gist.github.com&#x2F;nicowilliams&#x2F;ea2fa2b445c2db50d2ee650...</a></div><br/></div></div></div></div><div id="37096033" class="c"><input type="checkbox" id="c-37096033" checked=""/><div class="controls bullet"><span class="by">jensenbox</span><span>|</span><a href="#37095838">prev</a><span>|</span><a href="#37096728">next</a><span>|</span><label class="collapse" for="c-37096033">[-]</label><label class="expand" for="c-37096033">[3 more]</label></div><br/><div class="children"><div class="content">Is there a pronunciation key for the name?</div><br/><div id="37098340" class="c"><input type="checkbox" id="c-37098340" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#37096033">parent</a><span>|</span><a href="#37096865">next</a><span>|</span><label class="collapse" for="c-37098340">[-]</label><label class="expand" for="c-37098340">[1 more]</label></div><br/><div class="children"><div class="content">Pijul is an actual species of bird, so I presume the way the bird is called?</div><br/></div></div><div id="37096865" class="c"><input type="checkbox" id="c-37096865" checked=""/><div class="controls bullet"><span class="by">joedrago</span><span>|</span><a href="#37096033">parent</a><span>|</span><a href="#37098340">prev</a><span>|</span><a href="#37096728">next</a><span>|</span><label class="collapse" for="c-37096865">[-]</label><label class="expand" for="c-37096865">[1 more]</label></div><br/><div class="children"><div class="content">This appears to be from the official devs on Twitter (and corresponds with how the speaker in this video says it):<p><a href="https:&#x2F;&#x2F;twitter.com&#x2F;pijul_org&#x2F;status&#x2F;764116443550117889" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;pijul_org&#x2F;status&#x2F;764116443550117889</a></div><br/></div></div></div></div><div id="37096728" class="c"><input type="checkbox" id="c-37096728" checked=""/><div class="controls bullet"><span class="by">commandersaki</span><span>|</span><a href="#37096033">prev</a><span>|</span><label class="collapse" for="c-37096728">[-]</label><label class="expand" for="c-37096728">[1 more]</label></div><br/><div class="children"><div class="content">Sounds elegant, lacks critical mass.</div><br/></div></div></div></div></div></div></div></body></html>