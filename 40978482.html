<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721206870077" as="style"/><link rel="stylesheet" href="styles.css?v=1721206870077"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://www.righto.com/2024/07/ibm-3274-keystone-chip.html">Inside an IBM/Motorola mainframe controller chip from 1981</a> <span class="domain">(<a href="http://www.righto.com">www.righto.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>71 comments</span></div><br/><div><div id="40983687" class="c"><input type="checkbox" id="c-40983687" checked=""/><div class="controls bullet"><span class="by">Steve44</span><span>|</span><a href="#40979048">next</a><span>|</span><label class="collapse" for="c-40983687">[-]</label><label class="expand" for="c-40983687">[1 more]</label></div><br/><div class="children"><div class="content">Slightly off topic and not sure if this is allowed but I&#x27;ve a copy of MVS JCL by Doug Lowe and rather than dump it I&#x27;d be more than happy to send it free of charge to anyone in the UK.<p>It&#x27;s in excellent condition other than a bit of staining on the outer rear cover<p><a href="https:&#x2F;&#x2F;www.amazon.co.uk&#x2F;MVS-JCL-370-XA-JES&#x2F;dp&#x2F;0911625852" rel="nofollow">https:&#x2F;&#x2F;www.amazon.co.uk&#x2F;MVS-JCL-370-XA-JES&#x2F;dp&#x2F;0911625852</a><p>I worked with them for a year or so at an insurance company and particularly liked some of the feature of the ISPF editor.  You could hide rows then perform actions on the remaining columns, quirky but very handy when you needed it!</div><br/></div></div><div id="40979048" class="c"><input type="checkbox" id="c-40979048" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#40983687">prev</a><span>|</span><a href="#40980503">next</a><span>|</span><label class="collapse" for="c-40979048">[-]</label><label class="expand" for="c-40979048">[25 more]</label></div><br/><div class="children"><div class="content">I was lucky to get to use an IBM 3090 (close to the peak of the bipolar mainframe) with the Computer Explorers troop that met at New Hampshire Insurance.<p>We used VM&#x2F;CMS where VM was a virtual machine monitor and CMS was a single-user OS that felt a lot like CP&#x2F;M or MS-DOS.  (I understand CP&#x2F;M was inspired by CMS)  If you have a lot of developers,  they all get their own OS and normally they would store their files on &quot;minidisc&quot; images.<p>Even though the experience wouldn&#x27;t seem too foreign to somebody who works on the command line today, the I&#x2F;O was not character based but instead buffered the way the article describes.  Applications were built around a model where you program fields on the terminal which get submitted when somebody hits the send button such as the XEDIT text editor<p><a href="https:&#x2F;&#x2F;www.ibm.com&#x2F;docs&#x2F;en&#x2F;zvm&#x2F;7.3?topic=zvm-cms-file-editor-xedit" rel="nofollow">https:&#x2F;&#x2F;www.ibm.com&#x2F;docs&#x2F;en&#x2F;zvm&#x2F;7.3?topic=zvm-cms-file-edito...</a><p>which was functionally similar to the TECO editor you&#x27;d see on DEC minicomputers but quite different in implementation.  (e.g. 1970&#x27;s mainframe apps were similar to 1990&#x27;s web form applications)<p>Since we had Digital right across the border in Massachusetts,  schools and children&#x27;s museums in my area where saturated with PDP-8, PDP-11 and VAX machines.  The computer club (which met at the physics clasroom) at my high school inherited an old PDP-8 when the school got a VAX,  it was an unusual system that they were planning to ship to a newspaper that didn&#x27;t buy it in the end which had terminals that used an ordinary serial connection but could be programmed to behave like the 3270,  we didn&#x27;t have any software that used that feature until I got out the manuals and wrote a BASIC program that would send the control sequences for that mode.</div><br/><div id="40980333" class="c"><input type="checkbox" id="c-40980333" checked=""/><div class="controls bullet"><span class="by">nsguy</span><span>|</span><a href="#40979048">parent</a><span>|</span><a href="#40979691">next</a><span>|</span><label class="collapse" for="c-40980333">[-]</label><label class="expand" for="c-40980333">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used a 3090 and some of the predecessors and VM&#x2F;CMS. The &quot;monitor&quot; was called CP (control program) IIRC.<p>XEDIT was a great editor. There was also Rexx (and previously EXEC and EXEC&#x2F;2) as the system&#x27;s programming language that you could use to customize virtually every aspect of the editor and automated tasks. Rexx had integration with the editor and also integrated with the OS there were lots of these small integration points that let you do really powerful stuff. Applications like email were implemented on top of the basic OS and editor. A very unique and powerful architecture (mirrored to some degree in OS&#x2F;2 later).<p>The ecosystem was incredible. The virtualization support in the CPU let you run a complete multi-user system with each user having a visualized CPU within one virtual CPU. I.e. it was &quot;fully&quot; virtualized. What&#x27;s more incredible is that a lot of these pieces, like the OS, were all written in assembly. Super robust. Super clean. Amazing documentation for everything. As top notch engineering as it gets.<p>The full screen terminal (e.g. 327X) were part of the architecture, delegating a lot of the interaction to the terminal. Interesting enough you could poll the terminals for input which we&#x27;ve used for writing some games. A friend of mine wrote a library for doing that. There were also colour&#x2F;graphics terminals like the 3279 and could be programmed e.g. with a library called GDDM.<p>EDIT:
- <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;VM_(operating_system)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;VM_(operating_system)</a><p>Another interesting bit is that IBM shipped the full source code for everything (I think this was by default). They also had a shared bug reporting system (anyone remember what that was called?).</div><br/><div id="40980489" class="c"><input type="checkbox" id="c-40980489" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40980333">parent</a><span>|</span><a href="#40979691">next</a><span>|</span><label class="collapse" for="c-40980489">[-]</label><label class="expand" for="c-40980489">[1 more]</label></div><br/><div class="children"><div class="content">Right.  It was really common for sites in the 1970s to compile their own OS so they could set the configuration.  This was how you told it which devices where attached on which ports.</div><br/></div></div></div></div><div id="40979691" class="c"><input type="checkbox" id="c-40979691" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#40979048">parent</a><span>|</span><a href="#40980333">prev</a><span>|</span><a href="#40980503">next</a><span>|</span><label class="collapse" for="c-40979691">[-]</label><label class="expand" for="c-40979691">[22 more]</label></div><br/><div class="children"><div class="content">If you want unfamiliar, try MVS on IBM s&#x2F;370 mainframes. Version 3.8j (from the early 80s) is readily available, and runs great on the Hercules emulator: <a href="https:&#x2F;&#x2F;www.jaymoseley.com&#x2F;hercules&#x2F;installMVS&#x2F;iMVSintroV8.htm" rel="nofollow">https:&#x2F;&#x2F;www.jaymoseley.com&#x2F;hercules&#x2F;installMVS&#x2F;iMVSintroV8.h...</a><p>It made me realize just how many fundamental things that I completely took for granted in the &quot;modern&quot; computing world, were ultimately just concepts derived from UNIX (even for OSes that you&#x27;d think have little relation to it at all), and how there were (and in some capacity still are) very, very different worlds out there.</div><br/><div id="40979809" class="c"><input type="checkbox" id="c-40979809" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40979691">parent</a><span>|</span><a href="#40979742">next</a><span>|</span><label class="collapse" for="c-40979809">[-]</label><label class="expand" for="c-40979809">[11 more]</label></div><br/><div class="children"><div class="content">Yes, looking at IBM stuff is like being in a parallel universe where everything you take for granted is slightly off. You have token-ring instead of Ethernet, you have SNA (or something) instead of TCP&#x2F;IP. Characters are EBCDIC, not ASCII. Terminals are connected with coax, not RS-232. For hardware, chips are packaged in metal instead of plastic. Circuit boards are a weird grid. Even the terminology and schematic symbols are different: if it looks like an AND gate, it&#x27;s an OR gate.</div><br/><div id="40980283" class="c"><input type="checkbox" id="c-40980283" checked=""/><div class="controls bullet"><span class="by">axiolite</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40979809">parent</a><span>|</span><a href="#40979896">next</a><span>|</span><label class="collapse" for="c-40980283">[-]</label><label class="expand" for="c-40980283">[3 more]</label></div><br/><div class="children"><div class="content">Ethernet (OSA cards) and Fibre Channel (FICON cards) are standard on z Mainframes these days.  TCP&#x2F;IP is standard on z&#x2F;OS, CP (z&#x2F;VM), AIX and Linux.  Terminal emulators connect over TCP&#x2F;IP, not RS-232 or coax. etc.<p>But still today:<p>- The character set for most OSes (not Linux) is EBCDIC.<p>- The terminal is form-based (like a web page, but with invisible input fields) rather than character based.<p>- You ALWAYS have to have key punch and card reader devices defined (even on Linux).<p>- z&#x2F;OS needs proprietary FICON (not plain fibre channel) connections to emulated ECKD disks (not block based) on one of just a few SANs that support it.<p>- VSE still needs a TCP&#x2F;IP stack (one of two 3rd party vendors) purchased separately.<p>- You need several x86 computers (HMC and two support elements) to manage or even boot-up a mainframe.<p>- You have to painstakingly configure virtual to physical device address mappings (IOCDS) before you can boot-up anything.<p>And more.</div><br/><div id="40980510" class="c"><input type="checkbox" id="c-40980510" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40980283">parent</a><span>|</span><a href="#40979896">next</a><span>|</span><label class="collapse" for="c-40980510">[-]</label><label class="expand" for="c-40980510">[2 more]</label></div><br/><div class="children"><div class="content">&gt; - You ALWAYS have to have key punch and card reader devices defined (even on Linux).<p>Linux doesn’t actually support <i>physical</i> card readers&#x2F;punches, only paravirtualized readers&#x2F;punches under z&#x2F;VM (implemented using DIAG hypervisor call interface). [0] And that’s because paravirtualized card devices are heavily used under z&#x2F;VM for IPC (inter-VM communication), although there are alternatives (IUCV, TCP&#x2F;IP). So if you aren’t running under z&#x2F;VM, Linux can’t use readers&#x2F;punches, because the hypervisor interface isn’t there. And even under z&#x2F;VM, Linux will work fine without them, because they are mainly used for sending data between Linux and other mainframe operating systems such as CMS and RSCS, and maybe you aren’t interested in that. And if somehow you managed to connect a real card reader or punch to your mainframe (you’d need to chain together a bus&#x2F;tag to ESCON bridge with an ESCON to FICON bridge), bare metal Linux would have no idea how to talk to it, because it doesn’t support real card devices, only paravirtualized ones. Linux under z&#x2F;VM <i>might</i> be able to do so, by relying on the hypervisor’s card device driver.<p>[0] Have a look at <a href="https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;blob&#x2F;v6.10&#x2F;drivers&#x2F;s390&#x2F;char&#x2F;vmur.c#L383">https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;blob&#x2F;v6.10&#x2F;drivers&#x2F;s390&#x2F;ch...</a> – if it encounters a <i>real</i> card reader&#x2F;punch, it is hardcoded to return -EOPNOTSUPP. Actually it looks like it does use CCWs to write to punches, but it relies on DIAG for reading from card readers and device discovery. And due to that code, even if it is generating the correct CCWs to write to a physical punch (I don&#x27;t know), it would refuse to do so.</div><br/><div id="40981363" class="c"><input type="checkbox" id="c-40981363" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40980510">parent</a><span>|</span><a href="#40979896">next</a><span>|</span><label class="collapse" for="c-40981363">[-]</label><label class="expand" for="c-40981363">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Linux under z&#x2F;VM might be able to do so, by relying on the hypervisor’s card device driver.<p>Actually thinking more about the code I linked, I don’t think this would work - even if the z&#x2F;VM hypervisor (CP) still knows how to talk to physical card devices (maybe the code has bitrotted, or maybe IBM has removed it as legacy cruft) - the DIAG interface would report it as a physical&#x2F;real device, and hence that Linux kernel driver would refuse to talk to it</div><br/></div></div></div></div></div></div><div id="40979896" class="c"><input type="checkbox" id="c-40979896" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40979809">parent</a><span>|</span><a href="#40980283">prev</a><span>|</span><a href="#40982980">next</a><span>|</span><label class="collapse" for="c-40979896">[-]</label><label class="expand" for="c-40979896">[5 more]</label></div><br/><div class="children"><div class="content">From the &quot;If I could&quot; files, I would have liked to spent 5 years on an AS&#x2F;400, trying to make it work for whatever company I was working for.<p>The best way to learn this stuff is simply apply it, trying to solve problems.<p>Going from a High School PET to a College CDC NOS&#x2F;VM Cyber 730 to a RSTS&#x2F;E PDP 11&#x2F;70 was very education cross section of computing that really opened my eyes. If I had gone to school only a few years later, it would have been all PCs, all the time, and I would have missed that little fascinating window.<p>But I never got to go hands on with an IBM or an AS&#x2F;400, and I think that would have been interesting before diving into the Unix world.</div><br/><div id="40979954" class="c"><input type="checkbox" id="c-40979954" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40979896">parent</a><span>|</span><a href="#40983319">next</a><span>|</span><label class="collapse" for="c-40979954">[-]</label><label class="expand" for="c-40979954">[3 more]</label></div><br/><div class="children"><div class="content">The OS for the AS&#x2F;400 is really remarkable as a &quot;path not taken&quot; by the industry and remarkably advanced.  Many of the OO architecture ideas that became popular with Java were baked into the OS<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;IBM_AS&#x2F;400" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;IBM_AS&#x2F;400</a><p>and of course it started out with a virtual machine in the late 1970s.</div><br/><div id="40981411" class="c"><input type="checkbox" id="c-40981411" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40979954">parent</a><span>|</span><a href="#40980386">next</a><span>|</span><label class="collapse" for="c-40981411">[-]</label><label class="expand" for="c-40981411">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Many of the OO architecture ideas that became popular with Java were baked into the OS<p>I disagree. OS&#x2F;400 has this weird version of “OO” in which (1) there is no inheritance (although the concept has been partially tacked on in a non-generic way by having a “subtype” attribute on certain object types), (2) the set of classes is closed and only IBM can define new ones.<p>That’s a long way from what “OO” normally means. Not bad for a system designed in the 1970s (1988’s AS&#x2F;400 was just a “version 2” of 1978’s System&#x2F;38, and a lot of this stuff was largely unchanged from its forebear.) But AS&#x2F;400 fans have this marked tendency to make the system sound more advanced and cutting-edge than it actually was. Don’t get me wrong, the use of capability-based addressing is still something that is at the research-level on mainstream architectures (see CHERI) - but the OO stuff is a lot less impressive than it sounds at first. Like someone in the 70s had a quick look at Smalltalk and came away with a rather incomplete understanding of it.<p>&gt; and of course it started out with a virtual machine in the late 1970s.<p>If you consider UCSD Pascal, BCPL Ocode - far from a unique idea in the 1970s. It is just that many of those other ideas ended up being technological dead-ends, hence many people aren’t aware of them. I suppose ultimately AS&#x2F;400 is slowly turning into a dead-end too, it has just taken a lot longer. I wouldn’t be surprised if in a few more years IBM sells off IBM i, just like they’ve done with VSE</div><br/></div></div><div id="40980386" class="c"><input type="checkbox" id="c-40980386" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40979954">parent</a><span>|</span><a href="#40981411">prev</a><span>|</span><a href="#40983319">next</a><span>|</span><label class="collapse" for="c-40980386">[-]</label><label class="expand" for="c-40980386">[1 more]</label></div><br/><div class="children"><div class="content">Yes, AS&#x2F;400 &#x2F; IBM i is the other IBM OS I like to play with (I have an actual AS&#x2F;400e at home), and in a lot of ways I consider it to be the polar opposite of MVS on the mainframe:<p>Where MVS seems to be missing very simple abstractions that I took for granted, AS&#x2F;400 abstracts <i>way more</i> than I&#x27;m used to, differently, and most importantly far away from the very, very &quot;file-centric&quot; view of today&#x27;s systems that was derived from UNIX. It indeed shows you what computing could have been, had AS&#x2F;400 been more open and had those ideas spread farther.<p>Before I got to know AS&#x2F;400, I thought UNIX was great, and that it rightfully took over computing. Now, not so much, and I&#x27;ve started to see how detrimental the &quot;everything is a file&quot; concept that UNIX brought into the world actually was to computing in general.</div><br/></div></div></div></div><div id="40983319" class="c"><input type="checkbox" id="c-40983319" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40979896">parent</a><span>|</span><a href="#40979954">prev</a><span>|</span><a href="#40982980">next</a><span>|</span><label class="collapse" for="c-40983319">[-]</label><label class="expand" for="c-40983319">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>From the &quot;If I could&quot; files, I would have liked to spent 5 years on an AS&#x2F;400,</i><p>pub400.com still exists and probably will for 5 more years.  not sure to what extent you can make it work for a company but you can at least do learning projects on it</div><br/></div></div></div></div><div id="40982980" class="c"><input type="checkbox" id="c-40982980" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40979809">parent</a><span>|</span><a href="#40979896">prev</a><span>|</span><a href="#40979742">next</a><span>|</span><label class="collapse" for="c-40982980">[-]</label><label class="expand" for="c-40982980">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d forgotten about the weird grid. Good times.</div><br/><div id="40983094" class="c"><input type="checkbox" id="c-40983094" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40982980">parent</a><span>|</span><a href="#40979742">next</a><span>|</span><label class="collapse" for="c-40983094">[-]</label><label class="expand" for="c-40983094">[1 more]</label></div><br/><div class="children"><div class="content">Probably the most expensive proto-board looking thing around.</div><br/></div></div></div></div></div></div><div id="40979742" class="c"><input type="checkbox" id="c-40979742" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40979691">parent</a><span>|</span><a href="#40979809">prev</a><span>|</span><a href="#40980503">next</a><span>|</span><label class="collapse" for="c-40979742">[-]</label><label class="expand" for="c-40979742">[10 more]</label></div><br/><div class="children"><div class="content">In the 1980s a clear case of this was that MS-DOS 2.0 had system calls for file operations that basically worked like Unix whereas MS-DOS 1&#x27;s filesystem API looked like CP&#x2F;M.<p>It&#x27;s an interesting story that IBM really struggled to develop an OS which was &quot;universal&quot; the way the &quot;360&quot; was supposed to be universal.  The answer they came to was VM which would let you run different OSes for your batch jobs, interactive sessions, transaction managers, databases, etc.  Contrast that to Unix, VAX&#x2F;VMS or Windows NT where you can run all those things under one OS.  In 1970 though, IBM had no idea how to do that.<p>Note today a Z installation is very likely to have Linux in the mix<p><a href="https:&#x2F;&#x2F;www.ibm.com&#x2F;z&#x2F;linux" rel="nofollow">https:&#x2F;&#x2F;www.ibm.com&#x2F;z&#x2F;linux</a><p>so it is no problem running your POSIX app together with traditional mainframe apps.  Also there is a Java runtime<p><a href="https:&#x2F;&#x2F;www.ibm.com&#x2F;docs&#x2F;en&#x2F;zos-basic-skills?topic=zos-java" rel="nofollow">https:&#x2F;&#x2F;www.ibm.com&#x2F;docs&#x2F;en&#x2F;zos-basic-skills?topic=zos-java</a><p>so you can host your Java apps.</div><br/><div id="40980339" class="c"><input type="checkbox" id="c-40980339" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40979742">parent</a><span>|</span><a href="#40980503">next</a><span>|</span><label class="collapse" for="c-40980339">[-]</label><label class="expand" for="c-40980339">[9 more]</label></div><br/><div class="children"><div class="content">&gt; In the 1980s a clear case of this was that MS-DOS 2.0 had system calls for file operations that basically worked like Unix whereas MS-DOS 1&#x27;s filesystem API looked like CP&#x2F;M.<p>I honestly don&#x27;t think that&#x27;s a good example. On the contrary, I think it actually obscures what I mean, and would lead the casual reader to assume that things were actually much less different than they actually were.<p>Both MS-DOS and CP&#x2F;M still had the very clear and almost identical concept of a &quot;file&quot; in the first place. I don&#x27;t know if CP&#x2F;M (and in turn CMS) was inspired by UNIX in that way, or whether the &quot;file&quot; concept came from a different common ancestor, but it&#x27;s worth repeating that MVS has more or less <i>nothing</i> like that &quot;file&quot; concept.<p>MVS had &quot;datasets&quot; and &quot;partitioned datasets&quot;, which I often see people relating to &quot;files&quot; and &quot;directories&quot; through a lens colored by today&#x27;s computing world. But if you start using it, you quickly realize that the semblance is actual pretty minimal. (If you use the 1980s MVS 3.8j, that is.)<p>Both datasets and partitioned datasets require you to do things that even the simplest of filesystems (e.g. FAT12 for MS-DOS) do on their own and completely transparently to the user (or even developer). And moreover, datasets&#x2F;members are usually (not always) organized as &quot;records&quot;, sometimes indexed, sometimes even indexed in a key-value manner. This goes so fundamentally with the system that it <i>goes down into the hardware</i>, i.e. the disk itself understands the concept of indices, record lengths and even keyed records with associated values. MS-DOS, CP&#x2F;M, and practically all modern systems, instead see &quot;files&quot; as a stream of bytes&#x2F;words&#x2F;octets or whatever.<p>A lot of this has been abstracted away and &quot;pulled&quot; into the modern and familiar &quot;file&quot; concept the closer you get to z&#x2F;OS, but that&#x27;s what MVS back then was like.<p>A C64 with its 1541 is closer to old school MVS than MS-DOS and CP&#x2F;M both are, because an 1541 supports both &quot;sequential&quot; files (byte streams) and &quot;relative&quot; files (indexed record sets), and because it provides relatively high level interface to circumvent that altogether and work with the disk (&quot;volume&quot; in MVS parlance) more directly. There&#x27;s even a &quot;user defined&quot; file type. However, altogether the 1541 is closer to MS-DOS and CP&#x2F;M again, because usually (not always!) you leave the block allocation to the system itself. Like you <i>always</i> do in a modern system and MS-DOS or CP&#x2F;M, there is basically no sane way around it (at best you can slightly &quot;tweak&quot; it).<p>That&#x27;s not even touching on what &quot;batch processing&quot;, and associated job control languages and reader&#x2F;printer&#x2F;puncher queues, mean in practice.<p>It&#x27;s so alien to the world of nowadays.</div><br/><div id="40983377" class="c"><input type="checkbox" id="c-40983377" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40980339">parent</a><span>|</span><a href="#40980746">next</a><span>|</span><label class="collapse" for="c-40983377">[-]</label><label class="expand" for="c-40983377">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Both MS-DOS and CP&#x2F;M still had the very clear and almost identical concept of a &quot;file&quot; in the first place.</i><p>ms-dos files (after 2.0) were sequences of bytes; cp&#x2F;m&#x27;s were sequences of 128-byte &#x27;records&#x27;, which is why old text files pad out to a multiple of 128 bytes with ^z characters.  ms-dos (after 2.0) supported using the same &#x27;file&#x27; system calls to read and write bytestream devices like paper tape readers and the console; cp&#x2F;m had special system calls to read and write those (though pip did have special-case device names).  see <a href="https:&#x2F;&#x2F;www.seasip.info&#x2F;Cpm&#x2F;bdos.html" rel="nofollow">https:&#x2F;&#x2F;www.seasip.info&#x2F;Cpm&#x2F;bdos.html</a><p>that is, this<p>&gt; <i>CP&#x2F;M (...) instead see[s] &quot;files&quot; as a stream of bytes&#x2F;words&#x2F;octets or whatever.</i><p>is not correct; cp&#x2F;m has no system calls for reading or writing bytes or words to or from a file.  nor octets, which is french for what ms-dos and cp&#x2F;m call &#x27;bytes&#x27;<p>admittedly filesystems with more than two types of files (ms-dos 2+ has two: directories and regular files) are <i>more</i> different from cp&#x2F;m</div><br/><div id="40983743" class="c"><input type="checkbox" id="c-40983743" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40983377">parent</a><span>|</span><a href="#40980746">next</a><span>|</span><label class="collapse" for="c-40983743">[-]</label><label class="expand" for="c-40983743">[2 more]</label></div><br/><div class="children"><div class="content">Granted, I wasn‘t aware. But unless you also have to tell CP&#x2F;M how many cylinders and&#x2F;or tracks you want to allocate for your „file“ upfront, and how large the (single!) extent should be should that allocation be exceeded, as well as having to <i>separately</i> enter your file into a catalogue (instead of every file on disk implying at least one directory entry, multiple for filesystems that support hard links), then CP&#x2F;M and MS-DOS files are still very similar to each other.<p>Also, it sounds to me like those 128 byte records were still very much sequential. That is, 128 bytes may have been the smallest unit that you can extend a file by, but after that it‘s still a consecutive stream of bytes. (Happy to get told that I’m wrong.) With MVS, the „files“ can be fundamentally indexed by record number, or even by key, <i>and it will even be organized like that by the disk hardware itself</i>.</div><br/><div id="40983798" class="c"><input type="checkbox" id="c-40983798" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40983743">parent</a><span>|</span><a href="#40980746">next</a><span>|</span><label class="collapse" for="c-40983798">[-]</label><label class="expand" for="c-40983798">[1 more]</label></div><br/><div class="children"><div class="content">yes, exactly right, except that it&#x27;s not a consecutive stream of bytes, it&#x27;s a consecutive stream of 128-byte records; all access to files in cp&#x2F;m is by record number, not byte number</div><br/></div></div></div></div></div></div><div id="40980746" class="c"><input type="checkbox" id="c-40980746" checked=""/><div class="controls bullet"><span class="by">sillywalk</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40980339">parent</a><span>|</span><a href="#40983377">prev</a><span>|</span><a href="#40982310">next</a><span>|</span><label class="collapse" for="c-40980746">[-]</label><label class="expand" for="c-40980746">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This goes so fundamentally with the system that it goes down into the hardware, i.e. the disk itself understands the concept of indices, record lengths and even keyed records with associated values.<p>Interesting, so the disk controller firmware understood records &#x2F; data sets?<p>I believe Filesystems with files that could be record-oriented in addition to bytestreams  were also common e.g. VMS had RMS on Files-11; the MPE file system was record-oriented until it got POSIX with MPE&#x2F;IX. Tandem NonStop&#x27;s Enscribe filesystem also has different types of record-oriented files in addition to unstructured files.<p>I assume it was a logical transition for businesses transferring from punch-cards or just plain paper &quot;records&quot; to digital ones.</div><br/><div id="40980915" class="c"><input type="checkbox" id="c-40980915" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40980746">parent</a><span>|</span><a href="#40982310">next</a><span>|</span><label class="collapse" for="c-40980915">[-]</label><label class="expand" for="c-40980915">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Interesting, so the disk controller firmware understood records &#x2F; data sets?<p>Yep. The disk was addressed by record in a fundamental manner: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Count_key_data" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Count_key_data</a><p>An offshoot of this is that the Hercules mainframe emulator reflects that in its disk image format, which unlike other common disk image formats is not just an opaque stream of bytes&#x2F;words.<p>&gt; I assume it was a logical transition for businesses transferring from punch-cards or just plain paper &quot;records&quot; to digital ones.<p>Yeah, that is a sensible assumption. In general, MVS&#x27;s &quot;not-filesystem&quot; world looks in a lot of ways like an intermediary between paper records&#x2F;tapes and actual filesystems.</div><br/></div></div></div></div><div id="40982310" class="c"><input type="checkbox" id="c-40982310" checked=""/><div class="controls bullet"><span class="by">myself248</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40980339">parent</a><span>|</span><a href="#40980746">prev</a><span>|</span><a href="#40981572">next</a><span>|</span><label class="collapse" for="c-40982310">[-]</label><label class="expand" for="c-40982310">[1 more]</label></div><br/><div class="children"><div class="content">Yet even Microsoft tried to shove something like that into the PC world, whether it was the OFS effort during Cairo development, up to WinFS that actually appeared in a developer&#x27;s release of Longhorn.<p>And even more recently, there&#x27;ve been efforts to expose a native key:value interface on SSDs, to let the drive controller handle the abstraction of the underlying flash cells.<p>I&#x27;m not well-enough versed in this stuff to understand how similar these things are to what you&#x27;re talking about, however. Very much appreciate any clue you feel like offering.</div><br/></div></div><div id="40981572" class="c"><input type="checkbox" id="c-40981572" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40980339">parent</a><span>|</span><a href="#40982310">prev</a><span>|</span><a href="#40980503">next</a><span>|</span><label class="collapse" for="c-40981572">[-]</label><label class="expand" for="c-40981572">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t know if CP&#x2F;M (and in turn CMS) was inspired by UNIX in that way, or whether the &quot;file&quot; concept came from a different common ancestor, […]<p>CP&#x2F;M drew heavily on DEC operating system designs, notably RSX-11M – it even had PIP as a file «manipulation» command as well as the device naming and management commands (e.g. ASSIGN). Perhaps something else. MS-DOS 1 has descended from CP&#x2F;M whereas MS-DOS 2 diverged from it and borrowed from UNIX .<p>&gt; […] but it&#x27;s worth repeating that MVS has more or less nothing like that &quot;file&quot; concept.<p>Ironically, the today&#x27;s blame that [nearly] everything is a file and a stream of bytes in UNIX is the root cause of all evil was the major <i>liberating</i> innovation and a productivity boost that UNIX has offered to the world. Whenever somebody mentions that stderr should be a stream of typed objects or alike, I cringe and shudder as people do not realise how the typed things couple the typed object consumer with the typed object producer, a major bane of computing of old days.<p>The world was a different place back then, and the idea of having a personal computer of any sort was either preposterous or a product of distant future set science fiction.<p>So, the I&#x2F;O on mainframes and minicomputers was heavily skewed towards the business oriented tasks, business automation and business productivity enhacements. Databases had not entered the world yet, either, and as they were still incubating in research departments of IBM et al, and the record oriented I&#x2F;O was pretty much the mainstream. Conceptually, it was the overengineered Berkely DB so to speak baked into the kernel and the hardware, so it was not possible to <i>just</i> open a file as it was not, well, a file. In fact, I have an opened PDF on my laptop titled «IAS&#x2F;RSX-11M I&#x2F;O Operations Reference Manual» that has 262 pages in total and has <i>45 pages</i> in Chapter 2 dedicated to the description of how to prepare a <i>file control block</i> alone required just to open a file. I will take an open(2) UNIX one-liner any time over that, thanks.</div><br/><div id="40981673" class="c"><input type="checkbox" id="c-40981673" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#40979048">root</a><span>|</span><a href="#40981572">parent</a><span>|</span><a href="#40980503">next</a><span>|</span><label class="collapse" for="c-40981673">[-]</label><label class="expand" for="c-40981673">[1 more]</label></div><br/><div class="children"><div class="content">I think those things are largely orthogonal, though. Opening a file can be simple, while not everything having to be a file.<p>So, having the concept of files at all (and simple to open ones, to boot) is of course much better than MVS datasets, which barely abstracted the storage hardware at all for you. But on the other end of this, that does not mean everything has to be a file, as UNIX popularized.<p>To be clear, I am never defending MVS. We&#x27;ve come a long way from that, and that&#x27;s good. I may however want to defend AS&#x2F;400, which is far away from UNIX in the other direction, and so in a lot of ways the polar opposite of MVS. However, I haven&#x27;t actually worked with it enough to know whether it&#x27;s awesome seeming concepts actually hold up in real life. (Though I&#x27;ve at least frequently heard how incredibly rock solid and dependable AS&#x2F;400s are.)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40980503" class="c"><input type="checkbox" id="c-40980503" checked=""/><div class="controls bullet"><span class="by">kmeisthax</span><span>|</span><a href="#40979048">prev</a><span>|</span><a href="#40981087">next</a><span>|</span><label class="collapse" for="c-40980503">[-]</label><label class="expand" for="c-40980503">[6 more]</label></div><br/><div class="children"><div class="content">Y&#x27;know, that thing about how IBM terminals are really form display machines instead of character streamers actually put something in context for me. Over a decade ago I interviewed at multiple companies whose business included adapting text-based interfaces for the Web. One was MUMPS[0], the other AS&#x2F;400[1]. My thought was that they were writing shittons of text parsing code for each screen, but had I been hired and trained for the role I would have learned that HTML forms are poorly reimplemented IBM terminals and time is a flat circle.<p>[0] &quot;AS&#x2F;400, but it&#x27;s a hacked-together line of business program turned hospital OS written when Microsoft Access was still in di-a-pers.&quot;<p>No, I don&#x27;t know if MUMPS actually presents forms in terminal buffered I&#x2F;O or not.<p>[1] &quot;Microsoft Access, but it&#x27;s an enterprise grade server OS written when Windows NT was still in di-a-pers.&quot;</div><br/><div id="40980652" class="c"><input type="checkbox" id="c-40980652" checked=""/><div class="controls bullet"><span class="by">axiolite</span><span>|</span><a href="#40980503">parent</a><span>|</span><a href="#40981131">next</a><span>|</span><label class="collapse" for="c-40980652">[-]</label><label class="expand" for="c-40980652">[2 more]</label></div><br/><div class="children"><div class="content">&gt; HTML forms are poorly reimplemented IBM terminals<p>In HTML forms you can SEE where the input fields are.  You don&#x27;t have to &quot;PROTECT&quot; the HTML document from warping.  You don&#x27;t have to hit a special key when an HTML document is larger than your screen.<p>And IBM manages to get credit for ALL the early computer technologies just because they&#x27;re still around.  Other block-oriented terminals certainly existed, and I&#x27;m glad they didn&#x27;t catch-on...</div><br/><div id="40981776" class="c"><input type="checkbox" id="c-40981776" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#40980503">root</a><span>|</span><a href="#40980652">parent</a><span>|</span><a href="#40981131">next</a><span>|</span><label class="collapse" for="c-40981776">[-]</label><label class="expand" for="c-40981776">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you can SEE where the input fields are<p>There was always type=&quot;hidden&quot; then they added CSS for extra spice.<p>&gt; You don&#x27;t have to &quot;PROTECT&quot; the HTML document from warping.<p>Input elements have &#x27;readonly&#x27; and &#x27;disabled&#x27; and most other elements can have &#x27;contenteditable&#x27;.<p>&gt; You don&#x27;t have to hit a special key when an HTML document is larger than your screen.<p>Page Down?</div><br/></div></div></div></div><div id="40981131" class="c"><input type="checkbox" id="c-40981131" checked=""/><div class="controls bullet"><span class="by">jerrysievert</span><span>|</span><a href="#40980503">parent</a><span>|</span><a href="#40980652">prev</a><span>|</span><a href="#40981087">next</a><span>|</span><label class="collapse" for="c-40981131">[-]</label><label class="expand" for="c-40981131">[3 more]</label></div><br/><div class="children"><div class="content">you fully missed a bullet not working with MUMPS.  my favorite &quot;issue&quot; when dealing with MUMPS was failure to run in production because a line wrapped into a second 4k &quot;page&quot;.<p>that pretty much all medical records go through MUMPS scares the hell out of me after spending time moving broken web products off of MUMPS.</div><br/><div id="40981925" class="c"><input type="checkbox" id="c-40981925" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#40980503">root</a><span>|</span><a href="#40981131">parent</a><span>|</span><a href="#40982882">next</a><span>|</span><label class="collapse" for="c-40981925">[-]</label><label class="expand" for="c-40981925">[1 more]</label></div><br/><div class="children"><div class="content">You can run GNU MUMPS, written by Harlan Stenn who now maintains NTP</div><br/></div></div><div id="40982882" class="c"><input type="checkbox" id="c-40982882" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#40980503">root</a><span>|</span><a href="#40981131">parent</a><span>|</span><a href="#40981925">prev</a><span>|</span><a href="#40981087">next</a><span>|</span><label class="collapse" for="c-40982882">[-]</label><label class="expand" for="c-40982882">[1 more]</label></div><br/><div class="children"><div class="content">Lots of MUMPS use in financial system these days.</div><br/></div></div></div></div></div></div><div id="40981087" class="c"><input type="checkbox" id="c-40981087" checked=""/><div class="controls bullet"><span class="by">segmondy</span><span>|</span><a href="#40980503">prev</a><span>|</span><a href="#40978534">next</a><span>|</span><label class="collapse" for="c-40981087">[-]</label><label class="expand" for="c-40981087">[5 more]</label></div><br/><div class="children"><div class="content">&quot;IBM&#x27;s vintage mainframes were extremely underpowered compared to modern computers; a System&#x2F;370 mainframe ran well under 1 million instructions per second, while a modern laptop executes billions of instructions per second. But these mainframes could support rooms full of users, while my 2017 laptop can barely handle one person&quot;<p>Software has gotten complex, folks were running BBS with multiple users 30+ years ago on 286 computers.    First multi user machine I used was 386 BSD supporting 50-100 students at once.  486 machines were supporting thousand of users at once.   A cheap under $500 server can probably handle 5k hackernew users at once without missing a beat.    Love the article, but don&#x27;t blame the hardware, hardware has grown, software has just grown faster with so much waste as well.</div><br/><div id="40981169" class="c"><input type="checkbox" id="c-40981169" checked=""/><div class="controls bullet"><span class="by">mbreese</span><span>|</span><a href="#40981087">parent</a><span>|</span><a href="#40981153">next</a><span>|</span><label class="collapse" for="c-40981169">[-]</label><label class="expand" for="c-40981169">[2 more]</label></div><br/><div class="children"><div class="content">I think the authors point was that even though the mainframe was underpowered from a raw performance point of view, it augmented that performance with accessory units and processors. By offloading as much of the non-core functions (I&#x2F;O) as possible, the machines themselves would be able to process as much data as possible without waiting for input.<p>So while software has gotten more complex&#x2F;bloated and hardware ludicrously fast, we still are waiting for input, IO, network, etc.<p>I think of it as the old school mainframe engineers knew every trick to eke out every ounce of performance. And they used all of the tricks. We’ve sadly lost a lot of those tricks because our hardware is so fast, we can ignore the performance losses.</div><br/><div id="40981376" class="c"><input type="checkbox" id="c-40981376" checked=""/><div class="controls bullet"><span class="by">DaoVeles</span><span>|</span><a href="#40981087">root</a><span>|</span><a href="#40981169">parent</a><span>|</span><a href="#40981153">next</a><span>|</span><label class="collapse" for="c-40981376">[-]</label><label class="expand" for="c-40981376">[1 more]</label></div><br/><div class="children"><div class="content">As an aside, I have seen some folks get incredible boot times simply by eliminating all devices wait times or loading things concurrently. Looking at game consoles is a good example of cold booting speeds but even they are much slower than even a decade or two back.</div><br/></div></div></div></div><div id="40981153" class="c"><input type="checkbox" id="c-40981153" checked=""/><div class="controls bullet"><span class="by">DaoVeles</span><span>|</span><a href="#40981087">parent</a><span>|</span><a href="#40981169">prev</a><span>|</span><a href="#40981410">next</a><span>|</span><label class="collapse" for="c-40981153">[-]</label><label class="expand" for="c-40981153">[1 more]</label></div><br/><div class="children"><div class="content">There are many factors that feed into the software complexity.<p>Added abstraction for ease of development, added demands of some software functions that are not so immediately apparent and the endless needs for ever higher security on software.<p>It is most points 1 and 3 that are the biggest issue. If we could code low level and didn&#x27;t have to worry so much about folks trying to bust into various systems - the performance would be astounding.</div><br/></div></div></div></div><div id="40978534" class="c"><input type="checkbox" id="c-40978534" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#40981087">prev</a><span>|</span><a href="#40979120">next</a><span>|</span><label class="collapse" for="c-40978534">[-]</label><label class="expand" for="c-40978534">[21 more]</label></div><br/><div class="children"><div class="content">Author here if anyone has questions...</div><br/><div id="40979039" class="c"><input type="checkbox" id="c-40979039" checked=""/><div class="controls bullet"><span class="by">kaladin_1</span><span>|</span><a href="#40978534">parent</a><span>|</span><a href="#40978877">next</a><span>|</span><label class="collapse" for="c-40979039">[-]</label><label class="expand" for="c-40979039">[4 more]</label></div><br/><div class="children"><div class="content">Thanks a lot for the work you do in documenting these chips.<p>I am a software engineer that mostly sell fullstack skills. After reading your article on the chip that powers Montreal subway, I developed an interest in chip architectures.<p>I just finished these two books, The Soul of a New Machine by Tracy Kidder and Hackers by Steven Levy, they are historical books on computer design.<p>If you have other good reads that a web dev can use in testing the waters I would appreciate.</div><br/><div id="40982726" class="c"><input type="checkbox" id="c-40982726" checked=""/><div class="controls bullet"><span class="by">abraae</span><span>|</span><a href="#40978534">root</a><span>|</span><a href="#40979039">parent</a><span>|</span><a href="#40983675">next</a><span>|</span><label class="collapse" for="c-40982726">[-]</label><label class="expand" for="c-40982726">[2 more]</label></div><br/><div class="children"><div class="content">The Mythical Man Month by Fred Brooks is always worth a read. It&#x27;s now an ancient tome (e.g talk of how much storage space comments take up) but there is a lot of wisdom there and it certainly ticks the historical box. It&#x27;s one of the only books I re-read regularly.</div><br/><div id="40983100" class="c"><input type="checkbox" id="c-40983100" checked=""/><div class="controls bullet"><span class="by">jdougan</span><span>|</span><a href="#40978534">root</a><span>|</span><a href="#40982726">parent</a><span>|</span><a href="#40983675">next</a><span>|</span><label class="collapse" for="c-40983100">[-]</label><label class="expand" for="c-40983100">[1 more]</label></div><br/><div class="children"><div class="content">I also reread MMM from time to time. Also Peopleware and Yourdon&#x27;s Death March.</div><br/></div></div></div></div><div id="40983675" class="c"><input type="checkbox" id="c-40983675" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40978534">root</a><span>|</span><a href="#40979039">parent</a><span>|</span><a href="#40982726">prev</a><span>|</span><a href="#40978877">next</a><span>|</span><label class="collapse" for="c-40983675">[-]</label><label class="expand" for="c-40983675">[1 more]</label></div><br/><div class="children"><div class="content">if you want to understand chip architectures, work through <i>the elements of computing systems</i> (aka <i>nand to tetris</i>).  it walks you through implementing your own cpu, gate by gate, plus an operating system, compiler, and tetris game, in a way tested to successfully fit inside of a single-semester undergraduate class.  their hardware designs are pretty weird (their hdl looks nothing like any hdl you can actually synthesize hardware from, their descriptions of how gates work are oversimplified, and their instruction set architecture is pretty similar to the eclipse that kidder was writing about but completely unlike any current design) but that isn&#x27;t really important<p>after completing the work in that book and raising investment capital for your company, you can honestly call yourself a fullstack engineer<p>— arm —<p>the best architecture to <i>write</i> assembly for is the arm—the original one, not thumb, which is a bit of a pain—and arm is also only slightly more complex <i>to build</i> than the fake-ass architecture in nand2tetris, and quite a bit faster.   if you already know any assembly language, including the nand2tetris one, the best introduction to arm might not actually be any current tutorial but rather the vlsi arm3 datasheet from 01990 <a href="https:&#x2F;&#x2F;www.chiark.greenend.org.uk&#x2F;~theom&#x2F;riscos&#x2F;docs&#x2F;ARM3-datasheet_ARM-Family-Data-Manual-VLSI.pdf" rel="nofollow">https:&#x2F;&#x2F;www.chiark.greenend.org.uk&#x2F;~theom&#x2F;riscos&#x2F;docs&#x2F;ARM3-d...</a> which has a summary of the instruction set on p.1-7 (9&#x2F;56) and a fully complete description on pp.3-12 to 3-43 (19&#x2F;56 to 34&#x2F;56)<p>as you probably know, the vast majority of the cpus around you run the arm instruction set or its thumb variant, although amd64 and aarch64 (arm64) are also significant.  the current arm architecture reference manual describes all the new instructions that have been added since arm3, as well as thumb, which makes it enormous and intimidating, with a very low signal-to-noise ratio<p>if you <i>don&#x27;t</i> know any assembly, the three best actual tutorials for arm that i&#x27;ve found are <a href="https:&#x2F;&#x2F;www.coranac.com&#x2F;tonc&#x2F;text&#x2F;asm.htm" rel="nofollow">https:&#x2F;&#x2F;www.coranac.com&#x2F;tonc&#x2F;text&#x2F;asm.htm</a> (aimed at the gameboy advance), <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20210531-00&#x2F;?p=105265" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20210531-00&#x2F;?p=10...</a> (aimed at windows 10, thumb-only), and <a href="https:&#x2F;&#x2F;azeria-labs.com&#x2F;writing-arm-assembly-part-1&#x2F;" rel="nofollow">https:&#x2F;&#x2F;azeria-labs.com&#x2F;writing-arm-assembly-part-1&#x2F;</a> (aimed at crackers).  these are all much longer than the relevant part of the arm3 datasheet but will guide you through how to actually use the things<p>— teensy programs —<p>perhaps the best introduction to writing assembly language <i>in general</i> on current systems is <a href="https:&#x2F;&#x2F;www.muppetlabs.com&#x2F;~breadbox&#x2F;software&#x2F;tiny&#x2F;teensy.html" rel="nofollow">https:&#x2F;&#x2F;www.muppetlabs.com&#x2F;~breadbox&#x2F;software&#x2F;tiny&#x2F;teensy.ht...</a>, which is not really focused on assembly at all, but on understanding how the interface between the operating system (i386 linux in this case) and user programs work, which just happens to be at the assembly-language level<p>it&#x27;s also a lot more fun to read than any of these except maybe kidder and levy<p>— risc-v —<p>the risc-v architecture is very similar to arm but simpler; however, it&#x27;s a little more of a pain to program, and there aren&#x27;t any high-performance implementations of it out there, something that&#x27;s likely to change in the next few years.  the part of the risc-v manual <a href="https:&#x2F;&#x2F;riscv.org&#x2F;wp-content&#x2F;uploads&#x2F;2019&#x2F;12&#x2F;riscv-spec-20191213.pdf" rel="nofollow">https:&#x2F;&#x2F;riscv.org&#x2F;wp-content&#x2F;uploads&#x2F;2019&#x2F;12&#x2F;riscv-spec-2019...</a> that corresponds to the part of the arm3 manual i recommended above is chapter 2, rv32i base integer instruction set, pp.13–29.  this reflects an additional 30 years of computer architecture lessons from arm and its successors, and a lot of those lessons are helpfully explained in the italic notes in the text.  geohot livecoded a full implementation of risc-v in verilog on his twitch stream a few years ago, so you can literally implement risc-v in an afternoon: <a href="https:&#x2F;&#x2F;github.com&#x2F;geohot&#x2F;twitchcore">https:&#x2F;&#x2F;github.com&#x2F;geohot&#x2F;twitchcore</a><p>gcc can compile to risc-v and generates decent code, and linux can run on it, but the risc-v that linux runs on is quite a bit hairier to implement than the rv32i isa; you have to implement the risc-v privileged isa<p>— if what you&#x27;re interested in is how <i>varied</i> cpu architectures can be —<p>probably risc-v and arm won&#x27;t do it for you<p>the nand2tetris &#x27;hack&#x27; is pretty weird, and very similar not only to the dirty genitals nova, but also to chuck thacker&#x27;s &#x27;tiny computer for teaching&#x27; <a href="https:&#x2F;&#x2F;www.cl.cam.ac.uk&#x2F;teaching&#x2F;1112&#x2F;ECAD+Arch&#x2F;files&#x2F;Thacker-A_Tiny_Computer-3.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cl.cam.ac.uk&#x2F;teaching&#x2F;1112&#x2F;ECAD+Arch&#x2F;files&#x2F;Thack...</a> which is two pages of vhdl<p>weird in a different direction is the tera mta, which has 128 hardware threads and context-switches every clock cycle; the 11¢ padauk pmc251 microcontroller does the same thing (but with only two threads; padauk sells parts with up to four threads)<p>the tera mta was designed to compete in the vector supercomputer field originally defined by the cray-1, which had a very different architecture; the convex <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40979684">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40979684</a> was very similar to the cray-1<p>in a sense, though, the cray wasn&#x27;t really the first supercomputer; the cdc 6600, also designed by seymour cray, was, and it was arguably the first risc, in 01964<p>unlike all of these, the burroughs 5500 architecture had no registers, just a stack, and that&#x27;s what smalltalk, java, and c# are based on<p>the 12-bit pdp-8 was the first really mass-produced computer, with over 50000 units sold, and its architecture is interestingly different from all of these, too; intersil produced a 4000-gate single-chip version, and the family was popular enough that there are pdp-8 hobbyists even today<p>most current numerical computation is being done on gpus, and i don&#x27;t know what to recommend as reading material on gpus, which have bizarrely different instruction set architectures that use a model called &#x27;simt&#x27;, single instruction, multiple thread.  if anyone does, let me know<p>finally, chuck moore&#x27;s line of two-stack processors based on forth are a sadly underdeveloped branch of the genealogical tree; koopman&#x27;s <i>stack computers: the new wave</i> <a href="https:&#x2F;&#x2F;users.ece.cmu.edu&#x2F;~koopman&#x2F;stack_computers&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;users.ece.cmu.edu&#x2F;~koopman&#x2F;stack_computers&#x2F;index.htm...</a> goes into their historical development a bit.  they had some significant success in the 80s (the novix nc4000 and the harris rtx2000) but the later members of the family (the sh-boom, the mup21, the stillborn f21, the intellasys seaforth 40c18, and the greenarrays ga4 and ga144 chips) have no real users, in part due to malfeasance—after losing a protracted lawsuit with moore, intellasys head dan leckrone now goes by &#x27;mac leckrone&#x27;, perhaps as a result<p>there are lots of other interestingly different instruction set architectures out there: s&#x2F;360, 6502, amd64, pic16, the erim cytocomputer, the thinking machines cm4, the em-4 dataflow machine, the maxim maxq, the as&#x2F;400, webassembly, vulkan spir-v, the hp 9825 desk calculator, saturn (used in the hp 48gx), etc.<p>i hope this is helpful!</div><br/></div></div></div></div><div id="40978877" class="c"><input type="checkbox" id="c-40978877" checked=""/><div class="controls bullet"><span class="by">renewedrebecca</span><span>|</span><a href="#40978534">parent</a><span>|</span><a href="#40979039">prev</a><span>|</span><a href="#40979073">next</a><span>|</span><label class="collapse" for="c-40978877">[-]</label><label class="expand" for="c-40978877">[3 more]</label></div><br/><div class="children"><div class="content">Really appreciate the work you do on documenting these chips.  It&#x27;s awesome to see how the stuff I only worked with from the programming side works at the hardware level.</div><br/><div id="40979486" class="c"><input type="checkbox" id="c-40979486" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#40978534">root</a><span>|</span><a href="#40978877">parent</a><span>|</span><a href="#40979073">next</a><span>|</span><label class="collapse" for="c-40979486">[-]</label><label class="expand" for="c-40979486">[2 more]</label></div><br/><div class="children"><div class="content">Thank you to you and all the others in this thread for your positive comments. I almost didn&#x27;t write about this chip because it is so obscure, so it is encouraging that people are reading it.</div><br/><div id="40979640" class="c"><input type="checkbox" id="c-40979640" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#40978534">root</a><span>|</span><a href="#40979486">parent</a><span>|</span><a href="#40979073">next</a><span>|</span><label class="collapse" for="c-40979640">[-]</label><label class="expand" for="c-40979640">[1 more]</label></div><br/><div class="children"><div class="content">In some ways, the obscurity makes it even more interesting. That&#x27;s of course not to say that I didn&#x27;t enjoy your articles about popular chips like the Z80 or any x86 variant as well, I really do. One is interesting because you get fantastic insight into the chips you&#x27;ve been using for so long, the other because it&#x27;s a glimpse into an unfamiliar world.</div><br/></div></div></div></div></div></div><div id="40979073" class="c"><input type="checkbox" id="c-40979073" checked=""/><div class="controls bullet"><span class="by">mrgaro</span><span>|</span><a href="#40978534">parent</a><span>|</span><a href="#40978877">prev</a><span>|</span><a href="#40979609">next</a><span>|</span><label class="collapse" for="c-40979073">[-]</label><label class="expand" for="c-40979073">[1 more]</label></div><br/><div class="children"><div class="content">Thanks Master Ken for doing these awesome posts and participating in the Marc&#x27;s youtube channel! Both amazing content!</div><br/></div></div><div id="40979609" class="c"><input type="checkbox" id="c-40979609" checked=""/><div class="controls bullet"><span class="by">throaway12345</span><span>|</span><a href="#40978534">parent</a><span>|</span><a href="#40979073">prev</a><span>|</span><a href="#40978767">next</a><span>|</span><label class="collapse" for="c-40979609">[-]</label><label class="expand" for="c-40979609">[4 more]</label></div><br/><div class="children"><div class="content">I really love these updates. I really appreciate your articles and they&#x27;ve made me go into a deep dive into the history of microchips and IC design in general.<p>How did you get into this in the first place? From your blog I gather that you used to be in software (or still are).</div><br/><div id="40979768" class="c"><input type="checkbox" id="c-40979768" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#40978534">root</a><span>|</span><a href="#40979609">parent</a><span>|</span><a href="#40978767">next</a><span>|</span><label class="collapse" for="c-40979768">[-]</label><label class="expand" for="c-40979768">[3 more]</label></div><br/><div class="children"><div class="content">How did I get into this? It started when I saw the simulation of the 6502 processor from the Visual6502 team [1]. It was very cool, but totally mysterious. I realized that even though I was a programmer and understood the &quot;full stack&quot;, I had no idea how a processor chip actually worked. (I&#x27;d taken computer architecture courses but there&#x27;s still a big jump to physical transistors on a chip.)<p>I started looking at the 6502&#x27;s circuits and one thing led to another and here I am today, reverse-engineering obscure chips with a microscope :-)<p>[1] <a href="http:&#x2F;&#x2F;www.visual6502.org&#x2F;JSSim&#x2F;index.html" rel="nofollow">http:&#x2F;&#x2F;www.visual6502.org&#x2F;JSSim&#x2F;index.html</a></div><br/><div id="40979993" class="c"><input type="checkbox" id="c-40979993" checked=""/><div class="controls bullet"><span class="by">throaway12345</span><span>|</span><a href="#40978534">root</a><span>|</span><a href="#40979768">parent</a><span>|</span><a href="#40978767">next</a><span>|</span><label class="collapse" for="c-40979993">[-]</label><label class="expand" for="c-40979993">[2 more]</label></div><br/><div class="children"><div class="content">Hehehe. Maybe some day if somebody asks me &quot;how did you get into ICs?&quot; I&#x27;ll have to answer &quot;well, I kept reading Ken Shirriff&#x27;s blog...&quot;<p>Also, what type of microscope do you use?</div><br/><div id="40982033" class="c"><input type="checkbox" id="c-40982033" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#40978534">root</a><span>|</span><a href="#40979993">parent</a><span>|</span><a href="#40978767">next</a><span>|</span><label class="collapse" for="c-40982033">[-]</label><label class="expand" for="c-40982033">[1 more]</label></div><br/><div class="children"><div class="content">I use an AmScope ME300TZB-2L-10M metallurgical microscope that I got for cheap on eBay. My friends all have cooler microscopes :-)</div><br/></div></div></div></div></div></div></div></div><div id="40978767" class="c"><input type="checkbox" id="c-40978767" checked=""/><div class="controls bullet"><span class="by">java-man</span><span>|</span><a href="#40978534">parent</a><span>|</span><a href="#40979609">prev</a><span>|</span><a href="#40979120">next</a><span>|</span><label class="collapse" for="c-40978767">[-]</label><label class="expand" for="c-40978767">[8 more]</label></div><br/><div class="children"><div class="content">Thank you for your work, every article brightens my day!<p>Every time I look at the chips from 70s and 80s, I notice how huge the features are.  Was that determined by the current stepper technology at the time, or by the fact that people drew the early designs by hand?<p>Or am I totally wrong and the chips are always at the limit of the contemporary technology?</div><br/><div id="40978928" class="c"><input type="checkbox" id="c-40978928" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#40978534">root</a><span>|</span><a href="#40978767">parent</a><span>|</span><a href="#40979852">next</a><span>|</span><label class="collapse" for="c-40978928">[-]</label><label class="expand" for="c-40978928">[1 more]</label></div><br/><div class="children"><div class="content">The feature size on chips has steadily shrunk from 10 µm for the Intel 8008 to a few nanometers nowadays. The feature size is determined by the limits of contemporary technology, which steadily improves as described by Moore&#x27;s Law. Many different technological aspects need to improve to shrink the features, from the design techniques to the optics to the chemical processes.</div><br/></div></div><div id="40979852" class="c"><input type="checkbox" id="c-40979852" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#40978534">root</a><span>|</span><a href="#40978767">parent</a><span>|</span><a href="#40978928">prev</a><span>|</span><a href="#40979120">next</a><span>|</span><label class="collapse" for="c-40979852">[-]</label><label class="expand" for="c-40979852">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Or am I totally wrong and the chips are always at the limit of the contemporary technology?<p>I can chime in here. There are many things that determine the feature size.<p>There is the process limit, yes, and if your needs are simple digital logic, that&#x27;s often going to be the density limit.<p>But if you need NOR flash, there&#x27;s a stability limit around 40nm process node. You can use smaller transistors for everything else, but soon the NOR is most of the chip.<p>But what if you need a 1 Amp FET in your PMIC? Well, that won&#x27;t shrink with process node at all, so maybe a cheaper process node is better to use.<p>It really depends.</div><br/><div id="40980022" class="c"><input type="checkbox" id="c-40980022" checked=""/><div class="controls bullet"><span class="by">java-man</span><span>|</span><a href="#40978534">root</a><span>|</span><a href="#40979852">parent</a><span>|</span><a href="#40980610">next</a><span>|</span><label class="collapse" for="c-40980022">[-]</label><label class="expand" for="c-40980022">[3 more]</label></div><br/><div class="children"><div class="content">Yes, I was referring to 70&#x27;s and 80&#x27;s.  Even today, I think, there are applications where 150 nm process is perfectly fine - RFID, transportation cards etc.<p>If you look at the 74 TTL series dies, they look almost primitive.  But perhaps these were one of the first attempts at ICs, so it is expected.<p>When did transition from hand-drawn to computer-generated designs happen?</div><br/><div id="40983371" class="c"><input type="checkbox" id="c-40983371" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#40978534">root</a><span>|</span><a href="#40980022">parent</a><span>|</span><a href="#40982313">next</a><span>|</span><label class="collapse" for="c-40983371">[-]</label><label class="expand" for="c-40983371">[1 more]</label></div><br/><div class="children"><div class="content">Around the mid 80s, for example the 386 was the first x86 processor to largely use standard cells.<p>It seems appropriate to cite Ken&#x27;s blog post on the topic: <a href="https:&#x2F;&#x2F;www.righto.com&#x2F;2024&#x2F;01&#x2F;intel-386-standard-cells.html" rel="nofollow">https:&#x2F;&#x2F;www.righto.com&#x2F;2024&#x2F;01&#x2F;intel-386-standard-cells.html</a></div><br/></div></div><div id="40982313" class="c"><input type="checkbox" id="c-40982313" checked=""/><div class="controls bullet"><span class="by">greenyoda</span><span>|</span><a href="#40978534">root</a><span>|</span><a href="#40980022">parent</a><span>|</span><a href="#40983371">prev</a><span>|</span><a href="#40980610">next</a><span>|</span><label class="collapse" for="c-40982313">[-]</label><label class="expand" for="c-40982313">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you look at the 74 TTL series dies, they look almost primitive. But perhaps these were one of the first attempts at ICs...<p>TTL wasn&#x27;t the first attempt at ICs. Before TTL, there was RTL:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Resistor%E2%80%93transistor_logic" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Resistor%E2%80%93transistor_lo...</a></div><br/></div></div></div></div><div id="40980610" class="c"><input type="checkbox" id="c-40980610" checked=""/><div class="controls bullet"><span class="by">CamperBob2</span><span>|</span><a href="#40978534">root</a><span>|</span><a href="#40979852">parent</a><span>|</span><a href="#40980022">prev</a><span>|</span><a href="#40979120">next</a><span>|</span><label class="collapse" for="c-40980610">[-]</label><label class="expand" for="c-40980610">[2 more]</label></div><br/><div class="children"><div class="content"><i>But what if you need a 1 Amp FET in your PMIC?</i><p>You use lots of very small FETs in parallel (and derate the living bejesus out of the SOA curves, because there&#x27;s no chance that they&#x27;ll all run at the same temperature.)</div><br/><div id="40983704" class="c"><input type="checkbox" id="c-40983704" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40978534">root</a><span>|</span><a href="#40980610">parent</a><span>|</span><a href="#40979120">next</a><span>|</span><label class="collapse" for="c-40983704">[-]</label><label class="expand" for="c-40983704">[1 more]</label></div><br/><div class="children"><div class="content">i mean in effect a hexfet <i>is</i> a lot of very small fets in parallel<p>nice thing about fets, hotspots don&#x27;t hog current, so you don&#x27;t have to derate the living bejesus out of the soa curves</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40979120" class="c"><input type="checkbox" id="c-40979120" checked=""/><div class="controls bullet"><span class="by">travismcpeak</span><span>|</span><a href="#40978534">prev</a><span>|</span><a href="#40979139">next</a><span>|</span><label class="collapse" for="c-40979120">[-]</label><label class="expand" for="c-40979120">[3 more]</label></div><br/><div class="children"><div class="content">This is really cool! How do you accomplish your research? I&#x27;m assuming IBM has some corporate records, but didn&#x27;t realize they&#x27;d be this complete.</div><br/><div id="40979452" class="c"><input type="checkbox" id="c-40979452" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#40979120">parent</a><span>|</span><a href="#40979139">next</a><span>|</span><label class="collapse" for="c-40979452">[-]</label><label class="expand" for="c-40979452">[2 more]</label></div><br/><div class="children"><div class="content">We haven&#x27;t been able to get old information from IBM; either they discarded it or don&#x27;t make it available. There are lots of old manuals on bitsavers, which is a treasure for historical computer research. It is worrisome how much preservation depends on the efforts of a single person.<p><a href="https:&#x2F;&#x2F;bitsavers.org&#x2F;pdf&#x2F;ibm&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bitsavers.org&#x2F;pdf&#x2F;ibm&#x2F;</a></div><br/><div id="40979616" class="c"><input type="checkbox" id="c-40979616" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#40979120">root</a><span>|</span><a href="#40979452">parent</a><span>|</span><a href="#40979139">next</a><span>|</span><label class="collapse" for="c-40979616">[-]</label><label class="expand" for="c-40979616">[1 more]</label></div><br/><div class="children"><div class="content">One of my hobbies is writing period-correct stuff for s&#x2F;370 and MVS, and, yep, bitsavers is where it&#x27;s at. Weird thought that if that person didn&#x27;t go through the effort, the information would be near-unobtainable.</div><br/></div></div></div></div></div></div><div id="40979139" class="c"><input type="checkbox" id="c-40979139" checked=""/><div class="controls bullet"><span class="by">codedokode</span><span>|</span><a href="#40979120">prev</a><span>|</span><a href="#40983393">next</a><span>|</span><label class="collapse" for="c-40979139">[-]</label><label class="expand" for="c-40979139">[6 more]</label></div><br/><div class="children"><div class="content">Talking about chips, does anyone know what was the feature size in classical DIP-package chips like 4000, 7400, 74LS, 74HC, 74AC series? I googled around, but for example this Wikipedia article [1] has information only on CPUs, but not on simple logic chips.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Transistor_count" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Transistor_count</a></div><br/><div id="40979413" class="c"><input type="checkbox" id="c-40979413" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#40979139">parent</a><span>|</span><a href="#40979519">next</a><span>|</span><label class="collapse" for="c-40979413">[-]</label><label class="expand" for="c-40979413">[1 more]</label></div><br/><div class="children"><div class="content">I looked at a random 7400-series die and I think the feature size is about 5 µm. (The width of the thinnest metal and silicon features.) Bipolar chips have different construction from a MOS processor, so the features aren&#x27;t directly comparable, but this should give you a rough idea.</div><br/></div></div><div id="40979519" class="c"><input type="checkbox" id="c-40979519" checked=""/><div class="controls bullet"><span class="by">bregma</span><span>|</span><a href="#40979139">parent</a><span>|</span><a href="#40979413">prev</a><span>|</span><a href="#40983393">next</a><span>|</span><label class="collapse" for="c-40979519">[-]</label><label class="expand" for="c-40979519">[4 more]</label></div><br/><div class="children"><div class="content">I imagine a 7400 TTL quad NAND gate would have... 16 transistors?</div><br/><div id="40980784" class="c"><input type="checkbox" id="c-40980784" checked=""/><div class="controls bullet"><span class="by">codedokode</span><span>|</span><a href="#40979139">root</a><span>|</span><a href="#40979519">parent</a><span>|</span><a href="#40983393">next</a><span>|</span><label class="collapse" for="c-40980784">[-]</label><label class="expand" for="c-40980784">[3 more]</label></div><br/><div class="children"><div class="content">I was curious about feature size (e.g. wire width). The number of transistors can actually be found in some datasheets (don&#x27;t remember exactly which manufacturer published it though).</div><br/><div id="40982580" class="c"><input type="checkbox" id="c-40982580" checked=""/><div class="controls bullet"><span class="by">GeorgeTirebiter</span><span>|</span><a href="#40979139">root</a><span>|</span><a href="#40980784">parent</a><span>|</span><a href="#40983393">next</a><span>|</span><label class="collapse" for="c-40982580">[-]</label><label class="expand" for="c-40982580">[2 more]</label></div><br/><div class="children"><div class="content">A 2-input TTL NAND gate usually consists of 5 transistors:<p>Two multi-emitter transistors (counted as two separate transistors here)
One phase splitter transistor.
One pull-down transistor.
One output transistor.<p>The multi-emitter transistors are easy to make on-chip and are a clever way of getting two inputs into one &#x27;device&#x27;.    For a 7400 that was 4 sections x 5 transistors per section = 20 transistors, total.<p>NAND was the fundamental block in TTL; in the earlier RTL, NOR was the fundamental block - and used only 2 transistors, but needed resistors for the inputs and as the load pull-up.  Power hungry and slow as a result.</div><br/><div id="40983708" class="c"><input type="checkbox" id="c-40983708" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40979139">root</a><span>|</span><a href="#40982580">parent</a><span>|</span><a href="#40983393">next</a><span>|</span><label class="collapse" for="c-40983708">[-]</label><label class="expand" for="c-40983708">[1 more]</label></div><br/><div class="children"><div class="content">shouldn&#x27;t you count the input clamping diodes as transistors</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40983393" class="c"><input type="checkbox" id="c-40983393" checked=""/><div class="controls bullet"><span class="by">protocolture</span><span>|</span><a href="#40979139">prev</a><span>|</span><a href="#40980645">next</a><span>|</span><label class="collapse" for="c-40983393">[-]</label><label class="expand" for="c-40983393">[1 more]</label></div><br/><div class="children"><div class="content">Uh thats sad. I processed one a similar IBM controller unit when I worked in recycling. I tried for 2 weeks to first figure out what the heck it was, and then secondly find a home for it that wasnt scrap.<p>Ultimately, it was gutted and converted into a mobile workstation.</div><br/></div></div><div id="40980645" class="c"><input type="checkbox" id="c-40980645" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#40983393">prev</a><span>|</span><label class="collapse" for="c-40980645">[-]</label><label class="expand" for="c-40980645">[2 more]</label></div><br/><div class="children"><div class="content">The partnership between IBM and Motorola is something I find intriguing. And I&#x27;m not just talking about PowerPC. In the 80s -- long before Hercules -- IBM developed a &quot;mainframe on a card&quot; solution for use in IBM PCs. For a CPU, they commissioned Motorola to build a special 68000 CPU with different microcode that implemented a large subset of the System&#x2F;370 instruction set. Any instructions that could not be implemented with this custom-schmustom architecture would trap, and be decoded and emulated by a regular 68000 that ran in tandem with the custom one. The resulting architecture was able to run mainframe operating systems and applications very well, providing mainframe developers a benchside testing solution that allowed them to run software still in development without tying up resources on the actual mainframe (which needed to have as much CPU time as possible committed to production workloads in order to be profitable to run).<p>Still probably cost an arm and a leg, though. The cards weren&#x27;t sold on their own, but installed inside a PC under the names Personal Computer XT&#x2F;370 or AT&#x2F;370:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;PC-based_IBM_mainframe-compatible_systems#Personal_Computer_XT&#x2F;370" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;PC-based_IBM_mainframe-compati...</a></div><br/><div id="40980812" class="c"><input type="checkbox" id="c-40980812" checked=""/><div class="controls bullet"><span class="by">sillywalk</span><span>|</span><a href="#40980645">parent</a><span>|</span><label class="collapse" for="c-40980812">[-]</label><label class="expand" for="c-40980812">[1 more]</label></div><br/><div class="children"><div class="content">I remember reading about that, from the Chipletter in 2022[0]:<p>&quot;The XT&#x2F;370, with a hard drive, could be purchased for as little as $8085. This compares with a basic PC&#x2F;XT with 256K RAM for $4395 and adds a lot more functionality.&quot;<p>...<p>&quot;So what was the PC XT&#x2F;370? Put simply, it was a PC XT (the original IBM PC with a hard disk drive) with three additional cards:<p>PC&#x2F;370-P : A card with one modified 68000, one standard 68000 and lots of logic chips.<p>PC&#x2F;370-M : A card with 512 kilobytes of memory.<p>PC&#x2F;370 EM: Providing the ability to emulate an IBM 3270 terminal.<p>The XT&#x2F;370 then became three machines in one:<p>An IBM PC&#x2F;XT.<p>An IBM 3270 terminal that could be used to access a System&#x2F;370 mainframe.<p>A machine capable of running some System&#x2F;370 software.&quot;<p>[0] <a href="https:&#x2F;&#x2F;thechipletter.substack.com&#x2F;p&#x2F;motorola-intel-ibm-make-a-mainframe" rel="nofollow">https:&#x2F;&#x2F;thechipletter.substack.com&#x2F;p&#x2F;motorola-intel-ibm-make...</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>