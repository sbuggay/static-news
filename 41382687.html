<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724922069026" as="style"/><link rel="stylesheet" href="styles.css?v=1724922069026"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://stepchange.work/blog/scaling-rails-postgres-to-millions-of-users-at-microsoft-lessons-takeaways">Scaling Rails and Postgres to millions of users at Microsoft</a> <span class="domain">(<a href="https://stepchange.work">stepchange.work</a>)</span></div><div class="subtext"><span>htormey</span> | <span>42 comments</span></div><br/><div><div id="41383943" class="c"><input type="checkbox" id="c-41383943" checked=""/><div class="controls bullet"><span class="by">cdiamand</span><span>|</span><a href="#41386160">next</a><span>|</span><label class="collapse" for="c-41383943">[-]</label><label class="expand" for="c-41383943">[9 more]</label></div><br/><div class="children"><div class="content">I ran into some scaling challenges with Postgres a few years ago and had to dive into the docs.<p>While I was mostly living out of the &quot;High Availability, Load Balancing, and Replication&quot; chapter, I couldn&#x27;t help but poke around and found the docs to be excellent in general. Highly recommend checking them out.<p><a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;16&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;16&#x2F;index.html</a></div><br/><div id="41385533" class="c"><input type="checkbox" id="c-41385533" checked=""/><div class="controls bullet"><span class="by">danpalmer</span><span>|</span><a href="#41383943">parent</a><span>|</span><a href="#41384021">next</a><span>|</span><label class="collapse" for="c-41385533">[-]</label><label class="expand" for="c-41385533">[4 more]</label></div><br/><div class="children"><div class="content">They are excellent! Another great example is the Django project, which I always point to for how to write and structure great technical documentation. Working with Django&#x2F;Postgres is such a nice combo and the standards of documentation and community are a huge part of that.</div><br/><div id="41386529" class="c"><input type="checkbox" id="c-41386529" checked=""/><div class="controls bullet"><span class="by">irjustin</span><span>|</span><a href="#41383943">root</a><span>|</span><a href="#41385533">parent</a><span>|</span><a href="#41384021">next</a><span>|</span><label class="collapse" for="c-41386529">[-]</label><label class="expand" for="c-41386529">[3 more]</label></div><br/><div class="children"><div class="content">Interestingly I have had almost the exact opposite experience being very frustrated with the Django docs.<p>To be fair, it could be because I&#x27;m frustrated with Django&#x27;s design decisions having come from Rails.<p>When learning Django a few years ago, I still carry a deep loathing against polymorphism (generic relations[0]), and model validations (full clean[1]),<p>You know what - it&#x27;s design decisions...<p>[0] <a href="https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;5.1&#x2F;ref&#x2F;contrib&#x2F;contenttypes&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;5.1&#x2F;ref&#x2F;contrib&#x2F;contenttyp...</a><p>[1] <a href="https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;5.1&#x2F;ref&#x2F;models&#x2F;instances&#x2F;#validating-objects" rel="nofollow">https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;5.1&#x2F;ref&#x2F;models&#x2F;instances&#x2F;#...</a></div><br/><div id="41387050" class="c"><input type="checkbox" id="c-41387050" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41383943">root</a><span>|</span><a href="#41386529">parent</a><span>|</span><a href="#41388336">next</a><span>|</span><label class="collapse" for="c-41387050">[-]</label><label class="expand" for="c-41387050">[1 more]</label></div><br/><div class="children"><div class="content">generic relations are hard to get right, really if you can avoid using them you&#x27;re going to avoid a lot of trickiness.<p>When you need them... it&#x27;s nice to have them &quot;just there&quot;, implemented correctly (at least as correctly as they can be in an entirely generic way).<p>Model validations is a whole thing... I think that Django offering a built-in auto-generated admin leads to a whole slew of differing decisions that end up coming back to be really tricky to handle.</div><br/></div></div><div id="41388336" class="c"><input type="checkbox" id="c-41388336" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#41383943">root</a><span>|</span><a href="#41386529">parent</a><span>|</span><a href="#41387050">prev</a><span>|</span><a href="#41384021">next</a><span>|</span><label class="collapse" for="c-41388336">[-]</label><label class="expand" for="c-41388336">[1 more]</label></div><br/><div class="children"><div class="content">Would love to hear more about what you don&#x27;t like with model validations (full clean).</div><br/></div></div></div></div></div></div><div id="41384021" class="c"><input type="checkbox" id="c-41384021" checked=""/><div class="controls bullet"><span class="by">jbverschoor</span><span>|</span><a href="#41383943">parent</a><span>|</span><a href="#41385533">prev</a><span>|</span><a href="#41386160">next</a><span>|</span><label class="collapse" for="c-41384021">[-]</label><label class="expand" for="c-41384021">[4 more]</label></div><br/><div class="children"><div class="content">Like many of the BSDs</div><br/><div id="41384219" class="c"><input type="checkbox" id="c-41384219" checked=""/><div class="controls bullet"><span class="by">aerzen</span><span>|</span><a href="#41383943">root</a><span>|</span><a href="#41384021">parent</a><span>|</span><a href="#41386160">next</a><span>|</span><label class="collapse" for="c-41384219">[-]</label><label class="expand" for="c-41384219">[3 more]</label></div><br/><div class="children"><div class="content">Did Postgres used to be a BSD? Are they known for good documentation?</div><br/><div id="41386747" class="c"><input type="checkbox" id="c-41386747" checked=""/><div class="controls bullet"><span class="by">andrewf</span><span>|</span><a href="#41383943">root</a><span>|</span><a href="#41384219">parent</a><span>|</span><a href="#41384323">next</a><span>|</span><label class="collapse" for="c-41386747">[-]</label><label class="expand" for="c-41386747">[1 more]</label></div><br/><div class="children"><div class="content">BSD was the Unix distribution; BSD and Postgres&#x2F;Ingres development did overlap at UC Berkeley.</div><br/></div></div><div id="41384323" class="c"><input type="checkbox" id="c-41384323" checked=""/><div class="controls bullet"><span class="by">password4321</span><span>|</span><a href="#41383943">root</a><span>|</span><a href="#41384219">parent</a><span>|</span><a href="#41386747">prev</a><span>|</span><a href="#41386160">next</a><span>|</span><label class="collapse" for="c-41384323">[-]</label><label class="expand" for="c-41384323">[1 more]</label></div><br/><div class="children"><div class="content">BSD? No, that&#x27;s operating system(s)<p>Good documentation? Yes</div><br/></div></div></div></div></div></div></div></div><div id="41386160" class="c"><input type="checkbox" id="c-41386160" checked=""/><div class="controls bullet"><span class="by">pajeets</span><span>|</span><a href="#41383943">prev</a><span>|</span><a href="#41388574">next</a><span>|</span><label class="collapse" for="c-41386160">[-]</label><label class="expand" for="c-41386160">[13 more]</label></div><br/><div class="children"><div class="content">Postgres can be scaled vertically like Stackoverflow did. With cache on edge for popular reads if you absolutely must (but you most likely dont).<p>No need to microservice or sync read replicas even (unless you are making a game). No load balancers. Just up the RAM and CPU up to TB levels for heavy real world apps (99% of you wont ever run into this issue)<p>Seriously its so create scalable backend services with postgrest, rpc, triggers, v8, even queues now  all in Postgres. You dont even need cloud. Even a mildly RAM&#x27;d VPS will do for most apps.<p>got rid of  redis, kubernetes, rabbitmq, bunch of SaaS tools. I just do everything on Postgres and scale vertically.<p>One server. No serverless. No microservice or load handlers. It&#x27;s sooo easy.</div><br/><div id="41388569" class="c"><input type="checkbox" id="c-41388569" checked=""/><div class="controls bullet"><span class="by">danmaz74</span><span>|</span><a href="#41386160">parent</a><span>|</span><a href="#41386602">next</a><span>|</span><label class="collapse" for="c-41388569">[-]</label><label class="expand" for="c-41388569">[1 more]</label></div><br/><div class="children"><div class="content">Having at least 2 web servers and a read-only DB replica for redundancy&#x2F;high availability is very easy and much safer. Yes, setting up a single-server is faster, but if your DB server dies - and at some point it will happen - you&#x27;ll not just save a lot of downtime, but also a lot of stress and additional work.</div><br/></div></div><div id="41386602" class="c"><input type="checkbox" id="c-41386602" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#41386160">parent</a><span>|</span><a href="#41388569">prev</a><span>|</span><a href="#41386590">next</a><span>|</span><label class="collapse" for="c-41386602">[-]</label><label class="expand" for="c-41386602">[2 more]</label></div><br/><div class="children"><div class="content">That works for the performance aspect, but doesn&#x27;t address any kind of High Availability (HA).<p>There are definitely ways to make HA work, especially if you run your own hardware, but the point is that you&#x27;ll need (at least) a 2nd server to take over the load of the primary one that died.</div><br/><div id="41387316" class="c"><input type="checkbox" id="c-41387316" checked=""/><div class="controls bullet"><span class="by">pajeets</span><span>|</span><a href="#41386160">root</a><span>|</span><a href="#41386602">parent</a><span>|</span><a href="#41386590">next</a><span>|</span><label class="collapse" for="c-41387316">[-]</label><label class="expand" for="c-41387316">[1 more]</label></div><br/><div class="children"><div class="content">sure failover is recommended if you have HA commitments</div><br/></div></div></div></div><div id="41386590" class="c"><input type="checkbox" id="c-41386590" checked=""/><div class="controls bullet"><span class="by">mr_toad</span><span>|</span><a href="#41386160">parent</a><span>|</span><a href="#41386602">prev</a><span>|</span><a href="#41386541">next</a><span>|</span><label class="collapse" for="c-41386590">[-]</label><label class="expand" for="c-41386590">[5 more]</label></div><br/><div class="children"><div class="content">Stack overflow absolutely had load balancers, and 9 web servers, and Redis caches.  They also use 4 SQL servers, so not entirely vertical either.  And they were only serving 500 requests a second on average (peak was probably higher).</div><br/><div id="41387319" class="c"><input type="checkbox" id="c-41387319" checked=""/><div class="controls bullet"><span class="by">pajeets</span><span>|</span><a href="#41386160">root</a><span>|</span><a href="#41386590">parent</a><span>|</span><a href="#41386541">next</a><span>|</span><label class="collapse" for="c-41387319">[-]</label><label class="expand" for="c-41387319">[4 more]</label></div><br/><div class="children"><div class="content">was it? i read it was a huge ram server</div><br/><div id="41387651" class="c"><input type="checkbox" id="c-41387651" checked=""/><div class="controls bullet"><span class="by">mr_toad</span><span>|</span><a href="#41386160">root</a><span>|</span><a href="#41387319">parent</a><span>|</span><a href="#41388600">next</a><span>|</span><label class="collapse" for="c-41387651">[-]</label><label class="expand" for="c-41387651">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;stackexchange.com&#x2F;performance" rel="nofollow">https:&#x2F;&#x2F;stackexchange.com&#x2F;performance</a></div><br/><div id="41387891" class="c"><input type="checkbox" id="c-41387891" checked=""/><div class="controls bullet"><span class="by">DoctorOW</span><span>|</span><a href="#41386160">root</a><span>|</span><a href="#41387651">parent</a><span>|</span><a href="#41388600">next</a><span>|</span><label class="collapse" for="c-41387891">[-]</label><label class="expand" for="c-41387891">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a primary and backup server for Stackoverflow and a primary&#x2F;backup for SE. But they each have the full dataset for their sites, not actual horizontal scaling. Also that page is just a static marketing tool, not very representative of their current stack. See: <a href="https:&#x2F;&#x2F;meta.stackexchange.com&#x2F;questions&#x2F;374585&#x2F;is-the-stack-exchange-performance-page-up-to-date" rel="nofollow">https:&#x2F;&#x2F;meta.stackexchange.com&#x2F;questions&#x2F;374585&#x2F;is-the-stack...</a></div><br/></div></div></div></div><div id="41388600" class="c"><input type="checkbox" id="c-41388600" checked=""/><div class="controls bullet"><span class="by">zo1</span><span>|</span><a href="#41386160">root</a><span>|</span><a href="#41387319">parent</a><span>|</span><a href="#41387651">prev</a><span>|</span><a href="#41386541">next</a><span>|</span><label class="collapse" for="c-41388600">[-]</label><label class="expand" for="c-41388600">[1 more]</label></div><br/><div class="children"><div class="content">The details of their architecture is documented in a series of blog posts:<p><a href="https:&#x2F;&#x2F;nickcraver.com&#x2F;blog&#x2F;2016&#x2F;02&#x2F;03&#x2F;stack-overflow-a-technical-deconstruction&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nickcraver.com&#x2F;blog&#x2F;2016&#x2F;02&#x2F;03&#x2F;stack-overflow-a-tech...</a><p>I get what you&#x27;re saying, they didn&#x27;t do dynamic and &quot;wild&quot; horizontal scaling, they focused more on having an optimal architecture with beefy &quot;vertically scaled&quot; servers.<p>Very much something we should focus on. These days horizontal scaling, microservices, kubernetes, and just generally &quot;throwing compute&quot; at the problem is the lazy answer to scaling issues.</div><br/></div></div></div></div></div></div><div id="41386541" class="c"><input type="checkbox" id="c-41386541" checked=""/><div class="controls bullet"><span class="by">seabrookmx</span><span>|</span><a href="#41386160">parent</a><span>|</span><a href="#41386590">prev</a><span>|</span><a href="#41387366">next</a><span>|</span><label class="collapse" for="c-41386541">[-]</label><label class="expand" for="c-41386541">[3 more]</label></div><br/><div class="children"><div class="content">&gt; One server<p>What happens if this server dies?</div><br/><div id="41386894" class="c"><input type="checkbox" id="c-41386894" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#41386160">root</a><span>|</span><a href="#41386541">parent</a><span>|</span><a href="#41387311">next</a><span>|</span><label class="collapse" for="c-41386894">[-]</label><label class="expand" for="c-41386894">[1 more]</label></div><br/><div class="children"><div class="content">Then your service is offline until you fix it. For many services a completely acceptable thing to happen once in a blue moon<p>Most would probably get two servers with a simple failover strategy. But on the other hand servers rarely die. At the scale of a datacenter it happens often, but if you have like six of them, buy server grade stuff and replace them every 3-5 years chances you won&#x27;t experience any hardware issues</div><br/></div></div><div id="41387311" class="c"><input type="checkbox" id="c-41387311" checked=""/><div class="controls bullet"><span class="by">pajeets</span><span>|</span><a href="#41386160">root</a><span>|</span><a href="#41386541">parent</a><span>|</span><a href="#41386894">prev</a><span>|</span><a href="#41387366">next</a><span>|</span><label class="collapse" for="c-41387311">[-]</label><label class="expand" for="c-41387311">[1 more]</label></div><br/><div class="children"><div class="content">if you cant risk this rarity then get a failover server with equal specs<p>maybe add another for good measure....if the biz insurance needs extreme HA then absolutely have multiple failover<p>my point is you arent doing extreme orchestration or routing<p>throw a cloudflare ddos protection too</div><br/></div></div></div></div><div id="41387366" class="c"><input type="checkbox" id="c-41387366" checked=""/><div class="controls bullet"><span class="by">jamil7</span><span>|</span><a href="#41386160">parent</a><span>|</span><a href="#41386541">prev</a><span>|</span><a href="#41388574">next</a><span>|</span><label class="collapse" for="c-41387366">[-]</label><label class="expand" for="c-41387366">[1 more]</label></div><br/><div class="children"><div class="content">Our backend at work does use a read replica purely for websockets. I always wondered if it was overkill, I’m not a backend developer, though.</div><br/></div></div></div></div><div id="41388574" class="c"><input type="checkbox" id="c-41388574" checked=""/><div class="controls bullet"><span class="by">teleforce</span><span>|</span><a href="#41386160">prev</a><span>|</span><a href="#41386785">next</a><span>|</span><label class="collapse" for="c-41388574">[-]</label><label class="expand" for="c-41388574">[1 more]</label></div><br/><div class="children"><div class="content">Please check this excellent book by former Microsoft and Groupon engineer on scaling Rails and Postgres:<p>[1] High Performance PostgreSQL for Rails Reliable, Scalable, Maintainable Database Applications by Andrew Atkinson:<p><a href="https:&#x2F;&#x2F;pragprog.com&#x2F;titles&#x2F;aapsql&#x2F;high-performance-postgresql-for-rails&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pragprog.com&#x2F;titles&#x2F;aapsql&#x2F;high-performance-postgres...</a></div><br/></div></div><div id="41386785" class="c"><input type="checkbox" id="c-41386785" checked=""/><div class="controls bullet"><span class="by">giovannibonetti</span><span>|</span><a href="#41388574">prev</a><span>|</span><a href="#41387528">next</a><span>|</span><label class="collapse" for="c-41386785">[-]</label><label class="expand" for="c-41386785">[2 more]</label></div><br/><div class="children"><div class="content">What a small world. Earlier today I got tagged in a PR [1] where Andrew became the maintainer of a Ruby gem related to database migrations. Good to know he is involved in multiple projects in this space.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;lfittl&#x2F;activerecord-clean-db-structure&#x2F;issues&#x2F;33">https:&#x2F;&#x2F;github.com&#x2F;lfittl&#x2F;activerecord-clean-db-structure&#x2F;is...</a></div><br/><div id="41386881" class="c"><input type="checkbox" id="c-41386881" checked=""/><div class="controls bullet"><span class="by">andatki</span><span>|</span><a href="#41386785">parent</a><span>|</span><a href="#41387528">next</a><span>|</span><label class="collapse" for="c-41386881">[-]</label><label class="expand" for="c-41386881">[1 more]</label></div><br/><div class="children"><div class="content">Hi there! That&#x27;s funny! This interview and those gem updates were unrelated. However both are part of the sweet spot for me of education, advocacy, and technical solutions for PostgreSQL and Ruby on Rails apps.<p>I hope you’re able to check out the podcast episode and enjoy it. Thanks for weighing in within the gem comments, and for commenting here on this connection. :)</div><br/></div></div></div></div><div id="41387528" class="c"><input type="checkbox" id="c-41387528" checked=""/><div class="controls bullet"><span class="by">benwilber0</span><span>|</span><a href="#41386785">prev</a><span>|</span><a href="#41387232">next</a><span>|</span><label class="collapse" for="c-41387528">[-]</label><label class="expand" for="c-41387528">[7 more]</label></div><br/><div class="children"><div class="content">Postgres can scale to millions of users, but Rails definitely can&#x27;t.  Unless you&#x27;re prepared to spend a ton of money.</div><br/><div id="41387632" class="c"><input type="checkbox" id="c-41387632" checked=""/><div class="controls bullet"><span class="by">petcat</span><span>|</span><a href="#41387528">parent</a><span>|</span><a href="#41387232">next</a><span>|</span><label class="collapse" for="c-41387632">[-]</label><label class="expand" for="c-41387632">[6 more]</label></div><br/><div class="children"><div class="content">For real.  Show me a company that has scaled RoR or Django to 1 million concurrent users without blowing $250,000&#x2F;month on their AWS bill.  I&#x27;ve worked at unicorn companies trying to do exactly that.<p>Their baseline was 800 instances of the Rails app...lol.<p>I&#x27;m not going to name-names (you&#x27;ve heard of them) ... but this is a company that had to invent an entirely new and novel deployment process in order to get new code onto the massive beast of Rails servers within a finite amount of time.</div><br/><div id="41388639" class="c"><input type="checkbox" id="c-41388639" checked=""/><div class="controls bullet"><span class="by">danmaz74</span><span>|</span><a href="#41387528">root</a><span>|</span><a href="#41387632">parent</a><span>|</span><a href="#41388471">next</a><span>|</span><label class="collapse" for="c-41388639">[-]</label><label class="expand" for="c-41388639">[1 more]</label></div><br/><div class="children"><div class="content">&quot;without blowing $250,000&#x2F;month on their AWS bill&quot;. The point is that you don&#x27;t need AWS for this! You can use Docker to configure <i>much</i>, <i>much</i> cheaper&#x2F;faster physical servers from Hetzner or similar with super-simple automated failover, and you absolutely don&#x27;t need an expensive dedicated OPS team for that for this kind of simple deployments, as I read so often here on HN.<p>You might get surprised as how far you can go with the KISS approach with modern hardware and open source tools.</div><br/></div></div><div id="41388471" class="c"><input type="checkbox" id="c-41388471" checked=""/><div class="controls bullet"><span class="by">hw</span><span>|</span><a href="#41387528">root</a><span>|</span><a href="#41387632">parent</a><span>|</span><a href="#41388639">prev</a><span>|</span><a href="#41387883">next</a><span>|</span><label class="collapse" for="c-41388471">[-]</label><label class="expand" for="c-41388471">[1 more]</label></div><br/><div class="children"><div class="content">“Rails can’t scale” is so 10 years ago. It’s often other things like DB queries or network I&#x2F;O that tend to be bottlenecks, or you have a huge Rails monolith that has a large memory footprint, or an application that isn’t well architected or optimized.</div><br/></div></div><div id="41387883" class="c"><input type="checkbox" id="c-41387883" checked=""/><div class="controls bullet"><span class="by">loktarogar</span><span>|</span><a href="#41387528">root</a><span>|</span><a href="#41387632">parent</a><span>|</span><a href="#41388471">prev</a><span>|</span><a href="#41388346">next</a><span>|</span><label class="collapse" for="c-41387883">[-]</label><label class="expand" for="c-41387883">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve scaled a single rails server to 50k concurrent, and so if Rails is the theoretical bottleneck there, and we base it off scaling my meager efforts, that&#x27;s only 20 servers for 1 mil concurrent, or around $1000&#x2F;mo at the price point I was paying (heroku).<p>Rails these days isn&#x27;t the top of the speed meters but it&#x27;s not that slow either.</div><br/><div id="41388048" class="c"><input type="checkbox" id="c-41388048" checked=""/><div class="controls bullet"><span class="by">petcat</span><span>|</span><a href="#41387528">root</a><span>|</span><a href="#41387883">parent</a><span>|</span><a href="#41388346">next</a><span>|</span><label class="collapse" for="c-41388048">[-]</label><label class="expand" for="c-41388048">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like you made a nice, tight little Rails app.  50,000 concurrent?  Oh man, I wish.</div><br/></div></div></div></div><div id="41388346" class="c"><input type="checkbox" id="c-41388346" checked=""/><div class="controls bullet"><span class="by">ainiriand</span><span>|</span><a href="#41387528">root</a><span>|</span><a href="#41387632">parent</a><span>|</span><a href="#41387883">prev</a><span>|</span><a href="#41387232">next</a><span>|</span><label class="collapse" for="c-41388346">[-]</label><label class="expand" for="c-41388346">[1 more]</label></div><br/><div class="children"><div class="content">We use 5 ec2 instances to serve around 32 million requests per day on PHP, all under 100ms. It is not the language.</div><br/></div></div></div></div></div></div><div id="41386485" class="c"><input type="checkbox" id="c-41386485" checked=""/><div class="controls bullet"><span class="by">djaouen</span><span>|</span><a href="#41387506">prev</a><span>|</span><a href="#41388272">next</a><span>|</span><label class="collapse" for="c-41386485">[-]</label><label class="expand" for="c-41386485">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand why you wouldn&#x27;t just use Elixir&#x2F;Phoenix if you need to scale?</div><br/><div id="41387293" class="c"><input type="checkbox" id="c-41387293" checked=""/><div class="controls bullet"><span class="by">foundart</span><span>|</span><a href="#41386485">parent</a><span>|</span><a href="#41386546">next</a><span>|</span><label class="collapse" for="c-41387293">[-]</label><label class="expand" for="c-41387293">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps because you need to scale quickly and already have a large Rails app that would take a long time to recreate in another language and framework.</div><br/></div></div><div id="41386546" class="c"><input type="checkbox" id="c-41386546" checked=""/><div class="controls bullet"><span class="by">seabrookmx</span><span>|</span><a href="#41386485">parent</a><span>|</span><a href="#41387293">prev</a><span>|</span><a href="#41388272">next</a><span>|</span><label class="collapse" for="c-41386546">[-]</label><label class="expand" for="c-41386546">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand why you wouldn&#x27;t use &lt;compiled language that&#x27;s faster than the BEAM&gt; if you need to scale?<p>&#x2F;s</div><br/><div id="41386563" class="c"><input type="checkbox" id="c-41386563" checked=""/><div class="controls bullet"><span class="by">djaouen</span><span>|</span><a href="#41386485">root</a><span>|</span><a href="#41386546">parent</a><span>|</span><a href="#41388272">next</a><span>|</span><label class="collapse" for="c-41386563">[-]</label><label class="expand" for="c-41386563">[1 more]</label></div><br/><div class="children"><div class="content">I mean, you could, but you&#x27;d be missing out on the Rails-esque nature of Elixir&#x2F;Phoenix.</div><br/></div></div></div></div></div></div><div id="41388272" class="c"><input type="checkbox" id="c-41388272" checked=""/><div class="controls bullet"><span class="by">datadeft</span><span>|</span><a href="#41386485">prev</a><span>|</span><label class="collapse" for="c-41388272">[-]</label><label class="expand" for="c-41388272">[3 more]</label></div><br/><div class="children"><div class="content">Scaling a non-scalabe by default framework that should have been few services written in a performance first language at a billion+ USD company.<p>I am not sure why are we boliling the oceans for the sake of a language like Ruby and a framework like Rails. I love those to death but Amazons approach is much better (or it used to be): you can&#x27;t make a service for 10.000+ users in anything else than: C++, Java (probably Rust as well nowadays).<p>For millions of users the CPU cost difference probably justifies the rewrite cost.</div><br/><div id="41388652" class="c"><input type="checkbox" id="c-41388652" checked=""/><div class="controls bullet"><span class="by">danmaz74</span><span>|</span><a href="#41388272">parent</a><span>|</span><a href="#41388337">next</a><span>|</span><label class="collapse" for="c-41388652">[-]</label><label class="expand" for="c-41388652">[1 more]</label></div><br/><div class="children"><div class="content">&quot;For millions of users the CPU cost difference probably justifies the rewrite cost.&quot; This is only true if you have expensive computations done in Ruby or Python or similar, which is very rarely the case.</div><br/></div></div><div id="41388337" class="c"><input type="checkbox" id="c-41388337" checked=""/><div class="controls bullet"><span class="by">ainiriand</span><span>|</span><a href="#41388272">parent</a><span>|</span><a href="#41388652">prev</a><span>|</span><label class="collapse" for="c-41388337">[-]</label><label class="expand" for="c-41388337">[1 more]</label></div><br/><div class="children"><div class="content">You really do not know what you are talking about, it is not about the language, like it was repeated in this forum many many times already. We serve an application in PHP to thousands of users per second in less than 100ms constantly.</div><br/></div></div></div></div></div></div></div></div></div></body></html>