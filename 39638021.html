<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709888451440" as="style"/><link rel="stylesheet" href="styles.css?v=1709888451440"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://unix.stackexchange.com/questions/335648/why-does-the-reset-command-include-a-delay">Why does the `reset` command include a delay? (2017)</a> <span class="domain">(<a href="https://unix.stackexchange.com">unix.stackexchange.com</a>)</span></div><div class="subtext"><span>eklitzke</span> | <span>44 comments</span></div><br/><div><div id="39639208" class="c"><input type="checkbox" id="c-39639208" checked=""/><div class="controls bullet"><span class="by">aumerle</span><span>|</span><a href="#39639216">next</a><span>|</span><label class="collapse" for="c-39639208">[-]</label><label class="expand" for="c-39639208">[1 more]</label></div><br/><div class="children"><div class="content">To workaround it add the following to your shell&#x27;s rc file:<p>function reset { printf &#x27;\e]\e\\\ec&#x27; }<p>Uses the VT100 RIS escape code to ask the terminal to reset itself. But first it send an empty OSC escape to reset the terminals VT parser back to normal mode, so that the RIS escape code is parsed correctly. No need to depend on any external utilities like tput or the reset binary. This should work with any halfway decent terminal emulator.</div><br/></div></div><div id="39638337" class="c"><input type="checkbox" id="c-39638337" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39639216">prev</a><span>|</span><a href="#39638812">next</a><span>|</span><label class="collapse" for="c-39638337">[-]</label><label class="expand" for="c-39638337">[25 more]</label></div><br/><div class="children"><div class="content">I love the &quot;It&#x27;s harmless with a terminal emulator&quot;. I (obviously) get what they&#x27;re saying, but you&#x27;d think making millions of people waste 3 seconds of their lives every time would be considered at least a modicum of harm.</div><br/><div id="39638572" class="c"><input type="checkbox" id="c-39638572" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#39638337">parent</a><span>|</span><a href="#39638812">next</a><span>|</span><label class="collapse" for="c-39638572">[-]</label><label class="expand" for="c-39638572">[24 more]</label></div><br/><div class="children"><div class="content">That’s a touch exaggerative don’t you think?<p>reset wouldn’t be used used by millions of people and most of
those who do use wouldn’t be using it regularly either.<p>reset should be a last resort. If you need to use it then something else has gone wrong and <i>thats</i> what needs to be fixed.<p>I’m all for modernising our terminal but in this instance we are talking about a last resort command taking 3 seconds longer than needed just in case some of some edge case scenario occurs. So 3 seconds is definitely not harmful.</div><br/><div id="39638648" class="c"><input type="checkbox" id="c-39638648" checked=""/><div class="controls bullet"><span class="by">mhw</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638572">parent</a><span>|</span><a href="#39638659">next</a><span>|</span><label class="collapse" for="c-39638648">[-]</label><label class="expand" for="c-39638648">[1 more]</label></div><br/><div class="children"><div class="content">&gt; sleep(1);       &#x2F;* let terminal settle down *&#x2F;<p>&gt; making millions of people waste 3 seconds<p>&gt; That&#x27;s a touch exaggerative don&#x27;t you think?<p>Literally!</div><br/></div></div><div id="39638659" class="c"><input type="checkbox" id="c-39638659" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638572">parent</a><span>|</span><a href="#39638648">prev</a><span>|</span><a href="#39638652">next</a><span>|</span><label class="collapse" for="c-39638659">[-]</label><label class="expand" for="c-39638659">[17 more]</label></div><br/><div class="children"><div class="content">&gt; reset should be a last resort. If you need to use it then something else has gone wrong and <i>thats</i> what needs to be fixed.<p>Er, <i>my</i> comment was exaggerative? (edit: fixed typo)<p>I use reset all the time, it&#x27;s not &quot;last resort&quot; by any means. It... clears the screen and scrollback buffer. If you&#x27;re the kind of person who keeps 150 tabs open then I guess I can see why you wouldn&#x27;t see the value in cleaning the screen up frequently, but clearing the terminal is a pretty frequent and useful operation for other folks.</div><br/><div id="39639146" class="c"><input type="checkbox" id="c-39639146" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638659">parent</a><span>|</span><a href="#39638688">next</a><span>|</span><label class="collapse" for="c-39639146">[-]</label><label class="expand" for="c-39639146">[1 more]</label></div><br/><div class="children"><div class="content">If you need reset(1) to clear the screen and scrollback buffer all the time (it shouldn’t clear the buffer btw, don’t know why you think it does if you really do it all the time), consider using your terminal emulator’s native keyboard shortcut, it’s faster to type, faster to run, you can do it at any time without the shell yielding control back to you, and it doesn’t pollute the shell history.<p>If your terminal emulator doesn’t even have that, I suggest switching to a better one.<p>I hope you realize you’re doing something really suboptimal here.<p>Edit: Saw your other comment and apparently you don’t even use reset(1), just your own function (which is still suboptimal like I said). WTF is with all the arguing then.</div><br/></div></div><div id="39638688" class="c"><input type="checkbox" id="c-39638688" checked=""/><div class="controls bullet"><span class="by">rezonant</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638659">parent</a><span>|</span><a href="#39639146">prev</a><span>|</span><a href="#39638689">next</a><span>|</span><label class="collapse" for="c-39638688">[-]</label><label class="expand" for="c-39638688">[3 more]</label></div><br/><div class="children"><div class="content">Fwiw parent comment currently says exaggerative, not aggressive.<p>Why wouldn&#x27;t you use &quot;clear&quot; for that, or Ctrl+L? &quot;reset&quot; does a lot more, you use it when you&#x27;ve accidentally written a binary to your terminal and triggered a bunch of terminal modes.<p>I guess clear wouldn&#x27;t clear the scroll buffer, is that the main reason?</div><br/><div id="39638755" class="c"><input type="checkbox" id="c-39638755" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638688">parent</a><span>|</span><a href="#39638784">prev</a><span>|</span><a href="#39638689">next</a><span>|</span><label class="collapse" for="c-39638755">[-]</label><label class="expand" for="c-39638755">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I guess clear wouldn&#x27;t clear the scroll buffer, is that the main reason?<p>Yes. See sibling replies.</div><br/></div></div></div></div><div id="39638689" class="c"><input type="checkbox" id="c-39638689" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638659">parent</a><span>|</span><a href="#39638688">prev</a><span>|</span><a href="#39638684">next</a><span>|</span><label class="collapse" for="c-39638689">[-]</label><label class="expand" for="c-39638689">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Er, my comment was aggressive?<p>No it wasn’t. But I also said exaggerative not aggressive.<p>&gt; I use reset all the time, it&#x27;s not &quot;last resort&quot; by any means. It clears the screen.<p>That’s what ‘clear’ is for.<p>Reset is intended to do more than just clear the screen. It’s intended to reset, as the name suggests, the entire terminal. The idea being it’s got itself into some kind of unknown state.<p>There are hot keys to clear your screen too, such as ctrl+L (works in most shells) plus your terminal emulator will likely have its own hot keys too. So fewer button presses and even quicker for you.</div><br/><div id="39638714" class="c"><input type="checkbox" id="c-39638714" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638689">parent</a><span>|</span><a href="#39638684">next</a><span>|</span><label class="collapse" for="c-39638714">[-]</label><label class="expand" for="c-39638714">[5 more]</label></div><br/><div class="children"><div class="content">Clearing <i>just</i> the screen without the scrollback history is pretty damn useless and in fact outright frustrating. It boggles my mind people read &quot;clear the screen&quot; and think &quot;oh, surely he doesn&#x27;t want to clear the scrollback buffer&quot;. You have to realize, a command for that is so close to useless it doesn&#x27;t even exist as a separate operation on Windows. Over there, cls (&quot;CLear Screen&quot;) does <i>both</i> and is incredibly handy. And on the <i>incredibly</i> rare occasions when I actively want to keep the scrollback buffer (read: like once every 2 months, tops?), I can already do that much more intuitively by scrolling down or holding Enter for 3 seconds. I don&#x27;t need a separate command for it any more than I need a separate command to scroll down.</div><br/><div id="39638799" class="c"><input type="checkbox" id="c-39638799" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638714">parent</a><span>|</span><a href="#39638684">next</a><span>|</span><label class="collapse" for="c-39638799">[-]</label><label class="expand" for="c-39638799">[4 more]</label></div><br/><div class="children"><div class="content">`reset` doesn&#x27;t even clear the scrollback buffer on all terminal emulators. In fact there&#x27;s no formal specification for how scrollback buffers should behave because they&#x27;re a modern incantation. Take iTerm2, this is what happens when I run `reset` and then scroll up:<p><pre><code>    lmorg ~ % reset
    
    lmorg ~ % reset
    
    lmorg ~ % which reset
    &#x2F;usr&#x2F;bin&#x2F;reset
    lmorg ~ %
</code></pre>
You might find the ANSI escape code for reset, {ESC}c, does what you need:<p><pre><code>    function reset {
        printf &#x27;\033c&#x27;
    }
</code></pre>
The above code should work on sh, Bash, Zsh, Oil and Murex.</div><br/><div id="39638816" class="c"><input type="checkbox" id="c-39638816" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638799">parent</a><span>|</span><a href="#39638684">next</a><span>|</span><label class="collapse" for="c-39638816">[-]</label><label class="expand" for="c-39638816">[3 more]</label></div><br/><div class="children"><div class="content">&gt; You might find the ANSI escape code for reset, {ESC}c, does what you need:<p>See <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39638794">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39638794</a></div><br/><div id="39639058" class="c"><input type="checkbox" id="c-39639058" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638816">parent</a><span>|</span><a href="#39638684">next</a><span>|</span><label class="collapse" for="c-39639058">[-]</label><label class="expand" for="c-39639058">[2 more]</label></div><br/><div class="children"><div class="content">If you&#x27;ve already got a working solution then I don&#x27;t see why this is problem. The way you&#x27;ve conversed in this thread sounds like it&#x27;s a daily annoyance for you.</div><br/><div id="39639080" class="c"><input type="checkbox" id="c-39639080" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39639058">parent</a><span>|</span><a href="#39638684">next</a><span>|</span><label class="collapse" for="c-39639080">[-]</label><label class="expand" for="c-39639080">[1 more]</label></div><br/><div class="children"><div class="content">It <i>was</i> one for several years, until I solved it like this. It was such an unnecessary waste of my time. And it would not have taken nearly that long if everyone&#x27;s response to &quot;how to clear the terminal on Linux&quot; on Google wasn&#x27;t &quot;clear&quot; or &quot;Ctrl+L&quot;.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39638684" class="c"><input type="checkbox" id="c-39638684" checked=""/><div class="controls bullet"><span class="by">sidneythekidney</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638659">parent</a><span>|</span><a href="#39638689">prev</a><span>|</span><a href="#39638652">next</a><span>|</span><label class="collapse" for="c-39638684">[-]</label><label class="expand" for="c-39638684">[6 more]</label></div><br/><div class="children"><div class="content">If you only need to clear the screen, you may want to check out clear(1).</div><br/><div id="39638686" class="c"><input type="checkbox" id="c-39638686" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638684">parent</a><span>|</span><a href="#39638652">next</a><span>|</span><label class="collapse" for="c-39638686">[-]</label><label class="expand" for="c-39638686">[5 more]</label></div><br/><div class="children"><div class="content">I literally edited my comment just before you said this because I suddenly realized someone was going to say this. No, the point is never just the &quot;screen&quot;. The point is the whole buffer including the screen. Clearing just the screen is pretty useless to me, I might as well just scroll down or hold Enter for 3 seconds.</div><br/><div id="39638797" class="c"><input type="checkbox" id="c-39638797" checked=""/><div class="controls bullet"><span class="by">Ennea</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638686">parent</a><span>|</span><a href="#39638777">next</a><span>|</span><label class="collapse" for="c-39638797">[-]</label><label class="expand" for="c-39638797">[2 more]</label></div><br/><div class="children"><div class="content">My terminal emulator of choice, WezTerm, has this feature built in [1], so there&#x27;s no need for using `reset`. Perhaps your terminal emulator has something like it, too?<p>[1] <a href="https:&#x2F;&#x2F;wezfurlong.org&#x2F;wezterm&#x2F;config&#x2F;lua&#x2F;keyassignment&#x2F;ClearScrollback.html" rel="nofollow">https:&#x2F;&#x2F;wezfurlong.org&#x2F;wezterm&#x2F;config&#x2F;lua&#x2F;keyassignment&#x2F;Clea...</a></div><br/><div id="39638809" class="c"><input type="checkbox" id="c-39638809" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638797">parent</a><span>|</span><a href="#39638777">next</a><span>|</span><label class="collapse" for="c-39638809">[-]</label><label class="expand" for="c-39638809">[1 more]</label></div><br/><div class="children"><div class="content">Why in the world would I do that when I can just redefine reset and have it work from every terminal?!</div><br/></div></div></div></div><div id="39638777" class="c"><input type="checkbox" id="c-39638777" checked=""/><div class="controls bullet"><span class="by">sidneythekidney</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638686">parent</a><span>|</span><a href="#39638797">prev</a><span>|</span><a href="#39638652">next</a><span>|</span><label class="collapse" for="c-39638777">[-]</label><label class="expand" for="c-39638777">[2 more]</label></div><br/><div class="children"><div class="content">Hah :)<p>You could try echo -ne &#x27;\ec&#x27; or echo -ne &#x27;\033c&#x27;. Or this from bash&#x2F;readline:<p><pre><code>  clear-display (M-C-l)
          Clear  the  screen  and,  if possible, the terminal&#x27;s scrollback buffer, then redraw the current line, leaving the current line at the top of the screen.
</code></pre>
But yea, this might depend on terminal as well</div><br/><div id="39638794" class="c"><input type="checkbox" id="c-39638794" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638777">parent</a><span>|</span><a href="#39638652">next</a><span>|</span><label class="collapse" for="c-39638794">[-]</label><label class="expand" for="c-39638794">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m aware, I already have<p><pre><code>  reset() { clear &amp;&amp; printf &#x27;\33c&#x27;; }</code></pre></div><br/></div></div></div></div></div></div></div></div></div></div><div id="39638652" class="c"><input type="checkbox" id="c-39638652" checked=""/><div class="controls bullet"><span class="by">benwaffle</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638572">parent</a><span>|</span><a href="#39638659">prev</a><span>|</span><a href="#39638812">next</a><span>|</span><label class="collapse" for="c-39638652">[-]</label><label class="expand" for="c-39638652">[5 more]</label></div><br/><div class="children"><div class="content">I use it to clear my scrollback buffer. It makes it easier to search any new output.</div><br/><div id="39638667" class="c"><input type="checkbox" id="c-39638667" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638652">parent</a><span>|</span><a href="#39638812">next</a><span>|</span><label class="collapse" for="c-39638667">[-]</label><label class="expand" for="c-39638667">[4 more]</label></div><br/><div class="children"><div class="content">There’s probably a hot key in your terminal emulator to do that. Fewer buttons to press, so even quicker. ;)</div><br/><div id="39638770" class="c"><input type="checkbox" id="c-39638770" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638667">parent</a><span>|</span><a href="#39638812">next</a><span>|</span><label class="collapse" for="c-39638770">[-]</label><label class="expand" for="c-39638770">[3 more]</label></div><br/><div class="children"><div class="content">Sadly there isn&#x27;t on Linux. There is on Mac - Ctrl-K. But for some reason nobody on Linux has realised how useful it is. It&#x27;s actually even better than `reset` because it works at any time.</div><br/><div id="39639025" class="c"><input type="checkbox" id="c-39639025" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638770">parent</a><span>|</span><a href="#39639022">next</a><span>|</span><label class="collapse" for="c-39639025">[-]</label><label class="expand" for="c-39639025">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re conflating SHELL with TERM because the OS has nothing to do with what hot keys your terminal emulator supports (the OS wouldn&#x27;t dictate hot keys available for shells either, but popular Linux distros don&#x27;t tend to default to Zsh like macOS does).<p>A terminal emulator is the software application you use to bring the command prompt up. So a terminal emulator is operating system agnostic.<p>Granted there are some macOS only terms out there like iTerm2 and Apples own Terminal. Just as there are terminals that haven&#x27;t (as far as I&#x27;m aware) been ported to macOS, like xterm. But there&#x27;s plenty of cross platform terminal emulators too, in fact most are cross platform.</div><br/></div></div><div id="39639022" class="c"><input type="checkbox" id="c-39639022" checked=""/><div class="controls bullet"><span class="by">mbork_pl</span><span>|</span><a href="#39638337">root</a><span>|</span><a href="#39638770">parent</a><span>|</span><a href="#39639025">prev</a><span>|</span><a href="#39638812">next</a><span>|</span><label class="collapse" for="c-39639022">[-]</label><label class="expand" for="c-39639022">[1 more]</label></div><br/><div class="children"><div class="content">There is in kitty: <a href="https:&#x2F;&#x2F;sw.kovidgoyal.net&#x2F;kitty&#x2F;conf&#x2F;#shortcut-kitty.Reset-the-terminal" rel="nofollow">https:&#x2F;&#x2F;sw.kovidgoyal.net&#x2F;kitty&#x2F;conf&#x2F;#shortcut-kitty.Reset-t...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39638812" class="c"><input type="checkbox" id="c-39638812" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#39638337">prev</a><span>|</span><a href="#39638321">next</a><span>|</span><label class="collapse" for="c-39638812">[-]</label><label class="expand" for="c-39638812">[1 more]</label></div><br/><div class="children"><div class="content">Back in the day, when the screen&#x2F;terminal was borked, due to <i>cat</i>ting a binary or other reasons, we used to do;<p><pre><code>  stty sane Ctrl-J

</code></pre>
or other variants. It mostly worked. Last resort was to switch the terminal off and on, and&#x2F;or to kill the login shell from another terminal, IIRC.<p>See: man stty</div><br/></div></div><div id="39638321" class="c"><input type="checkbox" id="c-39638321" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#39638812">prev</a><span>|</span><a href="#39638407">next</a><span>|</span><label class="collapse" for="c-39638321">[-]</label><label class="expand" for="c-39638321">[5 more]</label></div><br/><div class="children"><div class="content">&gt;Real (hardware) terminals need that.<p>I wonder who uses real terminals and for what.</div><br/><div id="39638878" class="c"><input type="checkbox" id="c-39638878" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39638321">parent</a><span>|</span><a href="#39638426">next</a><span>|</span><label class="collapse" for="c-39638878">[-]</label><label class="expand" for="c-39638878">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I wonder who uses real terminals and for what.<p>I&#x27;m guessing the same people who believed 1991 was the year of Linux on the desktop.</div><br/></div></div><div id="39638426" class="c"><input type="checkbox" id="c-39638426" checked=""/><div class="controls bullet"><span class="by">bongodongobob</span><span>|</span><a href="#39638321">parent</a><span>|</span><a href="#39638878">prev</a><span>|</span><a href="#39639181">next</a><span>|</span><label class="collapse" for="c-39638426">[-]</label><label class="expand" for="c-39638426">[1 more]</label></div><br/><div class="children"><div class="content">I ran into one about 10 years ago. It was a bespoke diagnostic tool for some industrial machinery. It was only needed for last resort situations to get in via serial and gracefully rescue the HMI from a freeze or sync issue where the machine found itself in an impossible state doing maintenance to prevent having to do a physical lockout and shutdown situation or something like that. Never saw it actually used though as the beast was built before laptops and USB serial adapters were a thing. It was probably collecting dust for a decade before I came across it.</div><br/></div></div><div id="39639181" class="c"><input type="checkbox" id="c-39639181" checked=""/><div class="controls bullet"><span class="by">ssl-3</span><span>|</span><a href="#39638321">parent</a><span>|</span><a href="#39638426">prev</a><span>|</span><a href="#39638523">next</a><span>|</span><label class="collapse" for="c-39639181">[-]</label><label class="expand" for="c-39639181">[1 more]</label></div><br/><div class="children"><div class="content">I used to have some real (hardware) terminals, back in the day when (what we then called) IP Masquerading was still kind of new, Ethernet was still expensive to sensibly implement, and old cheap still-useful PC hardware didn&#x27;t usually exist (and things like freebie &quot;closet laptops&quot; absolutely did not exist at all).<p>It was a bit of a different world back then.  Most of my Internet and general-computing experience happened in a terminal -- whether xterm, 80x25, or a silly high-res BIOS-based text mode set using svgatextmode.  Text-based web browsing with Lynx was still <i>useful</i>, and Pine (email) and tin (usenet) were well-suited to those applications at that time.<p>I had a desktop Linux (or sometimes, FreeBSD) box that I of course did all kinds of stuff with, and at least one remote shell account on a far-away computer to provide continuity, and I also had a couple of DEC VT330 terminals that I scored cheap at the Dayton hamfest.  One was next to my favorite armchair so I could chat on IRC and listen to the stereo in the sweet spot at the same time.  Another was in the bedroom, which I mostly used for reading books and other passive consumption.<p>It all worked well, of course.  There was no reason for it not to work well.  And at a time when the Internet was kind of a weird thing to be involved with at all, and almost always involved exactly one person using one dialup connection in exactly one physical location, I could meander around and do my usual Internet things in a few different locations in the house (thanks, <i>screen</i>!).<p>I didn&#x27;t really build it for multiple users.  But sometimes, the girlfriend would hang out and chat on IRC in one place while I did my own Internet things elsewhere, all on a light-weight 32-bit computer with only a few megabytes of RAM.  It did fine.<p>---<p>But your question was present-tense.  Because life has a way of things, I&#x27;ve sadly lost track of those VT330s.  And your implication is correct:  I haven&#x27;t seen a standalone terminal in the wild for a really, really long time.<p>In the present-tense, I kind of miss the expediency of the interface.  Many of us here use terminal emulators every day, so it may sound like I&#x27;m preaching to the choir, but I mean:  The expedience of the text-based interfaces <i>out in the wild</i>.  It is seemingly as lost as my VT330s are.<p>It used to be that if I needed a set of spark plugs for a car, then I might pop over to Autozone.  The guy behind the counter there would mash in the make&#x2F;model&#x2F;year almost instantly on the terminal&#x27;s keyboard, as if by muscle memory, and almost immediately he&#x27;d be rattling off different options, prices, and features.<p>Nowadays it&#x27;s all web based.  The parts store clerk&#x27;s stupid-fast muscle memory has been replaced by mousing around interactively -- clicking and drooling (and worse: scrolling through stupid HTML dropdowns to find &quot;Toyota,&quot; or &quot;Volvo&quot;) through a website that is very much like the same website I can use from home.  And that website sucks, time-wise, compared to the dumb terminal interface that they used to have muxed back to the home base.<p>(The only advantage I can find to the web interface that has been in place for a quarter of a century now is that it has pictures, but the pictures are often simply wrong.  Bad data is no data, so this is a misfeature.)</div><br/></div></div><div id="39638523" class="c"><input type="checkbox" id="c-39638523" checked=""/><div class="controls bullet"><span class="by">simonjgreen</span><span>|</span><a href="#39638321">parent</a><span>|</span><a href="#39639181">prev</a><span>|</span><a href="#39638407">next</a><span>|</span><label class="collapse" for="c-39638523">[-]</label><label class="expand" for="c-39638523">[1 more]</label></div><br/><div class="children"><div class="content">I’ve seen large scale epos systems in more complex sales environments like furniture or brown goods that use them. All old of course.</div><br/></div></div></div></div><div id="39638407" class="c"><input type="checkbox" id="c-39638407" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#39638321">prev</a><span>|</span><label class="collapse" for="c-39638407">[-]</label><label class="expand" for="c-39638407">[10 more]</label></div><br/><div class="children"><div class="content">&gt;and since there&#x27;s no conventional way to tell the difference (and too hard to determine if some escape sequence might do a hardware-reset), reset assumes your terminal is real.<p>The TERM environmental variable can be used</div><br/><div id="39638492" class="c"><input type="checkbox" id="c-39638492" checked=""/><div class="controls bullet"><span class="by">phone8675309</span><span>|</span><a href="#39638407">parent</a><span>|</span><label class="collapse" for="c-39638492">[-]</label><label class="expand" for="c-39638492">[9 more]</label></div><br/><div class="children"><div class="content">Sure, okay, but there&#x27;s two problems with that:
1) you have to trust the user to get that right, and
2) how do you know it&#x27;s an actual hardware terminal and not a terminal emulator?</div><br/><div id="39639124" class="c"><input type="checkbox" id="c-39639124" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#39638407">root</a><span>|</span><a href="#39638492">parent</a><span>|</span><a href="#39638563">next</a><span>|</span><label class="collapse" for="c-39639124">[-]</label><label class="expand" for="c-39639124">[1 more]</label></div><br/><div class="children"><div class="content">TERM is already used for determining color support. Not sure what terminals do without color support with color escape codes.</div><br/></div></div><div id="39638563" class="c"><input type="checkbox" id="c-39638563" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#39638407">root</a><span>|</span><a href="#39638492">parent</a><span>|</span><a href="#39639124">prev</a><span>|</span><label class="collapse" for="c-39638563">[-]</label><label class="expand" for="c-39638563">[7 more]</label></div><br/><div class="children"><div class="content">1) The user does not set TERM.<p>2) You keep track of a list of what TERM are hardware based that need this delay</div><br/><div id="39638630" class="c"><input type="checkbox" id="c-39638630" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#39638407">root</a><span>|</span><a href="#39638563">parent</a><span>|</span><label class="collapse" for="c-39638630">[-]</label><label class="expand" for="c-39638630">[6 more]</label></div><br/><div class="children"><div class="content">1. It’s just an env var and users frequently do fiddle with it<p>2. That’s great in theory, but in practice a lot of software is written expecting TERM to contain, for example, xterm.<p>The TERM env var is actually worse than HTTP User-Agent for fingerprinting. And for all the same reasons why User-Agent is a hot ball of mess.<p>The way capabilities between different hardware terminals are usually detected is via special interactive ANSI escape codes. But there isn’t currently one to ask if the terminal is hardware or software.</div><br/><div id="39638739" class="c"><input type="checkbox" id="c-39638739" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#39638407">root</a><span>|</span><a href="#39638630">parent</a><span>|</span><a href="#39638795">next</a><span>|</span><label class="collapse" for="c-39638739">[-]</label><label class="expand" for="c-39638739">[3 more]</label></div><br/><div class="children"><div class="content">&gt;It’s just an env var and users frequently do fiddle with it<p>If a user misconfigures what their current terminal is there isn&#x27;t much that can be done.<p>&gt;but in practice a lot of software is written expecting TERM to contain, for example, xterm.<p>It&#x27;s not like the list of new terminals is constantly growing. The list of terminals could be periodically synced if needed.</div><br/><div id="39639213" class="c"><input type="checkbox" id="c-39639213" checked=""/><div class="controls bullet"><span class="by">PennRobotics</span><span>|</span><a href="#39638407">root</a><span>|</span><a href="#39638739">parent</a><span>|</span><a href="#39638867">next</a><span>|</span><label class="collapse" for="c-39639213">[-]</label><label class="expand" for="c-39639213">[1 more]</label></div><br/><div class="children"><div class="content">From my experience, the list of new terminals <i>IS</i> always growing.<p>Wayland? A developer wanting to flex their Rust or Go muscles? Poor Unicode or RTL support? Slow buffer? &quot;I can GPU accelerate the terminal&quot;? Tiling? Dropdown on tilde? Keypress customization? Better cross-platform compatibility? Sixel support? &quot;We&#x27;re a trendy yet ancient mega-corp that now supports open source please use our cloud product&quot;? ... all reasons I&#x27;ve seen a new terminal or three.<p>Last night, I ssh&#x27;d into a server that had a huge TERM list but alacritty was not on it, so I had no dircolors even when using --color=always. The only reason I&#x27;m even using alacritty is due to my last terminal not working well on new hardware.<p>I don&#x27;t have a better solution. Obviously the terminal should self-report its capabilities and everyone writes software respecting those, but that ship has sailed, so we&#x27;re stuck with QWERTY as a keyboard layout (or whatever your country collectively uses; FR, DACH, etc), x86 as an architecture, and TERM as a variable.</div><br/></div></div><div id="39638867" class="c"><input type="checkbox" id="c-39638867" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#39638407">root</a><span>|</span><a href="#39638739">parent</a><span>|</span><a href="#39639213">prev</a><span>|</span><a href="#39638795">next</a><span>|</span><label class="collapse" for="c-39638867">[-]</label><label class="expand" for="c-39638867">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If a user misconfigures what their current terminal is there isn&#x27;t much that can be done.<p>We aren&#x27;t talking about people misconfiguring their terminal. We are talking about application developers abusing the $TERM command to detect terminal functionality rather than using ANSI escape sequences to detect a terminals support. And thus people then need to spoof $TERM strings to retain the same functionality.<p>This is why you often see $KITTY, $MXTERM and other env vars in addition to $TERM.<p>source: I wrote my own terminal emulator. $TERM these days is garbage.<p>&gt; It&#x27;s not like the list of new terminals is constantly growing. The list of terminals could be periodically synced if needed.<p>New terminal emulators do. Plus we already have ANSI escape sequences for detecting terminal functionality and it was purposely designed for hardware terminals in mind. Just doing the kids school run but I can share a link to them when i return</div><br/></div></div></div></div><div id="39638795" class="c"><input type="checkbox" id="c-39638795" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39638407">root</a><span>|</span><a href="#39638630">parent</a><span>|</span><a href="#39638739">prev</a><span>|</span><label class="collapse" for="c-39638795">[-]</label><label class="expand" for="c-39638795">[2 more]</label></div><br/><div class="children"><div class="content">So you&#x27;re advocating inflicting an annoying delay on tens of thousands of people because there might exist one person a) uses ancient hardware and b) uses recent software and c) messes with their TERM environment variable?<p>Ridiculous</div><br/><div id="39638833" class="c"><input type="checkbox" id="c-39638833" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#39638407">root</a><span>|</span><a href="#39638795">parent</a><span>|</span><label class="collapse" for="c-39638833">[-]</label><label class="expand" for="c-39638833">[1 more]</label></div><br/><div class="children"><div class="content">Yes. Because those &quot;tens of thousands&quot; of people have other options available, as has been discussed in this thread.<p>But for people who have physical terminals, which I know is exceedingly small, there is <i>no</i> other option. Hence why the behaviour still exists.<p>If time is your only constraint then use a clear screen hot key or write a function and make it a single char, like the following:<p><pre><code>    function r {
        printf &#x27;\033c&#x27;
    }
</code></pre>
I&#x27;m all for modernising the terminal but in this instance there are already other options that solve your needs better than `reset`.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>