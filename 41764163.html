<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728550878897" as="style"/><link rel="stylesheet" href="styles.css?v=1728550878897"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://zod.dev/">Zod: TypeScript-first schema validation with static type inference</a> <span class="domain">(<a href="https://zod.dev">zod.dev</a>)</span></div><div class="subtext"><span>tosh</span> | <span>130 comments</span></div><br/><div><div id="41791316" class="c"><input type="checkbox" id="c-41791316" checked=""/><div class="controls bullet"><span class="by">steve_adams_86</span><span>|</span><a href="#41790169">next</a><span>|</span><label class="collapse" for="c-41791316">[-]</label><label class="expand" for="c-41791316">[24 more]</label></div><br/><div class="children"><div class="content">I love Zod, but recently I&#x27;ve been converting to Effect&#x27;s Data and Schema modules.<p>Previously I liked a combination of Zod and ts-pattern to create safe, pattern matching-oriented logic around my data. I find Effect is designed far better for this, so far. I&#x27;m enjoying it a lot. The Schema module has a nice convention for expressing validators, and it&#x27;s very composable and flexible: <a href="https:&#x2F;&#x2F;effect.website&#x2F;docs&#x2F;guides&#x2F;schema&#x2F;introduction" rel="nofollow">https:&#x2F;&#x2F;effect.website&#x2F;docs&#x2F;guides&#x2F;schema&#x2F;introduction</a><p>There are also really nice aspects like the interoperability between Schema and Data, allowing you to safely parse data from outside your application boundary then perform safe operations like exhaustively matching on tagged types (essentially discriminated unions): <a href="https:&#x2F;&#x2F;effect.website&#x2F;docs&#x2F;other&#x2F;data-types&#x2F;data#is-and-match" rel="nofollow">https:&#x2F;&#x2F;effect.website&#x2F;docs&#x2F;other&#x2F;data-types&#x2F;data#is-and-mat...</a><p>It feels extremely productive and intuitive once you get the hang of it. I didn&#x27;t expect to like it so much.<p>I think the real power here is that these modules also have full interop with the rest of Effect. Effects are like little lazy loaded logical bits that are all consistent in how they resolve, making it trivial to compose and execute logic. Data and Schema fit into the ecosystem perfectly, making it really easy to compose very resilient, scalable, reliable data pipelines for example. I&#x27;m a convert.<p>Zod is awesome if you don&#x27;t want to adopt Effect wholesale, though.</div><br/><div id="41791501" class="c"><input type="checkbox" id="c-41791501" checked=""/><div class="controls bullet"><span class="by">bjacobso</span><span>|</span><a href="#41791316">parent</a><span>|</span><a href="#41795090">next</a><span>|</span><label class="collapse" for="c-41791501">[-]</label><label class="expand" for="c-41791501">[20 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had a very similar experience, and have been slowly moving from zod and ts-rest to @effect&#x2F;schema and @effect&#x2F;platform&#x2F;HttpApi as well as migration to Effect Match from ts-pattern. There is a learning curve but its a pretty incredible ecosystem once you are in it for a bit.<p>I think the real turning point was typescript 5.5 (May 2024). The creator of typescript personally fixed a bug that unlocked a more natural generator syntax for Effect, which I think unlocks mainstream adoption potential.<p><a href="https:&#x2F;&#x2F;twitter.com&#x2F;MichaelArnaldi&#x2F;status&#x2F;1785061608894451725" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;MichaelArnaldi&#x2F;status&#x2F;178506160889445172...</a>
<a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;pull&#x2F;58337">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;pull&#x2F;58337</a></div><br/><div id="41791545" class="c"><input type="checkbox" id="c-41791545" checked=""/><div class="controls bullet"><span class="by">morbicer</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41791501">parent</a><span>|</span><a href="#41792966">next</a><span>|</span><label class="collapse" for="c-41791545">[-]</label><label class="expand" for="c-41791545">[11 more]</label></div><br/><div class="children"><div class="content">I feel like Effect is today&#x27;s Ramda. So cool but it&#x27;s going to be regretted by you and people coming after you in few years.
Me and my team reverted to more stupid code and we are happier.</div><br/><div id="41795921" class="c"><input type="checkbox" id="c-41795921" checked=""/><div class="controls bullet"><span class="by">hresvelgr</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41791545">parent</a><span>|</span><a href="#41795345">next</a><span>|</span><label class="collapse" for="c-41795921">[-]</label><label class="expand" for="c-41795921">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Me and my team reverted to more stupid code and we are happier.<p>This is 100% how to write more reliable software. We are in the process of reducing our TS dependencies to effectively just express and node-postgres and everything is becoming infinitely easier to manage.</div><br/><div id="41796515" class="c"><input type="checkbox" id="c-41796515" checked=""/><div class="controls bullet"><span class="by">BillyTheKing</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41795921">parent</a><span>|</span><a href="#41795345">next</a><span>|</span><label class="collapse" for="c-41796515">[-]</label><label class="expand" for="c-41796515">[2 more]</label></div><br/><div class="children"><div class="content">Yes, all true - apart from treating errors as values and including them function signatures... That should simply be something every modern language should ship with</div><br/><div id="41796662" class="c"><input type="checkbox" id="c-41796662" checked=""/><div class="controls bullet"><span class="by">Sammi</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41796515">parent</a><span>|</span><a href="#41795345">next</a><span>|</span><label class="collapse" for="c-41796662">[-]</label><label class="expand" for="c-41796662">[1 more]</label></div><br/><div class="children"><div class="content">I have never written any code in Go, but increasingly I am writing my TS in the style I hear Go code is written in. Very procedural, very verbose. All of the fancy indirection you get with coding everything with higher order functions just makes the program impossible to debug later. Procedural style programming lends itself to debugging, and I definitely am so dumb I need to debug my own programs.<p>I may simply be too dumb for lots of fancy functional programming. I can barely understand code when reading one line and statement at a time. Reading functions calling functions calling functions just makes me feel like gravity stopped working and I don&#x27;t know which way is up. My brain too small.</div><br/></div></div></div></div></div></div><div id="41795345" class="c"><input type="checkbox" id="c-41795345" checked=""/><div class="controls bullet"><span class="by">presentation</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41791545">parent</a><span>|</span><a href="#41795921">prev</a><span>|</span><a href="#41792186">next</a><span>|</span><label class="collapse" for="c-41795345">[-]</label><label class="expand" for="c-41795345">[1 more]</label></div><br/><div class="children"><div class="content">My experience with fp-ts and io-ts was that we quickly got to a point where the team was divided into a small group of people usually with postgraduate CS degrees who really understood it, and then everyone else who saw it as black magic and were afraid to touch it.<p>Nowadays I’d rather rely on libraries that don’t require a phd to use them properly.</div><br/></div></div><div id="41792186" class="c"><input type="checkbox" id="c-41792186" checked=""/><div class="controls bullet"><span class="by">steve_adams_86</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41791545">parent</a><span>|</span><a href="#41795345">prev</a><span>|</span><a href="#41793956">next</a><span>|</span><label class="collapse" for="c-41792186">[-]</label><label class="expand" for="c-41792186">[1 more]</label></div><br/><div class="children"><div class="content">I agree in some contexts. Kind of like Rust, I see a place for more durable code that&#x27;s harder to reason about in some cases.<p>I wouldn&#x27;t use Effect for a lot of things. For some things, I&#x27;m very glad to have it. One thing Effect has going for it that Ramda didn&#x27;t is that it&#x27;s much less abstract and it&#x27;s quite a bit more opinionated about some more complex concepts like error handling, concurrency, or scheduling.<p>Kind of like state machines. You shouldn&#x27;t use them for everything. For some things, it&#x27;s a bad idea not to (in my opinion).<p>Then of course subjectivity is a factor here. Some people will never like conventions like Effect, and that&#x27;s fine too. Just write what feels right.</div><br/></div></div><div id="41793956" class="c"><input type="checkbox" id="c-41793956" checked=""/><div class="controls bullet"><span class="by">Stoids</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41791545">parent</a><span>|</span><a href="#41792186">prev</a><span>|</span><a href="#41793752">next</a><span>|</span><label class="collapse" for="c-41793956">[-]</label><label class="expand" for="c-41793956">[1 more]</label></div><br/><div class="children"><div class="content">I think going all-in on Effect in its current state is not something I&#x27;d do. However there&#x27;s a subset of its functionality that I&#x27;m currently replicating with a bunch of different libraries: ts-pattern, zod, some lightweight result &#x2F; option wrapper like ts-belt, etc. Pretty much trying to pretend I&#x27;m writing ML &#x2F; OCaml. Having those all in one package is quite convenient. Add in TypeScript&#x27;s the much needed story around retry &#x2F; observability &#x2F; error handling—I see why people lean into it.<p>Having experience with ZIO &#x2F; FP in Scala, I&#x27;m a bit biased in seeing the value of Effect systems as a whole, but taking on the burden of explaining that mental model to team members and future maintainers is a big cost for most teams.</div><br/></div></div><div id="41793752" class="c"><input type="checkbox" id="c-41793752" checked=""/><div class="controls bullet"><span class="by">k__</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41791545">parent</a><span>|</span><a href="#41793956">prev</a><span>|</span><a href="#41794405">next</a><span>|</span><label class="collapse" for="c-41793752">[-]</label><label class="expand" for="c-41793752">[1 more]</label></div><br/><div class="children"><div class="content">Yes it&#x27;s quite sad.<p>I liked the idea of Ramda until I saw code bases that where using it for everything.<p>I&#x27;m doing JS for over a decade now and I couldn&#x27;t understand a thing.</div><br/></div></div><div id="41794405" class="c"><input type="checkbox" id="c-41794405" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41791545">parent</a><span>|</span><a href="#41793752">prev</a><span>|</span><a href="#41791565">next</a><span>|</span><label class="collapse" for="c-41794405">[-]</label><label class="expand" for="c-41794405">[2 more]</label></div><br/><div class="children"><div class="content">Effect is not only much easier to get productive on than Ramda, but it provides an entire ecosystem.<p>Our team is full effect from two years and juniors can pick it and start working on it with ease.</div><br/><div id="41795519" class="c"><input type="checkbox" id="c-41795519" checked=""/><div class="controls bullet"><span class="by">steve_adams_86</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41794405">parent</a><span>|</span><a href="#41791565">next</a><span>|</span><label class="collapse" for="c-41795519">[-]</label><label class="expand" for="c-41795519">[1 more]</label></div><br/><div class="children"><div class="content">Having references to work from is essential. Their documentation doesn’t do as good of a job demonstrating that as it could, in my opinion.</div><br/></div></div></div></div><div id="41791565" class="c"><input type="checkbox" id="c-41791565" checked=""/><div class="controls bullet"><span class="by">bjacobso</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41791545">parent</a><span>|</span><a href="#41794405">prev</a><span>|</span><a href="#41792966">next</a><span>|</span><label class="collapse" for="c-41791565">[-]</label><label class="expand" for="c-41791565">[1 more]</label></div><br/><div class="children"><div class="content">that is certainly a possibility</div><br/></div></div></div></div><div id="41792966" class="c"><input type="checkbox" id="c-41792966" checked=""/><div class="controls bullet"><span class="by">dimal</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41791501">parent</a><span>|</span><a href="#41791545">prev</a><span>|</span><a href="#41792257">next</a><span>|</span><label class="collapse" for="c-41792966">[-]</label><label class="expand" for="c-41792966">[7 more]</label></div><br/><div class="children"><div class="content">How did you find learning Effect? The sales pitch sounds great, but when I went through the docs it seemed pretty confusing to me. I’m sure there are reasons for the everything but I couldn’t grok it. In particular, I’m thinking of the Express integration example.[0] I look at that and think, I need all that just to create a server and a route? What’s the benefit there? I’m hesitant to buy into the ecosystem after looking at that. I want to like it, though.<p>[0] <a href="https:&#x2F;&#x2F;effect.website&#x2F;docs&#x2F;integrations&#x2F;express" rel="nofollow">https:&#x2F;&#x2F;effect.website&#x2F;docs&#x2F;integrations&#x2F;express</a></div><br/><div id="41793764" class="c"><input type="checkbox" id="c-41793764" checked=""/><div class="controls bullet"><span class="by">obeavs</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41792966">parent</a><span>|</span><a href="#41793246">next</a><span>|</span><label class="collapse" for="c-41793764">[-]</label><label class="expand" for="c-41793764">[2 more]</label></div><br/><div class="children"><div class="content">Hands down, the best (free, no email) resource to learn Effect is here <a href="https:&#x2F;&#x2F;www.typeonce.dev&#x2F;course&#x2F;effect-beginners-complete-getting-started" rel="nofollow">https:&#x2F;&#x2F;www.typeonce.dev&#x2F;course&#x2F;effect-beginners-complete-ge...</a>, as opposed to the docs. The link referenced gives a holistic view of how to incorporate it.</div><br/><div id="41794857" class="c"><input type="checkbox" id="c-41794857" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41793764">parent</a><span>|</span><a href="#41793246">next</a><span>|</span><label class="collapse" for="c-41794857">[-]</label><label class="expand" for="c-41794857">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been following the author Sandro Maglione for quite a while and am on his email list, he&#x27;s great. He wrote fpdart which I&#x27;ve used and now he seems to be all in on Effect, with XState.</div><br/></div></div></div></div><div id="41793246" class="c"><input type="checkbox" id="c-41793246" checked=""/><div class="controls bullet"><span class="by">theschwa</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41792966">parent</a><span>|</span><a href="#41793764">prev</a><span>|</span><a href="#41793375">next</a><span>|</span><label class="collapse" for="c-41793246">[-]</label><label class="expand" for="c-41793246">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, looking at that example feels like jumping straight into the deep end of the pool. I think it helps going through a tutorial that breaks down the why of each piece. I really liked this tutorial on it: <a href="https:&#x2F;&#x2F;www.typeonce.dev&#x2F;course&#x2F;effect-beginners-complete-getting-started" rel="nofollow">https:&#x2F;&#x2F;www.typeonce.dev&#x2F;course&#x2F;effect-beginners-complete-ge...</a><p>Some core things from Effect though that you can see in that Express example:<p>* Break things down into Services. Effect handles dependency injection, that&#x27;s typed, for services so you can easily test them and have different versions running for testing, production, etc.
* Fibers for threaded execution
* Managing resources to make sure they&#x27;re properly closed with scope<p>I think a lot of these things though often aren&#x27;t truly appreciated until you&#x27;ve had something go wrong before or you&#x27;ve had to build a system to manage them yourself.
*</div><br/><div id="41794687" class="c"><input type="checkbox" id="c-41794687" checked=""/><div class="controls bullet"><span class="by">mewpmewp2</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41793246">parent</a><span>|</span><a href="#41793706">next</a><span>|</span><label class="collapse" for="c-41794687">[-]</label><label class="expand" for="c-41794687">[1 more]</label></div><br/><div class="children"><div class="content">But I feel like I&#x27;ve worked with massive systems with a lot going on where nothing has gone wrong that this sort of thing specifically would solve it. I think it would just increase learning curve and make people make other types of mistakes (business logic or otherwise) because it&#x27;s so much less readable and understandable. I&#x27;ve seen similar libraries used in the past that have caused much more worse bugs because people misunderstand how they exactly work.</div><br/></div></div><div id="41793706" class="c"><input type="checkbox" id="c-41793706" checked=""/><div class="controls bullet"><span class="by">dimal</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41793246">parent</a><span>|</span><a href="#41794687">prev</a><span>|</span><a href="#41793375">next</a><span>|</span><label class="collapse" for="c-41793706">[-]</label><label class="expand" for="c-41793706">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, this looks like the tutorial I needed. Thanks.</div><br/></div></div></div></div><div id="41793375" class="c"><input type="checkbox" id="c-41793375" checked=""/><div class="controls bullet"><span class="by">bjacobso</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41792966">parent</a><span>|</span><a href="#41793246">prev</a><span>|</span><a href="#41792257">next</a><span>|</span><label class="collapse" for="c-41793375">[-]</label><label class="expand" for="c-41793375">[1 more]</label></div><br/><div class="children"><div class="content">I agree, some of there examples are a little overly complicated by their quest to be hyper composable. In fact they should probably remove that example. I am currently using it with Remix, and using their @effect&#x2F;platform package to produce a simple web handler (request: Request) =&gt; Response (thank remix for heavily promoting the adoption of web standards).<p>I fully agree parts of the ecosystem are complex, and likely not fully ready for broad adoption. But I do think things will simplify with time, patterns will emerge, and it will be seen as react-for-the-backend, the de facto first choice. effect + schema + platform + cluster will be an extremely compelling stack.</div><br/></div></div></div></div><div id="41792257" class="c"><input type="checkbox" id="c-41792257" checked=""/><div class="controls bullet"><span class="by">steve_adams_86</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41791501">parent</a><span>|</span><a href="#41792966">prev</a><span>|</span><a href="#41795090">next</a><span>|</span><label class="collapse" for="c-41792257">[-]</label><label class="expand" for="c-41792257">[1 more]</label></div><br/><div class="children"><div class="content">I agree about the turning point. Things have improved dramatically. And I know it probably doesn&#x27;t feel the same for tons of people, but I love to see generators being used in every day code.<p>The learning curve just about turned me away from it at the start, but I&#x27;m glad I stuck with it.<p>I think learning Effect would actually teach a lot of people some very useful concepts and patterns for programming in general. It&#x27;s very well thought out.</div><br/></div></div></div></div><div id="41795090" class="c"><input type="checkbox" id="c-41795090" checked=""/><div class="controls bullet"><span class="by">seer</span><span>|</span><a href="#41791316">parent</a><span>|</span><a href="#41791501">prev</a><span>|</span><a href="#41793804">next</a><span>|</span><label class="collapse" for="c-41795090">[-]</label><label class="expand" for="c-41795090">[1 more]</label></div><br/><div class="children"><div class="content">I’d love to hear more stories of people using Effect in production codebases.<p>It looks very similar in its ideas to fp-ts (in the “let’s bring monads, algebraic types etc to typescript” sense).<p>But I did hear from teams that embraced fp-ts that things kinda ground to a halt for them. And those were category theory enthusiasts that were very good scala devs so I’m sure they knew what they were doing with fp-ts.<p>What happened was that the typescript compile time just shot into minutes, for a moderately sized micro-service, without anything externally heavy being introduced like you could on the frontend.<p>It just turned out that Typescript compiler was not so great at tracking all the inferred types throughout the codebase.<p>So wonder if things have improved or effect uses types more intelligently so that this is not an issue.</div><br/></div></div><div id="41793804" class="c"><input type="checkbox" id="c-41793804" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#41791316">parent</a><span>|</span><a href="#41795090">prev</a><span>|</span><a href="#41790169">next</a><span>|</span><label class="collapse" for="c-41793804">[-]</label><label class="expand" for="c-41793804">[2 more]</label></div><br/><div class="children"><div class="content">I like the functionality, but the verbosity of the API makes me want to immediately ignore it. I feel like zod nailed the usability part.</div><br/><div id="41794421" class="c"><input type="checkbox" id="c-41794421" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#41791316">root</a><span>|</span><a href="#41793804">parent</a><span>|</span><a href="#41790169">next</a><span>|</span><label class="collapse" for="c-41794421">[-]</label><label class="expand" for="c-41794421">[1 more]</label></div><br/><div class="children"><div class="content">Schema is a much powerful tool than Zod. Zod is merely a parser, while Schema has a decoder&#x2F;encoder architecture.</div><br/></div></div></div></div></div></div><div id="41790169" class="c"><input type="checkbox" id="c-41790169" checked=""/><div class="controls bullet"><span class="by">threatofrain</span><span>|</span><a href="#41791316">prev</a><span>|</span><a href="#41794441">next</a><span>|</span><label class="collapse" for="c-41790169">[-]</label><label class="expand" for="c-41790169">[27 more]</label></div><br/><div class="children"><div class="content">This is just a link to the front page of possibly the #1 most popular type validation library in the ecosystem? Anyways, ya&#x27;ll might want to check out up-and-coming Valibot, which has a really nice pipe API.<p><a href="https:&#x2F;&#x2F;valibot.dev" rel="nofollow">https:&#x2F;&#x2F;valibot.dev</a></div><br/><div id="41790395" class="c"><input type="checkbox" id="c-41790395" checked=""/><div class="controls bullet"><span class="by">rjknight</span><span>|</span><a href="#41790169">parent</a><span>|</span><a href="#41790398">next</a><span>|</span><label class="collapse" for="c-41790395">[-]</label><label class="expand" for="c-41790395">[6 more]</label></div><br/><div class="children"><div class="content">Valibot is really nice, particularly for avoiding bundle size bloat. Because Zod uses a &quot;fluent builder&quot; API, all of Zod&#x27;s functionality is implemented in classes with many methods. Importing something like `z.string` also imports validators to check if the string is a UUID, email address, has a minimum or maximum length, matches a regex, and so on - even if none of those validators are used. Valibot makes these independent functions that are composed using the &quot;pipe&quot; function, which means that only the functions which are actually used need to be included in your JavaScript bundle. Since most apps use only a small percentage of the available validators, the bundle size reduction can be quite significant relative to Zod.</div><br/><div id="41794189" class="c"><input type="checkbox" id="c-41794189" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41790169">root</a><span>|</span><a href="#41790395">parent</a><span>|</span><a href="#41790398">next</a><span>|</span><label class="collapse" for="c-41794189">[-]</label><label class="expand" for="c-41794189">[5 more]</label></div><br/><div class="children"><div class="content">Is there a reason why tree shaking algorithms don&#x27;t prune unused class members? My IDE can tell me when a method is unused, it seems odd that the tree shaker can&#x27;t.</div><br/><div id="41796327" class="c"><input type="checkbox" id="c-41796327" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#41790169">root</a><span>|</span><a href="#41794189">parent</a><span>|</span><a href="#41794313">next</a><span>|</span><label class="collapse" for="c-41796327">[-]</label><label class="expand" for="c-41796327">[1 more]</label></div><br/><div class="children"><div class="content">Because you can write `this[anything()]()` and it&#x27;s impossible to analyze it.  IDE false negative will not do anything bad, but treeshaker false negative will introduce a bug, so they have to be conservative.</div><br/></div></div><div id="41794313" class="c"><input type="checkbox" id="c-41794313" checked=""/><div class="controls bullet"><span class="by">everforward</span><span>|</span><a href="#41790169">root</a><span>|</span><a href="#41794189">parent</a><span>|</span><a href="#41796327">prev</a><span>|</span><a href="#41794492">next</a><span>|</span><label class="collapse" for="c-41794313">[-]</label><label class="expand" for="c-41794313">[2 more]</label></div><br/><div class="children"><div class="content">Does that work for all class members?  I think I&#x27;ve only ever seen that on private members, though I don&#x27;t know whether that&#x27;s because it&#x27;s so much easier to check whether a private member is used or because an unused public member isn&#x27;t an issue for eg a library.<p>This feels like an issue that reduces down to the Halting Problem, though.  Halting is a function that could be made a member of a class, so if you could tell whether that method is used or not then you could tell whether the program will halt or not.  I think it&#x27;s one of those things that feels like it should be fairly easy, and it&#x27;s really really not.</div><br/><div id="41794373" class="c"><input type="checkbox" id="c-41794373" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41790169">root</a><span>|</span><a href="#41794313">parent</a><span>|</span><a href="#41794492">next</a><span>|</span><label class="collapse" for="c-41794373">[-]</label><label class="expand" for="c-41794373">[1 more]</label></div><br/><div class="children"><div class="content">Comparing this to the halting problem isn&#x27;t really meaningful here because even if you could make a full mapping (which yours isn&#x27;t), you <i>can</i> prove that a rather large subset of programs halt, which is good enough for a tree shaker.<p>I don&#x27;t need to be able to eliminate every single unused function in every situation, but if I can prove that certain functions are unused then I can delete just those functions. We&#x27;re already doing this regularly with standalone functions, so my question is just why this isn&#x27;t done with class members.</div><br/></div></div></div></div><div id="41794492" class="c"><input type="checkbox" id="c-41794492" checked=""/><div class="controls bullet"><span class="by">aleclarsoniv</span><span>|</span><a href="#41790169">root</a><span>|</span><a href="#41794189">parent</a><span>|</span><a href="#41794313">prev</a><span>|</span><a href="#41790398">next</a><span>|</span><label class="collapse" for="c-41794492">[-]</label><label class="expand" for="c-41794492">[1 more]</label></div><br/><div class="children"><div class="content">It requires flow analysis, which is really hard to get right. I don&#x27;t think there&#x27;s a tree-shaking library that uses the TypeScript compiler API for static analysis purposes. Maybe because it would be slow?<p><i>edit:</i> The creator of Terser is working on flow analysis for his new minifier, according to him[1].<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;terser&#x2F;terser&#x2F;issues&#x2F;1410#issuecomment-1710349693">https:&#x2F;&#x2F;github.com&#x2F;terser&#x2F;terser&#x2F;issues&#x2F;1410#issuecomment-17...</a></div><br/></div></div></div></div></div></div><div id="41790398" class="c"><input type="checkbox" id="c-41790398" checked=""/><div class="controls bullet"><span class="by">crooked-v</span><span>|</span><a href="#41790169">parent</a><span>|</span><a href="#41790395">prev</a><span>|</span><a href="#41790557">next</a><span>|</span><label class="collapse" for="c-41790398">[-]</label><label class="expand" for="c-41790398">[3 more]</label></div><br/><div class="children"><div class="content">Valibot also has much, much more efficient type inference, which sounds unimportant right up until you have 50 schemas referencing each other and all your Typescript stuff slows to a molasses crawl.</div><br/><div id="41796900" class="c"><input type="checkbox" id="c-41796900" checked=""/><div class="controls bullet"><span class="by">Escapado</span><span>|</span><a href="#41790169">root</a><span>|</span><a href="#41790398">parent</a><span>|</span><a href="#41792711">next</a><span>|</span><label class="collapse" for="c-41796900">[-]</label><label class="expand" for="c-41796900">[1 more]</label></div><br/><div class="children"><div class="content">Not only that, runtime schema validation was also way faster in my last project for larger arrays of complex objects with lots of union types. Went from 400ms to 24ms all else being equal. Since our validation was running on every request for certain reasons this made a huge difference in perceived performance for our users and less load on our servers.</div><br/></div></div><div id="41792711" class="c"><input type="checkbox" id="c-41792711" checked=""/><div class="controls bullet"><span class="by">zztop44</span><span>|</span><a href="#41790169">root</a><span>|</span><a href="#41790398">parent</a><span>|</span><a href="#41796900">prev</a><span>|</span><a href="#41790557">next</a><span>|</span><label class="collapse" for="c-41792711">[-]</label><label class="expand" for="c-41792711">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. I recently moved a production app from Zod to Valibot for exactly this reason. I still slightly prefer Zod’s syntax but the performance issues were absolutely killing us.</div><br/></div></div></div></div><div id="41790557" class="c"><input type="checkbox" id="c-41790557" checked=""/><div class="controls bullet"><span class="by">kaoD</span><span>|</span><a href="#41790169">parent</a><span>|</span><a href="#41790398">prev</a><span>|</span><a href="#41791776">next</a><span>|</span><label class="collapse" for="c-41790557">[-]</label><label class="expand" for="c-41790557">[3 more]</label></div><br/><div class="children"><div class="content">Does&#x2F;will this correctly handle `| undefined` vs `?`, i.e. correct behavior under `exactOptionalPropertyTypes`?<p>Zod doesn&#x27;t (yet[0]) and it&#x27;s been a pain point for me.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;colinhacks&#x2F;zod&#x2F;issues&#x2F;635">https:&#x2F;&#x2F;github.com&#x2F;colinhacks&#x2F;zod&#x2F;issues&#x2F;635</a></div><br/><div id="41790712" class="c"><input type="checkbox" id="c-41790712" checked=""/><div class="controls bullet"><span class="by">x1000</span><span>|</span><a href="#41790169">root</a><span>|</span><a href="#41790557">parent</a><span>|</span><a href="#41794549">next</a><span>|</span><label class="collapse" for="c-41790712">[-]</label><label class="expand" for="c-41790712">[1 more]</label></div><br/><div class="children"><div class="content">I ran into exactly same pain point which was enough to nullify the benefits of using zod at all.</div><br/></div></div><div id="41794549" class="c"><input type="checkbox" id="c-41794549" checked=""/><div class="controls bullet"><span class="by">aleclarsoniv</span><span>|</span><a href="#41790169">root</a><span>|</span><a href="#41790557">parent</a><span>|</span><a href="#41790712">prev</a><span>|</span><a href="#41791776">next</a><span>|</span><label class="collapse" for="c-41794549">[-]</label><label class="expand" for="c-41794549">[1 more]</label></div><br/><div class="children"><div class="content">TypeBox[1] differentiates between optional and undefined.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;sinclairzx81&#x2F;typebox">https:&#x2F;&#x2F;github.com&#x2F;sinclairzx81&#x2F;typebox</a></div><br/></div></div></div></div><div id="41791776" class="c"><input type="checkbox" id="c-41791776" checked=""/><div class="controls bullet"><span class="by">Eric_WVGG</span><span>|</span><a href="#41790169">parent</a><span>|</span><a href="#41790557">prev</a><span>|</span><a href="#41790418">next</a><span>|</span><label class="collapse" for="c-41791776">[-]</label><label class="expand" for="c-41791776">[1 more]</label></div><br/><div class="children"><div class="content">Is Valibot&#x27;s error handling any good? Zod&#x27;s is… like punishment for a crime I wasn&#x27;t aware that I had committed.</div><br/></div></div><div id="41790418" class="c"><input type="checkbox" id="c-41790418" checked=""/><div class="controls bullet"><span class="by">Timon3</span><span>|</span><a href="#41790169">parent</a><span>|</span><a href="#41791776">prev</a><span>|</span><a href="#41793826">next</a><span>|</span><label class="collapse" for="c-41790418">[-]</label><label class="expand" for="c-41790418">[8 more]</label></div><br/><div class="children"><div class="content">I recently stumbled onto this when looking for alternatives, and though it might sound a bit extreme: the style of documentation means I&#x27;ll never consider it for any project. It&#x27;s strange and honestly somehow unnerving to read documentation written from a first-person perspective. Is there some good reason for this that I&#x27;m missing? Or am I just crazy and this isn&#x27;t an issue for anyone else?</div><br/><div id="41790674" class="c"><input type="checkbox" id="c-41790674" checked=""/><div class="controls bullet"><span class="by">Bjartr</span><span>|</span><a href="#41790169">root</a><span>|</span><a href="#41790418">parent</a><span>|</span><a href="#41792472">next</a><span>|</span><label class="collapse" for="c-41790674">[-]</label><label class="expand" for="c-41790674">[4 more]</label></div><br/><div class="children"><div class="content">I only see second-person &quot;you&quot; and not first-person &quot;I&quot; in the linked documentation. Am I missing what you intended to point out?<p>In any case, this might actually be a good use for an LLM to post-process it into whatever style you want. I bet there&#x27;s even a browser extension that could do it on-demand and in-place.</div><br/><div id="41790796" class="c"><input type="checkbox" id="c-41790796" checked=""/><div class="controls bullet"><span class="by">Timon3</span><span>|</span><a href="#41790169">root</a><span>|</span><a href="#41790674">parent</a><span>|</span><a href="#41792472">next</a><span>|</span><label class="collapse" for="c-41790796">[-]</label><label class="expand" for="c-41790796">[3 more]</label></div><br/><div class="children"><div class="content">Really? For example under &quot;Main concepts&quot; on the &quot;Schemas&quot; site[0], I see stuff like this:<p>- I support the creation of schemas for any primitive data type.<p>- Among complex values I support objects, records, arrays, tuples as well as various other classes.<p>- For objects I provide various methods like pick, omit, partial and required.<p>- Beyond primitive and complex values, I also provide schema functions for more special cases.<p>Same for &quot;Mental model&quot;, &quot;Pipeline&quot;, &quot;Parse data&quot;, &quot;Infer types&quot;, &quot;Methods&quot; and &quot;Issues&quot; - I&#x27;ll assume the other sections also follow this style. That&#x27;s all not showing up for you?<p>While the LLM suggestion is nice, it&#x27;s not something I&#x27;m comfortable with unless hallucinations are incredibly rare. Why would I use a library whose documentation I have to pass through an unreliable preprocessor to follow a normal style?<p>[0]: <a href="https:&#x2F;&#x2F;valibot.dev&#x2F;guides&#x2F;schemas&#x2F;" rel="nofollow">https:&#x2F;&#x2F;valibot.dev&#x2F;guides&#x2F;schemas&#x2F;</a></div><br/><div id="41790952" class="c"><input type="checkbox" id="c-41790952" checked=""/><div class="controls bullet"><span class="by">prophesi</span><span>|</span><a href="#41790169">root</a><span>|</span><a href="#41790796">parent</a><span>|</span><a href="#41792472">next</a><span>|</span><label class="collapse" for="c-41790952">[-]</label><label class="expand" for="c-41790952">[2 more]</label></div><br/><div class="children"><div class="content">If they&#x27;re part of Hacktoberfest, editing those pages to drop the first person perspective sounds like a pretty useful first contribution.</div><br/><div id="41791526" class="c"><input type="checkbox" id="c-41791526" checked=""/><div class="controls bullet"><span class="by">Timon3</span><span>|</span><a href="#41790169">root</a><span>|</span><a href="#41790952">parent</a><span>|</span><a href="#41792472">next</a><span>|</span><label class="collapse" for="c-41791526">[-]</label><label class="expand" for="c-41791526">[1 more]</label></div><br/><div class="children"><div class="content">It seems I&#x27;m not the first person to make this observation: <a href="https:&#x2F;&#x2F;github.com&#x2F;fabian-hiller&#x2F;valibot&#x2F;issues&#x2F;687">https:&#x2F;&#x2F;github.com&#x2F;fabian-hiller&#x2F;valibot&#x2F;issues&#x2F;687</a><p>I honestly don&#x27;t want my validation library to &quot;tell a story&quot; at the expense of documentation clarity. It&#x27;s absolutely fine that this project uses it, I don&#x27;t want to impose my view on them - I guess it&#x27;s just not the validation library for me.</div><br/></div></div></div></div></div></div></div></div><div id="41792472" class="c"><input type="checkbox" id="c-41792472" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41790169">root</a><span>|</span><a href="#41790418">parent</a><span>|</span><a href="#41790674">prev</a><span>|</span><a href="#41790964">next</a><span>|</span><label class="collapse" for="c-41792472">[-]</label><label class="expand" for="c-41792472">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a little too cute, but I don&#x27;t see it as a deciding factor on which library to use.<p>I think a more important issue is that Valibot hasn&#x27;t reached 1.0 yet. But it looks like it&#x27;s very close.</div><br/></div></div><div id="41790964" class="c"><input type="checkbox" id="c-41790964" checked=""/><div class="controls bullet"><span class="by">kaoD</span><span>|</span><a href="#41790169">root</a><span>|</span><a href="#41790418">parent</a><span>|</span><a href="#41792472">prev</a><span>|</span><a href="#41793826">next</a><span>|</span><label class="collapse" for="c-41790964">[-]</label><label class="expand" for="c-41790964">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Or am I just crazy and this isn&#x27;t an issue for anyone else?<p>Not an issue for me, to be honest. Why does it bother you at all?</div><br/><div id="41791484" class="c"><input type="checkbox" id="c-41791484" checked=""/><div class="controls bullet"><span class="by">Timon3</span><span>|</span><a href="#41790169">root</a><span>|</span><a href="#41790964">parent</a><span>|</span><a href="#41793826">next</a><span>|</span><label class="collapse" for="c-41791484">[-]</label><label class="expand" for="c-41791484">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not exactly sure myself, but every time I open one of the pages, I mentally stumble over the formulations. I think there are two components:<p>1. The biggest part is that I&#x27;ve simply never seen documentation written in this style, any mentions of &quot;I&quot; or &quot;we&quot; are usually explaining the choices made by the author(s). When skimming documentation I pay more attention to those parts. Here those parts don&#x27;t have a comparable meaning.<p>2. The smaller part is that the writing style reminds me of the way brands use mascots with first-person writing to advertise to children. There&#x27;s not really any other association I have with this way of writing, and it makes me feel like the author either isn&#x27;t taking the project seriously, or me.<p>I&#x27;m not trying to argue that the documentation should be understood this way, or that it should be changed - but I&#x27;ve stumbled over this multiple times, and can&#x27;t imagine that it&#x27;s just me.</div><br/></div></div></div></div></div></div><div id="41791178" class="c"><input type="checkbox" id="c-41791178" checked=""/><div class="controls bullet"><span class="by">mightyham</span><span>|</span><a href="#41790169">parent</a><span>|</span><a href="#41793826">prev</a><span>|</span><a href="#41792430">next</a><span>|</span><label class="collapse" for="c-41791178">[-]</label><label class="expand" for="c-41791178">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m currently using valibot and the author&#x27;s associated modular form library in a production app and can vouch that it&#x27;s been very pleasant to work with.</div><br/></div></div><div id="41792430" class="c"><input type="checkbox" id="c-41792430" checked=""/><div class="controls bullet"><span class="by">hyperbrainer</span><span>|</span><a href="#41790169">parent</a><span>|</span><a href="#41791178">prev</a><span>|</span><a href="#41790394">next</a><span>|</span><label class="collapse" for="c-41792430">[-]</label><label class="expand" for="c-41792430">[1 more]</label></div><br/><div class="children"><div class="content">Maybe OP is one of the lucky 10,000. <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1053&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;1053&#x2F;</a></div><br/></div></div><div id="41790394" class="c"><input type="checkbox" id="c-41790394" checked=""/><div class="controls bullet"><span class="by">sergiotapia</span><span>|</span><a href="#41790169">parent</a><span>|</span><a href="#41792430">prev</a><span>|</span><a href="#41794441">next</a><span>|</span><label class="collapse" for="c-41790394">[-]</label><label class="expand" for="c-41790394">[2 more]</label></div><br/><div class="children"><div class="content">A whole lot of yapping and ZERO code on the homepage. Authors should remove 90% of the stuff on that landing page, jesus!<p>also since zod is the de facto validation lib, might be worth a specific page talking about why this vs zod. even their migration from zod page looks nearly identical between the two packages.</div><br/><div id="41790454" class="c"><input type="checkbox" id="c-41790454" checked=""/><div class="controls bullet"><span class="by">petesergeant</span><span>|</span><a href="#41790169">root</a><span>|</span><a href="#41790394">parent</a><span>|</span><a href="#41794441">next</a><span>|</span><label class="collapse" for="c-41790454">[-]</label><label class="expand" for="c-41790454">[1 more]</label></div><br/><div class="children"><div class="content">On the front page there is a prominent section addressing the differences from Zod, which appear to be “much better performance”</div><br/></div></div></div></div></div></div><div id="41794441" class="c"><input type="checkbox" id="c-41794441" checked=""/><div class="controls bullet"><span class="by">aleclarsoniv</span><span>|</span><a href="#41790169">prev</a><span>|</span><a href="#41790774">next</a><span>|</span><label class="collapse" for="c-41794441">[-]</label><label class="expand" for="c-41794441">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d recommend TypeBox[1] as an alternative, which has a runtime “compiler” for generating optimized JS functions from the type objects. It also produces a JSON schema, which can be useful for generating API docs and API clients if needed.<p>It also has a companion library[2] for generating TypeBox validators from TypeScript definitions, which I&#x27;m currently using in an RPC library I&#x27;m working on.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;sinclairzx81&#x2F;typebox">https:&#x2F;&#x2F;github.com&#x2F;sinclairzx81&#x2F;typebox</a>
[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;sinclairzx81&#x2F;typebox-codegen">https:&#x2F;&#x2F;github.com&#x2F;sinclairzx81&#x2F;typebox-codegen</a></div><br/><div id="41794468" class="c"><input type="checkbox" id="c-41794468" checked=""/><div class="controls bullet"><span class="by">JasonSage</span><span>|</span><a href="#41794441">parent</a><span>|</span><a href="#41790774">next</a><span>|</span><label class="collapse" for="c-41794468">[-]</label><label class="expand" for="c-41794468">[1 more]</label></div><br/><div class="children"><div class="content">We are moving from Zod to TypeBox because there’s a lot of inflexibility in Zod’s extensibility story that we’re able to get past in TypeBox.<p>After doing a deep-dive comparison, I’m left wondering why to ever choose Zod over TypeBox.</div><br/></div></div></div></div><div id="41790774" class="c"><input type="checkbox" id="c-41790774" checked=""/><div class="controls bullet"><span class="by">dhruvrajvanshi</span><span>|</span><a href="#41794441">prev</a><span>|</span><a href="#41791038">next</a><span>|</span><label class="collapse" for="c-41790774">[-]</label><label class="expand" for="c-41790774">[21 more]</label></div><br/><div class="children"><div class="content">I wonder about a Typescript with alternate design decisions.
The type system is cool and you can do a lot of compile time metaprogramming.
However, when there&#x27;s a type error in computed types, it&#x27;s a nightmare to visually parse<p><pre><code>  type { foo: ... , bar: ..., ... } can&#x27;t be assigned to type { foo: ..., bar: ... }. type { foo: ... bar: ..., ... } is missing the following properties from { foo: ..., bar: ..., ... }
</code></pre>
Apart from repeating roughly the same type 4 times (which is a UX issue that&#x27;s fixable), debugging computed types requires having a typescript interpreter in your head.<p>I wonder if we had nominal runtime checked types, it could work better than the current design in terms of DX.
Basically, the : Type would always be a runtime checked assertion. Zod certainly fills that gap, but it would be nicer to have it baked in.<p>The type system would not be as powerful, but when I&#x27;m writing Kotlin, I really don&#x27;t miss the advanced features of Typescript at all. I just define a data class structure and add @Serializable to generate conversions from&#x2F;to JSON.</div><br/><div id="41790930" class="c"><input type="checkbox" id="c-41790930" checked=""/><div class="controls bullet"><span class="by">wrs</span><span>|</span><a href="#41790774">parent</a><span>|</span><a href="#41790902">next</a><span>|</span><label class="collapse" for="c-41790930">[-]</label><label class="expand" for="c-41790930">[8 more]</label></div><br/><div class="children"><div class="content">TypeScript has a crazy powerful type system because it has to be able to describe any crazy behavior that was implemented in JavaScript. I mean, just take a look at @types&#x2F;express-serve-static-core [0] or @types&#x2F;lodash [1] to see the lengths TS will let you go.<p>If you write in TS to start with, you can use a more sane subset.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;DefinitelyTyped&#x2F;DefinitelyTyped&#x2F;blob&#x2F;master&#x2F;types&#x2F;express-serve-static-core&#x2F;index.d.ts">https:&#x2F;&#x2F;github.com&#x2F;DefinitelyTyped&#x2F;DefinitelyTyped&#x2F;blob&#x2F;mast...</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;DefinitelyTyped&#x2F;DefinitelyTyped&#x2F;blob&#x2F;master&#x2F;types&#x2F;lodash&#x2F;common&#x2F;common.d.ts">https:&#x2F;&#x2F;github.com&#x2F;DefinitelyTyped&#x2F;DefinitelyTyped&#x2F;blob&#x2F;mast...</a></div><br/><div id="41791780" class="c"><input type="checkbox" id="c-41791780" checked=""/><div class="controls bullet"><span class="by">dhruvrajvanshi</span><span>|</span><a href="#41790774">root</a><span>|</span><a href="#41790930">parent</a><span>|</span><a href="#41790902">next</a><span>|</span><label class="collapse" for="c-41791780">[-]</label><label class="expand" for="c-41791780">[7 more]</label></div><br/><div class="children"><div class="content">Right. I&#x27;m aware. My point was that even though the type system is powerful, somehow, I&#x27;m able to represent everything I need to in Kotlin&#x27;s type system just fine and it feels a lot more type safe because it will throw a type error at runtime in the right place if I do a bad cast.<p>Typescript `as Foo` will not do anything at runtime, and it will just keep on going, then throw a type error somewhere else later (possibly across an async boundary).<p>You can, in theory use very strong lint rules (disallow `as` operator in favour of Zod, disallow postfix ! operator), but no actual codebase that I&#x27;ve worked on has these checks. Even the ones with the strictest checks enabled have gaps.<p>Not to mention, there&#x27;s intentional unsoundness in the type system, so even if you wanted, you couldn&#x27;t really create a save subset of TS.<p>Then there&#x27;s the issue of reading the library types of some generic heavy code. When I &quot;go to definition&quot; in my fastify codebase, I see stuff like this<p><pre><code>  RouteHandlerMethod&lt;RawServer, RawRequest, RawReply, RouteGeneric, ContextConfig, SchemaCompiler, TypeProvider, Logger&gt;
</code></pre>
Which expands to this<p><pre><code>  export type RouteHandlerMethod&lt;
  RawServer extends RawServerBase = RawServerDefault,
  RawRequest extends RawRequestDefaultExpression&lt;RawServer&gt; = RawRequestDefaultExpression&lt;RawServer&gt;,
  RawReply extends RawReplyDefaultExpression&lt;RawServer&gt; = RawReplyDefaultExpression&lt;RawServer&gt;,
  RouteGeneric extends RouteGenericInterface = RouteGenericInterface,
  ContextConfig = ContextConfigDefault,
  SchemaCompiler extends FastifySchema = FastifySchema,
  TypeProvider extends FastifyTypeProvider = FastifyTypeProviderDefault,
  Logger extends FastifyBaseLogger = FastifyBaseLogger</code></pre>
&gt; = (
  this: FastifyInstance&lt;RawServer, RawRequest, RawReply, Logger, TypeProvider&gt;,
  request: FastifyRequest&lt;RouteGeneric, RawServer, RawRequest, SchemaCompiler, TypeProvider, ContextConfig, Logger&gt;,
  reply: FastifyReply&lt;RouteGeneric, RawServer, RawRequest, RawReply, ContextConfig, SchemaCompiler, TypeProvider&gt;
  &#x2F;&#x2F; This return type used to be a generic type argument. Due to TypeScript&#x27;s inference of return types, this rendered returns unchecked.
) =&gt; ResolveFastifyReplyReturnType&lt;TypeProvider, SchemaCompiler, RouteGeneric&gt;<p>Other languages somehow don&#x27;t need types this complicated and they&#x27;re still safer at runtime :shrug:</div><br/><div id="41794427" class="c"><input type="checkbox" id="c-41794427" checked=""/><div class="controls bullet"><span class="by">everforward</span><span>|</span><a href="#41790774">root</a><span>|</span><a href="#41791780">parent</a><span>|</span><a href="#41796270">next</a><span>|</span><label class="collapse" for="c-41794427">[-]</label><label class="expand" for="c-41794427">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t write Kotlin, but what that does (assuming I&#x27;m guessing at it correctly) requires far more awkward code in most other languages.  That looks like it will allow you to extend the types of objects deep inside the library so that you could e.g. create your own Request object without having to type cast inside the HTTP handlers or wrap the entire library.<p>That shifts the complexity of doing that out of the runtime and into the Typescript preprocessor where it&#x27;s not going to mess with your production instances.<p>I also don&#x27;t think it&#x27;s all that bad; it&#x27;s a lot of generic types, but it doesn&#x27;t appear to be doing anything particularly complicated.<p>I do think they get awful, though.  This is something I&#x27;ve been hacking on that I&#x27;m probably going to rewrite <a href="https:&#x2F;&#x2F;pastebin.com&#x2F;VszX3MyE" rel="nofollow">https:&#x2F;&#x2F;pastebin.com&#x2F;VszX3MyE</a>  It&#x27;s a wrapper around Electron&#x27;s IPC and derives a type for the client from the type for the server (has to have the same methods and does some type finagling to strip out the server-specific types).  It also dynamically generates a client based on the server prototype.  The whole thing rapidly fell into the &quot;neat but too complicated to be practical&quot; hole.</div><br/><div id="41796067" class="c"><input type="checkbox" id="c-41796067" checked=""/><div class="controls bullet"><span class="by">dhruvrajvanshi</span><span>|</span><a href="#41790774">root</a><span>|</span><a href="#41794427">parent</a><span>|</span><a href="#41796270">next</a><span>|</span><label class="collapse" for="c-41796067">[-]</label><label class="expand" for="c-41796067">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t write Kotlin, but what that does (assuming I&#x27;m guessing at it correctly) requires far more awkward code in most other languages<p>You&#x27;re <i>NOT</i> assuming correctly. In Kotlin, this would be handled as an extension property on the Request type. You could write it just like normal code instead of extending some global ambient interfaces.<p><pre><code>  val Request.foo: Bar = whatever
  get(&quot;&#x2F;&quot;) { req.foo &#x2F;&#x2F; just a method call }
</code></pre>
You can CMD+Click on it and read the actual implementation (instead of generated type definitions).<p>The Typescript ecosystem needs these complicated types because of some design choices (no type based dispatch). I suggest looking up how other languages solve these problems. You&#x27;ll find that in typescript, you have to reach for complex types far sooner than in other languages.</div><br/></div></div></div></div><div id="41792057" class="c"><input type="checkbox" id="c-41792057" checked=""/><div class="controls bullet"><span class="by">rimunroe</span><span>|</span><a href="#41790774">root</a><span>|</span><a href="#41791780">parent</a><span>|</span><a href="#41796270">prev</a><span>|</span><a href="#41795364">next</a><span>|</span><label class="collapse" for="c-41792057">[-]</label><label class="expand" for="c-41792057">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can, in theory use very strong lint rules (disallow `as` operator in favour of Zod, disallow postfix ! operator), but no actual codebase that I&#x27;ve worked on has these checks. Even the ones with the strictest checks enabled have gaps.<p>That&#x27;s surprising. I&#x27;ve worked on a few codebases with reasonably mature TS usage and they&#x27;ve all disallowed as&#x2F;!&#x2F;any without an explicit comment to disable the rule and explain why the use is required there.</div><br/></div></div><div id="41795364" class="c"><input type="checkbox" id="c-41795364" checked=""/><div class="controls bullet"><span class="by">presentation</span><span>|</span><a href="#41790774">root</a><span>|</span><a href="#41791780">parent</a><span>|</span><a href="#41792057">prev</a><span>|</span><a href="#41793464">next</a><span>|</span><label class="collapse" for="c-41795364">[-]</label><label class="expand" for="c-41795364">[1 more]</label></div><br/><div class="children"><div class="content">My company’s codebase disallows type coercion. You can disable the lint rule if there’s a legit reason to but then we ask to explain why.</div><br/></div></div><div id="41793464" class="c"><input type="checkbox" id="c-41793464" checked=""/><div class="controls bullet"><span class="by">wrs</span><span>|</span><a href="#41790774">root</a><span>|</span><a href="#41791780">parent</a><span>|</span><a href="#41795364">prev</a><span>|</span><a href="#41790902">next</a><span>|</span><label class="collapse" for="c-41793464">[-]</label><label class="expand" for="c-41793464">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s apples and oranges. The type system in Kotlin is integrated into the language. TypeScript is a preprocessor for JavaScript that isn&#x27;t allowed to change the JavaScript language, or have any runtime.<p>The &quot;as Foo&quot; construct is for you to tell TS that you know better than it, or that you deliberately want to bypass the type system. You can have a runtime check, but you have to write the code yourself (a type predicate), because TS doesn&#x27;t write or change any JavaScript*, it just type-checks it.<p>I&#x27;ve certainly worked in new codebases where a relatively simple subset of TS types were used. Even then there were a few places the crazy type system was helpful to have. For example, we enforced that the names of the properties in the global configuration object weren&#x27;t allowed to have consecutive uppercase letters!<p>(* with minor exceptions like transpiling for new JS features)</div><br/></div></div></div></div></div></div><div id="41790902" class="c"><input type="checkbox" id="c-41790902" checked=""/><div class="controls bullet"><span class="by">rlp</span><span>|</span><a href="#41790774">parent</a><span>|</span><a href="#41790930">prev</a><span>|</span><a href="#41793383">next</a><span>|</span><label class="collapse" for="c-41790902">[-]</label><label class="expand" for="c-41790902">[8 more]</label></div><br/><div class="children"><div class="content">This is my exact experience. TypeScript seemed to hit a complexity sweet spot about 5 years ago, then they just kept adding more obscure stuff to the type system. I find that understanding TypeScript compiler errors can be almost as difficult as understanding C++ template errors at times.</div><br/><div id="41794437" class="c"><input type="checkbox" id="c-41794437" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#41790774">root</a><span>|</span><a href="#41790902">parent</a><span>|</span><a href="#41790996">next</a><span>|</span><label class="collapse" for="c-41794437">[-]</label><label class="expand" for="c-41794437">[3 more]</label></div><br/><div class="children"><div class="content">Hint, 9 times out of 10 you only need to read the last part of the error.<p>Also, there are many ways to make types opaque (not show their entire verbose structure).</div><br/><div id="41794936" class="c"><input type="checkbox" id="c-41794936" checked=""/><div class="controls bullet"><span class="by">trevor-e</span><span>|</span><a href="#41790774">root</a><span>|</span><a href="#41794437">parent</a><span>|</span><a href="#41790996">next</a><span>|</span><label class="collapse" for="c-41794936">[-]</label><label class="expand" for="c-41794936">[2 more]</label></div><br/><div class="children"><div class="content">Which begs the question of why they don&#x27;t rearrange that part to the first in the error message. Like you said, 9&#x2F;10 times I scroll down without thinking which is silly.</div><br/><div id="41796531" class="c"><input type="checkbox" id="c-41796531" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#41790774">root</a><span>|</span><a href="#41794936">parent</a><span>|</span><a href="#41790996">next</a><span>|</span><label class="collapse" for="c-41796531">[-]</label><label class="expand" for="c-41796531">[1 more]</label></div><br/><div class="children"><div class="content">I have no clue, but I guess there were (and are), good discussions around it.</div><br/></div></div></div></div></div></div><div id="41790996" class="c"><input type="checkbox" id="c-41790996" checked=""/><div class="controls bullet"><span class="by">phplovesong</span><span>|</span><a href="#41790774">root</a><span>|</span><a href="#41790902">parent</a><span>|</span><a href="#41794437">prev</a><span>|</span><a href="#41793383">next</a><span>|</span><label class="collapse" for="c-41790996">[-]</label><label class="expand" for="c-41790996">[4 more]</label></div><br/><div class="children"><div class="content">This. Haxe is a more sane TS alternative in 2024.</div><br/><div id="41794683" class="c"><input type="checkbox" id="c-41794683" checked=""/><div class="controls bullet"><span class="by">earslap</span><span>|</span><a href="#41790774">root</a><span>|</span><a href="#41790996">parent</a><span>|</span><a href="#41793394">next</a><span>|</span><label class="collapse" for="c-41794683">[-]</label><label class="expand" for="c-41794683">[1 more]</label></div><br/><div class="children"><div class="content">Haxe is amazing, has macros etc. A force multiplier if you are a solo developer for sure. But damn, you feel kinda alone if you are using it. Not everything is an npm install away which negates your velocity gains from using a saner language.</div><br/></div></div><div id="41793394" class="c"><input type="checkbox" id="c-41793394" checked=""/><div class="controls bullet"><span class="by">jadbox</span><span>|</span><a href="#41790774">root</a><span>|</span><a href="#41790996">parent</a><span>|</span><a href="#41794683">prev</a><span>|</span><a href="#41793383">next</a><span>|</span><label class="collapse" for="c-41793394">[-]</label><label class="expand" for="c-41793394">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s Haxe still been actively developed? I loved it back in the day. The blog hasn&#x27;t had an update in years.</div><br/><div id="41796961" class="c"><input type="checkbox" id="c-41796961" checked=""/><div class="controls bullet"><span class="by">phplovesong</span><span>|</span><a href="#41790774">root</a><span>|</span><a href="#41793394">parent</a><span>|</span><a href="#41793383">next</a><span>|</span><label class="collapse" for="c-41796961">[-]</label><label class="expand" for="c-41796961">[1 more]</label></div><br/><div class="children"><div class="content">It is. And only getting better SLOWLY by each iteration. The thing i love about Haxe that once you use it, your installed version is not legacy in a month (unlike npm&#x2F;typescipt ecosystem). Haxe is fully working, and does not need a lot of &quot;new&quot; features.<p>More news about Haxe can be found here: <a href="https:&#x2F;&#x2F;haxe.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;haxe.io&#x2F;</a> (the old blog is not updated AFAIK)</div><br/></div></div></div></div></div></div></div></div><div id="41793383" class="c"><input type="checkbox" id="c-41793383" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#41790774">parent</a><span>|</span><a href="#41790902">prev</a><span>|</span><a href="#41790931">next</a><span>|</span><label class="collapse" for="c-41793383">[-]</label><label class="expand" for="c-41793383">[2 more]</label></div><br/><div class="children"><div class="content">Can you do <i>any</i> compile time metaprogramming in typescript?</div><br/><div id="41794864" class="c"><input type="checkbox" id="c-41794864" checked=""/><div class="controls bullet"><span class="by">mhio</span><span>|</span><a href="#41790774">root</a><span>|</span><a href="#41793383">parent</a><span>|</span><a href="#41790931">next</a><span>|</span><label class="collapse" for="c-41794864">[-]</label><label class="expand" for="c-41794864">[1 more]</label></div><br/><div class="children"><div class="content">Not really - <a href="https:&#x2F;&#x2F;github.com&#x2F;Microsoft&#x2F;TypeScript&#x2F;issues&#x2F;16607">https:&#x2F;&#x2F;github.com&#x2F;Microsoft&#x2F;TypeScript&#x2F;issues&#x2F;16607</a>.<p>ts-morph provides an easy way to use the TypeScript Compiler API to view and edit the AST before compile. Once you get your head around the API, which has good examples but isn&#x27;t thoroughly documented on the web.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;dsherret&#x2F;ts-morph">https:&#x2F;&#x2F;github.com&#x2F;dsherret&#x2F;ts-morph</a></div><br/></div></div></div></div><div id="41790931" class="c"><input type="checkbox" id="c-41790931" checked=""/><div class="controls bullet"><span class="by">spencerchubb</span><span>|</span><a href="#41790774">parent</a><span>|</span><a href="#41793383">prev</a><span>|</span><a href="#41791038">next</a><span>|</span><label class="collapse" for="c-41790931">[-]</label><label class="expand" for="c-41790931">[2 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t this be improved by showing a diff between the mismatched types?</div><br/><div id="41791715" class="c"><input type="checkbox" id="c-41791715" checked=""/><div class="controls bullet"><span class="by">dhruvrajvanshi</span><span>|</span><a href="#41790774">root</a><span>|</span><a href="#41790931">parent</a><span>|</span><a href="#41791038">next</a><span>|</span><label class="collapse" for="c-41791715">[-]</label><label class="expand" for="c-41791715">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I did mention that the UX of the type errors could be improved and probably should, but once you start getting into conditional types, and nested types (which may not be fully expanded when you see the error), it gets hairy.</div><br/></div></div></div></div></div></div><div id="41791038" class="c"><input type="checkbox" id="c-41791038" checked=""/><div class="controls bullet"><span class="by">Stoids</span><span>|</span><a href="#41790774">prev</a><span>|</span><a href="#41793626">next</a><span>|</span><label class="collapse" for="c-41791038">[-]</label><label class="expand" for="c-41791038">[2 more]</label></div><br/><div class="children"><div class="content">The fragmentation around runtime validation libraries is pretty crazy. The fact that half these comments mention some alternative library that mimics almost the exact API of Zod illustrates that.<p>It is filling a necessary shortcoming in the gradual typing of TypeScript, and using validator schema types to power other APIs generic inference is powerful. I am optimistic about an obvious leader emerging, or at least a better story about swapping between them more easily, but a bit annoying when trying to pick one to settle on for work that I have confidence in. That being said, Zod seems like the community favorite at the moment.</div><br/><div id="41792807" class="c"><input type="checkbox" id="c-41792807" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41791038">parent</a><span>|</span><a href="#41793626">next</a><span>|</span><label class="collapse" for="c-41792807">[-]</label><label class="expand" for="c-41792807">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s annoying. I share your optimism. This is how the JavaScript (and now TypeScript) community figures things out.<p>Note that TypeScript had competitors, too. It got better. Zod has an early lead and is good enough in a lot of ways, but I&#x27;m not sure it will be the one.<p>Perhaps someday there will be a bun&#x2F;deno-like platform with TypeScript++ that has validation merged in, but it&#x27;s probably good that it&#x27;s not standardized yet.</div><br/></div></div></div></div><div id="41793626" class="c"><input type="checkbox" id="c-41793626" checked=""/><div class="controls bullet"><span class="by">n00bskoolbus</span><span>|</span><a href="#41791038">prev</a><span>|</span><a href="#41790517">next</a><span>|</span><label class="collapse" for="c-41793626">[-]</label><label class="expand" for="c-41793626">[1 more]</label></div><br/><div class="children"><div class="content">Something cool that I can&#x27;t remember if it was posted on HN at one point or I stumbled across when looking for alternatives to yup but this repo has been compiling a bunch of different benchmarks for runtime validation of ts validation libraries. Obviously to some degree the performance is arbitrary when you&#x27;re reaching millions of operations per second but on the flipside their benchmarks are against rather data. Would be interested to see comparison of either more nested data or otherwise complex. Maybe something to look at in my spare time.<p><a href="https:&#x2F;&#x2F;moltar.github.io&#x2F;typescript-runtime-type-benchmarks&#x2F;" rel="nofollow">https:&#x2F;&#x2F;moltar.github.io&#x2F;typescript-runtime-type-benchmarks&#x2F;</a></div><br/></div></div><div id="41790517" class="c"><input type="checkbox" id="c-41790517" checked=""/><div class="controls bullet"><span class="by">timpetri</span><span>|</span><a href="#41793626">prev</a><span>|</span><a href="#41791000">next</a><span>|</span><label class="collapse" for="c-41790517">[-]</label><label class="expand" for="c-41790517">[3 more]</label></div><br/><div class="children"><div class="content">Looking around on Twitter and repos in the OSS community, it appears that Zod is now almost always favored over yup, despite an almost identical API. Curious to hear what people think if they&#x27;ve worked with both. We went with Yup early on at my company, and now that&#x27;s what we use for consistency in our codebase. I haven&#x27;t personally found it to be lacking, but some of the logic around nulls and undefined always lead me back to the docs.</div><br/><div id="41790812" class="c"><input type="checkbox" id="c-41790812" checked=""/><div class="controls bullet"><span class="by">roessland</span><span>|</span><a href="#41790517">parent</a><span>|</span><a href="#41791000">next</a><span>|</span><label class="collapse" for="c-41790812">[-]</label><label class="expand" for="c-41790812">[2 more]</label></div><br/><div class="children"><div class="content">My company used Yup initially but we moved to Zod to be able to infer types from schemas. For example, API response payloads are Zod schemas. OpenAPI components are also generated from Zod schemas.<p>There are some performance issues, and WebStorm is struggling, which forced me over to VS Code.<p>But overall pretty happy.</div><br/><div id="41791201" class="c"><input type="checkbox" id="c-41791201" checked=""/><div class="controls bullet"><span class="by">kabes</span><span>|</span><a href="#41790517">root</a><span>|</span><a href="#41790812">parent</a><span>|</span><a href="#41791000">next</a><span>|</span><label class="collapse" for="c-41791201">[-]</label><label class="expand" for="c-41791201">[1 more]</label></div><br/><div class="children"><div class="content">But Yup also allows to infer types from schemas...</div><br/></div></div></div></div></div></div><div id="41791000" class="c"><input type="checkbox" id="c-41791000" checked=""/><div class="controls bullet"><span class="by">bjacobso</span><span>|</span><a href="#41790517">prev</a><span>|</span><a href="#41796034">next</a><span>|</span><label class="collapse" for="c-41791000">[-]</label><label class="expand" for="c-41791000">[2 more]</label></div><br/><div class="children"><div class="content">zod is great, but I have been moving to @effect&#x2F;schema  and think it deserves a mention here. @effect&#x2F;schema is the evolution of io-ts, which originally inspired zod.<p>It supports decoding as well as encoding, and fits natively into the rest of the effect ecosystem.<p><a href="https:&#x2F;&#x2F;effect.website&#x2F;docs&#x2F;guides&#x2F;schema&#x2F;introduction" rel="nofollow">https:&#x2F;&#x2F;effect.website&#x2F;docs&#x2F;guides&#x2F;schema&#x2F;introduction</a><p>It does come with the cost of importing effect, so might not be the best in certain scenarios. However, there are smaller options than zod if that is a concern.</div><br/><div id="41791434" class="c"><input type="checkbox" id="c-41791434" checked=""/><div class="controls bullet"><span class="by">obeavs</span><span>|</span><a href="#41791000">parent</a><span>|</span><a href="#41796034">next</a><span>|</span><label class="collapse" for="c-41791434">[-]</label><label class="expand" for="c-41791434">[1 more]</label></div><br/><div class="children"><div class="content">Yep. Effect is so cool. The ability encode AND decode is tomorrow&#x27;s standard.<p>With all the work they&#x27;re doing on durable workflows, hard to imagine that 2025 is anyone else&#x27;s year.</div><br/></div></div></div></div><div id="41796034" class="c"><input type="checkbox" id="c-41796034" checked=""/><div class="controls bullet"><span class="by">stevebmark</span><span>|</span><a href="#41791000">prev</a><span>|</span><a href="#41791017">next</a><span>|</span><label class="collapse" for="c-41796034">[-]</label><label class="expand" for="c-41796034">[1 more]</label></div><br/><div class="children"><div class="content">To this day Zod is still a huge PITA to use. See <a href="https:&#x2F;&#x2F;github.com&#x2F;colinhacks&#x2F;zod&#x2F;issues&#x2F;372">https:&#x2F;&#x2F;github.com&#x2F;colinhacks&#x2F;zod&#x2F;issues&#x2F;372</a></div><br/></div></div><div id="41791017" class="c"><input type="checkbox" id="c-41791017" checked=""/><div class="controls bullet"><span class="by">dgellow</span><span>|</span><a href="#41796034">prev</a><span>|</span><a href="#41793583">next</a><span>|</span><label class="collapse" for="c-41791017">[-]</label><label class="expand" for="c-41791017">[1 more]</label></div><br/><div class="children"><div class="content">Zod is fantastic, we use it pretty extensively at Stainless. Definitely one of my favorite JS library. Not calling it a parser combinator was a really good marketing move</div><br/></div></div><div id="41793583" class="c"><input type="checkbox" id="c-41793583" checked=""/><div class="controls bullet"><span class="by">Cu3PO42</span><span>|</span><a href="#41791017">prev</a><span>|</span><a href="#41790751">next</a><span>|</span><label class="collapse" for="c-41793583">[-]</label><label class="expand" for="c-41793583">[4 more]</label></div><br/><div class="children"><div class="content">Zod has been a great boon to a project I&#x27;ve been working on. I get data from multiple sources where strong types cannot be generated and checking the schema of the response has caught a great number of errors early.<p>Another feature that I use intensively is transforming the response to parse JSON into more complex data types, e.g. dates but also project-specific types. In some situations, I also need to serialize these data types back into JSON. This is where Zod lacks most for my use-case. I cannot easily specify bidirectional transforms, instead I need to define two schemas (one for parsing, one for serializing) and only change the transforms. I have added type assertions that should catch any mistakes in this manual process, but it&#x27;d be great if I didn&#x27;t have to keep these two schemas in sync.<p>Another comment mentioned @effect&#x2F;schema [0], which apparently supports these encode&#x2F;decode relationships. I&#x27;m excited to try it out.<p>[0] <a href="https:&#x2F;&#x2F;effect.website&#x2F;docs&#x2F;guides&#x2F;schema&#x2F;introduction" rel="nofollow">https:&#x2F;&#x2F;effect.website&#x2F;docs&#x2F;guides&#x2F;schema&#x2F;introduction</a></div><br/><div id="41794585" class="c"><input type="checkbox" id="c-41794585" checked=""/><div class="controls bullet"><span class="by">aleclarsoniv</span><span>|</span><a href="#41793583">parent</a><span>|</span><a href="#41794448">next</a><span>|</span><label class="collapse" for="c-41794585">[-]</label><label class="expand" for="c-41794585">[2 more]</label></div><br/><div class="children"><div class="content">TypeBox[1] also supports bi-directional transforms.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;sinclairzx81&#x2F;typebox">https:&#x2F;&#x2F;github.com&#x2F;sinclairzx81&#x2F;typebox</a></div><br/><div id="41796866" class="c"><input type="checkbox" id="c-41796866" checked=""/><div class="controls bullet"><span class="by">Cu3PO42</span><span>|</span><a href="#41793583">root</a><span>|</span><a href="#41794585">parent</a><span>|</span><a href="#41794448">next</a><span>|</span><label class="collapse" for="c-41796866">[-]</label><label class="expand" for="c-41796866">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for the pointer! I will certainly consider TypeBox as well when the time comes to migrate.</div><br/></div></div></div></div><div id="41794448" class="c"><input type="checkbox" id="c-41794448" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#41793583">parent</a><span>|</span><a href="#41794585">prev</a><span>|</span><a href="#41790751">next</a><span>|</span><label class="collapse" for="c-41794448">[-]</label><label class="expand" for="c-41794448">[1 more]</label></div><br/><div class="children"><div class="content">I use schema extensively and I can tell you it hits the sweet spot for your use case. We have lots of similar use cases.</div><br/></div></div></div></div><div id="41790751" class="c"><input type="checkbox" id="c-41790751" checked=""/><div class="controls bullet"><span class="by">leontrolski</span><span>|</span><a href="#41793583">prev</a><span>|</span><a href="#41790942">next</a><span>|</span><label class="collapse" for="c-41790751">[-]</label><label class="expand" for="c-41790751">[1 more]</label></div><br/><div class="children"><div class="content">For those of you from a Python background - this is basically  &quot;Pydantic for Typescript&quot;. See also trpc - cross client&#x2F;server typing using zod under the hood - <a href="https:&#x2F;&#x2F;trpc.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;trpc.io&#x2F;</a></div><br/></div></div><div id="41790942" class="c"><input type="checkbox" id="c-41790942" checked=""/><div class="controls bullet"><span class="by">bearjaws</span><span>|</span><a href="#41790751">prev</a><span>|</span><a href="#41794457">next</a><span>|</span><label class="collapse" for="c-41790942">[-]</label><label class="expand" for="c-41790942">[1 more]</label></div><br/><div class="children"><div class="content">One of the brilliant decisions of the AI SDK from Vercel was to use Zod.<p>It makes tool calling and chaining very robust, despite how finicky LLMs can be.</div><br/></div></div><div id="41794457" class="c"><input type="checkbox" id="c-41794457" checked=""/><div class="controls bullet"><span class="by">shadowfiend</span><span>|</span><a href="#41790942">prev</a><span>|</span><a href="#41790292">next</a><span>|</span><label class="collapse" for="c-41794457">[-]</label><label class="expand" for="c-41794457">[3 more]</label></div><br/><div class="children"><div class="content">What’s the go-to reason to use this over ajv? In particular, being rooted in JSON Schema feels like a pretty big win tooling-wise and interop-wise.</div><br/><div id="41796397" class="c"><input type="checkbox" id="c-41796397" checked=""/><div class="controls bullet"><span class="by">Timon3</span><span>|</span><a href="#41794457">parent</a><span>|</span><a href="#41794540">next</a><span>|</span><label class="collapse" for="c-41796397">[-]</label><label class="expand" for="c-41796397">[1 more]</label></div><br/><div class="children"><div class="content">Personally a big factor: I haven&#x27;t had the Zod creator scrape my email and send me a newsletter asking for money. That kind of soured me on ajv.</div><br/></div></div><div id="41794540" class="c"><input type="checkbox" id="c-41794540" checked=""/><div class="controls bullet"><span class="by">petesergeant</span><span>|</span><a href="#41794457">parent</a><span>|</span><a href="#41796397">prev</a><span>|</span><a href="#41790292">next</a><span>|</span><label class="collapse" for="c-41794540">[-]</label><label class="expand" for="c-41794540">[1 more]</label></div><br/><div class="children"><div class="content">You can reflect TS types out of it. There are 3rd party libraries to generate JSON Schemas from Zod objects, which is helpful if you have non-TS clients you want to support</div><br/></div></div></div></div><div id="41790292" class="c"><input type="checkbox" id="c-41790292" checked=""/><div class="controls bullet"><span class="by">diggan</span><span>|</span><a href="#41794457">prev</a><span>|</span><a href="#41790467">next</a><span>|</span><label class="collapse" for="c-41790292">[-]</label><label class="expand" for="c-41790292">[8 more]</label></div><br/><div class="children"><div class="content">As someone who never jumped onto the TypeScript hype-wagon, what is this for? Is this something like clojure.spec by for TypeScript so you can do runtime validation of data instead of compile-time validation?<p>Basically joi (<a href="https:&#x2F;&#x2F;joi.dev&#x2F;api&#x2F;?v=17.13.3" rel="nofollow">https:&#x2F;&#x2F;joi.dev&#x2F;api&#x2F;?v=17.13.3</a>) but different in some way?</div><br/><div id="41790630" class="c"><input type="checkbox" id="c-41790630" checked=""/><div class="controls bullet"><span class="by">newaccountman2</span><span>|</span><a href="#41790292">parent</a><span>|</span><a href="#41790405">next</a><span>|</span><label class="collapse" for="c-41790630">[-]</label><label class="expand" for="c-41790630">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is this something like clojure.spec by for TypeScript so you can do runtime validation of data instead of compile-time<p>not really &quot;instead&quot;, more like &quot;in addition to&quot;. Even if your code compiles, if you are receiving data, e.g., via API, then you need to check that it actually conforms to the type&#x2F;schema you expect. What is run is JS, so it, sadly, won&#x27;t just crash&#x2F;error if an object that is supposed to be of `type Cat = {name: string, ownerId: number}` lacks an `ownerId` at runtime.<p>Have you used Pydantic in Python? It&#x27;s like that, but feels worse, IMO lol. I say this because Pydantic fits into writing Python code much more naturally than writing Zod stuff fits into writing TypeScript, IMO.</div><br/></div></div><div id="41790405" class="c"><input type="checkbox" id="c-41790405" checked=""/><div class="controls bullet"><span class="by">_fat_santa</span><span>|</span><a href="#41790292">parent</a><span>|</span><a href="#41790630">prev</a><span>|</span><a href="#41790414">next</a><span>|</span><label class="collapse" for="c-41790405">[-]</label><label class="expand" for="c-41790405">[2 more]</label></div><br/><div class="children"><div class="content">I think the killer feature of Zod is type inference. Not sure if Joi has support for it yet but you can take a zod schema and wrap it in `z.infer` to get the typescript type.<p>Personally I use zod in my API for body validations, it&#x27;s super nice to write the schema then just use `type Body = z.infer(schema)` to get the TS type to use inside the code.</div><br/><div id="41790936" class="c"><input type="checkbox" id="c-41790936" checked=""/><div class="controls bullet"><span class="by">threatofrain</span><span>|</span><a href="#41790292">root</a><span>|</span><a href="#41790405">parent</a><span>|</span><a href="#41790414">next</a><span>|</span><label class="collapse" for="c-41790936">[-]</label><label class="expand" for="c-41790936">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s table stakes for this niche.</div><br/></div></div></div></div><div id="41790414" class="c"><input type="checkbox" id="c-41790414" checked=""/><div class="controls bullet"><span class="by">naberhausj</span><span>|</span><a href="#41790292">parent</a><span>|</span><a href="#41790405">prev</a><span>|</span><a href="#41790396">next</a><span>|</span><label class="collapse" for="c-41790414">[-]</label><label class="expand" for="c-41790414">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve not used either, but it appears to be similar to JOI, yes.<p>The main distinction is that ZOD allows you to extract a TypeScript type from your schema. This means you get both compile-time and run-time type checking.</div><br/></div></div><div id="41790396" class="c"><input type="checkbox" id="c-41790396" checked=""/><div class="controls bullet"><span class="by">VoidWhisperer</span><span>|</span><a href="#41790292">parent</a><span>|</span><a href="#41790414">prev</a><span>|</span><a href="#41790525">next</a><span>|</span><label class="collapse" for="c-41790396">[-]</label><label class="expand" for="c-41790396">[1 more]</label></div><br/><div class="children"><div class="content">Correct on the part of it being a runtime validation of data library (I can&#x27;t as easily speak to whether or not it is similar to joi, never used it)</div><br/></div></div><div id="41790525" class="c"><input type="checkbox" id="c-41790525" checked=""/><div class="controls bullet"><span class="by">valbaca</span><span>|</span><a href="#41790292">parent</a><span>|</span><a href="#41790396">prev</a><span>|</span><a href="#41790467">next</a><span>|</span><label class="collapse" for="c-41790525">[-]</label><label class="expand" for="c-41790525">[2 more]</label></div><br/><div class="children"><div class="content">yep.<p>Typescript is build-time validation, but in the end TS is &quot;just JS&quot;<p>Zod provides runtime validation (and also works well with TS)</div><br/><div id="41790918" class="c"><input type="checkbox" id="c-41790918" checked=""/><div class="controls bullet"><span class="by">molszanski</span><span>|</span><a href="#41790292">root</a><span>|</span><a href="#41790525">parent</a><span>|</span><a href="#41790467">next</a><span>|</span><label class="collapse" for="c-41790918">[-]</label><label class="expand" for="c-41790918">[1 more]</label></div><br/><div class="children"><div class="content">Deepkit.io has cool validations in runtime based on TS, but it is whole another level.</div><br/></div></div></div></div></div></div><div id="41790467" class="c"><input type="checkbox" id="c-41790467" checked=""/><div class="controls bullet"><span class="by">vorticalbox</span><span>|</span><a href="#41790292">prev</a><span>|</span><a href="#41792952">next</a><span>|</span><label class="collapse" for="c-41790467">[-]</label><label class="expand" for="c-41790467">[1 more]</label></div><br/><div class="children"><div class="content">At work I have used zod, myzod, joi though I have settled on class-validator as it ties in with nestjs really well.</div><br/></div></div><div id="41792952" class="c"><input type="checkbox" id="c-41792952" checked=""/><div class="controls bullet"><span class="by">agluszak</span><span>|</span><a href="#41790467">prev</a><span>|</span><a href="#41791048">next</a><span>|</span><label class="collapse" for="c-41792952">[-]</label><label class="expand" for="c-41792952">[8 more]</label></div><br/><div class="children"><div class="content">Could someone explain to me what problem exactly Zod solves?<p>Why do you need to do `type User = z.infer&lt;typeof User&gt;;` instead of declaring a class with typed fields and, idk, deriving a parser for it somehow? (like you would with Serde in Rust for example). I don&#x27;t understand why Zod creates something which looks like an orthogonal type hierarchy.<p>For context: I come from the backend land, I enjoy strong, static typing, but I have very little experience with JS&#x2F;TS and structural typing</div><br/><div id="41793133" class="c"><input type="checkbox" id="c-41793133" checked=""/><div class="controls bullet"><span class="by">tubthumper8</span><span>|</span><a href="#41792952">parent</a><span>|</span><a href="#41793072">next</a><span>|</span><label class="collapse" for="c-41793133">[-]</label><label class="expand" for="c-41793133">[1 more]</label></div><br/><div class="children"><div class="content">&gt; deriving a parser for it somehow<p>Serde in Rust does this with the Rust macro system, but TypeScript doesn&#x27;t have a macro system. That&#x27;s why people have to go the other way, the programmer defines the parser, then TypeScript can infer the type from the parser.<p>I have seen a library that invented their own macro system (a script that you configure to run before build, and it writes code into your node_modules directory), though I can&#x27;t recall the name.</div><br/></div></div><div id="41793072" class="c"><input type="checkbox" id="c-41793072" checked=""/><div class="controls bullet"><span class="by">arzig</span><span>|</span><a href="#41792952">parent</a><span>|</span><a href="#41793133">prev</a><span>|</span><a href="#41794173">next</a><span>|</span><label class="collapse" for="c-41793072">[-]</label><label class="expand" for="c-41793072">[1 more]</label></div><br/><div class="children"><div class="content">There’s no macro system in TS that could analyze the type to build the parser. So, you work the other way and build the parser and then produce the type from that.</div><br/></div></div><div id="41793028" class="c"><input type="checkbox" id="c-41793028" checked=""/><div class="controls bullet"><span class="by">_heimdall</span><span>|</span><a href="#41792952">parent</a><span>|</span><a href="#41794173">prev</a><span>|</span><a href="#41793017">next</a><span>|</span><label class="collapse" for="c-41793028">[-]</label><label class="expand" for="c-41793028">[1 more]</label></div><br/><div class="children"><div class="content">Zod offers runtime type validation where typescript only does this at build time. You can also use it for data normalization, safely parsing date strings to Date objects for example.</div><br/></div></div><div id="41793017" class="c"><input type="checkbox" id="c-41793017" checked=""/><div class="controls bullet"><span class="by">outlore</span><span>|</span><a href="#41792952">parent</a><span>|</span><a href="#41793028">prev</a><span>|</span><a href="#41792979">next</a><span>|</span><label class="collapse" for="c-41793017">[-]</label><label class="expand" for="c-41793017">[1 more]</label></div><br/><div class="children"><div class="content">The “type User =“ statement creates a TypeScript type from the zod schema, which can be useful when passing that definition around to functions<p>The schema object is useful for runtime validation, e.g. User.parse(). this is handy when validating payloads that come over the wire that might be untrusted. the output of the “parse()” function is an object of type User<p>you can kind of think of it like marshaling Json into a struct in Go :)</div><br/></div></div><div id="41792979" class="c"><input type="checkbox" id="c-41792979" checked=""/><div class="controls bullet"><span class="by">xmonkee</span><span>|</span><a href="#41792952">parent</a><span>|</span><a href="#41793017">prev</a><span>|</span><a href="#41793043">next</a><span>|</span><label class="collapse" for="c-41792979">[-]</label><label class="expand" for="c-41792979">[1 more]</label></div><br/><div class="children"><div class="content">The User object in your example is used to parse the data. Its the “somehow” part of your question. There is no way to go from a type to data in typescript (there is no runtime awareness of types whatsoever) so zod solves this by you writing the zod object and then deriving the type from <i>it</i>. Basically you only have to weite one thing to get the parser and the type.</div><br/></div></div><div id="41793043" class="c"><input type="checkbox" id="c-41793043" checked=""/><div class="controls bullet"><span class="by">cheriot</span><span>|</span><a href="#41792952">parent</a><span>|</span><a href="#41792979">prev</a><span>|</span><a href="#41791048">next</a><span>|</span><label class="collapse" for="c-41793043">[-]</label><label class="expand" for="c-41793043">[1 more]</label></div><br/><div class="children"><div class="content">I used it to validate data from config files matched the schema. I imagine it could be useful for other sources of suppose-to-be-structured data like an http body.</div><br/></div></div></div></div><div id="41791048" class="c"><input type="checkbox" id="c-41791048" checked=""/><div class="controls bullet"><span class="by">root_axis</span><span>|</span><a href="#41792952">prev</a><span>|</span><a href="#41794283">next</a><span>|</span><label class="collapse" for="c-41791048">[-]</label><label class="expand" for="c-41791048">[1 more]</label></div><br/><div class="children"><div class="content">I prefer typebox because it uses JSON schema. As far I&#x27;m aware it&#x27;s otherwise on par with Zod, but I might be unaware of some capabilities of Zod that typebox lacks.</div><br/></div></div><div id="41794283" class="c"><input type="checkbox" id="c-41794283" checked=""/><div class="controls bullet"><span class="by">matt7340</span><span>|</span><a href="#41791048">prev</a><span>|</span><a href="#41790702">next</a><span>|</span><label class="collapse" for="c-41794283">[-]</label><label class="expand" for="c-41794283">[1 more]</label></div><br/><div class="children"><div class="content">I really like the Decoders library for this. Similar in function to Zod, but a more Elm inspired approach - <a href="https:&#x2F;&#x2F;decoders.cc&#x2F;" rel="nofollow">https:&#x2F;&#x2F;decoders.cc&#x2F;</a></div><br/></div></div><div id="41790702" class="c"><input type="checkbox" id="c-41790702" checked=""/><div class="controls bullet"><span class="by">psadri</span><span>|</span><a href="#41794283">prev</a><span>|</span><a href="#41790875">next</a><span>|</span><label class="collapse" for="c-41790702">[-]</label><label class="expand" for="c-41790702">[2 more]</label></div><br/><div class="children"><div class="content">One thing to note about zod - it clones objects as it validates (parses) them.  Eg z.array(z.object()) with an array of 10k objects will result in 10k cloned objects → slow.</div><br/><div id="41790907" class="c"><input type="checkbox" id="c-41790907" checked=""/><div class="controls bullet"><span class="by">molszanski</span><span>|</span><a href="#41790702">parent</a><span>|</span><a href="#41790875">next</a><span>|</span><label class="collapse" for="c-41790907">[-]</label><label class="expand" for="c-41790907">[1 more]</label></div><br/><div class="children"><div class="content">I would suggest <a href="https:&#x2F;&#x2F;arktype.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;arktype.io&#x2F;</a>. Much faster on my project</div><br/></div></div></div></div><div id="41790875" class="c"><input type="checkbox" id="c-41790875" checked=""/><div class="controls bullet"><span class="by">molszanski</span><span>|</span><a href="#41790702">prev</a><span>|</span><a href="#41791757">next</a><span>|</span><label class="collapse" for="c-41790875">[-]</label><label class="expand" for="c-41790875">[2 more]</label></div><br/><div class="children"><div class="content">I very much enjoy more an alternative. 
Sadly much less hyped    
<a href="https:&#x2F;&#x2F;arktype.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;arktype.io&#x2F;</a></div><br/><div id="41790896" class="c"><input type="checkbox" id="c-41790896" checked=""/><div class="controls bullet"><span class="by">threatofrain</span><span>|</span><a href="#41790875">parent</a><span>|</span><a href="#41791757">next</a><span>|</span><label class="collapse" for="c-41790896">[-]</label><label class="expand" for="c-41790896">[1 more]</label></div><br/><div class="children"><div class="content">What do you like most about arktype?</div><br/></div></div></div></div><div id="41791757" class="c"><input type="checkbox" id="c-41791757" checked=""/><div class="controls bullet"><span class="by">BenoitP</span><span>|</span><a href="#41790875">prev</a><span>|</span><a href="#41790912">next</a><span>|</span><label class="collapse" for="c-41791757">[-]</label><label class="expand" for="c-41791757">[1 more]</label></div><br/><div class="children"><div class="content">And thus custom validation goes to json, completing a what is old is new again cycle. After XML&#x2F;XSD, after CORBA.</div><br/></div></div><div id="41790912" class="c"><input type="checkbox" id="c-41790912" checked=""/><div class="controls bullet"><span class="by">aleksiy123</span><span>|</span><a href="#41791757">prev</a><span>|</span><a href="#41790773">next</a><span>|</span><label class="collapse" for="c-41790912">[-]</label><label class="expand" for="c-41790912">[6 more]</label></div><br/><div class="children"><div class="content">Does anyone have a nice combination of tooling for typed handlers + client generation.<p>Thinking maybe Zod + Zod open API.<p>Really looking to replicate similar   spec first workflow similar to protobuf services.<p><a href="https:&#x2F;&#x2F;typespec.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;typespec.io&#x2F;</a> also looks promising but seems early.</div><br/><div id="41790949" class="c"><input type="checkbox" id="c-41790949" checked=""/><div class="controls bullet"><span class="by">mnahkies</span><span>|</span><a href="#41790912">parent</a><span>|</span><a href="#41790939">next</a><span>|</span><label class="collapse" for="c-41790949">[-]</label><label class="expand" for="c-41790949">[1 more]</label></div><br/><div class="children"><div class="content">My tool <a href="https:&#x2F;&#x2F;openapi-code-generator.nahkies.co.nz&#x2F;overview&#x2F;about" rel="nofollow">https:&#x2F;&#x2F;openapi-code-generator.nahkies.co.nz&#x2F;overview&#x2F;about</a> generates typed handlers based around koa (routing, req&#x2F;res validation using zod) from openapi 3, as well as typed clients with optional zod validation using fetch&#x2F;axios.<p>It also supports typespec using their transpilation to openapi 3 tooling</div><br/></div></div><div id="41790939" class="c"><input type="checkbox" id="c-41790939" checked=""/><div class="controls bullet"><span class="by">bjacobso</span><span>|</span><a href="#41790912">parent</a><span>|</span><a href="#41790949">prev</a><span>|</span><a href="#41790773">next</a><span>|</span><label class="collapse" for="c-41790939">[-]</label><label class="expand" for="c-41790939">[4 more]</label></div><br/><div class="children"><div class="content">I think you are looking for <a href="https:&#x2F;&#x2F;ts-rest.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ts-rest.com&#x2F;</a></div><br/><div id="41790984" class="c"><input type="checkbox" id="c-41790984" checked=""/><div class="controls bullet"><span class="by">kaoD</span><span>|</span><a href="#41790912">root</a><span>|</span><a href="#41790939">parent</a><span>|</span><a href="#41790773">next</a><span>|</span><label class="collapse" for="c-41790984">[-]</label><label class="expand" for="c-41790984">[3 more]</label></div><br/><div class="children"><div class="content">Nice. I&#x27;m looking to migrate away from a legacy custom framework over Express and this could help.<p>If someone has tried both, can anyone share how it compares with tRPC[0]?<p>[0] <a href="https:&#x2F;&#x2F;trpc.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;trpc.io&#x2F;</a></div><br/><div id="41791036" class="c"><input type="checkbox" id="c-41791036" checked=""/><div class="controls bullet"><span class="by">bjacobso</span><span>|</span><a href="#41790912">root</a><span>|</span><a href="#41790984">parent</a><span>|</span><a href="#41793078">next</a><span>|</span><label class="collapse" for="c-41791036">[-]</label><label class="expand" for="c-41791036">[1 more]</label></div><br/><div class="children"><div class="content">From my understanding trpc is very similar, however, the rpc mechanism is not a standard. ts-rest produces openapi schemas and speaks REST over http, as well as a typed client.<p>That being said, I am actually slowly migrating off ts-rest and adopting @effect&#x2F;schema and @effect&#x2F;platform&#x2F;HttpApi, I foresee this being the direction the typescript ecosystem heads in over the next few years. However, the APIs are not stable yet and it has a bit of a learning curve, so would not adopt lightly</div><br/></div></div><div id="41793078" class="c"><input type="checkbox" id="c-41793078" checked=""/><div class="controls bullet"><span class="by">AWebOfBrown</span><span>|</span><a href="#41790912">root</a><span>|</span><a href="#41790984">parent</a><span>|</span><a href="#41791036">prev</a><span>|</span><a href="#41790773">next</a><span>|</span><label class="collapse" for="c-41793078">[-]</label><label class="expand" for="c-41793078">[1 more]</label></div><br/><div class="children"><div class="content">I really wanted to adopt tRPC but the deal breaker was it being opinionated on status codes without allowing configurability. Because I needed to meet an existing API spec, that meant ts-rest was a better option. I think there&#x27;s an aditional option with a native spec generator in frameworks like Hono, and maybe Elysia.</div><br/></div></div></div></div></div></div></div></div><div id="41790773" class="c"><input type="checkbox" id="c-41790773" checked=""/><div class="controls bullet"><span class="by">brap</span><span>|</span><a href="#41790912">prev</a><span>|</span><label class="collapse" for="c-41790773">[-]</label><label class="expand" for="c-41790773">[6 more]</label></div><br/><div class="children"><div class="content">I always found it pretty awkward that you even need libraries like this. A limitation of TS I suppose.</div><br/><div id="41794879" class="c"><input type="checkbox" id="c-41794879" checked=""/><div class="controls bullet"><span class="by">bluepnume</span><span>|</span><a href="#41790773">parent</a><span>|</span><a href="#41796693">next</a><span>|</span><label class="collapse" for="c-41794879">[-]</label><label class="expand" for="c-41794879">[4 more]</label></div><br/><div class="children"><div class="content">You find it weird that a type system doesn&#x27;t do runtime validation? Is that common in many other languages?</div><br/><div id="41796879" class="c"><input type="checkbox" id="c-41796879" checked=""/><div class="controls bullet"><span class="by">dhruvrajvanshi</span><span>|</span><a href="#41790773">root</a><span>|</span><a href="#41794879">parent</a><span>|</span><a href="#41796514">next</a><span>|</span><label class="collapse" for="c-41796879">[-]</label><label class="expand" for="c-41796879">[1 more]</label></div><br/><div class="children"><div class="content">Well in most statically typed languages with a VM (Java&#x2F;C#), there&#x27;s some sort of runtime validation<p>In Java
   Object something = new Map();
   String badCast = (Object) something; &#x2F;&#x2F; This line would throw a ClassCastException because something is not a String<p>This has the advantage of throwing an exception in the correct place, instead of somewhere down the line.</div><br/></div></div><div id="41796514" class="c"><input type="checkbox" id="c-41796514" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#41790773">root</a><span>|</span><a href="#41794879">parent</a><span>|</span><a href="#41796879">prev</a><span>|</span><a href="#41796693">next</a><span>|</span><label class="collapse" for="c-41796514">[-]</label><label class="expand" for="c-41796514">[2 more]</label></div><br/><div class="children"><div class="content">Other statically-typed languages do have to deal with the problem of parsing external objects. In my experience, none of them have parsers as good as Zod in terms of ergonomics.</div><br/><div id="41796895" class="c"><input type="checkbox" id="c-41796895" checked=""/><div class="controls bullet"><span class="by">dhruvrajvanshi</span><span>|</span><a href="#41790773">root</a><span>|</span><a href="#41796514">parent</a><span>|</span><a href="#41796693">next</a><span>|</span><label class="collapse" for="c-41796895">[-]</label><label class="expand" for="c-41796895">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Other statically-typed languages do have to deal with the problem of parsing external objects.<p>Well that&#x27;s just blatantly not true. Which languages are you thinking of? I&#x27;m sure I&#x27;m misunderstanding what you said.<p>I can&#x27;t think of a single server side language that doesn&#x27;t have to parse external untyped objects. That&#x27;s where these serialization libraries come into play.<p>For example, in Kotlin, you declare a data class and mark it as @Serializable and it generateds `toJSON&#x2F;fromJSON` for you. IMO it&#x27;s a much better experience than Zod.</div><br/></div></div></div></div></div></div><div id="41796693" class="c"><input type="checkbox" id="c-41796693" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41790773">parent</a><span>|</span><a href="#41794879">prev</a><span>|</span><label class="collapse" for="c-41796693">[-]</label><label class="expand" for="c-41796693">[1 more]</label></div><br/><div class="children"><div class="content">What language <i>doesn&#x27;t</i> need libraries like this?!<p>Java - Jackson<p>Rust - serde<p>Python - marshmallow<p>etc</div><br/></div></div></div></div></div></div></div></div></div></body></html>