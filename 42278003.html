<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733302858227" as="style"/><link rel="stylesheet" href="styles.css?v=1733302858227"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://gendignoux.com/blog/2024/11/18/rust-rayon-optimized.html">Making a parallel Rust workload 10x faster with (or without) Rayon</a> <span class="domain">(<a href="https://gendignoux.com">gendignoux.com</a>)</span></div><div class="subtext"><span>lukastyrychtr</span> | <span>23 comments</span></div><br/><div><div id="42312616" class="c"><input type="checkbox" id="c-42312616" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#42315180">next</a><span>|</span><label class="collapse" for="c-42312616">[-]</label><label class="expand" for="c-42312616">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen this over and over. One of the main issues pointed out by TFA is that there&#x27;s too many small tasks allocated for parallel execution. Rayon is not going to magically distribute your work perfectly, though it very often does a decent job.<p>If your algorithm is the equivalent of a couple of nested iterations, you have essentially three options: parallelize outer, inner, or both. In the vast majority of the cases I&#x27;ve run into, you want thread&#x2F;task level parallelism on the outer loop (only), and if required, data&#x2F;simd parallelism on the inner loop(s).<p>It&#x27;s a rule of thumb, but it biases towards batches of work assigned to CPUs for a decent amount of time, allowing cache locality and pipelining to kick in. That&#x27;s even before SIMD.</div><br/><div id="42313042" class="c"><input type="checkbox" id="c-42313042" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#42312616">parent</a><span>|</span><a href="#42313558">next</a><span>|</span><label class="collapse" for="c-42313042">[-]</label><label class="expand" for="c-42313042">[2 more]</label></div><br/><div class="children"><div class="content">The rule of thumb also keeps you from doing a lot of task switching.  It isn&#x27;t free enqueue and dequeue tasks.  It is better if you have a million things to do to have a smaller set of tasks.  Especially if the runtime for those tasks are somewhat uniform.</div><br/><div id="42314461" class="c"><input type="checkbox" id="c-42314461" checked=""/><div class="controls bullet"><span class="by">mcronce</span><span>|</span><a href="#42312616">root</a><span>|</span><a href="#42313042">parent</a><span>|</span><a href="#42313558">next</a><span>|</span><label class="collapse" for="c-42314461">[-]</label><label class="expand" for="c-42314461">[1 more]</label></div><br/><div class="children"><div class="content">For sure.  Context switching tasks is certainly a lot cheaper than context switching threads, but it isn&#x27;t free.</div><br/></div></div></div></div><div id="42313558" class="c"><input type="checkbox" id="c-42313558" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#42312616">parent</a><span>|</span><a href="#42313042">prev</a><span>|</span><a href="#42315180">next</a><span>|</span><label class="collapse" for="c-42313558">[-]</label><label class="expand" for="c-42313558">[1 more]</label></div><br/><div class="children"><div class="content">Larger grain size better.</div><br/></div></div></div></div><div id="42315180" class="c"><input type="checkbox" id="c-42315180" checked=""/><div class="controls bullet"><span class="by">xnorswap</span><span>|</span><a href="#42312616">prev</a><span>|</span><a href="#42313705">next</a><span>|</span><label class="collapse" for="c-42315180">[-]</label><label class="expand" for="c-42315180">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confused by the before &#x2F; after graph, this is how I&#x27;m reading the graphs:<p>The &quot;before&quot; graph shows a ~300ms wall-clock time which drops to ~150ms parallelised.<p>The &quot;after&quot; graph shows a ~27ms wall-clock time which drops to ~17ms when parallelised.<p>Isn&#x27;t all the improvement still outside of the parallelisation then? There&#x27;s an awful lot of discussion about parallelisation and the behaviour of schedulers given there wasn&#x27;t any improvement of how parallelisable the end result was?</div><br/><div id="42315681" class="c"><input type="checkbox" id="c-42315681" checked=""/><div class="controls bullet"><span class="by">meheleventyone</span><span>|</span><a href="#42315180">parent</a><span>|</span><a href="#42313705">next</a><span>|</span><label class="collapse" for="c-42315681">[-]</label><label class="expand" for="c-42315681">[1 more]</label></div><br/><div class="children"><div class="content">The reported benefit of using the custom threading implementation over rayon was 20% according to the article. So not nothing but not the biggest win. If they were able to rejig the algorithm so they could parralelize the outer loop there&#x27;s probably a bigger win to be had.</div><br/></div></div></div></div><div id="42313705" class="c"><input type="checkbox" id="c-42313705" checked=""/><div class="controls bullet"><span class="by">ModernMech</span><span>|</span><a href="#42315180">prev</a><span>|</span><a href="#42313759">next</a><span>|</span><label class="collapse" for="c-42313705">[-]</label><label class="expand" for="c-42313705">[2 more]</label></div><br/><div class="children"><div class="content">Per the article&#x27;s &quot;Using the right profiling tools&quot;, I have gone through a similar profiling journey in Rust and found this tool very useful: <a href="https:&#x2F;&#x2F;superluminal.eu&#x2F;rust&#x2F;" rel="nofollow">https:&#x2F;&#x2F;superluminal.eu&#x2F;rust&#x2F;</a><p>Works on Windows, has a great GUI, shows pretty flame charts, really pleasant to use. Costs money but worth it.</div><br/><div id="42314135" class="c"><input type="checkbox" id="c-42314135" checked=""/><div class="controls bullet"><span class="by">yazzku</span><span>|</span><a href="#42313705">parent</a><span>|</span><a href="#42313759">next</a><span>|</span><label class="collapse" for="c-42314135">[-]</label><label class="expand" for="c-42314135">[1 more]</label></div><br/><div class="children"><div class="content">Superluminal is a sampling profiler for the most part. It works great for what it does, sure. But in the author&#x27;s own words:<p>&gt; So far, we’ve only used perf to record stack traces at a regular time interval. This is useful, but only scratching the surface.<p>For cache hits and other counters, you&#x27;re gonna have to go deeper than just sampling.</div><br/></div></div></div></div><div id="42313759" class="c"><input type="checkbox" id="c-42313759" checked=""/><div class="controls bullet"><span class="by">ciupicri</span><span>|</span><a href="#42313705">prev</a><span>|</span><label class="collapse" for="c-42313759">[-]</label><label class="expand" for="c-42313759">[14 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand why is he running it under Docker when one of the touted benefits of Rust is that all you need to do is just copy &amp; run the binary on the destination machine.</div><br/><div id="42313817" class="c"><input type="checkbox" id="c-42313817" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#42313759">parent</a><span>|</span><a href="#42314477">next</a><span>|</span><label class="collapse" for="c-42313817">[-]</label><label class="expand" for="c-42313817">[3 more]</label></div><br/><div class="children"><div class="content">They explain in a different blog post.<p>&gt; Now, you may wonder why profiling Rust code within Docker, an engine to run containerized applications. The main advantage of containers is that when configured properly, they provide isolation from the rest of your system, allowing to restrict access to resources (files, networking, memory, etc.).<p><a href="https:&#x2F;&#x2F;gendignoux.com&#x2F;blog&#x2F;2019&#x2F;11&#x2F;09&#x2F;profiling-rust-docker-perf.html" rel="nofollow">https:&#x2F;&#x2F;gendignoux.com&#x2F;blog&#x2F;2019&#x2F;11&#x2F;09&#x2F;profiling-rust-docker...</a></div><br/><div id="42314665" class="c"><input type="checkbox" id="c-42314665" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#42313759">root</a><span>|</span><a href="#42313817">parent</a><span>|</span><a href="#42314477">next</a><span>|</span><label class="collapse" for="c-42314665">[-]</label><label class="expand" for="c-42314665">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always heard that containers don&#x27;t actually provide that much by way of security, although I imagine that maybe it could provide some value as one of many layers of a more in-depth defense. Is what I&#x27;ve heard correct here, or am I maybe missing some nuance?</div><br/><div id="42315427" class="c"><input type="checkbox" id="c-42315427" checked=""/><div class="controls bullet"><span class="by">khafra</span><span>|</span><a href="#42313759">root</a><span>|</span><a href="#42314665">parent</a><span>|</span><a href="#42314477">next</a><span>|</span><label class="collapse" for="c-42315427">[-]</label><label class="expand" for="c-42315427">[1 more]</label></div><br/><div class="children"><div class="content">I think there&#x27;s a somewhat fine distinction to be made, here. An analogy is chroot. It&#x27;s not a &quot;security tool,&quot; and there are many ways to break out of a chroot jail, but it does provide some isolation, and that does provide a measure of security. If you run an application inside a container, and you have that container well-configured, it&#x27;s going to be harder for someone with an RCE on that application to affect the rest of your system than if you weren&#x27;t running that application in a container.<p>But a container does not provide a security boundary in the same sense as the security boundary between kernel mode and user mode.</div><br/></div></div></div></div></div></div><div id="42314477" class="c"><input type="checkbox" id="c-42314477" checked=""/><div class="controls bullet"><span class="by">mcronce</span><span>|</span><a href="#42313759">parent</a><span>|</span><a href="#42313817">prev</a><span>|</span><a href="#42313764">next</a><span>|</span><label class="collapse" for="c-42314477">[-]</label><label class="expand" for="c-42314477">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that&#x27;s a commonly touted benefit of Rust.<p>You certainly <i>can</i> build a statically linked binary with musl libc (in many circumstances, at least), but it&#x27;s not the default.<p>The default is a binary that statically links all the Rust crates you pull in, but dynamically links glibc, the vdso, and several other common dependencies.  It&#x27;s also, IIRC, the default to dynamically link many other common dependencies like openssl if you pull them in, although I think it&#x27;s common for the crates that wrap them to offer static linking as an option.</div><br/><div id="42314693" class="c"><input type="checkbox" id="c-42314693" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#42313759">root</a><span>|</span><a href="#42314477">parent</a><span>|</span><a href="#42313764">next</a><span>|</span><label class="collapse" for="c-42314693">[-]</label><label class="expand" for="c-42314693">[1 more]</label></div><br/><div class="children"><div class="content">Quite a lot of things can get by without needing any other dynamic libraries other than libc; there are some alternatives to using openssl in Rust that are fairly common. There definitely are places I&#x27;ve seen containers used for building&#x2F;deploying Rust due to the need for dynamically-linked dependencies, but I&#x27;ve also seen it a bit in places where they already are using containers for everything else, and using the same thing for all of their services regardless of whether they&#x27;re in Rust, Node, Python can can make the process around deployment simpler rather than having a separate way of doing things for each language.</div><br/></div></div></div></div><div id="42313764" class="c"><input type="checkbox" id="c-42313764" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#42313759">parent</a><span>|</span><a href="#42314477">prev</a><span>|</span><a href="#42314799">next</a><span>|</span><label class="collapse" for="c-42313764">[-]</label><label class="expand" for="c-42313764">[4 more]</label></div><br/><div class="children"><div class="content">&gt; one of the touted benefits of Rust is that all you need to do is just copy &amp; run the binary on the destination machine<p>is it? I&#x27;ve heard that about Go, not so much Rust. cargo doesn&#x27;t statically link system dependencies by default, only other rust dependencies.</div><br/><div id="42313955" class="c"><input type="checkbox" id="c-42313955" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#42313759">root</a><span>|</span><a href="#42313764">parent</a><span>|</span><a href="#42314799">next</a><span>|</span><label class="collapse" for="c-42313955">[-]</label><label class="expand" for="c-42313955">[3 more]</label></div><br/><div class="children"><div class="content">Go statically links C deps? Like gtk?</div><br/><div id="42314524" class="c"><input type="checkbox" id="c-42314524" checked=""/><div class="controls bullet"><span class="by">password4321</span><span>|</span><a href="#42313759">root</a><span>|</span><a href="#42313955">parent</a><span>|</span><a href="#42314799">next</a><span>|</span><label class="collapse" for="c-42314524">[-]</label><label class="expand" for="c-42314524">[2 more]</label></div><br/><div class="children"><div class="content">I think the point is Go doesn&#x27;t have C deps by default like Rust does.</div><br/><div id="42314930" class="c"><input type="checkbox" id="c-42314930" checked=""/><div class="controls bullet"><span class="by">m0shen</span><span>|</span><a href="#42313759">root</a><span>|</span><a href="#42314524">parent</a><span>|</span><a href="#42314799">next</a><span>|</span><label class="collapse" for="c-42314930">[-]</label><label class="expand" for="c-42314930">[1 more]</label></div><br/><div class="children"><div class="content">I thought it depended on libc by default?</div><br/></div></div></div></div></div></div></div></div><div id="42314799" class="c"><input type="checkbox" id="c-42314799" checked=""/><div class="controls bullet"><span class="by">kristianp</span><span>|</span><a href="#42313759">parent</a><span>|</span><a href="#42313764">prev</a><span>|</span><a href="#42314072">next</a><span>|</span><label class="collapse" for="c-42314799">[-]</label><label class="expand" for="c-42314799">[1 more]</label></div><br/><div class="children"><div class="content">He&#x27;s running docker to make it easier to clean up and return to a clean slate.  Profiling in itself doesn&#x27;t require docker, I think it needlessly adds to the complexity of the task of profiling, unless its providing clear benefits.</div><br/></div></div><div id="42314072" class="c"><input type="checkbox" id="c-42314072" checked=""/><div class="controls bullet"><span class="by">vips7L</span><span>|</span><a href="#42313759">parent</a><span>|</span><a href="#42314799">prev</a><span>|</span><label class="collapse" for="c-42314072">[-]</label><label class="expand" for="c-42314072">[3 more]</label></div><br/><div class="children"><div class="content">Except if the destination machine is an entirely different architecture or doesn’t include the same instructions as the compilation machine…</div><br/><div id="42314109" class="c"><input type="checkbox" id="c-42314109" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#42313759">root</a><span>|</span><a href="#42314072">parent</a><span>|</span><label class="collapse" for="c-42314109">[-]</label><label class="expand" for="c-42314109">[2 more]</label></div><br/><div class="children"><div class="content">Docker doesn&#x27;t solve that problem</div><br/><div id="42314954" class="c"><input type="checkbox" id="c-42314954" checked=""/><div class="controls bullet"><span class="by">dymk</span><span>|</span><a href="#42313759">root</a><span>|</span><a href="#42314109">parent</a><span>|</span><label class="collapse" for="c-42314954">[-]</label><label class="expand" for="c-42314954">[1 more]</label></div><br/><div class="children"><div class="content">It does. Docker will by default run images built for different architectures in a virtual machine.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>