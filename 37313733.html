<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693472463117" as="style"/><link rel="stylesheet" href="styles.css?v=1693472463117"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.jntrnr.com/case-for-nushell/">The Case for Nushell</a> <span class="domain">(<a href="https://www.jntrnr.com">www.jntrnr.com</a>)</span></div><div class="subtext"><span>lukastyrychtr</span> | <span>32 comments</span></div><br/><div><div id="37332758" class="c"><input type="checkbox" id="c-37332758" checked=""/><div class="controls bullet"><span class="by">svat</span><span>|</span><a href="#37332861">next</a><span>|</span><label class="collapse" for="c-37332758">[-]</label><label class="expand" for="c-37332758">[2 more]</label></div><br/><div class="children"><div class="content">This may be obvious, but what I realized recently, when I tried to switch to one of the “alternative” shells (xonsh, based on Python), is that the experience of using a shell is (at least) four (overlapping) experiences:<p>1. The basic interactive stuff at the command-line: typing commands, tab-completion, aborting a half-written command when you change your mind or remember something else to do first, cut-and-paste, ….<p>2. Basic scripting at the command-line: writing a loop, piping one command into another, defining a function (over multiple lines?), ….<p>3. Scripting for <i>job control</i>: getting the return value of a command, waiting for a command to finish, putting one in the background, sleep, …<p>4. Programming as in other languages: if&#x2F;else statements, assigning to variables, what arrays look like, doing more complicated logic and processing, ….<p>[There&#x27;s some overlap, and note that (3) or (4) may happen either at the command-line itself or in a separate .sh (or whatever) file in a text editor.]<p>I found that `xonsh` seemed to be focusing on making (4) better—basically replacing the `if … fi` and `case … esac` of Bash&#x2F;Zsh with Python—but it turns out I care about it less, and I&#x27;m too used to (just) 20 years of (1) to miss it: when Alt-. doesn&#x27;t insert the last part of the previous command, or I cut some line(s) with Ctrl-k and Alt-y doesn&#x27;t maintain the kill ring to paste it back (so it&#x27;s gone??), and half-a-dozen other issues like that, it was annoying enough for me to switch back in less than a day or two. I don&#x27;t think of myself as an old&#x2F;long-time user (when I started in 2003 I was a newbie), but I guess I am one by now: don&#x27;t mess with standard readline conventions. And (3) is core to why someone would use shell scripts; if you need me to &quot;import subprocess&quot; or do anything nontrivial to pipe (for example), you&#x27;ve already lost me.<p>My understanding is that fish has focused on (1) with good results, and the &quot;ls | where size &gt; 10kb&quot; example here, or what Powershell is good at, is focusing on another (5) that I didn&#x27;t write about (the commands themselves, the flags to them, parsing their output etc).<p>Anyway, interesting post, I&#x27;ll try out nushell. As the post doesn&#x27;t seem to link to it: <a href="https:&#x2F;&#x2F;www.nushell.sh&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.nushell.sh&#x2F;</a> (install it, and then start it with `nu`, <i>not</i> `nushell`.)</div><br/><div id="37332882" class="c"><input type="checkbox" id="c-37332882" checked=""/><div class="controls bullet"><span class="by">maegul</span><span>|</span><a href="#37332758">parent</a><span>|</span><a href="#37332861">next</a><span>|</span><label class="collapse" for="c-37332882">[-]</label><label class="expand" for="c-37332882">[1 more]</label></div><br/><div class="children"><div class="content">Interesting on (1), I’ve always used vi mode (like I don’t even know those commands, maybe they work in vi mode too?) and from memory Xonsh had as good a vi mode as bash along with some baked in improvements over vanilla bash.<p>I’m more or less waiting to move to Xonsh full time to see how I go once I’ve got some time to invest moving, largely because it seems it will be a win on all 4 points for me.<p>Otherwise, the bigger point 5 you allude to is probably the real issue we’re all avoiding.</div><br/></div></div></div></div><div id="37332861" class="c"><input type="checkbox" id="c-37332861" checked=""/><div class="controls bullet"><span class="by">nickelpro</span><span>|</span><a href="#37332758">prev</a><span>|</span><a href="#37332992">next</a><span>|</span><label class="collapse" for="c-37332861">[-]</label><label class="expand" for="c-37332861">[7 more]</label></div><br/><div class="children"><div class="content">This makes a terrible case for Nushell as a shell. It makes a reasonable case for Nuhsell as a programming language.<p>If I want a programming language I use a programming language. A shell is an interactive environment and only a  programming language by way of the Turing-complete nature of its grammar. However, if I am stringing more than a couple commands together something has gone terribly wrong.<p>The features I care about are features that make that interactivity better, not a type system.</div><br/><div id="37333294" class="c"><input type="checkbox" id="c-37333294" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#37332861">parent</a><span>|</span><a href="#37333479">next</a><span>|</span><label class="collapse" for="c-37333294">[-]</label><label class="expand" for="c-37333294">[3 more]</label></div><br/><div class="children"><div class="content">&gt;<i>If I want a programming language I use a programming language. A shell is an interactive environment</i><p>That&#x27;s the mindset behind us still having crappy shells...</div><br/><div id="37333314" class="c"><input type="checkbox" id="c-37333314" checked=""/><div class="controls bullet"><span class="by">nickelpro</span><span>|</span><a href="#37332861">root</a><span>|</span><a href="#37333294">parent</a><span>|</span><a href="#37333479">next</a><span>|</span><label class="collapse" for="c-37333314">[-]</label><label class="expand" for="c-37333314">[2 more]</label></div><br/><div class="children"><div class="content">If being a good programming language is what makes a shell good, use the Python repl</div><br/><div id="37333333" class="c"><input type="checkbox" id="c-37333333" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#37332861">root</a><span>|</span><a href="#37333314">parent</a><span>|</span><a href="#37333479">next</a><span>|</span><label class="collapse" for="c-37333333">[-]</label><label class="expand" for="c-37333333">[1 more]</label></div><br/><div class="children"><div class="content">The false dichotomy is the issue. There&#x27;s no reason (compatibility aside) a shell can&#x27;t be both a great interactive environment and offer a great language (one 10x more well designed and consistent than what it offers now).</div><br/></div></div></div></div></div></div><div id="37333479" class="c"><input type="checkbox" id="c-37333479" checked=""/><div class="controls bullet"><span class="by">eecc</span><span>|</span><a href="#37332861">parent</a><span>|</span><a href="#37333294">prev</a><span>|</span><a href="#37333007">next</a><span>|</span><label class="collapse" for="c-37333479">[-]</label><label class="expand" for="c-37333479">[1 more]</label></div><br/><div class="children"><div class="content">Uhm, so what about REPLs? Jupyter notebooks? Are they wrong?<p>What if the typedness of the shell made the interaction better? Can you make an argument that this does not hold? The article does make a good argument in favor</div><br/></div></div><div id="37333007" class="c"><input type="checkbox" id="c-37333007" checked=""/><div class="controls bullet"><span class="by">Eji1700</span><span>|</span><a href="#37332861">parent</a><span>|</span><a href="#37333479">prev</a><span>|</span><a href="#37332992">next</a><span>|</span><label class="collapse" for="c-37333007">[-]</label><label class="expand" for="c-37333007">[2 more]</label></div><br/><div class="children"><div class="content">The article admits basically exactly this, but also makes arguments as to why?<p>```<p>He proceeded to explain that if he could recreate many of the techniques we showed all as part of a C++ library that people could use. At this time, I wasn&#x27;t sure how to respond other than &quot;but you don&#x27;t have to, we already built this language&quot; but he couldn&#x27;t be swayed. If it wasn&#x27;t C++, he didn&#x27;t want it.<p>Fast forward a couple years, and I&#x27;m standing in front of a JavaScript audience giving a similar talk, this time promoting TypeScript. I remember the kind of politely confused looks on people&#x27;s faces as I showed off the features TypeScript offered. There was a similar sense of &quot;why do we need to leave JavaScript?&quot;.<p>To answer whether Nushell can overcome this kind of inertia, I&#x27;ll pose two questions:<p><pre><code>    Is Nushell compelling enough for a single person to adopt it?
    Would adopting Nushell broadly as a community move the needle?
</code></pre>
Let&#x27;s tackle the first question. Time and again, as people try Nushell, they come back with quotes like &quot;this is the most excited I&#x27;ve been about tech in 15 years&quot;. It has a fanbase that loves it, and that fanbase is growing. It reminds me of the early days of Rust, just after hitting 1.0.<p>To the second question: would adopting Nushell broadly actually improve things noticeably? Without a doubt. I say this without any reservation. Thinking of our shells as structured, interactive processing engines opens up the doors to a much wider array of things you can do with them. The commands would be far simpler than their POSIX equivalents and would compose far better. They&#x27;d benefit from the full knowledge of the data being shared between them. Adaptors could be made to connect to all parts of the system, allowing you full, structured interaction with everything you have access to.<p>```<p>I enjoy nushell, but I am far far far from the average user&#x2F;target audience. I do not sys admin or anything like it, I mostly use it to quickly navigate the filesystem and, with nushell specifically, occasionally to work with data i&#x27;ve gotten from other things.   I haven&#x27;t gotten quite to the point I would write scripts in it yet, but at the point i&#x27;m considering throwing up an FSX file or going into a repl, I like that I might just be able to use nushell instead for the smaller tasks.<p>Is this useful?  To me, sure, to everyone else, hell if I know.<p>edit-<p>Article even touches on this mindset:<p>&gt; I don&#x27;t need to do heavy data processing everyday, but it&#x27;s nice to not have to shift what I&#x27;m doing at all when I need to do it. I don&#x27;t have to download new utilities or switch languages. It&#x27;s all right there. Need to write a script to load some files and handle some directory processing? Still right there. Need to throw together some web query that outputs the top download results for a github repo? You guessed it, all still right there.</div><br/><div id="37333298" class="c"><input type="checkbox" id="c-37333298" checked=""/><div class="controls bullet"><span class="by">nickelpro</span><span>|</span><a href="#37332861">root</a><span>|</span><a href="#37333007">parent</a><span>|</span><a href="#37332992">next</a><span>|</span><label class="collapse" for="c-37333298">[-]</label><label class="expand" for="c-37333298">[1 more]</label></div><br/><div class="children"><div class="content">The comparisons provided are borderline non-sequiturs<p>The C++ library and Chapel were solving the same problem, but Chapel (in the author&#x27;s framing) did it better. Javascript and Typescript solve the same problem, but Typescript (in the view of people who care about type systems) does it better.<p>Nushell is not trying to solve the same problems as a shell:<p>&gt; Nushell is really an interactive, data-focused scripting language with shell capabilities.<p>Great, but that&#x27;s not the problem I give a damn about. If I want an interactive, data-focused scripting language I will use Python. And against Python, Nushell is not nearly as attractive.<p>Nushell is trying to blend two domains, shells and programming languages, which I see distinct advantages <i>in keeping seperate</i>. I do not want the world to be built on the back of shell scripts, regardless of how good you make the type system. I do not want to ask more of shell scripts and view that as a negative.</div><br/></div></div></div></div></div></div><div id="37332992" class="c"><input type="checkbox" id="c-37332992" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#37332861">prev</a><span>|</span><a href="#37332994">next</a><span>|</span><label class="collapse" for="c-37332992">[-]</label><label class="expand" for="c-37332992">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Recently, I had a chat with some of my friends about Nushell and why they stuck with traditional shells like bash&#x2F;zsh or the &quot;new&quot; hotness like fish rather than using Nushell.<p>Umm... because Nushell is pre-1.0, with major language changes every few weeks?<p>Living on the bleeding edge isn&#x27;t everyone&#x27;s cup of tea, and certainly not with something as fundamental to the system as a shell. Rest assured I will switch the moment 1.0 is released and a stability promise is published.<p>That being said, yeah – Nushell is the real deal. It&#x27;s the Unix philosophy, except this time it actually works.</div><br/><div id="37333370" class="c"><input type="checkbox" id="c-37333370" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#37332992">parent</a><span>|</span><a href="#37332994">next</a><span>|</span><label class="collapse" for="c-37333370">[-]</label><label class="expand" for="c-37333370">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s the Unix philosophy, except this time it actually works.<p>How is Nushell compatible with the Unix philosophy? The core Unix philosophy is about enabling workflows that combine a set of independent tools in novel ways. Nushell implements a monolithic ecosystem with commands that support its fancy features, but using any external command not written for Nushell will be cumbersome at best, and incompatible at worst. This goes against the open philosophy of Unix, which is partly what has allowed it to grow and succeed.</div><br/><div id="37333849" class="c"><input type="checkbox" id="c-37333849" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#37332992">root</a><span>|</span><a href="#37333370">parent</a><span>|</span><a href="#37333788">next</a><span>|</span><label class="collapse" for="c-37333849">[-]</label><label class="expand" for="c-37333849">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The core Unix philosophy is about enabling workflows that combine a set of independent tools in novel ways.<p>You mean like<p><pre><code>    ls | rm
</code></pre>
deletes the files in a directory?<p>Uh wait, that doesn&#x27;t actually work.<p>Because the Unix tools actually don&#x27;t implement the Unix philosophy at all.<p>Because as it turns out, text streams are <i>not</i> a universal interface after all.<p>Nushell succeeds where the coreutils have failed for decades precisely <i>because</i> its commands are designed to work together. They pass structured data around, which means that pipelines can actually work without requiring weird hacks to make one underspecified text format conform to the other. That is the Unix philosophy: Tools that work together.<p>But don&#x27;t worry, the old Unix tools can be used from Nushell – and they work together just as poorly in Nushell as in every other shell, not one bit worse.</div><br/></div></div><div id="37333788" class="c"><input type="checkbox" id="c-37333788" checked=""/><div class="controls bullet"><span class="by">ChrisSD</span><span>|</span><a href="#37332992">root</a><span>|</span><a href="#37333370">parent</a><span>|</span><a href="#37333849">prev</a><span>|</span><a href="#37332994">next</a><span>|</span><label class="collapse" for="c-37333788">[-]</label><label class="expand" for="c-37333788">[1 more]</label></div><br/><div class="children"><div class="content">So long as a tool can output a machine readable format, it can be consumed by nushell. If it can&#x27;t then... that&#x27;s actually a big problem when composing tools in bash too. Parsing arbitrary unstructured text is not good for composition and requires making something bespoke for each and every tool. As well as each and every argument for each and every tool for those arguments that happen to change the output in different ways.</div><br/></div></div></div></div></div></div><div id="37332994" class="c"><input type="checkbox" id="c-37332994" checked=""/><div class="controls bullet"><span class="by">guitarbill</span><span>|</span><a href="#37332992">prev</a><span>|</span><a href="#37333260">next</a><span>|</span><label class="collapse" for="c-37332994">[-]</label><label class="expand" for="c-37332994">[2 more]</label></div><br/><div class="children"><div class="content">Maybe I&#x27;m not using my shell to the fullest, but 95% of commands are pretty simple, and not complicated queries. `ls` might have a bajillion flags, but `-lah` go a long way. Because fish&#x27;s autocomplete, I don&#x27;t have to remember tar flags. That&#x27;s the killer feature for me.<p>Along those lines, a quick way to drive adoption could be a huge &quot;how do i do x&quot; or recipes page to Ctrl+F through. If I have to search the internet for how to do x in nushell&#x2F;fish&#x2F;etc, I might as well stick to arcane bash - at least you know someone has had the same problem before.<p>Make it easy for me to get stuff done by showing me how to get stuff done, and I&#x27;ll grok the shell bit by bit.<p>I did see <a href="https:&#x2F;&#x2F;www.nushell.sh&#x2F;cookbook&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.nushell.sh&#x2F;cookbook&#x2F;</a> , but it isn&#x27;t really a searchable reference. There&#x27;s some setup stuff, other short pages with basic tutorials (?), a link to a repo with example scripts, and for one-liners you are instructed to join a discord. None of these are easily searchable.</div><br/><div id="37333912" class="c"><input type="checkbox" id="c-37333912" checked=""/><div class="controls bullet"><span class="by">westernpopular</span><span>|</span><a href="#37332994">parent</a><span>|</span><a href="#37333260">next</a><span>|</span><label class="collapse" for="c-37333912">[-]</label><label class="expand" for="c-37333912">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Along those lines, a quick way to drive adoption could be a huge &quot;how do i do x&quot; or recipes page to Ctrl+F through. If I have to search the internet for how to do x in nushell&#x2F;fish&#x2F;etc, I might as well stick to arcane bash - at least you know someone has had the same problem before.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;tldr-pages&#x2F;tldr">https:&#x2F;&#x2F;github.com&#x2F;tldr-pages&#x2F;tldr</a></div><br/></div></div></div></div><div id="37333260" class="c"><input type="checkbox" id="c-37333260" checked=""/><div class="controls bullet"><span class="by">hresvelgr</span><span>|</span><a href="#37332994">prev</a><span>|</span><a href="#37333659">next</a><span>|</span><label class="collapse" for="c-37333260">[-]</label><label class="expand" for="c-37333260">[3 more]</label></div><br/><div class="children"><div class="content">The case for Nushell is weak because shells are not an ideal environment, but rather a lowest common denominator by today&#x27;s standards that has stuck and hasn&#x27;t disappeared. What we need is a better interactive environment interface. It baffles me that something like Pharo&#x27;s interactive environment hasn&#x27;t been copied all over the place. I understand it&#x27;s largely because it&#x27;s a self contained environment that it is able to afford the functionality it has, but there are lessons in there worth learning from.</div><br/><div id="37333303" class="c"><input type="checkbox" id="c-37333303" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#37333260">parent</a><span>|</span><a href="#37333659">next</a><span>|</span><label class="collapse" for="c-37333303">[-]</label><label class="expand" for="c-37333303">[2 more]</label></div><br/><div class="children"><div class="content">&gt;<i>The case for Nushell is weak because shells are not an ideal environment</i><p>Not sure what &quot;an ideal environment&quot; even means, but shells have tons of very nice features. The problem is they also have a lot of legacy bs and tons of footguns.</div><br/><div id="37334183" class="c"><input type="checkbox" id="c-37334183" checked=""/><div class="controls bullet"><span class="by">hresvelgr</span><span>|</span><a href="#37333260">root</a><span>|</span><a href="#37333303">parent</a><span>|</span><a href="#37333659">next</a><span>|</span><label class="collapse" for="c-37334183">[-]</label><label class="expand" for="c-37334183">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Not sure what &quot;an ideal environment&quot; even means, but shells have tons of very nice features.<p>If you haven&#x27;t, I would encourage you to try Pharo. It&#x27;s a Smalltalk dialect but you program through what feels like an operating system. The richness in interactivity and feedback is unparalleled. This is what I would consider an &quot;ideal environment.&quot; Shells are useful tools, they wouldn&#x27;t have the ubiquity they do if that weren&#x27;t true. That being said, there&#x27;s definitely more interesting and powerful paradigms out there for interacting with an operating system at a lower level.</div><br/></div></div></div></div></div></div><div id="37333659" class="c"><input type="checkbox" id="c-37333659" checked=""/><div class="controls bullet"><span class="by">fergie</span><span>|</span><a href="#37333260">prev</a><span>|</span><a href="#37333502">next</a><span>|</span><label class="collapse" for="c-37333659">[-]</label><label class="expand" for="c-37333659">[1 more]</label></div><br/><div class="children"><div class="content">Nushell is part of the ongoing Visual Studio-ification of software engineering.<p>TypeScript and Powershell are preferences, not standards. If you want to use them, great, but its wrong to say that these have evolved into defacto ways of doing things.<p>Also- that everything is text in Bash is one of its great strengths, just as Powershell&#x27;s reliance on Objects was generally understood to be a weakness.<p>Also- I don&#x27;t get the need for IDE support? Surely the point of a shell language is that it is designed to be used for a terminal?<p>As others have said here- this feels like a better case for nushell as a scripting language than nushell as a shell.</div><br/></div></div><div id="37333502" class="c"><input type="checkbox" id="c-37333502" checked=""/><div class="controls bullet"><span class="by">jakobnissen</span><span>|</span><a href="#37333659">prev</a><span>|</span><a href="#37314824">next</a><span>|</span><label class="collapse" for="c-37333502">[-]</label><label class="expand" for="c-37333502">[1 more]</label></div><br/><div class="children"><div class="content">Nushell is a great improvement in terms of shell design, and it really does feel like a modern, better equivalent of the shell.<p>However, I tried using it twice as my main shell and had to give up both times. The first time, I experienced a handful of bugs. The most annoying one was that I couldn&#x27;t copy-paste passwords into the shell because Nu kept inserting control characters.
Then I kept having trouble with other programs that rely on the shell - for example, &quot;conda init&quot; does not work with nushell, nor does Julia&#x27;s shell work with nu. So practically speaking, I had to continually boot up zsh inside Nu.<p>Then, there are the constant breaking changes. It feels like every month there is some breaking change, and every few months I need to dig into my nushell setup scripts to unbreak half my shell tools because some syntax changed.<p>Yeah, no thanks. Hopefully someone else will do the annoying work of test running Nu for 5 more years until it&#x27;s stable and integrates well, but for me, I went back to zsh.</div><br/></div></div><div id="37314824" class="c"><input type="checkbox" id="c-37314824" checked=""/><div class="controls bullet"><span class="by">natemcintosh</span><span>|</span><a href="#37333502">prev</a><span>|</span><a href="#37333278">next</a><span>|</span><label class="collapse" for="c-37314824">[-]</label><label class="expand" for="c-37314824">[1 more]</label></div><br/><div class="children"><div class="content">I love using nushell, and I hope it becomes a standard going forward. I do sometimes feel slightly annoyed that I have to type out a bit more in nushell, as opposed to simply tacking on another flag, but I think JT makes a really great case for doing just that. In terms of adoption, JT asks:<p>1. Is Nushell compelling enough for a single person to adopt it?
2. Would adopting Nushell broadly as a community move the needle?<p>I&#x27;m 100% on board with nushell in my personal computing. But I&#x27;m still worried about number 2. I think something like rust was able to succeed because enough people really felt like there a need for something to fill that space. Do enough people feel like nushell fills a necessary gap? I hope so.</div><br/></div></div><div id="37333278" class="c"><input type="checkbox" id="c-37333278" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#37314824">prev</a><span>|</span><a href="#37333036">next</a><span>|</span><label class="collapse" for="c-37333278">[-]</label><label class="expand" for="c-37333278">[1 more]</label></div><br/><div class="children"><div class="content">This post implies the decision is between nushell, MS Powershell or something based on shells from the 70s. But there are a plethora of other shells like nushell, that have been around for longer than nushell.<p>It’s actually a pretty crowded market space.<p>So why are people still using bash? In part because it’s a default (defaults are hard to change) and in part because it’s largely “good enough”.<p>It’s the same reason JavaScript is everywhere. First because it was the default in browsers and then because it was good enough that people didn’t want the effort of having to learn nor use another language.</div><br/></div></div><div id="37333036" class="c"><input type="checkbox" id="c-37333036" checked=""/><div class="controls bullet"><span class="by">parasitid</span><span>|</span><a href="#37333278">prev</a><span>|</span><a href="#37333210">next</a><span>|</span><label class="collapse" for="c-37333036">[-]</label><label class="expand" for="c-37333036">[1 more]</label></div><br/><div class="children"><div class="content">and there shall be Emacs Shell ;)<p><a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;emacs&#x2F;manual&#x2F;html_mono&#x2F;eshell.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;emacs&#x2F;manual&#x2F;html_mono&#x2F;eshell.h...</a></div><br/></div></div><div id="37333210" class="c"><input type="checkbox" id="c-37333210" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#37333036">prev</a><span>|</span><a href="#37333191">next</a><span>|</span><label class="collapse" for="c-37333210">[-]</label><label class="expand" for="c-37333210">[3 more]</label></div><br/><div class="children"><div class="content">Nushell is definitely interesting, and I&#x27;m glad it exists, but I&#x27;m not using it because of at least a couple of major reasons:<p>- It reimplements all commands. You&#x27;re not actually using GNU coreutils, but Nushell reimplementations of ls, rm, etc. See [1].<p>I understand why it&#x27;s done, but this has many drawbacks:<p>1. All existing shell examples and documentation spanning decades are useless. Nushell commands try to replicate existing UIs, but they invariably must be incompatible to support all features and deprecate unnecessary ones, so the only valid source of documentation is Nushell itself.<p>2. Nushell-specific bugs[2,3]. This goes without saying, and will improve as the project matures, but experiencing bugs with core commands is jarring. I&#x27;ve never had that with GNU tools.<p>3. Unsupported commands won&#x27;t have any of the benefits, and you&#x27;d still have to parse their output in the traditional way, or use a Nushell helper. How often this happens will depend on your use case, but you&#x27;ll always depend on Nushell for integrating that command in your workflow.<p>- Related to point 3, Nushell is building an entirely separate monolithic ecosystem, which goes against the open ideology of Unix. This is similar to BusyBox, where you always have to be aware you&#x27;re not using GNU tools, but some slightly incompatible equivalents.<p>More importantly, this approach doesn&#x27;t scale. There will always be new commands that target POSIX shells, but not many commands will be written specifically for Nushell.<p>I appreciate what projects like Nushell and Murex are trying to address, but having a saner scripting language and passing structured data in pipelines is not worth the drawbacks for me.<p>For one, Bash scripting is not so bad if you set some sane defaults and use ShellCheck. Sure, it has its quirks, but all languages do. Even so, the same golden rule applies: use a &quot;real&quot; programming language if your problem exceeds a certain level of complexity. This is relative and will depend on your discomfort threshold, but using the right tool for the job is always a good practice. No matter how good the shell language is, I would hesitate to write and maintain a complex project in it.<p>And for general QoL improvements with interactive use, Zsh is a fine shell, while still being POSIX compatible.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;nushell&#x2F;nushell&#x2F;blob&#x2F;main&#x2F;crates&#x2F;nu-command&#x2F;src&#x2F;filesystem&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;nushell&#x2F;nushell&#x2F;blob&#x2F;main&#x2F;crates&#x2F;nu-comma...</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;nushell&#x2F;nushell&#x2F;issues&#x2F;5027">https:&#x2F;&#x2F;github.com&#x2F;nushell&#x2F;nushell&#x2F;issues&#x2F;5027</a><p>[3]: <a href="https:&#x2F;&#x2F;github.com&#x2F;nushell&#x2F;nushell&#x2F;issues&#x2F;9310">https:&#x2F;&#x2F;github.com&#x2F;nushell&#x2F;nushell&#x2F;issues&#x2F;9310</a></div><br/><div id="37333843" class="c"><input type="checkbox" id="c-37333843" checked=""/><div class="controls bullet"><span class="by">KingMob</span><span>|</span><a href="#37333210">parent</a><span>|</span><a href="#37333903">next</a><span>|</span><label class="collapse" for="c-37333843">[-]</label><label class="expand" for="c-37333843">[1 more]</label></div><br/><div class="children"><div class="content">You may be interested in <a href="https:&#x2F;&#x2F;www.oilshell.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.oilshell.org&#x2F;</a>. It has many of the same end goals as nushell with more of an upgrade path from bash planned. You can start with full compatibility, and then turn on shell opts as you get comfortable to enable new behavior and disable bad old practices.</div><br/></div></div><div id="37333903" class="c"><input type="checkbox" id="c-37333903" checked=""/><div class="controls bullet"><span class="by">mongol</span><span>|</span><a href="#37333210">parent</a><span>|</span><a href="#37333843">prev</a><span>|</span><a href="#37333191">next</a><span>|</span><label class="collapse" for="c-37333903">[-]</label><label class="expand" for="c-37333903">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  It reimplements all commands. You&#x27;re not actually using GNU coreutils, but Nushell reimplementations of ls, rm, etc. See [1].<p>Yeah, ls being called ls despite not being coreutils ls is both a pro and a con. If it would be called lf, for list files, I think it would actually be a little easier to adapt. Because I usually use ls with the flags that don&#x27;t exist in nushell, which obviously fails. It feels strange to borrow the name without being compatible.</div><br/></div></div></div></div><div id="37333191" class="c"><input type="checkbox" id="c-37333191" checked=""/><div class="controls bullet"><span class="by">mongol</span><span>|</span><a href="#37333210">prev</a><span>|</span><a href="#37332884">next</a><span>|</span><label class="collapse" for="c-37333191">[-]</label><label class="expand" for="c-37333191">[2 more]</label></div><br/><div class="children"><div class="content">I tried it briefly and the fact that find means grep and so on will be a tough nut for me to crack, learning-wise. I understand that if you start from a clean slate, you want to make the experience internally consistent. But how do you as a user manage, when your muscle memory is used to something else?</div><br/><div id="37333315" class="c"><input type="checkbox" id="c-37333315" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#37333191">parent</a><span>|</span><a href="#37332884">next</a><span>|</span><label class="collapse" for="c-37333315">[-]</label><label class="expand" for="c-37333315">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>But how do you as a user manage, when your muscle memory is used to something else?</i><p>Like with anything else new: if you find it worth it, you develop new muscle memory.</div><br/></div></div></div></div><div id="37332884" class="c"><input type="checkbox" id="c-37332884" checked=""/><div class="controls bullet"><span class="by">LispSporks22</span><span>|</span><a href="#37333191">prev</a><span>|</span><a href="#37333925">next</a><span>|</span><label class="collapse" for="c-37332884">[-]</label><label class="expand" for="c-37332884">[1 more]</label></div><br/><div class="children"><div class="content">I can’t live without job control</div><br/></div></div><div id="37333925" class="c"><input type="checkbox" id="c-37333925" checked=""/><div class="controls bullet"><span class="by">meeho</span><span>|</span><a href="#37332884">prev</a><span>|</span><label class="collapse" for="c-37333925">[-]</label><label class="expand" for="c-37333925">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Nushell is designed to be a language<p>Last time I checked it didn&#x27;t have functions. Has that changed?</div><br/><div id="37333945" class="c"><input type="checkbox" id="c-37333945" checked=""/><div class="controls bullet"><span class="by">milliams</span><span>|</span><a href="#37333925">parent</a><span>|</span><label class="collapse" for="c-37333945">[-]</label><label class="expand" for="c-37333945">[1 more]</label></div><br/><div class="children"><div class="content">It does, see <a href="https:&#x2F;&#x2F;www.nushell.sh&#x2F;book&#x2F;custom_commands.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.nushell.sh&#x2F;book&#x2F;custom_commands.html</a><p><pre><code>  def greet [name] {
    $&quot;hello ($name)&quot;
  }
</code></pre>
They were added in 0.25 in January 2021 (<a href="https:&#x2F;&#x2F;www.nushell.sh&#x2F;blog&#x2F;2021-01-05-nushell_0_25.html#custom-commands" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.nushell.sh&#x2F;blog&#x2F;2021-01-05-nushell_0_25.html#cus...</a>)</div><br/></div></div></div></div></div></div></div></div></div></body></html>