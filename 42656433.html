<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1736586060714" as="style"/><link rel="stylesheet" href="styles.css?v=1736586060714"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://brooker.co.za/blog/2024/04/17/formal">Formal Methods: Just Good Engineering Practice? (2024)</a> <span class="domain">(<a href="https://brooker.co.za">brooker.co.za</a>)</span></div><div class="subtext"><span>aiono</span> | <span>104 comments</span></div><br/><div><div id="42656639" class="c"><input type="checkbox" id="c-42656639" checked=""/><div class="controls bullet"><span class="by">constantcrying</span><span>|</span><a href="#42656736">next</a><span>|</span><label class="collapse" for="c-42656639">[-]</label><label class="expand" for="c-42656639">[43 more]</label></div><br/><div class="children"><div class="content">Formal verification of software, as the article acknowledges, relies heavily on the type of software and the development process.<p>To use formal verification you need to have <i>formal requirements</i> of the behavior of your software. Most software projects and design philosophies are simply incompatible with this.<p>In software development and design can often fall together, but that means that it is uniquely ill suited for formal methods. If you are developing, before you are sure what you even want, then formal methods do not apply.<p>But I agree that there are certain areas, mostly smaller, safety critical, systems, which rely on upfront specifications, which can heavily benefit from formal verification. E.g. Aerospace software relies heavily on verification.</div><br/><div id="42657553" class="c"><input type="checkbox" id="c-42657553" checked=""/><div class="controls bullet"><span class="by">agentultra</span><span>|</span><a href="#42656639">parent</a><span>|</span><a href="#42657137">next</a><span>|</span><label class="collapse" for="c-42657553">[-]</label><label class="expand" for="c-42657553">[17 more]</label></div><br/><div class="children"><div class="content">It hasn’t been my experience that it is as niche as this. I believe the “costs,” people refer to in these discussions have come way down over the last couple of decades. I’ve taught developers how to use tools like TLA+ and Alloy in week.<p>It’s not a skill that requires a PhD and years of research to acquire these days.<p>Nor does writing a basic, high level specification.<p>If anything you will learn something about the system you are modelling by using a model checker. And that can be useful even if it is used for documentation or teaching.<p>The fundamental power of formal methods is that they force you to think things through.<p>All too often I find software developers eager to believe that they can implement concurrent algorithms armed with their own wit, a type checker, and a smattering of unit tests. It can be humbling to find errors in your design and assumptions after using a model checker. And perhaps it’s hubris that keeps programmers from using such tools in more “mundane” and “real world” contexts.<p>There are a lot more “small” distributed systems than you’d expect and state spaces are generally larger than you’d anticipate if you weren’t open to formalizing your work.</div><br/><div id="42658679" class="c"><input type="checkbox" id="c-42658679" checked=""/><div class="controls bullet"><span class="by">umvi</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42657553">parent</a><span>|</span><a href="#42657780">next</a><span>|</span><label class="collapse" for="c-42658679">[-]</label><label class="expand" for="c-42658679">[2 more]</label></div><br/><div class="children"><div class="content">Seems like it would really slow you down though if you adopt it too early. Sometimes you don&#x27;t even know if the thing you want to do is possible.<p>My development style is:<p>- prototype ideas in a quick and dirty dynamic typed language just to gain confidence it&#x27;s going to work (a lot of ideas die here)<p>- rewrite in a more performant and safe language with a &quot;type checker and a smattering of unit tests&quot; (usually here I&#x27;m &quot;done&quot; and have moved onto the next idea&#x2F;task. If there&#x27;s an issue I fix it and add another test case)<p>I&#x27;m trying to imagine where formal verification comes in. I&#x27;m imagining something like:<p>- prototype ideas in a quick and dirty dynamic typed language just to gain confidence it&#x27;s going to work (a lot of ideas die here)<p>- Formally model the requirements<p>- rewrite in a language that can be formally verified and which is hopefully performant and lets me do things like simd and&#x2F;or cuda if needed<p>- Never have to fix a bug unless there was a bug in the requirements (?)<p>To me, it just seems like it would take an order of magnitude longer to develop things this way for not much benefit (I&#x27;ve traded development time and potentially runtime performance in exchange for correctness)</div><br/><div id="42660748" class="c"><input type="checkbox" id="c-42660748" checked=""/><div class="controls bullet"><span class="by">adsharma</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42658679">parent</a><span>|</span><a href="#42657780">next</a><span>|</span><label class="collapse" for="c-42660748">[-]</label><label class="expand" for="c-42660748">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;adsharma.github.io&#x2F;agentic-transpilers&#x2F;" rel="nofollow">https:&#x2F;&#x2F;adsharma.github.io&#x2F;agentic-transpilers&#x2F;</a><p>Long way to go. But there is a design.<p>Use z3&#x2F;SMT instead of TLA+</div><br/></div></div></div></div><div id="42657780" class="c"><input type="checkbox" id="c-42657780" checked=""/><div class="controls bullet"><span class="by">constantcrying</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42657553">parent</a><span>|</span><a href="#42658679">prev</a><span>|</span><a href="#42657790">next</a><span>|</span><label class="collapse" for="c-42657780">[-]</label><label class="expand" for="c-42657780">[2 more]</label></div><br/><div class="children"><div class="content">I would say that the &quot;nicheness&quot; depends on how you treat software. Your development process and software architecture are engineering choices you make and these engineering choices affect how well formal specification applies.<p>I didn&#x27;t talk about &quot;costs&quot; or about &quot;how hard&quot; it is, but that common practices in software development make using formal methods infeasible. If you want to use formal verification you likely have to change how you develop software. In an environment where there is general uncertainty about architecture and behavior, as is common in agile environments, formal verification is difficult to implement. By its nature, formal verification discourages fast iteration.</div><br/><div id="42658881" class="c"><input type="checkbox" id="c-42658881" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42657780">parent</a><span>|</span><a href="#42657790">next</a><span>|</span><label class="collapse" for="c-42658881">[-]</label><label class="expand" for="c-42658881">[1 more]</label></div><br/><div class="children"><div class="content">&gt; By its nature, formal verification discourages fast iteration.<p>Not necessarily. You can develop the specification and implementation in parallel. That way, at every point in time, you could have a much more thorough and deep understanding of what you&#x27;re currently building, as well as how exactly you decide to change it.</div><br/></div></div></div></div><div id="42657790" class="c"><input type="checkbox" id="c-42657790" checked=""/><div class="controls bullet"><span class="by">aleph_minus_one</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42657553">parent</a><span>|</span><a href="#42657780">prev</a><span>|</span><a href="#42660410">next</a><span>|</span><label class="collapse" for="c-42657790">[-]</label><label class="expand" for="c-42657790">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I’ve taught developers how to use tools like TLA+ and Alloy in week.<p>TLA+:<p>- <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;TLA%2B" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;TLA%2B</a><p>- <a href="https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;tla&#x2F;tla.html" rel="nofollow">https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;tla&#x2F;tla.html</a><p>Alloy:<p>- <a href="https:&#x2F;&#x2F;alloytools.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;alloytools.org&#x2F;</a><p>- <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Alloy_(specification_language)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Alloy_(specification_language)</a></div><br/></div></div><div id="42660410" class="c"><input type="checkbox" id="c-42660410" checked=""/><div class="controls bullet"><span class="by">pnathan</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42657553">parent</a><span>|</span><a href="#42657790">prev</a><span>|</span><a href="#42660542">next</a><span>|</span><label class="collapse" for="c-42660410">[-]</label><label class="expand" for="c-42660410">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s your recommendation on how to rapidly learn TLA+? I spent some time staring at references and the UI a few months ago and came away very defeated. But I&#x27;d like to actually level up here.</div><br/><div id="42663496" class="c"><input type="checkbox" id="c-42663496" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42660410">parent</a><span>|</span><a href="#42660542">next</a><span>|</span><label class="collapse" for="c-42663496">[-]</label><label class="expand" for="c-42663496">[1 more]</label></div><br/><div class="children"><div class="content">I also found TLA+ difficult to learn and a chore due to the syntax. I truly wish designers of popular languages would incorporate model verification within the language&#x2F;compiler tools - this would likely need a constrained subset of the language with restricted syntax and special extensions. Ideally, it should be possible to just annotate or &quot;color&quot; a function for formal verification. All parameter types and functions used by the &quot;formal&quot; function would also be colored.</div><br/></div></div></div></div><div id="42660542" class="c"><input type="checkbox" id="c-42660542" checked=""/><div class="controls bullet"><span class="by">ajmurmann</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42657553">parent</a><span>|</span><a href="#42660410">prev</a><span>|</span><a href="#42658494">next</a><span>|</span><label class="collapse" for="c-42660542">[-]</label><label class="expand" for="c-42660542">[2 more]</label></div><br/><div class="children"><div class="content">For distributed systems this makes sense. Most people aren&#x27;t writing distributed system components though but things where the risk usually isn&#x27;t technical like business software. I worked on a project where I got into arguments with the PMs because I pushed back on optimizing performance on the main page of our pre-launch product. I argued that we don&#x27;t have any real feedback that the page is what is needed and the PM thought I was insane for doubting the main page was needed. We completely redesigned that page twice, deleted it entirely and then had to bring it back because the sales team liked it for initial demos.<p>Every process is a tradeoff and it anyways depends on your specific circumstances which choice is best for your team and project.</div><br/><div id="42660785" class="c"><input type="checkbox" id="c-42660785" checked=""/><div class="controls bullet"><span class="by">agentultra</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42660542">parent</a><span>|</span><a href="#42658494">next</a><span>|</span><label class="collapse" for="c-42660785">[-]</label><label class="expand" for="c-42660785">[1 more]</label></div><br/><div class="children"><div class="content">It does depend a lot on circumstance and context.<p>Is it absolutely important that your system is correct? ... begs the question, <i>correct with respect to what?</i> Generally: a specification.<p>There are lots of situations where you don&#x27;t know what your system is supposed to do, where testing a few examples is sufficient, or it&#x27;s not terribly important that you know that it does what you say it ought to. Generating a batch report or storing some customer responses in a database? Trust the framework, write a few tests if you need to, nobody is going to find a formal specification valuable here.<p>However, if you need to deploy configuration to a cluster and need to ensure there is at least two nodes with the a version of the configuration that matches the database in the load balancer group at all times during the migration? Need to make sure the migration always completes and never leaves the cluster in a bad state?<p>Even smaller in scale: need to make sure that references in your allocator don&#x27;t contain addresses outside of your memory pool? Need to make sure that all locks are eventually released?<p>It&#x27;s definitely much faster to iterate on a formal specification first. A model checker executes your model against the entire state space. If you&#x27;re used to test-driven development or working in a statically typed language, this is useful feedback to get early on in the design process.<p>What the scope is that is appropriate for using tools like this is quite large and not as niche as some folks imply. I don&#x27;t do aerospace engineering but I&#x27;ve used TLA+ to model deployment scripts and find bugs in OpenStack deployments, as well as to simply learn that the design of certain async libraries are sound.<p><i>Update</i>: more examples.</div><br/></div></div></div></div><div id="42658494" class="c"><input type="checkbox" id="c-42658494" checked=""/><div class="controls bullet"><span class="by">billfruit</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42657553">parent</a><span>|</span><a href="#42660542">prev</a><span>|</span><a href="#42662921">next</a><span>|</span><label class="collapse" for="c-42658494">[-]</label><label class="expand" for="c-42658494">[2 more]</label></div><br/><div class="children"><div class="content">Alloy is a brute force model checker (for rather small models).<p>Is that the state of the art for formal methods? How do you think of formally verifying systems with floating points calculations, with randomness, with databases and external environments?</div><br/><div id="42658777" class="c"><input type="checkbox" id="c-42658777" checked=""/><div class="controls bullet"><span class="by">agentultra</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42658494">parent</a><span>|</span><a href="#42662921">next</a><span>|</span><label class="collapse" for="c-42658777">[-]</label><label class="expand" for="c-42658777">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is that the state of the art for formal methods?<p>I think the state of the art is quite broad as there are many tools.<p>Model checking is, in my estimation, the most useful for industry programmers today. It doesn&#x27;t require as much training to use as automated theorem proving, it doesn&#x27;t provide the guarantees that mathematical induction and proof do; but you get far more for your buck than from testing alone.<p>However model checkers are very flexible because the language they use, math, is also very flexible. TLA+ has been used to find errors in the Xbox 360 memory controller before it went to launch as well as in Amazon&#x27;s S3 [0] -- errors so complex that it would have been highly improbable that a human would detect them and the result of finding those errors and solving them saved real businesses a lot of money.<p>It comes down to your ability to pick good levels of abstraction. You can start with a very high level specification that admits no details about how the file system works or the kernel syscalls involved and still get value out of it. If those details _do_ matter there&#x27;s a strategy called <i>refinement</i> where you can create another specification that is more specialized and write an expression that implies if the refined specification holds then the original specification does as well.<p>Tools for randomness and numerical methods exist and depending on your needs you may want to look at other tools than <i>just</i> a model checker. TLA+, for example, isn&#x27;t good at modelling &quot;amounts&quot; as it creates a rather large state space quickly; so users tend to create abstractions to represent these things with a finite number of states.<p>[0] <a href="https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;tla&#x2F;formal-methods-amazon.pdf" rel="nofollow">https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;tla&#x2F;formal-methods-amazon....</a></div><br/></div></div></div></div><div id="42662921" class="c"><input type="checkbox" id="c-42662921" checked=""/><div class="controls bullet"><span class="by">abhgh</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42657553">parent</a><span>|</span><a href="#42658494">prev</a><span>|</span><a href="#42657817">next</a><span>|</span><label class="collapse" for="c-42662921">[-]</label><label class="expand" for="c-42662921">[1 more]</label></div><br/><div class="children"><div class="content">Could you point to some good resources for either, that enables quick application?</div><br/></div></div><div id="42657817" class="c"><input type="checkbox" id="c-42657817" checked=""/><div class="controls bullet"><span class="by">gte525u</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42657553">parent</a><span>|</span><a href="#42662921">prev</a><span>|</span><a href="#42663632">next</a><span>|</span><label class="collapse" for="c-42657817">[-]</label><label class="expand" for="c-42657817">[3 more]</label></div><br/><div class="children"><div class="content">Do you have any resources you could link to - for those that are curious?</div><br/><div id="42658553" class="c"><input type="checkbox" id="c-42658553" checked=""/><div class="controls bullet"><span class="by">bassp</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42657817">parent</a><span>|</span><a href="#42662994">next</a><span>|</span><label class="collapse" for="c-42658553">[-]</label><label class="expand" for="c-42658553">[1 more]</label></div><br/><div class="children"><div class="content">Not the OP, but Hillel Wayne’s course&#x2F;tutorial (<a href="https:&#x2F;&#x2F;www.learntla.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.learntla.com&#x2F;</a>) is fantastic. It’s focused on building practical skills, and helped me build enough competence to write a few (simple, but useful!) specs for some of the systems I work on.</div><br/></div></div><div id="42662994" class="c"><input type="checkbox" id="c-42662994" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42657817">parent</a><span>|</span><a href="#42658553">prev</a><span>|</span><a href="#42663632">next</a><span>|</span><label class="collapse" for="c-42662994">[-]</label><label class="expand" for="c-42662994">[1 more]</label></div><br/><div class="children"><div class="content">To get an overview of what all are involved in &quot;Formal Methods&quot; see <i>Understanding Formal Methods by Jean-Francois Monin</i>. The book gives an overview of both the various mathematical models and some of the tools implementing them. There is a lot here and it may seem haphazard but that is only because we haven&#x27;t yet grasped the &quot;full picture&quot;. I have been reading this for a while but still have a long way to go.<p>A four-part <i>TLA+ in Practice and Theory</i> by user &quot;pron&quot; - <a href="https:&#x2F;&#x2F;pron.github.io&#x2F;posts&#x2F;tlaplus_part1" rel="nofollow">https:&#x2F;&#x2F;pron.github.io&#x2F;posts&#x2F;tlaplus_part1</a></div><br/></div></div></div></div><div id="42663632" class="c"><input type="checkbox" id="c-42663632" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42657553">parent</a><span>|</span><a href="#42657817">prev</a><span>|</span><a href="#42657137">next</a><span>|</span><label class="collapse" for="c-42663632">[-]</label><label class="expand" for="c-42663632">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The fundamental power of formal methods is that they force you to think things through.<p>... Using Mathematical Reasoning and Tools.<p>This is the main reason for me to study Formal Methods. The shift in thinking is profound and it affects one&#x27;s own programming even if one does not use any of the tools.</div><br/></div></div></div></div><div id="42657137" class="c"><input type="checkbox" id="c-42657137" checked=""/><div class="controls bullet"><span class="by">bassp</span><span>|</span><a href="#42656639">parent</a><span>|</span><a href="#42657553">prev</a><span>|</span><a href="#42658693">next</a><span>|</span><label class="collapse" for="c-42657137">[-]</label><label class="expand" for="c-42657137">[3 more]</label></div><br/><div class="children"><div class="content">It’s not all or nothing!<p>I work on a very “product-y” back end that isn’t fully specified, but I have formally specified <i>parts</i> of it.<p>For instance, I property-based-tested a particularly nasty state machine I wrote to ensure that, no matter what kind of crazy input I called an endpoint with, the underlying state machine never made any invalid transitions. None of the code around the state machine has a formal spec, but because the state machine does, I was able to specify it.<p>In the process, I found some very subtle bugs I’d have never caught via traditional unit testing.</div><br/><div id="42657206" class="c"><input type="checkbox" id="c-42657206" checked=""/><div class="controls bullet"><span class="by">constantcrying</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42657137">parent</a><span>|</span><a href="#42659010">next</a><span>|</span><label class="collapse" for="c-42657206">[-]</label><label class="expand" for="c-42657206">[1 more]</label></div><br/><div class="children"><div class="content">Completely agree, but obviously you relied on the state machine being sufficiently separate and having a formal specification for it.<p>State machines are quite common, in aerospace software, where the requirements even specify the states and transitions. If you can formally verify them, I believe, you absolutely should, as often there can be a lot of subtlety going on there, especially if you have a distributed system of state machines sending messages to one another.</div><br/></div></div><div id="42659010" class="c"><input type="checkbox" id="c-42659010" checked=""/><div class="controls bullet"><span class="by">senderista</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42657137">parent</a><span>|</span><a href="#42657206">prev</a><span>|</span><a href="#42658693">next</a><span>|</span><label class="collapse" for="c-42659010">[-]</label><label class="expand" for="c-42659010">[1 more]</label></div><br/><div class="children"><div class="content">Property-based testing is also effective in finding bugs even in the absence of any formal model. Basically you just need to identify informal invariants (&quot;properties&quot;), encode them as asserts, and then run tests with enough coverage to likely find any invariant violations.</div><br/></div></div></div></div><div id="42658693" class="c"><input type="checkbox" id="c-42658693" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#42656639">parent</a><span>|</span><a href="#42657137">prev</a><span>|</span><a href="#42657489">next</a><span>|</span><label class="collapse" for="c-42658693">[-]</label><label class="expand" for="c-42658693">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Formal&quot; means &quot;written in a language that can be interpreted by a computer&quot; and that is the very thing programmers do. Writing a code <i>is</i> writing a formal specification of the program&#x27;s behaviour, and by definition, every piece of software must do that.<p>But you&#x27;re right that to benefit from any formal methods, you need to compare the program&#x27;s behaviour to something else that isn&#x27;t the program itself, and that other thing also needs to be written in a formal language. To be able to write that other thing, you do need to have a precise understanding of what the wanted behaviour should be so that you could express it in a formal language, but it doesn&#x27;t have to cover the full behaviour of the software.<p>As an example of what that means, take automated (unit) tests. Automated tests <i>are</i> a formal specification, and running them <i>is</i> a formal verification method. Tests are a relatively weak specification, and executing them is a relatively weak verification, compared to what we normally mean by &quot;formal methods&quot;, but there is no clear qualitative difference -- conceptual or even practical -- between tests and more powerful formal specification and verification. You can think of these practices as more powerful tests or as tests that work differently, but tests <i>are</i> formal specifications, and if they&#x27;re applicable to a piece of software, it&#x27;s likely that richer formal specification methods are, too (learning the cost&#x2F;benfit of other methods is similar to learning the cost&#x2F;benefit of tests -- you don&#x27;t get it right at first, but you learn along the way).</div><br/><div id="42660524" class="c"><input type="checkbox" id="c-42660524" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42658693">parent</a><span>|</span><a href="#42657489">next</a><span>|</span><label class="collapse" for="c-42660524">[-]</label><label class="expand" for="c-42660524">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Automated tests are a formal specification, and running them is a formal verification method.<p>This is a great way to describe it, and an important concept to grasp.<p>Another kind of formal verification that exists between &quot;standard&quot; unit tests and model checking&#x2F;automated theorem proving is property-based testing a la quickcheck: You have a function you want to test (e.g., a sort), you describe the properties of inputs (&quot;a list of integers&quot;) and state the properties you want to hold of the output (&quot;every number should appear the same number of times in the output as in the input, and every number should be &gt;= the number to its left&quot;) and ask the system to generate and test lots of random inputs for you. These properties can often be used more or less directly in model checkers, which makes the checking exhaustive (on some small, finite domain).</div><br/></div></div></div></div><div id="42657489" class="c"><input type="checkbox" id="c-42657489" checked=""/><div class="controls bullet"><span class="by">trending486</span><span>|</span><a href="#42656639">parent</a><span>|</span><a href="#42658693">prev</a><span>|</span><a href="#42656764">next</a><span>|</span><label class="collapse" for="c-42657489">[-]</label><label class="expand" for="c-42657489">[1 more]</label></div><br/><div class="children"><div class="content">You are going to have requirements whether you like it or not. It doesn&#x27;t matter if you discover them during requirements engineering and validate and deconflict them on a simple text document, or if you discover them as you go during coding (possibly after having coded the wrong thing), or if the client discovers them during the &quot;sprint review&quot; of some allegedly agile cult. The only difference is how much money and time are you willing to trade for being called &quot;agile&quot;. Ironically the traditional way of doing a requirements stage is the less expensive of all three options. It is also the most aligned with the original agile spirit, since it converges with the client as soon as posible, at the point where changes are the most cheap (changing a line on a text document).</div><br/></div></div><div id="42656764" class="c"><input type="checkbox" id="c-42656764" checked=""/><div class="controls bullet"><span class="by">aiono</span><span>|</span><a href="#42656639">parent</a><span>|</span><a href="#42657489">prev</a><span>|</span><a href="#42660381">next</a><span>|</span><label class="collapse" for="c-42656764">[-]</label><label class="expand" for="c-42656764">[3 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s more formalisability than requiring upfront design. For example you may have an insurance claim automation system which you can&#x27;t design upfront because most insurance providers have unspecified behaviour. But that doesn&#x27;t mean you can refine your automation system as you get more information from interactions. You would still get the benefit that you ensure not leaving out any cases or not having any contradiction in your system</div><br/><div id="42656863" class="c"><input type="checkbox" id="c-42656863" checked=""/><div class="controls bullet"><span class="by">constantcrying</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42656764">parent</a><span>|</span><a href="#42660381">next</a><span>|</span><label class="collapse" for="c-42656863">[-]</label><label class="expand" for="c-42656863">[2 more]</label></div><br/><div class="children"><div class="content">But that still relies on having a prior notion of the formal requirements of your system. I know little about insurance systems, but deriving a formal specification seems like a nightmare task. Although, as you mentioned, if you had a partial one you certainly would get some benefits from it.</div><br/><div id="42657398" class="c"><input type="checkbox" id="c-42657398" checked=""/><div class="controls bullet"><span class="by">aiono</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42656863">parent</a><span>|</span><a href="#42660381">next</a><span>|</span><label class="collapse" for="c-42657398">[-]</label><label class="expand" for="c-42657398">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been a while since I worked on those systems, but you usually decide on some rules that you refine over time. So they are purely logical decisions that you can formalize. I don&#x27;t see why it would be hard to specify. I don&#x27;t mean to specify all up front but one can specify the exact decision procedure that is implemented right now very easily in my experience. Generally you have a state machine representing the process.<p>This state machine is usually embedded in the code, but code has a lot of noise around the state machine that makes it harder to see the underlying state machine.</div><br/></div></div></div></div></div></div><div id="42660381" class="c"><input type="checkbox" id="c-42660381" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#42656639">parent</a><span>|</span><a href="#42656764">prev</a><span>|</span><a href="#42658372">next</a><span>|</span><label class="collapse" for="c-42660381">[-]</label><label class="expand" for="c-42660381">[1 more]</label></div><br/><div class="children"><div class="content">Static type checking is a kind of formal verification of software - there are formal requirements (the program doesn&#x27;t go &quot;wrong&quot; in a number of rigorously defined ways) that are automatically checked.  And you can certainly do &quot;design and development&quot; together in type-safe languages.</div><br/></div></div><div id="42658372" class="c"><input type="checkbox" id="c-42658372" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42656639">parent</a><span>|</span><a href="#42660381">prev</a><span>|</span><a href="#42658746">next</a><span>|</span><label class="collapse" for="c-42658372">[-]</label><label class="expand" for="c-42658372">[2 more]</label></div><br/><div class="children"><div class="content">I worked on a project where a couple people formally proved our design sound while I was still fixing bugs in the spec. We don’t have spherical cows. Theoretical models aren’t reality. The map is not the territory.</div><br/><div id="42662313" class="c"><input type="checkbox" id="c-42662313" checked=""/><div class="controls bullet"><span class="by">casey2</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42658372">parent</a><span>|</span><a href="#42658746">next</a><span>|</span><label class="collapse" for="c-42662313">[-]</label><label class="expand" for="c-42662313">[1 more]</label></div><br/><div class="children"><div class="content">People who argue for formal methods are well aware that theorems change over time [1], the point is that with formal methods the theorems become simpler and in turn result in simpler proofs. With ad hocery or communal wisdom, unless you are a genius artist, the theorem only becomes more complex.<p>[1] You can see Lakatos in Dijstrak&#x27;s library for example <a href="https:&#x2F;&#x2F;dijkstrascry.com&#x2F;inventory#box4" rel="nofollow">https:&#x2F;&#x2F;dijkstrascry.com&#x2F;inventory#box4</a></div><br/></div></div></div></div><div id="42658746" class="c"><input type="checkbox" id="c-42658746" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#42656639">parent</a><span>|</span><a href="#42658372">prev</a><span>|</span><a href="#42658945">next</a><span>|</span><label class="collapse" for="c-42658746">[-]</label><label class="expand" for="c-42658746">[1 more]</label></div><br/><div class="children"><div class="content">You can also use proof assistants as &quot;unit tests&quot; for entire classes of behaviors rather than specific values. This lets you add proofs incrementally even when a formal spec is too difficult.</div><br/></div></div><div id="42658945" class="c"><input type="checkbox" id="c-42658945" checked=""/><div class="controls bullet"><span class="by">senderista</span><span>|</span><a href="#42656639">parent</a><span>|</span><a href="#42658746">prev</a><span>|</span><a href="#42658441">next</a><span>|</span><label class="collapse" for="c-42658945">[-]</label><label class="expand" for="c-42658945">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure that &quot;aerospace software relies heavily on verification&quot; is very commonly the case at all, even if one would like it to be...</div><br/><div id="42659199" class="c"><input type="checkbox" id="c-42659199" checked=""/><div class="controls bullet"><span class="by">kmoser</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42658945">parent</a><span>|</span><a href="#42658441">next</a><span>|</span><label class="collapse" for="c-42659199">[-]</label><label class="expand" for="c-42659199">[1 more]</label></div><br/><div class="children"><div class="content">What makes you say that? I&#x27;m pretty sure it&#x27;s one of the more heavily verified industries. If it wasn&#x27;t, air travel would be much more dangerous.</div><br/></div></div></div></div><div id="42658441" class="c"><input type="checkbox" id="c-42658441" checked=""/><div class="controls bullet"><span class="by">billfruit</span><span>|</span><a href="#42656639">parent</a><span>|</span><a href="#42658945">prev</a><span>|</span><a href="#42657926">next</a><span>|</span><label class="collapse" for="c-42658441">[-]</label><label class="expand" for="c-42658441">[2 more]</label></div><br/><div class="children"><div class="content">Dijkstra for example didn&#x27;t think so, I think. He had a din view of testing as compared with proofs for ensuring software correctness.</div><br/><div id="42661696" class="c"><input type="checkbox" id="c-42661696" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42658441">parent</a><span>|</span><a href="#42657926">next</a><span>|</span><label class="collapse" for="c-42661696">[-]</label><label class="expand" for="c-42661696">[1 more]</label></div><br/><div class="children"><div class="content">They both have their place. If you get a requirement wrong you can prove an incorrect system. In a complex system I doubt you can understand it from the requirements and so we should assume they are wrong. A test by constrast can (but need not!) be obviously correct but it is correct one for that case and so doesn&#x27;t say anything about the rest.</div><br/></div></div></div></div><div id="42657926" class="c"><input type="checkbox" id="c-42657926" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#42656639">parent</a><span>|</span><a href="#42658441">prev</a><span>|</span><a href="#42659362">next</a><span>|</span><label class="collapse" for="c-42657926">[-]</label><label class="expand" for="c-42657926">[4 more]</label></div><br/><div class="children"><div class="content">Everything you said about formal verification is also true about tests; do you think software is also uniquely ill suited for TDD?</div><br/><div id="42658262" class="c"><input type="checkbox" id="c-42658262" checked=""/><div class="controls bullet"><span class="by">constantcrying</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42657926">parent</a><span>|</span><a href="#42659362">next</a><span>|</span><label class="collapse" for="c-42658262">[-]</label><label class="expand" for="c-42658262">[3 more]</label></div><br/><div class="children"><div class="content">I did not say that software is uniquely ill suited for formal verification. That also would be total nonsense.<p>I said that certain philosophies of software design are uniquely unsuited for formal verification.<p>Besides, tests and formal verification are different. A test is essentially a formal specification for a single point or, depending on how you test, multiple, potentially random, points. Writing or changing a test is less time intensive than writing or changing a full formal specification for an entire subsystem, therefore tests are more suited to volatile software development practices.</div><br/><div id="42658934" class="c"><input type="checkbox" id="c-42658934" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42658262">parent</a><span>|</span><a href="#42659362">next</a><span>|</span><label class="collapse" for="c-42658934">[-]</label><label class="expand" for="c-42658934">[2 more]</label></div><br/><div class="children"><div class="content">&gt; therefore tests are more suited to volatile software development practices.<p>And having <i>no</i> tests is even more suited...</div><br/><div id="42661706" class="c"><input type="checkbox" id="c-42661706" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42658934">parent</a><span>|</span><a href="#42659362">next</a><span>|</span><label class="collapse" for="c-42661706">[-]</label><label class="expand" for="c-42661706">[1 more]</label></div><br/><div class="children"><div class="content">Maybe there are tradeoffs. If the code will never need the same thing again manual tests are good enough. Most code has things that don&#x27;t change even as you add new features and so tests are valuable.</div><br/></div></div></div></div></div></div></div></div><div id="42659362" class="c"><input type="checkbox" id="c-42659362" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#42656639">parent</a><span>|</span><a href="#42657926">prev</a><span>|</span><a href="#42662690">next</a><span>|</span><label class="collapse" for="c-42659362">[-]</label><label class="expand" for="c-42659362">[1 more]</label></div><br/><div class="children"><div class="content">That’s true. Back when they were inventing security, the requirement for high-security systems (A1 under TCSEC) required formal verification. Those who did it said its cost ranged from not too burdensome to very high. What’s the reason?<p>While many requirements existed, the design assurance required specifying what problem was being solved, how it’s being solved, and the safety&#x2F;security properties. Then, proving that the security properties were embodied in the artifacts in all states. That problem is difficult enough that most people who succeeded were also geniuses good at programming and math. Geniuses are in short supply.<p>The lessons learned papers also pointed out a recurring problem. Each requirement, security policy, algorithm, etc needed a mathematical specification. Then, proof techniques were necessary that could handle each. Instead of developing software features, you are now both developing software and doing R&amp;D on applied mathematics.<p>Steve Lipner’s The Ethics of Perfection pointed out it took several quarters to make a major change on a product. The markets value development velocity over quality, even demand side. So, that’s already a no go for most businesses. Likewise, the motivations of OSS developers work against high assurance practices as well.<p>If you want formal verification, then you are forced to make certain decisions. For one, you need to build simple systems that are easy to verify, from design to language. Then, you use the easiest, most-automated tools for the job. Most drop full verification to do automated, partial checking: TLA+, Alloy, SPARK Ada, Meta’s Infer, etc.. If doing full verification, it’s better to make or build on reusable components like we see done with CompCert and seL4. GEMSOS and VAX VMM advocated that back in the day, too.<p>So, most software development isn’t fit for use of formal verification. I think we can default on a combo of contracts (specs), automated testing, static analysis, and safe languages. If distributed, stronger consistency when possible. Then, use CI to run the verification on each commit. Some tools can generate patches, too.</div><br/></div></div><div id="42662690" class="c"><input type="checkbox" id="c-42662690" checked=""/><div class="controls bullet"><span class="by">ijustlovemath</span><span>|</span><a href="#42656639">parent</a><span>|</span><a href="#42659362">prev</a><span>|</span><a href="#42661534">next</a><span>|</span><label class="collapse" for="c-42662690">[-]</label><label class="expand" for="c-42662690">[1 more]</label></div><br/><div class="children"><div class="content">V&amp;V doesn&#x27;t really mean formal verification, unless you&#x27;re doing some extremely cutting edge stuff. It&#x27;s so much cheaper to do the basic boundary testing, fuzzing, unit &amp; integration tests than to spend the time and find the talent who can not just formally specify but also code proofs of your requirements being met.<p>Formal verification is just not as common as you might think in these highly regulated industries; the expertise isn&#x27;t as prevalent as your average HN reader would think.</div><br/></div></div><div id="42661534" class="c"><input type="checkbox" id="c-42661534" checked=""/><div class="controls bullet"><span class="by">Ericson2314</span><span>|</span><a href="#42656639">parent</a><span>|</span><a href="#42662690">prev</a><span>|</span><a href="#42656736">next</a><span>|</span><label class="collapse" for="c-42661534">[-]</label><label class="expand" for="c-42661534">[2 more]</label></div><br/><div class="children"><div class="content">&gt; To use formal verification you need to have formal requirements of the behavior of your software.<p>Not true!<p>Well, it is true of TLA+, but that is why TLA+ is not the future. The future is dependent types.<p>It is true we&#x27;ll always be programming and specifying as we go to some extent. That&#x27;s why formal methods have to be part of the software itself, not some extra burden off to the side.<p>Dependent types is basically unique in doing that. You can right some code, then reason about that code. Or you can write a program where the propositions&#x2F;proofs and executable program proper are so intertwined the separation stops making sense in theory too.<p>This, and this alone, supports the dialectic of &quot;doing&quot; and &quot;planning&quot; that is hardly unique to software development, but rather is emblematic of most sufficiently complex human activities.<p>----<p>A really nice example to make this concrete is Lean&#x27;s standard libraries&#x27;s `SatisfyingM` and `MonadSatisfying`<p>(See <a href="https:&#x2F;&#x2F;leanprover-community.github.io&#x2F;mathlib4_docs&#x2F;Batteries&#x2F;Classes&#x2F;SatisfiesM.html#MonadSatisfying" rel="nofollow">https:&#x2F;&#x2F;leanprover-community.github.io&#x2F;mathlib4_docs&#x2F;Batteri...</a>)<p>`SatisfiesM` is an attempt to support &quot;external&quot; reasoning: one already wrote a non-trivial monadic action, and now one wants to do Hoare-like reasoning about preconditions, posts conditions, the returned value, etc.<p>But a different monadic action that uses the first one might need to then <i>internalize</i> this reasoning. For example, it need to turn a pair of (program, proof about program&#x27;s return value) into a new program that returns the thing <i>and the proof</i>.<p>This is `MonadSatisfying` is for. It is a constraint on the monad saying we now how to internalize such a proof.<p>The &quot;external&quot; proofs are the only ones TLA+ and similar tools support, and the honest truth is that you might want to make them, you might be forced for compliance&#x2F;legal&#x2F;insurance reasons to make them, but you are never <i>intrinsically forced by the software itself</i> to make them.<p>The &quot;internal proofs&quot;, in contrast, <i>are</i> so required. The represent different abstractions which state their interface such that it is impossible to use them incorrectly --- providing a proof is a non-negotiable obligation on user of the abstraction just as providing a &quot;regular&quot; argument is a non-negotiable obligation to making a regular function call.<p>In addition to supporting to modular reasoning --- write a very fancy thing and then make sure your coworkers don&#x27;t use it incorrectly --- this fixes the economic problem --- gotta do the proofs or the code won&#x27;t compile!<p>----<p>If you have no idea how to start programming more formally, here are some ways to start:<p>external proofs:<p>you probably have tests. Think, how did you know those test cases are correct? Can you rewrite individual unit tests as property tests, to &quot;formalize&quot; that reasoning (yes, it is still formal, even though property testing is old and simple. &quot;formal&quot; means &quot;explicit&quot; not &quot;fancy&quot;!). If you can write a property test to by checked by probabilistic methods, then you implicitly have a property you could proove instead. Problem solved!<p>internal proofs:<p>Does you program have any `panic(&quot;this should never happen&quot;)` or similar? Well, why shouldn&#x27;t it? Types, even non-dependent ones, allow for <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Principle_of_explosion" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Principle_of_explosion</a>, which is nothing more than showing some case-alternative has been given an impossible value, and so must be dead code. Every bit of code you <i>think</i> is unreachable, and your intuition is not correct, has a proof saying it is in fact so, and that proof is needed internally do &quot;discharge&quot; the branch.<p>Every assert? remember &quot;assert c = branch c -&gt; ok; not c -&gt; panic(&quot;this should never happen&quot;)&quot; so all your assertions are not things you might prove!<p>Even people that never have written down specs in their life probably have some assertions or panics lying about. So they too have something to formalize.</div><br/><div id="42662386" class="c"><input type="checkbox" id="c-42662386" checked=""/><div class="controls bullet"><span class="by">groby_b</span><span>|</span><a href="#42656639">root</a><span>|</span><a href="#42661534">parent</a><span>|</span><a href="#42656736">next</a><span>|</span><label class="collapse" for="c-42662386">[-]</label><label class="expand" for="c-42662386">[1 more]</label></div><br/><div class="children"><div class="content">This sounds fabulous on paper. Are there any examples of moving unit tests to property tests? Are there examples for proving unreachability? Has anybody successfully managed to explain how this is applicable if you don&#x27;t have a deep background in formal methods?<p>If we can&#x27;t provide a pathway from where we are to a more formal world that is understandable to garden variety developers, it will remain an ivory tower occupation.<p>(And, in fact, things will get worse. Because in a world of LLM churnage, provable correctness becomes even more important)</div><br/></div></div></div></div></div></div><div id="42656736" class="c"><input type="checkbox" id="c-42656736" checked=""/><div class="controls bullet"><span class="by">commandlinefan</span><span>|</span><a href="#42656639">prev</a><span>|</span><a href="#42657177">next</a><span>|</span><label class="collapse" for="c-42656736">[-]</label><label class="expand" for="c-42656736">[9 more]</label></div><br/><div class="children"><div class="content">I see this line of reasoning about formal methods a lot: software is big and complicated and hard to get right... therefore formal methods.<p>On the one hand, I _want_ this to be true both for selfish and practical reasons: selfishly because I&#x27;m very very good at learning things that require an academic learning approach (read a book, work some exercises, practice) and if something I&#x27;m good at is important, that means more money for me.  Practically because they&#x27;re right, software _is_ big and complicated and hard to get right and as a practitioner, it&#x27;s really frustrating when it does fail and I&#x27;m scrambling to figure out why.<p>On the other hand, though, nobody ever seems to make a compelling case for how formal methods proposes to solve that problem.  This author actually does better than most by pointing out how most modern &quot;design&quot; is a waste of time but doesn&#x27;t really go into why TLA, say, is better than (demonstrably mostly useless) UML.  There&#x27;s sort of an implied suggestion that if you dedicate a few months (or years?) to learning TLA, you&#x27;ll reach enlightenment and understand how it&#x27;s helpful in a way that&#x27;s impossible to articulate to the unenlightened.  And that&#x27;s not impossible to imagine!  Calculus and Bayesian statistics are kind of like that; you need to really understand them before you can really see why they&#x27;re useful.<p>I always find myself left applying what I call &quot;project manager&quot; logic - I need to make a snap decision right now about whether or not I should invest time in this &quot;formal method&quot; stuff or not so I have to be observational: if it was really that helpful, more people would be applying it and the benefits would speak for themselves.  They&#x27;ve been around a long, long time, though, and never caught on - it&#x27;s hard not to conclude that there&#x27;s probably a reason.</div><br/><div id="42657184" class="c"><input type="checkbox" id="c-42657184" checked=""/><div class="controls bullet"><span class="by">t43562</span><span>|</span><a href="#42656736">parent</a><span>|</span><a href="#42657256">next</a><span>|</span><label class="collapse" for="c-42657184">[-]</label><label class="expand" for="c-42657184">[1 more]</label></div><br/><div class="children"><div class="content">IMO UML is useless because whatever diagram gets produced means different things to different people and it&#x27;s very complex but not check-able so people can make UML diagrams that are self contradictory or nonsense.<p>I find myself using a &quot;method&quot; of some kind when faced with a problem that&#x27;s hard to think about. A communications protocol - nice to have a state machine to describe it for example. TLA obviously fits that niche even better. I&#x27;ve been lucky enough not to have too many problems recently that felt like they justified that effort but it&#x27;s of incredible value when one does. Domain Specific Languages - so much better to use a parser framework than hand-code if you want to avoid all sorts of undesirable outcomes.<p>Currently most of my rework comes from changes to the requirements and our &quot;customers&quot; not really knowing what they want till we give them something and they say &quot;not that.&quot;<p>This is partly because the people asking for things don&#x27;t fully think out all the implications of what they&#x27;re asking.  It&#x27;s mostly about not having enough knowledge in one place to make good decisions on.</div><br/></div></div><div id="42657256" class="c"><input type="checkbox" id="c-42657256" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#42656736">parent</a><span>|</span><a href="#42657184">prev</a><span>|</span><a href="#42658488">next</a><span>|</span><label class="collapse" for="c-42657256">[-]</label><label class="expand" for="c-42657256">[1 more]</label></div><br/><div class="children"><div class="content">I only am familiar with formal verification in the context of a hardware class, which is like programming but the cost:benefit is wildly different (can’t fix a physical chip after it has been fabricated very easily) and the types of designs are very different.<p>But, the impression I got was that the rigors of the formal verifier would sort of impose a limit on the complexity of the design just based on… completing in a reasonable timeframe and in a reasonable amount of memory space. Maybe the true victory of demanding formal verification would be fixing:<p>&gt; software is big and complicated and hard to get right<p>By making big complex programs a pain to work with, haha.</div><br/></div></div><div id="42658488" class="c"><input type="checkbox" id="c-42658488" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42656736">parent</a><span>|</span><a href="#42657256">prev</a><span>|</span><a href="#42657139">next</a><span>|</span><label class="collapse" for="c-42658488">[-]</label><label class="expand" for="c-42658488">[2 more]</label></div><br/><div class="children"><div class="content">If we’re going to boil this frog, we need to steal wisdom from TLA, not teach it. Type systems have borrowed a lot from Hinley-Milner, and are themselves a formal, partial proof.<p>I think I’d like to see a descendent of Property Based Testing that uses SAT or TLA techniques to rapidly condense the input space in a repeatable fashion. We should be able to deduce through parsing and code coverage that passing 12 to a function can never follow different branches than 11, but that -1 or 2^17 &lt; n &lt; 2^32 might.</div><br/><div id="42662198" class="c"><input type="checkbox" id="c-42662198" checked=""/><div class="controls bullet"><span class="by">johnbender</span><span>|</span><a href="#42656736">root</a><span>|</span><a href="#42658488">parent</a><span>|</span><a href="#42657139">next</a><span>|</span><label class="collapse" for="c-42662198">[-]</label><label class="expand" for="c-42662198">[1 more]</label></div><br/><div class="children"><div class="content">There’s decades of research in this vein fwiw, usually referred to as symbolic execution and it’s descendants like concolic execution.</div><br/></div></div></div></div><div id="42657139" class="c"><input type="checkbox" id="c-42657139" checked=""/><div class="controls bullet"><span class="by">hitchstory</span><span>|</span><a href="#42656736">parent</a><span>|</span><a href="#42658488">prev</a><span>|</span><a href="#42663078">next</a><span>|</span><label class="collapse" for="c-42657139">[-]</label><label class="expand" for="c-42657139">[2 more]</label></div><br/><div class="children"><div class="content">&gt;if it was really that helpful, more people would be applying it and the benefits would speak for themselves. They&#x27;ve been around a long, long time, though, and never caught on - it&#x27;s hard not to conclude that there&#x27;s probably a reason.<p>My impression is that there are actually not that many business domains where a large investment in time and money to get domain logic correctness from 98% to 99.99% correct is actually called for.<p>Formal methods <i>are</i> a large investment, too. No two ways around it.<p>Also, while they havent really caught on in general, some of their ideas have made it into modern type systems.</div><br/><div id="42663100" class="c"><input type="checkbox" id="c-42663100" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#42656736">root</a><span>|</span><a href="#42657139">parent</a><span>|</span><a href="#42663078">next</a><span>|</span><label class="collapse" for="c-42663100">[-]</label><label class="expand" for="c-42663100">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Formal methods are a large investment, too. No two ways around it.<p>My issue with the entire discussion, and lots of the community is that formal methods are not all the same.<p>Some are expensive, yes. If you insist on doing them all, you&#x27;ll never finish anything. But that&#x27;s not a reason to dump the entire set.</div><br/></div></div></div></div><div id="42663078" class="c"><input type="checkbox" id="c-42663078" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#42656736">parent</a><span>|</span><a href="#42657139">prev</a><span>|</span><a href="#42659081">next</a><span>|</span><label class="collapse" for="c-42663078">[-]</label><label class="expand" for="c-42663078">[1 more]</label></div><br/><div class="children"><div class="content">&gt; if it was really that helpful, more people would be applying it and the benefits would speak for themselves<p>Well... that&#x27;s not a good logic on any area, and on software development it&#x27;s twice as bad.<p>Most software projects still fail. And that&#x27;s not &quot;market failure&quot;, it&#x27;s just &quot;didn&#x27;t manage to build it&quot;.</div><br/></div></div><div id="42659081" class="c"><input type="checkbox" id="c-42659081" checked=""/><div class="controls bullet"><span class="by">sesm</span><span>|</span><a href="#42656736">parent</a><span>|</span><a href="#42663078">prev</a><span>|</span><a href="#42657177">next</a><span>|</span><label class="collapse" for="c-42659081">[-]</label><label class="expand" for="c-42659081">[1 more]</label></div><br/><div class="children"><div class="content">For Calculus you can easily explain to the unenlightened that many physical and engineering laws work in terms of speed and acceleration of measurable values, and Calculus is a mathematical framework for working with this.</div><br/></div></div></div></div><div id="42657177" class="c"><input type="checkbox" id="c-42657177" checked=""/><div class="controls bullet"><span class="by">jcgrillo</span><span>|</span><a href="#42656736">prev</a><span>|</span><a href="#42658164">next</a><span>|</span><label class="collapse" for="c-42657177">[-]</label><label class="expand" for="c-42657177">[8 more]</label></div><br/><div class="children"><div class="content">The lightweight formal methods callout is a good one. Maintaining a suite of proptest[1] strategies alongside the codebase is not a very much larger investment than writing unit tests by hand, but the insights they provide due to extensive coverage and compact understandable failure cases are way better. And crucially this approach <i>does</i> align with normal software development practices.<p>[1] <a href="https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;proptest" rel="nofollow">https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;proptest</a></div><br/><div id="42658066" class="c"><input type="checkbox" id="c-42658066" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#42657177">parent</a><span>|</span><a href="#42657218">next</a><span>|</span><label class="collapse" for="c-42658066">[-]</label><label class="expand" for="c-42658066">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Maintaining a suite of proptest[1] strategies alongside the codebase is not a very much larger investment than writing unit tests by hand,<p>I actually generate a unit tests with LLMs a lot lately. They do a decent job and you can just ask it to be a little more exhaustive, test any edge cases it can think of, or instruct it to deal with specific ones. I know a fair bit about how to write good tests and the effort you can put in that. But LLMs can generate better tests than me way faster.<p>If anything, they are less likely to do a half-assed job of it than me because I tend to run out of patience doing repetitive tedious shit. This is a healthy trait to have for a software engineer: we are supposed to make stuff easier by automating it. If it feels repetitive, your reflex should be to write code to make it less repetitive. Documentation is the same. I generate that too these days and since it is so easy, I do it more often and sooner.<p>LLMs might trigger a minor revolution in the adoption of formal method verification. Generating a correct specification is a combination of tedious and probably relatively easy for an LLM given enough context like working code, documentation, and other hints as to what the thing should do.<p>I&#x27;d be a lot more likely to bother with that stuff if I can just let it generate specification and then briefly glance through them than if I have to spell everything out manually.<p>I think using Rust kind of signals that you care about correctness. It&#x27;s compiler is probably the closest to proving your system is probably correct that you can get without resorting to formal methods. And probably a lot easier than trying to bolt on formal methods to languages that don&#x27;t even use a compiler or explicitly specified types.</div><br/></div></div><div id="42657218" class="c"><input type="checkbox" id="c-42657218" checked=""/><div class="controls bullet"><span class="by">andrepd</span><span>|</span><a href="#42657177">parent</a><span>|</span><a href="#42658066">prev</a><span>|</span><a href="#42658164">next</a><span>|</span><label class="collapse" for="c-42657218">[-]</label><label class="expand" for="c-42657218">[6 more]</label></div><br/><div class="children"><div class="content">Yeah but proptest &#x2F; qcheck is not formal methods at all. It&#x27;s randomised testing.</div><br/><div id="42657343" class="c"><input type="checkbox" id="c-42657343" checked=""/><div class="controls bullet"><span class="by">jcgrillo</span><span>|</span><a href="#42657177">root</a><span>|</span><a href="#42657218">parent</a><span>|</span><a href="#42657411">next</a><span>|</span><label class="collapse" for="c-42657343">[-]</label><label class="expand" for="c-42657343">[1 more]</label></div><br/><div class="children"><div class="content">The assertion is that they&#x27;re <i>lightweight</i> formal methods. Or is the article (and the proceedings of SOSP &#x27;21 it links to) wrong?<p>EDIT: ah I see where there might be confusion--obviously a library for generating random test data and making assertions about code under test itself doesn&#x27;t constitute anything like &quot;formal methods&quot; but the idea of <i>using</i> that library in the way described in the paper linked from the article does. But that&#x27;s kinda always the thing about software libraries..</div><br/></div></div><div id="42657411" class="c"><input type="checkbox" id="c-42657411" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#42657177">root</a><span>|</span><a href="#42657218">parent</a><span>|</span><a href="#42657343">prev</a><span>|</span><a href="#42658142">next</a><span>|</span><label class="collapse" for="c-42657411">[-]</label><label class="expand" for="c-42657411">[2 more]</label></div><br/><div class="children"><div class="content">Property tests are informal tests of formal properties.  They don&#x27;t guarantee the properties hold, or that the formal properties are complete, but they exploit the existence of these formal properties.<p>Once you have formal properties, you can write property-based tests using them, and I wonder how much of the benefit of formal methods could be obtained just by doing this.  It&#x27;s another example of using increased computing power (testing) to substitute for expensive hand labor (proving theorems).<p>I&#x27;ll also observe that even theorem proving systems benefit from a kind of property based testing.  If there&#x27;s a goal to prove the existence of a value satisfying some property, this is essentially a property based testing problem.  Similarly, find a counterexample to a universally quantified formula (also an existential problem) can be used to prune off unproductive branches of a search tree.</div><br/><div id="42657496" class="c"><input type="checkbox" id="c-42657496" checked=""/><div class="controls bullet"><span class="by">jcgrillo</span><span>|</span><a href="#42657177">root</a><span>|</span><a href="#42657411">parent</a><span>|</span><a href="#42658142">next</a><span>|</span><label class="collapse" for="c-42657496">[-]</label><label class="expand" for="c-42657496">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s something also in the UX dynamics. As a developer writing property based tests I&#x27;m encouraged to think much more carefully about system invariants, otherwise there&#x27;s not much value added over unit tests. For anything nontrivial this entails building a model of the system and checking it against the system under test, like they did at AWS. So the decision to use this tool shapes how you think about the system--it makes you reason more formally about it rather than just winging it and writing tests to exercise the code.</div><br/></div></div></div></div><div id="42658142" class="c"><input type="checkbox" id="c-42658142" checked=""/><div class="controls bullet"><span class="by">Tryk</span><span>|</span><a href="#42657177">root</a><span>|</span><a href="#42657218">parent</a><span>|</span><a href="#42657411">prev</a><span>|</span><a href="#42658164">next</a><span>|</span><label class="collapse" for="c-42658142">[-]</label><label class="expand" for="c-42658142">[2 more]</label></div><br/><div class="children"><div class="content">With an infinite domain (e.g.numbers) randomised testing is necessary, no?</div><br/><div id="42664031" class="c"><input type="checkbox" id="c-42664031" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#42657177">root</a><span>|</span><a href="#42658142">parent</a><span>|</span><a href="#42658164">next</a><span>|</span><label class="collapse" for="c-42664031">[-]</label><label class="expand" for="c-42664031">[1 more]</label></div><br/><div class="children"><div class="content">Not sure what exactly you mean by &quot;necessary&quot;, but I feel like the entire field of mathematics would disagree. Proving statements about infinite domains has a very long tradition.</div><br/></div></div></div></div></div></div></div></div><div id="42658164" class="c"><input type="checkbox" id="c-42658164" checked=""/><div class="controls bullet"><span class="by">synchronousq</span><span>|</span><a href="#42657177">prev</a><span>|</span><a href="#42662130">next</a><span>|</span><label class="collapse" for="c-42658164">[-]</label><label class="expand" for="c-42658164">[4 more]</label></div><br/><div class="children"><div class="content">I just want to note, there exist two main flavors of formal methods: extrinsic techniques, which are disjoint from the code itself and generally reason about the specifications of code, and intrinsic techniques, which are inline with the code itself and reason about the code more directly. Historically, intrinsic techniques (such as type systems) reason about code at a functional level, while extrinsic techniques (such as decidable model checkers like Spin&#x2F;P) reason about a model of the code, ascribed to formalism like an automata. But imo we&#x27;re currently in a complete golden age of formal methods research, and extrinsic techniques are falling out of flavor in comparison to intrinsic methods as pushed by type system advancements and projects like Verus [1].<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;verus-lang&#x2F;verus">https:&#x2F;&#x2F;github.com&#x2F;verus-lang&#x2F;verus</a></div><br/><div id="42660783" class="c"><input type="checkbox" id="c-42660783" checked=""/><div class="controls bullet"><span class="by">adsharma</span><span>|</span><a href="#42658164">parent</a><span>|</span><a href="#42658229">next</a><span>|</span><label class="collapse" for="c-42660783">[-]</label><label class="expand" for="c-42660783">[1 more]</label></div><br/><div class="children"><div class="content">TLA+ and the like work because they target a very small specification language.<p>With the large footprint of Rust, I&#x27;ve seen questions raised about how this will work. But haven&#x27;t seen good answers.<p>Would love to read more.</div><br/></div></div><div id="42658229" class="c"><input type="checkbox" id="c-42658229" checked=""/><div class="controls bullet"><span class="by">hashxyz</span><span>|</span><a href="#42658164">parent</a><span>|</span><a href="#42660783">prev</a><span>|</span><a href="#42662130">next</a><span>|</span><label class="collapse" for="c-42658229">[-]</label><label class="expand" for="c-42658229">[2 more]</label></div><br/><div class="children"><div class="content">I don’t see how the distinction makes any sense when the Verus project you linked requires you to write correctness specs. It sounded like intrinsic techniques were preferred because they would not require you to write and maintain a separate spec, but this is not the case.</div><br/><div id="42660692" class="c"><input type="checkbox" id="c-42660692" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#42658164">root</a><span>|</span><a href="#42658229">parent</a><span>|</span><a href="#42662130">next</a><span>|</span><label class="collapse" for="c-42660692">[-]</label><label class="expand" for="c-42660692">[1 more]</label></div><br/><div class="children"><div class="content">I prefer intrinsic techniques because it prevents the model from being out of sync with the implementation.<p>The thing that&#x27;s never made any sense to me about using a marble checker for anything but concurrency issues (which are hard enough to warrant it) is that once you&#x27;ve validated your model you have to go actually implement it, and that&#x27;s usually the most error prone part of the process.<p>If the correctness spec has to be written manually but prevents you from diverging from the spec in your implementation, that&#x27;s a huge step up from extrinsic model checkers.</div><br/></div></div></div></div></div></div><div id="42662130" class="c"><input type="checkbox" id="c-42662130" checked=""/><div class="controls bullet"><span class="by">charleshn</span><span>|</span><a href="#42658164">prev</a><span>|</span><a href="#42656612">next</a><span>|</span><label class="collapse" for="c-42662130">[-]</label><label class="expand" for="c-42662130">[3 more]</label></div><br/><div class="children"><div class="content">On lightweight formal methods, a favorite of mine that&#x27;s not widely known is trace verification using Linear Temporal Logic [0].<p>Basically you just need to log events - which you can even have for free in event-driven architectures etc - and run some predicates on execution traces, e.g. &quot;Always(Locked, Implies(Eventually(Unlocked)))&quot;, etc.<p>One can run it on historical traces, but also couple it to stress tests, fuzzing etc to explore the state space.<p>Quite simple, powerful and widely applicable, and doesn&#x27;t require a model, just predicates.<p>[0] <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Linear_temporal_logic" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Linear_temporal_logic</a></div><br/><div id="42662184" class="c"><input type="checkbox" id="c-42662184" checked=""/><div class="controls bullet"><span class="by">johnbender</span><span>|</span><a href="#42662130">parent</a><span>|</span><a href="#42656612">next</a><span>|</span><label class="collapse" for="c-42662184">[-]</label><label class="expand" for="c-42662184">[2 more]</label></div><br/><div class="children"><div class="content">A minor point. This is more akin to testing because you’re only checking your formulae against a subset of system traces.<p>Formal methods connotes comprehensive evidence about system behavior. In the case of TLA and similar system that’s a state machine and not the real system but the output for the state machine is a proof that your LTL&#x2F;CTL&#x2F;TLA properties hold for all behaviors of the system (traces or trees of traces).</div><br/><div id="42662650" class="c"><input type="checkbox" id="c-42662650" checked=""/><div class="controls bullet"><span class="by">charleshn</span><span>|</span><a href="#42662130">root</a><span>|</span><a href="#42662184">parent</a><span>|</span><a href="#42656612">next</a><span>|</span><label class="collapse" for="c-42662650">[-]</label><label class="expand" for="c-42662650">[1 more]</label></div><br/><div class="children"><div class="content">Definitely, I&#x27;m playing fast and loose with &quot;lightweight formal method here&quot;, thanks for making it clear.<p>I was mentioning it in the same context as e.g. the Amazon paper on lightweight formal methods [0] where they use property-based testing to test that the implementation conforms to the model specification.<p>In a similar spirit, linearizability checkers like Porcupine [1] are a nice mix of formalism and usability.<p>I really like those because they are incredibly powerful, don&#x27;t require a model and verify the actual implementation - obviously as you mention they are not exhaustive.<p>[0] <a href="https:&#x2F;&#x2F;assets.amazon.science&#x2F;77&#x2F;5e&#x2F;4a7c238f4ce890efdc325df83263&#x2F;using-lightweight-formal-methods-to-validate-a-key-value-storage-node-in-amazon-s3-2.pdf" rel="nofollow">https:&#x2F;&#x2F;assets.amazon.science&#x2F;77&#x2F;5e&#x2F;4a7c238f4ce890efdc325df8...</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;anishathalye&#x2F;porcupine">https:&#x2F;&#x2F;github.com&#x2F;anishathalye&#x2F;porcupine</a></div><br/></div></div></div></div></div></div><div id="42656612" class="c"><input type="checkbox" id="c-42656612" checked=""/><div class="controls bullet"><span class="by">franktankbank</span><span>|</span><a href="#42662130">prev</a><span>|</span><a href="#42656939">next</a><span>|</span><label class="collapse" for="c-42656612">[-]</label><label class="expand" for="c-42656612">[4 more]</label></div><br/><div class="children"><div class="content">Too slow, planning==ossification any documentation can and will be used against you in the Agile court of law.</div><br/><div id="42657703" class="c"><input type="checkbox" id="c-42657703" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#42656612">parent</a><span>|</span><a href="#42656939">next</a><span>|</span><label class="collapse" for="c-42657703">[-]</label><label class="expand" for="c-42657703">[3 more]</label></div><br/><div class="children"><div class="content">Arguably, if &#x27;real&#x27; Agile is ever found Formal Methods would be the antithesis of it: something provable and reproducible is blasphemy to True Believers.</div><br/><div id="42657768" class="c"><input type="checkbox" id="c-42657768" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#42656612">root</a><span>|</span><a href="#42657703">parent</a><span>|</span><a href="#42656939">next</a><span>|</span><label class="collapse" for="c-42657768">[-]</label><label class="expand" for="c-42657768">[2 more]</label></div><br/><div class="children"><div class="content">Not at all.  Something <i>that you can&#x27;t easily change</i> is terrifying.<p>Reproducible?  Sure, that&#x27;s what unit tests are for.  Make a change, prove that you didn&#x27;t break any behavior that anybody relied on.<p>But if you have to do a three-month-long formal proof run because the specification had a one-line change, then you&#x27;re not agile, under any meaningful definition.<p>(Where did three months come from?  Thin air.  I don&#x27;t know how long a true formal proof would take.  Depends on how many things you&#x27;re proving, how long your spec is, and how much CPU power you have.  I would think, though, to formally prove significant properties of a large code base would take a significant time.)</div><br/><div id="42658118" class="c"><input type="checkbox" id="c-42658118" checked=""/><div class="controls bullet"><span class="by">franktankbank</span><span>|</span><a href="#42656612">root</a><span>|</span><a href="#42657768">parent</a><span>|</span><a href="#42656939">next</a><span>|</span><label class="collapse" for="c-42658118">[-]</label><label class="expand" for="c-42658118">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, we are discussing Agile not agile.</div><br/></div></div></div></div></div></div></div></div><div id="42656939" class="c"><input type="checkbox" id="c-42656939" checked=""/><div class="controls bullet"><span class="by">thefaux</span><span>|</span><a href="#42656612">prev</a><span>|</span><a href="#42656505">next</a><span>|</span><label class="collapse" for="c-42656939">[-]</label><label class="expand" for="c-42656939">[4 more]</label></div><br/><div class="children"><div class="content">Most of the articles I&#x27;ve read about formal methods feel like lead gen for consultants. That&#x27;s fine but feels obnoxious when they implicitly act as though they have reached formal methods induced enlightenment that you can too if you buy a pack of trainings for your employees&#x2F;coworkers or hire me as an employee to fix your bad (irresponsibly dangerous even!) programming habits.<p>Get back to me when the formal methods actually generate high quality code that cannot deviate from the spec.</div><br/><div id="42657970" class="c"><input type="checkbox" id="c-42657970" checked=""/><div class="controls bullet"><span class="by">aiono</span><span>|</span><a href="#42656939">parent</a><span>|</span><a href="#42657648">next</a><span>|</span><label class="collapse" for="c-42657970">[-]</label><label class="expand" for="c-42657970">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Get back to me when the formal methods actually generate high quality code that cannot deviate from the spec<p>That would be useful but there is a fundamental issue: code is too specific. İn formal specification you usually don&#x27;t specify that detailed but you specify the general behaviour of the system. So usually the specification corresponds to a lot of programs with subtle differences. That&#x27;s why code a documentation falls short: you don&#x27;t know what is intentional and what is just a random choice. It&#x27;s simply too specific to describe high level requirements.<p>The other way around (verification of program with respect to the specification) can be more feasible to implement.</div><br/></div></div><div id="42657648" class="c"><input type="checkbox" id="c-42657648" checked=""/><div class="controls bullet"><span class="by">erpellan</span><span>|</span><a href="#42656939">parent</a><span>|</span><a href="#42657970">prev</a><span>|</span><a href="#42656505">next</a><span>|</span><label class="collapse" for="c-42657648">[-]</label><label class="expand" for="c-42657648">[2 more]</label></div><br/><div class="children"><div class="content">How about <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SPARK_(programming_language)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SPARK_(programming_language)</a></div><br/><div id="42660776" class="c"><input type="checkbox" id="c-42660776" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#42656939">root</a><span>|</span><a href="#42657648">parent</a><span>|</span><a href="#42656505">next</a><span>|</span><label class="collapse" for="c-42660776">[-]</label><label class="expand" for="c-42660776">[1 more]</label></div><br/><div class="children"><div class="content">Ada is terminally underappreciated.</div><br/></div></div></div></div></div></div><div id="42656505" class="c"><input type="checkbox" id="c-42656505" checked=""/><div class="controls bullet"><span class="by">ot</span><span>|</span><a href="#42656939">prev</a><span>|</span><a href="#42660145">next</a><span>|</span><label class="collapse" for="c-42656505">[-]</label><label class="expand" for="c-42656505">[6 more]</label></div><br/><div class="children"><div class="content">Previous discussion (Jun 2024): <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40753989">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40753989</a></div><br/><div id="42656682" class="c"><input type="checkbox" id="c-42656682" checked=""/><div class="controls bullet"><span class="by">aiono</span><span>|</span><a href="#42656505">parent</a><span>|</span><a href="#42660145">next</a><span>|</span><label class="collapse" for="c-42656682">[-]</label><label class="expand" for="c-42656682">[5 more]</label></div><br/><div class="children"><div class="content">Thanks, I couldn&#x27;t find it via Google search on this website for some reason.</div><br/><div id="42657099" class="c"><input type="checkbox" id="c-42657099" checked=""/><div class="controls bullet"><span class="by">ChrisArchitect</span><span>|</span><a href="#42656505">root</a><span>|</span><a href="#42656682">parent</a><span>|</span><a href="#42656843">next</a><span>|</span><label class="collapse" for="c-42657099">[-]</label><label class="expand" for="c-42657099">[1 more]</label></div><br/><div class="children"><div class="content">Google search? Use the HN search on site here: <a href="https:&#x2F;&#x2F;hn.algolia.com&#x2F;?q=https%3A%2F%2Fbrooker.co.za%2Fblog%2F2024%2F04%2F17%2Fformal" rel="nofollow">https:&#x2F;&#x2F;hn.algolia.com&#x2F;?q=https%3A%2F%2Fbrooker.co.za%2Fblog...</a></div><br/></div></div><div id="42656843" class="c"><input type="checkbox" id="c-42656843" checked=""/><div class="controls bullet"><span class="by">onionisafruit</span><span>|</span><a href="#42656505">root</a><span>|</span><a href="#42656682">parent</a><span>|</span><a href="#42657099">prev</a><span>|</span><a href="#42656887">next</a><span>|</span><label class="collapse" for="c-42656843">[-]</label><label class="expand" for="c-42656843">[2 more]</label></div><br/><div class="children"><div class="content">I’m glad you couldn’t if that would have kept you from posting it today.</div><br/><div id="42657451" class="c"><input type="checkbox" id="c-42657451" checked=""/><div class="controls bullet"><span class="by">aiono</span><span>|</span><a href="#42656505">root</a><span>|</span><a href="#42656843">parent</a><span>|</span><a href="#42656887">next</a><span>|</span><label class="collapse" for="c-42657451">[-]</label><label class="expand" for="c-42657451">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I wasn&#x27;t going to post it if it was shared before. But I am happy that some are happy that it&#x27;s reposted.</div><br/></div></div></div></div><div id="42656887" class="c"><input type="checkbox" id="c-42656887" checked=""/><div class="controls bullet"><span class="by">ot</span><span>|</span><a href="#42656505">root</a><span>|</span><a href="#42656682">parent</a><span>|</span><a href="#42656843">prev</a><span>|</span><a href="#42660145">next</a><span>|</span><label class="collapse" for="c-42656887">[-]</label><label class="expand" for="c-42656887">[1 more]</label></div><br/><div class="children"><div class="content">Nothing wrong with reposts, it&#x27;s just useful to link to previous discussions for context :)</div><br/></div></div></div></div></div></div><div id="42660145" class="c"><input type="checkbox" id="c-42660145" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42656505">prev</a><span>|</span><a href="#42657879">next</a><span>|</span><label class="collapse" for="c-42660145">[-]</label><label class="expand" for="c-42660145">[1 more]</label></div><br/><div class="children"><div class="content">IMO formal software verification is still waaay too difficult to be worth it in all but the most extreme cases. That&#x27;s really different to formal hardware verification where it is a no-brainer.<p>I keep trying to learn it, but you need to be a real expert. Like &quot;I wrote the compiler&quot; level expert for most systems.<p>For example I tried to prove a varint encoder&#x2F;decoder. It worked for one or two bytes, but not more. Asking for help the reason was that the compiler internally only unrolls loops 5 times, or some random internal detail like that that you could never really hope to know.<p>I&#x27;ve been learning Lean recently, and ... I mean I like it, but if you learn it you&#x27;re going to encounter documentation like this:<p>&gt; Definitional equality includes η-equivalence of functions and single-constructor inductive types. That is, fun x =&gt; f x is definitionally equal to f, and S.mk x.f1 x.f2 is definitionally equal to x, if S is a structure with fields f1 and f2. It also features proof irrelevance, so any two proofs of the same proposition are definitionally equal. It is reflexive, symmetric, and a congruence.<p>And that&#x27;s not really a knock on Lean - it seems to have some of the better documentation out of the alternatives.</div><br/></div></div><div id="42657879" class="c"><input type="checkbox" id="c-42657879" checked=""/><div class="controls bullet"><span class="by">brap</span><span>|</span><a href="#42660145">prev</a><span>|</span><a href="#42662749">next</a><span>|</span><label class="collapse" for="c-42657879">[-]</label><label class="expand" for="c-42657879">[3 more]</label></div><br/><div class="children"><div class="content">I’m not super experienced with formal verification, but I did dip my toes in it a few times.<p>My impression is that it’s far from a magic bullet. Writing formal specs is basically like writing the code&#x2F;tests just differently. And the more it covers the more it becomes the same thing. And it suffers from the same problems.<p>My conclusion every time was that the code itself <i>is</i> the formal spec and the formal spec <i>is</i> the code.<p>By analogy with construction, the code is both the building and the blueprint.</div><br/><div id="42660245" class="c"><input type="checkbox" id="c-42660245" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42657879">parent</a><span>|</span><a href="#42657953">next</a><span>|</span><label class="collapse" for="c-42660245">[-]</label><label class="expand" for="c-42660245">[1 more]</label></div><br/><div class="children"><div class="content">&gt; My conclusion every time was that the code itself is the formal spec and the formal spec is the code.<p>Yes you can end up with tautological specs, where it&#x27;s more or less a copy of the code. E.g. you aren&#x27;t going to benefit much from formally verifying `max()`.<p>But there are <i>many many</i> cases where the formal specification is <i>much much</i> simpler and more obviously correct than the actual code. The classic examples are:<p>* Any kind of encoding &#x2F; decoding transformation has the property `decode(encode(x)) == x`.<p>* Sorting: any sorting algorithm should result in a sorted array (forall i, j: i &lt; j --&gt; array[i] &lt;= array[j])</div><br/></div></div><div id="42657953" class="c"><input type="checkbox" id="c-42657953" checked=""/><div class="controls bullet"><span class="by">davidmurdoch</span><span>|</span><a href="#42657879">parent</a><span>|</span><a href="#42660245">prev</a><span>|</span><a href="#42662749">next</a><span>|</span><label class="collapse" for="c-42657953">[-]</label><label class="expand" for="c-42657953">[1 more]</label></div><br/><div class="children"><div class="content">This. In my very limited experience (i didn&#x27;t write the code or specs), I&#x27;ve seen the runtime code find more bugs in the formal specs than the formal specs finding bugs in the runtime code.</div><br/></div></div></div></div><div id="42662749" class="c"><input type="checkbox" id="c-42662749" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42657879">prev</a><span>|</span><a href="#42658965">next</a><span>|</span><label class="collapse" for="c-42662749">[-]</label><label class="expand" for="c-42662749">[1 more]</label></div><br/><div class="children"><div class="content">AWS has said that when software has a robust set of formal verification tests they can be very aggressive when optimizing it and be confident that they aren&#x27;t changing its behavior. They say they were able to optimize their IAM authentication code by over 50% this way.</div><br/></div></div><div id="42658965" class="c"><input type="checkbox" id="c-42658965" checked=""/><div class="controls bullet"><span class="by">markusde</span><span>|</span><a href="#42662749">prev</a><span>|</span><a href="#42657545">next</a><span>|</span><label class="collapse" for="c-42658965">[-]</label><label class="expand" for="c-42658965">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d recommend anyone with a passing interest in the role formal techniques can play in software development watch this [1] talk. Mike Dodds is a principal scientist at Galois (a company which has a lot of experience with applying formal methods in industry and government) and the talk does a good job at explaining where they&#x27;ve seen value-added from formal methods, and the right kind of formal methods for different applications.<p>[1]: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=gfvvowAc130" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=gfvvowAc130</a></div><br/></div></div><div id="42657545" class="c"><input type="checkbox" id="c-42657545" checked=""/><div class="controls bullet"><span class="by">trending486</span><span>|</span><a href="#42658965">prev</a><span>|</span><a href="#42657897">next</a><span>|</span><label class="collapse" for="c-42657545">[-]</label><label class="expand" for="c-42657545">[6 more]</label></div><br/><div class="children"><div class="content">Modern formal methods like TLA+ and Alloy are as easy to pick up as Python, and other than having to write a spec (an ultra-simplified model of part of a system) they are completely automatic (based on model checkers). There is no reason for a modern software engineer not to have them on her radar. As a matter of fact most of the cloud systems you are using everyday have been verified with modern formal tools: Azure Cosmos DB, Dynamo DB, MongoDB, CockroachDB, ... and many others.</div><br/><div id="42658447" class="c"><input type="checkbox" id="c-42658447" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#42657545">parent</a><span>|</span><a href="#42660817">next</a><span>|</span><label class="collapse" for="c-42658447">[-]</label><label class="expand" for="c-42658447">[3 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t done enough with Alloy to speak with any degree of competence with it, so I&#x27;ll only speak on TLA+.<p>While I do think TLA+ is relatively easy to pick up (especially compared to Isabelle or Coq), and I think it&#x27;s pretty awesome, I&#x27;m hesitant to say it&#x27;s as &quot;easy to pick up as Python&quot;.  You need a basic understanding of set theory and state machines to even get started, and more advanced concepts like algorithm refinement to get into the really useful juicy stuff.<p>When I&#x27;ve tried to push TLA+ at work, the mathey syntax is usually a non-starter for most of my engineering colleagues.  I don&#x27;t think my coworkers are stupid by any stretch, but they are decidedly uninterested in re-learning any discrete math (if they ever learned it in the first place, which isn&#x27;t a guarantee). For an engineer LARPing as an academic like me, TLA+&#x27;s notation isn&#x27;t really hard at all, but I will often forget that most engineers <i>only</i> think in code.</div><br/><div id="42659839" class="c"><input type="checkbox" id="c-42659839" checked=""/><div class="controls bullet"><span class="by">Taikonerd</span><span>|</span><a href="#42657545">root</a><span>|</span><a href="#42658447">parent</a><span>|</span><a href="#42660817">next</a><span>|</span><label class="collapse" for="c-42659839">[-]</label><label class="expand" for="c-42659839">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; When I&#x27;ve tried to push TLA+ at work, the mathey syntax is usually a non-starter</i><p>Would they be interested in Quint?[0]  If I understand correctly, Quint is very similar to TLA+, but with a more &quot;code-looking&quot; notation.  And it has some nice dev tooling, like an LSP, which also lowers the barrier to entry.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;informalsystems&#x2F;quint">https:&#x2F;&#x2F;github.com&#x2F;informalsystems&#x2F;quint</a></div><br/><div id="42660291" class="c"><input type="checkbox" id="c-42660291" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#42657545">root</a><span>|</span><a href="#42659839">parent</a><span>|</span><a href="#42660817">next</a><span>|</span><label class="collapse" for="c-42660291">[-]</label><label class="expand" for="c-42660291">[1 more]</label></div><br/><div class="children"><div class="content">Possible, I haven’t tried it.<p>It’s still an uphill battle, because the comparison to unit tests always comes up, and I have to explain how they’re not equivalent.</div><br/></div></div></div></div></div></div><div id="42660817" class="c"><input type="checkbox" id="c-42660817" checked=""/><div class="controls bullet"><span class="by">adsharma</span><span>|</span><a href="#42657545">parent</a><span>|</span><a href="#42658447">prev</a><span>|</span><a href="#42657897">next</a><span>|</span><label class="collapse" for="c-42660817">[-]</label><label class="expand" for="c-42660817">[2 more]</label></div><br/><div class="children"><div class="content">Why not use python itself then? The design by contract PEP is old. Not sure if anyone is working on it.<p><a href="https:&#x2F;&#x2F;adsharma.github.io&#x2F;agentic-transpilers&#x2F;" rel="nofollow">https:&#x2F;&#x2F;adsharma.github.io&#x2F;agentic-transpilers&#x2F;</a><p><a href="https:&#x2F;&#x2F;adsharma.github.io&#x2F;pysmt" rel="nofollow">https:&#x2F;&#x2F;adsharma.github.io&#x2F;pysmt</a></div><br/><div id="42660938" class="c"><input type="checkbox" id="c-42660938" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#42657545">root</a><span>|</span><a href="#42660817">parent</a><span>|</span><a href="#42657897">next</a><span>|</span><label class="collapse" for="c-42660938">[-]</label><label class="expand" for="c-42660938">[1 more]</label></div><br/><div class="children"><div class="content">A 21-year-old deferred PEP is probably safely described as dead with only the most distant hope that it might one day be revived, or, more likely replaced with an entirely different PEP addressing a similar domain with a new approach.</div><br/></div></div></div></div></div></div><div id="42657897" class="c"><input type="checkbox" id="c-42657897" checked=""/><div class="controls bullet"><span class="by">nimish</span><span>|</span><a href="#42657545">prev</a><span>|</span><a href="#42659454">next</a><span>|</span><label class="collapse" for="c-42657897">[-]</label><label class="expand" for="c-42657897">[3 more]</label></div><br/><div class="children"><div class="content">Formal methods work great when the price of failure is absolute. Mostly pointless otherwise but can be a good exercise I guess.</div><br/><div id="42658400" class="c"><input type="checkbox" id="c-42658400" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#42657897">parent</a><span>|</span><a href="#42659134">next</a><span>|</span><label class="collapse" for="c-42658400">[-]</label><label class="expand" for="c-42658400">[1 more]</label></div><br/><div class="children"><div class="content">With most testing and verification, there&#x27;s a law of diminishing returns. It helps you find stuff that you need to fix and there is always stuff to find. But at some point you&#x27;ve found enough of the stuff that needed fixing that you can use the software and it starts making money for you. Most people stop there. It&#x27;s not going to make much more money if you continue your efforts and the risk of a lot of financial damage is usually not that high. A good software license will ensure that. You might be better off paying a decent lawyer than wasting time on formal methods. Lawyers aren&#x27;t cheap. But neither is having your software engineering team faff about with a lot of complex tools for weeks on end.<p>And with software you can just do an update if something is found later. Not a big deal usually. There are exceptions of course. With hardware things get more expensive. But still, judging from the state of e.g. most bluetooth and other hardware I&#x27;ve ever owned, the barrier of good enough is pretty low there too. Mostly things work and you can usually work around minor issues when they don&#x27;t.<p>Some, software justifies&#x2F;requires going above and beyond doing testing. Especially if it controls critical hardware. I&#x27;ve never worked on such stuff. And even there the notion of releasing often and breaking stuff by testing it seems to be catching on. For example SpaceX is doing agile rocket development. They launch starship every few months until they get it reliable enough to launch things into orbit.</div><br/></div></div><div id="42659134" class="c"><input type="checkbox" id="c-42659134" checked=""/><div class="controls bullet"><span class="by">aiono</span><span>|</span><a href="#42657897">parent</a><span>|</span><a href="#42658400">prev</a><span>|</span><a href="#42659454">next</a><span>|</span><label class="collapse" for="c-42659134">[-]</label><label class="expand" for="c-42659134">[1 more]</label></div><br/><div class="children"><div class="content">I doubt that although I agree that it&#x27;s much more useful when cost of a failure is higher. For example I work in a lab that formalizes requirements and we have real customers that pay us for formalization because they find it useful. Some products are things that a failure could cause injury or even possibly death. But not all systems have that high costs and they still see benefits.</div><br/></div></div></div></div><div id="42659454" class="c"><input type="checkbox" id="c-42659454" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42657897">prev</a><span>|</span><a href="#42657166">next</a><span>|</span><label class="collapse" for="c-42659454">[-]</label><label class="expand" for="c-42659454">[1 more]</label></div><br/><div class="children"><div class="content">The article is thin on specifics.<p>Some problems specify well. A database is an example. A spec for a database can be written in terms of exhaustive search, running the query against everything. Now show that an efficient database yields the same output.</div><br/></div></div><div id="42657166" class="c"><input type="checkbox" id="c-42657166" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#42659454">prev</a><span>|</span><a href="#42658432">next</a><span>|</span><label class="collapse" for="c-42657166">[-]</label><label class="expand" for="c-42657166">[1 more]</label></div><br/><div class="children"><div class="content">I would guess a majority of developers use formal methods these days. We just tend to call them type systems, and for some reason consider them a distinct category. If simulations count as formal methods, then tests, and particularly property-based testing, also make the cut.</div><br/></div></div><div id="42658432" class="c"><input type="checkbox" id="c-42658432" checked=""/><div class="controls bullet"><span class="by">begueradj</span><span>|</span><a href="#42657166">prev</a><span>|</span><a href="#42657079">next</a><span>|</span><label class="collapse" for="c-42658432">[-]</label><label class="expand" for="c-42658432">[1 more]</label></div><br/><div class="children"><div class="content">For those interested in the information exchange about this same article: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40753989">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40753989</a></div><br/></div></div><div id="42657789" class="c"><input type="checkbox" id="c-42657789" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#42657079">prev</a><span>|</span><a href="#42657084">next</a><span>|</span><label class="collapse" for="c-42657789">[-]</label><label class="expand" for="c-42657789">[1 more]</label></div><br/><div class="children"><div class="content">Good engineering practice is to use the <i>appropriate</i> level of rigor.  It depends on what the cost of failure is, and what the cost of the rigor is.</div><br/></div></div></div></div></div></div></div></body></html>