<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685437257244" as="style"/><link rel="stylesheet" href="styles.css?v=1685437257244"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blainehansen.me/post/macro-ts/">Macro-ts: TypeScript compiler with typesafe syntactic macros (2022)</a> <span class="domain">(<a href="https://blainehansen.me">blainehansen.me</a>)</span></div><div class="subtext"><span>aabbcc1241</span> | <span>18 comments</span></div><br/><div><div id="36121405" class="c"><input type="checkbox" id="c-36121405" checked=""/><div class="controls bullet"><span class="by">amitport</span><span>|</span><a href="#36122083">next</a><span>|</span><label class="collapse" for="c-36121405">[-]</label><label class="expand" for="c-36121405">[2 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t call this a macro system. It&#x27;s a preprocessor for another language that is transpiled to typescript.<p>A ts macro system would be integrated with ts language service and tsc. As a compile time language, the main advantage of tsc is, well, developer experience, which, unless I&#x27;m missing something, gets thrown out the door here.<p>Also, the demo includes very weak use cases, much of it could be done directly with js functionality without the additional macros. It&#x27;s not clear to me how much effort and computation time does this saves.</div><br/><div id="36121841" class="c"><input type="checkbox" id="c-36121841" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#36121405">parent</a><span>|</span><a href="#36122083">next</a><span>|</span><label class="collapse" for="c-36121841">[-]</label><label class="expand" for="c-36121841">[1 more]</label></div><br/><div class="children"><div class="content">Agree. It’s template TS, which is why I shied away from it when I first encountered it. I do think it has some language service support FWIW, but I don’t want even more new arbitrary syntax in a constantly churning language. I do want TS macros, I just want them to be compile time functions over existing syntax with, well… lisp but I can’t have that.</div><br/></div></div></div></div><div id="36122083" class="c"><input type="checkbox" id="c-36122083" checked=""/><div class="controls bullet"><span class="by">9dev</span><span>|</span><a href="#36121405">prev</a><span>|</span><a href="#36121396">next</a><span>|</span><label class="collapse" for="c-36122083">[-]</label><label class="expand" for="c-36122083">[2 more]</label></div><br/><div class="children"><div class="content">The case he describes seems like a really bad example. All of that code could be rewritten to use properly composed functions - a library, for sure, but the complaint isn’t valid. That’s like writing procedural PHP with the database connection defined inline everywhere you use it. There is no need to do so if you can import modules!<p>Are there any actual cases where a macro system in TypeScript would be useful?</div><br/><div id="36122176" class="c"><input type="checkbox" id="c-36122176" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#36122083">parent</a><span>|</span><a href="#36121396">next</a><span>|</span><label class="collapse" for="c-36122176">[-]</label><label class="expand" for="c-36122176">[1 more]</label></div><br/><div class="children"><div class="content">I think it could be useful for cases where codegen is used - creating ts file that operates on a list of files in directory, autogen for client&#x2F;protocol based on some schema&#x2F;declaration.</div><br/></div></div></div></div><div id="36121396" class="c"><input type="checkbox" id="c-36121396" checked=""/><div class="controls bullet"><span class="by">tonyg</span><span>|</span><a href="#36122083">prev</a><span>|</span><a href="#36121613">next</a><span>|</span><label class="collapse" for="c-36121396">[-]</label><label class="expand" for="c-36121396">[4 more]</label></div><br/><div class="children"><div class="content">&gt; We can&#x27;t change the parser<p>Aw :-(<p>That&#x27;s the bit that I&#x27;d really like to have TS macros for!<p>My own approach has been to loosely parse input as something like D-expressions, transform that, and pipe the result into the TS compiler. Crude but effective. The trickiest part is extending the tsserver support, but even this is doable.</div><br/><div id="36121590" class="c"><input type="checkbox" id="c-36121590" checked=""/><div class="controls bullet"><span class="by">LispSporks22</span><span>|</span><a href="#36121396">parent</a><span>|</span><a href="#36121613">next</a><span>|</span><label class="collapse" for="c-36121590">[-]</label><label class="expand" for="c-36121590">[3 more]</label></div><br/><div class="children"><div class="content">Lisp user here. How come they can’t change their parser?</div><br/><div id="36122070" class="c"><input type="checkbox" id="c-36122070" checked=""/><div class="controls bullet"><span class="by">tonyg</span><span>|</span><a href="#36121396">root</a><span>|</span><a href="#36121590">parent</a><span>|</span><a href="#36121617">next</a><span>|</span><label class="collapse" for="c-36122070">[-]</label><label class="expand" for="c-36122070">[1 more]</label></div><br/><div class="children"><div class="content">The implementation of the parser is deeply, deeply baked in to the whole of the MS TypeScript compiler and tooling libraries. It&#x27;s not feasible to, e.g., add new AST nodes, or change or augment the grammar producing them, and there&#x27;s nothing like S- or D-expressions to allow for read&#x2F;parse separation like in lisps. (Which is why I added something D-expression like.)</div><br/></div></div><div id="36121617" class="c"><input type="checkbox" id="c-36121617" checked=""/><div class="controls bullet"><span class="by">goto11</span><span>|</span><a href="#36121396">root</a><span>|</span><a href="#36121590">parent</a><span>|</span><a href="#36122070">prev</a><span>|</span><a href="#36121613">next</a><span>|</span><label class="collapse" for="c-36121617">[-]</label><label class="expand" for="c-36121617">[1 more]</label></div><br/><div class="children"><div class="content">The describe it as &quot;an unsanctioned hack on top of typescript&quot;, so I think the point is they don&#x27;t want to change the typescript parser itself, but provide this as an add-on.</div><br/></div></div></div></div></div></div><div id="36121613" class="c"><input type="checkbox" id="c-36121613" checked=""/><div class="controls bullet"><span class="by">cabalamat</span><span>|</span><a href="#36121396">prev</a><span>|</span><a href="#36121379">next</a><span>|</span><label class="collapse" for="c-36121613">[-]</label><label class="expand" for="c-36121613">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Since WebAssembly can&#x27;t directly interact with the dom (yet)<p>Going off at a tangent, is there a reason WebAssembly can&#x27;t interact with the DOM? I would have thought that being able to do so would be kinda useful, particularly in a web page.</div><br/><div id="36121857" class="c"><input type="checkbox" id="c-36121857" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#36121613">parent</a><span>|</span><a href="#36121966">next</a><span>|</span><label class="collapse" for="c-36121857">[-]</label><label class="expand" for="c-36121857">[1 more]</label></div><br/><div class="children"><div class="content">WebAssembly can interact with JavaScript, and JavaScript can access the DOM. This was a compromise to reduce attack surface and implementation effort, to get a version 1 out the door. Allowing direct DOM access would have required implementors to harden every individual DOM API to make sure the new call path doesn’t open any security holes. The WASM-to-JS layer is comparably tiny, and the JS-to-DOM layer is already there and (hopefully) secure.</div><br/></div></div><div id="36121966" class="c"><input type="checkbox" id="c-36121966" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#36121613">parent</a><span>|</span><a href="#36121857">prev</a><span>|</span><a href="#36121379">next</a><span>|</span><label class="collapse" for="c-36121966">[-]</label><label class="expand" for="c-36121966">[3 more]</label></div><br/><div class="children"><div class="content">Codeflo answers it from the security perspective, but I’ll add a little to it in that WebAssembly doesn’t want to replace JavaScript. At least not currently, but it wasn’t always like that and there has been a long road of getting to this point with a lot of discussions on the topic. This may be dumbing it down a little, but basically it was decided that replacing JavaScript was unrealistic.<p>So for now you can think of it as a range of different things in the form of web development. You can view it as a sort of non-proprietary flash, where you can technically distribute your flash-like application to any browser. You can also view it like another form of virtual DOM (of sorts) the way Microsoft tries to do with Blazor, or you can view it as JavaScript “modules” where you do compute heavy stuff with C++ and implement it in your otherwise JavaScript frontend. But that’s just the web part, WebAssembly wants to be more than that, but you should go to their documentation for a better understanding of that.<p>It would be kind of useful to have WebAssembly interact with the DOM and I’m not completely convinced that the security would be a major issue, but it’s a massive undertaking, and it’s likely going to be sort of in vain. Because JavaScript is moving forward at a much higher pace than WebAssembly. One of the primary reasons you often see listed is that the DOM is slow, but that’s not really true. Because the adding or removing a DOM node is literally a few pointer swaps, which isn&#x27;t much more than setting a property on an OOP language object. What is slow is &quot;layout&quot;. When Javascript changes something and hands control back to the browser it invokes its CSS recalc, layout, repaint and finally recomposition algorithms to redraw the screen. The layout algorithm is quite complex and it&#x27;s synchronous, which makes it stupidly easy to make thing slow. Imagine handling that, again, when we’re not even really intend on doing so in most frontend JavaScript. What I mean by this is that one or the reasons we use React (and by we I mean the global we) is that it’s much easier to not fuck-up with the virtual DOM, and while things like Blazor is valid alternatives, they aren’t remotely comparable even when backed by Microsoft.<p>So it’s really a question of “do we want to do all that work, when all that work is already being done better by someone else?”, and for now the answer is “no”. Which is disappointing to many, but probably not the many who were going to contribute anyway.</div><br/><div id="36122407" class="c"><input type="checkbox" id="c-36122407" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#36121613">root</a><span>|</span><a href="#36121966">parent</a><span>|</span><a href="#36122224">next</a><span>|</span><label class="collapse" for="c-36122407">[-]</label><label class="expand" for="c-36122407">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that&#x27;s the consensus opinion, and suggesting that it is might be misleading to people who are less informed than you are.<p>You already mention Blazor, which would hugely profit from direct DOM access. Various React-like frameworks now exist for various languages that target WebAssembly, all of them would receive performance benefits from not having to go through a JavaScript layer all the time.<p>That&#x27;s the community side. On the standards side, efforts to enable direct Web IDL bindings are still underway, they just take time. Some things have been postponed because the issues are more complex than originally anticipated. But this will eventually happen.</div><br/></div></div><div id="36122224" class="c"><input type="checkbox" id="c-36122224" checked=""/><div class="controls bullet"><span class="by">throwaway3245</span><span>|</span><a href="#36121613">root</a><span>|</span><a href="#36121966">parent</a><span>|</span><a href="#36122407">prev</a><span>|</span><a href="#36121379">next</a><span>|</span><label class="collapse" for="c-36122224">[-]</label><label class="expand" for="c-36122224">[1 more]</label></div><br/><div class="children"><div class="content">Excellent overview, thank you. WebAssembly is something I have seen mentioned for maybe 10 years but I never really took time to actually figure out what it is. I suppose I still don&#x27;t truly know but for a 2 minute read, it cleared up a lot of my misunderstanding.</div><br/></div></div></div></div></div></div><div id="36121379" class="c"><input type="checkbox" id="c-36121379" checked=""/><div class="controls bullet"><span class="by">dvt</span><span>|</span><a href="#36121613">prev</a><span>|</span><label class="collapse" for="c-36121379">[-]</label><label class="expand" for="c-36121379">[4 more]</label></div><br/><div class="children"><div class="content">&gt; knows that a huge chunk of why it&#x27;s so excellent is the macro system<p>Macros are bad and you&#x27;re bad if you use them. This has been essentially a <i>de facto</i> mantra since the early 90s (when I was a wee lad) and it&#x27;s quite common to see people writing very long articles on why you shouldn&#x27;t use them[1]. They are magic, so should be avoided.<p>There&#x27;s a reason languages like C# or Go don&#x27;t have them, and you should take heed of the very smart people that designed these languages. Even in Rust, they are controversial[2] (the most obvious reason is that your IDE is worthless when macros are involved). Metaprogramming (i.e. macros) adds extreme complexity (in some cases, pre-runtime-Turing-completeness) with many footguns, including the classic, and very &quot;fun,&quot; double evaluation.<p><i>Here be dragons.</i><p>[1] <a href="https:&#x2F;&#x2F;www.linkedin.com&#x2F;pulse&#x2F;why-considered-bad-practice-use-macros-c-herbert-elwood-gilliland-iii" rel="nofollow">https:&#x2F;&#x2F;www.linkedin.com&#x2F;pulse&#x2F;why-considered-bad-practice-u...</a><p>[2] <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;taxfe3&#x2F;what_are_the_pros_and_cons_of_using_macros_in_rust&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;taxfe3&#x2F;what_are_the_p...</a></div><br/><div id="36121850" class="c"><input type="checkbox" id="c-36121850" checked=""/><div class="controls bullet"><span class="by">1322322441</span><span>|</span><a href="#36121379">parent</a><span>|</span><a href="#36121436">next</a><span>|</span><label class="collapse" for="c-36121850">[-]</label><label class="expand" for="c-36121850">[1 more]</label></div><br/><div class="children"><div class="content">C# _does_ have a macro system. See <a href="https:&#x2F;&#x2F;dotnetfiddle.net&#x2F;y3zFQ4" rel="nofollow">https:&#x2F;&#x2F;dotnetfiddle.net&#x2F;y3zFQ4</a> for example. This has a macro called Foo which, when calls, prints out the AST of the given expression. It could also manipulate part of the expression and evaluate it, if desired.</div><br/></div></div><div id="36121436" class="c"><input type="checkbox" id="c-36121436" checked=""/><div class="controls bullet"><span class="by">AmalgatedAmoeba</span><span>|</span><a href="#36121379">parent</a><span>|</span><a href="#36121850">prev</a><span>|</span><a href="#36121554">next</a><span>|</span><label class="collapse" for="c-36121436">[-]</label><label class="expand" for="c-36121436">[1 more]</label></div><br/><div class="children"><div class="content">As is usually the case, it depends. Macros for “reducing boilerplate” or other syntactic reasons are poorly justified. While the resulting code might look cleaner, it’s often much harder to decipher (JS “decorators” suffer from the same issue). Macros can be invaluable for trading compile time for runtime performance, compensating for missing language features, and general metaprogramming… in a compiled language. It’s beyond me why would anybody think that macros are a good fit for interpreted JS.</div><br/></div></div><div id="36121554" class="c"><input type="checkbox" id="c-36121554" checked=""/><div class="controls bullet"><span class="by">throw_m239339</span><span>|</span><a href="#36121379">parent</a><span>|</span><a href="#36121436">prev</a><span>|</span><label class="collapse" for="c-36121554">[-]</label><label class="expand" for="c-36121554">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s a reason languages like C# or Go don&#x27;t have them,<p>Go has a quasi macro system though (go generate)<p><a href="https:&#x2F;&#x2F;gradha.github.io&#x2F;articles&#x2F;2015&#x2F;01&#x2F;the-day-go-reinvented-macros.html" rel="nofollow">https:&#x2F;&#x2F;gradha.github.io&#x2F;articles&#x2F;2015&#x2F;01&#x2F;the-day-go-reinven...</a><p>I like the macro systems in Crystal and Haxe (reifed macros)<p><a href="https:&#x2F;&#x2F;haxe.org&#x2F;manual&#x2F;macro-reification-expression.html" rel="nofollow">https:&#x2F;&#x2F;haxe.org&#x2F;manual&#x2F;macro-reification-expression.html</a><p><a href="https:&#x2F;&#x2F;crystal-lang.org&#x2F;reference&#x2F;1.8&#x2F;syntax_and_semantics&#x2F;macros&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;crystal-lang.org&#x2F;reference&#x2F;1.8&#x2F;syntax_and_semantics&#x2F;...</a><p>I think C would have benefited from such system at the AST level instead of text substitution.<p>Javascript is dynamic enough there is absolutely no need for Macros.</div><br/></div></div></div></div></div></div></div></div></div></body></html>