<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729501267894" as="style"/><link rel="stylesheet" href="styles.css?v=1729501267894"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">How to do distributed locking (2016)</a> <span class="domain">(<a href="https://martin.kleppmann.com">martin.kleppmann.com</a>)</span></div><div class="subtext"><span>yusufaytas</span> | <span>94 comments</span></div><br/><div><div id="41897133" class="c"><input type="checkbox" id="c-41897133" checked=""/><div class="controls bullet"><span class="by">jojolatulipe</span><span>|</span><a href="#41895577">next</a><span>|</span><label class="collapse" for="c-41897133">[-]</label><label class="expand" for="c-41897133">[4 more]</label></div><br/><div class="children"><div class="content">At work we use Temporal and ended up using a dedicated workflow and signals to do distributed locking. Working well so far and the implementation is rather simple, relying on Temporal’s facilities to do the distributed parts of the lock.</div><br/><div id="41898031" class="c"><input type="checkbox" id="c-41898031" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#41897133">parent</a><span>|</span><a href="#41895577">next</a><span>|</span><label class="collapse" for="c-41898031">[-]</label><label class="expand" for="c-41898031">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m keen to use Temporal, but I&#x27;ve heard it can be flaky. In your experience has it worked well?</div><br/><div id="41898181" class="c"><input type="checkbox" id="c-41898181" checked=""/><div class="controls bullet"><span class="by">calmoo</span><span>|</span><a href="#41897133">root</a><span>|</span><a href="#41898031">parent</a><span>|</span><a href="#41895577">next</a><span>|</span><label class="collapse" for="c-41898181">[-]</label><label class="expand" for="c-41898181">[2 more]</label></div><br/><div class="children"><div class="content">Rock solid in my experience and kind of a game changer. I’m surprised it’s not more widespread in large orgs.</div><br/><div id="41898576" class="c"><input type="checkbox" id="c-41898576" checked=""/><div class="controls bullet"><span class="by">Icathian</span><span>|</span><a href="#41897133">root</a><span>|</span><a href="#41898181">parent</a><span>|</span><a href="#41895577">next</a><span>|</span><label class="collapse" for="c-41898576">[-]</label><label class="expand" for="c-41898576">[1 more]</label></div><br/><div class="children"><div class="content">We use it a ton at my shop for internal things like release rollouts.  Fairly big tech company, and same experience. It&#x27;s an excellent product.</div><br/></div></div></div></div></div></div></div></div><div id="41895577" class="c"><input type="checkbox" id="c-41895577" checked=""/><div class="controls bullet"><span class="by">eknkc</span><span>|</span><a href="#41897133">prev</a><span>|</span><a href="#41895138">next</a><span>|</span><label class="collapse" for="c-41895577">[-]</label><label class="expand" for="c-41895577">[7 more]</label></div><br/><div class="children"><div class="content">I tend to use postgresql for distributed locking. As in, even if the job is not db related, I start a transaction and obtain an advisory lock which stays locked until the transaction is released. Either by the app itself or due to a crash or something.<p>Felt pretty safe about it so far but I just realised I never check if the db connection is still ok. If this is a db related job and I need to touch the db, fine. Some query will fail on the connection and my job will fail anyway. Otherwise I might have already lost the lock and not aware of it.<p>Without fencing tokens, atomic ops and such, I guess one needs a two stage commit on everything for absolute correctness?</div><br/><div id="41895763" class="c"><input type="checkbox" id="c-41895763" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#41895577">parent</a><span>|</span><a href="#41899374">next</a><span>|</span><label class="collapse" for="c-41895763">[-]</label><label class="expand" for="c-41895763">[4 more]</label></div><br/><div class="children"><div class="content">One gotcha maybe with locks is they are connection specific AFAIK, and in most libraries you&#x27;re using a pool typically.  So you need to have a specific connection for locks, and ensure you&#x27;re using that connection when doing periodic lock tests.</div><br/><div id="41901248" class="c"><input type="checkbox" id="c-41901248" checked=""/><div class="controls bullet"><span class="by">skrause</span><span>|</span><a href="#41895577">root</a><span>|</span><a href="#41895763">parent</a><span>|</span><a href="#41899383">next</a><span>|</span><label class="collapse" for="c-41901248">[-]</label><label class="expand" for="c-41901248">[1 more]</label></div><br/><div class="children"><div class="content">PostgreSQL has pg_advisory_xact_lock which releases the lock automatically when the transaction is over.</div><br/></div></div><div id="41899383" class="c"><input type="checkbox" id="c-41899383" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#41895577">root</a><span>|</span><a href="#41895763">parent</a><span>|</span><a href="#41901248">prev</a><span>|</span><a href="#41899374">next</a><span>|</span><label class="collapse" for="c-41899383">[-]</label><label class="expand" for="c-41899383">[2 more]</label></div><br/><div class="children"><div class="content">Why would locks be connection-specific? ... considering that only one operation can be in flight at a time on a single connection. (Usually, at least.)</div><br/><div id="41899585" class="c"><input type="checkbox" id="c-41899585" checked=""/><div class="controls bullet"><span class="by">joatmon-snoo</span><span>|</span><a href="#41895577">root</a><span>|</span><a href="#41899383">parent</a><span>|</span><a href="#41899374">next</a><span>|</span><label class="collapse" for="c-41899585">[-]</label><label class="expand" for="c-41899585">[1 more]</label></div><br/><div class="children"><div class="content">Different DBs implement locks differently.<p>Postgres allows obtaining advisory locks at either the session _or_ transaction level. If it&#x27;s session-level, then you have, ergo, a connection-level lock.<p><a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;explicit-locking.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;explicit-locking.htm...</a></div><br/></div></div></div></div></div></div><div id="41899374" class="c"><input type="checkbox" id="c-41899374" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#41895577">parent</a><span>|</span><a href="#41895763">prev</a><span>|</span><a href="#41895138">next</a><span>|</span><label class="collapse" for="c-41899374">[-]</label><label class="expand" for="c-41899374">[2 more]</label></div><br/><div class="children"><div class="content">Advisory locks have many pitfalls, see [0].<p>AFAIK the only correct way to do what you probably thought you were doing is &quot;EXCLUSIVE&quot; or &quot;ACCESS EXCLUSIVE&quot;... or two-phase commit or idempotency for the operations you&#x27;re doing.<p>[0] <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;explicit-locking.html#LOCKING-TABLES" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;explicit-locking.htm...</a></div><br/><div id="41901268" class="c"><input type="checkbox" id="c-41901268" checked=""/><div class="controls bullet"><span class="by">skrause</span><span>|</span><a href="#41895577">root</a><span>|</span><a href="#41899374">parent</a><span>|</span><a href="#41895138">next</a><span>|</span><label class="collapse" for="c-41901268">[-]</label><label class="expand" for="c-41901268">[1 more]</label></div><br/><div class="children"><div class="content">You link to table level locks which are different from advisory locks: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;explicit-locking.html#ADVISORY-LOCKS" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;explicit-locking.htm...</a><p>Are you sure that you&#x27;re talking about the same locks? What are the pitfalls exactly?</div><br/></div></div></div></div></div></div><div id="41895138" class="c"><input type="checkbox" id="c-41895138" checked=""/><div class="controls bullet"><span class="by">antirez</span><span>|</span><a href="#41895577">prev</a><span>|</span><a href="#41896223">next</a><span>|</span><label class="collapse" for="c-41895138">[-]</label><label class="expand" for="c-41895138">[9 more]</label></div><br/><div class="children"><div class="content">I suggest reading the comment I left back then in this blog post comments section, and the reply I wrote in my blog.<p>Btw, things to note in random order:<p>1. Check my comment under this blog post. The author had missed a <i>fundamental</i> point in how the algorithm works. Then he based the refusal of the algorithm on the remaining weaker points.<p>2. It is not true that you can&#x27;t wait an approximately correct amount of time, with modern computers an APIs. GC pauses are bound and monotonic clocks work. These are acceptable assumptions.<p>3. To critique the auto release mechanism in-se, because you don&#x27;t want to expose yourself to the fact that there is a potential race, is one thing. To critique the algorithm in front of its goals and its system model is another thing.<p>4. Over the years Redlock was used in a huge amount of use cases with success, because if you pick a timeout which is much larger than: A) the time to complete the task. B) the random pauses you can have in normal operating systems. Race conditions are very hard to trigger, and the other failures in the article were, AFAIK, never been observed. Of course if you have a super small timeout to auto release the lock, and the task may easily take this amount of time, you just committed a deisgn error, but that&#x27;s not about Redlock.</div><br/><div id="41895393" class="c"><input type="checkbox" id="c-41895393" checked=""/><div class="controls bullet"><span class="by">computerfan494</span><span>|</span><a href="#41895138">parent</a><span>|</span><a href="#41895296">next</a><span>|</span><label class="collapse" for="c-41895393">[-]</label><label class="expand" for="c-41895393">[6 more]</label></div><br/><div class="children"><div class="content">To be honest I&#x27;ve long been puzzled by your response blog post. Maybe the following question can help achieve common ground:<p>Would you use RedLock in a situation where the timeout is fairly short (1-2 seconds maybe), the work done usually takes ~90% of that timeout, and the work you do while holding a RedLock lock MUST NOT be done concurrently with another lock holder?<p>I think the correct answer here is always &quot;No&quot; because the risk of the lease sometimes expiring before the client has finished its work is very high. You must alter your work to be idempotent because RedLock cannot guarantee mutual exclusion under all circumstances. Optimistic locking is a good way to implement this type of thing while the work done is idempotent.</div><br/><div id="41895434" class="c"><input type="checkbox" id="c-41895434" checked=""/><div class="controls bullet"><span class="by">kgeist</span><span>|</span><a href="#41895138">root</a><span>|</span><a href="#41895393">parent</a><span>|</span><a href="#41895556">next</a><span>|</span><label class="collapse" for="c-41895434">[-]</label><label class="expand" for="c-41895434">[1 more]</label></div><br/><div class="children"><div class="content">&gt;because the risk of the lease sometimes expiring before the client has finished its work is very high<p>We had corrupted data bacause of  this.</div><br/></div></div><div id="41895556" class="c"><input type="checkbox" id="c-41895556" checked=""/><div class="controls bullet"><span class="by">antirez</span><span>|</span><a href="#41895138">root</a><span>|</span><a href="#41895393">parent</a><span>|</span><a href="#41895434">prev</a><span>|</span><a href="#41895296">next</a><span>|</span><label class="collapse" for="c-41895556">[-]</label><label class="expand" for="c-41895556">[4 more]</label></div><br/><div class="children"><div class="content">The timeout must be much larger than the time required to do the work. The point is that distributed locks without a release mechanism are in practical terms very problematic.<p>Btw, things to note in random order:<p>1. Check my comment under this blog post. The author had missed a <i>fundamental</i> point in how the algorithm works. Then he based the refusal of the algorithm on the remaining weaker points.<p>2. It is not true that you can&#x27;t wait an approximately correct amount of time, with modern computers an APIs. GC pauses are bound and monotonic clocks work. These are acceptable assumptions.<p>3. To critique the auto release mechanism in-se, because you don&#x27;t want to expose yourself to the fact that there is a potential race, is one thing. To critique the algorithm in front of its goals and its system model is another thing.<p>4. Over the years Redlock was used in a huge amount of use cases with success, because if you pick a timeout which is much larger than: A) the time to complete the task. B) the random pauses you can have in normal operating systems. Race conditions are very hard to trigger, and the other failures in the article were, AFAIK, never been observed. Of course if you have a super small timeout to auto release the lock, and the task may easily take this amount of time, you just committed a deisgn error, but that&#x27;s not about Redlock.</div><br/><div id="41895614" class="c"><input type="checkbox" id="c-41895614" checked=""/><div class="controls bullet"><span class="by">computerfan494</span><span>|</span><a href="#41895138">root</a><span>|</span><a href="#41895556">parent</a><span>|</span><a href="#41895296">next</a><span>|</span><label class="collapse" for="c-41895614">[-]</label><label class="expand" for="c-41895614">[3 more]</label></div><br/><div class="children"><div class="content">Locking without a timeout is indeed in the majority of use-cases a non-starter, we are agreed there.<p>The critical point that users must understand is that it is <i>impossible</i> to guarantee that the RedLock client never holds its lease longer than the timeout. Compounding this problem is that the longer you make your timeout to minimize the likelihood of this from accidentally happening, the less responsive your system becomes during genuine client misbehaviour.</div><br/><div id="41896193" class="c"><input type="checkbox" id="c-41896193" checked=""/><div class="controls bullet"><span class="by">antirez</span><span>|</span><a href="#41895138">root</a><span>|</span><a href="#41895614">parent</a><span>|</span><a href="#41895296">next</a><span>|</span><label class="collapse" for="c-41896193">[-]</label><label class="expand" for="c-41896193">[2 more]</label></div><br/><div class="children"><div class="content">In most real world scenarios, the tradeoffs are a bit softer than what people in the formal world dictates (and doing so they forced certain systems to become suboptimal for everything but during failures, kicking them out of business...). Few examples:<p>1. E-commerce system where there are a limited amount of items of the same kind, you don&#x27;t want to oversell.<p>2. Hotel booking system where we don&#x27;t want to reserve the same dates&#x2F;rooms multiple times.<p>3. Online medical appointments system.<p>In all those systems, to re-open the item&#x2F;date&#x2F;... after some time it&#x27;s ok, even after one day. And if the lock hold time is not too big, but a very strict compromise (it&#x27;s also a reasonable choice in the spectrum), and it could happen that during edge case failures three items are sold and there are two, orders can be cancelled.<p>So yes, there is a tension between timeout, race condition, recovery time, but in many systems using something like RedLock the development and end-user experience can be both improved with a high rate of success, and the random unhappy event can be handled. Now the algorithm is very old, still used by many implementations, and as we are talking problems are solved in a straightforward way with very good performances. Of course, the developers of the solution should be aware that there are tradeoffs between certain values: but when are distributed systems easy?<p>P.S. why 10 years of strong usage count, in the face of a blog post telling that you can&#x27;t trust a system like that? Because even if DS issues emerge randomly and sporadically, in the long run systems that create real-world issues, if they reach mass usage, are known. A big enough user base is a continuous integration test big enough to detect when a solution has real world serious issues. So of course RedLock users picking short timeouts with tasks that take a very hard to predict amount of time, will indeed incur into <i>knonw</i> issues. But the other systemic failure modes described in the blog post are never mentioned by users AFAIK.</div><br/><div id="41896517" class="c"><input type="checkbox" id="c-41896517" checked=""/><div class="controls bullet"><span class="by">computerfan494</span><span>|</span><a href="#41895138">root</a><span>|</span><a href="#41896193">parent</a><span>|</span><a href="#41895296">next</a><span>|</span><label class="collapse" for="c-41896517">[-]</label><label class="expand" for="c-41896517">[1 more]</label></div><br/><div class="children"><div class="content">I feel like you&#x27;re dancing around admitting the core issue that Martin points out - RedLock is <i>not</i> suitable for systems where correctness is paramount. It can get close, but it is not robust in all cases.<p>If you want to say &quot;RedLock is correct a very high percentage of the time when lease timeouts are tuned for the workload&quot;, I would agree with you actually. I even possibly agree with the statements &quot;most systems can tolerate unlikely correctness failures due to RedLock lease violations. Manual intervention is fine in those cases. RedLock may allow fast iteration times and is worth this cost&quot;. I just think it&#x27;s important to be crystal clear on the guarantees RedLock provides.<p>I first read Martin&#x27;s blog post and your response years ago when I worked at a company that was using RedLock despite it not being an appropriate tool. We had an outage caused by overlapping leases because the original implementor of the system didn&#x27;t understand what Martin has pointed out from the RedLock documentation alone.<p>I&#x27;ve been a happy Redis user and fan of your work outside of this poor experience with RedLock, by the way. I greatly appreciate the hard work that has gone into making it a fantastic database.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41895296" class="c"><input type="checkbox" id="c-41895296" checked=""/><div class="controls bullet"><span class="by">bluepizza</span><span>|</span><a href="#41895138">parent</a><span>|</span><a href="#41895393">prev</a><span>|</span><a href="#41896223">next</a><span>|</span><label class="collapse" for="c-41895296">[-]</label><label class="expand" for="c-41895296">[2 more]</label></div><br/><div class="children"><div class="content">Could you provide links?</div><br/><div id="41895413" class="c"><input type="checkbox" id="c-41895413" checked=""/><div class="controls bullet"><span class="by">saikatsg</span><span>|</span><a href="#41895138">root</a><span>|</span><a href="#41895296">parent</a><span>|</span><a href="#41896223">next</a><span>|</span><label class="collapse" for="c-41895413">[-]</label><label class="expand" for="c-41895413">[1 more]</label></div><br/><div class="children"><div class="content"><a href="http:&#x2F;&#x2F;antirez.com&#x2F;news&#x2F;101" rel="nofollow">http:&#x2F;&#x2F;antirez.com&#x2F;news&#x2F;101</a></div><br/></div></div></div></div></div></div><div id="41896223" class="c"><input type="checkbox" id="c-41896223" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#41895138">prev</a><span>|</span><a href="#41896851">next</a><span>|</span><label class="collapse" for="c-41896223">[-]</label><label class="expand" for="c-41896223">[2 more]</label></div><br/><div class="children"><div class="content">I am updating my low level and algo knowledge; what are good books about this (I have the one written by the author). I am looking to build something for fun, but everything is either a toy or very complicated.</div><br/><div id="41896260" class="c"><input type="checkbox" id="c-41896260" checked=""/><div class="controls bullet"><span class="by">cosmicradiance</span><span>|</span><a href="#41896223">parent</a><span>|</span><a href="#41896851">next</a><span>|</span><label class="collapse" for="c-41896260">[-]</label><label class="expand" for="c-41896260">[1 more]</label></div><br/><div class="children"><div class="content">System Design Interview I and II - Alex Xu. 
Take one of the topics and do it practically.</div><br/></div></div></div></div><div id="41896851" class="c"><input type="checkbox" id="c-41896851" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41896223">prev</a><span>|</span><a href="#41896205">next</a><span>|</span><label class="collapse" for="c-41896851">[-]</label><label class="expand" for="c-41896851">[17 more]</label></div><br/><div class="children"><div class="content">&gt; The lock has a timeout (i.e. it is a lease), which is always a good idea (otherwise a crashed client could end up holding a lock forever and never releasing it). However, if the GC pause lasts longer than the lease expiry period, and the client doesn’t realise that it has expired, it may go ahead and make some unsafe change.<p>Hold on, this sounds absurd to me:<p>First, if your client <i>crashes</i>, then you don&#x27;t need a timed lease on the lock to detect this in the first place. The lock would get released by the OS or supervisor, whether there are any timeouts or not. If both of <i>those</i> crash too, then the connection would eventually break, and the network system should then detect that (via network resets or timeouts, lack of heartbeats, etc.) and then invalidate all your connections before releasing any locks.<p>Second, if the problem becomes that your client is <i>buggy</i> and thus holds the lock <i>too long</i> without crashing, then shouldn&#x27;t some kind of supervisor detect that and then kill the client (e.g., by the OS terminating the process) before releasing the lock for everybody else?<p>Third, if you <i>are</i> going to have locks with timeouts to deal with corner cases you can&#x27;t handle like the above, shouldn&#x27;t they notify the actual program somehow (e.g., by throwing an exception, raising a signal, terminating it, etc.) instead of letting it happily continue execution? And shouldn&#x27;t those cases wait for some kind of verification that the program was notified before releasing the lock?<p>The whole notion that timeouts should somehow permit the program execution to continue ordinary control flow sounds like the root cause of the problem, and nobody is even batting an eye at it? Is there an obvious reason why this makes sense? I feel I must be missing something here... what am I missing?</div><br/><div id="41897034" class="c"><input type="checkbox" id="c-41897034" checked=""/><div class="controls bullet"><span class="by">winwang</span><span>|</span><a href="#41896851">parent</a><span>|</span><a href="#41897032">next</a><span>|</span><label class="collapse" for="c-41897034">[-]</label><label class="expand" for="c-41897034">[12 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t a mutex, but the distributed equivalent of one. The storage service is the one who invalidates the lock on their side. The client won&#x27;t detect its own issues without additional guarantees not given (supposedly) by Redlock.</div><br/><div id="41897136" class="c"><input type="checkbox" id="c-41897136" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41896851">root</a><span>|</span><a href="#41897034">parent</a><span>|</span><a href="#41897096">next</a><span>|</span><label class="collapse" for="c-41897136">[-]</label><label class="expand" for="c-41897136">[10 more]</label></div><br/><div class="children"><div class="content">I understand that. What I&#x27;m hung up on is, why does the storage system feel it is at liberty to just invalidate a lock and thus let someone else reacquire it without <i>any</i> sort of acknowledgment (either from the owner or from the communication systems connecting the owner to the outside world) that the owner will no longer rely on it? It just seems fundamentally wrong. The lock service just... doesn&#x27;t have that liberty, as I see it.</div><br/><div id="41897225" class="c"><input type="checkbox" id="c-41897225" checked=""/><div class="controls bullet"><span class="by">winwang</span><span>|</span><a href="#41896851">root</a><span>|</span><a href="#41897136">parent</a><span>|</span><a href="#41897096">next</a><span>|</span><label class="collapse" for="c-41897225">[-]</label><label class="expand" for="c-41897225">[9 more]</label></div><br/><div class="children"><div class="content">What if the rack goes down? But I think the author is saying a similar thing to you. The fenced token is essentially asserting that the client will no longer rely on the lock, even if it tries to. The difference is the service doesn&#x27;t need any acknowledgement, no permission needed to simlly deny the client later.</div><br/><div id="41897377" class="c"><input type="checkbox" id="c-41897377" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41896851">root</a><span>|</span><a href="#41897225">parent</a><span>|</span><a href="#41897096">next</a><span>|</span><label class="collapse" for="c-41897377">[-]</label><label class="expand" for="c-41897377">[8 more]</label></div><br/><div class="children"><div class="content">To be clear, my objection is to the premise, not to the offered solution.<p>To your question, could you clarify what exactly you mean by the rack &quot;going down&quot;? This encompasses a lot of different scenarios, I&#x27;m not sure which one you&#x27;re asking about. The obvious interpretation would break all the connections the program has to the outside world, thus preventing the problem by construction.</div><br/><div id="41897707" class="c"><input type="checkbox" id="c-41897707" checked=""/><div class="controls bullet"><span class="by">winwang</span><span>|</span><a href="#41896851">root</a><span>|</span><a href="#41897377">parent</a><span>|</span><a href="#41898935">next</a><span>|</span><label class="collapse" for="c-41897707">[-]</label><label class="expand" for="c-41897707">[6 more]</label></div><br/><div class="children"><div class="content">The rack could go down from the point of view of the storage service, but the machine&#x2F;VM itself could be perfectly fine.</div><br/><div id="41898443" class="c"><input type="checkbox" id="c-41898443" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41896851">root</a><span>|</span><a href="#41897707">parent</a><span>|</span><a href="#41898935">next</a><span>|</span><label class="collapse" for="c-41898443">[-]</label><label class="expand" for="c-41898443">[5 more]</label></div><br/><div class="children"><div class="content">In that scenario the machine would become aware that it can&#x27;t reach the storage service either, no? In which case the host can terminate the program, or the network can break all the connections between them, or whatever. By default I would think that the lease shouldn&#x27;t be broken until the network partition gets resolved, but I think the storage system <i>could</i> have a timeout for breaking the lease in that scenario if you really want, but then it would come with a time-based guarantee that the program isn&#x27;t running anymore, no?</div><br/><div id="41898912" class="c"><input type="checkbox" id="c-41898912" checked=""/><div class="controls bullet"><span class="by">winwang</span><span>|</span><a href="#41896851">root</a><span>|</span><a href="#41898443">parent</a><span>|</span><a href="#41898935">next</a><span>|</span><label class="collapse" for="c-41898912">[-]</label><label class="expand" for="c-41898912">[4 more]</label></div><br/><div class="children"><div class="content">Everything you&#x27;re saying is plausibly possible in the absurdly large search space of all possible scenarios. The author&#x27;s premise, however, is rooted in the specific scenario they lay out, with historical supporting examples which you can look into. Even then, the premise before all that was essentially: Redlock does not do what people might expect of a distributed lock. Btw I do have responses to your questions, but often times in these sorts of discussions, I find that there can always be an objection to an objection to ... etc. The &quot;sense&quot; (or flavor) in this case is that &quot;we are taking a complex topic too lightly&quot;. In fact, I should probably continue reading the author&#x27;s book (DDIA) at some point...</div><br/><div id="41899355" class="c"><input type="checkbox" id="c-41899355" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41896851">root</a><span>|</span><a href="#41898912">parent</a><span>|</span><a href="#41898935">next</a><span>|</span><label class="collapse" for="c-41899355">[-]</label><label class="expand" for="c-41899355">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The &quot;sense&quot; (or flavor) in this case is that &quot;we are taking a complex topic too lightly&quot;.<p>I get that -- and honestly, I&#x27;m not expecting a treatise on distributed consensus here. But what took me aback was that the blog post didn&#x27;t even <i>attempt</i> to mention anything about the fact that the premise (at first glance) looks glaringly broken. If he&#x27;d even said 1 single sentence like &quot;it&#x27;s {difficult&#x2F;infeasible&#x2F;impossible} to design a client that will never continue execution past a timeout&quot;, it&#x27;d have been fine, and I would&#x27;ve happily moved along. But the way it is written right now, it reads a little bit like: &quot;we design a ticking time bomb that we can&#x27;t turn off; how can we make sure we don&#x27;t forget to reset the timer every time?&quot;... without bothering to say <i>anything</i> about why we should be digging ourselves into such a hole in the first place.</div><br/><div id="41900382" class="c"><input type="checkbox" id="c-41900382" checked=""/><div class="controls bullet"><span class="by">winwang</span><span>|</span><a href="#41896851">root</a><span>|</span><a href="#41899355">parent</a><span>|</span><a href="#41898935">next</a><span>|</span><label class="collapse" for="c-41900382">[-]</label><label class="expand" for="c-41900382">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, that makes sense now. I think, personally, I&#x27;ve simply seen that design around a bunch, but great on you to question it and call it out -- also plausible that my own headcanon doesn&#x27;t check out.</div><br/><div id="41900444" class="c"><input type="checkbox" id="c-41900444" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41896851">root</a><span>|</span><a href="#41900382">parent</a><span>|</span><a href="#41898935">next</a><span>|</span><label class="collapse" for="c-41900444">[-]</label><label class="expand" for="c-41900444">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, yeah. For what it&#x27;s worth, partly what led me to even leave this comment is that when he wrote &quot;the code above is broken&quot;, I stared at it, and for the life of me I couldn&#x27;t see why it was broken. Because, of course, the code was lying: there was no mention of leases or timeouts. Having a &quot;lease&quot; suddenly pulled out of nowhere really felt like a fast one being pulled on me (and really unfairly so!), hence I decided I&#x27;d actually leave the comment and question what the basis for this hidden time bomb even was in the first place?! If the code had said leaseLock(filename, timeout), I think the bug would&#x27;ve been glaringly obvious, and far fewer people would&#x27;ve been surprised by looking at the code.<p>Also for what it&#x27;s worth, I can <i>guess</i> what some of the answers might be. For example, it&#x27;s possible you&#x27;d need very precise timing facilities that aren&#x27;t always available, in order to be able to guarantee high throughput with correctness (like Google Spanner&#x27;s). Or it might be that doing so requires a trade-off between availability and partition-tolerance that in some applications isn&#x27;t justified. But I&#x27;m curious what the answer actually is, rather than just (semi-)random guesses as to what it could be.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41898935" class="c"><input type="checkbox" id="c-41898935" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#41896851">root</a><span>|</span><a href="#41897377">parent</a><span>|</span><a href="#41897707">prev</a><span>|</span><a href="#41897096">next</a><span>|</span><label class="collapse" for="c-41898935">[-]</label><label class="expand" for="c-41898935">[1 more]</label></div><br/><div class="children"><div class="content">The process that owns the lock is never heard from again.</div><br/></div></div></div></div></div></div></div></div><div id="41897096" class="c"><input type="checkbox" id="c-41897096" checked=""/><div class="controls bullet"><span class="by">neonbrain</span><span>|</span><a href="#41896851">root</a><span>|</span><a href="#41897034">parent</a><span>|</span><a href="#41897136">prev</a><span>|</span><a href="#41897032">next</a><span>|</span><label class="collapse" for="c-41897096">[-]</label><label class="expand" for="c-41897096">[1 more]</label></div><br/><div class="children"><div class="content">My understanding is that the dataflow user was talking about a notification which the server is supposed to receive from the OS in the case of a broken client connection. This notification is usually received, but cannot be guaranteed in a distributed environment.</div><br/></div></div></div></div><div id="41897032" class="c"><input type="checkbox" id="c-41897032" checked=""/><div class="controls bullet"><span class="by">neonbrain</span><span>|</span><a href="#41896851">parent</a><span>|</span><a href="#41897034">prev</a><span>|</span><a href="#41896205">next</a><span>|</span><label class="collapse" for="c-41897032">[-]</label><label class="expand" for="c-41897032">[4 more]</label></div><br/><div class="children"><div class="content">The assumption that your server will always receive RST or FIN from your client is incorrect. There are some cases when these packets are being dropped, and your server will stay with an open connection while the client on the remote machine is already dead.
P.S. BTW, it&#x27;s not me who downvoted you</div><br/><div id="41897097" class="c"><input type="checkbox" id="c-41897097" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41896851">root</a><span>|</span><a href="#41897032">parent</a><span>|</span><a href="#41896205">next</a><span>|</span><label class="collapse" for="c-41897097">[-]</label><label class="expand" for="c-41897097">[3 more]</label></div><br/><div class="children"><div class="content">I made no such assumption this will always happen though? That&#x27;s why the comment was so much longer than just &quot;isn&#x27;t TCP RST enough?&quot;... I listed a ton of ways to deal with this that didn&#x27;t involve letting the program continue happily on its path.</div><br/><div id="41898479" class="c"><input type="checkbox" id="c-41898479" checked=""/><div class="controls bullet"><span class="by">neonbrain</span><span>|</span><a href="#41896851">root</a><span>|</span><a href="#41897097">parent</a><span>|</span><a href="#41896205">next</a><span>|</span><label class="collapse" for="c-41898479">[-]</label><label class="expand" for="c-41898479">[2 more]</label></div><br/><div class="children"><div class="content">Sorry didn&#x27;t see your message.
What I mean is that if you are not getting RST&#x2F;FIN or any other indication for your closed communication channel, you only left to the mechanism of timeouts to recognize a partitioned&#x2F;dead&#x2F;slow worker client. Basically, you&#x27;ve mentioned them yourself (&quot;timeouts, lack of heartbeats, etc&quot; in your post are all forms of timeouts). So you can piggyback on these timeouts or use a smaller timeout configured in the lease, whatever suits your purpose, I guess.
This is what I believe Kleppmann referring here to. He&#x27;s just being generic in his description.</div><br/><div id="41898562" class="c"><input type="checkbox" id="c-41898562" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41896851">root</a><span>|</span><a href="#41898479">parent</a><span>|</span><a href="#41896205">next</a><span>|</span><label class="collapse" for="c-41898562">[-]</label><label class="expand" for="c-41898562">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What I mean is that if you are not getting RST&#x2F;FIN or any other indication for your closed communication channel, you only left to the mechanism of timeouts to recognize a partitioned&#x2F;dead&#x2F;slow worker client.<p>Timeouts were a red herring in my comment. My problem wasn&#x27;t with the mere existence of timeouts in corner cases, it was the fact that the worker is assumed to keep working merrily on, despite the timeouts. That&#x27;s what I don&#x27;t understand the justification for. If the worker is dead, then it&#x27;s a non-issue, and the lease can be broken. If the system is alive, the host can discover (via RST, heartbeats, or other timeouts) that the storage system is unreachable, and thus prevent the program from continuing execution -- and at that point the storage service can still break the lease (via a timeout), but it would actually come with a timing-based guarantee that the program will no longer continue execution.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41896205" class="c"><input type="checkbox" id="c-41896205" checked=""/><div class="controls bullet"><span class="by">egcodes</span><span>|</span><a href="#41896851">prev</a><span>|</span><a href="#41895978">next</a><span>|</span><label class="collapse" for="c-41896205">[-]</label><label class="expand" for="c-41896205">[1 more]</label></div><br/><div class="children"><div class="content">Once I wrote a dist. lock blog using this resource. Here it is: <a href="https:&#x2F;&#x2F;medium.com&#x2F;sahibinden-technology&#x2F;an-easy-integration-of-distributed-lock-4b19a704ce49" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;sahibinden-technology&#x2F;an-easy-integration...</a></div><br/></div></div><div id="41895978" class="c"><input type="checkbox" id="c-41895978" checked=""/><div class="controls bullet"><span class="by">hoppp</span><span>|</span><a href="#41896205">prev</a><span>|</span><a href="#41895613">next</a><span>|</span><label class="collapse" for="c-41895978">[-]</label><label class="expand" for="c-41895978">[1 more]</label></div><br/><div class="children"><div class="content">I did distributed locking with Deno, and Deno KV hosted by Deno Deploy.<p>Its using foundationdb, a distributed db. 
The deno instances running on local devices all connect to the same Deno KV to acquire the lock.<p>But using postgres, a select for update also works, the database is not distributed tho.</div><br/></div></div><div id="41895613" class="c"><input type="checkbox" id="c-41895613" checked=""/><div class="controls bullet"><span class="by">jroseattle</span><span>|</span><a href="#41895978">prev</a><span>|</span><a href="#41894762">next</a><span>|</span><label class="collapse" for="c-41895613">[-]</label><label class="expand" for="c-41895613">[19 more]</label></div><br/><div class="children"><div class="content">We reviewed Redis back in 2018 as a potential solution for our use case. In the end, we opted for a less sexy solution (not Redis) that never failed us, no joke.<p>Our use case: handing out a ticket (something with an identifier) from a finite set of tickets from a campaign. It&#x27;s something akin to Ticketmaster allocating seats in a venue for a concert. Our operation was as you might expect: provide a ticket to a request if one is available, assign some metadata from the request to the allocated ticket, and remove it from consideration for future client requests.<p>We had failed campaigns in the past (over-allocation, under-allocation, duplicate allocation, etc.) so our concern was accuracy. Clients would connect and request a ticket; we wanted to exclusively distribute only the set of tickets available from the pool. If the number of client requests exceeded the number of tickets, the system should protect for that.<p>We tried Redis, including the naive implementation of getting the lock, checking the lock, doing our thing, releasing the lock. It was ok, but administrative overhead was a lot for us at the time. I&#x27;m glad we didn&#x27;t go that route, though.<p>We ultimately settled on...Postgres. Our &quot;distributed lock&quot; was just a composite UPDATE statement using some Postgres-specific features. We effectively turned requests into a SET operation, where the database would return either a record that indicated the request was successful, or something that indicated it failed. ACID transactions for the win!<p>With accuracy solved, we next looked at scale&#x2F;performance. We didn&#x27;t need to support millions of requests&#x2F;sec, but we did have some spikiness thresholds. We were able to optimize read&#x2F;write db instances within our cluster, and strategically load larger&#x2F;higher-demand campaigns to allocated systems. We continued to improve on optimization over two years, but not once did we ever have a campaign with ticket distribution failures.<p>Note: I am not an expert of any kind in distributed-lock technology. I&#x27;m just someone who did their homework, focused on the problem to be solved, and found a solution after trying a few things.</div><br/><div id="41895829" class="c"><input type="checkbox" id="c-41895829" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#41895613">parent</a><span>|</span><a href="#41895977">next</a><span>|</span><label class="collapse" for="c-41895829">[-]</label><label class="expand" for="c-41895829">[5 more]</label></div><br/><div class="children"><div class="content">You are right that anything that needs up to 50000 atomic, short-lived transactions per second can just use Postgres.<p>Your UPDATE transaction lasts just a few microseconds, so you can just centralise the problem and that&#x27;s good because it&#x27;s simpler, faster and safer.<p>But this is not a _distributed_ problem, as the article explains:<p>&gt; remember that a lock in a distributed system is not like a mutex in a multi-threaded application. It’s a more complicated beast, due to the problem that different nodes and the network can all fail independently in various ways<p>You need distributed locking if the transactions can take seconds or hours, and the machines involved can fail while they hold the lock.</div><br/><div id="41900138" class="c"><input type="checkbox" id="c-41900138" checked=""/><div class="controls bullet"><span class="by">jroseattle</span><span>|</span><a href="#41895613">root</a><span>|</span><a href="#41895829">parent</a><span>|</span><a href="#41897501">next</a><span>|</span><label class="collapse" for="c-41900138">[-]</label><label class="expand" for="c-41900138">[2 more]</label></div><br/><div class="children"><div class="content">&gt; up to 50000 atomic, short-lived transactions per second<p>50000?<p>&gt; You need distributed locking if the transactions can take seconds or hours, and the machines involved can fail while they hold the lock.
From my experience, locks are needed to ensure synchronized access to resources. Distributed locks are a form of that isolation being held across computing processes, as opposed to the mutex example provided.<p>And while our implementation definitively did not use a distributed lock, we could still see those machines fail.<p>I fail to understand why a distributed lock is needed for anything due to it&#x27;s duration.</div><br/><div id="41901116" class="c"><input type="checkbox" id="c-41901116" checked=""/><div class="controls bullet"><span class="by">throwawaythekey</span><span>|</span><a href="#41895613">root</a><span>|</span><a href="#41900138">parent</a><span>|</span><a href="#41897501">next</a><span>|</span><label class="collapse" for="c-41901116">[-]</label><label class="expand" for="c-41901116">[1 more]</label></div><br/><div class="children"><div class="content">Mostly guessing but -&gt; duration is usually inversely correlated with throughput.<p>If you require high throughput and have a high duration then partitioning&#x2F;distribution are the normal solution.</div><br/></div></div></div></div><div id="41897501" class="c"><input type="checkbox" id="c-41897501" checked=""/><div class="controls bullet"><span class="by">fny</span><span>|</span><a href="#41895613">root</a><span>|</span><a href="#41895829">parent</a><span>|</span><a href="#41900138">prev</a><span>|</span><a href="#41895977">next</a><span>|</span><label class="collapse" for="c-41897501">[-]</label><label class="expand" for="c-41897501">[2 more]</label></div><br/><div class="children"><div class="content">You could just have multiple clients attempt to update a row that defines the lock. Postgres transactions have no limit and will unwind on client failure. Since connections are persistent, there’s no need to play a game to determine the state of a client.</div><br/><div id="41897724" class="c"><input type="checkbox" id="c-41897724" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#41895613">root</a><span>|</span><a href="#41897501">parent</a><span>|</span><a href="#41895977">next</a><span>|</span><label class="collapse" for="c-41897724">[-]</label><label class="expand" for="c-41897724">[1 more]</label></div><br/><div class="children"><div class="content">Your scenario still uses a centralised single postgres server. Failure of that server takes down the whole locking functionality. That&#x27;s not what people usually mean by &quot;distributed&quot;.<p>&quot;the machines involved can fail&quot; must also include the postgres machines.<p>To get that, you need to coordinate multiple postgres servers, e.g. using ... distributed locking. Postgres does not provide that out of the box -- neither multi-master setups, nor master-standby synchronous replication with automatic failover. Wrapper software that provides that, such as Stolon and Patroni, use distributed KV stores &#x2F; lock managers such as etcd and Consul to provide it.</div><br/></div></div></div></div></div></div><div id="41895977" class="c"><input type="checkbox" id="c-41895977" checked=""/><div class="controls bullet"><span class="by">stickfigure</span><span>|</span><a href="#41895613">parent</a><span>|</span><a href="#41895829">prev</a><span>|</span><a href="#41896180">next</a><span>|</span><label class="collapse" for="c-41895977">[-]</label><label class="expand" for="c-41895977">[2 more]</label></div><br/><div class="children"><div class="content">I think this illustrates something important, which is that: You don&#x27;t need <i>locking</i>. You need <i>&lt;some high-level business constraint that might or might not require some form of locking&gt;</i>.<p>In your case, the constraint is &quot;don&#x27;t sell more than N tickets&quot;. For most realistic traffic volumes for that kind of problem, you can solve it with traditional rdbms transactional behavior and let it manage whatever locking it uses internally.<p>I wish developers were a lot slower to reach for &quot;I&#x27;ll build distributed locks&quot;. There&#x27;s almost always a better answer, but it&#x27;s specific to each application.</div><br/><div id="41900150" class="c"><input type="checkbox" id="c-41900150" checked=""/><div class="controls bullet"><span class="by">jroseattle</span><span>|</span><a href="#41895613">root</a><span>|</span><a href="#41895977">parent</a><span>|</span><a href="#41896180">next</a><span>|</span><label class="collapse" for="c-41900150">[-]</label><label class="expand" for="c-41900150">[1 more]</label></div><br/><div class="children"><div class="content">This is exactly how we arrived at our solution. We needed to satisfy the constraint; locking was one means of addressing the constraint.<p>Maybe we were lucky in our implementation, but a key factor for our decision was understanding how to manage the systems in our environment. We would have skilled up with Redis, but we felt our Postgres solution would be a good first step. We just haven&#x27;t had a need to go to a second step yet.</div><br/></div></div></div></div><div id="41896180" class="c"><input type="checkbox" id="c-41896180" checked=""/><div class="controls bullet"><span class="by">nasretdinov</span><span>|</span><a href="#41895613">parent</a><span>|</span><a href="#41895977">prev</a><span>|</span><a href="#41895681">next</a><span>|</span><label class="collapse" for="c-41896180">[-]</label><label class="expand" for="c-41896180">[3 more]</label></div><br/><div class="children"><div class="content">So basically your answer (and the correct answer most of the time) was that you don&#x27;t really need distributed locks even if you think you do :)</div><br/><div id="41897311" class="c"><input type="checkbox" id="c-41897311" checked=""/><div class="controls bullet"><span class="by">tonyarkles</span><span>|</span><a href="#41895613">root</a><span>|</span><a href="#41896180">parent</a><span>|</span><a href="#41895681">next</a><span>|</span><label class="collapse" for="c-41897311">[-]</label><label class="expand" for="c-41897311">[2 more]</label></div><br/><div class="children"><div class="content">Heh, in my local developer community I have a bit of a reputation for being “the guy” to talk to about distributed systems. I’d done a bunch of work in the early days of the horizontal-scaling movement (vs just buying bigger servers) and did an M.Sc focused on distributed systems performance.<p>Whenever anyone would come and ask for help with a planned distributed system the first question I would always ask is: does this system actually need to be distributed?! In my 15 years of consulting I think the answer was only actually “yes” 2 or 3 times. Much more often than was helping them solve the performance problems in their single server system; without doing that they would usually just have ended up with a slow complex distributed system.<p>Edit: lol this paper was not popular in the Distributed Systems Group at my school: <a href="https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;conference&#x2F;hotos15&#x2F;hotos15-paper-mcsherry.pdf" rel="nofollow">https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;conference&#x2F;hotos15&#x2F;hotos...</a><p>“You can have a second computer once you’ve shown you know how to use the first one.”</div><br/><div id="41898616" class="c"><input type="checkbox" id="c-41898616" checked=""/><div class="controls bullet"><span class="by">Agingcoder</span><span>|</span><a href="#41895613">root</a><span>|</span><a href="#41897311">parent</a><span>|</span><a href="#41895681">next</a><span>|</span><label class="collapse" for="c-41898616">[-]</label><label class="expand" for="c-41898616">[1 more]</label></div><br/><div class="children"><div class="content">I wanted to post the same paper. With Adrian Colyer’s explanations:
<a href="https:&#x2F;&#x2F;blog.acolyer.org&#x2F;2015&#x2F;06&#x2F;05&#x2F;scalability-but-at-what-cost&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.acolyer.org&#x2F;2015&#x2F;06&#x2F;05&#x2F;scalability-but-at-what-...</a></div><br/></div></div></div></div></div></div><div id="41895681" class="c"><input type="checkbox" id="c-41895681" checked=""/><div class="controls bullet"><span class="by">wwarner</span><span>|</span><a href="#41895613">parent</a><span>|</span><a href="#41896180">prev</a><span>|</span><a href="#41896833">next</a><span>|</span><label class="collapse" for="c-41895681">[-]</label><label class="expand" for="c-41895681">[4 more]</label></div><br/><div class="children"><div class="content">This is the best way, and actually the only sensible way to approach the problem. I first read about it here <a href="https:&#x2F;&#x2F;code.flickr.net&#x2F;2010&#x2F;02&#x2F;08&#x2F;ticket-servers-distributed-unique-primary-keys-on-the-cheap&#x2F;" rel="nofollow">https:&#x2F;&#x2F;code.flickr.net&#x2F;2010&#x2F;02&#x2F;08&#x2F;ticket-servers-distribute...</a></div><br/><div id="41895868" class="c"><input type="checkbox" id="c-41895868" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#41895613">root</a><span>|</span><a href="#41895681">parent</a><span>|</span><a href="#41896833">next</a><span>|</span><label class="collapse" for="c-41895868">[-]</label><label class="expand" for="c-41895868">[3 more]</label></div><br/><div class="children"><div class="content">&gt; only sensible way<p>That&#x27;s a bit strong. Like most of engineering, it depends. Postgres is a good solution if you only have maybe 100k QPS, the locks are logically (if not necessarily fully physically) partially independent, and they aren&#x27;t held for long. Break any of those constraints, or add anything weird (inefficient postgres clients, high DB load, ...), and you start having to explore either removing those seeming constraints or using other solutions.</div><br/><div id="41895896" class="c"><input type="checkbox" id="c-41895896" checked=""/><div class="controls bullet"><span class="by">wwarner</span><span>|</span><a href="#41895613">root</a><span>|</span><a href="#41895868">parent</a><span>|</span><a href="#41896833">next</a><span>|</span><label class="collapse" for="c-41895896">[-]</label><label class="expand" for="c-41895896">[2 more]</label></div><br/><div class="children"><div class="content">Ok fair; I&#x27;m not really talking about postgres (the link i shared uses mysql). I&#x27;m saying that creating a ticket server that just issues and persists unique tokens, is a way to provide coordination between loosely coupled applications.</div><br/><div id="41896096" class="c"><input type="checkbox" id="c-41896096" checked=""/><div class="controls bullet"><span class="by">zbobet2012</span><span>|</span><a href="#41895613">root</a><span>|</span><a href="#41895896">parent</a><span>|</span><a href="#41896833">next</a><span>|</span><label class="collapse" for="c-41896096">[-]</label><label class="expand" for="c-41896096">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that&#x27;s cookies. They are great.</div><br/></div></div></div></div></div></div></div></div><div id="41896833" class="c"><input type="checkbox" id="c-41896833" checked=""/><div class="controls bullet"><span class="by">etcd</span><span>|</span><a href="#41895613">parent</a><span>|</span><a href="#41895681">prev</a><span>|</span><a href="#41897029">next</a><span>|</span><label class="collapse" for="c-41896833">[-]</label><label class="expand" for="c-41896833">[1 more]</label></div><br/><div class="children"><div class="content">I guess this is embarassingly parralelizable in that you can shard by concert to different instances. Might even be a job for that newfangled cloudflare sqlite thing.</div><br/></div></div><div id="41897029" class="c"><input type="checkbox" id="c-41897029" checked=""/><div class="controls bullet"><span class="by">OnlyMortal</span><span>|</span><a href="#41895613">parent</a><span>|</span><a href="#41896833">prev</a><span>|</span><a href="#41896281">next</a><span>|</span><label class="collapse" for="c-41897029">[-]</label><label class="expand" for="c-41897029">[1 more]</label></div><br/><div class="children"><div class="content">Interesting. We went through a similar process and ended up with Yugabyte to deal with the locks (cluster).<p>It’s based on Postgres but performance was not good enough.<p>We’re now moving to RDMA.</div><br/></div></div><div id="41896281" class="c"><input type="checkbox" id="c-41896281" checked=""/><div class="controls bullet"><span class="by">apwell23</span><span>|</span><a href="#41895613">parent</a><span>|</span><a href="#41897029">prev</a><span>|</span><a href="#41897993">next</a><span>|</span><label class="collapse" for="c-41896281">[-]</label><label class="expand" for="c-41896281">[1 more]</label></div><br/><div class="children"><div class="content">Classic tech interview question</div><br/></div></div></div></div><div id="41894762" class="c"><input type="checkbox" id="c-41894762" checked=""/><div class="controls bullet"><span class="by">galeaspablo</span><span>|</span><a href="#41895613">prev</a><span>|</span><a href="#41895002">next</a><span>|</span><label class="collapse" for="c-41894762">[-]</label><label class="expand" for="c-41894762">[11 more]</label></div><br/><div class="children"><div class="content">Many engineers don’t truly care about the correctness issue, until it’s too late. Similar to security.<p>Or they care but don’t bother checking whether what they’re doing is correct.<p>For example, in my field, where microservices&#x2F;actors&#x2F;processes pass messages between each other over a network, I dare say &gt;95% of implementations I see have edge cases where messages might be lost or processed out of order.<p>But there isn’t an alignment of incentives that fixes this problem. Ie the payment structures for executives and engineers aren’t aligned with the best outcome for customers and shareholders.</div><br/><div id="41895586" class="c"><input type="checkbox" id="c-41895586" checked=""/><div class="controls bullet"><span class="by">noprocrasted</span><span>|</span><a href="#41894762">parent</a><span>|</span><a href="#41895051">next</a><span>|</span><label class="collapse" for="c-41895586">[-]</label><label class="expand" for="c-41895586">[4 more]</label></div><br/><div class="children"><div class="content">&gt; there isn’t an alignment of incentives that fixes this problem<p>&quot;Microservices&quot; itself is often a symptom of this problem.<p>Everyone and their dog wants to introduce a network boundary in between function calls for no good reason just so they can subsequently have endless busywork writing HTTP (or gRPC if you&#x27;re lucky) servers, clients &amp; JSON (de?)serializers for said function calls and try to reimplement things like distributed transactions across said network boundary and dealing with the inevitable &quot;spooky action at a distance&quot; that this will yield.</div><br/><div id="41896593" class="c"><input type="checkbox" id="c-41896593" checked=""/><div class="controls bullet"><span class="by">sethammons</span><span>|</span><a href="#41894762">root</a><span>|</span><a href="#41895586">parent</a><span>|</span><a href="#41897331">next</a><span>|</span><label class="collapse" for="c-41896593">[-]</label><label class="expand" for="c-41896593">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked with microservices at scale and it was fantastic. We couldn&#x27;t break backwards compatibility with our API without a lot of coordination. Outside of that, you could deploy as frequently as needed and other services could update as needed to make use of new features.<p>The monoliths I have worked in, very contrastingly, have had issues coordinating changes within the codebases, code crosses boundaries it should not and datastores get shared and coupled to (what should be) different domains leading to slow, inefficient code and ossified options for product changes.</div><br/></div></div><div id="41897331" class="c"><input type="checkbox" id="c-41897331" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#41894762">root</a><span>|</span><a href="#41895586">parent</a><span>|</span><a href="#41896593">prev</a><span>|</span><a href="#41895051">next</a><span>|</span><label class="collapse" for="c-41897331">[-]</label><label class="expand" for="c-41897331">[2 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re hand-writing clients&#x2F;servers&#x2F;serializers instead of generating them from schema definitions then you have more fundamental issues than using microservices.</div><br/><div id="41899665" class="c"><input type="checkbox" id="c-41899665" checked=""/><div class="controls bullet"><span class="by">sethammons</span><span>|</span><a href="#41894762">root</a><span>|</span><a href="#41897331">parent</a><span>|</span><a href="#41895051">next</a><span>|</span><label class="collapse" for="c-41899665">[-]</label><label class="expand" for="c-41899665">[1 more]</label></div><br/><div class="children"><div class="content">We hand wrote clients at my last microservice based gig. It was marginally slower than automated clients and we did run into a few cases of teams &quot;waisting&quot; their time writing their own clients; that was fixed by the authoring service team also authoring clients. It wasn&#x27;t a big issue</div><br/></div></div></div></div></div></div><div id="41895051" class="c"><input type="checkbox" id="c-41895051" checked=""/><div class="controls bullet"><span class="by">sethammons</span><span>|</span><a href="#41894762">parent</a><span>|</span><a href="#41895586">prev</a><span>|</span><a href="#41894888">next</a><span>|</span><label class="collapse" for="c-41895051">[-]</label><label class="expand" for="c-41895051">[2 more]</label></div><br/><div class="children"><div class="content">The path to fixing this requires first measuring and monitoring it, then establishing service level objectives that represent customer experience. Product and engineering teams have to agree on them. If the SLOs become violated, focus shifts towards system stability.<p>Getting everyone onboard is hard and that is why good leadership is needed. When customers start to churn because bugs pop up and new features are slow or non existent, then the case is very easy to make quality part of the process. Mature leaders get ahead of that as early as possible.</div><br/><div id="41895102" class="c"><input type="checkbox" id="c-41895102" checked=""/><div class="controls bullet"><span class="by">galeaspablo</span><span>|</span><a href="#41894762">root</a><span>|</span><a href="#41895051">parent</a><span>|</span><a href="#41894888">next</a><span>|</span><label class="collapse" for="c-41895102">[-]</label><label class="expand" for="c-41895102">[1 more]</label></div><br/><div class="children"><div class="content">Good leadership is spot on! Agreed. The cynic part of me sees incentives that discourage mature leadership styles.<p>Leaders tend to be impatient and think of this quarter’s OKRs as opposed to the business’ long term financial health. In other word the leaders of leaders use standard MBA prescribed incentive structures.</div><br/></div></div></div></div><div id="41894888" class="c"><input type="checkbox" id="c-41894888" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41894762">parent</a><span>|</span><a href="#41895051">prev</a><span>|</span><a href="#41895407">next</a><span>|</span><label class="collapse" for="c-41894888">[-]</label><label class="expand" for="c-41894888">[1 more]</label></div><br/><div class="children"><div class="content">I think there&#x27;s a bit of an alignment of incentives: the edge cases are tricky enough that your programmers probably need to handle a lot of support tickets, which isn&#x27;t good for anyone.<p>But I don&#x27;t see anyway to convince yesterday&#x27;s managers to give us time to build it right.</div><br/></div></div><div id="41895407" class="c"><input type="checkbox" id="c-41895407" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#41894762">parent</a><span>|</span><a href="#41894888">prev</a><span>|</span><a href="#41897997">next</a><span>|</span><label class="collapse" for="c-41895407">[-]</label><label class="expand" for="c-41895407">[2 more]</label></div><br/><div class="children"><div class="content">&gt; 95% of implementations I see have edge cases where messages might be lost or processed out of order.<p>Eek. This sort of thing can end up with innocent people in jail, or dead.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;British_Post_Office_scandal" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;British_Post_Office_scandal</a></div><br/><div id="41895622" class="c"><input type="checkbox" id="c-41895622" checked=""/><div class="controls bullet"><span class="by">noprocrasted</span><span>|</span><a href="#41894762">root</a><span>|</span><a href="#41895407">parent</a><span>|</span><a href="#41897997">next</a><span>|</span><label class="collapse" for="c-41895622">[-]</label><label class="expand" for="c-41895622">[1 more]</label></div><br/><div class="children"><div class="content">The problem (or the solution, depending on which side you&#x27;re on) is that <i>innocent</i> people are in jail or dead. The people that <i>knowingly</i> allowed this to happen are still free and wealthy.<p>So I&#x27;m not particularly sure this is a good example - if anything, it sets the opposite incentives, that even jailing people or driving them to suicide won&#x27;t actually have any consequences for you.</div><br/></div></div></div></div></div></div><div id="41895002" class="c"><input type="checkbox" id="c-41895002" checked=""/><div class="controls bullet"><span class="by">jmull</span><span>|</span><a href="#41894762">prev</a><span>|</span><label class="collapse" for="c-41895002">[-]</label><label class="expand" for="c-41895002">[22 more]</label></div><br/><div class="children"><div class="content">This overcomplicates things...<p>* If you have something like what the article calls a fencing token, you don&#x27;t need any locks.<p>* The token doesn&#x27;t need to be monotonically increasing, just a passive unique value that both the client and storage have.<p>Let&#x27;s call it a version token. It could be monotonically increasing, but a generated UUID, which is typically easier, would work too. (Technically, it could even be a hash of all the data in the store, though that&#x27;s probably not practical.) The logic becomes:<p>(1) client retrieves the current version token from storage, along with any data it may want to modify. There&#x27;s no external lock, though the storage needs to retrieve the data and version token atomically, ensuring the token is specifically for the version of the data retrieved.<p>(2) client sends the version token back along with any changes.<p>(3) Storage accepts the changes if the current token matches the one passed with the changes and creates a new version token (atomically, but still no external locks).<p>Now, you can introduce locks for other reasons (hopefully goods ones... they seem to be misused a lot). Just pointing out they are&#x2F;should be independent of storage integrity in a distributed system.<p>(I don&#x27;t even like the term lock, because they are temporary&#x2F;unguaranteed. Lease or reservation might be a term that better conveys the meaning.)</div><br/><div id="41895448" class="c"><input type="checkbox" id="c-41895448" checked=""/><div class="controls bullet"><span class="by">cnlwsu</span><span>|</span><a href="#41895002">parent</a><span>|</span><a href="#41895513">next</a><span>|</span><label class="collapse" for="c-41895448">[-]</label><label class="expand" for="c-41895448">[1 more]</label></div><br/><div class="children"><div class="content">You’re describing compare and swap which is a good solution. You’re pushing complexity down to the database, and remember this is distributed locking. When you have a single database it’s simple until the database crashes leaving you in state of not knowing which of your CAS writes took effect. In major systems that demand high availability and multi datacenter backups this becomings pretty complicated with scenarios that break this as well around node failure. Usually some form of paxos transaction log is used. Never assume there is an easy solution in distributed systems… it just always sucks</div><br/></div></div><div id="41895513" class="c"><input type="checkbox" id="c-41895513" checked=""/><div class="controls bullet"><span class="by">zeroxfe</span><span>|</span><a href="#41895002">parent</a><span>|</span><a href="#41895448">prev</a><span>|</span><a href="#41895264">next</a><span>|</span><label class="collapse" for="c-41895513">[-]</label><label class="expand" for="c-41895513">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This overcomplicates things...<p>You&#x27;re misinterpreting the problem described, and proposing a solution for a different problem.</div><br/></div></div><div id="41895264" class="c"><input type="checkbox" id="c-41895264" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#41895002">parent</a><span>|</span><a href="#41895513">prev</a><span>|</span><a href="#41895192">next</a><span>|</span><label class="collapse" for="c-41895264">[-]</label><label class="expand" for="c-41895264">[4 more]</label></div><br/><div class="children"><div class="content">This is known as &#x27;optimistic locking&#x27;. But I wouldn&#x27;t call it a distributed locking mechanism.</div><br/><div id="41895633" class="c"><input type="checkbox" id="c-41895633" checked=""/><div class="controls bullet"><span class="by">jameshart</span><span>|</span><a href="#41895002">root</a><span>|</span><a href="#41895264">parent</a><span>|</span><a href="#41895192">next</a><span>|</span><label class="collapse" for="c-41895633">[-]</label><label class="expand" for="c-41895633">[3 more]</label></div><br/><div class="children"><div class="content">Optimistic locks are absolutely a distributed locking mechanism, in that they are for coordinating activity among distributed nodes - but they do require the storage node to have strong guarantees about serialization and atomicity of writes. That means it isn’t a distributed storage solution, but it is something you can build over the top of a distributed storage solution that has strong read after write guarantees.</div><br/><div id="41896188" class="c"><input type="checkbox" id="c-41896188" checked=""/><div class="controls bullet"><span class="by">zeroxfe</span><span>|</span><a href="#41895002">root</a><span>|</span><a href="#41895633">parent</a><span>|</span><a href="#41895684">next</a><span>|</span><label class="collapse" for="c-41896188">[-]</label><label class="expand" for="c-41896188">[1 more]</label></div><br/><div class="children"><div class="content">This is unconventional use of the term &quot;distributed locking&quot;. This alternative just punts the hard part of locking to the storage system.</div><br/></div></div><div id="41895684" class="c"><input type="checkbox" id="c-41895684" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#41895002">root</a><span>|</span><a href="#41895633">parent</a><span>|</span><a href="#41896188">prev</a><span>|</span><a href="#41895192">next</a><span>|</span><label class="collapse" for="c-41895684">[-]</label><label class="expand" for="c-41895684">[1 more]</label></div><br/><div class="children"><div class="content">I normally see it as a version column in a database where it being with the data makes it non-distributed.<p>I&#x27;m not even sure how it could be used for exclusive update to a resource elsewhere--all clients will think they &#x27;have&#x27; the lock and change the resource, then find out they didn&#x27;t when they update the lock. Or if they bump the lock first, another client could immediately &#x27;have&#x27; the lock too.</div><br/></div></div></div></div></div></div><div id="41895192" class="c"><input type="checkbox" id="c-41895192" checked=""/><div class="controls bullet"><span class="by">wh0knows</span><span>|</span><a href="#41895002">parent</a><span>|</span><a href="#41895264">prev</a><span>|</span><a href="#41895382">next</a><span>|</span><label class="collapse" for="c-41895192">[-]</label><label class="expand" for="c-41895192">[5 more]</label></div><br/><div class="children"><div class="content">This neglects the first reason listed in the article for why you would use a lock.<p>&gt; Efficiency: Taking a lock saves you from unnecessarily doing the same work twice (e.g. some expensive computation). If the lock fails and two nodes end up doing the same piece of work, the result is a minor increase in cost (you end up paying 5 cents more to AWS than you otherwise would have) or a minor inconvenience (e.g. a user ends up getting the same email notification twice).<p>I think multiple nodes doing the same work is actually much worse than what’s listed, as it would inhibit you from having any kind of scalable distributed processing.</div><br/><div id="41895289" class="c"><input type="checkbox" id="c-41895289" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#41895002">root</a><span>|</span><a href="#41895192">parent</a><span>|</span><a href="#41895299">next</a><span>|</span><label class="collapse" for="c-41895289">[-]</label><label class="expand" for="c-41895289">[3 more]</label></div><br/><div class="children"><div class="content">As mentioned in the article, a non-100%-correct lock can be used for efficiency purposes. So basically use an imperfect locking mechanism for efficiency and a reliable one for correctness.</div><br/><div id="41895335" class="c"><input type="checkbox" id="c-41895335" checked=""/><div class="controls bullet"><span class="by">jmull</span><span>|</span><a href="#41895002">root</a><span>|</span><a href="#41895289">parent</a><span>|</span><a href="#41895299">next</a><span>|</span><label class="collapse" for="c-41895335">[-]</label><label class="expand" for="c-41895335">[2 more]</label></div><br/><div class="children"><div class="content">&gt; and a reliable one for correctness<p>To be clear, my point is don&#x27;t use distributed locking for correctness. There are much better options.<p>Now, the atomicity I mention implies some kind of internal synchronization mechanism for multiple requests, which could be based on locks, but those would be real, non-distributed ones.</div><br/></div></div></div></div><div id="41895299" class="c"><input type="checkbox" id="c-41895299" checked=""/><div class="controls bullet"><span class="by">jmull</span><span>|</span><a href="#41895002">root</a><span>|</span><a href="#41895192">parent</a><span>|</span><a href="#41895289">prev</a><span>|</span><a href="#41895382">next</a><span>|</span><label class="collapse" for="c-41895299">[-]</label><label class="expand" for="c-41895299">[1 more]</label></div><br/><div class="children"><div class="content">Sure, that&#x27;s why I said you might introduce &quot;locks&quot; (reservations is a much better term) for other reasons.<p>Efficiency is one, as you say.<p>The other main one that comes to mind is to implement other &quot;business rules&quot; (hate that term, but that&#x27;s what people use), like for a online shopping app, the stock to fulfill an order might be reserved for a time when the user starts the checkout process.</div><br/></div></div></div></div><div id="41895382" class="c"><input type="checkbox" id="c-41895382" checked=""/><div class="controls bullet"><span class="by">bootsmann</span><span>|</span><a href="#41895002">parent</a><span>|</span><a href="#41895192">prev</a><span>|</span><a href="#41895475">next</a><span>|</span><label class="collapse" for="c-41895382">[-]</label><label class="expand" for="c-41895382">[7 more]</label></div><br/><div class="children"><div class="content">Won&#x27;t this lead to inconsistent states if you don&#x27;t do monotonically increasing tokens?<p>I.e. your storage system has two nodes and there are two read-modify-write processes running. Process 1 acquires the first token &quot;abc&quot; and process two also acquires the token &quot;abc&quot;. Now process 1 commits, the token is changed to &quot;cde&quot; and the change streamed to node 2. Due to network delay, the change to node 2 is delayed. Meanwhile process 2 commits to node 2 with token &quot;abc&quot;. Node 2 accepts the change because it has not received the message from node 1 and your system is now in an inconsistent state.<p>Note that this cannot happen in a scenario where we have monotonically increasing fencing tokens because that requirement forces the nodes to agree on a total order of operations before they can supply the fencing token.</div><br/><div id="41895446" class="c"><input type="checkbox" id="c-41895446" checked=""/><div class="controls bullet"><span class="by">computerfan494</span><span>|</span><a href="#41895002">root</a><span>|</span><a href="#41895382">parent</a><span>|</span><a href="#41895458">next</a><span>|</span><label class="collapse" for="c-41895446">[-]</label><label class="expand" for="c-41895446">[4 more]</label></div><br/><div class="children"><div class="content">In the above description of optimistic locking, it is assumed that it is impossible to issue the same token to multiple clients. Nodes can agree that a given token has also never been issued before just like a monotonically increasing value. The nice property about non-monitonically-increasing tokens is that nodes may generate them without coordinating if you can make other assumptions about that system. A good example is when nodes use an ID they were assigned beforehand as part of the token generation, guaranteeing that the leasing tokens they mint will not conflict with other nodes&#x27; as long as node IDs are not reused.</div><br/><div id="41896604" class="c"><input type="checkbox" id="c-41896604" checked=""/><div class="controls bullet"><span class="by">bootsmann</span><span>|</span><a href="#41895002">root</a><span>|</span><a href="#41895446">parent</a><span>|</span><a href="#41895458">next</a><span>|</span><label class="collapse" for="c-41896604">[-]</label><label class="expand" for="c-41896604">[3 more]</label></div><br/><div class="children"><div class="content">I have a hard time wrapping my head around what you are proposing here.  
Say client A requests data, they get the token a-abc. Then client B requests data, they get the token b-cde. Client A commits their write, does the storage reject it because they already issued another token (the one from client B) or does it accept it?</div><br/><div id="41896803" class="c"><input type="checkbox" id="c-41896803" checked=""/><div class="controls bullet"><span class="by">computerfan494</span><span>|</span><a href="#41895002">root</a><span>|</span><a href="#41896604">parent</a><span>|</span><a href="#41895458">next</a><span>|</span><label class="collapse" for="c-41896803">[-]</label><label class="expand" for="c-41896803">[2 more]</label></div><br/><div class="children"><div class="content">My understanding of what the OP was discussing is an optimistic locking system where the nodes only accept commits if the last issued token matches the token included in the commit. While agreeing on the last token requested requires coordination, unlike monotonically increasing tokens you could have well-behaved clients generate token content themselves without coordination. That may or may not be useful as a property.</div><br/><div id="41897171" class="c"><input type="checkbox" id="c-41897171" checked=""/><div class="controls bullet"><span class="by">bootsmann</span><span>|</span><a href="#41895002">root</a><span>|</span><a href="#41896803">parent</a><span>|</span><a href="#41895458">next</a><span>|</span><label class="collapse" for="c-41897171">[-]</label><label class="expand" for="c-41897171">[1 more]</label></div><br/><div class="children"><div class="content">Got it, thank you for clarifying this.</div><br/></div></div></div></div></div></div></div></div><div id="41895458" class="c"><input type="checkbox" id="c-41895458" checked=""/><div class="controls bullet"><span class="by">jmull</span><span>|</span><a href="#41895002">root</a><span>|</span><a href="#41895382">parent</a><span>|</span><a href="#41895446">prev</a><span>|</span><a href="#41895475">next</a><span>|</span><label class="collapse" for="c-41895458">[-]</label><label class="expand" for="c-41895458">[2 more]</label></div><br/><div class="children"><div class="content">&quot;node1&quot;, &quot;node2&quot;, and &quot;storage&quot; are three separate things in the distributed environment. Only storage accepts changes, and it&#x27;s what verifies the incoming token matches the current token.<p>So node2 doesn&#x27;t get to accept changes. It can only send changes to storage, which may or may not be accepted by it.</div><br/><div id="41896506" class="c"><input type="checkbox" id="c-41896506" checked=""/><div class="controls bullet"><span class="by">bootsmann</span><span>|</span><a href="#41895002">root</a><span>|</span><a href="#41895458">parent</a><span>|</span><a href="#41895475">next</a><span>|</span><label class="collapse" for="c-41896506">[-]</label><label class="expand" for="c-41896506">[1 more]</label></div><br/><div class="children"><div class="content">If the storage is a singular entity then this is not a distributed systems problem at all, no?</div><br/></div></div></div></div></div></div><div id="41895475" class="c"><input type="checkbox" id="c-41895475" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41895002">parent</a><span>|</span><a href="#41895382">prev</a><span>|</span><label class="collapse" for="c-41895475">[-]</label><label class="expand" for="c-41895475">[3 more]</label></div><br/><div class="children"><div class="content">Git push&#x27;s `--force-with-lease` option does essentially this.<p>(Honestly, they should rename `--force-with-lease` to just `--force`, and rename the old `--force` behaviour to `--force-with-extreme-prejudice` or something like that.  Basically make the new behaviour the default `--force` behaviour.)</div><br/><div id="41898300" class="c"><input type="checkbox" id="c-41898300" checked=""/><div class="controls bullet"><span class="by">pyrolistical</span><span>|</span><a href="#41895002">root</a><span>|</span><a href="#41895475">parent</a><span>|</span><label class="collapse" for="c-41898300">[-]</label><label class="expand" for="c-41898300">[2 more]</label></div><br/><div class="children"><div class="content">`--force-unsafe`</div><br/><div id="41901432" class="c"><input type="checkbox" id="c-41901432" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41895002">root</a><span>|</span><a href="#41898300">parent</a><span>|</span><label class="collapse" for="c-41901432">[-]</label><label class="expand" for="c-41901432">[1 more]</label></div><br/><div class="children"><div class="content">That would be the saner name, yes.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>