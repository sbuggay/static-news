<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734512460715" as="style"/><link rel="stylesheet" href="styles.css?v=1734512460715"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://olivernguyen.io/w/namespace.error/">How We Centralized and Structured Error Handling in Golang</a> <span class="domain">(<a href="https://olivernguyen.io">olivernguyen.io</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>67 comments</span></div><br/><div><div id="42448398" class="c"><input type="checkbox" id="c-42448398" checked=""/><div class="controls bullet"><span class="by">jaza</span><span>|</span><a href="#42448449">next</a><span>|</span><label class="collapse" for="c-42448398">[-]</label><label class="expand" for="c-42448398">[7 more]</label></div><br/><div class="children"><div class="content">Feels like OP is basically implementing exceptions and exception handling at the application level. If this is what you want, then why not just switch to one of the many other languages that has exceptions built in at the language level?</div><br/><div id="42448461" class="c"><input type="checkbox" id="c-42448461" checked=""/><div class="controls bullet"><span class="by">KingOfCoders</span><span>|</span><a href="#42448398">parent</a><span>|</span><a href="#42448449">next</a><span>|</span><label class="collapse" for="c-42448461">[-]</label><label class="expand" for="c-42448461">[6 more]</label></div><br/><div class="children"><div class="content">I think they use too many sentinel errors [0] I have been doing Java for two decades, and I thought you need to handle individual errors by type. Using Go, I&#x27;ve learned from the code I write, 90%+ of errors I don&#x27;t need to handle individually, or I can&#x27;t do anything except bubble an error up. There is the rare case (10%) when a file does not exist, and I try to read an alternative one and I don&#x27;t bubble up an error.<p>For customer support I also found it much easier, instead of an error number, print a UUID that customers can give to support, and that UUID (Request ID) then can be found in the logs to find out what happened by developers.<p>[0]:<a href="https:&#x2F;&#x2F;dave.cheney.net&#x2F;2016&#x2F;04&#x2F;27&#x2F;dont-just-check-errors-handle-them-gracefully" rel="nofollow">https:&#x2F;&#x2F;dave.cheney.net&#x2F;2016&#x2F;04&#x2F;27&#x2F;dont-just-check-errors-ha...</a></div><br/><div id="42448524" class="c"><input type="checkbox" id="c-42448524" checked=""/><div class="controls bullet"><span class="by">gf000</span><span>|</span><a href="#42448398">root</a><span>|</span><a href="#42448461">parent</a><span>|</span><a href="#42448477">next</a><span>|</span><label class="collapse" for="c-42448524">[-]</label><label class="expand" for="c-42448524">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Using Go, I&#x27;ve learned from the code I write, 90%+ of errors I don&#x27;t need to handle individually, or I can&#x27;t do anything except bubble an error up<p>So... exceptions are better, because they would do the correct thing by default in the majority of cases?</div><br/><div id="42448631" class="c"><input type="checkbox" id="c-42448631" checked=""/><div class="controls bullet"><span class="by">lordofgibbons</span><span>|</span><a href="#42448398">root</a><span>|</span><a href="#42448524">parent</a><span>|</span><a href="#42448477">next</a><span>|</span><label class="collapse" for="c-42448631">[-]</label><label class="expand" for="c-42448631">[3 more]</label></div><br/><div class="children"><div class="content">Unless you forget to catch the right type of exception. Then all hell breaks loose.</div><br/><div id="42448677" class="c"><input type="checkbox" id="c-42448677" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#42448398">root</a><span>|</span><a href="#42448631">parent</a><span>|</span><a href="#42448666">next</a><span>|</span><label class="collapse" for="c-42448677">[-]</label><label class="expand" for="c-42448677">[1 more]</label></div><br/><div class="children"><div class="content">People bitch about checked exceptions in Java but this is precisely why I think they&#x27;re a great idea. You can&#x27;t forget to catch the right type of exception.</div><br/></div></div></div></div></div></div><div id="42448477" class="c"><input type="checkbox" id="c-42448477" checked=""/><div class="controls bullet"><span class="by">RVuRnvbM2e</span><span>|</span><a href="#42448398">root</a><span>|</span><a href="#42448461">parent</a><span>|</span><a href="#42448524">prev</a><span>|</span><a href="#42448449">next</a><span>|</span><label class="collapse" for="c-42448477">[-]</label><label class="expand" for="c-42448477">[1 more]</label></div><br/><div class="children"><div class="content">This was exactly my train of thought. I even went looking for Dave&#x27;s blog post about it before I saw your comment. :D</div><br/></div></div></div></div></div></div><div id="42448449" class="c"><input type="checkbox" id="c-42448449" checked=""/><div class="controls bullet"><span class="by">rollulus</span><span>|</span><a href="#42448398">prev</a><span>|</span><a href="#42447879">next</a><span>|</span><label class="collapse" for="c-42448449">[-]</label><label class="expand" for="c-42448449">[2 more]</label></div><br/><div class="children"><div class="content">Ah, a God error package that has all seeing knowledge of the domain around it. What a monstrosity.</div><br/><div id="42448696" class="c"><input type="checkbox" id="c-42448696" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42448449">parent</a><span>|</span><a href="#42447879">next</a><span>|</span><label class="collapse" for="c-42448696">[-]</label><label class="expand" for="c-42448696">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not the worst idea for an organisation to centralise stuff that needs to be centralised.<p>Like defining protobuf schemas, it&#x27;s no good if each team does its own thing.</div><br/></div></div></div></div><div id="42447879" class="c"><input type="checkbox" id="c-42447879" checked=""/><div class="controls bullet"><span class="by">vrosas</span><span>|</span><a href="#42448449">prev</a><span>|</span><a href="#42447841">next</a><span>|</span><label class="collapse" for="c-42447879">[-]</label><label class="expand" for="c-42447879">[31 more]</label></div><br/><div class="children"><div class="content">Trying to shoehorn code errors into HTTP errors is a prime example of conflating two very different things because sometimes they look similar. Let different things be different, I like to say. You either let your HTTP handlers do their own error-to-http-code management or you end up with a massive switch statement trying to map them all, or whatever monstrosity this approach is.<p>Also the entire problem of the OP would go away if they just implemented opentelemetry tracing to their logs.</div><br/><div id="42448023" class="c"><input type="checkbox" id="c-42448023" checked=""/><div class="controls bullet"><span class="by">pluto_modadic</span><span>|</span><a href="#42447879">parent</a><span>|</span><a href="#42448459">next</a><span>|</span><label class="collapse" for="c-42448023">[-]</label><label class="expand" for="c-42448023">[29 more]</label></div><br/><div class="children"><div class="content">ah, yes, completely separate.<p>HTTP code: 200 ok<p>Body: {&quot;error&quot;:&quot;internal server error&quot;}</div><br/><div id="42448843" class="c"><input type="checkbox" id="c-42448843" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448023">parent</a><span>|</span><a href="#42448212">next</a><span>|</span><label class="collapse" for="c-42448843">[-]</label><label class="expand" for="c-42448843">[1 more]</label></div><br/><div class="children"><div class="content">Think about what the client code looks like to handle this and the alternative, particularly if you’re implementing an sdk and the api is an implementation detail. I’m not saying I would choose this path, but it certainly reduces the amount of code on both sides that you have to write.</div><br/></div></div><div id="42448212" class="c"><input type="checkbox" id="c-42448212" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448023">parent</a><span>|</span><a href="#42448843">prev</a><span>|</span><a href="#42448296">next</a><span>|</span><label class="collapse" for="c-42448212">[-]</label><label class="expand" for="c-42448212">[5 more]</label></div><br/><div class="children"><div class="content">My favorite example of this was renaming a 500 error due to an unhandled exception to a 400 error to make it look like it was the error of the caller.  Management was also possibly tracking 500 errors too, so the 400 could also have been gaming the system.<p>In some mental models, though, it did make sense.  Particularly the one that went, &quot;Well, we never would have errored, if you never called us!&quot;</div><br/><div id="42448348" class="c"><input type="checkbox" id="c-42448348" checked=""/><div class="controls bullet"><span class="by">xmprt</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448212">parent</a><span>|</span><a href="#42448296">next</a><span>|</span><label class="collapse" for="c-42448348">[-]</label><label class="expand" for="c-42448348">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s somewhat fair though. If there&#x27;s a case that would cause errors for the system and it&#x27;s a case that you&#x27;re not supposed to handle, then a 400 error sounds perfect for that case. For example, if you have a service and it panics&#x2F;returns 500 when you pass in an empty user id, then you could instead return a 400 before you hit the panic and all is good.</div><br/><div id="42448397" class="c"><input type="checkbox" id="c-42448397" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448348">parent</a><span>|</span><a href="#42448296">next</a><span>|</span><label class="collapse" for="c-42448397">[-]</label><label class="expand" for="c-42448397">[3 more]</label></div><br/><div class="children"><div class="content">Normally you should attempt to find all the corner cases and present the errors to the user -- before processing the request.  If you can&#x27;t do this, it&#x27;s time to rethink how your api works.  A good api is simple to use and simple to write.<p>It also simplifies your business logic in that all the possible user defined idiocies are caught before your business logic actually processes the request.<p>Some frameworks do this better than others. And rather than documentation, I tend to prefer comprehensive error messages.</div><br/><div id="42448557" class="c"><input type="checkbox" id="c-42448557" checked=""/><div class="controls bullet"><span class="by">fmbb</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448397">parent</a><span>|</span><a href="#42448296">next</a><span>|</span><label class="collapse" for="c-42448557">[-]</label><label class="expand" for="c-42448557">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Normally you should attempt to find all the corner cases and present the errors to the user -- before processing the request.<p>That is what they are suggesting. You check the request and return 400 if it’s bad.</div><br/><div id="42448613" class="c"><input type="checkbox" id="c-42448613" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448557">parent</a><span>|</span><a href="#42448296">next</a><span>|</span><label class="collapse" for="c-42448613">[-]</label><label class="expand" for="c-42448613">[1 more]</label></div><br/><div class="children"><div class="content">One example of a 500 error is a null pointer error.  Was it a bad request or a logic error?  One is your problem the other is not.  Just returning a 400 hides that issue.  Validating the payload before processing it simplifies the issue for everyone involved.<p>A 500 error should be your problem with a stack trace in the log.  A 400 error should provide enough description to tell the user it&#x27;s theirs and how to fix it.<p>Just marking recoding a 500 to a 400 because of a null pointer error would get noticed on a code review and marked up on a code review.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42448296" class="c"><input type="checkbox" id="c-42448296" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448023">parent</a><span>|</span><a href="#42448212">prev</a><span>|</span><a href="#42448094">next</a><span>|</span><label class="collapse" for="c-42448296">[-]</label><label class="expand" for="c-42448296">[21 more]</label></div><br/><div class="children"><div class="content">Honestly, my controversial take is that for APIs, it would be cleaner to not use any HTTP status codes other than 200 and have all of the semantics in the body of the response. I&#x27;m sure someone smarter than me will jump in and explain why this wouldn&#x27;t work in practice, but it just feels like application semantics are leaking from a much more natural location in the body of the response. I feel similarly about HTTP request methods other than POST in APIs; between the endpoint route and the body, there should be more than enough room to express the difference between POST, PATCH, and DELETE without needing them to be encoded as separate HTTP methods.</div><br/><div id="42448475" class="c"><input type="checkbox" id="c-42448475" checked=""/><div class="controls bullet"><span class="by">turbojet1321</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448296">parent</a><span>|</span><a href="#42448867">next</a><span>|</span><label class="collapse" for="c-42448475">[-]</label><label class="expand" for="c-42448475">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sympathetic, but this can have issues if you want your API to be used by anything other than your own client, including stuff like logging middleware. A lot of tools inherently support&#x2F;understand HTTP status codes, so building on top of that can make integration a lot easier.<p>We, very roughly, do it like this:<p>- 200: all good<p>- 401: we don&#x27;t know who you are<p>- 403: you&#x27;re not allowed to do that<p>- 400: something&#x27;s wrong and you can fix it<p>- 500: something&#x27;s wrong and you can&#x27;t fix it<p>Each response (other than 401) includes a json blob with details that our UI can do something with, but any other consumer of the API or HTTP traffic still knows roughly what&#x27;s going on.<p>I&#x27;ve worked in places where we really sweated on getting the perfect HTTP status codes, and I&#x27;m not sure it added much benefit.<p>On POST - I find myself doing logical GETs with POST a lot, because the endpoint requires more information than can be conveyed in URL params. It makes me feel dirty, and it&#x27;s obviously not RESTful but you know - sometimes you just have to get things done.</div><br/><div id="42448603" class="c"><input type="checkbox" id="c-42448603" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448475">parent</a><span>|</span><a href="#42448867">next</a><span>|</span><label class="collapse" for="c-42448603">[-]</label><label class="expand" for="c-42448603">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;ve just described basically everything a dev needs to know to implement HTTP APIs that report status codes properly, yet some people still seem to think it&#x27;s oh so complicated. What has gone wrong?</div><br/><div id="42448627" class="c"><input type="checkbox" id="c-42448627" checked=""/><div class="controls bullet"><span class="by">turbojet1321</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448603">parent</a><span>|</span><a href="#42448867">next</a><span>|</span><label class="collapse" for="c-42448627">[-]</label><label class="expand" for="c-42448627">[3 more]</label></div><br/><div class="children"><div class="content">I can understand how people might look at all the full list status codes and think it&#x27;s all too hard, but yes, once you realize that there are only a handful you need <i>most of the time</i> it all becomes pretty simple.</div><br/><div id="42448727" class="c"><input type="checkbox" id="c-42448727" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448627">parent</a><span>|</span><a href="#42448867">next</a><span>|</span><label class="collapse" for="c-42448727">[-]</label><label class="expand" for="c-42448727">[2 more]</label></div><br/><div class="children"><div class="content">Sure, but the problem in my opinion is that while the handful that you pick is totally reasonable, someone else might pick a slightly different handful that&#x27;s just as reasonable. If I want to use a new API and delete a user, how do I know if it uses DELETE or POST, and if it will return 401 or 403? At best, you&#x27;ll be able to skim through the documentation more quickly due to having encountered similar conventions before, but nothing stops that from happening in terms of request and response bodies either.<p>The fact that existing tooling relies on some of these conventions is probably a good enough reason to do things this way, but it&#x27;s not obvious to me that this is because it&#x27;s actually better rather than inertia. Conventions could be developed around the body of requests as well, and at least to me, it doesn&#x27;t seem obvious that the amount of information conveyed at the HTTP method&#x2F;response status layer was necessary to try to separate from the semantics of the request and response bodies. I&#x27;m sure that a part of that was due to HTTP supporting different content types for payloads, but nowadays it seems like quite a lot of the common alternatives to JSON APIs were designed not to even use HTTP (GraphQL, gRPC, etc.), which I&#x27;d argue is evidence that HTTP isn&#x27;t necessarily being used as well for APIs as some people would like.<p>To make something explicit that I&#x27;ve been alluding to, everything I&#x27;ve said is about using APIs in HTTP, not HTTP in the context of viewing webpages in a browser. It really seems like a lot of the complications in HTTP are due to it trying to be sufficient for both browsers and APIs, and in my opinion this comes mostly at the expense of the latter.</div><br/><div id="42449041" class="c"><input type="checkbox" id="c-42449041" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448727">parent</a><span>|</span><a href="#42448867">next</a><span>|</span><label class="collapse" for="c-42449041">[-]</label><label class="expand" for="c-42449041">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s quite unclear what&#x27;s your point. HTTP APIs should have minimal status code set. Parent described it perfectly. It&#x27;s simple, practical (especially from monitoring perspective) and doesn&#x27;t intervenes with a service domain.<p>It seems you have some alternative in mind but it wasn&#x27;t presented.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42448867" class="c"><input type="checkbox" id="c-42448867" checked=""/><div class="controls bullet"><span class="by">LouisSayers</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448296">parent</a><span>|</span><a href="#42448475">prev</a><span>|</span><a href="#42448452">next</a><span>|</span><label class="collapse" for="c-42448867">[-]</label><label class="expand" for="c-42448867">[2 more]</label></div><br/><div class="children"><div class="content">I like to find a middle ground.<p>I use http status codes to encode how the _request_ was handled, not necessarily the data within the request.<p>A 400 if you send mangled JSON, but a 200 if the request was valid but does not pass business validation rules.<p>Inside the 200 response is structured JSON that also has a status that is relevant at the application level.<p>Otherwise how can for example you tell if a 404 response is because the endpoint doesn&#x27;t exist, or because the item requested at the endpoint doesn&#x27;t exist?<p>I believe it&#x27;s important to have a separation between what is happening at the API level vs Application, and this approach caters for both.</div><br/><div id="42449046" class="c"><input type="checkbox" id="c-42449046" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448867">parent</a><span>|</span><a href="#42448452">next</a><span>|</span><label class="collapse" for="c-42449046">[-]</label><label class="expand" for="c-42449046">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A 400 if you send mangled JSON, but a 200 if the request was valid but does not pass business validation rules.<p>What about empty required field in JSON? Is it still mangled or it&#x27;s already BL?</div><br/></div></div></div></div><div id="42448452" class="c"><input type="checkbox" id="c-42448452" checked=""/><div class="controls bullet"><span class="by">bilbo-b-baggins</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448296">parent</a><span>|</span><a href="#42448867">prev</a><span>|</span><a href="#42448443">next</a><span>|</span><label class="collapse" for="c-42448452">[-]</label><label class="expand" for="c-42448452">[3 more]</label></div><br/><div class="children"><div class="content">Go ahead try to implement something like cross-origin requests or multipart encoded form uploads just using the body semantics you described. I’ll wait.<p>Also that is not a controversial take. It is at best a naive or inexperienced take.</div><br/><div id="42448762" class="c"><input type="checkbox" id="c-42448762" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448452">parent</a><span>|</span><a href="#42448443">next</a><span>|</span><label class="collapse" for="c-42448762">[-]</label><label class="expand" for="c-42448762">[2 more]</label></div><br/><div class="children"><div class="content">Both of those happen in the context of web browsing rather than existing in APIs in a vaccuum; I&#x27;d argue that there&#x27;s absolutely no reason why the mechanism used to request a webpage from a browser needed to be identical to the mechanism used for the webpage to perform those actions dynamically, which is pretty much my whole point: it doesn&#x27;t seem obvious to me that it&#x27;s useful to encode all of that information in an API that isn&#x27;t also being used to serve webpages. If you are serving webpages, then it makes sense to use semantics that help with that, but I can&#x27;t imagine I&#x27;m the only one who&#x27;s had to deal with bikeshedding around this sort of thing in APIs that literally only are used for backends.</div><br/><div id="42448868" class="c"><input type="checkbox" id="c-42448868" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448762">parent</a><span>|</span><a href="#42448443">next</a><span>|</span><label class="collapse" for="c-42448868">[-]</label><label class="expand" for="c-42448868">[1 more]</label></div><br/><div class="children"><div class="content">Multipart messages definitely happens in APIs as well, if you are handling blobs that are potentially pretty big.</div><br/></div></div></div></div></div></div><div id="42448443" class="c"><input type="checkbox" id="c-42448443" checked=""/><div class="controls bullet"><span class="by">omcnoe</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448296">parent</a><span>|</span><a href="#42448452">prev</a><span>|</span><a href="#42448759">next</a><span>|</span><label class="collapse" for="c-42448443">[-]</label><label class="expand" for="c-42448443">[1 more]</label></div><br/><div class="children"><div class="content">There are a lot of useful network monitoring tools that can analyze HTTP response codes out of the box. They can&#x27;t do this for your custom application error format. You don&#x27;t have to go crazy with it, but supporting at least 200&#x2F;400&#x2F;500 makes it so much easier to monitor the health of your services.</div><br/></div></div><div id="42448759" class="c"><input type="checkbox" id="c-42448759" checked=""/><div class="controls bullet"><span class="by">JodieBenitez</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448296">parent</a><span>|</span><a href="#42448443">prev</a><span>|</span><a href="#42448552">next</a><span>|</span><label class="collapse" for="c-42448759">[-]</label><label class="expand" for="c-42448759">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Honestly, my controversial take is that for APIs, it would be cleaner to not use any HTTP status codes other than 200 and have all of the semantics in the body of the response.<p>We&#x27;ve been doing that for 20 years with json-rpc 1.0<p><pre><code>    --&gt; { &quot;method&quot;: &quot;echo&quot;, &quot;params&quot;: [&quot;Hello JSON-RPC&quot;], &quot;id&quot;:1}
    &lt;-- { &quot;result&quot;: &quot;Hello JSON-RPC&quot;, &quot;error&quot;: null, &quot;id&quot;: 1}
</code></pre>
In this context, HTTP is just the transport and HTTP errors are only transport errors.<p>Yes, you throw away lots of HTTP goodies with that, but there are many situations where it makes more sense than some half-assed ReSTish API. YMMV.</div><br/></div></div><div id="42448552" class="c"><input type="checkbox" id="c-42448552" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448296">parent</a><span>|</span><a href="#42448759">prev</a><span>|</span><a href="#42448319">next</a><span>|</span><label class="collapse" for="c-42448552">[-]</label><label class="expand" for="c-42448552">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, that&#x27;s usually the pragmatic thing to do. Facebook does that with their API, for example.<p>4xx or 5xx gets you the default HTTP handling for that kind of error. Occasionally - especially in small examples - that default handling does what you want and saves you duplicating a lot of work. More often it gets in your way.<p>I&#x27;d compare it to browser default styling - in small examples it sounds useful, but in a decent-sized site you just end up having to do a &quot;CSS reset&quot; to get it out of the way before you do your styling.</div><br/></div></div><div id="42448319" class="c"><input type="checkbox" id="c-42448319" checked=""/><div class="controls bullet"><span class="by">tayo42</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448296">parent</a><span>|</span><a href="#42448552">prev</a><span>|</span><a href="#42448379">next</a><span>|</span><label class="collapse" for="c-42448319">[-]</label><label class="expand" for="c-42448319">[5 more]</label></div><br/><div class="children"><div class="content">Your kind of describing things like thrift and other rpc servers?</div><br/><div id="42448350" class="c"><input type="checkbox" id="c-42448350" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448319">parent</a><span>|</span><a href="#42448379">next</a><span>|</span><label class="collapse" for="c-42448350">[-]</label><label class="expand" for="c-42448350">[4 more]</label></div><br/><div class="children"><div class="content">Possibly. I&#x27;m not sure why it should require switching to an entirely different protocol though; my point is that making an API that only uses POST and always returns 200 is something that already works in HTTP though, and I have trouble understanding why that isn&#x27;t enough for pretty much everything.</div><br/><div id="42448424" class="c"><input type="checkbox" id="c-42448424" checked=""/><div class="controls bullet"><span class="by">necovek</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448350">parent</a><span>|</span><a href="#42448418">next</a><span>|</span><label class="collapse" for="c-42448424">[-]</label><label class="expand" for="c-42448424">[1 more]</label></div><br/><div class="children"><div class="content">You lose some benefits of features already implemented by existing HTTP clients (caching, redirection, authorization and authentication, cross-origin protections, understanding the nature of the error to know that this request has failed and you need to try another one...).<p>It&#x27;s is certainly not comprehensive, but it&#x27;s right there and it works.<p>Moving to your own solution means that you have to reimplement all of this in every client.</div><br/></div></div><div id="42448418" class="c"><input type="checkbox" id="c-42448418" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448350">parent</a><span>|</span><a href="#42448424">prev</a><span>|</span><a href="#42448416">next</a><span>|</span><label class="collapse" for="c-42448418">[-]</label><label class="expand" for="c-42448418">[1 more]</label></div><br/><div class="children"><div class="content">You are thinking like a developer, but there is a world of networking as well. Between your client and server will be various bits of hardware that cannot speak the language you invent. 200, 401, 500 — these are not for the use of the application developer — but rather the infrastructure engineer.</div><br/></div></div><div id="42448416" class="c"><input type="checkbox" id="c-42448416" checked=""/><div class="controls bullet"><span class="by">tayo42</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448350">parent</a><span>|</span><a href="#42448418">prev</a><span>|</span><a href="#42448379">next</a><span>|</span><label class="collapse" for="c-42448416">[-]</label><label class="expand" for="c-42448416">[1 more]</label></div><br/><div class="children"><div class="content">You need some kind of structured way to describe the action to take, what the result is or what the error is. so the client and server can actually parse the data. that&#x27;s the protocol, whether its something formal like rpc libraries, or &quot;REST&quot;-ish or w&#x2F;e<p>json-rpc is probably what your describing over http, maybe if you squint enough graphql too</div><br/></div></div></div></div></div></div><div id="42448379" class="c"><input type="checkbox" id="c-42448379" checked=""/><div class="controls bullet"><span class="by">evnix</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448296">parent</a><span>|</span><a href="#42448319">prev</a><span>|</span><a href="#42448094">next</a><span>|</span><label class="collapse" for="c-42448379">[-]</label><label class="expand" for="c-42448379">[2 more]</label></div><br/><div class="children"><div class="content">This is the way to go, pretty much solves, 404 resource not found or route not found. But you will get laughed at by so called architectural dogmatists. Remember we aren&#x27;t really doing REST, it&#x27;s just RPC and let&#x27;s call it that.<p>Shoehorning http protocols error codes as application error codes, drinking the cool aid and calling it best practice is beyond bizzare.</div><br/><div id="42448442" class="c"><input type="checkbox" id="c-42448442" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#42447879">root</a><span>|</span><a href="#42448379">parent</a><span>|</span><a href="#42448094">next</a><span>|</span><label class="collapse" for="c-42448442">[-]</label><label class="expand" for="c-42448442">[1 more]</label></div><br/><div class="children"><div class="content">Agree. &quot;200 - successfully failed to do the thing&quot; is valid and useful.<p>500 is &quot;failed to do anything at all&quot;</div><br/></div></div></div></div></div></div></div></div><div id="42448459" class="c"><input type="checkbox" id="c-42448459" checked=""/><div class="controls bullet"><span class="by">rollulus</span><span>|</span><a href="#42447879">parent</a><span>|</span><a href="#42448023">prev</a><span>|</span><a href="#42447841">next</a><span>|</span><label class="collapse" for="c-42448459">[-]</label><label class="expand" for="c-42448459">[1 more]</label></div><br/><div class="children"><div class="content">The error to code in the http handler is the true path. It’s the only place where the context and knowledge is about semantics. In one endpoint if something is not found it can be a proper 404, if its existence is truly optional. In another endpoint the absence might very well qualify as a 500.</div><br/></div></div></div></div><div id="42447841" class="c"><input type="checkbox" id="c-42447841" checked=""/><div class="controls bullet"><span class="by">nikolayasdf123</span><span>|</span><a href="#42447879">prev</a><span>|</span><a href="#42448293">next</a><span>|</span><label class="collapse" for="c-42447841">[-]</label><label class="expand" for="c-42447841">[1 more]</label></div><br/><div class="children"><div class="content">&gt; centralized system [... for errors]<p>dont think this will scale. errors are part of API. (especially Go mantra errors are values <a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;errors-are-values" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;errors-are-values</a> it is ever more prominent). and each API is responsibility of a service<p>so unless you deal with infrastructure or standards&#x2F;protocols layer (say you define what HTTP 500 means or common pattern for URL paths in your API), then better not couple all services. those standards are very minimal and primitive that works for everything, which is opposite what you doing here aggregating all the specifics into single place</div><br/></div></div><div id="42448293" class="c"><input type="checkbox" id="c-42448293" checked=""/><div class="controls bullet"><span class="by">winstonp</span><span>|</span><a href="#42447841">prev</a><span>|</span><a href="#42447993">next</a><span>|</span><label class="collapse" for="c-42448293">[-]</label><label class="expand" for="c-42448293">[2 more]</label></div><br/><div class="children"><div class="content">I agree Go error handling is unoptimal, but this is simply not the right approach. This essentially turns error handling into a whole other language, almost like how Ginkgo is a separate language for handling tests.</div><br/><div id="42448616" class="c"><input type="checkbox" id="c-42448616" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42448293">parent</a><span>|</span><a href="#42447993">next</a><span>|</span><label class="collapse" for="c-42448616">[-]</label><label class="expand" for="c-42448616">[1 more]</label></div><br/><div class="children"><div class="content">And most languages are lacking this useful error language. You can’t speak if you have no language, so having it must be a good thing.<p>The only questionable thing here is that this framework is not a part of the main language still, which means near zero adoption. But that train has sailed.</div><br/></div></div></div></div><div id="42447993" class="c"><input type="checkbox" id="c-42447993" checked=""/><div class="controls bullet"><span class="by">rednafi</span><span>|</span><a href="#42448293">prev</a><span>|</span><a href="#42448501">next</a><span>|</span><label class="collapse" for="c-42447993">[-]</label><label class="expand" for="c-42447993">[5 more]</label></div><br/><div class="children"><div class="content">Go’s error handling is still cumbersome and lacking. I love writing Go but I don’t want to ever adopt anything like. It’s bending over backwards to achieve something sum types provide and this pattern is a mess.</div><br/><div id="42448433" class="c"><input type="checkbox" id="c-42448433" checked=""/><div class="controls bullet"><span class="by">KingOfCoders</span><span>|</span><a href="#42447993">parent</a><span>|</span><a href="#42448377">next</a><span>|</span><label class="collapse" for="c-42448433">[-]</label><label class="expand" for="c-42448433">[1 more]</label></div><br/><div class="children"><div class="content">I thought so too, after years with Scala and Rust. Now I think (X, error) is fine, indeed I think it is great for it&#x27;s simplicity. I might want to have a safe assignment<p><pre><code>   &#x2F;&#x2F; x() (X,error)
   x != x() 
   &#x2F;&#x2F; x is X
   &#x2F;&#x2F; return on error
</code></pre>
But the urge is not very high.</div><br/></div></div><div id="42448377" class="c"><input type="checkbox" id="c-42448377" checked=""/><div class="controls bullet"><span class="by">solumunus</span><span>|</span><a href="#42447993">parent</a><span>|</span><a href="#42448433">prev</a><span>|</span><a href="#42448501">next</a><span>|</span><label class="collapse" for="c-42448377">[-]</label><label class="expand" for="c-42448377">[3 more]</label></div><br/><div class="children"><div class="content">I would be all over Go with a better type system or  exceptions.</div><br/><div id="42448534" class="c"><input type="checkbox" id="c-42448534" checked=""/><div class="controls bullet"><span class="by">gf000</span><span>|</span><a href="#42447993">root</a><span>|</span><a href="#42448377">parent</a><span>|</span><a href="#42448425">next</a><span>|</span><label class="collapse" for="c-42448534">[-]</label><label class="expand" for="c-42448534">[1 more]</label></div><br/><div class="children"><div class="content">C#, OCaml, Java, Scala, Kotlin all fulfill these requirements, while targeting the same niche.</div><br/></div></div></div></div></div></div><div id="42448501" class="c"><input type="checkbox" id="c-42448501" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42447993">prev</a><span>|</span><a href="#42448478">next</a><span>|</span><label class="collapse" for="c-42448501">[-]</label><label class="expand" for="c-42448501">[4 more]</label></div><br/><div class="children"><div class="content">Is this just someone&#x27;s proposal, or a formal addition to Go, or what?<p><i>&quot;All errors must implement the Error interface.&quot;</i> That&#x27;s a step forward.<p>Rust really has the same error handling as Go - return an error status. But the syntax is cleaner. Rust thrashed around with errors at first. Then things sort of settled down.
At this point, everybody uses Result&lt;UsefulValue, Error&gt;, but &quot;Error&quot; is just a trait that doesn&#x27;t require much information. And &quot;?&quot; for propagating errors upwards is a huge convenience.<p>It&#x27;s probably too late to retrofit &quot;Result&quot; and &quot;?&quot; into Go libraries, although they&#x27;d fit the language.</div><br/><div id="42448517" class="c"><input type="checkbox" id="c-42448517" checked=""/><div class="controls bullet"><span class="by">gf000</span><span>|</span><a href="#42448501">parent</a><span>|</span><a href="#42448478">next</a><span>|</span><label class="collapse" for="c-42448517">[-]</label><label class="expand" for="c-42448517">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Rust really has the same error handling as Go<p>Not at all. Rust has proper sum types, that it can return just like anything else in the language, while Go has a special cased error return slot (one may be tempted to call it an ugly hack), and it can return a value on <i>both</i>, which it does in some standard library calls.</div><br/><div id="42448528" class="c"><input type="checkbox" id="c-42448528" checked=""/><div class="controls bullet"><span class="by">margalabargala</span><span>|</span><a href="#42448501">root</a><span>|</span><a href="#42448517">parent</a><span>|</span><a href="#42448478">next</a><span>|</span><label class="collapse" for="c-42448528">[-]</label><label class="expand" for="c-42448528">[2 more]</label></div><br/><div class="children"><div class="content">Not at all. Go has an error type, and Go functions have the ability to return zero, one, two, or more items, ordered however the developer likes. An error may be among those, as desired, and populated as desired.<p>Some software also writes to both STDOUT and STDERR.</div><br/><div id="42448564" class="c"><input type="checkbox" id="c-42448564" checked=""/><div class="controls bullet"><span class="by">gf000</span><span>|</span><a href="#42448501">root</a><span>|</span><a href="#42448528">parent</a><span>|</span><a href="#42448478">next</a><span>|</span><label class="collapse" for="c-42448564">[-]</label><label class="expand" for="c-42448564">[1 more]</label></div><br/><div class="children"><div class="content">I know, special cased may have been better worded as &quot;just a convention&quot;. My point is, this is not much different than using a thread-local variable, like errno, and adds useless confusion - your return values represent n*m values, while there is only n+m case with proper error semantics.<p>Re STDERR: but shells don&#x27;t decide whether a program execution failed on having written to STDERR, but by the returned singular error code.</div><br/></div></div></div></div></div></div></div></div><div id="42448478" class="c"><input type="checkbox" id="c-42448478" checked=""/><div class="controls bullet"><span class="by">tzahifadida</span><span>|</span><a href="#42448501">prev</a><span>|</span><a href="#42448668">next</a><span>|</span><label class="collapse" for="c-42448478">[-]</label><label class="expand" for="c-42448478">[3 more]</label></div><br/><div class="children"><div class="content">I arrived to a similar conclusion. I come from Java and in Java you have exceptions with TryCatch clauses and declaring them in function signatures. It works fairly well but very difficult and not idiomatic to Golang.<p>Therefor, I created a simple rule. If you do not know what this error means to the user yet then let it stay a fmt.errorf(&quot;xx:%w&quot;,err). If you do, wrap it in your own custom ServerError struct and return that type from now on. Do not change the meaning of ServerError even if you wrap the Error with another ServerError.</div><br/><div id="42448485" class="c"><input type="checkbox" id="c-42448485" checked=""/><div class="controls bullet"><span class="by">RVuRnvbM2e</span><span>|</span><a href="#42448478">parent</a><span>|</span><a href="#42448668">next</a><span>|</span><label class="collapse" for="c-42448485">[-]</label><label class="expand" for="c-42448485">[2 more]</label></div><br/><div class="children"><div class="content">It is telling that you come from Java with this opinion. OP&#x27;s approach is certainly not idiomatic Go.</div><br/><div id="42448646" class="c"><input type="checkbox" id="c-42448646" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42448478">root</a><span>|</span><a href="#42448485">parent</a><span>|</span><a href="#42448668">next</a><span>|</span><label class="collapse" for="c-42448646">[-]</label><label class="expand" for="c-42448646">[1 more]</label></div><br/><div class="children"><div class="content">Idiomatic here means no idiom suggested really. So yeah, non-idiomatic.</div><br/></div></div></div></div></div></div><div id="42448668" class="c"><input type="checkbox" id="c-42448668" checked=""/><div class="controls bullet"><span class="by">rollulus</span><span>|</span><a href="#42448478">prev</a><span>|</span><a href="#42448580">next</a><span>|</span><label class="collapse" for="c-42448668">[-]</label><label class="expand" for="c-42448668">[4 more]</label></div><br/><div class="children"><div class="content">This approach is so bad, I don&#x27;t even know where to start. But it&#x27;s all symptoms of their, sorry, incompetence. Take the loadCredentials example on top. If os.ReadFile cannot find the file, it returns an error with string representation: &quot;open cred.json: no such file or directory&quot;. This comes straight from the std lib as it is, a great error. What does the errors.Is(err, os.ErrNotExist) do: prepend &quot;file not found&quot; to it, rendering: &quot;file not found: open cred.json: no such file or directory&quot;. So this adds exactly nothing. The next if will prepend &quot;failed to read file&quot; to it, again, adding nothing as well. The two errors checks should be replaced by one if statement, optionally wrapping it with a context string but I cannot think of any use. Then the next step, error handling of verifyCredentials. I can only guess what it does, but assume that it returns an &quot;username &#x27;foo bar&#x27; cannot contain spaces&quot; error. Does prepending &quot;invalid credentials&quot; help anything? Nope, so the whole if can be removed as well. No surprise your errors get clunky if you make them clunky.<p>I have more pressing things to do than dissect this article line by line, but let me suffice that I feel sorry for newcomers to the language that an article like this is so high on HN. Back in the days there was just Dave Cheney&#x27;s material to read [1], and it was excellent. It&#x27;s unfortunately outdated in certain regards (e.g. with new Is&#x2F;As functionality in the errors package for inspection and the %w formatting directive in fmt.Errorf) but it&#x27;s still an excellent article.<p>[1]: <a href="https:&#x2F;&#x2F;dave.cheney.net&#x2F;2016&#x2F;04&#x2F;27&#x2F;dont-just-check-errors-handle-them-gracefully" rel="nofollow">https:&#x2F;&#x2F;dave.cheney.net&#x2F;2016&#x2F;04&#x2F;27&#x2F;dont-just-check-errors-ha...</a></div><br/><div id="42449004" class="c"><input type="checkbox" id="c-42449004" checked=""/><div class="controls bullet"><span class="by">mariusor</span><span>|</span><a href="#42448668">parent</a><span>|</span><a href="#42448981">next</a><span>|</span><label class="collapse" for="c-42449004">[-]</label><label class="expand" for="c-42449004">[1 more]</label></div><br/><div class="children"><div class="content">As someone that ended up implementing something very similar to TFA, I&#x27;d like to ask in which way can you pass errors from 3 layers deep in your stack to the top layer and maintain context?<p>Ie, when I can&#x27;t find cred.json I want to return a 401 error, but when I can&#x27;t find the entity cred.json is supposed to be owned by I want to return 404. How can one &quot;not incompetent&quot; Go developer solve this and distinguish between the two errors?</div><br/></div></div><div id="42448981" class="c"><input type="checkbox" id="c-42448981" checked=""/><div class="controls bullet"><span class="by">vl</span><span>|</span><a href="#42448668">parent</a><span>|</span><a href="#42449004">prev</a><span>|</span><a href="#42448862">next</a><span>|</span><label class="collapse" for="c-42448981">[-]</label><label class="expand" for="c-42448981">[1 more]</label></div><br/><div class="children"><div class="content">&gt;it returns an error with string representation: &quot;open cred.json: no such file or directory&quot;. This comes straight from the std lib as it is, a great error.<p>It’s a terrible error. It’s not structured, so you can’t aggregate it effectively in logs, on top of that it leaks potential secret, so you can’t return it from RPC handler.</div><br/></div></div><div id="42448862" class="c"><input type="checkbox" id="c-42448862" checked=""/><div class="controls bullet"><span class="by">franticgecko3</span><span>|</span><a href="#42448668">parent</a><span>|</span><a href="#42448981">prev</a><span>|</span><a href="#42448580">next</a><span>|</span><label class="collapse" for="c-42448862">[-]</label><label class="expand" for="c-42448862">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m worried readers of this article will be horrified and believe this kind of DIY error handling is necessary in Go.<p>The author has attempted to fix their unidiomatic error handling with an even more unidiomatic error framework.<p>New Go users: most of the time returning an error without checking its value or adding extra context is the right thing to do</div><br/></div></div></div></div><div id="42448580" class="c"><input type="checkbox" id="c-42448580" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42448668">prev</a><span>|</span><a href="#42448591">next</a><span>|</span><label class="collapse" for="c-42448580">[-]</label><label class="expand" for="c-42448580">[1 more]</label></div><br/><div class="children"><div class="content">When I thought about errors&#x2F;exceptions, I basically came to the same conclusion. To reiterate or add to tfa: standard formulations, expected vs. happened, reasonable context visible in logs, error trees, automatic http&#x2F;etc codes, tidy client messages in prod, reasonable distinction between: unexpected, semi-normal, programming error, likely fatal.<p>Not sure why most (all?) programming languages have such poor support for errors. Coding may feel like 2024, but error handling like 1980. Anyone with 2-5 years of any programming experience (in where errors do happen and they choose to handle them) will come to similar ideas.<p>Also the fact that try {} and catch&#x2F;finally {} are always three different scopes is just idiotic. It should be try {catch{} finally{}}, what in the cargo cult that {}{}{} is? Everyone copies it blindly from grammar to grammar.</div><br/></div></div><div id="42448591" class="c"><input type="checkbox" id="c-42448591" checked=""/><div class="controls bullet"><span class="by">ikiris</span><span>|</span><a href="#42448580">prev</a><span>|</span><a href="#42447840">next</a><span>|</span><label class="collapse" for="c-42448591">[-]</label><label class="expand" for="c-42448591">[1 more]</label></div><br/><div class="children"><div class="content">The fact that this code also has gorm in it in one of the examples is neither supportive of the proposal’s fit for the language, nor really surprising.</div><br/></div></div><div id="42447840" class="c"><input type="checkbox" id="c-42447840" checked=""/><div class="controls bullet"><span class="by">omeid2</span><span>|</span><a href="#42448591">prev</a><span>|</span><a href="#42448434">next</a><span>|</span><label class="collapse" for="c-42447840">[-]</label><label class="expand" for="c-42447840">[1 more]</label></div><br/><div class="children"><div class="content">This is a cry for sum types.</div><br/></div></div><div id="42448434" class="c"><input type="checkbox" id="c-42448434" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#42447840">prev</a><span>|</span><a href="#42448454">next</a><span>|</span><label class="collapse" for="c-42448434">[-]</label><label class="expand" for="c-42448434">[1 more]</label></div><br/><div class="children"><div class="content">Too much writing and lack of diagramming is a sign of digging through the rabitt hole.</div><br/></div></div><div id="42448454" class="c"><input type="checkbox" id="c-42448454" checked=""/><div class="controls bullet"><span class="by">bilbo-b-baggins</span><span>|</span><a href="#42448434">prev</a><span>|</span><label class="collapse" for="c-42448454">[-]</label><label class="expand" for="c-42448454">[3 more]</label></div><br/><div class="children"><div class="content">Bro got dragged so hard in the comments he took his site down. Oof.</div><br/><div id="42448879" class="c"><input type="checkbox" id="c-42448879" checked=""/><div class="controls bullet"><span class="by">asabla</span><span>|</span><a href="#42448454">parent</a><span>|</span><a href="#42448700">next</a><span>|</span><label class="collapse" for="c-42448879">[-]</label><label class="expand" for="c-42448879">[1 more]</label></div><br/><div class="children"><div class="content">more like hug of death from HN users. Since the site is back up and working again</div><br/></div></div><div id="42448700" class="c"><input type="checkbox" id="c-42448700" checked=""/><div class="controls bullet"><span class="by">jatins</span><span>|</span><a href="#42448454">parent</a><span>|</span><a href="#42448879">prev</a><span>|</span><label class="collapse" for="c-42448700">[-]</label><label class="expand" for="c-42448700">[1 more]</label></div><br/><div class="children"><div class="content">I mean their intentions are good but if I worked at a place that made me use that error package I&#x27;d not have a good time<p>In general with golang, if something is not idiomatic Go then don&#x27;t try too hard to fit constructs from other languages into it. Even the use of lodash like packages feels awkward in Go</div><br/></div></div></div></div></div></div></div></div></div></body></html>