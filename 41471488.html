<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725699671405" as="style"/><link rel="stylesheet" href="styles.css?v=1725699671405"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mariusbancila.ro/blog/2024/09/06/whats-new-in-c26-part-1/">What&#x27;s new in C++26 (part 1)</a> <span class="domain">(<a href="https://mariusbancila.ro">mariusbancila.ro</a>)</span></div><div class="subtext"><span>jandeboevrie</span> | <span>36 comments</span></div><br/><div><div id="41472524" class="c"><input type="checkbox" id="c-41472524" checked=""/><div class="controls bullet"><span class="by">alecco</span><span>|</span><a href="#41472101">next</a><span>|</span><label class="collapse" for="c-41472524">[-]</label><label class="expand" for="c-41472524">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20240907061007&#x2F;https:&#x2F;&#x2F;mariusbancila.ro&#x2F;blog&#x2F;2024&#x2F;09&#x2F;06&#x2F;whats-new-in-c26-part-1&#x2F;" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20240907061007&#x2F;https:&#x2F;&#x2F;mariusban...</a><p>It seems to be down.</div><br/></div></div><div id="41472101" class="c"><input type="checkbox" id="c-41472101" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41472524">prev</a><span>|</span><a href="#41472132">next</a><span>|</span><label class="collapse" for="c-41472101">[-]</label><label class="expand" for="c-41472101">[4 more]</label></div><br/><div class="children"><div class="content">Exciting as it may be, to be fully available for portable codebases maybe around 2030, given the current velocity of compilers adoption of ongoing standards, even among the big three.<p>As of today, C++17 is the latest  one can aspire to use for portable code, and better not making use of parallel STL features.</div><br/><div id="41472310" class="c"><input type="checkbox" id="c-41472310" checked=""/><div class="controls bullet"><span class="by">Kelteseth</span><span>|</span><a href="#41472101">parent</a><span>|</span><a href="#41472132">next</a><span>|</span><label class="collapse" for="c-41472310">[-]</label><label class="expand" for="c-41472310">[3 more]</label></div><br/><div class="children"><div class="content">I would argue C++20 is totally fine. MSVC does not yet has a C++23 flag and it will be internally replaced with &#x27;latest&#x27;, aka some C++26 features, when you use it. This took us by surprise, because they deprecated some enum conversions and thus our clang-cl CI failed for openCV, with the latest llvm. I still fail to understand why enabling a specific C++ version, automatically means that it is considered stable. At least give use C++23-experimental or something &#x2F;rant.</div><br/><div id="41472338" class="c"><input type="checkbox" id="c-41472338" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41472101">root</a><span>|</span><a href="#41472310">parent</a><span>|</span><a href="#41472132">next</a><span>|</span><label class="collapse" for="c-41472338">[-]</label><label class="expand" for="c-41472338">[2 more]</label></div><br/><div class="children"><div class="content">Writing C++20 code without modules, ranges, or concepts, is like, what is the point.<p>Naturally when code portability doesn&#x27;t matter, it is another thing.<p>All my C++ side projects are written against C++latest on Visual C++, and make full use of modules and concepts.</div><br/><div id="41472549" class="c"><input type="checkbox" id="c-41472549" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#41472101">root</a><span>|</span><a href="#41472338">parent</a><span>|</span><a href="#41472132">next</a><span>|</span><label class="collapse" for="c-41472549">[-]</label><label class="expand" for="c-41472549">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Writing C++20 code without modules, ranges, or concepts, is like, what is the point.<p>* std::span is in! <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;q&#x2F;45723819&#x2F;1593077" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;q&#x2F;45723819&#x2F;1593077</a><p>* Designated initializers (like in C99)<p>* Spaceship operator and default comparison ops<p>* More language constructs can be constexpr&#x27;ed<p>* Better structured binding<p>* using on enums<p>* Don&#x27;t need to say &quot;typename&quot; as much :-)<p>* Bunch of minor improvements to the standard library<p>Note I did not say coroutines. I still don&#x27;t understand how that boondoggle made it into the language the way that it has.</div><br/></div></div></div></div></div></div></div></div><div id="41472132" class="c"><input type="checkbox" id="c-41472132" checked=""/><div class="controls bullet"><span class="by">sohamgovande</span><span>|</span><a href="#41472101">prev</a><span>|</span><a href="#41471743">next</a><span>|</span><label class="collapse" for="c-41472132">[-]</label><label class="expand" for="c-41472132">[10 more]</label></div><br/><div class="children"><div class="content">One major gripe I have with these C++ updates is that the proportion of codebases that <i>actually use</i> recent C++ features (cpp17, cpp20, cpp23) is very close to zero. The more and more esoteric this language becomes, the fewer people who can actually master it.<p>Source: I&#x27;ve been writing C++ for 8 years.</div><br/><div id="41472426" class="c"><input type="checkbox" id="c-41472426" checked=""/><div class="controls bullet"><span class="by">Calavar</span><span>|</span><a href="#41472132">parent</a><span>|</span><a href="#41472399">next</a><span>|</span><label class="collapse" for="c-41472426">[-]</label><label class="expand" for="c-41472426">[2 more]</label></div><br/><div class="children"><div class="content">You can find  std::string_view (C++17) in Google&#x27;s WebGPU implementation [1], static_assert (C++17) in Protobufs [2], &lt;bit&gt; (C++20) in React Native [3], and std::format (C++20) in Cuda Core Compute [4]. So the big names in tech aren&#x27;t afraid to add -std=c++20 to their build scripts. On the other hand, C++23 features aren&#x27;t as common yet, but it&#x27;s still very fresh and MSVC support is WIP.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;dawn&#x2F;blob&#x2F;40cf7fd7bc06f871fc5e482338dffa3a8ba3acfb&#x2F;src&#x2F;tint&#x2F;utils&#x2F;cli&#x2F;cli.cc#L135">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;dawn&#x2F;blob&#x2F;40cf7fd7bc06f871fc5e4823...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;blob&#x2F;c964e143d97b16fd76a1d00486810cc05874f3ee&#x2F;hpb&#x2F;repeated_field.h#L80">https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;blob&#x2F;c964e143d97...</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;react-native&#x2F;blob&#x2F;77b3a8bdd6164b4c2407e53cb0e27075c3ea7213&#x2F;packages&#x2F;react-native&#x2F;ReactCommon&#x2F;yoga&#x2F;yoga&#x2F;enums&#x2F;YogaEnums.h#L10">https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;react-native&#x2F;blob&#x2F;77b3a8bdd6164b...</a><p>[4] <a href="https:&#x2F;&#x2F;github.com&#x2F;NVIDIA&#x2F;cccl&#x2F;blob&#x2F;07fef970a33ae120c8ff2a9efea3e83d9d903cff&#x2F;c&#x2F;src&#x2F;reduce.cu#L465">https:&#x2F;&#x2F;github.com&#x2F;NVIDIA&#x2F;cccl&#x2F;blob&#x2F;07fef970a33ae120c8ff2a9e...</a></div><br/><div id="41472542" class="c"><input type="checkbox" id="c-41472542" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41472132">root</a><span>|</span><a href="#41472426">parent</a><span>|</span><a href="#41472399">next</a><span>|</span><label class="collapse" for="c-41472542">[-]</label><label class="expand" for="c-41472542">[1 more]</label></div><br/><div class="children"><div class="content">Imagine how widespread use of Java 8, .NET Framework, Python 2, C89 is still around the industry and now apply it to C++ versions.<p>There is a reason why C++17 is the best we can currently hope for in what concerns portable code, given the actual support across industry compilers, and company project guidelines.<p>Many embedded shops might still be discussing between adopting C++11 or C++14.</div><br/></div></div></div></div><div id="41472399" class="c"><input type="checkbox" id="c-41472399" checked=""/><div class="controls bullet"><span class="by">fsloth</span><span>|</span><a href="#41472132">parent</a><span>|</span><a href="#41472426">prev</a><span>|</span><a href="#41472312">next</a><span>|</span><label class="collapse" for="c-41472399">[-]</label><label class="expand" for="c-41472399">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been writing C++ over 20 years. The language is a freak show, combining the solid industrial tooling and userbase, with some development efforts led by a clown-car full of pretentious academics and people who just want to bolt on new stuff for no good reason except to ”keep the language fresh”.<p>C++ is not supposed to be fresh. It’s supposed to be portable, and allow fine tuning of programs to bare metal while allowing a sort of high level implementation of API:s (but often fragile and badly designed).<p>Some new features are excellent, others are not, and the history is plagued with weird historical feature gaps obvious to anyone familiar at all with more consistent languages.<p>So if something feels weird, there is always a good chance it’s not you, it’s the language (committee).</div><br/></div></div><div id="41472312" class="c"><input type="checkbox" id="c-41472312" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41472132">parent</a><span>|</span><a href="#41472399">prev</a><span>|</span><a href="#41472194">next</a><span>|</span><label class="collapse" for="c-41472312">[-]</label><label class="expand" for="c-41472312">[2 more]</label></div><br/><div class="children"><div class="content">&gt; the proportion of codebases that <i>actually</i> use recent C++ features (cpp17, cpp20, cpp23) is very close to zero<p>~Nobody uses <i>all</i> the recent features, but some new C++20 stuff <i>does</i> get adopted very quickly, like 3-way comparisons, constinit, abbreviated function template, etc.<p>For C++23, support for it is severely lacking in MSVC at least, so that&#x27;s going to severely impact users.</div><br/><div id="41472555" class="c"><input type="checkbox" id="c-41472555" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41472132">root</a><span>|</span><a href="#41472312">parent</a><span>|</span><a href="#41472194">next</a><span>|</span><label class="collapse" for="c-41472555">[-]</label><label class="expand" for="c-41472555">[1 more]</label></div><br/><div class="children"><div class="content">Other compilers are hardly any better.<p>There can&#x27;t be full C++23 support when they are still busy adding C++17 and C++20 features.</div><br/></div></div></div></div><div id="41472194" class="c"><input type="checkbox" id="c-41472194" checked=""/><div class="controls bullet"><span class="by">jb1991</span><span>|</span><a href="#41472132">parent</a><span>|</span><a href="#41472312">prev</a><span>|</span><a href="#41472300">next</a><span>|</span><label class="collapse" for="c-41472194">[-]</label><label class="expand" for="c-41472194">[1 more]</label></div><br/><div class="children"><div class="content">In some ways, you’re not wrong. In other ways, there’s been extremely broad support for some major new features in the language in recent years, like coroutines and concepts.</div><br/></div></div><div id="41472300" class="c"><input type="checkbox" id="c-41472300" checked=""/><div class="controls bullet"><span class="by">TrainedMonkey</span><span>|</span><a href="#41472132">parent</a><span>|</span><a href="#41472194">prev</a><span>|</span><a href="#41472236">next</a><span>|</span><label class="collapse" for="c-41472300">[-]</label><label class="expand" for="c-41472300">[1 more]</label></div><br/><div class="children"><div class="content">Same with cars, buildings made out of newly discovered building materials, and electronics. I would argue this is a good thing for the same roughly the same reasons - rewriting software to use latest and greatest language feature is usually not efficient.</div><br/></div></div><div id="41472236" class="c"><input type="checkbox" id="c-41472236" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#41472132">parent</a><span>|</span><a href="#41472300">prev</a><span>|</span><a href="#41471743">next</a><span>|</span><label class="collapse" for="c-41472236">[-]</label><label class="expand" for="c-41472236">[2 more]</label></div><br/><div class="children"><div class="content">This is intentional.<p>Most of the new features are for library writers.</div><br/><div id="41472367" class="c"><input type="checkbox" id="c-41472367" checked=""/><div class="controls bullet"><span class="by">fsloth</span><span>|</span><a href="#41472132">root</a><span>|</span><a href="#41472236">parent</a><span>|</span><a href="#41471743">next</a><span>|</span><label class="collapse" for="c-41472367">[-]</label><label class="expand" for="c-41472367">[1 more]</label></div><br/><div class="children"><div class="content">I don’t really get this argument. Large C++ codebases are generally divided to libraries. The internal libraries and vendor libraries should both be of high quality. I’m not familiar with industrial use cases where every C++ user would not be a library writer.</div><br/></div></div></div></div></div></div><div id="41471743" class="c"><input type="checkbox" id="c-41471743" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#41472132">prev</a><span>|</span><a href="#41471662">next</a><span>|</span><label class="collapse" for="c-41471743">[-]</label><label class="expand" for="c-41471743">[1 more]</label></div><br/><div class="children"><div class="content">User-generated static_assert messages would make it easier to build games that can be played entirely using compiler error messages.  Something like this old IOCCC entry but nicer:<p><a href="https:&#x2F;&#x2F;www.ioccc.org&#x2F;years.html#1994_westley" rel="nofollow">https:&#x2F;&#x2F;www.ioccc.org&#x2F;years.html#1994_westley</a></div><br/></div></div><div id="41471662" class="c"><input type="checkbox" id="c-41471662" checked=""/><div class="controls bullet"><span class="by">giancarlostoro</span><span>|</span><a href="#41471743">prev</a><span>|</span><a href="#41471855">next</a><span>|</span><label class="collapse" for="c-41471662">[-]</label><label class="expand" for="c-41471662">[1 more]</label></div><br/><div class="children"><div class="content">Some of those features look like features I&#x27;ve been seeing in all major languages I use. They&#x27;re mostly ergonomic for the developer.</div><br/></div></div><div id="41471855" class="c"><input type="checkbox" id="c-41471855" checked=""/><div class="controls bullet"><span class="by">sixthDot</span><span>|</span><a href="#41471662">prev</a><span>|</span><a href="#41472036">next</a><span>|</span><label class="collapse" for="c-41471855">[-]</label><label class="expand" for="c-41471855">[8 more]</label></div><br/><div class="children"><div class="content">&gt; if (auto [to, ec] = std::to_chars(p, last, 42))<p>I&#x27;m not into plusplus, however i&#x27;m curious. How the tuple get evaluated to a condition ? is that lowered to if `to &amp;&amp; ec` ?</div><br/><div id="41471955" class="c"><input type="checkbox" id="c-41471955" checked=""/><div class="controls bullet"><span class="by">rnallandigal</span><span>|</span><a href="#41471855">parent</a><span>|</span><a href="#41471912">next</a><span>|</span><label class="collapse" for="c-41471955">[-]</label><label class="expand" for="c-41471955">[4 more]</label></div><br/><div class="children"><div class="content">The std::to_chars function returns an object of type std::to_chars_result, which defines an operator bool() checking if ec == std::errc[0].<p>The if statement determines which branch to take based on the value of the condition. This value is contextually converted to a bool and evaluated[1].<p>[0] <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;utility&#x2F;to_chars_result" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;utility&#x2F;to_chars_result</a><p>[1] <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;if#Condition" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;if#Condition</a></div><br/><div id="41472057" class="c"><input type="checkbox" id="c-41472057" checked=""/><div class="controls bullet"><span class="by">quietbritishjim</span><span>|</span><a href="#41471855">root</a><span>|</span><a href="#41471955">parent</a><span>|</span><a href="#41471912">next</a><span>|</span><label class="collapse" for="c-41472057">[-]</label><label class="expand" for="c-41472057">[3 more]</label></div><br/><div class="children"><div class="content">But there are two variables being defined by the destructuring. I believe OP&#x27;s question was whether there&#x27;s a rule for which gets chosen for the condition, rather than about contextual conversion to bool in general (which happens even when there&#x27;s no initialisation in the if statement at all).<p>Your comment seems to imply the condition is evaluated before initialising the variable(s) at all; is that what you meant? If so, this beast would work (even though it&#x27;s undefined behaviour to construct a std::string from nullptr, and std::string is not convertible to bool):<p><pre><code>   const char* foo() &#x2F;&#x2F; may return nullptr
   if (std::string s = foo())</code></pre></div><br/><div id="41472516" class="c"><input type="checkbox" id="c-41472516" checked=""/><div class="controls bullet"><span class="by">alecco</span><span>|</span><a href="#41471855">root</a><span>|</span><a href="#41472057">parent</a><span>|</span><a href="#41472389">next</a><span>|</span><label class="collapse" for="c-41472516">[-]</label><label class="expand" for="c-41472516">[1 more]</label></div><br/><div class="children"><div class="content">What is assigned (std::to_chars_result) is considered by the if condition. The left hand side of the assignment is then split in two. Just like if it were if (auto res = std::to_chars(p, last, 42)). The split with the [to, ec] makes it convenient inside the if body.</div><br/></div></div><div id="41472389" class="c"><input type="checkbox" id="c-41472389" checked=""/><div class="controls bullet"><span class="by">wrasee</span><span>|</span><a href="#41471855">root</a><span>|</span><a href="#41472057">parent</a><span>|</span><a href="#41472516">prev</a><span>|</span><a href="#41471912">next</a><span>|</span><label class="collapse" for="c-41472389">[-]</label><label class="expand" for="c-41472389">[1 more]</label></div><br/><div class="children"><div class="content">Yes exactly.  My hunch is to remember that in `auto [to, ec] = std::to_chars(p, last, 42)` the two names `to` and `ec` are not &quot;real&quot; variables&#x2F;objects, but names bound to parts of the object returned to by `std::to_chars`.  So fundamentally, `std::to_chars` returns a `std::to_chars_result`, that _is_ the return value and what is then contextually converted to bool for evaluation of the condition.  It&#x27;s then some C++17 compiler thing that separately associates the two names `to` and `ec` with the two parts of that returned tuple object.<p>But I could be wrong, the paper for the feature is linked but I didn&#x27;t read it (!).</div><br/></div></div></div></div></div></div><div id="41471912" class="c"><input type="checkbox" id="c-41471912" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#41471855">parent</a><span>|</span><a href="#41471955">prev</a><span>|</span><a href="#41472036">next</a><span>|</span><label class="collapse" for="c-41471912">[-]</label><label class="expand" for="c-41471912">[3 more]</label></div><br/><div class="children"><div class="content">`ec` is an error code.
What happens is a conversion to bool, see `operátor bool()` <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;utility&#x2F;to_chars_result" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;utility&#x2F;to_chars_result</a><p>And no, don&#x27;t ask mé why somebody might think that a bool is a suitable type to check for success or error.</div><br/><div id="41472078" class="c"><input type="checkbox" id="c-41472078" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41471855">root</a><span>|</span><a href="#41471912">parent</a><span>|</span><a href="#41472036">next</a><span>|</span><label class="collapse" for="c-41472078">[-]</label><label class="expand" for="c-41472078">[2 more]</label></div><br/><div class="children"><div class="content">What is wrong with your keyboard lol</div><br/><div id="41472117" class="c"><input type="checkbox" id="c-41472117" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#41471855">root</a><span>|</span><a href="#41472078">parent</a><span>|</span><a href="#41472036">next</a><span>|</span><label class="collapse" for="c-41472117">[-]</label><label class="expand" for="c-41472117">[1 more]</label></div><br/><div class="children"><div class="content">Autocomplete.</div><br/></div></div></div></div></div></div></div></div><div id="41472036" class="c"><input type="checkbox" id="c-41472036" checked=""/><div class="controls bullet"><span class="by">logicchains</span><span>|</span><a href="#41471855">prev</a><span>|</span><a href="#41471666">next</a><span>|</span><label class="collapse" for="c-41472036">[-]</label><label class="expand" for="c-41472036">[2 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t mention the most exciting thing coming: static reflection. Finally no need to manually implement printing or serialisation functions for every struct.</div><br/><div id="41472094" class="c"><input type="checkbox" id="c-41472094" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41472036">parent</a><span>|</span><a href="#41471666">next</a><span>|</span><label class="collapse" for="c-41472094">[-]</label><label class="expand" for="c-41472094">[1 more]</label></div><br/><div class="children"><div class="content">Probably, it isn&#x27;t fully backed in, and can happen the same as contracts in C++20.</div><br/></div></div></div></div><div id="41471666" class="c"><input type="checkbox" id="c-41471666" checked=""/><div class="controls bullet"><span class="by">bun_terminator</span><span>|</span><a href="#41472036">prev</a><span>|</span><a href="#41471659">next</a><span>|</span><label class="collapse" for="c-41471666">[-]</label><label class="expand" for="c-41471666">[6 more]</label></div><br/><div class="children"><div class="content">.</div><br/><div id="41471774" class="c"><input type="checkbox" id="c-41471774" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#41471666">parent</a><span>|</span><a href="#41471760">next</a><span>|</span><label class="collapse" for="c-41471774">[-]</label><label class="expand" for="c-41471774">[2 more]</label></div><br/><div class="children"><div class="content">std::ignore doesn&#x27;t work in the context of structured bindings. And even if it did, &quot;we already have this&quot; has never stopped the C++ committee from adding something before :)</div><br/><div id="41471854" class="c"><input type="checkbox" id="c-41471854" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#41471666">root</a><span>|</span><a href="#41471774">parent</a><span>|</span><a href="#41471760">next</a><span>|</span><label class="collapse" for="c-41471854">[-]</label><label class="expand" for="c-41471854">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the &quot;skill&quot; of the commitee to discuss some feature for a really looooooong time and then come up with a solution which is going to be (half) fixed in the next standard always astonishes mé :).<p>I guess with C++38 we&#x27;ll get a `always_definetly_ignore_this_wothout_any_diagnostic_whatsoever`.</div><br/></div></div></div></div><div id="41471760" class="c"><input type="checkbox" id="c-41471760" checked=""/><div class="controls bullet"><span class="by">beached_whale</span><span>|</span><a href="#41471666">parent</a><span>|</span><a href="#41471774">prev</a><span>|</span><a href="#41471831">next</a><span>|</span><label class="collapse" for="c-41471760">[-]</label><label class="expand" for="c-41471760">[2 more]</label></div><br/><div class="children"><div class="content">sure about that?  It does, happen to, work on libstdc++&#x2F;libc++&#x2F;MS STL but it&#x27;s not specified to work anywhere but std::tie.  The existing practice is to cast to void.</div><br/><div id="41471793" class="c"><input type="checkbox" id="c-41471793" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#41471666">root</a><span>|</span><a href="#41471760">parent</a><span>|</span><a href="#41471831">next</a><span>|</span><label class="collapse" for="c-41471793">[-]</label><label class="expand" for="c-41471793">[1 more]</label></div><br/><div class="children"><div class="content">can you show an example how? I can&#x27;t find a case where std::ignore compiles inside a structured binding declaration.<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;sjefeGvPf" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;sjefeGvPf</a>
<a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;8a7Ps4KdW" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;8a7Ps4KdW</a></div><br/></div></div></div></div><div id="41471831" class="c"><input type="checkbox" id="c-41471831" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#41471666">parent</a><span>|</span><a href="#41471760">prev</a><span>|</span><a href="#41471659">next</a><span>|</span><label class="collapse" for="c-41471831">[-]</label><label class="expand" for="c-41471831">[1 more]</label></div><br/><div class="children"><div class="content">No, that&#x27;s why `maybe_unused` has been needed.</div><br/></div></div></div></div><div id="41471659" class="c"><input type="checkbox" id="c-41471659" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#41471666">prev</a><span>|</span><label class="collapse" for="c-41471659">[-]</label><label class="expand" for="c-41471659">[2 more]</label></div><br/><div class="children"><div class="content">Leading with &quot;Specifying a reason for deleting a function&quot; then following up with &quot;Placeholder variables with no name&quot; did make me check the date of the article. It wasn&#x27;t April 1.<p>The standards committee are thorough in their mission to including everything and the kitchen sink in C++.</div><br/><div id="41472086" class="c"><input type="checkbox" id="c-41472086" checked=""/><div class="controls bullet"><span class="by">omnicognate</span><span>|</span><a href="#41471659">parent</a><span>|</span><label class="collapse" for="c-41472086">[-]</label><label class="expand" for="c-41472086">[1 more]</label></div><br/><div class="children"><div class="content">C++ has certainly had a lot added, but I don&#x27;t get your point regarding these particular two features. They seem quite minor, useful, easily implemented and unlikely to interact problematically with other things.</div><br/></div></div></div></div></div></div></div></div></div></body></html>