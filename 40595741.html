<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717750850254" as="style"/><link rel="stylesheet" href="styles.css?v=1717750850254"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://edw.is/learning-vulkan/">I learned Vulkan and wrote a small game engine with it</a> <span class="domain">(<a href="https://edw.is">edw.is</a>)</span></div><div class="subtext"><span>eliasdaler</span> | <span>208 comments</span></div><br/><div><div id="40600804" class="c"><input type="checkbox" id="c-40600804" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40601605">next</a><span>|</span><label class="collapse" for="c-40600804">[-]</label><label class="expand" for="c-40600804">[19 more]</label></div><br/><div class="children"><div class="content">This minimalism is very effective.<p>I took the opposite approach, and it has cause great pain. I&#x27;ve been writing a metaverse client in Rust. Right now, it&#x27;s running on another screen, showing an avatar riding a tram through a large steampunk city. I let that run for 12 hours before shipping a new pre-release.<p>This uses Vulkan, but it has WGPU and Rend3 on top. Rend3 offers a very clean API - you create meshes, 2d textures, etc., and &quot;objects&quot;, which reference the meshes and textures. Creating an object puts it on screen. Rust reference counting interlocks everything. It&#x27;s very straightforward to use.<p>All those layers create problems. WGPU tries to support web browsers, Vulkan, Metal, DX11 (recently dropped), DX12, Android, and OpenGL. So it needs a big dev team and changes are hard. WGPU&#x27;s own API is mostly like Vulkan - you still have to do your own GPU memory allocation and synchronization.<p>WGPU has lowest-common-denominator problems. Some of those platforms can&#x27;t support some functions. WGPU doesn&#x27;t support multiple threads updating GPU memory without interference, which Vulkan supports. That&#x27;s how you get content into the GPU without killing the frame rate. Big-world games and clients need that. Also, having to deal with platforms with different concurrency restrictions results in lock conflicts that can kill performance.<p>Rend3 is supposed to be a modest level of glue code to handle synchronization and allocation. Those are hard to do in a general way. Especially synchronization. Rend3 also does frustum culling (which is a big performance win; you&#x27;re not rendering what&#x27;s behind you) and tried to do occlusion culling (which was a performance lose because the compute to do that slowed things down). It also does translucency, which means a depth sort. (Translucent objects are a huge pain. I really need them; I work on worlds with lots of windows, which you can see out of and see in.)<p>The Rust 3D stack people are annoyed with me because I&#x27;ve been pounding on them to fix their stack for three years now. That&#x27;s all volunteer. Vulkan has money behind it and enough users to keep it maintained. Rend3 was recently abandoned by its creator, so now I have to go inside that and fix it. Few people do anything elaborate on WGPU - mostly it&#x27;s 2D games you could have done in Flash, or simple static 3D scenes. Commercial projects continue to use Unity or UE5.<p>If I went directly to Vulkan, I&#x27;d still have to write synchronization, allocation, frustrum culling, and translucency. So that&#x27;s a big switch.<p>Incidentally, Vulkano, the wrapper over Vulkan and Metal, has lowest-common-denominator problems too. It doesn&#x27;t allow concurrent updating of assets in the GPU. Both Vulkan and Metal support that. But, of course, Apple does it differently.</div><br/><div id="40605976" class="c"><input type="checkbox" id="c-40605976" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#40600804">parent</a><span>|</span><a href="#40602084">next</a><span>|</span><label class="collapse" for="c-40605976">[-]</label><label class="expand" for="c-40605976">[2 more]</label></div><br/><div class="children"><div class="content">&gt; WGPU doesn&#x27;t support multiple threads updating GPU memory without interference<p>WGPU uses WebGPU and AFAIK no browser so far supports &quot;threads&quot;. 
<a href="https:&#x2F;&#x2F;gpuweb.github.io&#x2F;gpuweb&#x2F;explainer&#x2F;#multithreading" rel="nofollow">https:&#x2F;&#x2F;gpuweb.github.io&#x2F;gpuweb&#x2F;explainer&#x2F;#multithreading</a>
<a href="https:&#x2F;&#x2F;github.com&#x2F;gpuweb&#x2F;gpuweb&#x2F;issues&#x2F;354">https:&#x2F;&#x2F;github.com&#x2F;gpuweb&#x2F;gpuweb&#x2F;issues&#x2F;354</a><p>And OpenGL never supported &quot;threads&quot;, so anything using OpenGL can&#x27;t either.</div><br/><div id="40606037" class="c"><input type="checkbox" id="c-40606037" checked=""/><div class="controls bullet"><span class="by">exDM69</span><span>|</span><a href="#40600804">root</a><span>|</span><a href="#40605976">parent</a><span>|</span><a href="#40602084">next</a><span>|</span><label class="collapse" for="c-40606037">[-]</label><label class="expand" for="c-40606037">[1 more]</label></div><br/><div class="children"><div class="content">OpenGL can do threads with shared contexts but caveats apply so it is not popular.<p>But even more common is mapping memory in &quot;OpenGL thread&quot; and then letting another thread fill the memory. Quite common is mapping buffers with persistent&#x2F;coherent flags at init, and then leave them mapped.</div><br/></div></div></div></div><div id="40602084" class="c"><input type="checkbox" id="c-40602084" checked=""/><div class="controls bullet"><span class="by">jms55</span><span>|</span><a href="#40600804">parent</a><span>|</span><a href="#40605976">prev</a><span>|</span><a href="#40601927">next</a><span>|</span><label class="collapse" for="c-40602084">[-]</label><label class="expand" for="c-40602084">[5 more]</label></div><br/><div class="children"><div class="content">&gt; All those layers create problems. WGPU tries to support web browsers, Vulkan, Metal, DX11 (recently dropped), DX12, Android, and OpenGL. So it needs a big dev team and changes are hard. WGPU&#x27;s own API is mostly like Vulkan - you still have to do your own GPU memory allocation and synchronization.<p>The first part is true, but the second part is not. Allocation and synchronization is automatic.</div><br/><div id="40602515" class="c"><input type="checkbox" id="c-40602515" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40600804">root</a><span>|</span><a href="#40602084">parent</a><span>|</span><a href="#40601927">next</a><span>|</span><label class="collapse" for="c-40602515">[-]</label><label class="expand" for="c-40602515">[4 more]</label></div><br/><div class="children"><div class="content">Vulkan does not allocate GPU memory for you. Well, it gives you a big block, and then it&#x27;s the problem of the caller to allocate little pieces from that. It&#x27;s like &quot;sbrk&quot; in Linux&#x2F;Unix, which gets memory from the OS. You usually don&#x27;t use &quot;sbrk&quot; directly. Something like &quot;malloc&quot; is used on top of that.</div><br/><div id="40603323" class="c"><input type="checkbox" id="c-40603323" checked=""/><div class="controls bullet"><span class="by">jms55</span><span>|</span><a href="#40600804">root</a><span>|</span><a href="#40602515">parent</a><span>|</span><a href="#40601927">next</a><span>|</span><label class="collapse" for="c-40603323">[-]</label><label class="expand" for="c-40603323">[3 more]</label></div><br/><div class="children"><div class="content">Vulkan doesn&#x27;t, but WebGPU does do synchronization and memory allocation for you.</div><br/><div id="40604768" class="c"><input type="checkbox" id="c-40604768" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#40600804">root</a><span>|</span><a href="#40603323">parent</a><span>|</span><a href="#40601927">next</a><span>|</span><label class="collapse" for="c-40604768">[-]</label><label class="expand" for="c-40604768">[2 more]</label></div><br/><div class="children"><div class="content">WGPU or WebGPU? The former is the Rust crate being discussed in the quote.</div><br/><div id="40604901" class="c"><input type="checkbox" id="c-40604901" checked=""/><div class="controls bullet"><span class="by">jms55</span><span>|</span><a href="#40600804">root</a><span>|</span><a href="#40604768">parent</a><span>|</span><a href="#40601927">next</a><span>|</span><label class="collapse" for="c-40604901">[-]</label><label class="expand" for="c-40604901">[1 more]</label></div><br/><div class="children"><div class="content">Both.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40601927" class="c"><input type="checkbox" id="c-40601927" checked=""/><div class="controls bullet"><span class="by">dc443</span><span>|</span><a href="#40600804">parent</a><span>|</span><a href="#40602084">prev</a><span>|</span><a href="#40601605">next</a><span>|</span><label class="collapse" for="c-40601927">[-]</label><label class="expand" for="c-40601927">[11 more]</label></div><br/><div class="children"><div class="content">&gt; WGPU doesn&#x27;t support multiple threads updating GPU memory without interference, which Vulkan supports.<p>This is really helpful for me to learn about, this is a key thing I want to be able to get right for having a good experience. I really hope WGPU can find a way to add something for this as an extension.</div><br/><div id="40601951" class="c"><input type="checkbox" id="c-40601951" checked=""/><div class="controls bullet"><span class="by">dc443</span><span>|</span><a href="#40600804">root</a><span>|</span><a href="#40601927">parent</a><span>|</span><a href="#40604644">next</a><span>|</span><label class="collapse" for="c-40601951">[-]</label><label class="expand" for="c-40601951">[9 more]</label></div><br/><div class="children"><div class="content">Do you know if these things I found offer any hope for being able to continue rendering a scene smoothly while we handle GPU memory management operations on worker threads?<p><a href="https:&#x2F;&#x2F;gfx-rs.github.io&#x2F;2023&#x2F;11&#x2F;24&#x2F;arcanization.html" rel="nofollow">https:&#x2F;&#x2F;gfx-rs.github.io&#x2F;2023&#x2F;11&#x2F;24&#x2F;arcanization.html</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;gfx-rs&#x2F;wgpu&#x2F;issues&#x2F;5322">https:&#x2F;&#x2F;github.com&#x2F;gfx-rs&#x2F;wgpu&#x2F;issues&#x2F;5322</a></div><br/><div id="40602134" class="c"><input type="checkbox" id="c-40602134" checked=""/><div class="controls bullet"><span class="by">jms55</span><span>|</span><a href="#40600804">root</a><span>|</span><a href="#40601951">parent</a><span>|</span><a href="#40602788">next</a><span>|</span><label class="collapse" for="c-40602134">[-]</label><label class="expand" for="c-40602134">[5 more]</label></div><br/><div class="children"><div class="content">The actual issue is not CPU-side. The issue is GPU-side.<p>The CPU feeds commands (CommandBuffers) telling the GPU what to do over a Queue.<p>WebGPU&#x2F;wgpu&#x2F;dawn only have a single general purpose queue. Meaning any data upload commands (copyBufferToBuffer) you send on the queue block rendering commands from starting.<p>The solution is multiple queues. Modern GPUs have a dedicated transfer&#x2F;copy queue separate from the main general purpose queue.<p>WebGPU&#x2F;wgpu&#x2F;dawn would need to add support for additional queues: <a href="https:&#x2F;&#x2F;github.com&#x2F;gpuweb&#x2F;gpuweb&#x2F;issues?q=is%3Aopen+is%3Aissue+label%3Amulti-queue">https:&#x2F;&#x2F;github.com&#x2F;gpuweb&#x2F;gpuweb&#x2F;issues?q=is%3Aopen+is%3Aiss...</a><p>There&#x27;s also ReBAR&#x2F;SMA, and unified memory (UMA) platforms to consider, but that gets even more complex.</div><br/><div id="40602855" class="c"><input type="checkbox" id="c-40602855" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40600804">root</a><span>|</span><a href="#40602134">parent</a><span>|</span><a href="#40602272">next</a><span>|</span><label class="collapse" for="c-40602855">[-]</label><label class="expand" for="c-40602855">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The solution is multiple queues. Modern GPUs have a dedicated transfer&#x2F;copy queue separate from the main general purpose queue.<p>Yes. This is the big performance advantage of Vulkan over OpenGL. You can get the bulk copying of textures and meshes out of the render thread. So asset loading can be done concurrently with rendering.<p>None of this matters until you&#x27;re rendering something really big. Then it dominates the  problem.</div><br/><div id="40604538" class="c"><input type="checkbox" id="c-40604538" checked=""/><div class="controls bullet"><span class="by">Ono-Sendai</span><span>|</span><a href="#40600804">root</a><span>|</span><a href="#40602855">parent</a><span>|</span><a href="#40602272">next</a><span>|</span><label class="collapse" for="c-40604538">[-]</label><label class="expand" for="c-40604538">[1 more]</label></div><br/><div class="children"><div class="content">I believe you can do loading texture data onto the GPU from another thread with OpenGL with pixel buffer objects: <a href="https:&#x2F;&#x2F;www.khronos.org&#x2F;opengl&#x2F;wiki&#x2F;Pixel_Buffer_Object" rel="nofollow">https:&#x2F;&#x2F;www.khronos.org&#x2F;opengl&#x2F;wiki&#x2F;Pixel_Buffer_Object</a><p>I haven&#x27;t tried it yet, but will try soon for my open-source metaverse Substrata: <a href="https:&#x2F;&#x2F;substrata.info&#x2F;" rel="nofollow">https:&#x2F;&#x2F;substrata.info&#x2F;</a>.</div><br/></div></div></div></div><div id="40602272" class="c"><input type="checkbox" id="c-40602272" checked=""/><div class="controls bullet"><span class="by">dc443</span><span>|</span><a href="#40600804">root</a><span>|</span><a href="#40602134">parent</a><span>|</span><a href="#40602855">prev</a><span>|</span><a href="#40602788">next</a><span>|</span><label class="collapse" for="c-40602272">[-]</label><label class="expand" for="c-40602272">[2 more]</label></div><br/><div class="children"><div class="content">Thank you. I hope to see progress in these areas when I visit later. I was hoping to be able to go all in on wgpu but if there are still legitimate reasons like this one to build a native app, then so be it.</div><br/><div id="40602340" class="c"><input type="checkbox" id="c-40602340" checked=""/><div class="controls bullet"><span class="by">jms55</span><span>|</span><a href="#40600804">root</a><span>|</span><a href="#40602272">parent</a><span>|</span><a href="#40602788">next</a><span>|</span><label class="collapse" for="c-40602340">[-]</label><label class="expand" for="c-40602340">[1 more]</label></div><br/><div class="children"><div class="content">It depends on your requirements and experience level. Using WebGPU is _much_ easier than Vulkan, so if you don&#x27;t have a lot of prior experience with all of computer graphics theory &#x2F; graphics APIs &#x2F; engine design, I would definitely start with WebGPU. You can still get very far with it, and it&#x27;s way easier.</div><br/></div></div></div></div></div></div><div id="40602788" class="c"><input type="checkbox" id="c-40602788" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40600804">root</a><span>|</span><a href="#40601951">parent</a><span>|</span><a href="#40602134">prev</a><span>|</span><a href="#40604644">next</a><span>|</span><label class="collapse" for="c-40602788">[-]</label><label class="expand" for="c-40602788">[3 more]</label></div><br/><div class="children"><div class="content">Short version: hope, yes. Obtain now, no.<p>Long version: <a href="https:&#x2F;&#x2F;github.com&#x2F;gfx-rs&#x2F;wgpu&#x2F;discussions&#x2F;5525">https:&#x2F;&#x2F;github.com&#x2F;gfx-rs&#x2F;wgpu&#x2F;discussions&#x2F;5525</a><p>There&#x27;s a lock stall around resource allocation. The asset-loading threads can stall out the rendering thread.
I can see this in Tracy profiilng, but don&#x27;t fully understand the underlying problem. Looks like one of three locks in WGPU, and I&#x27;m going to have to build WGPU with more profiling scopes to narrow the problem.<p>Very few people have gotten far enough with 3D graphics in Rust to need this.
Most Rust 3D graphics projects are like the OP&#x27;s here - load up a mostly static scene and do a little
with it. If you load all the content before displaying, and don&#x27;t do much dynamic modification beyond moving items around, most of the hard problems can be bypassed. You can move stuff just by changing its transform - that&#x27;s cheap. So you can do a pretty good small-world game without hitting these problems. Scale up to a big world that won&#x27;t all fit in the GPU at once, and things get complicated.<p>I&#x27;m glad to hear from someone else who&#x27;s trying to push on this. Write me at &quot;nagle@animats.com&quot;, please.<p>For a sense of what I&#x27;m doing: <a href="https:&#x2F;&#x2F;video.hardlimit.com&#x2F;w&#x2F;7usCE3v2RrWK6nuoSr4NHJ" rel="nofollow">https:&#x2F;&#x2F;video.hardlimit.com&#x2F;w&#x2F;7usCE3v2RrWK6nuoSr4NHJ</a></div><br/><div id="40604607" class="c"><input type="checkbox" id="c-40604607" checked=""/><div class="controls bullet"><span class="by">Ono-Sendai</span><span>|</span><a href="#40600804">root</a><span>|</span><a href="#40602788">parent</a><span>|</span><a href="#40604644">next</a><span>|</span><label class="collapse" for="c-40604607">[-]</label><label class="expand" for="c-40604607">[2 more]</label></div><br/><div class="children"><div class="content">What I do currently is just limit the amount of data uploaded per frame.  Not ideal but works.</div><br/><div id="40604891" class="c"><input type="checkbox" id="c-40604891" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40600804">root</a><span>|</span><a href="#40604607">parent</a><span>|</span><a href="#40604644">next</a><span>|</span><label class="collapse" for="c-40604891">[-]</label><label class="expand" for="c-40604891">[1 more]</label></div><br/><div class="children"><div class="content">That works better in game dev where you have control over the content. Metaverse dev is like writing a web browser - some people are going to create excessively bulky assets, and you have to do something reasonable with them.</div><br/></div></div></div></div></div></div></div></div><div id="40604644" class="c"><input type="checkbox" id="c-40604644" checked=""/><div class="controls bullet"><span class="by">0x1ceb00da</span><span>|</span><a href="#40600804">root</a><span>|</span><a href="#40601927">parent</a><span>|</span><a href="#40601951">prev</a><span>|</span><a href="#40601605">next</a><span>|</span><label class="collapse" for="c-40604644">[-]</label><label class="expand" for="c-40604644">[1 more]</label></div><br/><div class="children"><div class="content">Do you have any references? I thought all wgpu objects are wrapped with an Arc&lt;Mutex&lt;&gt;&gt;.</div><br/></div></div></div></div></div></div><div id="40601605" class="c"><input type="checkbox" id="c-40601605" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40600804">prev</a><span>|</span><a href="#40597707">next</a><span>|</span><label class="collapse" for="c-40601605">[-]</label><label class="expand" for="c-40601605">[29 more]</label></div><br/><div class="children"><div class="content">I tried learning Vulkan a little more than a year ago and I have no desire to ever touch it again. It really bothers me that we&#x27;re deprecating OpenGL and replacing it with something that&#x27;s ridiculously hard to do anything simple (e.g. doing a spinning cube takes several hundred lines of code).<p>OpenGL was never &quot;easy&quot; but it was at least something a regular person could learn the basics of in a fairly short amount of time. You could go to any big book store, buy some intro to graphics programming book, and get some basic stuff rendering in an afternoon or two. I&#x27;m sure Vulkan is better in some regards but is simply not feasible to expect someone to learn it quickly.<p>Like, imagine the newest Intel&#x2F;ARM&#x2F;AMD chips came along and instead of being able to write C or C++, you&#x27;re being told &quot;We are dropping support for higher level languages so you can only write assembly on this now and it&#x27;ll be faster because you have more control!&quot;  It would be correctly labeled as ridiculous.</div><br/><div id="40606378" class="c"><input type="checkbox" id="c-40606378" checked=""/><div class="controls bullet"><span class="by">account42</span><span>|</span><a href="#40601605">parent</a><span>|</span><a href="#40602110">next</a><span>|</span><label class="collapse" for="c-40606378">[-]</label><label class="expand" for="c-40606378">[2 more]</label></div><br/><div class="children"><div class="content">&gt; e.g. doing a spinning cube takes several hundred lines of code<p>This really doesn&#x27;t mean much. The second cube (or another shape) isn&#x27;t going to double the line count.<p>&gt; OpenGL was never &quot;easy&quot; but it was at least something a regular person could learn the basics of in a fairly short amount of time.<p>The problem is that OpenGL no longer matches current hardware so the naive way to use it is very much suboptimal for performance. Once you move to zero driver overhead techniques for OpenGL then Vulkan is not that much harder.<p>&gt; Like, imagine the newest Intel&#x2F;ARM&#x2F;AMD chips came along and instead of being able to write C or C++, you&#x27;re being told &quot;We are dropping support for higher level languages so you can only write assembly on this now and it&#x27;ll be faster because you have more control!&quot; It would be correctly labeled as ridiculous.<p>Except <i>current</i> Intel&#x2F;ARM&#x2F;AMD chips don&#x27;t support C or C++ and you already have to write assembly ... or use a third-party tool to do the translation from C or C++ for you. That&#x27;s also the goal for Vulkan - to provide a low level standard interface for GPUs on top of which more user friendly abstractions can be layered.</div><br/><div id="40606727" class="c"><input type="checkbox" id="c-40606727" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40606378">parent</a><span>|</span><a href="#40602110">next</a><span>|</span><label class="collapse" for="c-40606727">[-]</label><label class="expand" for="c-40606727">[1 more]</label></div><br/><div class="children"><div class="content">&gt;This really doesn&#x27;t mean much. The second cube (or another shape) isn&#x27;t going to double the line count.<p>It&#x27;s like the difference between &quot;Hello World&quot; in Python and &quot;Hello World&quot; in Java. Doesn&#x27;t matter in the context of a serious software engineering project, but it&#x27;s a significant barrier for beginners.</div><br/></div></div></div></div><div id="40602110" class="c"><input type="checkbox" id="c-40602110" checked=""/><div class="controls bullet"><span class="by">SubjectToChange</span><span>|</span><a href="#40601605">parent</a><span>|</span><a href="#40606378">prev</a><span>|</span><a href="#40605940">next</a><span>|</span><label class="collapse" for="c-40602110">[-]</label><label class="expand" for="c-40602110">[4 more]</label></div><br/><div class="children"><div class="content"><i>It really bothers me that we&#x27;re deprecating OpenGL and replacing it with something that&#x27;s ridiculously hard to do anything simple</i><p>OpenGL is only deprecated on MacOS, AFAIK, it will exist for many years to come.<p><i>I&#x27;m sure Vulkan is better in some regards but is simply not feasible to expect someone to learn it quickly.</i><p>Vulkan is often said to be more of a “GPU API” than a high level graphics API. With that in mind, the complexity of Vulkan is not surprising. It’s just a difficult domain.<p><i>Like, imagine the newest Intel&#x2F;ARM&#x2F;AMD chips came along and instead of being able to write C or C++, you&#x27;re being told &quot;We are dropping support for higher level languages so you can only write assembly on this now and it&#x27;ll be faster because you have more control!&quot; It would be correctly labeled as ridiculous.</i><p>IMO, it’s more like single threaded C&#x2F;C++ vs multithreaded C&#x2F;C++ programming. There is a massive increase in complexity and if you don’t know what you are doing, it’ll blow up in your face and&#x2F;or give you worse performance. However, it’s the only practical path forward.<p>Anyway, OpenGL can basically be implemented on top of Vulkan. Perhaps it is regrettable that the OpenGL standard is no longer being actively developed, but nothing lasts forever.</div><br/><div id="40605870" class="c"><input type="checkbox" id="c-40605870" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40602110">parent</a><span>|</span><a href="#40603918">next</a><span>|</span><label class="collapse" for="c-40605870">[-]</label><label class="expand" for="c-40605870">[1 more]</label></div><br/><div class="children"><div class="content">&gt; OpenGL is only deprecated on MacOS, AFAIK, it will exist for many years to come.<p>It&#x27;s abandondend by Khronos and GPU vendors, which is pretty much the same thing as deprecated unfortunately.</div><br/></div></div><div id="40603918" class="c"><input type="checkbox" id="c-40603918" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40602110">parent</a><span>|</span><a href="#40605870">prev</a><span>|</span><a href="#40605940">next</a><span>|</span><label class="collapse" for="c-40603918">[-]</label><label class="expand" for="c-40603918">[2 more]</label></div><br/><div class="children"><div class="content">Everything you said is fine, and I&#x27;m ok with OpenGL being killed&#x2F;downplayed&#x2F;deprecated.<p>What I would have really preferred is Apple releasing Metal as a standard that anyone could use.  Metal is a pretty nice API that&#x27;s fairly fun and easy to use.  I feel like if we need a &quot;next gen&quot; version of a graphics API, I would have had Vulkan for super low-level stuff, and Metal or DirectX for higher-level stuff.</div><br/><div id="40605881" class="c"><input type="checkbox" id="c-40605881" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40603918">parent</a><span>|</span><a href="#40605940">next</a><span>|</span><label class="collapse" for="c-40605881">[-]</label><label class="expand" for="c-40605881">[1 more]</label></div><br/><div class="children"><div class="content">WebGPU is mostly very similar to Metal (except for a couple of overly &#x27;rigid&#x27; parts which are mostly inherited from Vulkan - most importantly the resource binding via BindGroups and all-in-one PSOs).<p>Also, Metal isn&#x27;t generally a high-level API, it has low-level features which are pretty much like Vulkan or D3D12, you just don&#x27;t need to use those low level features if not needed.</div><br/></div></div></div></div></div></div><div id="40605940" class="c"><input type="checkbox" id="c-40605940" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#40601605">parent</a><span>|</span><a href="#40602110">prev</a><span>|</span><a href="#40601714">next</a><span>|</span><label class="collapse" for="c-40605940">[-]</label><label class="expand" for="c-40605940">[2 more]</label></div><br/><div class="children"><div class="content">If you want OpenGL use ANGLE<p><a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;angle">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;angle</a><p>several phones now ship ANGLE as their only OpenGL support on top of their Vulkan drivers.<p>If you want a modern-ish API that&#x27;s relatively easy and portable use WebGPU via wgpu (rust) or dawn (c++).</div><br/><div id="40606567" class="c"><input type="checkbox" id="c-40606567" checked=""/><div class="controls bullet"><span class="by">debugnik</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40605940">parent</a><span>|</span><a href="#40601714">next</a><span>|</span><label class="collapse" for="c-40606567">[-]</label><label class="expand" for="c-40606567">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not so much a modern API but a modern feature set. Most ANGLE backends give you an ES 3.0 context (except for 3.2 on Vulkan, so the problem is mostly Apple), and all of them lack some useful extensions to narrow the gap between ES and the desktop APIs.</div><br/></div></div></div></div><div id="40601714" class="c"><input type="checkbox" id="c-40601714" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#40601605">parent</a><span>|</span><a href="#40605940">prev</a><span>|</span><a href="#40604207">next</a><span>|</span><label class="collapse" for="c-40601714">[-]</label><label class="expand" for="c-40601714">[19 more]</label></div><br/><div class="children"><div class="content">Vulkan is for writing OpenGL-type libraries against. It&#x27;s advantage is largely that much of the library-level code is moved out of opaque and buggy device drivers and into user-space libraries.</div><br/><div id="40601807" class="c"><input type="checkbox" id="c-40601807" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40601714">parent</a><span>|</span><a href="#40602120">next</a><span>|</span><label class="collapse" for="c-40601807">[-]</label><label class="expand" for="c-40601807">[6 more]</label></div><br/><div class="children"><div class="content">No, I don&#x27;t think that that&#x27;s good reasoning.  They could, if nothing else, make first-party libraries that have a high-level DSL or something that makes it less horrible to use. As it stands it creates a bunch of crappy libraries on top instead of an officially supported API that could also be standardized across operating systems and platforms.<p>The terrible terrible Vulkan API just kind of feels gatekeepey.  They got rid of the only open easy-to-use graphics standard, made <i>NO REPLACEMENT</i>, and then said &quot;oh you should just use this impossible API or let the outside world come up with a fix around it&quot;.</div><br/><div id="40606135" class="c"><input type="checkbox" id="c-40606135" checked=""/><div class="controls bullet"><span class="by">exDM69</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40601807">parent</a><span>|</span><a href="#40601915">next</a><span>|</span><label class="collapse" for="c-40606135">[-]</label><label class="expand" for="c-40606135">[2 more]</label></div><br/><div class="children"><div class="content">Please try again with Vulkan 1.3 and reassess how &quot;terrible&quot; the API is.<p>And use some high level library like vk-bootstrap to do the boring init work.<p>Because once it&#x27;s set up, Vulkan 1.3 is about as easy as OpenGL (if you stick with OpenGL-level stuff).<p>It is easier than WGPU because the RenderPass stuff required in Vulkan 1.0 (and hence WGPU) is gone, removing a lot of boilerplate code.<p>Pipeline barriers are the only &quot;complex&quot; thing remaining but even they are somewhat simplified with the right defaults (sharing mode) and simplifications (set stage masks to all commands, overhead is negligible on desktop devices).<p>Use push descriptors for &quot;bindful&quot; textures, set all your pipelines states dynamic (except blending), and timeline semaphores for sync.<p>For simple stuff (OpenGL level) it&#x27;s a pleasure to work with, and you get rid of all the OpenGL quirks.<p>Complex stuff like bindless texturing and GPU driven rendering is still complex, but that&#x27;s the same in all APIs.<p>It can still be a bit verbose and the init code is too much work (but you do it only once), but after it is set up it&#x27;s quite okay.<p>And if you want OpenGL, use OpenGL. Zink (OpenGL on Vulkan) guarantees that it will be supported, even if GPU vendors stop keeping their GL drivers up to date (has not happened yet).</div><br/><div id="40606441" class="c"><input type="checkbox" id="c-40606441" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40606135">parent</a><span>|</span><a href="#40601915">next</a><span>|</span><label class="collapse" for="c-40606441">[-]</label><label class="expand" for="c-40606441">[1 more]</label></div><br/><div class="children"><div class="content">It has happened on Android, version 15 is now making ANGLE the official way to still have OpenGL, given the sore state of Vulkan drivers, it is a yet another move to force OEMs to improve their story.</div><br/></div></div></div></div><div id="40601915" class="c"><input type="checkbox" id="c-40601915" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40601807">parent</a><span>|</span><a href="#40606135">prev</a><span>|</span><a href="#40602120">next</a><span>|</span><label class="collapse" for="c-40601915">[-]</label><label class="expand" for="c-40601915">[3 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t really make sense to have Khronos maintain nice high-level libraries. There&#x27;s no evidence they&#x27;d be good at it and if you look at their GitHub, they&#x27;re not particularly good at maintaining actual codebases in the first place. Their commitee&#x2F;standard-based process works for specs, but I don&#x27;t think it will work very well for the needs of day-to-day application programmers.<p>Why do you need Khronos to &quot;bless&quot; a particular library anyway?<p>Also they didn&#x27;t get rid of OpenGL. You can still use it. It will probably be the most widely supported graphics API for a long time.</div><br/><div id="40601973" class="c"><input type="checkbox" id="c-40601973" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40601915">parent</a><span>|</span><a href="#40602120">next</a><span>|</span><label class="collapse" for="c-40601973">[-]</label><label class="expand" for="c-40601973">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It doesn&#x27;t really make sense to have Khronos maintain nice high-level libraries.<p>I guess we&#x27;ll have to agree to disagree on that.<p>&gt; There&#x27;s no evidence they&#x27;d be good at it and if you look at their GitHub, they&#x27;re not particularly good at maintaining actual codebases in the first place.<p>Well that&#x27;s another complaint then, but it doesn&#x27;t detract away from my initial complaints.<p>&gt; Why do you need Khronos to &quot;bless&quot; a particular library anyway?<p>Because now we&#x27;re going to have a million different wrapper libraries to do everything, or you&#x27;re going to be stuck with the absurd Vulkan API.  It was already annoying enough that you had to have different wrappers to abstract the GUI components, now people have to have another mediocre abstraction in addition to the GUI crap.<p>I suppose you could argue &quot;that&#x27;s fine&quot;, and you&#x27;re free to have that opinion, but I think it&#x27;s worse<p>&gt; Also they didn&#x27;t get rid of OpenGL. You can still use it. It will probably be the most widely supported graphics API for a long time.<p>They&#x27;re not doing new versions of OpenGL.  Yes, the drivers will support them for the foreseeable future but they will get increasingly out of date.</div><br/><div id="40606143" class="c"><input type="checkbox" id="c-40606143" checked=""/><div class="controls bullet"><span class="by">johnnyanmac</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40601973">parent</a><span>|</span><a href="#40602120">next</a><span>|</span><label class="collapse" for="c-40606143">[-]</label><label class="expand" for="c-40606143">[1 more]</label></div><br/><div class="children"><div class="content">&gt;now we&#x27;re going to have a million different wrapper libraries to do everything, or you&#x27;re going to be stuck with the absurd Vulkan API.<p>The more things change...<p>Fact is that most people will never directly touch such things unless they are a) a graphics programmer at a handful of companies or b) someone like this author doing something more for education than to produce raw business value. our &quot;high level libraries&quot; are Unity and Unreal if you&#x27;re makinig a game (and some smaller engines),  and BGFX et al. if you&#x27;re making your own small engine. The work is already done without Khronos lifting a finger for implementation.<p>the recipients of a) are the ones who asked for more control. They are paid pretty well so they have plenty of time to grok the specs compared to a small time creator, so rapid prototyping isn&#x27;t prioritized.</div><br/></div></div></div></div></div></div></div></div><div id="40602120" class="c"><input type="checkbox" id="c-40602120" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40601714">parent</a><span>|</span><a href="#40601807">prev</a><span>|</span><a href="#40604207">next</a><span>|</span><label class="collapse" for="c-40602120">[-]</label><label class="expand" for="c-40602120">[12 more]</label></div><br/><div class="children"><div class="content">Khronos keeps pushing this in their promotional materials for the standard, and it&#x27;s not an advantage. Now instead of vendors writing this correctly once for everyone, everyone can do it poorly. Go read a few Vulkan initialization implementations across a few repositories. It&#x27;s all the same code, and some people miss portions of it here and there.<p>I don&#x27;t know how this lie caught on so well, but it doesn&#x27;t pass the smell test.</div><br/><div id="40602562" class="c"><input type="checkbox" id="c-40602562" checked=""/><div class="controls bullet"><span class="by">jms55</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40602120">parent</a><span>|</span><a href="#40602279">next</a><span>|</span><label class="collapse" for="c-40602562">[-]</label><label class="expand" for="c-40602562">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Now instead of vendors writing this correctly once for everyone, everyone can do it poorly.<p>_Vendors_ did it poorly, which is why everyone wanted to get away from them. You could argue they over-corrected and left _too_ much to the user, but better safe than sorry.<p>Sure users can write bad code as well, but at least it&#x27;s _consistently_ bad, and fully under their control. There are so many fewer problems nowadays like &quot;oh it works on my desktop, but on this older intel GPU for a user with outdated drivers it segfaults in the driver, and there&#x27;s nothing we can do to fix it ourselves&quot;.</div><br/><div id="40606540" class="c"><input type="checkbox" id="c-40606540" checked=""/><div class="controls bullet"><span class="by">account42</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40602562">parent</a><span>|</span><a href="#40602279">next</a><span>|</span><label class="collapse" for="c-40606540">[-]</label><label class="expand" for="c-40606540">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but on this older intel GPU for a user with outdated drivers it segfaults in the driver<p>Implying that up to date Intel drivers don&#x27;t segfault on perfectly valid OpenGL use.</div><br/></div></div></div></div><div id="40602279" class="c"><input type="checkbox" id="c-40602279" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40602120">parent</a><span>|</span><a href="#40602562">prev</a><span>|</span><a href="#40606203">next</a><span>|</span><label class="collapse" for="c-40602279">[-]</label><label class="expand" for="c-40602279">[8 more]</label></div><br/><div class="children"><div class="content">Pushing the code into a user-space library used by many programs means bugs can be fixed once in the library, instead of being at the mercy of every vendor fixing their driver blobs.</div><br/><div id="40602439" class="c"><input type="checkbox" id="c-40602439" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40602279">parent</a><span>|</span><a href="#40606203">next</a><span>|</span><label class="collapse" for="c-40602439">[-]</label><label class="expand" for="c-40602439">[7 more]</label></div><br/><div class="children"><div class="content">Yeah, somehow I think putting this one on multi-million dollar companies with budgets to work on graphics work for products they sell and make actual money off of is better than having some podunkian whose popular graphics library gets consumed by a bunch of people while they make $5 each from less than 1% of their users off Patreon and GitHub Sponsors.</div><br/><div id="40606353" class="c"><input type="checkbox" id="c-40606353" checked=""/><div class="controls bullet"><span class="by">MindSpunk</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40602439">parent</a><span>|</span><a href="#40604948">next</a><span>|</span><label class="collapse" for="c-40606353">[-]</label><label class="expand" for="c-40606353">[1 more]</label></div><br/><div class="children"><div class="content">Then you mustn’t have much experience working with the drivers those multi million dollar companies were (and still are) shipping to customers. They are full of bugs, quirks and performance traps. Vulkan wasn’t created because of some theoretical future problem, Vulkan was born from the real struggle of developers at the time. Problems were still struggling now.<p>We don’t need to speculate whether hardware vendors can ship bullet proof drivers and API implementations, they have already proven they can’t. Vulkan was built based on industry experience from organisations big enough to sit at the Khronos table. They were trying to give the vendors as little rope to hang themselves on by reducing the complexity of driver implementation because these stakeholders (large AAA studios) were collectively expending massive resources working around vendors inability to ship good quality drivers. This problem is still ongoing even with Vulkan.<p>Vulkan drivers on Android are a complete joke. They barely work and I’m debugging and working around a new driver bug or performance trap every few weeks at this rate. If we can’t rely on quality Vulkan drivers, an API designed to make drivers easier to implement, how will vendors fare with a much more complex to implement API like OpenGL? (poorly, look up the history of OpenGLES3).<p>Desktop PC is the exception because it’s the only GPU market where hardware vendors have real market pressure to deliver working drivers. Just look at Intel’s Arc launch, a product where it’s single biggest criticism and flaw citied universally is driver issues. There is no other market where this same pressure has been applied. Nobody bought a phone specifically because it had “good GPU drivers”. Unless the hardware market a vendor is selling to cares garbage drivers are the default. Qualcomm and Arm provide more than enough proof for that.</div><br/></div></div><div id="40604948" class="c"><input type="checkbox" id="c-40604948" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40602439">parent</a><span>|</span><a href="#40606353">prev</a><span>|</span><a href="#40606203">next</a><span>|</span><label class="collapse" for="c-40604948">[-]</label><label class="expand" for="c-40604948">[5 more]</label></div><br/><div class="children"><div class="content">Those multi-million dollar companies working on graphics libraries exist. Their names are Epic Games and Unity. Unfortunately, multi-million dollar companies want to make a profit, not give away their product for free.</div><br/><div id="40605167" class="c"><input type="checkbox" id="c-40605167" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40604948">parent</a><span>|</span><a href="#40606203">next</a><span>|</span><label class="collapse" for="c-40605167">[-]</label><label class="expand" for="c-40605167">[4 more]</label></div><br/><div class="children"><div class="content">Those aren&#x27;t graphics libraries.</div><br/><div id="40606200" class="c"><input type="checkbox" id="c-40606200" checked=""/><div class="controls bullet"><span class="by">johnnyanmac</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40605167">parent</a><span>|</span><a href="#40606034">next</a><span>|</span><label class="collapse" for="c-40606200">[-]</label><label class="expand" for="c-40606200">[1 more]</label></div><br/><div class="children"><div class="content">They have a graphics library inside of a larger engine. And for 99% of devs they don&#x27;t care about directly modifying such code, so they are fine with the stipulation of &quot;use our tool to get graphics&quot; approach.</div><br/></div></div><div id="40606034" class="c"><input type="checkbox" id="c-40606034" checked=""/><div class="controls bullet"><span class="by">beautron</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40605167">parent</a><span>|</span><a href="#40606200">prev</a><span>|</span><a href="#40606203">next</a><span>|</span><label class="collapse" for="c-40606034">[-]</label><label class="expand" for="c-40606034">[2 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t Unity and Epic have people working directly on the Vulkan specification? I remember reading a comment (maybe here!), way back during Vulkan&#x27;s original release, where someone was screaming about how Vulkan was a conspiracy to make us dependent on giant, multi million dollar game engines.<p>I don&#x27;t know about any conspiring, but I&#x27;ve thought about that comment often, because the result appears the same: The barrier to in-house game engine development has been risen further.</div><br/><div id="40606212" class="c"><input type="checkbox" id="c-40606212" checked=""/><div class="controls bullet"><span class="by">johnnyanmac</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40606034">parent</a><span>|</span><a href="#40606203">next</a><span>|</span><label class="collapse" for="c-40606212">[-]</label><label class="expand" for="c-40606212">[1 more]</label></div><br/><div class="children"><div class="content">I know Unity does, I forget if Epic does but I&#x27;d be surprised if they didn&#x27;t.<p>Not really a conspiracy so much as the fact that Unity&#x2F;Epic have much more opinions on what a graphics library can&#x2F;should be than a small engine developer. The former don&#x27;t care if it takes longer to release games, they have staff around the clock working on the engine.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40606203" class="c"><input type="checkbox" id="c-40606203" checked=""/><div class="controls bullet"><span class="by">torginus</span><span>|</span><a href="#40601605">root</a><span>|</span><a href="#40602120">parent</a><span>|</span><a href="#40602279">prev</a><span>|</span><a href="#40604207">next</a><span>|</span><label class="collapse" for="c-40606203">[-]</label><label class="expand" for="c-40606203">[1 more]</label></div><br/><div class="children"><div class="content">Honestly, this might be a bit of a conspiracy theory, but the practical use-case of Vulkan&#x27;s low-level access isn&#x27;t because of PCs and consoles - it&#x27;s because of smartphone manufacturers that make absolutely abysmal mobile drivers.</div><br/></div></div></div></div></div></div></div></div><div id="40597707" class="c"><input type="checkbox" id="c-40597707" checked=""/><div class="controls bullet"><span class="by">jokoon</span><span>|</span><a href="#40601605">prev</a><span>|</span><a href="#40597467">next</a><span>|</span><label class="collapse" for="c-40597707">[-]</label><label class="expand" for="c-40597707">[50 more]</label></div><br/><div class="children"><div class="content">I think vulkan is great, but its only purpose is to take full advantage of advanced GPU features. It also leads to better performance when using advanced GPU features compared to OpenGL.<p>Generally, I feel OpenGL is the recommended route if you don&#x27;t really aim for advanced rendering techniques.<p>There are plenty 2D &#x2F;lowpoly&#x2F;ps1-graphics games right now, and those don&#x27;t need to use vulkan.<p>Vulkan is an example of how the AAA gaming industry is skewed towards rendering quality and appearance. AAA game studios justify their budget with those very advanced engines and content, but there is a growing market of 2D&#x2F;low poly game, because players are tired and realized they want gameplay, not graphics.<p>Also if you are a game developer, you don&#x27;t want to focus on rendering quality, you want to focus on gameplay and features.</div><br/><div id="40598029" class="c"><input type="checkbox" id="c-40598029" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#40597707">parent</a><span>|</span><a href="#40597798">next</a><span>|</span><label class="collapse" for="c-40598029">[-]</label><label class="expand" for="c-40598029">[4 more]</label></div><br/><div class="children"><div class="content">Vulkan has advantages over OpenGL even if you don&#x27;t care about visual fidelity.<p>- No global state<p>- You can select which GPU you want to use at runtime<p>- OpenGL error handling is terrible<p>- Validation layers!!<p>- Cool official artwork<p>- Fantastic documentation<p>- You can upload data to the GPU asynchronously from a second thread in a sane way<p>- Fancy GPU features - Mesh shaders, RTX</div><br/><div id="40598830" class="c"><input type="checkbox" id="c-40598830" checked=""/><div class="controls bullet"><span class="by">hjadal</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598029">parent</a><span>|</span><a href="#40597798">next</a><span>|</span><label class="collapse" for="c-40598830">[-]</label><label class="expand" for="c-40598830">[3 more]</label></div><br/><div class="children"><div class="content">I will say that validation layers alone are worth it. Damn they are nice, so many bugs in my code has been found by them which saved a lot of time.</div><br/><div id="40601874" class="c"><input type="checkbox" id="c-40601874" checked=""/><div class="controls bullet"><span class="by">eliasdaler</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598830">parent</a><span>|</span><a href="#40600516">next</a><span>|</span><label class="collapse" for="c-40601874">[-]</label><label class="expand" for="c-40601874">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. I don’t even need all these fancy Vulkan features most of the time… Just validation layers and RenderDoc debugging make the whole experience of doing graphics programming so much more pleasant for me, compared to what I had to deal with in OpenGL.</div><br/></div></div><div id="40600516" class="c"><input type="checkbox" id="c-40600516" checked=""/><div class="controls bullet"><span class="by">rrradical</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598830">parent</a><span>|</span><a href="#40601874">prev</a><span>|</span><a href="#40597798">next</a><span>|</span><label class="collapse" for="c-40600516">[-]</label><label class="expand" for="c-40600516">[1 more]</label></div><br/><div class="children"><div class="content">I switched from opengl b&#x2F;c I was tired of staring at a black screen with no debugging information (sure...glGetError) when I tried to implement a non-trivial feature. After tons of work to learn vulkan and getting it up and running, I still think it was worth it.</div><br/></div></div></div></div></div></div><div id="40597798" class="c"><input type="checkbox" id="c-40597798" checked=""/><div class="controls bullet"><span class="by">ChadNauseam</span><span>|</span><a href="#40597707">parent</a><span>|</span><a href="#40598029">prev</a><span>|</span><a href="#40606228">next</a><span>|</span><label class="collapse" for="c-40597798">[-]</label><label class="expand" for="c-40597798">[25 more]</label></div><br/><div class="children"><div class="content">A middle ground is webgpu. It is much less verbose than Vulkan and is guaranteed to run anywhere, including the browser. At the same time, it has access to &quot;modern&quot; features like compute shaders which would not be available in webgl. It also doesn&#x27;t have much legacy cruft leading to multiple ways of doing the same thing, unlike opengl. The main advantage is that it&#x27;s new, so there are many fewer tutorials available for it, and that is a very serious disadvantage.</div><br/><div id="40606468" class="c"><input type="checkbox" id="c-40606468" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40597798">parent</a><span>|</span><a href="#40600030">next</a><span>|</span><label class="collapse" for="c-40606468">[-]</label><label class="expand" for="c-40606468">[1 more]</label></div><br/><div class="children"><div class="content">Compute shaders aren&#x27;t available in WebGL thanks to Google, OpenGL ES does them just fine.</div><br/></div></div><div id="40600030" class="c"><input type="checkbox" id="c-40600030" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40597798">parent</a><span>|</span><a href="#40606468">prev</a><span>|</span><a href="#40598203">next</a><span>|</span><label class="collapse" for="c-40600030">[-]</label><label class="expand" for="c-40600030">[5 more]</label></div><br/><div class="children"><div class="content">Not to downplay it or anything, but I&#x27;m curious why webgpu is receiving so much attention? There have been many low-level cross-platform graphics abstractions over the years. The bgfx [1] project had its first commit ~12 years ago and it&#x27;s still going! It&#x27;s much more mature than webgpu. I&#x27;m guessing being W3C backed is what&#x27;s propelling it?<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;bkaradzic&#x2F;bgfx">https:&#x2F;&#x2F;github.com&#x2F;bkaradzic&#x2F;bgfx</a></div><br/><div id="40606492" class="c"><input type="checkbox" id="c-40606492" checked=""/><div class="controls bullet"><span class="by">MindSpunk</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40600030">parent</a><span>|</span><a href="#40605906">next</a><span>|</span><label class="collapse" for="c-40606492">[-]</label><label class="expand" for="c-40606492">[1 more]</label></div><br/><div class="children"><div class="content">My perspective is it’s a couple things. Mainly because it’s backed by several implementations with market pressure to deliver high quality working implementations (wgpu in Firefox, Dawn in Chrome). Not saying bgfx or others are bad, but the Chrome team will be putting in a lot of work for you to make sure Dawn works well everywhere Chrome needs to be. That plus it’s super portable. First time in a long time that we could truly be looking at a “write once run anywhere” GPU API. It also fills OpenGL’s niche by being much more approachable than Vulkan. I guess this really just adds up to it being the “OpenGL 2” a lot of people have been wanting in light of Vulkan’s complexity and weaker portability.</div><br/></div></div><div id="40605906" class="c"><input type="checkbox" id="c-40605906" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40600030">parent</a><span>|</span><a href="#40606492">prev</a><span>|</span><a href="#40602207">next</a><span>|</span><label class="collapse" for="c-40605906">[-]</label><label class="expand" for="c-40605906">[1 more]</label></div><br/><div class="children"><div class="content">One remarkable feature of WebGPU is that it has no undefined behaviour, traditional 3D APIs are riddled with subtle UB. It also receives much better testing across all sorts of hardware and driver configs, just by being integrated with web browsers.</div><br/></div></div><div id="40602207" class="c"><input type="checkbox" id="c-40602207" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40600030">parent</a><span>|</span><a href="#40605906">prev</a><span>|</span><a href="#40598203">next</a><span>|</span><label class="collapse" for="c-40602207">[-]</label><label class="expand" for="c-40602207">[2 more]</label></div><br/><div class="children"><div class="content">webgpu is a modern graphics API for modern GPUs to replace&#x2F;complement these two APIs in the browser: WebGL (a very limited outdated subset of OpenGL) and Canvas (basically WinAPI drawing from 2000s)<p>It&#x27;s heavily influenced by Metal (based on original work by Apple and Mozilla).<p>People are talking about it because it&#x27;s on the web and it&#x27;s finally something modern to work with.</div><br/><div id="40605911" class="c"><input type="checkbox" id="c-40605911" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40602207">parent</a><span>|</span><a href="#40598203">next</a><span>|</span><label class="collapse" for="c-40605911">[-]</label><label class="expand" for="c-40605911">[1 more]</label></div><br/><div class="children"><div class="content">&gt; webgpu is a modern graphics API<p>TBF, WebGPU is at least a decade behind too. For instance it implements a Vulkan-style rigid render pipeline model which even Vulkan is moving away from because it turned out too rigid. So once WebGPU becomes mainstream it may very well be the most &quot;awkward&quot; 3D API.</div><br/></div></div></div></div></div></div><div id="40598203" class="c"><input type="checkbox" id="c-40598203" checked=""/><div class="controls bullet"><span class="by">solardev</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40597798">parent</a><span>|</span><a href="#40600030">prev</a><span>|</span><a href="#40597989">next</a><span>|</span><label class="collapse" for="c-40598203">[-]</label><label class="expand" for="c-40598203">[5 more]</label></div><br/><div class="children"><div class="content">I thought its browser support was pretty bad? <a href="https:&#x2F;&#x2F;caniuse.com&#x2F;webgpu" rel="nofollow">https:&#x2F;&#x2F;caniuse.com&#x2F;webgpu</a><p>Firefox and Safari don&#x27;t support it yet. And how would you even deploy it to Steam (edit: or rather, make a desktop or mobile game with it)? Can you wrap it in a webview?<p>Doesn&#x27;t seem mature...</div><br/><div id="40598269" class="c"><input type="checkbox" id="c-40598269" checked=""/><div class="controls bullet"><span class="by">bla3</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598203">parent</a><span>|</span><a href="#40597989">next</a><span>|</span><label class="collapse" for="c-40598269">[-]</label><label class="expand" for="c-40598269">[4 more]</label></div><br/><div class="children"><div class="content">There is a native API too, not just JS. You can link it into your game like any other library.</div><br/><div id="40598295" class="c"><input type="checkbox" id="c-40598295" checked=""/><div class="controls bullet"><span class="by">solardev</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598269">parent</a><span>|</span><a href="#40597989">next</a><span>|</span><label class="collapse" for="c-40598295">[-]</label><label class="expand" for="c-40598295">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confused now. I thought by definition it&#x27;s a browser API that allows them to make Vulkan&#x2F;OpenGL&#x2F;DirectX calls, like an abstraction layer. Am I wrong?<p>Edit: wgpu is a reimplementation of the WebGPU api for use with desktop apps outside of browsers. See sibling thread by another poster for an explanation: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40598416">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40598416</a></div><br/><div id="40598829" class="c"><input type="checkbox" id="c-40598829" checked=""/><div class="controls bullet"><span class="by">MindSpunk</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598295">parent</a><span>|</span><a href="#40597989">next</a><span>|</span><label class="collapse" for="c-40598829">[-]</label><label class="expand" for="c-40598829">[2 more]</label></div><br/><div class="children"><div class="content">wgpu isn’t a reimplementation of WebGPU, it’s Firefox’s WebGPU implementation. It also conveniently runs outside of a browser and is accessible with a Rust or C API. You can also do the same thing with Dawn, which is Chrome’s implementation of WebGPU.</div><br/><div id="40598909" class="c"><input type="checkbox" id="c-40598909" checked=""/><div class="controls bullet"><span class="by">solardev</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598829">parent</a><span>|</span><a href="#40597989">next</a><span>|</span><label class="collapse" for="c-40598909">[-]</label><label class="expand" for="c-40598909">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the correction!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40597989" class="c"><input type="checkbox" id="c-40597989" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40597798">parent</a><span>|</span><a href="#40598203">prev</a><span>|</span><a href="#40606228">next</a><span>|</span><label class="collapse" for="c-40597989">[-]</label><label class="expand" for="c-40597989">[13 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a JavaScript API, it only runs in the browser. It&#x27;s not real.</div><br/><div id="40598156" class="c"><input type="checkbox" id="c-40598156" checked=""/><div class="controls bullet"><span class="by">ncallaway</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40597989">parent</a><span>|</span><a href="#40606228">next</a><span>|</span><label class="collapse" for="c-40598156">[-]</label><label class="expand" for="c-40598156">[12 more]</label></div><br/><div class="children"><div class="content">That&#x27;s just not true. <a href="https:&#x2F;&#x2F;wgpu.rs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;wgpu.rs&#x2F;</a><p>I&#x27;m literally writing native code running on linux with winit and wgpu right now.</div><br/><div id="40598237" class="c"><input type="checkbox" id="c-40598237" checked=""/><div class="controls bullet"><span class="by">solardev</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598156">parent</a><span>|</span><a href="#40606228">next</a><span>|</span><label class="collapse" for="c-40598237">[-]</label><label class="expand" for="c-40598237">[11 more]</label></div><br/><div class="children"><div class="content">Wait, is that the same as using WebGPU? It says outside of browsers it uses opengl and vulkan and directx.</div><br/><div id="40598286" class="c"><input type="checkbox" id="c-40598286" checked=""/><div class="controls bullet"><span class="by">ncallaway</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598237">parent</a><span>|</span><a href="#40598911">next</a><span>|</span><label class="collapse" for="c-40598286">[-]</label><label class="expand" for="c-40598286">[4 more]</label></div><br/><div class="children"><div class="content">Yea, wgpu is basically an adapting layer between the WebGPU API and opengl, vulkan, directx. So it&#x27;s the same† API.<p>But WebGPU in the browser is <i>also</i> an adapting layer between those technologies, it&#x27;s just the browser that does the adapting instead of the wgpu library. For Firefox, WebGPU is adapted to those underlying systems <i>by</i> wgpu: <a href="https:&#x2F;&#x2F;github.com&#x2F;gpuweb&#x2F;gpuweb&#x2F;wiki&#x2F;Implementation-Status">https:&#x2F;&#x2F;github.com&#x2F;gpuweb&#x2F;gpuweb&#x2F;wiki&#x2F;Implementation-Status</a><p>† There are some &quot;native-only&quot; extensions beyond the WebGPU spec that gpu provides, so it does go a little beyond WebGPU. But for the most part, it&#x27;s very similar.</div><br/><div id="40598325" class="c"><input type="checkbox" id="c-40598325" checked=""/><div class="controls bullet"><span class="by">solardev</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598286">parent</a><span>|</span><a href="#40598911">next</a><span>|</span><label class="collapse" for="c-40598325">[-]</label><label class="expand" for="c-40598325">[3 more]</label></div><br/><div class="children"><div class="content">Wait... so if webgpu (the API) is to allow browsers to use the underlying graphics libs... but desktop apps can access those directly... why would they want to go through the browser abstraction API instead? Better dev ex and ergonomics?</div><br/><div id="40598416" class="c"><input type="checkbox" id="c-40598416" checked=""/><div class="controls bullet"><span class="by">ncallaway</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598325">parent</a><span>|</span><a href="#40598911">next</a><span>|</span><label class="collapse" for="c-40598416">[-]</label><label class="expand" for="c-40598416">[2 more]</label></div><br/><div class="children"><div class="content">&gt; why would they want to go through the browser abstraction API instead? Better dev ex and ergonomics?<p>That and portability. The ergonomics are always up for debate, but I find it a much more modern and nicer interface than OpenGL which feels...quite dated. How it compares to something like Vulkan or Metal is up for debate.<p>But for portability if I write my code using directx, then I can only run it on systems with directx. If I write it for vulkan, I can only target systems with vulkan. If I write for metal, I can only target systems with metal.<p>However, if I use wgpu and the WebGPU API, I can target <i>any</i> system that has directx <i>or</i> vulkan <i>or</i> metal <i>or</i> OpenGL. I can also target wasm and compile my application for the web.<p>So, I can really easily write code that will run natively on linux, on osx, on windows and the web and will use the graphics library native to that platform.</div><br/><div id="40598483" class="c"><input type="checkbox" id="c-40598483" checked=""/><div class="controls bullet"><span class="by">solardev</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598416">parent</a><span>|</span><a href="#40598911">next</a><span>|</span><label class="collapse" for="c-40598483">[-]</label><label class="expand" for="c-40598483">[1 more]</label></div><br/><div class="children"><div class="content">I see now. Thanks for explaining! That makes a lot of sense.</div><br/></div></div></div></div></div></div></div></div><div id="40598911" class="c"><input type="checkbox" id="c-40598911" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598237">parent</a><span>|</span><a href="#40598286">prev</a><span>|</span><a href="#40606228">next</a><span>|</span><label class="collapse" for="c-40598911">[-]</label><label class="expand" for="c-40598911">[6 more]</label></div><br/><div class="children"><div class="content">wgpu is not WebGPU. One is a Web specification, the other is a Rust library.<p>wgpu is also not a graphics API, it&#x27;s a library that abstracts the underlying graphics API.</div><br/><div id="40598927" class="c"><input type="checkbox" id="c-40598927" checked=""/><div class="controls bullet"><span class="by">solardev</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598911">parent</a><span>|</span><a href="#40606228">next</a><span>|</span><label class="collapse" for="c-40598927">[-]</label><label class="expand" for="c-40598927">[5 more]</label></div><br/><div class="children"><div class="content">Even more confused now, lol.<p>(edit: thanks for editing your post. the revised version clears it up!)</div><br/><div id="40599135" class="c"><input type="checkbox" id="c-40599135" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598927">parent</a><span>|</span><a href="#40606228">next</a><span>|</span><label class="collapse" for="c-40599135">[-]</label><label class="expand" for="c-40599135">[4 more]</label></div><br/><div class="children"><div class="content">Vulkan, Direct3D, Metal and OpenGL are graphics APIs - the implementation comes with your GPU driver, and they&#x27;re as close as you can reasonably get to writing code &quot;directly for the GPU&quot;. When you call a Vulkan function you&#x27;re directly calling driver code.<p>wgpu is a regular library that uses the native APIs above and abstracts them from you. I don&#x27;t like calling it a graphics API because it implies it&#x27;s the same as the vendor-provided APIs - it&#x27;s a completely different beast.<p>WebGPU and WebGL are Web standards that the browser implements, and you program them via JS. Similarly to wgpu, they&#x27;re implemented on top of the native graphics APIs.<p>The relationship between wgpu and WebGPU is that they&#x27;re basically made by the same people, and in Firefox WebGPU is implemented on top of wgpu.<p>But saying &quot;WebGPU runs everywhere&quot; is plain wrong - it&#x27;s a browser-exclusive API, and on top of that, at the point of writing this it doesn&#x27;t even run on all browsers (71% support according to <a href="https:&#x2F;&#x2F;caniuse.com&#x2F;webgpu" rel="nofollow">https:&#x2F;&#x2F;caniuse.com&#x2F;webgpu</a>)</div><br/><div id="40605481" class="c"><input type="checkbox" id="c-40605481" checked=""/><div class="controls bullet"><span class="by">ncallaway</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40599135">parent</a><span>|</span><a href="#40601631">next</a><span>|</span><label class="collapse" for="c-40605481">[-]</label><label class="expand" for="c-40605481">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The relationship between wgpu and WebGPU is that they&#x27;re basically made by the same people, and in Firefox WebGPU is implemented on top of wgpu.<p>I think that’s understating the relationship a bit. The wgpu API follows the WebGPU spec quite closely. It’s like saying “taffy isn’t flexbox”. You can make a technical argument that it’s not identical, and to be flexbox it must be in a browser, but anyone working with taffy will recognize that it’s implementing flexbox and will find that all their understands of flexbox apply to taffy.<p>Similarly, most of what I’m learning working with wgpu (outside of, maybe, threading), is directly transferable to WebGPU. And vice versa.</div><br/><div id="40606535" class="c"><input type="checkbox" id="c-40606535" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40605481">parent</a><span>|</span><a href="#40601631">next</a><span>|</span><label class="collapse" for="c-40606535">[-]</label><label class="expand" for="c-40606535">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s fair, my comment did understate their relation quite a lot. They are very closely linked, to the point stuff has been added to the WebGPU spec pretty-much because &quot;eh, it&#x27;s already in wgpu&quot;.<p>But the &quot;knowledge is transferable to WebGPU&quot; is key. Even when you&#x27;re compiling your wgpu code to WASM, you&#x27;re not using WebGPU directly - for every API call, you&#x27;re going through generated bindings on the Rust side and then generated bindings on the JS side where the actual call is made. The JS wrappers aren&#x27;t trivial either - Rust structs need to be converted to the nested JS objects required by WebGPU spec, numeric enums need to be converted strings, etc.<p>Considering that WebGPU is supposed to be the low-level graphics API for the Web, DX12&#x2F;VK&#x2F;Metal equivalent, all this is at least worth a mention, and &quot;wgpu == WebGPU&quot; brushes over a all that, to the point where we&#x27;re now casually throwing statements like &quot;[WebGPU] is guaranteed to run anywhere, including the browser&quot;.</div><br/></div></div></div></div><div id="40601631" class="c"><input type="checkbox" id="c-40601631" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40599135">parent</a><span>|</span><a href="#40605481">prev</a><span>|</span><a href="#40606228">next</a><span>|</span><label class="collapse" for="c-40601631">[-]</label><label class="expand" for="c-40601631">[1 more]</label></div><br/><div class="children"><div class="content">But clearly libraries like wgpu implement WebGPU while not requiring a browser. So WebGPU is not browser-exclusive.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40606228" class="c"><input type="checkbox" id="c-40606228" checked=""/><div class="controls bullet"><span class="by">torginus</span><span>|</span><a href="#40597707">parent</a><span>|</span><a href="#40597798">prev</a><span>|</span><a href="#40597957">next</a><span>|</span><label class="collapse" for="c-40606228">[-]</label><label class="expand" for="c-40606228">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think this is true. You can pretty much implement everything in OpenGL that you can do in Vulkan. The magic&#x27;s in the shaders usually and I think there&#x27;s pretty much feature parity there.<p>Performance isn&#x27;t an issue either - with the advent of GPU-resident drawing ,meaning a compute shader filling buffers with draw parameters and drawing multiple objects with complex materials in a single draw call means there isn&#x27;t much of a CPU bottleneck. Look up OpenGL AZDO if you are interested in this.</div><br/></div></div><div id="40597957" class="c"><input type="checkbox" id="c-40597957" checked=""/><div class="controls bullet"><span class="by">MajimasEyepatch</span><span>|</span><a href="#40597707">parent</a><span>|</span><a href="#40606228">prev</a><span>|</span><a href="#40604256">next</a><span>|</span><label class="collapse" for="c-40597957">[-]</label><label class="expand" for="c-40597957">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Vulkan is an example of how the AAA gaming industry is skewed towards rendering quality and appearance. AAA game studios justify their budget with those very advanced engines and content, but there is a growing market of 2D&#x2F;low poly game, because players are tired and realized they want gameplay, not graphics.<p>I think the driver here is more likely the financial reality of game development. High-fidelity graphics are incredibly expensive, and small game studios simply cannot produce them on a realistic timeline and budget. Would consumers reject indie games with AAA-quality graphics? I think not. It&#x27;s just that few such games exist because it&#x27;s not financially viable, and there is a large enough market that is fine with more stylized, lower-fidelity graphics.</div><br/><div id="40602331" class="c"><input type="checkbox" id="c-40602331" checked=""/><div class="controls bullet"><span class="by">jokoon</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40597957">parent</a><span>|</span><a href="#40604256">next</a><span>|</span><label class="collapse" for="c-40602331">[-]</label><label class="expand" for="c-40602331">[2 more]</label></div><br/><div class="children"><div class="content">Yes, I agree.<p>With current hardware and tools, it becomes much cheaper to reach graphics quality that is 10 or 15 years old, so such game would be just enough and be profitable enough.<p>I think that high quality rendering is reaching a tipping point where it&#x27;s mostly of diminishing returns, this means AAA studios could differentiate with good graphics, but this becomes less and less true.<p>Gameplay matters, and the innovation is not the on the side of AAA studios.</div><br/><div id="40606236" class="c"><input type="checkbox" id="c-40606236" checked=""/><div class="controls bullet"><span class="by">johnnyanmac</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40602331">parent</a><span>|</span><a href="#40604256">next</a><span>|</span><label class="collapse" for="c-40606236">[-]</label><label class="expand" for="c-40606236">[1 more]</label></div><br/><div class="children"><div class="content">gameplay matters, but graphics sell. Look no further at the modern state of hardcore reviewers and hyper nitpickers on social media. See how every switch game is criticized for not being 1080p60 on 2017 mobile hardware. People demand that kind of quality.<p>That&#x27;s a loud minority, but it&#x27;s not like the biggest games aren&#x27;t selling more and more every year en large. So non-vocal gamers do seem to be drawn to it.</div><br/></div></div></div></div></div></div><div id="40604256" class="c"><input type="checkbox" id="c-40604256" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#40597707">parent</a><span>|</span><a href="#40597957">prev</a><span>|</span><a href="#40598040">next</a><span>|</span><label class="collapse" for="c-40604256">[-]</label><label class="expand" for="c-40604256">[1 more]</label></div><br/><div class="children"><div class="content">OpenGL is being sunset, no one cares about Metal, and the only people who voluntarily write Vulkan are bearded code wizards taking the weekend off from writing the kernel.<p>There&#x27;s no end of frameworks and engines out there, most unfinished, and all extremely opinionated about what your code must look like. (&quot;You will build scene trees that hold callbacks. Actually no, you will write entity and component classes and objects. Wait, forget that, everything is immediate mode and functional and stateless now!&quot;)<p>Add all the platform nonsense on top (push notifications for a mobile game? In-app purchases? Mandatory signing via Xcode?) and it&#x27;s all just a hot mess. There&#x27;s a reason Unity has the market share it does, and it&#x27;s not because it&#x27;s a fantastic piece of software. It&#x27;s because cross-platform for anything more complex than a glorified web view (which is, to be fair, most non-game apps) is still a massive pain.</div><br/></div></div><div id="40598040" class="c"><input type="checkbox" id="c-40598040" checked=""/><div class="controls bullet"><span class="by">samuellavoie90</span><span>|</span><a href="#40597707">parent</a><span>|</span><a href="#40604256">prev</a><span>|</span><a href="#40599046">next</a><span>|</span><label class="collapse" for="c-40598040">[-]</label><label class="expand" for="c-40598040">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just about performance, I think one of the reasons for moving away from OpenGL is that the High level functions are inconsistent across driver implementations&#x2F;GPUs.  Whats the point of an abstraction layer if you keep having to write GPU&#x2F;driver specific code.  Its better to have a low level driver and a high level library instead.</div><br/></div></div><div id="40599046" class="c"><input type="checkbox" id="c-40599046" checked=""/><div class="controls bullet"><span class="by">Keyframe</span><span>|</span><a href="#40597707">parent</a><span>|</span><a href="#40598040">prev</a><span>|</span><a href="#40597912">next</a><span>|</span><label class="collapse" for="c-40599046">[-]</label><label class="expand" for="c-40599046">[5 more]</label></div><br/><div class="children"><div class="content">I think Vulkan was a mistake. Maybe I should say OpenGL Next should&#x27;ve been a (priority) thing and Vulkan could still happen on the side.. and not this, push towards everything Vulkan. It&#x27;s not for everybody and not everybody needs it (nor deserves it).</div><br/><div id="40599430" class="c"><input type="checkbox" id="c-40599430" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40599046">parent</a><span>|</span><a href="#40601923">next</a><span>|</span><label class="collapse" for="c-40599430">[-]</label><label class="expand" for="c-40599430">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it&#x27;s a mistake, I think it&#x27;s targeted and leveraged poorly.<p>Vulkan is a great idea for a general game engine or backing something like OpenGL.  It&#x27;s a low-level abstraction that should allow you to do something like use OpenGL 8.0 on a GPU that has long lost support for from its manufacturer.</div><br/><div id="40602233" class="c"><input type="checkbox" id="c-40602233" checked=""/><div class="controls bullet"><span class="by">jms55</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40599430">parent</a><span>|</span><a href="#40601923">next</a><span>|</span><label class="collapse" for="c-40602233">[-]</label><label class="expand" for="c-40602233">[2 more]</label></div><br/><div class="children"><div class="content">Exactly this. Vulkan, especially Vulkan 1.0, was never really meant directly for graphics developers. It was meant specifically for engine developers that didn&#x27;t want to have to deal with buggy and inconsistent drivers, e.g. Nvidia vs AMD vs crappy Android phones.<p>The solution Vulkan came up with was &quot;make everything as explicit and user-controlled as possible&quot;, and leave &quot;implementing a more user friendly driver&quot; up to user-space, so that it could be tweaked by users, wouldn&#x27;t be tied to driver updates users would never do, would be consistent across platforms, etc.<p>Except that never really happened. There are some graphics-driver-as-a-library projects (daxa, nabla, etc), but none with a large amount of community support.<p>Meanwhile GPU&#x27;s evolved over time (AMD RDNA1, Nvidia Turing, Intel Arc, Apple Silicon), and it turns out that some of the choices Vulkan 1.0 bet on weren&#x27;t great (explicit extensive pipeline state, binding model, render passes).<p>Vulkan 1.2&#x2F;1.3 cleaned up a lot of this (dynamic state, descriptor indexing, sync v2), which also happens to improve ergonomics a lot to the point that it&#x27;s much less painful to use Vulkan directly nowadays, as long as you&#x27;re ok dropping support for older platforms.</div><br/><div id="40606253" class="c"><input type="checkbox" id="c-40606253" checked=""/><div class="controls bullet"><span class="by">johnnyanmac</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40602233">parent</a><span>|</span><a href="#40601923">next</a><span>|</span><label class="collapse" for="c-40606253">[-]</label><label class="expand" for="c-40606253">[1 more]</label></div><br/><div class="children"><div class="content">&gt;There are some graphics-driver-as-a-library projects (daxa, nabla, etc), but none with a large amount of community support.<p>That&#x27;s more on the community then, no? Same issue as OpenGL; most of the market is Windows or consoles, Windows&#x2F;consoles have their own graphics api and professional suppport, the devs choose convinience over control and cross-compatibility.<p>Seems like a self-furfilling prophecy if devs relinquish their control to the corporations.</div><br/></div></div></div></div></div></div><div id="40601923" class="c"><input type="checkbox" id="c-40601923" checked=""/><div class="controls bullet"><span class="by">eliasdaler</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40599046">parent</a><span>|</span><a href="#40599430">prev</a><span>|</span><a href="#40597912">next</a><span>|</span><label class="collapse" for="c-40601923">[-]</label><label class="expand" for="c-40601923">[1 more]</label></div><br/><div class="children"><div class="content">I can somewhat agree… I don’t dislike&#x2F;fear Vulkan now, but I feel like there should have been something in-between OpenGL and Vulkan, because in most cases you don’t need the same level control over the GPU which AAA game require. 
Thankfully, libraries like VMA and vk-bootstrap + new extensions like dynamic rendering make Vulkan start to resemble what “OpenGL Next” could have been. It’s still not perfect, but I’m glad that things have moved into that direction.</div><br/></div></div></div></div><div id="40597912" class="c"><input type="checkbox" id="c-40597912" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#40597707">parent</a><span>|</span><a href="#40599046">prev</a><span>|</span><a href="#40604345">next</a><span>|</span><label class="collapse" for="c-40597912">[-]</label><label class="expand" for="c-40597912">[1 more]</label></div><br/><div class="children"><div class="content">The general idea is that if you care more about gameplay and features, use an existing engine, the engine itself takes advantage of Vulkan, or whatever backend is the most appropriate, so you don&#x27;t have to.<p>OpenGL is kind of a middle ground. That&#x27;s if you want to get technical, but not micromanage every detail and write pages of boilerplate. It is also a great introduction to graphics programming. More than an introduction actually, there is a lot you can do with OpenGL.</div><br/></div></div><div id="40604345" class="c"><input type="checkbox" id="c-40604345" checked=""/><div class="controls bullet"><span class="by">wmil</span><span>|</span><a href="#40597707">parent</a><span>|</span><a href="#40597912">prev</a><span>|</span><a href="#40598567">next</a><span>|</span><label class="collapse" for="c-40604345">[-]</label><label class="expand" for="c-40604345">[1 more]</label></div><br/><div class="children"><div class="content">OpenGL is deprecated on MacOS, so there&#x27;s an argument that it&#x27;s on it&#x27;s way out and may not be supported in the future.</div><br/></div></div><div id="40598567" class="c"><input type="checkbox" id="c-40598567" checked=""/><div class="controls bullet"><span class="by">Const-me</span><span>|</span><a href="#40597707">parent</a><span>|</span><a href="#40604345">prev</a><span>|</span><a href="#40605016">next</a><span>|</span><label class="collapse" for="c-40598567">[-]</label><label class="expand" for="c-40598567">[6 more]</label></div><br/><div class="children"><div class="content">Another good option is Direct3D 11. It’s IMO even easier to use than OpenGL but still allows to implement pretty good visuals, see GTA 5 or Baldur’s Gate 3.</div><br/><div id="40598694" class="c"><input type="checkbox" id="c-40598694" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598567">parent</a><span>|</span><a href="#40605016">next</a><span>|</span><label class="collapse" for="c-40598694">[-]</label><label class="expand" for="c-40598694">[5 more]</label></div><br/><div class="children"><div class="content">Eh that&#x27;s really only an option if you want to only ever target Microsoft platforms. Which is fine for <i>some</i> people, sure, but in a lot of situations, closing the door on Linux (Steam Deck), macOS, iOS, Android and the non-xbox consoles is a tough sell.</div><br/><div id="40599102" class="c"><input type="checkbox" id="c-40599102" checked=""/><div class="controls bullet"><span class="by">MindSpunk</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598694">parent</a><span>|</span><a href="#40606510">next</a><span>|</span><label class="collapse" for="c-40599102">[-]</label><label class="expand" for="c-40599102">[1 more]</label></div><br/><div class="children"><div class="content">Linux you can get for “free” with DXVK or VKD3D-proton. MacOS is an even more niche platform than Linux as far as gaming is concerned and is not a tough sell to skip considering the total lack of market share in games. iOS and Android generally come in a pair so unless you’re only targeting one you need to support multiple APIs anyway. Xbox requires Xbox specific APIs so you need explicit work there. Every other console uses a bespoke API that will require another backend in your engine (yes Switch technically supports Vulkan but that is not the recommended path from Nintendo, you will likely end up with an NVN backend).<p>D3D11 gives you both desktop platforms that matter for games, everything else will require multiple backends anyway so if you only care about desktop it’s a fair choice.</div><br/></div></div><div id="40606510" class="c"><input type="checkbox" id="c-40606510" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598694">parent</a><span>|</span><a href="#40599102">prev</a><span>|</span><a href="#40605628">next</a><span>|</span><label class="collapse" for="c-40606510">[-]</label><label class="expand" for="c-40606510">[1 more]</label></div><br/><div class="children"><div class="content">Contrary to urban myths, non-xbox consoles aren&#x27;t that found of Khronos standards either.</div><br/></div></div><div id="40605628" class="c"><input type="checkbox" id="c-40605628" checked=""/><div class="controls bullet"><span class="by">_kidlike</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598694">parent</a><span>|</span><a href="#40606510">prev</a><span>|</span><a href="#40599637">next</a><span>|</span><label class="collapse" for="c-40605628">[-]</label><label class="expand" for="c-40605628">[1 more]</label></div><br/><div class="children"><div class="content">Valve&#x27;s efforts on playing Microsoft only games started ~10 years ago with Proton (which is more like an umbrella project for ~15 software components like Wine and DXVK). Today, proton is surprisingly good. Their bet paid off, and allowed them to make SteamDeck. Most if not all new games play fine out of the box, with 0 tinkering. Older games sometimes have issues.</div><br/></div></div><div id="40599637" class="c"><input type="checkbox" id="c-40599637" checked=""/><div class="controls bullet"><span class="by">debugnik</span><span>|</span><a href="#40597707">root</a><span>|</span><a href="#40598694">parent</a><span>|</span><a href="#40605628">prev</a><span>|</span><a href="#40605016">next</a><span>|</span><label class="collapse" for="c-40599637">[-]</label><label class="expand" for="c-40599637">[1 more]</label></div><br/><div class="children"><div class="content">Since DXVK exists and Apple dropped OpenGL, the latter gains you access to Android and that&#x27;s about it, unless you&#x27;re ok with ES 3.0 contexts and a lackluster set of extensions (ANGLE on Metal).<p>AFAIK the non-Xbox consoles either don&#x27;t support OpenGL or we reportedly don&#x27;t want to use their implementations.</div><br/></div></div></div></div></div></div><div id="40605016" class="c"><input type="checkbox" id="c-40605016" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#40597707">parent</a><span>|</span><a href="#40598567">prev</a><span>|</span><a href="#40597467">next</a><span>|</span><label class="collapse" for="c-40605016">[-]</label><label class="expand" for="c-40605016">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Generally, I feel OpenGL is the recommended route if you don&#x27;t really aim for advanced rendering techniques.<p>Unfortunately, Apple is holding every OpenGL app and dev hostage. It&#x27;s officially deprecated by Apple. So OpenGL is not a viable cross-platform solution moving forward. Eventually, it will be completely removed from macOS, at which point it will just be an OpenGL to Metal converter that everyone uses, just like Vulkan with MoltenVK. So I feel it&#x27;s better to use something like WebGPU moving forward that directly takes the stance that each OS will implement its own (perhaps multiple) backends. Unfortunately, it doesn&#x27;t have the tutorials and learning material that OpenGL does. (This is from an inexperienced 3D person that&#x27;s been looking into this a lot.)</div><br/></div></div></div></div><div id="40597467" class="c"><input type="checkbox" id="c-40597467" checked=""/><div class="controls bullet"><span class="by">spicyusername</span><span>|</span><a href="#40597707">prev</a><span>|</span><a href="#40596865">next</a><span>|</span><label class="collapse" for="c-40597467">[-]</label><label class="expand" for="c-40597467">[29 more]</label></div><br/><div class="children"><div class="content">Lots of good advice in this article.<p>One that stuck out to me: Don’t implement something unless you need it right now<p>This is a constant battle I fight with more junior programmers, who maybe have a few years of experience, but who are still getting there.<p>They are often obsessed with &quot;best-practices&quot; and whatever fancy new tool is trending, but they have trouble starting with the problem they need to solve and focusing on the minimum needed to just solve that problem.</div><br/><div id="40600808" class="c"><input type="checkbox" id="c-40600808" checked=""/><div class="controls bullet"><span class="by">proc0</span><span>|</span><a href="#40597467">parent</a><span>|</span><a href="#40597627">next</a><span>|</span><label class="collapse" for="c-40600808">[-]</label><label class="expand" for="c-40600808">[8 more]</label></div><br/><div class="children"><div class="content">This is in context of a one person team. The next advice makes this evident:<p>&gt; Remember that you can always rewrite any part of your game&#x2F;engine later.<p>This isn&#x27;t the case in medium to large organizations. Usually you will just move on and rarely have the time to revisit something. This is unfortunate of course, but it means you need to build things properly the first time around and make sure it won&#x27;t have a chance to create bugs or side effects. I have worked in too many codebases were people feel the need to rush new features, and then it creates a minefield of a codebase where you have to manually check every feature and have the entire application in context when changing something small.</div><br/><div id="40600934" class="c"><input type="checkbox" id="c-40600934" checked=""/><div class="controls bullet"><span class="by">jshowa</span><span>|</span><a href="#40597467">root</a><span>|</span><a href="#40600808">parent</a><span>|</span><a href="#40602261">next</a><span>|</span><label class="collapse" for="c-40600934">[-]</label><label class="expand" for="c-40600934">[2 more]</label></div><br/><div class="children"><div class="content">I agree with this. In a large organization, if you have risen to a level where you are being relied upon at a regular intervals, it is imperative that you have a well architected solution that you can readily change and this is where you separate your program from spaghetti code to something useful. Sure, its nice to write unmaintainable junk when toying around, but I to have seen too many codebases where people were just throwing features in without thought and it causes the program to become way too constrained to only a specific problem domain and it becomes inflexible for solving new problems (to the point you have to re-write nearly everything from scratch).</div><br/><div id="40602539" class="c"><input type="checkbox" id="c-40602539" checked=""/><div class="controls bullet"><span class="by">jaggederest</span><span>|</span><a href="#40597467">root</a><span>|</span><a href="#40600934">parent</a><span>|</span><a href="#40602261">next</a><span>|</span><label class="collapse" for="c-40602539">[-]</label><label class="expand" for="c-40602539">[1 more]</label></div><br/><div class="children"><div class="content">The contrast to this is to put in tickets specifically for refactoring and reorganization, but I&#x27;ve rarely seen that work since they often don&#x27;t have any sweetener included to encourage e.g. product organization to sign off on the work.</div><br/></div></div></div></div><div id="40602261" class="c"><input type="checkbox" id="c-40602261" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#40597467">root</a><span>|</span><a href="#40600808">parent</a><span>|</span><a href="#40600934">prev</a><span>|</span><a href="#40601842">next</a><span>|</span><label class="collapse" for="c-40602261">[-]</label><label class="expand" for="c-40602261">[1 more]</label></div><br/><div class="children"><div class="content">Most importantly, you need to get <i>interfaces</i> right. The right interface that allows the caller to express their underlying intent allows you to rewrite bits of the implementation as-needed without forcing a rewrite from your downstream consumers.</div><br/></div></div><div id="40601842" class="c"><input type="checkbox" id="c-40601842" checked=""/><div class="controls bullet"><span class="by">eliasdaler</span><span>|</span><a href="#40597467">root</a><span>|</span><a href="#40600808">parent</a><span>|</span><a href="#40602261">prev</a><span>|</span><a href="#40602540">next</a><span>|</span><label class="collapse" for="c-40601842">[-]</label><label class="expand" for="c-40601842">[1 more]</label></div><br/><div class="children"><div class="content">I agree. I should probably clarify that in the article. It’s much easier to write “throwaway” code when you’re working alone and when you’re doing it just for fun. 
This advice was probably aimed at people who tend to overthink things in <i>these</i> kinds of situations and spend years implementing things in the “right” way, which tends to slow them down considerably instead.</div><br/></div></div><div id="40602540" class="c"><input type="checkbox" id="c-40602540" checked=""/><div class="controls bullet"><span class="by">exe34</span><span>|</span><a href="#40597467">root</a><span>|</span><a href="#40600808">parent</a><span>|</span><a href="#40601842">prev</a><span>|</span><a href="#40597627">next</a><span>|</span><label class="collapse" for="c-40602540">[-]</label><label class="expand" for="c-40602540">[3 more]</label></div><br/><div class="children"><div class="content">&gt; it means you need to build things properly the first time around and make sure it won&#x27;t have a chance to create bugs or side effects. I<p>yes! and this means you need to know everything about what you&#x27;re building upfront! so now you have to do waterfall, but hide all the actual effort and pretend you&#x27;re just figuring it out in the moment because agile.</div><br/><div id="40602825" class="c"><input type="checkbox" id="c-40602825" checked=""/><div class="controls bullet"><span class="by">proc0</span><span>|</span><a href="#40597467">root</a><span>|</span><a href="#40602540">parent</a><span>|</span><a href="#40597627">next</a><span>|</span><label class="collapse" for="c-40602825">[-]</label><label class="expand" for="c-40602825">[2 more]</label></div><br/><div class="children"><div class="content">I agree, and would add that agile is bad because it&#x27;s used to iterate along the product vertical, so first create an MVP, then add features. Instead it could be used to iterate from a technical standpoint, first adding the helper functions, then the interfaces, then some of the core functionality.. but the problem there is that most orgs prefer immediate &quot;business value&quot; at the cost of long term good engineering. In some cases, when the application is meant to be short-lived this makes sense, but more often than not I&#x27;ve seen teams suffer from this approach, not realizing they have been digging their own hole for years.</div><br/><div id="40603069" class="c"><input type="checkbox" id="c-40603069" checked=""/><div class="controls bullet"><span class="by">exe34</span><span>|</span><a href="#40597467">root</a><span>|</span><a href="#40602825">parent</a><span>|</span><a href="#40597627">next</a><span>|</span><label class="collapse" for="c-40603069">[-]</label><label class="expand" for="c-40603069">[1 more]</label></div><br/><div class="children"><div class="content">&gt; so first create an MVP, then add features.<p>It seems to guarantee technical debt starts to build as soon as possible and as fast as possible!<p>(I.e. I&#x27;m referring to agile as it is practised, not the true scotsman&#x27;s agile. We apply the same rigour towards socialism.)</div><br/></div></div></div></div></div></div></div></div><div id="40597627" class="c"><input type="checkbox" id="c-40597627" checked=""/><div class="controls bullet"><span class="by">Hendrikto</span><span>|</span><a href="#40597467">parent</a><span>|</span><a href="#40600808">prev</a><span>|</span><a href="#40599002">next</a><span>|</span><label class="collapse" for="c-40597627">[-]</label><label class="expand" for="c-40597627">[2 more]</label></div><br/><div class="children"><div class="content">&gt; They are often obsessed with &quot;best-practices&quot;<p>Tell them YAGNI is also a best practice :D</div><br/><div id="40599603" class="c"><input type="checkbox" id="c-40599603" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40597467">root</a><span>|</span><a href="#40597627">parent</a><span>|</span><a href="#40599002">next</a><span>|</span><label class="collapse" for="c-40599603">[-]</label><label class="expand" for="c-40599603">[1 more]</label></div><br/><div class="children"><div class="content">Yes. So is KISS.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;KISS_principle" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;KISS_principle</a></div><br/></div></div></div></div><div id="40599002" class="c"><input type="checkbox" id="c-40599002" checked=""/><div class="controls bullet"><span class="by">xedrac</span><span>|</span><a href="#40597467">parent</a><span>|</span><a href="#40597627">prev</a><span>|</span><a href="#40599519">next</a><span>|</span><label class="collapse" for="c-40599002">[-]</label><label class="expand" for="c-40599002">[7 more]</label></div><br/><div class="children"><div class="content">Yes, over engineering solutions is a constant thorn in my side.  The end result is you get a lot of additional complexity for basically no benefit.  In my experience, if new requirements do come down the pipeline at some later time, the generic solution you previously built will be completely inadequate and will need to be redone anyway.  Solve the problem in front of you, not some unknown future problem.</div><br/><div id="40601438" class="c"><input type="checkbox" id="c-40601438" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#40597467">root</a><span>|</span><a href="#40599002">parent</a><span>|</span><a href="#40601342">next</a><span>|</span><label class="collapse" for="c-40601438">[-]</label><label class="expand" for="c-40601438">[5 more]</label></div><br/><div class="children"><div class="content">On the other hand, often a &quot;quick and dirty&quot; solution unexpectedly becomes the foundation of a lot of other stuff, which can be a persistent pain in the future, while the cost of rewriting the whole thing increases the more other stuff depends on it.<p>There are two poles: On the one side is making everything an unmaintainable pile of quick hacks, on the other side is over engineering everything. You want to be somewhere in the middle.</div><br/><div id="40601681" class="c"><input type="checkbox" id="c-40601681" checked=""/><div class="controls bullet"><span class="by">sigseg1v</span><span>|</span><a href="#40597467">root</a><span>|</span><a href="#40601438">parent</a><span>|</span><a href="#40602307">next</a><span>|</span><label class="collapse" for="c-40601681">[-]</label><label class="expand" for="c-40601681">[2 more]</label></div><br/><div class="children"><div class="content">Totally agree, it needs a careful balance. But is it possible to know when to use what?<p>Anecdote: A couple years ago I migrated a 1M+ LOC application from one database to another, cutting the cloud hosting costs practically in half. This was absolutely massive for the company. It took a bit less than a year, but was possible because the people who designed the application didn&#x27;t write any hardcoded queries, and everything went through an ORM or a query builder. Everything was built to an interface, even though they all only had one implementation. This turned out to be absolutely critical when we had to add the second implementation (and because we needed to maintain compatibility for the original implementation at the same time due to some one-off contracts) and the migration would not have been worth it cost-wise if the proper architecture wasn&#x27;t in place from the start.<p>Now take the same application. It has tons of complicated architecture stuff implemented in house. Parts of it are definitely overengineered. It&#x27;s been apparent when doing other upgrades and finding out &quot;oh... this doesn&#x27;t work because it&#x27;s using a custom JSON serializer&quot; that the choice to do that was poor.<p>In the end, I think the right choice for that application was the complex design that allowed those big migrations. For others, they might never do that and only get hit with downsides.<p>What it needs is likely a good vision and someone smart to know what to abstract and what to not abstract such that it will have been a good choice 15 years down the road.</div><br/><div id="40606411" class="c"><input type="checkbox" id="c-40606411" checked=""/><div class="controls bullet"><span class="by">mobiuscog</span><span>|</span><a href="#40597467">root</a><span>|</span><a href="#40601681">parent</a><span>|</span><a href="#40602307">next</a><span>|</span><label class="collapse" for="c-40606411">[-]</label><label class="expand" for="c-40606411">[1 more]</label></div><br/><div class="children"><div class="content">ORMs and query builders can also constrain the implementation from a performance and flexibility perspective though.<p>Your anecdote and reflections are all absolutely true in my experience, but I&#x27;ve found just as many problems with off-the-shelf ORMs.<p>The key is the clean boundaries&#x2F;interfaces and keeping things simple - leaving the bridge intact so that your enemies may retreat.</div><br/></div></div></div></div><div id="40602307" class="c"><input type="checkbox" id="c-40602307" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#40597467">root</a><span>|</span><a href="#40601438">parent</a><span>|</span><a href="#40601681">prev</a><span>|</span><a href="#40602191">next</a><span>|</span><label class="collapse" for="c-40602307">[-]</label><label class="expand" for="c-40602307">[1 more]</label></div><br/><div class="children"><div class="content">In my 25-year career I’ve experienced easily fifty times as much pain from underthought and hastily-implemented systems than I have from overengineered ones.<p>Sure, build user-facing stuff cheaply and ready to be thrown away as requirements change. But libraries, tooling, and infrastructure that everything else is built on top of should have thought and care invested in it. This will return dividends.<p>We spend so much time as an industry worried that somebody might put five percent more effort into a project than it’s worth, that the overwhelming majority of engineers have no idea whatsoever of how to build something to be reliable, to be easily iterated on, and to last. And so we spend tens of times more effort trying to build on top of a mountain of crap.</div><br/></div></div><div id="40602191" class="c"><input type="checkbox" id="c-40602191" checked=""/><div class="controls bullet"><span class="by">dessimus</span><span>|</span><a href="#40597467">root</a><span>|</span><a href="#40601438">parent</a><span>|</span><a href="#40602307">prev</a><span>|</span><a href="#40601342">next</a><span>|</span><label class="collapse" for="c-40602191">[-]</label><label class="expand" for="c-40602191">[1 more]</label></div><br/><div class="children"><div class="content">&gt; On the other hand, often a &quot;quick and dirty&quot; solution unexpectedly becomes the foundation of a lot of other stuff<p>This is how Access &quot;databases&quot; and Excel spreadsheets often become mission-critical in SMBs. &quot;We&#x27;ll deal with needing a database server down the road...&quot;</div><br/></div></div></div></div><div id="40601342" class="c"><input type="checkbox" id="c-40601342" checked=""/><div class="controls bullet"><span class="by">outworlder</span><span>|</span><a href="#40597467">root</a><span>|</span><a href="#40599002">parent</a><span>|</span><a href="#40601438">prev</a><span>|</span><a href="#40599519">next</a><span>|</span><label class="collapse" for="c-40601342">[-]</label><label class="expand" for="c-40601342">[1 more]</label></div><br/><div class="children"><div class="content">The only thing I&#x27;ll add is: do the simplest thing that can possibly work, but no simpler.<p>Don&#x27;t back yourself into a corner. If a solution will block you from doing the right thing later, maybe some additional engineering may be needed after all to ensure you can continue to iterate. In large companies, inertia is enormous. Once a solution is in place and gets replicated, backtracking may become a herculean task.</div><br/></div></div></div></div><div id="40599519" class="c"><input type="checkbox" id="c-40599519" checked=""/><div class="controls bullet"><span class="by">pxtail</span><span>|</span><a href="#40597467">parent</a><span>|</span><a href="#40599002">prev</a><span>|</span><a href="#40599799">next</a><span>|</span><label class="collapse" for="c-40599519">[-]</label><label class="expand" for="c-40599519">[4 more]</label></div><br/><div class="children"><div class="content">&gt;starting with the problem they need to solve and focusing on the minimum needed to just solve that problem<p>To be fair if held strictly to these principles their work would revolve mostly around gluing together various Apis, services and sometimes adjusting already written software to company&#x27;s needs. So I&#x27;m not surprised they are using every possible opportunity to write something here and there, this menial digital plumber&#x27;s work takes its toll and one needs to try to squeeze in something a bit more enjoyable from time to time just to keep sanity in place a bit longer</div><br/><div id="40600610" class="c"><input type="checkbox" id="c-40600610" checked=""/><div class="controls bullet"><span class="by">SR2Z</span><span>|</span><a href="#40597467">root</a><span>|</span><a href="#40599519">parent</a><span>|</span><a href="#40599799">next</a><span>|</span><label class="collapse" for="c-40600610">[-]</label><label class="expand" for="c-40600610">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, I am no longer a junior engineer.<p>When I WAS the bane of my existence was senior and staff engineers hoarding all the fun, new work for themselves and forcing me into &quot;bitch work&quot; where I&#x27;m just cleaning up old, broken code and handling bugs.  I finally got promoted because I explicitly ignored my manager to deploy changes that were needed for my company, and that was what finally got me promoted.  Of course, at that point, I had been looking for a new job and just left instead of taking the shitty, bottom-of-band promo increase.<p>It&#x27;s awful for promotion chances, and it forced me to quit.</div><br/><div id="40606313" class="c"><input type="checkbox" id="c-40606313" checked=""/><div class="controls bullet"><span class="by">johnnyanmac</span><span>|</span><a href="#40597467">root</a><span>|</span><a href="#40600610">parent</a><span>|</span><a href="#40601729">next</a><span>|</span><label class="collapse" for="c-40606313">[-]</label><label class="expand" for="c-40606313">[1 more]</label></div><br/><div class="children"><div class="content">Not just politics, I almost feel it can hamper you as an engineer. If you just do basic plumbing for 10 years, are you really an engineer with 10 YOE or one with 2YOE 5 times over because everyone needs a plumber?<p>2-3 years seems to be where that valuable plumbing experience starts to plateu. I don&#x27;t know how engineers these days that move companies every other year even get a chance to grow when you&#x27;re doing a soft restart at every job hop.</div><br/></div></div><div id="40601729" class="c"><input type="checkbox" id="c-40601729" checked=""/><div class="controls bullet"><span class="by">lpapez</span><span>|</span><a href="#40597467">root</a><span>|</span><a href="#40600610">parent</a><span>|</span><a href="#40606313">prev</a><span>|</span><a href="#40599799">next</a><span>|</span><label class="collapse" for="c-40601729">[-]</label><label class="expand" for="c-40601729">[1 more]</label></div><br/><div class="children"><div class="content">&gt; When I WAS the bane of my existence was senior and staff engineers hoarding all the fun, new work for themselves and forcing me into &quot;bitch work&quot; where I&#x27;m just cleaning up old, broken code and handling bugs.<p>Oh how I relate to this...<p>That&#x27;s why these days I go out of my way to &quot;save&quot; interesting work for my junior colleagues and have them grow through it.</div><br/></div></div></div></div></div></div><div id="40599799" class="c"><input type="checkbox" id="c-40599799" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40597467">parent</a><span>|</span><a href="#40599519">prev</a><span>|</span><a href="#40597970">next</a><span>|</span><label class="collapse" for="c-40599799">[-]</label><label class="expand" for="c-40599799">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Don’t implement something unless you need it right now<p>Useful advice to start with. It’s a rule that experts are allowed to break though.</div><br/></div></div><div id="40597970" class="c"><input type="checkbox" id="c-40597970" checked=""/><div class="controls bullet"><span class="by">Narhem</span><span>|</span><a href="#40597467">parent</a><span>|</span><a href="#40599799">prev</a><span>|</span><a href="#40605028">next</a><span>|</span><label class="collapse" for="c-40597970">[-]</label><label class="expand" for="c-40597970">[1 more]</label></div><br/><div class="children"><div class="content">Definitely agree.<p>But there’s a fine line between implementing things but the difficulty being understanding long term vision and making sure short term improvements don’t actively work against the ‘ideal’. Kind of hard for newer programmers to get a good sense of system design.</div><br/></div></div><div id="40605028" class="c"><input type="checkbox" id="c-40605028" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#40597467">parent</a><span>|</span><a href="#40597970">prev</a><span>|</span><a href="#40597789">next</a><span>|</span><label class="collapse" for="c-40605028">[-]</label><label class="expand" for="c-40605028">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is a constant battle I fight with more junior programmers<p>This can go both ways, as senior devs can just want to use what they know.</div><br/></div></div><div id="40597789" class="c"><input type="checkbox" id="c-40597789" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#40597467">parent</a><span>|</span><a href="#40605028">prev</a><span>|</span><a href="#40603743">next</a><span>|</span><label class="collapse" for="c-40597789">[-]</label><label class="expand" for="c-40597789">[1 more]</label></div><br/><div class="children"><div class="content">Yep. I attribute YAGNI to a lot of my quickest prototypes and some of my best code.</div><br/></div></div><div id="40603743" class="c"><input type="checkbox" id="c-40603743" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#40597467">parent</a><span>|</span><a href="#40597789">prev</a><span>|</span><a href="#40600170">next</a><span>|</span><label class="collapse" for="c-40603743">[-]</label><label class="expand" for="c-40603743">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had to fight this battle with a Principal Engineer. He created a framework encrusted with DI malarkey that turned building a standard Koa microservice into a twisty maze of module dependency declarations and configuration objects. Just complexity on top of complexity, all for the sake of what, pulling some rows out of a database?</div><br/></div></div><div id="40600170" class="c"><input type="checkbox" id="c-40600170" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40597467">parent</a><span>|</span><a href="#40603743">prev</a><span>|</span><a href="#40602684">next</a><span>|</span><label class="collapse" for="c-40600170">[-]</label><label class="expand" for="c-40600170">[1 more]</label></div><br/><div class="children"><div class="content">&gt; [Junior programmers] are often obsessed with &quot;best-practices&quot; and whatever fancy new tool is trending, but they have trouble starting with the problem they need to solve and focusing on the minimum needed to just solve that problem.<p>I’ve observed&#x2F;experienced the same exact thing [0]. I think it’s due to a combo of (1) not knowing what “the right way” to do things are and (2) thinking it’ll make your peers perceive you as more knowledgeable or advanced if they see you writing “best practices” code. Not to mention that sometimes the simpler solutions are so simple, they make you feel like you’re not a real software engineer. I usually just do my best to help them understand that simple solutions are okay, especially since (1) I’ve been there myself when I was in their shoes and (2) I know they have good intentions.<p>[0]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40527071">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40527071</a></div><br/></div></div></div></div><div id="40596865" class="c"><input type="checkbox" id="c-40596865" checked=""/><div class="controls bullet"><span class="by">edu</span><span>|</span><a href="#40597467">prev</a><span>|</span><a href="#40598202">next</a><span>|</span><label class="collapse" for="c-40596865">[-]</label><label class="expand" for="c-40596865">[2 more]</label></div><br/><div class="children"><div class="content">The site seems hugged to death, cached: <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20240606103630&#x2F;https:&#x2F;&#x2F;edw.is&#x2F;learning-vulkan&#x2F;" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20240606103630&#x2F;https:&#x2F;&#x2F;edw.is&#x2F;le...</a></div><br/><div id="40597403" class="c"><input type="checkbox" id="c-40597403" checked=""/><div class="controls bullet"><span class="by">eliasdaler</span><span>|</span><a href="#40596865">parent</a><span>|</span><a href="#40598202">next</a><span>|</span><label class="collapse" for="c-40597403">[-]</label><label class="expand" for="c-40597403">[1 more]</label></div><br/><div class="children"><div class="content">Thank you! Also, everything explained in the article is pretty much here: <a href="https:&#x2F;&#x2F;github.com&#x2F;eliasdaler&#x2F;edbr">https:&#x2F;&#x2F;github.com&#x2F;eliasdaler&#x2F;edbr</a></div><br/></div></div></div></div><div id="40598202" class="c"><input type="checkbox" id="c-40598202" checked=""/><div class="controls bullet"><span class="by">samiv</span><span>|</span><a href="#40596865">prev</a><span>|</span><a href="#40598055">next</a><span>|</span><label class="collapse" for="c-40598202">[-]</label><label class="expand" for="c-40598202">[17 more]</label></div><br/><div class="children"><div class="content">This might come off as a surprise to some people but getting good performance with Vulkan (compared to say OpenGL) isn&#x27;t trivial because:<p>the Vulkan driver is missing that ~20k loc of code that OpenGL driver does for you to set up the rendering pipelines, render targets etc.<p>This is all code that already exists in the OpenGL driver and has been optimized for +20 years by the best people in the industry.<p>So when you start putting together the equivalent functionality that you get out of the box with OpenGL on top of Vulkan doing it the naive way doesn&#x27;t magically give you good perf, but you gotta put in some more work and then the real problems start stacking up  such as making sure that you have all right fences etc synchronization primitives in place and so forth.<p>So only when you actually know what you&#x27;re doing and you&#x27;re capable of executing your rendering with good parallelism and correct synchronization can you start dreaming about the performance benefits of using Vulkan.<p>So for a hobbyist like myself.. I&#x27;m using OpenGL ES3 for the simplicity of it and because it&#x27;s already good enough for me and I have more pressing things to matter than spend time writing those pesky Vulkan vertex descriptor descriptor descriptors ;-)<p>Btw this is my engine:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ensisoft&#x2F;detonator">https:&#x2F;&#x2F;github.com&#x2F;ensisoft&#x2F;detonator</a></div><br/><div id="40598641" class="c"><input type="checkbox" id="c-40598641" checked=""/><div class="controls bullet"><span class="by">OnionBlender</span><span>|</span><a href="#40598202">parent</a><span>|</span><a href="#40598478">next</a><span>|</span><label class="collapse" for="c-40598641">[-]</label><label class="expand" for="c-40598641">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard the same thing about DirectX 12 vs DirectX 11. One book basically said that you will probably have worse performance in DirectX 12 vs DirectX 11 if you don&#x27;t know what you&#x27;re doing.</div><br/><div id="40598740" class="c"><input type="checkbox" id="c-40598740" checked=""/><div class="controls bullet"><span class="by">sigmoid10</span><span>|</span><a href="#40598202">root</a><span>|</span><a href="#40598641">parent</a><span>|</span><a href="#40598478">next</a><span>|</span><label class="collapse" for="c-40598740">[-]</label><label class="expand" for="c-40598740">[2 more]</label></div><br/><div class="children"><div class="content">DirectX 12 only gets interesting when you want hardware raytracing support to make use of the new Nvidia cards on windows. Tbf that is pretty cool, which is why I actually dabbled with it a little. But it&#x27;s not necessary for the vast, vast majority of graphics applications.</div><br/><div id="40601877" class="c"><input type="checkbox" id="c-40601877" checked=""/><div class="controls bullet"><span class="by">dc443</span><span>|</span><a href="#40598202">root</a><span>|</span><a href="#40598740">parent</a><span>|</span><a href="#40598478">next</a><span>|</span><label class="collapse" for="c-40601877">[-]</label><label class="expand" for="c-40601877">[1 more]</label></div><br/><div class="children"><div class="content">I wonder how much less ergonomic is is for getting there via Vulkan. For the ray tracing shaders.</div><br/></div></div></div></div></div></div><div id="40598478" class="c"><input type="checkbox" id="c-40598478" checked=""/><div class="controls bullet"><span class="by">harrison_clarke</span><span>|</span><a href="#40598202">parent</a><span>|</span><a href="#40598641">prev</a><span>|</span><a href="#40598709">next</a><span>|</span><label class="collapse" for="c-40598478">[-]</label><label class="expand" for="c-40598478">[5 more]</label></div><br/><div class="children"><div class="content">the biggest part for me is the shader compiler. opengl has one built in, vulkan requires me to pull in yet another dependency<p>i&#x27;ve heard that vulkan allows bindless textures now, so the descriptor nonsense is a bit less awful that it used to be<p>vulkan is appealing, but there&#x27;s a high initial cost that i don&#x27;t want to pay</div><br/><div id="40598670" class="c"><input type="checkbox" id="c-40598670" checked=""/><div class="controls bullet"><span class="by">sigmoid10</span><span>|</span><a href="#40598202">root</a><span>|</span><a href="#40598478">parent</a><span>|</span><a href="#40599145">next</a><span>|</span><label class="collapse" for="c-40598670">[-]</label><label class="expand" for="c-40598670">[3 more]</label></div><br/><div class="children"><div class="content">Vulkan is super appealing if you&#x27;re in the industry and have the time and resources necessary to profit from its advantages. But if you&#x27;re a single dev who wants to learn game engine design, you&#x27;re going to have a bad time. Most people also don&#x27;t get that game engine design is very far removed from actual game design. You can have a ton of fun learning math, physics and computer science when building an engine, but beware that you&#x27;ll likely be mentally and physically exhausted long before you actually get to build a fun <i>game</i>.</div><br/><div id="40606609" class="c"><input type="checkbox" id="c-40606609" checked=""/><div class="controls bullet"><span class="by">johnnyanmac</span><span>|</span><a href="#40598202">root</a><span>|</span><a href="#40598670">parent</a><span>|</span><a href="#40601571">next</a><span>|</span><label class="collapse" for="c-40606609">[-]</label><label class="expand" for="c-40606609">[1 more]</label></div><br/><div class="children"><div class="content">&gt;if you&#x27;re in the industry and have the time and resources necessary to profit from its advantages.<p>I don&#x27;t even know how you get into the graphics industry these days. The bar is so high and I just don&#x27;t see how you get the knowledge needed for it. I graduated years ago and don&#x27;t feel any closer now than back in the mid 2010&#x27;s despite having a lot more experience to point to in other parts of games.</div><br/></div></div><div id="40601571" class="c"><input type="checkbox" id="c-40601571" checked=""/><div class="controls bullet"><span class="by">harrison_clarke</span><span>|</span><a href="#40598202">root</a><span>|</span><a href="#40598670">parent</a><span>|</span><a href="#40606609">prev</a><span>|</span><a href="#40599145">next</a><span>|</span><label class="collapse" for="c-40601571">[-]</label><label class="expand" for="c-40601571">[1 more]</label></div><br/><div class="children"><div class="content">vulkan doesn&#x27;t have global state, and the error handling is better<p>but it&#x27;s not batteries-included, and that&#x27;s often to be a deciding factor at small scales<p>i think if you&#x27;re going to dabble in engine dev, you pick which one you want depending on which part of the engine you find interesting. if you want to make a game, you pick up unity or godot or something</div><br/></div></div></div></div><div id="40599145" class="c"><input type="checkbox" id="c-40599145" checked=""/><div class="controls bullet"><span class="by">kiririn</span><span>|</span><a href="#40598202">root</a><span>|</span><a href="#40598478">parent</a><span>|</span><a href="#40598670">prev</a><span>|</span><a href="#40598709">next</a><span>|</span><label class="collapse" for="c-40599145">[-]</label><label class="expand" for="c-40599145">[1 more]</label></div><br/><div class="children"><div class="content">Also in the case of glslang there are enough references to GPL to (probably erroneously) strike fear into legal departments</div><br/></div></div></div></div><div id="40598709" class="c"><input type="checkbox" id="c-40598709" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#40598202">parent</a><span>|</span><a href="#40598478">prev</a><span>|</span><a href="#40598863">next</a><span>|</span><label class="collapse" for="c-40598709">[-]</label><label class="expand" for="c-40598709">[7 more]</label></div><br/><div class="children"><div class="content">Could someone write an OpenGL to Vulkan layer as a library so that we can target Vulkan but at a higher level of abstraction?<p>Then gradually we can replace that library with routines optimised for the use case?</div><br/><div id="40598766" class="c"><input type="checkbox" id="c-40598766" checked=""/><div class="controls bullet"><span class="by">cluoma</span><span>|</span><a href="#40598202">root</a><span>|</span><a href="#40598709">parent</a><span>|</span><a href="#40598995">next</a><span>|</span><label class="collapse" for="c-40598766">[-]</label><label class="expand" for="c-40598766">[5 more]</label></div><br/><div class="children"><div class="content">There is the Zink project[1]. It is an OGL to Vulkan translation layer.<p>[1]<a href="https:&#x2F;&#x2F;docs.mesa3d.org&#x2F;drivers&#x2F;zink.html" rel="nofollow">https:&#x2F;&#x2F;docs.mesa3d.org&#x2F;drivers&#x2F;zink.html</a></div><br/><div id="40603534" class="c"><input type="checkbox" id="c-40603534" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#40598202">root</a><span>|</span><a href="#40598766">parent</a><span>|</span><a href="#40598995">next</a><span>|</span><label class="collapse" for="c-40603534">[-]</label><label class="expand" for="c-40603534">[4 more]</label></div><br/><div class="children"><div class="content">But it&#x27;s part of Mesa, it&#x27;s not something you can drop into an app written against OpenGL to translate the calls to Vulkan right?</div><br/><div id="40606562" class="c"><input type="checkbox" id="c-40606562" checked=""/><div class="controls bullet"><span class="by">MindSpunk</span><span>|</span><a href="#40598202">root</a><span>|</span><a href="#40603534">parent</a><span>|</span><a href="#40605010">next</a><span>|</span><label class="collapse" for="c-40606562">[-]</label><label class="expand" for="c-40606562">[1 more]</label></div><br/><div class="children"><div class="content">You absolutely can. It can even build and run on Windows too. I’ve used it to play some modded Minecraft builds where Zink outperformed the native OpenGL2 drivers on my machine. Mainly because the native OpenGL2 driver was terrible at the time for my hardware but it’s 100% a thing you can do.<p>Some games are even shipping on it [1]<p>[1] <a href="https:&#x2F;&#x2F;www.gamingonlinux.com&#x2F;2023&#x2F;02&#x2F;x-plane-12-now-uses-the-open-source-zink-driver-to-help-plugins&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.gamingonlinux.com&#x2F;2023&#x2F;02&#x2F;x-plane-12-now-uses-th...</a></div><br/></div></div><div id="40605010" class="c"><input type="checkbox" id="c-40605010" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#40598202">root</a><span>|</span><a href="#40603534">parent</a><span>|</span><a href="#40606562">prev</a><span>|</span><a href="#40598995">next</a><span>|</span><label class="collapse" for="c-40605010">[-]</label><label class="expand" for="c-40605010">[2 more]</label></div><br/><div class="children"><div class="content">Where do you think &lt;GL&#x2F;gl.h&gt; comes from?</div><br/></div></div></div></div></div></div><div id="40598995" class="c"><input type="checkbox" id="c-40598995" checked=""/><div class="controls bullet"><span class="by">sehugg</span><span>|</span><a href="#40598202">root</a><span>|</span><a href="#40598709">parent</a><span>|</span><a href="#40598766">prev</a><span>|</span><a href="#40598863">next</a><span>|</span><label class="collapse" for="c-40598995">[-]</label><label class="expand" for="c-40598995">[1 more]</label></div><br/><div class="children"><div class="content">ANGLE is the (certified compliant) OpenGL ES -&gt; Vulkan&#x2F;Metal&#x2F;Direct3D&#x2F;etc translation layer used by your friendly neighborhood web browser. There are docs about how the Vulkan translation layer works: <a href="https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;angle&#x2F;angle&#x2F;+&#x2F;HEAD&#x2F;src&#x2F;libANGLE&#x2F;renderer&#x2F;vulkan&#x2F;README.md" rel="nofollow">https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;angle&#x2F;angle&#x2F;+&#x2F;HEAD&#x2F;src&#x2F;lib...</a></div><br/></div></div></div></div></div></div><div id="40598055" class="c"><input type="checkbox" id="c-40598055" checked=""/><div class="controls bullet"><span class="by">rossant</span><span>|</span><a href="#40598202">prev</a><span>|</span><a href="#40599394">next</a><span>|</span><label class="collapse" for="c-40598055">[-]</label><label class="expand" for="c-40598055">[1 more]</label></div><br/><div class="children"><div class="content">Great writeup! I learned Vulkan myself so that I could write a scientific data visualization engine (<a href="https:&#x2F;&#x2F;datoviz.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;datoviz.org&#x2F;</a> still quite experimental, will release a newer version soon). I had some knowledge of OpenGL before and learning Vulkan was SO hard. The learning resources weren&#x27;t that great 5 years ago. I took up the challenge and it was so much fun. It took me months to understand the role of the various dozens of abstractions. In the process I wrote a small wrapper around Vulkan (<a href="https:&#x2F;&#x2F;datoviz.org&#x2F;api&#x2F;vklite&#x2F;" rel="nofollow">https:&#x2F;&#x2F;datoviz.org&#x2F;api&#x2F;vklite&#x2F;</a>) to make it a bit less painful to work with (it supports a subset of the features, those that are the most required for scientific visualization purposes).</div><br/></div></div><div id="40599394" class="c"><input type="checkbox" id="c-40599394" checked=""/><div class="controls bullet"><span class="by">wudangmonk</span><span>|</span><a href="#40598055">prev</a><span>|</span><a href="#40598595">next</a><span>|</span><label class="collapse" for="c-40599394">[-]</label><label class="expand" for="c-40599394">[7 more]</label></div><br/><div class="children"><div class="content">Its great to have more Vulkan resources but unfortunately this one too suffers from the same problem as every other resource I&#x27;ve found on getting something on the screen with Vulkan.<p>They all introduce another layer of abstraction on top of Vulkan even before giving you the simple case without it. Its always use vk-bootstrap, volk, vma or someother library.<p>Is there a single resource anywhere that gives an example of doing the memory management manually because I havent found one, it seems like its either use vma or go figure out the spec are the only choices you are given. Is it too much to ask to just get the most basic example without having to add any libraries other than the Vulkan sdk itself?.</div><br/><div id="40599496" class="c"><input type="checkbox" id="c-40599496" checked=""/><div class="controls bullet"><span class="by">harrison_clarke</span><span>|</span><a href="#40599394">parent</a><span>|</span><a href="#40601222">next</a><span>|</span><label class="collapse" for="c-40599496">[-]</label><label class="expand" for="c-40599496">[2 more]</label></div><br/><div class="children"><div class="content">there&#x27;s a common gamedev practice of allocating a big chunk of memory up front, and then using a bump allocator inside of it<p>in most games, there are about 3 &quot;lifetimes&quot;:
- permanent&#x2F;startup
- per-level
- per-frame<p>and they&#x27;re nested. so, you can use a single stack allocator for all of them. at the end of the frame&#x2F;level, pop back to where it started<p>there are more complicated patterns, but this one will get you pretty far. you can use it on the CPU and the GPU</div><br/></div></div><div id="40601222" class="c"><input type="checkbox" id="c-40601222" checked=""/><div class="controls bullet"><span class="by">izacus</span><span>|</span><a href="#40599394">parent</a><span>|</span><a href="#40599496">prev</a><span>|</span><a href="#40600838">next</a><span>|</span><label class="collapse" for="c-40601222">[-]</label><label class="expand" for="c-40601222">[3 more]</label></div><br/><div class="children"><div class="content">Vulkan was always designed to be extremely low level API and with an idea in mind, that libraries would be required to get it up to level of OpenGL&#x2F;DX11 and others. So in this respect, extensively using libraries on top of it is very normal, just like you don&#x27;t write your software against syscalls these days.</div><br/><div id="40601632" class="c"><input type="checkbox" id="c-40601632" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40599394">root</a><span>|</span><a href="#40601222">parent</a><span>|</span><a href="#40600838">next</a><span>|</span><label class="collapse" for="c-40601632">[-]</label><label class="expand" for="c-40601632">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what bothers me though; why not have an <i>official</i> higher level API that&#x27;s less awful to use?  Instead you get a bunch of third party libraries bolted on top of everything.</div><br/><div id="40602489" class="c"><input type="checkbox" id="c-40602489" checked=""/><div class="controls bullet"><span class="by">izacus</span><span>|</span><a href="#40599394">root</a><span>|</span><a href="#40601632">parent</a><span>|</span><a href="#40600838">next</a><span>|</span><label class="collapse" for="c-40602489">[-]</label><label class="expand" for="c-40602489">[1 more]</label></div><br/><div class="children"><div class="content">Why though? Khronos doesn&#x27;t have the best record of API design and there&#x27;s plenty of other projects that are much higher level and simpler to use for a newbie developer. You can scroll just a bit up and see just how many webdevs end up using webgpu which is closer to the abstraction they prefer.</div><br/></div></div></div></div></div></div><div id="40600838" class="c"><input type="checkbox" id="c-40600838" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#40599394">parent</a><span>|</span><a href="#40601222">prev</a><span>|</span><a href="#40598595">next</a><span>|</span><label class="collapse" for="c-40600838">[-]</label><label class="expand" for="c-40600838">[1 more]</label></div><br/><div class="children"><div class="content">Yes. It&#x27;s too much to ask. Even the &quot;official&quot; examples by documentation do not do it. Reading the Vulkan specifications is an exercise in practicing technical bullshit.<p>When you&#x27;re corroborating some random person&#x27;s third-party instructions on initializing Vulkan and comparing those notes to what&#x27;s done in Khronos Group repositories and reading the Vulkan 1.3 spec and realizing you have to read the specification out-of-order to get anything done, it&#x27;s clear that they failed.<p>They failed. It&#x27;s bad work by any other standard. But you&#x27;ll do the work once and forget about it for the most part, so professionals don&#x27;t complain too much.<p>Read my other comment in this thread for a portion of source code annotated with the specification chapters and sections.<p>It&#x27;s a generic implementation that can be used with SDL and others.<p>Edit: As of the time of writing, the standard approach is to use VMA and Volk, both of which are included with the official Vulkan SDK. That should tell you enough about the state of the art.</div><br/></div></div></div></div><div id="40598595" class="c"><input type="checkbox" id="c-40598595" checked=""/><div class="controls bullet"><span class="by">OnionBlender</span><span>|</span><a href="#40599394">prev</a><span>|</span><a href="#40604815">next</a><span>|</span><label class="collapse" for="c-40598595">[-]</label><label class="expand" for="c-40598595">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been trying to learn Vulkan on and off for years (I used to know OpenGL ES 2&amp;3 pretty well).<p>One thing I found difficult is understanding how to use things in a real engine rather than a sample. A lot of samples will allocate exactly what they need or allocate hundreds of something so that they&#x27;re unlikely to run out. When I was trying to learn DirectX, I found Microsoft&#x27;s MiniEngine helpful because it wasn&#x27;t overly complex but had things like a DescriptorAllocator that would manage allocating descriptors. Is there something similar for Vulkan?<p>Another thing I struggle with is knowing how to create good abstractions like materials, meshes, and how to decide in what order to render things. Are there any good engines or frameworks I should study in order to move beyond tutorials?</div><br/><div id="40599512" class="c"><input type="checkbox" id="c-40599512" checked=""/><div class="controls bullet"><span class="by">gmueckl</span><span>|</span><a href="#40598595">parent</a><span>|</span><a href="#40599324">next</a><span>|</span><label class="collapse" for="c-40599512">[-]</label><label class="expand" for="c-40599512">[1 more]</label></div><br/><div class="children"><div class="content">Vulkan is quite similar DirectX 12. Done concepts transfer directly. For memory allocation, you can use a library called vma to assst you. It takes care of a few stupid edge cases that the Standard accunulated over the years and is quite powerful.<p>For descriptor set allocation, there is only one pattern that nakes sense to me: expect the pools to be rather short lived and expect to have many of them. Allocate a new one once allocation from the current one fails - don&#x27;t keep your own counters for alocated descriptors. The standard allows for all kinds of pool behaviors that deviate from strict counting. Discard old pools after the the last command buffer referencing that pool is finished.<p>Pipeline barriers and image layouts are a big pain in the butt. It makes sense to abstract them away in a layer that tracks last usage and lat Format for everything and adds barriers as required. It can get complex, but ot&#x27;s worthbitnonce you have optional passen or passes that can get reordered or other more complex things going on.<p>About neshes, materials, rendering order: this goes beyond what I can summarize in a single HN post. This depends a lot on the choice of rendering algorithms and I do not consider a very generalized solution to be worth the (enormous) effortto get this right.</div><br/></div></div><div id="40599324" class="c"><input type="checkbox" id="c-40599324" checked=""/><div class="controls bullet"><span class="by">cmovq</span><span>|</span><a href="#40598595">parent</a><span>|</span><a href="#40599512">prev</a><span>|</span><a href="#40604815">next</a><span>|</span><label class="collapse" for="c-40599324">[-]</label><label class="expand" for="c-40599324">[1 more]</label></div><br/><div class="children"><div class="content">Take a look at a real engine, something like vkquake is a good reference [1].<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;Novum&#x2F;vkQuake">https:&#x2F;&#x2F;github.com&#x2F;Novum&#x2F;vkQuake</a></div><br/></div></div></div></div><div id="40604815" class="c"><input type="checkbox" id="c-40604815" checked=""/><div class="controls bullet"><span class="by">dynjo</span><span>|</span><a href="#40598595">prev</a><span>|</span><a href="#40602910">next</a><span>|</span><label class="collapse" for="c-40604815">[-]</label><label class="expand" for="c-40604815">[2 more]</label></div><br/><div class="children"><div class="content">Highly recommend this guy’s channel, he livestreams building a Vulkan game engine and he has a crazy style too <a href="https:&#x2F;&#x2F;youtube.com&#x2F;@tokyospliff?si=CMF53295xeETykbP" rel="nofollow">https:&#x2F;&#x2F;youtube.com&#x2F;@tokyospliff?si=CMF53295xeETykbP</a></div><br/><div id="40604956" class="c"><input type="checkbox" id="c-40604956" checked=""/><div class="controls bullet"><span class="by">wilkystyle</span><span>|</span><a href="#40604815">parent</a><span>|</span><a href="#40602910">next</a><span>|</span><label class="collapse" for="c-40604956">[-]</label><label class="expand" for="c-40604956">[1 more]</label></div><br/><div class="children"><div class="content">This is great, thanks for sharing! No kidding about the interesting style, too. Very entertaining.<p>For example, his quick sidebar to explain fundamental shader types was great even for me, as someone who is not that familiar with the topic (link goes to 11:20):<p><a href="https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=azdjSi_9Xyc&amp;t=11m20s" rel="nofollow">https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=azdjSi_9Xyc&amp;t=11m20s</a></div><br/></div></div></div></div><div id="40602910" class="c"><input type="checkbox" id="c-40602910" checked=""/><div class="controls bullet"><span class="by">rychco</span><span>|</span><a href="#40604815">prev</a><span>|</span><a href="#40597187">next</a><span>|</span><label class="collapse" for="c-40602910">[-]</label><label class="expand" for="c-40602910">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been lurking &amp; following your project for months in the Graphics Programming discord as I work on my own hobby Vulkan engine. It’s been inspiring seeing all the progress you’ve made. I especially admire your willingness to ask questions &amp; share your work-in-progress so openly. Keep up the great work</div><br/></div></div><div id="40597187" class="c"><input type="checkbox" id="c-40597187" checked=""/><div class="controls bullet"><span class="by">archermarks</span><span>|</span><a href="#40602910">prev</a><span>|</span><a href="#40599727">next</a><span>|</span><label class="collapse" for="c-40597187">[-]</label><label class="expand" for="c-40597187">[19 more]</label></div><br/><div class="children"><div class="content">Really nice article! I have some OpenGL familiarity and tried out Vulkan but bounced off of it due to all of the up-front complexity just getting something running. Might give it another shot now!</div><br/><div id="40597357" class="c"><input type="checkbox" id="c-40597357" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#40597187">parent</a><span>|</span><a href="#40601980">next</a><span>|</span><label class="collapse" for="c-40597357">[-]</label><label class="expand" for="c-40597357">[15 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not quite as bad as it used to be, various later additions to Vulkan like dynamic rendering have eliminated some of the complexity it originally had. Figuring out which subset you should be using is a challenge in itself though, especially since there&#x27;s a lot of outdated introductory resources floating around which still promote the ultra-verbose Vulkan 1.0 way of doing things. If a tutorial tells you to use render passes, run away.</div><br/><div id="40597758" class="c"><input type="checkbox" id="c-40597758" checked=""/><div class="controls bullet"><span class="by">BearOso</span><span>|</span><a href="#40597187">root</a><span>|</span><a href="#40597357">parent</a><span>|</span><a href="#40597756">next</a><span>|</span><label class="collapse" for="c-40597758">[-]</label><label class="expand" for="c-40597758">[5 more]</label></div><br/><div class="children"><div class="content">Unfortunately, dynamic rendering didn&#x27;t come about until &quot;recently&quot;. Many devices are stuck on Vulkan 1.1. Go to <a href="http:&#x2F;&#x2F;vulkan.gpuinfo.org&#x2F;listextensions.php" rel="nofollow">http:&#x2F;&#x2F;vulkan.gpuinfo.org&#x2F;listextensions.php</a> and search for dynamic_rendering. It&#x27;s only supported on about 28% of reports.<p>If you want to support those other devices you have to have a non-dynamic rendering path, and then at that point dynamic rendering is just more code. VK_EXT_shader_object is even better, but availability is that much worse.<p><i>Edit</i>: If you are able to find a tutorial using dynamic rendering, learn with that. Render passes obfuscate what&#x27;s going on, and with dynamic rendering you can see exactly what&#x27;s happening.</div><br/><div id="40597882" class="c"><input type="checkbox" id="c-40597882" checked=""/><div class="controls bullet"><span class="by">exDM69</span><span>|</span><a href="#40597187">root</a><span>|</span><a href="#40597758">parent</a><span>|</span><a href="#40597817">next</a><span>|</span><label class="collapse" for="c-40597882">[-]</label><label class="expand" for="c-40597882">[3 more]</label></div><br/><div class="children"><div class="content">&gt; only supported on about 28% of reports.<p>This information is misleading because it includes old reports from years ago, before this feature existed. It does NOT mean that 28% of devices out there have support. You will need Steam hardware survey results and cross reference gpuinfo.org or Android hardware survey results which directly list Vulkan versions.<p>Dynamic rendering is available on all desktop GPUs (Intel, NV, AMD), on all desktop OSes (Windows, Macos, Linux) as long as you&#x27;ve got drivers that are up to date (no older than 2023).<p>For mobile devices, the situation isn&#x27;t as good. Updating mobile GPU drivers is an unsolved problem.</div><br/><div id="40598027" class="c"><input type="checkbox" id="c-40598027" checked=""/><div class="controls bullet"><span class="by">BearOso</span><span>|</span><a href="#40597187">root</a><span>|</span><a href="#40597882">parent</a><span>|</span><a href="#40597817">next</a><span>|</span><label class="collapse" for="c-40598027">[-]</label><label class="expand" for="c-40598027">[2 more]</label></div><br/><div class="children"><div class="content">I get your point. But you might be surprised how many PCs are still in use that have pre-Skylake Intel IGPs. Some people just don&#x27;t update their drivers, either.</div><br/><div id="40598132" class="c"><input type="checkbox" id="c-40598132" checked=""/><div class="controls bullet"><span class="by">exDM69</span><span>|</span><a href="#40597187">root</a><span>|</span><a href="#40598027">parent</a><span>|</span><a href="#40597817">next</a><span>|</span><label class="collapse" for="c-40598132">[-]</label><label class="expand" for="c-40598132">[1 more]</label></div><br/><div class="children"><div class="content">Pre-Skylake Intel never had proper Vulkan support (on Linux at least) so it&#x27;s a non issue.<p>I use a 2015 Skylake laptop for most of my graphics programming project and it&#x27;s got full Vulkan 1.3 and wide set of features. The hardware doesn&#x27;t do mesh shaders or Ray tracing but apart from that every new feature is available.<p>Not updating drivers is a problem, especially on mobile. Thankfully auto updaters are very common these days.</div><br/></div></div></div></div></div></div><div id="40597817" class="c"><input type="checkbox" id="c-40597817" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#40597187">root</a><span>|</span><a href="#40597758">parent</a><span>|</span><a href="#40597882">prev</a><span>|</span><a href="#40597756">next</a><span>|</span><label class="collapse" for="c-40597817">[-]</label><label class="expand" for="c-40597817">[1 more]</label></div><br/><div class="children"><div class="content">You really have to think of Vulkan on PCs and Vulkan on mobile as separate things, if you only care about running on the former then you can easily count on things like dynamic rendering always being available as long as your users drivers are up to date. If you need to target Android though, my condolences.</div><br/></div></div></div></div><div id="40597756" class="c"><input type="checkbox" id="c-40597756" checked=""/><div class="controls bullet"><span class="by">bashmelek</span><span>|</span><a href="#40597187">root</a><span>|</span><a href="#40597357">parent</a><span>|</span><a href="#40597758">prev</a><span>|</span><a href="#40597610">next</a><span>|</span><label class="collapse" for="c-40597756">[-]</label><label class="expand" for="c-40597756">[2 more]</label></div><br/><div class="children"><div class="content">Do you have any recommendations for sources?  I’ve used Vulkan Tutorial, which is a bit stale but I suppose still good for exposure. I’ve also used Vulkan Guide, before its latest overhaul.  That one was educational.  Not sure if I’ll be able to do their new guide, my laptop can’t run some of the more recent versions of Vulkan</div><br/><div id="40598818" class="c"><input type="checkbox" id="c-40598818" checked=""/><div class="controls bullet"><span class="by">OnionBlender</span><span>|</span><a href="#40597187">root</a><span>|</span><a href="#40597756">parent</a><span>|</span><a href="#40597610">next</a><span>|</span><label class="collapse" for="c-40598818">[-]</label><label class="expand" for="c-40598818">[1 more]</label></div><br/><div class="children"><div class="content">Khronos overhauled their docs last year. I&#x27;ve found the &quot;Vulkan Guide&quot; easier to read than the spec.<p><a href="https:&#x2F;&#x2F;docs.vulkan.org&#x2F;guide&#x2F;latest&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;docs.vulkan.org&#x2F;guide&#x2F;latest&#x2F;index.html</a><p>Not to be confused with the tutorial you&#x27;re referring to.<p><a href="https:&#x2F;&#x2F;vkguide.dev" rel="nofollow">https:&#x2F;&#x2F;vkguide.dev</a></div><br/></div></div></div></div><div id="40597610" class="c"><input type="checkbox" id="c-40597610" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#40597187">root</a><span>|</span><a href="#40597357">parent</a><span>|</span><a href="#40597756">prev</a><span>|</span><a href="#40601980">next</a><span>|</span><label class="collapse" for="c-40597610">[-]</label><label class="expand" for="c-40597610">[7 more]</label></div><br/><div class="children"><div class="content">Interesting, for a while the guidance for a while was to learn webgpu instead unless you needed all that extra control. Do you think these changes modify that guidance?</div><br/><div id="40597932" class="c"><input type="checkbox" id="c-40597932" checked=""/><div class="controls bullet"><span class="by">exDM69</span><span>|</span><a href="#40597187">root</a><span>|</span><a href="#40597610">parent</a><span>|</span><a href="#40597662">next</a><span>|</span><label class="collapse" for="c-40597932">[-]</label><label class="expand" for="c-40597932">[3 more]</label></div><br/><div class="children"><div class="content">With WebGPU&#x2F;wgpu you don&#x27;t get mesh shaders, ray tracing or shader subgroup&#x2F;wave&#x2F;warp operations. Its feature set is comparable to Vulkan 1.0, and Vulkan has progressed a lot since.<p>And WebGPU still requires all the RenderPass setup code which is a lot of boilerplate that Vulkan no longer requires.</div><br/><div id="40602349" class="c"><input type="checkbox" id="c-40602349" checked=""/><div class="controls bullet"><span class="by">jms55</span><span>|</span><a href="#40597187">root</a><span>|</span><a href="#40597932">parent</a><span>|</span><a href="#40597662">next</a><span>|</span><label class="collapse" for="c-40602349">[-]</label><label class="expand" for="c-40602349">[2 more]</label></div><br/><div class="children"><div class="content">Subgroups have actually been added very recently. The rest, sadly missing (along with multi-queue and bindless) :(</div><br/><div id="40606654" class="c"><input type="checkbox" id="c-40606654" checked=""/><div class="controls bullet"><span class="by">exDM69</span><span>|</span><a href="#40597187">root</a><span>|</span><a href="#40602349">parent</a><span>|</span><a href="#40597662">next</a><span>|</span><label class="collapse" for="c-40606654">[-]</label><label class="expand" for="c-40606654">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the update.<p>Subgroups may seem like a minor feature, but they can unlock huge performance. I recently had a 10x perf boost with a very basic subgroup trick to let neighboring pixels collaborate on some expensive operations in fragment shaders. And there&#x27;s another 5x in there waiting for me to implement some subgroup quad tricks.</div><br/></div></div></div></div></div></div><div id="40597662" class="c"><input type="checkbox" id="c-40597662" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#40597187">root</a><span>|</span><a href="#40597610">parent</a><span>|</span><a href="#40597932">prev</a><span>|</span><a href="#40601980">next</a><span>|</span><label class="collapse" for="c-40597662">[-]</label><label class="expand" for="c-40597662">[3 more]</label></div><br/><div class="children"><div class="content">WebGPU (or Metal if you&#x27;re in Apple land) still has a much gentler learning curve. The simplifications to Vulkan weren&#x27;t really aimed at making it easier to use, just streamlining parts of the API which turned out to be needlessly complex, so the parts that are complex for a reason are still just as complex.</div><br/><div id="40597801" class="c"><input type="checkbox" id="c-40597801" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#40597187">root</a><span>|</span><a href="#40597662">parent</a><span>|</span><a href="#40601980">next</a><span>|</span><label class="collapse" for="c-40597801">[-]</label><label class="expand" for="c-40597801">[2 more]</label></div><br/><div class="children"><div class="content">Thanks! Other than a project not running as fast as necessary, do you have any advice on how to know when&#x2F;if I need to switch to vulkan?</div><br/><div id="40598022" class="c"><input type="checkbox" id="c-40598022" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#40597187">root</a><span>|</span><a href="#40597801">parent</a><span>|</span><a href="#40601980">next</a><span>|</span><label class="collapse" for="c-40598022">[-]</label><label class="expand" for="c-40598022">[1 more]</label></div><br/><div class="children"><div class="content">Aside from performance there&#x27;s also just more hardware features exposed via Vulkan, as a sibling mentioned if you want to do anything with raytracing for example then you will have to graduate to Vulkan in order to take advantage of hardware acceleration.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40601980" class="c"><input type="checkbox" id="c-40601980" checked=""/><div class="controls bullet"><span class="by">eliasdaler</span><span>|</span><a href="#40597187">parent</a><span>|</span><a href="#40597357">prev</a><span>|</span><a href="#40597286">next</a><span>|</span><label class="collapse" for="c-40601980">[-]</label><label class="expand" for="c-40601980">[1 more]</label></div><br/><div class="children"><div class="content">vkguide is a great way to get a feel of modern Vulkan. Maybe it’ll be still to complex for you - then it’s okay to say on OpenGL or learn some WebGPU.<p>I started learning Vulkan as an experiment and it seemed to work out well, so that’s why I wrote this article. :)</div><br/></div></div><div id="40597286" class="c"><input type="checkbox" id="c-40597286" checked=""/><div class="controls bullet"><span class="by">eliasdaler</span><span>|</span><a href="#40597187">parent</a><span>|</span><a href="#40601980">prev</a><span>|</span><a href="#40599727">next</a><span>|</span><label class="collapse" for="c-40597286">[-]</label><label class="expand" for="c-40597286">[2 more]</label></div><br/><div class="children"><div class="content">Thank you. The up-front complexity is still there and it might take quite a few days to see your first triangle. But I promise, everything will get much easier from that point. :)</div><br/><div id="40598774" class="c"><input type="checkbox" id="c-40598774" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#40597187">root</a><span>|</span><a href="#40597286">parent</a><span>|</span><a href="#40599727">next</a><span>|</span><label class="collapse" for="c-40598774">[-]</label><label class="expand" for="c-40598774">[1 more]</label></div><br/><div class="children"><div class="content">The thing I&#x27;m most interested in doing when starting a new project is pretty much never to spend a few weeks and writing 10-20k LOC to get a triangle on the screen, I think I&#x27;ll stick with OpenGL for the time being tbh</div><br/></div></div></div></div></div></div><div id="40599727" class="c"><input type="checkbox" id="c-40599727" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#40597187">prev</a><span>|</span><a href="#40598152">next</a><span>|</span><label class="collapse" for="c-40599727">[-]</label><label class="expand" for="c-40599727">[2 more]</label></div><br/><div class="children"><div class="content">Off topic kind of - Can an LLM generate such an article? Reading such in depth experiences and consolidating advice makes me think that web is made by humans and every other day,I spot something on the web that is clearly generated from some LLM.<p>Great write up. Inspiring.</div><br/><div id="40601954" class="c"><input type="checkbox" id="c-40601954" checked=""/><div class="controls bullet"><span class="by">eliasdaler</span><span>|</span><a href="#40599727">parent</a><span>|</span><a href="#40598152">next</a><span>|</span><label class="collapse" for="c-40601954">[-]</label><label class="expand" for="c-40601954">[1 more]</label></div><br/><div class="children"><div class="content">Thanks a lot, that’s a very touching comment.<p>I try to make my website to feel like “the old Internet” that we seem to be losing and it&#x27;s great that it’s noticeable. :)</div><br/></div></div></div></div><div id="40598152" class="c"><input type="checkbox" id="c-40598152" checked=""/><div class="controls bullet"><span class="by">atan2</span><span>|</span><a href="#40599727">prev</a><span>|</span><a href="#40601259">next</a><span>|</span><label class="collapse" for="c-40598152">[-]</label><label class="expand" for="c-40598152">[1 more]</label></div><br/><div class="children"><div class="content">Great read! Elias always does great work.</div><br/></div></div><div id="40601259" class="c"><input type="checkbox" id="c-40601259" checked=""/><div class="controls bullet"><span class="by">brian_herman</span><span>|</span><a href="#40598152">prev</a><span>|</span><a href="#40598769">next</a><span>|</span><label class="collapse" for="c-40601259">[-]</label><label class="expand" for="c-40601259">[2 more]</label></div><br/><div class="children"><div class="content">Those kitties are so cute!</div><br/><div id="40601992" class="c"><input type="checkbox" id="c-40601992" checked=""/><div class="controls bullet"><span class="by">eliasdaler</span><span>|</span><a href="#40601259">parent</a><span>|</span><a href="#40598769">next</a><span>|</span><label class="collapse" for="c-40601992">[-]</label><label class="expand" for="c-40601992">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! :D</div><br/></div></div></div></div><div id="40598769" class="c"><input type="checkbox" id="c-40598769" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#40601259">prev</a><span>|</span><a href="#40599886">next</a><span>|</span><label class="collapse" for="c-40598769">[-]</label><label class="expand" for="c-40598769">[5 more]</label></div><br/><div class="children"><div class="content">For the casual reader who is curious what it takes to write a &quot;Hello, Triangle!&quot; in Vulkan 1.3: <a href="https:&#x2F;&#x2F;github.com&#x2F;Planimeter&#x2F;game-engine-3d&#x2F;blob&#x2F;main&#x2F;src&#x2F;graphics_vulkan.cpp">https:&#x2F;&#x2F;github.com&#x2F;Planimeter&#x2F;game-engine-3d&#x2F;blob&#x2F;main&#x2F;src&#x2F;g...</a></div><br/><div id="40599566" class="c"><input type="checkbox" id="c-40599566" checked=""/><div class="controls bullet"><span class="by">eliasdaler</span><span>|</span><a href="#40598769">parent</a><span>|</span><a href="#40599171">next</a><span>|</span><label class="collapse" for="c-40599566">[-]</label><label class="expand" for="c-40599566">[3 more]</label></div><br/><div class="children"><div class="content">Indeed. vk-bootstrap is a bit better with 600 lines of code, though: <a href="https:&#x2F;&#x2F;github.com&#x2F;charles-lunarg&#x2F;vk-bootstrap&#x2F;blob&#x2F;main&#x2F;example&#x2F;triangle.cpp">https:&#x2F;&#x2F;github.com&#x2F;charles-lunarg&#x2F;vk-bootstrap&#x2F;blob&#x2F;main&#x2F;exa...</a><p>Vulkan initialization and basic swapchain management is very verbose, but things get much better after you do it for the first time and make some handy abstractions around pipeline creation&#x2F;management later.</div><br/><div id="40600916" class="c"><input type="checkbox" id="c-40600916" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#40598769">root</a><span>|</span><a href="#40599566">parent</a><span>|</span><a href="#40599171">next</a><span>|</span><label class="collapse" for="c-40600916">[-]</label><label class="expand" for="c-40600916">[2 more]</label></div><br/><div class="children"><div class="content">For sure. They just move the roughly 300 lines of code elsewhere so you don&#x27;t have to do it, though.<p>I&#x27;d like to see them move nearly all 900-ish lines of SLOC back down into the near 90-ish you&#x27;d need to initialize OpenGL.<p>There&#x27;s so much overlap in basically everyone&#x27;s graphic usage of Vulkan that you realize after doing it yourself they should have done some simple optimization for the 99% use case, and allowed other people to write the full 900+ lines for GPU compute or other use cases.</div><br/><div id="40602112" class="c"><input type="checkbox" id="c-40602112" checked=""/><div class="controls bullet"><span class="by">eliasdaler</span><span>|</span><a href="#40598769">root</a><span>|</span><a href="#40600916">parent</a><span>|</span><a href="#40599171">next</a><span>|</span><label class="collapse" for="c-40602112">[-]</label><label class="expand" for="c-40602112">[1 more]</label></div><br/><div class="children"><div class="content">I guess libraries like bgfx, sokol and The Forge are kinda like that. But I just feel like it’s either all or nothing if you’re already doing your own game engine.<p>I’m okay with using middleware&#x2F;3rd party libraries for things which I don’t care too much about (e.g. physics), but graphics is such a core component that I want to handle it myself.<p>In a way, OpenGL drivers were such middleware libraries written for you by GPU vendors (or open source community). But now they stopped doing that and now you’re either writing your own graphics abstraction layer or using someone else’s.<p>In this case, I choose the hard way. And it seemed to have worked out so far. I definitely won’t recommend it to everyone (especially if they want to make a game in less than a year!), but as a learning experience it was fun.</div><br/></div></div></div></div></div></div><div id="40599171" class="c"><input type="checkbox" id="c-40599171" checked=""/><div class="controls bullet"><span class="by">ku1ik</span><span>|</span><a href="#40598769">parent</a><span>|</span><a href="#40599566">prev</a><span>|</span><a href="#40599886">next</a><span>|</span><label class="collapse" for="c-40599171">[-]</label><label class="expand" for="c-40599171">[1 more]</label></div><br/><div class="children"><div class="content">&#x2F;o\</div><br/></div></div></div></div><div id="40599886" class="c"><input type="checkbox" id="c-40599886" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#40598769">prev</a><span>|</span><a href="#40601779">next</a><span>|</span><label class="collapse" for="c-40599886">[-]</label><label class="expand" for="c-40599886">[1 more]</label></div><br/><div class="children"><div class="content">Is this better than learning Klingon? ;)</div><br/></div></div><div id="40601779" class="c"><input type="checkbox" id="c-40601779" checked=""/><div class="controls bullet"><span class="by">uwagar</span><span>|</span><a href="#40599886">prev</a><span>|</span><a href="#40600250">next</a><span>|</span><label class="collapse" for="c-40601779">[-]</label><label class="expand" for="c-40601779">[2 more]</label></div><br/><div class="children"><div class="content">life was a pleasure writing programs in IrisGL and then OpengGL :(</div><br/><div id="40602030" class="c"><input type="checkbox" id="c-40602030" checked=""/><div class="controls bullet"><span class="by">eliasdaler</span><span>|</span><a href="#40601779">parent</a><span>|</span><a href="#40600250">next</a><span>|</span><label class="collapse" for="c-40602030">[-]</label><label class="expand" for="c-40602030">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. Even though it might seem I’m 100% enjoying Vulkan, I still wish there was something closer to OpenGL and which was supported by GPU manufacturers. Other 3d party graphics frameworks are not bad, but you don’t feel the same confidence in their future in the same way as you did about OpenGL.</div><br/></div></div></div></div><div id="40600250" class="c"><input type="checkbox" id="c-40600250" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#40601779">prev</a><span>|</span><a href="#40597425">next</a><span>|</span><label class="collapse" for="c-40600250">[-]</label><label class="expand" for="c-40600250">[3 more]</label></div><br/><div class="children"><div class="content">Are there any examples of an academic attempt at putting as much of a game into the GPU as possible? Like, architecting a game in a way that pretty much everything, including game logic, could be implemented as a shader?</div><br/><div id="40606484" class="c"><input type="checkbox" id="c-40606484" checked=""/><div class="controls bullet"><span class="by">Cloudef</span><span>|</span><a href="#40600250">parent</a><span>|</span><a href="#40603354">next</a><span>|</span><label class="collapse" for="c-40606484">[-]</label><label class="expand" for="c-40606484">[1 more]</label></div><br/><div class="children"><div class="content">Posted this in hn few days ago
<a href="https:&#x2F;&#x2F;vkguide.dev&#x2F;docs&#x2F;gpudriven&#x2F;gpu_driven_engines&#x2F;" rel="nofollow">https:&#x2F;&#x2F;vkguide.dev&#x2F;docs&#x2F;gpudriven&#x2F;gpu_driven_engines&#x2F;</a></div><br/></div></div><div id="40603354" class="c"><input type="checkbox" id="c-40603354" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#40600250">parent</a><span>|</span><a href="#40606484">prev</a><span>|</span><a href="#40597425">next</a><span>|</span><label class="collapse" for="c-40603354">[-]</label><label class="expand" for="c-40603354">[1 more]</label></div><br/><div class="children"><div class="content">Shadertoy is your best bet. There are a few people doing it there.</div><br/></div></div></div></div><div id="40597995" class="c"><input type="checkbox" id="c-40597995" checked=""/><div class="controls bullet"><span class="by">alunchbox</span><span>|</span><a href="#40597358">prev</a><span>|</span><label class="collapse" for="c-40597995">[-]</label><label class="expand" for="c-40597995">[7 more]</label></div><br/><div class="children"><div class="content">hey just curious, any reason why some of these articles I see from time to time don&#x27;t apply some simply CSS? I don&#x27;t mind the raw html, I&#x27;m mostly wondering if there&#x27;s some benefit to it that I might not be aware of.</div><br/><div id="40598263" class="c"><input type="checkbox" id="c-40598263" checked=""/><div class="controls bullet"><span class="by">solardev</span><span>|</span><a href="#40597995">parent</a><span>|</span><a href="#40598056">next</a><span>|</span><label class="collapse" for="c-40598263">[-]</label><label class="expand" for="c-40598263">[1 more]</label></div><br/><div class="children"><div class="content">Just a guess, but the folks interested in low level graphics programming are probably the same people who would want to stay away from bloated frontends?<p>A simple blog post doesn&#x27;t need super fancy design when its content can speak for itself.</div><br/></div></div><div id="40598056" class="c"><input type="checkbox" id="c-40598056" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#40597995">parent</a><span>|</span><a href="#40598263">prev</a><span>|</span><label class="collapse" for="c-40598056">[-]</label><label class="expand" for="c-40598056">[5 more]</label></div><br/><div class="children"><div class="content">The site definitely has CSS, just not a lot of it.</div><br/><div id="40599508" class="c"><input type="checkbox" id="c-40599508" checked=""/><div class="controls bullet"><span class="by">eliasdaler</span><span>|</span><a href="#40597995">root</a><span>|</span><a href="#40598056">parent</a><span>|</span><label class="collapse" for="c-40599508">[-]</label><label class="expand" for="c-40599508">[4 more]</label></div><br/><div class="children"><div class="content">Indeed. I used as little CSS as I could because I love minimalist websites. And the lack of syntax highlighting was inspired by Go blog, for example. :)<p>Raw HTML definitely looks much uglier, sadly (“Reader mode” in most browsers makes websites without CSS easily readable, though!).</div><br/><div id="40606717" class="c"><input type="checkbox" id="c-40606717" checked=""/><div class="controls bullet"><span class="by">johnnyanmac</span><span>|</span><a href="#40597995">root</a><span>|</span><a href="#40599508">parent</a><span>|</span><a href="#40600708">next</a><span>|</span><label class="collapse" for="c-40606717">[-]</label><label class="expand" for="c-40606717">[1 more]</label></div><br/><div class="children"><div class="content">reminds me a lot of <a href="http:&#x2F;&#x2F;bettermotherfuckingwebsite.com&#x2F;" rel="nofollow">http:&#x2F;&#x2F;bettermotherfuckingwebsite.com&#x2F;</a><p>pretty much all HTML, with only the bare minimum CSS to make it somewhat responsive.<p>I guess if you want one tiny piece of feedback, based on the above site:<p>&gt;A little less contrast<p>&gt;Black on white? How often do you see that kind of contrast in real life? Tone it down a bit, asshole. I would&#x27;ve even made this site&#x27;s background a nice #EEEEEE if I wasn&#x27;t so focused on keeping declarations to a lean 7 fucking lines.<p>I agree with the advice, but I&#x27;ve definitely seen many a heated debate over raw black on raw white amongst designers. So take with a grain of salt and a handful of personal preference.</div><br/></div></div><div id="40600708" class="c"><input type="checkbox" id="c-40600708" checked=""/><div class="controls bullet"><span class="by">cristoperb</span><span>|</span><a href="#40597995">root</a><span>|</span><a href="#40599508">parent</a><span>|</span><a href="#40606717">prev</a><span>|</span><label class="collapse" for="c-40600708">[-]</label><label class="expand" for="c-40600708">[2 more]</label></div><br/><div class="children"><div class="content">Your site looks nice and is quite readable! The thing I most dislike about sites that just use raw HTML is the lack of `max-width` on the text containers (which makes using reader mode necessary), so thanks for including that</div><br/><div id="40602127" class="c"><input type="checkbox" id="c-40602127" checked=""/><div class="controls bullet"><span class="by">eliasdaler</span><span>|</span><a href="#40597995">root</a><span>|</span><a href="#40600708">parent</a><span>|</span><label class="collapse" for="c-40602127">[-]</label><label class="expand" for="c-40602127">[1 more]</label></div><br/><div class="children"><div class="content">Thank you! :)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>