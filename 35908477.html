<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683882047320" as="style"/><link rel="stylesheet" href="styles.css?v=1683882047320"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://buttondown.email/hillelwayne/archive/problems-harder-than-np-complete/">Problems harder than NP-Complete</a> <span class="domain">(<a href="https://buttondown.email">buttondown.email</a>)</span></div><div class="subtext"><span>azhenley</span> | <span>71 comments</span></div><br/><div><div id="35909543" class="c"><input type="checkbox" id="c-35909543" checked=""/><div class="controls bullet"><span class="by">steeps</span><span>|</span><a href="#35909263">next</a><span>|</span><label class="collapse" for="c-35909543">[-]</label><label class="expand" for="c-35909543">[2 more]</label></div><br/><div class="children"><div class="content">One 2EXPTIME-complete problem that I really like is that of Linear Temporal Logic (LTL)[1] realizability. Informally, given a temporal logic formula over inputs and outputs, we can ask whether there exists some program which models the formula over all possible inputs.<p>For instance, if we label the undesirable outputs as BAD, then we can write a formula like G!BAD (read: always not BAD), and ask if there exists a program which models this formula - if there does, then we know there&#x27;s some program which never enters the undesirable states, regardless of the input. You can extend this from a decision problem (yes&#x2F;no answers) to synthesis, and construct such a program using similar techniques (I&#x27;m using &quot;program&quot; in a very specific sense here - much of the current art is focused around finite-state automata).<p>Shameless plug: I wrote my thesis on decision problems around the existence of game-theoretic solutions concepts (e.g. Nash equilibria, the Core) in multi-agent systems and many of these were 2EXPTIME-complete. A lot of the time you could easily show membership in 2EXPTIME by making an exponential(!) number of relevant calls to the LTL realizability problem.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Linear_temporal_logic" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Linear_temporal_logic</a></div><br/><div id="35913012" class="c"><input type="checkbox" id="c-35913012" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#35909543">parent</a><span>|</span><a href="#35909263">next</a><span>|</span><label class="collapse" for="c-35913012">[-]</label><label class="expand" for="c-35913012">[1 more]</label></div><br/><div class="children"><div class="content">Could you perhaps recommend some book on computational complexities? My CS curriculum back then mostly included the usual Chomsky hierarchy, but was quite lean on anything other than P&#x2F;NP, and most books I found were also mostly about the “basics”.</div><br/></div></div></div></div><div id="35909263" class="c"><input type="checkbox" id="c-35909263" checked=""/><div class="controls bullet"><span class="by">cvoss</span><span>|</span><a href="#35909543">prev</a><span>|</span><a href="#35909137">next</a><span>|</span><label class="collapse" for="c-35909263">[-]</label><label class="expand" for="c-35909263">[9 more]</label></div><br/><div class="children"><div class="content">&gt; does a CS regular expression without stars have no matches?<p>It&#x27;s worth elaborating this one, because testing whether an ordinary star-free regular expression has no matches is super easy. Not sure what the author means by &quot;CS&quot; (maybe just &quot;computer science&quot;?), but the actual problem is &quot;Does a <i>generalized</i> regular expression without stars have no matches?&quot; Here, &quot;generalized&quot; means that we have two new operators, beyond union (alternation) and concatenation: they are intersection and negation. [0]<p>You may recall that constructing an intersection automaton involves a cross product of NFAs, and constructing the negation automaton involves just flipping the accepting&#x2F;rejecting states of a DFA. However, the NFA -&gt; DFA construction can incur an exponential blowup of states.<p>So at the very least, intuition shows that the automata we&#x27;re working with are enormous w.r.t. the expression size. But at this point my intuition stops, so I won&#x27;t be able to explain how we get from here to a TOWER-complete decision procedure for whether the accepting set is empty.<p>[0] <a href="https:&#x2F;&#x2F;planetmath.org&#x2F;generalizedregularexpression" rel="nofollow">https:&#x2F;&#x2F;planetmath.org&#x2F;generalizedregularexpression</a></div><br/><div id="35910400" class="c"><input type="checkbox" id="c-35910400" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#35909263">parent</a><span>|</span><a href="#35909628">next</a><span>|</span><label class="collapse" for="c-35910400">[-]</label><label class="expand" for="c-35910400">[1 more]</label></div><br/><div class="children"><div class="content">I would assume CS regular expression means the computer sci version vs the (non-regular) regexes in popular use.</div><br/></div></div><div id="35909628" class="c"><input type="checkbox" id="c-35909628" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#35909263">parent</a><span>|</span><a href="#35910400">prev</a><span>|</span><a href="#35910440">next</a><span>|</span><label class="collapse" for="c-35909628">[-]</label><label class="expand" for="c-35909628">[1 more]</label></div><br/><div class="children"><div class="content">My guess would be context sensitive?</div><br/></div></div><div id="35910440" class="c"><input type="checkbox" id="c-35910440" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#35909263">parent</a><span>|</span><a href="#35909628">prev</a><span>|</span><a href="#35909137">next</a><span>|</span><label class="collapse" for="c-35910440">[-]</label><label class="expand" for="c-35910440">[6 more]</label></div><br/><div class="children"><div class="content">&gt; You may recall that constructing an intersection automaton involves a cross product of NFAs<p>I&#x27;m not sure what you mean by &quot;cross product&quot; here, but there&#x27;s nothing multiplicative involved. You just run both NFAs simultaneously. This gives you a number of states to track equal to the sum, not the product, of the two NFAs being intersected.</div><br/><div id="35910886" class="c"><input type="checkbox" id="c-35910886" checked=""/><div class="controls bullet"><span class="by">opportune</span><span>|</span><a href="#35909263">root</a><span>|</span><a href="#35910440">parent</a><span>|</span><a href="#35912618">next</a><span>|</span><label class="collapse" for="c-35910886">[-]</label><label class="expand" for="c-35910886">[1 more]</label></div><br/><div class="children"><div class="content">Most likely they mean Cartesian product instead of cross product.<p>Also whatever you are describing is not an intersection per se as it’s not a permutation of the two possible combined states, it’s a construction for doing certain computations on intersected NFAs given its constituents. If each of two intersected NFA has three states the intersection can be up to 9 (the cardinality of the Cartesian product) states</div><br/></div></div><div id="35912618" class="c"><input type="checkbox" id="c-35912618" checked=""/><div class="controls bullet"><span class="by">suyjuris</span><span>|</span><a href="#35909263">root</a><span>|</span><a href="#35910440">parent</a><span>|</span><a href="#35910886">prev</a><span>|</span><a href="#35910751">next</a><span>|</span><label class="collapse" for="c-35912618">[-]</label><label class="expand" for="c-35912618">[1 more]</label></div><br/><div class="children"><div class="content">You are thinking of the union, where you can indeed just put the two NFAs “side-by-side”. This does not work for the intersection though, there you need the product construction.</div><br/></div></div><div id="35910751" class="c"><input type="checkbox" id="c-35910751" checked=""/><div class="controls bullet"><span class="by">cvoss</span><span>|</span><a href="#35909263">root</a><span>|</span><a href="#35910440">parent</a><span>|</span><a href="#35912618">prev</a><span>|</span><a href="#35909137">next</a><span>|</span><label class="collapse" for="c-35910751">[-]</label><label class="expand" for="c-35910751">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s one way to perform the computation, but that&#x27;s not an NFA. The product construction involves making a single new NFA to do the job.</div><br/><div id="35910880" class="c"><input type="checkbox" id="c-35910880" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#35909263">root</a><span>|</span><a href="#35910751">parent</a><span>|</span><a href="#35909137">next</a><span>|</span><label class="collapse" for="c-35910880">[-]</label><label class="expand" for="c-35910880">[2 more]</label></div><br/><div class="children"><div class="content">It is an NFA in every way except that you no longer have a single list of accepting states. &quot;Doing two different things simultaneously&quot; is the whole concept of nondeterminism.<p>If you loosen the definition of &quot;NFA&quot; that you&#x27;re working with from requiring a set of final states to requiring a function from a set of states to {0, 1}, everything will still work exactly the same way, all of your theorems will still hold, but intersecting two NFAs will consist of adding one state and adjusting the accept function.</div><br/></div></div></div></div></div></div></div></div><div id="35909137" class="c"><input type="checkbox" id="c-35909137" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#35909263">prev</a><span>|</span><a href="#35910203">next</a><span>|</span><label class="collapse" for="c-35909137">[-]</label><label class="expand" for="c-35909137">[6 more]</label></div><br/><div class="children"><div class="content">A practical (and solvable in practical cases!) EXPTIME-complete problem is type inference (or even typability) in the ML type system (that is Hindley–Milner extended with let-polymorphism) or in Trevor Jim’s much nicer System P₂ (equivalently rank-2 intersection types; <i>a fortiori</i> his System P; no, I’m not going to stop shilling System P, it’s too neat to not have a language built upon it at least once).<p>Interesting decidable problems with even more insane complexity include provability in Presburger arithmetic (the one where you’re forbidden from multiplying variables together, so avoid the undecidability of Peano) and over the reals (with addition and multiplication only).</div><br/><div id="35909306" class="c"><input type="checkbox" id="c-35909306" checked=""/><div class="controls bullet"><span class="by">apatil</span><span>|</span><a href="#35909137">parent</a><span>|</span><a href="#35911860">next</a><span>|</span><label class="collapse" for="c-35909306">[-]</label><label class="expand" for="c-35909306">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s very interesting. In which variable is type inference EXPTIME complete?<p>Whichever variable it is, I suppose in practice humans can&#x27;t create programs that are big enough in that way for type inference to become impractical. However, I wonder whether someone could comment on what this means about the utility of HM-like type systems in future AI generated software.</div><br/><div id="35909437" class="c"><input type="checkbox" id="c-35909437" checked=""/><div class="controls bullet"><span class="by">kachnuv_ocasek</span><span>|</span><a href="#35909137">root</a><span>|</span><a href="#35909306">parent</a><span>|</span><a href="#35911697">next</a><span>|</span><label class="collapse" for="c-35909437">[-]</label><label class="expand" for="c-35909437">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the size of the term. See this paper which proves the result for details: <a href="https:&#x2F;&#x2F;link.springer.com&#x2F;chapter&#x2F;10.1007&#x2F;3-540-52590-4_50" rel="nofollow">https:&#x2F;&#x2F;link.springer.com&#x2F;chapter&#x2F;10.1007&#x2F;3-540-52590-4_50</a></div><br/><div id="35911872" class="c"><input type="checkbox" id="c-35911872" checked=""/><div class="controls bullet"><span class="by">mmoskal</span><span>|</span><a href="#35909137">root</a><span>|</span><a href="#35909437">parent</a><span>|</span><a href="#35911697">next</a><span>|</span><label class="collapse" for="c-35911872">[-]</label><label class="expand" for="c-35911872">[1 more]</label></div><br/><div class="children"><div class="content">More specifically, time is almost linear with the size of the type, which can be doubly exponential compared to the program but people don&#x27;t write such programs.</div><br/></div></div></div></div><div id="35911697" class="c"><input type="checkbox" id="c-35911697" checked=""/><div class="controls bullet"><span class="by">disjunction181</span><span>|</span><a href="#35909137">root</a><span>|</span><a href="#35909306">parent</a><span>|</span><a href="#35909437">prev</a><span>|</span><a href="#35911860">next</a><span>|</span><label class="collapse" for="c-35911697">[-]</label><label class="expand" for="c-35911697">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not that humans don&#x27;t write such large programs, it&#x27;s that the kind of pattern that causes the exponential behavior doesn&#x27;t naturally occur in long chains in any kind of written code. You can provide the pathological inputs yourself and quickly freeze e.g. OCaml&#x27;s typechecker, they just don&#x27;t ever naturally occur to the point of becoming a problem.<p>Here&#x27;s an example of the pathological pattern in OCaml: <a href="https:&#x2F;&#x2F;cs.stackexchange.com&#x2F;questions&#x2F;6617&#x2F;concise-example-of-exponential-cost-of-ml-type-inference" rel="nofollow">https:&#x2F;&#x2F;cs.stackexchange.com&#x2F;questions&#x2F;6617&#x2F;concise-example-...</a></div><br/></div></div></div></div><div id="35911860" class="c"><input type="checkbox" id="c-35911860" checked=""/><div class="controls bullet"><span class="by">carterschonwald</span><span>|</span><a href="#35909137">parent</a><span>|</span><a href="#35909306">prev</a><span>|</span><a href="#35910203">next</a><span>|</span><label class="collapse" for="c-35911860">[-]</label><label class="expand" for="c-35911860">[1 more]</label></div><br/><div class="children"><div class="content">Is there any PDFs of that type system? I tried to dig some up but I found only some post script files about polar type inference</div><br/></div></div></div></div><div id="35910203" class="c"><input type="checkbox" id="c-35910203" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#35909137">prev</a><span>|</span><a href="#35913385">next</a><span>|</span><label class="collapse" for="c-35910203">[-]</label><label class="expand" for="c-35910203">[2 more]</label></div><br/><div class="children"><div class="content">One example I’ve always liked:<p>Solving Sudoku (for general sized grids) is np-complete, but usually fairly easy. Many people write quite good sudoku solvers that can solve any 9x9 in a few milliseconds.<p>Now, a valid sudoku is a grid which has one unique answer. What’s the smallest number of clues a valid sudoku can have?<p>That problem is still in a 9x9 grid, and has been solved but it up at the limit of what we can do. It took a whole bunch of clever maths, and about a million CPU hours.</div><br/><div id="35911604" class="c"><input type="checkbox" id="c-35911604" checked=""/><div class="controls bullet"><span class="by">cwmoore</span><span>|</span><a href="#35910203">parent</a><span>|</span><a href="#35913385">next</a><span>|</span><label class="collapse" for="c-35911604">[-]</label><label class="expand" for="c-35911604">[1 more]</label></div><br/><div class="children"><div class="content">That is an interesting contrast. I don&#x27;t know the smallest number of clues a kakuro puzzle can have, but I made easier ones with many clues, and harder ones, that also have many clues, generously fitting the heart shape, but I&#x27;d only be willing to spend tens of CPU hours on optimizing it.<p><a href="https:&#x2F;&#x2F;www.curtiswmoore.com&#x2F;kakuro&#x2F;v0.2&#x2F;kakuro_with_solver.html" rel="nofollow">https:&#x2F;&#x2F;www.curtiswmoore.com&#x2F;kakuro&#x2F;v0.2&#x2F;kakuro_with_solver....</a></div><br/></div></div></div></div><div id="35913385" class="c"><input type="checkbox" id="c-35913385" checked=""/><div class="controls bullet"><span class="by">eterevsky</span><span>|</span><a href="#35910203">prev</a><span>|</span><a href="#35909064">next</a><span>|</span><label class="collapse" for="c-35913385">[-]</label><label class="expand" for="c-35913385">[1 more]</label></div><br/><div class="children"><div class="content">&gt; most EXPTIME-complete examples fall in one of two categories. First, game problems. Given a configuration of an NxN Go&#x2F;Chess&#x2F;Checkers&#x2F;Shogi board, does player 1 have a winning strategy?<p>It seems like these should be solvable in PSPACE, provided there&#x27;s a polynomial limit on the number of moves in the game, since you can just do a recursive minimax search.</div><br/></div></div><div id="35909064" class="c"><input type="checkbox" id="c-35909064" checked=""/><div class="controls bullet"><span class="by">raatmarien</span><span>|</span><a href="#35913385">prev</a><span>|</span><a href="#35910390">next</a><span>|</span><label class="collapse" for="c-35909064">[-]</label><label class="expand" for="c-35909064">[12 more]</label></div><br/><div class="children"><div class="content">And then beyond these decidable problems, there is a whole hierarchy of harder and harder undecidable problems, which I think is really cool as well.<p><a href="https:&#x2F;&#x2F;marienraat.nl&#x2F;blog&#x2F;posts&#x2F;hardest-computational-problems&#x2F;" rel="nofollow">https:&#x2F;&#x2F;marienraat.nl&#x2F;blog&#x2F;posts&#x2F;hardest-computational-probl...</a></div><br/><div id="35909430" class="c"><input type="checkbox" id="c-35909430" checked=""/><div class="controls bullet"><span class="by">cvoss</span><span>|</span><a href="#35909064">parent</a><span>|</span><a href="#35910876">next</a><span>|</span><label class="collapse" for="c-35909430">[-]</label><label class="expand" for="c-35909430">[5 more]</label></div><br/><div class="children"><div class="content">This is always fascinating to me, that there continues to be interesting structure among computational problems even after you pass the point where they aren&#x27;t computable anymore.<p>Kind of tangentially, but similar in spirit, I&#x27;ve often wondered about the following: You know how if you can prove False from a system of axioms, then the whole system collapses because you can prove anything from False? Well, surely not all such inconsistent systems are created equal. Right? There&#x27;s a smallest&#x2F;first proof of False in each inconsistent system. In some systems it may be very easy to prove False succinctly, while in others it may be a herculean effort to get your first proof of False. So, in that sense, some inconsistent systems are &quot;more consistent&quot; than others, or perhaps &quot;consistent w.r.t particular inconsistencies&quot;. I wonder what this &quot;structure among inconsistent systems&quot; looks like!</div><br/><div id="35909487" class="c"><input type="checkbox" id="c-35909487" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#35909064">root</a><span>|</span><a href="#35909430">parent</a><span>|</span><a href="#35911632">next</a><span>|</span><label class="collapse" for="c-35909487">[-]</label><label class="expand" for="c-35909487">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that is interesting.  Maybe one way to paraphrase it is that &quot;infinity&quot; is very big and you can fit a lot of interesting structure there :)<p><i>It actually turns out that there are infinitely many other problems that are not Turing reducible to any of these ordinary halting problems and to which none of the halting problems are reducible.18 And all these problems have halting problems of their own, defined by the halting of computers that have access to their solutions, that are strictly harder.</i><p>Similarly with the classic essay <i>Who Can Name the Bigger Number?</i><p><a href="https:&#x2F;&#x2F;www.scottaaronson.com&#x2F;writings&#x2F;bignumbers.html" rel="nofollow">https:&#x2F;&#x2F;www.scottaaronson.com&#x2F;writings&#x2F;bignumbers.html</a><p>If you have infinite space, then you can be infinitely clever ...<p><i>Who can name the bigger number? Whoever has the deeper paradigm.</i></div><br/></div></div><div id="35911632" class="c"><input type="checkbox" id="c-35911632" checked=""/><div class="controls bullet"><span class="by">nl</span><span>|</span><a href="#35909064">root</a><span>|</span><a href="#35909430">parent</a><span>|</span><a href="#35909487">prev</a><span>|</span><a href="#35909795">next</a><span>|</span><label class="collapse" for="c-35911632">[-]</label><label class="expand" for="c-35911632">[1 more]</label></div><br/><div class="children"><div class="content">Steven Wolfram talks about related concepts a lot in the frame of his &quot;computational irreducibility&quot; concept. It&#x27;s interesting to think that there could be systems composed of comparatively simple rules but computing that first proof of False could take longer than the universe.<p>It&#x27;s interesting, and Wolfram explains it well. You do need to ignore the ego though.</div><br/></div></div><div id="35909795" class="c"><input type="checkbox" id="c-35909795" checked=""/><div class="controls bullet"><span class="by">ithinkso</span><span>|</span><a href="#35909064">root</a><span>|</span><a href="#35909430">parent</a><span>|</span><a href="#35911632">prev</a><span>|</span><a href="#35910876">next</a><span>|</span><label class="collapse" for="c-35909795">[-]</label><label class="expand" for="c-35909795">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I understand you correctly but in boolean logic it is super hard to be somewhere between truth and false. Fuzzy logic is what you&#x27;re after</div><br/><div id="35910781" class="c"><input type="checkbox" id="c-35910781" checked=""/><div class="controls bullet"><span class="by">cvoss</span><span>|</span><a href="#35909064">root</a><span>|</span><a href="#35909795">parent</a><span>|</span><a href="#35910876">next</a><span>|</span><label class="collapse" for="c-35910781">[-]</label><label class="expand" for="c-35910781">[1 more]</label></div><br/><div class="children"><div class="content">No, fuzzy logic is not what I&#x27;m after. Nor even the truth or falsity of single statements. I&#x27;m interested in the degree to which an entire inconsistent system of logic is inconsistent.</div><br/></div></div></div></div></div></div><div id="35910876" class="c"><input type="checkbox" id="c-35910876" checked=""/><div class="controls bullet"><span class="by">zbobet2012</span><span>|</span><a href="#35909064">parent</a><span>|</span><a href="#35909430">prev</a><span>|</span><a href="#35911971">next</a><span>|</span><label class="collapse" for="c-35910876">[-]</label><label class="expand" for="c-35910876">[2 more]</label></div><br/><div class="children"><div class="content">One of the more interesting undecidable problems out there is kolmogorov complexity. It basically asks the question: given a string what is the smallest program that generates that string. Which fundamentally is the question of compression. So these undecidable problems actually have a lot of practical value.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Kolmogorov_complexity" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Kolmogorov_complexity</a></div><br/><div id="35911658" class="c"><input type="checkbox" id="c-35911658" checked=""/><div class="controls bullet"><span class="by">nl</span><span>|</span><a href="#35909064">root</a><span>|</span><a href="#35910876">parent</a><span>|</span><a href="#35911971">next</a><span>|</span><label class="collapse" for="c-35911658">[-]</label><label class="expand" for="c-35911658">[1 more]</label></div><br/><div class="children"><div class="content">And Kolmogorov complexity is used by Shane Legg (DeepMind founder) and Marcus Hutter (Hutter prize etc) in their paper &quot;A Formal Measure of Machine Intelligence&quot;<p><a href="http:&#x2F;&#x2F;www.vetta.org&#x2F;documents&#x2F;legg-hutter-2006-formal-measure-intelligence.pdf" rel="nofollow">http:&#x2F;&#x2F;www.vetta.org&#x2F;documents&#x2F;legg-hutter-2006-formal-measu...</a></div><br/></div></div></div></div><div id="35911971" class="c"><input type="checkbox" id="c-35911971" checked=""/><div class="controls bullet"><span class="by">mbork_pl</span><span>|</span><a href="#35909064">parent</a><span>|</span><a href="#35910876">prev</a><span>|</span><a href="#35910391">next</a><span>|</span><label class="collapse" for="c-35911971">[-]</label><label class="expand" for="c-35911971">[1 more]</label></div><br/><div class="children"><div class="content">This is a very loose association from someone coming from mathematical analysis background, maybe interesting for some people.<p>In analysis&#x2F;topology you have this concept of a <i>compact set</i>.  Compact sets are &quot;small&quot; - they are close (in a sense) to finite sets, and close (in another sense) to finite-dimensional sets, balls in infinite-dimensional Banach spaces are never compact, etc.  (The notion of compactness is one of the most fundamental concept in mathematical analysis.)  One of the famous fixed point theorems, Schauder fixed point theorem, asserts that a continuous mapping of a non-empty, compact and convex set has a fixed point.  (This is a direct generalization of the Brouwer fixed point theorem, perhaps one of the two most well-known results of this type.)<p>Now, in 1930 Kuratowski introduced a so-called &quot;measure of non-compactness&quot; - a number saying &quot;how far the given set is from being compact&quot;.  (Since then, many similar notions were also examined.)  There is a very cool family of fixed-point theorems of the type &quot;Let X be some «nice» set and f:X → X some continuous mapping which transforms sets into «less non-compact» sets; then, it has a fixed point.&quot;  (At least some of those theorems require the axiom of choice, btw.  Also, Kuratowski had no idea about them AFAIK, his motivation to consider his measure was completely different.)<p>Just wondering if CS people have their way of measuring non-decidability of problems...  (Probably yes.)</div><br/></div></div><div id="35910391" class="c"><input type="checkbox" id="c-35910391" checked=""/><div class="controls bullet"><span class="by">JoeDaDude</span><span>|</span><a href="#35909064">parent</a><span>|</span><a href="#35911971">prev</a><span>|</span><a href="#35910447">next</a><span>|</span><label class="collapse" for="c-35910391">[-]</label><label class="expand" for="c-35910391">[1 more]</label></div><br/><div class="children"><div class="content">I remember my head exploding upon seeing a presentation on the work of Larry Stockmeyer.  Though he was an academic working in the obscure discipline of theoretical computer science, he ended up being named in a science fiction novel.<p>Summary paper:
<a href="https:&#x2F;&#x2F;lance.fortnow.com&#x2F;papers&#x2F;files&#x2F;beyondnp.pdf" rel="nofollow">https:&#x2F;&#x2F;lance.fortnow.com&#x2F;papers&#x2F;files&#x2F;beyondnp.pdf</a><p>Slide show:
<a href="https:&#x2F;&#x2F;www.slideserve.com&#x2F;leda&#x2F;beyond-np-the-work-and-legacy-of-larry-stockmeyer" rel="nofollow">https:&#x2F;&#x2F;www.slideserve.com&#x2F;leda&#x2F;beyond-np-the-work-and-legac...</a></div><br/></div></div><div id="35910447" class="c"><input type="checkbox" id="c-35910447" checked=""/><div class="controls bullet"><span class="by">semihsalihoglu</span><span>|</span><a href="#35909064">parent</a><span>|</span><a href="#35910391">prev</a><span>|</span><a href="#35910390">next</a><span>|</span><label class="collapse" for="c-35910447">[-]</label><label class="expand" for="c-35910447">[2 more]</label></div><br/><div class="children"><div class="content">I hadn&#x27;t heard for this but this sounds very similar to the definition of polynomial hierarchy: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Polynomial_hierarchy" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Polynomial_hierarchy</a><p>What has fascinated me (if I&#x27;m not mistaken) when I was learning about computational complexity was that P=NP implies that the polynomial hierarchy (so this infinite classes of problem) collapses to P, so all problems in the polynomial hierarchy are solvable in polynomial time.</div><br/><div id="35910868" class="c"><input type="checkbox" id="c-35910868" checked=""/><div class="controls bullet"><span class="by">legobmw99</span><span>|</span><a href="#35909064">root</a><span>|</span><a href="#35910447">parent</a><span>|</span><a href="#35910390">next</a><span>|</span><label class="collapse" for="c-35910868">[-]</label><label class="expand" for="c-35910868">[1 more]</label></div><br/><div class="children"><div class="content">Your understanding is correct: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Karp%E2%80%93Lipton_theorem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Karp%E2%80%93Lipton_theorem</a></div><br/></div></div></div></div></div></div><div id="35910390" class="c"><input type="checkbox" id="c-35910390" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#35909064">prev</a><span>|</span><a href="#35912391">next</a><span>|</span><label class="collapse" for="c-35910390">[-]</label><label class="expand" for="c-35910390">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Problems can get way, way harder than NP.<p>I don&#x27;t think anyone doubts that. NP vs P is just talked about because its the dividing line where things first become too hard (to overgeneralize). There are lots of NP problems that are close to being tractable so it feels like they are in reach. There are also lots in this category that are things that are useful to do. While there are certainly exceptions, harder categories have problems that seem more obviously out of reach at a glance.</div><br/></div></div><div id="35912391" class="c"><input type="checkbox" id="c-35912391" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#35910390">prev</a><span>|</span><a href="#35909214">next</a><span>|</span><label class="collapse" for="c-35912391">[-]</label><label class="expand" for="c-35912391">[1 more]</label></div><br/><div class="children"><div class="content">#P Complete is my favorite &#x27;harder than NP Complete&#x27; class.<p>Discovering if a 3-SAT problem has Zero solutions is a famous NP complete problem.<p>#P is very easy to understand as an extension. Instead of asking for &#x27;Is there more than zero solutions?&#x27;, you ask &#x27;How many solutions are there?&#x27;<p>And bam, you&#x27;ve gone from NP complete to #P complete. One of the easiest ways to make NP complete problems even harder.<p>--------<p>All NP Complete algorithms can be solved by a #P complete algorithm. Just ask for the count, return true if count &gt; 0. Return false if count == 0.<p>Therefore, NP Complete is proven to be easier (or worst case, tied with) #P Complete space.</div><br/></div></div><div id="35909214" class="c"><input type="checkbox" id="c-35909214" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#35912391">prev</a><span>|</span><a href="#35909636">next</a><span>|</span><label class="collapse" for="c-35909214">[-]</label><label class="expand" for="c-35909214">[5 more]</label></div><br/><div class="children"><div class="content">Something is up with the succinct circuits description.<p>&gt; An n-node simple graph can have up to 2^n edges, meaning it takes exponential space to encode<p>An n-node simple graph can only have O(n^2) edges, and only needs quadratic space to encode.</div><br/><div id="35909435" class="c"><input type="checkbox" id="c-35909435" checked=""/><div class="controls bullet"><span class="by">perihelions</span><span>|</span><a href="#35909214">parent</a><span>|</span><a href="#35909310">next</a><span>|</span><label class="collapse" for="c-35909435">[-]</label><label class="expand" for="c-35909435">[3 more]</label></div><br/><div class="children"><div class="content">Pretty sure &quot;n-node&quot; is a typo and both vertices and edges are 2ⁿ.</div><br/><div id="35909775" class="c"><input type="checkbox" id="c-35909775" checked=""/><div class="controls bullet"><span class="by">hwayne</span><span>|</span><a href="#35909214">root</a><span>|</span><a href="#35909435">parent</a><span>|</span><a href="#35909310">next</a><span>|</span><label class="collapse" for="c-35909775">[-]</label><label class="expand" for="c-35909775">[2 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s a dumb mistake, I was thinking of the number of subgraphs of the N-node graph. I&#x27;ll fix it.</div><br/><div id="35910036" class="c"><input type="checkbox" id="c-35910036" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#35909214">root</a><span>|</span><a href="#35909775">parent</a><span>|</span><a href="#35909310">next</a><span>|</span><label class="collapse" for="c-35910036">[-]</label><label class="expand" for="c-35910036">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure you want subgraphs, either.  Succinct circuits encode exponential-sized graphs in poly space.<p>I read a little on this, and I realize I&#x27;ve seen examples of succinct circuits.  Hash functions are a great example of poly-sized circuits that compute the edges of exponentially-large graphs (fixing the input size to the output size, for example).  Want to find the edge-reversal of that graph?  It&#x27;ll cost ya.</div><br/></div></div></div></div></div></div></div></div><div id="35909636" class="c"><input type="checkbox" id="c-35909636" checked=""/><div class="controls bullet"><span class="by">g42gregory</span><span>|</span><a href="#35909214">prev</a><span>|</span><a href="#35909234">next</a><span>|</span><label class="collapse" for="c-35909636">[-]</label><label class="expand" for="c-35909636">[15 more]</label></div><br/><div class="children"><div class="content">I used to be excited about complexity theory, but these days I can&#x27;t help but wonder, what is the practical applications of this in real engineering problems? Most of the NP-Complete problems can be solved in polynomial time (but not all, of course!) with appropriate heuristics.</div><br/><div id="35911636" class="c"><input type="checkbox" id="c-35911636" checked=""/><div class="controls bullet"><span class="by">H8crilA</span><span>|</span><a href="#35909636">parent</a><span>|</span><a href="#35910180">next</a><span>|</span><label class="collapse" for="c-35911636">[-]</label><label class="expand" for="c-35911636">[3 more]</label></div><br/><div class="children"><div class="content">If P=NP then there is no encryption and no secure digital signature algorithms whatsoever. No post-quantum variants, I mean there&#x27;s nothing at all. Also, if P=NP quantum computers are probably not useful at all, perhaps they&#x27;re a bit cheaper, that&#x27;s all.<p>There&#x27;s a lot of NP-hard problems that you&#x27;d love to solve if you could, but you avoid them because you immediately know it&#x27;s not possible. For example, you could create optimal neural networks that might be 10x? 100x? more powerful for the same size&#x2F;cost as GPT-4 is.<p>This stuff is likely so beyond the reach of today&#x27;s knowledge that it would be like talking about quantum mechanics and integrated circuits running at GHz speed to Euclides. It&#x27;s like when Paul Erdős talked about the Collatz conjecture: &quot;Mathematics may not be ready for such problems.&quot;</div><br/><div id="35913327" class="c"><input type="checkbox" id="c-35913327" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#35909636">root</a><span>|</span><a href="#35911636">parent</a><span>|</span><a href="#35913556">next</a><span>|</span><label class="collapse" for="c-35913327">[-]</label><label class="expand" for="c-35913327">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If P=NP then there is no encryption and no secure digital signature algorithms whatsoever.<p>Why do you say that?  A problem being in P does not necessarily mean that it&#x27;s easy, or that it is solvable at all in practice.  Recall that the class P contains problems that require a running time of O(n^A(6,6)), where A is the Ackerman function.  This is an inconceivably large number, and there&#x27;s no realistic expectation to solve such a problem for even minuscule values of n, like n=2 or 3.<p>The class P is <i>huge</i>, and our puny linear and quadratic algorithms can only solve its lower, trivial levels.  We have not yet started scratching the surface of the enormous set P, yet some of us are arrogant enough to call all of it &quot;easy&quot;.<p>For all we know, it may well be that P=NP but have no practical consequences whatsoever.</div><br/></div></div><div id="35913556" class="c"><input type="checkbox" id="c-35913556" checked=""/><div class="controls bullet"><span class="by">yeeniee</span><span>|</span><a href="#35909636">root</a><span>|</span><a href="#35911636">parent</a><span>|</span><a href="#35913327">prev</a><span>|</span><a href="#35910180">next</a><span>|</span><label class="collapse" for="c-35913556">[-]</label><label class="expand" for="c-35913556">[1 more]</label></div><br/><div class="children"><div class="content">&gt;If P=NP then there is no encryption and no secure digital signature algorithms whatsoever.<p>I don&#x27;t see how that follows.<p>A polynomial can still have factors or constants on the orders of &quot;not in this universe&#x27;s lifetime&quot;, so for all practical purposes it doesn&#x27;t matter.</div><br/></div></div></div></div><div id="35910180" class="c"><input type="checkbox" id="c-35910180" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#35909636">parent</a><span>|</span><a href="#35911636">prev</a><span>|</span><a href="#35909903">next</a><span>|</span><label class="collapse" for="c-35910180">[-]</label><label class="expand" for="c-35910180">[2 more]</label></div><br/><div class="children"><div class="content">In my experience of NP-complete research, there tends to be “real world bias”.<p>There are problems we can mostly solve in polynomial time, and those gets lots of study and people talk about them a lot.<p>There are other problems which are equally valid np-complete problems, for example reversing most encryption and hashing algorithms (with hashes you obviously don’t get a unique reversal, but you can get something), which we generally don’t discuss, as they are entirely unsolvable in practice.</div><br/><div id="35910421" class="c"><input type="checkbox" id="c-35910421" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#35909636">root</a><span>|</span><a href="#35910180">parent</a><span>|</span><a href="#35909903">next</a><span>|</span><label class="collapse" for="c-35910421">[-]</label><label class="expand" for="c-35910421">[1 more]</label></div><br/><div class="children"><div class="content">Finding a hash pre-image is kind of an artificial problem, because hash algorithms are specificly chosen to make that hard.<p>I would assume those things are not np-complete and just np.</div><br/></div></div></div></div><div id="35909903" class="c"><input type="checkbox" id="c-35909903" checked=""/><div class="controls bullet"><span class="by">ackbar03</span><span>|</span><a href="#35909636">parent</a><span>|</span><a href="#35910180">prev</a><span>|</span><a href="#35909731">next</a><span>|</span><label class="collapse" for="c-35909903">[-]</label><label class="expand" for="c-35909903">[1 more]</label></div><br/><div class="children"><div class="content">I did a fix on some open source tool that was pretty fancy and had the same operational complexity. But then I realized oh sht, it&#x27;s now two times slower</div><br/></div></div><div id="35909731" class="c"><input type="checkbox" id="c-35909731" checked=""/><div class="controls bullet"><span class="by">zeroonetwothree</span><span>|</span><a href="#35909636">parent</a><span>|</span><a href="#35909903">prev</a><span>|</span><a href="#35912004">next</a><span>|</span><label class="collapse" for="c-35909731">[-]</label><label class="expand" for="c-35909731">[7 more]</label></div><br/><div class="children"><div class="content">Much of theoretical CS is just math and has no real practical consequences. Once in a while you do encounter something useful but it’s rare.</div><br/><div id="35909889" class="c"><input type="checkbox" id="c-35909889" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#35909636">root</a><span>|</span><a href="#35909731">parent</a><span>|</span><a href="#35910777">next</a><span>|</span><label class="collapse" for="c-35909889">[-]</label><label class="expand" for="c-35909889">[5 more]</label></div><br/><div class="children"><div class="content">Many NP-complete problems and their Harder variants are in the realm of optimization.  Packing boxes in air freight 1% tighter can have millions of dollars of practical consequences per year.  Communications and electrical networks depend on the Steiner tree problem.  Machine shops, restaurants, etc leave money on the table when their schedules are not well-optimized.  I could go on and on.</div><br/><div id="35910229" class="c"><input type="checkbox" id="c-35910229" checked=""/><div class="controls bullet"><span class="by">bjourne</span><span>|</span><a href="#35909636">root</a><span>|</span><a href="#35909889">parent</a><span>|</span><a href="#35910137">next</a><span>|</span><label class="collapse" for="c-35910229">[-]</label><label class="expand" for="c-35910229">[3 more]</label></div><br/><div class="children"><div class="content">There are polynomial-time approximation schemes for all those problems. Few of the NP-complete problems are both difficult to approximate and have practical use cases. 3SAT is the big exception.</div><br/><div id="35912141" class="c"><input type="checkbox" id="c-35912141" checked=""/><div class="controls bullet"><span class="by">CaptainNegative</span><span>|</span><a href="#35909636">root</a><span>|</span><a href="#35910229">parent</a><span>|</span><a href="#35911767">next</a><span>|</span><label class="collapse" for="c-35912141">[-]</label><label class="expand" for="c-35912141">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know which airlines are packing one-dimensional bins :). In dimensions 2 and above, bin packing has no PTAS unless P=NP, and in particular it&#x27;s hard to derive anything with an approximation ratio appreciably better than sqrt(num_dimensions)).<p>And the famous Steiner tree result holds only in highly structured metrics like the Euclidean plane and some minor generalizations. For general metrics there&#x27;s a lower bound of around 1.01 unless P=NP.</div><br/></div></div><div id="35911767" class="c"><input type="checkbox" id="c-35911767" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#35909636">root</a><span>|</span><a href="#35910229">parent</a><span>|</span><a href="#35912141">prev</a><span>|</span><a href="#35910137">next</a><span>|</span><label class="collapse" for="c-35911767">[-]</label><label class="expand" for="c-35911767">[1 more]</label></div><br/><div class="children"><div class="content">Steiner tree problems are particularly vexatious in that regard.  Polynomial-time approximation only guarantees a solution at most 40% more expensive than optimal.  When you&#x27;re spending tens to hundreds of millions of dollars on an electrical grid, that&#x27;s quite the differential.</div><br/></div></div></div></div><div id="35910137" class="c"><input type="checkbox" id="c-35910137" checked=""/><div class="controls bullet"><span class="by">affinepplan</span><span>|</span><a href="#35909636">root</a><span>|</span><a href="#35909889">parent</a><span>|</span><a href="#35910229">prev</a><span>|</span><a href="#35910777">next</a><span>|</span><label class="collapse" for="c-35910137">[-]</label><label class="expand" for="c-35910137">[1 more]</label></div><br/><div class="children"><div class="content">yes but theoretical advancements in NP-complete problems very rarely turn into empirical improvements</div><br/></div></div></div></div></div></div><div id="35912004" class="c"><input type="checkbox" id="c-35912004" checked=""/><div class="controls bullet"><span class="by">Ar-Curunir</span><span>|</span><a href="#35909636">parent</a><span>|</span><a href="#35909731">prev</a><span>|</span><a href="#35909234">next</a><span>|</span><label class="collapse" for="c-35912004">[-]</label><label class="expand" for="c-35912004">[1 more]</label></div><br/><div class="children"><div class="content">Complexity theory doesn&#x27;t need to have practical applications to be exciting (though it has often led to such practical applications). Complexity theory explores the fundamental nature of computation: what is and isn&#x27;t feasible. It&#x27;s a window into how the universe works, and so it&#x27;s exciting in the same way that, say, general relativity or quantum mechanics is.</div><br/></div></div></div></div><div id="35909234" class="c"><input type="checkbox" id="c-35909234" checked=""/><div class="controls bullet"><span class="by">sgrove</span><span>|</span><a href="#35909636">prev</a><span>|</span><a href="#35913148">next</a><span>|</span><label class="collapse" for="c-35909234">[-]</label><label class="expand" for="c-35909234">[1 more]</label></div><br/><div class="children"><div class="content">My absolute favorite overview of this - the video goes over both the explanation of the spaces, but also how it relates to a sort of understanding of reality itself!<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;YX40hbAHx3s" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;YX40hbAHx3s</a></div><br/></div></div><div id="35913148" class="c"><input type="checkbox" id="c-35913148" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#35909234">prev</a><span>|</span><a href="#35911185">next</a><span>|</span><label class="collapse" for="c-35913148">[-]</label><label class="expand" for="c-35913148">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The canonical NP problem is quantified satisfiability.<p>That should be &quot;canonical PSPACE problem&quot;, I believe.</div><br/></div></div><div id="35911185" class="c"><input type="checkbox" id="c-35911185" checked=""/><div class="controls bullet"><span class="by">elteto</span><span>|</span><a href="#35913148">prev</a><span>|</span><a href="#35911613">next</a><span>|</span><label class="collapse" for="c-35911185">[-]</label><label class="expand" for="c-35911185">[2 more]</label></div><br/><div class="children"><div class="content">Coming to a software interview near you: “Define a Vector Addition System as follows: you have a starting vector S, like [...] You have 45 minutes, I expect working code.”</div><br/><div id="35911199" class="c"><input type="checkbox" id="c-35911199" checked=""/><div class="controls bullet"><span class="by">blt</span><span>|</span><a href="#35911185">parent</a><span>|</span><a href="#35911613">next</a><span>|</span><label class="collapse" for="c-35911199">[-]</label><label class="expand" for="c-35911199">[1 more]</label></div><br/><div class="children"><div class="content">Just because the complexity is high, doesn&#x27;t mean the algorithm is complicated.</div><br/></div></div></div></div><div id="35911613" class="c"><input type="checkbox" id="c-35911613" checked=""/><div class="controls bullet"><span class="by">Xcelerate</span><span>|</span><a href="#35911185">prev</a><span>|</span><a href="#35911715">next</a><span>|</span><label class="collapse" for="c-35911613">[-]</label><label class="expand" for="c-35911613">[1 more]</label></div><br/><div class="children"><div class="content">For problems that are still computable, what’s the upper limit to hardness? BB(n)?</div><br/></div></div><div id="35911715" class="c"><input type="checkbox" id="c-35911715" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#35911613">prev</a><span>|</span><a href="#35911820">next</a><span>|</span><label class="collapse" for="c-35911715">[-]</label><label class="expand" for="c-35911715">[1 more]</label></div><br/><div class="children"><div class="content">&gt; introduces the HAck complexity class and gives examples of it. Both the definition and the examples are beyond my understanding.<p>hah, i&#x27;ve already lost understanding at the &#x27;ELEMENTARY-complete&#x27; level.</div><br/></div></div><div id="35911820" class="c"><input type="checkbox" id="c-35911820" checked=""/><div class="controls bullet"><span class="by">gessha</span><span>|</span><a href="#35911715">prev</a><span>|</span><a href="#35909377">next</a><span>|</span><label class="collapse" for="c-35911820">[-]</label><label class="expand" for="c-35911820">[1 more]</label></div><br/><div class="children"><div class="content">Hmm, I didn’t see “designing a mediocre printer” in there</div><br/></div></div><div id="35909377" class="c"><input type="checkbox" id="c-35909377" checked=""/><div class="controls bullet"><span class="by">krick</span><span>|</span><a href="#35911820">prev</a><span>|</span><a href="#35909836">next</a><span>|</span><label class="collapse" for="c-35909377">[-]</label><label class="expand" for="c-35909377">[5 more]</label></div><br/><div class="children"><div class="content">How hard is computing Ramsey numbers, BTW? Is there a word for that?</div><br/><div id="35909820" class="c"><input type="checkbox" id="c-35909820" checked=""/><div class="controls bullet"><span class="by">Laakeri</span><span>|</span><a href="#35909377">parent</a><span>|</span><a href="#35909836">next</a><span>|</span><label class="collapse" for="c-35909820">[-]</label><label class="expand" for="c-35909820">[4 more]</label></div><br/><div class="children"><div class="content">For binary-encoded input it is in 2-EXPTIME by trying all graphs of size exponential in the input number and testing all subsets of the given size. Would be surprising if any hardness result for complexity classes would be known.</div><br/><div id="35910947" class="c"><input type="checkbox" id="c-35910947" checked=""/><div class="controls bullet"><span class="by">ouid</span><span>|</span><a href="#35909377">root</a><span>|</span><a href="#35909820">parent</a><span>|</span><a href="#35909836">next</a><span>|</span><label class="collapse" for="c-35910947">[-]</label><label class="expand" for="c-35910947">[3 more]</label></div><br/><div class="children"><div class="content">Wait, that doesn&#x27;t make sense, does it? The Ramsey function grows so fast that Peano arithmetic cannot prove that it is total.</div><br/><div id="35912192" class="c"><input type="checkbox" id="c-35912192" checked=""/><div class="controls bullet"><span class="by">CaptainNegative</span><span>|</span><a href="#35909377">root</a><span>|</span><a href="#35910947">parent</a><span>|</span><a href="#35909836">next</a><span>|</span><label class="collapse" for="c-35912192">[-]</label><label class="expand" for="c-35912192">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what you&#x27;re referring to here. Ramsey&#x27;s theorem is constructive enough that you can extract an upper bound of 4^k on the kth diagonal Ramsey number, and the (j,k)th Ramsey number is bounded from above by the max(j,k)th diagonal number.</div><br/><div id="35913125" class="c"><input type="checkbox" id="c-35913125" checked=""/><div class="controls bullet"><span class="by">ouid</span><span>|</span><a href="#35909377">root</a><span>|</span><a href="#35912192">parent</a><span>|</span><a href="#35909836">next</a><span>|</span><label class="collapse" for="c-35913125">[-]</label><label class="expand" for="c-35913125">[1 more]</label></div><br/><div class="children"><div class="content">My mistake. I, and I suspect the original commenter, was thinking about the <i>strengthened</i> finite Ramsey theorem. From wikipedia: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Paris%E2%80%93Harrington_theorem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Paris%E2%80%93Harrington_theor...</a><p>For any positive integers n, k, m, such that m ≥ n, one can find N with the following property: if we color each of the n-element subsets of S = {1, 2, 3,..., N} with one of k colors, then we can find a subset Y of S with at least m elements, such that all n-element subsets of Y have the same color, and the number of elements of Y is at least the smallest element of Y.<p><i>This</i> function is outside the reach of Peano arithmetic.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="35909836" class="c"><input type="checkbox" id="c-35909836" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#35909377">prev</a><span>|</span><a href="#35909230">next</a><span>|</span><label class="collapse" for="c-35909836">[-]</label><label class="expand" for="c-35909836">[2 more]</label></div><br/><div class="children"><div class="content">For anyone with an interest in going a little deeper, in my opinion the best textbook on the subject is Sipser&#x27;s <i>Introduction to the Theory of Computation</i>. It&#x27;s truly introductory, so anyone who is smart enough to program will be able to follow, if they do the work.<p>[1] <a href="https:&#x2F;&#x2F;www.goodreads.com&#x2F;en&#x2F;book&#x2F;show&#x2F;400716" rel="nofollow">https:&#x2F;&#x2F;www.goodreads.com&#x2F;en&#x2F;book&#x2F;show&#x2F;400716</a></div><br/><div id="35913547" class="c"><input type="checkbox" id="c-35913547" checked=""/><div class="controls bullet"><span class="by">henrik_w</span><span>|</span><a href="#35909836">parent</a><span>|</span><a href="#35909230">next</a><span>|</span><label class="collapse" for="c-35913547">[-]</label><label class="expand" for="c-35913547">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, looks fantastic. Just ordered it.</div><br/></div></div></div></div><div id="35911762" class="c"><input type="checkbox" id="c-35911762" checked=""/><div class="controls bullet"><span class="by">bobsmooth</span><span>|</span><a href="#35909230">prev</a><span>|</span><label class="collapse" for="c-35911762">[-]</label><label class="expand" for="c-35911762">[1 more]</label></div><br/><div class="children"><div class="content">The 2-EXPTIME example of beating pokemon blind and deaf is really interesting.</div><br/></div></div></div></div></div></div></div></body></html>