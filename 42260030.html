<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732784458451" as="style"/><link rel="stylesheet" href="styles.css?v=1732784458451"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://arxiv.org/abs/2411.16544">Float Self-Tagging</a>Â <span class="domain">(<a href="https://arxiv.org">arxiv.org</a>)</span></div><div class="subtext"><span>ndjdjddjsjj</span> | <span>21 comments</span></div><br/><div><div id="42261548" class="c"><input type="checkbox" id="c-42261548" checked=""/><div class="controls bullet"><span class="by">pavpanchekha</span><span>|</span><a href="#42263230">next</a><span>|</span><label class="collapse" for="c-42261548">[-]</label><label class="expand" for="c-42261548">[15 more]</label></div><br/><div class="children"><div class="content">I loved this clever, weird, awesome paper, so a short summary.<p>In many dynamic languages some values are stored on the heap (&quot;boxed&quot;) and represented as a pointer, while others are represented as an immediate value (&quot;unboxed&quot; or &quot;immediate&quot;). Pointer tagging is a common way to do that: the low bit of the value tells you the value&#x27;s type, and some types are immediate while others are boxed.<p>Naturally, the tag bits have a fixed value, so can&#x27;t be used to store data. So for example your language might offer 61-bit integer immediates instead of 64-bit integers; the other three bits are used for tags. Possibly, larger integers are stored on the heap and treated as a different type (for example Python 2.X had separate int and long types for these cases).<p>However, it&#x27;s hard to use this strategy for floats, because floats need all 64 bits (or 32 bits for single-precision, same difference). There&#x27;s a trick called &quot;NaN boxing&quot; which makes use of the large number of NaNs in the float representation, but read the paper if you want more on that.<p>The authors&#x27; insight is that, suppose you have a three-bit tag and 011 is the tag for floats. By totally random chance, _some_ floats will end in 011; you can represent those as immediates with those tag bits. Obviously, that&#x27;s unlikely, though you can raise the chances by using, like, 010, 011, 100, and 101 all as float tags. Still, the low bits are a bad choice. But what about high bits? Most floats have one of a couple high bit patterns, because most floats are either 0 or between, say, 1e-100 and 1e100. Floats outside that range can be boxed but since they&#x27;re really rare it&#x27;s not a big cost to box them.<p>So basically, we use high bits as our tag bits and map all the common float prefixes to float tags. This allows unboxing the vast majority of floats, which leads to <i>big</i> speedups on float-heavy benchmarks.<p>A personal note: I&#x27;ve been working in numerics and floating-point for a decade now and have had to deal with float boxing both from a research point of view (lots of runtime analysis systems for floats), from a user point of view (using unboxed float vectors for significant speedup in my own software), and from a teaching point of view (discussing boxing in my compilers class, using NaN-boxing as an example of cleverness).<p>This idea is so simple, so crazy, so stupid, and works so well, but I never thought of it. Bravo to the authors.</div><br/><div id="42262159" class="c"><input type="checkbox" id="c-42262159" checked=""/><div class="controls bullet"><span class="by">daanx</span><span>|</span><a href="#42261548">parent</a><span>|</span><a href="#42261761">next</a><span>|</span><label class="collapse" for="c-42262159">[-]</label><label class="expand" for="c-42262159">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This idea is so simple, so crazy, so stupid, and works so well, but I never thought of it. Bravo to the authors.<p>Thanks for the nice summary -- looking forward to read the paper!<p>The same idea of self-tagging is actually also used in Koka language [1] runtime system where by default the Koka compiler only heap allocates float64&#x27;s when their absolute value is outside the range [2e-511,2e512) and not 0, infinity, or NaN (see [2]). This saves indeed many (many!) heap allocations for float intensive programs.<p>Since Koka only uses 1 bit to distinguish pointers from values, another slightly faster option is to only box negative float64&#x27;s but of course, negative numbers are still quite common so it saves less allocations in general.<p>[1] <a href="https:&#x2F;&#x2F;koka-lang.github.io&#x2F;koka&#x2F;doc&#x2F;book.html#sec-value-types" rel="nofollow">https:&#x2F;&#x2F;koka-lang.github.io&#x2F;koka&#x2F;doc&#x2F;book.html#sec-value-typ...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;koka-lang&#x2F;koka&#x2F;blob&#x2F;dev&#x2F;kklib&#x2F;src&#x2F;box.c#L309">https:&#x2F;&#x2F;github.com&#x2F;koka-lang&#x2F;koka&#x2F;blob&#x2F;dev&#x2F;kklib&#x2F;src&#x2F;box.c#L...</a><p>ps. If you enjoy reading about tagging, I recently wrote a note on efficiently supporting seamless large integer arithmetic (as used in Koka as well) and discuss how certain hardware instructions could really help to speed this up [3]:<p>[3] <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;uploads&#x2F;prod&#x2F;2022&#x2F;07&#x2F;int.pdf" rel="nofollow">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;uploads&#x2F;prod&#x2F;2022&#x2F;0...</a> (ML workshop 2022)</div><br/></div></div><div id="42261761" class="c"><input type="checkbox" id="c-42261761" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#42261548">parent</a><span>|</span><a href="#42262159">prev</a><span>|</span><a href="#42263093">next</a><span>|</span><label class="collapse" for="c-42261761">[-]</label><label class="expand" for="c-42261761">[6 more]</label></div><br/><div class="children"><div class="content">Do all float operations need to reconfirm those bits afterwards though? I suppose if you have some sort of JIT you can end up with a bunch of unboxed floats and would only pay the cost on boundaries though</div><br/><div id="42263129" class="c"><input type="checkbox" id="c-42263129" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42261761">parent</a><span>|</span><a href="#42262058">next</a><span>|</span><label class="collapse" for="c-42263129">[-]</label><label class="expand" for="c-42263129">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but there should be some optimisation opportunities.<p>Off the top of my head: Any multiply by a constant less than 1.0 will never overflow the unboxed range (but might underflow) and there should be times when it&#x27;s provably better to check the inputs are inside a range, rather than checking the outputs.<p>It&#x27;s worth pointing out that these overflow&#x2F;underflow checks will be very cold (on typical code). They won&#x27;t waste much in the way of branch-prediction resources.<p>I wonder if it&#x27;s worth taking advantage of floating point overflow&#x2F;underflow exceptions. I think a multiplication by 2^767 will trigger an exception if the value would overflow, and the corresponding multiply by 2^-765 will catch underflows.<p>It&#x27;s tempting to allocate two more tags for floats (001 and 010), covering the entire range from -2^257 to +2^257. It will be rare to actually see those small floats near zero, but it could be worth eliminating the possibility of underflows.</div><br/></div></div><div id="42262058" class="c"><input type="checkbox" id="c-42262058" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42261761">parent</a><span>|</span><a href="#42263129">prev</a><span>|</span><a href="#42261994">next</a><span>|</span><label class="collapse" for="c-42262058">[-]</label><label class="expand" for="c-42262058">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>reconfirm those bits afterwards</i><p>Thanks - I hadn&#x27;t thought about that but it seems to be the main downside of this approach. The benefit of NaN-boxing is that it reassigns values that are otherwise unused - floating-point calculations will never generate NaNs with those bit patterns.</div><br/><div id="42263237" class="c"><input type="checkbox" id="c-42263237" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42262058">parent</a><span>|</span><a href="#42261994">next</a><span>|</span><label class="collapse" for="c-42263237">[-]</label><label class="expand" for="c-42263237">[1 more]</label></div><br/><div class="children"><div class="content">An additional wrinkle is that NaNs are a bit unstable and can have large performance penalties. You can&#x27;t let the NaNs ever escape into arithmetic and you may even have issues even storing them in a register.</div><br/></div></div></div></div><div id="42261994" class="c"><input type="checkbox" id="c-42261994" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42261761">parent</a><span>|</span><a href="#42262058">prev</a><span>|</span><a href="#42263093">next</a><span>|</span><label class="collapse" for="c-42261994">[-]</label><label class="expand" for="c-42261994">[2 more]</label></div><br/><div class="children"><div class="content">Only when they have to be boxed, but yes if you are talking about that.</div><br/><div id="42263056" class="c"><input type="checkbox" id="c-42263056" checked=""/><div class="controls bullet"><span class="by">ndjdjddjsjj</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42261994">parent</a><span>|</span><a href="#42263093">next</a><span>|</span><label class="collapse" for="c-42263056">[-]</label><label class="expand" for="c-42263056">[1 more]</label></div><br/><div class="children"><div class="content">You need to check after the floating point operation though just in case. Or after the boundary where you pass the float to something else expecting this scheme.</div><br/></div></div></div></div></div></div><div id="42263093" class="c"><input type="checkbox" id="c-42263093" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#42261548">parent</a><span>|</span><a href="#42261761">prev</a><span>|</span><a href="#42261743">next</a><span>|</span><label class="collapse" for="c-42263093">[-]</label><label class="expand" for="c-42263093">[1 more]</label></div><br/><div class="children"><div class="content">Itâs clever, but not random chance. That would be too much of a coincidence. They rotate the floats to make it happen the way they want.<p>Itâs hardly random that only 8 bits of exponent are needed for many calculations.</div><br/></div></div><div id="42261743" class="c"><input type="checkbox" id="c-42261743" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#42261548">parent</a><span>|</span><a href="#42263093">prev</a><span>|</span><a href="#42261690">next</a><span>|</span><label class="collapse" for="c-42261743">[-]</label><label class="expand" for="c-42261743">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <i>This allows unboxing the vast majority of floats, which leads to big speedups on float-heavy benchmarks.</i><p>NaN-boxing allows <i>all</i> floats to be unboxed though. The main benefit of the self-tagging approach seems to be that by boxing <i>some</i> floats, we can make space for 64-bit pointers which are too large for NaN-boxing.<p>The surprising part of the paper is that &quot;<i>some</i> floats&quot; is only a small minority of values - not, say, 50% of them.</div><br/><div id="42263029" class="c"><input type="checkbox" id="c-42263029" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42261743">parent</a><span>|</span><a href="#42262562">next</a><span>|</span><label class="collapse" for="c-42263029">[-]</label><label class="expand" for="c-42263029">[1 more]</label></div><br/><div class="children"><div class="content">A small minority, but apparently it includes all the floats youâre likely to use. It seems the insight is that you only need 8 bits of exponent in most cases. (And single-precision floating point only has 8 bits of exponent.)<p><i>Most</i> double-precision floats are never used because they have high exponents.</div><br/></div></div><div id="42262562" class="c"><input type="checkbox" id="c-42262562" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42261743">parent</a><span>|</span><a href="#42263029">prev</a><span>|</span><a href="#42261690">next</a><span>|</span><label class="collapse" for="c-42262562">[-]</label><label class="expand" for="c-42262562">[2 more]</label></div><br/><div class="children"><div class="content">50% means you only get 1 tag bit.<p>also you totally can fit 64 bit pointers inside a NaN. 46 bit pointers are only 48 bits and you have 53 bits of NaN payload. (you also could get an extra 3 bits if you only allow storing 8 byte aligned pointers unboxed)</div><br/><div id="42262621" class="c"><input type="checkbox" id="c-42262621" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42262562">parent</a><span>|</span><a href="#42261690">next</a><span>|</span><label class="collapse" for="c-42262621">[-]</label><label class="expand" for="c-42262621">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>50% means you only get 1 tag bit.</i><p>That&#x27;s enough to distinguish between &quot;unboxed float&quot; and &quot;something else&quot;, where the latter can have additional tag bits.<p>&gt; <i>[64-bit] pointers are only 48 bits and you have 53 bits of NaN payload.</i><p>The paper specifically talks about support for &quot;high memory addresses that do not fit in 48 bits&quot;. If you don&#x27;t have to handle those high addresses, I don&#x27;t think this approach has any benefits compared to NaN-boxing.</div><br/></div></div></div></div></div></div><div id="42261690" class="c"><input type="checkbox" id="c-42261690" checked=""/><div class="controls bullet"><span class="by">jonnycomputer</span><span>|</span><a href="#42261548">parent</a><span>|</span><a href="#42261743">prev</a><span>|</span><a href="#42263016">next</a><span>|</span><label class="collapse" for="c-42261690">[-]</label><label class="expand" for="c-42261690">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for the clear explanation!</div><br/></div></div></div></div><div id="42263230" class="c"><input type="checkbox" id="c-42263230" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#42261548">prev</a><span>|</span><a href="#42262354">next</a><span>|</span><label class="collapse" for="c-42263230">[-]</label><label class="expand" for="c-42263230">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For instance, NaN-tagging prevents (or largely complicates) optimizations relying on stack allocations. The stack uses high memory addresses that do not fit in 48 bits unless encoded relative to the location of the stack segment.<p>Er, what?  The paper says they tested on a Xeon CPU, so x86-64, running Linux.  On traditional x86-64, all pointers fit in 48 bits, period.  Stack memory is no exception.  More recently the architecture was extended to allow 56-bit pointers, but my impression is that Linux (like other OSes) keeps them disabled by default in userspace.  According to the documentation [1]:<p>&gt; Not all user space is ready to handle wide addresses. [..] To mitigate this, we are not going to allocate virtual address space above 47-bit by default.<p>So how would the stack end up above 47 bits?  Is the documentation out of date?<p>[1] <a href="https:&#x2F;&#x2F;docs.kernel.org&#x2F;arch&#x2F;x86&#x2F;x86_64&#x2F;5level-paging.html" rel="nofollow">https:&#x2F;&#x2F;docs.kernel.org&#x2F;arch&#x2F;x86&#x2F;x86_64&#x2F;5level-paging.html</a></div><br/></div></div><div id="42262354" class="c"><input type="checkbox" id="c-42262354" checked=""/><div class="controls bullet"><span class="by">plagiarist</span><span>|</span><a href="#42263230">prev</a><span>|</span><label class="collapse" for="c-42262354">[-]</label><label class="expand" for="c-42262354">[4 more]</label></div><br/><div class="children"><div class="content">The idea in the paper is really cool.<p>People who enjoyed this might also like to read how Apple used tagged pointers for short strings in Objective-C [0]. I think that&#x27;s when I first learned about tagged pointers. NaN-boxing was mindblowing for me. I love this kind of stuff.<p>[0] <a href="https:&#x2F;&#x2F;mikeash.com&#x2F;pyblog&#x2F;friday-qa-2015-07-31-tagged-pointer-strings.html" rel="nofollow">https:&#x2F;&#x2F;mikeash.com&#x2F;pyblog&#x2F;friday-qa-2015-07-31-tagged-point...</a></div><br/><div id="42262832" class="c"><input type="checkbox" id="c-42262832" checked=""/><div class="controls bullet"><span class="by">wging</span><span>|</span><a href="#42262354">parent</a><span>|</span><label class="collapse" for="c-42262832">[-]</label><label class="expand" for="c-42262832">[3 more]</label></div><br/><div class="children"><div class="content">Another cool thing that seems related: exploiting alignment to free up N bits in a &#x27;pointer&#x27; representation, because your values have to be aligned. The JVM does this to expand the set of possible addresses representable in 32 bits: <a href="https:&#x2F;&#x2F;shipilev.net&#x2F;jvm&#x2F;anatomy-quarks&#x2F;23-compressed-references&#x2F;" rel="nofollow">https:&#x2F;&#x2F;shipilev.net&#x2F;jvm&#x2F;anatomy-quarks&#x2F;23-compressed-refere...</a><p>So, for example, with 3 bits of alignment required, the first valid address for a pointer to point to after 0x0 is 0x8, and after that is 0x10, but you represent those as 0x1 and 0x2 respectively, and use a shift to get back the actual address (0x1 &lt;&lt; 3 = 0x8, actual address). I think this is gestured at in section 1.1 of the paper, sort of, except they envision using the space thus freed for tags, rather than additional bits. (Which only makes sense if your address is 32 bits anyway, rather than 64 as in the paper: no one has 67-bit addresses. So saving 3 bits doesn&#x27;t buy you anything. I think.)<p>&gt; Aligning all heap-allocated values to 64-bit machine words conveniently frees the low bits of pointers to store a 3-bit tag.</div><br/><div id="42262934" class="c"><input type="checkbox" id="c-42262934" checked=""/><div class="controls bullet"><span class="by">plagiarist</span><span>|</span><a href="#42262354">root</a><span>|</span><a href="#42262832">parent</a><span>|</span><label class="collapse" for="c-42262934">[-]</label><label class="expand" for="c-42262934">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s interesting which runtimes exploit the extra space for what reasons! Definitely makes more sense to have the extra address space on 32 bits compared to 64. I wonder if the extra addresses are specific to JVM &#x2F; not something that works well in the C family?</div><br/><div id="42263485" class="c"><input type="checkbox" id="c-42263485" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42262354">root</a><span>|</span><a href="#42262934">parent</a><span>|</span><label class="collapse" for="c-42263485">[-]</label><label class="expand" for="c-42263485">[1 more]</label></div><br/><div class="children"><div class="content">Well in C you have non-aligned pointers, because you can have pointers to things that aren&#x27;t objects and might not be aligned (e.g. individual chars or shorts). In Java everything is at least 8-byte-aligned, you can&#x27;t store a loose char&#x2F;short&#x2F;int on the heap (it has to go in a boxed object that&#x27;s 8-byte-aligned, though the compiler will do this semi-automatically) and you can&#x27;t take a pointer to an individual element of an array.<p>If you applied the C standard strictly, you could use a JVM-style representation for pointers to longs, pointers, and structs that start with longs and pointers, so you could theoretically have an implementation where those pointers were shorter. But you&#x27;d have to convert back and forth when casting to and from void* (and char*), and in practice C people expect to be able to cast a long* to int, cast that to void*, and get the same result as casting long* to void*, even though doing that and using it is undefined behaviour according to the standard.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>