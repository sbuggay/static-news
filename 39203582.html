<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706778072749" as="style"/><link rel="stylesheet" href="styles.css?v=1706778072749"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dave.cheney.net/2019/05/07/prefer-table-driven-tests">Prefer table driven tests (2019)</a> <span class="domain">(<a href="https://dave.cheney.net">dave.cheney.net</a>)</span></div><div class="subtext"><span>PaulHoule</span> | <span>14 comments</span></div><br/><div><div id="39213893" class="c"><input type="checkbox" id="c-39213893" checked=""/><div class="controls bullet"><span class="by">yellowapple</span><span>|</span><a href="#39213536">next</a><span>|</span><label class="collapse" for="c-39213893">[-]</label><label class="expand" for="c-39213893">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m fond of taking this a step further and actually offloading the test cases to a separate language-agnostic file, then have implementations&#x27; test harnesses read cases from that file.  The Ruby gem for Base32H¹ does exactly this to test the encoder&#x2F;decoder logic, pulling the test cases from CSV files in a separate repo² included as a Git submodule.  One of these days I need to port the other reference implementations over to using the tests repo, but once that&#x27;s done I&#x27;ll be able to update the test cases in one place and they&#x27;ll automatically work everywhere.<p>----<p>¹ <a href="https:&#x2F;&#x2F;github.com&#x2F;Base32H&#x2F;base32h.rb&#x2F;tree&#x2F;master&#x2F;spec">https:&#x2F;&#x2F;github.com&#x2F;Base32H&#x2F;base32h.rb&#x2F;tree&#x2F;master&#x2F;spec</a><p>² <a href="https:&#x2F;&#x2F;github.com&#x2F;Base32H&#x2F;base32h-tests">https:&#x2F;&#x2F;github.com&#x2F;Base32H&#x2F;base32h-tests</a></div><br/></div></div><div id="39213536" class="c"><input type="checkbox" id="c-39213536" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39213893">prev</a><span>|</span><a href="#39213349">next</a><span>|</span><label class="collapse" for="c-39213536">[-]</label><label class="expand" for="c-39213536">[7 more]</label></div><br/><div class="children"><div class="content">As usually, Gophers might have some good ideas here and there, but they are stuck in their own world..<p>The obvious-in-hindsight next step up from table driven tests is property based testing.  That&#x27;s where you ask the computer to generate the tables for you, and also to automatically shrink any counterexamples it finds to be as simple as possible.<p>See <a href="https:&#x2F;&#x2F;fsharpforfunandprofit.com&#x2F;series&#x2F;property-based-testing&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fsharpforfunandprofit.com&#x2F;series&#x2F;property-based-test...</a> for an introduction.<p>(One big benefit you get from property based testing is that the computer only needs to be taught once to always remember to also test edge cases like empty strings and zero length arrays, and NaN and infinity for your floats etc.  Instead of a human having to remember for every test that zero is also a number.<p>Of course, property-based-testing libraries also allow you to exclude those values, when they are not applicable.  Eg not everything that consumes floats needs to handle NaNs.<p>And explicitly filtering NaNs and infinities from your test case generation serves as good documentation for those kinds of assumptions.)</div><br/><div id="39213789" class="c"><input type="checkbox" id="c-39213789" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#39213536">parent</a><span>|</span><a href="#39213764">next</a><span>|</span><label class="collapse" for="c-39213789">[-]</label><label class="expand" for="c-39213789">[2 more]</label></div><br/><div class="children"><div class="content">&gt; and also to automatically shrink any counterexamples it finds to be as simple as possible.<p>This actually is a problém with most quickcheck clones (and quickcheck itself), that&#x27;s why it&#x27;s better to use a library that is inspired by Python&#x27;s Hypothesis (combining generation and shrinking, in a nutshell). So Hedgehog for Haskell and F# (instead of Fscheck) and Rapid for Go <a href="https:&#x2F;&#x2F;github.com&#x2F;flyingmutant&#x2F;rapid">https:&#x2F;&#x2F;github.com&#x2F;flyingmutant&#x2F;rapid</a><p>But tables and property tests complement each other, even if you can get rid of some tables by using property testing.<p>Example article about the shrinking of  Hypothesis vs. Quickcheck 
<a href="https:&#x2F;&#x2F;hypothesis.works&#x2F;articles&#x2F;integrated-shrinking&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hypothesis.works&#x2F;articles&#x2F;integrated-shrinking&#x2F;</a></div><br/><div id="39213897" class="c"><input type="checkbox" id="c-39213897" checked=""/><div class="controls bullet"><span class="by">lloydatkinson</span><span>|</span><a href="#39213536">root</a><span>|</span><a href="#39213789">parent</a><span>|</span><a href="#39213764">next</a><span>|</span><label class="collapse" for="c-39213897">[-]</label><label class="expand" for="c-39213897">[1 more]</label></div><br/><div class="children"><div class="content">I’ve recently started using property based testing in C# using FsCheck. The FsCheck docs are already pretty unclear with poor examples, and the C# snippets are tiny and barely explained.<p>I want to use it more but it’s actually quite painful to even understand how to achieve the thing I want. I briefly looked at Hedgehog which seems to have even less documentation let alone anything helpful for C#.<p>Just started reading that link and I agree, I’ve found it confusing how FsCheck has Arbritary and Gen. Are there any other differences?</div><br/></div></div></div></div><div id="39213764" class="c"><input type="checkbox" id="c-39213764" checked=""/><div class="controls bullet"><span class="by">boxed</span><span>|</span><a href="#39213536">parent</a><span>|</span><a href="#39213789">prev</a><span>|</span><a href="#39213802">next</a><span>|</span><label class="collapse" for="c-39213764">[-]</label><label class="expand" for="c-39213764">[2 more]</label></div><br/><div class="children"><div class="content">And mutation testing... which in my opinion is just way easier to do and more mentally straight forward. Plus you get the satisfaction is actually knowing you&#x27;re DONE, unlike PBT where you just give up after a certain amount of CPU time has passed.</div><br/><div id="39213875" class="c"><input type="checkbox" id="c-39213875" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#39213536">root</a><span>|</span><a href="#39213764">parent</a><span>|</span><a href="#39213802">next</a><span>|</span><label class="collapse" for="c-39213875">[-]</label><label class="expand" for="c-39213875">[1 more]</label></div><br/><div class="children"><div class="content">How you write the tests that you&#x27;re testing with mutatation does not matter. Or, to rephrase, you need both if you want to do mutatation testing (which is really slow).</div><br/></div></div></div></div><div id="39213802" class="c"><input type="checkbox" id="c-39213802" checked=""/><div class="controls bullet"><span class="by">Zababa</span><span>|</span><a href="#39213536">parent</a><span>|</span><a href="#39213764">prev</a><span>|</span><a href="#39213349">next</a><span>|</span><label class="collapse" for="c-39213802">[-]</label><label class="expand" for="c-39213802">[2 more]</label></div><br/><div class="children"><div class="content">There are utilities for property-based testing in the standard library <a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;testing&#x2F;quick@go1.21.6" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;testing&#x2F;quick@go1.21.6</a>. There&#x27;s also fuzzing since Go 1.18 <a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;security&#x2F;fuzz&#x2F;" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;security&#x2F;fuzz&#x2F;</a>.</div><br/><div id="39213884" class="c"><input type="checkbox" id="c-39213884" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#39213536">root</a><span>|</span><a href="#39213802">parent</a><span>|</span><a href="#39213349">next</a><span>|</span><label class="collapse" for="c-39213884">[-]</label><label class="expand" for="c-39213884">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but using quick is just a PITA, I&#x27;d recommend using Rapid <a href="https:&#x2F;&#x2F;github.com&#x2F;flyingmutant&#x2F;rapid">https:&#x2F;&#x2F;github.com&#x2F;flyingmutant&#x2F;rapid</a> instead</div><br/></div></div></div></div></div></div><div id="39213349" class="c"><input type="checkbox" id="c-39213349" checked=""/><div class="controls bullet"><span class="by">atomicnumber3</span><span>|</span><a href="#39213536">prev</a><span>|</span><a href="#39213762">next</a><span>|</span><label class="collapse" for="c-39213349">[-]</label><label class="expand" for="c-39213349">[3 more]</label></div><br/><div class="children"><div class="content">I split tests into two categories. One is &quot;I&#x27;m testing a bunch of different variations of the same thing.&quot; Table tests are great for this, they make the code pretty readable and, perhaps more importantly, the process of writing the inner part of the table test seems to nudge you to think about all the permutations and combinations of what you&#x27;re testing can be. It leads to good tests and helps you reason about your inputs.<p>The other kind of test is what I call a &quot;storybook test.&quot; Table tests are less useful here, this is usually for testing CRUD in a coherent manner but can apply to any kind of object that has a lifecycle that you need to transition between various states. You may argue: aha! This is a state machine and you ought to simply independently test each state transition! Fair enough, I say, and yes in some cases I might actually do so if the API that&#x27;s exposed lends itself to having its internal state set so explicitly. But more often than not I argue that the story itself is more valuable than exactly what permutations of the inputs and state get tested at each call. What the test represents is that some flow is important, gives an example of it, and helps show that <i>this general use-case</i> is what we want to keep working, not necessarily these specific state transitions.<p>Mind you reality is messy so tests often blur and blend and so on. But when I sit down and write a new test, I&#x27;m usually imagining it as one of these two archetypes of tests.</div><br/><div id="39213526" class="c"><input type="checkbox" id="c-39213526" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39213349">parent</a><span>|</span><a href="#39213375">next</a><span>|</span><label class="collapse" for="c-39213526">[-]</label><label class="expand" for="c-39213526">[1 more]</label></div><br/><div class="children"><div class="content">&gt; [T]he process of writing the inner part of the table test seems to nudge you to think about all the permutations and combinations of what you&#x27;re testing can be. It leads to good tests and helps you reason about your inputs.<p>I think this is not inherent. If you need to test all permutations and combinations, do the exhaustive property testing instead. Table tests (ideally) represent a pruned tree of possibilities that make intuitive sense to humans, but that pruning itself doesn&#x27;t always neatly fit into tables. But otherwise I generally agree.<p>When I write a specific set of tests I first start with representative positive cases, and I think you would call them as a storybook test (because it serves both as a test and an example). Then I map out edge and negative cases, but with a knowledge of <i>some</i> internal working in order to prune them. For example if some function `f(x, y)` requires both `x` and `y` to be a square number, I can reasonably expect that such check happens before anything else so we can only feed square numbers when we are confident enough that checks are correct. And then I optionally write more expensive tests to fill any remaining gaps---exhaustive testing, randomized testing, property testing and so on.<p>Note that these tests are essentially sequential because each test relies on assumptions that are thought to be verified by earlier tests. Some of them can make use of tables, but the entire test should look like a gradient of increasing complexity and assurance in my opinion. Table tests are only a good fit for some portion of that gradient. And I don&#x27;t like per-case subtests suggested in the OP---it just feels like a workaround over Go&#x27;s inability to provide more contexts on panic.</div><br/></div></div><div id="39213375" class="c"><input type="checkbox" id="c-39213375" checked=""/><div class="controls bullet"><span class="by">leetrout</span><span>|</span><a href="#39213349">parent</a><span>|</span><a href="#39213526">prev</a><span>|</span><a href="#39213762">next</a><span>|</span><label class="collapse" for="c-39213375">[-]</label><label class="expand" for="c-39213375">[1 more]</label></div><br/><div class="children"><div class="content">Are you dogmatic about things such as only one assert per test case or similar?</div><br/></div></div></div></div><div id="39213762" class="c"><input type="checkbox" id="c-39213762" checked=""/><div class="controls bullet"><span class="by">boxed</span><span>|</span><a href="#39213349">prev</a><span>|</span><a href="#39213433">next</a><span>|</span><label class="collapse" for="c-39213762">[-]</label><label class="expand" for="c-39213762">[1 more]</label></div><br/><div class="children"><div class="content">In Python land this is called &quot;parameterized tests&quot;: <a href="https:&#x2F;&#x2F;docs.pytest.org&#x2F;en&#x2F;7.1.x&#x2F;example&#x2F;parametrize.html" rel="nofollow">https:&#x2F;&#x2F;docs.pytest.org&#x2F;en&#x2F;7.1.x&#x2F;example&#x2F;parametrize.html</a><p>I think the author might want to look into mutation testing or property based testing to get to something closer to fully testing stuff.</div><br/></div></div><div id="39213433" class="c"><input type="checkbox" id="c-39213433" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39213762">prev</a><span>|</span><label class="collapse" for="c-39213433">[-]</label><label class="expand" for="c-39213433">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Please don’t email me to argue that map iteration order is random. It’s not.<p>He definitely knows about this, but more clearly: there is no specified behavior about the map iteration order with a clarification that it can vary for each iteration of the same map, but the <i>intent</i> is that it is explicitly going to be unpredictable [1] and the main Go implementation always behaved like that since 1.0, so such argument is not exactly wrong. (I don&#x27;t know whether this distinction is intentional. Most likely a simple oversight.)<p>[1] <a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;go1#iteration" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;go1#iteration</a></div><br/></div></div></div></div></div></div></div></body></html>