<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716800484453" as="style"/><link rel="stylesheet" href="styles.css?v=1716800484453"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://compcert.org/compcert-C.html">The CompCert C Compiler</a> <span class="domain">(<a href="https://compcert.org">compcert.org</a>)</span></div><div class="subtext"><span>nequo</span> | <span>129 comments</span></div><br/><div><div id="40484853" class="c"><input type="checkbox" id="c-40484853" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40486105">next</a><span>|</span><label class="collapse" for="c-40484853">[-]</label><label class="expand" for="c-40484853">[111 more]</label></div><br/><div class="children"><div class="content">I have never understood why the C community does not rally around what seems to me to be the obvious answer to the main problem with C: stop conflating pointers and arrays, or at least deprecate it.  Make arrays a separate data type, not a synonym for a pointer, and require the system to track the size of arrays either at compile time or at run time (or both).  Make a[x] be a bounds-checked array reference rather than a synonym for an unchecked dereference of a+x.  It seems stupidly obvious to me that this is the Right Thing.  Yes, it would be a non-backwards-compatible change, but the benefits seem to me to vastly outweigh the costs.</div><br/><div id="40484894" class="c"><input type="checkbox" id="c-40484894" checked=""/><div class="controls bullet"><span class="by">elteto</span><span>|</span><a href="#40484853">parent</a><span>|</span><a href="#40485995">next</a><span>|</span><label class="collapse" for="c-40484894">[-]</label><label class="expand" for="c-40484894">[68 more]</label></div><br/><div class="children"><div class="content">Because you can&#x27;t do that and still call the resulting language C. It would be a different language incompatible will _all_ existing C code.<p>Pointer decay is a fundamental mechanic in C. If you use arrays in C, and you pass said arrays as an argument to a function, then you are dealing with pointer decay.</div><br/><div id="40487662" class="c"><input type="checkbox" id="c-40487662" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40484894">parent</a><span>|</span><a href="#40485575">next</a><span>|</span><label class="collapse" for="c-40487662">[-]</label><label class="expand" for="c-40487662">[7 more]</label></div><br/><div class="children"><div class="content">OK, don&#x27;t call it C, call it C[*].<p>It will accept any existing C program unmodified.<p>With a per-file switch, say, #define __FEATURE_WEAK_ARRAYS, it will start to discriminate T* and T[], make it an error to mix them in assignments, or to pass one instead of the other if both the function definition and the function call are in files with this feature on. It will not complain about functions defined elsewhere.<p>Then, say, #define __FEATURE_STRICT_ARRAYS the compiler will complain about mixing arrays and pointers as function arguments, no matter where the function is defined. It would require updated stdlib headers, for instance.<p>Additionally, #define __FEATURE_MULTI_ARRAYS would enable syntax for fixed-size multidimensional arrays, Fortran-style. Now uint8[3][2][10] foo; would allocate 60 elements, and access to foo[1][2][3] would involve one memory dereference, not three.<p>More support would be needed: sizeof, support for slices, safe array copies and length checks. Nothing extraordinary.<p>Having this implemented would make a terrific master&#x27;s degree work.</div><br/><div id="40488537" class="c"><input type="checkbox" id="c-40488537" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40487662">parent</a><span>|</span><a href="#40487814">next</a><span>|</span><label class="collapse" for="c-40488537">[-]</label><label class="expand" for="c-40488537">[1 more]</label></div><br/><div class="children"><div class="content">There are a million little places in existing codebases where you start with an array, and then you work with pointers to elements inside the array. So it may be a lot of work to retrofit some of your existing code. If you are not retrofitting enough of your existing code, then you’d be serving greenfield projects—and greenfield projects can use Rust or something.<p>There are also probably a ton of edge cases you haven’t thought about yet. For one thing, your T[] would be a different beast depending on where it appears—if you declare a variable in a block as T[], it’s an array, but it sounds like your proposal has different semantics for T[] in function parameters—it’s a reference type.<p><pre><code>    void f(int x[]) {
      int y[] = {1, 2, 3};
      y = x; &#x2F;&#x2F; is this allowed?
    }
</code></pre>
I’m not trying to fight over the specifics of your proposal. I just want to illustrate that the language design is a tapestry, and you’re pulling at one of the threads.<p>There are a few proposals I see like this that circle around. This is not the first array improvement proposal I’ve seen for C. There are also lambdas &#x2F; closures, which are surprisingly untenable in C when you really dive into it. There’s sum types &#x2F; discriminated unions in Go, and higher-kinded types in Rust. For each of these features, you can find languages which <i>already have these features</i>, giving you all sorts of templates for how to build it, and yet it’s still such a pain in the ass to add these features to the languages which lack them.</div><br/></div></div><div id="40487814" class="c"><input type="checkbox" id="c-40487814" checked=""/><div class="controls bullet"><span class="by">pklausler</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40487662">parent</a><span>|</span><a href="#40488537">prev</a><span>|</span><a href="#40487823">next</a><span>|</span><label class="collapse" for="c-40487814">[-]</label><label class="expand" for="c-40487814">[3 more]</label></div><br/><div class="children"><div class="content">Why do you think that foo[1][2][3] requires more than one memory reference?</div><br/><div id="40488590" class="c"><input type="checkbox" id="c-40488590" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40487814">parent</a><span>|</span><a href="#40487823">next</a><span>|</span><label class="collapse" for="c-40488590">[-]</label><label class="expand" for="c-40488590">[2 more]</label></div><br/><div class="children"><div class="content">AFAIK in regular C a T[][][] foo would be a the same as T ** foo, so it gets implemented as a pointer to an array of pointers to arrays of pointers, each pointing to contiguous allocations of multiple Ts, each not necessarily near the other. So you need three dereferences to get to an element.<p><pre><code>  T value = foo[1][2][3];  &#x2F;&#x2F; becomes:
  foo -&gt;  (T **)
          (T **) -&gt; (T *)
          (T **)    (T *)
          ...       (T *) -&gt; (T)
                    (T *)    (T)
                    ...      (T)
                             (T) &lt;-- This one!
</code></pre>
This allows for jagged arrays, yay! So useful.<p>This is in stark contrast to a Fortran-style array, which is allocated as one contiguous piece, all dimensions folded up for linear access with one dereference.</div><br/></div></div></div></div><div id="40487823" class="c"><input type="checkbox" id="c-40487823" checked=""/><div class="controls bullet"><span class="by">KerrAvon</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40487662">parent</a><span>|</span><a href="#40487814">prev</a><span>|</span><a href="#40485575">next</a><span>|</span><label class="collapse" for="c-40487823">[-]</label><label class="expand" for="c-40487823">[2 more]</label></div><br/><div class="children"><div class="content">It’s more complex than that in practice. You need to support variable length arrays, which means you need to pass length information with the pointer, which doubles the size of array arguments. And that has ripple effects; you can’t do that indiscriminately without memory bloat and severe runtime impact, so you need to annotate argument. And you don’t have complete memory safety. And it takes a lot of manual programmer effort to get there.<p>This has been studied for decades; there have been many attempts to build a safer version of C. And eventually the C standard committee will have to decide on an approach or lose out to newer languages at an increasingly accelerated rate.</div><br/><div id="40488683" class="c"><input type="checkbox" id="c-40488683" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40487823">parent</a><span>|</span><a href="#40485575">next</a><span>|</span><label class="collapse" for="c-40488683">[-]</label><label class="expand" for="c-40488683">[1 more]</label></div><br/><div class="children"><div class="content">The fun part here is that most allocators <i>already</i> keep the size of the chunk within the header of the chunk, before the pointer they return to the caller of malloc(3). (Yes, jemalloc does not, it keeps the size info in a different way.) BTW I mentioned this as a master&#x27;s graduation project, not a realistic way forward, because, well, it&#x27;s not needed.<p>I&#x27;d say that C will lose relevance slowly, more and more, as much as Zig will gain relevance, hopefully to the point of becoming the default choice, and having key parts of Linux kernel ported to it. Not Rust, which mostly replaces C++; even though it can venture on the C territory, its not comfortable nor seamless there. Zig is so seamless, it can even compile your C code along the way. It can do gnarly stuff like handling memory-mapped control registers with relative ease, and with much fewer footguns than C.<p>C is old, and its age shows. It needs to gradually retire, the way Fortran-77 did.</div><br/></div></div></div></div></div></div><div id="40485575" class="c"><input type="checkbox" id="c-40485575" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40484894">parent</a><span>|</span><a href="#40487662">prev</a><span>|</span><a href="#40484983">next</a><span>|</span><label class="collapse" for="c-40485575">[-]</label><label class="expand" for="c-40485575">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know how much C code actually uses it tbh.<p>Most things just take a pointer.<p>Wouldn&#x27;t be easy by any means but it could be done at the scale of the Linux kernel if anyone cared enough.</div><br/><div id="40486239" class="c"><input type="checkbox" id="c-40486239" checked=""/><div class="controls bullet"><span class="by">elteto</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485575">parent</a><span>|</span><a href="#40487576">next</a><span>|</span><label class="collapse" for="c-40486239">[-]</label><label class="expand" for="c-40486239">[2 more]</label></div><br/><div class="children"><div class="content">If you use arrays in C you are using pointers and pointer decay. There’s not a lot of useful C code that doesn’t use arrays.</div><br/><div id="40486343" class="c"><input type="checkbox" id="c-40486343" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40486239">parent</a><span>|</span><a href="#40487576">next</a><span>|</span><label class="collapse" for="c-40486343">[-]</label><label class="expand" for="c-40486343">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true but this is mostly the easy case where things decay in relatively trivial fashion as opposed to the &quot;they&#x27;re different but actually the same&quot; aspect which is genuinely a bitch of change.</div><br/></div></div></div></div><div id="40487576" class="c"><input type="checkbox" id="c-40487576" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485575">parent</a><span>|</span><a href="#40486239">prev</a><span>|</span><a href="#40486672">next</a><span>|</span><label class="collapse" for="c-40487576">[-]</label><label class="expand" for="c-40487576">[1 more]</label></div><br/><div class="children"><div class="content">The Linux kernel already uses not standard C, but a dialect of C defined by the GCC flags they use.<p>But if you are willing to use something-like-C-but-not-shackled-by-backwards-compatibility, then why stop at arrays and pointers?  Just move all the way to D or Zig (or even Rust).  These are all languages designed (partially) so that you can port an existing C system bit-by-bit over into them.<p>Many people who can afford that, are doing that, of course.  And that&#x27;s why you don&#x27;t really hear much about backwards incompatible developments for C.  What would be the point?</div><br/></div></div><div id="40486672" class="c"><input type="checkbox" id="c-40486672" checked=""/><div class="controls bullet"><span class="by">LeFantome</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485575">parent</a><span>|</span><a href="#40487576">prev</a><span>|</span><a href="#40484983">next</a><span>|</span><label class="collapse" for="c-40486672">[-]</label><label class="expand" for="c-40486672">[1 more]</label></div><br/><div class="children"><div class="content">I think that is part of his point. Most functions take a pointer, even if they are expecting an array.</div><br/></div></div></div></div><div id="40484983" class="c"><input type="checkbox" id="c-40484983" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40484894">parent</a><span>|</span><a href="#40485575">prev</a><span>|</span><a href="#40485995">next</a><span>|</span><label class="collapse" for="c-40484983">[-]</label><label class="expand" for="c-40484983">[55 more]</label></div><br/><div class="children"><div class="content">&gt; Because you can&#x27;t do that and still call the resulting language C.<p>Says who?  Non-backwards-compatible changes are made to language standards all the time.  It&#x27;s not pain-free, but neither is the status quo.<p>Besides, who cares what the language is called?  Change the name if that&#x27;s what it takes, but stop conflating pointers and arrays.  The cost of that has been literally billions of dollars in losses due to buffer overflows over the decades.</div><br/><div id="40485345" class="c"><input type="checkbox" id="c-40485345" checked=""/><div class="controls bullet"><span class="by">colonwqbang</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40484983">parent</a><span>|</span><a href="#40485197">next</a><span>|</span><label class="collapse" for="c-40485345">[-]</label><label class="expand" for="c-40485345">[48 more]</label></div><br/><div class="children"><div class="content">There are many good &quot;better C&quot; alternatives already. Rust, zig, D. They address other common types of bug like resource leaks, overflows, use after free. If you&#x27;re ok with rewriting code, you have terrific options.<p>And of course there is C++, the most famous attempt to fix C in a somewhat compatible way by adding more features. It is debatable whether this effort resulted in a better language. C++ has all the bits needed to check array bounds by default but chooses not to do so...<p>The problem is that the huge existing stock of C code is written in C and not rust, zig, D, etc. The same would be true for your proposed &quot;better C&quot; language and any other incompatible iteration of C.<p>If you can come up with a way to add these guarantees to C without needing significant rewriting, I can assure you that most C programmers would be very interested.</div><br/><div id="40485427" class="c"><input type="checkbox" id="c-40485427" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485345">parent</a><span>|</span><a href="#40487783">next</a><span>|</span><label class="collapse" for="c-40485427">[-]</label><label class="expand" for="c-40485427">[31 more]</label></div><br/><div class="children"><div class="content">&gt; There are many good &quot;better C&quot; alternatives already. Rust, zig, D.<p>All of these are very different from C.  What I&#x27;m proposing is just one small change to the existing C language.<p>&gt; If you can come up with a way to add these guarantees to C without needing significant rewriting, I can assure you that most C programmers would be very interested.<p>I can pretty much guarantee that they would not because this is easy: phase in the changes.  Start by turning array-pointer conflation into a mandatory warning rather than undefined behavior or whatever it is now.  Then wait a few years.  Then turn it into an error that you can muffle using -C2024 or whatever.<p>I actually don&#x27;t know whether array-pointer conflation is required by the standard or if it&#x27;s undefined behavior (I&#x27;m pretty sure it&#x27;s one or the other).  But if it&#x27;s the latter then you don&#x27;t actually have to change the standard to make this happen, all you need to do is write a compiler that does the Right Thing.  AFAIK no such compiler exists.  But there is just no excuse for this:<p><pre><code>    % gcc -v
    Apple clang version 14.0.0 (clang-1400.0.29.202)
    ...
    % more test.c
    int main () {
      int x[10];
      return *(x+20);
    }
    % gcc -Wall test.c
    %</code></pre></div><br/><div id="40485484" class="c"><input type="checkbox" id="c-40485484" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485427">parent</a><span>|</span><a href="#40488280">next</a><span>|</span><label class="collapse" for="c-40485484">[-]</label><label class="expand" for="c-40485484">[10 more]</label></div><br/><div class="children"><div class="content">There are more than one billion lines of C code which hasn&#x27;t been updated in the last decade and is still in use.<p>Who is going to update these code once the &quot;do the right thing&quot;-compiler become available?<p>Oh, and the worst part: some of them may already be bug-free due to 15 years (if not more) of people trying to make money by selling exploits to surveillance vendors or who knows. But there&#x27;s certainly high-impact bugs left. Now what, refactor the code to use the fancy eliminate-spatial-memory-corruption C variant and introduce a few UAF by the way?</div><br/><div id="40485510" class="c"><input type="checkbox" id="c-40485510" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485484">parent</a><span>|</span><a href="#40488280">next</a><span>|</span><label class="collapse" for="c-40485510">[-]</label><label class="expand" for="c-40485510">[9 more]</label></div><br/><div class="children"><div class="content">The authors and maintainers of that code.  Any error or warning flagged by this change is something that really ought to be changed anyway because any unchecked array or pointer dereference is a potential security risk.</div><br/><div id="40487918" class="c"><input type="checkbox" id="c-40487918" checked=""/><div class="controls bullet"><span class="by">112233</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485510">parent</a><span>|</span><a href="#40485603">next</a><span>|</span><label class="collapse" for="c-40487918">[-]</label><label class="expand" for="c-40487918">[1 more]</label></div><br/><div class="children"><div class="content">&gt; any unchecked array or pointer dereference is a potential security risk.<p>I take exception to this. Of course if I write once-test never, copying from google results and trying to hit jira metrics, then any safety feature in the language will filter out some of the toxic waste code I am producing.<p>If secure code is designed and engineered, like any other secure technical system would, the language used does not matter so much, but, unsurprisingly, needs to be easy to reason about formally.</div><br/></div></div><div id="40485603" class="c"><input type="checkbox" id="c-40485603" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485510">parent</a><span>|</span><a href="#40487918">prev</a><span>|</span><a href="#40488280">next</a><span>|</span><label class="collapse" for="c-40485603">[-]</label><label class="expand" for="c-40485603">[7 more]</label></div><br/><div class="children"><div class="content">Have you read the source code of Xpdf (the thing being exploited in the famous NSO Apple iMessage 0-click blah blah)?<p>I did (because I wrote an exploit for the bug after the Google blogpost, for curiosity), the code looks disgusting. The author (one poor guy) does not have the code in an online VCS and instead dump a source tarball every few months (or years). The upstream vulnerable code was fixed months after news outbreak.<p>My conclusion is if Apple had a choice it won&#x27;t end up in iOS at all. Clearly, Apple already paid a lot of maintaining cost in this case (fixing bugs before upstream did), but what you asked for is a whole new level.</div><br/><div id="40486101" class="c"><input type="checkbox" id="c-40486101" checked=""/><div class="controls bullet"><span class="by">VogonPoetry</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485603">parent</a><span>|</span><a href="#40485849">next</a><span>|</span><label class="collapse" for="c-40486101">[-]</label><label class="expand" for="c-40486101">[2 more]</label></div><br/><div class="children"><div class="content">I think you conflating bugs. Apple doesn&#x27;t use Xpdf as the basis of the PDF Framework. The NSO bug exploited a bug in the JBIG2 file format. The same implementation of this code was included in both Xpdf and the Apple PDF code. That is why Xpdf needed to also fix the same code.</div><br/><div id="40487904" class="c"><input type="checkbox" id="c-40487904" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40486101">parent</a><span>|</span><a href="#40485849">next</a><span>|</span><label class="collapse" for="c-40487904">[-]</label><label class="expand" for="c-40487904">[1 more]</label></div><br/><div class="children"><div class="content">Of course I mean the fact they use the JBIG2 part of Xpdf. You don&#x27;t have to use Xpdf for processing PDF in order to use these `class JBIG2*` and you don&#x27;t even need to patch it.</div><br/></div></div></div></div><div id="40485849" class="c"><input type="checkbox" id="c-40485849" checked=""/><div class="controls bullet"><span class="by">LukeShu</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485603">parent</a><span>|</span><a href="#40486101">prev</a><span>|</span><a href="#40488280">next</a><span>|</span><label class="collapse" for="c-40485849">[-]</label><label class="expand" for="c-40485849">[4 more]</label></div><br/><div class="children"><div class="content">There is a well-maintained in-VCS less-disgusting version of Xpdf. It&#x27;s called Poppler, and Apple chooses to not use it.</div><br/><div id="40486207" class="c"><input type="checkbox" id="c-40486207" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485849">parent</a><span>|</span><a href="#40486089">prev</a><span>|</span><a href="#40488280">next</a><span>|</span><label class="collapse" for="c-40486207">[-]</label><label class="expand" for="c-40486207">[2 more]</label></div><br/><div class="children"><div class="content">Popper is GPL licensed, so Apple cannot use it.<p>(If you&#x27;re going to say &quot;but they could use it if they relicensed all of iOS as GPL&quot;: don&#x27;t be daft.)</div><br/><div id="40488867" class="c"><input type="checkbox" id="c-40488867" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40486207">parent</a><span>|</span><a href="#40488280">next</a><span>|</span><label class="collapse" for="c-40488867">[-]</label><label class="expand" for="c-40488867">[1 more]</label></div><br/><div class="children"><div class="content">I guess that is Apple&#x27;s problem</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40488280" class="c"><input type="checkbox" id="c-40488280" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485427">parent</a><span>|</span><a href="#40485484">prev</a><span>|</span><a href="#40485518">next</a><span>|</span><label class="collapse" for="c-40488280">[-]</label><label class="expand" for="c-40488280">[2 more]</label></div><br/><div class="children"><div class="content">&gt; All of these are very different from C.<p>With the changes you have in mind, that new &quot;C+&quot; would be much closer to Zig than C. For a backward compatible bounds-checking proposal see: <a href="https:&#x2F;&#x2F;discourse.llvm.org&#x2F;t&#x2F;rfc-enforcing-bounds-safety-in-c-fbounds-safety&#x2F;70854" rel="nofollow">https:&#x2F;&#x2F;discourse.llvm.org&#x2F;t&#x2F;rfc-enforcing-bounds-safety-in-...</a><p>This basically just associates a pointer and a length via new (and optional) annotations.</div><br/><div id="40488395" class="c"><input type="checkbox" id="c-40488395" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40488280">parent</a><span>|</span><a href="#40485518">next</a><span>|</span><label class="collapse" for="c-40488395">[-]</label><label class="expand" for="c-40488395">[1 more]</label></div><br/><div class="children"><div class="content">That is what Microsoft is already doing since the Windows XP SP2 security task force, Apple came a bit late into the game.<p>The<p><pre><code>    void foo(int *__counted_by(N) ptr, size_t N);
</code></pre>
with SAL<p><pre><code>    void foo(_In_reads_bytes_(N) int *ptr, size_t N);
</code></pre>
<a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;code-quality&#x2F;understanding-sal?view=msvc-170" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;code-quality&#x2F;understan...</a><p>But given how much long time ago XP SP 2 was, and how many people actually use them, unless forced at their job, that is quite telling how much people care.</div><br/></div></div></div></div><div id="40485518" class="c"><input type="checkbox" id="c-40485518" checked=""/><div class="controls bullet"><span class="by">retrac</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485427">parent</a><span>|</span><a href="#40488280">prev</a><span>|</span><a href="#40485892">next</a><span>|</span><label class="collapse" for="c-40485518">[-]</label><label class="expand" for="c-40485518">[15 more]</label></div><br/><div class="children"><div class="content">In assembly, arrays and structs reduce to base address, plus offset times scaling factor.  C provides a thin veneer over that.  Scaling derived from size of type.  Offset is the array index. The basic programming model of C is to view memory as an array.</div><br/><div id="40487585" class="c"><input type="checkbox" id="c-40487585" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485518">parent</a><span>|</span><a href="#40485618">next</a><span>|</span><label class="collapse" for="c-40487585">[-]</label><label class="expand" for="c-40487585">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s tempting to view C as a thin veneer over assembly.<p>Alas going there ignores all the nice undefined behaviour landmines the standard has buried for you.</div><br/></div></div><div id="40485618" class="c"><input type="checkbox" id="c-40485618" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485518">parent</a><span>|</span><a href="#40487585">prev</a><span>|</span><a href="#40485892">next</a><span>|</span><label class="collapse" for="c-40485618">[-]</label><label class="expand" for="c-40485618">[13 more]</label></div><br/><div class="children"><div class="content">Yes, I understand that.  But the topic at hand is a compiler whose &quot;intended use is the compilation of life-critical and mission-critical software written in C&quot;.  The idea of using C in life-critical and mission-critical software is risible as long as the language definition requires it to have gaping security holes, especially when the single biggest contributor to this problem is fairly easy to fix, at least from a technological point of view if not a political and sociological one.</div><br/><div id="40488277" class="c"><input type="checkbox" id="c-40488277" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485618">parent</a><span>|</span><a href="#40485758">next</a><span>|</span><label class="collapse" for="c-40488277">[-]</label><label class="expand" for="c-40488277">[5 more]</label></div><br/><div class="children"><div class="content">&gt;  The idea of using C in life-critical and mission-critical software is risible as long as the language definition requires it to have gaping security holes,<p>And yet, even though C has been the primary language for safety and life-critical software for decades, with billions of lines of code written to control things where failure results in loss of human life, there has been no significant loss of human life due to the C language.<p>Throughout the 80s, 90s, 2000s and 2010s C has been the primary language used to control industrial machinery that would kill people on software failure, munitions that would kill people on software failure[1], vehicles that would kill people on software failure, medical devices that would kill people on failure ... and out of these billions of deployments, with billions of lines of code, offhand I can think of only <i>one</i> instance where a different language would have prevented 3 deaths.<p>I&#x27;m not saying that C is safe, but it is clear from the statistics that the danger is <i>very very highly</i> overrated. There is a much greater danger in <i>rewriting battle-tested systems</i> just for the sake of rewriting.<p>[1] An industry I worked in, btw.</div><br/><div id="40488404" class="c"><input type="checkbox" id="c-40488404" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40488277">parent</a><span>|</span><a href="#40488900">next</a><span>|</span><label class="collapse" for="c-40488404">[-]</label><label class="expand" for="c-40488404">[3 more]</label></div><br/><div class="children"><div class="content">So you are well aware that isn&#x27;t regular C that gets written, rather something that most HN readers would run away from if forced to write such kind of C.</div><br/><div id="40488691" class="c"><input type="checkbox" id="c-40488691" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40488404">parent</a><span>|</span><a href="#40488900">next</a><span>|</span><label class="collapse" for="c-40488691">[-]</label><label class="expand" for="c-40488691">[2 more]</label></div><br/><div class="children"><div class="content">&gt; So you are well aware that isn&#x27;t regular C that gets written, rather something that most HN readers would run away from if forced to write such kind of C.<p>I&#x27;m not sure what your point is.<p>It isn&#x27;t always standard C, if that&#x27;s what you&#x27;re trying to say.<p>It&#x27;s usually not a hosted implementation, but sometimes it is. It&#x27;s usually done within industry regulated guidelines, but not always.<p>The fact is, the &quot;not always&quot; bit matters, because the body of C code controlling actions where human lives matter is so large that <i>there is still a substantial body of standards-compliant C code that doesn&#x27;t kill people!</i><p>The claim being made is contrary to the large body of evidence that we have.</div><br/><div id="40488759" class="c"><input type="checkbox" id="c-40488759" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40488691">parent</a><span>|</span><a href="#40488900">next</a><span>|</span><label class="collapse" for="c-40488759">[-]</label><label class="expand" for="c-40488759">[1 more]</label></div><br/><div class="children"><div class="content">My point is MISRA, AUTOSAR, DO-178C and plenty of other ones, alongside the industry moving on into hardware memory tagging as the only means to fix C for such kind of security critical systems, short of using something else if possible as suggested by upcoming cybersecurity laws.</div><br/></div></div></div></div></div></div><div id="40488900" class="c"><input type="checkbox" id="c-40488900" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40488277">parent</a><span>|</span><a href="#40488404">prev</a><span>|</span><a href="#40485758">next</a><span>|</span><label class="collapse" for="c-40488900">[-]</label><label class="expand" for="c-40488900">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m not saying that C is safe, but it is clear from the statistics that the danger is very very highly overrated. There is a much greater danger in rewriting battle-tested systems just for the sake of rewriting.<p>From 80-&gt;90-&gt;00-&gt;10-&gt;20s reading and writing C seems less and less magical, including for exploit writers. In 10 years exploits might even be written willy-nilly by an LLM. One of the reasons why writing safe and secure code requires thinking few steps into the future.</div><br/></div></div></div></div><div id="40485758" class="c"><input type="checkbox" id="c-40485758" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485618">parent</a><span>|</span><a href="#40488277">prev</a><span>|</span><a href="#40485892">next</a><span>|</span><label class="collapse" for="c-40485758">[-]</label><label class="expand" for="c-40485758">[7 more]</label></div><br/><div class="children"><div class="content">My understanding is that the primary purpose of CompCert is to make formally verified code that is extracted into C also get compiled by a compiler that is formally verified to preserve the intended semantics.<p>So CompCert seems to me to aim to help mission-critical software to <i>move away</i> from C, and possibly into Coq&#x2F;Isabelle&#x2F;etc., except for the purposes of compilation to machine code.</div><br/><div id="40485870" class="c"><input type="checkbox" id="c-40485870" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485758">parent</a><span>|</span><a href="#40485892">next</a><span>|</span><label class="collapse" for="c-40485870">[-]</label><label class="expand" for="c-40485870">[6 more]</label></div><br/><div class="children"><div class="content">That is a noble goal, but I don&#x27;t see how it can possibly achieve the intended result as long as the C standard is a fundamentally borken as it is.<p>I tried to download CompCert so I could try it out, but they only have a source distribution and to build it you need Coq and OCaml and a few other things because <i>of course</i> CompCert is not written in C.  No one in their right mind would write mission-critical software in C.</div><br/><div id="40487175" class="c"><input type="checkbox" id="c-40487175" checked=""/><div class="controls bullet"><span class="by">seabird</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485870">parent</a><span>|</span><a href="#40487448">next</a><span>|</span><label class="collapse" for="c-40487175">[-]</label><label class="expand" for="c-40487175">[1 more]</label></div><br/><div class="children"><div class="content">If your original source is provably transpilable to C with no UB, and your compiler provably compiles that C without any bungling, then you&#x27;ve made it. The standard is bad and I want to see the end of C before I&#x27;m dead, but this isn&#x27;t a stretch, and C is just a detail in the process.</div><br/></div></div><div id="40487448" class="c"><input type="checkbox" id="c-40487448" checked=""/><div class="controls bullet"><span class="by">LeFantome</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485870">parent</a><span>|</span><a href="#40487175">prev</a><span>|</span><a href="#40488287">next</a><span>|</span><label class="collapse" for="c-40487448">[-]</label><label class="expand" for="c-40487448">[3 more]</label></div><br/><div class="children"><div class="content">I am mostly in the other side of this argument. C is an insane language in my view ( in a modern context ).<p>That said, what “mission critical software” are you using that is not running on an OS written in C?</div><br/><div id="40488820" class="c"><input type="checkbox" id="c-40488820" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40487448">parent</a><span>|</span><a href="#40487616">next</a><span>|</span><label class="collapse" for="c-40488820">[-]</label><label class="expand" for="c-40488820">[1 more]</label></div><br/><div class="children"><div class="content">Historical reasons, my Windows, Android, macOS, iOS devices have plenty of OS code written in C++.<p>Even those criticial OSes that refuse to move beyond C, most likely are using C compilers written in C++.</div><br/></div></div><div id="40487616" class="c"><input type="checkbox" id="c-40487616" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40487448">parent</a><span>|</span><a href="#40488820">prev</a><span>|</span><a href="#40488287">next</a><span>|</span><label class="collapse" for="c-40487616">[-]</label><label class="expand" for="c-40487616">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; No one in their right mind would write mission-critical software in C.<p>&gt; That said, what “mission critical software” are you using that is not running on an OS written in C?<p>I&#x27;m not sure that&#x27;s relevant?<p>If you have a piece of mission critical software, almost all the time you run it on an existing OS like Windows or Linux.  You don&#x27;t _write_ a new OS just for your one piece of software.<p>Of course, that OS had to be written at some point in the past (and is still being worked on).  Presumably that writing was (and is) being done by people not &#x27;in their right mind&#x27;.  But that shouldn&#x27;t concern you.<p>The problem with C is not that you can&#x27;t write secure-ish software at all; the problem is that this is insanely difficult, and that the trade-offs aren&#x27;t worth it.  Especially for new software.<p>For software that I get from some third-party, like the OS, I only care about its quality (and price); I don&#x27;t care about the trade-offs and pains the authors had to endure.  If they want to use C in the privacy of their own bedroom, that&#x27;s up to them.<p>Of course, Linux in 2024 is written in C, mostly because Linux in 2023 was written in C, then 2022, etc all the way back to the 1990s.  There&#x27;s a lot of path dependence.  Back in the 1990s C was a more reasonable choice to write your new OS in.  Especially if it was a clone of Unix, C&#x27;s original home and killer app.</div><br/></div></div></div></div><div id="40488287" class="c"><input type="checkbox" id="c-40488287" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485870">parent</a><span>|</span><a href="#40487448">prev</a><span>|</span><a href="#40485892">next</a><span>|</span><label class="collapse" for="c-40488287">[-]</label><label class="expand" for="c-40488287">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  No one in their right mind would write mission-critical software in C.<p>Read my previous response to you[1]: you clearly haven&#x27;t worked on systems that would kill people if things went wrong.<p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40488277">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40488277</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="40485892" class="c"><input type="checkbox" id="c-40485892" checked=""/><div class="controls bullet"><span class="by">pyrolistical</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485427">parent</a><span>|</span><a href="#40485518">prev</a><span>|</span><a href="#40487783">next</a><span>|</span><label class="collapse" for="c-40485892">[-]</label><label class="expand" for="c-40485892">[3 more]</label></div><br/><div class="children"><div class="content">You should take a closer look at zig. While superficially the syntax is very different, what zig really is, c but more specific</div><br/><div id="40485937" class="c"><input type="checkbox" id="c-40485937" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485892">parent</a><span>|</span><a href="#40487783">next</a><span>|</span><label class="collapse" for="c-40485937">[-]</label><label class="expand" for="c-40485937">[2 more]</label></div><br/><div class="children"><div class="content">No, I get that.  I was referring to the syntax.  Syntax matters.<p>Zig is hands-down a <i>better</i> language than C, and (I&#x27;ll take your word that) it fills the same niche as C, but it is still a <i>different</i> language with its own idioms and lore and conventions.  It is not C-with-tweaks.  It cannot be compiled by an extant C compiler.  Code written under my proposal would be legal C code under the current standard (but not the other way around).<p>[EDIT] Actually, that turns out not to be true.  You&#x27;d need to change the behavior of SIZEOF or provide some other way of getting the size of dynamically allocated arrays at run time, since this information would now be maintained by the compiler.</div><br/><div id="40488548" class="c"><input type="checkbox" id="c-40488548" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485937">parent</a><span>|</span><a href="#40487783">next</a><span>|</span><label class="collapse" for="c-40488548">[-]</label><label class="expand" for="c-40488548">[1 more]</label></div><br/><div class="children"><div class="content">Of course sizeof already has that capability since C has variable length arrays. They are kind of being phased out, but they are there.<p>You can do this:<p><pre><code>    #include &lt;stdio.h&gt;

    int main(int argc, char *argv[])  {
        unsigned int lens[argc];
        for (int i = 0; i &lt; argc; ++i)
            lens[i] = (int) strlen(argv[i]);
        printf(&quot;Computed %d lens into %zu bytes of array\n&quot;, argc, sizeof lens);
        return 0;
    }
</code></pre>
Very contrived pointless example, but still.</div><br/></div></div></div></div></div></div></div></div><div id="40487783" class="c"><input type="checkbox" id="c-40487783" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485345">parent</a><span>|</span><a href="#40485427">prev</a><span>|</span><a href="#40485479">next</a><span>|</span><label class="collapse" for="c-40487783">[-]</label><label class="expand" for="c-40487783">[4 more]</label></div><br/><div class="children"><div class="content">&gt; C++ has all the bits needed to check array bounds by default but chooses not to do so...<p>std::array::at does bound check.</div><br/><div id="40488033" class="c"><input type="checkbox" id="c-40488033" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40487783">parent</a><span>|</span><a href="#40485479">next</a><span>|</span><label class="collapse" for="c-40488033">[-]</label><label class="expand" for="c-40488033">[3 more]</label></div><br/><div class="children"><div class="content">Yes, but they&#x27;ve made the convenient lightweight syntax <i>not</i> bounds check. Defaults matter in languages. Other languages make you use an esoteric function e.g at_unsafe to skip bounds checking.</div><br/><div id="40488840" class="c"><input type="checkbox" id="c-40488840" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40488033">parent</a><span>|</span><a href="#40488248">next</a><span>|</span><label class="collapse" for="c-40488840">[-]</label><label class="expand" for="c-40488840">[1 more]</label></div><br/><div class="children"><div class="content">While a bummer, most C++ compilers do have a build flag to enable bounds check in operator[]().<p>Which most sane compilers will do for you in debug builds.</div><br/></div></div><div id="40488248" class="c"><input type="checkbox" id="c-40488248" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40488033">parent</a><span>|</span><a href="#40488840">prev</a><span>|</span><a href="#40485479">next</a><span>|</span><label class="collapse" for="c-40488248">[-]</label><label class="expand" for="c-40488248">[1 more]</label></div><br/><div class="children"><div class="content">its probably because per contract std::array has to behave exactly like C array for legacy ops. Also this is not zero cost abstraction, so programmer has a choice: ultimate performance or extra safety.</div><br/></div></div></div></div></div></div><div id="40485479" class="c"><input type="checkbox" id="c-40485479" checked=""/><div class="controls bullet"><span class="by">admax88qqq</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485345">parent</a><span>|</span><a href="#40487783">prev</a><span>|</span><a href="#40485197">next</a><span>|</span><label class="collapse" for="c-40485479">[-]</label><label class="expand" for="c-40485479">[12 more]</label></div><br/><div class="children"><div class="content">&gt; huge existing stock of C code<p>I feel like the amount of effort that has been spent so far to make C safe and fix bugs due to C not being safe is greater than the effort that would have been required to rewrite all existing C code into memory safe languages.<p>But I think secretly C programmers don&#x27;t want memory safety. Dealing with pointers and remembering to malloc and free are part of what makes them feel more skilled&#x2F;elite than those other programmers who have garbage collection and bounds checking.</div><br/><div id="40486257" class="c"><input type="checkbox" id="c-40486257" checked=""/><div class="controls bullet"><span class="by">optymizer</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485479">parent</a><span>|</span><a href="#40486755">next</a><span>|</span><label class="collapse" for="c-40486257">[-]</label><label class="expand" for="c-40486257">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not that I don&#x27;t want memory safety or that I feel superior - what I want is to write the fastest possible portable code. That&#x27;s what C does, and nothing more.<p>Memory management, array bounds checking and a bunch of other &#x27;safe&#x27; features have a price that I&#x27;m not willing to apply broadly and redudantly to all of my software.<p>I&#x27;m going for speed, that&#x27;s why I&#x27;m using a Ferrari. Corolla&#x27;s are fast and safe - use those, don&#x27;t lobby for Ferrari to add safety to their cars at the expense of speed.<p>There are hundreds of languages. Use those. Write transpilers for C code for software that shouldn&#x27;t have been written in C because it had to be safe. That would be a better use of your time.</div><br/><div id="40486391" class="c"><input type="checkbox" id="c-40486391" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40486257">parent</a><span>|</span><a href="#40486755">next</a><span>|</span><label class="collapse" for="c-40486391">[-]</label><label class="expand" for="c-40486391">[5 more]</label></div><br/><div class="children"><div class="content">But that&#x27;s <i>not</i> what C does, You&#x27;ve been, at best, misled.<p>What C does is assume that you&#x27;re willing to sacrifice correctness to make the compiler simpler which is quite different from what you described.<p>In practice this has a negative consequence for performance as well as safety.</div><br/><div id="40486542" class="c"><input type="checkbox" id="c-40486542" checked=""/><div class="controls bullet"><span class="by">optymizer</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40486391">parent</a><span>|</span><a href="#40486755">next</a><span>|</span><label class="collapse" for="c-40486542">[-]</label><label class="expand" for="c-40486542">[4 more]</label></div><br/><div class="children"><div class="content">Having written a compiler for a subset of the C99 standard, I&#x27;m going to disagree here.<p>Array bounds are not being checked on every array access not because it would make compilers too complex.<p>Correctness is being sacrificed mostly for speed or portability on future CPUs.<p>There are examples of language features that simplify compiler writing, however.<p>For example, type promotion from char to int is a feature that reduces the number of cases one would have to deal with when implementing the type system in a compiler, but it&#x27;s there because it doesn&#x27;t sacrifice neither performance nor portability.</div><br/><div id="40488854" class="c"><input type="checkbox" id="c-40488854" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40486542">parent</a><span>|</span><a href="#40487626">next</a><span>|</span><label class="collapse" for="c-40488854">[-]</label><label class="expand" for="c-40488854">[1 more]</label></div><br/><div class="children"><div class="content">Yet every other systems programming language never had any issues with enabling bounds checks, their only failure was not having a free beer OS to come along for the ride.</div><br/></div></div><div id="40487626" class="c"><input type="checkbox" id="c-40487626" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40486542">parent</a><span>|</span><a href="#40488854">prev</a><span>|</span><a href="#40486755">next</a><span>|</span><label class="collapse" for="c-40487626">[-]</label><label class="expand" for="c-40487626">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Array bounds are not being checked on every array access not because it would make compilers too complex.<p>That might be true, but you could still specify something slightly less exploit heavy than &#x27;undefined behaviour&#x27;.  Eg you could make out-of-bounds access into implementation defined behaviour.</div><br/><div id="40488896" class="c"><input type="checkbox" id="c-40488896" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40487626">parent</a><span>|</span><a href="#40486755">next</a><span>|</span><label class="collapse" for="c-40488896">[-]</label><label class="expand" for="c-40488896">[1 more]</label></div><br/><div class="children"><div class="content">There is no way to predict what will happen if your program is accessing random memory at runtime, especially if it&#x27;s a write access. To specify what would happen on a write to random memory would take books that basically lay out most of the internals of the compiler and also the host OS.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40486755" class="c"><input type="checkbox" id="c-40486755" checked=""/><div class="controls bullet"><span class="by">girvo</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485479">parent</a><span>|</span><a href="#40486257">prev</a><span>|</span><a href="#40485713">next</a><span>|</span><label class="collapse" for="c-40486755">[-]</label><label class="expand" for="c-40486755">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But I think secretly C programmers don&#x27;t want memory safety<p>Having just come out of embedded firmware land: it&#x27;s not secret, a few members of my team were pretty open about either not caring about or not wanting memory safety. But the added productivity that Nim gave us outweighed their complaints in the end</div><br/></div></div><div id="40485713" class="c"><input type="checkbox" id="c-40485713" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485479">parent</a><span>|</span><a href="#40486755">prev</a><span>|</span><a href="#40485197">next</a><span>|</span><label class="collapse" for="c-40485713">[-]</label><label class="expand" for="c-40485713">[4 more]</label></div><br/><div class="children"><div class="content">The problem here is people seldomly get paid rewriting existing C code into memory safe lamguages. While once in a while someone would be annoyed enough and pay for a fixing-C effort for a little.<p>Do you have suggestions on how to fix the incentive?</div><br/><div id="40485993" class="c"><input type="checkbox" id="c-40485993" checked=""/><div class="controls bullet"><span class="by">admax88qqq</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485713">parent</a><span>|</span><a href="#40485197">next</a><span>|</span><label class="collapse" for="c-40485993">[-]</label><label class="expand" for="c-40485993">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that&#x27;s the root problem. I think C programmers don&#x27;t believe C is a problem. New software is started every day on C.  There&#x27;s no excuse for that and no financial incentive to do it.<p>If the engineers actually admitted that C is not a safe languages for shipping software, then we could at the very least freeze the existing code and write everything _new_ in a same language.  But we don&#x27;t. Engineers still go starting brand new greenfield projects in C which is just insane.</div><br/><div id="40487948" class="c"><input type="checkbox" id="c-40487948" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485993">parent</a><span>|</span><a href="#40486273">next</a><span>|</span><label class="collapse" for="c-40487948">[-]</label><label class="expand" for="c-40487948">[1 more]</label></div><br/><div class="children"><div class="content">&gt; then we could at the very least freeze the existing code and write everything _new_ in a same language<p>Sure, if you are willing to help, here&#x27;s my wishlist:<p>- I wish we can freeze libssh and write everything new in Rust.<p>- I wish we can freeze CPython and write everything new in Rust.<p>- ...<p>Can you do it for free? At work I&#x27;m busy maintaining old projects in C++ and writing new ones in Rust. Since I&#x27;m not getting paid to rewrite or maintain our dependencies full-time I can&#x27;t do above. Oh, I&#x27;m not paid to initiate an effort to freeze our old projects either.<p>If this sounds too harsh:<p>- I wish we can freeze ZMK [1] and write everything new in Rust (or Zig, though it&#x27;s not memory safe, whatever).<p>That&#x27;s about one of my hobbies and I always wanted to do it.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;zmkfirmware&#x2F;zmk">https:&#x2F;&#x2F;github.com&#x2F;zmkfirmware&#x2F;zmk</a></div><br/></div></div><div id="40486273" class="c"><input type="checkbox" id="c-40486273" checked=""/><div class="controls bullet"><span class="by">optymizer</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485993">parent</a><span>|</span><a href="#40487948">prev</a><span>|</span><a href="#40485197">next</a><span>|</span><label class="collapse" for="c-40486273">[-]</label><label class="expand" for="c-40486273">[1 more]</label></div><br/><div class="children"><div class="content">Just because you don&#x27;t understand it, doesn&#x27;t mean it&#x27;s insane. It just means that your view of the world is different from others.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40485197" class="c"><input type="checkbox" id="c-40485197" checked=""/><div class="controls bullet"><span class="by">usrnm</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40484983">parent</a><span>|</span><a href="#40485345">prev</a><span>|</span><a href="#40485995">next</a><span>|</span><label class="collapse" for="c-40485197">[-]</label><label class="expand" for="c-40485197">[6 more]</label></div><br/><div class="children"><div class="content">&gt; The cost of that has been literally billions of dollars in losses due to buffer overflows over the decades.<p>How much, do you think, would rewriting all existing C code cost?</div><br/><div id="40485341" class="c"><input type="checkbox" id="c-40485341" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485197">parent</a><span>|</span><a href="#40485382">next</a><span>|</span><label class="collapse" for="c-40485341">[-]</label><label class="expand" for="c-40485341">[3 more]</label></div><br/><div class="children"><div class="content">Nothing, if new standards are opted in via a #pragma.</div><br/><div id="40487630" class="c"><input type="checkbox" id="c-40487630" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485341">parent</a><span>|</span><a href="#40485382">next</a><span>|</span><label class="collapse" for="c-40487630">[-]</label><label class="expand" for="c-40487630">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure that&#x27;s this easy, because of the copy-and-paste nature of C&#x27;s &quot;libraries&quot; via pre-processor #include directives.</div><br/><div id="40488224" class="c"><input type="checkbox" id="c-40488224" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40487630">parent</a><span>|</span><a href="#40485382">next</a><span>|</span><label class="collapse" for="c-40488224">[-]</label><label class="expand" for="c-40488224">[1 more]</label></div><br/><div class="children"><div class="content">Not really. We already have `#pragma once` which is per-file, not per-translation-unit.</div><br/></div></div></div></div></div></div><div id="40485382" class="c"><input type="checkbox" id="c-40485382" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485197">parent</a><span>|</span><a href="#40485341">prev</a><span>|</span><a href="#40485632">next</a><span>|</span><label class="collapse" for="c-40485382">[-]</label><label class="expand" for="c-40485382">[1 more]</label></div><br/><div class="children"><div class="content">Why do you think that would be necessary?</div><br/></div></div><div id="40485632" class="c"><input type="checkbox" id="c-40485632" checked=""/><div class="controls bullet"><span class="by">candiodari</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485197">parent</a><span>|</span><a href="#40485382">prev</a><span>|</span><a href="#40485995">next</a><span>|</span><label class="collapse" for="c-40485632">[-]</label><label class="expand" for="c-40485632">[1 more]</label></div><br/><div class="children"><div class="content">The whole reason C code is used is that it can be used for free. In other words, infinitely more than they&#x27;re spending now. More than even the CCP is willing to spend to protect state secrets.</div><br/></div></div></div></div></div></div></div></div><div id="40485995" class="c"><input type="checkbox" id="c-40485995" checked=""/><div class="controls bullet"><span class="by">lieks</span><span>|</span><a href="#40484853">parent</a><span>|</span><a href="#40484894">prev</a><span>|</span><a href="#40486017">next</a><span>|</span><label class="collapse" for="c-40485995">[-]</label><label class="expand" for="c-40485995">[3 more]</label></div><br/><div class="children"><div class="content">C99 did that.<p><pre><code>    void f(int len, char s[len]);
    void g(float m[static 16]);
</code></pre>
The first one is for variable-length arrays, the second one for fixed-length. TCC even implements array bounds-checking.<p>But because a lot of people were stuck using C89 for several decades (due to old compilers), and the syntax isn&#x27;t that great, nobody even knows they exist.<p>Personally, I think Dennis Ritchie&#x27;s[a] proposed syntax[b] was much better:<p><pre><code>    void f(char s[?]);
</code></pre>
[a] The creator of C.<p>[b] <a href="https:&#x2F;&#x2F;www.bell-labs.com&#x2F;usr&#x2F;dmr&#x2F;www&#x2F;vararray.html" rel="nofollow">https:&#x2F;&#x2F;www.bell-labs.com&#x2F;usr&#x2F;dmr&#x2F;www&#x2F;vararray.html</a></div><br/><div id="40487195" class="c"><input type="checkbox" id="c-40487195" checked=""/><div class="controls bullet"><span class="by">segfaultbuserr</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485995">parent</a><span>|</span><a href="#40488655">next</a><span>|</span><label class="collapse" for="c-40487195">[-]</label><label class="expand" for="c-40487195">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>and the syntax isn&#x27;t that great, nobody even knows they exist.</i><p>Linux kernel maintainers certainly do - they even invented a non-standard extension of C99&#x27;s VLA notation (their own invention, not implemented in GCC)... In newer versions of the package &quot;Linux man-pages&quot;, most libc functions are documented using a non-standard extension of that syntax. For example, the prototype of memcpy() now reads [0]:<p><pre><code>    void *memcpy(void dest[restrict .n], const void src[restrict .n], size_t n);
</code></pre>
It means this function accepts two arrays (dest[] and src[]), with n bytes of data type &quot;void&quot;, src[] is read-only (&quot;const&quot;), and both src[] and dest[] are non-overlapping (&quot;restrict&quot;). Two non-standard notations are used here: a &quot;void&quot; array with elements of unknown type (not allowed in C99), also, &quot;.n&quot; means &quot;a variable in the argument list, but defined <i>after</i> this variable&quot; (which is not allowed in C99).<p>The equivalent C99 definition would be something similar to:<p><pre><code>    void *memcpy(size_t n, char dest[restrict n], const char src[restrict n]);
</code></pre>
As more people are exposed to these man pages, the C99 syntax hopefully will have more publicity. Finally, C23 interestingly states that:<p>&gt; <i>15. Application Programming Interfaces (APIs) should be self-documenting when possible. In particular, the order of parameters in function declarations should be arranged such that the size of an array appears before the array. The purpose is to allow Variable-Length Array (VLA) notation to be used. This not only makes the code&#x27;s purpose clearer to human readers, but also makes static analysis easier. Any new APIs added to the Standard should take this into consideration.</i><p>[0] <a href="https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;docs&#x2F;man-pages&#x2F;man-pages.git&#x2F;commit&#x2F;man3&#x2F;memcpy.3?id=c64cd13e002561c6802c6a1a1a8a640f034fea70" rel="nofollow">https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;docs&#x2F;man-pages&#x2F;man-pages.git&#x2F;...</a><p>[1] <a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg14&#x2F;www&#x2F;docs&#x2F;n2611.htm" rel="nofollow">https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg14&#x2F;www&#x2F;docs&#x2F;n2611.htm</a></div><br/></div></div><div id="40488655" class="c"><input type="checkbox" id="c-40488655" checked=""/><div class="controls bullet"><span class="by">guenthert</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485995">parent</a><span>|</span><a href="#40487195">prev</a><span>|</span><a href="#40486017">next</a><span>|</span><label class="collapse" for="c-40488655">[-]</label><label class="expand" for="c-40488655">[1 more]</label></div><br/><div class="children"><div class="content">&gt; TCC even implements array bounds-checking.<p>Optionally (command line option &#x27;-b&#x27;) though and (somewhat perplexingly) only at run-time.  The documentation hints at the run-time performance (and code size) impact.</div><br/></div></div></div></div><div id="40486017" class="c"><input type="checkbox" id="c-40486017" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#40484853">parent</a><span>|</span><a href="#40485995">prev</a><span>|</span><a href="#40488166">next</a><span>|</span><label class="collapse" for="c-40486017">[-]</label><label class="expand" for="c-40486017">[2 more]</label></div><br/><div class="children"><div class="content">This article is 15 years old now, and nothing has changed:<p><a href="https:&#x2F;&#x2F;digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html" rel="nofollow">https:&#x2F;&#x2F;digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html</a><p>(and of course the problem wasn&#x27;t new 15 years ago either.)<p>It wasn&#x27;t fixed then. It won&#x27;t be fixed now.<p>C is valued for not changing. C is valued for backwards compatibility with the most obscure platforms with unmaintained compilers.<p>The C userbase is self-selected to like C exactly the way it is.</div><br/><div id="40488869" class="c"><input type="checkbox" id="c-40488869" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40486017">parent</a><span>|</span><a href="#40488166">next</a><span>|</span><label class="collapse" for="c-40488869">[-]</label><label class="expand" for="c-40488869">[1 more]</label></div><br/><div class="children"><div class="content">The irony is that C does change, we are at C23 now, but not in the ways that would actually improve its safety.</div><br/></div></div></div></div><div id="40488166" class="c"><input type="checkbox" id="c-40488166" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40484853">parent</a><span>|</span><a href="#40486017">prev</a><span>|</span><a href="#40485592">next</a><span>|</span><label class="collapse" for="c-40488166">[-]</label><label class="expand" for="c-40488166">[2 more]</label></div><br/><div class="children"><div class="content">Once you have &quot;proper&quot; arrays, you&#x27;ll also need &quot;array-references&quot; e.g. fat pointers carrying a length (aka slices), and if you want to avoid unsafe pointer&#x2F;array conversions you&#x27;ll also need a typed allocator function, and all of that also requires a new stdlib and probably an extended ABI, or at least a standard for how the new types are layed out in memory, and passed into and out of functions. At that point the whole thing is so different from C that we should give it a new name - maybe, I dunno &quot;Zig&quot;? ;)<p>PS: There was actually a quite recent bounds-checking proposal by (I think) Apple Clang folks that works with annotations and IMHO looks pretty good (in the sense of &quot;I would actually use it in my libraries&quot;):<p><a href="https:&#x2F;&#x2F;discourse.llvm.org&#x2F;t&#x2F;rfc-enforcing-bounds-safety-in-c-fbounds-safety&#x2F;70854" rel="nofollow">https:&#x2F;&#x2F;discourse.llvm.org&#x2F;t&#x2F;rfc-enforcing-bounds-safety-in-...</a></div><br/><div id="40488364" class="c"><input type="checkbox" id="c-40488364" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40488166">parent</a><span>|</span><a href="#40485592">next</a><span>|</span><label class="collapse" for="c-40488364">[-]</label><label class="expand" for="c-40488364">[1 more]</label></div><br/><div class="children"><div class="content">Yes and even Dennis Ritchie failed to have WG14 caring about them.<p>Not that his proposal was perfect, but WG14 didn&#x27;t even bothered to improve upon it.</div><br/></div></div></div></div><div id="40485592" class="c"><input type="checkbox" id="c-40485592" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#40484853">parent</a><span>|</span><a href="#40488166">prev</a><span>|</span><a href="#40488593">next</a><span>|</span><label class="collapse" for="c-40485592">[-]</label><label class="expand" for="c-40485592">[6 more]</label></div><br/><div class="children"><div class="content">For the people who actually care about using C, there can be no unified concept of &quot;array&quot;. Any single &quot;the system&quot; will just plain and simply be unusable in a good majority of situations.<p>Some people will want to store the size in a type smaller than size_t (and potentially place it not adjacent to the data pointer for better packing in a struct; or perhaps even bit-pack it). Some will want to place the size relative to the data instead of the pointer (esp. flexible array members). Some will want to store half (or a third, etc) of the element count, the array being used as multiple back-to-back arrays. Then you&#x27;ll have questions on pointers in the middle of an array, indexable by positive and negative indices. Never mind the pretty significantly increased register shuffling of having to pass the size across functions.<p>For projects that are fine with doing things in the single way forced upon you and don&#x27;t care about how things are done as long as it&#x27;s safe, C is already rather clearly not the language to choose.<p>C++ as-is can already pretty trivially allow adding bounds-checked array types, and compilers can even be configured to warn on all pointer indexing (<a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;W8sqGW5sh" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;W8sqGW5sh</a>), achieving the entirety of your proposal while not locking people into a single data structure. (granted, some may not want to expand to C++ &quot;just&quot; for one or two features (me included), but here allowing customizable array data structures is basically the only sane option, and C would have to take a rather significant amount from C++ to allow for such itself)</div><br/><div id="40485827" class="c"><input type="checkbox" id="c-40485827" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485592">parent</a><span>|</span><a href="#40488593">next</a><span>|</span><label class="collapse" for="c-40485827">[-]</label><label class="expand" for="c-40485827">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Some people will want to store the size in a type smaller than size_t<p>So?  My point here is that this should be the compiler&#x27;s responsibility, not the programmer&#x27;s.  Why could not a compiler bitpack the same way -- or even better than -- a programmer could?</div><br/><div id="40485878" class="c"><input type="checkbox" id="c-40485878" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485827">parent</a><span>|</span><a href="#40488593">next</a><span>|</span><label class="collapse" for="c-40485878">[-]</label><label class="expand" for="c-40485878">[4 more]</label></div><br/><div class="children"><div class="content">The compiler cannot change the length field&#x27;s size if a reference to the array (or a struct where it&#x27;s contained) is ever passed to an unknown function, as that function has to be able to read the length from memory based just on the spelled-out type.<p>Not a problem when passing the array by value (i.e. two registers of the data pointer and length), but then any packing automatically does not apply anyway.</div><br/><div id="40486003" class="c"><input type="checkbox" id="c-40486003" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485878">parent</a><span>|</span><a href="#40488593">next</a><span>|</span><label class="collapse" for="c-40486003">[-]</label><label class="expand" for="c-40486003">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand this.  Why does it matter if you&#x27;re calling an unknown function?  Why would an unknown function be unable to get the length?  All you would need to do is to change the behavior of SIZEOF to make it aware of dynamically allocated arrays.</div><br/><div id="40486064" class="c"><input type="checkbox" id="c-40486064" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40486003">parent</a><span>|</span><a href="#40486103">next</a><span>|</span><label class="collapse" for="c-40486064">[-]</label><label class="expand" for="c-40486064">[1 more]</label></div><br/><div class="children"><div class="content">I mean in the case of an array type that tracks its length at runtime. Take:<p><pre><code>    typedef struct {
      uint32_t arr1_len, arr2_len;
      int* arr1;
      int* arr2;
    } Foo;
</code></pre>
That&#x27;s, on a 64-bit system, a 24-byte structure. Were it written as a struct of two array fields, the compiler couldn&#x27;t choose a layout as efficient while maintaining being able to get a pointer to each field. Never mind that the compiler would likely not be omniscient enough to be able to tell that the structure is never used with arrays exceeding 2^32 elements.<p>Perhaps you mean to keep using regular pointers for non-trivial heap-stored things, but I&#x27;d imagine that makes up a pretty significant amount of cases with buffer overflow potential.</div><br/></div></div><div id="40486103" class="c"><input type="checkbox" id="c-40486103" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40486003">parent</a><span>|</span><a href="#40486064">prev</a><span>|</span><a href="#40488593">next</a><span>|</span><label class="collapse" for="c-40486103">[-]</label><label class="expand" for="c-40486103">[1 more]</label></div><br/><div class="children"><div class="content">Or add another sizeof keyword.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40488593" class="c"><input type="checkbox" id="c-40488593" checked=""/><div class="controls bullet"><span class="by">zik</span><span>|</span><a href="#40484853">parent</a><span>|</span><a href="#40485592">prev</a><span>|</span><a href="#40488760">next</a><span>|</span><label class="collapse" for="c-40488593">[-]</label><label class="expand" for="c-40488593">[1 more]</label></div><br/><div class="children"><div class="content">This has been done quite a few times before, but the resulting languages are not C.<p>Also saying that&#x27;s &quot;the main problem with C&quot; seems to miss the mark. As a C programmer I wouldn&#x27;t call this the crux of any particular problem. It&#x27;s weird and problematic in multiple ways but surely not &quot;the main problem&quot;.</div><br/></div></div><div id="40488760" class="c"><input type="checkbox" id="c-40488760" checked=""/><div class="controls bullet"><span class="by">MaxBarraclough</span><span>|</span><a href="#40484853">parent</a><span>|</span><a href="#40488593">prev</a><span>|</span><a href="#40485716">next</a><span>|</span><label class="collapse" for="c-40488760">[-]</label><label class="expand" for="c-40488760">[1 more]</label></div><br/><div class="children"><div class="content">See also Walter Bright&#x27;s 2009 article <i>C&#x27;s Biggest Mistake</i>, on this topic.<p><a href="https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html" rel="nofollow">https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html</a><p>Recent discussion: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40392371">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40392371</a><p>Discussion thread about the article, 10 months ago: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36564535">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36564535</a></div><br/></div></div><div id="40485716" class="c"><input type="checkbox" id="c-40485716" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#40484853">parent</a><span>|</span><a href="#40488760">prev</a><span>|</span><a href="#40484950">next</a><span>|</span><label class="collapse" for="c-40485716">[-]</label><label class="expand" for="c-40485716">[1 more]</label></div><br/><div class="children"><div class="content">Arrays are a separate data type than pointers, although in many contexts you can use an array where a pointer is expected and it will work, and this feature is useful.<p>Bounds-checking can sometimes be useful, and can perhaps have a switch to control its working.<p>Some instruction sets (such as Flex) have tagged memory. In Flex, a pointer contains the address of a block (and a pointer can also be designated is read-only, disallowing writing through the pointer). There is also a &quot;reference&quot; consisting of a pointer and a displacement; I suppose this &quot;reference&quot; can be used to implement C pointers. If you use this, then the computer will automatically do bounds-checking and will result in an error if you make an access that is out of bounds.<p>Tagged memory also allows to easily find the pointers in memory without needing to know the types of variables, which can be helpful for some uses, e.g. to detect improper use of realloc&#x2F;free. Furthermore, null pointer can be zero (without the tag bits), which is automatically an error when used as a pointer because it is not a pointer.</div><br/></div></div><div id="40484950" class="c"><input type="checkbox" id="c-40484950" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40484853">parent</a><span>|</span><a href="#40485716">prev</a><span>|</span><a href="#40487123">next</a><span>|</span><label class="collapse" for="c-40484950">[-]</label><label class="expand" for="c-40484950">[6 more]</label></div><br/><div class="children"><div class="content">In fact, per the standard, a+x is already an array reference: you aren&#x27;t allowed to go outside the bounds of the array immediately containing the pointee, on pain of UB.<p>(Arrays do exist in the object model, and you can take pointers to them of type T (*)[N]; you just can&#x27;t copy them around by value, and the name of an array decays to its first element pointer.)<p>Compilers just typically don&#x27;t track array bounds at runtime because of (a) performance and (b) big ABI incompatibilities. There&#x27;s nothing in the language itself that stops them.</div><br/><div id="40485467" class="c"><input type="checkbox" id="c-40485467" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40484950">parent</a><span>|</span><a href="#40487123">next</a><span>|</span><label class="collapse" for="c-40485467">[-]</label><label class="expand" for="c-40485467">[5 more]</label></div><br/><div class="children"><div class="content">&gt; on pain of UB<p>But this is exactly the problem.  UB can be anything, including nothing.  This should be <i>at the very least</i> an optional warning.  But here is what happens with a fairly current C compiler:<p><pre><code>    % gcc -v
    Apple clang version 14.0.0 (clang-1400.0.29.202)
    ...
    % more test.c
    int main () {
      int x[10];
      return *(x+20);
    }
    % gcc -Wall test.c
    %</code></pre></div><br/><div id="40486578" class="c"><input type="checkbox" id="c-40486578" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485467">parent</a><span>|</span><a href="#40485631">next</a><span>|</span><label class="collapse" for="c-40486578">[-]</label><label class="expand" for="c-40486578">[1 more]</label></div><br/><div class="children"><div class="content">You can also make it throw an error at runtime:<p><pre><code>  $ gcc -fsanitize=undefined -o test test.c
  $ .&#x2F;test
  test.c:3:10: runtime error: load of address 0x7ffea07fded0 with insufficient space for an object of type &#x27;int&#x27;
  0x7ffea07fded0: note: pointer points here
   b2 55 00 00  d8 df 7f a0 01 00 00 00  c8 df 7f a0 fe 7f 00 00  00 00 00 00 00 00 00 00  62 0f 73 ea
                ^
</code></pre>
&gt; But this is exactly the problem. UB can be anything, including nothing.<p>There&#x27;s nothing stopping compilers from implementing the semantics you want (when not crossing an ABI boundary), and indeed, they&#x27;ve been adding more gradual hardening options that can be used in production. It&#x27;s just that there&#x27;s little demand for universal bounds-checking on arrays, and some users even want more flexible accesses, e.g., for operations like container_of.<p>On the other hand, people can and have made experimental forks of the Rust compiler to turn all panics into immediate LLVM-level UB, but the mere existence of such an option doesn&#x27;t mean that Rust&#x27;s bounds-checking is now worthless, as you seem to be implying for C.</div><br/></div></div><div id="40485631" class="c"><input type="checkbox" id="c-40485631" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485467">parent</a><span>|</span><a href="#40486578">prev</a><span>|</span><a href="#40487123">next</a><span>|</span><label class="collapse" for="c-40485631">[-]</label><label class="expand" for="c-40485631">[3 more]</label></div><br/><div class="children"><div class="content">These kinds of warnings need optimizations enabled.<p><pre><code>    $ gcc -O2 -Wall -c t.c 
    t.c: In function ‘main’:
    t.c:3:14: warning: array subscript 20 is outside array bounds of ‘int[10]’ [-Warray-bounds]
        3 |       return *(x+20);
          |              ^~~~~~~
    t.c:2:11: note: at offset 80 into object ‘x’ of size 40
        2 |       int x[10];
          |           ^
</code></pre>
Not sure how to get Clang to warn. It clearly recognizes the undefined behavior.</div><br/><div id="40485725" class="c"><input type="checkbox" id="c-40485725" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485631">parent</a><span>|</span><a href="#40487123">next</a><span>|</span><label class="collapse" for="c-40485725">[-]</label><label class="expand" for="c-40485725">[2 more]</label></div><br/><div class="children"><div class="content">Clang appears to have -Warray-bounds-pointer-arithmetic for this, though not enabled on -Wall nor -Wextra. (fwiw, clang has -Weverything to turn on literally every warning, including conflicting ones, for finding what flags there are)</div><br/><div id="40485755" class="c"><input type="checkbox" id="c-40485755" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485725">parent</a><span>|</span><a href="#40487123">next</a><span>|</span><label class="collapse" for="c-40485755">[-]</label><label class="expand" for="c-40485755">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, Clang warns on x[20] but not *(x+20) even with -Wall and -O2.  It&#x27;s kinda weird.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40487123" class="c"><input type="checkbox" id="c-40487123" checked=""/><div class="controls bullet"><span class="by">abtinf</span><span>|</span><a href="#40484853">parent</a><span>|</span><a href="#40484950">prev</a><span>|</span><a href="#40484941">next</a><span>|</span><label class="collapse" for="c-40487123">[-]</label><label class="expand" for="c-40487123">[2 more]</label></div><br/><div class="children"><div class="content">Are you referencing this?<p><a href="https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html" rel="nofollow">https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html</a></div><br/><div id="40487889" class="c"><input type="checkbox" id="c-40487889" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40487123">parent</a><span>|</span><a href="#40484941">next</a><span>|</span><label class="collapse" for="c-40487889">[-]</label><label class="expand" for="c-40487889">[1 more]</label></div><br/><div class="children"><div class="content">Yep.</div><br/></div></div></div></div><div id="40484941" class="c"><input type="checkbox" id="c-40484941" checked=""/><div class="controls bullet"><span class="by">Xeamek</span><span>|</span><a href="#40484853">parent</a><span>|</span><a href="#40487123">prev</a><span>|</span><a href="#40485727">next</a><span>|</span><label class="collapse" for="c-40484941">[-]</label><label class="expand" for="c-40484941">[11 more]</label></div><br/><div class="children"><div class="content"><i>C programmers</i> NO! You can&#x27;t do that, that would break compatibility!<p><i>also C programmers</i>
Wow, You are trying to compile this old program on new toolchain?<p>Here is a list of 10k errors due to changed defaults flags for compilation, dependencies breaking by going from 9.4.1 to 9.4.2 and also, your code contains platform-specific extensions anyway.<p>But C is portable guys! It really is!</div><br/><div id="40485221" class="c"><input type="checkbox" id="c-40485221" checked=""/><div class="controls bullet"><span class="by">pdw</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40484941">parent</a><span>|</span><a href="#40485159">next</a><span>|</span><label class="collapse" for="c-40485221">[-]</label><label class="expand" for="c-40485221">[3 more]</label></div><br/><div class="children"><div class="content">That makes sense when you realize that what C folks care about more than anything else is _ABI compatibility_. Changes to language or toolchain are acceptable as long as they don&#x27;t change the ABI.<p>E.g. consider the hemming and hawing about a 64-bit time_t. That&#x27;s a tiny change in comparison, and one that&#x27;s obviously unavoidable and with a strict deadline. And yet...</div><br/><div id="40485663" class="c"><input type="checkbox" id="c-40485663" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485221">parent</a><span>|</span><a href="#40485339">next</a><span>|</span><label class="collapse" for="c-40485663">[-]</label><label class="expand" for="c-40485663">[1 more]</label></div><br/><div class="children"><div class="content">&gt; E.g. consider the hemming and hawing about a 64-bit time_t.<p>I had received a compiler warning about this when trying to compile a program on Raspberry Pi (it was a old version; I did this a few days before they implemented 64-bit time_t on Raspberry Pi). Fortunately I was able to add a macro to allow it to work on computers without 64-bit time_t. Other than that, the program I compiled worked perfectly, although I wrote the program on PC and did not specifically try to make it work with Raspberry Pi. So, a C code is portable, although sometimes a few changes are required to make the program to work.<p>But I think that 64-bit time_t is a good idea.</div><br/></div></div><div id="40485339" class="c"><input type="checkbox" id="c-40485339" checked=""/><div class="controls bullet"><span class="by">kukkamario</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485221">parent</a><span>|</span><a href="#40485663">prev</a><span>|</span><a href="#40485159">next</a><span>|</span><label class="collapse" for="c-40485339">[-]</label><label class="expand" for="c-40485339">[1 more]</label></div><br/><div class="children"><div class="content">64-bit time has already been resolved in newer 32-bit Linux versions. Issue isn&#x27;t that changing ABI couldn&#x27;t be done. It is that no one wants to update OS and custom software of a 15-year-old embedded system that still works. Archeology to find correct instructions to build a working OS image is challenge itself and then there is a need to adapt them to more modern tools. Been there, done that, and it wasn&#x27;t fun...</div><br/></div></div></div></div><div id="40485159" class="c"><input type="checkbox" id="c-40485159" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40484941">parent</a><span>|</span><a href="#40485221">prev</a><span>|</span><a href="#40485727">next</a><span>|</span><label class="collapse" for="c-40485159">[-]</label><label class="expand" for="c-40485159">[7 more]</label></div><br/><div class="children"><div class="content">But that&#x27;s the thing, code bases are full of non-standard C, but they never break because the C standard changes, only because their weird hacks are falling out of favour. Fixing a design flaw in C will break all existing code, instead of the code of the dozens of companies relying on weird hacks they wrote ten years ago.<p>Once Zig becomes stable, I think it may have a chance of slowly fixing existing C code bases, by its virtue of being able to co-exist with existing code bases. On the other hand, a lot of C programmers don&#x27;t want to change because they don&#x27;t see a problem, so the presence of those will probably ruin any chance Zig has of improving the situation.</div><br/><div id="40487815" class="c"><input type="checkbox" id="c-40487815" checked=""/><div class="controls bullet"><span class="by">qiqitori</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485159">parent</a><span>|</span><a href="#40485611">next</a><span>|</span><label class="collapse" for="c-40487815">[-]</label><label class="expand" for="c-40487815">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Once Zig becomes stable<p>Zig was introduced in 2016. If it still isn&#x27;t stable 8 years later, I wouldn&#x27;t hold my breath.</div><br/><div id="40488320" class="c"><input type="checkbox" id="c-40488320" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40487815">parent</a><span>|</span><a href="#40485611">next</a><span>|</span><label class="collapse" for="c-40488320">[-]</label><label class="expand" for="c-40488320">[2 more]</label></div><br/><div class="children"><div class="content">Rust began in 2006 and became stable in 2015. Zig still has a year at the very least!<p>Zig lacks the corporate backing Rust had, though, so it&#x27;s hard to say when they&#x27;ll get stable.<p>Regardless, even if it&#x27;ll take Zig a decade, I&#x27;m sure it&#x27;ll have a stable release with decent memory management as part of the language spec before C will.</div><br/><div id="40488430" class="c"><input type="checkbox" id="c-40488430" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40488320">parent</a><span>|</span><a href="#40485611">next</a><span>|</span><label class="collapse" for="c-40488430">[-]</label><label class="expand" for="c-40488430">[1 more]</label></div><br/><div class="children"><div class="content">Zig is basically the Modula-2 features (1978) in a more C like friendly packaging, with an additional metaprogramming capabilities.<p>It needs a bit more than only corporate backing for taking off, something that makes it unavoidable, specially given the alternatives.</div><br/></div></div></div></div></div></div><div id="40485611" class="c"><input type="checkbox" id="c-40485611" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485159">parent</a><span>|</span><a href="#40487815">prev</a><span>|</span><a href="#40485727">next</a><span>|</span><label class="collapse" for="c-40485611">[-]</label><label class="expand" for="c-40485611">[3 more]</label></div><br/><div class="children"><div class="content">Other than the pessimistic finish, my prediction is that this is exactly what will happen.<p>The change will be a generational one. C will never entirely disappear, but over time, C code will be old code. People will occasionally write new C for what amounts to aesthetic reasons, and there will be a robust niche (doubtless well-paid) of maintainers of legacy C projects. All the kernels currently written in C will still exist, and still be composed mostly or entirely of C.<p>But new work in embedded, drivers, implementation of programming languages, netork stacks, will be in Zig instead. With some Rust as well, but I figure we&#x27;ve seen enough of that arc to tentatively conclude that what Rust is displacing is mostly C++, not C.<p>But when I say generational, I mean it. You&#x27;re quite right that there is a legion of C programmers who like it and intend to stick with it. But they&#x27;ll retire one day.</div><br/><div id="40488887" class="c"><input type="checkbox" id="c-40488887" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485611">parent</a><span>|</span><a href="#40488365">next</a><span>|</span><label class="collapse" for="c-40488887">[-]</label><label class="expand" for="c-40488887">[1 more]</label></div><br/><div class="children"><div class="content">In many places outside the UNIX FOSS sphere and hardcore embedded devs, C++ keeps replacing C already, that includes Apple, Google and Microsoft OSes.<p>While Rust might be a better alternative, C++ is already much better than raw C.</div><br/></div></div><div id="40488365" class="c"><input type="checkbox" id="c-40488365" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485611">parent</a><span>|</span><a href="#40488887">prev</a><span>|</span><a href="#40485727">next</a><span>|</span><label class="collapse" for="c-40488365">[-]</label><label class="expand" for="c-40488365">[1 more]</label></div><br/><div class="children"><div class="content">Except for maybe in kernel projects, C code already is old code. As far as I can tell, (modern) C++ is the oldest common language for new projects.<p>Rust is already part of the Linux kernel, being used for rather complex things like GPU drivers in Asahi. Android rewrote their Bluetooth stack into Rust and Windows is actively replacing existing operating system components with Rust as well. I don&#x27;t think we&#x27;ll need to wait for Zig to start replacing old C code, it&#x27;s already being replaced with Rust now.<p>I think Zig would&#x27;ve been a better choice for some parts, but it&#x27;s taking too long to become stable for it to be included in large projects. Still, it may be useful for people working on embedded stuff, as embedded code seems to be stuck with 90s C when it comes to language support, if someone can manage to write a compiler backend for that specific embedded chip.</div><br/></div></div></div></div></div></div></div></div><div id="40485727" class="c"><input type="checkbox" id="c-40485727" checked=""/><div class="controls bullet"><span class="by">marmakoide</span><span>|</span><a href="#40484853">parent</a><span>|</span><a href="#40484941">prev</a><span>|</span><a href="#40487152">next</a><span>|</span><label class="collapse" for="c-40485727">[-]</label><label class="expand" for="c-40485727">[3 more]</label></div><br/><div class="children"><div class="content">That would break most C code handling hardware directly, like on MCUs</div><br/><div id="40485744" class="c"><input type="checkbox" id="c-40485744" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485727">parent</a><span>|</span><a href="#40487152">next</a><span>|</span><label class="collapse" for="c-40485744">[-]</label><label class="expand" for="c-40485744">[2 more]</label></div><br/><div class="children"><div class="content">Why?</div><br/><div id="40488895" class="c"><input type="checkbox" id="c-40488895" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40485744">parent</a><span>|</span><a href="#40487152">next</a><span>|</span><label class="collapse" for="c-40488895">[-]</label><label class="expand" for="c-40488895">[1 more]</label></div><br/><div class="children"><div class="content">Most likely because while they call C, what they actually write is macro Assembler looking code, full of compiler specific language extensions doing MCU intrisics, instead of Assembly opcodes.</div><br/></div></div></div></div></div></div><div id="40487152" class="c"><input type="checkbox" id="c-40487152" checked=""/><div class="controls bullet"><span class="by">fijiaarone</span><span>|</span><a href="#40484853">parent</a><span>|</span><a href="#40485727">prev</a><span>|</span><a href="#40488370">next</a><span>|</span><label class="collapse" for="c-40487152">[-]</label><label class="expand" for="c-40487152">[2 more]</label></div><br/><div class="children"><div class="content">That’s like saying “the problem with aircraft is that they keep crashing when there is not enough lift under the wings, so the obvious answer is to get rid of wings”.<p>Only, it would even be stupider if your grasp of programming was as great as your understanding of aerodynamics.</div><br/><div id="40487902" class="c"><input type="checkbox" id="c-40487902" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40487152">parent</a><span>|</span><a href="#40488370">next</a><span>|</span><label class="collapse" for="c-40487902">[-]</label><label class="expand" for="c-40487902">[1 more]</label></div><br/><div class="children"><div class="content">Ironic that you would pick that metaphor because I happen to have both a pilot&#x27;s license and a Ph.D. in computer science.  So I really snookered someone.</div><br/></div></div></div></div><div id="40488370" class="c"><input type="checkbox" id="c-40488370" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40484853">parent</a><span>|</span><a href="#40487152">prev</a><span>|</span><a href="#40486105">next</a><span>|</span><label class="collapse" for="c-40488370">[-]</label><label class="expand" for="c-40488370">[2 more]</label></div><br/><div class="children"><div class="content">Because typing &amp;myarray[0] is too much typing. &#x2F;s<p>Even Dennis Ritchie tried to add fat pointers, but failed to have the new C overlords care about his proposals.<p>Despite what we might think about their feature set, it is quite relevant that Alef, Limbo and Go were designed by the UNIX folks, and all of them don&#x27;t repeat the same mistake with arrays and strings.</div><br/><div id="40488382" class="c"><input type="checkbox" id="c-40488382" checked=""/><div class="controls bullet"><span class="by">psychoslave</span><span>|</span><a href="#40484853">root</a><span>|</span><a href="#40488370">parent</a><span>|</span><a href="#40486105">next</a><span>|</span><label class="collapse" for="c-40488382">[-]</label><label class="expand" for="c-40488382">[1 more]</label></div><br/><div class="children"><div class="content">Interesting hint on Dennis Ritchie attempt. Here is a related thread: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39677581">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39677581</a></div><br/></div></div></div></div></div></div><div id="40486105" class="c"><input type="checkbox" id="c-40486105" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40484853">prev</a><span>|</span><a href="#40486920">next</a><span>|</span><label class="collapse" for="c-40486105">[-]</label><label class="expand" for="c-40486105">[1 more]</label></div><br/><div class="children"><div class="content">When I was writing my proposal to get into a PhD program, I had to do a crash course in formally verified applications.  The focus of the program is actually in Isabelle, but Coq is similar enough (in a hand-wavey kind of way) to where it was relevant to what I was writing about, and I stumbled across a few formally verified things with Coq.<p>I became slightly obsessed with CompCert, but it felt like a &quot;real&quot; program that was utilizing proper formal verification techniques.  It seemed so cool to me that there can be (to some extent), and &quot;objectively correct&quot; version of a C compiler. I still think it&#x27;s very cool; I wish people would geek out about this stuff as much as I would sometimes.</div><br/></div></div><div id="40486920" class="c"><input type="checkbox" id="c-40486920" checked=""/><div class="controls bullet"><span class="by">nullifidian</span><span>|</span><a href="#40486105">prev</a><span>|</span><a href="#40486021">next</a><span>|</span><label class="collapse" for="c-40486920">[-]</label><label class="expand" for="c-40486920">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s important to note that you can&#x27;t use it commercially.<p>&quot;The INRIA Non-Commercial License Agreement is a non-free license that
grants you the right to use the CompCert verified compiler for
educational, research or evaluation purposes only, but prohibits
any commercial use.<p>For commercial use you need a Software Usage Agreement from
AbsInt Angewandte Informatik GmbH.&quot;</div><br/></div></div><div id="40486021" class="c"><input type="checkbox" id="c-40486021" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#40486920">prev</a><span>|</span><a href="#40484822">next</a><span>|</span><label class="collapse" for="c-40486021">[-]</label><label class="expand" for="c-40486021">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>CompCert – Formally-verified C compiler</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27648735">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27648735</a> - June 2021 (123 comments)<p><i>CompCert C a formally verified optimizing compiler for a large subset of C99</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27644356">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27644356</a> - June 2021 (1 comment)<p><i>CompCert – A formally verified C compiler</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18968125">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18968125</a> - Jan 2019 (57 comments)<p><i>Closing the Gap – The Formally Verified Optimizing Compiler CompCert [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=13046449">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=13046449</a> - Nov 2016 (10 comments)<p><i>CompCert: A formally verified optimizing C compiler</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9130934">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9130934</a> - March 2015 (62 comments)<p><i>CompCert - Compilers you can formally trust</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=2619650">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=2619650</a> - June 2011 (28 comments)</div><br/></div></div><div id="40484822" class="c"><input type="checkbox" id="c-40484822" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40486021">prev</a><span>|</span><label class="collapse" for="c-40484822">[-]</label><label class="expand" for="c-40484822">[14 more]</label></div><br/><div class="children"><div class="content">A cautionary tale for anyone relying on formal proofs of correctness:<p><a href="https:&#x2F;&#x2F;spinroot.com&#x2F;spin&#x2F;Doc&#x2F;rax.pdf" rel="nofollow">https:&#x2F;&#x2F;spinroot.com&#x2F;spin&#x2F;Doc&#x2F;rax.pdf</a><p>TL;DR: in the 1990s NASA flew an autonomous control system that was formally verified, tested out the wazoo, but which nonetheless failed in flight.<p>[UPDATE] I did not mean to imply that the formal verification failed.  It did not.  The formal verification worked as advertised.  The cause of the failure was much more subtle and nuanced.</div><br/><div id="40484872" class="c"><input type="checkbox" id="c-40484872" checked=""/><div class="controls bullet"><span class="by">elteto</span><span>|</span><a href="#40484822">parent</a><span>|</span><a href="#40484926">next</a><span>|</span><label class="collapse" for="c-40484872">[-]</label><label class="expand" for="c-40484872">[3 more]</label></div><br/><div class="children"><div class="content">You make it seem like the formal verification missed an issue. Not quite what happened:<p>&quot;The first effort consisted of analyzing part of the RA autonomous space craft software using the SPIN model checker. One of the errors found with SPIN, a missing critical section around a conditional wait statement, was in fact reintroduced in a different subsystem that was not verified in this first pre-flight effort. This error caused a real deadlock in the RA during flight in space.&quot;<p>The model actually found an issue that was later reintroduced in a different part of the system that was not formally verified. If anything, it tells us we need _more_ formal verification!</div><br/><div id="40484970" class="c"><input type="checkbox" id="c-40484970" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40484822">root</a><span>|</span><a href="#40484872">parent</a><span>|</span><a href="#40484926">next</a><span>|</span><label class="collapse" for="c-40484970">[-]</label><label class="expand" for="c-40484970">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You make it seem like the formal verification missed an issue.<p>Sorry, that was not my intent.  I added a clarification.</div><br/><div id="40486837" class="c"><input type="checkbox" id="c-40486837" checked=""/><div class="controls bullet"><span class="by">sobkas</span><span>|</span><a href="#40484822">root</a><span>|</span><a href="#40484970">parent</a><span>|</span><a href="#40484926">next</a><span>|</span><label class="collapse" for="c-40486837">[-]</label><label class="expand" for="c-40486837">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; You make it seem like the formal verification missed an issue.<p>&gt; Sorry, that was not my intent. I added a clarification.<p>I&#x27;m sorry but it didn&#x27;t. Without reading next comment I wouldn&#x27;t know why it failed.</div><br/></div></div></div></div></div></div><div id="40484926" class="c"><input type="checkbox" id="c-40484926" checked=""/><div class="controls bullet"><span class="by">cwzwarich</span><span>|</span><a href="#40484822">parent</a><span>|</span><a href="#40484872">prev</a><span>|</span><a href="#40486144">next</a><span>|</span><label class="collapse" for="c-40484926">[-]</label><label class="expand" for="c-40484926">[5 more]</label></div><br/><div class="children"><div class="content">I’m confused. Wasn’t the error actually in an unverified subsystem and isomorphic to an error caught by the model checker in a verified subsystem? Isn’t this more of a cautionary tale for someone <i>not</i> relying on formal verification?</div><br/><div id="40484953" class="c"><input type="checkbox" id="c-40484953" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40484822">root</a><span>|</span><a href="#40484926">parent</a><span>|</span><a href="#40486144">next</a><span>|</span><label class="collapse" for="c-40484953">[-]</label><label class="expand" for="c-40484953">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Wasn’t the error actually in an unverified subsystem and isomorphic to an error caught by the model checker in a verified subsystem?<p>No, it was quite a bit more subtle than that.  The problem was that there was no mechanism to enforce the use of the formally verified API, and an application programmer put in a direct call to a system function that bypassed that API.<p>Source: I was the technical lead on the RAX executive.</div><br/><div id="40485130" class="c"><input type="checkbox" id="c-40485130" checked=""/><div class="controls bullet"><span class="by">extrabajs</span><span>|</span><a href="#40484822">root</a><span>|</span><a href="#40484953">parent</a><span>|</span><a href="#40485186">next</a><span>|</span><label class="collapse" for="c-40485130">[-]</label><label class="expand" for="c-40485130">[1 more]</label></div><br/><div class="children"><div class="content">It sounds more like a cautionary tale against bypassing APIs. What part of this is related to formal verification?</div><br/></div></div><div id="40485186" class="c"><input type="checkbox" id="c-40485186" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#40484822">root</a><span>|</span><a href="#40484953">parent</a><span>|</span><a href="#40485130">prev</a><span>|</span><a href="#40486144">next</a><span>|</span><label class="collapse" for="c-40485186">[-]</label><label class="expand" for="c-40485186">[2 more]</label></div><br/><div class="children"><div class="content">This is why friends don&#x27;t let friends use unsafePerformIO ... or whatever the equivalent was here :)<p>I&#x27;m still a bit confused about the point though. I feel like an adequate rejoinder would be to enforce formal methods at all the levels? I&#x27;m obviously not talking specifics (because I don&#x27;t know them! ... and you do), but this seems like a failure of process or lack of enforcement of formal methods &quot;all the way down&quot; as it were. I dunno, color me confused...</div><br/><div id="40486106" class="c"><input type="checkbox" id="c-40486106" checked=""/><div class="controls bullet"><span class="by">wucke13</span><span>|</span><a href="#40484822">root</a><span>|</span><a href="#40485186">parent</a><span>|</span><a href="#40486144">next</a><span>|</span><label class="collapse" for="c-40486106">[-]</label><label class="expand" for="c-40486106">[1 more]</label></div><br/><div class="children"><div class="content">Which almost reads as a cautionary tale about mechanisms like Dust&#x27;s `unsafe`. Not necessarily the specifics of the Rust, but the overall idea of having a safe (by whatever means) sunset of operations and and additional unsafe operations, which eases code analysis tremendously. You can&#x27;t got without unsafe in most embedded systems. But it&#x27;s good to very explicitly mark in the code wherever the unknown depths of UB lurk if not the most attention is exercised.</div><br/></div></div></div></div></div></div></div></div><div id="40486144" class="c"><input type="checkbox" id="c-40486144" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40484822">parent</a><span>|</span><a href="#40484926">prev</a><span>|</span><a href="#40487480">next</a><span>|</span><label class="collapse" for="c-40486144">[-]</label><label class="expand" for="c-40486144">[4 more]</label></div><br/><div class="children"><div class="content">Honestly, I don&#x27;t think you&#x27;re wrong, and this is from a guy who is getting a PhD in formal methods.<p>Formal methods are super cool, and formal verification is even cool, but it can be really easy to think it&#x27;s always perfect.  It gives you such amazing guardrails most of the time that it can be easy to stop looking for when there aren&#x27;t any.<p>For example, model checking is cool and useful, but sort of by definition it is exhaustive and as a result you end up having to restrict scope in a lot of cases (For example, redefining the INTEGERS set to {-1000...1000} in TLA+). This is <i>almost always</i> perfectly fine and can catch a lot of weird cases, but it&#x27;s easy to forget that &quot;nearly everything&quot; is not the same thing as &quot;everything&quot;.<p>Obviously I still think formal methods are worth it, but they&#x27;re not a substitute for being careful.</div><br/><div id="40486686" class="c"><input type="checkbox" id="c-40486686" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40484822">root</a><span>|</span><a href="#40486144">parent</a><span>|</span><a href="#40487480">next</a><span>|</span><label class="collapse" for="c-40486686">[-]</label><label class="expand" for="c-40486686">[3 more]</label></div><br/><div class="children"><div class="content">&gt; formal methods are worth it, but they&#x27;re not a substitute for being careful.<p>Yes.  Exactly this.  I hereby dub this Tombert&#x27;s law.  :-)</div><br/><div id="40486768" class="c"><input type="checkbox" id="c-40486768" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40484822">root</a><span>|</span><a href="#40486686">parent</a><span>|</span><a href="#40487480">next</a><span>|</span><label class="collapse" for="c-40486768">[-]</label><label class="expand" for="c-40486768">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m honored! I always thought Tombert&#x27;s Law would end up being something about cartoon trivia, so this is much better.</div><br/><div id="40486782" class="c"><input type="checkbox" id="c-40486782" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40484822">root</a><span>|</span><a href="#40486768">parent</a><span>|</span><a href="#40487480">next</a><span>|</span><label class="collapse" for="c-40486782">[-]</label><label class="expand" for="c-40486782">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m going to start listing it alongside my other favorite aphorism: Furious activity is no substitute for understanding.  -- H.H. Williams</div><br/></div></div></div></div></div></div></div></div><div id="40487480" class="c"><input type="checkbox" id="c-40487480" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#40484822">parent</a><span>|</span><a href="#40486144">prev</a><span>|</span><label class="collapse" for="c-40487480">[-]</label><label class="expand" for="c-40487480">[1 more]</label></div><br/><div class="children"><div class="content">IIRC Regehr found a bug when testing compcert.  It turned out to be a bug in a standard header file.  Similar idea of bugs due to incomplete verification.</div><br/></div></div></div></div></div></div></div></div></div></body></html>