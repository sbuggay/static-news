<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704531656404" as="style"/><link rel="stylesheet" href="styles.css?v=1704531656404"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://yosefk.com/blog/why-bad-scientific-code-beats-code-following-best-practices.html">Why bad scientific code beats code following &quot;best practices&quot; (2014)</a> <span class="domain">(<a href="https://yosefk.com">yosefk.com</a>)</span></div><div class="subtext"><span>luu</span> | <span>57 comments</span></div><br/><div><div id="38889796" class="c"><input type="checkbox" id="c-38889796" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#38889051">next</a><span>|</span><label class="collapse" for="c-38889796">[-]</label><label class="expand" for="c-38889796">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>Why bad scientific code beats code following “best practices” (2014)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=12377385">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=12377385</a> - Aug 2016 (261 comments)<p><i>Why bad scientific code beats code following &quot;best practices&quot;</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=7731624">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=7731624</a> - May 2014 (168 comments)</div><br/></div></div><div id="38889051" class="c"><input type="checkbox" id="c-38889051" checked=""/><div class="controls bullet"><span class="by">jurschreuder</span><span>|</span><a href="#38889796">prev</a><span>|</span><a href="#38889110">next</a><span>|</span><label class="collapse" for="c-38889051">[-]</label><label class="expand" for="c-38889051">[18 more]</label></div><br/><div class="children"><div class="content">This is so true I don&#x27;t think I ever read something so true.<p>It&#x27;s not even scientists vs software developers. It&#x27;s people who are really into software development and clean code.<p>They say the program needs a total rewrite and proceed to add 20 layers of inheritance and spreading out every function over 8 files.<p>Ever since I make sure to repeat my mantra every week to developers:<p>How maintainable code is is measured in how many files you have to edit to add one feature.</div><br/><div id="38889130" class="c"><input type="checkbox" id="c-38889130" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38889051">parent</a><span>|</span><a href="#38889218">next</a><span>|</span><label class="collapse" for="c-38889130">[-]</label><label class="expand" for="c-38889130">[4 more]</label></div><br/><div class="children"><div class="content">Wrong.<p>How maintainable code is is measured in how well you know where to change something, and how certain you are that it did the right thing without side effects.<p>The fatal error of the linked article is that bad scientific code often suffers from correctness problems - not just theoretical concerns, but the &quot;negates the main point of this paper&quot; kind of thing.</div><br/><div id="38889248" class="c"><input type="checkbox" id="c-38889248" checked=""/><div class="controls bullet"><span class="by">thriftwy</span><span>|</span><a href="#38889051">root</a><span>|</span><a href="#38889130">parent</a><span>|</span><a href="#38889218">next</a><span>|</span><label class="collapse" for="c-38889248">[-]</label><label class="expand" for="c-38889248">[3 more]</label></div><br/><div class="children"><div class="content">What if a new person takes your place and they do not know it and are not certain in anything?</div><br/><div id="38889316" class="c"><input type="checkbox" id="c-38889316" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38889051">root</a><span>|</span><a href="#38889248">parent</a><span>|</span><a href="#38889260">prev</a><span>|</span><a href="#38889218">next</a><span>|</span><label class="collapse" for="c-38889316">[-]</label><label class="expand" for="c-38889316">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s how you measure job security, which is a slightly different concept than maintainability.</div><br/></div></div></div></div></div></div><div id="38889218" class="c"><input type="checkbox" id="c-38889218" checked=""/><div class="controls bullet"><span class="by">logicchains</span><span>|</span><a href="#38889051">parent</a><span>|</span><a href="#38889130">prev</a><span>|</span><a href="#38889146">next</a><span>|</span><label class="collapse" for="c-38889218">[-]</label><label class="expand" for="c-38889218">[1 more]</label></div><br/><div class="children"><div class="content">&gt;They say the program needs a total rewrite and proceed to add 20 layers of inheritance and spreading out every function over 8 files.<p>Anyone who in 2023 still thinks inheritance is a good idea for anything other than a few very specialised use-cases is not somebody who seriously cares about the craft of software development, not somebody who&#x27;s put any effort to study programming theory and move beyond destructive 1990s enterprise Java practices. Widespread usage of inheritance inevitably makes code harder to reason about and refactor, as anyone who&#x27;s compared code in Java to code for similar functionality in Rust or Go would see (both Rust and Go deliberately eschew support for inheritance due to the nightmares it can cause).</div><br/></div></div><div id="38889146" class="c"><input type="checkbox" id="c-38889146" checked=""/><div class="controls bullet"><span class="by">Exoristos</span><span>|</span><a href="#38889051">parent</a><span>|</span><a href="#38889218">prev</a><span>|</span><a href="#38889101">next</a><span>|</span><label class="collapse" for="c-38889146">[-]</label><label class="expand" for="c-38889146">[7 more]</label></div><br/><div class="children"><div class="content">Am I missing something? Opening files is not my most intensive work as a developer.</div><br/><div id="38889191" class="c"><input type="checkbox" id="c-38889191" checked=""/><div class="controls bullet"><span class="by">querez</span><span>|</span><a href="#38889051">root</a><span>|</span><a href="#38889146">parent</a><span>|</span><a href="#38889157">next</a><span>|</span><label class="collapse" for="c-38889191">[-]</label><label class="expand" for="c-38889191">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a decent measure of complexity: It&#x27;s not that &quot;opening files&quot; themselves is work-intensive. But having a lot of files smells of overengineered code. One long, yet simple function has less cognitive overhead than spreading the function across multiple classes or functions or call hierarchies (themselves spread over multiple files).</div><br/><div id="38889221" class="c"><input type="checkbox" id="c-38889221" checked=""/><div class="controls bullet"><span class="by">bobmaxup</span><span>|</span><a href="#38889051">root</a><span>|</span><a href="#38889191">parent</a><span>|</span><a href="#38889157">next</a><span>|</span><label class="collapse" for="c-38889221">[-]</label><label class="expand" for="c-38889221">[3 more]</label></div><br/><div class="children"><div class="content">&gt; One long, yet simple function has less cognitive overhead than spreading the function across multiple classes or functions or call hierarchies<p>Not if you are encapsulating and naming effectively...<p>Why read 100 lines when you can read 20 and find concerns in one routine you are concerned with?<p>Function calls can be expensive. However, optimization can come whenever you need it, and if what you need is one  call vs 5, it is trivial to move that code back into a single routine.</div><br/><div id="38889306" class="c"><input type="checkbox" id="c-38889306" checked=""/><div class="controls bullet"><span class="by">thorncorona</span><span>|</span><a href="#38889051">root</a><span>|</span><a href="#38889221">parent</a><span>|</span><a href="#38889157">next</a><span>|</span><label class="collapse" for="c-38889306">[-]</label><label class="expand" for="c-38889306">[2 more]</label></div><br/><div class="children"><div class="content">I like long simple functions because it makes them easy to reason about when debugging.<p>Rarely does having more functions solve “does this do what I expect.”</div><br/><div id="38889570" class="c"><input type="checkbox" id="c-38889570" checked=""/><div class="controls bullet"><span class="by">bobmaxup</span><span>|</span><a href="#38889051">root</a><span>|</span><a href="#38889306">parent</a><span>|</span><a href="#38889157">next</a><span>|</span><label class="collapse" for="c-38889570">[-]</label><label class="expand" for="c-38889570">[1 more]</label></div><br/><div class="children"><div class="content">Maybe it boils down to how well you are able to navigate a code base.<p>With a full-featured language specific IDE, it is very easy to navigate through even complicated spaghetti. It makes debugging call traces simple, with a GUI.<p>However, many other file viewers and editors make this much more complicated, and it can be frustrating to follow code that is making heavy use of modularization.<p>If you are grepping your way through a deeply modular code base it can quickly become difficult to keep track of anything.</div><br/></div></div></div></div></div></div></div></div><div id="38889157" class="c"><input type="checkbox" id="c-38889157" checked=""/><div class="controls bullet"><span class="by">__loam</span><span>|</span><a href="#38889051">root</a><span>|</span><a href="#38889146">parent</a><span>|</span><a href="#38889191">prev</a><span>|</span><a href="#38889101">next</a><span>|</span><label class="collapse" for="c-38889157">[-]</label><label class="expand" for="c-38889157">[2 more]</label></div><br/><div class="children"><div class="content">Adding indirection makes code less maintainable.</div><br/><div id="38889215" class="c"><input type="checkbox" id="c-38889215" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#38889051">root</a><span>|</span><a href="#38889157">parent</a><span>|</span><a href="#38889101">next</a><span>|</span><label class="collapse" for="c-38889215">[-]</label><label class="expand" for="c-38889215">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Adding indirection makes code less maintainable.<p>This is why I hated Fortran (77 in particular) as an applications language (for tasks like scientific computing people seemed to use saner portions of it). Computed go tos were the bane of my existence.</div><br/></div></div></div></div></div></div><div id="38889101" class="c"><input type="checkbox" id="c-38889101" checked=""/><div class="controls bullet"><span class="by">erhaetherth</span><span>|</span><a href="#38889051">parent</a><span>|</span><a href="#38889146">prev</a><span>|</span><a href="#38889108">next</a><span>|</span><label class="collapse" for="c-38889101">[-]</label><label class="expand" for="c-38889101">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a slippery mantra. I can see putting everything in one file.</div><br/></div></div><div id="38889108" class="c"><input type="checkbox" id="c-38889108" checked=""/><div class="controls bullet"><span class="by">canpolat</span><span>|</span><a href="#38889051">parent</a><span>|</span><a href="#38889101">prev</a><span>|</span><a href="#38889106">next</a><span>|</span><label class="collapse" for="c-38889108">[-]</label><label class="expand" for="c-38889108">[3 more]</label></div><br/><div class="children"><div class="content">Working with a 300 line method is not fun, believe me. Everything is in one place and you don&#x27;t have to change many files, yes, but due to the cognitive load, it&#x27;s so much more effort to maintain it.</div><br/><div id="38889172" class="c"><input type="checkbox" id="c-38889172" checked=""/><div class="controls bullet"><span class="by">__loam</span><span>|</span><a href="#38889051">root</a><span>|</span><a href="#38889108">parent</a><span>|</span><a href="#38889106">next</a><span>|</span><label class="collapse" for="c-38889172">[-]</label><label class="expand" for="c-38889172">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a happy middle path here I think. Long functions are hard to grok. Spreading the logic across 20 files also increases cognitive load. There&#x27;s a balance to strike.</div><br/><div id="38889321" class="c"><input type="checkbox" id="c-38889321" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#38889051">root</a><span>|</span><a href="#38889172">parent</a><span>|</span><a href="#38889106">next</a><span>|</span><label class="collapse" for="c-38889321">[-]</label><label class="expand" for="c-38889321">[1 more]</label></div><br/><div class="children"><div class="content">Right, but the article seems to imply that all code should be in a single file.<p>It seems the author indeed is not a SW Engineer and thus does not really grok the benefit of &quot;modules&quot;.<p>This of course depends on the size of the program. Small program &quot;fits&quot; into a single module.<p>And I think that scientific programs are basically small and simple because they don&#x27;t typically need to deal with user-interaction at all, they just need to calculate a result.<p>Further I think scientific programs rely heavily on existing libraries, and writing a program that relies heavily on calls to external libraries produces simple, short programs.<p>Scientists produce science, engineers produce code-libraries.</div><br/></div></div></div></div></div></div><div id="38889106" class="c"><input type="checkbox" id="c-38889106" checked=""/><div class="controls bullet"><span class="by">arthurcolle</span><span>|</span><a href="#38889051">parent</a><span>|</span><a href="#38889108">prev</a><span>|</span><a href="#38889110">next</a><span>|</span><label class="collapse" for="c-38889106">[-]</label><label class="expand" for="c-38889106">[1 more]</label></div><br/><div class="children"><div class="content">works until it doesn&#x27;t</div><br/></div></div></div></div><div id="38889110" class="c"><input type="checkbox" id="c-38889110" checked=""/><div class="controls bullet"><span class="by">gregopet</span><span>|</span><a href="#38889051">prev</a><span>|</span><a href="#38889383">next</a><span>|</span><label class="collapse" for="c-38889110">[-]</label><label class="expand" for="c-38889110">[2 more]</label></div><br/><div class="children"><div class="content">Sounds like the non-programmers are good at what they are supposed to be good at (solving the actual problem, if perhaps not always in the most elegant manner) while the programmers should be producing a highly maintainable, understandable, testable and reliable code base (and potentially have problems with advanced algorithms that rely on complicated theorems), but they are not. The OP has a case of bad programmers - the techniques listed as bad can be awesome if used with prudence.<p>A good programmer has a very deep knowledge of the various techniques they can use and the wisdom to actually choose the right ones in a given situation.<p>The bad programmers learn a few techniques and apply them everywhere, no matter what they&#x27;re working on, with whom they are working with. Good programmers learn from their mistakes and adapt, bad programmers blame others.<p>I&#x27;ve worked with my share of bad programmers and they really suck. A good programmer&#x27;s code is a joy to work with.</div><br/><div id="38889392" class="c"><input type="checkbox" id="c-38889392" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#38889110">parent</a><span>|</span><a href="#38889383">next</a><span>|</span><label class="collapse" for="c-38889392">[-]</label><label class="expand" for="c-38889392">[1 more]</label></div><br/><div class="children"><div class="content">Right and I think &quot;scientists&quot; simply are more intelligent than average Joe Coder. Intelligent people produce better software.<p>It is easy to learn some coding, not so easy to become a scientist.<p>To becomes a scientist you must write and get your PhD-thesis approved, which must already be about scientific discoveries you have made while doing that thesis. Only people with above average IQ can accomplish something like that, I think.</div><br/></div></div></div></div><div id="38889383" class="c"><input type="checkbox" id="c-38889383" checked=""/><div class="controls bullet"><span class="by">jusssi</span><span>|</span><a href="#38889110">prev</a><span>|</span><a href="#38888943">next</a><span>|</span><label class="collapse" for="c-38889383">[-]</label><label class="expand" for="c-38889383">[1 more]</label></div><br/><div class="children"><div class="content">Two more to the scientists&#x27; tab:<p>1. No tests of any kind. &quot;I know what the output should look like.&quot; Over time people who know what it should look like leave, and then it&#x27;s untouchable.<p>2. No regard to the physical limits of hardware. &quot;We can always get more RAM on everyone&#x27;s laptops, right?&quot;. (You wouldn&#x27;t need to if you just processed the JSONs one at a time, instead of first loading <i>all</i> of them to the memory and then processing them one at a time.)<p>Also the engineers&#x27; tab has a strong smell of junior in it. When you have spent some time <i>maintaining</i> such code, you&#x27;ll learn not to make that same mess yourself. (You&#x27;ll overcorrect and make another, novel kind of mess; some iterations are required to get it right.)</div><br/></div></div><div id="38888943" class="c"><input type="checkbox" id="c-38888943" checked=""/><div class="controls bullet"><span class="by">bearsnowstorm</span><span>|</span><a href="#38889383">prev</a><span>|</span><a href="#38888989">next</a><span>|</span><label class="collapse" for="c-38888943">[-]</label><label class="expand" for="c-38888943">[2 more]</label></div><br/><div class="children"><div class="content">Read this on mobile and the identifier longWindedNameThatYouCantReallyReadBTWProgrammersDoThatALotToo overflowed into the margins - I regard this not as a bug but a feature which helped make the author’s point :-)</div><br/><div id="38889366" class="c"><input type="checkbox" id="c-38889366" checked=""/><div class="controls bullet"><span class="by">_the_inflator</span><span>|</span><a href="#38888943">parent</a><span>|</span><a href="#38888989">next</a><span>|</span><label class="collapse" for="c-38889366">[-]</label><label class="expand" for="c-38889366">[1 more]</label></div><br/><div class="children"><div class="content">That’s why I fell in love with Objective C. The libraries used a lot of those expressive descriptions for attributes and methods.<p>I never understood nor understand people who nest their inner loops in an entangled mess of hardly distinguishable digits, which is error prone.<p>Same for method names.<p>I try to use speaking out loud to some of my methods: What do you do? And if the answer is getValue I believe it needs renaming.</div><br/></div></div></div></div><div id="38888989" class="c"><input type="checkbox" id="c-38888989" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#38888943">prev</a><span>|</span><a href="#38889294">next</a><span>|</span><label class="collapse" for="c-38888989">[-]</label><label class="expand" for="c-38888989">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Simple-minded, care-free near-incompetence can be better than industrial-strength good intentions paving a superhighway to hell. The &quot;real world&quot; outside the computer is full of such examples.<p>Overengineering is insidious - &quot;It is difficult to get a man to understand something, when his salary depends upon his not understanding it&quot;.  A team can sell a solution better than a single person fixing something without making a big deal out of it. You get organizational clout and inertia on your side when you make something big and expensive.<p>And then complex systems are by nature hard to reason about and by extension hard to critique.<p>So many things come down to &quot;complexity is the enemy&quot;.</div><br/><div id="38889048" class="c"><input type="checkbox" id="c-38889048" checked=""/><div class="controls bullet"><span class="by">bottled_poe</span><span>|</span><a href="#38888989">parent</a><span>|</span><a href="#38889045">next</a><span>|</span><label class="collapse" for="c-38889048">[-]</label><label class="expand" for="c-38889048">[2 more]</label></div><br/><div class="children"><div class="content">any code base that evolves over time will have complexity. It can be either manageable or unmanageable complexity. Either sacrifice maintainability for early development velocity, or plan for medium-to-long term velocity. You CAN have both velocity and maintainability, but the engineers will be expensive. Fast, good, cheap - pick two. A tale as old as bits.</div><br/><div id="38889083" class="c"><input type="checkbox" id="c-38889083" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#38888989">root</a><span>|</span><a href="#38889048">parent</a><span>|</span><a href="#38889045">next</a><span>|</span><label class="collapse" for="c-38889083">[-]</label><label class="expand" for="c-38889083">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s not a zero-sum game, you can win by judiciously avoiding incidental complexity.</div><br/></div></div></div></div><div id="38889045" class="c"><input type="checkbox" id="c-38889045" checked=""/><div class="controls bullet"><span class="by">zmgsabst</span><span>|</span><a href="#38888989">parent</a><span>|</span><a href="#38889048">prev</a><span>|</span><a href="#38889294">next</a><span>|</span><label class="collapse" for="c-38889045">[-]</label><label class="expand" for="c-38889045">[4 more]</label></div><br/><div class="children"><div class="content">Prime Finance (at Amazon) did that.<p>Wrote fancy math on a PhD economist’s laptop.<p>Then when we added testing when developing a platform, we found out we’d been 5% off in allocating Prime revenue between organizations — and had the correct amount gone to Retail, the 2018 hiring freeze might have been avoided. (According to a very angry Wilke.)<p>Whoops.<p>Turned out we <i>did</i> need a team and all those guardrails, processes, code reviews, etc.<p>There’s a time and a place for “move fast and break things” — but real trouble can come from taking those academic practices into the real world.</div><br/><div id="38889103" class="c"><input type="checkbox" id="c-38889103" checked=""/><div class="controls bullet"><span class="by">aragilar</span><span>|</span><a href="#38888989">root</a><span>|</span><a href="#38889045">parent</a><span>|</span><a href="#38889294">next</a><span>|</span><label class="collapse" for="c-38889103">[-]</label><label class="expand" for="c-38889103">[3 more]</label></div><br/><div class="children"><div class="content">Did no-one check the maths? There&#x27;s a difference between having a full test suite, and someone trying some choice values, but I&#x27;d expect both would pick up something like that.</div><br/><div id="38889177" class="c"><input type="checkbox" id="c-38889177" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#38888989">root</a><span>|</span><a href="#38889103">parent</a><span>|</span><a href="#38889241">next</a><span>|</span><label class="collapse" for="c-38889177">[-]</label><label class="expand" for="c-38889177">[1 more]</label></div><br/><div class="children"><div class="content">If simple checks could find all bugs we would not have so much buggy software.</div><br/></div></div><div id="38889241" class="c"><input type="checkbox" id="c-38889241" checked=""/><div class="controls bullet"><span class="by">zmgsabst</span><span>|</span><a href="#38888989">root</a><span>|</span><a href="#38889103">parent</a><span>|</span><a href="#38889177">prev</a><span>|</span><a href="#38889294">next</a><span>|</span><label class="collapse" for="c-38889241">[-]</label><label class="expand" for="c-38889241">[1 more]</label></div><br/><div class="children"><div class="content">The PhD economists on our team looked at it.<p>Economists from other teams looked at it and signed off.<p>There was manual testing — ie, trying some “choice values”.<p>We discovered their error in convexity when our test suite allowed us to randomly sample the models at scale. (Actually, I had questions before that — but unsurprisingly, when it was just me questioning a PhD economist, the lowly SDE was ignored.)<p>Good intentions aren’t enough; you need mechanisms.</div><br/></div></div></div></div></div></div></div></div><div id="38889294" class="c"><input type="checkbox" id="c-38889294" checked=""/><div class="controls bullet"><span class="by">laserbeam</span><span>|</span><a href="#38888989">prev</a><span>|</span><a href="#38889013">next</a><span>|</span><label class="collapse" for="c-38889294">[-]</label><label class="expand" for="c-38889294">[1 more]</label></div><br/><div class="children"><div class="content">I agree with the feelings of the author, most software is overengineered (including most of my software).<p>That being said, most scientific code I&#x27;ve encountered doesn&#x27;t compile&#x2F;run. It ran once at some point, it produced results, it worked for the authors and published a paper. The goal for that code was satisfied and than that code somehow rusted out (doesn&#x27;t work with other compilers, hadn&#x27;t properly documented how it gets build, unclear what dependencies were used, dependencies were preprocessed at some point and you can&#x27;t find the preprocessed versions anywhere to reproduce the code, has hardcoded data files which are not in the published repos etc.). I wouldn&#x27;t use THAT as my compass on how to write higher quality code.</div><br/></div></div><div id="38889013" class="c"><input type="checkbox" id="c-38889013" checked=""/><div class="controls bullet"><span class="by">scj</span><span>|</span><a href="#38889294">prev</a><span>|</span><a href="#38888970">next</a><span>|</span><label class="collapse" for="c-38889013">[-]</label><label class="expand" for="c-38889013">[1 more]</label></div><br/><div class="children"><div class="content">Best practices tend to be overkill for small codebases that have few users, which encompasses the majority of scientific code.<p>Sheer tenacity is typically sufficient for scientific codebases.</div><br/></div></div><div id="38888970" class="c"><input type="checkbox" id="c-38888970" checked=""/><div class="controls bullet"><span class="by">nickm12</span><span>|</span><a href="#38889013">prev</a><span>|</span><a href="#38889206">next</a><span>|</span><label class="collapse" for="c-38888970">[-]</label><label class="expand" for="c-38888970">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve been working, ... in an environment dominated by people with a background in math or physics who often have sparse knowledge of &quot;software engineering&quot;. ... Invariably, the biggest messes are made by the minority of people who do define themselves as programmers.<p>Interesting switch in language here from &quot;software engineering&quot; to &quot;programmers&quot;. There is of course a long history of debate on these terms, whether there is a meaningful distinction, and what qualifies as engineering versus programming.<p>Wherever you stand on this debate, there are a number of practices of software developers that tend to be used more towards the &quot;engineering&quot; side. Two of the most essential in my mind are peer code reviews and automated testing of changes (with tests, linters, type-checkers, code formatters, profilers, fuzzers, etc.).<p>This post doesn&#x27;t talk about any of these practices or whether the so-called &quot;programmers&quot; messing up the scientific code are using them. I&#x27;d say if the people messing up the code are not actually advocating for using software development tools to write better code they are not actually applying software engineering practices to their code.</div><br/></div></div><div id="38889206" class="c"><input type="checkbox" id="c-38889206" checked=""/><div class="controls bullet"><span class="by">wilg</span><span>|</span><a href="#38888970">prev</a><span>|</span><a href="#38889351">next</a><span>|</span><label class="collapse" for="c-38889206">[-]</label><label class="expand" for="c-38889206">[1 more]</label></div><br/><div class="children"><div class="content">Is this article just two strawmen fighting?</div><br/></div></div><div id="38889351" class="c"><input type="checkbox" id="c-38889351" checked=""/><div class="controls bullet"><span class="by">hannofcart</span><span>|</span><a href="#38889206">prev</a><span>|</span><a href="#38889069">next</a><span>|</span><label class="collapse" for="c-38889351">[-]</label><label class="expand" for="c-38889351">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not so sure that this claim is valid as a general observation.<p>Multiple times in my career, I have seen scientific code written by academics dramatically sped up by developers who used parallelisation, vectorisation using SIMD etc.<p>So in terms of performance, naively written scientific code is generally easy to beat in terms of performance for a reasonably adept programmer.<p>That said, &quot;enterprisey&quot; Java&#x2F;.NET software engineering shops can indeed make scientific code sub-optimal sometimes. Have come across that sometimes too but I wouldn&#x27;t generalize.</div><br/></div></div><div id="38889069" class="c"><input type="checkbox" id="c-38889069" checked=""/><div class="controls bullet"><span class="by">cube00</span><span>|</span><a href="#38889351">prev</a><span>|</span><a href="#38889320">next</a><span>|</span><label class="collapse" for="c-38889069">[-]</label><label class="expand" for="c-38889069">[2 more]</label></div><br/><div class="children"><div class="content">When scientific code is not required to be published with its research literature who really knows how bad it is?</div><br/><div id="38889330" class="c"><input type="checkbox" id="c-38889330" checked=""/><div class="controls bullet"><span class="by">bsdpufferfish</span><span>|</span><a href="#38889069">parent</a><span>|</span><a href="#38889320">next</a><span>|</span><label class="collapse" for="c-38889330">[-]</label><label class="expand" for="c-38889330">[1 more]</label></div><br/><div class="children"><div class="content">A few responses come to mind. Who is requiring? What counts as code that needs to be published?<p>But perhaps the most relevant response is that few people read papers, even fewer are going to look into their zip. The whole idea of papers is to condense a whole lot of work into concise digestible information.</div><br/></div></div></div></div><div id="38889320" class="c"><input type="checkbox" id="c-38889320" checked=""/><div class="controls bullet"><span class="by">YouWhy</span><span>|</span><a href="#38889069">prev</a><span>|</span><a href="#38889413">next</a><span>|</span><label class="collapse" for="c-38889320">[-]</label><label class="expand" for="c-38889320">[1 more]</label></div><br/><div class="children"><div class="content">I think we have a case of survivorship bias.<p>A considerable majority of the science-non-SWE crowd are de facto incapable of writing more than 100 lines of runs-in-my-notebook code.<p>Hence, if a change&#x2F;bug is necessary, it is much likelier to fall under a SWE jurisdiction, and hence is much more likely to be industrial code.<p>Add to that a further confounder (tiptoeing a &quot;no true Scotsman&quot; here): academia is not a first choice of workplace for strong SWEs.</div><br/></div></div><div id="38889413" class="c"><input type="checkbox" id="c-38889413" checked=""/><div class="controls bullet"><span class="by">LudwigNagasena</span><span>|</span><a href="#38889320">prev</a><span>|</span><a href="#38888991">next</a><span>|</span><label class="collapse" for="c-38889413">[-]</label><label class="expand" for="c-38889413">[1 more]</label></div><br/><div class="children"><div class="content">I will believe that when scientists will stop being too embarrassed to publish their code. Do people not remember mrc-ide&#x2F;covid-sim?</div><br/></div></div><div id="38888991" class="c"><input type="checkbox" id="c-38888991" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#38889413">prev</a><span>|</span><a href="#38889145">next</a><span>|</span><label class="collapse" for="c-38888991">[-]</label><label class="expand" for="c-38888991">[3 more]</label></div><br/><div class="children"><div class="content">If the non programmers commit correctness bugs and the programmers are just using patterns you don&#x27;t like, maybe try to understand the patterns instead of balk at them.</div><br/><div id="38889190" class="c"><input type="checkbox" id="c-38889190" checked=""/><div class="controls bullet"><span class="by">aragilar</span><span>|</span><a href="#38888991">parent</a><span>|</span><a href="#38889066">next</a><span>|</span><label class="collapse" for="c-38889190">[-]</label><label class="expand" for="c-38889190">[1 more]</label></div><br/><div class="children"><div class="content">Define &quot;correctness bugs&quot;. Does the code leak memory (which is not ideal)? That&#x27;s only an issue for the scientist if it prevents&#x2F;invalidates the science. But if the pattern hides how something is expressed, or someone unfamiliar with the science tries refactoring the code, that&#x27;s more likely to cause issues with the science than the memory leak.</div><br/></div></div><div id="38889066" class="c"><input type="checkbox" id="c-38889066" checked=""/><div class="controls bullet"><span class="by">InSteady</span><span>|</span><a href="#38888991">parent</a><span>|</span><a href="#38889190">prev</a><span>|</span><a href="#38889145">next</a><span>|</span><label class="collapse" for="c-38889066">[-]</label><label class="expand" for="c-38889066">[1 more]</label></div><br/><div class="children"><div class="content">The author states they are primarily a software engineer and have also been guilty of following these patterns, so the clear implication is that they understand the patterns. The author isn&#x27;t making the case &quot;I don&#x27;t like it,&quot; they are making the case that these patterns actually lead to more and bigger problems in the field of scientific computing than the usually simple errors of ignorance committed by non-programmers.</div><br/></div></div></div></div><div id="38889145" class="c"><input type="checkbox" id="c-38889145" checked=""/><div class="controls bullet"><span class="by">quirkot</span><span>|</span><a href="#38888991">prev</a><span>|</span><a href="#38889363">next</a><span>|</span><label class="collapse" for="c-38889145">[-]</label><label class="expand" for="c-38889145">[1 more]</label></div><br/><div class="children"><div class="content">Good code is the simplest code you can write to get the job done.<p>Getting too excited about techniques is a form of scope creep</div><br/></div></div><div id="38889363" class="c"><input type="checkbox" id="c-38889363" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#38889145">prev</a><span>|</span><a href="#38889308">next</a><span>|</span><label class="collapse" for="c-38889363">[-]</label><label class="expand" for="c-38889363">[1 more]</label></div><br/><div class="children"><div class="content">Meh.<p>Who actually works as a software dev at one of these academic institutions? The pay is beyond terrible. Presumably you have either:<p>- Young and keen. Young and keen are the source of all kinds of terrible things. That’s why you need old and bitter to balance it out. Old and bitter is off working for much more money in a boring corporate.<p>- Side hustlers&#x2F;other incompetents. “I’m now a software dev!”<p>It’s not that proper software shops don’t struggle against “complexification” and all manner of other deviant behaviours. There are so many ways to turn software into hell - “All happy families are alike; each unhappy family is unhappy in its own way.” But if this is your problem, the problem isn’t “the software industry” or “best practice” or “devs jobs are so easy they just have to make up complexity”. The problem is incompetence. Managerial&#x2F;leadership incompetence.</div><br/></div></div><div id="38889308" class="c"><input type="checkbox" id="c-38889308" checked=""/><div class="controls bullet"><span class="by">a-dub</span><span>|</span><a href="#38889363">prev</a><span>|</span><a href="#38872541">next</a><span>|</span><label class="collapse" for="c-38889308">[-]</label><label class="expand" for="c-38889308">[1 more]</label></div><br/><div class="children"><div class="content">numerical code isn&#x27;t like application code. the rules of application code don&#x27;t always apply. for example, i think one character variable names are totally fine if they come from equations or papers where in most applications it&#x27;s generally frowned upon.<p>this is why i&#x27;m a little skeptical of languages that blur the lines. sometimes ideas from application programming can complicate numerical code and sometimes numerical programmers don&#x27;t fully understand the systems abstractions they&#x27;re building on and end up reinventing wheels to avoid simpler solutions they feared or didn&#x27;t know existed.<p>the moral of the story is to keep an open mind, to not be a zealot and to avoid dogmatic thinking.</div><br/></div></div><div id="38872541" class="c"><input type="checkbox" id="c-38872541" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#38889308">prev</a><span>|</span><a href="#38889052">next</a><span>|</span><label class="collapse" for="c-38872541">[-]</label><label class="expand" for="c-38872541">[8 more]</label></div><br/><div class="children"><div class="content">TL;DR: a counter-productive rant against software engineers, claiming that bad code from software engineers is worse than bad code from scientists.<p>Did you consider hiring an experienced software engineer as a lead?</div><br/><div id="38889152" class="c"><input type="checkbox" id="c-38889152" checked=""/><div class="controls bullet"><span class="by">aragilar</span><span>|</span><a href="#38872541">parent</a><span>|</span><a href="#38888972">next</a><span>|</span><label class="collapse" for="c-38889152">[-]</label><label class="expand" for="c-38889152">[2 more]</label></div><br/><div class="children"><div class="content">Bad code written by software engineers <i>is</i> worse than bad code written by scientists, as the former takes more effort to fix than the latter (given the pathologies mentioned). It&#x27;s naturally preferable to not have bad code, but it that choice was actually on the table, then I don&#x27;t know who would choose the bad code.<p>As for hiring software devs, that&#x27;s not going to change (in general, there are places where software devs write code used by scientists, but rarely are these codes themselves pushing research boundaries, it&#x27;s code on top it that does) absent significant changes in funding structure and rules (which are typically a government&#x2F;public service concern, and not up to researchers).</div><br/><div id="38889436" class="c"><input type="checkbox" id="c-38889436" checked=""/><div class="controls bullet"><span class="by">Faark</span><span>|</span><a href="#38872541">root</a><span>|</span><a href="#38889152">parent</a><span>|</span><a href="#38888972">next</a><span>|</span><label class="collapse" for="c-38889436">[-]</label><label class="expand" for="c-38889436">[1 more]</label></div><br/><div class="children"><div class="content">&gt; as the former takes more effort to fix than the latter<p>Disagree. Well, maybe still acceptable if the software is small &#x2F; limited to a single paper. Having worked on a code base the people writing it learned programming on that job, guessing their intention is like archeology. And each iteration tended to add some complicated interdependence. Or like when int errorCode came from other, overlapping error ranges.<p>A part of the &quot;new&quot; code base is exactly as described by TFA. Including most interfaces having only one implementation. But while annoying, I am more able to work on it without things breaking...</div><br/></div></div></div></div><div id="38888972" class="c"><input type="checkbox" id="c-38888972" checked=""/><div class="controls bullet"><span class="by">stalfosknight</span><span>|</span><a href="#38872541">parent</a><span>|</span><a href="#38889152">prev</a><span>|</span><a href="#38888976">next</a><span>|</span><label class="collapse" for="c-38888972">[-]</label><label class="expand" for="c-38888972">[1 more]</label></div><br/><div class="children"><div class="content">TFA seems to have hit a nerve.</div><br/></div></div><div id="38888976" class="c"><input type="checkbox" id="c-38888976" checked=""/><div class="controls bullet"><span class="by">namaria</span><span>|</span><a href="#38872541">parent</a><span>|</span><a href="#38888972">prev</a><span>|</span><a href="#38889052">next</a><span>|</span><label class="collapse" for="c-38888976">[-]</label><label class="expand" for="c-38888976">[4 more]</label></div><br/><div class="children"><div class="content">You know, 96% of businesses (and by extension codebases) have to get by software wise without high priced software engineers. They couldn&#x27;t afford it. The vast majority of running code is produced by people whose understanding of computer systems and programming goes as deep as how much documentation they need to ctrl+f through to get some specific tasks done.</div><br/><div id="38889075" class="c"><input type="checkbox" id="c-38889075" checked=""/><div class="controls bullet"><span class="by">nvy</span><span>|</span><a href="#38872541">root</a><span>|</span><a href="#38888976">parent</a><span>|</span><a href="#38889052">next</a><span>|</span><label class="collapse" for="c-38889075">[-]</label><label class="expand" for="c-38889075">[3 more]</label></div><br/><div class="children"><div class="content">&gt;The vast majority of running code is produced by people whose understanding of computer systems and programming goes as deep as how much documentation they need to ctrl+f through to get some specific tasks done.<p>I doubt this very much.  Surely the vast majority of running code is some chunk of Chrome, Android, or the JVM (&quot;billions of devices run Java...&quot;) or something. All those things were produced by software engineers with more than surface-level understanding.</div><br/><div id="38889317" class="c"><input type="checkbox" id="c-38889317" checked=""/><div class="controls bullet"><span class="by">bdowling</span><span>|</span><a href="#38872541">root</a><span>|</span><a href="#38889075">parent</a><span>|</span><a href="#38889251">next</a><span>|</span><label class="collapse" for="c-38889317">[-]</label><label class="expand" for="c-38889317">[1 more]</label></div><br/><div class="children"><div class="content">For every well-engineered application used by millions of users, you&#x27;ve got thousands of poorly-engineered, bespoke applications in use by one or two users (often internal corporate tools or expensive middleware with minimal customization besides changing the corporate branding).</div><br/></div></div><div id="38889251" class="c"><input type="checkbox" id="c-38889251" checked=""/><div class="controls bullet"><span class="by">namaria</span><span>|</span><a href="#38872541">root</a><span>|</span><a href="#38889075">parent</a><span>|</span><a href="#38889317">prev</a><span>|</span><a href="#38889052">next</a><span>|</span><label class="collapse" for="c-38889251">[-]</label><label class="expand" for="c-38889251">[1 more]</label></div><br/><div class="children"><div class="content">Maybe by instances of the same codebase, yeah absolutely.<p>But there is certainly more codebases out there running some python or js written by designers, data analysts etc then those produced and curated by software engineers.</div><br/></div></div></div></div></div></div></div></div><div id="38889052" class="c"><input type="checkbox" id="c-38889052" checked=""/><div class="controls bullet"><span class="by">briantakita</span><span>|</span><a href="#38872541">prev</a><span>|</span><a href="#38889178">next</a><span>|</span><label class="collapse" for="c-38889052">[-]</label><label class="expand" for="c-38889052">[1 more]</label></div><br/><div class="children"><div class="content">Some people incorporate antipatterns into their practice &amp; reinforce these antipatterns with years of experience. All fields have this issue. Bad professional scientists are often worse than effective amateur scientists. Having good first principles with little experience often beats plenty of experience with bad first principles.<p>I have learned to appreciate codebases which break some rules &amp; yet are easier to maintain for some reason(s) Distilling the reason(s) identifies areas where I can modify my technique...or at least help identify questions &amp; alternatives to some techniques that I regularly use.</div><br/></div></div></div></div></div></div></div></body></html>