<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700730064108" as="style"/><link rel="stylesheet" href="styles.css?v=1700730064108"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://gpuopen.com/learn/how_do_you_become_a_graphics_programmer/">How do I become a graphics programmer?</a> <span class="domain">(<a href="https://gpuopen.com">gpuopen.com</a>)</span></div><div class="subtext"><span>pjmlp</span> | <span>125 comments</span></div><br/><div><div id="38386259" class="c"><input type="checkbox" id="c-38386259" checked=""/><div class="controls bullet"><span class="by">stemlord</span><span>|</span><a href="#38390788">next</a><span>|</span><label class="collapse" for="c-38386259">[-]</label><label class="expand" for="c-38386259">[19 more]</label></div><br/><div class="children"><div class="content">I would suggest that beginners not lead with &quot;which tools should I capitalize on&quot; and instead, take a step back and ask &quot;what do I want to make&quot;? Don&#x27;t lose focus on the final output as you make your first steps. In the world of computer graphics today there are so many tools that abstract away various steps in the process of drawing pixels to the screen that you could very easily waste too much time suffering with low level code up-front and then later realize that the niche field in the wide array of industries that utilize graphics programming that you want to pursue actually only hires people who use Unity, TouchDesigner, threejs, and after effects and don&#x27;t actually write a lick of C++ unless push comes to shove, and even then they might just contract an outside engineer for it.<p>Not to say that learning how things work on the ground level isn&#x27;t immeasureably valuable, but I think trying to do that first is the slow approach. Learning is accelerated when 1) you enter the industry (so you should prioritize output up-front and let the deeper learning happen when you&#x27;re earning a paycheck for it) and 2) you get a better conceptual understanding of what&#x27;s happening under the hood offered by tools of abstraction like a game engine or visual programming paradigm.<p>This comes from someone who spent many years trying to learn cpp and opengl the hard way only to endure a long battle against an internal sunk cost fallacy I&#x27;ve harbored that kept me from taking the no-code approach. Don&#x27;t waste your time taking this path if it doesn&#x27;t help you make what you actually want to be making at the end of the day.</div><br/><div id="38387731" class="c"><input type="checkbox" id="c-38387731" checked=""/><div class="controls bullet"><span class="by">ryandrake</span><span>|</span><a href="#38386259">parent</a><span>|</span><a href="#38390721">next</a><span>|</span><label class="collapse" for="c-38387731">[-]</label><label class="expand" for="c-38387731">[10 more]</label></div><br/><div class="children"><div class="content">Listen to this guy, great advice. Early in my career, I set out to become an &quot;OpenGL expert&quot; and I&#x27;d say I mostly got there. I mean I&#x27;m no Mark Kilgard and haven&#x27;t written any textbooks, but I dove super deep into the technology, and gained at least a decade of experience working on all levels of the API from the driver level to conformance tests and performance tuning, up the stack to game and application code, and across each major desktop and mobile platform.<p>Where did it get me? Not very far, really. First of all, almost nobody cares about OpenGL anymore--it&#x27;s kind of dead with the two major OS vendors finally abandoning it. Go to any &quot;HN Who&#x27;s Hiring&quot; and text search for OpenGL. Sure, I could have gone and re-skilled and learned another similar graphics API, but the second problem is nobody really needs people who write low-level Direct3D or Vulkan or Metal anymore because that&#x27;s all abstracted for you by engines. And there are max 5 or 6 companies in the world that even have the need for people who can do low-level graphics drivers. It&#x27;s a career-limiting niche.<p>The smaller the piece of the machine you focus on, the more of a world-class expert you need to become in order to make it your whole career. So, unless your plan includes becoming the next John Carmack or something, I&#x27;d recommend going broad rather than deep.</div><br/><div id="38389493" class="c"><input type="checkbox" id="c-38389493" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38386259">root</a><span>|</span><a href="#38387731">parent</a><span>|</span><a href="#38389893">next</a><span>|</span><label class="collapse" for="c-38389493">[-]</label><label class="expand" for="c-38389493">[2 more]</label></div><br/><div class="children"><div class="content">I feel like better expertise targets tend to be more durable. In other words, rather than expert in a specific technology or technique, the best experts had the ability to develop expertise in any given technology within a space and often overlapped cursory knowledge with other spaces. I met plenty of graphics experts at Oculus and they didn’t care so much about whether it was D3D or Vulkan - originally they were D3D engineers for PCVR and then a good chunk of them shifted to Vulkan once the focus shifted to mobile VR. They just knew how those APIs mapped to the actual HW reality, how things connected, why things were slow, how to improve performance, etc. The mundane stuff of “what is the sequence of steps to do X in Vulkan” is answered by Google&#x2F;StackOverflow (or even these days ChatGPT). Heck, a good chunk of them were creating their own new APIs. This isn’t unique to Meta by the way. It’s like engineers who say they’re “C” or “C++ experts”. With the exception of authors like Scott Meyers or people working on the C++ language spec who I think can truly maybe claim that title, the kind of thing that is called a “language X expert” is the kind of expertise that a good engineer should be able to develop in any language with 2-3 years of practice and proficient mastery within ~3-12 months because the true expertise is the underlying CS principles (at least for a family of languages - I’ve never done too much with non-Algol families so I don’t know how I’d fare there).<p>However, I do agree that generally graphics engineer is a niche limited to the few people working on gaming engines, VR R&amp;D, or animation R&amp;D. But those skills, at least today, are generally transferable to AI engineering because GPU compute plays such a huge role. There’s less graphics programming of course and the APIs for GPU compute are a bit different, but AFAIK many of the hardware concepts remain (e.g. wavefronts, how GPUs do threading, etc etc).</div><br/><div id="38390037" class="c"><input type="checkbox" id="c-38390037" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38386259">root</a><span>|</span><a href="#38389493">parent</a><span>|</span><a href="#38389893">next</a><span>|</span><label class="collapse" for="c-38390037">[-]</label><label class="expand" for="c-38390037">[1 more]</label></div><br/><div class="children"><div class="content">When people like Bjarne Stroustoup, Herb Suttter, Andrei Alexandrescu say they are by no means a C++ expert, always beware of anyone that says otherwise.<p>Same applies to most languages, unless they are talking about toy languages.<p>Even something like C or Go, have so much room to debunk such experts. Between compilers, versions, language evolution, runtime, standard library, OS specific behaviours,....</div><br/></div></div></div></div><div id="38389893" class="c"><input type="checkbox" id="c-38389893" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#38386259">root</a><span>|</span><a href="#38387731">parent</a><span>|</span><a href="#38389493">prev</a><span>|</span><a href="#38388507">next</a><span>|</span><label class="collapse" for="c-38389893">[-]</label><label class="expand" for="c-38389893">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s pretty sad. Without people like you, the engines all the others use would not exist. It always saddens me to see people making millions off of high level tools while the people who made it possible get limited returns.</div><br/></div></div><div id="38388507" class="c"><input type="checkbox" id="c-38388507" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#38386259">root</a><span>|</span><a href="#38387731">parent</a><span>|</span><a href="#38389893">prev</a><span>|</span><a href="#38390437">next</a><span>|</span><label class="collapse" for="c-38388507">[-]</label><label class="expand" for="c-38388507">[5 more]</label></div><br/><div class="children"><div class="content">But without people like you (who understands the low-level graphics programming), the development of engine will completely stagnate.</div><br/><div id="38389153" class="c"><input type="checkbox" id="c-38389153" checked=""/><div class="controls bullet"><span class="by">BobbyJo</span><span>|</span><a href="#38386259">root</a><span>|</span><a href="#38388507">parent</a><span>|</span><a href="#38390437">next</a><span>|</span><label class="collapse" for="c-38389153">[-]</label><label class="expand" for="c-38389153">[4 more]</label></div><br/><div class="children"><div class="content">And without slaves, the pyramids would never have been built.</div><br/><div id="38390643" class="c"><input type="checkbox" id="c-38390643" checked=""/><div class="controls bullet"><span class="by">ywain</span><span>|</span><a href="#38386259">root</a><span>|</span><a href="#38389153">parent</a><span>|</span><a href="#38390456">next</a><span>|</span><label class="collapse" for="c-38390643">[-]</label><label class="expand" for="c-38390643">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I understand how your analogy is relevant to the discussion, but you should know that the current consensus is that the pyramids were build by paid laborers, not slaves. Cf. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Slavery_in_ancient_Egypt#Great_Pyramids_not_built_by_slaves" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Slavery_in_ancient_Egypt#Great...</a></div><br/></div></div><div id="38390456" class="c"><input type="checkbox" id="c-38390456" checked=""/><div class="controls bullet"><span class="by">nahumfarchi</span><span>|</span><a href="#38386259">root</a><span>|</span><a href="#38389153">parent</a><span>|</span><a href="#38390643">prev</a><span>|</span><a href="#38389500">next</a><span>|</span><label class="collapse" for="c-38390456">[-]</label><label class="expand" for="c-38390456">[1 more]</label></div><br/><div class="children"><div class="content">That escalated quickly</div><br/></div></div><div id="38389500" class="c"><input type="checkbox" id="c-38389500" checked=""/><div class="controls bullet"><span class="by">thejazzman</span><span>|</span><a href="#38386259">root</a><span>|</span><a href="#38389153">parent</a><span>|</span><a href="#38390456">prev</a><span>|</span><a href="#38390437">next</a><span>|</span><label class="collapse" for="c-38389500">[-]</label><label class="expand" for="c-38389500">[1 more]</label></div><br/><div class="children"><div class="content">yikes.</div><br/></div></div></div></div></div></div><div id="38390437" class="c"><input type="checkbox" id="c-38390437" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#38386259">root</a><span>|</span><a href="#38387731">parent</a><span>|</span><a href="#38388507">prev</a><span>|</span><a href="#38390721">next</a><span>|</span><label class="collapse" for="c-38390437">[-]</label><label class="expand" for="c-38390437">[1 more]</label></div><br/><div class="children"><div class="content">Focusing on a single technology never was a great idea though. Even already towards the end of the 90&#x27;s D3D was the better choice on Windows, so one had to write code against multiple 3D APIs anyway. This also gives a better perspective where the strengths and weaknesses of the different technologies are and it makes it easier to learn new APIs. But in the end, 3D APIs are just a utility to write applications (mostly games), not to build one&#x27;s career upon. 3D APIs come and go and are (to some degree) also subject to fashion cycles, the underlying GPU hardware develops a lot more predictable than 3D APIs (e.g. especially Vulkan had pretty bad &quot;mood swings&quot; recently).<p>Of course when focusing strictly on money and &quot;career growth&quot;, going into game development is a pretty bad idea to begin with ;)</div><br/></div></div></div></div><div id="38390721" class="c"><input type="checkbox" id="c-38390721" checked=""/><div class="controls bullet"><span class="by">beAbU</span><span>|</span><a href="#38386259">parent</a><span>|</span><a href="#38387731">prev</a><span>|</span><a href="#38389359">next</a><span>|</span><label class="collapse" for="c-38390721">[-]</label><label class="expand" for="c-38390721">[1 more]</label></div><br/><div class="children"><div class="content">This is the classic trap that new developers step in all the time. It&#x27;s not just associated with graphics programming.<p>Youtube is full of beginner programming videos that take the developer through a journey of learning a stack of technologies in stead of focusing on something interesting to build. You end up with a lot of cargo-culting, and these massively complex Ruby Goldberg contraptions to render some text on a web-page. All in the name of padding out that CV.<p>When I was in university I dabbled with some graphics programming for a semester, and I found it was sufficiently complex that the only reasonable answer to &quot;what do I want to make&quot; was &quot;render a green triangle on a black background&quot;. Going from there to square, to cube, to sphere, to animated sphere, to bouncing ball, is a logical progression and it helps you stay focussed on the prize. So don&#x27;t also make the mistake of answering the above question with &quot;first person shooter with ray-traced lighting and subsurface scattering&quot;.<p>I can promise you the first iteration of a bouncing ball will be truly horrible code. But that&#x27;s fine. Over time you&#x27;ll figure out how to optimise and improve things. And let me tell you, there&#x27;s nothing as invigorating as discovering a design pattern by yourself: reading a book on a new topic and going &quot;hey I&#x27;m already doing that!&quot;</div><br/></div></div><div id="38389359" class="c"><input type="checkbox" id="c-38389359" checked=""/><div class="controls bullet"><span class="by">TheRoque</span><span>|</span><a href="#38386259">parent</a><span>|</span><a href="#38390721">prev</a><span>|</span><a href="#38387054">next</a><span>|</span><label class="collapse" for="c-38389359">[-]</label><label class="expand" for="c-38389359">[4 more]</label></div><br/><div class="children"><div class="content">Well, as someone looking to get into this field, I kind of disagree. A lot (if not all) job postings about graphics programming require you to know C++ beforehand. Sure, you can have another role, like gameplay programmer, and slowly work your way in graphics, and it&#x27;s probably easier to do so, but in fine, for the graphics programmer role, C++ is required.<p>What you are describing is more about someone who wants to be productive with graphical stuff fast, but it&#x27;s not graphics programming.</div><br/><div id="38390189" class="c"><input type="checkbox" id="c-38390189" checked=""/><div class="controls bullet"><span class="by">meheleventyone</span><span>|</span><a href="#38386259">root</a><span>|</span><a href="#38389359">parent</a><span>|</span><a href="#38390496">next</a><span>|</span><label class="collapse" for="c-38390189">[-]</label><label class="expand" for="c-38390189">[1 more]</label></div><br/><div class="children"><div class="content">There’s two or three strands of graphics programming though:<p>Plumbing - Delivering data efficiently from the game engine to the GPU often in a platform agnostic way with efficient implementations underneath.<p>Art Pipeline - Delivering data efficiently from the artist tools to the game engine.<p>GPU Programming - Creating visual effects, shaders, compute shaders and tools around these to empower artists.<p>All of these use multiple languages, sure C++ is a common one and good to know (likewise as a gameplay programmer) but the bigger percentage of what you need to know as a graphics programmer isn’t how to write C++ but the concepts you’re trying to implement with it.<p>There’s also R&amp;D but it’s a much smaller part of things.</div><br/></div></div><div id="38390496" class="c"><input type="checkbox" id="c-38390496" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#38386259">root</a><span>|</span><a href="#38389359">parent</a><span>|</span><a href="#38390189">prev</a><span>|</span><a href="#38390082">next</a><span>|</span><label class="collapse" for="c-38390496">[-]</label><label class="expand" for="c-38390496">[1 more]</label></div><br/><div class="children"><div class="content">People shouldn&#x27;t be disillusioned though when they find out that there&#x27;s not such a big need for the traditional role of graphics programmer who wrestles directly with lighting models in shader code and shadow rendering implementations. 95% (or so) of game industry jobs is plumbing engine-provided components together, writing some very high level gameplay code and maybe a bit of inhouse tools development. The hard rendering tasks are done by a handful engines now, and currently the pendulum seems to swing away from inhouse engines towards UE5 again.</div><br/></div></div><div id="38390082" class="c"><input type="checkbox" id="c-38390082" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38386259">root</a><span>|</span><a href="#38389359">parent</a><span>|</span><a href="#38390496">prev</a><span>|</span><a href="#38387054">next</a><span>|</span><label class="collapse" for="c-38390082">[-]</label><label class="expand" for="c-38390082">[1 more]</label></div><br/><div class="children"><div class="content">First learn the foundations, then the language.<p>When I started, graphics programming was all about Assembly.<p>Then it was about Object Pascal and C, then it was about C++, now it also requires C#.<p>And who knows, maybe in 20 years, one of the C++ wannabe replacements manages to also have a spot, or some AI driven thingie.<p>Those will solid foundations in graphics programming algorithms, will manage regardless of the language.</div><br/></div></div></div></div><div id="38387054" class="c"><input type="checkbox" id="c-38387054" checked=""/><div class="controls bullet"><span class="by">captainkrtek</span><span>|</span><a href="#38386259">parent</a><span>|</span><a href="#38389359">prev</a><span>|</span><a href="#38390242">next</a><span>|</span><label class="collapse" for="c-38387054">[-]</label><label class="expand" for="c-38387054">[1 more]</label></div><br/><div class="children"><div class="content">This is great advice. I think it’s a common trap when I see questions like “what language should I learn&#x2F;what language is the best”, which skip the point of “what would you like to build”. The tools change with time, and the best engineers in my experience generally know how to use a variety of tools with varying degrees of skill rather than be super deep in a single one.</div><br/></div></div><div id="38390242" class="c"><input type="checkbox" id="c-38390242" checked=""/><div class="controls bullet"><span class="by">nullptr_deref</span><span>|</span><a href="#38386259">parent</a><span>|</span><a href="#38387054">prev</a><span>|</span><a href="#38389621">next</a><span>|</span><label class="collapse" for="c-38390242">[-]</label><label class="expand" for="c-38390242">[1 more]</label></div><br/><div class="children"><div class="content">This is hands down the reality and the best advice out there. No one cares if you are able to do vulkan for 8 years EXCEPT for research labs.<p>And getting there requires that - you either have a PhD or the exact experience (threeJS, unity etc) as above because that will help you set foot on industry effectively allowing you to work on higher abstraction and slowly&#x2F;rapidly decent into low level code.</div><br/></div></div></div></div><div id="38390788" class="c"><input type="checkbox" id="c-38390788" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#38386259">prev</a><span>|</span><a href="#38387082">next</a><span>|</span><label class="collapse" for="c-38390788">[-]</label><label class="expand" for="c-38390788">[1 more]</label></div><br/><div class="children"><div class="content">I have the horrible feeling that, if you start to become a graphics programmer now, by the time you&#x27;re done, AI will be doing it.<p>If you want to make games, learn a game engine. The big 3D ones are Unity (not too hard), Unreal Engine (hard, used for AAA titles), and Bevy (in Rust, open source.)
There are a ton of 2D engines, mostly used to do retro stuff.</div><br/></div></div><div id="38387082" class="c"><input type="checkbox" id="c-38387082" checked=""/><div class="controls bullet"><span class="by">quelsolaar</span><span>|</span><a href="#38390788">prev</a><span>|</span><a href="#38386333">next</a><span>|</span><label class="collapse" for="c-38387082">[-]</label><label class="expand" for="c-38387082">[3 more]</label></div><br/><div class="children"><div class="content">As a graphics programmer i think its good to have a well rounded idea about how graphics works. Here are some things I would expect a good graphics programmer to know, beyond just programming and an API:<p>-Rotation view and projection matrices, and general vector math.<p>-Shader programming.<p>-Procedural primitives like voronoi, SDF and perlin.<p>-Image Compositing.<p>-Forward and deferred rendering.<p>-Various sampling techniques.<p>-Shadow and lighting techniques.<p>-Knowing a bit about how the art pipeline works and how to get data out of 3D apps.<p>-Being comfortable using a profiler and debugger.<p>-Capable of reading Siggraph papers.<p>-Knowing various spacial partitioning and volume hierarchy techniques.<p>-Being able to build a simple raytracer.<p>-Good understanding of primitives, like sprites, triangles n-gons and so on.<p>-Some particle and simulation experience.</div><br/><div id="38390410" class="c"><input type="checkbox" id="c-38390410" checked=""/><div class="controls bullet"><span class="by">rajangdavis</span><span>|</span><a href="#38387082">parent</a><span>|</span><a href="#38386333">next</a><span>|</span><label class="collapse" for="c-38390410">[-]</label><label class="expand" for="c-38390410">[2 more]</label></div><br/><div class="children"><div class="content">Where do you learn this stuff?</div><br/><div id="38390731" class="c"><input type="checkbox" id="c-38390731" checked=""/><div class="controls bullet"><span class="by">rustybolt</span><span>|</span><a href="#38387082">root</a><span>|</span><a href="#38390410">parent</a><span>|</span><a href="#38386333">next</a><span>|</span><label class="collapse" for="c-38390731">[-]</label><label class="expand" for="c-38390731">[1 more]</label></div><br/><div class="children"><div class="content">Googling it works pretty well</div><br/></div></div></div></div></div></div><div id="38386333" class="c"><input type="checkbox" id="c-38386333" checked=""/><div class="controls bullet"><span class="by">Buttons840</span><span>|</span><a href="#38387082">prev</a><span>|</span><a href="#38389784">next</a><span>|</span><label class="collapse" for="c-38386333">[-]</label><label class="expand" for="c-38386333">[28 more]</label></div><br/><div class="children"><div class="content">I&#x27;d recommend the Pikuma course Graphics From Scratch[0]. The first thing you do is write a set_pixel function utilizing SDL and the rest of the course is all your code, every matrix operation, every vertex transformation, every triangle rasterization. You calculate what every individual pixel should be colored.<p>[0]: <a href="https:&#x2F;&#x2F;pikuma.com&#x2F;courses&#x2F;learn-3d-computer-graphics-programming" rel="nofollow noreferrer">https:&#x2F;&#x2F;pikuma.com&#x2F;courses&#x2F;learn-3d-computer-graphics-progra...</a></div><br/><div id="38388448" class="c"><input type="checkbox" id="c-38388448" checked=""/><div class="controls bullet"><span class="by">rmshin</span><span>|</span><a href="#38386333">parent</a><span>|</span><a href="#38386922">next</a><span>|</span><label class="collapse" for="c-38388448">[-]</label><label class="expand" for="c-38388448">[1 more]</label></div><br/><div class="children"><div class="content">Just wanted to second this recommendation. I did the course a few months ago with near-zero baseline in graphics programming (though a few years&#x27; experience as a standard swe), and it gave me a pretty decent grasp of how 3d shapes get drawn on the screen. Afterwards I was able to pick up webgpu in a matter of days, which I don&#x27;t think would&#x27;ve been possible without the understanding I gained from the course.<p>If anyone&#x27;s looking for motivation, I made a wasm-compiled demo of the renderer you produce by the end - <a href="https:&#x2F;&#x2F;rmshin.github.io&#x2F;3d-renderer-wasm" rel="nofollow noreferrer">https:&#x2F;&#x2F;rmshin.github.io&#x2F;3d-renderer-wasm</a></div><br/></div></div><div id="38386922" class="c"><input type="checkbox" id="c-38386922" checked=""/><div class="controls bullet"><span class="by">starmole</span><span>|</span><a href="#38386333">parent</a><span>|</span><a href="#38388448">prev</a><span>|</span><a href="#38386367">next</a><span>|</span><label class="collapse" for="c-38386922">[-]</label><label class="expand" for="c-38386922">[2 more]</label></div><br/><div class="children"><div class="content">I find this very interesting. I have been toying around how I would design a graphics 101 course myself. Should it start with putpixel style sdl code like we did in the 90s? Or start with shadertoy? 
Of course basic matrix math is always important. But how to teach rasterizing a triangle? Can we skip to homogenous coordinates and quad trees without going through scan lines? 
Should we really teach Phong shading or can we move straight to BRDFs?
Some parts might be teaching &quot;old hacks&quot; instead of relevant skills.
Statistics and sampling are way more important today. 
I believe graphics is getting more &quot;mathy&quot; every year. 
So learn math, teach math.</div><br/><div id="38389307" class="c"><input type="checkbox" id="c-38389307" checked=""/><div class="controls bullet"><span class="by">corysama</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38386922">parent</a><span>|</span><a href="#38386367">next</a><span>|</span><label class="collapse" for="c-38389307">[-]</label><label class="expand" for="c-38389307">[1 more]</label></div><br/><div class="children"><div class="content">I started with putting pixels in MCGA to CPU rasterize phong shaded triangles, and I don’t recommend it.<p>Instead, I’d recommend<p><a href="https:&#x2F;&#x2F;learnopengl.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;learnopengl.com&#x2F;</a>
<a href="https:&#x2F;&#x2F;raytracing.github.io&#x2F;books&#x2F;RayTracingInOneWeekend.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;raytracing.github.io&#x2F;books&#x2F;RayTracingInOneWeekend.ht...</a>
<a href="https:&#x2F;&#x2F;fgiesen.wordpress.com&#x2F;2011&#x2F;07&#x2F;09&#x2F;a-trip-through-the-graphics-pipeline-2011-index&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;fgiesen.wordpress.com&#x2F;2011&#x2F;07&#x2F;09&#x2F;a-trip-through-the-...</a>
<a href="https:&#x2F;&#x2F;foundationsofgameenginedev.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;foundationsofgameenginedev.com&#x2F;</a>
<a href="https:&#x2F;&#x2F;youtu.be&#x2F;j-A0mwsJRmk" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;j-A0mwsJRmk</a><p>Though, if you really do want to put pixels, this is how you should do it: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;CoryBloyd&#x2F;6725bb78323bb1157ff8d4175d42d789" rel="nofollow noreferrer">https:&#x2F;&#x2F;gist.github.com&#x2F;CoryBloyd&#x2F;6725bb78323bb1157ff8d4175d...</a></div><br/></div></div></div></div><div id="38386367" class="c"><input type="checkbox" id="c-38386367" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38386333">parent</a><span>|</span><a href="#38386922">prev</a><span>|</span><a href="#38389784">next</a><span>|</span><label class="collapse" for="c-38386367">[-]</label><label class="expand" for="c-38386367">[24 more]</label></div><br/><div class="children"><div class="content">&gt;No GPU, no OpenGL, no DirectX!<p>This is the opposite of what you would hope to see for learning graphics programming.</div><br/><div id="38386568" class="c"><input type="checkbox" id="c-38386568" checked=""/><div class="controls bullet"><span class="by">ChuckMcM</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38386367">parent</a><span>|</span><a href="#38386677">next</a><span>|</span><label class="collapse" for="c-38386568">[-]</label><label class="expand" for="c-38386568">[10 more]</label></div><br/><div class="children"><div class="content">I feel like this comment perfectly captures the difference between programming and coding.<p>Programming comes from a place of first principles, the goal being to understand what is needed completely so that a solution that meets many parallel constraints can be constructed.<p>Coding comes from a place of completing a task, the goal being to get from the requirement to the operating task in as short a time as possible so that one might move on to the next task.<p>Both disciplines have value. The original question was unclear about where the author hoped to end up.<p>To put this in a slightly different perspective, a graphics <i>programmer</i> can write a program to show a shaded object on any platform with a CPU and a way to display graphics. A graphics <i>coder</i> can write a program to show a shaded object only on those platforms where they have previously mastered the APIs for generating display graphics.</div><br/><div id="38387010" class="c"><input type="checkbox" id="c-38387010" checked=""/><div class="controls bullet"><span class="by">lackbeard</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38386568">parent</a><span>|</span><a href="#38386826">next</a><span>|</span><label class="collapse" for="c-38387010">[-]</label><label class="expand" for="c-38387010">[3 more]</label></div><br/><div class="children"><div class="content">Good comment, and, basically, I fully agree, except, I really dislike your attempt to appropriate the words &quot;programming&quot; and &quot;coding&quot; here. Like, can you just explain what you mean without trying to redefine terms that have broadly accepted definitions distinct from how you&#x27;re trying to use them here?<p>(Sorry, this probably sounds more critical than I&#x27;m intending...)</div><br/><div id="38387469" class="c"><input type="checkbox" id="c-38387469" checked=""/><div class="controls bullet"><span class="by">ChuckMcM</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38387010">parent</a><span>|</span><a href="#38387667">next</a><span>|</span><label class="collapse" for="c-38387469">[-]</label><label class="expand" for="c-38387469">[1 more]</label></div><br/><div class="children"><div class="content">No worries, got to use something as the holder of the definition. FWIW I read a similar essay that discussed cooks and chefs and came away seeing the many parallels with programming and coding.</div><br/></div></div><div id="38387667" class="c"><input type="checkbox" id="c-38387667" checked=""/><div class="controls bullet"><span class="by">caslon</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38387010">parent</a><span>|</span><a href="#38387469">prev</a><span>|</span><a href="#38386826">next</a><span>|</span><label class="collapse" for="c-38387667">[-]</label><label class="expand" for="c-38387667">[1 more]</label></div><br/><div class="children"><div class="content">Programming requires creative thinking. Coding, historically, was a lower-paid, unskilled position.<p>You may think this is redefinition. It&#x27;s not. This is how both terms <i>originated.</i> A &quot;coder&quot; did the unskilled gruntwork of implementation for business projects, while a programmer was holistic.<p>&gt; I find it bizarre that people now use the term &quot;coding&quot; to mean programming. For decades, we used the word &quot;coding&quot; for the work of low-level staff in a business programming team. The designer would write a detailed flow chart, then the &quot;coders&quot; would write code to implement the flow chart. This is quite different from what we did and do in the hacker community -- with us, one person designs the program and writes its code as a single activity. When I developed GNU programs, that was programming, but it was definitely not coding.<p>&gt; Since I don&#x27;t think the recent fad for &quot;coding&quot; is an improvement, I have decided not to adopt it. I don&#x27;t use the term &quot;coding&quot;, unless I am talking about a business programming team which has coders.<p><a href="https:&#x2F;&#x2F;stallman.org&#x2F;stallman-computing.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;stallman.org&#x2F;stallman-computing.html</a><p>In this case, it is you, and the wider cottage industry of business &quot;coders&quot; who are doing the appropriation. It&#x27;s not your fault. The bootcamp or Super Cool Totally Serious College you likely learned from probably used the term &quot;coder&quot; alongside words like &quot;rockstar!&quot; You were given a bad definition, and never knew any better at all. ChuckMcM&#x27;s comment, on the other hand, is correct. Using the word &quot;literally&quot; to mean &quot;figuratively,&quot; while colloquial, is still less correct than figuratively.<p>The phrase &quot;code monkey&quot; is not a compliment, and didn&#x27;t come from nowhere. It came directly from these pre-existing definitions.<p>Programming requires logic. If you are coding, the thinking&#x27;s already been done for you. You are just doing unskilled labor akin to data entry to get the computer to actually follow the instructions.</div><br/></div></div></div></div><div id="38386826" class="c"><input type="checkbox" id="c-38386826" checked=""/><div class="controls bullet"><span class="by">NikolaNovak</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38386568">parent</a><span>|</span><a href="#38387010">prev</a><span>|</span><a href="#38387599">next</a><span>|</span><label class="collapse" for="c-38386826">[-]</label><label class="expand" for="c-38386826">[1 more]</label></div><br/><div class="children"><div class="content">I like the distinction, and I think there should exist different terms, but I don&#x27;t think those two are nearly universal. Many people will use them interchangeably, others may even think other way around (&quot;programming&quot; as a professional discipline where you use tools to achieve an MVP most efficiently, vs &quot;coding&quot; as an enthusiastic activity that&#x27;s more creative and open ended).</div><br/></div></div><div id="38387599" class="c"><input type="checkbox" id="c-38387599" checked=""/><div class="controls bullet"><span class="by">dkjaudyeqooe</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38386568">parent</a><span>|</span><a href="#38386826">prev</a><span>|</span><a href="#38386894">next</a><span>|</span><label class="collapse" for="c-38387599">[-]</label><label class="expand" for="c-38387599">[1 more]</label></div><br/><div class="children"><div class="content">There is a lot to be said for understanding things from first principles, but not everyone wants to go that low. Not everyone is that nerdy or maybe hasn&#x27;t the time or motivation.<p>The other issue is that not everyone learns well from the bottom up. I believe that top down is a much better way of learning anything, and lets you progressively get closer to first principles while not discouraging learners with a steep difficulty curve. But unfortunately is an approach that is seldom facilitated by anyone.</div><br/></div></div><div id="38386894" class="c"><input type="checkbox" id="c-38386894" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38386568">parent</a><span>|</span><a href="#38387599">prev</a><span>|</span><a href="#38386893">next</a><span>|</span><label class="collapse" for="c-38386894">[-]</label><label class="expand" for="c-38386894">[2 more]</label></div><br/><div class="children"><div class="content">2D graphics with bitblits is a completely different paradigm. If you were using 2D GPUs from the 90s, or maybe a 2D Industrial PC&#x27;s GPU, sure... Learning about Bitblits and rects is good.<p>But if your goal is to program a modern shader on a modern platform (even if it&#x27;s a 2D graphic), you should learn a modern graphics library.<p>-------<p>A modern graphics API is laid out the way it is: to maximize modern performance on modern systems. A first principles bottom up approach will absolutely cover shaders (maybe compute shaders are easiest?)</div><br/><div id="38388390" class="c"><input type="checkbox" id="c-38388390" checked=""/><div class="controls bullet"><span class="by">crq-yml</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38386894">parent</a><span>|</span><a href="#38386893">next</a><span>|</span><label class="collapse" for="c-38388390">[-]</label><label class="expand" for="c-38388390">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a lot of leeway to learn 3D principles through a basic software rasterizer. It does not take long - if you already have some awareness of the math, it&#x27;s at most a few weeks to work through the essentials from a tutorial. Once you get to the point where you&#x27;re drawing filled triangles through a projected camera, you can move on. There&#x27;s no need to go into occlusion culling  strategies, texture mapping or lighting calculations, or really to make the rasterizer fast in any way. That wouldn&#x27;t be the point of the exercise. It could be done entirely with a fixed-size bitmap and a setPixel(x, y, v) call.<p>The argument against &quot;just&quot; using the hardware is that the hardware resists learning that conceptual skeleton. Instead of learning how a rasterizer is implemented, you learn the specific API incantation to bring one up, and that has changed a lot over the years in the direction of being a more professionalized phenomenon, so now it&#x27;s much easier to start application top-down, from within a premade rendering environment like a game engine or Blender&#x27;s rasterizers.<p>Learning to work on production rendering engines would involve reading and studying existing implementations, reading the relevant research papers along the way.</div><br/></div></div></div></div><div id="38386893" class="c"><input type="checkbox" id="c-38386893" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38386568">parent</a><span>|</span><a href="#38386894">prev</a><span>|</span><a href="#38386677">next</a><span>|</span><label class="collapse" for="c-38386893">[-]</label><label class="expand" for="c-38386893">[2 more]</label></div><br/><div class="children"><div class="content">Your definitions are made up.<p>Programming refers to the act of writing a program for a computer to follow.<p>Coding refers to the act of writing code for a computer.<p>Edit: The definitions are not commonly used this way and in fact I&#x27;ve heard other people even give opposite definitions to what correponds to which word.</div><br/><div id="38386975" class="c"><input type="checkbox" id="c-38386975" checked=""/><div class="controls bullet"><span class="by">javajosh</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38386893">parent</a><span>|</span><a href="#38386677">next</a><span>|</span><label class="collapse" for="c-38386975">[-]</label><label class="expand" for="c-38386975">[1 more]</label></div><br/><div class="children"><div class="content">Hate to break it to you, but all definitions are made up. The question is whether or not the distinction is useful or not. In my opinion, it seems useful to distinguish between understanding oriented tasks and goal oriented tasks.</div><br/></div></div></div></div></div></div><div id="38386677" class="c"><input type="checkbox" id="c-38386677" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38386367">parent</a><span>|</span><a href="#38386568">prev</a><span>|</span><a href="#38386840">next</a><span>|</span><label class="collapse" for="c-38386677">[-]</label><label class="expand" for="c-38386677">[7 more]</label></div><br/><div class="children"><div class="content">Personally... I disagree. The course says:<p>&gt; You&#x27;ll learn how a software 3D engine works under the hood, and ... write a complete <i>software rasterizer</i> from scratch<p>Writing a software rasteriser is a <i>fantastic</i> way to learn the classic graphics pipeline, Every <i>single</i> aspect of said pipeline offers scope for one to learn more about how GPUs work, and the algorithms behind them. This would be immensely educational to a new graphics developer.<p>Vertex processing, including fast, efficient file parsing, vertex data layout and storage, and optimisation.<p>Fast primitive assembly from vertices, including line-drawing and interpolation algorithms.<p>Texture mipmapping, and mapping.<p>The rasterisation phase itself offers tons of opportunity, from Bresenham&#x27;s line drawing algorithm to supersampling, tiled rendering, parallelisation, and efficient memory layouts for cache locality.<p>Clipping, culling, hidden-surface removal, <i>z</i>-buffering, and stencil tests.<p>Various other algorithms that are taken for granted with a pre-existing graphics pipeline, like texture lookup, vector reflection, environment mapping.<p>Post-processing and miscellaneous algorithms like anisotropic filtering, multi-sample anti-aliasing, temporal anti-aliasing, and even deferred rendering.</div><br/><div id="38386835" class="c"><input type="checkbox" id="c-38386835" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38386677">parent</a><span>|</span><a href="#38386840">next</a><span>|</span><label class="collapse" for="c-38386835">[-]</label><label class="expand" for="c-38386835">[6 more]</label></div><br/><div class="children"><div class="content">If you want to learn webdev you don&#x27;t start by building a web browser despite the fact that building a web browser would teach you a lot.</div><br/><div id="38386896" class="c"><input type="checkbox" id="c-38386896" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38386835">parent</a><span>|</span><a href="#38389750">next</a><span>|</span><label class="collapse" for="c-38386896">[-]</label><label class="expand" for="c-38386896">[4 more]</label></div><br/><div class="children"><div class="content">Web dev is sufficiently abstracted from the browser and the hardware that a skilled web developer doesn&#x27;t really need to know the internals of the V8 engine or how a browser works. A web back-end developer probably doesn&#x27;t need to deal with the browser at all.<p>Graphics programming skill (by &#x27;skill&#x27;, I mean being able to write a shader pipeline that both satisfies the art direction <i>and</i> performs well), on the contrary, is <i>very deeply tied</i> to a good understanding of hardware. Especially now that the new APIs (Vulkan, Metal, D3D12) are <i>purposely</i> less abstracted than their predecessors.</div><br/><div id="38387107" class="c"><input type="checkbox" id="c-38387107" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38386896">parent</a><span>|</span><a href="#38389750">next</a><span>|</span><label class="collapse" for="c-38387107">[-]</label><label class="expand" for="c-38387107">[3 more]</label></div><br/><div class="children"><div class="content">All programmers at a certain level must understand the lower levels of the stack they are building upon. I think most people can get by with just learning the abstractions that are provided to them. With time people can learn more and more about lower levels as they specialize. Most people who become graphics programmers don&#x27;t need to know the low levels of how a GPU works, so I personally do not think that is a good place to start for people who want to get into graphics programming.</div><br/><div id="38387769" class="c"><input type="checkbox" id="c-38387769" checked=""/><div class="controls bullet"><span class="by">achierius</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38387107">parent</a><span>|</span><a href="#38389750">next</a><span>|</span><label class="collapse" for="c-38387769">[-]</label><label class="expand" for="c-38387769">[2 more]</label></div><br/><div class="children"><div class="content">Are you a graphics programmer, or are you just saying this because that&#x27;s true in the CPU world (where you have experience)? From both my own and my colleagues&#x27; experiences, I would 100% disagree: the nature of GPU architectures means you are forced to deal with super low-level details from the very beginning. Part of this is because graphics (and GPGPU compute) programming is inherently performance-constrained: if it wasn&#x27;t, you could just do your work on the CPU with much less of a headache. Even just generally though, the path to running code on a GPU is much simpler — the hardware does less work for the programmer, there&#x27;s no operating system to manage threads, everything&#x27;s a single binary, etc. — which means that there&#x27;s less to insulate you from what&#x27;s underneath.</div><br/><div id="38389180" class="c"><input type="checkbox" id="c-38389180" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38387769">parent</a><span>|</span><a href="#38389750">next</a><span>|</span><label class="collapse" for="c-38389180">[-]</label><label class="expand" for="c-38389180">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Are you a graphics programmer, or are you just saying this because that&#x27;s true in the CPU world (where you have experience)<p>Neither.<p>&gt;the nature of GPU architectures means you are forced to deal with super low-level details from the very beginning.<p>Not everyone is trying to push the hardware to its limits by making the best thing possible with the hardware. Plenty of projects can get along fine with a A&#x2F;AA renderer or with unoptimized shaders.<p>&gt;there&#x27;s no operating system to manage threads<p>There literally is. Or if you disagree the firmware manages the threads.</div><br/></div></div></div></div></div></div></div></div><div id="38389750" class="c"><input type="checkbox" id="c-38389750" checked=""/><div class="controls bullet"><span class="by">signaru</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38386835">parent</a><span>|</span><a href="#38386896">prev</a><span>|</span><a href="#38386840">next</a><span>|</span><label class="collapse" for="c-38389750">[-]</label><label class="expand" for="c-38389750">[1 more]</label></div><br/><div class="children"><div class="content">A more realistic comparison for webdev is using plain JS vs using frameworks.</div><br/></div></div></div></div></div></div><div id="38386840" class="c"><input type="checkbox" id="c-38386840" checked=""/><div class="controls bullet"><span class="by">throwawee</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38386367">parent</a><span>|</span><a href="#38386677">prev</a><span>|</span><a href="#38386410">next</a><span>|</span><label class="collapse" for="c-38386840">[-]</label><label class="expand" for="c-38386840">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. I&#x27;ve seen beginners fall into the trap of spending way too much time on software rendering that won&#x27;t be useful or performant later because every platform they&#x27;ll ever develop for has hardware accelerated rendering. I learned how to painstakingly render scenes pixel by pixel and then had to unlearn it because graphics programming doesn&#x27;t work that way anymore.<p>Teaching beginners to render graphics without the GPU is like teaching them to do fractional math without the FPU. It won&#x27;t make their first project better and gives them the wrong idea of what to expect.</div><br/></div></div><div id="38386410" class="c"><input type="checkbox" id="c-38386410" checked=""/><div class="controls bullet"><span class="by">CountHackulus</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38386367">parent</a><span>|</span><a href="#38386840">prev</a><span>|</span><a href="#38387201">next</a><span>|</span><label class="collapse" for="c-38386410">[-]</label><label class="expand" for="c-38386410">[1 more]</label></div><br/><div class="children"><div class="content">I disagree. It&#x27;s good to understand what the GPU is doing at scale before jumping in too deep. It&#x27;s obviously not how you do your day-to-day work, but it helps you understand what&#x27;s going on at a deeper level.</div><br/></div></div><div id="38387201" class="c"><input type="checkbox" id="c-38387201" checked=""/><div class="controls bullet"><span class="by">virtualritz</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38386367">parent</a><span>|</span><a href="#38386410">prev</a><span>|</span><a href="#38386604">next</a><span>|</span><label class="collapse" for="c-38387201">[-]</label><label class="expand" for="c-38387201">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; No GPU, no OpenGL, no DirectX!<p>&gt; This is the opposite of what you would hope to see for learning graphics programming.<p>It is exactly what you would hope to see.<p>And I would dare say I&#x27;m a graphics programmer, mostly self taught.<p>When I started, as a teenager, in the late 80&#x27;s, there were no GPUs. So I learned everything from first principles. I recall implementing Bresenham in x86 assembly for my CGA card. And then, as a follow up, rasterizing a triangle. You really had to understand stuff end-to-end then as the hardware was so slow. I.e. even C was too slow for that stuff.<p>And today, still, the best offline renderers, that produce the images you see on the big screen, are CPU-only. 100% custom code, no 3rd party API dependency.[1]<p>If you write stuff for CAD&#x2F;CAM&#x2F;CAE&#x2F;VFX, there is a big chance you do not think about the constraints of a GPU and less so of one of the APIs used to program it. Except for previewing stuff.<p>I would suggest to anyone learning graphics programming (or anything else for that matter) to do so from first principles.<p>GPUs are specialized hardware for realtime applications. That is very specific. I don&#x27;t say don&#x27;t learn that. But I suggest to not start with it.<p>[1] One of my best friends is the lead developer of the 3Delight renderer.</div><br/><div id="38388510" class="c"><input type="checkbox" id="c-38388510" checked=""/><div class="controls bullet"><span class="by">crq-yml</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38387201">parent</a><span>|</span><a href="#38386604">next</a><span>|</span><label class="collapse" for="c-38388510">[-]</label><label class="expand" for="c-38388510">[1 more]</label></div><br/><div class="children"><div class="content">My little spot of nuance on this reply would be that the point of starting in software would not be to aim for a fast or feature-rich implementation. That seems to be the sticking point of the replies in favor of going hardware-first - that &quot;we don&#x27;t optimize the same way anymore&quot;. But nobody was asking about optimizing! People seem to go performance-brained when they talk about graphics because they read about John Carmack once. Then they go right back to their Javascript frameworks.<p>Like any student engineering project, &quot;baby&#x27;s first rasterizer&quot; would emphasize a combination of concepts and motions - a path to take, to get to a result that can be tested. We don&#x27;t even have to use Bresenham now - deriving the rasterized line from linear interpolation is mathematically more sound and no sweat for modern CPUs. But it might be pedagogically useful to compare the two to explain quality vs performance tradeoffs, ones that were made historically and those that are still in use today.</div><br/></div></div></div></div><div id="38386604" class="c"><input type="checkbox" id="c-38386604" checked=""/><div class="controls bullet"><span class="by">moron4hire</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38386367">parent</a><span>|</span><a href="#38387201">prev</a><span>|</span><a href="#38386412">next</a><span>|</span><label class="collapse" for="c-38386604">[-]</label><label class="expand" for="c-38386604">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s what my graphics courses in my computer science degree did. The skills I learned have benefitted me long after (20 years), and I mostly &quot;just&quot; do web development.</div><br/></div></div><div id="38386412" class="c"><input type="checkbox" id="c-38386412" checked=""/><div class="controls bullet"><span class="by">robomartin</span><span>|</span><a href="#38386333">root</a><span>|</span><a href="#38386367">parent</a><span>|</span><a href="#38386604">prev</a><span>|</span><a href="#38389784">next</a><span>|</span><label class="collapse" for="c-38386412">[-]</label><label class="expand" for="c-38386412">[1 more]</label></div><br/><div class="children"><div class="content">Believe it or not, we were doing graphics without any of those things a very long time ago.  Learning fundamentals is really important.  You can always learn easier ways to do things later.<p>For example, area fill algorithms are really interesting.  Etc.</div><br/></div></div></div></div></div></div><div id="38389784" class="c"><input type="checkbox" id="c-38389784" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#38386333">prev</a><span>|</span><a href="#38387275">next</a><span>|</span><label class="collapse" for="c-38389784">[-]</label><label class="expand" for="c-38389784">[1 more]</label></div><br/><div class="children"><div class="content">Oh there are so many more ways to become a graphics programmer than by starting with DX&#x2F;VK&#x2F;OGL. No need to use C++ at all. Look at all the amazing 3d graphics 3Blue1Brown does in Python.<p>Learn DirectX or Vulkan if you want to write game engines.<p>Learn WebGL if you want to write browser applications.<p>Those APIs are heavy though, and don’t even necessarily teach you that much about graphics on their own. If you want to learn graphics concepts, write your own rasterizer and ray tracer - both! - in any language you want.<p>There are also a bunch of super-easy-to-use graphics libraries &amp; coding environments that are so much more fun than slogging through Vulkan or DX. Processing is wonderful. Or checkout PlotDevice.io (Python), or its predecessors NodeBox, or DrawBot. ShaderToy is another place where you can learn how to write shaders, or lots and lots about rendering, and it’s so easy to get started. JavaScript has lots of options and libraries. These can be way more accessible and motivating to a beginner, but still offer enough power and flexibility to take the curious student as far as they want.</div><br/></div></div><div id="38387275" class="c"><input type="checkbox" id="c-38387275" checked=""/><div class="controls bullet"><span class="by">SuboptimalEng</span><span>|</span><a href="#38389784">prev</a><span>|</span><a href="#38390614">next</a><span>|</span><label class="collapse" for="c-38387275">[-]</label><label class="expand" for="c-38387275">[1 more]</label></div><br/><div class="children"><div class="content">You can start learning graphics by writing shaders on Shadertoy. It’s where tons of graphics programmers get their start.<p>Shameless self promotion, I’ve made 10+ tutorials going over topics like: how to write shaders in VS Code, SDFs, ray marching, noise functions, fractional brownian motion, etc.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;suboptimaleng&#x2F;shader-tutorials">https:&#x2F;&#x2F;github.com&#x2F;suboptimaleng&#x2F;shader-tutorials</a><p>I’m certainly standing on the shoulders of giants like Inigo Quilez, The Art of Code, SimonDev and Acerola.</div><br/></div></div><div id="38390614" class="c"><input type="checkbox" id="c-38390614" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#38387275">prev</a><span>|</span><a href="#38388919">next</a><span>|</span><label class="collapse" for="c-38390614">[-]</label><label class="expand" for="c-38390614">[1 more]</label></div><br/><div class="children"><div class="content">Depends on what you want to make and on which level. Doing graphics for a desktop application will differ from doing it for a web application, for embedded devices or for a game.<p>That being said for a beginner I would recommend starting with the examples in processing.org. This is basically a small IDE where you can make your code draw things in a window with minimal boilerplate (the boilerplate is hidden). There is a heap of examples, how to do easing functions, how to work with vectors, etc.<p>The stuff learned there will be useful for anything where you need to work with a coordinate system.</div><br/></div></div><div id="38388919" class="c"><input type="checkbox" id="c-38388919" checked=""/><div class="controls bullet"><span class="by">uglycoyote</span><span>|</span><a href="#38390614">prev</a><span>|</span><a href="#38386824">next</a><span>|</span><label class="collapse" for="c-38388919">[-]</label><label class="expand" for="c-38388919">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a game developer but not specifically a graphics programmer.  Although I work with modern graphics APIs and GLSL shaders in my day job, when my 13 year old recently graduated from wanting to program in Scratch or Python to wanting to learn C++, I decided the best thing to do was break out the old OpenGL 1.2 DLL&#x27;s that I still had on my machine since 1999 and starting him writing some code using glut and glbegin&#x2F;glvertex&#x2F;glend type of immediate programming.<p>it is just a lot more fun than trying to suffer through all of the setup that one needs to do with modern APIs.  he is more interested in computational geometry type of things like voronoi diagrams so the graphics API is really just a means to an end and fancy shaders and lighting aren&#x27;t important right now, and performance in C++ and old school OpenGL is about a thousand times faster than Scratch, so I think we hit a sweet spot for where he is at in terms of his progression of learning.<p>even with the simplified API of OpenGL 1.2, he is still biting off a pretty ambitious chunk of learning to try to grasp c++ at the same time as OpenGL, so the simplicity helps keep it sane and manageable, and things are going well.  He did some neat marching squares demos and I helped add an IMgui menu to tune parameters at runtime.  it has been entertaining!</div><br/></div></div><div id="38386824" class="c"><input type="checkbox" id="c-38386824" checked=""/><div class="controls bullet"><span class="by">trevortheblack</span><span>|</span><a href="#38388919">prev</a><span>|</span><a href="#38386773">next</a><span>|</span><label class="collapse" for="c-38386824">[-]</label><label class="expand" for="c-38386824">[2 more]</label></div><br/><div class="children"><div class="content">Since this is on the front page I guess I&#x27;ll post the resource that the graphics programming industry actually uses (note, I&#x27;m an author): <a href="https:&#x2F;&#x2F;raytracing.github.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;raytracing.github.io&#x2F;</a><p>It&#x27;s included in the &quot;Useful Websites&quot; in the article above.<p>Also note that graphics is large enough that there no longer exists a one-size-fits all solution to learning graphics. If you want to learn graphics I&#x27;d recommend finding a mentor.</div><br/><div id="38387169" class="c"><input type="checkbox" id="c-38387169" checked=""/><div class="controls bullet"><span class="by">starmole</span><span>|</span><a href="#38386824">parent</a><span>|</span><a href="#38386773">next</a><span>|</span><label class="collapse" for="c-38387169">[-]</label><label class="expand" for="c-38387169">[1 more]</label></div><br/><div class="children"><div class="content">Great stuff! I especially agree with teaching math via raytracing first instead of APIs.</div><br/></div></div></div></div><div id="38386773" class="c"><input type="checkbox" id="c-38386773" checked=""/><div class="controls bullet"><span class="by">demondemidi</span><span>|</span><a href="#38386824">prev</a><span>|</span><a href="#38389674">next</a><span>|</span><label class="collapse" for="c-38386773">[-]</label><label class="expand" for="c-38386773">[3 more]</label></div><br/><div class="children"><div class="content">Not really sure what this website is asking. Does the person want to: Rig? Texture? Model? Write drivers? Make GUIs? Animate websites? Make graphics tools? Work with shaders? Or work with 2D photo engines? Make 2D games? Make 3D games? Write procedural scripts? Optimize graphics code?<p>There are hundreds of disciplines that fall under &quot;computer graphics&quot;. The website focuses on a teensy little corner: programming graphics SDKs.</div><br/><div id="38386900" class="c"><input type="checkbox" id="c-38386900" checked=""/><div class="controls bullet"><span class="by">quelsolaar</span><span>|</span><a href="#38386773">parent</a><span>|</span><a href="#38389423">next</a><span>|</span><label class="collapse" for="c-38386900">[-]</label><label class="expand" for="c-38386900">[1 more]</label></div><br/><div class="children"><div class="content">Being a graphics programmer is a pretty well defined category of programmers. A lot of the things you mentioned aren&#x27;t graphics programming like Rig, Texture or Model, and a graphics programmer is expected to be able to run the gamut of games, 3D, 2D, tools, shaders and optimization.</div><br/></div></div><div id="38389423" class="c"><input type="checkbox" id="c-38389423" checked=""/><div class="controls bullet"><span class="by">hshsbs84848</span><span>|</span><a href="#38386773">parent</a><span>|</span><a href="#38386900">prev</a><span>|</span><a href="#38389674">next</a><span>|</span><label class="collapse" for="c-38389423">[-]</label><label class="expand" for="c-38389423">[1 more]</label></div><br/><div class="children"><div class="content">I can see how it’s confusing but usually “graphics programmer” is someone who works on a graphics rendering engine (either real time or offline rendering)</div><br/></div></div></div></div><div id="38389674" class="c"><input type="checkbox" id="c-38389674" checked=""/><div class="controls bullet"><span class="by">wly_cdgr</span><span>|</span><a href="#38386773">prev</a><span>|</span><a href="#38386515">next</a><span>|</span><label class="collapse" for="c-38389674">[-]</label><label class="expand" for="c-38389674">[2 more]</label></div><br/><div class="children"><div class="content">The details are outdated now, I guess, but I don&#x27;t know if there&#x27;s any more inspiring reading for an aspiring graphics programmer than Fabian Giesen&#x27;s &quot;A trip through the graphics pipeline&quot; <a href="https:&#x2F;&#x2F;fgiesen.wordpress.com&#x2F;2011&#x2F;07&#x2F;09&#x2F;a-trip-through-the-graphics-pipeline-2011-index&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;fgiesen.wordpress.com&#x2F;2011&#x2F;07&#x2F;09&#x2F;a-trip-through-the-...</a><p>As for a place to actually start, I think Computer Graphics From Scratch is a good place <a href="https:&#x2F;&#x2F;www.gabrielgambetta.com&#x2F;computer-graphics-from-scratch&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.gabrielgambetta.com&#x2F;computer-graphics-from-scrat...</a>. A great thing about the book is it gives you many ideas for where to go next once you work your way through to the end.</div><br/><div id="38389860" class="c"><input type="checkbox" id="c-38389860" checked=""/><div class="controls bullet"><span class="by">Agentlien</span><span>|</span><a href="#38389674">parent</a><span>|</span><a href="#38386515">next</a><span>|</span><label class="collapse" for="c-38389860">[-]</label><label class="expand" for="c-38389860">[1 more]</label></div><br/><div class="children"><div class="content">The details are surprisingly still relevant. A lot has changed, but most of that (compute shaders, Ray tracing hardware, ...) is actually orthogonal to everything mentioned in this article or simply details changing in aspects glossed over.<p>I still link people this article because I have yet to find anything which does a better job explaining these things.</div><br/></div></div></div></div><div id="38386515" class="c"><input type="checkbox" id="c-38386515" checked=""/><div class="controls bullet"><span class="by">atum47</span><span>|</span><a href="#38389674">prev</a><span>|</span><a href="#38386931">next</a><span>|</span><label class="collapse" for="c-38386515">[-]</label><label class="expand" for="c-38386515">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m on that journey myself. Two years ago I followed several tutorials and youtube videos to create my first 3D engine. It&#x27;s very simple, but I like simple stuff. Right now I&#x27;m working on using this engine to create a city builder game [1]. It is a lot of fun to learn to manipulate stuff using matrix and cross products.<p>1 - <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=cvyrfPUpyp0" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=cvyrfPUpyp0</a></div><br/></div></div><div id="38386931" class="c"><input type="checkbox" id="c-38386931" checked=""/><div class="controls bullet"><span class="by">quelsolaar</span><span>|</span><a href="#38386515">prev</a><span>|</span><a href="#38390598">next</a><span>|</span><label class="collapse" for="c-38386931">[-]</label><label class="expand" for="c-38386931">[2 more]</label></div><br/><div class="children"><div class="content">C is a perfectly good alternative to C++ for Graphics programming. OpenGL and Vulcan are C APIs and DirectX has a C wrapper. Some games like Call of duty are written in C, but C++ is more common.</div><br/><div id="38388095" class="c"><input type="checkbox" id="c-38388095" checked=""/><div class="controls bullet"><span class="by">mabster</span><span>|</span><a href="#38386931">parent</a><span>|</span><a href="#38390598">next</a><span>|</span><label class="collapse" for="c-38388095">[-]</label><label class="expand" for="c-38388095">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done games in both. My favourite is mostly imperative C++ so you can use templates.</div><br/></div></div></div></div><div id="38390598" class="c"><input type="checkbox" id="c-38390598" checked=""/><div class="controls bullet"><span class="by">MurageKabui</span><span>|</span><a href="#38386931">prev</a><span>|</span><a href="#38387042">next</a><span>|</span><label class="collapse" for="c-38390598">[-]</label><label class="expand" for="c-38390598">[1 more]</label></div><br/><div class="children"><div class="content">Not one mention of GDI+ ?</div><br/></div></div><div id="38387042" class="c"><input type="checkbox" id="c-38387042" checked=""/><div class="controls bullet"><span class="by">TrackerFF</span><span>|</span><a href="#38390598">prev</a><span>|</span><a href="#38389443">next</a><span>|</span><label class="collapse" for="c-38387042">[-]</label><label class="expand" for="c-38387042">[1 more]</label></div><br/><div class="children"><div class="content">Learning trigonometry and linear algebra would be a good start.</div><br/></div></div><div id="38389443" class="c"><input type="checkbox" id="c-38389443" checked=""/><div class="controls bullet"><span class="by">slalomskiing</span><span>|</span><a href="#38387042">prev</a><span>|</span><a href="#38387144">next</a><span>|</span><label class="collapse" for="c-38389443">[-]</label><label class="expand" for="c-38389443">[1 more]</label></div><br/><div class="children"><div class="content">I went through this and switched from web dev to being a graphics programmer at a game studio<p>Personally I think LearnOpenGL is still the best tutorial series if you want to work on game rendering engines<p>Just because it covers a ton of different topics from beginner up to advanced all in one series. You go from scratch all the way up to implementing deferred rendering and a full PBR implementation<p>If you understand all of those tutorials you have a pretty good baseline for how modern game rendering works (minus ray tracing)<p>In terms of getting a job though the modern APIs are highly desirable</div><br/></div></div><div id="38387144" class="c"><input type="checkbox" id="c-38387144" checked=""/><div class="controls bullet"><span class="by">barbariangrunge</span><span>|</span><a href="#38389443">prev</a><span>|</span><a href="#38387101">next</a><span>|</span><label class="collapse" for="c-38387144">[-]</label><label class="expand" for="c-38387144">[1 more]</label></div><br/><div class="children"><div class="content">If you’re teaching yourself, it might be nice to have an early win. Something like unreals material editor or shader graph might be a nice start. Lots of tutorials around. Then, when you go to write actual shaders. You’ll know what logically you intend to do, and all you have to do is learn the syntax of whatever graphics language&#x2F;api you choose<p>Tangent: Learning the syntax for OpenGL is hellish, and there’s a lack of great resources on it, at least as of several years ago.<p>Then, after you understand shaders a little, go and make your game engine (physics will be its own beast)</div><br/></div></div><div id="38387101" class="c"><input type="checkbox" id="c-38387101" checked=""/><div class="controls bullet"><span class="by">zffr</span><span>|</span><a href="#38387144">prev</a><span>|</span><a href="#38387584">next</a><span>|</span><label class="collapse" for="c-38387101">[-]</label><label class="expand" for="c-38387101">[1 more]</label></div><br/><div class="children"><div class="content">For complete beginners looking to get a good conceptual understanding of what shaders are actually doing, I would highly recommend this course: <a href="https:&#x2F;&#x2F;github.com&#x2F;ssloy&#x2F;tinyrenderer">https:&#x2F;&#x2F;github.com&#x2F;ssloy&#x2F;tinyrenderer</a><p>In the course you will build a purely CPU-based renderer that simulates the way OpenGL shaders work. I found it to be incredibly useful for understanding shaders.</div><br/></div></div><div id="38387584" class="c"><input type="checkbox" id="c-38387584" checked=""/><div class="controls bullet"><span class="by">raytopia</span><span>|</span><a href="#38387101">prev</a><span>|</span><a href="#38386529">next</a><span>|</span><label class="collapse" for="c-38387584">[-]</label><label class="expand" for="c-38387584">[2 more]</label></div><br/><div class="children"><div class="content">If you want to be a retro graphics programmer reject shaders and return to glBegin.</div><br/><div id="38387755" class="c"><input type="checkbox" id="c-38387755" checked=""/><div class="controls bullet"><span class="by">jherico</span><span>|</span><a href="#38387584">parent</a><span>|</span><a href="#38386529">next</a><span>|</span><label class="collapse" for="c-38387755">[-]</label><label class="expand" for="c-38387755">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure there&#x27;s a set of shaders that will basically let you emulate the fixed function pipeline without having to endure the shitty performance implications of passing a vertex list to the GPU every single frame.</div><br/></div></div></div></div><div id="38386529" class="c"><input type="checkbox" id="c-38386529" checked=""/><div class="controls bullet"><span class="by">byyoung3</span><span>|</span><a href="#38387584">prev</a><span>|</span><a href="#38387199">next</a><span>|</span><label class="collapse" for="c-38386529">[-]</label><label class="expand" for="c-38386529">[1 more]</label></div><br/><div class="children"><div class="content">program graphics</div><br/></div></div><div id="38387199" class="c"><input type="checkbox" id="c-38387199" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#38386529">prev</a><span>|</span><a href="#38387395">next</a><span>|</span><label class="collapse" for="c-38387199">[-]</label><label class="expand" for="c-38387199">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    10 GRAPHICS 8+16:REM HIRES MODE WITHOUT TEXT WINDOW
    15 SETCOLOR 0,0,0:SETCOLOR 2,10,15
    20 COLOR 1
    30 PLOT 0,0
    40 DRAWTO 319,190
    50 GOTO 50</code></pre></div><br/></div></div><div id="38387395" class="c"><input type="checkbox" id="c-38387395" checked=""/><div class="controls bullet"><span class="by">drones</span><span>|</span><a href="#38387199">prev</a><span>|</span><a href="#38386246">next</a><span>|</span><label class="collapse" for="c-38387395">[-]</label><label class="expand" for="c-38387395">[1 more]</label></div><br/><div class="children"><div class="content">Are there any good resources for learning graphics programming for the first time with WebGPU? I have heard mixed opinions about WGSL.</div><br/></div></div><div id="38386246" class="c"><input type="checkbox" id="c-38386246" checked=""/><div class="controls bullet"><span class="by">theodpHN</span><span>|</span><a href="#38387395">prev</a><span>|</span><a href="#38388712">next</a><span>|</span><label class="collapse" for="c-38386246">[-]</label><label class="expand" for="c-38386246">[1 more]</label></div><br/><div class="children"><div class="content">Practice.<p><a href="https:&#x2F;&#x2F;www.carnegiehall.org&#x2F;Explore&#x2F;Articles&#x2F;2020&#x2F;04&#x2F;10&#x2F;The-Joke" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.carnegiehall.org&#x2F;Explore&#x2F;Articles&#x2F;2020&#x2F;04&#x2F;10&#x2F;The...</a></div><br/></div></div><div id="38388712" class="c"><input type="checkbox" id="c-38388712" checked=""/><div class="controls bullet"><span class="by">photochemsyn</span><span>|</span><a href="#38386246">prev</a><span>|</span><a href="#38387850">next</a><span>|</span><label class="collapse" for="c-38388712">[-]</label><label class="expand" for="c-38388712">[2 more]</label></div><br/><div class="children"><div class="content">All the comments here are BS. You have to learn how to construct 2D and 3D graphical spaces in real time and let them evolve and I&#x27;m sorry to say, as others have before, there is no royal road to mathematics. You simply have to put your time in the trenches. All the tools being sold to you are ephemeral and will soon become obsolete, so you simply have to grasp fundamentals of linear algebra and 3D spatial representations.<p>You can try to use tools created by others but the results will all just look the same as theirs, and if this is too much bother I&#x27;d suggest going back to non-digital mediums for your artwork like pen &amp; ink watercolors oil paints etc.<p>If you can&#x27;t handle vector calculus and complex analysis then that&#x27;s too bad. Try harder or do something else.</div><br/><div id="38389696" class="c"><input type="checkbox" id="c-38389696" checked=""/><div class="controls bullet"><span class="by">wly_cdgr</span><span>|</span><a href="#38388712">parent</a><span>|</span><a href="#38387850">next</a><span>|</span><label class="collapse" for="c-38389696">[-]</label><label class="expand" for="c-38389696">[1 more]</label></div><br/><div class="children"><div class="content">Ok but what are you saying? After understanding the math, are you suggesting that people need to use that understanding to interface with the graphics hardware at a level below Vulkan?</div><br/></div></div></div></div><div id="38387850" class="c"><input type="checkbox" id="c-38387850" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#38388712">prev</a><span>|</span><a href="#38387944">next</a><span>|</span><label class="collapse" for="c-38387850">[-]</label><label class="expand" for="c-38387850">[1 more]</label></div><br/><div class="children"><div class="content">Put one pixel in front of another..</div><br/></div></div><div id="38387944" class="c"><input type="checkbox" id="c-38387944" checked=""/><div class="controls bullet"><span class="by">jheriko</span><span>|</span><a href="#38387850">prev</a><span>|</span><a href="#38386074">next</a><span>|</span><label class="collapse" for="c-38387944">[-]</label><label class="expand" for="c-38387944">[1 more]</label></div><br/><div class="children"><div class="content">make things. the end.</div><br/></div></div><div id="38386074" class="c"><input type="checkbox" id="c-38386074" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#38387944">prev</a><span>|</span><a href="#38386374">next</a><span>|</span><label class="collapse" for="c-38386074">[-]</label><label class="expand" for="c-38386074">[26 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t hard: DirectX 12 and C++ and Visual Studio (not VSCode) and Windows on an NVIDIA card.<p>Vulkan basically isn&#x27;t relevant anymore unless you are doing Android.  Metal similarly unless you are doing iOS.<p>As a Linux user, this pains me.  But it&#x27;s just life.  Windows-land is <i>soooo</i> much better for graphics programming that it&#x27;s absurd.</div><br/><div id="38386225" class="c"><input type="checkbox" id="c-38386225" checked=""/><div class="controls bullet"><span class="by">slabity</span><span>|</span><a href="#38386074">parent</a><span>|</span><a href="#38386174">next</a><span>|</span><label class="collapse" for="c-38386225">[-]</label><label class="expand" for="c-38386225">[12 more]</label></div><br/><div class="children"><div class="content">&gt; Vulkan basically isn&#x27;t relevant anymore unless you are doing Android.<p>Why do you say this?</div><br/><div id="38386541" class="c"><input type="checkbox" id="c-38386541" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#38386074">root</a><span>|</span><a href="#38386225">parent</a><span>|</span><a href="#38386525">next</a><span>|</span><label class="collapse" for="c-38386541">[-]</label><label class="expand" for="c-38386541">[1 more]</label></div><br/><div class="children"><div class="content">I’m not the person you asked but my 2c (since I agree with their point on Vulkan)<p>Very few video games are made with Vulkan. DirectX is the primary API.<p>Android is the only place where Vulkan really has an interesting market share.<p>For a beginner, it has an incredibly steep learning curve vs DirectX as well. So given the low usage and high friction to pick it up, you have a really poor ROI.<p>DirectX and Metal are much more conducive to getting results quickly and efficiently.</div><br/></div></div><div id="38386525" class="c"><input type="checkbox" id="c-38386525" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#38386074">root</a><span>|</span><a href="#38386225">parent</a><span>|</span><a href="#38386541">prev</a><span>|</span><a href="#38386617">next</a><span>|</span><label class="collapse" for="c-38386525">[-]</label><label class="expand" for="c-38386525">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not the parent commenter, but I&#x27;d like to explain their logic, which has at least a modicum of reason to it.<p>About 99% of desktop video games (by far the largest clients of graphics APIs) target Windows, and therefore target either Direct3D 11 or Direct3D 12. This includes free-to-use game engines including CryEngine, Unity, Unreal, and Ren&#x27;Py. Almost <i>all</i> the famous, proprietary, high-performance game engines (id Tech, Frostbite, Slipspace, REDEngine, Source) target D3D exclusively. Vulkan is clearly a second-class citizen on Windows. <i>Some</i> engines target OpenGL, and they tend to be used in (hurriedly dashed-out) console ports, but in almost all cases they exhibit worse performance than their D3D competitors.<p>Vulkan is completely absent from MacOS and iOS, where Apple has pushed its own API, Metal. OpenGL on MacOS is deprecated and is stuck on 4.1, missing all the advancements in 4.6, which include mesh shader support.<p>Many Android games are likely still running GLES. Vulkan is pretty hard to get started with, because things that are implicitly handled by the OpenGL global state machine now have to be explicitly handled by the developer, and chances are the developers of the millions of throw-away microtransaction-laden game apps on Android aren&#x27;t writing their own rendering engines in Vulkan.<p>Therefore, despite all the positives of Vulkan—open-source specification, cross-platform support, SPIR-V shader target allowing shaders to be written in any language (HLSL, GLSL, other esoteric languages that compile to SPIR-V), an extension mechanism allowing fast iteration and updates—it has a fairly uphill battle.<p>EDIT: I was incorrect, id Tech supports Vulkan exclusively. But it is a minority in a sea of D3D-first engines.</div><br/><div id="38387001" class="c"><input type="checkbox" id="c-38387001" checked=""/><div class="controls bullet"><span class="by">spookie</span><span>|</span><a href="#38386074">root</a><span>|</span><a href="#38386525">parent</a><span>|</span><a href="#38386724">next</a><span>|</span><label class="collapse" for="c-38387001">[-]</label><label class="expand" for="c-38387001">[2 more]</label></div><br/><div class="children"><div class="content">iD Tech, Source 2, Unreal, and Unity support Vulkan.<p>iD Tech targets Vulkan exclusively on PC:
<a href="https:&#x2F;&#x2F;twitter.com&#x2F;billykhan&#x2F;status&#x2F;1028133659168186368" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;billykhan&#x2F;status&#x2F;1028133659168186368</a><p>Other points are also blatantly untrue, but I think I have made my point. At this point, targeting only DirectX is shooting yourself in the foot.<p>Other references:
<a href="https:&#x2F;&#x2F;docs.unity3d.com&#x2F;Manual&#x2F;GraphicsAPIs.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.unity3d.com&#x2F;Manual&#x2F;GraphicsAPIs.html</a>
<a href="https:&#x2F;&#x2F;www.khronos.org&#x2F;news&#x2F;press&#x2F;khronos-group-releases-vulkan-1-1" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.khronos.org&#x2F;news&#x2F;press&#x2F;khronos-group-releases-vu...</a>
<a href="https:&#x2F;&#x2F;docs.unrealengine.com&#x2F;5.3&#x2F;en-US&#x2F;supported-features-by-rendering-path-for-desktop-with-unreal-engine&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.unrealengine.com&#x2F;5.3&#x2F;en-US&#x2F;supported-features-b...</a></div><br/><div id="38387083" class="c"><input type="checkbox" id="c-38387083" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#38386074">root</a><span>|</span><a href="#38387001">parent</a><span>|</span><a href="#38386724">next</a><span>|</span><label class="collapse" for="c-38387083">[-]</label><label class="expand" for="c-38387083">[1 more]</label></div><br/><div class="children"><div class="content">While I was incorrect about id Tech (and have edited my comment), I never made the point that any of the other engines <i>didn&#x27;t</i> target Vulkan.<p>Where else is my comment untrue? Many engines and rendering back-ends have only recently completed a Vulkan-based implementation. I am confident in my assessment that the large majority of existing implementations are still running OpenGL and&#x2F;or Direct3D, if on Windows.</div><br/></div></div></div></div><div id="38386724" class="c"><input type="checkbox" id="c-38386724" checked=""/><div class="controls bullet"><span class="by">vivty</span><span>|</span><a href="#38386074">root</a><span>|</span><a href="#38386525">parent</a><span>|</span><a href="#38387001">prev</a><span>|</span><a href="#38387239">next</a><span>|</span><label class="collapse" for="c-38386724">[-]</label><label class="expand" for="c-38386724">[4 more]</label></div><br/><div class="children"><div class="content">Maybe i am wrong, but this tweet and wikipedia directly contradicts what you say (id tech does indeed use vulkan on windows):
<a href="https:&#x2F;&#x2F;twitter.com&#x2F;billykhan&#x2F;status&#x2F;1028133659168186368" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;billykhan&#x2F;status&#x2F;1028133659168186368</a><p>I am just doing game dev on the side but i think nowadays the graphics abstractions are fairly similar in how they work (the modern abstractions, i.e. Metal, D3D12, Vulkan). Of course ideally you choose the graphics abstraction that is &quot;native&quot; to the platform, but vulkan seems to be supported very well on windows (many AAA game use it and it works great, many games run even better with vulkan abstraction than with their d3d12 counterpart). I use vukan so my graphics can run on windows and linux (which is why i chose vulkan instead of d3d12).</div><br/><div id="38386933" class="c"><input type="checkbox" id="c-38386933" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#38386074">root</a><span>|</span><a href="#38386724">parent</a><span>|</span><a href="#38386905">next</a><span>|</span><label class="collapse" for="c-38386933">[-]</label><label class="expand" for="c-38386933">[2 more]</label></div><br/><div class="children"><div class="content">You are correct that idTech targets Vulkan (and they have some great GDC talks to boot)<p>They are however very much the minority.<p>I am suspect of your claim about Vulkan abstraction layers running better than DX12. If there is a performance difference, it’s likely elsewhere in the stack and just tangentially related.</div><br/><div id="38388149" class="c"><input type="checkbox" id="c-38388149" checked=""/><div class="controls bullet"><span class="by">mabster</span><span>|</span><a href="#38386074">root</a><span>|</span><a href="#38386933">parent</a><span>|</span><a href="#38386905">next</a><span>|</span><label class="collapse" for="c-38388149">[-]</label><label class="expand" for="c-38388149">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised by that as well.<p>I haven&#x27;t done this stuff for quite a while, so my memory might be foggy, but the main advantage of Vulcan was that you can control all the CPU locking rather than the API doing it. This allows you to do stuff like prepare on one thread and submit on another, etc.<p>But that would be negated if you&#x27;re using an abstraction layer.</div><br/></div></div></div></div></div></div><div id="38387239" class="c"><input type="checkbox" id="c-38387239" checked=""/><div class="controls bullet"><span class="by">spookie</span><span>|</span><a href="#38386074">root</a><span>|</span><a href="#38386525">parent</a><span>|</span><a href="#38386724">prev</a><span>|</span><a href="#38386617">next</a><span>|</span><label class="collapse" for="c-38387239">[-]</label><label class="expand" for="c-38387239">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Almost <i>all</i> the famous, proprietary, high-performance game engines (id Tech, Frostbite, Slipspace, REDEngine, Source) target D3D exclusively.<p>You&#x27;ve said it there, hence my reply</div><br/></div></div></div></div><div id="38386617" class="c"><input type="checkbox" id="c-38386617" checked=""/><div class="controls bullet"><span class="by">moron4hire</span><span>|</span><a href="#38386074">root</a><span>|</span><a href="#38386225">parent</a><span>|</span><a href="#38386525">prev</a><span>|</span><a href="#38386612">next</a><span>|</span><label class="collapse" for="c-38386617">[-]</label><label class="expand" for="c-38386617">[1 more]</label></div><br/><div class="children"><div class="content">IDK, all the games I try to run on Linux seem to work better in Windows&#x2F;DX emulation rather than native&#x2F;Vulkan.</div><br/></div></div></div></div><div id="38386174" class="c"><input type="checkbox" id="c-38386174" checked=""/><div class="controls bullet"><span class="by">SeanAnderson</span><span>|</span><a href="#38386074">parent</a><span>|</span><a href="#38386225">prev</a><span>|</span><a href="#38386201">next</a><span>|</span><label class="collapse" for="c-38386174">[-]</label><label class="expand" for="c-38386174">[10 more]</label></div><br/><div class="children"><div class="content">How does this sentiment align with the advent of WebGPU?</div><br/><div id="38390201" class="c"><input type="checkbox" id="c-38390201" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38386074">root</a><span>|</span><a href="#38386174">parent</a><span>|</span><a href="#38386588">next</a><span>|</span><label class="collapse" for="c-38390201">[-]</label><label class="expand" for="c-38390201">[1 more]</label></div><br/><div class="children"><div class="content">WebGPU is a browser API.<p>Anyone making use of it outside the browser is making themselves a disservice by not using a middleware engine instead.<p>WebGPU as specified cannot do many modern features, and naturally making use of extensions in wgpu or Dawn, makes the code non portable.</div><br/></div></div><div id="38386588" class="c"><input type="checkbox" id="c-38386588" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#38386074">root</a><span>|</span><a href="#38386174">parent</a><span>|</span><a href="#38390201">prev</a><span>|</span><a href="#38387833">next</a><span>|</span><label class="collapse" for="c-38386588">[-]</label><label class="expand" for="c-38386588">[6 more]</label></div><br/><div class="children"><div class="content">WebGPU is little more than a laboratory experiment right now. There are probably <i>no</i> industry implementations (game&#x2F;graphics engine, visualisers, etc). Computer graphics is particularly industry-driven—consider the proportion of game devs who present at SIGGRAPH versus academics.<p>I give it at least a <i>decade</i> before WebGPU sees any meaningful market share.</div><br/><div id="38386868" class="c"><input type="checkbox" id="c-38386868" checked=""/><div class="controls bullet"><span class="by">Jasper_</span><span>|</span><a href="#38386074">root</a><span>|</span><a href="#38386588">parent</a><span>|</span><a href="#38386688">next</a><span>|</span><label class="collapse" for="c-38386868">[-]</label><label class="expand" for="c-38386868">[1 more]</label></div><br/><div class="children"><div class="content">Chrome is switching to using Dawn (Google&#x27;s WebGPU implementation) for its Skia backend. This would render all UI elements across Chrome using WebGPU. You can find plenty of projects that are using WebGPU today. In the web space, BabylonJS has had plenty of experience using it already, and you can run several demos [0]. Offline, there are games like Veloren [1] that use it exclusively as a graphics backend. Plus a number of other projects I can&#x27;t talk about yet.<p>It&#x27;s pretty obvious WebGPU is not going to replace any big engine&#x27;s custom-built graphics backend, but it&#x27;s already pretty capable, and I think it&#x27;s going to be a good place to start for beginners for a long time.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;Popov72&#x2F;OceanDemo">https:&#x2F;&#x2F;github.com&#x2F;Popov72&#x2F;OceanDemo</a>
[1] <a href="https:&#x2F;&#x2F;veloren.net&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;veloren.net&#x2F;</a></div><br/></div></div><div id="38386688" class="c"><input type="checkbox" id="c-38386688" checked=""/><div class="controls bullet"><span class="by">SeanAnderson</span><span>|</span><a href="#38386074">root</a><span>|</span><a href="#38386588">parent</a><span>|</span><a href="#38386868">prev</a><span>|</span><a href="#38387833">next</a><span>|</span><label class="collapse" for="c-38386688">[-]</label><label class="expand" for="c-38386688">[4 more]</label></div><br/><div class="children"><div class="content">Bevy Engine (<a href="https:&#x2F;&#x2F;bevyengine.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;bevyengine.org&#x2F;</a>) is built ontop of wgpu (<a href="https:&#x2F;&#x2F;wgpu.rs&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;wgpu.rs&#x2F;</a>) and runs in-browser today (<a href="https:&#x2F;&#x2F;bevyengine.org&#x2F;news&#x2F;bevy-webgpu&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;bevyengine.org&#x2F;news&#x2F;bevy-webgpu&#x2F;</a>)<p>Bevy is the second highest starred game engine on GitHub&#x27;s Game Engine topic: <a href="https:&#x2F;&#x2F;github.com&#x2F;topics&#x2F;game-engine">https:&#x2F;&#x2F;github.com&#x2F;topics&#x2F;game-engine</a><p>I definitely agree that it&#x27;s still new, but I don&#x27;t feel like it&#x27;s quite as far out as you&#x27;re implying. A year or two at best IMO?</div><br/><div id="38386795" class="c"><input type="checkbox" id="c-38386795" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#38386074">root</a><span>|</span><a href="#38386688">parent</a><span>|</span><a href="#38387833">next</a><span>|</span><label class="collapse" for="c-38386795">[-]</label><label class="expand" for="c-38386795">[3 more]</label></div><br/><div class="children"><div class="content">GitHub stars aren&#x27;t really an accurate indicator of market share. I&#x27;ve previously starred it, too, but I&#x27;ve never used it.<p>I&#x27;d like to draw attention to the last phrase in my comment:<p>&gt; WebGPU sees any <i>meaningful</i> market share<p>I am comparing anything implemented in WebGPU to existing games that are played <i>today</i> by gamers.<p>Finally, it&#x27;s using Rust, and the majority of graphics + game engines are written in C++ (with a minority in Java and C#). Despite the safety and tooling benefits, moving to Rust is still a change that companies have to implement and educate their developers on, which is going to take a lot of time. And game dev companies are fairly slow at adopting new language standards (even if they adopt new <i>graphics</i> APIs and hardware fairly quickly, e.g. ray-tracing).<p>I don&#x27;t quite share your optimism; sorry.</div><br/><div id="38386910" class="c"><input type="checkbox" id="c-38386910" checked=""/><div class="controls bullet"><span class="by">SeanAnderson</span><span>|</span><a href="#38386074">root</a><span>|</span><a href="#38386795">parent</a><span>|</span><a href="#38387833">next</a><span>|</span><label class="collapse" for="c-38386910">[-]</label><label class="expand" for="c-38386910">[2 more]</label></div><br/><div class="children"><div class="content">Well, I&#x27;m writing a game intended for the web using Bevy right now, so I&#x27;m clearly biased :)<p>There are also some industry veterans building games using it. <a href="https:&#x2F;&#x2F;www.mobygames.com&#x2F;person&#x2F;6108&#x2F;brandon-reinhart&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.mobygames.com&#x2F;person&#x2F;6108&#x2F;brandon-reinhart&#x2F;</a> to name one specifically.<p>You can just use FFI if you want to integrate C crates with Rust, it&#x27;s not that bad. Figma uses a mixture of Rust and C++ in the WASM that they ship.<p>Guess we&#x27;ll see what the future holds.</div><br/><div id="38387125" class="c"><input type="checkbox" id="c-38387125" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#38386074">root</a><span>|</span><a href="#38386910">parent</a><span>|</span><a href="#38387833">next</a><span>|</span><label class="collapse" for="c-38387125">[-]</label><label class="expand" for="c-38387125">[1 more]</label></div><br/><div class="children"><div class="content">All the best. I&#x27;ll be happy to eat my words.<p>Rust is a great language (although I don&#x27;t use it myself), and WebGPU is pretty interesting as well.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38387833" class="c"><input type="checkbox" id="c-38387833" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#38386074">root</a><span>|</span><a href="#38386174">parent</a><span>|</span><a href="#38386588">prev</a><span>|</span><a href="#38386201">next</a><span>|</span><label class="collapse" for="c-38387833">[-]</label><label class="expand" for="c-38387833">[2 more]</label></div><br/><div class="children"><div class="content">WebGPU needs to cater to the lowest common denominator so it&#x27;s unlikely to replace DX12&#x2F;Vulkan&#x2F;Metal in the demanding usages. It&#x27;s always going to lag behind on features, capabilities, and performance.<p>But for the long tail of image filters, video effects, more graphically basic games - yeah, it&#x27;s a great fit there. Probably.</div><br/><div id="38390185" class="c"><input type="checkbox" id="c-38390185" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38386074">root</a><span>|</span><a href="#38387833">parent</a><span>|</span><a href="#38386201">next</a><span>|</span><label class="collapse" for="c-38390185">[-]</label><label class="expand" for="c-38390185">[1 more]</label></div><br/><div class="children"><div class="content">To put it in perspective, WebGPU 1.0, that 6 years later is still only available on Chrome, is the lowest common denominator from 2015 GPU hardware.</div><br/></div></div></div></div></div></div><div id="38386201" class="c"><input type="checkbox" id="c-38386201" checked=""/><div class="controls bullet"><span class="by">0xDEF</span><span>|</span><a href="#38386074">parent</a><span>|</span><a href="#38386174">prev</a><span>|</span><a href="#38386181">next</a><span>|</span><label class="collapse" for="c-38386201">[-]</label><label class="expand" for="c-38386201">[1 more]</label></div><br/><div class="children"><div class="content">Academic computer graphics research is in many places still using OpenGL 4.1.</div><br/></div></div><div id="38386181" class="c"><input type="checkbox" id="c-38386181" checked=""/><div class="controls bullet"><span class="by">all2</span><span>|</span><a href="#38386074">parent</a><span>|</span><a href="#38386201">prev</a><span>|</span><a href="#38386374">next</a><span>|</span><label class="collapse" for="c-38386181">[-]</label><label class="expand" for="c-38386181">[2 more]</label></div><br/><div class="children"><div class="content">Why is this the case?</div><br/><div id="38386522" class="c"><input type="checkbox" id="c-38386522" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#38386074">root</a><span>|</span><a href="#38386181">parent</a><span>|</span><a href="#38386374">next</a><span>|</span><label class="collapse" for="c-38386522">[-]</label><label class="expand" for="c-38386522">[1 more]</label></div><br/><div class="children"><div class="content">Because the amount of resources that Microsoft and NVIDIA pour at graphics programming dwarfs the amount of resources that <i>everybody else combined</i> seems willing to put into it.<p>The implementations are better.  The support is better.  The ecosystem is better.  The debugging tools are better.</div><br/></div></div></div></div></div></div><div id="38386374" class="c"><input type="checkbox" id="c-38386374" checked=""/><div class="controls bullet"><span class="by">adamnemecek</span><span>|</span><a href="#38386074">prev</a><span>|</span><a href="#38386036">next</a><span>|</span><label class="collapse" for="c-38386374">[-]</label><label class="expand" for="c-38386374">[10 more]</label></div><br/><div class="children"><div class="content">wgpu, the Rust WebGPU implementation is the bee&#x27;s knees. <a href="https:&#x2F;&#x2F;wgpu.rs&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;wgpu.rs&#x2F;</a> You can use it beyond the web.</div><br/><div id="38388222" class="c"><input type="checkbox" id="c-38388222" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#38386374">parent</a><span>|</span><a href="#38386036">next</a><span>|</span><label class="collapse" for="c-38388222">[-]</label><label class="expand" for="c-38388222">[9 more]</label></div><br/><div class="children"><div class="content">You think the first thing for someone who wants to learn graphics programming is to compile rust&#x27;s webgpu implementation?</div><br/><div id="38388960" class="c"><input type="checkbox" id="c-38388960" checked=""/><div class="controls bullet"><span class="by">TheRoque</span><span>|</span><a href="#38386374">root</a><span>|</span><a href="#38388222">parent</a><span>|</span><a href="#38388629">next</a><span>|</span><label class="collapse" for="c-38388960">[-]</label><label class="expand" for="c-38388960">[3 more]</label></div><br/><div class="children"><div class="content">WebGPU is a pretty good starting point, that&#x27;s what I did myself (with C++, not Rust though, which should be even more straightforward). You can even use it in the browser and skip all the native hassle.<p>Just learn the basic concepts like buffers, drawing, texture, light, perspective etc. from <a href="https:&#x2F;&#x2F;learnopengl.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;learnopengl.com&#x2F;</a> then you can jump into WebGPU. Even though there&#x27;s not that many WebGPU tutorial, applying the OpenGL tutorials to it is pretty straightforward once you understand the fundamentals.</div><br/><div id="38389021" class="c"><input type="checkbox" id="c-38389021" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#38386374">root</a><span>|</span><a href="#38388960">parent</a><span>|</span><a href="#38388629">next</a><span>|</span><label class="collapse" for="c-38389021">[-]</label><label class="expand" for="c-38389021">[2 more]</label></div><br/><div class="children"><div class="content">Using webgpu makes sense, but that isn&#x27;t what they said. They said compiling a rust webgpu implementation.</div><br/><div id="38389211" class="c"><input type="checkbox" id="c-38389211" checked=""/><div class="controls bullet"><span class="by">TheRoque</span><span>|</span><a href="#38386374">root</a><span>|</span><a href="#38389021">parent</a><span>|</span><a href="#38388629">next</a><span>|</span><label class="collapse" for="c-38389211">[-]</label><label class="expand" for="c-38389211">[1 more]</label></div><br/><div class="children"><div class="content">Since this is very straightforward to do, I took it as equivalent statements</div><br/></div></div></div></div></div></div><div id="38388629" class="c"><input type="checkbox" id="c-38388629" checked=""/><div class="controls bullet"><span class="by">jholman</span><span>|</span><a href="#38386374">root</a><span>|</span><a href="#38388222">parent</a><span>|</span><a href="#38388960">prev</a><span>|</span><a href="#38388839">next</a><span>|</span><label class="collapse" for="c-38388629">[-]</label><label class="expand" for="c-38388629">[1 more]</label></div><br/><div class="children"><div class="content">Obviously not.  Obviously the first thing for someone who wants to learn graphics programming is to learn Rust.  I&#x27;m surprised you asked.</div><br/></div></div><div id="38388839" class="c"><input type="checkbox" id="c-38388839" checked=""/><div class="controls bullet"><span class="by">adamnemecek</span><span>|</span><a href="#38386374">root</a><span>|</span><a href="#38388222">parent</a><span>|</span><a href="#38388629">prev</a><span>|</span><a href="#38386036">next</a><span>|</span><label class="collapse" for="c-38388839">[-]</label><label class="expand" for="c-38388839">[4 more]</label></div><br/><div class="children"><div class="content">It’s actually relatively small.</div><br/><div id="38389008" class="c"><input type="checkbox" id="c-38389008" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#38386374">root</a><span>|</span><a href="#38388839">parent</a><span>|</span><a href="#38386036">next</a><span>|</span><label class="collapse" for="c-38389008">[-]</label><label class="expand" for="c-38389008">[3 more]</label></div><br/><div class="children"><div class="content">So what? You don&#x27;t think they might need to learn math or a graphics API or fundamentals first? You think  they need to compile a rust webgpu implementation first because it&#x27;s small?<p>How does this make any sense?</div><br/><div id="38389224" class="c"><input type="checkbox" id="c-38389224" checked=""/><div class="controls bullet"><span class="by">TheRoque</span><span>|</span><a href="#38386374">root</a><span>|</span><a href="#38389008">parent</a><span>|</span><a href="#38389518">next</a><span>|</span><label class="collapse" for="c-38389224">[-]</label><label class="expand" for="c-38389224">[1 more]</label></div><br/><div class="children"><div class="content">You can learn along the way. If you learned with the famous learnopengl website, you learn about compiling glad, glfw and putting up a C++, along with maths, all at the same time, incrementally... The tutorials for Rust&#x27;s wgpu isn&#x27;t any different.</div><br/></div></div><div id="38389518" class="c"><input type="checkbox" id="c-38389518" checked=""/><div class="controls bullet"><span class="by">adamnemecek</span><span>|</span><a href="#38386374">root</a><span>|</span><a href="#38389008">parent</a><span>|</span><a href="#38389224">prev</a><span>|</span><a href="#38386036">next</a><span>|</span><label class="collapse" for="c-38389518">[-]</label><label class="expand" for="c-38389518">[1 more]</label></div><br/><div class="children"><div class="content">What do you think wgpu is if not a graphics API?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38386036" class="c"><input type="checkbox" id="c-38386036" checked=""/><div class="controls bullet"><span class="by">lopkeny12ko</span><span>|</span><a href="#38386374">prev</a><span>|</span><label class="collapse" for="c-38386036">[-]</label><label class="expand" for="c-38386036">[8 more]</label></div><br/><div class="children"><div class="content">Ah, the AMD Game Engineering team, the same fine folks who implemented driver-level &quot;optimizations&quot; for Counter Strike that resulted in thousands of players getting permanently VAC banned.</div><br/><div id="38386160" class="c"><input type="checkbox" id="c-38386160" checked=""/><div class="controls bullet"><span class="by">voldacar</span><span>|</span><a href="#38386036">parent</a><span>|</span><label class="collapse" for="c-38386160">[-]</label><label class="expand" for="c-38386160">[7 more]</label></div><br/><div class="children"><div class="content">The vac bans got reversed.</div><br/><div id="38386167" class="c"><input type="checkbox" id="c-38386167" checked=""/><div class="controls bullet"><span class="by">qup</span><span>|</span><a href="#38386036">root</a><span>|</span><a href="#38386160">parent</a><span>|</span><a href="#38386503">next</a><span>|</span><label class="collapse" for="c-38386167">[-]</label><label class="expand" for="c-38386167">[1 more]</label></div><br/><div class="children"><div class="content">Temporarily permanently banned</div><br/></div></div><div id="38386503" class="c"><input type="checkbox" id="c-38386503" checked=""/><div class="controls bullet"><span class="by">lopkeny12ko</span><span>|</span><a href="#38386036">root</a><span>|</span><a href="#38386160">parent</a><span>|</span><a href="#38386167">prev</a><span>|</span><label class="collapse" for="c-38386503">[-]</label><label class="expand" for="c-38386503">[5 more]</label></div><br/><div class="children"><div class="content">I fail to see how that excuses sloppy engineering.</div><br/><div id="38387203" class="c"><input type="checkbox" id="c-38387203" checked=""/><div class="controls bullet"><span class="by">voldacar</span><span>|</span><a href="#38386036">root</a><span>|</span><a href="#38386503">parent</a><span>|</span><a href="#38386734">next</a><span>|</span><label class="collapse" for="c-38387203">[-]</label><label class="expand" for="c-38387203">[1 more]</label></div><br/><div class="children"><div class="content">I agree with that, I was just correcting you. It&#x27;s crazy that they deliberately altered the code of a running program like that, especially one which is going to have an anti-cheat system.</div><br/></div></div><div id="38386734" class="c"><input type="checkbox" id="c-38386734" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38386036">root</a><span>|</span><a href="#38386503">parent</a><span>|</span><a href="#38387203">prev</a><span>|</span><label class="collapse" for="c-38386734">[-]</label><label class="expand" for="c-38386734">[3 more]</label></div><br/><div class="children"><div class="content">It wasn&#x27;t sloppy engineering unless you are saying AMD should have used a VAC bypass</div><br/><div id="38387363" class="c"><input type="checkbox" id="c-38387363" checked=""/><div class="controls bullet"><span class="by">TillE</span><span>|</span><a href="#38386036">root</a><span>|</span><a href="#38386734">parent</a><span>|</span><label class="collapse" for="c-38387363">[-]</label><label class="expand" for="c-38387363">[2 more]</label></div><br/><div class="children"><div class="content">Injecting code into third-party DLLs is as sloppy as it gets. It&#x27;s an awful hack.</div><br/><div id="38388472" class="c"><input type="checkbox" id="c-38388472" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38386036">root</a><span>|</span><a href="#38387363">parent</a><span>|</span><label class="collapse" for="c-38388472">[-]</label><label class="expand" for="c-38388472">[1 more]</label></div><br/><div class="children"><div class="content">An AMD DLL always has been loaded into the game&#x27;s process.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>