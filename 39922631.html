<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712221254621" as="style"/><link rel="stylesheet" href="styles.css?v=1712221254621"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/zeroasiccorp/logik">Logik: Open-source FPGA toolchain by Zero ASIC</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>jasondavies</span> | <span>30 comments</span></div><br/><div><div id="39923967" class="c"><input type="checkbox" id="c-39923967" checked=""/><div class="controls bullet"><span class="by">zachbee</span><span>|</span><a href="#39924722">next</a><span>|</span><label class="collapse" for="c-39923967">[-]</label><label class="expand" for="c-39923967">[4 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t appear to support any FPGAs other than their FPGA chiplet [1]. Also, like UncleOxidant said, the most complex parts of this toolchain are just existing open-source tools (Yosys and VPR).<p>This seems like a useful toolchain for ZeroASIC customers who are using their hardware, but not for FPGA enthusiasts more broadly.<p>[1]. <a href="https:&#x2F;&#x2F;www.zeroasic.com&#x2F;chiplets&#x2F;fpga" rel="nofollow">https:&#x2F;&#x2F;www.zeroasic.com&#x2F;chiplets&#x2F;fpga</a></div><br/><div id="39924227" class="c"><input type="checkbox" id="c-39924227" checked=""/><div class="controls bullet"><span class="by">hedgehog</span><span>|</span><a href="#39923967">parent</a><span>|</span><a href="#39924162">next</a><span>|</span><label class="collapse" for="c-39924227">[-]</label><label class="expand" for="c-39924227">[1 more]</label></div><br/><div class="children"><div class="content">I think it supports whatever SiliconCompiler supports (which is both FPGA and different ASIC flows) and the EBRICK example is showing how to put that design onto an ASIC or FPGA for testing.<p>Edit: Here&#x27;s the SiliconCompiler list: <a href="https:&#x2F;&#x2F;docs.siliconcompiler.com&#x2F;en&#x2F;stable&#x2F;user_guide&#x2F;introduction.html#supported-technologies" rel="nofollow">https:&#x2F;&#x2F;docs.siliconcompiler.com&#x2F;en&#x2F;stable&#x2F;user_guide&#x2F;introd...</a></div><br/></div></div><div id="39924162" class="c"><input type="checkbox" id="c-39924162" checked=""/><div class="controls bullet"><span class="by">sitzkrieg</span><span>|</span><a href="#39923967">parent</a><span>|</span><a href="#39924227">prev</a><span>|</span><a href="#39924385">next</a><span>|</span><label class="collapse" for="c-39924162">[-]</label><label class="expand" for="c-39924162">[1 more]</label></div><br/><div class="children"><div class="content">yea this caught me too. that online digital twin is pretty slick tho</div><br/></div></div><div id="39924385" class="c"><input type="checkbox" id="c-39924385" checked=""/><div class="controls bullet"><span class="by">cushychicken</span><span>|</span><a href="#39923967">parent</a><span>|</span><a href="#39924162">prev</a><span>|</span><a href="#39924722">next</a><span>|</span><label class="collapse" for="c-39924385">[-]</label><label class="expand" for="c-39924385">[1 more]</label></div><br/><div class="children"><div class="content">Commoditize your complements, baby.</div><br/></div></div></div></div><div id="39924722" class="c"><input type="checkbox" id="c-39924722" checked=""/><div class="controls bullet"><span class="by">marcodiego</span><span>|</span><a href="#39923967">prev</a><span>|</span><a href="#39926350">next</a><span>|</span><label class="collapse" for="c-39924722">[-]</label><label class="expand" for="c-39924722">[17 more]</label></div><br/><div class="children"><div class="content">I use to say this whenever I see anything related to FPGA: the FPGA world needs it&#x27;s equivalent to Arduino. Before the Arduino, the world of microcontrollers was dominated by bad proprietary tools; the FPGA world suffers of the same illness today.<p>We really need to fix this before FPGA&#x27;s falls in the hands and hearts of any willing hobbyist.</div><br/><div id="39927120" class="c"><input type="checkbox" id="c-39927120" checked=""/><div class="controls bullet"><span class="by">dailykoder</span><span>|</span><a href="#39924722">parent</a><span>|</span><a href="#39927833">next</a><span>|</span><label class="collapse" for="c-39927120">[-]</label><label class="expand" for="c-39927120">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what I used to believe and it&#x27;s probably true, but I think it will not really happen. You just don&#x27;t need FPGAs for most things. Especially if you just like to tinker around. I mean we have Microcontrollers running at 600MHz+. That&#x27;s usually fast enough to get things sorted in software.<p>I do have hell of a lot fun designing my own CPUs and other hardware on FPGAs, but I&#x27;ve been doing this for a couple of years now and whenever I talk to someone who hasn&#x27;t done any development in that direction yet, I often have to remind myself that hardware development is just a completely different mindset.<p>Yes, copy pasting a few logic gates into vhdl is easy, but I don&#x27;t know how you would go on from that if you just want to have fun. Getting something done in hardware can be really frustrating sometimes. Maybe all the &quot;new-age HDLs&quot; might be a solution to this - i have to admit i haven&#x27;t really tried them out yet.</div><br/><div id="39927939" class="c"><input type="checkbox" id="c-39927939" checked=""/><div class="controls bullet"><span class="by">RantyDave</span><span>|</span><a href="#39924722">root</a><span>|</span><a href="#39927120">parent</a><span>|</span><a href="#39927833">next</a><span>|</span><label class="collapse" for="c-39927939">[-]</label><label class="expand" for="c-39927939">[1 more]</label></div><br/><div class="children"><div class="content">&gt; we have Microcontrollers running at 600MHz+<p>The RP2040 has little tiny processors dedicated to bit banging. I think at this point the only thing you need FPGA&#x27;s for is mega bandwidth stuff.</div><br/></div></div></div></div><div id="39927833" class="c"><input type="checkbox" id="c-39927833" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#39924722">parent</a><span>|</span><a href="#39927120">prev</a><span>|</span><a href="#39927745">next</a><span>|</span><label class="collapse" for="c-39927833">[-]</label><label class="expand" for="c-39927833">[1 more]</label></div><br/><div class="children"><div class="content">Before you can have an arduino you need a gcc. Arduino itself was just a user-friendly wrapper over the existing work of making an open-source cross compiler for the platform.</div><br/></div></div><div id="39927745" class="c"><input type="checkbox" id="c-39927745" checked=""/><div class="controls bullet"><span class="by">bogantech</span><span>|</span><a href="#39924722">parent</a><span>|</span><a href="#39927833">prev</a><span>|</span><a href="#39926578">next</a><span>|</span><label class="collapse" for="c-39927745">[-]</label><label class="expand" for="c-39927745">[1 more]</label></div><br/><div class="children"><div class="content">I lack imagination, what would the beginner do&#x2F;create with a simple to use FPGA toolchain?<p>If it&#x27;s just open tools you need then yosys is a thing.</div><br/></div></div><div id="39926578" class="c"><input type="checkbox" id="c-39926578" checked=""/><div class="controls bullet"><span class="by">eyegor</span><span>|</span><a href="#39924722">parent</a><span>|</span><a href="#39927745">prev</a><span>|</span><a href="#39925161">next</a><span>|</span><label class="collapse" for="c-39926578">[-]</label><label class="expand" for="c-39926578">[3 more]</label></div><br/><div class="children"><div class="content">Closest I can think of, $70: <a href="https:&#x2F;&#x2F;nandland.com&#x2F;the-go-board&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nandland.com&#x2F;the-go-board&#x2F;</a><p>The problem with FPGAs is they&#x27;re inherently unfriendly to beginners. Thinking in HDL is a bit more difficult than a high level language like scratch or arduino c++. Plus the &quot;compile times&quot; are absurd so a beginner would probably lose patience.</div><br/><div id="39927778" class="c"><input type="checkbox" id="c-39927778" checked=""/><div class="controls bullet"><span class="by">DrFalkyn</span><span>|</span><a href="#39924722">root</a><span>|</span><a href="#39926578">parent</a><span>|</span><a href="#39925161">next</a><span>|</span><label class="collapse" for="c-39927778">[-]</label><label class="expand" for="c-39927778">[2 more]</label></div><br/><div class="children"><div class="content">LabVIEW has had FPGA programming as block diagrams for a good 15 years now.  Vivado has something similar.<p>Programming FPGA as block diagrams is very natural, because you are essentially designing a circuit.  So strictly speaking, you don&#x27;t need to learn a HDL to do FPGA anymore</div><br/></div></div></div></div><div id="39925161" class="c"><input type="checkbox" id="c-39925161" checked=""/><div class="controls bullet"><span class="by">0xcde4c3db</span><span>|</span><a href="#39924722">parent</a><span>|</span><a href="#39926578">prev</a><span>|</span><a href="#39926895">next</a><span>|</span><label class="collapse" for="c-39925161">[-]</label><label class="expand" for="c-39925161">[4 more]</label></div><br/><div class="children"><div class="content">People have been working on it for years, but it&#x27;s a <i>lot</i> of work when the chip vendor isn&#x27;t helping to make it happen. At this point it&#x27;s more akin to building reverse-engineered GPU drivers like Panfrost and Nouveau than a platform like Arduino (where AVR was well-documented by Atmel and avr-gcc already existed).</div><br/><div id="39925460" class="c"><input type="checkbox" id="c-39925460" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#39924722">root</a><span>|</span><a href="#39925161">parent</a><span>|</span><a href="#39926895">next</a><span>|</span><label class="collapse" for="c-39925460">[-]</label><label class="expand" for="c-39925460">[3 more]</label></div><br/><div class="children"><div class="content">The solution is to build our own FPGAs, fpgas are not more complex than any other ASIC, in fact more regular and simpler.<p>There are multiple fpga fabric generators<p>FABulous  OpenFPGA  PRGA  Uranus<p>All of which could lay down a fabric that could be programmed by OSS tools.</div><br/><div id="39926416" class="c"><input type="checkbox" id="c-39926416" checked=""/><div class="controls bullet"><span class="by">adapteva</span><span>|</span><a href="#39924722">root</a><span>|</span><a href="#39925460">parent</a><span>|</span><a href="#39926895">next</a><span>|</span><label class="collapse" for="c-39926416">[-]</label><label class="expand" for="c-39926416">[2 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s a great idea, but none of the projects you mentioned are ready for production. Who will find the building of these products?</div><br/><div id="39926495" class="c"><input type="checkbox" id="c-39926495" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#39924722">root</a><span>|</span><a href="#39926416">parent</a><span>|</span><a href="#39926895">next</a><span>|</span><label class="collapse" for="c-39926495">[-]</label><label class="expand" for="c-39926495">[1 more]</label></div><br/><div class="children"><div class="content">:)</div><br/></div></div></div></div></div></div></div></div><div id="39926895" class="c"><input type="checkbox" id="c-39926895" checked=""/><div class="controls bullet"><span class="by">Ticktok</span><span>|</span><a href="#39924722">parent</a><span>|</span><a href="#39925161">prev</a><span>|</span><a href="#39925601">next</a><span>|</span><label class="collapse" for="c-39926895">[-]</label><label class="expand" for="c-39926895">[1 more]</label></div><br/><div class="children"><div class="content">The (Upduino)[<a href="https:&#x2F;&#x2F;tinyvision.ai&#x2F;products&#x2F;upduino-v3-1" rel="nofollow">https:&#x2F;&#x2F;tinyvision.ai&#x2F;products&#x2F;upduino-v3-1</a>] and the (pico-ice)[<a href="https:&#x2F;&#x2F;tinyvision.ai&#x2F;products&#x2F;pico-ice" rel="nofollow">https:&#x2F;&#x2F;tinyvision.ai&#x2F;products&#x2F;pico-ice</a>] try to meet that solution to me. Both cheap, easy to use fpga boards that are completely compatible with the opensource toolchain.</div><br/></div></div><div id="39925601" class="c"><input type="checkbox" id="c-39925601" checked=""/><div class="controls bullet"><span class="by">qiqitori</span><span>|</span><a href="#39924722">parent</a><span>|</span><a href="#39926895">prev</a><span>|</span><a href="#39926350">next</a><span>|</span><label class="collapse" for="c-39925601">[-]</label><label class="expand" for="c-39925601">[4 more]</label></div><br/><div class="children"><div class="content">Lattice Semiconductor&#x27;s iCE40 sort of qualifies, no? (Maybe getting a little old now?) Cheap and fully supported by an open-source toolchain and really easy to use. (Unless a GUI is needed.)</div><br/><div id="39926237" class="c"><input type="checkbox" id="c-39926237" checked=""/><div class="controls bullet"><span class="by">codebje</span><span>|</span><a href="#39924722">root</a><span>|</span><a href="#39925601">parent</a><span>|</span><a href="#39926350">next</a><span>|</span><label class="collapse" for="c-39926237">[-]</label><label class="expand" for="c-39926237">[3 more]</label></div><br/><div class="children"><div class="content">iCE40 was a good start, but boards based around that family are getting hard to find. For those who are building their own PCB and want an FPGA on it with minimal fuss, the iCE40HX1K comes in a TQFP-144 package and is still readily available from the usual retailers for such things. Nice for hobby PCB makers, but not a current-day solution for easy FPGA projects for software devs.<p>IMO Sipeed Tang is the product most like Arduino for FPGAs: boards ready to program with a USB cable and a range of plug-in-and-go peripheral boards available. The Gowin IDE is free but not open, while the yosys+nextpnr open toolchain claims full support for the FPGAs on the Tang boards.<p>LiteX makes speccing out an FPGA core much more approachable for someone from a software development background, too, so LiteX plus a Tang Nano 20k and you can do all sorts of awesome things without too much trouble.</div><br/><div id="39926392" class="c"><input type="checkbox" id="c-39926392" checked=""/><div class="controls bullet"><span class="by">MegaDeKay</span><span>|</span><a href="#39924722">root</a><span>|</span><a href="#39926237">parent</a><span>|</span><a href="#39926350">next</a><span>|</span><label class="collapse" for="c-39926392">[-]</label><label class="expand" for="c-39926392">[2 more]</label></div><br/><div class="children"><div class="content">&gt; while the yosys+nextpnr open toolchain claims full support for the FPGAs on the Tang boards<p>Citation needed. The GoWin FPGAs on these boards are still very much a work in progress. YRabbit is doing most of the reverse engineering on them, it seems, with the DSP blocks only implemented a couple weeks ago.<p><a href="https:&#x2F;&#x2F;twitter.com&#x2F;YLRabbit&#x2F;status&#x2F;1768935258903503248" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;YLRabbit&#x2F;status&#x2F;1768935258903503248</a></div><br/><div id="39927316" class="c"><input type="checkbox" id="c-39927316" checked=""/><div class="controls bullet"><span class="by">codebje</span><span>|</span><a href="#39924722">root</a><span>|</span><a href="#39926392">parent</a><span>|</span><a href="#39926350">next</a><span>|</span><label class="collapse" for="c-39927316">[-]</label><label class="expand" for="c-39927316">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;YosysHQ&#x2F;apicula">https:&#x2F;&#x2F;github.com&#x2F;YosysHQ&#x2F;apicula</a><p>Project Apicula says &quot;currently supported boards are ... [list of mostly Tang boards]&quot; without qualification.<p>I wouldn&#x27;t be surprised to discover that it actually is qualified support, though. Do you think the actual support is low enough that one should avoid those boards for now?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39926350" class="c"><input type="checkbox" id="c-39926350" checked=""/><div class="controls bullet"><span class="by">adapteva</span><span>|</span><a href="#39924722">prev</a><span>|</span><a href="#39925069">next</a><span>|</span><label class="collapse" for="c-39926350">[-]</label><label class="expand" for="c-39926350">[1 more]</label></div><br/><div class="children"><div class="content">Haha, cool to see this on HN.:-)<p>Yosys and vpr is clearly doing the heavy lifting here...the novelty here is the fact that an FPGA startup is giving public access to the fpga pre production and is opening the bit stream format. This hasn&#x27;t really been done before.</div><br/></div></div><div id="39925069" class="c"><input type="checkbox" id="c-39925069" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#39926350">prev</a><span>|</span><a href="#39923900">next</a><span>|</span><label class="collapse" for="c-39925069">[-]</label><label class="expand" for="c-39925069">[3 more]</label></div><br/><div class="children"><div class="content">In computer programming, you can get say a ~10x speed improvement between writing bit twiddling code in python and hand writing SIMD assembly to do the same job.<p>Is there a similar gaping gap between writing verilog for something, vs hand-designing the lookup tables and laying out the FPGA routing?</div><br/><div id="39926903" class="c"><input type="checkbox" id="c-39926903" checked=""/><div class="controls bullet"><span class="by">nrclark</span><span>|</span><a href="#39925069">parent</a><span>|</span><a href="#39925472">next</a><span>|</span><label class="collapse" for="c-39926903">[-]</label><label class="expand" for="c-39926903">[1 more]</label></div><br/><div class="children"><div class="content">Most FPGAs have various kinds of primitives that can be instantiated manually in the middle of a larger Verilog design. Sometimes those primitives can be used to do things that are very hard to make the synthesizer create automatically.<p>In general, the synthesizer will be better than you at anything lookup-table or flip-flop related. Ditto for simple primitives like shift-registers. But it probably doesn&#x27;t know how to infer the more complicated primitives, and so those are usually done with the Verilog equivalent of inline assembly.<p>For a few tight designs, I&#x27;ve given some hints to the the placer. These are things like grouping components together, or setting location constraints on a few key primitives. That kind of thing isn&#x27;t too uncommon. I&#x27;ve never seen anybody try to route things manually though.</div><br/></div></div><div id="39925472" class="c"><input type="checkbox" id="c-39925472" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#39925069">parent</a><span>|</span><a href="#39926903">prev</a><span>|</span><a href="#39923900">next</a><span>|</span><label class="collapse" for="c-39925472">[-]</label><label class="expand" for="c-39925472">[1 more]</label></div><br/><div class="children"><div class="content">Python to SIMD is 1000x, to HDL it is 10k to 100k multiple.<p>Python is 100x slower than native code. SIMD often gets you a 10x increase or more from native.</div><br/></div></div></div></div><div id="39923900" class="c"><input type="checkbox" id="c-39923900" checked=""/><div class="controls bullet"><span class="by">UncleOxidant</span><span>|</span><a href="#39925069">prev</a><span>|</span><a href="#39924687">next</a><span>|</span><label class="collapse" for="c-39923900">[-]</label><label class="expand" for="c-39923900">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t it Yosys and VPR doing the heavy lifting here?</div><br/><div id="39926408" class="c"><input type="checkbox" id="c-39926408" checked=""/><div class="controls bullet"><span class="by">adapteva</span><span>|</span><a href="#39923900">parent</a><span>|</span><a href="#39924687">next</a><span>|</span><label class="collapse" for="c-39926408">[-]</label><label class="expand" for="c-39926408">[1 more]</label></div><br/><div class="children"><div class="content">Yes</div><br/></div></div></div></div><div id="39924687" class="c"><input type="checkbox" id="c-39924687" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#39923900">prev</a><span>|</span><label class="collapse" for="c-39924687">[-]</label><label class="expand" for="c-39924687">[2 more]</label></div><br/><div class="children"><div class="content">What are the advantages of this? e.g. How does this compare to using a Makefile?<p>(which is what I&#x27;ve been doing so far, and does not feel complex)</div><br/><div id="39926405" class="c"><input type="checkbox" id="c-39926405" checked=""/><div class="controls bullet"><span class="by">adapteva</span><span>|</span><a href="#39924687">parent</a><span>|</span><label class="collapse" for="c-39926405">[-]</label><label class="expand" for="c-39926405">[1 more]</label></div><br/><div class="children"><div class="content">Makefiles can work for simple builds. Logik being Python based can do so much more: automated metrics gathering, conditional flows, parallel execution, error handling, dependency management</div><br/></div></div></div></div></div></div></div></div></div></body></html>