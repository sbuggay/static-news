<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1703062865710" as="style"/><link rel="stylesheet" href="styles.css?v=1703062865710"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jepsen.io/analyses/mysql-8.0.34">Jepsen: MySQL 8.0.34</a> <span class="domain">(<a href="https://jepsen.io">jepsen.io</a>)</span></div><div class="subtext"><span>aphyr</span> | <span>118 comments</span></div><br/><div><div id="38704438" class="c"><input type="checkbox" id="c-38704438" checked=""/><div class="controls bullet"><span class="by">tzone</span><span>|</span><a href="#38705090">next</a><span>|</span><label class="collapse" for="c-38704438">[-]</label><label class="expand" for="c-38704438">[7 more]</label></div><br/><div class="children"><div class="content">I have been advocating for the longest time that &quot;repeatable read&quot; is just a bad idea. Even if implementations were perfect. Even when it works correctly in the Database, it is still very tricky to reason about when dealing with complex queries.<p>I think two isolation levels that make sense are either:<p>* read committed<p>* serializable<p>You either go all the way to have a serializable setup, where there are no surprises. OR, you go in read committed direction where it is obvious that if you want have a consistent view of the data within a transaction, you have to lock the rows before you start reading them.<p>Read committed is very similar to just regular multi-threaded code and its memory management, so most engineers can get a decent intuitive sense for it.<p>Serializable is so strict that it is pretty hard to make very unexpected mistakes.<p>Anything in-between is a no man&#x27;s land. And anything less consistent than Read Committed is no longer really a database.</div><br/><div id="38704517" class="c"><input type="checkbox" id="c-38704517" checked=""/><div class="controls bullet"><span class="by">jasonwatkinspdx</span><span>|</span><a href="#38704438">parent</a><span>|</span><a href="#38705215">next</a><span>|</span><label class="collapse" for="c-38704517">[-]</label><label class="expand" for="c-38704517">[3 more]</label></div><br/><div class="children"><div class="content">Read only snapshot queries are very useful in practical systems.</div><br/><div id="38704624" class="c"><input type="checkbox" id="c-38704624" checked=""/><div class="controls bullet"><span class="by">tzone</span><span>|</span><a href="#38704438">root</a><span>|</span><a href="#38704517">parent</a><span>|</span><a href="#38705215">next</a><span>|</span><label class="collapse" for="c-38704624">[-]</label><label class="expand" for="c-38704624">[2 more]</label></div><br/><div class="children"><div class="content">Here is my issue with this. We are assuming you need to read a &quot;consistent snapshot&quot; in some type of real time application. Because if it isn&#x27;t real time, you can always have those snapshot type of querying on &quot;replicas&quot;, since that is a lot easier to implement correctly without sacrificing performance.<p>So assuming you are looking at reading &quot;consistent snapshot&quot; in the context of a real time transaction. If the data that you want to read as a &quot;consistent snapshot&quot; is small, locking + reading is good enough in most cases.<p>If the data to read is too large (i.e. query takes long time to execute, and pulls a lot of data), you are going to have ton of scaling issues if you are depending on something like &quot;repeatable read&quot;. Long running transactions, long running queries, etc are bane of all the database scaling and performance.<p>So you really want to avoid that anyways, you would almost always be much better of changing your application logic to make sure you can have much shorter, time bounded transactions and queries and setup better application level consistency scheme. Otherwise you will at some point hit scaling&#x2F;performance problems and they will be an absolute nightmare to fix.</div><br/><div id="38704878" class="c"><input type="checkbox" id="c-38704878" checked=""/><div class="controls bullet"><span class="by">jasonwatkinspdx</span><span>|</span><a href="#38704438">root</a><span>|</span><a href="#38704624">parent</a><span>|</span><a href="#38705215">next</a><span>|</span><label class="collapse" for="c-38704878">[-]</label><label class="expand" for="c-38704878">[1 more]</label></div><br/><div class="children"><div class="content">Under MVCC this does not require locks which is a non trivial overhead savings for use cases that can tolerate slightly stale data, but want that data to be internally consistent, ie no read skew (and write skew is irrelevant in read only queries). This combination of strict serializable + read only snapshots is quite common with recently developed databases.</div><br/></div></div></div></div></div></div><div id="38705215" class="c"><input type="checkbox" id="c-38705215" checked=""/><div class="controls bullet"><span class="by">rockwotj</span><span>|</span><a href="#38704438">parent</a><span>|</span><a href="#38704517">prev</a><span>|</span><a href="#38704474">next</a><span>|</span><label class="collapse" for="c-38705215">[-]</label><label class="expand" for="c-38705215">[1 more]</label></div><br/><div class="children"><div class="content">I honestly don&#x27;t think I&#x27;ve seen people reason about read committed well, especially as an application grows it becomes very difficult to understand all the cases in which locks are grabbed&#x2F;data is accessed. (I feel that way about multi-threaded code and locks too, but that&#x27;s for another time).<p>So I really only see serializable to be the only sane isolation model (for r&#x2F;w transactions), and snapshot isolation is a good model for readonly transactions (basically you get a frozen in time snapshot of the database to work with). This also happens to be the only modes in which Spanner gives you: <a href="https:&#x2F;&#x2F;cloud.google.com&#x2F;spanner&#x2F;docs&#x2F;transactions" rel="nofollow noreferrer">https:&#x2F;&#x2F;cloud.google.com&#x2F;spanner&#x2F;docs&#x2F;transactions</a></div><br/></div></div><div id="38704474" class="c"><input type="checkbox" id="c-38704474" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#38704438">parent</a><span>|</span><a href="#38705215">prev</a><span>|</span><a href="#38705090">next</a><span>|</span><label class="collapse" for="c-38704474">[-]</label><label class="expand" for="c-38704474">[2 more]</label></div><br/><div class="children"><div class="content">But you wouldn’t need to lock them if repeatable read actually worked</div><br/><div id="38704706" class="c"><input type="checkbox" id="c-38704706" checked=""/><div class="controls bullet"><span class="by">tzone</span><span>|</span><a href="#38704438">root</a><span>|</span><a href="#38704474">parent</a><span>|</span><a href="#38705090">next</a><span>|</span><label class="collapse" for="c-38704706">[-]</label><label class="expand" for="c-38704706">[1 more]</label></div><br/><div class="children"><div class="content">That is sort of my point. I think &quot;repeatable read&quot; is a fools gold. You think you wont need to do locking, but it is too easy to make incorrect assumptions about what guarantees &quot;repeatable read&quot; provides and you can make very subtle mistakes which leads to rare, extremely hard to diagnose correctness issues.<p>Repeatable read type of setups also make it much easier to accidentally create much longer running transactions, and long running transactions&#x2F;too many concurrent open transactions&#x2F;etc can create really unexpected, very hard to resolve performance issues in the long run for any database.</div><br/></div></div></div></div></div></div><div id="38705090" class="c"><input type="checkbox" id="c-38705090" checked=""/><div class="controls bullet"><span class="by">Corrado</span><span>|</span><a href="#38704438">prev</a><span>|</span><a href="#38699128">next</a><span>|</span><label class="collapse" for="c-38705090">[-]</label><label class="expand" for="c-38705090">[1 more]</label></div><br/><div class="children"><div class="content">I appreciate the write-up and the nod to AWS RDS.  However, I was wondering if there was any focus on AWS Aurora (MySQL)?  For those that don&#x27;t know, AWS build a protocol compatible database platform that pretends to be MySQL or PostgreSQL.  It would be interesting to see if Aurora MySQL has the same &quot;features&quot; as RDS or even MariaDB.</div><br/></div></div><div id="38699128" class="c"><input type="checkbox" id="c-38699128" checked=""/><div class="controls bullet"><span class="by">pella</span><span>|</span><a href="#38705090">prev</a><span>|</span><a href="#38700754">next</a><span>|</span><label class="collapse" for="c-38699128">[-]</label><label class="expand" for="c-38699128">[1 more]</label></div><br/><div class="children"><div class="content">FOSSDEM-2024 :<p>Isolation Levels and MVCC in SQL Databases: A Technical Comparative Study<p>&#x2F;&#x2F;  Oracle, MySQL, SQL Server, PostgreSQL, and YugabyteDB.<p><a href="https:&#x2F;&#x2F;fosdem.org&#x2F;2024&#x2F;schedule&#x2F;event&#x2F;fosdem-2024-3600-isolation-levels-and-mvcc-in-sql-databases-a-technical-comparative-study&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;fosdem.org&#x2F;2024&#x2F;schedule&#x2F;event&#x2F;fosdem-2024-3600-isol...</a></div><br/></div></div><div id="38700754" class="c"><input type="checkbox" id="c-38700754" checked=""/><div class="controls bullet"><span class="by">PeterZaitsev</span><span>|</span><a href="#38699128">prev</a><span>|</span><a href="#38704281">next</a><span>|</span><label class="collapse" for="c-38700754">[-]</label><label class="expand" for="c-38700754">[2 more]</label></div><br/><div class="children"><div class="content">Facinating read. I think it is a great illustration to show how many &quot;practically working systems&quot; can be built on the foundation exhibiting so many consistency artifacts</div><br/><div id="38704482" class="c"><input type="checkbox" id="c-38704482" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#38700754">parent</a><span>|</span><a href="#38704281">next</a><span>|</span><label class="collapse" for="c-38704482">[-]</label><label class="expand" for="c-38704482">[1 more]</label></div><br/><div class="children"><div class="content">Most systems are practically broken and it’s worked around by human factors</div><br/></div></div></div></div><div id="38704281" class="c"><input type="checkbox" id="c-38704281" checked=""/><div class="controls bullet"><span class="by">hipadev23</span><span>|</span><a href="#38700754">prev</a><span>|</span><a href="#38696682">next</a><span>|</span><label class="collapse" for="c-38704281">[-]</label><label class="expand" for="c-38704281">[8 more]</label></div><br/><div class="children"><div class="content">&quot;SELECT ... FOR UPDATE&quot; seems to be the answer to all these issues right? Lock the rows you&#x27;re going to be updating and suddenly everything works as advertised.</div><br/><div id="38704431" class="c"><input type="checkbox" id="c-38704431" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#38704281">parent</a><span>|</span><a href="#38704291">next</a><span>|</span><label class="collapse" for="c-38704431">[-]</label><label class="expand" for="c-38704431">[1 more]</label></div><br/><div class="children"><div class="content">In general, stuff that locks rows tends to &quot;snap&quot; values into existence regardless of repeatable read.<p>If you want to update a record based upon data in another record, you should do a locking read on that something else and maybe the record you&#x27;re updating.  If you run an sql query to update a record based upon some other record using a single query, MySQL will lock both for you anyways.<p>If you need to update something based upon multiple something elses, in my experience that&#x27;s very deadlock prone.  Instead you should lock some kinda locking record, then do a repeatable read on the data you want, then do an update.<p>The point in time of the repeatable read isn&#x27;t established until you perform a consistent read.  Select... for update isn&#x27;t a consistent read.  So it works perfectly fine in the face of concurrency while not locking dozens or hundreds of rows using a normal SQL update.</div><br/></div></div><div id="38704291" class="c"><input type="checkbox" id="c-38704291" checked=""/><div class="controls bullet"><span class="by">xxpor</span><span>|</span><a href="#38704281">parent</a><span>|</span><a href="#38704431">prev</a><span>|</span><a href="#38696682">next</a><span>|</span><label class="collapse" for="c-38704291">[-]</label><label class="expand" for="c-38704291">[6 more]</label></div><br/><div class="children"><div class="content">If you want performance to completely tank, sure.</div><br/><div id="38704416" class="c"><input type="checkbox" id="c-38704416" checked=""/><div class="controls bullet"><span class="by">hipadev23</span><span>|</span><a href="#38704281">root</a><span>|</span><a href="#38704291">parent</a><span>|</span><a href="#38696682">next</a><span>|</span><label class="collapse" for="c-38704416">[-]</label><label class="expand" for="c-38704416">[5 more]</label></div><br/><div class="children"><div class="content">Afaik, it only locks the row(s) in question. Do you have a setup where the same row is being updated by multiple clients all the time?</div><br/><div id="38705749" class="c"><input type="checkbox" id="c-38705749" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#38704281">root</a><span>|</span><a href="#38704416">parent</a><span>|</span><a href="#38704642">next</a><span>|</span><label class="collapse" for="c-38705749">[-]</label><label class="expand" for="c-38705749">[1 more]</label></div><br/><div class="children"><div class="content">SQL Server will escalate locks. Because keeping a million rows locked is expensive.</div><br/></div></div><div id="38704642" class="c"><input type="checkbox" id="c-38704642" checked=""/><div class="controls bullet"><span class="by">jtc331</span><span>|</span><a href="#38704281">root</a><span>|</span><a href="#38704416">parent</a><span>|</span><a href="#38705749">prev</a><span>|</span><a href="#38696682">next</a><span>|</span><label class="collapse" for="c-38704642">[-]</label><label class="expand" for="c-38704642">[3 more]</label></div><br/><div class="children"><div class="content">SELECT FOR UPDATE means two queries can’t _read_ the same row at the same time, right?</div><br/><div id="38704761" class="c"><input type="checkbox" id="c-38704761" checked=""/><div class="controls bullet"><span class="by">hipadev23</span><span>|</span><a href="#38704281">root</a><span>|</span><a href="#38704642">parent</a><span>|</span><a href="#38696682">next</a><span>|</span><label class="collapse" for="c-38704761">[-]</label><label class="expand" for="c-38704761">[2 more]</label></div><br/><div class="children"><div class="content">To my understanding, yes. If you have broad select queries across all the rows, that would slow things down quite a bit.</div><br/><div id="38705048" class="c"><input type="checkbox" id="c-38705048" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#38704281">root</a><span>|</span><a href="#38704761">parent</a><span>|</span><a href="#38696682">next</a><span>|</span><label class="collapse" for="c-38705048">[-]</label><label class="expand" for="c-38705048">[1 more]</label></div><br/><div class="children"><div class="content">You can use SKIP LOCKED normally. That’s how popular queue implementations usually work. I believe pg even calls this out in their docs</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38696682" class="c"><input type="checkbox" id="c-38696682" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#38704281">prev</a><span>|</span><a href="#38699899">next</a><span>|</span><label class="collapse" for="c-38696682">[-]</label><label class="expand" for="c-38696682">[3 more]</label></div><br/><div class="children"><div class="content">How does append (a) map onto actual SQL operations on the given tables?  Are the TEXT fields being used as lists?<p>Also… I’ve been issues in MySQL repeatable read mode where a single SELECT, selecting a single row, returned impossible results. I think it was:<p><pre><code>    SELECT min(value), max(value) FROM table WHERE id = 1;
</code></pre>
where id is a primary key.  I got two <i>different</i> values for min and max.  That was a fun one.</div><br/><div id="38696828" class="c"><input type="checkbox" id="c-38696828" checked=""/><div class="controls bullet"><span class="by">aphyr</span><span>|</span><a href="#38696682">parent</a><span>|</span><a href="#38696799">next</a><span>|</span><label class="collapse" for="c-38696828">[-]</label><label class="expand" for="c-38696828">[1 more]</label></div><br/><div class="children"><div class="content">Yup! See <a href="https:&#x2F;&#x2F;jepsen.io&#x2F;analyses&#x2F;mysql-8.0.34#list-append" rel="nofollow noreferrer">https:&#x2F;&#x2F;jepsen.io&#x2F;analyses&#x2F;mysql-8.0.34#list-append</a>, which also has a link to the code: <a href="https:&#x2F;&#x2F;github.com&#x2F;jepsen-io&#x2F;mysql&#x2F;blob&#x2F;4c239cb5c66a7f1a55fa02ce4c9f43b7a70e9d0b&#x2F;src&#x2F;jepsen&#x2F;mysql&#x2F;append.clj#L33">https:&#x2F;&#x2F;github.com&#x2F;jepsen-io&#x2F;mysql&#x2F;blob&#x2F;4c239cb5c66a7f1a55fa...</a><p>This isn&#x27;t CONCAT-specific, BTW--we just use CONCAT because it allows us to infer anomalies in linear, rather than exponential time. Same kinds of behaviors manifest with plain old read&#x2F;write registers.</div><br/></div></div></div></div><div id="38699899" class="c"><input type="checkbox" id="c-38699899" checked=""/><div class="controls bullet"><span class="by">dasmoop</span><span>|</span><a href="#38696682">prev</a><span>|</span><a href="#38697022">next</a><span>|</span><label class="collapse" for="c-38699899">[-]</label><label class="expand" for="c-38699899">[3 more]</label></div><br/><div class="children"><div class="content">The RDS replication that stopped working after 5min messing with it, with no alert of failed health check is a bit worrying...</div><br/><div id="38701394" class="c"><input type="checkbox" id="c-38701394" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#38699899">parent</a><span>|</span><a href="#38704537">next</a><span>|</span><label class="collapse" for="c-38701394">[-]</label><label class="expand" for="c-38701394">[1 more]</label></div><br/><div class="children"><div class="content">Obviously the devil&#x27;s in the details, and it&#x27;s almost impossible to troubleshoot from a screencast, but my experience has been that AWS is generally pretty liberal with the CloudWatch Metrics, but does place the onus upon the user to dig through the 150++ of them to read the docs to find the one that matters. They also claim &lt;<a href="https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;AmazonRDS&#x2F;latest&#x2F;UserGuide&#x2F;USER_ReadRepl.html#USER_ReadRepl.Monitoring" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;AmazonRDS&#x2F;latest&#x2F;UserGuide&#x2F;USER_...</a>&gt; there&#x27;s a console table cell for the replication status, but my experience with the console is that often one must opt-in to having that column <i>shown</i> which is suboptimal :-(<p>That &quot;shared responsibility model,&quot; they lean on it heavily</div><br/></div></div><div id="38704537" class="c"><input type="checkbox" id="c-38704537" checked=""/><div class="controls bullet"><span class="by">mianos</span><span>|</span><a href="#38699899">parent</a><span>|</span><a href="#38701394">prev</a><span>|</span><a href="#38697022">next</a><span>|</span><label class="collapse" for="c-38704537">[-]</label><label class="expand" for="c-38704537">[1 more]</label></div><br/><div class="children"><div class="content">I can assure you, you can not trust any AWS health checks to be a primary alert for something down. You have to do it all yourself, on host, or inside the container.<p>AWS&#x2F;Rackspace support just say: &quot;It&#x27;s your problem as we don&#x27;t manage what is inside the AWS service&quot;.</div><br/></div></div></div></div><div id="38697022" class="c"><input type="checkbox" id="c-38697022" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#38699899">prev</a><span>|</span><a href="#38698772">next</a><span>|</span><label class="collapse" for="c-38697022">[-]</label><label class="expand" for="c-38697022">[4 more]</label></div><br/><div class="children"><div class="content">how about that, I planned to do some work today.<p>aphyr, thank you. call me maybe and later jepsen.io have been consistently some of the best content I&#x27;ve ever read on the internet.</div><br/><div id="38697078" class="c"><input type="checkbox" id="c-38697078" checked=""/><div class="controls bullet"><span class="by">aphyr</span><span>|</span><a href="#38697022">parent</a><span>|</span><a href="#38698772">next</a><span>|</span><label class="collapse" for="c-38697078">[-]</label><label class="expand" for="c-38697078">[3 more]</label></div><br/><div class="children"><div class="content">Aw shucks, thanks :-)</div><br/><div id="38697308" class="c"><input type="checkbox" id="c-38697308" checked=""/><div class="controls bullet"><span class="by">don_neufeld</span><span>|</span><a href="#38697022">root</a><span>|</span><a href="#38697078">parent</a><span>|</span><a href="#38699425">next</a><span>|</span><label class="collapse" for="c-38697308">[-]</label><label class="expand" for="c-38697308">[1 more]</label></div><br/><div class="children"><div class="content">Seriously, thanks for what you do!<p>I’ve been reading your stuff for almost 10 years and doing work at this level of rigor makes the world a better place.</div><br/></div></div><div id="38699425" class="c"><input type="checkbox" id="c-38699425" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#38697022">root</a><span>|</span><a href="#38697078">parent</a><span>|</span><a href="#38697308">prev</a><span>|</span><a href="#38698772">next</a><span>|</span><label class="collapse" for="c-38699425">[-]</label><label class="expand" for="c-38699425">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t use Jepsen, but I love your blog! Your &quot;x the Technical Interview&quot; series  are my absolute favorite.</div><br/></div></div></div></div></div></div><div id="38698772" class="c"><input type="checkbox" id="c-38698772" checked=""/><div class="controls bullet"><span class="by">PeterCorless</span><span>|</span><a href="#38697022">prev</a><span>|</span><a href="#38696421">next</a><span>|</span><label class="collapse" for="c-38698772">[-]</label><label class="expand" for="c-38698772">[7 more]</label></div><br/><div class="children"><div class="content">How much of what is contained within this analysis of MySQL is going to be the same-same for MariaDB, given that it uses InnoDB as the default storage engine?</div><br/><div id="38703962" class="c"><input type="checkbox" id="c-38703962" checked=""/><div class="controls bullet"><span class="by">semiquaver</span><span>|</span><a href="#38698772">parent</a><span>|</span><a href="#38704095">next</a><span>|</span><label class="collapse" for="c-38703962">[-]</label><label class="expand" for="c-38703962">[1 more]</label></div><br/><div class="children"><div class="content">Per the article, MariaDB was also tested.<p><pre><code>  &gt; We designed a small test suite for MySQL using the Jepsen testing library at version 0.3.4. We used the mysql-connector-j JDBC adapter as our client. We tested MySQL 8.0.34, and MariaDB 10.11.3 on Debian Bookworm. Our tests ran against a single MySQL node as well as binlog-replicated clusters with one or two read-only followers, without failover. We also ran our test suite against a hosted MySQL service: AWS’s RDS Cluster, using the “Multi-AZ DB Cluster” profile. This is the recommended default for production workloads, and offers a binlog-replicated deployment of MySQL 8.0.34 where secondary nodes support read queries.
</code></pre>
Most concerning to me is how practically none of these had anything to do with “distributed computing”. It seems that MySQL in single-server mode is still liable to corrupt data with nontrivial workloads.</div><br/></div></div><div id="38704095" class="c"><input type="checkbox" id="c-38704095" checked=""/><div class="controls bullet"><span class="by">aphyr</span><span>|</span><a href="#38698772">parent</a><span>|</span><a href="#38703962">prev</a><span>|</span><a href="#38701427">next</a><span>|</span><label class="collapse" for="c-38704095">[-]</label><label class="expand" for="c-38704095">[1 more]</label></div><br/><div class="children"><div class="content">Basically all of it. MariaDB exhibits every class of anomaly we found in MySQL, all in single-node deployments.</div><br/></div></div><div id="38701427" class="c"><input type="checkbox" id="c-38701427" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#38698772">parent</a><span>|</span><a href="#38704095">prev</a><span>|</span><a href="#38699170">next</a><span>|</span><label class="collapse" for="c-38701427">[-]</label><label class="expand" for="c-38701427">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t want to speak out of school, because I&#x27;ve never tried to boot up Jepsen for anything, but <i>in theory</i> the purpose of publishing the code for the experiment is that one can replicate its findings in your own environment to see if it impacts you. Yes, I&#x27;d guess that custom FUSE will be a PITA to configure but my experience with the AWS RDS setups for kicking the tires on MariaDB is (ahem) just money versus costing huge amounts of glucose</div><br/><div id="38704110" class="c"><input type="checkbox" id="c-38704110" checked=""/><div class="controls bullet"><span class="by">aphyr</span><span>|</span><a href="#38698772">root</a><span>|</span><a href="#38701427">parent</a><span>|</span><a href="#38699170">next</a><span>|</span><label class="collapse" for="c-38704110">[-]</label><label class="expand" for="c-38704110">[1 more]</label></div><br/><div class="children"><div class="content">The FUSE stuff actually isn&#x27;t too bad--Jepsen goes to a lot of trouble to make all this stuff automatic. The test harness pulls dependencies, compiles LazyFS, and mounts the filesystem for you. Just pass `--lazyfs` at the CLI. :-)</div><br/></div></div></div></div><div id="38699170" class="c"><input type="checkbox" id="c-38699170" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#38698772">parent</a><span>|</span><a href="#38701427">prev</a><span>|</span><a href="#38696421">next</a><span>|</span><label class="collapse" for="c-38699170">[-]</label><label class="expand" for="c-38699170">[2 more]</label></div><br/><div class="children"><div class="content">I think they&#x27;ve been diverged long enough that we can consider them separate products at this point. (14 years!)<p>You wouldn&#x27;t assume that Plex and XMBC shared much compatibility despite forking around the same time.</div><br/><div id="38701228" class="c"><input type="checkbox" id="c-38701228" checked=""/><div class="controls bullet"><span class="by">PeterCorless</span><span>|</span><a href="#38698772">root</a><span>|</span><a href="#38699170">parent</a><span>|</span><a href="#38696421">next</a><span>|</span><label class="collapse" for="c-38701228">[-]</label><label class="expand" for="c-38701228">[1 more]</label></div><br/><div class="children"><div class="content">I guess I was wondering how much of this behavior is endemic to MySQL, per se, and how much was endemic to InnoDB.</div><br/></div></div></div></div></div></div><div id="38696421" class="c"><input type="checkbox" id="c-38696421" checked=""/><div class="controls bullet"><span class="by">beltsazar</span><span>|</span><a href="#38698772">prev</a><span>|</span><a href="#38696431">next</a><span>|</span><label class="collapse" for="c-38696421">[-]</label><label class="expand" for="c-38696421">[26 more]</label></div><br/><div class="children"><div class="content">I understand why the default transaction isolation level of most DBMS is weaker than serializable (it&#x27;s for benchmark purposes), but I&#x27;d argue the best default is serializable. Most DBMS users don&#x27;t even know there are many consistency models [1]. They expect transactions to &quot;just work,&quot; i.e. to appear to have occurred in some total order, which is the definition of serializability [2]. And to some who know when to use a weaker isolation level for better performance can always set it per transaction [3].<p>---<p>[1] <a href="https:&#x2F;&#x2F;jepsen.io&#x2F;consistency" rel="nofollow noreferrer">https:&#x2F;&#x2F;jepsen.io&#x2F;consistency</a><p>[2] <a href="https:&#x2F;&#x2F;jepsen.io&#x2F;consistency&#x2F;models&#x2F;serializable" rel="nofollow noreferrer">https:&#x2F;&#x2F;jepsen.io&#x2F;consistency&#x2F;models&#x2F;serializable</a><p>[3] <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;16&#x2F;sql-set-transaction.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;16&#x2F;sql-set-transaction.html</a></div><br/><div id="38696877" class="c"><input type="checkbox" id="c-38696877" checked=""/><div class="controls bullet"><span class="by">wolfgang42</span><span>|</span><a href="#38696421">parent</a><span>|</span><a href="#38697651">next</a><span>|</span><label class="collapse" for="c-38696877">[-]</label><label class="expand" for="c-38696877">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; can always set it per transaction [3]</i><p>I just found out yesterday[1] that in Postgres “serializable” transactions can still have anomalies if other non-serializable transactions are running in parallel! So check your DBMS <i>very</i> carefully before trying this, I guess.<p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38685267">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38685267</a></div><br/></div></div><div id="38697651" class="c"><input type="checkbox" id="c-38697651" checked=""/><div class="controls bullet"><span class="by">continuational</span><span>|</span><a href="#38696421">parent</a><span>|</span><a href="#38696877">prev</a><span>|</span><a href="#38700392">next</a><span>|</span><label class="collapse" for="c-38697651">[-]</label><label class="expand" for="c-38697651">[4 more]</label></div><br/><div class="children"><div class="content">As soon as you let users edit data, you can&#x27;t really benefit from serializable transactions.<p>Partly because you don&#x27;t really want arbitrary long transactions that span however long the user wants to be editing for.<p>Partly because it&#x27;s rather rude to roll back all the users edits with a &quot;deadlock detected, please reload the form and fill it out again&quot;.</div><br/><div id="38697898" class="c"><input type="checkbox" id="c-38697898" checked=""/><div class="controls bullet"><span class="by">aphyr</span><span>|</span><a href="#38696421">root</a><span>|</span><a href="#38697651">parent</a><span>|</span><a href="#38698006">next</a><span>|</span><label class="collapse" for="c-38697898">[-]</label><label class="expand" for="c-38697898">[1 more]</label></div><br/><div class="children"><div class="content">I, uh, do want to point out that the alternative here is not &quot;everything is OK&quot;. If you <i>don&#x27;t</i> abort when, say, two users update the same row concurrently, then you might cause (e.g.) silent data loss for one of them. Or you might end up with a record in an illegal state--say, one with two different fields that should never be in their particular states together. You have to look at your transaction structure, intended application invariants, and measured frequency of concurrency to figure out if using a relaxed isolation level is actually safe or not.</div><br/></div></div><div id="38698006" class="c"><input type="checkbox" id="c-38698006" checked=""/><div class="controls bullet"><span class="by">mavelikara</span><span>|</span><a href="#38696421">root</a><span>|</span><a href="#38697651">parent</a><span>|</span><a href="#38697898">prev</a><span>|</span><a href="#38700392">next</a><span>|</span><label class="collapse" for="c-38698006">[-]</label><label class="expand" for="c-38698006">[2 more]</label></div><br/><div class="children"><div class="content">IME in this model, the middleware-DB transaction were set to be serializable, but the web-user-edits were done under an optimistic concurrency model, using versions or timestamps. You’d run into edit conflicts, which for many applications is a reasonable compromise.<p>The DB transactions would need to be kept open for user edits only if one were using a pessimistic model.<p>Am I thinking about this correctly?</div><br/><div id="38698234" class="c"><input type="checkbox" id="c-38698234" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#38696421">root</a><span>|</span><a href="#38698006">parent</a><span>|</span><a href="#38700392">next</a><span>|</span><label class="collapse" for="c-38698234">[-]</label><label class="expand" for="c-38698234">[1 more]</label></div><br/><div class="children"><div class="content">Most systems I&#x27;ve worked on would just let users completely overwrite eachother and would neither hold open a transaction nor use versioning.  For those that didn&#x27;t behave this way, I think versioning is the sanest option (as long as requirements permit it).</div><br/></div></div></div></div></div></div><div id="38700392" class="c"><input type="checkbox" id="c-38700392" checked=""/><div class="controls bullet"><span class="by">sgift</span><span>|</span><a href="#38696421">parent</a><span>|</span><a href="#38697651">prev</a><span>|</span><a href="#38697990">next</a><span>|</span><label class="collapse" for="c-38700392">[-]</label><label class="expand" for="c-38700392">[1 more]</label></div><br/><div class="children"><div class="content">I agree, and for the same reason that people should only use relaxed consistency models for atomics in their code if they <i>really</i> know what they are doing, there <i>really</i> is a need and they have appropriate testing. It&#x27;s good that the option is available, but the headaches that you can get yourself if you don&#x27;t know exactly what you are doing are real. Good luck debugging these types of Heisenbugs. You&#x27;ll need it.</div><br/></div></div><div id="38697990" class="c"><input type="checkbox" id="c-38697990" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#38696421">parent</a><span>|</span><a href="#38700392">prev</a><span>|</span><a href="#38700919">next</a><span>|</span><label class="collapse" for="c-38697990">[-]</label><label class="expand" for="c-38697990">[3 more]</label></div><br/><div class="children"><div class="content">Serializable by default doesn&#x27;t seem feasible when you really dive into the concept.<p>&quot;Serializable&quot; is a system property that describes how two or more transactions will take effect. In this context, I would define &quot;transaction&quot; as a business activity with a clear beginning, middle &amp; end and exhibiting specific, predictable data dependencies.  Without any knowledge of the transaction type(s) and their semantics per the business domain, it would be impossible to make assumptions about logical ordering of anything.<p>SQLite is the closest thing to what you are asking for. All writes are serialized by default, but this is probably not what you really want. We can ensure multiple concurrent connections don&#x27;t corrupt the data files, but we aren&#x27;t achieving anything in business terms with this.</div><br/><div id="38698472" class="c"><input type="checkbox" id="c-38698472" checked=""/><div class="controls bullet"><span class="by">dastbe</span><span>|</span><a href="#38696421">root</a><span>|</span><a href="#38697990">parent</a><span>|</span><a href="#38698554">next</a><span>|</span><label class="collapse" for="c-38698472">[-]</label><label class="expand" for="c-38698472">[1 more]</label></div><br/><div class="children"><div class="content">transaction in the way everyone else here is using it is referring to the primitive provided by the database which gives certain guarantees (depending on isolation level) wrt reads and writes.<p>Even in the context of &quot;transaction&quot; the business activity, they are an extremely useful tool for building up exactly the kind of sequencing and dependency guarantees you refer to.</div><br/></div></div><div id="38698554" class="c"><input type="checkbox" id="c-38698554" checked=""/><div class="controls bullet"><span class="by">beltsazar</span><span>|</span><a href="#38696421">root</a><span>|</span><a href="#38697990">parent</a><span>|</span><a href="#38698472">prev</a><span>|</span><a href="#38700919">next</a><span>|</span><label class="collapse" for="c-38698554">[-]</label><label class="expand" for="c-38698554">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Serializable by default doesn&#x27;t seem feasible when you really dive into the concept.<p>I was expecting you&#x27;d argue for a weaker isolation level than serializable, but then you said:<p>&gt; Without any knowledge of the transaction type(s) and their semantics per the business domain, it would be impossible to make assumptions about logical ordering of anything.<p>Serializable isolation level only guarantees <i>some</i> total order of transactions, and yes, it doesn&#x27;t guarantee that the order will be exactly what you want (e.g. first come, first serve). So, are you now suggesting strict serializability [1], then?<p>[1] <a href="https:&#x2F;&#x2F;jepsen.io&#x2F;consistency&#x2F;models&#x2F;strict-serializable" rel="nofollow noreferrer">https:&#x2F;&#x2F;jepsen.io&#x2F;consistency&#x2F;models&#x2F;strict-serializable</a></div><br/></div></div></div></div><div id="38700919" class="c"><input type="checkbox" id="c-38700919" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#38696421">parent</a><span>|</span><a href="#38697990">prev</a><span>|</span><a href="#38696784">next</a><span>|</span><label class="collapse" for="c-38700919">[-]</label><label class="expand" for="c-38700919">[1 more]</label></div><br/><div class="children"><div class="content">I kind of agree, but given the amount of locking[1] that would entail, the drop-off in performance would have those self-same users squalling about how slow it was . And then they had rewrite everything with a (NOLOCK) without understanding the implications are even worse (&quot;hey guys, I put this hint everywhere and things run really fast now!&quot;). I know this because I&#x27;ve seen it.<p>IIRC Jim Gray said that Repeatable Read is 99% of Serialisable anyway, all serialisable does is hide phantoms.<p>[1] speaking for MS SQL, which is mainly locking based.</div><br/></div></div><div id="38696784" class="c"><input type="checkbox" id="c-38696784" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#38696421">parent</a><span>|</span><a href="#38700919">prev</a><span>|</span><a href="#38701279">next</a><span>|</span><label class="collapse" for="c-38696784">[-]</label><label class="expand" for="c-38696784">[11 more]</label></div><br/><div class="children"><div class="content">It has a very high cost in terms of performance.</div><br/><div id="38696831" class="c"><input type="checkbox" id="c-38696831" checked=""/><div class="controls bullet"><span class="by">eatonphil</span><span>|</span><a href="#38696421">root</a><span>|</span><a href="#38696784">parent</a><span>|</span><a href="#38698237">next</a><span>|</span><label class="collapse" for="c-38696831">[-]</label><label class="expand" for="c-38696831">[4 more]</label></div><br/><div class="children"><div class="content">Is there any measurement of the impact you could point at?<p>For example, I imagine that it depends on the workload. If the workload isn&#x27;t contentious SERIALIZABLE might not make a big difference? Then again if the workload isn&#x27;t contentious maybe it doesn&#x27;t matter?<p>Either way, I&#x27;d love to see numbers. Not because I don&#x27;t believe anyone but I&#x27;m just curious what ballpark we&#x27;re talking about.<p>Edit: Also, SQLite and Cockroach only allow SERIALIZABLE transactions so the unviability of SERIALIZABLE seems questionable.</div><br/><div id="38703936" class="c"><input type="checkbox" id="c-38703936" checked=""/><div class="controls bullet"><span class="by">bennysaurus</span><span>|</span><a href="#38696421">root</a><span>|</span><a href="#38696831">parent</a><span>|</span><a href="#38705755">next</a><span>|</span><label class="collapse" for="c-38703936">[-]</label><label class="expand" for="c-38703936">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right it is workload dependent. If you&#x27;re low write but read heavy, you won&#x27;t see huge differences in performance between RR and Serializable, so it can make sense to shift exclusively to that. The last benchmark here shows some of that with Postgres if you&#x27;re looking for numbers (not an exhaustive test by any stretch): <a href="https:&#x2F;&#x2F;lchsk.com&#x2F;benchmarking-concurrent-operations-in-postgresql" rel="nofollow noreferrer">https:&#x2F;&#x2F;lchsk.com&#x2F;benchmarking-concurrent-operations-in-post...</a><p>SQLite is single writer, so transaction isolation is easy, writes are linear by their very nature.<p>Cockroach does some really funky stuff, but its serialization guarantees are only within certain conditions. Traditionally it has also had low write throughput compared to other systems, mainly due to its distributed nature. Jepsen touches on that here <a href="https:&#x2F;&#x2F;jepsen.io&#x2F;analyses&#x2F;cockroachdb-beta-20160829" rel="nofollow noreferrer">https:&#x2F;&#x2F;jepsen.io&#x2F;analyses&#x2F;cockroachdb-beta-20160829</a> though things have vastly improved since then.<p>To your earlier point, it may not even matter depending on the workload, or if you&#x27;re aware of your database limitations. In cases where it does matter then being aware of the limitations of something like Repeatable Read makes the trade-off worth it.</div><br/></div></div><div id="38705755" class="c"><input type="checkbox" id="c-38705755" checked=""/><div class="controls bullet"><span class="by">nvanbenschoten</span><span>|</span><a href="#38696421">root</a><span>|</span><a href="#38696831">parent</a><span>|</span><a href="#38703936">prev</a><span>|</span><a href="#38704062">next</a><span>|</span><label class="collapse" for="c-38705755">[-]</label><label class="expand" for="c-38705755">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Cockroach only allow SERIALIZABLE transactions so the unviability of SERIALIZABLE seems questionable.<p>We&#x27;ve actually been hard at work on adding Read Committed and Repeatable Read isolation into CockroachDB. The risks of weak isolation levels are real, but they do have a role in SQL databases. We did our best to avoid the pitfalls and inconsistencies of MySQL and even PostgreSQL by defining clear read snapshot scopes (statement vs. transaction).<p>The preview release for both will be dropping in Jan. Some links if you&#x27;re interested:
- RFC: <a href="https:&#x2F;&#x2F;github.com&#x2F;cockroachdb&#x2F;cockroach&#x2F;blob&#x2F;master&#x2F;docs&#x2F;RFCS&#x2F;20230122_read_committed_isolation.md">https:&#x2F;&#x2F;github.com&#x2F;cockroachdb&#x2F;cockroach&#x2F;blob&#x2F;master&#x2F;docs&#x2F;RF...</a>
- Hermitage test: <a href="https:&#x2F;&#x2F;github.com&#x2F;ept&#x2F;hermitage&#x2F;blob&#x2F;master&#x2F;cockroachdb.md">https:&#x2F;&#x2F;github.com&#x2F;ept&#x2F;hermitage&#x2F;blob&#x2F;master&#x2F;cockroachdb.md</a></div><br/></div></div><div id="38704062" class="c"><input type="checkbox" id="c-38704062" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38696421">root</a><span>|</span><a href="#38696831">parent</a><span>|</span><a href="#38705755">prev</a><span>|</span><a href="#38698237">next</a><span>|</span><label class="collapse" for="c-38704062">[-]</label><label class="expand" for="c-38704062">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Edit: Also, SQLite and Cockroach only allow SERIALIZABLE transactions so the unviability of SERIALIZABLE seems questionable.<p>SQLite is unviable in a lot of use cases. Also transactions are mostly a joke anyway, they were completely broken in MySQL for years and no-one cared, real systems don&#x27;t actually use them much.</div><br/></div></div></div></div><div id="38698237" class="c"><input type="checkbox" id="c-38698237" checked=""/><div class="controls bullet"><span class="by">beltsazar</span><span>|</span><a href="#38696421">root</a><span>|</span><a href="#38696784">parent</a><span>|</span><a href="#38696831">prev</a><span>|</span><a href="#38696886">next</a><span>|</span><label class="collapse" for="c-38698237">[-]</label><label class="expand" for="c-38698237">[1 more]</label></div><br/><div class="children"><div class="content">The performance hit is likely worth it—considering that the alternative is inconsistent data. In most cases correctness is more, if not much more, important than performance. As I said, those who know what they&#x27;re doing can always use a weaker isolation in cases where performance is more important than correctness.</div><br/></div></div><div id="38696886" class="c"><input type="checkbox" id="c-38696886" checked=""/><div class="controls bullet"><span class="by">pkulak</span><span>|</span><a href="#38696421">root</a><span>|</span><a href="#38696784">parent</a><span>|</span><a href="#38698237">prev</a><span>|</span><a href="#38701279">next</a><span>|</span><label class="collapse" for="c-38696886">[-]</label><label class="expand" for="c-38696886">[5 more]</label></div><br/><div class="children"><div class="content">And serializable transactions fail all the time. You have to always code so that re-running them is trivial and expected. 99% of the queries I write are fine at the lowest transaction level, and that saves me and the DB lots of time.</div><br/><div id="38698424" class="c"><input type="checkbox" id="c-38698424" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#38696421">root</a><span>|</span><a href="#38696886">parent</a><span>|</span><a href="#38697731">next</a><span>|</span><label class="collapse" for="c-38698424">[-]</label><label class="expand" for="c-38698424">[1 more]</label></div><br/><div class="children"><div class="content">You should anyway...<p>If you don&#x27;t, you sooner or later get presented with <i>unexpected</i> &#x27;transaction aborted due to deadlock&#x27; errors in prod. Better have someone who&#x27;s already been through that then, at the very least.</div><br/></div></div><div id="38697731" class="c"><input type="checkbox" id="c-38697731" checked=""/><div class="controls bullet"><span class="by">RedCrowbar</span><span>|</span><a href="#38696421">root</a><span>|</span><a href="#38696886">parent</a><span>|</span><a href="#38698424">prev</a><span>|</span><a href="#38701279">next</a><span>|</span><label class="collapse" for="c-38697731">[-]</label><label class="expand" for="c-38697731">[3 more]</label></div><br/><div class="children"><div class="content">If your database client is any good, it should do the retries for you. EdgeDB uses serializable isolation (as the only option), and all our bindings are coded to retry on transaction serialization errors by default.<p>Transaction deadlocks are another common issue that is triggered by concurrent transactions even at lower levels and should be retried also.</div><br/><div id="38698280" class="c"><input type="checkbox" id="c-38698280" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#38696421">root</a><span>|</span><a href="#38697731">parent</a><span>|</span><a href="#38701279">next</a><span>|</span><label class="collapse" for="c-38698280">[-]</label><label class="expand" for="c-38698280">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious how you can handle transaction deadlocks at a low level - there might have been a lot of non-SQL processing code that determined those values and blindly re-playing the transactions could result in incorrect data.<p>We handle this by passing our transaction a function to run - it will retry a few times if it gets a deadlock.  But I don&#x27;t consider this to be very low level.</div><br/><div id="38698603" class="c"><input type="checkbox" id="c-38698603" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#38696421">root</a><span>|</span><a href="#38698280">parent</a><span>|</span><a href="#38701279">next</a><span>|</span><label class="collapse" for="c-38698603">[-]</label><label class="expand" for="c-38698603">[1 more]</label></div><br/><div class="children"><div class="content">“We handle this by passing our transaction a function to run - it will retry a few times if it gets a deadlock. But I don&#x27;t consider this to be very low level.”<p>Oh neat, I was just thinking about something like this the other day.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38696868" class="c"><input type="checkbox" id="c-38696868" checked=""/><div class="controls bullet"><span class="by">gigatexal</span><span>|</span><a href="#38696421">parent</a><span>|</span><a href="#38701279">prev</a><span>|</span><a href="#38696431">next</a><span>|</span><label class="collapse" for="c-38696868">[-]</label><label class="expand" for="c-38696868">[2 more]</label></div><br/><div class="children"><div class="content">Snapshot is good enough. And then do all your related table changes in a single atomic txn and you’re good</div><br/><div id="38696973" class="c"><input type="checkbox" id="c-38696973" checked=""/><div class="controls bullet"><span class="by">aphyr</span><span>|</span><a href="#38696421">root</a><span>|</span><a href="#38696868">parent</a><span>|</span><a href="#38696431">next</a><span>|</span><label class="collapse" for="c-38696973">[-]</label><label class="expand" for="c-38696973">[1 more]</label></div><br/><div class="children"><div class="content">That depends! As the article discusses, snapshot allows anomalies--like write skew--which might violate application invariants. Depends on your workload.</div><br/></div></div></div></div></div></div><div id="38696431" class="c"><input type="checkbox" id="c-38696431" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#38696421">prev</a><span>|</span><a href="#38704296">next</a><span>|</span><label class="collapse" for="c-38696431">[-]</label><label class="expand" for="c-38696431">[9 more]</label></div><br/><div class="children"><div class="content">In my experience, most developers don&#x27;t even consider isolation level in the first place and just take whatever the default is. Any race conditions are met with an &#x27;oh that&#x27;s weird&#x27;, and then they move on.</div><br/><div id="38696811" class="c"><input type="checkbox" id="c-38696811" checked=""/><div class="controls bullet"><span class="by">nordsieck</span><span>|</span><a href="#38696431">parent</a><span>|</span><a href="#38703685">next</a><span>|</span><label class="collapse" for="c-38696811">[-]</label><label class="expand" for="c-38696811">[4 more]</label></div><br/><div class="children"><div class="content">I wish I could argue with you, but the highly successful early years of MongoDB proves your point nicely.</div><br/><div id="38703736" class="c"><input type="checkbox" id="c-38703736" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#38696431">root</a><span>|</span><a href="#38696811">parent</a><span>|</span><a href="#38703685">next</a><span>|</span><label class="collapse" for="c-38703736">[-]</label><label class="expand" for="c-38703736">[3 more]</label></div><br/><div class="children"><div class="content">Mongodb did not have those concerns because work on a single document is atomic and there are no joins.</div><br/><div id="38704154" class="c"><input type="checkbox" id="c-38704154" checked=""/><div class="controls bullet"><span class="by">aphyr</span><span>|</span><a href="#38696431">root</a><span>|</span><a href="#38703736">parent</a><span>|</span><a href="#38703685">next</a><span>|</span><label class="collapse" for="c-38704154">[-]</label><label class="expand" for="c-38704154">[2 more]</label></div><br/><div class="children"><div class="content">This depends on what you mean by &quot;atomic&quot;. Prior to 5.0, MongoDB&#x27;s defaults were to use a sub-majority write concern. This allowed all kinds of interesting atomicity violations, even on single documents. For instance, you could write a value, some clients might read it, and then your write would be silently lost as if it never happened. Clients could disagree on whether the write happened or not. A single client could observe, then un-observe the write. It gets weird. :-)</div><br/><div id="38705271" class="c"><input type="checkbox" id="c-38705271" checked=""/><div class="controls bullet"><span class="by">leoqa</span><span>|</span><a href="#38696431">root</a><span>|</span><a href="#38704154">parent</a><span>|</span><a href="#38703685">next</a><span>|</span><label class="collapse" for="c-38705271">[-]</label><label class="expand" for="c-38705271">[1 more]</label></div><br/><div class="children"><div class="content">This is actually an evolved model, as the system has to handle data loss as a primitive upfront.<p>Similar to how Rust forces you to reason about allocators.</div><br/></div></div></div></div></div></div></div></div><div id="38703685" class="c"><input type="checkbox" id="c-38703685" checked=""/><div class="controls bullet"><span class="by">sporkland</span><span>|</span><a href="#38696431">parent</a><span>|</span><a href="#38696811">prev</a><span>|</span><a href="#38696489">next</a><span>|</span><label class="collapse" for="c-38703685">[-]</label><label class="expand" for="c-38703685">[1 more]</label></div><br/><div class="children"><div class="content">It becomes so hard to reason about isolation issues that most things below  serializable consistency will lead to you getting bitten in various ways, so I would argue most developers <i>shouldn&#x27;t</i> even consider isolation levels.  And that MySQL and some others provide too little guarantees for the average dev.</div><br/></div></div><div id="38696489" class="c"><input type="checkbox" id="c-38696489" checked=""/><div class="controls bullet"><span class="by">beltsazar</span><span>|</span><a href="#38696431">parent</a><span>|</span><a href="#38703685">prev</a><span>|</span><a href="#38697928">next</a><span>|</span><label class="collapse" for="c-38696489">[-]</label><label class="expand" for="c-38696489">[2 more]</label></div><br/><div class="children"><div class="content">Exactly! That&#x27;s why I just commented [1] that the default isolation level should be serializable.<p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38696421">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38696421</a></div><br/><div id="38700188" class="c"><input type="checkbox" id="c-38700188" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#38696431">root</a><span>|</span><a href="#38696489">parent</a><span>|</span><a href="#38697928">next</a><span>|</span><label class="collapse" for="c-38700188">[-]</label><label class="expand" for="c-38700188">[1 more]</label></div><br/><div class="children"><div class="content">Completely agree, I&#x27;ve made that exact same argument on HN before.</div><br/></div></div></div></div><div id="38697928" class="c"><input type="checkbox" id="c-38697928" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#38696431">parent</a><span>|</span><a href="#38696489">prev</a><span>|</span><a href="#38704296">next</a><span>|</span><label class="collapse" for="c-38697928">[-]</label><label class="expand" for="c-38697928">[1 more]</label></div><br/><div class="children"><div class="content">In my experience almost no developer considers consistency at all.</div><br/></div></div></div></div><div id="38704296" class="c"><input type="checkbox" id="c-38704296" checked=""/><div class="controls bullet"><span class="by">rob-olmos</span><span>|</span><a href="#38696431">prev</a><span>|</span><a href="#38697966">next</a><span>|</span><label class="collapse" for="c-38704296">[-]</label><label class="expand" for="c-38704296">[1 more]</label></div><br/><div class="children"><div class="content">Related: ACIDRain for the repeatable read without explicit &quot;select .. for update&quot; locking gotcha gift that still keeps on giving: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=20027532">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=20027532</a></div><br/></div></div><div id="38696034" class="c"><input type="checkbox" id="c-38696034" checked=""/><div class="controls bullet"><span class="by">adontz</span><span>|</span><a href="#38697966">prev</a><span>|</span><label class="collapse" for="c-38696034">[-]</label><label class="expand" for="c-38696034">[44 more]</label></div><br/><div class="children"><div class="content">Serious question. I have this question for, like 20 years already.<p>Why would anyone start a new project with MySQL? Is it really superior in anything?
I&#x27;m in industry for 20+ years and as far as I remember MySQL was always the worst and most popular RDBMS at any given moment.</div><br/><div id="38706644" class="c"><input type="checkbox" id="c-38706644" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#38696034">parent</a><span>|</span><a href="#38696744">next</a><span>|</span><label class="collapse" for="c-38706644">[-]</label><label class="expand" for="c-38706644">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is it really superior in anything?<p>Yes, its replication support out of the box is decades ahead of Postgres.<p>(Mongodb has an even better replication story than Myqsl, but Mongo isn&#x27;t a real database.)</div><br/></div></div><div id="38696744" class="c"><input type="checkbox" id="c-38696744" checked=""/><div class="controls bullet"><span class="by">dissident_coder</span><span>|</span><a href="#38696034">parent</a><span>|</span><a href="#38706644">prev</a><span>|</span><a href="#38703532">next</a><span>|</span><label class="collapse" for="c-38696744">[-]</label><label class="expand" for="c-38696744">[5 more]</label></div><br/><div class="children"><div class="content">First, MySQL is the &quot;devil you know&quot;.  If you&#x27;ve spent a decade working exclusively with MySQL quirks, you&#x27;re just gonna be more comfortable with it regardless of quality.<p>MySQL also tends to be faster for read-heavy workloads and simple queries.<p>Also replication is easier to setup with MySQL in my (outdated) experience, even though it&#x27;s gotten better with Postgres recently and I haven&#x27;t really been able to compare them myself since I&#x27;m just using Amazon RDS Postgres these days and haven&#x27;t had the need to setup master-master replication (which is the pain point in postgres, and was pretty straightfoward with mysql the last time I worked with it).  Setting up read-replicas with postgres is still ezpz.<p>Postgres specific features tend to be much better than MySQL ones, Postgresql JSON(b) support blows MySQL out of the water.  And as far as I can remember MySQL still doesn&#x27;t support partial&#x2F;expression indexes, which is a deal breaker for me.  Especially in my json heavy workloads where being able to index specific json paths is critical for performance.  If you don&#x27;t need that kind of stuff, you might be fine - but I would hate to hit a wall in my application where I want to reach for it and it&#x27;s not there.<p>MySQL used to be the only game in town, so it was the &quot;default&quot; choice - but IMO postgres has surpassed it.</div><br/><div id="38696923" class="c"><input type="checkbox" id="c-38696923" checked=""/><div class="controls bullet"><span class="by">darrenf</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38696744">parent</a><span>|</span><a href="#38703532">next</a><span>|</span><label class="collapse" for="c-38696923">[-]</label><label class="expand" for="c-38696923">[4 more]</label></div><br/><div class="children"><div class="content">&gt; And as far as I can remember MySQL still doesn&#x27;t support partial&#x2F;expression indexes, which is a deal breaker for me. Especially in my json heavy workloads where being able to index specific json paths is critical for performance.<p>Do generated column indexes meet this need?<p><pre><code>    CREATE TABLE json_with_id_index (
       json_data JSON,
       id        INT GENERATED ALWAYS AS (json_data-&gt;&quot;$.id&quot;),

       INDEX id (id)
    )
</code></pre>
<a href="https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;8.0&#x2F;en&#x2F;create-table-secondary-indexes.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;8.0&#x2F;en&#x2F;create-table-seconda...</a></div><br/><div id="38698552" class="c"><input type="checkbox" id="c-38698552" checked=""/><div class="controls bullet"><span class="by">dissident_coder</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38696923">parent</a><span>|</span><a href="#38697076">next</a><span>|</span><label class="collapse" for="c-38698552">[-]</label><label class="expand" for="c-38698552">[1 more]</label></div><br/><div class="children"><div class="content">I suppose this is a decent workaround for certain things (i&#x27;ve used it in sqlite before), the main kind of index i&#x27;m using with postgres jsonb looks something like this<p><pre><code>    create index on my_table(document -&gt;&gt; &#x27;some_key&#x27;) where (document ? &#x27;some_key&#x27; AND document -&gt;&gt; &#x27;some_key&#x27; IS NOT NULL);
</code></pre>
you can use generated columns to get around the first part of the index, but you can&#x27;t have the WHERE part of the index in mysql as far as I am aware (but it has been a very long time since I&#x27;ve worked with it so I&#x27;m prepared to be wrong).</div><br/></div></div><div id="38697076" class="c"><input type="checkbox" id="c-38697076" checked=""/><div class="controls bullet"><span class="by">simcop2387</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38696923">parent</a><span>|</span><a href="#38698552">prev</a><span>|</span><a href="#38703532">next</a><span>|</span><label class="collapse" for="c-38697076">[-]</label><label class="expand" for="c-38697076">[2 more]</label></div><br/><div class="children"><div class="content">Looks like that would work as an expression index, though i can&#x27;t tell at a glance if this requires the column to also be stored which would increase storage size (but probably isn&#x27;t a huge problem if it is).  But that likely won&#x27;t work for dealing with the partial index case where you&#x27;re only wanting to keep the ones that aren&#x27;t null in the index to reduce the size (and speed up null&#x2F;not null checks).</div><br/><div id="38697275" class="c"><input type="checkbox" id="c-38697275" checked=""/><div class="controls bullet"><span class="by">evanelias</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38697076">parent</a><span>|</span><a href="#38703532">next</a><span>|</span><label class="collapse" for="c-38697275">[-]</label><label class="expand" for="c-38697275">[1 more]</label></div><br/><div class="children"><div class="content">MySQL supports indexing expressions directly, which is effectively the same as indexing an invisible virtual column: <a href="https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;8.0&#x2F;en&#x2F;create-index.html#create-index-functional-key-parts" rel="nofollow noreferrer">https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;8.0&#x2F;en&#x2F;create-index.html#cr...</a><p>MySQL supports &quot;multi-valued indexes&quot; over JSON data, which offer a non-obvious solution for partial indexes, since &quot;index records are not added for empty arrays&quot;: <a href="https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;8.0&#x2F;en&#x2F;create-index.html#create-index-multi-valued" rel="nofollow noreferrer">https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;8.0&#x2F;en&#x2F;create-index.html#cr...</a><p>MariaDB doesn&#x27;t support any of this directly yet though: <a href="https:&#x2F;&#x2F;www.skeema.io&#x2F;blog&#x2F;2023&#x2F;05&#x2F;10&#x2F;mysql-vs-mariadb-schema&#x2F;#generated-columns" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.skeema.io&#x2F;blog&#x2F;2023&#x2F;05&#x2F;10&#x2F;mysql-vs-mariadb-schem...</a></div><br/></div></div></div></div></div></div></div></div><div id="38703532" class="c"><input type="checkbox" id="c-38703532" checked=""/><div class="controls bullet"><span class="by">turtles3</span><span>|</span><a href="#38696034">parent</a><span>|</span><a href="#38696744">prev</a><span>|</span><a href="#38696315">next</a><span>|</span><label class="collapse" for="c-38703532">[-]</label><label class="expand" for="c-38703532">[2 more]</label></div><br/><div class="children"><div class="content">This is a great question, and if the choice is between mysql and postgres, I would like to make the case that despite the current popular momentum behind postgres, mysql is a better default. Please note I&#x27;m not saying mysql is better, but in the absence of any other criteria, I would suggest stating with mysql.<p>I have a few reasons for this view, but they mostly revolve around operational complexity. From a developer&#x27;s point of view postgres is fantastic. Far saner SQL dialect, tons of great features. When it comes to operations though, that&#x27;s where mysql has the edge, and ops is half of using a database - it&#x27;s an important facet for a business to consider.<p>As other commenters have mentioned, postgres requires careful tuning of the autovacuum process, otherwise it can&#x27;t keep up as the workload grows.<p>Postgres has a far more advanced query planner, but it comes at the cost of potentially blowing up your app at 3am, and it gives you no tools to patch in a quick fix while you address the root cause. This frankly ignores the reality of operating a business. Sometimes you need a quick fix, even if that might lead to users developing bad habits. Yes there is the pg_hint_plan extension, but that still only helps you later after the problem had happened. You can&#x27;t pin a query plan. To me the ideal situation would be for postgres to continue to use the old query plan, but emit some structured log to tell you it thinks it&#x27;s now suboptimal. But I digress.<p>Thirdly, postgres has no way to have an index clustered table. This lets you trade a small cost on write for greater page locality when reading related rows. Postgres let&#x27;s you do this as a one time operation that takes the table offline for the duration, which isn&#x27;t sufficient if you need it.<p>Fourthly, mysql is still easier to upgrade. You will need to upgrade your database at some point. Mysql has great support for upgrade in place, as well as using replication to build a new db. Mysql replication has always been logical replication, which has tradeoffs of course, but what it buys you is the ability to replicate across different versions. Pg&#x27;s logical replication still has a bunch of sharp edges.<p>Ok this rant is long enough already, but I do want to emphasise that this isn&#x27;t hating on postgres. I know it&#x27;s controversial to be recommending mysql over postgres, but I do think the ops concerns win out.<p>Ps the orioledb project is fantastic and I hope it one day becomes the default for postgres.</div><br/><div id="38705212" class="c"><input type="checkbox" id="c-38705212" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38703532">parent</a><span>|</span><a href="#38696315">next</a><span>|</span><label class="collapse" for="c-38705212">[-]</label><label class="expand" for="c-38705212">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t working in the first place an ops concern?</div><br/></div></div></div></div><div id="38696315" class="c"><input type="checkbox" id="c-38696315" checked=""/><div class="controls bullet"><span class="by">gog</span><span>|</span><a href="#38696034">parent</a><span>|</span><a href="#38703532">prev</a><span>|</span><a href="#38696282">next</a><span>|</span><label class="collapse" for="c-38696315">[-]</label><label class="expand" for="c-38696315">[14 more]</label></div><br/><div class="children"><div class="content">We use it, we know it and can troubleshoot it if needed, it satisfies our needs and it works. What more do you need?<p>It also works for others, Github for example.<p>The only thing I am missing at the moment is a native UUID type so I don&#x27;t have to write functions that convert 16bit binary to textual representation and back when examining the data manually on the server.</div><br/><div id="38697700" class="c"><input type="checkbox" id="c-38697700" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38696315">parent</a><span>|</span><a href="#38705204">next</a><span>|</span><label class="collapse" for="c-38697700">[-]</label><label class="expand" for="c-38697700">[11 more]</label></div><br/><div class="children"><div class="content">I strongly dislike how people look to github as an example, its the highest appeal to authority.<p>I know facebook uses mysql, but I also know that it is a bastardised custom version that has known constraints and has limited use (no foreign keys for example).<p>I spoke to the DBA who first deployed MySQL at Github and the vibe I got from him immediately was that he had doubled down on his prejudice: which is fine, but its not ok to ignore that it can be a lot of effort to work around issues with any given technology.<p>For a great example of what I mean: most people wouldn’t choose PHP for a new project (despite it having improved majorly) - the appeal to authority there is to say “it works for Facebook” without mentioning “Hack” or the myriad of internal processes to avoid the warts of PHP.<p>That a large headcount company <i>can use</i> something does not make it immune from criticism.</div><br/><div id="38697932" class="c"><input type="checkbox" id="c-38697932" checked=""/><div class="controls bullet"><span class="by">capableweb</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38697700">parent</a><span>|</span><a href="#38700168">next</a><span>|</span><label class="collapse" for="c-38697932">[-]</label><label class="expand" for="c-38697932">[3 more]</label></div><br/><div class="children"><div class="content">&gt; most people wouldn’t choose PHP for a new project<p>Is this really true?<p>I used to be a full-time PHP developer but I personally don&#x27;t touch that language anymore. But it&#x27;s still very popular around the world, I&#x27;ve seen multiple projects start this year use PHP, because that&#x27;s the language the founders&#x2F;most developers in the company are familiar with. Probably depends a lot on where in the world you&#x27;re located.<p>Last Stack Overflow survey had ~20% of the people answering the survey saying that they still use PHP in some capacity.</div><br/><div id="38700270" class="c"><input type="checkbox" id="c-38700270" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38697932">parent</a><span>|</span><a href="#38698011">next</a><span>|</span><label class="collapse" for="c-38700270">[-]</label><label class="expand" for="c-38700270">[1 more]</label></div><br/><div class="children"><div class="content">The beauty of PHP is that it is stateless and the end of the run, everything is freed. It is difficult to have memory leaks.<p>Personally, I like using Typescript&#x2F;Javascript on both front end and backend, but I don’t look down at PHP backends at all. And it’s come a long way as a language.<p>I’ve been a fan of rolling your own stdlib as the semantics there are old and weird, but vscode tells you so who cares anymore.</div><br/></div></div></div></div><div id="38700168" class="c"><input type="checkbox" id="c-38700168" checked=""/><div class="controls bullet"><span class="by">stephenr</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38697700">parent</a><span>|</span><a href="#38697932">prev</a><span>|</span><a href="#38705204">next</a><span>|</span><label class="collapse" for="c-38700168">[-]</label><label class="expand" for="c-38700168">[7 more]</label></div><br/><div class="children"><div class="content">&gt; most people wouldn’t choose PHP for a new project<p>Most people on HN, or most developers in the world?<p>PHP is still <i>very</i> popular, and plenty of people start new projects in it all the time.<p>&gt; does not make it immune from criticism<p>Show me a technology without critics and I&#x27;ll show you a technology zero people use.</div><br/><div id="38700354" class="c"><input type="checkbox" id="c-38700354" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38700168">parent</a><span>|</span><a href="#38705204">next</a><span>|</span><label class="collapse" for="c-38700354">[-]</label><label class="expand" for="c-38700354">[6 more]</label></div><br/><div class="children"><div class="content">I mean, outside of HN too: <i>new</i> projects are less and less commonly PHP based.<p><a href="https:&#x2F;&#x2F;madnight.github.io&#x2F;githut&#x2F;#&#x2F;pull_requests&#x2F;2023&#x2F;3" rel="nofollow noreferrer">https:&#x2F;&#x2F;madnight.github.io&#x2F;githut&#x2F;#&#x2F;pull_requests&#x2F;2023&#x2F;3</a></div><br/><div id="38700488" class="c"><input type="checkbox" id="c-38700488" checked=""/><div class="controls bullet"><span class="by">stephenr</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38700354">parent</a><span>|</span><a href="#38705204">next</a><span>|</span><label class="collapse" for="c-38700488">[-]</label><label class="expand" for="c-38700488">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that data is particularly meaningful, unless you&#x27;re also going to claim that both JavaScript and Ruby are &quot;less and less commonly&quot; used, because they&#x27;ve both had <i>much</i> bigger drops, according to that data.<p>Pulls, Pushes, Issues and GitHub stars are terrible ways to gauge the popularity of a language.</div><br/><div id="38700542" class="c"><input type="checkbox" id="c-38700542" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38700488">parent</a><span>|</span><a href="#38700655">next</a><span>|</span><label class="collapse" for="c-38700542">[-]</label><label class="expand" for="c-38700542">[3 more]</label></div><br/><div class="children"><div class="content">¯\_(ツ)_&#x2F;¯<p>There is no better measure I&#x27;m aware of, and I&#x27;ll take any measure you supply.<p>I would definitely also argue that Ruby is in pretty significant decline, the majority of Ruby projects were sysadminy projects from the 2010 era and most sysadminy types learned it as an alternative to perl. Web developers who learned it were mostly using Rails which has fallen somewhat out of favour. YMMV obviously, but I can understand it&#x27;s decline as Python has concretely taken over the working space and devops tools like Chef&#x2F;Puppet are not en-vogue any longer as Go and Kubernetes&#x2F;CNCF stuff took the lions share.<p>Equally: javascript (node, really) is less favourable to many JS devs than Typescript. If you aggregate TS and JS then you&#x27;ll see that the ecosystem <i>is</i> growing but many people who are JS folks have switched to TS.<p>I&#x27;m taken aback by what you seem to suggest though; Would you seriously claim that <i>most new projects ARE using PHP</i>?<p>I would happily argue that point with any data you supply, it&#x27;s completely contrary to my experience and understanding of things and I have a pretty wide and disparate social circle in tech companies.</div><br/><div id="38700917" class="c"><input type="checkbox" id="c-38700917" checked=""/><div class="controls bullet"><span class="by">stephenr</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38700542">parent</a><span>|</span><a href="#38700655">next</a><span>|</span><label class="collapse" for="c-38700917">[-]</label><label class="expand" for="c-38700917">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m taken aback by what you seem to suggest though; Would you seriously claim that most new projects ARE using PHP?<p>No. I didn&#x27;t say that, and we need to clarify what you meant originally to make sense here.<p>When you say &quot;most people wouldn&#x27;t start a project in php&quot;, there are two ways to interpret &quot;most&quot; in that sentence: &quot;the majority of&quot; (ie 50%+) or &quot;nearly all of&quot; (ie a much higher percentage). Both are accepted definitions for &quot;most&quot;.<p>I <i>assumed</i> you meant the latter: ie &quot;nearly everyone would not start a project in php&quot;, which is what I disagree with, because the former makes little sense in context.<p>If you did in fact mean &quot;a majority of people would not start a project in php&quot; then of course I agree because that sentence can be substituted to mention any programming language in existence and still be true, because none are ever so dominant over all others in terms of popularity, that more than half of all new projects are written in said language.</div><br/><div id="38700966" class="c"><input type="checkbox" id="c-38700966" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38700917">parent</a><span>|</span><a href="#38700655">next</a><span>|</span><label class="collapse" for="c-38700966">[-]</label><label class="expand" for="c-38700966">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s a little bit hair splitty, but I see what you might be trying to get at.<p>What I tried to convey is that PHP is not enjoying the development heyday it once had, and the numbers of people choosing PHP for a new project today (even among people who learned development with PHP) is decreasing. It&#x27;s not popular.<p>let&#x27;s try to leave it as: &quot;I believe PHP to be in decline for new projects as a share of total new projects divided by the total number of developers who are starting new projects&quot;.</div><br/></div></div></div></div></div></div><div id="38700655" class="c"><input type="checkbox" id="c-38700655" checked=""/><div class="controls bullet"><span class="by">johnmaguire</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38700488">parent</a><span>|</span><a href="#38700542">prev</a><span>|</span><a href="#38705204">next</a><span>|</span><label class="collapse" for="c-38700655">[-]</label><label class="expand" for="c-38700655">[1 more]</label></div><br/><div class="children"><div class="content">Ruby has had a huge decline in the past ten years, IMO.<p>Also, note that TypeScript is tracked separately from Javascript, which is likely part of its decline. I wouldn&#x27;t be surprised if JS backends are ultimately declining as well (perhaps Go and Python are taking its place?)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38705204" class="c"><input type="checkbox" id="c-38705204" checked=""/><div class="controls bullet"><span class="by">Bognar</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38696315">parent</a><span>|</span><a href="#38697700">prev</a><span>|</span><a href="#38700128">next</a><span>|</span><label class="collapse" for="c-38705204">[-]</label><label class="expand" for="c-38705204">[1 more]</label></div><br/><div class="children"><div class="content">Having worked at GitHub, we used MySQL because we&#x27;ve always used MySQL. It works because the business depends on making it continue to work, and switching off at this point is a multi-year effort. Herculean efforts have gone into scaling MySQL, and that is not without its own issues (outages, maintenance cost, etc.).<p>Isolation level consistency is not a problem I heard anyone talk about, but that&#x27;s probably because most devs interact with the database via Active Record which is not exactly known for its transactionality guarantees (and is, of course, a source of yet another set of problems).</div><br/></div></div><div id="38700128" class="c"><input type="checkbox" id="c-38700128" checked=""/><div class="controls bullet"><span class="by">stephenr</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38696315">parent</a><span>|</span><a href="#38705204">prev</a><span>|</span><a href="#38696282">next</a><span>|</span><label class="collapse" for="c-38700128">[-]</label><label class="expand" for="c-38700128">[1 more]</label></div><br/><div class="children"><div class="content">&gt; a native UUID type so I don&#x27;t have to write functions that convert 16bit binary to textual representation and back when examining the data manually on the server<p>MySQL 8 adds the `BIN_TO_UUID()` function (and the inverse, UUID_TO_BIN), and supports the quasi-standard bit swapping trick to handle time-based UUID&#x27;s in indexed columns.</div><br/></div></div></div></div><div id="38696282" class="c"><input type="checkbox" id="c-38696282" checked=""/><div class="controls bullet"><span class="by">WJW</span><span>|</span><a href="#38696034">parent</a><span>|</span><a href="#38696315">prev</a><span>|</span><a href="#38696068">next</a><span>|</span><label class="collapse" for="c-38696282">[-]</label><label class="expand" for="c-38696282">[1 more]</label></div><br/><div class="children"><div class="content">- It works well enough.<p>- It scales up fine for 99+% of companies, and for the ones that need to scale beyond that there are battle tested solutions like Vitess.<p>- It is what people know already so they don&#x27;t have to learn anything new.<p>Same reason why people still make new websites in PHP I guess. It&#x27;s not fancy but it works fine and won&#x27;t bring any unwelcome surprises.</div><br/></div></div><div id="38696068" class="c"><input type="checkbox" id="c-38696068" checked=""/><div class="controls bullet"><span class="by">willvarfar</span><span>|</span><a href="#38696034">parent</a><span>|</span><a href="#38696282">prev</a><span>|</span><a href="#38700830">next</a><span>|</span><label class="collapse" for="c-38696068">[-]</label><label class="expand" for="c-38696068">[1 more]</label></div><br/><div class="children"><div class="content">Not up to date, but a decade ago MySQL supported pluggable storage engines and so had had some good non-default choices.  It was possible to fit really big databases onto small boxes using tokudb, for example.<p>This doesn&#x27;t explain why it was so popular for starting new small projects, but people were also choosing mongodb at that time too, so ymmv :)<p>Nowadays postgres has grown a lot of features but I believe it is still behind on built-in compression?<p>Added: this old blog post of mine is still getting traffic 10 years later; probably still valid <a href="https:&#x2F;&#x2F;williame.github.io&#x2F;post&#x2F;25080396258.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;williame.github.io&#x2F;post&#x2F;25080396258.html</a></div><br/></div></div><div id="38700830" class="c"><input type="checkbox" id="c-38700830" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#38696034">parent</a><span>|</span><a href="#38696068">prev</a><span>|</span><a href="#38696630">next</a><span>|</span><label class="collapse" for="c-38700830">[-]</label><label class="expand" for="c-38700830">[1 more]</label></div><br/><div class="children"><div class="content">Others mentioned a few reasons already, but compared to postgres (because typically that&#x27;s the other option) I&#x27;ll add index selection. Even with the available plugins and stats and everything, I don&#x27;t want to in an emergency situation spend time trying to indirectly convince postgres that it should use a different index. &quot;A query takes 20x the time and you can&#x27;t force it back immediately&quot; is a really bad failure mode.</div><br/></div></div><div id="38696630" class="c"><input type="checkbox" id="c-38696630" checked=""/><div class="controls bullet"><span class="by">Topgamer7</span><span>|</span><a href="#38696034">parent</a><span>|</span><a href="#38700830">prev</a><span>|</span><a href="#38696205">next</a><span>|</span><label class="collapse" for="c-38696630">[-]</label><label class="expand" for="c-38696630">[3 more]</label></div><br/><div class="children"><div class="content">MySQL has some aggregation performance over postgres. Having done a recent migration of an application two things that come to mind are:<p>- its case insensitive by default, which can make filtering simpler, without having to deal with a duplicate column where all values are lower&#x2F;upper cased.
- MySQL implements loose index scan and index skip scan, which improves performance of a number of join aggregation operations (<a href="https:&#x2F;&#x2F;wiki.postgresql.org&#x2F;wiki&#x2F;Loose_indexscan" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.postgresql.org&#x2F;wiki&#x2F;Loose_indexscan</a>)</div><br/><div id="38697163" class="c"><input type="checkbox" id="c-38697163" checked=""/><div class="controls bullet"><span class="by">dpratt</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38696630">parent</a><span>|</span><a href="#38696205">next</a><span>|</span><label class="collapse" for="c-38697163">[-]</label><label class="expand" for="c-38697163">[2 more]</label></div><br/><div class="children"><div class="content">| its case insensitive by default<p>This is obviously up for debate, but subjectively I find this to be an absolutely <i>terrible</i> design decision.</div><br/><div id="38701265" class="c"><input type="checkbox" id="c-38701265" checked=""/><div class="controls bullet"><span class="by">hu3</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38697163">parent</a><span>|</span><a href="#38696205">next</a><span>|</span><label class="collapse" for="c-38701265">[-]</label><label class="expand" for="c-38701265">[1 more]</label></div><br/><div class="children"><div class="content">I agree it&#x27;s debatable. And not intuitive at first.<p>With that said, in all my years and thousands of tables across multiple jobs, I have yet to see a single case where I had to change a table to be case sensitive. So I guess for me it is a sensible default.</div><br/></div></div></div></div></div></div><div id="38696205" class="c"><input type="checkbox" id="c-38696205" checked=""/><div class="controls bullet"><span class="by">Keyframe</span><span>|</span><a href="#38696034">parent</a><span>|</span><a href="#38696630">prev</a><span>|</span><a href="#38698858">next</a><span>|</span><label class="collapse" for="c-38696205">[-]</label><label class="expand" for="c-38696205">[1 more]</label></div><br/><div class="children"><div class="content">Once upon a time it was easi-ish to scale out, and was simple to use and fast. There was Percona as well. These days, who knows? Might still be true.</div><br/></div></div><div id="38698858" class="c"><input type="checkbox" id="c-38698858" checked=""/><div class="controls bullet"><span class="by">adontz</span><span>|</span><a href="#38696034">parent</a><span>|</span><a href="#38696205">prev</a><span>|</span><a href="#38696346">next</a><span>|</span><label class="collapse" for="c-38698858">[-]</label><label class="expand" for="c-38698858">[1 more]</label></div><br/><div class="children"><div class="content">Just want to add, that comparing to postgresql is a very modern view. There were other databases, not popular today, but quite popular back in the day. To name a few: DB2, InterBase, Firebird, Paradox, Access, SQL Server Compact. MySQL was a really shitty database in early 2000s, still THE most popular.</div><br/></div></div><div id="38696346" class="c"><input type="checkbox" id="c-38696346" checked=""/><div class="controls bullet"><span class="by">endorphine</span><span>|</span><a href="#38696034">parent</a><span>|</span><a href="#38698858">prev</a><span>|</span><a href="#38704097">next</a><span>|</span><label class="collapse" for="c-38696346">[-]</label><label class="expand" for="c-38696346">[4 more]</label></div><br/><div class="children"><div class="content">As opposed to what? Postgres? Isn&#x27;t InnoDB most performant for read-heavy apps?</div><br/><div id="38699106" class="c"><input type="checkbox" id="c-38699106" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38696346">parent</a><span>|</span><a href="#38704097">next</a><span>|</span><label class="collapse" for="c-38699106">[-]</label><label class="expand" for="c-38699106">[3 more]</label></div><br/><div class="children"><div class="content">MyISAM is actually considerably faster (than InnoDB) for read heavy apps.<p>InnoDB is comparatively slow, but you get much better transactionality (IE; something that is much closer to ACID compliance). Row level locking is faster for inserts than table level locking, but table level locking is faster for reads than row level locking.<p>Regardless: Both storage engines do not scale with core count as effectively as postgres due to some deadlocking on update that I have witnessed with MySQL. (not that Postgresql is the only alternative btw).</div><br/><div id="38706591" class="c"><input type="checkbox" id="c-38706591" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38699106">parent</a><span>|</span><a href="#38705125">next</a><span>|</span><label class="collapse" for="c-38706591">[-]</label><label class="expand" for="c-38706591">[1 more]</label></div><br/><div class="children"><div class="content">MyISAM is not a transactional storage engine even to begin with, so saying that you get &quot;much better transactionality with InnoDB&quot; or &quot;MyISAM is actually considerably faster&quot; is either wrong or at best comparing apples to oranges.<p>&gt; Both storage engines do not scale with core count as effectively as postgres due to some deadlocking on update that I have witnessed with MySQL.<p>Strange take since a deadlock is rather an exceptional event you want never to occur so deadlocking, in algorithm design, wouldn&#x27;t be considered a reason one would say that the implementation does not &quot;scale with the core count&quot;. Whether or not the algorithm scales with the core count is for many other different reasons but not deadlocks.<p>Considering the &quot;scale with the core count&quot; design problem, Postgres process-per-connection architecture makes it a much less viable option than, say, MySQL so this is wrong as well.</div><br/></div></div><div id="38705125" class="c"><input type="checkbox" id="c-38705125" checked=""/><div class="controls bullet"><span class="by">VintageCool</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38699106">parent</a><span>|</span><a href="#38706591">prev</a><span>|</span><a href="#38704097">next</a><span>|</span><label class="collapse" for="c-38705125">[-]</label><label class="expand" for="c-38705125">[1 more]</label></div><br/><div class="children"><div class="content">There is no excuse to be using MyISAM instead of InnoDB in 2023. It was a scarcely forgivable mistake in 2013.<p>The read performance advantages of MyISAM are solved better by using SSDs instead of HDDs.<p>MyISAM will cost you dearly when performing actions like &quot;trying to create a new replica of an existing database&quot;.</div><br/></div></div></div></div></div></div><div id="38704097" class="c"><input type="checkbox" id="c-38704097" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38696034">parent</a><span>|</span><a href="#38696346">prev</a><span>|</span><a href="#38704065">next</a><span>|</span><label class="collapse" for="c-38704097">[-]</label><label class="expand" for="c-38704097">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why would anyone start a new project with MySQL? Is it really superior in anything?<p>It&#x27;s the most developer-friendly thing out there. Particularly for a datastore CLI, which is inherently something you use rarely, MySQL&#x27;s is just a lot nicer, more discoverable.<p>I think it has the least bad HA story among (free) traditional SQL-RDBMSes too (not that I understand why anyone would start a new project on a traditional SQL-RDBMS at all).</div><br/></div></div><div id="38696760" class="c"><input type="checkbox" id="c-38696760" checked=""/><div class="controls bullet"><span class="by">Freeaqingme</span><span>|</span><a href="#38696034">parent</a><span>|</span><a href="#38704065">prev</a><span>|</span><a href="#38696833">next</a><span>|</span><label class="collapse" for="c-38696760">[-]</label><label class="expand" for="c-38696760">[3 more]</label></div><br/><div class="children"><div class="content">Also from an operations point of view it&#x27;s quite easy to manage. I&#x27;m not that experienced with Postgresql, but my understanding is that until recently you had to vacuum it every once in a while. Besides, it&#x27;s also using some kind of threading model that most people handle by putting a proxy in front of Postgres to keep connections open.<p>Also, Mysql has had native replication for a very long time, including Galera which does two-step commit in a multimaster cluster. Although Postgres is making some headway in this regard, it is my impression that this is only quite recent and not yet fully up to par with Mysql yet.</div><br/><div id="38700938" class="c"><input type="checkbox" id="c-38700938" checked=""/><div class="controls bullet"><span class="by">dgellow</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38696760">parent</a><span>|</span><a href="#38697139">next</a><span>|</span><label class="collapse" for="c-38700938">[-]</label><label class="expand" for="c-38700938">[1 more]</label></div><br/><div class="children"><div class="content">I think what you reference is known as Transaction ID Wraparound, Postgres still needs to be vacuumed to avoid that problem: <a href="https:&#x2F;&#x2F;www.crunchydata.com&#x2F;blog&#x2F;managing-transaction-id-wraparound-in-postgresql" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.crunchydata.com&#x2F;blog&#x2F;managing-transaction-id-wra...</a></div><br/></div></div><div id="38697139" class="c"><input type="checkbox" id="c-38697139" checked=""/><div class="controls bullet"><span class="by">stonemetal12</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38696760">parent</a><span>|</span><a href="#38700938">prev</a><span>|</span><a href="#38696833">next</a><span>|</span><label class="collapse" for="c-38697139">[-]</label><label class="expand" for="c-38697139">[1 more]</label></div><br/><div class="children"><div class="content">&gt;my understanding is that until recently you had to vacuum it every once in a while.<p>You still do. The auto Vacuum daemon was added in 2008ish, so it isn&#x27;t too bad. Just more complexity to manage.<p>&gt; it&#x27;s also using some kind of threading model<p>It does a process per connection just like web servers did back in the day when C10k was a thing.  A lot of the buffers are configured per connection so you can get bigger buffers if you keep the number of connections small.</div><br/></div></div></div></div><div id="38696833" class="c"><input type="checkbox" id="c-38696833" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#38696034">parent</a><span>|</span><a href="#38696760">prev</a><span>|</span><a href="#38701260">next</a><span>|</span><label class="collapse" for="c-38696833">[-]</label><label class="expand" for="c-38696833">[3 more]</label></div><br/><div class="children"><div class="content">Your memory is failing you maybe you don&#x27;t remember not too long ago when PG did not have any replications built-in.</div><br/><div id="38697515" class="c"><input type="checkbox" id="c-38697515" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38696833">parent</a><span>|</span><a href="#38701260">next</a><span>|</span><label class="collapse" for="c-38697515">[-]</label><label class="expand" for="c-38697515">[2 more]</label></div><br/><div class="children"><div class="content">Not too long ago MySQL didn&#x27;t have transactions.<p>Edit: I would just love a comment from the person who thinks &#x27;missing feature in the past&#x27; is wrong, unfair or irrelevant as a reply to a &#x27;missing feature in the past&#x27; comment.</div><br/><div id="38697889" class="c"><input type="checkbox" id="c-38697889" checked=""/><div class="controls bullet"><span class="by">evanelias</span><span>|</span><a href="#38696034">root</a><span>|</span><a href="#38697515">parent</a><span>|</span><a href="#38701260">next</a><span>|</span><label class="collapse" for="c-38697889">[-]</label><label class="expand" for="c-38697889">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a non-trivial nine-year difference between the things you&#x27;re describing: the InnoDB storage engine was released in 2001. Postgres gained built-in replication in 2010.<p>That said, personally I wouldn&#x27;t describe either of these as &quot;not too long ago&quot;. Technology rapidly changes and many things from either 2001 or 2010 are considered rather old.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>