<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710579650748" as="style"/><link rel="stylesheet" href="styles.css?v=1710579650748"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/trevorpogue/algebraic-nnhw">Show HN: Matrix Multiplication with Half the Multiplications</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>emacs28</span> | <span>70 comments</span></div><br/><div><div id="39714396" class="c"><input type="checkbox" id="c-39714396" checked=""/><div class="controls bullet"><span class="by">halflings</span><span>|</span><a href="#39718609">next</a><span>|</span><label class="collapse" for="c-39714396">[-]</label><label class="expand" for="c-39714396">[28 more]</label></div><br/><div class="children"><div class="content">This looks pretty cool! What&#x27;s the catch? e.g. why isn&#x27;t this already implemented in accelerators, is it really just a forgotten algorithm, or this has some implications on the cost of building the accelerator or else?</div><br/><div id="39714576" class="c"><input type="checkbox" id="c-39714576" checked=""/><div class="controls bullet"><span class="by">emacs28</span><span>|</span><a href="#39714396">parent</a><span>|</span><a href="#39715790">next</a><span>|</span><label class="collapse" for="c-39714576">[-]</label><label class="expand" for="c-39714576">[8 more]</label></div><br/><div class="children"><div class="content">IMHO, for fixed-point MM accelerators, there is no catch, I think it&#x27;s an overlooked algorithm. It&#x27;s based on an algorithm by Winograd who coincidentally also proposed another unrelated algorithm that later became very popular for CNN acceleration which would take some visibility away from this other algorithm by Winograd... But that is speculative</div><br/><div id="39715928" class="c"><input type="checkbox" id="c-39715928" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#39714396">root</a><span>|</span><a href="#39714576">parent</a><span>|</span><a href="#39715184">next</a><span>|</span><label class="collapse" for="c-39715928">[-]</label><label class="expand" for="c-39715928">[3 more]</label></div><br/><div class="children"><div class="content">LLM hype and this submission in particular keep making me think of a lecturer I had for <i>Topics in Large Dimensional Data Processing</i>, circa 2016: as I recall he was enthusiastically adamant that the most important thing, breakthroughs etc., in years&#x2F;decades to come was going to be faster matrix operations. Anyway, I&#x27;m pretty sure I recognise FIP (not FFIP of course) from that course.<p>I wish I could remember his name, I believe he left academia after my year and went to work in industry, I&#x27;d just be curious to see what he&#x27;s up to now. I&#x27;m not saying it was a particularly novel or prescient comment&#x2F;attitude, we may not have had quite such ML hype but certainly &#x27;big data&#x27; was all the rage at the time, it&#x27;s just something that&#x27;s stuck in my mind. One of those areas I always meant to study more, just realistically probably never had the mathematical chops for and certainly those I did have atrophied.</div><br/><div id="39717783" class="c"><input type="checkbox" id="c-39717783" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#39714396">root</a><span>|</span><a href="#39715928">parent</a><span>|</span><a href="#39715184">next</a><span>|</span><label class="collapse" for="c-39717783">[-]</label><label class="expand" for="c-39717783">[2 more]</label></div><br/><div class="children"><div class="content">Maybe I’m joking, but: our society is just a vehicle for economics at this point, our economy is built around science, our science has mostly been turned into observations about engineering, some time ago we changed all of engineering into differential equations, and differential equations can be solved by discretizing them and doing linear algebra, and most of linear algebra can be done with matrix multiplications (triangular solves and orthonormalizations if you are fancy). All you need is matmul.</div><br/><div id="39719306" class="c"><input type="checkbox" id="c-39719306" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#39714396">root</a><span>|</span><a href="#39717783">parent</a><span>|</span><a href="#39715184">next</a><span>|</span><label class="collapse" for="c-39719306">[-]</label><label class="expand" for="c-39719306">[1 more]</label></div><br/><div class="children"><div class="content">&gt; our science has mostly been turned into observations about engineering<p>You may be joking but that in particular seems pretty astute.<p>Superficially it seems accurate, and reasonably ascribable to economic forces, fewer concentrations of capital in people (aristocrats) spending it on a hobby interest or academic pursuit of their own - today&#x27;s equivalents mostly prefer philanthropy (Musk is, I suppose, for whatever else you might think of him, a notable exception - preferring to explore space, AI, etc. not really it seems for personal monetary gain). But I wonder if that <i>is</i> fair, to modern scientists, or is it just that &#x27;all the low-hanging stuff&#x27;s been done&#x27;?</div><br/></div></div></div></div></div></div><div id="39715184" class="c"><input type="checkbox" id="c-39715184" checked=""/><div class="controls bullet"><span class="by">yorwba</span><span>|</span><a href="#39714396">root</a><span>|</span><a href="#39714576">parent</a><span>|</span><a href="#39715928">prev</a><span>|</span><a href="#39715790">next</a><span>|</span><label class="collapse" for="c-39715184">[-]</label><label class="expand" for="c-39715184">[4 more]</label></div><br/><div class="children"><div class="content">On the other hand, if you tried it with floating point, you&#x27;d lose significant digits. Since the approach is to sum (a[i] + b[i+1])(a[i+1] + b[i]) and subtract the sums of a[i]a[i+1] and b[i]b[i+1] in the end to get a[i]b[i] + a[i+1]b[i+1], you may be taking the difference of two large values to get a small value, losing precision.</div><br/><div id="39718254" class="c"><input type="checkbox" id="c-39718254" checked=""/><div class="controls bullet"><span class="by">tmp8086</span><span>|</span><a href="#39714396">root</a><span>|</span><a href="#39715184">parent</a><span>|</span><a href="#39715790">next</a><span>|</span><label class="collapse" for="c-39718254">[-]</label><label class="expand" for="c-39718254">[3 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a matrix multiplication using Winograd&#x27;s algorithm (that you describe), implemented in Go (very small code):<p><a href="https:&#x2F;&#x2F;bugfix-66.com&#x2F;983cb3a3a37dbe8e82edea6298988f03d2a1a4590f70f9d1e04eb57b164ed2b0" rel="nofollow">https:&#x2F;&#x2F;bugfix-66.com&#x2F;983cb3a3a37dbe8e82edea6298988f03d2a1a4...</a></div><br/><div id="39721601" class="c"><input type="checkbox" id="c-39721601" checked=""/><div class="controls bullet"><span class="by">3abiton</span><span>|</span><a href="#39714396">root</a><span>|</span><a href="#39718254">parent</a><span>|</span><a href="#39715790">next</a><span>|</span><label class="collapse" for="c-39721601">[-]</label><label class="expand" for="c-39721601">[2 more]</label></div><br/><div class="children"><div class="content">On a tangent, go is so elegant.</div><br/></div></div></div></div></div></div></div></div><div id="39715790" class="c"><input type="checkbox" id="c-39715790" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#39714396">parent</a><span>|</span><a href="#39714576">prev</a><span>|</span><a href="#39719264">next</a><span>|</span><label class="collapse" for="c-39715790">[-]</label><label class="expand" for="c-39715790">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just a software algorithm. It&#x27;s a hardware architecture optimization. To benefit, you have to build hardware that matches the dimensions of the algorithm. That&#x27;s an expensive commitment.</div><br/><div id="39715954" class="c"><input type="checkbox" id="c-39715954" checked=""/><div class="controls bullet"><span class="by">emacs28</span><span>|</span><a href="#39714396">root</a><span>|</span><a href="#39715790">parent</a><span>|</span><a href="#39719264">next</a><span>|</span><label class="collapse" for="c-39715954">[-]</label><label class="expand" for="c-39715954">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you have to build hardware that matches the dimensions of the algorithm<p>Yes the benefits are realized in custom hardware designs as opposed to software, however, the hardware architectures work for multiplying matrices of arbitrary dimensions by splitting up larger matrices into smaller tiles, then summing up the tile products to form the final larger matrix products (i.e. GEMM)</div><br/></div></div></div></div><div id="39719264" class="c"><input type="checkbox" id="c-39719264" checked=""/><div class="controls bullet"><span class="by">pbsd</span><span>|</span><a href="#39714396">parent</a><span>|</span><a href="#39715790">prev</a><span>|</span><a href="#39715277">next</a><span>|</span><label class="collapse" for="c-39719264">[-]</label><label class="expand" for="c-39719264">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not quite forgotten. It kind of lives on in the pseudo-dot product Wegman-Carter authenticators like UMAC. See Section 3 of [1] for context.<p>[1] <a href="https:&#x2F;&#x2F;cr.yp.to&#x2F;antiforgery&#x2F;pema-20071022.pdf" rel="nofollow">https:&#x2F;&#x2F;cr.yp.to&#x2F;antiforgery&#x2F;pema-20071022.pdf</a></div><br/></div></div><div id="39715277" class="c"><input type="checkbox" id="c-39715277" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#39714396">parent</a><span>|</span><a href="#39719264">prev</a><span>|</span><a href="#39717572">next</a><span>|</span><label class="collapse" for="c-39715277">[-]</label><label class="expand" for="c-39715277">[14 more]</label></div><br/><div class="children"><div class="content">There are a lot of matrix multiplication algorithms out there with a lot of pluses and minuses. It&#x27;s always a balance of accuracy, runtime, and scaling.  This one probably has bad accuracy in floating point.</div><br/><div id="39718761" class="c"><input type="checkbox" id="c-39718761" checked=""/><div class="controls bullet"><span class="by">emacs28</span><span>|</span><a href="#39714396">root</a><span>|</span><a href="#39715277">parent</a><span>|</span><a href="#39717074">next</a><span>|</span><label class="collapse" for="c-39718761">[-]</label><label class="expand" for="c-39718761">[5 more]</label></div><br/><div class="children"><div class="content">For everyone discussing the reduced accuracy&#x2F;numerical stability of the algorithms in floating-point, this is true. But note that the application of the algorithms in the work is explored for fixed-point MM&#x2F;quantized integer NN inference, not floating-point MM&#x2F;inference. Hence, there is no reduction in accuracy for that application of it compared to using conventional fixed-point MM.</div><br/><div id="39719262" class="c"><input type="checkbox" id="c-39719262" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#39714396">root</a><span>|</span><a href="#39718761">parent</a><span>|</span><a href="#39720531">next</a><span>|</span><label class="collapse" for="c-39719262">[-]</label><label class="expand" for="c-39719262">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Conventional fixed-point MM&quot; is a large suite of algorithms.  It is correct that this is a 2x reduction in MULs compared to <i>naive</i> fixed-point matrix multiply, but there is a large body of literature out there with other circuits.  This is a cool trick to add to the group.</div><br/></div></div><div id="39720531" class="c"><input type="checkbox" id="c-39720531" checked=""/><div class="controls bullet"><span class="by">p1esk</span><span>|</span><a href="#39714396">root</a><span>|</span><a href="#39718761">parent</a><span>|</span><a href="#39719262">prev</a><span>|</span><a href="#39719086">next</a><span>|</span><label class="collapse" for="c-39720531">[-]</label><label class="expand" for="c-39720531">[1 more]</label></div><br/><div class="children"><div class="content">Inference world is gradually switching from INT formats to FP formats. FP8 is already supported in modern hardware, and FP4 support is coming. In my experiments I get better perplexity in language models with FP4 than with INT4.</div><br/></div></div><div id="39719086" class="c"><input type="checkbox" id="c-39719086" checked=""/><div class="controls bullet"><span class="by">abetusk</span><span>|</span><a href="#39714396">root</a><span>|</span><a href="#39718761">parent</a><span>|</span><a href="#39720531">prev</a><span>|</span><a href="#39717074">next</a><span>|</span><label class="collapse" for="c-39719086">[-]</label><label class="expand" for="c-39719086">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m no expert but I suspect this is wrong. To me, this is like saying you don&#x27;t need to worry about integer overflow because your operations are only working on fixed integers. Really? You don&#x27;t care if you multiply or add two large numbers and they spill over?<p>The more appropriate answer, I suspect, is that the numerical precision and stability sacrifices are more than adequate for normal usage.<p>If I&#x27;m wrong about this, I would certainly like to know.</div><br/><div id="39719274" class="c"><input type="checkbox" id="c-39719274" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#39714396">root</a><span>|</span><a href="#39719086">parent</a><span>|</span><a href="#39717074">next</a><span>|</span><label class="collapse" for="c-39719274">[-]</label><label class="expand" for="c-39719274">[1 more]</label></div><br/><div class="children"><div class="content">In hardware, you control your integer widths completely, so if you add two 32-bit ints to a 33-bit int, there is no chance of overflow.  The same goes for multiplications, etc.</div><br/></div></div></div></div></div></div><div id="39717074" class="c"><input type="checkbox" id="c-39717074" checked=""/><div class="controls bullet"><span class="by">waynecochran</span><span>|</span><a href="#39714396">root</a><span>|</span><a href="#39715277">parent</a><span>|</span><a href="#39718761">prev</a><span>|</span><a href="#39718054">next</a><span>|</span><label class="collapse" for="c-39717074">[-]</label><label class="expand" for="c-39717074">[6 more]</label></div><br/><div class="children"><div class="content">The document said it outputs the <i>exact</i> same values as the conventional method. There is <i>no</i> accuracy trade off here.</div><br/><div id="39717735" class="c"><input type="checkbox" id="c-39717735" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#39714396">root</a><span>|</span><a href="#39717074">parent</a><span>|</span><a href="#39717261">next</a><span>|</span><label class="collapse" for="c-39717735">[-]</label><label class="expand" for="c-39717735">[1 more]</label></div><br/><div class="children"><div class="content">The paper cited is about hardware, where there is no accuracy tradeoff because you control the numerical precision completely and use fixed point.  In a software implementation, neither is true.  There is <i>no chance</i> that you will get the exact same values out of this method that you do out of other FP matmuls.</div><br/></div></div><div id="39717261" class="c"><input type="checkbox" id="c-39717261" checked=""/><div class="controls bullet"><span class="by">p1esk</span><span>|</span><a href="#39714396">root</a><span>|</span><a href="#39717074">parent</a><span>|</span><a href="#39717735">prev</a><span>|</span><a href="#39718054">next</a><span>|</span><label class="collapse" for="c-39717261">[-]</label><label class="expand" for="c-39717261">[4 more]</label></div><br/><div class="children"><div class="content">For floating point? Are you sure?</div><br/><div id="39718591" class="c"><input type="checkbox" id="c-39718591" checked=""/><div class="controls bullet"><span class="by">waynecochran</span><span>|</span><a href="#39714396">root</a><span>|</span><a href="#39717261">parent</a><span>|</span><a href="#39717321">next</a><span>|</span><label class="collapse" for="c-39718591">[-]</label><label class="expand" for="c-39718591">[2 more]</label></div><br/><div class="children"><div class="content">Opening statement of README<p><pre><code>    This repository contains the source code for ML hardware architectures that 
    require nearly half the number of multiplier units to achieve the same 
    performance, by executing alternative inner-product algorithms that trade 
    nearly half the multiplications for cheap low-bitwidth additions, while still 
    producing identical output as the conventional inner product.</code></pre></div><br/><div id="39718843" class="c"><input type="checkbox" id="c-39718843" checked=""/><div class="controls bullet"><span class="by">p1esk</span><span>|</span><a href="#39714396">root</a><span>|</span><a href="#39718591">parent</a><span>|</span><a href="#39717321">next</a><span>|</span><label class="collapse" for="c-39718843">[-]</label><label class="expand" for="c-39718843">[1 more]</label></div><br/><div class="children"><div class="content">I just looked at the paper: the answer is no, floating point is not supported.</div><br/></div></div></div></div></div></div></div></div><div id="39718054" class="c"><input type="checkbox" id="c-39718054" checked=""/><div class="controls bullet"><span class="by">abetusk</span><span>|</span><a href="#39714396">root</a><span>|</span><a href="#39715277">parent</a><span>|</span><a href="#39717074">prev</a><span>|</span><a href="#39717572">next</a><span>|</span><label class="collapse" for="c-39718054">[-]</label><label class="expand" for="c-39718054">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know why this answer is getting downvoted. This is absolutely correct.<p>W. Miller has a paper discussing, under conditions of numerical stability, O(n^3) multiplications is necessary [0]. Any algorithm that gets sub cubic runtime for matrix multiplication, like Strassen&#x27;s or Coppersmith&#x27;s, must sacrifice some amount of precision or stability.<p>[0] <a href="https:&#x2F;&#x2F;epubs.siam.org&#x2F;doi&#x2F;10.1137&#x2F;0204009" rel="nofollow">https:&#x2F;&#x2F;epubs.siam.org&#x2F;doi&#x2F;10.1137&#x2F;0204009</a></div><br/><div id="39718700" class="c"><input type="checkbox" id="c-39718700" checked=""/><div class="controls bullet"><span class="by">gyrovagueGeist</span><span>|</span><a href="#39714396">root</a><span>|</span><a href="#39718054">parent</a><span>|</span><a href="#39717572">next</a><span>|</span><label class="collapse" for="c-39718700">[-]</label><label class="expand" for="c-39718700">[1 more]</label></div><br/><div class="children"><div class="content">Another relevant paper is: <a href="https:&#x2F;&#x2F;epubs.siam.org&#x2F;doi&#x2F;10.1137&#x2F;15M1032168" rel="nofollow">https:&#x2F;&#x2F;epubs.siam.org&#x2F;doi&#x2F;10.1137&#x2F;15M1032168</a></div><br/></div></div></div></div></div></div><div id="39717572" class="c"><input type="checkbox" id="c-39717572" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#39714396">parent</a><span>|</span><a href="#39715277">prev</a><span>|</span><a href="#39714599">next</a><span>|</span><label class="collapse" for="c-39717572">[-]</label><label class="expand" for="c-39717572">[1 more]</label></div><br/><div class="children"><div class="content">I’ve only glanced at it so someone correct me if I’m wrong, but IIUC this is not a replacement for matrix multiplication but rather an approximation that only gives decent-ish results for the types of linear systems you see in AI&#x2F;ML. But for that use case it is totally fine?</div><br/></div></div><div id="39714599" class="c"><input type="checkbox" id="c-39714599" checked=""/><div class="controls bullet"><span class="by">mariocesar</span><span>|</span><a href="#39714396">parent</a><span>|</span><a href="#39717572">prev</a><span>|</span><a href="#39718609">next</a><span>|</span><label class="collapse" for="c-39714599">[-]</label><label class="expand" for="c-39714599">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps it&#x27;s less of a hidden gem and more of a spotlight moment.</div><br/></div></div></div></div><div id="39718609" class="c"><input type="checkbox" id="c-39718609" checked=""/><div class="controls bullet"><span class="by">skykooler</span><span>|</span><a href="#39714396">prev</a><span>|</span><a href="#39716950">next</a><span>|</span><label class="collapse" for="c-39718609">[-]</label><label class="expand" for="c-39718609">[2 more]</label></div><br/><div class="children"><div class="content">I find it fascinating that this is using a process invented in 1968 and hasn&#x27;t been used for this purpose until now!</div><br/><div id="39718704" class="c"><input type="checkbox" id="c-39718704" checked=""/><div class="controls bullet"><span class="by">pk-protect-ai</span><span>|</span><a href="#39718609">parent</a><span>|</span><a href="#39716950">next</a><span>|</span><label class="collapse" for="c-39718704">[-]</label><label class="expand" for="c-39718704">[1 more]</label></div><br/><div class="children"><div class="content">Hey, nobody knew what to do with GF(2^x) up until mid last century either... Oh wait, CS was not really a thing almost up until mid last century...</div><br/></div></div></div></div><div id="39716950" class="c"><input type="checkbox" id="c-39716950" checked=""/><div class="controls bullet"><span class="by">michelpp</span><span>|</span><a href="#39718609">prev</a><span>|</span><a href="#39714420">next</a><span>|</span><label class="collapse" for="c-39716950">[-]</label><label class="expand" for="c-39716950">[9 more]</label></div><br/><div class="children"><div class="content">This is very cool and a real interesting read!  For those in the comments confused about how this is better, the paper is talking about synthesizing matrix multiplication pipelines in hardware, like an FPGA or ASIC.  On a CPU or GPU you won&#x27;t notice because adds and multiplications take the same amount of time generally, but multiplication units takes up many more transistors, so if you can reduce the circuit complexity you can increase the speed and parallel throughput and reduce power and routing complexity.  This approach could be particularly useful for efficient sparse matrix multiplication accelerators.<p>Another cool way to eliminate multiplication in matrix multiplication is to use different semirings [1].  The Tropical Semiring [2] for example substitutes addition for multiplication and min (or max) for addition.  It&#x27;s still matrix multiplication but with substituted binary operations.  The research in this relatively new field of Tropical Algebra [3] is quite active and rich right now, being used for all kinds of optimization problems and in research for optimizing neural networks [4]
.  This approach also lends itself to hardware synthesis since most FPGA configurable logical blocks can add&#x2F;min&#x2F;max in one clock cycle, whereas efficient multiplication requires fixed dedicated on-chip hardware multipliers.<p>Another way to efficiently remove multiplications with a different but related semiring is to use a Log Semiring [5].  If you have to multiply chains of probabilities (like Markov chains) then the numbers quickly become very small and floating point loses its accuracy to represent the numbers.  By scaling the numbers first by taking the log, multiplication becomes addition and addition becomes x + log1p(exp(y - x)).<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Semiring" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Semiring</a><p>[2] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tropical_semiring" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tropical_semiring</a><p>[3] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tropical_geometry" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tropical_geometry</a><p>[4] <a href="https:&#x2F;&#x2F;proceedings.mlr.press&#x2F;v80&#x2F;zhang18i&#x2F;zhang18i.pdf" rel="nofollow">https:&#x2F;&#x2F;proceedings.mlr.press&#x2F;v80&#x2F;zhang18i&#x2F;zhang18i.pdf</a><p>[5] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Log_semiring" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Log_semiring</a></div><br/><div id="39720332" class="c"><input type="checkbox" id="c-39720332" checked=""/><div class="controls bullet"><span class="by">gatane</span><span>|</span><a href="#39716950">parent</a><span>|</span><a href="#39721305">next</a><span>|</span><label class="collapse" for="c-39720332">[-]</label><label class="expand" for="c-39720332">[2 more]</label></div><br/><div class="children"><div class="content">Whoah, this is what Unified Algebra is all about!<p><a href="http:&#x2F;&#x2F;www.cs.toronto.edu&#x2F;~hehner&#x2F;UA.pdf" rel="nofollow">http:&#x2F;&#x2F;www.cs.toronto.edu&#x2F;~hehner&#x2F;UA.pdf</a></div><br/><div id="39721237" class="c"><input type="checkbox" id="c-39721237" checked=""/><div class="controls bullet"><span class="by">buybackoff</span><span>|</span><a href="#39716950">root</a><span>|</span><a href="#39720332">parent</a><span>|</span><a href="#39721305">next</a><span>|</span><label class="collapse" for="c-39721237">[-]</label><label class="expand" for="c-39721237">[1 more]</label></div><br/><div class="children"><div class="content">This is what HN is about :)<p>I understood a fraction but instantly wanted to dive into the topic just after reading such a knowledgeable comment.</div><br/></div></div></div></div><div id="39721305" class="c"><input type="checkbox" id="c-39721305" checked=""/><div class="controls bullet"><span class="by">btown</span><span>|</span><a href="#39716950">parent</a><span>|</span><a href="#39720332">prev</a><span>|</span><a href="#39720475">next</a><span>|</span><label class="collapse" for="c-39721305">[-]</label><label class="expand" for="c-39721305">[1 more]</label></div><br/><div class="children"><div class="content">The paper in [4] is absolutely fascinating - I&#x27;m very much a neophyte here, but I believe it shows that practically any ReLU network can be represented as a tropical ratio of two tropical polynomials, and thus can be analyzed with geometric principles including visualizations of surfaces. It&#x27;s been cited in more recent work: <a href="https:&#x2F;&#x2F;scholar.google.com&#x2F;scholar?cites=10037191125536204512&amp;as_sdt=5,31&amp;sciodt=0,31&amp;hl=en" rel="nofollow">https:&#x2F;&#x2F;scholar.google.com&#x2F;scholar?cites=1003719112553620451...</a> - does anyone know if there&#x27;s been any significant advancements here?</div><br/></div></div><div id="39720475" class="c"><input type="checkbox" id="c-39720475" checked=""/><div class="controls bullet"><span class="by">jhj</span><span>|</span><a href="#39716950">parent</a><span>|</span><a href="#39721305">prev</a><span>|</span><a href="#39720758">next</a><span>|</span><label class="collapse" for="c-39720475">[-]</label><label class="expand" for="c-39720475">[1 more]</label></div><br/><div class="children"><div class="content">&gt; By scaling the numbers first by taking the log, multiplication becomes addition and addition becomes x + log1p(exp(y - x)).<p>Addition&#x2F;subtraction in a logarithmic number system is way more expensive than what you would spend on multiplication, especially if you care about correctly rounded results, as the (hardware) LUTs required are rather big.</div><br/></div></div><div id="39720758" class="c"><input type="checkbox" id="c-39720758" checked=""/><div class="controls bullet"><span class="by">bearzoo</span><span>|</span><a href="#39716950">parent</a><span>|</span><a href="#39720475">prev</a><span>|</span><a href="#39717424">next</a><span>|</span><label class="collapse" for="c-39720758">[-]</label><label class="expand" for="c-39720758">[1 more]</label></div><br/><div class="children"><div class="content">somewhat related is the number theoretic transform<p><a href="https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;abstract&#x2F;document&#x2F;1451721" rel="nofollow">https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;abstract&#x2F;document&#x2F;1451721</a></div><br/></div></div><div id="39717424" class="c"><input type="checkbox" id="c-39717424" checked=""/><div class="controls bullet"><span class="by">pk-protect-ai</span><span>|</span><a href="#39716950">parent</a><span>|</span><a href="#39720758">prev</a><span>|</span><a href="#39721563">next</a><span>|</span><label class="collapse" for="c-39717424">[-]</label><label class="expand" for="c-39717424">[2 more]</label></div><br/><div class="children"><div class="content">&gt; By scaling the numbers first by taking the log, multiplication becomes addition and addition becomes x + log1p(exp(y - x)).<p>Isn&#x27;t this the same approach as in GF(2^x), which has been in use for decades? The only limitation that comes to mind is the field size.</div><br/><div id="39720860" class="c"><input type="checkbox" id="c-39720860" checked=""/><div class="controls bullet"><span class="by">jhj</span><span>|</span><a href="#39716950">root</a><span>|</span><a href="#39717424">parent</a><span>|</span><a href="#39721563">next</a><span>|</span><label class="collapse" for="c-39720860">[-]</label><label class="expand" for="c-39720860">[1 more]</label></div><br/><div class="children"><div class="content">Finite field log&#x2F;antilog lookup tables are used for efficient-ish multiplication, similar to addition&#x2F;subtraction tables used for logarithmic number systems.</div><br/></div></div></div></div></div></div><div id="39714420" class="c"><input type="checkbox" id="c-39714420" checked=""/><div class="controls bullet"><span class="by">Drakim</span><span>|</span><a href="#39716950">prev</a><span>|</span><a href="#39715033">next</a><span>|</span><label class="collapse" for="c-39714420">[-]</label><label class="expand" for="c-39714420">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised this actually works, usually detecting whether to use multiplication or addition is slower than simply using multiplication. Especially if it&#x27;s massive amounts of work being done in parallel.</div><br/></div></div><div id="39715033" class="c"><input type="checkbox" id="c-39715033" checked=""/><div class="controls bullet"><span class="by">ixaxaar</span><span>|</span><a href="#39714420">prev</a><span>|</span><a href="#39716476">next</a><span>|</span><label class="collapse" for="c-39715033">[-]</label><label class="expand" for="c-39715033">[7 more]</label></div><br/><div class="children"><div class="content">Man I remembered something similar I had tried working on in 2018, but gave up after all my PhD applications got rejected.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ixaxaar&#x2F;pytorch-dni">https:&#x2F;&#x2F;github.com&#x2F;ixaxaar&#x2F;pytorch-dni</a><p>The concept here goes a bit further and tries to replicate backprop with an external network, arguing that that&#x27;s probably what the brain actually does.</div><br/><div id="39715105" class="c"><input type="checkbox" id="c-39715105" checked=""/><div class="controls bullet"><span class="by">yorwba</span><span>|</span><a href="#39715033">parent</a><span>|</span><a href="#39717641">next</a><span>|</span><label class="collapse" for="c-39715105">[-]</label><label class="expand" for="c-39715105">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not seeing the connection. This work is about low-level optimization of matrix multiplication. The repo you linked seems to be about replacing back-propagated gradients with a cheaper estimate. What&#x27;s the similarity you see between these two?</div><br/><div id="39715279" class="c"><input type="checkbox" id="c-39715279" checked=""/><div class="controls bullet"><span class="by">ixaxaar</span><span>|</span><a href="#39715033">root</a><span>|</span><a href="#39715105">parent</a><span>|</span><a href="#39717641">next</a><span>|</span><label class="collapse" for="c-39715279">[-]</label><label class="expand" for="c-39715279">[1 more]</label></div><br/><div class="children"><div class="content">Correct, I think I mistook it as &quot;use a small neural net to approximate matrix multiplication&quot; instead it seems as &quot;use cheaper replacements of matrix mul without much acc loss&quot;.<p>Wellll that means I can give dni another try :D</div><br/></div></div></div></div><div id="39717641" class="c"><input type="checkbox" id="c-39717641" checked=""/><div class="controls bullet"><span class="by">jebarker</span><span>|</span><a href="#39715033">parent</a><span>|</span><a href="#39715105">prev</a><span>|</span><a href="#39715951">next</a><span>|</span><label class="collapse" for="c-39717641">[-]</label><label class="expand" for="c-39717641">[2 more]</label></div><br/><div class="children"><div class="content">This feels like a &quot;no free lunch&quot; situation. I would imagine that any time saving in approximating the gradients this way would be lost to needing to train for more iterations due to the loss in gradient accuracy. Is that not the case?</div><br/><div id="39718198" class="c"><input type="checkbox" id="c-39718198" checked=""/><div class="controls bullet"><span class="by">ixaxaar</span><span>|</span><a href="#39715033">root</a><span>|</span><a href="#39717641">parent</a><span>|</span><a href="#39715951">next</a><span>|</span><label class="collapse" for="c-39718198">[-]</label><label class="expand" for="c-39718198">[1 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s the reason for its dead end.<p>However if this is really the biological analogue of credit  assignment, this might scale better than training llms from scratch every time. Even if say it could approx gradients to a certain degree given a new network, normal backprop could further tune for a few epochs or so dramatically reducing overall training costs.</div><br/></div></div></div></div><div id="39715951" class="c"><input type="checkbox" id="c-39715951" checked=""/><div class="controls bullet"><span class="by">rollingtide</span><span>|</span><a href="#39715033">parent</a><span>|</span><a href="#39717641">prev</a><span>|</span><a href="#39716476">next</a><span>|</span><label class="collapse" for="c-39715951">[-]</label><label class="expand" for="c-39715951">[2 more]</label></div><br/><div class="children"><div class="content">Unrelated to the technical discussion but I was wondering what you made that architecture gif with? Looks neat!</div><br/><div id="39716425" class="c"><input type="checkbox" id="c-39716425" checked=""/><div class="controls bullet"><span class="by">ixaxaar</span><span>|</span><a href="#39715033">root</a><span>|</span><a href="#39715951">parent</a><span>|</span><a href="#39716476">next</a><span>|</span><label class="collapse" for="c-39716425">[-]</label><label class="expand" for="c-39716425">[1 more]</label></div><br/><div class="children"><div class="content">I think that image is from the paper and was not created by me. Looks cool indeed!</div><br/></div></div></div></div></div></div><div id="39716476" class="c"><input type="checkbox" id="c-39716476" checked=""/><div class="controls bullet"><span class="by">Lucasoato</span><span>|</span><a href="#39715033">prev</a><span>|</span><a href="#39714468">next</a><span>|</span><label class="collapse" for="c-39716476">[-]</label><label class="expand" for="c-39716476">[10 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re interested in the mathematical theory behind sub-cubic algorithms for matrix multiplications, you can start from here: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Matrix_multiplication_algorithm#Sub-cubic_algorithms" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Matrix_multiplication_algorith...</a><p>I conjecture that for every j &gt; 0 in R, a number n exists so that any two n x n matrices can be multiplied together in O(n^(2+j)) steps.<p>(Now proven for for 2+j = w = 2.3728596, or j &gt; 0.3728596)</div><br/><div id="39716748" class="c"><input type="checkbox" id="c-39716748" checked=""/><div class="controls bullet"><span class="by">gizmo686</span><span>|</span><a href="#39716476">parent</a><span>|</span><a href="#39719103">next</a><span>|</span><label class="collapse" for="c-39716748">[-]</label><label class="expand" for="c-39716748">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I conjecture that for every j &gt; 0 in R, a number n exists so that any two n x n matrices can be multiplied together in O(n^(2+j)) steps.<p>Is this stated correctly? Because it seems almost meaningless as stated. You start with &quot;for every j, there exists an n such that...&quot;. That would mean that for the rest of the statement, n and j are constant. So you are just saying that you can multiply constant sized matrices in constant time. Technically true, but I feel like you are trying to claim something stronger.</div><br/><div id="39717096" class="c"><input type="checkbox" id="c-39717096" checked=""/><div class="controls bullet"><span class="by">JohnKemeny</span><span>|</span><a href="#39716476">root</a><span>|</span><a href="#39716748">parent</a><span>|</span><a href="#39719103">next</a><span>|</span><label class="collapse" for="c-39717096">[-]</label><label class="expand" for="c-39717096">[3 more]</label></div><br/><div class="children"><div class="content">It should simply say:<p>for any j&gt;0 there exists an algorithm multiplying nxn matrices in time O(n^{2+j}).</div><br/><div id="39717970" class="c"><input type="checkbox" id="c-39717970" checked=""/><div class="controls bullet"><span class="by">Lucasoato</span><span>|</span><a href="#39716476">root</a><span>|</span><a href="#39717096">parent</a><span>|</span><a href="#39719103">next</a><span>|</span><label class="collapse" for="c-39717970">[-]</label><label class="expand" for="c-39717970">[2 more]</label></div><br/><div class="children"><div class="content">You are correct, I apologize for the confusion! :)</div><br/><div id="39724158" class="c"><input type="checkbox" id="c-39724158" checked=""/><div class="controls bullet"><span class="by">hnfong</span><span>|</span><a href="#39716476">root</a><span>|</span><a href="#39717970">parent</a><span>|</span><a href="#39719103">next</a><span>|</span><label class="collapse" for="c-39724158">[-]</label><label class="expand" for="c-39724158">[1 more]</label></div><br/><div class="children"><div class="content">Assuming your claim is not equivalent to &quot;matrix multiplication is in O(n^2)&quot;, then it is false assuming conventional mathematics (i.e. uncountable sets exist), because j in R is uncountable, and algorithms are countable...</div><br/></div></div></div></div></div></div></div></div><div id="39719103" class="c"><input type="checkbox" id="c-39719103" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#39716476">parent</a><span>|</span><a href="#39716748">prev</a><span>|</span><a href="#39716626">next</a><span>|</span><label class="collapse" for="c-39719103">[-]</label><label class="expand" for="c-39719103">[1 more]</label></div><br/><div class="children"><div class="content">It does seem to be harder to make progress over time though. Maybe it’ll bottom out at j=1&#x2F;e. I won’t call my guess even a conjecture though, it just happens to be a convenient constant near where the current value is. It would be a funny prank for math to pull on us.</div><br/></div></div><div id="39716626" class="c"><input type="checkbox" id="c-39716626" checked=""/><div class="controls bullet"><span class="by">abeppu</span><span>|</span><a href="#39716476">parent</a><span>|</span><a href="#39719103">prev</a><span>|</span><a href="#39714468">next</a><span>|</span><label class="collapse" for="c-39716626">[-]</label><label class="expand" for="c-39716626">[4 more]</label></div><br/><div class="children"><div class="content">Predicting that this holds for any j &gt; 0 seems rather bold. Would you care to share your intuition why you think that&#x27;s the case?</div><br/><div id="39716713" class="c"><input type="checkbox" id="c-39716713" checked=""/><div class="controls bullet"><span class="by">roflmaostc</span><span>|</span><a href="#39716476">root</a><span>|</span><a href="#39716626">parent</a><span>|</span><a href="#39714468">next</a><span>|</span><label class="collapse" for="c-39716713">[-]</label><label class="expand" for="c-39716713">[3 more]</label></div><br/><div class="children"><div class="content">Two matrices with size NxN each can be multiplied naively with the schoolbook algorithm in O(N^3).<p>It&#x27;s clear that the algorithm needs at least O(N^2) because to access each element of the matrices once, you need a double for loop, which is O(N^2).<p><pre><code>  for i in rows
      for j in cols
          # do something with element matrix1 [i, j], matrix2[i, j],...

</code></pre>
so it has to be j &gt;= 0</div><br/><div id="39717115" class="c"><input type="checkbox" id="c-39717115" checked=""/><div class="controls bullet"><span class="by">JohnKemeny</span><span>|</span><a href="#39716476">root</a><span>|</span><a href="#39716713">parent</a><span>|</span><a href="#39721012">next</a><span>|</span><label class="collapse" for="c-39717115">[-]</label><label class="expand" for="c-39717115">[1 more]</label></div><br/><div class="children"><div class="content">His question was: what is the reasoning behind there existing an algorithm running in time n^2+epsilon for really small epsilon.</div><br/></div></div><div id="39721012" class="c"><input type="checkbox" id="c-39721012" checked=""/><div class="controls bullet"><span class="by">abeppu</span><span>|</span><a href="#39716476">root</a><span>|</span><a href="#39716713">parent</a><span>|</span><a href="#39717115">prev</a><span>|</span><a href="#39714468">next</a><span>|</span><label class="collapse" for="c-39721012">[-]</label><label class="expand" for="c-39721012">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, we&#x27;re agreed that j cannot be less than 0.
But your conjecture was about _every j &gt; 0_.
Do you have any specific line of reasoning which suggests that j can be arbitrarily close to 0 (0 is the greatest lower bound)? Why do you not think there&#x27;s some other specific limit k \in (0, 0.3728596] beyond which j cannot be improved?</div><br/></div></div></div></div></div></div></div></div><div id="39714468" class="c"><input type="checkbox" id="c-39714468" checked=""/><div class="controls bullet"><span class="by">barfbagginus</span><span>|</span><a href="#39716476">prev</a><span>|</span><label class="collapse" for="c-39714468">[-]</label><label class="expand" for="c-39714468">[12 more]</label></div><br/><div class="children"><div class="content">This readme does a really poor job of explaining what the improvement is or how they drop half the multiplications. What is the Big O run time on this? Is this shifting the known best bounds?<p>And the diagrams are chaotic and don&#x27;t really explain anything about why this approach is fast or good. The result is that I&#x27;m reluctant to even click-through to the PDF.<p>If you want to improve the project credibility please consider being honest and open about what is actually going on and giving some clear explanations and illustrations, rather than things that may as well be designed to hype people too busy to tell you that you are cranks. It&#x27;s hard to tell if this is incredibly groundbreaking or just but nothingburger.   Sadly I almost feel like that must be an intentional decision motivated by poor merits of work and a desire to exploit AI height. The alternative - which I prefer to believe is the case - is that the author simply needs to revise and better contextualize.</div><br/><div id="39714991" class="c"><input type="checkbox" id="c-39714991" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#39714468">parent</a><span>|</span><a href="#39714778">next</a><span>|</span><label class="collapse" for="c-39714991">[-]</label><label class="expand" for="c-39714991">[2 more]</label></div><br/><div class="children"><div class="content">&gt; What is the Big O run time on this?<p>The claim is they’re dropping half the multiplications, so it isn’t doing anything for Big O.<p>&gt; If you want to improve the project credibility please consider being honest and open about what is actually going on and giving some clear explanations and illustrations,<p>The math explaining how to halve the number of multiplications in the paper (<a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2311.12224" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2311.12224</a>) isn’t hard to understand.<p>You only have to read formulas 2 (traditional matrix multiplication) and 3 to 6.<p>I think it’s clear it does do what’s being advertised, halving the number of multiplications at the cost of lots of extra additions&#x2F;subtractions.<p>They then go on to better vectorize that algorithm. That, as is usual for that, gets looking messy soon.<p>My main concern would be numerical stability.</div><br/><div id="39715061" class="c"><input type="checkbox" id="c-39715061" checked=""/><div class="controls bullet"><span class="by">emacs28</span><span>|</span><a href="#39714468">root</a><span>|</span><a href="#39714991">parent</a><span>|</span><a href="#39714778">next</a><span>|</span><label class="collapse" for="c-39715061">[-]</label><label class="expand" for="c-39715061">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, good summary. Regarding numerical stability, the application is for fixed-point arithmetic, and therefore numerical stability is not an issue (the result is identical compared to using the conventional inner-product)</div><br/></div></div></div></div><div id="39714778" class="c"><input type="checkbox" id="c-39714778" checked=""/><div class="controls bullet"><span class="by">stephencanon</span><span>|</span><a href="#39714468">parent</a><span>|</span><a href="#39714991">prev</a><span>|</span><a href="#39717316">next</a><span>|</span><label class="collapse" for="c-39714778">[-]</label><label class="expand" for="c-39714778">[1 more]</label></div><br/><div class="children"><div class="content">The readme doesn&#x27;t explain much, but the introduction to the paper itself is quite approachable.<p>As for whether it&#x27;s groundbreaking or not ... it&#x27;s a neat readily-accessible constant-factor improvement for area-constrained fixed-point accelerators. That doesn&#x27;t change everything overnight, but neither is it nothing. It&#x27;s nice work.</div><br/></div></div><div id="39717343" class="c"><input type="checkbox" id="c-39717343" checked=""/><div class="controls bullet"><span class="by">eigenket</span><span>|</span><a href="#39714468">parent</a><span>|</span><a href="#39717316">prev</a><span>|</span><a href="#39714541">next</a><span>|</span><label class="collapse" for="c-39717343">[-]</label><label class="expand" for="c-39717343">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This readme does a really poor job of explaining what the improvement is or how they drop half the multiplications. What is the Big O run time on this? Is this shifting the known best bounds?<p>Without wishing to sound elitist I, I don&#x27;t understand the point of this comment at all. If you don&#x27;t understand Big O notation enough to know that &quot;half the multiplications&quot; doesn&#x27;t change it then why are you even asking about it?</div><br/><div id="39722924" class="c"><input type="checkbox" id="c-39722924" checked=""/><div class="controls bullet"><span class="by">barfbagginus</span><span>|</span><a href="#39714468">root</a><span>|</span><a href="#39717343">parent</a><span>|</span><a href="#39714541">next</a><span>|</span><label class="collapse" for="c-39722924">[-]</label><label class="expand" for="c-39722924">[1 more]</label></div><br/><div class="children"><div class="content">I made two really bad misunderstandings which I completely own. I can&#x27;t seem to edit it, so please let this be my refutation and explanation of my own mistake.<p>First misunderstanding: I assumed this was a new large matrix multiplication algorithm building on the hype from last week or so where we saw this paper: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2210.10173" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2210.10173</a><p>It is not an algorithm, but a hardware design - a systolic array using roughly half of the silicon area of a baseline design.<p>2. Assuming that we were talking about an algorithm, I then further assumed that it reduce an algorithm&#x27;s multiplications by half for some important n. I assumed that it did this by accelerating some critical sub procedure in the baseline algorithm into a more efficient big O class without really changing the multiplicative factor. This is a common way to reduce the number of operations of an algorithm for some fixed n. As a consequence I thought that the author must be being sloppy by not telling us the full big o details of the improvement, and just picking some n where it just so happened that half of the multiplications vanish. That also seemed unlikely to be a consequence of a improvement in the bound of matrix multiplication, given how incredibly slow the progress on matrix multiplication bound has been. So I thought that the author might even be a crank.<p>But it turned out the sloppy thinking was on me. I was being the crank.<p>Reading the paper&#x27;s introduction made it very very clear that we were dealing with a systolic array that reduces silicon area per compute.<p>Even worse that information is there in the first sentence of the readme as well.<p>Would a clearer sentence have helped me? Something like:<p>&quot;We introduce a VHDL hardware design for a systolic array that nearly halves the silicon area of a baseline array, by replacing half of the multiplication-accumulate units (MACs) with simple adder units, exploiting Winograd&#x27;s 1967 fast inner product formula (FIP).&quot;<p>I&#x27;m honestly not sure, given how bad my mistake was to begin with. Not even the diagrams tipped me off - in hind site they are very obviously hardware block diagrams, but I thought that they were just needlessly complicated algorithmic diagrams! How silly!<p>I still believe that the readme could be simplified for a general audience of goobers like me. But first and foremost I have to admit that I was being a goober!<p>Does that help you understand my mistake here? I do understand Big O and why cutting operations by half is typically a constant factor improvement. But apparently I don&#x27;t understand it well enough to prevent me from retconning a narrative with some very stinky assumptions and then projecting them on to the poor innocent hardware designer. Not very proud about that.</div><br/></div></div></div></div><div id="39714541" class="c"><input type="checkbox" id="c-39714541" checked=""/><div class="controls bullet"><span class="by">mariocesar</span><span>|</span><a href="#39714468">parent</a><span>|</span><a href="#39717343">prev</a><span>|</span><label class="collapse" for="c-39714541">[-]</label><label class="expand" for="c-39714541">[5 more]</label></div><br/><div class="children"><div class="content">It´s actually fairly clear</div><br/><div id="39714723" class="c"><input type="checkbox" id="c-39714723" checked=""/><div class="controls bullet"><span class="by">hackyhacky</span><span>|</span><a href="#39714468">root</a><span>|</span><a href="#39714541">parent</a><span>|</span><a href="#39714801">next</a><span>|</span><label class="collapse" for="c-39714723">[-]</label><label class="expand" for="c-39714723">[3 more]</label></div><br/><div class="children"><div class="content">Not to everyone. If it&#x27;s clear to you, you could helpfully explain it.</div><br/><div id="39715909" class="c"><input type="checkbox" id="c-39715909" checked=""/><div class="controls bullet"><span class="by">VogonPoetry</span><span>|</span><a href="#39714468">root</a><span>|</span><a href="#39714723">parent</a><span>|</span><a href="#39714801">next</a><span>|</span><label class="collapse" for="c-39715909">[-]</label><label class="expand" for="c-39715909">[2 more]</label></div><br/><div class="children"><div class="content">This is an analogy.  a^2 - b^2 = a<i>a - b</i>b. This can be factored to (a+b)(a-b). In the first expression there are two multiplies, in the factored version there is only one.<p>However, from a numerical analysis &#x2F; accuracy standpoint, evaluating the factored expression can result in loss of precision in the result when a is close to b. This is especially true if you repeatedly and sequentially do a lot of these operations. Loss of precision can be a problem in numeral modeling (like climate simulation) -- long term predictions diverge.<p>Given that there is a drive to use greatly reduced precision in ML engines, loss of precision might have an effect on how a model performs. Then again, it might not. I haven&#x27;t read a lot of papers on ML, but I don&#x27;t recall seeing ones that try to quantify how sensitive a model is to error propagation. (I am making a distinction between tests where the precision is reduced to see where it breaks down v.s. calculating &#x2F; understanding what the error level actually is in a model)</div><br/><div id="39716448" class="c"><input type="checkbox" id="c-39716448" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#39714468">root</a><span>|</span><a href="#39715909">parent</a><span>|</span><a href="#39714801">next</a><span>|</span><label class="collapse" for="c-39716448">[-]</label><label class="expand" for="c-39716448">[1 more]</label></div><br/><div class="children"><div class="content">With LLMs they start showing signs of brain damage once the errors get too high. In my experience it reduces their ability to reason, they stop counting correctly, and they start homogenizing categories, like calling a lemur a monkey. Compare this with quantizing weights, which instead of brain damage leads to ignorance, forcing them to hallucinate more.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>