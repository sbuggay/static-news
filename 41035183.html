<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721725254542" as="style"/><link rel="stylesheet" href="styles.css?v=1721725254542"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.ubicloud.com/blog/difference-between-running-postgres-for-yourself-and-for-others">Difference between running Postgres for yourself and for others</a> <span class="domain">(<a href="https://www.ubicloud.com">www.ubicloud.com</a>)</span></div><div class="subtext"><span>pwmtr</span> | <span>21 comments</span></div><br/><div><div id="41043814" class="c"><input type="checkbox" id="c-41043814" checked=""/><div class="controls bullet"><span class="by">superice</span><span>|</span><a href="#41035387">next</a><span>|</span><label class="collapse" for="c-41043814">[-]</label><label class="expand" for="c-41043814">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a little confused about the point-in-time restore functionality, I&#x27;m pretty sure there must be a way to not have to force those one minute WAL boundaries. DigitalOceans managed PostgreSQL for instance just allows you to specify a timestamp and restore, and when looking into the PostgreSQL docs I remember seeing an option to specify a timestamp as well.</div><br/></div></div><div id="41035387" class="c"><input type="checkbox" id="c-41035387" checked=""/><div class="controls bullet"><span class="by">pwmtr</span><span>|</span><a href="#41043814">prev</a><span>|</span><a href="#41035352">next</a><span>|</span><label class="collapse" for="c-41035387">[-]</label><label class="expand" for="c-41035387">[15 more]</label></div><br/><div class="children"><div class="content">Hey, author for the blog post is here. If you have any questions or comments, please let me know!<p>It&#x27;s also worth calling out the first diagram shows dependencies between features for Ubicloud&#x27;s managed Postgres. AWS, Azure, and GCP&#x27;s managed Postgres service would have a different diagram. That&#x27;s because we at Ubicloud treat write-ahead logs (WAL) as a first class citizen.</div><br/><div id="41043741" class="c"><input type="checkbox" id="c-41043741" checked=""/><div class="controls bullet"><span class="by">matharmin</span><span>|</span><a href="#41035387">parent</a><span>|</span><a href="#41042568">next</a><span>|</span><label class="collapse" for="c-41043741">[-]</label><label class="expand" for="c-41043741">[2 more]</label></div><br/><div class="children"><div class="content">1. Do you use logical or physical replication for high availability? It seems like logical replication requires a lot of manual intervention, so I&#x27;d assume physical replication?
2. If that&#x27;s the case, does that mean customers can&#x27;t use logical replication for other use cases?<p>I&#x27;m asking because logical replication seems to become more and more common as a solution to automatically replicate data to external systems (another Postgres instance, Kafka, data warehousing, or offline sync systems in my case), but many cloud providers appear to not support it. Many others do (including AWS, GCP), so I&#x27;d also be interested in how they handle high availability.</div><br/><div id="41044036" class="c"><input type="checkbox" id="c-41044036" checked=""/><div class="controls bullet"><span class="by">pwmtr</span><span>|</span><a href="#41035387">root</a><span>|</span><a href="#41043741">parent</a><span>|</span><a href="#41042568">next</a><span>|</span><label class="collapse" for="c-41044036">[-]</label><label class="expand" for="c-41044036">[1 more]</label></div><br/><div class="children"><div class="content">Yes, we use physical replication for HA.<p>There are many reasons that cloud providers don&#x27;t want to support logical replication;
- It requires giving superuser access to user. Many cloud providers don&#x27;t want to give that level of privilege. Some cloud providers fork PostgreSQL or write custom extensions to allow managing replication slots without requiring superuser access. However, doing it securely is very difficult. You suddenly open up a new attack vector for various privilege escalation vulnerabilities.
- If user creates a replication slot, but does not consume the changes, it can quickly fill up the disk. I dealt many different failure modes of PostgreSQL, and I can confidently say that disk full cases one of the most problematic&#x2F;annoying ones to recover from.
- It requires careful management of replication slots in case of fail over. There are extensions or 3rd party tools helping with this though.<p>So, some cloud providers don&#x27;t support logical replication and some support it weakly (i.e. don&#x27;t cover all edge cases).<p>Thankfully there are some improvements are being done in PostgreSQL core that simplifies failover of logical replication slot (check out this for more information <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;17&#x2F;logical-replication-failover.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;17&#x2F;logical-replication-failo...</a>), but it is still too early.</div><br/></div></div></div></div><div id="41042568" class="c"><input type="checkbox" id="c-41042568" checked=""/><div class="controls bullet"><span class="by">rembicilious</span><span>|</span><a href="#41035387">parent</a><span>|</span><a href="#41043741">prev</a><span>|</span><a href="#41043102">next</a><span>|</span><label class="collapse" for="c-41042568">[-]</label><label class="expand" for="c-41042568">[7 more]</label></div><br/><div class="children"><div class="content">From the article:
“If the user isn’t actively working on the database, PostgreSQL won’t generate a WAL file each minute. WAL files are by default 16 MB and PostgreSQL waits for the 16 MB to fill up. So, your restore granularity could be much longer, and you may not be able to restore to a particular minute in time.<p>You can overcome this problem by setting the archive_timeout and forcing Postgres to generate a new WAL file every minute. With this configuration, Postgres would create a new WAL file when it hits the 1-minute or 16 MB threshold, whichever comes first.<p>The second issue with backup&#x2F;restore is “no activity”. In this case, PostgreSQL wouldn’t create a new file even if the archive_timeout is set. As a solution, you can generate artificial write activity by calling pg_current_xact_id().”<p>Can you explain why to create a WAL file even though there is no activity?</div><br/><div id="41043714" class="c"><input type="checkbox" id="c-41043714" checked=""/><div class="controls bullet"><span class="by">pwmtr</span><span>|</span><a href="#41035387">root</a><span>|</span><a href="#41042568">parent</a><span>|</span><a href="#41042993">next</a><span>|</span><label class="collapse" for="c-41043714">[-]</label><label class="expand" for="c-41043714">[1 more]</label></div><br/><div class="children"><div class="content">We want to ensure that the users are able to restore to any minute in the past.<p>Then, as @pintxo, @bjornsing, and @Doxin asked below; Why not let users pick a time and then replay the closest backup? Why create empty backups? This is a valid question.<p>The answer is that without an empty backup, it&#x27;s not possible to confirm there was no write activity.  Maybe some write activity occurred but you fail to archive the WAL file. You need at least one WAL file (empty or not) with a timestamp equal to or more recent than the target restore time to ensure there were no write activity.<p>I didn&#x27;t explain this in detail in the blog post for the sake of brevity, but you don&#x27;t need to create an empty WAL file for each minute with no write activity. For instance, if there was no write activity for 10 minutes and then a WAL file is generated, PostgreSQL can deduce there was no write activity during those 10 minutes and is able restore to any minute within that period. However, if the user wants to restore to 5 minutes ago and there has been no write activity for the past 10 minutes, PostgreSQL doesn&#x27;t have a WAL file to confirm lack of write activity. In this case, you need to call pg_current_xact_id() to generate a WAL file. So the trick is, when you get a restore request, call pg_current_xact_id() only once, just in case if there were no write activity.<p>This is a good example of difference between running PostgreSQL for yourself vs. others. When running PostgreSQL for yourself, such edge cases is not a concern. However, when managing it for others, an edge case like this could prevent a restore and create an operational burden. Automating this process is required especially if you are managing lots of PostgreSQL databases.</div><br/></div></div><div id="41042993" class="c"><input type="checkbox" id="c-41042993" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#41035387">root</a><span>|</span><a href="#41042568">parent</a><span>|</span><a href="#41043714">prev</a><span>|</span><a href="#41042687">next</a><span>|</span><label class="collapse" for="c-41042993">[-]</label><label class="expand" for="c-41042993">[4 more]</label></div><br/><div class="children"><div class="content">&quot;Point in time restore&quot; is a bad way to call the feature if you don&#x27;t let your customers pick a moment in time to restore to, so those tricks ensure that there&#x27;s enough WAL entries to allow people to pick with per-second granularity.</div><br/><div id="41043249" class="c"><input type="checkbox" id="c-41043249" checked=""/><div class="controls bullet"><span class="by">pintxo</span><span>|</span><a href="#41035387">root</a><span>|</span><a href="#41042993">parent</a><span>|</span><a href="#41043345">next</a><span>|</span><label class="collapse" for="c-41043249">[-]</label><label class="expand" for="c-41043249">[1 more]</label></div><br/><div class="children"><div class="content">One can let users pick a time and then just replay the closest backup? Why create empty backups?</div><br/></div></div><div id="41043345" class="c"><input type="checkbox" id="c-41043345" checked=""/><div class="controls bullet"><span class="by">bjornsing</span><span>|</span><a href="#41035387">root</a><span>|</span><a href="#41042993">parent</a><span>|</span><a href="#41043249">prev</a><span>|</span><a href="#41043338">next</a><span>|</span><label class="collapse" for="c-41043345">[-]</label><label class="expand" for="c-41043345">[1 more]</label></div><br/><div class="children"><div class="content">&gt; those tricks ensure that there&#x27;s enough WAL entries to allow people to pick with per-second granularity<p>How can they ensure that? Sounds more like they ensure that people can pick point in time with <i>minute</i> granularity.<p>I’m no expert, but doesn’t postgres write a timestamp with each record in the WAL? I know that when you start postgres in recovery mode it lets you specify a timestamp you want to restore to, and I don’t think that timestamp needs to be on a WAL file boundary. (So the tricks seem weird &#x2F; unnecessary to me.)</div><br/></div></div><div id="41043338" class="c"><input type="checkbox" id="c-41043338" checked=""/><div class="controls bullet"><span class="by">Doxin</span><span>|</span><a href="#41035387">root</a><span>|</span><a href="#41042993">parent</a><span>|</span><a href="#41043345">prev</a><span>|</span><a href="#41042687">next</a><span>|</span><label class="collapse" for="c-41043338">[-]</label><label class="expand" for="c-41043338">[1 more]</label></div><br/><div class="children"><div class="content">But if there has been no activity you surely can just pick the most recent log that&#x27;s older than the time the user picked?</div><br/></div></div></div></div><div id="41042687" class="c"><input type="checkbox" id="c-41042687" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#41035387">root</a><span>|</span><a href="#41042568">parent</a><span>|</span><a href="#41042993">prev</a><span>|</span><a href="#41043102">next</a><span>|</span><label class="collapse" for="c-41042687">[-]</label><label class="expand" for="c-41042687">[1 more]</label></div><br/><div class="children"><div class="content">The point is to create a WAL file if there is a <i>little</i> activity, but not enough to fill 16MB.</div><br/></div></div></div></div><div id="41043102" class="c"><input type="checkbox" id="c-41043102" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#41035387">parent</a><span>|</span><a href="#41042568">prev</a><span>|</span><a href="#41042381">next</a><span>|</span><label class="collapse" for="c-41043102">[-]</label><label class="expand" for="c-41043102">[1 more]</label></div><br/><div class="children"><div class="content">Great write up. Do you plan to have similar for MySQL as well?</div><br/></div></div><div id="41042381" class="c"><input type="checkbox" id="c-41042381" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#41035387">parent</a><span>|</span><a href="#41043102">prev</a><span>|</span><a href="#41035352">next</a><span>|</span><label class="collapse" for="c-41042381">[-]</label><label class="expand" for="c-41042381">[4 more]</label></div><br/><div class="children"><div class="content">Your blog doesn&#x27;t really mention any of the turn key PostgreSQL deployment options out there.  These days, especially on Kubernetes, it has never been easier to run a SaaS-equivalent PostgreSQL stack.<p>I think you may benefit from researching the ecosystem some more.</div><br/><div id="41042908" class="c"><input type="checkbox" id="c-41042908" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#41035387">root</a><span>|</span><a href="#41042381">parent</a><span>|</span><a href="#41043547">next</a><span>|</span><label class="collapse" for="c-41042908">[-]</label><label class="expand" for="c-41042908">[1 more]</label></div><br/><div class="children"><div class="content">Being critical without posting actual better solutions isn&#x27;t so helpful.<p>If you have concrete knowledge, please share it and don&#x27;t be cryptic!</div><br/></div></div><div id="41043547" class="c"><input type="checkbox" id="c-41043547" checked=""/><div class="controls bullet"><span class="by">sakjur</span><span>|</span><a href="#41035387">root</a><span>|</span><a href="#41042381">parent</a><span>|</span><a href="#41042908">prev</a><span>|</span><a href="#41035352">next</a><span>|</span><label class="collapse" for="c-41043547">[-]</label><label class="expand" for="c-41043547">[2 more]</label></div><br/><div class="children"><div class="content">The author seems to have spent the better part of a decade working professionally with Postgres. I think editorial choice, rather than ignorance, might be why they’re not mentioning more prior art.</div><br/><div id="41043719" class="c"><input type="checkbox" id="c-41043719" checked=""/><div class="controls bullet"><span class="by">pwmtr</span><span>|</span><a href="#41035387">root</a><span>|</span><a href="#41043547">parent</a><span>|</span><a href="#41035352">next</a><span>|</span><label class="collapse" for="c-41043719">[-]</label><label class="expand" for="c-41043719">[1 more]</label></div><br/><div class="children"><div class="content">Yes. :) We quite like k8s-based managed Postgres solutions. In fact, we convinced Patroni&#x27;s author to come work with us in a previous gig at Microsoft. We find that a good number of companies successfully use k8s to manage Postgres for themselves.<p>In this blog post, we wanted to focus on running Postgres for others. AWS, Azure, and GCP&#x27;s managed Postgres services, and those offered by startups like Crunchy, don&#x27;t use k8s-based solutions. For us, one reason was operational simplicity. You can write a control plane for managed Postgres in 20K lines of code, including unit tests. This way, if anything breaks at scale, you can quickly figure out the issue without having to dive into dependencies.<p>We also understand different tradeoffs apply when you&#x27;re running Postgres for yourself or for others. In this blog post, we wanted to focus on the latter scenario.</div><br/></div></div></div></div></div></div></div></div><div id="41035352" class="c"><input type="checkbox" id="c-41035352" checked=""/><div class="controls bullet"><span class="by">ramonverse</span><span>|</span><a href="#41035387">prev</a><span>|</span><a href="#41043076">next</a><span>|</span><label class="collapse" for="c-41035352">[-]</label><label class="expand" for="c-41035352">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Security: Did you know that with one simple trick you can drop to the OS from PostgreSQL and managed service providers hate that? The trick is COPY table_name from COMMAND<p>I certainly did not know that.</div><br/><div id="41042188" class="c"><input type="checkbox" id="c-41042188" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#41035352">parent</a><span>|</span><a href="#41043076">next</a><span>|</span><label class="collapse" for="c-41042188">[-]</label><label class="expand" for="c-41042188">[1 more]</label></div><br/><div class="children"><div class="content">If anyone actually needs the extra performance from avoiding streaming over the Postgres protocol, this <i>could</i> have been done with some dignity using pipes and splice or using SCM_RIGHTS.  The latter technology has been around for a long time.</div><br/></div></div></div></div><div id="41043076" class="c"><input type="checkbox" id="c-41043076" checked=""/><div class="controls bullet"><span class="by">zhengiszen</span><span>|</span><a href="#41035352">prev</a><span>|</span><label class="collapse" for="c-41043076">[-]</label><label class="expand" for="c-41043076">[2 more]</label></div><br/><div class="children"><div class="content">In Red Hat ecosystem there is an Ansible role to that end : <a href="https:&#x2F;&#x2F;github.com&#x2F;linux-system-roles&#x2F;postgresql">https:&#x2F;&#x2F;github.com&#x2F;linux-system-roles&#x2F;postgresql</a>
I don&#x27;t know if it will help everyone but it could be a good way to standardize and maintain an instance configuration</div><br/><div id="41043094" class="c"><input type="checkbox" id="c-41043094" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#41043076">parent</a><span>|</span><label class="collapse" for="c-41043094">[-]</label><label class="expand" for="c-41043094">[1 more]</label></div><br/><div class="children"><div class="content">Is there something similar for MySQL that covers backup and restore too?</div><br/></div></div></div></div></div></div></div></div></div></body></html>