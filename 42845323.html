<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1738054866593" as="style"/><link rel="stylesheet" href="styles.css?v=1738054866593"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.jvt.me/posts/2025/01/27/go-tools-124/">Go 1.24&#x27;s go tool is one of the best additions to the ecosystem in years</a>Â <span class="domain">(<a href="https://www.jvt.me">www.jvt.me</a>)</span></div><div class="subtext"><span>keybits</span> | <span>99 comments</span></div><br/><div><div id="42850278" class="c"><input type="checkbox" id="c-42850278" checked=""/><div class="controls bullet"><span class="by">tumetab1</span><span>|</span><a href="#42849901">next</a><span>|</span><label class="collapse" for="c-42850278">[-]</label><label class="expand" for="c-42850278">[1 more]</label></div><br/><div class="children"><div class="content">I appreciate that &quot;tools&quot; that are used to build the final version of a module&#x2F;cli&#x2F;service are explicitly managed through go.mod.<p>I really dislike that now I&#x27;m going to have two problems, managing other tools installed through a makefile, e.g. lint, and managing tools &quot;installed&quot; through go.mod, e.g. mocks generators, stringify, etc.<p>I feel like this is not a net negative on the ecosystem again. Each release Golang team adds thing to manage and makes it harder to interact with other codebases. In this case, each company will have to decide if they want to use &quot;go tool&quot; and when to use it. Each time I clone an open source repo I&#x27;m going to have to check how they manage their tools.</div><br/></div></div><div id="42849901" class="c"><input type="checkbox" id="c-42849901" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#42850278">prev</a><span>|</span><a href="#42847941">next</a><span>|</span><label class="collapse" for="c-42849901">[-]</label><label class="expand" for="c-42849901">[2 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s a bad addition since it pushes people towards a worse solution to a common problem.<p>Using &quot;go tool&quot; forces you to have a bunch of dependencies in your go.mod that can conflict with your software&#x27;s real dependency requirements, when there&#x27;s zero reason those matter. You shouldn&#x27;t have to care if one of your developer tools depends on a different version of a library than you.<p>It makes it so the tools themselves also are being run with a version of software they weren&#x27;t tested with.<p>If, for example, you used &quot;shell.nix&quot; or a dockerfile with the tool built from source, the tool&#x27;s dependencies would match it&#x27;s go.mod.<p>Now they have to merge with your go.mod...<p>And then, of course, you _still_ need something like shell.nix or a flox environment (<a href="https:&#x2F;&#x2F;flox.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;flox.dev&#x2F;</a>) since you need to control the version of go, control the version of non-go tools like &quot;protoc&quot;, and so you already have a better solution to downloading and executing a known version of a program in most non-trivial repos.</div><br/><div id="42849927" class="c"><input type="checkbox" id="c-42849927" checked=""/><div class="controls bullet"><span class="by">Defletter</span><span>|</span><a href="#42849901">parent</a><span>|</span><a href="#42847941">next</a><span>|</span><label class="collapse" for="c-42849927">[-]</label><label class="expand" for="c-42849927">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Using &quot;go tool&quot; forces you to have a bunch of dependencies in your go.mod that can conflict with your software&#x27;s real dependency requirements, when there&#x27;s zero reason those matter. You shouldn&#x27;t have to care if one of your developer tools depends on a different version of a library than you.<p>Heh, were the people who made &#x27;go tool&#x27; the same people who made Maven? Would make sense :P</div><br/></div></div></div></div><div id="42847941" class="c"><input type="checkbox" id="c-42847941" checked=""/><div class="controls bullet"><span class="by">amukher1</span><span>|</span><a href="#42849901">prev</a><span>|</span><a href="#42846272">next</a><span>|</span><label class="collapse" for="c-42847941">[-]</label><label class="expand" for="c-42847941">[15 more]</label></div><br/><div class="children"><div class="content">Found this a lot easier to follow. <a href="https:&#x2F;&#x2F;blog.howardjohn.info&#x2F;posts&#x2F;go-tools-command&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.howardjohn.info&#x2F;posts&#x2F;go-tools-command&#x2F;</a><p>And didn&#x27;t quite understand the euphoria.</div><br/><div id="42849112" class="c"><input type="checkbox" id="c-42849112" checked=""/><div class="controls bullet"><span class="by">mook</span><span>|</span><a href="#42847941">parent</a><span>|</span><a href="#42848297">next</a><span>|</span><label class="collapse" for="c-42849112">[-]</label><label class="expand" for="c-42849112">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also the (draft) release notes: 
<a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;go1.24" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;go1.24</a>
And the docs: 
<a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;modules&#x2F;managing-dependencies#tools" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;modules&#x2F;managing-dependencies#tools</a><p>I&#x27;ve done the blank import thing before, it was kinda awkward but not _that_ bad.</div><br/></div></div><div id="42848297" class="c"><input type="checkbox" id="c-42848297" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#42847941">parent</a><span>|</span><a href="#42849112">prev</a><span>|</span><a href="#42848033">next</a><span>|</span><label class="collapse" for="c-42848297">[-]</label><label class="expand" for="c-42848297">[11 more]</label></div><br/><div class="children"><div class="content">&quot;Shared dependency state&quot; was my very first thought when I heard about how it was built.<p>Yeah I want none of that.  I&#x27;ll stick with my makefiles and a dedicated &quot;internal&#x2F;tools&quot; module.  Tools routinely force upgrades that break other things, and allowing that is <i>a feature</i>.</div><br/><div id="42848411" class="c"><input type="checkbox" id="c-42848411" checked=""/><div class="controls bullet"><span class="by">nikolayasdf123</span><span>|</span><a href="#42847941">root</a><span>|</span><a href="#42848297">parent</a><span>|</span><a href="#42848578">next</a><span>|</span><label class="collapse" for="c-42848411">[-]</label><label class="expand" for="c-42848411">[7 more]</label></div><br/><div class="children"><div class="content">same. tools are not part of the codebase, nor dependencies.<p>you got to have isolation of artefact and tools around to work with it.<p>it is bonkers to start versioning tools used to build project mixed with artefact dependencies itself. should we include version of VSCode used to type code? how about transitive dependencies of VSCode? how about OS itself to edit files? how about version of LLM model that generated some of this code? where does this stop?</div><br/><div id="42849369" class="c"><input type="checkbox" id="c-42849369" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#42847941">root</a><span>|</span><a href="#42848411">parent</a><span>|</span><a href="#42849430">next</a><span>|</span><label class="collapse" for="c-42849369">[-]</label><label class="expand" for="c-42849369">[3 more]</label></div><br/><div class="children"><div class="content">The state of things with some projects I&#x27;ve touched is &quot;We have a giant CI thing that does a bunch of things. It is really very large. It might or might not be broken, but we work around it and it&#x27;s fine.&quot;<p>I think some of the euphoria around tracking tooling in the repo is &quot;yes, now I can run a command in the repo and it&#x27;s as if I spun up a docker container with the CI locally, but it&#x27;s just regular software running on my machine!&quot; This is a huge improvement if you&#x27;re used to the minutes-or-hours-long CI cycle being your only interaction with the &quot;real environment.&quot;<p>The reductio ad absurdum that you describe is basically &quot;a snapshot of the definitions of all the container images in our CI pipeline.&quot; It&#x27;s not a ridiculous example, it&#x27;s how many large projects run.</div><br/><div id="42849689" class="c"><input type="checkbox" id="c-42849689" checked=""/><div class="controls bullet"><span class="by">SOLAR_FIELDS</span><span>|</span><a href="#42847941">root</a><span>|</span><a href="#42849369">parent</a><span>|</span><a href="#42849665">next</a><span>|</span><label class="collapse" for="c-42849689">[-]</label><label class="expand" for="c-42849689">[1 more]</label></div><br/><div class="children"><div class="content">It makes sense to some extent when the toolchain can tap into native language specific constructs when you need that REPL-like iteration loop to be tight and fast. But that kind of thing is probably only required in a small subset of the kind of tooling that gets implemented.<p>The tradeoff with this approach is that you lose any sort of agnosticism when you drop into the language specific tooling. So now if you work at a corporation and have to deal with multiple toolchains every engineer now needs to learn and work with new build tooling X times for each supported language. This always happens to some extent - thereâs always going to be some things that use the languageâs specific task runner constructs - but keeping that minimal is usually a good idea in this scenario.<p>Your complaint feels to me that it is about poorly implemented CI systems that heavily leverage container based workflows (of which there are many in the wild). If implemented properly with caching, really the main overhead you are paying in these types of setups is the virtualization overhead (on macs) and the cold start time for the engine. For most people and in most cases neither will make a significant difference in the wall clock time of their loop, comparatively.</div><br/></div></div><div id="42849665" class="c"><input type="checkbox" id="c-42849665" checked=""/><div class="controls bullet"><span class="by">nikolayasdf123</span><span>|</span><a href="#42847941">root</a><span>|</span><a href="#42849369">parent</a><span>|</span><a href="#42849689">prev</a><span>|</span><a href="#42849430">next</a><span>|</span><label class="collapse" for="c-42849665">[-]</label><label class="expand" for="c-42849665">[1 more]</label></div><br/><div class="children"><div class="content">I am with you on the same boat that this better be versioned and reproducible and standardised.<p>my key concern whether tools to build project have to be in the same pool as project itself (that may or may not use tools to build&#x2F;edit&#x2F;maintain&#x2F;debug it).</div><br/></div></div></div></div><div id="42849430" class="c"><input type="checkbox" id="c-42849430" checked=""/><div class="controls bullet"><span class="by">Ferret7446</span><span>|</span><a href="#42847941">root</a><span>|</span><a href="#42848411">parent</a><span>|</span><a href="#42849369">prev</a><span>|</span><a href="#42849334">next</a><span>|</span><label class="collapse" for="c-42849430">[-]</label><label class="expand" for="c-42849430">[2 more]</label></div><br/><div class="children"><div class="content">This take absolute boggles the mind.  You don&#x27;t want people compiling your code with different versions of tools so you have to debug thousands of potential combinations of everything.  You don&#x27;t want people running different versions of formatters&#x2F;linters that leave conflicting diffs throughout your commit history.</div><br/><div id="42849685" class="c"><input type="checkbox" id="c-42849685" checked=""/><div class="controls bullet"><span class="by">nikolayasdf123</span><span>|</span><a href="#42847941">root</a><span>|</span><a href="#42849430">parent</a><span>|</span><a href="#42849334">next</a><span>|</span><label class="collapse" for="c-42849685">[-]</label><label class="expand" for="c-42849685">[1 more]</label></div><br/><div class="children"><div class="content">so where does it stop? let&#x27;s include version of OS on laptop of people who edit code? it is getting ridiculous.<p>you got to draw a line somewhere.<p>in my opinion, &quot;if dependency code is not linked nor compiled-into nor copied as a source (e.g. model weights, or other artefacts) then it must not be included into dependency tree of project source code&quot;<p>that still means, you are free to track versions&#x2F;hashes&#x2F;etc. of tools and their dependencies. just do it separately.</div><br/></div></div></div></div><div id="42849334" class="c"><input type="checkbox" id="c-42849334" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#42847941">root</a><span>|</span><a href="#42848411">parent</a><span>|</span><a href="#42849430">prev</a><span>|</span><a href="#42848578">next</a><span>|</span><label class="collapse" for="c-42849334">[-]</label><label class="expand" for="c-42849334">[1 more]</label></div><br/><div class="children"><div class="content">No one says that this is a one-size-fits-all solution, but for some use cases (small tools that are intimately connected to the rest of the codebase, even reuse some internal code&#x2F;libraries) it&#x27;s probably helpful...</div><br/></div></div></div></div><div id="42848578" class="c"><input type="checkbox" id="c-42848578" checked=""/><div class="controls bullet"><span class="by">0x696C6961</span><span>|</span><a href="#42847941">root</a><span>|</span><a href="#42848297">parent</a><span>|</span><a href="#42848411">prev</a><span>|</span><a href="#42848033">next</a><span>|</span><label class="collapse" for="c-42848578">[-]</label><label class="expand" for="c-42848578">[3 more]</label></div><br/><div class="children"><div class="content">The way it&#x27;s implemented is the way that almost everyone already does it. It&#x27;s just more convenient now.</div><br/><div id="42848984" class="c"><input type="checkbox" id="c-42848984" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#42847941">root</a><span>|</span><a href="#42848578">parent</a><span>|</span><a href="#42848976">next</a><span>|</span><label class="collapse" for="c-42848984">[-]</label><label class="expand" for="c-42848984">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Popular&quot; and &quot;good&quot; have no relation to each other.  They <i>correlate</i> fairly well, but that&#x27;s all.<p>Blending those dependencies already causes somewhat frequent problems for library owners &#x2F; for users of libraries that do this. Encouraging it is not what I would consider beneficial.</div><br/></div></div></div></div></div></div><div id="42848033" class="c"><input type="checkbox" id="c-42848033" checked=""/><div class="controls bullet"><span class="by">0x696C6961</span><span>|</span><a href="#42847941">parent</a><span>|</span><a href="#42848297">prev</a><span>|</span><a href="#42846272">next</a><span>|</span><label class="collapse" for="c-42848033">[-]</label><label class="expand" for="c-42848033">[2 more]</label></div><br/><div class="children"><div class="content">Yeah it&#x27;s a nice QOL improvement. Not some game changer ...</div><br/></div></div></div></div><div id="42846272" class="c"><input type="checkbox" id="c-42846272" checked=""/><div class="controls bullet"><span class="by">bjackman</span><span>|</span><a href="#42847941">prev</a><span>|</span><a href="#42849910">next</a><span>|</span><label class="collapse" for="c-42846272">[-]</label><label class="expand" for="c-42846272">[24 more]</label></div><br/><div class="children"><div class="content">I always think it&#x27;s a shame that these features end up getting built into ecosystem-specific build tools. Why do we need separate build systems for every language? It seems entirely possible to have build system that can do all this stuff for every language at once.<p>From my experience at Google I _know_ this is possible in a Megamonorepo. I have briefly fiddled with Bazel and it seems there&#x27;s quite a barrier to entry, I dunno if that&#x27;s just lack of experience but it didn&#x27;t quite seem ready for small projects.<p>Maybe Nix is the solution but that has barrier to entry more at the human level - it just seems like a Way of Life that you have to dive all the way into.<p>Nonetheless, maybe I should try diving into one or both of those tools at some point.</div><br/><div id="42846334" class="c"><input type="checkbox" id="c-42846334" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42846272">parent</a><span>|</span><a href="#42847699">next</a><span>|</span><label class="collapse" for="c-42846334">[-]</label><label class="expand" for="c-42846334">[8 more]</label></div><br/><div class="children"><div class="content">(I worked on source control at FB for many years.)<p>The main argument for not overly genericizing things is that you can deliver a better user experience through domain-specific code.<p>For Bazel and buck2 specifically, they require a total commitment to it, which implies ongoing maintenance work. I also think the fact that they don&#x27;t have open governance is a hindrance. Google&#x27;s and Meta&#x27;s internal monorepos make certain tradeoffs that don&#x27;t quite work in a more distributed model.<p>Bazel is also in Java I believe, which is a bit unfortunate due to process startup times. On my machine, `time bazelisk --help` takes over 0.75 seconds to run, compared to `time go --help` which is 0.003 seconds and `time cargo --help` which is 0.02 seconds. (This doesn&#x27;t apply to buck2, which is in Rust.)</div><br/><div id="42849535" class="c"><input type="checkbox" id="c-42849535" checked=""/><div class="controls bullet"><span class="by">spockz</span><span>|</span><a href="#42846272">root</a><span>|</span><a href="#42846334">parent</a><span>|</span><a href="#42846810">next</a><span>|</span><label class="collapse" for="c-42849535">[-]</label><label class="expand" for="c-42849535">[1 more]</label></div><br/><div class="children"><div class="content">GraalVMâs native image has been a thing for a while now. This could overcome the daemon issue partially. The daemon does more ofc by as it keeps some state in memory. But at least the binary start time is a solved problem in Java land.</div><br/></div></div><div id="42846810" class="c"><input type="checkbox" id="c-42846810" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#42846272">root</a><span>|</span><a href="#42846334">parent</a><span>|</span><a href="#42849535">prev</a><span>|</span><a href="#42847699">next</a><span>|</span><label class="collapse" for="c-42846810">[-]</label><label class="expand" for="c-42846810">[6 more]</label></div><br/><div class="children"><div class="content">This is likely because you are running it in some random PWD that doesn&#x27;t represent a bazel workspace. When running in a workspace the bazel daemon persists. Inside my workspace the bazelisk --help invocation needs just 30ms real time.<p>Running bazel outside of a bazel workspace is not a major use-case that needs to be fixed.</div><br/><div id="42849156" class="c"><input type="checkbox" id="c-42849156" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#42846272">root</a><span>|</span><a href="#42846810">parent</a><span>|</span><a href="#42846887">next</a><span>|</span><label class="collapse" for="c-42849156">[-]</label><label class="expand" for="c-42849156">[1 more]</label></div><br/><div class="children"><div class="content">&gt; When running in a workspace the bazel daemon persists. Inside my workspace the bazelisk --help invocation needs just 30ms real time.<p>It still has a slow startup time, bazel just works around that by using a persistent daemon, so that it is relatively fast after as long as the daemon is running.</div><br/></div></div><div id="42846887" class="c"><input type="checkbox" id="c-42846887" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42846272">root</a><span>|</span><a href="#42846810">parent</a><span>|</span><a href="#42849156">prev</a><span>|</span><a href="#42847699">next</a><span>|</span><label class="collapse" for="c-42846887">[-]</label><label class="expand" for="c-42846887">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s good to know, thank you!<p>Do you encounter cache invalidation bugs with daemonization often? I&#x27;ve had pretty bad experiences with daemonized dev tools in the past.</div><br/><div id="42847915" class="c"><input type="checkbox" id="c-42847915" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#42846272">root</a><span>|</span><a href="#42846887">parent</a><span>|</span><a href="#42847699">next</a><span>|</span><label class="collapse" for="c-42847915">[-]</label><label class="expand" for="c-42847915">[3 more]</label></div><br/><div class="children"><div class="content">Bazel prints a message when you invalidate the in-memory cache in a perhaps accidental way; you can supply it with a flag to make this an error and skip the cache invalidation.<p>If you try to run two Bazel invocations in parallel in the same workspace, one waits for the other to be done.</div><br/><div id="42847991" class="c"><input type="checkbox" id="c-42847991" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#42846272">root</a><span>|</span><a href="#42847915">parent</a><span>|</span><a href="#42847699">next</a><span>|</span><label class="collapse" for="c-42847991">[-]</label><label class="expand" for="c-42847991">[2 more]</label></div><br/><div class="children"><div class="content">I assumed they meant an error of improperly using cached results. I am sure bazel has its flaws but it assiduously avoids that.</div><br/><div id="42848479" class="c"><input type="checkbox" id="c-42848479" checked=""/><div class="controls bullet"><span class="by">__float</span><span>|</span><a href="#42846272">root</a><span>|</span><a href="#42847991">parent</a><span>|</span><a href="#42847699">next</a><span>|</span><label class="collapse" for="c-42848479">[-]</label><label class="expand" for="c-42848479">[1 more]</label></div><br/><div class="children"><div class="content">Yes, unless you&#x27;re using persistent workers. Then you may very well run into the same issues they mention.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42847699" class="c"><input type="checkbox" id="c-42847699" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#42846272">parent</a><span>|</span><a href="#42846334">prev</a><span>|</span><a href="#42847148">next</a><span>|</span><label class="collapse" for="c-42847699">[-]</label><label class="expand" for="c-42847699">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Why do we need separate build systems for every language?<p>Because being cross-language makes them inherit all of the complexity of the worst languages they support.<p>The infinite flexibility required to accommodate everyone keeps costing you at every step.<p>You need to learn a tool that is more powerful than your language requires, and pay the cost of more abstraction layers than you need.<p>Then you have to work with snowflake projects that are all different in arbitrary ways, because the everything-agnostic tool didn&#x27;t impose any conventions or constraints.<p>The vague do-it-all build systems make everything more complicated than necessary. Their &quot;simple&quot; components are either a mere execution primitive that make handling different platforms&#x2F;versions&#x2F;configurations your problem, or are macros&#x2F;magic&#x2F;plugins that are a fractal of a build system written inside a build system, with more custom complexity underneath.<p>OTOH a language-specific build system knows exactly what that language needs, and doesn&#x27;t need to support more. It can include specific solutions and workarounds for its target environments, out of the box, because it knows what it&#x27;s building and what platforms it supports. It can use conventions and defaults of its language to do most things without configuration. 
General build tools need build scripts written, debugged, and tweaked endlessly.<p>A single-language build tool can support just one standard project structure and have all projects and dependencies follow it. That makes it easier to work on other projects, and easier to write tooling that works with all of them. All because focused build system doesn&#x27;t accommodate all the custom legacy projects of all languages.<p>You don&#x27;t realize how much of a skill-and-effort black hole build scripts are is until you use a language where a build command just builds it.</div><br/><div id="42850106" class="c"><input type="checkbox" id="c-42850106" checked=""/><div class="controls bullet"><span class="by">bjackman</span><span>|</span><a href="#42846272">root</a><span>|</span><a href="#42847699">parent</a><span>|</span><a href="#42847148">next</a><span>|</span><label class="collapse" for="c-42850106">[-]</label><label class="expand" for="c-42850106">[1 more]</label></div><br/><div class="children"><div class="content">But this just doesn&#x27;t match my experience with Blaze at all. For my internal usage with C++ &amp; Go it&#x27;s perfect. For the weird niche use case of building and packaging BPF programs (with no support from the central tooling teams, we had to write our own macros) it still just works. For Python where it&#x27;s a poor fit for the language norms it&#x27;s a minor inconvenience but still mostly stays out of the way. I hear Java is similar.<p>For vendored open source projects that build with random other tools (CMake, Nix, custom Makefile) it&#x27;s a pain but the fact that it&#x27;s generally possible to get them building with Blaze at all says something...<p>Yes, the monorepo makes all of this dramatically easier. I can consider &quot;one-build-tool-to-rule-them-all isn&#x27;t really practical outside of a monorepo&quot; as a valid argument, although it remains to be proven. But &quot;you fundamentally need a build tool per language&quot; doesn&#x27;t hold any water for me.<p>&gt; That makes it easier to work on other projects, and easier to write tooling that works with all of them.<p>But... this is my whole point. Only if those projects are in the same language as yours! I can see how maybe that&#x27;s valid in some domains where there&#x27;s probably a lot of people who can just do almost everything on JS&#x2F;TS, maybe Java has a similar domain. But for most of us switching between Go&#x2F;Cargo&#x2F;CMake etc is a huge pain.<p>Oh btw, there&#x27;s also Meson. That&#x27;s very cross-language while also seeming extremely simple to use. But it doesn&#x27;t seem to deliver a very full-featured experience.</div><br/></div></div></div></div><div id="42847148" class="c"><input type="checkbox" id="c-42847148" checked=""/><div class="controls bullet"><span class="by">jlarsen</span><span>|</span><a href="#42846272">parent</a><span>|</span><a href="#42847699">prev</a><span>|</span><a href="#42847657">next</a><span>|</span><label class="collapse" for="c-42847148">[-]</label><label class="expand" for="c-42847148">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had exactly the same thought, after hitting walls repeatedly with limitations in single-language ecosystems. And likewise, I&#x27;ve had the same concerns around the complexity that comes with Bazel&#x2F;Buck&#x2F;Nix.<p>It&#x27;s been such a frustration for me that I started writing my own as a side project a year or two ago, based on a using a standardized filesystem structure for packages instead of a manifest or configuration language. By leaning into the filesystem heavily, you can avoid a lot of language lock-in and complexity that comes with other tools. And with fingerprint-based addressing for packages and files, it&#x27;s quite fast. Incremental rebuild checks for my projects with hundreds of packages take only 200-300ms on my low-end laptop with an Intel N200 and mid-tier SSD.<p>It&#x27;s an early stage project and the documentation needs some work, but if you&#x27;re interested:
<a href="https:&#x2F;&#x2F;github.com&#x2F;somesocks&#x2F;dryad">https:&#x2F;&#x2F;github.com&#x2F;somesocks&#x2F;dryad</a>
<a href="https:&#x2F;&#x2F;somesocks.github.io&#x2F;dryad&#x2F;" rel="nofollow">https:&#x2F;&#x2F;somesocks.github.io&#x2F;dryad&#x2F;</a><p>One other alternative I know of that&#x27;s multi-language is Pants(<a href="https:&#x2F;&#x2F;www.pantsbuild.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.pantsbuild.org&#x2F;</a>), which has support for packages in several languages, and an &quot;ad-hoc&quot; mode which lets you build packages with a custom tool if it isn&#x27;t officially supported. They&#x27;ve added support for quite a few new tools&#x2F;languages lately, and seem to be very much an active project.</div><br/></div></div><div id="42847657" class="c"><input type="checkbox" id="c-42847657" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#42846272">parent</a><span>|</span><a href="#42847148">prev</a><span>|</span><a href="#42846525">next</a><span>|</span><label class="collapse" for="c-42847657">[-]</label><label class="expand" for="c-42847657">[6 more]</label></div><br/><div class="children"><div class="content">I think the problem is basically because the build system has to be implemented using <i>some</i> ecosystem, and no other ecosystem wants to depend on <i>that</i> one.<p>If your &quot;one build system to rule them all&quot; was built in, say, Ruby, the Python ecosystem won&#x27;t want to use it. No Python evangelist wants to tell users that step 1 of getting up and running with Python is &quot;Install Ruby&quot;.<p>So you tend to get a lot of wheel reinvention across ecosystems.<p>I don&#x27;t necessarily think it&#x27;s a bad thing. Yes, it&#x27;s a lot of redundant work. But it&#x27;s also an opportunity to shed historical baggage and learn from previous mistakes. Compare, for example, how beloved Rust&#x27;s cargo ecosystem is compared the ongoing mess that is package management in Python.<p>A fresh start can be valuable, and not having a monoculture can be helpful for rapid evolution.</div><br/><div id="42847953" class="c"><input type="checkbox" id="c-42847953" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#42846272">root</a><span>|</span><a href="#42847657">parent</a><span>|</span><a href="#42848269">next</a><span>|</span><label class="collapse" for="c-42847953">[-]</label><label class="expand" for="c-42847953">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>No Python evangelist wants to tell users that step 1 of getting up and running with Python is &quot;Install Ruby&quot;.</i><p>True, but the Python community does seem to be coalescing around tools like UV and Ruff, written in Rust. Presumably thatâs more acceptable because itâs a compiled language, so they tell users to âinstall UVâ not âinstall Rustâ.</div><br/><div id="42849770" class="c"><input type="checkbox" id="c-42849770" checked=""/><div class="controls bullet"><span class="by">makapuf</span><span>|</span><a href="#42846272">root</a><span>|</span><a href="#42847953">parent</a><span>|</span><a href="#42849193">next</a><span>|</span><label class="collapse" for="c-42849770">[-]</label><label class="expand" for="c-42849770">[1 more]</label></div><br/><div class="children"><div class="content">Note that installing python stdlib installs tkinter and thus tcl.<p><a href="https:&#x2F;&#x2F;wiki.tcl-lang.org&#x2F;page&#x2F;Python-Tcl-Interactions" rel="nofollow">https:&#x2F;&#x2F;wiki.tcl-lang.org&#x2F;page&#x2F;Python-Tcl-Interactions</a></div><br/></div></div><div id="42849193" class="c"><input type="checkbox" id="c-42849193" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42846272">root</a><span>|</span><a href="#42847953">parent</a><span>|</span><a href="#42849770">prev</a><span>|</span><a href="#42848269">next</a><span>|</span><label class="collapse" for="c-42849193">[-]</label><label class="expand" for="c-42849193">[1 more]</label></div><br/><div class="children"><div class="content">I tend to think that is more Rust community using Python, and RIIR stuff, than Python community themselves.<p>I know Python since version 1.6, and this has never been a thing until Rust.<p>Same applies to the RIIR going on JavaScript side.<p>Including tools that were already written in compiled languages, but of course weren&#x27;t Rust, or had an idea to make a startup around them.</div><br/></div></div></div></div><div id="42848269" class="c"><input type="checkbox" id="c-42848269" checked=""/><div class="controls bullet"><span class="by">6keZbCECT2uB</span><span>|</span><a href="#42846272">root</a><span>|</span><a href="#42847657">parent</a><span>|</span><a href="#42847953">prev</a><span>|</span><a href="#42847874">next</a><span>|</span><label class="collapse" for="c-42848269">[-]</label><label class="expand" for="c-42848269">[1 more]</label></div><br/><div class="children"><div class="content">Partly in jest, you can often find a Perl &#x2F; bash available where you can&#x27;t find a Python, Ruby, or Cargo.</div><br/></div></div><div id="42847874" class="c"><input type="checkbox" id="c-42847874" checked=""/><div class="controls bullet"><span class="by">marwis</span><span>|</span><a href="#42846272">root</a><span>|</span><a href="#42847657">parent</a><span>|</span><a href="#42848269">prev</a><span>|</span><a href="#42846525">next</a><span>|</span><label class="collapse" for="c-42847874">[-]</label><label class="expand" for="c-42847874">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like the only way out of this is to design language agnostic tooling protocols that anybody can implement.</div><br/></div></div></div></div><div id="42846525" class="c"><input type="checkbox" id="c-42846525" checked=""/><div class="controls bullet"><span class="by">6keZbCECT2uB</span><span>|</span><a href="#42846272">parent</a><span>|</span><a href="#42847657">prev</a><span>|</span><a href="#42849174">next</a><span>|</span><label class="collapse" for="c-42846525">[-]</label><label class="expand" for="c-42846525">[4 more]</label></div><br/><div class="children"><div class="content">I agree. In my opinion, if you can keep the experience of Bazel limited to build targets, there is a low barrier to entry even if it is tedious. Major issues show up with Bazel once you start having to write rules, tool chains, or if your workspace file talks to the Internet.<p>I think you can fix these issues by using a package manager around Bazel. Conda is my preferred choice because it is in the top tier for adoption, cross platform support, and supported more locked down use cases like going through mirrors, not having root, not controlling file paths, etc. What Bazel gets from this is a generic solution for package management with better version solving for build rules, source dependencies and binary dependencies. By sourcing binary deps from conda forge, you get a midpoint between deep investment into Bazel and binaries with unknown provenance which allows you to incrementally move to source as appropriate.<p>Additional notes: some requirements limit utility and approach being partial support of a platform. If you require root on Linux, wsl on Windows, have frequent compilation breakage on darwin, or neglect Windows file paths, your cross platform support is partial in my book.<p>Use of Java for Bazel and Python for conda might be regrettable, but not bad enough to warrant moving down the list of adoption and in my experience there is vastly more Bazel out there than Buck or other competitors. Similarly, you want to see some adoption from Haskell, Rust, Julia, Golang, Python, C++, etc.<p>JavaScript is thorny. You really don&#x27;t want to have to deal with multiple versions of the same library with compiled languages, but you have to with JavaScript. I haven&#x27;t seen too much demand for JavaScript bindings to C++ wrappers around a Rust core that uses C core libraries, but I do see that for Python bindings.</div><br/><div id="42846626" class="c"><input type="checkbox" id="c-42846626" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42846272">root</a><span>|</span><a href="#42846525">parent</a><span>|</span><a href="#42849174">next</a><span>|</span><label class="collapse" for="c-42846626">[-]</label><label class="expand" for="c-42846626">[3 more]</label></div><br/><div class="children"><div class="content">&gt; You really don&#x27;t want to have to deal with multiple versions of the same library with compiled languages, but you have to with JavaScript.<p>Rust handles this fine by unifying up to semver compatibility -- diamond dependency hell is an artifact of the lack of namespacing in many older languages.</div><br/><div id="42848252" class="c"><input type="checkbox" id="c-42848252" checked=""/><div class="controls bullet"><span class="by">6keZbCECT2uB</span><span>|</span><a href="#42846272">root</a><span>|</span><a href="#42846626">parent</a><span>|</span><a href="#42849174">next</a><span>|</span><label class="collapse" for="c-42848252">[-]</label><label class="expand" for="c-42848252">[2 more]</label></div><br/><div class="children"><div class="content">Conda unifies by using a sat solver to find versions of software which are mutually compatible regardless of whether they agree on the meaning of semver. So, both approaches require unifying versions. Linking against C gets pretty broken without this.<p>The issue I was referring to is that in Javascript, you can write code which uses multiple versions of the same library which are mutually incompatible. Since they&#x27;re mutually incompatible, no sat-solve or unifyer is going to help you. You must permit multiple versions of the same library in the same environment. So far, my approach of ignoring some Javascript libraries has worked for my backend development. :)</div><br/><div id="42848975" class="c"><input type="checkbox" id="c-42848975" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42846272">root</a><span>|</span><a href="#42848252">parent</a><span>|</span><a href="#42849174">next</a><span>|</span><label class="collapse" for="c-42848975">[-]</label><label class="expand" for="c-42848975">[1 more]</label></div><br/><div class="children"><div class="content">Rust does permit multiple incompatible versions of the same library in the same environment. The types&#x2F;objects from one version are distinct from the types&#x2F;objects of the other, it&#x27;s a type error to try mix them.<p>But you can use two versions of the same library in your project; I&#x27;ve done it by giving one of them a different name.</div><br/></div></div></div></div></div></div></div></div><div id="42849174" class="c"><input type="checkbox" id="c-42849174" checked=""/><div class="controls bullet"><span class="by">morepedantic</span><span>|</span><a href="#42846272">parent</a><span>|</span><a href="#42846525">prev</a><span>|</span><a href="#42847689">next</a><span>|</span><label class="collapse" for="c-42849174">[-]</label><label class="expand" for="c-42849174">[1 more]</label></div><br/><div class="children"><div class="content">Brazil performs dependency resolution in a language-agnostic way.<p><a href="https:&#x2F;&#x2F;gist.github.com&#x2F;terabyte&#x2F;15a2d3d407285b8b5a0a7964dd6283b0" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;terabyte&#x2F;15a2d3d407285b8b5a0a7964dd6...</a></div><br/></div></div><div id="42847689" class="c"><input type="checkbox" id="c-42847689" checked=""/><div class="controls bullet"><span class="by">lihaoyi</span><span>|</span><a href="#42846272">parent</a><span>|</span><a href="#42849174">prev</a><span>|</span><a href="#42849910">next</a><span>|</span><label class="collapse" for="c-42847689">[-]</label><label class="expand" for="c-42847689">[1 more]</label></div><br/><div class="children"><div class="content">My experience with Bazel is it does everything you need, and works incredibly well once set up, but is ferociously complex and hard to learn and get started with. Buck and Pants are easier in some ways, but fundamentally they still look and feel mostly like Bazel, warts and all<p>I&#x27;ve been working on an alternate build tool Mill (<a href="https:&#x2F;&#x2F;www.mill-build.org" rel="nofollow">https:&#x2F;&#x2F;www.mill-build.org</a>) tries to provide the 90% of Bazel that people need at 10% the complexity cost. From a greenfield perspective a lot of work to try and catch up to Bazel&#x27;s cross-language support and community. I think we can eventually get there, but it will be a long slog</div><br/></div></div></div></div><div id="42849910" class="c"><input type="checkbox" id="c-42849910" checked=""/><div class="controls bullet"><span class="by">puika</span><span>|</span><a href="#42846272">prev</a><span>|</span><a href="#42845903">next</a><span>|</span><label class="collapse" for="c-42849910">[-]</label><label class="expand" for="c-42849910">[1 more]</label></div><br/><div class="children"><div class="content">My current approach has been setting GOBIN to a local project bin via direnv and go installing bins there. install commands themselves are cached by me with a naive checksum check for the install script itself when I run my commands. Therefore all `go install`s run in parallel if I edit the install script, and go decides what to reinstall or not. At this point I don&#x27;t feel it&#x27;s worth migrating to `go tool` having this setup, we&#x27;ll see when it&#x27;s stable</div><br/></div></div><div id="42845903" class="c"><input type="checkbox" id="c-42845903" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#42849910">prev</a><span>|</span><a href="#42845954">next</a><span>|</span><label class="collapse" for="c-42845903">[-]</label><label class="expand" for="c-42845903">[7 more]</label></div><br/><div class="children"><div class="content">So it&#x27;s just dev-dependencies?</div><br/><div id="42848417" class="c"><input type="checkbox" id="c-42848417" checked=""/><div class="controls bullet"><span class="by">nikolayasdf123</span><span>|</span><a href="#42845903">parent</a><span>|</span><a href="#42847648">next</a><span>|</span><label class="collapse" for="c-42848417">[-]</label><label class="expand" for="c-42848417">[2 more]</label></div><br/><div class="children"><div class="content">a bit worse. it is all mixed up. to keep separate dependency tree for tools need use old approach with go.mod. it is actually even worse now.</div><br/><div id="42850077" class="c"><input type="checkbox" id="c-42850077" checked=""/><div class="controls bullet"><span class="by">nikolayasdf123</span><span>|</span><a href="#42845903">root</a><span>|</span><a href="#42848417">parent</a><span>|</span><a href="#42847648">next</a><span>|</span><label class="collapse" for="c-42850077">[-]</label><label class="expand" for="c-42850077">[1 more]</label></div><br/><div class="children"><div class="content">UPD: there is no separate dependency tree. it is all single tree. transitive dependencies on tools versions will be propagated downstream. it would be impossible not to track tools dependencies.</div><br/></div></div></div></div><div id="42847648" class="c"><input type="checkbox" id="c-42847648" checked=""/><div class="controls bullet"><span class="by">silverwind</span><span>|</span><a href="#42845903">parent</a><span>|</span><a href="#42848417">prev</a><span>|</span><a href="#42845910">next</a><span>|</span><label class="collapse" for="c-42847648">[-]</label><label class="expand" for="c-42847648">[2 more]</label></div><br/><div class="children"><div class="content">Yes, except it does not support version ranges.</div><br/><div id="42847687" class="c"><input type="checkbox" id="c-42847687" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#42845903">root</a><span>|</span><a href="#42847648">parent</a><span>|</span><a href="#42845910">next</a><span>|</span><label class="collapse" for="c-42847687">[-]</label><label class="expand" for="c-42847687">[1 more]</label></div><br/><div class="children"><div class="content">Go uses Minimum Version Selection (MVS) instead of a SAT solver. There are no ranges in any go dependency specifications. It&#x27;s actually a very simple and elegant algorithm for dependency version selection<p><a href="https:&#x2F;&#x2F;research.swtch.com&#x2F;vgo-mvs" rel="nofollow">https:&#x2F;&#x2F;research.swtch.com&#x2F;vgo-mvs</a></div><br/></div></div></div></div><div id="42845910" class="c"><input type="checkbox" id="c-42845910" checked=""/><div class="controls bullet"><span class="by">jamietanna</span><span>|</span><a href="#42845903">parent</a><span>|</span><a href="#42847648">prev</a><span>|</span><a href="#42847029">next</a><span>|</span><label class="collapse" for="c-42845910">[-]</label><label class="expand" for="c-42845910">[1 more]</label></div><br/><div class="children"><div class="content">Yep, that&#x27;s the intent</div><br/></div></div><div id="42847029" class="c"><input type="checkbox" id="c-42847029" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#42845903">parent</a><span>|</span><a href="#42845910">prev</a><span>|</span><a href="#42845954">next</a><span>|</span><label class="collapse" for="c-42847029">[-]</label><label class="expand" for="c-42847029">[1 more]</label></div><br/><div class="children"><div class="content">lol yea</div><br/></div></div></div></div><div id="42845954" class="c"><input type="checkbox" id="c-42845954" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#42845903">prev</a><span>|</span><a href="#42849962">next</a><span>|</span><label class="collapse" for="c-42845954">[-]</label><label class="expand" for="c-42845954">[2 more]</label></div><br/><div class="children"><div class="content">This seems handy, but often the tools run by `go generate` are outside of the Go ecosystem, or need to be binaries.<p>So I think a general solution would work better, and not be limited to Go. There are plenty of tools in this space to choose from: mise, devenv, Nix, Hermit, etc.</div><br/><div id="42847726" class="c"><input type="checkbox" id="c-42847726" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#42845954">parent</a><span>|</span><a href="#42849962">next</a><span>|</span><label class="collapse" for="c-42847726">[-]</label><label class="expand" for="c-42847726">[1 more]</label></div><br/><div class="children"><div class="content">better motivation for rewrite it in go...<p>but are there really that many tools you need in a go project not written in go?</div><br/></div></div></div></div><div id="42849962" class="c"><input type="checkbox" id="c-42849962" checked=""/><div class="controls bullet"><span class="by">nikolayasdf123</span><span>|</span><a href="#42845954">prev</a><span>|</span><a href="#42847417">next</a><span>|</span><label class="collapse" for="c-42849962">[-]</label><label class="expand" for="c-42849962">[1 more]</label></div><br/><div class="children"><div class="content">what is also concerning, Go team years ago did small vote, small survey of positive occurrences, and decided to enforce it globally for anyone.<p>old design give people option to use `tools.go` approach, or other, or nothing at all. now they are enforcing this `tools.go` standard. Go looks to be moving into very restrictive territories.<p>what about surveying opposing views? what about people who did not use `tools.go`<p>what is going on in Google, Go team?</div><br/></div></div><div id="42847417" class="c"><input type="checkbox" id="c-42847417" checked=""/><div class="controls bullet"><span class="by">dprotaso</span><span>|</span><a href="#42849962">prev</a><span>|</span><a href="#42849853">next</a><span>|</span><label class="collapse" for="c-42847417">[-]</label><label class="expand" for="c-42847417">[1 more]</label></div><br/><div class="children"><div class="content">Funny to see a little go library you wrote [1] show up in a blog post years later. I need to update it now that go has iterators and generics.<p>Another great blog post [2] covers performance issues with go tool<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;dprotaso&#x2F;go-yit">https:&#x2F;&#x2F;github.com&#x2F;dprotaso&#x2F;go-yit</a><p>[2] <a href="https:&#x2F;&#x2F;blog.howardjohn.info&#x2F;posts&#x2F;go-tools-command&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.howardjohn.info&#x2F;posts&#x2F;go-tools-command&#x2F;</a></div><br/></div></div><div id="42849853" class="c"><input type="checkbox" id="c-42849853" checked=""/><div class="controls bullet"><span class="by">nikolayasdf123</span><span>|</span><a href="#42847417">prev</a><span>|</span><a href="#42849886">next</a><span>|</span><label class="collapse" for="c-42849853">[-]</label><label class="expand" for="c-42849853">[1 more]</label></div><br/><div class="children"><div class="content">proposal is closed and accepted by Go team. [~sigh]<p>you can still leave comments in discussion issue: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;48429">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;48429</a></div><br/></div></div><div id="42849886" class="c"><input type="checkbox" id="c-42849886" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#42849853">prev</a><span>|</span><a href="#42849285">next</a><span>|</span><label class="collapse" for="c-42849886">[-]</label><label class="expand" for="c-42849886">[1 more]</label></div><br/><div class="children"><div class="content">A note for the author in case they are reading: &quot;i.e.&quot; means &quot;that is&quot;, &quot;e.g.&quot; means &quot;for example&quot;. You should be able to substitute these meanings and find the sentence makes sense. In all cases here you wanted &quot;e.g.&quot;.</div><br/></div></div><div id="42849153" class="c"><input type="checkbox" id="c-42849153" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42849285">prev</a><span>|</span><a href="#42845870">next</a><span>|</span><label class="collapse" for="c-42849153">[-]</label><label class="expand" for="c-42849153">[1 more]</label></div><br/><div class="children"><div class="content">This has been a thing in dotnet tool for years, now.</div><br/></div></div><div id="42845870" class="c"><input type="checkbox" id="c-42845870" checked=""/><div class="controls bullet"><span class="by">syvolt</span><span>|</span><a href="#42849153">prev</a><span>|</span><a href="#42845947">next</a><span>|</span><label class="collapse" for="c-42845870">[-]</label><label class="expand" for="c-42845870">[17 more]</label></div><br/><div class="children"><div class="content">I have tested it and probably will use it but the fact that it pollutes your go.mod&#x27;s indirect dependency list (without any distinction indicating it&#x27;s for a tool) is very annoying.</div><br/><div id="42846778" class="c"><input type="checkbox" id="c-42846778" checked=""/><div class="controls bullet"><span class="by">cirwin</span><span>|</span><a href="#42845870">parent</a><span>|</span><a href="#42846750">next</a><span>|</span><label class="collapse" for="c-42846778">[-]</label><label class="expand" for="c-42846778">[11 more]</label></div><br/><div class="children"><div class="content">Primary contributor to the feature here.<p>We went back on forth on this <i>a lot</i>, but it boiled down to wanting only one dependency graph per module instead of two. This simplifies things like security scanners, and other workflows that analyze your dependencies.<p>A `&#x2F;&#x2F; tool` comment would be a nice addition, it&#x27;s probably not impossible to add, but the code is quite fiddly.<p>Luckily for library authors, although it does impact version selection for projects who use your module; those projects do not get `&#x2F;&#x2F; indirect` lines in their go.mod because those packages are not required when building their module.</div><br/><div id="42847426" class="c"><input type="checkbox" id="c-42847426" checked=""/><div class="controls bullet"><span class="by">syvolt</span><span>|</span><a href="#42845870">root</a><span>|</span><a href="#42846778">parent</a><span>|</span><a href="#42848235">next</a><span>|</span><label class="collapse" for="c-42847426">[-]</label><label class="expand" for="c-42847426">[8 more]</label></div><br/><div class="children"><div class="content">Thank you for working on it. It is a nice feature and still better than alternatives.<p>I&#x27;m not a library author and I try to be careful about what dependencies I introduce to my projects (including indirect dependencies). On one project, switching to `go tool` makes my go.mod go from 93 lines to 247 (excluding the tools themselves) - this makes it infeasible to manually review.<p>If I&#x27;m only using a single feature of a multi-purpose tool for example, does it matter to me that some unrelated dependency of theirs has a security issue?</div><br/><div id="42847596" class="c"><input type="checkbox" id="c-42847596" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#42845870">root</a><span>|</span><a href="#42847426">parent</a><span>|</span><a href="#42848235">next</a><span>|</span><label class="collapse" for="c-42847596">[-]</label><label class="expand" for="c-42847596">[7 more]</label></div><br/><div class="children"><div class="content">&gt;If I&#x27;m only using a single feature of a multi-purpose tool for example, does it matter to me that some unrelated dependency of theirs has a security issue?<p>How is anyone supposed to know whether there&#x27;s an issue or not? To simplify things, if you use the tool and the dependency belongs to the tool, then the issue can affect you. Anything more advanced than that requires analyzing the code.</div><br/><div id="42847813" class="c"><input type="checkbox" id="c-42847813" checked=""/><div class="controls bullet"><span class="by">syvolt</span><span>|</span><a href="#42845870">root</a><span>|</span><a href="#42847596">parent</a><span>|</span><a href="#42847709">next</a><span>|</span><label class="collapse" for="c-42847813">[-]</label><label class="expand" for="c-42847813">[3 more]</label></div><br/><div class="children"><div class="content">What if I&#x27;m already using techniques, such as sandboxing, to prevent the tools from doing anything unexpected? Why bring this entire mess of indirect dependencies into my project if I&#x27;m just using a tool to occasionally analyze my binary&#x27;s output size? Or a tool to lint my protobuf files?</div><br/><div id="42848204" class="c"><input type="checkbox" id="c-42848204" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#42845870">root</a><span>|</span><a href="#42847813">parent</a><span>|</span><a href="#42847709">next</a><span>|</span><label class="collapse" for="c-42848204">[-]</label><label class="expand" for="c-42848204">[2 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s a build dependency, then you have to have it. If you don&#x27;t like the size of the tool then take it up with the authors. I&#x27;m not a Go programmer by the way, this is all just obvious to me.</div><br/><div id="42848256" class="c"><input type="checkbox" id="c-42848256" checked=""/><div class="controls bullet"><span class="by">syvolt</span><span>|</span><a href="#42845870">root</a><span>|</span><a href="#42848204">parent</a><span>|</span><a href="#42847709">next</a><span>|</span><label class="collapse" for="c-42848256">[-]</label><label class="expand" for="c-42848256">[1 more]</label></div><br/><div class="children"><div class="content">The functionality we&#x27;re discussing can be used for tools that are not build dependencies. They may be important for your project and worth having contributors be on the same version but not part of the build.<p>It will still add the dependencies of those tools as indirect dependencies to your go.mod file, that is what&#x27;s being discussed.</div><br/></div></div></div></div></div></div><div id="42847709" class="c"><input type="checkbox" id="c-42847709" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#42845870">root</a><span>|</span><a href="#42847596">parent</a><span>|</span><a href="#42847813">prev</a><span>|</span><a href="#42848235">next</a><span>|</span><label class="collapse" for="c-42847709">[-]</label><label class="expand" for="c-42847709">[3 more]</label></div><br/><div class="children"><div class="content">In addition, a good dependency security scanning tool can analyze reachability to answer this question for you</div><br/><div id="42847777" class="c"><input type="checkbox" id="c-42847777" checked=""/><div class="controls bullet"><span class="by">syvolt</span><span>|</span><a href="#42845870">root</a><span>|</span><a href="#42847709">parent</a><span>|</span><a href="#42848235">next</a><span>|</span><label class="collapse" for="c-42847777">[-]</label><label class="expand" for="c-42847777">[2 more]</label></div><br/><div class="children"><div class="content">Reachability analysis on a tool that could be called by something outside of the project? We&#x27;re talking about tools here after all - anything that can run `go tool` in that directory can call it. The go.mod tool entry could just be being used for versioning.</div><br/><div id="42847839" class="c"><input type="checkbox" id="c-42847839" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#42845870">root</a><span>|</span><a href="#42847777">parent</a><span>|</span><a href="#42848235">next</a><span>|</span><label class="collapse" for="c-42847839">[-]</label><label class="expand" for="c-42847839">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m speaking of tools and processes independent of this &quot;go tool&quot; stuff that we already use in our CI pipelines<p>Big fan of Dagger over this go tool thing<p>I generally loath the use of comments for things other than comments</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42848235" class="c"><input type="checkbox" id="c-42848235" checked=""/><div class="controls bullet"><span class="by">caust1c</span><span>|</span><a href="#42845870">root</a><span>|</span><a href="#42846778">parent</a><span>|</span><a href="#42847426">prev</a><span>|</span><a href="#42846750">next</a><span>|</span><label class="collapse" for="c-42848235">[-]</label><label class="expand" for="c-42848235">[2 more]</label></div><br/><div class="children"><div class="content">Having not looked at it deeply yet, why require building every time it&#x27;s invoked?  Is the idea to get it working then add build caching later?  Seems like a pretty big drawback (bigger than the go.mod pollution, for me).  Github runners are sllooooow so build times matter to me.</div><br/><div id="42848561" class="c"><input type="checkbox" id="c-42848561" checked=""/><div class="controls bullet"><span class="by">cirwin</span><span>|</span><a href="#42845870">root</a><span>|</span><a href="#42848235">parent</a><span>|</span><a href="#42846750">next</a><span>|</span><label class="collapse" for="c-42848561">[-]</label><label class="expand" for="c-42848561">[1 more]</label></div><br/><div class="children"><div class="content">`go tool` doesn&#x27;t require a rebuild, but it does checking that the tool is up-to-date (which requires doing at least a bit of work).<p>This is one of the main advantages of using `go tool` over the &quot;hope that contributors to have the right version installed&quot; approach. As the version of the tool required by the project evolves, it continues to work.<p>Interestingly, when I was first working on the proposal, `go run` deliberately did not cache the built binary. That meant that `go tool` was much faster because it only had to do the check instead of re-running the `link` step. In Go 1.24 that was changed (both to support `go tool`, but also for some other work they are planning) so this advantage of `go tool` is not needed anymore.</div><br/></div></div></div></div></div></div><div id="42846750" class="c"><input type="checkbox" id="c-42846750" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#42845870">parent</a><span>|</span><a href="#42846778">prev</a><span>|</span><a href="#42846675">next</a><span>|</span><label class="collapse" for="c-42846750">[-]</label><label class="expand" for="c-42846750">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s module graph pruning <a href="https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;mod#graph-pruning" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;mod#graph-pruning</a></div><br/></div></div><div id="42846675" class="c"><input type="checkbox" id="c-42846675" checked=""/><div class="controls bullet"><span class="by">movedx</span><span>|</span><a href="#42845870">parent</a><span>|</span><a href="#42846750">prev</a><span>|</span><a href="#42845914">next</a><span>|</span><label class="collapse" for="c-42846675">[-]</label><label class="expand" for="c-42846675">[2 more]</label></div><br/><div class="children"><div class="content">What solution would you propose?</div><br/><div id="42846713" class="c"><input type="checkbox" id="c-42846713" checked=""/><div class="controls bullet"><span class="by">rplnt</span><span>|</span><a href="#42845870">root</a><span>|</span><a href="#42846675">parent</a><span>|</span><a href="#42845914">next</a><span>|</span><label class="collapse" for="c-42846713">[-]</label><label class="expand" for="c-42846713">[1 more]</label></div><br/><div class="children"><div class="content">At least a comment if not its own section.</div><br/></div></div></div></div><div id="42845914" class="c"><input type="checkbox" id="c-42845914" checked=""/><div class="controls bullet"><span class="by">jamietanna</span><span>|</span><a href="#42845870">parent</a><span>|</span><a href="#42846675">prev</a><span>|</span><a href="#42846849">next</a><span>|</span><label class="collapse" for="c-42845914">[-]</label><label class="expand" for="c-42845914">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;m still rather excited about it, but less-so given it &#x2F;does&#x2F; impact the `go.mod` for consumers</div><br/></div></div></div></div><div id="42846640" class="c"><input type="checkbox" id="c-42846640" checked=""/><div class="controls bullet"><span class="by">wordofx</span><span>|</span><a href="#42845944">prev</a><span>|</span><a href="#42847028">next</a><span>|</span><label class="collapse" for="c-42846640">[-]</label><label class="expand" for="c-42846640">[2 more]</label></div><br/><div class="children"><div class="content">Are we just copying .NET now?</div><br/><div id="42846688" class="c"><input type="checkbox" id="c-42846688" checked=""/><div class="controls bullet"><span class="by">movedx</span><span>|</span><a href="#42846640">parent</a><span>|</span><a href="#42847028">next</a><span>|</span><label class="collapse" for="c-42846688">[-]</label><label class="expand" for="c-42846688">[1 more]</label></div><br/><div class="children"><div class="content">Whatâs wrong with copying from other projects if theyâre indeed offering good ideas worth copying? You say it as if the Golang community MUST only ever have unique ideas no one else has ever thought of â something thatâs increasingly rare and unlikely.</div><br/></div></div></div></div><div id="42847028" class="c"><input type="checkbox" id="c-42847028" checked=""/><div class="controls bullet"><span class="by">purpleidea</span><span>|</span><a href="#42846640">prev</a><span>|</span><a href="#42845787">next</a><span>|</span><label class="collapse" for="c-42847028">[-]</label><label class="expand" for="c-42847028">[4 more]</label></div><br/><div class="children"><div class="content">go.mod and the golang tooling is a horror show. I absolutely LOVE the language, but dealing with the tooling is horrendous. I should blog about the specifics, but if you want a short version:<p>* not using posix args<p>* obscure incantations to run tests<p>* go.mod tooling is completely non-deterministic and hard to use, they should have just left the old-style vendor&#x2F; alone (which worked perfectly) and wrapped a git-submodules front-end on top for everyone who was afraid of submodules. Instead they reinvented this arcane new ecosystem.<p>If you want to rewrite the golang tooling, I&#x27;ll consult on this for free.</div><br/><div id="42847722" class="c"><input type="checkbox" id="c-42847722" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#42847028">parent</a><span>|</span><a href="#42845787">next</a><span>|</span><label class="collapse" for="c-42847722">[-]</label><label class="expand" for="c-42847722">[3 more]</label></div><br/><div class="children"><div class="content">MVS, the algo for dep version selection, is deterministic, given the same inputs you will get the same outputs. Go has invested a lot of effort in creating reproducible builds through the entire toolchain<p><a href="https:&#x2F;&#x2F;research.swtch.com&#x2F;vgo-mvs" rel="nofollow">https:&#x2F;&#x2F;research.swtch.com&#x2F;vgo-mvs</a></div><br/><div id="42848566" class="c"><input type="checkbox" id="c-42848566" checked=""/><div class="controls bullet"><span class="by">purpleidea</span><span>|</span><a href="#42847028">root</a><span>|</span><a href="#42847722">parent</a><span>|</span><a href="#42845787">next</a><span>|</span><label class="collapse" for="c-42848566">[-]</label><label class="expand" for="c-42848566">[2 more]</label></div><br/><div class="children"><div class="content">The _tooling_ is not reproducible. Take a not small golang project with some number of dependencies and there should be a single list of the latest versions for the entire project. And exactly what golang commands do you run to generate that list? It&#x27;s totally broken. This is why so many tools cropped up like go-mod-upgrade and so on.<p>Everyone downvoting obviously doesn&#x27;t understand the problem.</div><br/><div id="42849700" class="c"><input type="checkbox" id="c-42849700" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#42847028">root</a><span>|</span><a href="#42848566">parent</a><span>|</span><a href="#42845787">next</a><span>|</span><label class="collapse" for="c-42849700">[-]</label><label class="expand" for="c-42849700">[1 more]</label></div><br/><div class="children"><div class="content">`go.mod` contains the dependency list and minimum version required<p>`go.sum` is a lock file for the exact versions to use (ensures reproducibility)<p>`go mod graph` will produce the dependency graph with resolved versions<p>`go list -deps .&#x2F;...` will give you all packages used by a module or directory, depending on the args you provide<p>`go get -u .&#x2F;...` will update all dependencies to their latest version<p>Here is a post about Go toolchain reproducibility and verification: <a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;rebuild" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;rebuild</a><p>You are being downvoted for being wrong and talking about downvoting, which is called out as something not to do in the posting &amp; commenting guidelines</div><br/></div></div></div></div></div></div></div></div><div id="42845787" class="c"><input type="checkbox" id="c-42845787" checked=""/><div class="controls bullet"><span class="by">guessmyname</span><span>|</span><a href="#42847028">prev</a><span>|</span><label class="collapse" for="c-42845787">[-]</label><label class="expand" for="c-42845787">[4 more]</label></div><br/><div class="children"><div class="content">As someone whoâs been using Go since 2013 at commpanies like Apple, Microsoft, and Uber, this all seems quite unnecessary.<p>That said, if it helps people do âtheir thingâ in what they believe is an easier (more straightforward) way, then I welcome the new changes.</div><br/><div id="42845909" class="c"><input type="checkbox" id="c-42845909" checked=""/><div class="controls bullet"><span class="by">teeray</span><span>|</span><a href="#42845787">parent</a><span>|</span><a href="#42846123">next</a><span>|</span><label class="collapse" for="c-42845909">[-]</label><label class="expand" for="c-42845909">[2 more]</label></div><br/><div class="children"><div class="content">Given Goâs approach to âmetaprogrammingâ has long relied on tools written in Go, this does seem like a feature gap that needed closing. Even the introduction of `go generate` long ago formalized this approach, but still left installing the tools as an exercise for the reader. You canât have consistent code gen if you donât have consistent tooling across a team&#x2F;CI.</div><br/><div id="42849624" class="c"><input type="checkbox" id="c-42849624" checked=""/><div class="controls bullet"><span class="by">9rx</span><span>|</span><a href="#42845787">root</a><span>|</span><a href="#42845909">parent</a><span>|</span><a href="#42846123">next</a><span>|</span><label class="collapse" for="c-42849624">[-]</label><label class="expand" for="c-42849624">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Even the introduction of `go generate` long ago formalized this approach</i><p>It did, but if you recall it came with a lot of <i>&quot;We have no idea why you need this&quot;</i> from Pike and friends. Which, of course, makes sense when you remember that they don&#x27;t use the go toolchain inside Google. They use Google&#x27;s toolchain, which already supports things like code generation and build dependency management in a far more elegant way. Had Go not transitioned to a community project, I expect we would have seen the same <i>&quot;We have no idea why you need this&quot;</i> from the Go project as that is another thing already handled by Google&#x27;s tooling.<p>The parent&#x27;s experience comes from similar sized companies as Google who have similar kinds of tooling as Google. His question comes not from a <i>&quot;why would you need this kind of feature?&quot;</i> in concept, but more of a <i>&quot;why would you not use the tooling you already have?&quot;</i> angle. And, to be fair, none of this is needed where you have better tooling, but the better tooling we know tends to require entire teams to maintain it, which is unrealistic for individuals to small organizations. So, this is a pretty good half-measure to allow the rest of us to play the same game in a smaller way.</div><br/></div></div></div></div><div id="42846123" class="c"><input type="checkbox" id="c-42846123" checked=""/><div class="controls bullet"><span class="by">GauntletWizard</span><span>|</span><a href="#42845787">parent</a><span>|</span><a href="#42845909">prev</a><span>|</span><label class="collapse" for="c-42846123">[-]</label><label class="expand" for="c-42846123">[1 more]</label></div><br/><div class="children"><div class="content">I am both strongly of the opinion that this was already done much better in Bazel, and that the go-native version seems clean, clear, and simple and should probably be adopted by pure go shops.<p>The digraph problem of build tooling is hardly new, though the ability to checksum all of your build tools and executables and mid-outputs to assure consistency is relatively new to feasibility. Bazel is a heavy instrument and making it work as well as it does was a hard problem even for Google. I don&#x27;t know anyone making the same investment, and doubt it makes the slightest hint of sense for anyone outside the fortune 500.</div><br/></div></div></div></div></div></div></div></div></div></body></html>