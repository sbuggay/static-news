<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1727600469032" as="style"/><link rel="stylesheet" href="styles.css?v=1727600469032"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blogs.gentoo.org/mgorny/2024/09/28/the-perils-of-transition-to-64-bit-time_t/">The perils of transition to 64-bit time_t</a>Â <span class="domain">(<a href="https://blogs.gentoo.org">blogs.gentoo.org</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>178 comments</span></div><br/><div><div id="41681949" class="c"><input type="checkbox" id="c-41681949" checked=""/><div class="controls bullet"><span class="by">codys</span><span>|</span><a href="#41683154">next</a><span>|</span><label class="collapse" for="c-41681949">[-]</label><label class="expand" for="c-41681949">[14 more]</label></div><br/><div class="children"><div class="content">There are a few options for Gentoo not discussed in the post, possibly because for Gentoo they would be a larger amount of work due to the design of their system:<p>1. Allow building against packages without installing them. The core issue here is that Gentoo package build and install happen as a single step: one can&#x27;t &quot;build a bunch of things that depend on one another&quot; and then &quot;atomically install all the build items into place&quot;. This means that Gentoo can easily be partially broken when one is doing updates when an ABI change occurs (modulo so versioning, see next option). This issue with 64-bit time_t is an example of an ABI change that folks are very aware of and is very widespread. It&#x27;s also an example of something that causes an ABI change that isn&#x27;t handled by the normal `.so` versioning scheme (see next option).<p>2. Extend the normal `.so` versioning to capture changes to the ABI of packages caused by packages they depend on. Normally, every `.so` (shared object&#x2F;library) embeds a version number within it, and is also installed with that version number in the file name (`libfoo.so.1.0.0`, for example, would be the real `.so` file, and would have a symlink from `libfoo.so` to tell the linker which `.so` to use). This shared object version is normally managed by the package itself internally (iow: every package decides on their ABI version number to enable them to track their own internal ABI breakages). This allows Gentoo to upgrade without breaking everything while an update is going on as long as every package manages their `.so` version perfectly correctly (not a given, but does help in many cases). There is a process in Gentoo to remove old `.so.x.y.z` files that are no longer used after an install completes. What we&#x27;d need to do to support 64-bit time_t is add another component to this version that can be controlled by the inherited ABI of dependencies of each `.so`. This is very similar in result to the &quot;use a different libdir&quot; option from the post, but while it has the potential to set things up to enable the same kinds of ABI changes to be made in the future, it&#x27;s likely that fixing this would be more invasive than using a different libdir.</div><br/><div id="41682338" class="c"><input type="checkbox" id="c-41682338" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41681949">parent</a><span>|</span><a href="#41682366">next</a><span>|</span><label class="collapse" for="c-41682338">[-]</label><label class="expand" for="c-41682338">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Allow building against packages without installing them.<p>A partial staged update system would work the best.  I should be able to schedule the build of several new packages,  have them built into a sandbox,  and have new compilations use the sandbox first and then fallback to the system through a union,  and then once everything is build finally package up all the pieces and then move them out of the sandbox and into the system at large.<p>You could make all gentoo updates transactional that way which would be a huge boon in many other ways.</div><br/></div></div><div id="41682366" class="c"><input type="checkbox" id="c-41682366" checked=""/><div class="controls bullet"><span class="by">aaronmdjones</span><span>|</span><a href="#41681949">parent</a><span>|</span><a href="#41682338">prev</a><span>|</span><a href="#41683154">next</a><span>|</span><label class="collapse" for="c-41682366">[-]</label><label class="expand" for="c-41682366">[12 more]</label></div><br/><div class="children"><div class="content">Gentoo already allows option 1 by specifying a directory to ultimately install the finished image to (normally it is set to &#x2F;) [1]. One can do a complete rebuild of everything in @system and @world, install it to the specified subdirectory, and then sync it all over in one shot. Preferably you would do this from a live session, although in theory you could also bind-mount &#x2F; onto a subdirectory of the place you reinstalled everything to, chroot into it, and then sync it (what is now &#x2F;) into the bind-mounted real upper &#x2F;.<p>[1] <a href="https:&#x2F;&#x2F;devmanual.gentoo.org&#x2F;ebuild-writing&#x2F;variables&#x2F;#root" rel="nofollow">https:&#x2F;&#x2F;devmanual.gentoo.org&#x2F;ebuild-writing&#x2F;variables&#x2F;#root</a></div><br/><div id="41682706" class="c"><input type="checkbox" id="c-41682706" checked=""/><div class="controls bullet"><span class="by">codys</span><span>|</span><a href="#41681949">root</a><span>|</span><a href="#41682366">parent</a><span>|</span><a href="#41683434">next</a><span>|</span><label class="collapse" for="c-41682706">[-]</label><label class="expand" for="c-41682706">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s true that Gentoo has some pieces of what they need to build an implementation of option 1 (build packages that depend on other packages before completeing an install), but it&#x27;s currently the case that that is not what happens when one runs `emerge` (the gentoo packaging build&#x2F;installing tool), as you&#x27;ve noted one would need to write scripts that wrap emerge (or do the same work manually) to attempt to accomplish this today.<p>I suspect that using bind mounts and overlays (to allow the &quot;building packages&quot; chroot a view of the &quot;installed&quot; root) could be used to accomplish this, or alternately some filesystem snapshotting features if we&#x27;re thinking about this from the &quot;external to emerge&quot; angle. (It&#x27;s my understanding that for Gentoo to do this ABI change, though, they need some solution integrated into emerge).<p>To some extent, this kind of potential model also reminds me of systems that integrate their package updating with filesystem snapshotting to allow rollbacks and actually-atomic upgrades of many files. I think one or more of the solaris distributions did this?</div><br/><div id="41683726" class="c"><input type="checkbox" id="c-41683726" checked=""/><div class="controls bullet"><span class="by">aaronmdjones</span><span>|</span><a href="#41681949">root</a><span>|</span><a href="#41682706">parent</a><span>|</span><a href="#41683434">next</a><span>|</span><label class="collapse" for="c-41683726">[-]</label><label class="expand" for="c-41683726">[4 more]</label></div><br/><div class="children"><div class="content">&gt; but it&#x27;s currently the case that that is not what happens when one runs `emerge` (the gentoo packaging build&#x2F;installing tool)<p>This would be a simple matter of changing &#x2F;etc&#x2F;portage&#x2F;make.profile to point to a profile that uses the new ABI and setting (and exporting) the ROOT variable in the shell you type &quot;emerge&quot; into (or add this ROOT=&#x2F;whatever&#x2F; line to &#x2F;etc&#x2F;portage&#x2F;make.conf), is what I was getting at. There&#x27;s no need to write any wrappers.</div><br/><div id="41683823" class="c"><input type="checkbox" id="c-41683823" checked=""/><div class="controls bullet"><span class="by">codys</span><span>|</span><a href="#41681949">root</a><span>|</span><a href="#41683726">parent</a><span>|</span><a href="#41683434">next</a><span>|</span><label class="collapse" for="c-41683823">[-]</label><label class="expand" for="c-41683823">[3 more]</label></div><br/><div class="children"><div class="content">Simply changing `ROOT` doesn&#x27;t magically enable us to have `emerge` update our normal `ROOT=&#x2F;`. There&#x27;s extra steps here (the syncing, the bind mounting, etc) for the `emerge` with a custom `ROOT` to do an update to `&#x2F;` itself.<p>And that&#x27;s if we have a `ROOT` that allows us to source dependencies (libraries to link against, includes, etc). Currently it&#x27;s unclear to me how exactly `ROOT` works, probably meaning there needs to be a bit more documentation there and potentially indicating that it might not be used much right now.</div><br/><div id="41684079" class="c"><input type="checkbox" id="c-41684079" checked=""/><div class="controls bullet"><span class="by">aaronmdjones</span><span>|</span><a href="#41681949">root</a><span>|</span><a href="#41683823">parent</a><span>|</span><a href="#41683434">next</a><span>|</span><label class="collapse" for="c-41684079">[-]</label><label class="expand" for="c-41684079">[2 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s extra steps here (the syncing, the bind mounting, etc) for the `emerge` with a custom `ROOT` to do an update to `&#x2F;` itself.<p>Those extra steps are handled by telling people what to do, in news items. This happened for example in the 17.1 -&gt; 23.0 profile migration [1]; emerge wasn&#x27;t updated to help people do this in any way whatsoever, users are expected to do everything themselves. This is the Gentoo way.<p>&gt; And that&#x27;s if we had a `ROOT` that allowed us to source dependencies (libraries to link against, includes, etc).<p>You don&#x27;t need to source anything in ROOT because everything you&#x27;re <i>rebuilding</i> is <i>already</i> in &#x2F;.<p>If you intended to build a program that depended upon a library you did not already have (in &#x2F;), you&#x27;re right, this wouldn&#x27;t work. That isn&#x27;t the case here. The dynamic linker (ld-linux.so or whatever you fancy, the ELF interpreter, the thing that runs before main(), the thing that will look at the list of dependent libraries, try to load them, and balk at any mismatches) isn&#x27;t executed until the program is, and setting ROOT merely tells portage where to put them; it doesn&#x27;t execute them. This I alluded to in the other comment thread about building a userland that your CPU can&#x27;t even execute.<p>[1] <a href="https:&#x2F;&#x2F;www.gentoo.org&#x2F;support&#x2F;news-items&#x2F;2024-03-22-new-23-profiles.html" rel="nofollow">https:&#x2F;&#x2F;www.gentoo.org&#x2F;support&#x2F;news-items&#x2F;2024-03-22-new-23-...</a></div><br/><div id="41684133" class="c"><input type="checkbox" id="c-41684133" checked=""/><div class="controls bullet"><span class="by">codys</span><span>|</span><a href="#41681949">root</a><span>|</span><a href="#41684079">parent</a><span>|</span><a href="#41683434">next</a><span>|</span><label class="collapse" for="c-41684133">[-]</label><label class="expand" for="c-41684133">[1 more]</label></div><br/><div class="children"><div class="content">Huh. If it&#x27;s OK to have instructions like those for users to run through, then I guess I don&#x27;t understand what&#x27;s holding up switching to 64-bit time_t for gentoo. Seems like they could make a new profile and tell folks to deal with it. Perhaps I don&#x27;t understand what the requirements are here, which might indicate that the requirements aren&#x27;t clear for others too.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41683434" class="c"><input type="checkbox" id="c-41683434" checked=""/><div class="controls bullet"><span class="by">rini17</span><span>|</span><a href="#41681949">root</a><span>|</span><a href="#41682366">parent</a><span>|</span><a href="#41682706">prev</a><span>|</span><a href="#41683154">next</a><span>|</span><label class="collapse" for="c-41683434">[-]</label><label class="expand" for="c-41683434">[6 more]</label></div><br/><div class="children"><div class="content">The third paragraph says following, which means it&#x27;s not suitable solution to build whole system:<p>When building a package, ROOT should not be used to satisfy the required dependencies on libraries, headers files etc. Instead, the files on the build system should be specified using &#x2F;.</div><br/><div id="41683716" class="c"><input type="checkbox" id="c-41683716" checked=""/><div class="controls bullet"><span class="by">aaronmdjones</span><span>|</span><a href="#41681949">root</a><span>|</span><a href="#41683434">parent</a><span>|</span><a href="#41683154">next</a><span>|</span><label class="collapse" for="c-41683716">[-]</label><label class="expand" for="c-41683716">[5 more]</label></div><br/><div class="children"><div class="content">Yes, that means it will look in the host system (&#x2F;) for those dependencies. But when you&#x27;re also recompiling and installing those dependencies to &#x2F;whatever&#x2F; as well anyway, and &#x2F;whatever&#x2F; is eventually going to end up being &#x2F;, this is fine. The original &#x2F; doesn&#x27;t get touched until everything is done, and &#x2F;whatever&#x2F; is all built to the new ABI, which it can be precisely because nothing in &#x2F;whatever&#x2F; is getting consulted or used during the rebuild process.</div><br/><div id="41683854" class="c"><input type="checkbox" id="c-41683854" checked=""/><div class="controls bullet"><span class="by">codys</span><span>|</span><a href="#41681949">root</a><span>|</span><a href="#41683716">parent</a><span>|</span><a href="#41683154">next</a><span>|</span><label class="collapse" for="c-41683854">[-]</label><label class="expand" for="c-41683854">[4 more]</label></div><br/><div class="children"><div class="content">No, what rini17 pointed out is a problem here, and I think my previous comments that setting ROOT might be &quot;part of a solution&quot; are less accurate (as it seems `ROOT` is even less of a complete solution here).<p>Lets consider this hypothetical representation of the 64-bit time issue:<p>In `ROOT=&#x2F;`, we have a `libA.so` with 32-bit time_t, and a `libB.so` with 32-bit time_t that depends on `libA` (ie: `libB.so` -&gt; `libA.so`).<p>We rebuild package `A` with a special root (`ROOT=&#x2F;tmp&#x2F;new`) which has 64-bit time_t. We now have a `&#x2F;tmp&#x2F;new` with `libA.so` built for 64-bit time_t. We now want to build `B` for `ROOT=&#x2F;tmp&#x2F;new` with 64-bit time_t and have it link against the new `&#x2F;tmp&#x2F;new&#x2F;lib&#x2F;libA.so`.<p>But setting `ROOT=&#x2F;tmp&#x2F;new` doesn&#x27;t cause us to use the `&#x2F;tmp&#x2F;new` to as our source to link against things. So (as it currently stands) we&#x27;ll end up trying to link `libB.so` (64-bit time_t) against `&#x2F;lib&#x2F;libA.so` (32-bit time_t), and things just won&#x27;t work.<p>If gentoo changes&#x2F;extends ROOT (or adds something else like ROOT but used to locate dependencies for linking), then it could be a piece of a solution. But it sounds like it&#x27;s pretty far from that in intention&#x2F;practice right now.</div><br/><div id="41683891" class="c"><input type="checkbox" id="c-41683891" checked=""/><div class="controls bullet"><span class="by">aaronmdjones</span><span>|</span><a href="#41681949">root</a><span>|</span><a href="#41683854">parent</a><span>|</span><a href="#41683154">next</a><span>|</span><label class="collapse" for="c-41683891">[-]</label><label class="expand" for="c-41683891">[3 more]</label></div><br/><div class="children"><div class="content">&gt; But setting `ROOT=&#x2F;tmp&#x2F;new` doesn&#x27;t cause us to use the `&#x2F;tmp&#x2F;new` to as our source to link against things<p>That&#x27;s a good thing, because it won&#x27;t be &#x2F;tmp&#x2F;new&#x2F; when we&#x27;re finished.<p>&gt; So (as it currently stands) we&#x27;ll end up trying to link `libB.so` (64-bit time_t) against `&#x2F;lib&#x2F;libA.so` (32-bit time_t), and things just won&#x27;t work.<p>It won&#x27;t work until &#x2F;tmp&#x2F;new&#x2F; becomes &#x2F;, which it doesn&#x27;t have to until you&#x27;re done.<p>Remember that this is just for building and installing the software. It doesn&#x27;t get executed which is precisely what you want <i>because</i> it wouldn&#x27;t work properly otherwise, as you point out.<p>You can even use this method to build a complete userland for an instruction set architecture that your CPU doesn&#x27;t even support. All you need do is also set CHOST to the tuple identifying the target architecture in addition to setting ROOT for where it should be installed [1]. You just wouldn&#x27;t be able to chroot into it obviously.<p>[1] <a href="https:&#x2F;&#x2F;wiki.gentoo.org&#x2F;wiki&#x2F;Embedded_Handbook&#x2F;General&#x2F;Introduction#Environment_variables" rel="nofollow">https:&#x2F;&#x2F;wiki.gentoo.org&#x2F;wiki&#x2F;Embedded_Handbook&#x2F;General&#x2F;Intro...</a></div><br/><div id="41684104" class="c"><input type="checkbox" id="c-41684104" checked=""/><div class="controls bullet"><span class="by">codys</span><span>|</span><a href="#41681949">root</a><span>|</span><a href="#41683891">parent</a><span>|</span><a href="#41683154">next</a><span>|</span><label class="collapse" for="c-41684104">[-]</label><label class="expand" for="c-41684104">[2 more]</label></div><br/><div class="children"><div class="content">Before getting into the details here about why we need to read `libA.so` at build time: Perhaps the documentation gentoo provides about `ROOT` that was noted by rini17 is incorrect&#x2F;misleading and `ROOT` is used as the source of build time dependencies automatically and the documentation was intended for ebuild writers and not emerge users? (in which case, Gentoo should fix&#x2F;clarify it).<p>&quot;link&quot; has 2 meanings:<p>1. As you&#x27;ve pointed at, at runtime we have linking occur that reads files.<p>2. Additionally, building software with `gcc`&#x2F;etc, we tell it what libraries it needs to link against (`-lA`). When we do that, `gcc` as part of the build process searches for `libA.so` (in various locations dependent on its configuration and arguments), reads the `libA.so` file, and uses that info to determine what to emit in the object file that `gcc` is building. So we need to read a shared library. The same is true for headers used at build time. How much this actually ends up mattering varies depending on architectural details, and whether libraries have different symbols exposed (or generate different header files) depending on what the bit-width of time_t is. It may well be that for most packages we could have the build-time linking occur against a 32-bit time_t object as long as runtime linking is done to the 64-bit time_t object (assuming one is using identical package versions or at least versions with a compatible ABI).</div><br/><div id="41684168" class="c"><input type="checkbox" id="c-41684168" checked=""/><div class="controls bullet"><span class="by">aaronmdjones</span><span>|</span><a href="#41681949">root</a><span>|</span><a href="#41684104">parent</a><span>|</span><a href="#41683154">next</a><span>|</span><label class="collapse" for="c-41684168">[-]</label><label class="expand" for="c-41684168">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and whether libraries have different symbols exposed (or generate different header files) depending on what the bit-width of time_t is<p>Hmm. You have a good point there; I hadn&#x27;t thought about that...<p>Perhaps they can take an existing stage3 with 32-bit time_t, build a new stage1 through 3 with a 64-bit time_t, and compare the symbols and header files between them to identify any potential trouble spots. This would help them regardless of what migration course of action they decide upon.<p>Any software people have installed that isn&#x27;t included in the stage3 (e.g. desktop window managers and everything else on top) wouldn&#x27;t be included here and so is a potential pain point, but everything in @system would be, so at that point you can just rebuild @world again to fix everything.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41683154" class="c"><input type="checkbox" id="c-41683154" checked=""/><div class="controls bullet"><span class="by">eschaton</span><span>|</span><a href="#41681949">prev</a><span>|</span><a href="#41682277">next</a><span>|</span><label class="collapse" for="c-41683154">[-]</label><label class="expand" for="c-41683154">[26 more]</label></div><br/><div class="children"><div class="content">The way this was handled on Mac OS X for `off_t` and `ino_t` might provide some insight: The existing calls and structures using the types retained their behavior, new calls and types with `64` suffixes were added, and you could use a preprocessor macro to choose which calls and structs were actually referencedâbut they were hardly ever used directly.<p>Instead, the OS and its SDK are versioned, and at build time you can <i>also</i> specify the <i>earliest</i> OS version your compiled binary needes to run on. So using this, the headers ensured the proper macros were selected automatically. (This is the same mechanism by which new&#x2F;deprecated-in-some-version annotations would get set to enable weak linking for a symbol or to generate warnings for it respectively.)<p>And it was all handled initially via the preprocessor, though now the compilers have a much more sophisticated understanding of what Apple refers to as âAPI availability.â So it should be feasible to use the same mechanisms on any other platform too.</div><br/><div id="41683540" class="c"><input type="checkbox" id="c-41683540" checked=""/><div class="controls bullet"><span class="by">AshamedCaptain</span><span>|</span><a href="#41683154">parent</a><span>|</span><a href="#41684191">next</a><span>|</span><label class="collapse" for="c-41683540">[-]</label><label class="expand" for="c-41683540">[1 more]</label></div><br/><div class="children"><div class="content">This does not solve the main issue as explained by TFA, which is that now applications that use a different &quot;compiled OS version&quot; cannot link with each other anymore. Your application X  which declares to run on OS v.B cannot link anymore with application Y which declared to run on OS v.A , even when both are running under OS v.B .<p>In fact, what you describe is basically what every platform is doing.... as doing anything else would immediately break compatibility with all current binaries.</div><br/></div></div><div id="41684191" class="c"><input type="checkbox" id="c-41684191" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41683154">parent</a><span>|</span><a href="#41683540">prev</a><span>|</span><a href="#41684105">next</a><span>|</span><label class="collapse" for="c-41684191">[-]</label><label class="expand" for="c-41684191">[3 more]</label></div><br/><div class="children"><div class="content">The problem is that secondary libraries, that are not glibc, will not have multiply defined functions for different size of off_t and will not have the switch in their header file to transparently select the correct set of functions based on what the client program wants.<p>Yet, somehow the article emphasizes that this is more of a problem for time_t than off_t.<p>This is believable and it&#x27;s brobably it&#x27;s because time_t is more pervasive. Whereas off_t is a POSIX thing involved in a relatively small number of interfaces, time_ t is ISO C and is all over the place.<p>On top of everything, lots of  C code assumes that time_t is an integer type, equal in width to int. A similar assumption for off_t is less common.</div><br/><div id="41685411" class="c"><input type="checkbox" id="c-41685411" checked=""/><div class="controls bullet"><span class="by">_kst_</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41684191">parent</a><span>|</span><a href="#41684649">next</a><span>|</span><label class="collapse" for="c-41685411">[-]</label><label class="expand" for="c-41685411">[1 more]</label></div><br/><div class="children"><div class="content">Code that assumes time_t is the same width as int is already broken, and won&#x27;t work on typical 64-bit systems were int is 32 bits and time_t is 64 bits.<p>In any case, I&#x27;m not sure I&#x27;ve ever seen any such code.</div><br/></div></div><div id="41684649" class="c"><input type="checkbox" id="c-41684649" checked=""/><div class="controls bullet"><span class="by">eschaton</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41684191">parent</a><span>|</span><a href="#41685411">prev</a><span>|</span><a href="#41684105">next</a><span>|</span><label class="collapse" for="c-41684649">[-]</label><label class="expand" for="c-41684649">[1 more]</label></div><br/><div class="children"><div class="content">Since the different sizes are ultimately a platform thing, they need to support multiple variants on those platforms, or limit their support to a new enough base set of APIs that they can rely on 64-bit types being there.</div><br/></div></div></div></div><div id="41684105" class="c"><input type="checkbox" id="c-41684105" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#41683154">parent</a><span>|</span><a href="#41684191">prev</a><span>|</span><a href="#41683289">next</a><span>|</span><label class="collapse" for="c-41684105">[-]</label><label class="expand" for="c-41684105">[4 more]</label></div><br/><div class="children"><div class="content">your comment has the tone of this being an elegant solution, but it reads to me like an awful hack. typeless macros are a nightmare I never want to deal with again.</div><br/><div id="41684319" class="c"><input type="checkbox" id="c-41684319" checked=""/><div class="controls bullet"><span class="by">eschaton</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41684105">parent</a><span>|</span><a href="#41683289">next</a><span>|</span><label class="collapse" for="c-41684319">[-]</label><label class="expand" for="c-41684319">[3 more]</label></div><br/><div class="children"><div class="content">These are very straightforward and do in fact serve as an elegant solution.</div><br/><div id="41684461" class="c"><input type="checkbox" id="c-41684461" checked=""/><div class="controls bullet"><span class="by">smackeyacky</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41684319">parent</a><span>|</span><a href="#41683289">next</a><span>|</span><label class="collapse" for="c-41684461">[-]</label><label class="expand" for="c-41684461">[2 more]</label></div><br/><div class="children"><div class="content">Elegant maybe in the 1980s before compilers got properly complicated.  Now theyâre a weird anachronism.<p>Iâm old enough to have worked on c++ when it was a precompiler called cfront and  let me tell you trying to work out whether your macro was doing something weird or the cfront processor did something weird was very frustrating.  I swore off macros after that.</div><br/><div id="41684613" class="c"><input type="checkbox" id="c-41684613" checked=""/><div class="controls bullet"><span class="by">eschaton</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41684461">parent</a><span>|</span><a href="#41683289">next</a><span>|</span><label class="collapse" for="c-41684613">[-]</label><label class="expand" for="c-41684613">[1 more]</label></div><br/><div class="children"><div class="content">This is a case where youâre seeing the word âmacroâ and reacting to that when itâs really not warranted. Itâs not using macros for complicated code generation, just selecting from a couple alternatives based on one or two possible compiler arguments.<p>Iâm also old enough to remember CFront and this isnât that.</div><br/></div></div></div></div></div></div></div></div><div id="41683289" class="c"><input type="checkbox" id="c-41683289" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#41683154">parent</a><span>|</span><a href="#41684105">prev</a><span>|</span><a href="#41682277">next</a><span>|</span><label class="collapse" for="c-41683289">[-]</label><label class="expand" for="c-41683289">[17 more]</label></div><br/><div class="children"><div class="content">Lol, that only works if you can force everyone on the platform to go along with it. It is a nice solution, but it requires you to control the c library. Gentoo doesnât control what libc does; thatâs either GNU libc or MUSL or some other thing that the user wants to use.</div><br/><div id="41683349" class="c"><input type="checkbox" id="c-41683349" checked=""/><div class="controls bullet"><span class="by">eschaton</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41683289">parent</a><span>|</span><a href="#41683319">next</a><span>|</span><label class="collapse" for="c-41683349">[-]</label><label class="expand" for="c-41683349">[1 more]</label></div><br/><div class="children"><div class="content">Itâs entirely opt-in, Apple doesnât force it. If you just do `cc mything.c -o mything` you get a binary whose minimum required OS is the version of the SDK you built it against, just as with any other UNIX-like OS. Itâs just giving the developer the option to build something they know will run on an earlier version too.<p>And since it was all initially done with the preprocessor rather than adding knowledge to the compilers, thereâs no reason individual libraries canât handle API versioning in exactly this way, including things like differing `ino_t` and `off_t` sizes.</div><br/></div></div><div id="41683319" class="c"><input type="checkbox" id="c-41683319" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41683289">parent</a><span>|</span><a href="#41683349">prev</a><span>|</span><a href="#41682277">next</a><span>|</span><label class="collapse" for="c-41683319">[-]</label><label class="expand" for="c-41683319">[15 more]</label></div><br/><div class="children"><div class="content">&gt; requires you to control the c library<p>Which is why basically every other same operating system does that. BSDs, macOS, WinNT. Having the stable boundary be the kernel system call interface is fucking insane. And somehow the Linux userspace people keep failing to learn this lesson, no matter how many times they get clobbered in the face by the consequences of not learning it.</div><br/><div id="41683509" class="c"><input type="checkbox" id="c-41683509" checked=""/><div class="controls bullet"><span class="by">clhodapp</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41683319">parent</a><span>|</span><a href="#41683553">next</a><span>|</span><label class="collapse" for="c-41683509">[-]</label><label class="expand" for="c-41683509">[3 more]</label></div><br/><div class="children"><div class="content">Making the stable boundary be C <i>headers</i> is insane!<p>It means that there&#x27;s not actually any sort of ABI, only a C source API.</div><br/><div id="41684214" class="c"><input type="checkbox" id="c-41684214" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41683509">parent</a><span>|</span><a href="#41684111">next</a><span>|</span><label class="collapse" for="c-41684214">[-]</label><label class="expand" for="c-41684214">[1 more]</label></div><br/><div class="children"><div class="content">Headers can do the magic to select the right ABI more or less transparently, based on preprocessor symbols which indicate the selection: is a certain type 32 or 64.<p>This is similar to what Microsoft did in Win32 with the <i>W</i> and <i>A</i> functions (wide char and ascii&#x2F;ansi). You just call <i>MessageBox</i> and the header file will map that to <i>MessageBoxA</i> or <i>MessageBoxW</i> based on whether you are a <i>UNICODE</i> build.<p>The character element type in the strings accepted by <i>MessageBox</i> is <i>TCHAR</i>. That can either be <i>CHAR</i> or <i>WCHAR</i>.<p>Once the code is compiled, it depends on the appropriate ABI: MessageBoxA or MessageBoxW; MessageBox doesn&#x27;t exist; it is a source-level fiction, so to speak.</div><br/></div></div><div id="41684111" class="c"><input type="checkbox" id="c-41684111" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41683509">parent</a><span>|</span><a href="#41684214">prev</a><span>|</span><a href="#41683553">next</a><span>|</span><label class="collapse" for="c-41684111">[-]</label><label class="expand" for="c-41684111">[1 more]</label></div><br/><div class="children"><div class="content">cibuildwheel builds <i>manylinux</i> packages for glibc&gt;= and musl because of this ABI.<p>manylinux: 
<a href="https:&#x2F;&#x2F;github.com&#x2F;pypa&#x2F;manylinux">https:&#x2F;&#x2F;github.com&#x2F;pypa&#x2F;manylinux</a> :<p>&gt; <i>Python wheels that work on any linux (almost)</i><p>Static Go binaries that make direct syscalls and do not depend upon libc or musl run within very minimal containers.<p>Fuschia&#x27;s syscall docs are nice too; Linux plus additional syscalls.</div><br/></div></div></div></div><div id="41683553" class="c"><input type="checkbox" id="c-41683553" checked=""/><div class="controls bullet"><span class="by">AshamedCaptain</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41683319">parent</a><span>|</span><a href="#41683509">prev</a><span>|</span><a href="#41683623">next</a><span>|</span><label class="collapse" for="c-41683553">[-]</label><label class="expand" for="c-41683553">[3 more]</label></div><br/><div class="children"><div class="content">&gt;  no matter how many times they get clobbered in the face by the consequences of not learning it.<p>While I do think that the boundary should be set at the libc level just out of design cleanliness, I fail to see what the &quot;consequence&quot; of not doing so is.  You&#x27;re just changing the instruction binaries use for syscalls from a relative jump to a trap (or whatever), but you still have all the problems with data type sizes, function &quot;versions&quot; and the like which are what this discussion is about.</div><br/><div id="41683632" class="c"><input type="checkbox" id="c-41683632" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41683553">parent</a><span>|</span><a href="#41683623">next</a><span>|</span><label class="collapse" for="c-41683632">[-]</label><label class="expand" for="c-41683632">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  I fail to see what the &quot;consequence&quot; of not doing so is.<p>TFA ?</div><br/><div id="41683786" class="c"><input type="checkbox" id="c-41683786" checked=""/><div class="controls bullet"><span class="by">AshamedCaptain</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41683632">parent</a><span>|</span><a href="#41683623">next</a><span>|</span><label class="collapse" for="c-41683786">[-]</label><label class="expand" for="c-41683786">[1 more]</label></div><br/><div class="children"><div class="content">No. How would it benefit TFA _at all_?<p>For all practical purposes Linux currently has _two_ stable boundaries, libc (glibc) and kernel. If you move it so that the stable boundary is only the kernel, you still have this problem. If you move it so that the stable boundary is only libc, you still have this problem.<p>In fact, TFA&#x27;s problem comes from applications passing time_ts around, which is strictly a userspace problem, and the syscall interface is almost entirely ortogonal. Heck, the 32-bit glibc time_t functions probably use the 64-bit time_t syscalls these days...</div><br/></div></div></div></div></div></div><div id="41683623" class="c"><input type="checkbox" id="c-41683623" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41683319">parent</a><span>|</span><a href="#41683553">prev</a><span>|</span><a href="#41683421">next</a><span>|</span><label class="collapse" for="c-41683623">[-]</label><label class="expand" for="c-41683623">[3 more]</label></div><br/><div class="children"><div class="content">&gt; WinNT<p>This isn&#x27;t true. There is an msvcrt in the OS, but it&#x27;s mainly there for binaries that are part of Windows. The CRT is released as part of Visual Studio, out of band from the Windows release schedule.<p>Although CRT&#x27;s place is in the layering a little different, because of so many things talking directly to Windows APIs.</div><br/><div id="41683630" class="c"><input type="checkbox" id="c-41683630" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41683623">parent</a><span>|</span><a href="#41683421">next</a><span>|</span><label class="collapse" for="c-41683630">[-]</label><label class="expand" for="c-41683630">[2 more]</label></div><br/><div class="children"><div class="content">IIRC, the CRT in windows makes NO system calls. Those are all in ntdll.dll, and in ntdll.dll <i>ONLY</i></div><br/><div id="41683665" class="c"><input type="checkbox" id="c-41683665" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41683630">parent</a><span>|</span><a href="#41683421">next</a><span>|</span><label class="collapse" for="c-41683665">[-]</label><label class="expand" for="c-41683665">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s just a legacy of the strategy where NT native APIs were considered a private API, and you were meant to code against Win32 instead, to target both NT and 9x.<p>Syscalls are in ntdll, layered above that is kernel32 (today kernelbase), then most user mode code including CRT is above that. In 9x kernel32 were syscalls, in NT they were user mode shims above ntdll.<p>That&#x27;s <i>for most things</i>. Things like gdi have kernel entry points too afaik.<p>Anyway my point is that the C library is developed out of band from that.</div><br/></div></div></div></div></div></div><div id="41683421" class="c"><input type="checkbox" id="c-41683421" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41683319">parent</a><span>|</span><a href="#41683623">prev</a><span>|</span><a href="#41683640">next</a><span>|</span><label class="collapse" for="c-41683421">[-]</label><label class="expand" for="c-41683421">[3 more]</label></div><br/><div class="children"><div class="content">Itâs extra work, but I donât know that it is necessarily insane. If libc was under the complete control of the kernel developers, then that gives other languages fewer options. Go famously (or infamously) uses certain syscalls without going through libc, for example. Sometimes the choices made for the C library just arenât compatible with other languages. Frankly the C library, as it exists today, is insane. Maybe the solution is to split it in half: one for the syscalls and another for things like strings and environment variables and locales and all the other junk.</div><br/><div id="41683693" class="c"><input type="checkbox" id="c-41683693" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41683421">parent</a><span>|</span><a href="#41683640">next</a><span>|</span><label class="collapse" for="c-41683693">[-]</label><label class="expand" for="c-41683693">[2 more]</label></div><br/><div class="children"><div class="content">Splitting libc into one &quot;stable kernel API&quot; part and one &quot;library with things which are useful to C programmers&quot; part would honestly make a ton of sense. OSes which declare their syscall interface to be unstable would be more convincing if they actually provided a stable API that&#x27;s intended for other consumers than C.</div><br/><div id="41683820" class="c"><input type="checkbox" id="c-41683820" checked=""/><div class="controls bullet"><span class="by">AshamedCaptain</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41683693">parent</a><span>|</span><a href="#41683640">next</a><span>|</span><label class="collapse" for="c-41683820">[-]</label><label class="expand" for="c-41683820">[1 more]</label></div><br/><div class="children"><div class="content">Frankly I don&#x27;t see the point of complaining that libc is not useful for non-C consumers. Sure, there are some ancillary functions in libc you&#x27;ll likely never call. But what&#x27;s the issue with making syscalls through libc? Again, the only difference is what the very last call instruction is. If your runtime can marshal arguments for the kernel, then it surely can marshal arguments for libc. They are almost always practically the same ABI.<p>And you can avoid the need for VDSO-like hacks which is basically the kernel exposing a mini-libc to userspace.</div><br/></div></div></div></div></div></div><div id="41683358" class="c"><input type="checkbox" id="c-41683358" checked=""/><div class="controls bullet"><span class="by">eschaton</span><span>|</span><a href="#41683154">root</a><span>|</span><a href="#41683319">parent</a><span>|</span><a href="#41683640">prev</a><span>|</span><a href="#41682277">next</a><span>|</span><label class="collapse" for="c-41683358">[-]</label><label class="expand" for="c-41683358">[1 more]</label></div><br/><div class="children"><div class="content">And yet it would still work out for Linux if musl, glibc, et al just adopted `API_VERSION_MIN` and `API_VERSION_MAX` macros themselves, it doesnât actually have to be handled entirely at the `-isysroot` level.</div><br/></div></div></div></div></div></div></div></div><div id="41682277" class="c"><input type="checkbox" id="c-41682277" checked=""/><div class="controls bullet"><span class="by">grantla</span><span>|</span><a href="#41683154">prev</a><span>|</span><a href="#41685356">next</a><span>|</span><label class="collapse" for="c-41682277">[-]</label><label class="expand" for="c-41682277">[4 more]</label></div><br/><div class="children"><div class="content">&gt; A number of other distributions such as Debian have taken the leap and switched. Unfortunately, source-based distributions such as Gentoo donât have it that easy.<p>For Debian it was extremely painful. A few people probably burned out. Lots of people pointed to source-based distributions and said &quot;they will have it very easy&quot;.</div><br/><div id="41683147" class="c"><input type="checkbox" id="c-41683147" checked=""/><div class="controls bullet"><span class="by">Denvercoder9</span><span>|</span><a href="#41682277">parent</a><span>|</span><a href="#41683383">next</a><span>|</span><label class="collapse" for="c-41683147">[-]</label><label class="expand" for="c-41683147">[2 more]</label></div><br/><div class="children"><div class="content">&gt; For Debian it was extremely painful.<p>Do you have any references that elaborate on that? From an outsider perspective, the time64 transition in Debian seemed to have been relatively uncontroversial and smooth. Way better than e.g. the &#x2F;usr-merge.</div><br/><div id="41683491" class="c"><input type="checkbox" id="c-41683491" checked=""/><div class="controls bullet"><span class="by">jlarocco</span><span>|</span><a href="#41682277">root</a><span>|</span><a href="#41683147">parent</a><span>|</span><a href="#41683383">next</a><span>|</span><label class="collapse" for="c-41683491">[-]</label><label class="expand" for="c-41683491">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;812767&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;812767&#x2F;</a><p><a href="https:&#x2F;&#x2F;wiki.debian.org&#x2F;ReleaseGoals&#x2F;64bit-time" rel="nofollow">https:&#x2F;&#x2F;wiki.debian.org&#x2F;ReleaseGoals&#x2F;64bit-time</a><p>I&#x27;m continually impressed by Debian.  My Debian systems are pretty boring, so maybe it&#x27;s to be expected, but as an end-user neither the &#x2F;usr merge or time64 transition broke anything for me, and I&#x27;m using Testing.</div><br/></div></div></div></div><div id="41683383" class="c"><input type="checkbox" id="c-41683383" checked=""/><div class="controls bullet"><span class="by">ajsnigrutin</span><span>|</span><a href="#41682277">parent</a><span>|</span><a href="#41683147">prev</a><span>|</span><a href="#41685356">next</a><span>|</span><label class="collapse" for="c-41683383">[-]</label><label class="expand" for="c-41683383">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For Debian it was extremely painful. A few people probably burned out. Lots of people pointed to source-based distributions and said &quot;they will have it very easy&quot;.<p>&#x27;easy&#x27; in a way &quot;just tell the user to rebuild everything in one go&quot;? :)</div><br/></div></div></div></div><div id="41685356" class="c"><input type="checkbox" id="c-41685356" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#41682277">prev</a><span>|</span><a href="#41683505">next</a><span>|</span><label class="collapse" for="c-41685356">[-]</label><label class="expand" for="c-41685356">[1 more]</label></div><br/><div class="children"><div class="content">In the original BSD man pages, the &quot;Bugs&quot; section for &quot;tunefs&quot; had the famous joke &quot;You can tune a file system, but you can&#x27;t tune a fish.&quot; but according to &quot;Expert C Programming&quot;[1], 
the source code for this manpage had a comment next to the joke saying<p><pre><code>   &gt; Take this out and a UNIX Demon will dog your steps from now
   &gt; until the time_t&#x27;s wrap around. 
</code></pre>
Obviously back in the 70s when that was written 2038 seemed unimaginably far in the future.<p>[1] <a href="https:&#x2F;&#x2F;progforperf.github.io&#x2F;Expert_C_Programming.pdf" rel="nofollow">https:&#x2F;&#x2F;progforperf.github.io&#x2F;Expert_C_Programming.pdf</a></div><br/></div></div><div id="41683505" class="c"><input type="checkbox" id="c-41683505" checked=""/><div class="controls bullet"><span class="by">mhandley</span><span>|</span><a href="#41685356">prev</a><span>|</span><a href="#41681740">next</a><span>|</span><label class="collapse" for="c-41683505">[-]</label><label class="expand" for="c-41683505">[6 more]</label></div><br/><div class="children"><div class="content"><i>&quot;Letâs consider a trivial example:</i><p><pre><code>  struct {
      int a;
      time_t b;
      int c;
  };
</code></pre>
<i>With 32-bit time_t, the offset of c is 8. With the 64-bit type, itâs 12.&quot;</i><p>Surely it&#x27;s 16 not 12, as b needs to be 64-bit aligned, so padding is added between a and b?  Which also kind of makes the point the author is trying to make stronger.</div><br/><div id="41683984" class="c"><input type="checkbox" id="c-41683984" checked=""/><div class="controls bullet"><span class="by">AshamedCaptain</span><span>|</span><a href="#41683505">parent</a><span>|</span><a href="#41681740">next</a><span>|</span><label class="collapse" for="c-41683984">[-]</label><label class="expand" for="c-41683984">[5 more]</label></div><br/><div class="children"><div class="content">Most x86 ABIs do not mandate padding for 64-bit types, due to the lack of 64-bit loads (at the time).</div><br/><div id="41685653" class="c"><input type="checkbox" id="c-41685653" checked=""/><div class="controls bullet"><span class="by">256_</span><span>|</span><a href="#41683505">root</a><span>|</span><a href="#41683984">parent</a><span>|</span><a href="#41681740">next</a><span>|</span><label class="collapse" for="c-41685653">[-]</label><label class="expand" for="c-41685653">[4 more]</label></div><br/><div class="children"><div class="content">I thought you were right, but I tested it on x86_64 GNU&#x2F;Linux with this struct:<p><pre><code>    struct ts {
            int32_t dword1;
            int64_t qword1;
            int32_t dword2;
    };
</code></pre>
Writing -1 to all 3 members and printing out the individual bytes up to sizeof(struct ts), it produces this with -O0 and -O3:<p>FF FF FF FF 00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF 00 00 00 00<p>With -Os, I get some garbage data after the last member (always those 2 byte positions, with different values every time):<p>FF FF FF FF 00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF 45 76 00 00<p>I feel like I&#x27;m missing something obvious here. Or maybe my system&#x27;s ABI is a weird exception.</div><br/><div id="41685705" class="c"><input type="checkbox" id="c-41685705" checked=""/><div class="controls bullet"><span class="by">jabl</span><span>|</span><a href="#41683505">root</a><span>|</span><a href="#41685653">parent</a><span>|</span><a href="#41681740">next</a><span>|</span><label class="collapse" for="c-41685705">[-]</label><label class="expand" for="c-41685705">[3 more]</label></div><br/><div class="children"><div class="content">Was this with x86_64? The point of the parent was about x86_32, I believe.</div><br/><div id="41685747" class="c"><input type="checkbox" id="c-41685747" checked=""/><div class="controls bullet"><span class="by">256_</span><span>|</span><a href="#41683505">root</a><span>|</span><a href="#41685705">parent</a><span>|</span><a href="#41681740">next</a><span>|</span><label class="collapse" for="c-41685747">[-]</label><label class="expand" for="c-41685747">[2 more]</label></div><br/><div class="children"><div class="content">Oh yes, I really was missing something obvious. And you did, too, since I mentioned the architecture in the first line of my post.</div><br/><div id="41685777" class="c"><input type="checkbox" id="c-41685777" checked=""/><div class="controls bullet"><span class="by">jabl</span><span>|</span><a href="#41683505">root</a><span>|</span><a href="#41685747">parent</a><span>|</span><a href="#41681740">next</a><span>|</span><label class="collapse" for="c-41685777">[-]</label><label class="expand" for="c-41685777">[1 more]</label></div><br/><div class="children"><div class="content">I did see it, but was unsure if you meant you were compiling for a 32-bit target on a 64-bit host.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41681740" class="c"><input type="checkbox" id="c-41681740" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41683505">prev</a><span>|</span><a href="#41684857">next</a><span>|</span><label class="collapse" for="c-41681740">[-]</label><label class="expand" for="c-41681740">[9 more]</label></div><br/><div class="children"><div class="content">My biggest takeaway (and perhaps besides-the-point) is this:<p>&gt; Musl has already switched to that, glibc supports it as an option. A number of other distributions such as Debian have taken the leap and switched. Unfortunately, source-based distributions such as Gentoo donât have it that easy.<p>While I applaud their efforts I just think as a user I want to be over and done with this problem by switching to a non source-based distribution such as Debian.</div><br/><div id="41681934" class="c"><input type="checkbox" id="c-41681934" checked=""/><div class="controls bullet"><span class="by">ordu</span><span>|</span><a href="#41681740">parent</a><span>|</span><a href="#41681804">next</a><span>|</span><label class="collapse" for="c-41681934">[-]</label><label class="expand" for="c-41681934">[4 more]</label></div><br/><div class="children"><div class="content">There is an easy way to deal with this in Gentoo. Boot from usb or something, run mkfs.ext4 (or .whatever fs you use) on your &#x2F; and &#x2F;usr partitions, mount them, unpack stage3 on them, chroot into them and run `emerge $all-my-packages-that-where-installed-before-mkfs`.<p>You can install new copy of Gentoo instead of upgrading it incrementally.</div><br/><div id="41682012" class="c"><input type="checkbox" id="c-41682012" checked=""/><div class="controls bullet"><span class="by">robin_reala</span><span>|</span><a href="#41681740">root</a><span>|</span><a href="#41681934">parent</a><span>|</span><a href="#41681804">next</a><span>|</span><label class="collapse" for="c-41682012">[-]</label><label class="expand" for="c-41682012">[3 more]</label></div><br/><div class="children"><div class="content">âeasyâ</div><br/><div id="41682081" class="c"><input type="checkbox" id="c-41682081" checked=""/><div class="controls bullet"><span class="by">ordu</span><span>|</span><a href="#41681740">root</a><span>|</span><a href="#41682012">parent</a><span>|</span><a href="#41681804">next</a><span>|</span><label class="collapse" for="c-41682081">[-]</label><label class="expand" for="c-41682081">[2 more]</label></div><br/><div class="children"><div class="content">It is easy. It is just a tl;dr version of &quot;how to install gentoo&quot;. :)</div><br/><div id="41682103" class="c"><input type="checkbox" id="c-41682103" checked=""/><div class="controls bullet"><span class="by">lnxg33k1</span><span>|</span><a href="#41681740">root</a><span>|</span><a href="#41682081">parent</a><span>|</span><a href="#41681804">next</a><span>|</span><label class="collapse" for="c-41682103">[-]</label><label class="expand" for="c-41682103">[1 more]</label></div><br/><div class="children"><div class="content">I hope I will get a day where I have the will to recompile everything in the next 14 years, I think I had the same install for the past 10 or so on the gentoo desktop. The only think I reinstalled recently has been the laptop to switch from arch to sid</div><br/></div></div></div></div></div></div></div></div><div id="41681804" class="c"><input type="checkbox" id="c-41681804" checked=""/><div class="controls bullet"><span class="by">wtallis</span><span>|</span><a href="#41681740">parent</a><span>|</span><a href="#41681934">prev</a><span>|</span><a href="#41683031">next</a><span>|</span><label class="collapse" for="c-41681804">[-]</label><label class="expand" for="c-41681804">[3 more]</label></div><br/><div class="children"><div class="content">It sounds like the difficulty for source-based distributions comes from trying to do an in-place upgrade that makes incompatible changes to the ABI. So changing to an entirely different distribution would be at least as disruptive (though possibly less time consuming) as doing a clean install of Gentoo using a new ABI.</div><br/><div id="41682354" class="c"><input type="checkbox" id="c-41682354" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41681740">root</a><span>|</span><a href="#41681804">parent</a><span>|</span><a href="#41683031">next</a><span>|</span><label class="collapse" for="c-41682354">[-]</label><label class="expand" for="c-41682354">[2 more]</label></div><br/><div class="children"><div class="content">Starting a few years ago I partition all my drives with two root partitions.  Once is used and the other is blank.  For precisely this reason.  Sometimes it&#x27;s easier to just roll out a brand new stage3 onto the unused partition,  build an entirely new root,  and then just move over to that once it&#x27;s finished.<p>The bonus is you can build your new system from your old system using just chroot.  Very convenient.</div><br/><div id="41682452" class="c"><input type="checkbox" id="c-41682452" checked=""/><div class="controls bullet"><span class="by">jasomill</span><span>|</span><a href="#41681740">root</a><span>|</span><a href="#41682354">parent</a><span>|</span><a href="#41683031">next</a><span>|</span><label class="collapse" for="c-41682452">[-]</label><label class="expand" for="c-41682452">[1 more]</label></div><br/><div class="children"><div class="content">Several OSes I use on a daily basis (FreeBSD, Fedora CoreOS, and Fedora Kinoite) adopt related strategies as part of their regular (binary) update processes:<p><a href="https:&#x2F;&#x2F;wiki.freebsd.org&#x2F;BootEnvironments" rel="nofollow">https:&#x2F;&#x2F;wiki.freebsd.org&#x2F;BootEnvironments</a><p><a href="https:&#x2F;&#x2F;coreos.github.io&#x2F;rpm-ostree&#x2F;" rel="nofollow">https:&#x2F;&#x2F;coreos.github.io&#x2F;rpm-ostree&#x2F;</a></div><br/></div></div></div></div></div></div><div id="41683031" class="c"><input type="checkbox" id="c-41683031" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#41681740">parent</a><span>|</span><a href="#41681804">prev</a><span>|</span><a href="#41684857">next</a><span>|</span><label class="collapse" for="c-41683031">[-]</label><label class="expand" for="c-41683031">[1 more]</label></div><br/><div class="children"><div class="content">&gt; by switching to a non source-based distribution such as Debian.<p>The distinction has more nuance. Source based distros like nixos don&#x27;t have the same issue. The problem is more in how Gentoo builds&#x2F;installs the packages than in building from source.<p>Also with third party closed source software, you&#x27;re still going to have issues, even on binary systems. Actually you could even have issues with the first party packages if they&#x27;re installed in separate independent steps.</div><br/></div></div></div></div><div id="41684857" class="c"><input type="checkbox" id="c-41684857" checked=""/><div class="controls bullet"><span class="by">darkhelmet</span><span>|</span><a href="#41681740">prev</a><span>|</span><a href="#41682010">next</a><span>|</span><label class="collapse" for="c-41684857">[-]</label><label class="expand" for="c-41684857">[2 more]</label></div><br/><div class="children"><div class="content">Every time I see people struggling with this, I am so incredibly glad that I forced the issue for FreeBSD when I did the initial amd64 port.  I got to set the fundamental types in the ABI and decided to look forward rather than backward.<p>The amd64 architecture did have some interesting features that made this much easier than it might have been for other cpu architectures.  One of which was the automatic cast of 32 bit function arguments to 64 bit during the function call.  In most cases, if you passed a 32 bit time integer to a function expecting a 64 bit time_t, it Just Worked(TM) during the platform bringup.  This meant that a lot of the work on the loose ends could be deferred.<p>We did have some other 64 bit platforms at the time, but they did not have a 64 bit time_t.  FreeBSD&#x2F;amd64 was the first in its family, back in 2003&#x2F;2004&#x2F;2005.  If I remember correctly, sparc64 migrated to 64 bit time_t.<p>The biggest problem that I faced was that (at the time) tzcode was not 64 bit safe.  It used some algorithms in its &#x27;struct tm&#x27; normalization that ended up in some rather degenerate conditions, eg: iteratively trying to calculate the day&#x2F;month&#x2F;year for time_t(2^62).  IIRC, I cheated rather than change tzcode significantly, and made it simply fail for years before approx 1900, or after approx 10000.  I am pretty sure that this has been fixed upstream in tzcode long ago.<p>We did have a few years of whackamole with occasional 32&#x2F;64 time mixups where 3rd party code would be sloppy in its handling of int&#x2F;long&#x2F;time_t when handling data structures in files or on the network.<p>But for the most part, it was a non-issue for us.  Being able to have 64 bit time_t on day 1 avoided most of the problem.  Doing it from the start was easy.  Linux missed a huge opportunity to do the same when it began its amd64&#x2F;x86_64 port.<p>Aside: I did not finish 64 bit ino_t at the time. 32 bit inode numbers were heavily exposed in many, many places.   Even on-disk file systems, directory structures in UFS, and many, many more. There was no practical way to handle it for FreeBSD&#x2F;amd64 from the start while it was a low-tier platform without being massively disruptive to the other tier-1 architectures.  I did the work - twice - but somebody else eventually finished it - and fixed a number of other unfortunately short constants as well (eg: mountpoint path lengths etc).</div><br/><div id="41685678" class="c"><input type="checkbox" id="c-41685678" checked=""/><div class="controls bullet"><span class="by">jabl</span><span>|</span><a href="#41684857">parent</a><span>|</span><a href="#41682010">next</a><span>|</span><label class="collapse" for="c-41685678">[-]</label><label class="expand" for="c-41685678">[1 more]</label></div><br/><div class="children"><div class="content">AFAIU all 64-bit Linux ports have used 64-bit time_t, off_t, ino_t from the beginning. All this is about transitioning 32-bit Linux to 64-bit time_t.</div><br/></div></div></div></div><div id="41682010" class="c"><input type="checkbox" id="c-41682010" checked=""/><div class="controls bullet"><span class="by">nobluster</span><span>|</span><a href="#41684857">prev</a><span>|</span><a href="#41681758">next</a><span>|</span><label class="collapse" for="c-41682010">[-]</label><label class="expand" for="c-41682010">[4 more]</label></div><br/><div class="children"><div class="content">For a large legacy 32 bit unix system dealing with forward dates I replaced all the signed 32 bit time_t libc functions with unsigned 32 bit time_t equivalents. This bought the system another 68 years beyond 2038 - long after I&#x27;ll be gone. The downside is that it cannot represent dates before the unix epoch, 1970, but as it was a scheduling system it wasn&#x27;t an issue.<p>If legacy dates were a concern one could shift the epoch by a couple of decades, or even reduce the time granularity from 1 second to 2 seconds. Each alternative has subtle problems of their own. It depends on the use case.</div><br/><div id="41683424" class="c"><input type="checkbox" id="c-41683424" checked=""/><div class="controls bullet"><span class="by">suprjami</span><span>|</span><a href="#41682010">parent</a><span>|</span><a href="#41681758">next</a><span>|</span><label class="collapse" for="c-41683424">[-]</label><label class="expand" for="c-41683424">[3 more]</label></div><br/><div class="children"><div class="content">If you can change the whole system from signed to unsigned, why not change to 64-bit?</div><br/><div id="41685212" class="c"><input type="checkbox" id="c-41685212" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41682010">root</a><span>|</span><a href="#41683424">parent</a><span>|</span><a href="#41684512">next</a><span>|</span><label class="collapse" for="c-41685212">[-]</label><label class="expand" for="c-41685212">[1 more]</label></div><br/><div class="children"><div class="content">The main problem here is gradual upgrades.  Signed and unsigned code act exactly the same on dates before 2038, so you can upgrade piece by piece at your leisure.<p>The suggestions for messing with epoch or the timescale wouldn&#x27;t work nearly as well, for those just switch to 64 bit.</div><br/></div></div></div></div></div></div><div id="41681758" class="c"><input type="checkbox" id="c-41681758" checked=""/><div class="controls bullet"><span class="by">n_plus_1_acc</span><span>|</span><a href="#41682010">prev</a><span>|</span><a href="#41682496">next</a><span>|</span><label class="collapse" for="c-41681758">[-]</label><label class="expand" for="c-41681758">[32 more]</label></div><br/><div class="children"><div class="content">I&#x27;m no expert on C, but I was under the impression that type aliases like off_t are introduced to have the possibility to change then later. This clearly doesn&#x27;t work. Am I wrong?</div><br/><div id="41681820" class="c"><input type="checkbox" id="c-41681820" checked=""/><div class="controls bullet"><span class="by">wtallis</span><span>|</span><a href="#41681758">parent</a><span>|</span><a href="#41681842">next</a><span>|</span><label class="collapse" for="c-41681820">[-]</label><label class="expand" for="c-41681820">[3 more]</label></div><br/><div class="children"><div class="content">Source vs binary compatibility. Using typedefs like off_t mean you usually don&#x27;t have to re-write code, but you do have to re-compile <i>everything</i> that uses that type.</div><br/><div id="41682561" class="c"><input type="checkbox" id="c-41682561" checked=""/><div class="controls bullet"><span class="by">rblatz</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41681820">parent</a><span>|</span><a href="#41681842">next</a><span>|</span><label class="collapse" for="c-41682561">[-]</label><label class="expand" for="c-41682561">[2 more]</label></div><br/><div class="children"><div class="content">But isnât the point of a source only distribution like Gentoo, to build everything yourself? Who is running gentoo but also lugging around old precompiled stuff they donât have the source for?</div><br/><div id="41682617" class="c"><input type="checkbox" id="c-41682617" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41682561">parent</a><span>|</span><a href="#41681842">next</a><span>|</span><label class="collapse" for="c-41682617">[-]</label><label class="expand" for="c-41682617">[1 more]</label></div><br/><div class="children"><div class="content">As the post describes, the problem is that on Gentoo you canât really build everything then switch binaries for everything, or at least thatâs not what happens when you update things the usual way.<p>Instead, dependencies are built and then installed, then dependents are built against the installed versions and then installed, etc. In the middle of this process, the system can technically be half-broken, because it could be attempting to run older dependents against newer dependencies. Usually this is not a real problem. Because of how pervasive time_t is, though, the half-broken state here is potentially <i>very</i> broken to the point that you may be unable to resume the update process if anything breaks for any reason.</div><br/></div></div></div></div></div></div><div id="41681842" class="c"><input type="checkbox" id="c-41681842" checked=""/><div class="controls bullet"><span class="by">ordu</span><span>|</span><a href="#41681758">parent</a><span>|</span><a href="#41681820">prev</a><span>|</span><a href="#41682315">next</a><span>|</span><label class="collapse" for="c-41681842">[-]</label><label class="expand" for="c-41681842">[17 more]</label></div><br/><div class="children"><div class="content">It kinda work, but not in a source based distro. If you can atomically rebuild @world with changed definition of off_t, then there will be no problem. But source based distro doesn&#x27;t rebuild @world atomically. It rebuild one package at time, so there would be inconveniences like libc.so has 64-bit off_t, while gcc was build for 32-bit off_t, so gcc stops working. Or maybe bash, coreutils, make, binutils or any other package that is needed for rebuilding @world. At this point you are stuck.<p>So such upgrade needs care.</div><br/><div id="41682245" class="c"><input type="checkbox" id="c-41682245" checked=""/><div class="controls bullet"><span class="by">jasomill</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41681842">parent</a><span>|</span><a href="#41681893">next</a><span>|</span><label class="collapse" for="c-41682245">[-]</label><label class="expand" for="c-41682245">[2 more]</label></div><br/><div class="children"><div class="content">As someone whose nearest exposure to a &quot;source based distro&quot; is FreeBSD, this sounds like madness, as it means a broken build could not only impair attempts to repair the build, but render the system unbootable and&#x2F;or unusable.<p>And as someone who regularly uses traditional Linux distros like Debian and Fedora, the idea that a package management system would allow a set of packages known to be incompatible with one another to be installed without force, or that core package maintainers would knowingly specify incorrect requirements, is terrifying.<p>While I&#x27;m not familiar with Gentoo, my reading of this article suggests that its maintainers are well aware of these sorts of problems and that Gentoo does not, in fact, suffer from them (intentionally; inevitably mistakes happen just as they occasionally do on the bleeding edge of FreeBSD and other Linux distros).</div><br/><div id="41683571" class="c"><input type="checkbox" id="c-41683571" checked=""/><div class="controls bullet"><span class="by">AshamedCaptain</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41682245">parent</a><span>|</span><a href="#41681893">next</a><span>|</span><label class="collapse" for="c-41683571">[-]</label><label class="expand" for="c-41683571">[1 more]</label></div><br/><div class="children"><div class="content">FreeBSD does not use package management for the core system (i.e. freebsd itself, not ports). Gentoo does.</div><br/></div></div></div></div><div id="41681893" class="c"><input type="checkbox" id="c-41681893" checked=""/><div class="controls bullet"><span class="by">Athas</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41681842">parent</a><span>|</span><a href="#41682245">prev</a><span>|</span><a href="#41681859">next</a><span>|</span><label class="collapse" for="c-41681893">[-]</label><label class="expand" for="c-41681893">[5 more]</label></div><br/><div class="children"><div class="content">Why not essentially treat it as a cross compilation scenario? NixOS is also source based, but I don&#x27;t think such a migration would be particularly difficult. You&#x27;d use the 32-bit off_t gcc to compile a glibc with 64-bit off_t, then compile a 64-bit off_t gcc linked against that new glibc, and so on. The host compiler shouldn&#x27;t matter.<p>I always understood the challenge as <i>binary</i> compatibility, when you can&#x27;t just switch the entire world at once.</div><br/><div id="41682114" class="c"><input type="checkbox" id="c-41682114" checked=""/><div class="controls bullet"><span class="by">codys</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41681893">parent</a><span>|</span><a href="#41682535">next</a><span>|</span><label class="collapse" for="c-41682114">[-]</label><label class="expand" for="c-41682114">[1 more]</label></div><br/><div class="children"><div class="content">Nixos has it easier here because they don&#x27;t require packages to be &quot;installed&quot; before building code against them. For Gentoo, none of their build scripts (ebuilds) are written to support that. It&#x27;s plausible that they might change the embuild machinery so that this kind of build (against non-installed packages) could work, but it would need investigation and might be a difficult lift to get it working for all packages.<p>&quot;treat it as a cross compilation scenario&quot; is essentially what the post discusses when they mention &quot;use a different CHOST&quot;. A CHOST is a unique name identifying a system configuration, like &quot;x86_64-unknown-linux-gnu&quot; (etc). Gentoo treats building for different CHOSTs as cross compiling.</div><br/></div></div><div id="41682535" class="c"><input type="checkbox" id="c-41682535" checked=""/><div class="controls bullet"><span class="by">andrewaylett</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41681893">parent</a><span>|</span><a href="#41682114">prev</a><span>|</span><a href="#41681859">next</a><span>|</span><label class="collapse" for="c-41682535">[-]</label><label class="expand" for="c-41682535">[3 more]</label></div><br/><div class="children"><div class="content">NixOS isn&#x27;t the same kind of source-based.  At some level, even Debian could be said to be source based: there&#x27;s nothing stopping you from deciding to build every package from source before installing it, and obviously the packages are themselves built from source at some point.<p>NixOS sits between Debian and Gentoo, as it maintains an output that&#x27;s capable of existing independently of the rest of the system (like Debian) but is designed to use the current host as a builder (like Gentoo).  Gentoo doesn&#x27;t have any way to keep individual builds separate from the system as a whole, as intimated in the article, so you need to work out how to keep the two worlds separate while you do the build.<p>I think what they&#x27;re suggesting winds up being pretty similar to what you suggest, just with the right plumbing to make it work in a Gentoo system.  NixOS would need different plumbing, I&#x27;m not sure whether they&#x27;ve done it yet or how but I can easily imagine it being more straightforward than what Gentoo is needing to do.</div><br/><div id="41682640" class="c"><input type="checkbox" id="c-41682640" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41682535">parent</a><span>|</span><a href="#41681859">next</a><span>|</span><label class="collapse" for="c-41682640">[-]</label><label class="expand" for="c-41682640">[2 more]</label></div><br/><div class="children"><div class="content">There absolutely will be problems with different Nix profiles that aren&#x27;t updated together; for example, if you update some packages installed in your user&#x27;s profile but not the running system profile. But this is common enough with other glibc ABI breakage that folks tend to update home and system profiles together, or know that they need to reboot.<p>Where it will be hell is running Nix-built packages on a non-NixOS system with non-ABI-compatible glibc. That is something that desperately needs fixing on the glibc side, mostly from the design of nss and networking, that prevent linking against glibc statically.</div><br/><div id="41683526" class="c"><input type="checkbox" id="c-41683526" checked=""/><div class="controls bullet"><span class="by">oasisaimlessly</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41682640">parent</a><span>|</span><a href="#41681859">next</a><span>|</span><label class="collapse" for="c-41683526">[-]</label><label class="expand" for="c-41683526">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Where it will be hell is running Nix-built packages on a non-NixOS system with non-ABI-compatible glibc.<p>This isn&#x27;t a thing. Nix-built binaries all each use the hardcoded glibc they were built with. You can have any number of glibc&#x27;s simultaneously in use.</div><br/></div></div></div></div></div></div></div></div><div id="41681859" class="c"><input type="checkbox" id="c-41681859" checked=""/><div class="controls bullet"><span class="by">codys</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41681842">parent</a><span>|</span><a href="#41681893">prev</a><span>|</span><a href="#41681959">next</a><span>|</span><label class="collapse" for="c-41681859">[-]</label><label class="expand" for="c-41681859">[7 more]</label></div><br/><div class="children"><div class="content">&gt; there would be inconveniences like libc.so has 64-bit off_t<p>glibc specifically has support for the 32-bit and 64-bit time_t abi simultaneously.<p>From the post:<p>&gt; Whatâs important here is that a single glibc build remains compatible with all three variants. However, libraries that use these types in their API are not.</div><br/><div id="41681943" class="c"><input type="checkbox" id="c-41681943" checked=""/><div class="controls bullet"><span class="by">ordu</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41681859">parent</a><span>|</span><a href="#41681959">next</a><span>|</span><label class="collapse" for="c-41681943">[-]</label><label class="expand" for="c-41681943">[6 more]</label></div><br/><div class="children"><div class="content">Yeah, glibc was a bad example. Probably libz.so or something would be better.</div><br/><div id="41682137" class="c"><input type="checkbox" id="c-41682137" checked=""/><div class="controls bullet"><span class="by">codys</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41681943">parent</a><span>|</span><a href="#41681959">next</a><span>|</span><label class="collapse" for="c-41682137">[-]</label><label class="expand" for="c-41682137">[5 more]</label></div><br/><div class="children"><div class="content">Yep, agreed. Though it does expose an option here which would be &quot;have glibc provide a mechanism for other libraries (likely more core&#x2F;widely used libs) to support both ABIs simultaneously.<p>Presumably if that had been done in glibc when 64-bit time_t support was added, we could have had multi-size-time ABI support in things like zlib by now. Seems like a mistake on glibc&#x27;s part not to create that initially (years ago).<p>Though if other distros have already switched, I&#x27;d posit that perhaps Gentoo needs to rethink its design a bit so it doesn&#x27;t run into this issue instead.</div><br/><div id="41682477" class="c"><input type="checkbox" id="c-41682477" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41682137">parent</a><span>|</span><a href="#41682387">next</a><span>|</span><label class="collapse" for="c-41682477">[-]</label><label class="expand" for="c-41682477">[2 more]</label></div><br/><div class="children"><div class="content">&gt; have glibc provide a mechanism for other libraries (likely more core&#x2F;widely used libs) to support both ABIs simultaneously<p>The linked article is wrong to imply this isn&#x27;t possible - and it really doesn&#x27;t depend on &quot;GLIBC provide a mechanism&quot;. All you have to do is:<p>* Compile the library itself with traditional time_t (32-bit or 64-bit depending on platform), but convert and call time64 APIs internally.<p>* Make a copy of every public structure that embeds a time_t (directly or indirectly), using time64_t (or whatever contains it) instead.<p>* Make a copy of every function that takes any time-using type, to use the time64 types.<p>* In the public headers, check if everything is compiled with 64-bit time_t, and if so make all the traditional types&#x2F;functions aliases for the time64 versions.<p>* Disable most of this on platforms that already used 64-bit time_t. Instead (for convenience of external callers) make all the time64 names aliases for the traditional names.<p>It&#x27;s just that this is a lot of work, and little benefit to any particular library. the GCC 5 std::string transition is probably a better story than LFS, in particular the compiler-supported `abi_tag` to help detect errors (but I think that&#x27;s only for C++, ugh - language without room for automatic mangling suck).<p>(minor note: using typedefs rather than struct tags for your API makes this easier)</div><br/><div id="41684012" class="c"><input type="checkbox" id="c-41684012" checked=""/><div class="controls bullet"><span class="by">AshamedCaptain</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41682477">parent</a><span>|</span><a href="#41682387">next</a><span>|</span><label class="collapse" for="c-41684012">[-]</label><label class="expand" for="c-41684012">[1 more]</label></div><br/><div class="children"><div class="content">This is a nightmare to implement (unless you go library by library and do it by hand, or you have significant compiler help), as e.g. functions may not directly use a struct with time_t but indirectly assume something about the size of the struct.<p>Note that for example the std::string transition did not do this.</div><br/></div></div></div></div><div id="41682387" class="c"><input type="checkbox" id="c-41682387" checked=""/><div class="controls bullet"><span class="by">jasomill</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41682137">parent</a><span>|</span><a href="#41682477">prev</a><span>|</span><a href="#41681959">next</a><span>|</span><label class="collapse" for="c-41682387">[-]</label><label class="expand" for="c-41682387">[2 more]</label></div><br/><div class="children"><div class="content">This sounds like something similar to NeXTSTEP&#x2F;macOS fat binaries, only with the possibility of code sharing between &quot;architectures&quot;.<p>I like it, though it sounds like something that&#x27;d be unlikely to see adoption in the Linux world without the endorsement of multiple major distros.</div><br/><div id="41683907" class="c"><input type="checkbox" id="c-41683907" checked=""/><div class="controls bullet"><span class="by">codys</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41682387">parent</a><span>|</span><a href="#41681959">next</a><span>|</span><label class="collapse" for="c-41683907">[-]</label><label class="expand" for="c-41683907">[1 more]</label></div><br/><div class="children"><div class="content">Fat binaries (packing together 2 entirely different objects and picking one of them) could potentially work here, though I suspect we&#x27;d run into issues of mixed 32-bit&#x2F;64-bit time_t things.<p>Another option that&#x27;s closer to how things work with LFS (large file support) (mostly in the past now) is to use create different interfaces to support 64-bit time_t, and pick defaults for time_t at compile time with a macro that picks the right impl.<p>Also possible could be having something like a version script (<a href="https:&#x2F;&#x2F;sourceware.org&#x2F;binutils&#x2F;docs&#x2F;ld&#x2F;VERSION.html" rel="nofollow">https:&#x2F;&#x2F;sourceware.org&#x2F;binutils&#x2F;docs&#x2F;ld&#x2F;VERSION.html</a>) to tell the linker what symbols to use when 64-bit time_t was enabled. While this one might have some benefits, generally folks avoid using version scripts when possible, and would require changes in glibc, making it unlikely.<p>Both of those options (version script extention, and LFS-like pattern) could allow re-using the same binary (ie: smaller file size, no need to build code twice in general), and potentially enable mixing 32-bit time_t and 64-bit time_t code together in a single executable (not desirable, but does remove weird link issues).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41681959" class="c"><input type="checkbox" id="c-41681959" checked=""/><div class="controls bullet"><span class="by">ArsenArsen</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41681842">parent</a><span>|</span><a href="#41681859">prev</a><span>|</span><a href="#41682168">next</a><span>|</span><label class="collapse" for="c-41681959">[-]</label><label class="expand" for="c-41681959">[1 more]</label></div><br/><div class="children"><div class="content">this is just as much of a problem on binary distros mind you.  just because there might be a smaller time delta does not mean that the problem is solved</div><br/></div></div><div id="41682168" class="c"><input type="checkbox" id="c-41682168" checked=""/><div class="controls bullet"><span class="by">codys</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41681842">parent</a><span>|</span><a href="#41681959">prev</a><span>|</span><a href="#41682315">next</a><span>|</span><label class="collapse" for="c-41682168">[-]</label><label class="expand" for="c-41682168">[1 more]</label></div><br/><div class="children"><div class="content">nixos is an example of a distro that is source based and can do the atomic rebuild here because it has a way to build packages against other packages that aren&#x27;t &quot;installed&quot;. In nixos, this is because there are very few things that get &quot;installed&quot; as the global, only thing to use. But one could imagine that Gentoo could build something that would allow them to at least build up one set of new packages without installing them and then install the files all at once.</div><br/></div></div></div></div><div id="41682315" class="c"><input type="checkbox" id="c-41682315" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#41681758">parent</a><span>|</span><a href="#41681842">prev</a><span>|</span><a href="#41681834">next</a><span>|</span><label class="collapse" for="c-41682315">[-]</label><label class="expand" for="c-41682315">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s only the first step of the puzzle.  And arguably only a half step.  As the article points out anytime that off_t is stuffed into a struct, or used in a function call, or integrated into a protocol, the abstraction is lost and the actual size matters.  Mixing old and new code, either by loading a library or communicating over a protocol, means you get offsets wrong and things start crashing.  Ultimately the changeover requires everybody to segregate their programs between &quot;legacy&quot; and &quot;has been ported or at least looked over&quot;, which is incredibly painful.</div><br/></div></div><div id="41681834" class="c"><input type="checkbox" id="c-41681834" checked=""/><div class="controls bullet"><span class="by">smueller1234</span><span>|</span><a href="#41681758">parent</a><span>|</span><a href="#41682315">prev</a><span>|</span><a href="#41681830">next</a><span>|</span><label class="collapse" for="c-41681834">[-]</label><label class="expand" for="c-41681834">[1 more]</label></div><br/><div class="children"><div class="content">They make it easier, but just at a source code level. They&#x27;re not a real (and certainly not full) abstraction. An example that&#x27;ll be making it obvious: if you replace the underlying type with a floating point type, the semantics would change dramatically, fully visible to the user code.<p>With larger types that otherwise have similar semantics, you can still have breakage. A straightforward one would be padding in structs. Another one is that a lot of use cases convert pointers to integers and back, so if you change the underlying representation, that&#x27;s guaranteed to break. Whether that&#x27;s a good or not is another question, but it&#x27;s certainly not uncommon.<p>(Edit: sibling comments make the same point much more succinctly: ABI compatibility!)</div><br/></div></div><div id="41681830" class="c"><input type="checkbox" id="c-41681830" checked=""/><div class="controls bullet"><span class="by">jonathrg</span><span>|</span><a href="#41681758">parent</a><span>|</span><a href="#41681834">prev</a><span>|</span><a href="#41681824">next</a><span>|</span><label class="collapse" for="c-41681830">[-]</label><label class="expand" for="c-41681830">[1 more]</label></div><br/><div class="children"><div class="content">It does work, the problem with ABI changes is that when you change it, you have to change it everywhere at the same time. By default there&#x27;s nothing stopping you from linking one library built using 32-bit off_t with another library built using 64-bit off_t, and the resulting behaviour can be incredibly unpredictable.</div><br/></div></div><div id="41681971" class="c"><input type="checkbox" id="c-41681971" checked=""/><div class="controls bullet"><span class="by">raldi</span><span>|</span><a href="#41681758">parent</a><span>|</span><a href="#41681824">prev</a><span>|</span><a href="#41682724">next</a><span>|</span><label class="collapse" for="c-41681971">[-]</label><label class="expand" for="c-41681971">[1 more]</label></div><br/><div class="children"><div class="content">I think the main reason theyâre introduced is to provide a hint to the programmer and maybe some typesafety against accidentally passing, say, a file descriptor.</div><br/></div></div><div id="41682724" class="c"><input type="checkbox" id="c-41682724" checked=""/><div class="controls bullet"><span class="by">devit</span><span>|</span><a href="#41681758">parent</a><span>|</span><a href="#41681971">prev</a><span>|</span><a href="#41681828">next</a><span>|</span><label class="collapse" for="c-41682724">[-]</label><label class="expand" for="c-41682724">[1 more]</label></div><br/><div class="children"><div class="content">The C library uses macros so that the referenced symbols are different depending on ABI (e.g. open becomes open64, etc.), but most 3rd party libraries don&#x27;t bother with that, so they break if their API uses time_t&#x2F;off_t.</div><br/></div></div><div id="41681828" class="c"><input type="checkbox" id="c-41681828" checked=""/><div class="controls bullet"><span class="by">progbits</span><span>|</span><a href="#41681758">parent</a><span>|</span><a href="#41682724">prev</a><span>|</span><a href="#41681812">next</a><span>|</span><label class="collapse" for="c-41681828">[-]</label><label class="expand" for="c-41681828">[2 more]</label></div><br/><div class="children"><div class="content">Edit: nevermind others raise better points.</div><br/><div id="41681981" class="c"><input type="checkbox" id="c-41681981" checked=""/><div class="controls bullet"><span class="by">cataphract</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41681828">parent</a><span>|</span><a href="#41681812">next</a><span>|</span><label class="collapse" for="c-41681981">[-]</label><label class="expand" for="c-41681981">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not the problem. If time_t was a struct with a single int32_t, you&#x27;d be in the same situation when you changed it to int64_t (ABI incompatibility: you need more space to store the value now).<p>In order not to have this problem you&#x27;d need the API to use opaque struts, for which only pointers would be exchanged.</div><br/></div></div></div></div><div id="41681812" class="c"><input type="checkbox" id="c-41681812" checked=""/><div class="controls bullet"><span class="by">beached_whale</span><span>|</span><a href="#41681758">parent</a><span>|</span><a href="#41681828">prev</a><span>|</span><a href="#41681835">next</a><span>|</span><label class="collapse" for="c-41681812">[-]</label><label class="expand" for="c-41681812">[1 more]</label></div><br/><div class="children"><div class="content">at the source level it does, but when you have compiled libraries it breaks.</div><br/></div></div><div id="41681835" class="c"><input type="checkbox" id="c-41681835" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41681758">parent</a><span>|</span><a href="#41681812">prev</a><span>|</span><a href="#41682496">next</a><span>|</span><label class="collapse" for="c-41681835">[-]</label><label class="expand" for="c-41681835">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, the problem in general with type aliases is that they&#x27;re just that, aliases, not proper types. This means that they leak all the details of the underlying type, and don&#x27;t work for proper encapsulation, which is what&#x27;s needed for being able to change what should be implementation details.</div><br/><div id="41682679" class="c"><input type="checkbox" id="c-41682679" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41681758">root</a><span>|</span><a href="#41681835">parent</a><span>|</span><a href="#41682496">next</a><span>|</span><label class="collapse" for="c-41682679">[-]</label><label class="expand" for="c-41682679">[1 more]</label></div><br/><div class="children"><div class="content">The problem here would be exactly the same regardless of what form this type took. The issue is fundamental to any low level language: the size of a type is a part of its public API (well, ABI), by definition. This is true in C++ with private fields as well, for example: if you add a private field to a class, or change the type of a private field with one of a different size, all code using that class has to be re-built. The only way to abstract this is to use types strictly through pointers, the way Java does.</div><br/></div></div></div></div></div></div><div id="41682496" class="c"><input type="checkbox" id="c-41682496" checked=""/><div class="controls bullet"><span class="by">wpollock</span><span>|</span><a href="#41681758">prev</a><span>|</span><a href="#41683239">next</a><span>|</span><label class="collapse" for="c-41682496">[-]</label><label class="expand" for="c-41682496">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;m probably naive, but I see another way forward.  If all the t64 binaries are static linked, they have no danger of mixing abis.  After 2038, all the t32 code is broken anyway so there&#x27;s no  <i>additional</i> risk for going back to dynamic linking then.
I feel if this was a solution the author would have mentioned it but I&#x27;m willing to look foolish to hear what others will say.</div><br/><div id="41682559" class="c"><input type="checkbox" id="c-41682559" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41682496">parent</a><span>|</span><a href="#41684248">next</a><span>|</span><label class="collapse" for="c-41682559">[-]</label><label class="expand" for="c-41682559">[5 more]</label></div><br/><div class="children"><div class="content">Static linking is probably impractical for applying security updates, as often youâd have to recompile&#x2F;relink basically the whole system. In some cases it could also significantly increase memory usage.</div><br/><div id="41682825" class="c"><input type="checkbox" id="c-41682825" checked=""/><div class="controls bullet"><span class="by">GeorgeTirebiter</span><span>|</span><a href="#41682496">root</a><span>|</span><a href="#41682559">parent</a><span>|</span><a href="#41684248">next</a><span>|</span><label class="collapse" for="c-41682825">[-]</label><label class="expand" for="c-41682825">[4 more]</label></div><br/><div class="children"><div class="content">with fast networks, huge disks, fast processors --- it seems wasteful to me to even consider shared libraries.  Shared libraries is a technology that was useful when we were memory starved.  We are no longer memory starved.  So you replace the static binary?  Big deal, size is not an issue (for 99% of the cases) given what we have today.<p>Recall, too, that the &quot;link&quot; step of those .o files is actually a &quot;link &#x2F; edit&quot; step, where routines in the libraries not used are not linked.</div><br/><div id="41682887" class="c"><input type="checkbox" id="c-41682887" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41682496">root</a><span>|</span><a href="#41682825">parent</a><span>|</span><a href="#41683304">next</a><span>|</span><label class="collapse" for="c-41682887">[-]</label><label class="expand" for="c-41682887">[1 more]</label></div><br/><div class="children"><div class="content">Itâs much more straightforward to ensure consistency with shared libraries, and not having to rebuild stuff. Wasting disk space, RAM, network bandwidth and processing time is what seems wasteful to me.</div><br/></div></div><div id="41683304" class="c"><input type="checkbox" id="c-41683304" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#41682496">root</a><span>|</span><a href="#41682825">parent</a><span>|</span><a href="#41682887">prev</a><span>|</span><a href="#41683017">next</a><span>|</span><label class="collapse" for="c-41683304">[-]</label><label class="expand" for="c-41683304">[1 more]</label></div><br/><div class="children"><div class="content">Static linking is the root cause for âmodernâ apps based on Electron taking minutes to start up and be useful. Theyâre statically linking almost an entire operating system (Chromium), an entire web server, server runtime framework, <i>and</i> an equivalent client framework for good measure.<p>On the fastest PC that money can buy this is somewhere between âslowâ and âmolassesâ.<p>I miss the good old days when useful GUI programs were mere kilobytes in size and launched instantly.</div><br/></div></div><div id="41683017" class="c"><input type="checkbox" id="c-41683017" checked=""/><div class="controls bullet"><span class="by">gotoeleven</span><span>|</span><a href="#41682496">root</a><span>|</span><a href="#41682825">parent</a><span>|</span><a href="#41683304">prev</a><span>|</span><a href="#41684248">next</a><span>|</span><label class="collapse" for="c-41683017">[-]</label><label class="expand" for="c-41683017">[1 more]</label></div><br/><div class="children"><div class="content">Are you by chance a javascript programmer?</div><br/></div></div></div></div></div></div><div id="41684248" class="c"><input type="checkbox" id="c-41684248" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#41682496">parent</a><span>|</span><a href="#41682559">prev</a><span>|</span><a href="#41683239">next</a><span>|</span><label class="collapse" for="c-41684248">[-]</label><label class="expand" for="c-41684248">[1 more]</label></div><br/><div class="children"><div class="content">Considering the most important remaining use case for 32-bit is embedded systems, wouldn&#x27;t static linking be a non-starter due to space and performance constraints?</div><br/></div></div></div></div><div id="41683239" class="c"><input type="checkbox" id="c-41683239" checked=""/><div class="controls bullet"><span class="by">panzi</span><span>|</span><a href="#41682496">prev</a><span>|</span><a href="#41681945">next</a><span>|</span><label class="collapse" for="c-41683239">[-]</label><label class="expand" for="c-41683239">[1 more]</label></div><br/><div class="children"><div class="content">The only place where this is relevant for me is running old Windows games via wine. Wonder how wine is handling this? Might as well re-map the date for 32bit wine to the late 90s&#x2F;early 2000s, where my games are from. Heck, with faketime I can do that already, but don&#x27;t need it yet.</div><br/></div></div><div id="41681945" class="c"><input type="checkbox" id="c-41681945" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41683239">prev</a><span>|</span><a href="#41682974">next</a><span>|</span><label class="collapse" for="c-41681945">[-]</label><label class="expand" for="c-41681945">[31 more]</label></div><br/><div class="children"><div class="content">The C standard does not require time_t to be signed (nor does POSIX).  Just changing the 32-bit type to unsigned would (in some senses) extend the lifetime of the type out to 2106.  You could at least avoid some classes of ABI breakage in this way.  (On the other hand, Glibc has explicitly documented that its time_t is always signed.  So they do not have this option.)</div><br/><div id="41682052" class="c"><input type="checkbox" id="c-41682052" checked=""/><div class="controls bullet"><span class="by">pwg</span><span>|</span><a href="#41681945">parent</a><span>|</span><a href="#41681989">next</a><span>|</span><label class="collapse" for="c-41682052">[-]</label><label class="expand" for="c-41682052">[6 more]</label></div><br/><div class="children"><div class="content">While that avoids 2038 as a &quot;drop dead&quot; date for 32-bit time_t, it also removes the ability to represent any date&#x2F;time prior to 00:00:00 UTC on 1 January 1970 using 32-bit time_t because you lose the ability to represent negative values.<p>Having all existing stored date&#x2F;times that are currently prior to the epoch suddenly become dates post 2038 is also not a good scenario.</div><br/><div id="41682390" class="c"><input type="checkbox" id="c-41682390" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41682052">parent</a><span>|</span><a href="#41682472">next</a><span>|</span><label class="collapse" for="c-41682390">[-]</label><label class="expand" for="c-41682390">[4 more]</label></div><br/><div class="children"><div class="content">&gt; it also removes the ability to represent any date&#x2F;time prior to 00:00:00 UTC on 1 January 1970 using 32-bit time_t<p>Yes, of course.  This is probably not the main use of negative values with signed time_t, though -- which is just representing the result of subtraction when the operand happened before the subtrahend.<p>&gt; Having all existing stored date&#x2F;times that are currently prior to the epoch suddenly become dates post 2038 is also not a good scenario.<p>In practice, there are ~zero of these on systems with 32-bit time_t and a challenging migration path as we approach 2038.</div><br/><div id="41682544" class="c"><input type="checkbox" id="c-41682544" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41682390">parent</a><span>|</span><a href="#41682472">next</a><span>|</span><label class="collapse" for="c-41682544">[-]</label><label class="expand" for="c-41682544">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Yes, of course. This is probably not the main use of negative values with signed time_t, though -- which is just representing the result of subtraction when the operand happened before the subtrahend.<p>This is definitely a bigger concern, yes.  One has to be very careful with subtraction of timestamps.  But to be fair one already had to be very careful before because POSIX doesn&#x27;t say what the size or signedness of `time_t` is to begin with.<p>Indeed, in POSIX `time_t` can even be `float` or `double`[0]!<p><pre><code>  time_t and clock_t shall be integer or real-floating types.
</code></pre>
Though on all Unix, BSD, Linux, and any Unix-like systems thankfully `time_t` is always integral.  It&#x27;s really only size and signedness that one has to be careful with.<p>Thus one should always subtract only the smaller value from the larger, and cast the result to a signed integer.  And one has to be careful with overflow.  Fortunately `difftime()` exists in POSIX.  And there&#x27;s a reason that `difftime()` returns a `double`: to avoid having the caller have to deal with overflows.<p>Basically working safely with `time_t` arithmetic is a real PITA.<p><pre><code>  [0] https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;009696799&#x2F;basedefs&#x2F;sys&#x2F;types.h.html</code></pre></div><br/><div id="41682600" class="c"><input type="checkbox" id="c-41682600" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41682544">parent</a><span>|</span><a href="#41682472">next</a><span>|</span><label class="collapse" for="c-41682600">[-]</label><label class="expand" for="c-41682600">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Indeed, in POSIX `time_t` can even be `float` or `double`[0]!<p>Standard C, yes.  Newer POSIX (your link is to the 2004 version) requires time_t be an integer type: <a href="https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;basedefs&#x2F;sys_types.h.html#:~:text=time_t%20shall%20be%20an%20integer%20type" rel="nofollow">https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;basedefs&#x2F;sy...</a><p>&gt; Though on all Unix, BSD, Linux, and any Unix-like systems thankfully `time_t` is always integral. It&#x27;s really only size and signedness that one has to be careful with.
Thus one should always subtract only the smaller value from the larger, and cast the result to a signed integer. And one has to be careful with overflow. Fortunately `difftime()` exists in POSIX. And there&#x27;s a reason that `difftime()` returns a `double`: to avoid having the caller have to deal with overflows.<p>&gt; Basically working safely with `time_t` arithmetic is a real PITA.<p>Yes.</div><br/><div id="41682634" class="c"><input type="checkbox" id="c-41682634" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41682600">parent</a><span>|</span><a href="#41682472">next</a><span>|</span><label class="collapse" for="c-41682634">[-]</label><label class="expand" for="c-41682634">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I know that was older POSIX.  But we&#x27;re talking about old code, the unstated context is portability over a long period of time, and I wanted to make a point :)<p>So use `difftime()`, don&#x27;t assume signedness or size, but do assume that it&#x27;s an integral type.</div><br/></div></div></div></div></div></div></div></div><div id="41682472" class="c"><input type="checkbox" id="c-41682472" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41682052">parent</a><span>|</span><a href="#41682390">prev</a><span>|</span><a href="#41681989">next</a><span>|</span><label class="collapse" for="c-41682472">[-]</label><label class="expand" for="c-41682472">[1 more]</label></div><br/><div class="children"><div class="content">Stored _where_ exactly?</div><br/></div></div></div></div><div id="41681989" class="c"><input type="checkbox" id="c-41681989" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41681945">parent</a><span>|</span><a href="#41682052">prev</a><span>|</span><a href="#41682207">next</a><span>|</span><label class="collapse" for="c-41681989">[-]</label><label class="expand" for="c-41681989">[18 more]</label></div><br/><div class="children"><div class="content">You would then lose the ability to represent times before Jan. 1st, 1970. Which is not just a theoretical concern; those times appear e.g. in databases with people&#x27;s date of birth.</div><br/><div id="41682048" class="c"><input type="checkbox" id="c-41682048" checked=""/><div class="controls bullet"><span class="by">nobluster</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41681989">parent</a><span>|</span><a href="#41682394">next</a><span>|</span><label class="collapse" for="c-41682048">[-]</label><label class="expand" for="c-41682048">[8 more]</label></div><br/><div class="children"><div class="content">And a signed 32 bit time_t with an epoch of 1970 cannot represent dates before 1902. Using time_t to store legacy dates is not advisable - even if you ignore all the issues with time zones and changing local laws pertaining to offsets from UTC and daylight saving time.</div><br/><div id="41682083" class="c"><input type="checkbox" id="c-41682083" checked=""/><div class="controls bullet"><span class="by">pwg</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41682048">parent</a><span>|</span><a href="#41682394">next</a><span>|</span><label class="collapse" for="c-41682083">[-]</label><label class="expand" for="c-41682083">[7 more]</label></div><br/><div class="children"><div class="content">While true, that limitation has always existed, so everyone has already implemented whatever was necessary to represent dates earlier than that.<p>Changing 32-bit time_t to unsigned suddenly makes all dates from 1902 to Jan 1 1970 which were stored using time_t (even if it was non-advisable, it still will have occurred) appear to teleport into the future beyond 2038.</div><br/><div id="41682470" class="c"><input type="checkbox" id="c-41682470" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41682083">parent</a><span>|</span><a href="#41682394">next</a><span>|</span><label class="collapse" for="c-41682470">[-]</label><label class="expand" for="c-41682470">[6 more]</label></div><br/><div class="children"><div class="content">That&#x27;s alright, see, because I have no filesystems, no tarballs, no backups, no files on any kind of media with timestamps before 1970, and indeed, no one can except by manually setting those timestamps -- and why bother doing that?!<p>So any pre-1970 32-bit signed timestamps will be in... not spreadsheets, in what?  In databases?  No, not either.  So in some sort of documents, so software consuming those will need fixing, but we&#x27;re not going to see much teleporting of 1902-1970 timestamps to 2038-2106.  I&#x27;m not concerned.</div><br/><div id="41682621" class="c"><input type="checkbox" id="c-41682621" checked=""/><div class="controls bullet"><span class="by">jasomill</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41682470">parent</a><span>|</span><a href="#41682394">next</a><span>|</span><label class="collapse" for="c-41682621">[-]</label><label class="expand" for="c-41682621">[5 more]</label></div><br/><div class="children"><div class="content">Many important software projects predate UNIX. 
Perhaps you want to create a Git repository for one of them, with historically accurate commit timestamps?</div><br/><div id="41682951" class="c"><input type="checkbox" id="c-41682951" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41682621">parent</a><span>|</span><a href="#41684122">next</a><span>|</span><label class="collapse" for="c-41682951">[-]</label><label class="expand" for="c-41682951">[1 more]</label></div><br/><div class="children"><div class="content">Well, Git doesn&#x27;t seem to set file timestamps when cloning.  And as the sibling comment says, Git doesn&#x27;t use 32-bit signed integers to store timestamps.  So this is not a problem.<p>If, however, Git were to some day get an option to set file mtimes and atimes at clone time to the last-modified time of the files based on commit history, then you could always just use a 64-bit system where `time_t` is 64-bit.</div><br/></div></div><div id="41684122" class="c"><input type="checkbox" id="c-41684122" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41682621">parent</a><span>|</span><a href="#41682951">prev</a><span>|</span><a href="#41682635">next</a><span>|</span><label class="collapse" for="c-41684122">[-]</label><label class="expand" for="c-41684122">[2 more]</label></div><br/><div class="children"><div class="content">More importantly than a git repository, you might have archives (a .tar or equivalent) of these software projects, and might want to unpack them while preserving the timestamps contained within these archives.</div><br/><div id="41685085" class="c"><input type="checkbox" id="c-41685085" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41684122">parent</a><span>|</span><a href="#41682635">next</a><span>|</span><label class="collapse" for="c-41685085">[-]</label><label class="expand" for="c-41685085">[1 more]</label></div><br/><div class="children"><div class="content">Unix did not exist before 1970.  Neither did tar.  There are no tar files with files with timestamps before 1970 _unless_ you&#x27;ve used `touch -t 195001010000` or `utime(2)` or `futimes(3)` to set the files&#x27; time to before 1970.  That seems pretty unlikely.</div><br/></div></div></div></div><div id="41682635" class="c"><input type="checkbox" id="c-41682635" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41682621">parent</a><span>|</span><a href="#41684122">prev</a><span>|</span><a href="#41682394">next</a><span>|</span><label class="collapse" for="c-41682635">[-]</label><label class="expand" for="c-41682635">[1 more]</label></div><br/><div class="children"><div class="content">Git represents timestamps in ASCII strings, like &quot;12345.&quot;  Not time_t.  (I am not sure if it even allows negative integers in this format.)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41682394" class="c"><input type="checkbox" id="c-41682394" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41681989">parent</a><span>|</span><a href="#41682048">prev</a><span>|</span><a href="#41682353">next</a><span>|</span><label class="collapse" for="c-41682394">[-]</label><label class="expand" for="c-41682394">[1 more]</label></div><br/><div class="children"><div class="content">Databases do not and can not use system time_t.  Consider how their on-disk state would be impacted by a change from 32-bit time_t to 64-bit!  Instead they use specific or variable size integer types.</div><br/></div></div><div id="41682353" class="c"><input type="checkbox" id="c-41682353" checked=""/><div class="controls bullet"><span class="by">bloak</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41681989">parent</a><span>|</span><a href="#41682394">prev</a><span>|</span><a href="#41683368">next</a><span>|</span><label class="collapse" for="c-41682353">[-]</label><label class="expand" for="c-41682353">[6 more]</label></div><br/><div class="children"><div class="content">Serious question: do people use time_t for representing a date of birth?<p>To me that wouldn&#x27;t seem right: a date of birth isn&#x27;t a timestamp and you typically receive it without a corresponding place or time zone so there&#x27;s no reasonable way to convert it into a timestamp.<p>(The other problem is that a signed 32-bit time_t only goes back to 1901. You might not have to deal with a date of birth before 1901 today, unless you&#x27;re doing genealogy, of course, but until fairly recently it&#x27;s something you&#x27;d probably want to be able to handle.)</div><br/><div id="41682510" class="c"><input type="checkbox" id="c-41682510" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41682353">parent</a><span>|</span><a href="#41682389">next</a><span>|</span><label class="collapse" for="c-41682510">[-]</label><label class="expand" for="c-41682510">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Serious question: do people use time_t for representing a date of birth?<p>I have seen people in real life use seconds since the UNIX epoch to represent DOB, yes.</div><br/></div></div><div id="41682389" class="c"><input type="checkbox" id="c-41682389" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41682353">parent</a><span>|</span><a href="#41682510">prev</a><span>|</span><a href="#41683368">next</a><span>|</span><label class="collapse" for="c-41682389">[-]</label><label class="expand" for="c-41682389">[4 more]</label></div><br/><div class="children"><div class="content">My birth certificate has location, day, year, hour, and minute of birth. Birth is an event in time, perfectly represented with a (UTC) timestamp.</div><br/><div id="41682489" class="c"><input type="checkbox" id="c-41682489" checked=""/><div class="controls bullet"><span class="by">Merad</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41682389">parent</a><span>|</span><a href="#41682558">next</a><span>|</span><label class="collapse" for="c-41682489">[-]</label><label class="expand" for="c-41682489">[2 more]</label></div><br/><div class="children"><div class="content">Your birth is an event that happened at an instant in time, but very few systems concern themselves with that detail. The vast majority need to store birth _date_ and have no interest in the time or location.</div><br/><div id="41683464" class="c"><input type="checkbox" id="c-41683464" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41682489">parent</a><span>|</span><a href="#41682558">next</a><span>|</span><label class="collapse" for="c-41683464">[-]</label><label class="expand" for="c-41683464">[1 more]</label></div><br/><div class="children"><div class="content">&gt; have no interest in the time<p>Setting the bottom couple of bytes to zero achieves this, while maintaining nearly universal consistency with all other events in time that might need to be related with a packing of bits. People do it because it&#x27;s what&#x27;s being used at nearly every other level of the stack.</div><br/></div></div></div></div><div id="41682558" class="c"><input type="checkbox" id="c-41682558" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41682389">parent</a><span>|</span><a href="#41682489">prev</a><span>|</span><a href="#41683368">next</a><span>|</span><label class="collapse" for="c-41682558">[-]</label><label class="expand" for="c-41682558">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Birth is an event in time, perfectly represented with a (UTC) timestamp.<p>That&#x27;s not the same thing as `time_t` though.  `time_t` is UTC.  UTC is not `time_t`.</div><br/></div></div></div></div></div></div><div id="41683368" class="c"><input type="checkbox" id="c-41683368" checked=""/><div class="controls bullet"><span class="by">pezezin</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41681989">parent</a><span>|</span><a href="#41682353">prev</a><span>|</span><a href="#41682551">next</a><span>|</span><label class="collapse" for="c-41683368">[-]</label><label class="expand" for="c-41683368">[1 more]</label></div><br/><div class="children"><div class="content">Does any database actually use time_t? PostgreSQL uses its own datatype, the number of microseconds since 4713 BC. I am sure that other databases do the same.<p><a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;datatype-datetime.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;datatype-datetime.ht...</a></div><br/></div></div><div id="41682551" class="c"><input type="checkbox" id="c-41682551" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41681989">parent</a><span>|</span><a href="#41683368">prev</a><span>|</span><a href="#41682207">next</a><span>|</span><label class="collapse" for="c-41682551">[-]</label><label class="expand" for="c-41682551">[1 more]</label></div><br/><div class="children"><div class="content">Those databases might not even use `time_t`.  It&#x27;s their problem anyways, not the OS&#x27;s.</div><br/></div></div></div></div><div id="41682207" class="c"><input type="checkbox" id="c-41682207" checked=""/><div class="controls bullet"><span class="by">petee</span><span>|</span><a href="#41681945">parent</a><span>|</span><a href="#41681989">prev</a><span>|</span><a href="#41681987">next</a><span>|</span><label class="collapse" for="c-41682207">[-]</label><label class="expand" for="c-41682207">[3 more]</label></div><br/><div class="children"><div class="content">Openbsd did just this for 32bit compat when they changed to 64bit time 12 years ago, and seems to have worked out fine.</div><br/><div id="41682774" class="c"><input type="checkbox" id="c-41682774" checked=""/><div class="controls bullet"><span class="by">brynet</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41682207">parent</a><span>|</span><a href="#41681987">next</a><span>|</span><label class="collapse" for="c-41682774">[-]</label><label class="expand" for="c-41682774">[2 more]</label></div><br/><div class="children"><div class="content">No, time_t is a signed 64-bit type on all architectures, 64-bit architectures have no &quot;32bit compat&quot;.<p><a href="https:&#x2F;&#x2F;www.openbsd.org&#x2F;55.html" rel="nofollow">https:&#x2F;&#x2F;www.openbsd.org&#x2F;55.html</a></div><br/><div id="41683316" class="c"><input type="checkbox" id="c-41683316" checked=""/><div class="controls bullet"><span class="by">petee</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41682774">parent</a><span>|</span><a href="#41681987">next</a><span>|</span><label class="collapse" for="c-41683316">[-]</label><label class="expand" for="c-41683316">[1 more]</label></div><br/><div class="children"><div class="content">From the notes, this is what i was referring to, I think I just mistook the meaning -<p><i>Parts of the system that could not use 64-bit time_t were converted to use unsigned 32-bit instead, so they are good till the year 2106</i></div><br/></div></div></div></div></div></div><div id="41682030" class="c"><input type="checkbox" id="c-41682030" checked=""/><div class="controls bullet"><span class="by">scheme271</span><span>|</span><a href="#41681945">parent</a><span>|</span><a href="#41681987">prev</a><span>|</span><a href="#41682974">next</a><span>|</span><label class="collapse" for="c-41682030">[-]</label><label class="expand" for="c-41682030">[2 more]</label></div><br/><div class="children"><div class="content">If time_t is unsigned, how do times before the unix epoch get represented?</div><br/><div id="41682401" class="c"><input type="checkbox" id="c-41682401" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41681945">root</a><span>|</span><a href="#41682030">parent</a><span>|</span><a href="#41682974">next</a><span>|</span><label class="collapse" for="c-41682401">[-]</label><label class="expand" for="c-41682401">[1 more]</label></div><br/><div class="children"><div class="content">They don&#x27;t, much like they already do not.  32-bit time_t has always been finite, and 1970 was a long, long time ago.  (See &quot;in some senses&quot; in my earlier comment.)</div><br/></div></div></div></div></div></div><div id="41682974" class="c"><input type="checkbox" id="c-41682974" checked=""/><div class="controls bullet"><span class="by">ddoolin</span><span>|</span><a href="#41681945">prev</a><span>|</span><a href="#41684174">next</a><span>|</span><label class="collapse" for="c-41682974">[-]</label><label class="expand" for="c-41682974">[8 more]</label></div><br/><div class="children"><div class="content">Why was it 32 bits to begin with? Wasn&#x27;t it known that 2038 would be the cutoff?</div><br/><div id="41683067" class="c"><input type="checkbox" id="c-41683067" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#41682974">parent</a><span>|</span><a href="#41683042">next</a><span>|</span><label class="collapse" for="c-41683067">[-]</label><label class="expand" for="c-41683067">[1 more]</label></div><br/><div class="children"><div class="content">It has been that way since Unix V4 which released in 1973. Back then moving to something that breaks after 65 years was a massive upgrade over the old format that wrapped after two and a half years. And at least from the standpoint of Unix engineers 32 bits was more than enough: Nobody is using Unix V4 in production in 2024, never mind 2038.<p>Why it made it into Posix and wasn&#x27;t updated is a different question that&#x27;s a bit more difficult to answer</div><br/></div></div><div id="41683042" class="c"><input type="checkbox" id="c-41683042" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41682974">parent</a><span>|</span><a href="#41683067">prev</a><span>|</span><a href="#41683070">next</a><span>|</span><label class="collapse" for="c-41683042">[-]</label><label class="expand" for="c-41683042">[1 more]</label></div><br/><div class="children"><div class="content">It was not exactly a big concern when this was designed in early 70s, especially when you consider that Unix itself was kind of a hack at the time.</div><br/></div></div><div id="41683070" class="c"><input type="checkbox" id="c-41683070" checked=""/><div class="controls bullet"><span class="by">modeless</span><span>|</span><a href="#41682974">parent</a><span>|</span><a href="#41683042">prev</a><span>|</span><a href="#41682998">next</a><span>|</span><label class="collapse" for="c-41683070">[-]</label><label class="expand" for="c-41683070">[3 more]</label></div><br/><div class="children"><div class="content">In the 1970s people probably would have laughed at the idea that Unix would still be running in the year 2038.</div><br/><div id="41683821" class="c"><input type="checkbox" id="c-41683821" checked=""/><div class="controls bullet"><span class="by">ddoolin</span><span>|</span><a href="#41682974">root</a><span>|</span><a href="#41683070">parent</a><span>|</span><a href="#41682998">next</a><span>|</span><label class="collapse" for="c-41683821">[-]</label><label class="expand" for="c-41683821">[2 more]</label></div><br/><div class="children"><div class="content">I get that; I am surprised to find my own software running 7 years later, let alone ~60 and given the context.</div><br/><div id="41685073" class="c"><input type="checkbox" id="c-41685073" checked=""/><div class="controls bullet"><span class="by">PHGamer</span><span>|</span><a href="#41682974">root</a><span>|</span><a href="#41683821">parent</a><span>|</span><a href="#41682998">next</a><span>|</span><label class="collapse" for="c-41685073">[-]</label><label class="expand" for="c-41685073">[1 more]</label></div><br/><div class="children"><div class="content">well sometimes the old stuff is better than the new stuff. it really is hilarious though. things in the software world have regressed in some ways especially when it comes to privacy and locking down data.</div><br/></div></div></div></div></div></div><div id="41682998" class="c"><input type="checkbox" id="c-41682998" checked=""/><div class="controls bullet"><span class="by">NegativeLatency</span><span>|</span><a href="#41682974">parent</a><span>|</span><a href="#41683070">prev</a><span>|</span><a href="#41683036">next</a><span>|</span><label class="collapse" for="c-41682998">[-]</label><label class="expand" for="c-41682998">[1 more]</label></div><br/><div class="children"><div class="content">Ultimately probably hardware? I suspect itâs also been like this for a long time.</div><br/></div></div><div id="41683036" class="c"><input type="checkbox" id="c-41683036" checked=""/><div class="controls bullet"><span class="by">jdndhdhd</span><span>|</span><a href="#41682974">parent</a><span>|</span><a href="#41682998">prev</a><span>|</span><a href="#41684174">next</a><span>|</span><label class="collapse" for="c-41683036">[-]</label><label class="expand" for="c-41683036">[1 more]</label></div><br/><div class="children"><div class="content">Why is it 64 bit now? Isn&#x27;t it know that 292277026596 would be the cutoff?</div><br/></div></div></div></div><div id="41684174" class="c"><input type="checkbox" id="c-41684174" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41682974">prev</a><span>|</span><a href="#41683594">next</a><span>|</span><label class="collapse" for="c-41684174">[-]</label><label class="expand" for="c-41684174">[1 more]</label></div><br/><div class="children"><div class="content">All those arguments apply to off_t also. If a small-file executable with 32 bit off_t uses a large-file library with 64 bit off_t, there is no protection. Only glibc has the multiply implemented functions, selected by header file macrology.</div><br/></div></div><div id="41683594" class="c"><input type="checkbox" id="c-41683594" checked=""/><div class="controls bullet"><span class="by">rini17</span><span>|</span><a href="#41684174">prev</a><span>|</span><a href="#41682587">next</a><span>|</span><label class="collapse" for="c-41683594">[-]</label><label class="expand" for="c-41683594">[1 more]</label></div><br/><div class="children"><div class="content">Hope Gentoo alone won&#x27;t get overburdened with the development and maintenance of such hybrid toolchain, to be able to compile and run time32 processes alongside time64. When everyone else has moved on. Better do a complete reinstall from stage3.</div><br/></div></div><div id="41682587" class="c"><input type="checkbox" id="c-41682587" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#41683594">prev</a><span>|</span><a href="#41683619">next</a><span>|</span><label class="collapse" for="c-41682587">[-]</label><label class="expand" for="c-41682587">[1 more]</label></div><br/><div class="children"><div class="content">I think we should start putting details of the ABI in ELF (not the compiler flags as a string). Wait.. Who owns the ELF spec??<p>Then the linker and loader could error if two incompatible objects with different ABIs were attempted to be linked together.<p>For instance, I suspect you could have fields to denote the size of certain types. I guess DWARF has that... But DWARF is optional and sucks to parse.</div><br/></div></div><div id="41683619" class="c"><input type="checkbox" id="c-41683619" checked=""/><div class="controls bullet"><span class="by">malkia</span><span>|</span><a href="#41682587">prev</a><span>|</span><a href="#41683247">next</a><span>|</span><label class="collapse" for="c-41683619">[-]</label><label class="expand" for="c-41683619">[1 more]</label></div><br/><div class="children"><div class="content">Microsoft&#x27;s famous (infamous?) &quot;A&quot; &#x2F; &quot;W&quot; functions and macros controlling them -... but it works and one can link two different versions no problem. Wonder if that was possible here?</div><br/></div></div><div id="41683247" class="c"><input type="checkbox" id="c-41683247" checked=""/><div class="controls bullet"><span class="by">ok123456</span><span>|</span><a href="#41683619">prev</a><span>|</span><a href="#41682170">next</a><span>|</span><label class="collapse" for="c-41683247">[-]</label><label class="expand" for="c-41683247">[1 more]</label></div><br/><div class="children"><div class="content">What about making time_t 64-bit across all profiles and incrementing all the profile versions by one? Gentoo users are used to breaking changes when upgrading profiles.</div><br/></div></div><div id="41681907" class="c"><input type="checkbox" id="c-41681907" checked=""/><div class="controls bullet"><span class="by">fred_is_fred</span><span>|</span><a href="#41682170">prev</a><span>|</span><a href="#41682177">next</a><span>|</span><label class="collapse" for="c-41681907">[-]</label><label class="expand" for="c-41681907">[11 more]</label></div><br/><div class="children"><div class="content">Besides epoch time and the LFS support mentioned, are there any other 32-bit bombs waiting for Linux systems like this?</div><br/><div id="41682355" class="c"><input type="checkbox" id="c-41682355" checked=""/><div class="controls bullet"><span class="by">tredre3</span><span>|</span><a href="#41681907">parent</a><span>|</span><a href="#41682076">next</a><span>|</span><label class="collapse" for="c-41682355">[-]</label><label class="expand" for="c-41682355">[4 more]</label></div><br/><div class="children"><div class="content">The ext file system uses many 32bit counters. Admittedly, version 4 fixed most of that (when formatted with the correct options).</div><br/><div id="41682495" class="c"><input type="checkbox" id="c-41682495" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41681907">root</a><span>|</span><a href="#41682355">parent</a><span>|</span><a href="#41682076">next</a><span>|</span><label class="collapse" for="c-41682495">[-]</label><label class="expand" for="c-41682495">[3 more]</label></div><br/><div class="children"><div class="content">In a similar vein, inodes can run out. On most conventional Linux file systems, inode numbers are 32 bits.<p>For many, this is not going to be a practical problem yet, as real volumes will run out of usable space before exhausting 2^32 inodes. However, it is theoretically possible with a volume as small as ~18 TiB (using 16 TiB for 2^32 4096-byte or smaller files, 1-2 TiB for 2^32 256- or 512-byte inodes, plus file system overheads).<p>Anticipating this problem, most newer file systems use 64-bit inode numbers, and some older ones have been retrofitted (e.g. inode64 option in XFS). I don&#x27;t think ext4 is one of them, though.</div><br/><div id="41682705" class="c"><input type="checkbox" id="c-41682705" checked=""/><div class="controls bullet"><span class="by">lclarkmichalek</span><span>|</span><a href="#41681907">root</a><span>|</span><a href="#41682495">parent</a><span>|</span><a href="#41682076">next</a><span>|</span><label class="collapse" for="c-41682705">[-]</label><label class="expand" for="c-41682705">[2 more]</label></div><br/><div class="children"><div class="content">It does happen in prod. Usually due to virtual FSes that rely on get_next_ino: <a href="https:&#x2F;&#x2F;lkml.org&#x2F;lkml&#x2F;2020&#x2F;7&#x2F;13&#x2F;1078" rel="nofollow">https:&#x2F;&#x2F;lkml.org&#x2F;lkml&#x2F;2020&#x2F;7&#x2F;13&#x2F;1078</a></div><br/><div id="41685259" class="c"><input type="checkbox" id="c-41685259" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41681907">root</a><span>|</span><a href="#41682705">parent</a><span>|</span><a href="#41682076">next</a><span>|</span><label class="collapse" for="c-41685259">[-]</label><label class="expand" for="c-41685259">[1 more]</label></div><br/><div class="children"><div class="content">That method is wrapping and not checking for collisions?  I would not call that a problem of <i>running out</i> then.  It&#x27;s a cheap but dumb generator that needs extra bits to not break itself.</div><br/></div></div></div></div></div></div></div></div><div id="41682076" class="c"><input type="checkbox" id="c-41682076" checked=""/><div class="controls bullet"><span class="by">fph</span><span>|</span><a href="#41681907">parent</a><span>|</span><a href="#41682355">prev</a><span>|</span><a href="#41682177">next</a><span>|</span><label class="collapse" for="c-41682076">[-]</label><label class="expand" for="c-41682076">[6 more]</label></div><br/><div class="children"><div class="content">IPv4, technically, is another 32-bit bomb, but that&#x27;s not Linux-specific.</div><br/><div id="41682371" class="c"><input type="checkbox" id="c-41682371" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#41681907">root</a><span>|</span><a href="#41682076">parent</a><span>|</span><a href="#41682177">next</a><span>|</span><label class="collapse" for="c-41682371">[-]</label><label class="expand" for="c-41682371">[5 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t call this a bomb at all. Bombs are events, not processes.<p>Resource contention for IPv4 has been around for a long time, with a number of workarounds and the ultimate out of supporting IPv6.  There has been, to date, no moment of crisis, nor do I expect one in the future.<p>It will just get steadily more annoying&#x2F;expensive to use IPv4 and IPv6 will relieve that pressure incrementally.  We&#x27;re at least two decades into that process already.</div><br/><div id="41682555" class="c"><input type="checkbox" id="c-41682555" checked=""/><div class="controls bullet"><span class="by">poincaredisk</span><span>|</span><a href="#41681907">root</a><span>|</span><a href="#41682371">parent</a><span>|</span><a href="#41682465">next</a><span>|</span><label class="collapse" for="c-41682555">[-]</label><label class="expand" for="c-41682555">[3 more]</label></div><br/><div class="children"><div class="content">Two decades in, and IPv6 is still the more annoying option.<p>I wish they were less ambitious and just increased address sizes when designing ipv6.</div><br/><div id="41684413" class="c"><input type="checkbox" id="c-41684413" checked=""/><div class="controls bullet"><span class="by">icedchai</span><span>|</span><a href="#41681907">root</a><span>|</span><a href="#41682555">parent</a><span>|</span><a href="#41682465">next</a><span>|</span><label class="collapse" for="c-41684413">[-]</label><label class="expand" for="c-41684413">[2 more]</label></div><br/><div class="children"><div class="content">If more people bothered to configure IPv6 instead of complaining about it, V4 would be a thing of the past already.</div><br/><div id="41684619" class="c"><input type="checkbox" id="c-41684619" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41681907">root</a><span>|</span><a href="#41684413">parent</a><span>|</span><a href="#41682465">next</a><span>|</span><label class="collapse" for="c-41684619">[-]</label><label class="expand" for="c-41684619">[1 more]</label></div><br/><div class="children"><div class="content">A lot of people don&#x27;t have a choice.<p>Just last(?) year I finally switched to an ISP whose equipment supports IPv6. But I still can&#x27;t actually use it since my wifi router&#x27;s support for IPv6 somehow fails to talk to the ISP equipment.<p>Hm, there&#x27;s a firmware upgrade ... (installs it) well, re-trying all those options again, it looks like <i>one</i> of them lets it finally work now. The others (including the default) still fail with arcane errors though!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41682177" class="c"><input type="checkbox" id="c-41682177" checked=""/><div class="controls bullet"><span class="by">dark-star</span><span>|</span><a href="#41681907">prev</a><span>|</span><a href="#41681829">next</a><span>|</span><label class="collapse" for="c-41682177">[-]</label><label class="expand" for="c-41682177">[4 more]</label></div><br/><div class="children"><div class="content">Are there other distros where the switch to 64-bit time_t has already happened? What&#x27;s the easiest way to figure out whether $distro uses 32-bit or 64-bit time_t? Is there something easier&#x2F;quicker than writing a program to print `sizeof(struct stat)` and check if that&#x27;s 88, 96 or 1098 bytes (as hinted in the article)?</div><br/><div id="41682478" class="c"><input type="checkbox" id="c-41682478" checked=""/><div class="controls bullet"><span class="by">SAI_Peregrinus</span><span>|</span><a href="#41682177">parent</a><span>|</span><a href="#41682291">next</a><span>|</span><label class="collapse" for="c-41682478">[-]</label><label class="expand" for="c-41682478">[1 more]</label></div><br/><div class="children"><div class="content">NixOS switched. And they&#x27;re source-based, but with actual dependency tracking and all the (insanely complex) machinery needed to allow different programs to use different C library versions simultaneously.<p>`printf(&quot;sizeof (time_t) = %zu, %zu bits&quot;, sizeof (time_t), sizeof (time_t) * CHAR_BIT);` gives you the size in bytes and in bits. Needs time.h, stddef.h, and stdio.h.</div><br/></div></div><div id="41682291" class="c"><input type="checkbox" id="c-41682291" checked=""/><div class="controls bullet"><span class="by">teddyh</span><span>|</span><a href="#41682177">parent</a><span>|</span><a href="#41682478">prev</a><span>|</span><a href="#41682383">next</a><span>|</span><label class="collapse" for="c-41682291">[-]</label><label class="expand" for="c-41682291">[1 more]</label></div><br/><div class="children"><div class="content">Like the article says, Debian has already switched.</div><br/></div></div><div id="41682383" class="c"><input type="checkbox" id="c-41682383" checked=""/><div class="controls bullet"><span class="by">jonathrg</span><span>|</span><a href="#41682177">parent</a><span>|</span><a href="#41682291">prev</a><span>|</span><a href="#41681829">next</a><span>|</span><label class="collapse" for="c-41682383">[-]</label><label class="expand" for="c-41682383">[1 more]</label></div><br/><div class="children"><div class="content">printf &#x27;#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\nint main() { printf(&quot;time_t is %%zu-bit\\n&quot;, sizeof(time_t)*8); }\n&#x27; | gcc -x c -o timesize - &amp;&amp; .&#x2F;timesize &amp;&amp; rm .&#x2F;timesize<p>If you&#x27;re wondering about a specific distro that you&#x27;re not using right now - just look it up.</div><br/></div></div></div></div><div id="41681829" class="c"><input type="checkbox" id="c-41681829" checked=""/><div class="controls bullet"><span class="by">BoingBoomTschak</span><span>|</span><a href="#41682177">prev</a><span>|</span><a href="#41682524">next</a><span>|</span><label class="collapse" for="c-41681829">[-]</label><label class="expand" for="c-41681829">[1 more]</label></div><br/><div class="children"><div class="content">A very thoughtful way of handling a problem much trickier than the earlier &#x2F;usr merge. Had thought about 2 but not 1 and 3. I also had kinda forgotten that 2038 thing, time sure is flying!<p>I must say, mgorny&#x27;s posts are always a treat for those who like to peer under the hood! (The fact that Gentoo has remained my happy place for years doesn&#x27;t influence this position, though there&#x27;s probably some correlation)</div><br/></div></div><div id="41682524" class="c"><input type="checkbox" id="c-41682524" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41681829">prev</a><span>|</span><a href="#41682089">next</a><span>|</span><label class="collapse" for="c-41682524">[-]</label><label class="expand" for="c-41682524">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The second part is much harder. Obviously, as soon as weâre past the 2038 cutoff date, all 32-bit programs â using system libraries or not â will simply start failing in horrible ways. One possibility is to work with faketime to control the system clock. Another is to run a whole VM thatâs moved back in time.<p>Yet another is to freeze the time for those programs at the last 32-bit POSIX second. They would just appear to execute incredibly fast :). Of course some will still break, and itâs obviously not suitable for many use cases (but neither is running in the past), but some might be just fine.</div><br/></div></div><div id="41684477" class="c"><input type="checkbox" id="c-41684477" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#41682089">prev</a><span>|</span><a href="#41682490">next</a><span>|</span><label class="collapse" for="c-41684477">[-]</label><label class="expand" for="c-41684477">[1 more]</label></div><br/><div class="children"><div class="content">LFS should have become mandatory.</div><br/></div></div><div id="41682490" class="c"><input type="checkbox" id="c-41682490" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#41684477">prev</a><span>|</span><a href="#41682444">next</a><span>|</span><label class="collapse" for="c-41682490">[-]</label><label class="expand" for="c-41682490">[4 more]</label></div><br/><div class="children"><div class="content">Are we still keeping shared libraries? They are a complex solution to a problem that arguably stopped existing 20 years ago. Might be time to rethink the entire scheme.</div><br/><div id="41682572" class="c"><input type="checkbox" id="c-41682572" checked=""/><div class="controls bullet"><span class="by">filmor</span><span>|</span><a href="#41682490">parent</a><span>|</span><a href="#41683127">next</a><span>|</span><label class="collapse" for="c-41682572">[-]</label><label class="expand" for="c-41682572">[2 more]</label></div><br/><div class="children"><div class="content">On Gentoo, definitely. I really don&#x27;t want to rebuild my whole system whenever some foundational library fixes a bug. It already annoys me quite a bit that I need to set up sccache to get half-way reasonable compile times out of Rust projects (and I&#x27;m saying that as someone who enjoys gradually replacing significant portions of the userspace with Rust tools).</div><br/><div id="41684050" class="c"><input type="checkbox" id="c-41684050" checked=""/><div class="controls bullet"><span class="by">AshamedCaptain</span><span>|</span><a href="#41682490">root</a><span>|</span><a href="#41682572">parent</a><span>|</span><a href="#41683127">next</a><span>|</span><label class="collapse" for="c-41684050">[-]</label><label class="expand" for="c-41684050">[1 more]</label></div><br/><div class="children"><div class="content">This by itself is half the reason I think Nix&#x27;s approach is a step backwards.</div><br/></div></div></div></div><div id="41683127" class="c"><input type="checkbox" id="c-41683127" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#41682490">parent</a><span>|</span><a href="#41682572">prev</a><span>|</span><a href="#41682444">next</a><span>|</span><label class="collapse" for="c-41683127">[-]</label><label class="expand" for="c-41683127">[1 more]</label></div><br/><div class="children"><div class="content">The Docker image layers you so dearly love are an implementation of shared libraries, except done in a broken way that&#x27;s a thousand times less performant and more insecure.</div><br/></div></div></div></div><div id="41682444" class="c"><input type="checkbox" id="c-41682444" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41682490">prev</a><span>|</span><label class="collapse" for="c-41682444">[-]</label><label class="expand" for="c-41682444">[3 more]</label></div><br/><div class="children"><div class="content">The simplest thing to do is to make any 32-bit `time_t`s be unsigned.  That buys another 68 years to get the transition done.  Not that that&#x27;s exactly easy, but it&#x27;s easier than switching to 64-bit time_t.</div><br/><div id="41683538" class="c"><input type="checkbox" id="c-41683538" checked=""/><div class="controls bullet"><span class="by">rini17</span><span>|</span><a href="#41682444">parent</a><span>|</span><label class="collapse" for="c-41683538">[-]</label><label class="expand" for="c-41683538">[2 more]</label></div><br/><div class="children"><div class="content">You believe it will get somehow easier in 60 years?</div><br/><div id="41684124" class="c"><input type="checkbox" id="c-41684124" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41682444">root</a><span>|</span><a href="#41683538">parent</a><span>|</span><label class="collapse" for="c-41684124">[-]</label><label class="expand" for="c-41684124">[1 more]</label></div><br/><div class="children"><div class="content">Yes!<p>For one, none of us will be the ones dealing with it, but more seriously, by then 32-bit Unix&#x2F;Linux ABIs will be gone.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>