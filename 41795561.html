<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728550878897" as="style"/><link rel="stylesheet" href="styles.css?v=1728550878897"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://roborooter.com/post/wasm-is-the-new-cgi/">WASM Is the New CGI</a> <span class="domain">(<a href="https://roborooter.com">roborooter.com</a>)</span></div><div class="subtext"><span>burglins</span> | <span>120 comments</span></div><br/><div><div id="41795944" class="c"><input type="checkbox" id="c-41795944" checked=""/><div class="controls bullet"><span class="by">cheema33</span><span>|</span><a href="#41795946">next</a><span>|</span><label class="collapse" for="c-41795944">[-]</label><label class="expand" for="c-41795944">[34 more]</label></div><br/><div class="children"><div class="content">I have a different take on this.  I think local-first is the future.  This is where the apps runs mostly within user&#x27;s browser with little to no help from the server.  Apps like Figma, Linear and Superhuman use this model very successfully.  And to some degree Stackblitz does as well.<p>If somewhat complex apps like Figma can run almost entirely within user&#x27;s browser, then I think vast majority of the apps out there can. Server side mostly is there to sync data between different instances of the app if the user uses it from different locations.<p>The tooling for this is in the works, but is not yet mature.  e.g Electric-SQL.  Once these libraries are mature, I think this space will take off.<p>Serverless is mostly there to make money for Amazon and Azures of the world and will eventually go the way of the CGI.<p>WASM could succeed as well.  But mostly in user&#x27;s browser.  Microsoft uses it today for C#&#x2F;Blazor.  But it isn&#x27;t the correct approach as dotnet in browser will likely never be as fast as Javascript in the browser.</div><br/><div id="41796093" class="c"><input type="checkbox" id="c-41796093" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#41795944">parent</a><span>|</span><a href="#41796021">next</a><span>|</span><label class="collapse" for="c-41796093">[-]</label><label class="expand" for="c-41796093">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Serverless is mostly there to make money for Amazon and Azures of the world and will eventually go the way of the CGI.<p>CGI empowers users and small sites. No one talks about it because you can&#x27;t scale to a trillion add impressions a second on it. Serverless functions add 10 feet to Bazoz&#x27;s yacht every time someone writes one.</div><br/></div></div><div id="41796021" class="c"><input type="checkbox" id="c-41796021" checked=""/><div class="controls bullet"><span class="by">mattdesl</span><span>|</span><a href="#41795944">parent</a><span>|</span><a href="#41796093">prev</a><span>|</span><a href="#41796193">next</a><span>|</span><label class="collapse" for="c-41796021">[-]</label><label class="expand" for="c-41796021">[8 more]</label></div><br/><div class="children"><div class="content">I’m not sure I’d call Figma local first. If I’m offline or in a spotty wifi area, I can’t load my designs. And unless it’s recently changed, if you lose wifi and quit the browser after some edits, they won’t be saved.</div><br/><div id="41796070" class="c"><input type="checkbox" id="c-41796070" checked=""/><div class="controls bullet"><span class="by">curtisblaine</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796021">parent</a><span>|</span><a href="#41796193">next</a><span>|</span><label class="collapse" for="c-41796070">[-]</label><label class="expand" for="c-41796070">[7 more]</label></div><br/><div class="children"><div class="content">That&#x27;s intentional: they need you and your data tied to the server to make money. But there&#x27;s no reason why it couldn&#x27;t be local first (except the business model), since the bulk of execution is local.<p>Incidentally, I think that&#x27;s why local-first didn&#x27;t take off yet: it&#x27;s difficult to monetize and it&#x27;s almost impossible to monetize to the extent of server-based or server-less. If your application code is completely local, software producers are back to copy-protection schemes. If your data is completely local, you can migrate it to another app easily, which is good for the user but bad for the companies. It would be great to have more smaller companies embracing local-first instead of tech behemoths monopolizing resources, but I don&#x27;t see an easy transition to that state of things.</div><br/><div id="41796101" class="c"><input type="checkbox" id="c-41796101" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796070">parent</a><span>|</span><a href="#41796193">next</a><span>|</span><label class="collapse" for="c-41796101">[-]</label><label class="expand" for="c-41796101">[6 more]</label></div><br/><div class="children"><div class="content">&gt;Incidentally, I think that&#x27;s why local-first didn&#x27;t take off yet<p>Local first is what we had all throughout the 80s to 10s. It&#x27;s just that you can make a lot more from people who rent your software rather than buy it.</div><br/><div id="41796802" class="c"><input type="checkbox" id="c-41796802" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796101">parent</a><span>|</span><a href="#41796205">next</a><span>|</span><label class="collapse" for="c-41796802">[-]</label><label class="expand" for="c-41796802">[1 more]</label></div><br/><div class="children"><div class="content">The sweet, sweet ARR. Investors love it, banks love it, employees should also love it since it makes their paychecks predictable.<p>It sucks for customers, though.</div><br/></div></div><div id="41796205" class="c"><input type="checkbox" id="c-41796205" checked=""/><div class="controls bullet"><span class="by">OtomotO</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796101">parent</a><span>|</span><a href="#41796802">prev</a><span>|</span><a href="#41796193">next</a><span>|</span><label class="collapse" for="c-41796205">[-]</label><label class="expand" for="c-41796205">[4 more]</label></div><br/><div class="children"><div class="content">More and more reliably.<p>When people have an abo that cannot be quit every month it gives more financial security to the company.<p>Previously people would buy e.g. the creative suite from Adobe and then work with that version for many, many years to come</div><br/><div id="41796355" class="c"><input type="checkbox" id="c-41796355" checked=""/><div class="controls bullet"><span class="by">curtisblaine</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796205">parent</a><span>|</span><a href="#41796193">next</a><span>|</span><label class="collapse" for="c-41796355">[-]</label><label class="expand" for="c-41796355">[3 more]</label></div><br/><div class="children"><div class="content">Previously people would <i>crack</i> CS from Adobe then work with that version for many, many years to come :)</div><br/><div id="41796588" class="c"><input type="checkbox" id="c-41796588" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796355">parent</a><span>|</span><a href="#41796193">next</a><span>|</span><label class="collapse" for="c-41796588">[-]</label><label class="expand" for="c-41796588">[2 more]</label></div><br/><div class="children"><div class="content">True but do all those peeople now pay $100 a month to Adobe? Hardly.</div><br/><div id="41796721" class="c"><input type="checkbox" id="c-41796721" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796588">parent</a><span>|</span><a href="#41796193">next</a><span>|</span><label class="collapse" for="c-41796721">[-]</label><label class="expand" for="c-41796721">[1 more]</label></div><br/><div class="children"><div class="content">If they need what Adobe offers, yes.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41796193" class="c"><input type="checkbox" id="c-41796193" checked=""/><div class="controls bullet"><span class="by">torginus</span><span>|</span><a href="#41795944">parent</a><span>|</span><a href="#41796021">prev</a><span>|</span><a href="#41796768">next</a><span>|</span><label class="collapse" for="c-41796193">[-]</label><label class="expand" for="c-41796193">[7 more]</label></div><br/><div class="children"><div class="content">Hehehe, so the future is how we used to run applications from before the era of the web.</div><br/><div id="41796234" class="c"><input type="checkbox" id="c-41796234" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796193">parent</a><span>|</span><a href="#41796494">next</a><span>|</span><label class="collapse" for="c-41796234">[-]</label><label class="expand" for="c-41796234">[3 more]</label></div><br/><div class="children"><div class="content">Except with runtime safety, no installation process, no pointless scare popups when trying to run an app directly downloaded from the internet, and trivial distribution without random app store publishing rules getting in the way.<p>In a way - yes - it&#x27;s almost like it was before the internet, but mostly because other ways to distribute and run applications have become such a hassle, partly for security reasons, but mostly for gatekeeping reasons by the &quot;platform owners&quot;.</div><br/><div id="41796359" class="c"><input type="checkbox" id="c-41796359" checked=""/><div class="controls bullet"><span class="by">torginus</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796234">parent</a><span>|</span><a href="#41796494">next</a><span>|</span><label class="collapse" for="c-41796359">[-]</label><label class="expand" for="c-41796359">[2 more]</label></div><br/><div class="children"><div class="content">Apps like these were incredibly common on Windows from the late 90s-early 2010s era. They could do all this (except for the sandboxing thing). You just downloaded a single .exe file, and it ran self-contained, with all its dependencies statically linked, and it would work on practically any system.<p>On MacOS, the user facing model is still that you download an application, drop it 
in the Applications folder, and it works.</div><br/><div id="41796368" class="c"><input type="checkbox" id="c-41796368" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796359">parent</a><span>|</span><a href="#41796494">next</a><span>|</span><label class="collapse" for="c-41796368">[-]</label><label class="expand" for="c-41796368">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You just downloaded a single .exe file, and it ran self-contained, with all its dependencies statically linked, and it would work on practically any system.<p>Yeah, but try that today (and even by 2010 that wouldn&#x27;t work anymore). Windows will show a scare popup with a very hard to find &#x27;run anyway&#x27; button, unless your application download is above a certain &#x27;reputation score&#x27; or is code-signed with an expensive EV certificate.<p>&gt; On MacOS, the user facing model is still that you download an application, drop it in the Applications folder, and it works.<p>Not really, macOS will tell you that it cannot verify that the app doesn&#x27;t do any harm and helpfully offer to move the application into the trash bin (unless the app is signed and notarized - for which you&#x27;ll need an Apple developer account, and AFAIK even then there will be a &#x27;mild&#x27; warning popup that the app has been downloaded from the internet and whether you want to run it anyway). Apple is definitely nudging developers towards the app store, even on macOS.</div><br/></div></div></div></div></div></div><div id="41796494" class="c"><input type="checkbox" id="c-41796494" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796193">parent</a><span>|</span><a href="#41796234">prev</a><span>|</span><a href="#41796768">next</a><span>|</span><label class="collapse" for="c-41796494">[-]</label><label class="expand" for="c-41796494">[3 more]</label></div><br/><div class="children"><div class="content">Except worse, because everything has to run in a gigantic web browser even if it could be a small native app.</div><br/><div id="41796975" class="c"><input type="checkbox" id="c-41796975" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796494">parent</a><span>|</span><a href="#41796732">next</a><span>|</span><label class="collapse" for="c-41796975">[-]</label><label class="expand" for="c-41796975">[1 more]</label></div><br/><div class="children"><div class="content">Every native app has to be run in a gigantic special OS when it could be a small webapps running in a medium sized browser.<p>Many many ChromeOS (web based consumer OS) laptops are 4GB of ram. You do not want to try that with any normal OSes.</div><br/></div></div><div id="41796732" class="c"><input type="checkbox" id="c-41796732" checked=""/><div class="controls bullet"><span class="by">adwn</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796494">parent</a><span>|</span><a href="#41796975">prev</a><span>|</span><a href="#41796768">next</a><span>|</span><label class="collapse" for="c-41796732">[-]</label><label class="expand" for="c-41796732">[1 more]</label></div><br/><div class="children"><div class="content">Except better, because it doesn&#x27;t only work on Windows, and because I don&#x27;t invite a dozen viruses into my computer.</div><br/></div></div></div></div></div></div><div id="41796768" class="c"><input type="checkbox" id="c-41796768" checked=""/><div class="controls bullet"><span class="by">silvestrov</span><span>|</span><a href="#41795944">parent</a><span>|</span><a href="#41796193">prev</a><span>|</span><a href="#41796232">next</a><span>|</span><label class="collapse" for="c-41796768">[-]</label><label class="expand" for="c-41796768">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Figma can  [...] then I think vast majority of the apps out there can<p>This doesn&#x27;t follow.   If Figma has the best of the best developers then most businesses might not be able to write just as complex apps.<p>C++ is a good example of a language that requires high programming skills to be usable at all.  This is one of the reasons PHP became popular.</div><br/></div></div><div id="41796232" class="c"><input type="checkbox" id="c-41796232" checked=""/><div class="controls bullet"><span class="by">moi2388</span><span>|</span><a href="#41795944">parent</a><span>|</span><a href="#41796768">prev</a><span>|</span><a href="#41796126">next</a><span>|</span><label class="collapse" for="c-41796232">[-]</label><label class="expand" for="c-41796232">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Microsoft uses it today for C#&#x2F;Blazor. But it isn&#x27;t the correct approach as dotnet in browser will likely never be as fast as Javascript in the browser.<p>Might be true, but both will be more than fast enough. We develop Blazer WASM. When it comes to performance, dotnet is not the issue</div><br/><div id="41796552" class="c"><input type="checkbox" id="c-41796552" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796232">parent</a><span>|</span><a href="#41796126">next</a><span>|</span><label class="collapse" for="c-41796552">[-]</label><label class="expand" for="c-41796552">[1 more]</label></div><br/><div class="children"><div class="content">Yep. And when wasmgc is stable &amp; widely adopted, apps built using blazer will probably end up smaller than their equivalent rust+wasm counterparts, since .net apps won’t need to ship an allocator.</div><br/></div></div></div></div><div id="41796126" class="c"><input type="checkbox" id="c-41796126" checked=""/><div class="controls bullet"><span class="by">smolder</span><span>|</span><a href="#41795944">parent</a><span>|</span><a href="#41796232">prev</a><span>|</span><a href="#41796195">next</a><span>|</span><label class="collapse" for="c-41796126">[-]</label><label class="expand" for="c-41796126">[1 more]</label></div><br/><div class="children"><div class="content">I also support the development of client side applications, but I don&#x27;t think they should necessarily be run in a browser or sandbox or be bought through an app store, and it&#x27;s definitely not a new idea.</div><br/></div></div><div id="41796195" class="c"><input type="checkbox" id="c-41796195" checked=""/><div class="controls bullet"><span class="by">OtomotO</span><span>|</span><a href="#41795944">parent</a><span>|</span><a href="#41796126">prev</a><span>|</span><a href="#41796419">next</a><span>|</span><label class="collapse" for="c-41796195">[-]</label><label class="expand" for="c-41796195">[2 more]</label></div><br/><div class="children"><div class="content">I have a different take on this:<p>It depends on what you&#x27;re actually building.<p>For the business applications I build SSR (without any JS in the stack, but just golang or Rust or Zig) is the future.<p>It saves resources which in turn saves money, is way more reliable (again: money) and less complex (again: money) to syncing state all the time and having frontend state diverge from the actual (backend) state.</div><br/><div id="41796278" class="c"><input type="checkbox" id="c-41796278" checked=""/><div class="controls bullet"><span class="by">boomskats</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796195">parent</a><span>|</span><a href="#41796419">next</a><span>|</span><label class="collapse" for="c-41796278">[-]</label><label class="expand" for="c-41796278">[1 more]</label></div><br/><div class="children"><div class="content">I have a different take on this:<p>Business applications don&#x27;t care about client side resource utilisation. That resource has already been allocated and spent, and it&#x27;s not like their users can decide to walk away because their app takes an extra 250ms to render.<p>Client-side compute is the real money saver. This means CSR&#x2F;SPA&#x2F;PWA&#x2F;client-side state and things like WASM DuckDB and perspective over anything long-lived or computationally expensive on the backend.</div><br/></div></div></div></div><div id="41796419" class="c"><input type="checkbox" id="c-41796419" checked=""/><div class="controls bullet"><span class="by">createaccount99</span><span>|</span><a href="#41795944">parent</a><span>|</span><a href="#41796195">prev</a><span>|</span><a href="#41796031">next</a><span>|</span><label class="collapse" for="c-41796419">[-]</label><label class="expand" for="c-41796419">[2 more]</label></div><br/><div class="children"><div class="content">The frontend space is moving away from client-side state, not toward it.</div><br/><div id="41796469" class="c"><input type="checkbox" id="c-41796469" checked=""/><div class="controls bullet"><span class="by">bryanrasmussen</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796419">parent</a><span>|</span><a href="#41796031">next</a><span>|</span><label class="collapse" for="c-41796469">[-]</label><label class="expand" for="c-41796469">[1 more]</label></div><br/><div class="children"><div class="content">the frontend space is always moving in every direction at the same time, this is known as Schrodinger&#x27;s frontend, depending on when you look at it and what intentions you have - you may think you&#x27;re looking at the backend.</div><br/></div></div></div></div><div id="41796031" class="c"><input type="checkbox" id="c-41796031" checked=""/><div class="controls bullet"><span class="by">csomar</span><span>|</span><a href="#41795944">parent</a><span>|</span><a href="#41796419">prev</a><span>|</span><a href="#41796000">next</a><span>|</span><label class="collapse" for="c-41796031">[-]</label><label class="expand" for="c-41796031">[3 more]</label></div><br/><div class="children"><div class="content">At the end of the day, all you are doing is syncing state with the server. In the future, you&#x27;ll have a local state and a server state and the only server component is a sync Wasm binary hehe.<p>Still, you&#x27;ll be coding your front-end with Wasm&#x2F;Rust, so get in on the Rust train :)</div><br/><div id="41796053" class="c"><input type="checkbox" id="c-41796053" checked=""/><div class="controls bullet"><span class="by">meow_catrix</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796031">parent</a><span>|</span><a href="#41796557">next</a><span>|</span><label class="collapse" for="c-41796053">[-]</label><label class="expand" for="c-41796053">[1 more]</label></div><br/><div class="children"><div class="content">Rust frontend dev is not going to become mainstream, no matter what.</div><br/></div></div><div id="41796557" class="c"><input type="checkbox" id="c-41796557" checked=""/><div class="controls bullet"><span class="by">bryanrasmussen</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796031">parent</a><span>|</span><a href="#41796053">prev</a><span>|</span><a href="#41796000">next</a><span>|</span><label class="collapse" for="c-41796557">[-]</label><label class="expand" for="c-41796557">[1 more]</label></div><br/><div class="children"><div class="content">metaphorically, Rust train does not sound enticing.</div><br/></div></div></div></div><div id="41796000" class="c"><input type="checkbox" id="c-41796000" checked=""/><div class="controls bullet"><span class="by">jamil7</span><span>|</span><a href="#41795944">parent</a><span>|</span><a href="#41796031">prev</a><span>|</span><a href="#41796511">next</a><span>|</span><label class="collapse" for="c-41796000">[-]</label><label class="expand" for="c-41796000">[1 more]</label></div><br/><div class="children"><div class="content">I work on an iOS app like this right now, it predates a lot of these newer prebuilt solutions. There are some really nice features of working and building features this way, when it works well you can ignore networking code entirely. There are some tradeoffs though and a big one has been debugging and monitoring as well as migrations. There is also some level of end user education because the apps don’t always work the way they’re expecting. The industry the app serves is one in which people are working in the field, doing data entry on a tablet or phone with patchy connections.</div><br/></div></div><div id="41796511" class="c"><input type="checkbox" id="c-41796511" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#41795944">parent</a><span>|</span><a href="#41796000">prev</a><span>|</span><a href="#41796272">next</a><span>|</span><label class="collapse" for="c-41796511">[-]</label><label class="expand" for="c-41796511">[1 more]</label></div><br/><div class="children"><div class="content">CGI is alive and well. It’s still the easiest way to build small applications for browsers.</div><br/></div></div><div id="41796272" class="c"><input type="checkbox" id="c-41796272" checked=""/><div class="controls bullet"><span class="by">curtisblaine</span><span>|</span><a href="#41795944">parent</a><span>|</span><a href="#41796511">prev</a><span>|</span><a href="#41795946">next</a><span>|</span><label class="collapse" for="c-41796272">[-]</label><label class="expand" for="c-41796272">[4 more]</label></div><br/><div class="children"><div class="content">Some applications are inherently hard to make local-first. Social media and Internet forums come to mind. Heavily collaborative applications maybe too.</div><br/><div id="41796565" class="c"><input type="checkbox" id="c-41796565" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796272">parent</a><span>|</span><a href="#41795946">next</a><span>|</span><label class="collapse" for="c-41796565">[-]</label><label class="expand" for="c-41796565">[3 more]</label></div><br/><div class="children"><div class="content">I feel like social media is one of the main things folks want to be local-first. Own your own data, be able to browse&#x2F;post while offline, and then it all syncs to the big caches in the sky on reconnect...</div><br/><div id="41796728" class="c"><input type="checkbox" id="c-41796728" checked=""/><div class="controls bullet"><span class="by">curtisblaine</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796565">parent</a><span>|</span><a href="#41795946">next</a><span>|</span><label class="collapse" for="c-41796728">[-]</label><label class="expand" for="c-41796728">[2 more]</label></div><br/><div class="children"><div class="content">But how do you do that without essentially downloading the whole social network to your local machine? Are other people&#x27;s comments, quotes, likes, moderation signals something that should stay on the server or should be synced to the client for offline use? In the first case, you can&#x27;t really use the social network without connecting to a server. The second case is a privacy and resources nightmare (privacy, because you can hold posts and comments from users that have deleted their data or banned you, you can see who follows who etc. Resources, because you need to hold the whole social graph in your local client).</div><br/><div id="41796756" class="c"><input type="checkbox" id="c-41796756" checked=""/><div class="controls bullet"><span class="by">curtisblaine</span><span>|</span><a href="#41795944">root</a><span>|</span><a href="#41796728">parent</a><span>|</span><a href="#41795946">next</a><span>|</span><label class="collapse" for="c-41796756">[-]</label><label class="expand" for="c-41796756">[1 more]</label></div><br/><div class="children"><div class="content">(unless you want another paradigm of social networking in which you don&#x27;t have likes, public follows, replies etc., which won&#x27;t probably fly because it has a much worse UX compared to established social networks)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41795946" class="c"><input type="checkbox" id="c-41795946" checked=""/><div class="controls bullet"><span class="by">junto</span><span>|</span><a href="#41795944">prev</a><span>|</span><a href="#41796791">next</a><span>|</span><label class="collapse" for="c-41795946">[-]</label><label class="expand" for="c-41795946">[21 more]</label></div><br/><div class="children"><div class="content">Can someone explain to me what the difference really is between WASM and older tech like Java Applets, ActiveX, Silverlight and Macromedia Flash, because they don’t really sound much different to me. Maybe I’m just old, but I thought we’d learnt our lesson on running untrusted third party compiled code in a web browser. In all of these cases it’s pitched as improving the customer experience but also conveniently pushes the computational cost from server to client.</div><br/><div id="41796175" class="c"><input type="checkbox" id="c-41796175" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#41795946">parent</a><span>|</span><a href="#41796108">next</a><span>|</span><label class="collapse" for="c-41796175">[-]</label><label class="expand" for="c-41796175">[3 more]</label></div><br/><div class="children"><div class="content">Java and Flash failed to deliver its promise of unbreakable sandbox where one could run anything without risking compromising host. They tried, but their implementations were ridden with vulnerabilities and eventually browsers made them unusable. Other mentioned technologies didn&#x27;t even promise that, I think.<p>JavaScript did deliver its promise of unbreakable sandbox and nowadays browser runs JavaScript, downloaded from any domain without asking user whether he trusts it or not.<p>WASM builds on JavaScript engine, delivering similar security guarantees.<p>So there&#x27;s no fundamental difference between WASM and JVM bytecode. There&#x27;s only practical difference: WASM proved to be secure and JVM did not.<p>So now Google Chrome is secure enough for billions of people to safely run evil WASM without compromising their phones, and you can copy this engine from Google Chrome to server and use this strong sandbox to run scripts from various users, which could share resources.<p>An alternative is to use virtualization. So you can either compile your code to WASM blob and run it in the big WASM server, or you can compile your code to amd64 binary, put it along stripped Linux kernel and run this thing in the VM. There&#x27;s no clear winner here, I think, for now, there are pros and cons for every approach.</div><br/><div id="41796777" class="c"><input type="checkbox" id="c-41796777" checked=""/><div class="controls bullet"><span class="by">DanielHB</span><span>|</span><a href="#41795946">root</a><span>|</span><a href="#41796175">parent</a><span>|</span><a href="#41796780">next</a><span>|</span><label class="collapse" for="c-41796777">[-]</label><label class="expand" for="c-41796777">[1 more]</label></div><br/><div class="children"><div class="content">&gt; WASM proved to be secure and JVM did not.<p>It is interesting to ask why that is the case, from my point of view the reason is that the JVM standard library is just too damn large. While WASM goes on a lower-level approach of just not having one.<p>To make WASM have the capabilities required the host (the agent running the WASM code) needs to provide them. For a lot of languages that means using WASI, moving most of the security concerns to the WASI implementation used.<p>But if you really want to create a secure environment you can just... not implement all of WASI. So a lambda function host environment can, for example, just not implement any filesystem WASI calls because a lambda has no business implementing filesystem stuff.<p>&gt; An alternative is to use virtualization. So you can either compile your code to WASM blob and run it in the big WASM server, or you can compile your code to amd64 binary, put it along stripped Linux kernel and run this thing in the VM.<p>I think the first approach gives a lot more room for the host to create optimizations, to the point we could see hardware with custom instructions to make WASM faster. Or custom WASM runtimes heavily tied to the hardware they run on to make better JIT code.<p>I imagine a future where WASM is treated like LLVM IR</div><br/></div></div><div id="41796780" class="c"><input type="checkbox" id="c-41796780" checked=""/><div class="controls bullet"><span class="by">silvestrov</span><span>|</span><a href="#41795946">root</a><span>|</span><a href="#41796175">parent</a><span>|</span><a href="#41796777">prev</a><span>|</span><a href="#41796108">next</a><span>|</span><label class="collapse" for="c-41796780">[-]</label><label class="expand" for="c-41796780">[1 more]</label></div><br/><div class="children"><div class="content">Most of all the problem with Java Applets was that they were very slow to load and required so many resources that the computer came to a halt.<p>They also took much longer to develop than whatever you could cook up in plain html and javascript.</div><br/></div></div></div></div><div id="41796108" class="c"><input type="checkbox" id="c-41796108" checked=""/><div class="controls bullet"><span class="by">pdpi</span><span>|</span><a href="#41795946">parent</a><span>|</span><a href="#41796175">prev</a><span>|</span><a href="#41796097">next</a><span>|</span><label class="collapse" for="c-41796108">[-]</label><label class="expand" for="c-41796108">[2 more]</label></div><br/><div class="children"><div class="content">Unlike ActiveX, Silverlight, or Flash, it&#x27;s an open standard developed by a whole bunch of industry players, and it has multiple different implementations (where Java sits on that spectrum is perhaps a bit fuzzier). That alone puts it heads and shoulders above any of the alternatives.<p>Unlike the JVM, WASM offers linear memory, and no GC by default, which makes it a much better compilation target for a broader range of languages (most common being C and C++ through Emscripten, and Rust).<p>&gt; Maybe I’m just old, but I thought we’d learnt our lesson on running untrusted third party compiled code in a web browser.<p>WASM is bytecode, and I think most implementations share a lot of their runtime with the host JavaScript engine.<p>&gt; In all of these cases it’s pitched as improving the customer experience but also conveniently pushes the computational cost from server to client.<p>The whole industry has swung from fat clients to thin clients and back since time immemorial. The pendulum will keep swinging after this too.</div><br/><div id="41796343" class="c"><input type="checkbox" id="c-41796343" checked=""/><div class="controls bullet"><span class="by">DougMerritt</span><span>|</span><a href="#41795946">root</a><span>|</span><a href="#41796108">parent</a><span>|</span><a href="#41796097">next</a><span>|</span><label class="collapse" for="c-41796343">[-]</label><label class="expand" for="c-41796343">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The whole industry has swung from fat clients to thin clients and back since time immemorial. The pendulum will keep swinging after this too.<p>Indeed, graphics pioneer and all-around-genius Ivan Sutherland observed (and named) this back in 1968:<p>&quot;wheel of reincarnation
&quot;[coined in a paper by T.H. Myer and I.E. Sutherland On the Design of Display Processors, Comm. ACM, Vol. 11, no. 6, June 1968)] Term used to refer to a well-known effect whereby function in a computing system family is migrated out to special-purpose peripheral hardware for speed, then the peripheral evolves toward more computing power as it does its job, then somebody notices that it is inefficient to support two asymmetrical processors in the architecture and folds the function back into the main CPU, at which point the cycle begins again.<p>&quot;Several iterations of this cycle have been observed in graphics-processor design, and at least one or two in communications and floating-point processors. Also known as the Wheel of Life, the Wheel of Samsara, and other variations of the basic Hindu&#x2F;Buddhist theological idea. See also blitter.&quot;<p><a href="https:&#x2F;&#x2F;www.catb.org&#x2F;jargon&#x2F;html&#x2F;W&#x2F;wheel-of-reincarnation.html" rel="nofollow">https:&#x2F;&#x2F;www.catb.org&#x2F;jargon&#x2F;html&#x2F;W&#x2F;wheel-of-reincarnation.ht...</a></div><br/></div></div></div></div><div id="41796097" class="c"><input type="checkbox" id="c-41796097" checked=""/><div class="controls bullet"><span class="by">Laremere</span><span>|</span><a href="#41795946">parent</a><span>|</span><a href="#41796108">prev</a><span>|</span><a href="#41795990">next</a><span>|</span><label class="collapse" for="c-41796097">[-]</label><label class="expand" for="c-41796097">[5 more]</label></div><br/><div class="children"><div class="content">Wasm has a great benefits over those technologies:<p>- Wasm has verification specification that wasm bytecode must comply to.  This verified subset makes security exploits seen in those older technologies outright impossible. Attacks based around misbehaving hardware like heartbleed or rowhammer might still be possible, but you, eg, can&#x27;t reference memory outside of your wasm&#x27;s memory by tricking the VM to interpret a number you have as a pointer to memory that doesn&#x27;t belong to you.<p>- Wasm bytecode is trivial (as it gets) to turn into machine code.  So implementations can be smaller and faster than using a VM.<p>- Wasm isn&#x27;t owned by a specific company, and has an open and well written specification anyone can use.<p>- It has been adopted as a web standard, so no browser extensions are required.<p>As for computation on clients versus serves, that&#x27;s already true for Javascript.  More true in fact, since wasm code can be efficient in ways that are impossible for Javascript.</div><br/><div id="41796715" class="c"><input type="checkbox" id="c-41796715" checked=""/><div class="controls bullet"><span class="by">kgeist</span><span>|</span><a href="#41795946">root</a><span>|</span><a href="#41796097">parent</a><span>|</span><a href="#41796592">next</a><span>|</span><label class="collapse" for="c-41796715">[-]</label><label class="expand" for="c-41796715">[1 more]</label></div><br/><div class="children"><div class="content">Btw, is WASM really more secure? JVM and .NET basically have capability-based security thanks to their OOP design together with bytecode verification: if you can&#x27;t take a reference to an object (say, there&#x27;s a factory method with a check), you can&#x27;t access that object in any way (a reference is like an access token).<p>As far as I understand, in WASM memory is a linear blob, so if I compile C++ to WASM, isn&#x27;t it possible to reference a random segment of memory (say, via an unchecked array index exploit) and then do whatever you want with it (exploit other bugs in the original C++ app). The only benefit is that access to the OS is isolated, but all the other exploits are still possible (and impossible in JVM&#x2F;.NET).<p>Am I missing something?</div><br/></div></div><div id="41796592" class="c"><input type="checkbox" id="c-41796592" checked=""/><div class="controls bullet"><span class="by">kgeist</span><span>|</span><a href="#41795946">root</a><span>|</span><a href="#41796097">parent</a><span>|</span><a href="#41796715">prev</a><span>|</span><a href="#41795990">next</a><span>|</span><label class="collapse" for="c-41796592">[-]</label><label class="expand" for="c-41796592">[3 more]</label></div><br/><div class="children"><div class="content">&gt;Wasm has verification specification. This verified subset makes security exploits seen in those older technologies outright impossible<p>Both Java and .NET verify their bytecode.<p>&gt;Wasm bytecode is trivial (as it gets) to turn into machine code<p>JVM and .NET bytecodes aren&#x27;t supercomplicated either.<p>Probably the only real differences are: 1) WASM was designed to be more modular and slimmer from the start, while Java and .NET were designed to be fat; currently there are modularization efforts, but it&#x27;s too late 2) WASM is an open standard from the start and so browser vendors implement it without plugins<p>Other than that, it feels like WASM is a reinvention of what already existed before.</div><br/><div id="41796844" class="c"><input type="checkbox" id="c-41796844" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41795946">root</a><span>|</span><a href="#41796592">parent</a><span>|</span><a href="#41795990">next</a><span>|</span><label class="collapse" for="c-41796844">[-]</label><label class="expand" for="c-41796844">[2 more]</label></div><br/><div class="children"><div class="content">AFAIK the big new thing in WASM is that it enforces &#x27;structured control flow&#x27; - so it&#x27;s a bit more like a high level AST than an assembly-style virtual ISA. Not sure how much of that matters in practice, but AFAIK that was the one important feature that enabled the proper validation of WASM bytecode.</div><br/><div id="41796912" class="c"><input type="checkbox" id="c-41796912" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#41795946">root</a><span>|</span><a href="#41796844">parent</a><span>|</span><a href="#41795990">next</a><span>|</span><label class="collapse" for="c-41796912">[-]</label><label class="expand" for="c-41796912">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think there&#x27;s any significant advance in the bytecode beyond e.g. JVM bytecode.<p>The difference is in the surface area of the standard library -- Java applets exposed a lot of stuff that turned out to have a lot of security holes, and it was basically impossible to guarantee there weren&#x27;t further holes. In WASM, the linear memory and very simple OS interface makes the sandboxing much more tractable.</div><br/></div></div></div></div></div></div></div></div><div id="41795990" class="c"><input type="checkbox" id="c-41795990" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41795946">parent</a><span>|</span><a href="#41796097">prev</a><span>|</span><a href="#41796249">next</a><span>|</span><label class="collapse" for="c-41795990">[-]</label><label class="expand" for="c-41795990">[1 more]</label></div><br/><div class="children"><div class="content">Java Applets and ActiveX had less-mediated (Applets, somewhat; ActiveX, not at all) access to the underlying OS. The &quot;outer platform&quot; of WASM is approximately the Javascript runtime; the &quot;outer platform&quot; of Applets is execve(2).</div><br/></div></div><div id="41796249" class="c"><input type="checkbox" id="c-41796249" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41795946">parent</a><span>|</span><a href="#41795990">prev</a><span>|</span><a href="#41796032">next</a><span>|</span><label class="collapse" for="c-41796249">[-]</label><label class="expand" for="c-41796249">[1 more]</label></div><br/><div class="children"><div class="content">&gt; untrusted third party compiled code in a web browser.<p>WASM makes that safe, and that&#x27;s the whole point. It doesn&#x27;t increase the attack surface by much compared to running Javascript code in the browser, while the alternative solutions where directly poking through into the operating system and bypassing any security infrastructure of the browser for running untrusted code.</div><br/></div></div><div id="41796032" class="c"><input type="checkbox" id="c-41796032" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41795946">parent</a><span>|</span><a href="#41796249">prev</a><span>|</span><a href="#41796042">next</a><span>|</span><label class="collapse" for="c-41796032">[-]</label><label class="expand" for="c-41796032">[1 more]</label></div><br/><div class="children"><div class="content">Pushing compute to the client is the whole point, and is often a major improvement for the end user, especially in the era in which phones are faster than the supercomputers of the 90s.<p>And otherwise, WASM is different in two ways.<p>For one, browsers have gotten pretty good at running untrusted 3rd party code safely, which Flash or the JVM or IE or.NET were never even slightly adequate for.<p>The other difference is that WASM is designed to allow you to take a program in any language and run it in the user&#x27;s browser. The techs you mention were all available for a single language, so if you already had a program in, say, Python, you&#x27;d have to re-write it in Java or C#, or maybe Scala or F#, to run it as an applet or Silverlight program.</div><br/></div></div><div id="41796042" class="c"><input type="checkbox" id="c-41796042" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41795946">parent</a><span>|</span><a href="#41796032">prev</a><span>|</span><a href="#41795988">next</a><span>|</span><label class="collapse" for="c-41796042">[-]</label><label class="expand" for="c-41796042">[1 more]</label></div><br/><div class="children"><div class="content">The replacement for those technologies is arguably javascript. WASM is more focused on performance by providing less abstractions and an instruction set closer to assembly (hence the name).<p>The issue with those older technologies was that the runtime itself was a third-party external plugin you had to trust, and they often had various security issues. WASM however is an open standard, so browser manifacturers can directly implement it in browser engines without trusting other third-parties. It is also much more restricted in scope (less abstractions mean less work to optimize them!) which helps reducing the attack surface.</div><br/></div></div><div id="41795988" class="c"><input type="checkbox" id="c-41795988" checked=""/><div class="controls bullet"><span class="by">palmfacehn</span><span>|</span><a href="#41795946">parent</a><span>|</span><a href="#41796042">prev</a><span>|</span><a href="#41796668">next</a><span>|</span><label class="collapse" for="c-41795988">[-]</label><label class="expand" for="c-41795988">[1 more]</label></div><br/><div class="children"><div class="content">There have also been exploits of Chrome&#x27;s JS sandbox. For me the greatest difference is that WASM is supported by the browser itself. There isn&#x27;t the same conflict of interest between OS vendors and 3rd party runtime providers.</div><br/></div></div><div id="41796668" class="c"><input type="checkbox" id="c-41796668" checked=""/><div class="controls bullet"><span class="by">Starlevel004</span><span>|</span><a href="#41795946">parent</a><span>|</span><a href="#41795988">prev</a><span>|</span><a href="#41796013">next</a><span>|</span><label class="collapse" for="c-41796668">[-]</label><label class="expand" for="c-41796668">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t easily decompile WASM so it makes it harder to block inline ads.</div><br/></div></div><div id="41796013" class="c"><input type="checkbox" id="c-41796013" checked=""/><div class="controls bullet"><span class="by">pajamaboin</span><span>|</span><a href="#41795946">parent</a><span>|</span><a href="#41796668">prev</a><span>|</span><a href="#41795977">next</a><span>|</span><label class="collapse" for="c-41796013">[-]</label><label class="expand" for="c-41796013">[1 more]</label></div><br/><div class="children"><div class="content">This article is about WASM on the server so to answer your question it&#x27;s different because it&#x27;s not pushing computational cost from the server to the client. It can, but it doesn&#x27;t in all cases. That&#x27;s a huge difference. Others have already commented others (better sandboxing, isolation, etc)</div><br/></div></div><div id="41795977" class="c"><input type="checkbox" id="c-41795977" checked=""/><div class="controls bullet"><span class="by">freetonik</span><span>|</span><a href="#41795946">parent</a><span>|</span><a href="#41796013">prev</a><span>|</span><a href="#41796062">next</a><span>|</span><label class="collapse" for="c-41795977">[-]</label><label class="expand" for="c-41795977">[2 more]</label></div><br/><div class="children"><div class="content">Not an answer, but I think it’s unfair to group Flash with the others because it was both the editor&#x2F;compiler and the player were proprietary. I guess same applies to Silverlight at least.</div><br/><div id="41796027" class="c"><input type="checkbox" id="c-41796027" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#41795946">root</a><span>|</span><a href="#41795977">parent</a><span>|</span><a href="#41796062">next</a><span>|</span><label class="collapse" for="c-41796027">[-]</label><label class="expand" for="c-41796027">[1 more]</label></div><br/><div class="children"><div class="content">The ActiveX &quot;player&quot; (Internet Explorer) was also proprietary. And I&#x27;m not sure if you could get away without proprietary Microsoft tools to develop for it.</div><br/></div></div></div></div><div id="41796062" class="c"><input type="checkbox" id="c-41796062" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41795946">parent</a><span>|</span><a href="#41795977">prev</a><span>|</span><a href="#41796791">next</a><span>|</span><label class="collapse" for="c-41796062">[-]</label><label class="expand" for="c-41796062">[1 more]</label></div><br/><div class="children"><div class="content">ActiveX wasn&#x27;t sandboxed so it was a security joke. Flash and Silverlight were full custom runtimes that a) only worked with a specific language, and b) didn&#x27;t integrate well with the existing web platform. WASM fixes all of that.</div><br/></div></div></div></div><div id="41796791" class="c"><input type="checkbox" id="c-41796791" checked=""/><div class="controls bullet"><span class="by">openrisk</span><span>|</span><a href="#41795946">prev</a><span>|</span><a href="#41796252">next</a><span>|</span><label class="collapse" for="c-41796791">[-]</label><label class="expand" for="c-41796791">[1 more]</label></div><br/><div class="children"><div class="content">It is challenging to forecast how client-server architectures would evolve on the basis of technical merit, even if we restrict to &quot;web architectures&quot; (this itself being a bundle of multiple options).<p>Massive scaling with minimal resources is certainly one important enabler. If you were, e.g., to re-architect wikipedia with the knowledge and hardware of today how would you do it with wasm (on both desktop and mobile). How about a massive multiplayer game etc.<p>On the other hand you have the constraints and costs of current commercial &#x2F; business model realities and legacy patterns that create a high bar for any innovation to flurish. But high does not mean infinitely high.<p>I hate to be the person mentioning AI on every HN thread but its a good example of the long stagnation and then torrential change that is the hallmark of how online connected computing adoption evolves: e.g., we could have had online numerically very intensive apps and API&#x27;s a long time ago already (LLM&#x27;s are not the only useful algorithm invented by humankind). But we didnt. It takes engineering a stampede to move the lazy (cash) cows to new grass land.<p>So it does feel that at some point starting with a fresh canvas might make sense (as in, substantially expand what is possible). When the cruft accumulates sometimes it collapses under its own weight.</div><br/></div></div><div id="41796252" class="c"><input type="checkbox" id="c-41796252" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#41796791">prev</a><span>|</span><a href="#41796711">next</a><span>|</span><label class="collapse" for="c-41796252">[-]</label><label class="expand" for="c-41796252">[2 more]</label></div><br/><div class="children"><div class="content">WASM replaces a language specific vm (javascript) with a general purpose one anywhere javascript vms are currently used. But not exclusively just there. General purpose here means it can run just about anything with a compiler or interpreter for it. Including javascript. So anything, anywhere.<p>Since it is generally implemented as part of the javascript engine, it inherits a lot of stuff that comes with it like sandboxing and access to the APIs that come with it. Standardizing access to that is a bit of an ongoing process but the end state here is that anything that currently can only be done in Javascript will also be possible in WASM. And a lot more that is currently hard or impossible in Javascript. And it all might run a little faster&#x2F;smoother.<p>That makes WASM many things. But the main thing it does is remove a lot of restrictions we&#x27;ve had on environments where Javascript is currently popular. Javascript is a bit of a divisive language. Some people love it, some people hate it. It goes from being the only game in town to being one of many things you can pick to do a thing.<p>It&#x27;s been styled as a Javascript replacement, as a docker replacement, as a Java replacement, a CGI replacement (this article), etc. The short version of it is that it is all of these things. And more.</div><br/><div id="41796547" class="c"><input type="checkbox" id="c-41796547" checked=""/><div class="controls bullet"><span class="by">marcyb5st</span><span>|</span><a href="#41796252">parent</a><span>|</span><a href="#41796711">next</a><span>|</span><label class="collapse" for="c-41796547">[-]</label><label class="expand" for="c-41796547">[1 more]</label></div><br/><div class="children"><div class="content">While I don&#x27;t have a problem with Javascript, I have a problem with the ecosystem around publishing JS for the web. There are so many tools that do more or less the same thing and whose boundaries are unclear. Additionally, when you eventually manage to get everything working it feels brittle (IMHO). For someone that doesn&#x27;t do that professionally, it is daunting.<p>Nowadays, the few times I need to build something for the web I use leptos which has a much nicer DX and even if it didn&#x27;t reach 1.x yet, it feels more stable that chaining like 5 tools to transpile, uglify, minify, pack, ... your JS bundle.</div><br/></div></div></div></div><div id="41796711" class="c"><input type="checkbox" id="c-41796711" checked=""/><div class="controls bullet"><span class="by">DanielHB</span><span>|</span><a href="#41796252">prev</a><span>|</span><a href="#41796296">next</a><span>|</span><label class="collapse" for="c-41796711">[-]</label><label class="expand" for="c-41796711">[1 more]</label></div><br/><div class="children"><div class="content">I have been thinking we would be heading for a world where WASM replaces code running lambda functions on the cloud for a long time. WASM is traditionally seen as running on a host platform, but there is no reason it needs to be this way.<p>Because of the sandbox nature of WASM technically it could even run outside an operating system or in ring0 bypassing a lot of OS overhead.<p>Compiling to WASM makes a whole range of deployment problems a lot simpler for the user and gives a lot of room for the hosting environment to do optimizations (maybe even custom hardware to make WASM run faster).</div><br/></div></div><div id="41796296" class="c"><input type="checkbox" id="c-41796296" checked=""/><div class="controls bullet"><span class="by">torginus</span><span>|</span><a href="#41796711">prev</a><span>|</span><a href="#41795918">next</a><span>|</span><label class="collapse" for="c-41796296">[-]</label><label class="expand" for="c-41796296">[4 more]</label></div><br/><div class="children"><div class="content"><i>Just in Time (JIT) compilation is not possible as dynamic Wasm code generation is not allowed for security reasons. </i><p>This sounds.. not right. Honestly,this is an essential feature for allowing workloads like hot reloading code cleanly.<p>I&#x27;m quite convinced the alleged security argument is bull. You can hot reload JS (or even do wilder things like codegen) at runtime without compromising security. Additionally, you can emulate codegen or hot reload, by dynamically reloading the entire Wasm runtime and preserving the memory, but the user experience will be clunky.<p>I don&#x27;t see any technical reason why this couldn&#x27;t be possible.  If this were a security measure, it could be trivially bypassed.<p>Also, WASM bytecode is very similar conceptually to .NET IL, Java bytecode etc., things designed for JIT compilation.<p>I kind of dislike WASM. It&#x27;s a project lacking strong direction and will to succeed in a timely manner. First, the whole idea is conceptually unclear, its name suggests that it&#x27;s supposed to be &#x27;assembly for the web&#x27;, a machine language for a virtual CPU, but it&#x27;s actually an intermediate representation meant for compiler backends, with high-level features planned such as GC support. 
It&#x27;s still missing basic features, like the aforementioned hot reload, non-hacking threading, native interfacing with the DOM (without Javascript ideally), low-overhed graphics&#x2F;compute API support, low-level audio access etc.
You can&#x27;t run a big multimedia app without major compromises in it.</div><br/><div id="41796308" class="c"><input type="checkbox" id="c-41796308" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41796296">parent</a><span>|</span><a href="#41795918">next</a><span>|</span><label class="collapse" for="c-41796308">[-]</label><label class="expand" for="c-41796308">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Just in Time (JIT) compilation is not possible as dynamic Wasm code generation is not allowed for security reasons.<p>Browsers definitely use a form of JIT-ing for WASM (which is a bit unfortunate, because just as with JITs, you might see slight &#x27;warmup stutter&#x27; when running WASM code for the first time - although this has gotten a lot better over the years).<p>...also I&#x27;m pretty sure you can dynamically create a WASM blob in the browser and then dynamically instantiate and run that - not sure if that&#x27;s possible in other WASM runtimes though, and even in the browser you&#x27;ll have to reach out Javascript, but that&#x27;s needed for accessing any sort of &#x27;web API&#x27;.</div><br/><div id="41796440" class="c"><input type="checkbox" id="c-41796440" checked=""/><div class="controls bullet"><span class="by">torginus</span><span>|</span><a href="#41796296">root</a><span>|</span><a href="#41796308">parent</a><span>|</span><a href="#41795918">next</a><span>|</span><label class="collapse" for="c-41796440">[-]</label><label class="expand" for="c-41796440">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Browsers definitely use a form of JIT-ing for WASM<p>I (and the article) wasn&#x27;t referring to this kind of JIT. I was referring to the ability to dynamically create or modify methods or load libraries while the app is running (like `DynamicMethod` in .NET).<p>Afaik WASM even in the browser does not allow modifying the blob after instantiation.<p>The thing you are referring to puzzles me as well. I initially thought that WASM would be analogous to x86 or ARM asm and would be just another architecture emitted by the compiler. Running it in the browser would just involve a quick translation pass to the native architecture (with usually 1-to-1 mapping to machine instructions) and some quick check to see that it doesn&#x27;t do anything naughty. Instead it&#x27;s an LLVM IR analog that needs to be fed into a full-fledged compiler backend.<p>I&#x27;m sure there are good technical reasons as to why it was designed like this, but as you mentioned, it comes with tangible costc like startup time and runtime complexity.</div><br/><div id="41796724" class="c"><input type="checkbox" id="c-41796724" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41796296">root</a><span>|</span><a href="#41796440">parent</a><span>|</span><a href="#41795918">next</a><span>|</span><label class="collapse" for="c-41796724">[-]</label><label class="expand" for="c-41796724">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Afaik WASM even in the browser does not allow modifying the blob after instantiation.<p>...not your own WASM blob, but you can build a new WASM blob and run that.<p>&gt; The thing you are referring to puzzles me as well...<p>Yes, compilers emit WASM, but that WASM is just a bytecode (similar to JVM or .NET bytecode but even higher level because WASM enforces &#x27;structured control flow&#x27;) and needs to be compiled to actual machine code on the client before it can run, and this isn&#x27;t a simple AOT compilation - in browsers at least (it used to be for a while in Firefox, but that caused issues for large projects like Unity games, which might take dozens of seconds to AOT compile).<p>AFAIK all browsers now use a tiered approach. The WASM-to-machine-code compilation doesn&#x27;t happen on the whole WASM blob at once, but function by function. For the first time a WASM function is called, a fast compilation will happen which may have slow runtime performance, from then on, &#x27;hot functions&#x27; will be compiled with a higher tier backend which does additional optimization, is slow to compile but has better runtime performance - and AFAIK this is also quite similar to how Javascript JIT-ing works.<p>Also from what I understand WASM compilation is more complex than just translating bytecode instructions to native instructions. It&#x27;s more like compiling an AST into machine code - at least if you want any performance out of it.<p>The only difference to JS might be that a WASM functions are never &#x27;de-optimized&#x27;.</div><br/></div></div></div></div></div></div></div></div><div id="41795918" class="c"><input type="checkbox" id="c-41795918" checked=""/><div class="controls bullet"><span class="by">rpcope1</span><span>|</span><a href="#41796296">prev</a><span>|</span><a href="#41796010">next</a><span>|</span><label class="collapse" for="c-41795918">[-]</label><label class="expand" for="c-41795918">[16 more]</label></div><br/><div class="children"><div class="content">So basically we&#x27;re reinventing the JVM and it&#x27;s ecosystem?</div><br/><div id="41796297" class="c"><input type="checkbox" id="c-41796297" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41795918">parent</a><span>|</span><a href="#41795979">next</a><span>|</span><label class="collapse" for="c-41796297">[-]</label><label class="expand" for="c-41796297">[1 more]</label></div><br/><div class="children"><div class="content">In a way yes, except that WASM supports many more languages (e.g. back when I started to look into running C&#x2F;C++ code in the browser - around 2010 or so - it was absolutely impossible to compile C&#x2F;C++ to the JVM, which at the time would have been nice because Java Applets still were a thing - of course WASM didn&#x27;t exist yet either, but Emscripten did, which eventually led to the creation of WASM via asm.js).</div><br/></div></div><div id="41795979" class="c"><input type="checkbox" id="c-41795979" checked=""/><div class="controls bullet"><span class="by">thot_experiment</span><span>|</span><a href="#41795918">parent</a><span>|</span><a href="#41796297">prev</a><span>|</span><a href="#41796084">next</a><span>|</span><label class="collapse" for="c-41795979">[-]</label><label class="expand" for="c-41795979">[1 more]</label></div><br/><div class="children"><div class="content">Sort of yes, but WASM is designed with a different set of constraints in mind that make more sense when you just want to shove the runtime into your whatever. Sometimes reinventing X with lessons learned is actually a great idea.</div><br/></div></div><div id="41796084" class="c"><input type="checkbox" id="c-41796084" checked=""/><div class="controls bullet"><span class="by">epistasis</span><span>|</span><a href="#41795918">parent</a><span>|</span><a href="#41795979">prev</a><span>|</span><a href="#41795998">next</a><span>|</span><label class="collapse" for="c-41796084">[-]</label><label class="expand" for="c-41796084">[1 more]</label></div><br/><div class="children"><div class="content">The JVM is great and all, but that doesn&#x27;t mean that it is the be-all end-all of the genre. And having mucked with class loaders and writing directly in JVM assembly in the 2000s as part of programming language classes, I&#x27;m not sure that the JVM is even a very high point in the genre.<p>Sure, it allowed a large ecosystem, but holy crap is the whole JVM interface to the external world a clunky mess. For 20+ years I have groaned when encountering anything JVM related.<p>Comparing the packaging and ecosystem of Rust to that of Python, or <i>shudder</i> C++, shows that reinvention, with lessons learned in prior decades, can be a very very good thing.</div><br/></div></div><div id="41795998" class="c"><input type="checkbox" id="c-41795998" checked=""/><div class="controls bullet"><span class="by">mlhpdx</span><span>|</span><a href="#41795918">parent</a><span>|</span><a href="#41796084">prev</a><span>|</span><a href="#41796231">next</a><span>|</span><label class="collapse" for="c-41795998">[-]</label><label class="expand" for="c-41795998">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and the .Net CLR, etc.</div><br/></div></div><div id="41796231" class="c"><input type="checkbox" id="c-41796231" checked=""/><div class="controls bullet"><span class="by">singularity2001</span><span>|</span><a href="#41795918">parent</a><span>|</span><a href="#41795998">prev</a><span>|</span><a href="#41795959">next</a><span>|</span><label class="collapse" for="c-41796231">[-]</label><label class="expand" for="c-41796231">[2 more]</label></div><br/><div class="children"><div class="content">except that WASM has a huge classloader &#x2F; linker problem: It&#x27;s still very hard to combine two wasm files into one and get the memory merger right. Maybe component model can fix it but it comes with so much bloated nonsense that an adaption in Safari might take forever.</div><br/><div id="41796946" class="c"><input type="checkbox" id="c-41796946" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#41795918">root</a><span>|</span><a href="#41796231">parent</a><span>|</span><a href="#41795959">next</a><span>|</span><label class="collapse" for="c-41796946">[-]</label><label class="expand" for="c-41796946">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a problem for some use cases, but is it really a &quot;huge&quot; problem in general?<p>You can&#x27;t easily publish a library in WASM and link it into another application later. But you can publish it as C++ source (say) and compile it into a C++ application, and build the whole thing as WASM.<p>What are the scenarios where you really really want libraries in WASM format?</div><br/></div></div></div></div><div id="41795959" class="c"><input type="checkbox" id="c-41795959" checked=""/><div class="controls bullet"><span class="by">palmfacehn</span><span>|</span><a href="#41795918">parent</a><span>|</span><a href="#41796231">prev</a><span>|</span><a href="#41795945">next</a><span>|</span><label class="collapse" for="c-41795959">[-]</label><label class="expand" for="c-41795959">[4 more]</label></div><br/><div class="children"><div class="content">If your webserver is already JVM based, there&#x27;s no context switch between the webserver and the application. Not sure how this would be solved with WASM.</div><br/><div id="41796110" class="c"><input type="checkbox" id="c-41796110" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41795918">root</a><span>|</span><a href="#41795959">parent</a><span>|</span><a href="#41795945">next</a><span>|</span><label class="collapse" for="c-41796110">[-]</label><label class="expand" for="c-41796110">[3 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t make sense, WASM is supposed to run on the client, which is generally a different machine than the webserver, while a context switch is an event that happens within a single machine.</div><br/><div id="41796451" class="c"><input type="checkbox" id="c-41796451" checked=""/><div class="controls bullet"><span class="by">mlnj</span><span>|</span><a href="#41795918">root</a><span>|</span><a href="#41796110">parent</a><span>|</span><a href="#41796311">next</a><span>|</span><label class="collapse" for="c-41796451">[-]</label><label class="expand" for="c-41796451">[1 more]</label></div><br/><div class="children"><div class="content">WASM on the server also means that an execution engine that containerizes and runs server code in one of the many languages without the overhead of an entire OS like we do with containers now.</div><br/></div></div><div id="41796311" class="c"><input type="checkbox" id="c-41796311" checked=""/><div class="controls bullet"><span class="by">palmfacehn</span><span>|</span><a href="#41795918">root</a><span>|</span><a href="#41796110">parent</a><span>|</span><a href="#41796451">prev</a><span>|</span><a href="#41795945">next</a><span>|</span><label class="collapse" for="c-41796311">[-]</label><label class="expand" for="c-41796311">[1 more]</label></div><br/><div class="children"><div class="content">From the article:<p>&gt;Wasm on the Server<p>&gt;Why on earth are we talking about Wasm? Isn&#x27;t it for the browser?<p>&gt;And I really hope even my mention of that question becomes dated, but I still hear this question quite often so it&#x27;s worth talking about. Wasm was initially developed to run high performant code in the web browser.</div><br/></div></div></div></div></div></div><div id="41795945" class="c"><input type="checkbox" id="c-41795945" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41795918">parent</a><span>|</span><a href="#41795959">prev</a><span>|</span><a href="#41796010">next</a><span>|</span><label class="collapse" for="c-41795945">[-]</label><label class="expand" for="c-41795945">[5 more]</label></div><br/><div class="children"><div class="content">Yeah, by folks that most likely used to bash Application Servers from early 2000&#x27;s.<p>Not only JVM, also CLR, BEAM, P-Code, M-Code, and every other bytecode format since UNCOL came to be in 1958, but lets not forget about the coolness of selling WASM instead.</div><br/><div id="41796072" class="c"><input type="checkbox" id="c-41796072" checked=""/><div class="controls bullet"><span class="by">iforgotpassword</span><span>|</span><a href="#41795918">root</a><span>|</span><a href="#41795945">parent</a><span>|</span><a href="#41796036">next</a><span>|</span><label class="collapse" for="c-41796072">[-]</label><label class="expand" for="c-41796072">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a bit oversimplified. I had this thought too and tried to figure out why this is different, and I think there are some major points. The biggest one is in which order they were built and designed. If we take Java and ask why applets didn&#x27;t take off since they could do everything WASM offers and more, two things come to mind: it was <i>fucking slow</i> on contemporary machines, and the gui framework sucked. WASM is the complete opposite. The gui framework is HTML&#x2F;CSS, which despite its idiocy in many places had a long time to mature and we&#x27;ve generally came to accept the way it works. Now we just tacked a powerful VM onto it so we don&#x27;t need to target slow Javascript. There isn&#x27;t even a new language to learn, just compile whatever you want to WASM, which means you can use a familiar and mature dev environment.<p>The other point is that WASM is way more open than any of the mentioned predecessors were. They were mostly proprietary crap by vendors who didn&#x27;t give a shit (flash: security, Microsoft: other platforms) so inevitably someone else would throw their weight around (Apple) to kill them, and with good reason. WASM is part of the browser, so as a vendor you&#x27;re actually in control regarding security and other things, and are not at the mercy of some lazy entity who doesn&#x27;t give a damn because they think their product is irreplaceable.</div><br/><div id="41796242" class="c"><input type="checkbox" id="c-41796242" checked=""/><div class="controls bullet"><span class="by">singularity2001</span><span>|</span><a href="#41795918">root</a><span>|</span><a href="#41796072">parent</a><span>|</span><a href="#41796036">next</a><span>|</span><label class="collapse" for="c-41796242">[-]</label><label class="expand" for="c-41796242">[1 more]</label></div><br/><div class="children"><div class="content">Any reasonable interaction between WASM and JS&#x2F;DOM gets postponed seemingly indefinitely though.</div><br/></div></div></div></div><div id="41796036" class="c"><input type="checkbox" id="c-41796036" checked=""/><div class="controls bullet"><span class="by">thot_experiment</span><span>|</span><a href="#41795918">root</a><span>|</span><a href="#41795945">parent</a><span>|</span><a href="#41796072">prev</a><span>|</span><a href="#41796136">next</a><span>|</span><label class="collapse" for="c-41796036">[-]</label><label class="expand" for="c-41796036">[1 more]</label></div><br/><div class="children"><div class="content">The coolness of WASM is that I can run WASM on like 99.999% of the targets I care to run code on with zero friction. Everyone (well it&#x27;s HN so someone is probably on LYNX) reading this page is doing so in a browser with a WASM runtime. That has tremendous value.</div><br/></div></div><div id="41796136" class="c"><input type="checkbox" id="c-41796136" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41795918">root</a><span>|</span><a href="#41795945">parent</a><span>|</span><a href="#41796036">prev</a><span>|</span><a href="#41796010">next</a><span>|</span><label class="collapse" for="c-41796136">[-]</label><label class="expand" for="c-41796136">[1 more]</label></div><br/><div class="children"><div class="content">All of those bytecode formats were designed to support higher abstractions. WASM on the other hand was born from asm.js, which tried to <i>remove</i> abstraction to make code run faster. Ultimately the goal for WASM was to run code faster, hopefully near native speed, which is not a priority for all the bytecodes you mentioned. If that wasn&#x27;t needed then Javascript would have been enough.</div><br/></div></div></div></div></div></div><div id="41796010" class="c"><input type="checkbox" id="c-41796010" checked=""/><div class="controls bullet"><span class="by">fallous</span><span>|</span><a href="#41795918">prev</a><span>|</span><a href="#41796056">next</a><span>|</span><label class="collapse" for="c-41796010">[-]</label><label class="expand" for="c-41796010">[1 more]</label></div><br/><div class="children"><div class="content">This article really does remind me of an old Law of Software that we used to invoke:  Any sufficiently large and long-lived application will eventually re-implement the entire software stack it runs on, including the operating system.. and it will re-implement it poorly.<p>I&#x27;m unsure of the source for this Law, but it certainly proves correct more often than not.</div><br/></div></div><div id="41796056" class="c"><input type="checkbox" id="c-41796056" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#41796010">prev</a><span>|</span><a href="#41795890">next</a><span>|</span><label class="collapse" for="c-41796056">[-]</label><label class="expand" for="c-41796056">[2 more]</label></div><br/><div class="children"><div class="content">putting everything in WASM really drains the battery on mobile.<p>I hate WASM heavy websites as often they have bloat of javascript and site is very slow, especially during scrolling, zooming due to abuse of event listeners and piss poor coding discipline.<p>I kinda miss sometimes server rendered index.php</div><br/><div id="41796087" class="c"><input type="checkbox" id="c-41796087" checked=""/><div class="controls bullet"><span class="by">thot_experiment</span><span>|</span><a href="#41796056">parent</a><span>|</span><a href="#41795890">next</a><span>|</span><label class="collapse" for="c-41796087">[-]</label><label class="expand" for="c-41796087">[1 more]</label></div><br/><div class="children"><div class="content">WASM is a double edged sword, if you&#x27;re compiling fast implementations of heavy lift functions to WASM and calling them in lieu of a JS impl you&#x27;re going to end up saving battery life.<p>If you&#x27;re generating bindings for some legacy disaster and shipping it to clients as a big WASM blob you&#x27;re going to hell.</div><br/></div></div></div></div><div id="41795890" class="c"><input type="checkbox" id="c-41795890" checked=""/><div class="controls bullet"><span class="by">smolder</span><span>|</span><a href="#41796056">prev</a><span>|</span><a href="#41796040">next</a><span>|</span><label class="collapse" for="c-41795890">[-]</label><label class="expand" for="c-41795890">[9 more]</label></div><br/><div class="children"><div class="content">I kind of like this variety of headline for it&#x27;s ability to stimulate discussion but it&#x27;s also nonsense. CGI can be any type of code responding to an individual web request, represented as a set of parameters. It has basically nothing to do with wasm which is meant to be a universal code representation for a universal virtual machine. Have I missed something?</div><br/><div id="41796376" class="c"><input type="checkbox" id="c-41796376" checked=""/><div class="controls bullet"><span class="by">jblecanard</span><span>|</span><a href="#41795890">parent</a><span>|</span><a href="#41795905">next</a><span>|</span><label class="collapse" for="c-41796376">[-]</label><label class="expand" for="c-41796376">[1 more]</label></div><br/><div class="children"><div class="content">Totally agree there, the article makes complete confusion between the execution model and the tech used to execute. Especially since it says « not CGI as the protocol but as the model ».<p>As far as model goes, the serverless one is not a different model. It is still a flavor of the CGI concept. But the underlying tech is different. And not that much. It is only serverless for you as a customer. Technically speaking, it runs on servers in micro-VMs.<p>Those are orthogonal matters, and even if such tech as the middleware mentioned get some wind, the execution model is still the same and is not new.</div><br/></div></div><div id="41795905" class="c"><input type="checkbox" id="c-41795905" checked=""/><div class="controls bullet"><span class="by">waynecochran</span><span>|</span><a href="#41795890">parent</a><span>|</span><a href="#41796376">prev</a><span>|</span><a href="#41796035">next</a><span>|</span><label class="collapse" for="c-41795905">[-]</label><label class="expand" for="c-41795905">[6 more]</label></div><br/><div class="children"><div class="content">The use of wasm makes sense to me in context of the article.</div><br/><div id="41795927" class="c"><input type="checkbox" id="c-41795927" checked=""/><div class="controls bullet"><span class="by">smolder</span><span>|</span><a href="#41795890">root</a><span>|</span><a href="#41795905">parent</a><span>|</span><a href="#41796035">next</a><span>|</span><label class="collapse" for="c-41795927">[-]</label><label class="expand" for="c-41795927">[5 more]</label></div><br/><div class="children"><div class="content">The article does not seem to support the title. You&#x27;ll have to show me how it does. &#x27;serverless&#x27; is a wholly different concept that doesn&#x27;t have much to do with wasm. You could say it&#x27;s CGI as a service, but that has nothing to do with wasm.</div><br/><div id="41795980" class="c"><input type="checkbox" id="c-41795980" checked=""/><div class="controls bullet"><span class="by">svieira</span><span>|</span><a href="#41795890">root</a><span>|</span><a href="#41795927">parent</a><span>|</span><a href="#41796035">next</a><span>|</span><label class="collapse" for="c-41795980">[-]</label><label class="expand" for="c-41795980">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s quite buried amid a lot of extra paragraphs expositing about WASM and the future of serverless functions in general, but the article <i>does</i> contain this quote:<p>&gt; One of the many effect of how [WASM] modules are isolated is that you can &quot;pause&quot; a module, and save its memory as a data segment. A similar concept to a Snapshot of a virtual machine. You can then start as many copies of the paused module as you like. (As I tell friends, it&#x27;s like saving your game in an emulator.)<p>&gt; The snapshotted module has no extra startup time ...<p>&gt; If we go back to thinking about our Application Server models; this allows us to have a fresh process but without paying the startup costs of a new process. Essentially giving us CGI without the downsides of CGI. Or in more recent terms, serverless without cold starts. This is how Wasm is the new CGI.</div><br/><div id="41796029" class="c"><input type="checkbox" id="c-41796029" checked=""/><div class="controls bullet"><span class="by">smolder</span><span>|</span><a href="#41795890">root</a><span>|</span><a href="#41795980">parent</a><span>|</span><a href="#41796035">next</a><span>|</span><label class="collapse" for="c-41796029">[-]</label><label class="expand" for="c-41796029">[3 more]</label></div><br/><div class="children"><div class="content">This is not like CGI. Calling it &quot;the new CGI&quot; seems to me like a way to confuse people, since CGI was a response to individual requests and carrying state across requests was always extra work. None of this has to do with WASM in particular.</div><br/><div id="41796127" class="c"><input type="checkbox" id="c-41796127" checked=""/><div class="controls bullet"><span class="by">svieira</span><span>|</span><a href="#41795890">root</a><span>|</span><a href="#41796029">parent</a><span>|</span><a href="#41796035">next</a><span>|</span><label class="collapse" for="c-41796127">[-]</label><label class="expand" for="c-41796127">[2 more]</label></div><br/><div class="children"><div class="content">With CGI the developer of the script could pretend that the-only-thing-which-existed was this request and do all kinds of things that would bring down a persistent process (leak memory, mutate globals, etc.)  The problem was that spinning up a process per-request was expensive and slow.  Now, with WASM&#x27;s memory model it becomes possible to have a process that both does all the slow work initialization work once <i>and</i> has the ease-of-reasoning properties of CGI&#x27;s &quot;a single process for a single request&quot; serving model.</div><br/><div id="41796216" class="c"><input type="checkbox" id="c-41796216" checked=""/><div class="controls bullet"><span class="by">smolder</span><span>|</span><a href="#41795890">root</a><span>|</span><a href="#41796127">parent</a><span>|</span><a href="#41796035">next</a><span>|</span><label class="collapse" for="c-41796216">[-]</label><label class="expand" for="c-41796216">[1 more]</label></div><br/><div class="children"><div class="content">Edit to say: thanks for your answer. I&#x27;ll preserve the rest since I still think wheels are being reinvented here.<p>Bridging state across requests is not new. If &quot;the new CGI&quot; means more efficiently sharing state between requests, that&#x27;s a really arbitrary qualifier and is not unique to WASM or serverless or anything like that. The article is myopic, it doesn&#x27;t take into consideration what is established practice done over and over.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41796035" class="c"><input type="checkbox" id="c-41796035" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41795890">parent</a><span>|</span><a href="#41795905">prev</a><span>|</span><a href="#41796040">next</a><span>|</span><label class="collapse" for="c-41796035">[-]</label><label class="expand" for="c-41796035">[1 more]</label></div><br/><div class="children"><div class="content">You might have missed wasi</div><br/></div></div></div></div><div id="41796496" class="c"><input type="checkbox" id="c-41796496" checked=""/><div class="controls bullet"><span class="by">feverzsj</span><span>|</span><a href="#41796040">prev</a><span>|</span><a href="#41796125">next</a><span>|</span><label class="collapse" for="c-41796496">[-]</label><label class="expand" for="c-41796496">[1 more]</label></div><br/><div class="children"><div class="content">Companies choose wasm  to avoid crawlers.</div><br/></div></div><div id="41796125" class="c"><input type="checkbox" id="c-41796125" checked=""/><div class="controls bullet"><span class="by">wokwokwok</span><span>|</span><a href="#41796496">prev</a><span>|</span><a href="#41795968">next</a><span>|</span><label class="collapse" for="c-41796125">[-]</label><label class="expand" for="c-41796125">[1 more]</label></div><br/><div class="children"><div class="content">What the article actually says:<p>&gt; If we go back to thinking about our Application Server models; this allows us to have a fresh process but without paying the startup costs of a new process. Essentially giving us CGI without the downsides of CGI. Or in more recent terms, serverless without cold starts. This is how Wasm is the new CGI.<p>^ It&#x27;s not a frivolous claim.<p>&gt; Wasm improves performance, makes process level security much easier, and lowers the cost of building and executing serverless functions. It can run almost any language and with module linking and interface types it lowers the latency between functions incredibly.<p>^ Not unreasonable.<p>I don&#x27;t agree that its necessarily totally &#x27;game changing&#x27;, but if you read this article and you get to the end and you <i>dont</i> agree with:<p>&gt; When you change the constraints in a system you enable things that were impossible before.<p>Then I&#x27;m left scratching my head what it was you actually read, or what the heck you&#x27;re talking about.<p>&gt; Serverless is mostly there to make money for Amazon and Azures of the world and will eventually go the way of the CGI.<p>There&#x27;s... just no possible future, in which AWS and Azure just go away and stop selling something which is making them money, when a new technology comes along and makes it easier, safer and cheaper to it.<p>&gt; I kind of like this variety of headline for it&#x27;s ability to stimulate discussion but it&#x27;s also nonsense. CGI can be any type of code responding to an individual web request, represented as a set of parameters. It has basically nothing to do with wasm<p>*shakes head sadly...*<p>...well, time will tell, but for alllll the naysayers, WASM is here to stay and more and more people are using it for more and more things.<p>Good? Bad? Dunno. ...but it certainly isn&#x27;t some pointless niche tech that no one cares about is about to disappear.<p>CGI enabled a lot of things. WASM does too. The comparison isn&#x27;t totally outrageous. It&#x27;ll be fun to see where it ends up. :)</div><br/></div></div><div id="41795968" class="c"><input type="checkbox" id="c-41795968" checked=""/><div class="controls bullet"><span class="by">TekMol</span><span>|</span><a href="#41796125">prev</a><span>|</span><label class="collapse" for="c-41795968">[-]</label><label class="expand" for="c-41795968">[25 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see WASM as a significant step forward. In fact, I question its purpose altogether.<p>Before WASM you could already compile code from other languages into JavaScript. And have the same benefits as you have with WASM.<p>The only benefit WASM brings is a bit faster execution time. Like twice the speed. Which most applications don&#x27;t need. And which plain JavaScript offers about two years later because computers become faster.<p>And you pay dearly for being these two years ahead in terms of execution time. WASM is much more cumbersome to handle than plain JS when it comes to deployment, execution and debugging.<p>In IT we see it over and over again that saving developer time is more important than saving CPU cycles. So I think chosing WASM over plain JS is a net negative.</div><br/><div id="41796864" class="c"><input type="checkbox" id="c-41796864" checked=""/><div class="controls bullet"><span class="by">DanielHB</span><span>|</span><a href="#41795968">parent</a><span>|</span><a href="#41796090">next</a><span>|</span><label class="collapse" for="c-41796864">[-]</label><label class="expand" for="c-41796864">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Before WASM you could already compile code from other languages into JavaScript. And have the same benefits as you have with WASM.<p>If you are referring to asm.js you must be joking. asm.js was basically a proof of concept and is worse in every way compared to WASM.<p>Like parsing time overhead alone makes it a non-option for most large applications.<p>You seem to imply you should just do it in plain JS instead for &quot;deployment, execution and debugging&quot; benefits. Imagine if you could be free to use those python ML libs in any language of your choice, that alone is enough of an argument. No one is going to reimplement them in JS (or any other environemtn) unless there is a huge ecosystem movement around it.</div><br/></div></div><div id="41796090" class="c"><input type="checkbox" id="c-41796090" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41795968">parent</a><span>|</span><a href="#41796864">prev</a><span>|</span><a href="#41795983">next</a><span>|</span><label class="collapse" for="c-41796090">[-]</label><label class="expand" for="c-41796090">[3 more]</label></div><br/><div class="children"><div class="content">Debugging a Rust program compiled to Javascript is MUCH harder than debugging one compiled to WASM. That is the whole point. And even making the program work when compiled to JS is iffy, as JS has a few breaking constraints, notably that it is single threaded.<p>Sure, native JS is easier still. But there is a huge wealth of code already written in languages that are not JS. If you want a web app that needs this code, you&#x27;ll develop it many times faster by compiling the pre-existing code to WASM than by manually rewriting them in JS, and the experience will be significantly better than compiling that code to JS.</div><br/><div id="41796183" class="c"><input type="checkbox" id="c-41796183" checked=""/><div class="controls bullet"><span class="by">thot_experiment</span><span>|</span><a href="#41795968">root</a><span>|</span><a href="#41796090">parent</a><span>|</span><a href="#41795983">next</a><span>|</span><label class="collapse" for="c-41796183">[-]</label><label class="expand" for="c-41796183">[2 more]</label></div><br/><div class="children"><div class="content">ngl I&#x27;ve tried using Rust -&gt; WASM and it&#x27;s been an awful experience, I&#x27;m much much happier with C. Rust generates enormous blobs because you have to include stdlib, and if you don&#x27;t you don&#x27;t get any of the benefits of using Rust. I&#x27;m probably overrotating on binary size but it sure is nice being able to just read the WASM and make sense of it, which is generally the case for WASM made from C and is absolutely not the case if you&#x27;re building from Rust.</div><br/><div id="41796458" class="c"><input type="checkbox" id="c-41796458" checked=""/><div class="controls bullet"><span class="by">therein</span><span>|</span><a href="#41795968">root</a><span>|</span><a href="#41796183">parent</a><span>|</span><a href="#41795983">next</a><span>|</span><label class="collapse" for="c-41796458">[-]</label><label class="expand" for="c-41796458">[1 more]</label></div><br/><div class="children"><div class="content">Did you run the output through wasm-opt? The size isn&#x27;t terribly bad. I have a whole complex GUI with realtime charts, based on egui, under 4MB uncompressed. This includes three fonts and even some images.</div><br/></div></div></div></div></div></div><div id="41795983" class="c"><input type="checkbox" id="c-41795983" checked=""/><div class="controls bullet"><span class="by">pulse7</span><span>|</span><a href="#41795968">parent</a><span>|</span><a href="#41796090">prev</a><span>|</span><a href="#41796236">next</a><span>|</span><label class="collapse" for="c-41795983">[-]</label><label class="expand" for="c-41795983">[1 more]</label></div><br/><div class="children"><div class="content">When computers become faster, WASM will still be twice the speed of JavaScript, because untyped languages limit the optimizations.</div><br/></div></div><div id="41796236" class="c"><input type="checkbox" id="c-41796236" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#41795968">parent</a><span>|</span><a href="#41795983">prev</a><span>|</span><a href="#41796283">next</a><span>|</span><label class="collapse" for="c-41796236">[-]</label><label class="expand" for="c-41796236">[1 more]</label></div><br/><div class="children"><div class="content">You can probably optimize JS to run as fast in most cases.<p>What actually WASM brings is predictable performance.<p>If you&#x27;re JS wizard, you can shuffle code around, using obscure tricks to make current browser to run it really fast. The problem is: JS wizards are rare and tomorrow browser might actually run the same code much slower if some particular optimization changed.<p>WASM performance is pretty obvious and won&#x27;t change significantly across versions. And you don&#x27;t need to be wizard, you just need to know C and write good enough code, plenty of people can do that. Clang will do the rest.<p>I agree that using WASM instead of JS without reasons probably is not very wise. But people will abuse everything and sometimes it works out, so who knows... The whole modern web was born as abuse of simple language made to blink the text.</div><br/></div></div><div id="41796283" class="c"><input type="checkbox" id="c-41796283" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41795968">parent</a><span>|</span><a href="#41796236">prev</a><span>|</span><a href="#41796039">next</a><span>|</span><label class="collapse" for="c-41796283">[-]</label><label class="expand" for="c-41796283">[1 more]</label></div><br/><div class="children"><div class="content">&gt; WASM is much more cumbersome to handle than plain JS when it comes to deployment, execution and debugging.<p>For some of us it&#x27;s much easier than dealing with Javascript though (for instance debugging C&#x2F;C++ in Visual Studio is much nicer than debugging JS in Chrome - and that&#x27;s possible by simply building for a native target, and then just cross-compile to WASM - but even the WASM debugging situation has improved dramatically with <a href="https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=ms-vscode.wasm-dwarf-debugging" rel="nofollow">https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=ms-vscod...</a>)</div><br/></div></div><div id="41796039" class="c"><input type="checkbox" id="c-41796039" checked=""/><div class="controls bullet"><span class="by">winternewt</span><span>|</span><a href="#41795968">parent</a><span>|</span><a href="#41796283">prev</a><span>|</span><a href="#41796022">next</a><span>|</span><label class="collapse" for="c-41796039">[-]</label><label class="expand" for="c-41796039">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s difficult or impossible to compile many languages into JavaScript. WASM is more general.</div><br/><div id="41796596" class="c"><input type="checkbox" id="c-41796596" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#41795968">root</a><span>|</span><a href="#41796039">parent</a><span>|</span><a href="#41796057">next</a><span>|</span><label class="collapse" for="c-41796596">[-]</label><label class="expand" for="c-41796596">[1 more]</label></div><br/><div class="children"><div class="content">Do you have a source for this?<p>asm.js (the spiritual precursor to WASM) worked pretty much the same, and an awful lot of languages were compiled to it.<p>WASM does provide a more predictable compilation target to be sure, but I don&#x27;t think it actually opens any new possibilities re what languages can be compiled.</div><br/></div></div><div id="41796057" class="c"><input type="checkbox" id="c-41796057" checked=""/><div class="controls bullet"><span class="by">TekMol</span><span>|</span><a href="#41795968">root</a><span>|</span><a href="#41796039">parent</a><span>|</span><a href="#41796596">prev</a><span>|</span><a href="#41796022">next</a><span>|</span><label class="collapse" for="c-41796057">[-]</label><label class="expand" for="c-41796057">[1 more]</label></div><br/><div class="children"><div class="content">Theoretically or because of the tooling landscape?</div><br/></div></div></div></div><div id="41796022" class="c"><input type="checkbox" id="c-41796022" checked=""/><div class="controls bullet"><span class="by">thot_experiment</span><span>|</span><a href="#41795968">parent</a><span>|</span><a href="#41796039">prev</a><span>|</span><a href="#41796045">next</a><span>|</span><label class="collapse" for="c-41796022">[-]</label><label class="expand" for="c-41796022">[9 more]</label></div><br/><div class="children"><div class="content">Bad take. Yes, you can probably optimize a lot of algos in JS such that they are pretty fast, but THAT is cumbersome. I&#x27;d much rather write the things I need to go fast in a language that&#x27;s good at that (I use C for this). I&#x27;m currently working on a toolpath optimizer and I&#x27;m compiling just the optimizer function to WASM, it&#x27;s a couple kilobytes and will probably be an order of magnitude faster than the JS implementation while being FAR LESS cumbersome to write. My JS doesn&#x27;t change at all because i can just call the &quot;native function&quot; from JS, replacing my original JS impl.</div><br/><div id="41796077" class="c"><input type="checkbox" id="c-41796077" checked=""/><div class="controls bullet"><span class="by">xnorswap</span><span>|</span><a href="#41795968">root</a><span>|</span><a href="#41796022">parent</a><span>|</span><a href="#41796028">next</a><span>|</span><label class="collapse" for="c-41796077">[-]</label><label class="expand" for="c-41796077">[2 more]</label></div><br/><div class="children"><div class="content">Javascript is incredibly well optimised, I&#x27;m surprised if there&#x27;s an order of magnitude difference between JS and WASM without a fundamental difference in algorithm chosen.</div><br/><div id="41796118" class="c"><input type="checkbox" id="c-41796118" checked=""/><div class="controls bullet"><span class="by">thot_experiment</span><span>|</span><a href="#41795968">root</a><span>|</span><a href="#41796077">parent</a><span>|</span><a href="#41796028">next</a><span>|</span><label class="collapse" for="c-41796118">[-]</label><label class="expand" for="c-41796118">[1 more]</label></div><br/><div class="children"><div class="content">I will likely spend time implementing my solver in several different styles because this is a project I&#x27;m tackling largely to make some points about how <i>I</i> think WASM should be used. I&#x27;m far from final benchmarks on this but my suspicion is that the gap will be large.<p>Yes javascript is very well optimized, but as someone who&#x27;s spent a lot of time writing javascript where speed matters, it&#x27;s not easy, and it&#x27;s not predictable. You&#x27;re at the mercy of arcane optimizations in V8 which might not work for your specific situation because you did something weird, and if you&#x27;re taking a lot of care not to do anything weird, and manually managing your memory with typed arrays, well, then you might as well write C and compile to WASM.</div><br/></div></div></div></div><div id="41796028" class="c"><input type="checkbox" id="c-41796028" checked=""/><div class="controls bullet"><span class="by">TekMol</span><span>|</span><a href="#41795968">root</a><span>|</span><a href="#41796022">parent</a><span>|</span><a href="#41796077">prev</a><span>|</span><a href="#41796045">next</a><span>|</span><label class="collapse" for="c-41796028">[-]</label><label class="expand" for="c-41796028">[6 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    probably be an order of magnitude
    faster than the JS implementation
</code></pre>
What makes you think so?</div><br/><div id="41796061" class="c"><input type="checkbox" id="c-41796061" checked=""/><div class="controls bullet"><span class="by">thot_experiment</span><span>|</span><a href="#41795968">root</a><span>|</span><a href="#41796028">parent</a><span>|</span><a href="#41796045">next</a><span>|</span><label class="collapse" for="c-41796061">[-]</label><label class="expand" for="c-41796061">[5 more]</label></div><br/><div class="children"><div class="content">Off the rip because I didn&#x27;t spend time to make the JS implementation keep all of it&#x27;s data in a typed array that I manually manage, because it&#x27;s tedious to do that in JS and it&#x27;s straightforward in C. Though I&#x27;m betting there are other benefits I&#x27;ll get from -O2 and static analysis.</div><br/><div id="41796088" class="c"><input type="checkbox" id="c-41796088" checked=""/><div class="controls bullet"><span class="by">TekMol</span><span>|</span><a href="#41795968">root</a><span>|</span><a href="#41796061">parent</a><span>|</span><a href="#41796045">next</a><span>|</span><label class="collapse" for="c-41796088">[-]</label><label class="expand" for="c-41796088">[4 more]</label></div><br/><div class="children"><div class="content">Compiling your C to WASM might make it run twice as fast as compiling it to JS.<p>That&#x27;s all. All other aspects of the workflow are the same.</div><br/><div id="41796139" class="c"><input type="checkbox" id="c-41796139" checked=""/><div class="controls bullet"><span class="by">thot_experiment</span><span>|</span><a href="#41795968">root</a><span>|</span><a href="#41796088">parent</a><span>|</span><a href="#41796045">next</a><span>|</span><label class="collapse" for="c-41796139">[-]</label><label class="expand" for="c-41796139">[3 more]</label></div><br/><div class="children"><div class="content">I will try but I suspect the final score will be<p><pre><code>    1. WASM
    2. JS handwritten for speed
    3. C compiled to JS
</code></pre>
and the gaps will be greater than 2x</div><br/><div id="41796350" class="c"><input type="checkbox" id="c-41796350" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41795968">root</a><span>|</span><a href="#41796139">parent</a><span>|</span><a href="#41796176">next</a><span>|</span><label class="collapse" for="c-41796350">[-]</label><label class="expand" for="c-41796350">[1 more]</label></div><br/><div class="children"><div class="content">You forgot &#x27;C compiled to the asm.js subset of Javascript&#x27;, that would be on second place right after WASM (the switch from asm.js to WASM was hardly noticeable in my C&#x2F;C++ code performance-wise - some browsers had special &#x27;fast paths&#x27; for the asm.js subset though).</div><br/></div></div><div id="41796176" class="c"><input type="checkbox" id="c-41796176" checked=""/><div class="controls bullet"><span class="by">TekMol</span><span>|</span><a href="#41795968">root</a><span>|</span><a href="#41796139">parent</a><span>|</span><a href="#41796350">prev</a><span>|</span><a href="#41796045">next</a><span>|</span><label class="collapse" for="c-41796176">[-]</label><label class="expand" for="c-41796176">[1 more]</label></div><br/><div class="children"><div class="content">Awesome. I will notice when you reply here, no matter when. I routinely check for new replies even to old comments.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41796045" class="c"><input type="checkbox" id="c-41796045" checked=""/><div class="controls bullet"><span class="by">jamil7</span><span>|</span><a href="#41795968">parent</a><span>|</span><a href="#41796022">prev</a><span>|</span><a href="#41796085">next</a><span>|</span><label class="collapse" for="c-41796045">[-]</label><label class="expand" for="c-41796045">[4 more]</label></div><br/><div class="children"><div class="content">You’re assuming a lot of things in this comment, it seems like you believe every software engineer is working with the same constraints, language and platform as yourself.</div><br/><div id="41796066" class="c"><input type="checkbox" id="c-41796066" checked=""/><div class="controls bullet"><span class="by">TekMol</span><span>|</span><a href="#41795968">root</a><span>|</span><a href="#41796045">parent</a><span>|</span><a href="#41796085">next</a><span>|</span><label class="collapse" for="c-41796066">[-]</label><label class="expand" for="c-41796066">[3 more]</label></div><br/><div class="children"><div class="content">No. I say we could build the same dev experience to non-js coders by offering them compile-2-js tools instead of compile-2-wasm tools.</div><br/><div id="41796861" class="c"><input type="checkbox" id="c-41796861" checked=""/><div class="controls bullet"><span class="by">jamil7</span><span>|</span><a href="#41795968">root</a><span>|</span><a href="#41796066">parent</a><span>|</span><a href="#41796085">next</a><span>|</span><label class="collapse" for="c-41796861">[-]</label><label class="expand" for="c-41796861">[2 more]</label></div><br/><div class="children"><div class="content">Not really because then you need a JS environment everywhere you want to run your code. If I write a Rust module I have the possibility to compile to WASM or machine code. This is what I meant in my other comment, your assumption is everyone is making browser apps in Javascript that don&#x27;t have any performance or resource constraints.</div><br/><div id="41796924" class="c"><input type="checkbox" id="c-41796924" checked=""/><div class="controls bullet"><span class="by">TekMol</span><span>|</span><a href="#41795968">root</a><span>|</span><a href="#41796861">parent</a><span>|</span><a href="#41796085">next</a><span>|</span><label class="collapse" for="c-41796924">[-]</label><label class="expand" for="c-41796924">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    possibility to compile to WASM or machine code
</code></pre>
How is this better than &quot;possibility to compile to JS or machine code&quot;?</div><br/></div></div></div></div></div></div></div></div><div id="41796085" class="c"><input type="checkbox" id="c-41796085" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41795968">parent</a><span>|</span><a href="#41796045">prev</a><span>|</span><label class="collapse" for="c-41796085">[-]</label><label class="expand" for="c-41796085">[1 more]</label></div><br/><div class="children"><div class="content">The days of computers doubling in speed every 2 years are loooong gone.<p>Look into the history of WASM. They did try compiling everything into JS with asm.js, but then sensibly decided to do things properly. I don&#x27;t know why anyone would object to proper engineering.</div><br/></div></div></div></div></div></div></div></div></div></body></html>