<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705827653097" as="style"/><link rel="stylesheet" href="styles.css?v=1705827653097"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://flak.tedunangst.com/post/memory-leak-proof-every-C-program">Memory leak proof every C program</a> <span class="domain">(<a href="https://flak.tedunangst.com">flak.tedunangst.com</a>)</span></div><div class="subtext"><span>jandeboevrie</span> | <span>131 comments</span></div><br/><div><div id="39072496" class="c"><input type="checkbox" id="c-39072496" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#39062767">next</a><span>|</span><label class="collapse" for="c-39072496">[-]</label><label class="expand" for="c-39072496">[65 more]</label></div><br/><div class="children"><div class="content">This is the core idea:<p>&gt; It is [...] entirely optional to call free. If you don’t call free, memory usage will increase over time, but technically, it’s not a leak. As an optimization, you may choose to call free to reduce memory, but again, strictly optional.<p>This is beautiful!  Unless your program is long-running, there&#x27;s no point of ever calling free in your C programs.  The system will free the memory for you when the program ends.  Free-less C programming is an exhilarating experience that I recommend to anybody.<p>In the rare cases where your program needs to be long-running, leaks may become a real problem.  In that case, it&#x27;s better to write a long-running shell script that calls a pipeline of elegant free-less C programs.</div><br/><div id="39073180" class="c"><input type="checkbox" id="c-39073180" checked=""/><div class="controls bullet"><span class="by">rco8786</span><span>|</span><a href="#39072496">parent</a><span>|</span><a href="#39073086">next</a><span>|</span><label class="collapse" for="c-39073180">[-]</label><label class="expand" for="c-39073180">[25 more]</label></div><br/><div class="children"><div class="content">Reminds me of the HFT shop that built in Java and simply turned the garbage collector off. Then when the market closed they would restart the process for the next day.</div><br/><div id="39074976" class="c"><input type="checkbox" id="c-39074976" checked=""/><div class="controls bullet"><span class="by">JB_Dev</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073180">parent</a><span>|</span><a href="#39074138">next</a><span>|</span><label class="collapse" for="c-39074976">[-]</label><label class="expand" for="c-39074976">[1 more]</label></div><br/><div class="children"><div class="content">I’ve done something similar in one of our production services. There was a problem with extremely long GC pauses during Gen2 garbage collection (.NET uses a multigenerational GC design). Pauses could be many seconds long or more than a minute in extreme cases.<p>We found the underlying issue that caused memory pressure in the Gen2 region but the fix was to change some very fundamental aspects of the service and would need to have some significant refactoring. Since this was a legacy service (.net framework) that we were refactoring anyway to run in new .NET (5+), we decided to ignore the issue.<p>Instead we adjusted the GC to just never do the expensive Gen2 collections (GCLatencyMode) and moved the service to run on higher memory VMs. It would hit OOM every 3 days or so, so we just set instances to auto-restart once a day.<p>Then 1 year later we deployed the replacement for the legacy service and the problem was solved.</div><br/></div></div><div id="39074138" class="c"><input type="checkbox" id="c-39074138" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073180">parent</a><span>|</span><a href="#39074976">prev</a><span>|</span><a href="#39074783">next</a><span>|</span><label class="collapse" for="c-39074138">[-]</label><label class="expand" for="c-39074138">[7 more]</label></div><br/><div class="children"><div class="content">I had a friend who worked for one of the big Market Makers, and he told me that they would indeed turn the GC off, but what they&#x27;d do is just pre-allocate everything into bigass arrays before-hand, and have incrementers to simulate the &quot;new&quot; keyword. They might do this in something more or less like a threadlocal to avoid having to deal with locks or race conditions or anything like that.</div><br/><div id="39076789" class="c"><input type="checkbox" id="c-39076789" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39074138">parent</a><span>|</span><a href="#39074344">next</a><span>|</span><label class="collapse" for="c-39076789">[-]</label><label class="expand" for="c-39076789">[1 more]</label></div><br/><div class="children"><div class="content">This is like going back to malloc and free but using array indices rather than pointers, and each type has a fixed-size heap. We did it at Microsoft because the very first .NET releases had slow GCs.</div><br/></div></div><div id="39074344" class="c"><input type="checkbox" id="c-39074344" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39074138">parent</a><span>|</span><a href="#39076789">prev</a><span>|</span><a href="#39074317">next</a><span>|</span><label class="collapse" for="c-39074344">[-]</label><label class="expand" for="c-39074344">[2 more]</label></div><br/><div class="children"><div class="content">This is called bump or arena allocation, depending on how you want to define it.</div><br/><div id="39076409" class="c"><input type="checkbox" id="c-39076409" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39074344">parent</a><span>|</span><a href="#39074317">next</a><span>|</span><label class="collapse" for="c-39076409">[-]</label><label class="expand" for="c-39076409">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes also referred to as Object pools.</div><br/></div></div></div></div><div id="39074317" class="c"><input type="checkbox" id="c-39074317" checked=""/><div class="controls bullet"><span class="by">shortrounddev2</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39074138">parent</a><span>|</span><a href="#39074344">prev</a><span>|</span><a href="#39074783">next</a><span>|</span><label class="collapse" for="c-39074317">[-]</label><label class="expand" for="c-39074317">[3 more]</label></div><br/><div class="children"><div class="content">A lot of game engines do this, avoiding the cost of a malloc lookup by just allocating everything as a stack</div><br/><div id="39075298" class="c"><input type="checkbox" id="c-39075298" checked=""/><div class="controls bullet"><span class="by">tarnith</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39074317">parent</a><span>|</span><a href="#39074783">next</a><span>|</span><label class="collapse" for="c-39075298">[-]</label><label class="expand" for="c-39075298">[2 more]</label></div><br/><div class="children"><div class="content">Seen some audio engines that do this too. You can come up with an elegant non-blocking lock free allocator and pass updates from the user thread out to system and reserve the memory, or you can just up front allocate everything that&#x27;s needed.<p>If it&#x27;s a fixed function synth, sometimes just allocating everything up front makes more sense.</div><br/><div id="39075887" class="c"><input type="checkbox" id="c-39075887" checked=""/><div class="controls bullet"><span class="by">gabesk</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39075298">parent</a><span>|</span><a href="#39074783">next</a><span>|</span><label class="collapse" for="c-39075887">[-]</label><label class="expand" for="c-39075887">[1 more]</label></div><br/><div class="children"><div class="content">Kernel drivers, too. Especially the DMA buffers for devices that don’t support scatter gather: if you don’t allocate them at driver startup, you might not be able to find enough free contiguous regions later. Although maybe that’s not as big of a deal these days, since both Windows and Linux can relocate physical pages.</div><br/></div></div></div></div></div></div></div></div><div id="39074783" class="c"><input type="checkbox" id="c-39074783" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073180">parent</a><span>|</span><a href="#39074138">prev</a><span>|</span><a href="#39073487">next</a><span>|</span><label class="collapse" for="c-39074783">[-]</label><label class="expand" for="c-39074783">[1 more]</label></div><br/><div class="children"><div class="content">Many online games regularly schedule a downtime often to simply restart the process and &quot;solve&quot; moderate memory leaks.</div><br/></div></div><div id="39073487" class="c"><input type="checkbox" id="c-39073487" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073180">parent</a><span>|</span><a href="#39074783">prev</a><span>|</span><a href="#39073367">next</a><span>|</span><label class="collapse" for="c-39073487">[-]</label><label class="expand" for="c-39073487">[1 more]</label></div><br/><div class="children"><div class="content">It’s available from Java 11 as the Epsilon GC.</div><br/></div></div><div id="39073367" class="c"><input type="checkbox" id="c-39073367" checked=""/><div class="controls bullet"><span class="by">HideousKojima</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073180">parent</a><span>|</span><a href="#39073487">prev</a><span>|</span><a href="#39074375">next</a><span>|</span><label class="collapse" for="c-39073367">[-]</label><label class="expand" for="c-39073367">[12 more]</label></div><br/><div class="children"><div class="content">Or the missile firmware where the missile is going to explode before they run out of memory:<p><a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20180228-00&#x2F;?p=98125" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20180228-00&#x2F;?p=98...</a></div><br/><div id="39073568" class="c"><input type="checkbox" id="c-39073568" checked=""/><div class="controls bullet"><span class="by">tetromino_</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073367">parent</a><span>|</span><a href="#39073461">next</a><span>|</span><label class="collapse" for="c-39073568">[-]</label><label class="expand" for="c-39073568">[9 more]</label></div><br/><div class="children"><div class="content">Using warhead explosion as garbage collector might seem like a clever hack, but all it takes is an upgrade by a different team (say, adding a new engine, or longer-range sensors, or repurposing a surface-to-air missile for a surface-to-surface role), and suddenly your guidance software runs out of memory before it explodes, and your missile falls onto an an elementary school or hospital.</div><br/><div id="39074804" class="c"><input type="checkbox" id="c-39074804" checked=""/><div class="controls bullet"><span class="by">zlsa</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073568">parent</a><span>|</span><a href="#39076694">next</a><span>|</span><label class="collapse" for="c-39074804">[-]</label><label class="expand" for="c-39074804">[3 more]</label></div><br/><div class="children"><div class="content">Related: the Ariane 5 rocket failed on its maiden flight because it reused code from its predecessor, which made an assumption that didn&#x27;t apply to the higher-performance Ariane 5.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ariane_flight_V88" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ariane_flight_V88</a></div><br/><div id="39075880" class="c"><input type="checkbox" id="c-39075880" checked=""/><div class="controls bullet"><span class="by">h0l0cube</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39074804">parent</a><span>|</span><a href="#39076694">next</a><span>|</span><label class="collapse" for="c-39075880">[-]</label><label class="expand" for="c-39075880">[2 more]</label></div><br/><div class="children"><div class="content">Seems like a mitigation for this kind of issue would be to simulate the inputs to the system for the expected flight duration.</div><br/><div id="39076458" class="c"><input type="checkbox" id="c-39076458" checked=""/><div class="controls bullet"><span class="by">kitd</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39075880">parent</a><span>|</span><a href="#39076694">next</a><span>|</span><label class="collapse" for="c-39076458">[-]</label><label class="expand" for="c-39076458">[1 more]</label></div><br/><div class="children"><div class="content">IIRC it was the higher acceleration value of Ariane5 that the old code wasn&#x27;t expecting that caused the problem. Some fuzz testing could have worked, I suppose.</div><br/></div></div></div></div></div></div><div id="39076694" class="c"><input type="checkbox" id="c-39076694" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073568">parent</a><span>|</span><a href="#39074804">prev</a><span>|</span><a href="#39074350">next</a><span>|</span><label class="collapse" for="c-39076694">[-]</label><label class="expand" for="c-39076694">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and your missile falls onto an an elementary school or hospital.<p>Then you just say terrorists were hiding inside…</div><br/></div></div><div id="39074350" class="c"><input type="checkbox" id="c-39074350" checked=""/><div class="controls bullet"><span class="by">shortrounddev2</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073568">parent</a><span>|</span><a href="#39076694">prev</a><span>|</span><a href="#39074009">next</a><span>|</span><label class="collapse" for="c-39074350">[-]</label><label class="expand" for="c-39074350">[1 more]</label></div><br/><div class="children"><div class="content">I assume they would test the missiles before attesting to its range</div><br/></div></div><div id="39074009" class="c"><input type="checkbox" id="c-39074009" checked=""/><div class="controls bullet"><span class="by">HideousKojima</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073568">parent</a><span>|</span><a href="#39074350">prev</a><span>|</span><a href="#39074787">next</a><span>|</span><label class="collapse" for="c-39074009">[-]</label><label class="expand" for="c-39074009">[2 more]</label></div><br/><div class="children"><div class="content">You can probably double the ram (or more) again by then.</div><br/><div id="39076696" class="c"><input type="checkbox" id="c-39076696" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39074009">parent</a><span>|</span><a href="#39074787">next</a><span>|</span><label class="collapse" for="c-39076696">[-]</label><label class="expand" for="c-39076696">[1 more]</label></div><br/><div class="children"><div class="content">Assuming you know you have to do it.</div><br/></div></div></div></div><div id="39074787" class="c"><input type="checkbox" id="c-39074787" checked=""/><div class="controls bullet"><span class="by">wegfawefgawefg</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073568">parent</a><span>|</span><a href="#39074009">prev</a><span>|</span><a href="#39073461">next</a><span>|</span><label class="collapse" for="c-39074787">[-]</label><label class="expand" for="c-39074787">[1 more]</label></div><br/><div class="children"><div class="content">But sir!! They were nazi orphans!</div><br/></div></div></div></div><div id="39073461" class="c"><input type="checkbox" id="c-39073461" checked=""/><div class="controls bullet"><span class="by">jnwatson</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073367">parent</a><span>|</span><a href="#39073568">prev</a><span>|</span><a href="#39075273">next</a><span>|</span><label class="collapse" for="c-39073461">[-]</label><label class="expand" for="c-39073461">[1 more]</label></div><br/><div class="children"><div class="content">There was a certain Space Shuttle program that never returned from interrupt. At the end of its interrupt handler, it would just spin. The next interrupt would just add to the call stack.<p>What happens when it runs out of stack? It just resets the stack pointer back to the start.</div><br/></div></div><div id="39075273" class="c"><input type="checkbox" id="c-39075273" checked=""/><div class="controls bullet"><span class="by">queuebert</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073367">parent</a><span>|</span><a href="#39073461">prev</a><span>|</span><a href="#39074375">next</a><span>|</span><label class="collapse" for="c-39075273">[-]</label><label class="expand" for="c-39075273">[1 more]</label></div><br/><div class="children"><div class="content">God, that email takes me back to days when email was much higher signal-to-noise and sig lines were for color, not credentials.</div><br/></div></div></div></div><div id="39074375" class="c"><input type="checkbox" id="c-39074375" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073180">parent</a><span>|</span><a href="#39073367">prev</a><span>|</span><a href="#39073385">next</a><span>|</span><label class="collapse" for="c-39074375">[-]</label><label class="expand" for="c-39074375">[1 more]</label></div><br/><div class="children"><div class="content">it is somewhat common in garbage collected langages to fight the garrbage collector like that. Sure manual free probably adds up to more CPU time, but it is more spread out and thus not noticable (normally, real time still cannot allocate in the sensitive areas)</div><br/></div></div></div></div><div id="39073086" class="c"><input type="checkbox" id="c-39073086" checked=""/><div class="controls bullet"><span class="by">RustyRussell</span><span>|</span><a href="#39072496">parent</a><span>|</span><a href="#39073180">prev</a><span>|</span><a href="#39073691">next</a><span>|</span><label class="collapse" for="c-39073086">[-]</label><label class="expand" for="c-39073086">[2 more]</label></div><br/><div class="children"><div class="content">Hilarious!<p>But I remember the first time I saw such a program which never freed anything: jitterbug, the simple bug tracker which ran as a CGI script.<p>It indeed allows a very simple style!<p>Meanwhile, use ccan&#x2F;tal (<a href="https:&#x2F;&#x2F;github.com&#x2F;rustyrussell&#x2F;ccan&#x2F;blob&#x2F;master&#x2F;ccan&#x2F;tal&#x2F;_info">https:&#x2F;&#x2F;github.com&#x2F;rustyrussell&#x2F;ccan&#x2F;blob&#x2F;master&#x2F;ccan&#x2F;tal&#x2F;_i...</a>) and be happy :)</div><br/><div id="39074496" class="c"><input type="checkbox" id="c-39074496" checked=""/><div class="controls bullet"><span class="by">ramses0</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073086">parent</a><span>|</span><a href="#39073691">next</a><span>|</span><label class="collapse" for="c-39074496">[-]</label><label class="expand" for="c-39074496">[1 more]</label></div><br/><div class="children"><div class="content">I did a watch face on pebble once... the programming style was &quot;uncommon&quot; when you&#x27;re hardcoding the ONE watch face that is currently rendering the screen. It &quot;felt&quot; very leaky and illegal... but it&#x27;s a watch face with limited functionality, so... shrug?</div><br/></div></div></div></div><div id="39073691" class="c"><input type="checkbox" id="c-39073691" checked=""/><div class="controls bullet"><span class="by">alexgartrell</span><span>|</span><a href="#39072496">parent</a><span>|</span><a href="#39073086">prev</a><span>|</span><a href="#39072616">next</a><span>|</span><label class="collapse" for="c-39073691">[-]</label><label class="expand" for="c-39073691">[2 more]</label></div><br/><div class="children"><div class="content">A professor actually told us that freeing prior to exit was harmful, because you may spend all of that time resurrecting swapped pages for no real benefit.<p>Counterpoint is that debugging leaks is ~hopeless unless you have the ability to prune “intentional leaks” at exit</div><br/><div id="39073794" class="c"><input type="checkbox" id="c-39073794" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073691">parent</a><span>|</span><a href="#39072616">next</a><span>|</span><label class="collapse" for="c-39073794">[-]</label><label class="expand" for="c-39073794">[1 more]</label></div><br/><div class="children"><div class="content">&gt; debugging leaks is ~hopeless unless you have the ability to prune “intentional leaks” at exit<p>Not in general.  It depends on your debugger.  For example, valgrind distinguishes between harmless &quot;visible leaks&quot;, memory blocks allocated from main or on global variables, and &quot;true leaks&quot; that you cannot free anymore.  The first ones are given a simple warning by the leak detector, while the true leaks are actual errors.</div><br/></div></div></div></div><div id="39072616" class="c"><input type="checkbox" id="c-39072616" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#39072496">parent</a><span>|</span><a href="#39073691">prev</a><span>|</span><a href="#39073259">next</a><span>|</span><label class="collapse" for="c-39072616">[-]</label><label class="expand" for="c-39072616">[14 more]</label></div><br/><div class="children"><div class="content">In the not-rare case where you&#x27;re writing a library, or wrapping a utility, the last programmer&#x27;s exhilaration is your pain.</div><br/><div id="39072957" class="c"><input type="checkbox" id="c-39072957" checked=""/><div class="controls bullet"><span class="by">linkdd</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39072616">parent</a><span>|</span><a href="#39074581">next</a><span>|</span><label class="collapse" for="c-39072957">[-]</label><label class="expand" for="c-39072957">[11 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re writing a library, you&#x27;re not writing a program.<p>If you write a C library, it is a good practice to leave the allocations to the library user, or at least provide a way to override the library&#x27;s allocator. Allowing your user to write a free-less *program*.</div><br/><div id="39073014" class="c"><input type="checkbox" id="c-39073014" checked=""/><div class="controls bullet"><span class="by">MrJohz</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39072957">parent</a><span>|</span><a href="#39073287">next</a><span>|</span><label class="collapse" for="c-39073014">[-]</label><label class="expand" for="c-39073014">[5 more]</label></div><br/><div class="children"><div class="content">Any large program is composed of libraries. They may not explicitly be described as libraries, or imported from external sources, but there will be abstraction boundaries somewhere.<p>Which means that if you&#x27;re writing a program, you probably are also writing one or more libraries.</div><br/><div id="39073389" class="c"><input type="checkbox" id="c-39073389" checked=""/><div class="controls bullet"><span class="by">kbenson</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073014">parent</a><span>|</span><a href="#39073287">next</a><span>|</span><label class="collapse" for="c-39073389">[-]</label><label class="expand" for="c-39073389">[4 more]</label></div><br/><div class="children"><div class="content">The difference is that if you&#x27;re writing a program you know the scope of use of all libraries, whether they be externally loaded or internal abstraction boundaries, and also know the scope of use of the program, and can make a call as to whether cleanup during opetation is required.</div><br/><div id="39074430" class="c"><input type="checkbox" id="c-39074430" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073389">parent</a><span>|</span><a href="#39073287">next</a><span>|</span><label class="collapse" for="c-39074430">[-]</label><label class="expand" for="c-39074430">[3 more]</label></div><br/><div class="children"><div class="content">Not really. In theory you can, but in practice there are parts written by a different team and you don&#x27;t know the scope of there parts.<p>I also know someone who maintains some Clinton era encryption. that code is controlled who can know about it as obsecurity was all you were allowed. There are other pathalogical cases where you can&#x27;t know everything about your program-</div><br/><div id="39074766" class="c"><input type="checkbox" id="c-39074766" checked=""/><div class="controls bullet"><span class="by">linkdd</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39074430">parent</a><span>|</span><a href="#39074879">next</a><span>|</span><label class="collapse" for="c-39074766">[-]</label><label class="expand" for="c-39074766">[1 more]</label></div><br/><div class="children"><div class="content">Obviously, the &quot;free-less programs&quot; are not a &quot;one size fits all&quot; option. Like pretty much everything in IT and the dev world.</div><br/></div></div><div id="39074879" class="c"><input type="checkbox" id="c-39074879" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39074430">parent</a><span>|</span><a href="#39074766">prev</a><span>|</span><a href="#39073287">next</a><span>|</span><label class="collapse" for="c-39074879">[-]</label><label class="expand" for="c-39074879">[1 more]</label></div><br/><div class="children"><div class="content">But those parts, if they exist, are irrelevant to the current discussion, because they are not the parts you are writing.</div><br/></div></div></div></div></div></div></div></div><div id="39073287" class="c"><input type="checkbox" id="c-39073287" checked=""/><div class="controls bullet"><span class="by">avgcorrection</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39072957">parent</a><span>|</span><a href="#39073014">prev</a><span>|</span><a href="#39074581">next</a><span>|</span><label class="collapse" for="c-39073287">[-]</label><label class="expand" for="c-39073287">[5 more]</label></div><br/><div class="children"><div class="content">Yeah I don’t know how a C library without `_free()` calls would work across FFI (like making bindings).</div><br/><div id="39073486" class="c"><input type="checkbox" id="c-39073486" checked=""/><div class="controls bullet"><span class="by">the-smug-one</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073287">parent</a><span>|</span><a href="#39074581">next</a><span>|</span><label class="collapse" for="c-39073486">[-]</label><label class="expand" for="c-39073486">[4 more]</label></div><br/><div class="children"><div class="content">Why would FFI be an issue?</div><br/><div id="39074386" class="c"><input type="checkbox" id="c-39074386" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073486">parent</a><span>|</span><a href="#39073707">next</a><span>|</span><label class="collapse" for="c-39074386">[-]</label><label class="expand" for="c-39074386">[1 more]</label></div><br/><div class="children"><div class="content">It’s important to use the same allocator to free as you allocate with. You can’t assume that the same allocator is linked to both sides, so if you are allocating and then giving something to something else over FFI, you want to make sure you give them a way to call back into you to free.<p>This is true irrespective of language.</div><br/></div></div><div id="39073707" class="c"><input type="checkbox" id="c-39073707" checked=""/><div class="controls bullet"><span class="by">avgcorrection</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073486">parent</a><span>|</span><a href="#39074386">prev</a><span>|</span><a href="#39074581">next</a><span>|</span><label class="collapse" for="c-39073707">[-]</label><label class="expand" for="c-39073707">[2 more]</label></div><br/><div class="children"><div class="content">Maybe you allocate a string and pass it to Rust code. Then the Rust code needs a way to free it (through `drop`).</div><br/><div id="39074011" class="c"><input type="checkbox" id="c-39074011" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073707">parent</a><span>|</span><a href="#39074581">next</a><span>|</span><label class="collapse" for="c-39074011">[-]</label><label class="expand" for="c-39074011">[1 more]</label></div><br/><div class="children"><div class="content">1st approach) you don&#x27;t<p>2nd approach for when you ignore the first) you use a type that doesn&#x27;t &quot;own&quot; the pointer, and have the FFI side that allocated it free it<p>3rd approach for when you find out you can&#x27;t do the 2nd) hope that the &quot;owned&quot; type is actually generic over the allocator used, and make an allocator that doesn&#x27;t free (or even better, calls the correct free over the FFI boundary). `allocator-api` is the effort in this direction.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39074581" class="c"><input type="checkbox" id="c-39074581" checked=""/><div class="controls bullet"><span class="by">etimberg</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39072616">parent</a><span>|</span><a href="#39072957">prev</a><span>|</span><a href="#39073259">next</a><span>|</span><label class="collapse" for="c-39074581">[-]</label><label class="expand" for="c-39074581">[2 more]</label></div><br/><div class="children"><div class="content">Early in my career I saw the aftermath of someone trying to deal with this problem. The solution they went with was to replace all allocations in the offending code with a custom allocator and then just throw the allocator away every so often</div><br/><div id="39074648" class="c"><input type="checkbox" id="c-39074648" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39074581">parent</a><span>|</span><a href="#39073259">next</a><span>|</span><label class="collapse" for="c-39074648">[-]</label><label class="expand" for="c-39074648">[1 more]</label></div><br/><div class="children"><div class="content">Was there any way for them to know when it was safe to do so? If not:  Wouldn&#x27;t stopping and restarting the program be better?</div><br/></div></div></div></div></div></div><div id="39073259" class="c"><input type="checkbox" id="c-39073259" checked=""/><div class="controls bullet"><span class="by">marcodiego</span><span>|</span><a href="#39072496">parent</a><span>|</span><a href="#39072616">prev</a><span>|</span><a href="#39072882">next</a><span>|</span><label class="collapse" for="c-39073259">[-]</label><label class="expand" for="c-39073259">[1 more]</label></div><br/><div class="children"><div class="content">Actually that is not too far from reality. Data that will be allocated only once does not need be freed. You really only need to free memory that may increase iteratively. If the memory is not used frequently it will end up on swap without major implications. If it is used during the whole execution, it will only be freed when the program ends; there&#x27;s difference if it&#x27;s by a &#x27;free&#x27; or by the OS; there&#x27;s just no difference.<p>As an example, constant data that is allocated by GNU Nano is never freed. AFAIK, the same happens when you use GTK or QT; there were even tips on how to suppress valgrind warnings when using such libs.</div><br/></div></div><div id="39072882" class="c"><input type="checkbox" id="c-39072882" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#39072496">parent</a><span>|</span><a href="#39073259">prev</a><span>|</span><a href="#39073085">next</a><span>|</span><label class="collapse" for="c-39072882">[-]</label><label class="expand" for="c-39072882">[3 more]</label></div><br/><div class="children"><div class="content">This solution did not override &quot;free&quot; to free the extra struct, so calling free is in fact not optional but probably a bad idea.  Need an extra patch:<p><pre><code>    #define free(_) &#x2F;* no-op *&#x2F;</code></pre></div><br/><div id="39074369" class="c"><input type="checkbox" id="c-39074369" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39072882">parent</a><span>|</span><a href="#39074263">next</a><span>|</span><label class="collapse" for="c-39074369">[-]</label><label class="expand" for="c-39074369">[1 more]</label></div><br/><div class="children"><div class="content">Nitpick: for maximum source compatibility, use this instead:<p><pre><code>    #define free(_) ((void)0)</code></pre></div><br/></div></div><div id="39074263" class="c"><input type="checkbox" id="c-39074263" checked=""/><div class="controls bullet"><span class="by">hamburglar</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39072882">parent</a><span>|</span><a href="#39074369">prev</a><span>|</span><a href="#39073085">next</a><span>|</span><label class="collapse" for="c-39074263">[-]</label><label class="expand" for="c-39074263">[1 more]</label></div><br/><div class="children"><div class="content">Best criticism to this tongue-in-cheek solution yet.   I’ll add my own more minor criticism: it will explode if the leaksaver struct allocation ever fails because it doesn’t check the result.<p>That does it. I am not going to use it.</div><br/></div></div></div></div><div id="39073085" class="c"><input type="checkbox" id="c-39073085" checked=""/><div class="controls bullet"><span class="by">zanderwohl</span><span>|</span><a href="#39072496">parent</a><span>|</span><a href="#39072882">prev</a><span>|</span><a href="#39073277">next</a><span>|</span><label class="collapse" for="c-39073085">[-]</label><label class="expand" for="c-39073085">[3 more]</label></div><br/><div class="children"><div class="content">The Zig compiler does this on purpose in some cases, iirc. Free can be a waste of time if the program is going to die in half a second from
now.</div><br/><div id="39073674" class="c"><input type="checkbox" id="c-39073674" checked=""/><div class="controls bullet"><span class="by">toasterlovin</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073085">parent</a><span>|</span><a href="#39073277">next</a><span>|</span><label class="collapse" for="c-39073674">[-]</label><label class="expand" for="c-39073674">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, I first came across this strategy as a performance optimization in something Jared Sumner wrote about Bun (which is written in Zig).</div><br/><div id="39076610" class="c"><input type="checkbox" id="c-39076610" checked=""/><div class="controls bullet"><span class="by">subtra3t</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073674">parent</a><span>|</span><a href="#39073277">next</a><span>|</span><label class="collapse" for="c-39076610">[-]</label><label class="expand" for="c-39076610">[1 more]</label></div><br/><div class="children"><div class="content">Link to devblog article&#x2F;tweet?</div><br/></div></div></div></div></div></div><div id="39073277" class="c"><input type="checkbox" id="c-39073277" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#39072496">parent</a><span>|</span><a href="#39073085">prev</a><span>|</span><a href="#39073554">next</a><span>|</span><label class="collapse" for="c-39073277">[-]</label><label class="expand" for="c-39073277">[1 more]</label></div><br/><div class="children"><div class="content">The go guys knew this all along, because if I understood it correctly this is what happens when you disable the garbage collector. Voila, now you can claim your garbage collector is totally optional and your language fundamentally doesn&#x27;t require a garbage collector.<p>[I love golang, and I think it&#x27;s one of the best languages around. If only it had a truly optional garbage collector. But then again, it wouldn&#x27;t be go I guess...]</div><br/></div></div><div id="39073554" class="c"><input type="checkbox" id="c-39073554" checked=""/><div class="controls bullet"><span class="by">didgetmaster</span><span>|</span><a href="#39072496">parent</a><span>|</span><a href="#39073277">prev</a><span>|</span><a href="#39074585">next</a><span>|</span><label class="collapse" for="c-39073554">[-]</label><label class="expand" for="c-39073554">[1 more]</label></div><br/><div class="children"><div class="content">&gt;In the rare cases where your program needs to be long-running, leaks may become a real problem.<p>Where did this idea come from? I have seen leaks where a program can consume all available memory in just a few seconds because the programmer (definitely not me...) forgot to free something in a function called millions of times.</div><br/></div></div><div id="39074585" class="c"><input type="checkbox" id="c-39074585" checked=""/><div class="controls bullet"><span class="by">gnufx</span><span>|</span><a href="#39072496">parent</a><span>|</span><a href="#39073554">prev</a><span>|</span><a href="#39075885">next</a><span>|</span><label class="collapse" for="c-39074585">[-]</label><label class="expand" for="c-39074585">[1 more]</label></div><br/><div class="children"><div class="content">The canonical free-less (or no-op free) solution is conservative GC, isn&#x27;t it?  Specifically the Boehm collector..</div><br/></div></div><div id="39075885" class="c"><input type="checkbox" id="c-39075885" checked=""/><div class="controls bullet"><span class="by">ramshanker</span><span>|</span><a href="#39072496">parent</a><span>|</span><a href="#39074585">prev</a><span>|</span><a href="#39073613">next</a><span>|</span><label class="collapse" for="c-39075885">[-]</label><label class="expand" for="c-39075885">[1 more]</label></div><br/><div class="children"><div class="content">Not calling free can bite in short running programs also if memory allocation is done in a loop.</div><br/></div></div><div id="39073613" class="c"><input type="checkbox" id="c-39073613" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#39072496">parent</a><span>|</span><a href="#39075885">prev</a><span>|</span><a href="#39072626">next</a><span>|</span><label class="collapse" for="c-39073613">[-]</label><label class="expand" for="c-39073613">[1 more]</label></div><br/><div class="children"><div class="content">This is just an arena allocator scoped to the process.</div><br/></div></div><div id="39072626" class="c"><input type="checkbox" id="c-39072626" checked=""/><div class="controls bullet"><span class="by">gaudat</span><span>|</span><a href="#39072496">parent</a><span>|</span><a href="#39073613">prev</a><span>|</span><a href="#39073094">next</a><span>|</span><label class="collapse" for="c-39072626">[-]</label><label class="expand" for="c-39072626">[1 more]</label></div><br/><div class="children"><div class="content">Next thing they do is to optimize the hell out of kernel process management things until it catches up with the overhead of calling a function in a GC language.</div><br/></div></div><div id="39073450" class="c"><input type="checkbox" id="c-39073450" checked=""/><div class="controls bullet"><span class="by">msla</span><span>|</span><a href="#39072496">parent</a><span>|</span><a href="#39073094">prev</a><span>|</span><a href="#39072895">next</a><span>|</span><label class="collapse" for="c-39073450">[-]</label><label class="expand" for="c-39073450">[2 more]</label></div><br/><div class="children"><div class="content">A great way to write horrible programs.<p>In short: If it works until it crashes, it doesn&#x27;t work.</div><br/><div id="39073521" class="c"><input type="checkbox" id="c-39073521" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#39072496">root</a><span>|</span><a href="#39073450">parent</a><span>|</span><a href="#39072895">next</a><span>|</span><label class="collapse" for="c-39073521">[-]</label><label class="expand" for="c-39073521">[1 more]</label></div><br/><div class="children"><div class="content">TFA is clearly written in jest.  The provided code is not supposed to be run in production, just to illustrate how easy is to trick a &quot;leak detector&quot; in your debugger.  You just put all your mallocs in a list, and at the end of your program you can free them all.<p>Yet, the idea of not freeing some memory in your program is not entirely stupid.  Unless your memory is allocated inside a loop of unpredictable length, it&#x27;s not really necessary to ever free it.  Worse: the call to &quot;free&quot; may even fall after your program has run successfully.  Thus, avoiding the useless (but typical) freeing spree at the end of your program may make it more robust!</div><br/></div></div></div></div><div id="39072895" class="c"><input type="checkbox" id="c-39072895" checked=""/><div class="controls bullet"><span class="by">tenebrisalietum</span><span>|</span><a href="#39072496">parent</a><span>|</span><a href="#39073450">prev</a><span>|</span><a href="#39072793">next</a><span>|</span><label class="collapse" for="c-39072895">[-]</label><label class="expand" for="c-39072895">[1 more]</label></div><br/><div class="children"><div class="content">I always thought that was one reason the UNIX terminal login process (with `getty` and `exec` to shell, getty restarting when the shell exits) was the way it was.</div><br/></div></div></div></div><div id="39062767" class="c"><input type="checkbox" id="c-39062767" checked=""/><div class="controls bullet"><span class="by">kelthan</span><span>|</span><a href="#39072496">prev</a><span>|</span><a href="#39073023">next</a><span>|</span><label class="collapse" for="c-39062767">[-]</label><label class="expand" for="c-39062767">[11 more]</label></div><br/><div class="children"><div class="content">This solution doesn&#x27;t do anything to prevent leaking memory in anything but the most pedantic sense, and actually creates leaks and dangling pointers.<p>The function just indirects malloc with a wrapper so that all of the memory is traversable by the &quot;bigbucket&quot; structure. Memory is still leaked in the sense that any unfreed data will continue to consume heap memory and will still be inaccessible to the code unless the application does something with the &quot;bigbucket&quot; structure--which it can&#x27;t safely do (see below).<p>There is no corresponding free() call, so data put into the &quot;bigbucket&quot; structure is never removed, even when the memory allocation is freed by the application. This, by definition, is a leak, which is ironic.<p>In an application that does a lot of allocations, the &quot;bigbucket&quot; structure could exhaust the heap even though there are zero memory leaks in the code. Consider the program:<p><pre><code>  int main(int argc, char** argv) {
    for (long i = 0; i &lt; 1000000; i++) {
      void *foo = malloc(sizeof(char) * 1024);
      free(foo);
    }
    return 0;
  }
</code></pre>
At the end of the million iterations, there will be zero allocated memory, but the &quot;bigbucket&quot; structure will have a million entries (8MB of wasted heap space on a 64-bit computer). And every pointer to allocated memory in the &quot;bigbucket&quot; structure is pointing to a memory address previously freed so now points to a completely undefined location--possibly in the middle of some memory block allocated later.<p>There are already tools to identify memory leaks, such as LeakSanitiser <a href="https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;LeakSanitizer.html" rel="nofollow">https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;LeakSanitizer.html</a>. Use those instead.</div><br/><div id="39072828" class="c"><input type="checkbox" id="c-39072828" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#39062767">parent</a><span>|</span><a href="#39073060">next</a><span>|</span><label class="collapse" for="c-39072828">[-]</label><label class="expand" for="c-39072828">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There are already tools to identify memory leaks, such as LeakSanitiser <a href="https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;LeakSanitizer.html" rel="nofollow">https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;LeakSanitizer.html</a>. Use those instead.<p>Clearly the author of TFA is aware of such tools, since the idea is to trick them.</div><br/></div></div><div id="39073060" class="c"><input type="checkbox" id="c-39073060" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#39062767">parent</a><span>|</span><a href="#39072828">prev</a><span>|</span><a href="#39072978">next</a><span>|</span><label class="collapse" for="c-39073060">[-]</label><label class="expand" for="c-39073060">[2 more]</label></div><br/><div class="children"><div class="content">that&#x27;s the joke...</div><br/><div id="39075605" class="c"><input type="checkbox" id="c-39075605" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#39062767">root</a><span>|</span><a href="#39073060">parent</a><span>|</span><a href="#39072978">next</a><span>|</span><label class="collapse" for="c-39075605">[-]</label><label class="expand" for="c-39075605">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s not funny, it&#x27;s not obvious and it&#x27;s wasting a lot of people&#x27;s time. ha. ha. ha.</div><br/></div></div></div></div><div id="39072978" class="c"><input type="checkbox" id="c-39072978" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39062767">parent</a><span>|</span><a href="#39073060">prev</a><span>|</span><a href="#39073023">next</a><span>|</span><label class="collapse" for="c-39072978">[-]</label><label class="expand" for="c-39072978">[7 more]</label></div><br/><div class="children"><div class="content">Uhm... woosh!<p>You know this isn&#x27;t serious right?</div><br/><div id="39073983" class="c"><input type="checkbox" id="c-39073983" checked=""/><div class="controls bullet"><span class="by">WhackyIdeas</span><span>|</span><a href="#39062767">root</a><span>|</span><a href="#39072978">parent</a><span>|</span><a href="#39075619">next</a><span>|</span><label class="collapse" for="c-39073983">[-]</label><label class="expand" for="c-39073983">[3 more]</label></div><br/><div class="children"><div class="content">I just hope ChatGPT could see it was a joke</div><br/><div id="39074099" class="c"><input type="checkbox" id="c-39074099" checked=""/><div class="controls bullet"><span class="by">jamal-kumar</span><span>|</span><a href="#39062767">root</a><span>|</span><a href="#39073983">parent</a><span>|</span><a href="#39075619">next</a><span>|</span><label class="collapse" for="c-39074099">[-]</label><label class="expand" for="c-39074099">[2 more]</label></div><br/><div class="children"><div class="content">I posted the post into that and it said this:<p>While the provided code may seem like an interesting approach, it&#x27;s important to note that it introduces a number of issues and potential pitfalls. This code is an attempt to intercept the malloc function using the dlsym function from the dlfcn.h library and store every allocated pointer in a linked list called bigbucket. However, there are several problems with this solution:<p><pre><code>    Portability: This code relies on the dynamic linking functionality provided by the operating system. It may not work on all systems or with all compilers.

    Concurrency Issues: This solution is not thread-safe. If the program uses multiple threads, concurrent calls to malloc may result in race conditions and data corruption in the bigbucket linked list.

    Incomplete Solution: This code only intercepts calls to malloc. If the program uses other memory allocation functions like calloc, realloc, or custom memory allocators, memory leaks may still occur.

    Performance Overhead: The code introduces additional overhead for every memory allocation, potentially affecting the program&#x27;s performance.

    Undefined Behavior: Overriding standard library functions like malloc can lead to undefined behavior. The behavior of the program is no longer guaranteed to be consistent across different platforms or even different runs.

    Limited Practicality: While this approach technically prevents memory leaks by keeping track of all allocated pointers, it does not address the root cause of memory leaks, which is the failure to deallocate memory when it is no longer needed. Encouraging developers not to free memory is not a good practice and can lead to inefficient memory usage.
</code></pre>
A better approach to avoiding memory leaks is to adopt good programming practices, such as carefully managing memory allocation and deallocation, using automated tools like static analyzers and memory debuggers, and, when applicable, leveraging programming languages with automatic memory management (e.g., garbage collection in languages like Java or Python).</div><br/><div id="39074720" class="c"><input type="checkbox" id="c-39074720" checked=""/><div class="controls bullet"><span class="by">aeyes</span><span>|</span><a href="#39062767">root</a><span>|</span><a href="#39074099">parent</a><span>|</span><a href="#39075619">next</a><span>|</span><label class="collapse" for="c-39074720">[-]</label><label class="expand" for="c-39074720">[1 more]</label></div><br/><div class="children"><div class="content">The last part is funny. Even if you are technically not leaking memory you can still have pretty much the same end result in garbage collected languages if you mess up. The language might be tracking the objects but it can&#x27;t know if you don&#x27;t need them anymore.</div><br/></div></div></div></div></div></div><div id="39075619" class="c"><input type="checkbox" id="c-39075619" checked=""/><div class="controls bullet"><span class="by">voxl</span><span>|</span><a href="#39062767">root</a><span>|</span><a href="#39072978">parent</a><span>|</span><a href="#39073983">prev</a><span>|</span><a href="#39073023">next</a><span>|</span><label class="collapse" for="c-39075619">[-]</label><label class="expand" for="c-39075619">[3 more]</label></div><br/><div class="children"><div class="content">Why isn&#x27;t it serious? I can imagine a smart pointer that actually accomplished the stated goal. So the joke is that they took a good idea and made a rubbish solution?</div><br/><div id="39075863" class="c"><input type="checkbox" id="c-39075863" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#39062767">root</a><span>|</span><a href="#39075619">parent</a><span>|</span><a href="#39076647">next</a><span>|</span><label class="collapse" for="c-39075863">[-]</label><label class="expand" for="c-39075863">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I can imagine a smart pointer that actually accomplished the stated goal.<p>Can you elaborate on that?<p>If it requires you to free correctly, then you can just use plain C and the smart pointer isn&#x27;t accomplishing anything.  If it doesn&#x27;t require that, how does it work?</div><br/></div></div><div id="39076647" class="c"><input type="checkbox" id="c-39076647" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39062767">root</a><span>|</span><a href="#39075619">parent</a><span>|</span><a href="#39075863">prev</a><span>|</span><a href="#39073023">next</a><span>|</span><label class="collapse" for="c-39076647">[-]</label><label class="expand" for="c-39076647">[1 more]</label></div><br/><div class="children"><div class="content">I dunno how people are missing the point so much.<p>Traditionally memory is considered &quot;leaked&quot; if it is still allocated but nothing point to it; i.e. there&#x27;s no way to navigate to the allocation anymore.<p>He has made a joke &quot;solution&quot; by simply permanently storing a second pointer to all allocations so that by this definition they never <i>technically</i> leak. You can still always navigate to ever allocation so no allocation has leaked.<p>Of course it&#x27;s not a real solution because it doesn&#x27;t actually change the memory characteristics of a leaky program; it just hides the leak. In other words the technical description of the leak above isn&#x27;t really the thing we care about.<p>Seems like almost nobody here got that.</div><br/></div></div></div></div></div></div></div></div><div id="39073023" class="c"><input type="checkbox" id="c-39073023" checked=""/><div class="controls bullet"><span class="by">neonscribe</span><span>|</span><a href="#39062767">prev</a><span>|</span><a href="#39072696">next</a><span>|</span><label class="collapse" for="c-39073023">[-]</label><label class="expand" for="c-39073023">[5 more]</label></div><br/><div class="children"><div class="content">Obviously this is a joke, but the real message should be: if you can&#x27;t manage your own memory, you should be using a language implementation with automatic memory management. If your code really needs to run &quot;close to the metal&quot;, you really need to figure out how to manage your memory. In 2024, language implementations without automatic memory management should be reserved for applications that absolutely need them.</div><br/><div id="39073717" class="c"><input type="checkbox" id="c-39073717" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#39073023">parent</a><span>|</span><a href="#39073147">next</a><span>|</span><label class="collapse" for="c-39073717">[-]</label><label class="expand" for="c-39073717">[1 more]</label></div><br/><div class="children"><div class="content">Funny, I think the lesson is the opposite: just because you have mechanisms that technically prevent memory leaks doesn&#x27;t mean that you don&#x27;t need to think about memory and its allocation&#x2F;freeing. Or rather, memory leaks generally are not problem, unbounded memory consumption is, regardless if the consumption is technically due leak or some reference stashed somewhere.</div><br/></div></div><div id="39073147" class="c"><input type="checkbox" id="c-39073147" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#39073023">parent</a><span>|</span><a href="#39073717">prev</a><span>|</span><a href="#39072696">next</a><span>|</span><label class="collapse" for="c-39073147">[-]</label><label class="expand" for="c-39073147">[3 more]</label></div><br/><div class="children"><div class="content">It obviously is a joke, but at the same time it&#x27;s actually a viable approach for the right problem. Sometimes leaking is very tolerable and in terms of programmer time, very cheap!</div><br/><div id="39075867" class="c"><input type="checkbox" id="c-39075867" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#39073023">root</a><span>|</span><a href="#39073147">parent</a><span>|</span><a href="#39073537">next</a><span>|</span><label class="collapse" for="c-39075867">[-]</label><label class="expand" for="c-39075867">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It obviously is a joke, but at the same time it&#x27;s actually a viable approach for the right problem.<p>Define &quot;it&quot; here.<p>Because &quot;just don&#x27;t free&quot; is pretty different from what&#x27;s in the post!</div><br/></div></div><div id="39073537" class="c"><input type="checkbox" id="c-39073537" checked=""/><div class="controls bullet"><span class="by">Voultapher</span><span>|</span><a href="#39073023">root</a><span>|</span><a href="#39073147">parent</a><span>|</span><a href="#39075867">prev</a><span>|</span><a href="#39072696">next</a><span>|</span><label class="collapse" for="c-39073537">[-]</label><label class="expand" for="c-39073537">[1 more]</label></div><br/><div class="children"><div class="content">I think the mold linker does this.</div><br/></div></div></div></div></div></div><div id="39072696" class="c"><input type="checkbox" id="c-39072696" checked=""/><div class="controls bullet"><span class="by">lpapez</span><span>|</span><a href="#39073023">prev</a><span>|</span><a href="#39076307">next</a><span>|</span><label class="collapse" for="c-39072696">[-]</label><label class="expand" for="c-39072696">[4 more]</label></div><br/><div class="children"><div class="content">I bet this is what some people on my team would come up with if the ticket acceptance criteria said &quot;program must not leak memory when checked with valgrind&quot;</div><br/><div id="39074991" class="c"><input type="checkbox" id="c-39074991" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39072696">parent</a><span>|</span><a href="#39072821">next</a><span>|</span><label class="collapse" for="c-39074991">[-]</label><label class="expand" for="c-39074991">[1 more]</label></div><br/><div class="children"><div class="content">You can easily turn non-leaking program into a faster and leaking program, but the inverse direction is hard, so that criterion is entirely justified. Any optimization of this sort should be guarded against a compile time switch that simply swaps `free` with a placeholder. I think CPython did this for a long time, before the global initialization step was completely removed.</div><br/></div></div><div id="39072821" class="c"><input type="checkbox" id="c-39072821" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#39072696">parent</a><span>|</span><a href="#39074991">prev</a><span>|</span><a href="#39072727">next</a><span>|</span><label class="collapse" for="c-39072821">[-]</label><label class="expand" for="c-39072821">[1 more]</label></div><br/><div class="children"><div class="content">Goodhart&#x27;s Law[1] in action!<p>1: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Goodhart&#x27;s_law" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Goodhart&#x27;s_law</a></div><br/></div></div><div id="39072727" class="c"><input type="checkbox" id="c-39072727" checked=""/><div class="controls bullet"><span class="by">sgift</span><span>|</span><a href="#39072696">parent</a><span>|</span><a href="#39072821">prev</a><span>|</span><a href="#39076307">next</a><span>|</span><label class="collapse" for="c-39072727">[-]</label><label class="expand" for="c-39072727">[1 more]</label></div><br/><div class="children"><div class="content">That sounds painful. Unfortunately, I know the feeling.</div><br/></div></div></div></div><div id="39076307" class="c"><input type="checkbox" id="c-39076307" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#39072696">prev</a><span>|</span><a href="#39073142">next</a><span>|</span><label class="collapse" for="c-39076307">[-]</label><label class="expand" for="c-39076307">[1 more]</label></div><br/><div class="children"><div class="content">I have a much better and practical solution: <a href="https:&#x2F;&#x2F;github.com&#x2F;LibreDWG&#x2F;libredwg&#x2F;blob&#x2F;7d9fc3da44bbdb60a40d2dabd167341462434362&#x2F;programs&#x2F;dwgread.c#L327">https:&#x2F;&#x2F;github.com&#x2F;LibreDWG&#x2F;libredwg&#x2F;blob&#x2F;7d9fc3da44bbdb60a4...</a><p><pre><code>    #ifdef HAVE_VALGRIND_VALGRIND_H
      if (RUNNING_ON_VALGRIND)
    #endif
        free_all() 
</code></pre>
free is way too slow if not needed, so detect valgrind via its API. Just on valgrind do the unnecessary free dance. ASAN&#x27;s memleak detector is disabled via its env.<p>Perl5 does its final destruction similarly, only when it has important destructors (like IO, DB handles and such) to call.</div><br/></div></div><div id="39073142" class="c"><input type="checkbox" id="c-39073142" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#39076307">prev</a><span>|</span><a href="#39074238">next</a><span>|</span><label class="collapse" for="c-39073142">[-]</label><label class="expand" for="c-39073142">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve got an idea...<p>We have a counter that goes up by 1 every time you call malloc.<p>And down by one every time you call free.<p>And when the program quits, if the counter isn&#x27;t zero, an email is fired off and a dollar gets sent from the developers bank account to the users bank account...</div><br/><div id="39074210" class="c"><input type="checkbox" id="c-39074210" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#39073142">parent</a><span>|</span><a href="#39074238">next</a><span>|</span><label class="collapse" for="c-39074210">[-]</label><label class="expand" for="c-39074210">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s essentially how all leak detection tools work, minus the money part.<p>And it is not even always appropriate. It is common to allocate some memory for the entire lifetime of the process. For example, if your app is GUI-based and has a main window, there is no need to free the resources tied to the main window, because closing it means quitting the app which will cause all memory to be reclaimed by the OS. You can properly free your memory but it will only make quitting slower. Usually programmers only do that to satisfy leak detection tools, and if the overhead is significant, it may only be done in debug mode.</div><br/></div></div></div></div><div id="39074238" class="c"><input type="checkbox" id="c-39074238" checked=""/><div class="controls bullet"><span class="by">lgg</span><span>|</span><a href="#39073142">prev</a><span>|</span><a href="#39073234">next</a><span>|</span><label class="collapse" for="c-39074238">[-]</label><label class="expand" for="c-39074238">[3 more]</label></div><br/><div class="children"><div class="content">There is a bug here... Clearly the author intended to cache the value of nextmalloc to avoid calling dlsym() on every malloc. The correct code should be:<p><pre><code>  static void *(*nextmalloc)(size_t) = NULL;
  if (!nextmalloc) 
    nextmalloc = dlsym(RTLD_NEXT, &quot;malloc&quot;);
  }
</code></pre>
Somehow the fact that the optimization is incorrectly missed here feels appropriate ;-)</div><br/><div id="39074674" class="c"><input type="checkbox" id="c-39074674" checked=""/><div class="controls bullet"><span class="by">Taniwha</span><span>|</span><a href="#39074238">parent</a><span>|</span><a href="#39074949">prev</a><span>|</span><a href="#39073234">next</a><span>|</span><label class="collapse" for="c-39074674">[-]</label><label class="expand" for="c-39074674">[1 more]</label></div><br/><div class="children"><div class="content">yeah exactly, calling dlsym on every malloc would kill performance<p>the other bug of course is that it&#x27;s not thread safe</div><br/></div></div></div></div><div id="39073234" class="c"><input type="checkbox" id="c-39073234" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#39074238">prev</a><span>|</span><a href="#39072914">next</a><span>|</span><label class="collapse" for="c-39073234">[-]</label><label class="expand" for="c-39073234">[6 more]</label></div><br/><div class="children"><div class="content">This has been PHP’s approach to memory management during its best decades. It’s a fantastic idea for short-running processes, which there should be more of anyway.</div><br/><div id="39073343" class="c"><input type="checkbox" id="c-39073343" checked=""/><div class="controls bullet"><span class="by">tonyedgecombe</span><span>|</span><a href="#39073234">parent</a><span>|</span><a href="#39072914">next</a><span>|</span><label class="collapse" for="c-39073343">[-]</label><label class="expand" for="c-39073343">[5 more]</label></div><br/><div class="children"><div class="content">Are you saying PHP creates a new process for each request?</div><br/><div id="39076590" class="c"><input type="checkbox" id="c-39076590" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#39073234">root</a><span>|</span><a href="#39073343">parent</a><span>|</span><a href="#39073489">next</a><span>|</span><label class="collapse" for="c-39076590">[-]</label><label class="expand" for="c-39076590">[1 more]</label></div><br/><div class="children"><div class="content">Depends on the setup, but even when it doesn&#x27;t, it mallocs a huge chunk of memory at the start, lets the script run, allocate away and never free anything. Then, when the script is done, it frees the whole chunk in one fell swoop.<p>So for some definition of “process” it holds regardless - it’s just not always a real OS process.<p>They added GC at some point to allow scripts to run longer (eg for websocket servers) but even then last I checked you had to manually enable it.</div><br/></div></div><div id="39073489" class="c"><input type="checkbox" id="c-39073489" checked=""/><div class="controls bullet"><span class="by">SPascareli13</span><span>|</span><a href="#39073234">root</a><span>|</span><a href="#39073343">parent</a><span>|</span><a href="#39076590">prev</a><span>|</span><a href="#39074636">next</a><span>|</span><label class="collapse" for="c-39073489">[-]</label><label class="expand" for="c-39073489">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been a while since I used PHP, but this is something controlled by the server used. If you use Apache then it used to create a new process for each request, yes.</div><br/><div id="39073732" class="c"><input type="checkbox" id="c-39073732" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#39073234">root</a><span>|</span><a href="#39073489">parent</a><span>|</span><a href="#39074636">next</a><span>|</span><label class="collapse" for="c-39073732">[-]</label><label class="expand" for="c-39073732">[1 more]</label></div><br/><div class="children"><div class="content">Even in the classic prefork model (and mod_php), Apache did recycle worker processes. Only CGI operated on this new process for each request.</div><br/></div></div></div></div><div id="39074636" class="c"><input type="checkbox" id="c-39074636" checked=""/><div class="controls bullet"><span class="by">jbboehr</span><span>|</span><a href="#39073234">root</a><span>|</span><a href="#39073343">parent</a><span>|</span><a href="#39073489">prev</a><span>|</span><a href="#39072914">next</a><span>|</span><label class="collapse" for="c-39074636">[-]</label><label class="expand" for="c-39074636">[1 more]</label></div><br/><div class="children"><div class="content">It depends on the SAPI. The php-fpm approach is a pool of processes that are reused for multiple requests. Virtually all of the state visible to plain PHP code is reset between requests, however some interpreter&#x2F;runtime state is kept, e.g. in-memory bytecode cache, initialized extensions, some persistent network connections, etc.<p>In terms of memory management, PHP has both reference counting and garbage collection. Internally, an arena per request is used[0], so leaking memory over long periods of time is fairly rare and usually limited to native extensions.<p>[0]: <a href="https:&#x2F;&#x2F;www.phpinternalsbook.com&#x2F;php7&#x2F;memory_management&#x2F;zend_memory_manager.html" rel="nofollow">https:&#x2F;&#x2F;www.phpinternalsbook.com&#x2F;php7&#x2F;memory_management&#x2F;zend...</a></div><br/></div></div></div></div></div></div><div id="39072914" class="c"><input type="checkbox" id="c-39072914" checked=""/><div class="controls bullet"><span class="by">TillE</span><span>|</span><a href="#39073234">prev</a><span>|</span><a href="#39073045">next</a><span>|</span><label class="collapse" for="c-39072914">[-]</label><label class="expand" for="c-39072914">[2 more]</label></div><br/><div class="children"><div class="content">I used to really struggle with memory leaks in C++, until smart pointers came along. I think the only leak I&#x27;ve investigated since then wound up being an actual bug in the MSVC standard library.<p>OS handles and such are still an issue, but you can wrap them too. Thank goodness for RAII, a fantastic reason to use C++ even if you&#x27;re otherwise writing C-like code.</div><br/><div id="39073358" class="c"><input type="checkbox" id="c-39073358" checked=""/><div class="controls bullet"><span class="by">tonyedgecombe</span><span>|</span><a href="#39072914">parent</a><span>|</span><a href="#39073045">next</a><span>|</span><label class="collapse" for="c-39073358">[-]</label><label class="expand" for="c-39073358">[1 more]</label></div><br/><div class="children"><div class="content">As long as you don’t forget to make your destructors virtual.</div><br/></div></div></div></div><div id="39073045" class="c"><input type="checkbox" id="c-39073045" checked=""/><div class="controls bullet"><span class="by">privatedan</span><span>|</span><a href="#39072914">prev</a><span>|</span><a href="#39074599">next</a><span>|</span><label class="collapse" for="c-39073045">[-]</label><label class="expand" for="c-39073045">[1 more]</label></div><br/><div class="children"><div class="content">Hahahahaha I love this! Almost as good as fixing race conditions with sleep statements ( which I see a lot )</div><br/></div></div><div id="39074599" class="c"><input type="checkbox" id="c-39074599" checked=""/><div class="controls bullet"><span class="by">bluish29</span><span>|</span><a href="#39073045">prev</a><span>|</span><a href="#39074717">next</a><span>|</span><label class="collapse" for="c-39074599">[-]</label><label class="expand" for="c-39074599">[6 more]</label></div><br/><div class="children"><div class="content">This not bulletproof method to handle memory leaks as it still keeps all allocations. It simply keeps a list of all allocations but doesn&#x27;t address the core issue of unnecessary memory consumption if free is not called. But the more pressing problem is that this implementation is not thread safe. Concurrent accesses to the bigbucket list in a multi-threaded programs can easily lead to race conditions</div><br/><div id="39074625" class="c"><input type="checkbox" id="c-39074625" checked=""/><div class="controls bullet"><span class="by">mysterydip</span><span>|</span><a href="#39074599">parent</a><span>|</span><a href="#39074717">next</a><span>|</span><label class="collapse" for="c-39074625">[-]</label><label class="expand" for="c-39074625">[5 more]</label></div><br/><div class="children"><div class="content">While I&#x27;m sure it would bring its own problems, could you just stick a semaphore or similar around the function?</div><br/><div id="39074824" class="c"><input type="checkbox" id="c-39074824" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#39074599">root</a><span>|</span><a href="#39074625">parent</a><span>|</span><a href="#39074694">next</a><span>|</span><label class="collapse" for="c-39074824">[-]</label><label class="expand" for="c-39074824">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;re deep in a ridiculous scenario here, but the answer is that, yes, this would result in a safe program, provided that it never calls malloc() from a signal handler (since that would deadlock if the interrupted code had already grabbed the lock&#x2F;mutex&#x2F;semaphore&#x2F;whatever).<p>In any other scenario, if some execution thread reaches the point where it returns from calling lock() on the mutex guarding malloc(), it must eventually reach the call to unlock().</div><br/></div></div><div id="39074694" class="c"><input type="checkbox" id="c-39074694" checked=""/><div class="controls bullet"><span class="by">bluish29</span><span>|</span><a href="#39074599">root</a><span>|</span><a href="#39074625">parent</a><span>|</span><a href="#39074824">prev</a><span>|</span><a href="#39074747">next</a><span>|</span><label class="collapse" for="c-39074694">[-]</label><label class="expand" for="c-39074694">[2 more]</label></div><br/><div class="children"><div class="content">Yes, but it will not work in a generic case because you have to handle the situations of deadlocks (i.e recursive mutexes for nested locking ..etc). Also you will introduce more problems of creating performance deadlocks. There will not be out of box solutions to all these. Once you start considering solving case on its own then this does not provide out of box solution as the original premise.</div><br/><div id="39074848" class="c"><input type="checkbox" id="c-39074848" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#39074599">root</a><span>|</span><a href="#39074694">parent</a><span>|</span><a href="#39074747">next</a><span>|</span><label class="collapse" for="c-39074848">[-]</label><label class="expand" for="c-39074848">[1 more]</label></div><br/><div class="children"><div class="content">I think the only way this design could deadlock is if a signal handler calls malloc() -- specifically, if the interrupted code on that CPU thread was partway through a malloc() call of its own, having locked the mutex but not yet unlocked it.<p>In any other scenario, if some execution thread reaches the point where it returns from calling lock() on the mutex guarding malloc(), it must eventually reach the call to unlock().</div><br/></div></div></div></div></div></div></div></div><div id="39074717" class="c"><input type="checkbox" id="c-39074717" checked=""/><div class="controls bullet"><span class="by">Diggsey</span><span>|</span><a href="#39074599">prev</a><span>|</span><a href="#39072810">next</a><span>|</span><label class="collapse" for="c-39074717">[-]</label><label class="expand" for="c-39074717">[1 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t make sense even as a joke, since that&#x27;s not what it means to leak memory.<p>Memory being &quot;reachable&quot; is a property used by garbage collectors to determine what can be safely freed, but reachable memory can still be a memory leak. (Which is why languages with GC can still suffer from memory leaks...)</div><br/></div></div><div id="39072810" class="c"><input type="checkbox" id="c-39072810" checked=""/><div class="controls bullet"><span class="by">pxx</span><span>|</span><a href="#39074717">prev</a><span>|</span><a href="#39075371">next</a><span>|</span><label class="collapse" for="c-39072810">[-]</label><label class="expand" for="c-39072810">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for playing Wing Commander!</div><br/></div></div><div id="39075371" class="c"><input type="checkbox" id="c-39075371" checked=""/><div class="controls bullet"><span class="by">rkagerer</span><span>|</span><a href="#39072810">prev</a><span>|</span><a href="#39075370">next</a><span>|</span><label class="collapse" for="c-39075371">[-]</label><label class="expand" for="c-39075371">[1 more]</label></div><br/><div class="children"><div class="content">Since my computer memory isn&#x27;t draining out my computer and down into the sewers, all my programs must therefore be leak proof.</div><br/></div></div><div id="39076323" class="c"><input type="checkbox" id="c-39076323" checked=""/><div class="controls bullet"><span class="by">jenadine</span><span>|</span><a href="#39075200">prev</a><span>|</span><a href="#39073817">next</a><span>|</span><label class="collapse" for="c-39076323">[-]</label><label class="expand" for="c-39076323">[1 more]</label></div><br/><div class="children"><div class="content">To avoid an bugs, you can add a `exit(0)` at the beginning of your program.</div><br/></div></div><div id="39073817" class="c"><input type="checkbox" id="c-39073817" checked=""/><div class="controls bullet"><span class="by">Lasher</span><span>|</span><a href="#39076323">prev</a><span>|</span><a href="#39072554">next</a><span>|</span><label class="collapse" for="c-39073817">[-]</label><label class="expand" for="c-39073817">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of a situation I encountered with Salesforce code many years ago. Salesforce had a requirement that their test platform had to cover some percentage of the lines of code in the Sandbox before you could deploy something to production.<p>Our Salesforce implementation consultants had put 500 lines of &#x27;x = 1&#x27; into a piece of code to force it to deploy -- and these were people at a top consulting company with a very lucrative hourly rate.<p>No idea if SFDC still works this way or if this would fly today, this was back in the days when you had to use Flex to integrate anything with the UI.</div><br/></div></div><div id="39072554" class="c"><input type="checkbox" id="c-39072554" checked=""/><div class="controls bullet"><span class="by">david2ndaccount</span><span>|</span><a href="#39073817">prev</a><span>|</span><a href="#39074543">next</a><span>|</span><label class="collapse" for="c-39072554">[-]</label><label class="expand" for="c-39072554">[1 more]</label></div><br/><div class="children"><div class="content">This is not thread safe.</div><br/></div></div><div id="39074543" class="c"><input type="checkbox" id="c-39074543" checked=""/><div class="controls bullet"><span class="by">tverbeure</span><span>|</span><a href="#39072554">prev</a><span>|</span><a href="#39072645">next</a><span>|</span><label class="collapse" for="c-39074543">[-]</label><label class="expand" for="c-39074543">[2 more]</label></div><br/><div class="children"><div class="content">In the same spirit, here&#x27;s a fun talk about tool that guarantees 100% line coverage for your Python tool: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=A-cjMRsHcXI" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=A-cjMRsHcXI</a><p>After running your test suite, it kicks into action and deletes all the lines of your code that were never executed.</div><br/><div id="39075015" class="c"><input type="checkbox" id="c-39075015" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39074543">parent</a><span>|</span><a href="#39072645">next</a><span>|</span><label class="collapse" for="c-39075015">[-]</label><label class="expand" for="c-39075015">[1 more]</label></div><br/><div class="children"><div class="content">It is actually a viable strategy if you are heavily optimizing for the executable size [1]. It&#x27;s essentially a radical dead code elimination scheme.<p>[1] <a href="https:&#x2F;&#x2F;fgiesen.wordpress.com&#x2F;2012&#x2F;04&#x2F;08&#x2F;metaprogramming-for-madmen&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fgiesen.wordpress.com&#x2F;2012&#x2F;04&#x2F;08&#x2F;metaprogramming-for...</a></div><br/></div></div></div></div><div id="39072645" class="c"><input type="checkbox" id="c-39072645" checked=""/><div class="controls bullet"><span class="by">dgan</span><span>|</span><a href="#39074543">prev</a><span>|</span><a href="#39073070">next</a><span>|</span><label class="collapse" for="c-39072645">[-]</label><label class="expand" for="c-39072645">[2 more]</label></div><br/><div class="children"><div class="content">All arena-apologists hate this little trick</div><br/><div id="39073774" class="c"><input type="checkbox" id="c-39073774" checked=""/><div class="controls bullet"><span class="by">Gibbon1</span><span>|</span><a href="#39072645">parent</a><span>|</span><a href="#39073070">next</a><span>|</span><label class="collapse" for="c-39073774">[-]</label><label class="expand" for="c-39073774">[1 more]</label></div><br/><div class="children"><div class="content">Using an arena with an event loop and where persistent stuff is always copied has seemed really robust to me. When the event exits the handler resets the arena.</div><br/></div></div></div></div><div id="39073070" class="c"><input type="checkbox" id="c-39073070" checked=""/><div class="controls bullet"><span class="by">Manfred</span><span>|</span><a href="#39072645">prev</a><span>|</span><a href="#39072723">next</a><span>|</span><label class="collapse" for="c-39073070">[-]</label><label class="expand" for="c-39073070">[1 more]</label></div><br/><div class="children"><div class="content">From the comments I get the impression that we have all worked with someone that would have considered this an actual solution and we had to talk them out of it.</div><br/></div></div><div id="39072723" class="c"><input type="checkbox" id="c-39072723" checked=""/><div class="controls bullet"><span class="by">mmoll</span><span>|</span><a href="#39073070">prev</a><span>|</span><a href="#39073614">next</a><span>|</span><label class="collapse" for="c-39072723">[-]</label><label class="expand" for="c-39072723">[1 more]</label></div><br/><div class="children"><div class="content">If only I had known this earlier in my career! They should really add a feature to make a hard copy of the big bucket list to minimize memory overhead, though.</div><br/></div></div><div id="39073614" class="c"><input type="checkbox" id="c-39073614" checked=""/><div class="controls bullet"><span class="by">x86x87</span><span>|</span><a href="#39072723">prev</a><span>|</span><a href="#39073129">next</a><span>|</span><label class="collapse" for="c-39073614">[-]</label><label class="expand" for="c-39073614">[2 more]</label></div><br/><div class="children"><div class="content">Since this seems to be some sort of joke i&#x27;m going to provide a &quot;real&quot; answer: write modular software where you can verify that each module is leak proof + use valgrind to actually track and verify you don&#x27;t have links.<p>I have written medium to large projects using this approach and a leak-free program is not outside the realm of possible</div><br/><div id="39074615" class="c"><input type="checkbox" id="c-39074615" checked=""/><div class="controls bullet"><span class="by">diziet_sma</span><span>|</span><a href="#39073614">parent</a><span>|</span><a href="#39073129">next</a><span>|</span><label class="collapse" for="c-39074615">[-]</label><label class="expand" for="c-39074615">[1 more]</label></div><br/><div class="children"><div class="content">This does help, but the hard part of memory leaks is leaks across module&#x2F;api boundaries. You can write a memory safe module, I can write a memory safe program, but when my program starts calling your program there&#x27;s nothing validating I&#x27;m maintaining the invariants required to avoid memory leaks.<p>Hopefully the invariants are documented, but relying on documentation to help programmers avoid memory leaks is far from foolproof.</div><br/></div></div></div></div><div id="39073129" class="c"><input type="checkbox" id="c-39073129" checked=""/><div class="controls bullet"><span class="by">zeroCalories</span><span>|</span><a href="#39073614">prev</a><span>|</span><a href="#39073380">next</a><span>|</span><label class="collapse" for="c-39073129">[-]</label><label class="expand" for="c-39073129">[2 more]</label></div><br/><div class="children"><div class="content">While subtle, your point was not lost on me!<p>Technically all pointers are accessible, but the issue remains that we have not logically accounted for unused resources and are wasting capacity. In this sense, memory leaks are possible in all languages. We could store every object into a global structure, and it will never be freed in any language. Thus, my Rust program balloons forever.</div><br/><div id="39073615" class="c"><input type="checkbox" id="c-39073615" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#39073129">parent</a><span>|</span><a href="#39073380">next</a><span>|</span><label class="collapse" for="c-39073615">[-]</label><label class="expand" for="c-39073615">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Thus, my Rust program balloons forever.<p>I get the feeling that this might have been response to recent &quot;memory leak&quot; thread(s): <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39041520">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39041520</a></div><br/></div></div></div></div><div id="39073380" class="c"><input type="checkbox" id="c-39073380" checked=""/><div class="controls bullet"><span class="by">alexisread</span><span>|</span><a href="#39073129">prev</a><span>|</span><a href="#39076494">next</a><span>|</span><label class="collapse" for="c-39073380">[-]</label><label class="expand" for="c-39073380">[1 more]</label></div><br/><div class="children"><div class="content">Although this is a joke, from a systems perspective this is a valid strategy - stateless lambda (FAAS) functions can use this strategy as the state is moved externally, and can take the load of say long running monitoring processes.</div><br/></div></div><div id="39076494" class="c"><input type="checkbox" id="c-39076494" checked=""/><div class="controls bullet"><span class="by">throwaway892238</span><span>|</span><a href="#39073380">prev</a><span>|</span><a href="#39074696">next</a><span>|</span><label class="collapse" for="c-39076494">[-]</label><label class="expand" for="c-39076494">[1 more]</label></div><br/><div class="children"><div class="content">This one weird trick will fix your memory leaks forever</div><br/></div></div><div id="39074696" class="c"><input type="checkbox" id="c-39074696" checked=""/><div class="controls bullet"><span class="by">notfed</span><span>|</span><a href="#39076494">prev</a><span>|</span><a href="#39073291">next</a><span>|</span><label class="collapse" for="c-39074696">[-]</label><label class="expand" for="c-39074696">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Problem sovled!<p>Now if we could just fix off-by-one errors.</div><br/></div></div><div id="39073291" class="c"><input type="checkbox" id="c-39073291" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#39074696">prev</a><span>|</span><a href="#39072700">next</a><span>|</span><label class="collapse" for="c-39073291">[-]</label><label class="expand" for="c-39073291">[1 more]</label></div><br/><div class="children"><div class="content">“Hey I might need that later!”<p>Memory hoarding. I hate it but I love it.</div><br/></div></div><div id="39072700" class="c"><input type="checkbox" id="c-39072700" checked=""/><div class="controls bullet"><span class="by">bugbuddy</span><span>|</span><a href="#39073291">prev</a><span>|</span><label class="collapse" for="c-39072700">[-]</label><label class="expand" for="c-39072700">[2 more]</label></div><br/><div class="children"><div class="content">I totally thought this was an April fools joke at first. Why is this front page?</div><br/><div id="39072923" class="c"><input type="checkbox" id="c-39072923" checked=""/><div class="controls bullet"><span class="by">occamrazor</span><span>|</span><a href="#39072700">parent</a><span>|</span><label class="collapse" for="c-39072923">[-]</label><label class="expand" for="c-39072923">[1 more]</label></div><br/><div class="children"><div class="content">Probably because some people find it funny.</div><br/></div></div></div></div></div></div></div></div></div></body></html>