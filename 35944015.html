<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1684227658934" as="style"/><link rel="stylesheet" href="styles.css?v=1684227658934"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/mitsuhiko/self-replace">Self-Replace: A Utility For Self Replacing Executables</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>asicsp</span> | <span>19 comments</span></div><br/><div><div id="35956971" class="c"><input type="checkbox" id="c-35956971" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#35958481">next</a><span>|</span><label class="collapse" for="c-35956971">[-]</label><label class="expand" for="c-35956971">[4 more]</label></div><br/><div class="children"><div class="content">Two things:<p>1. Replacing the current executable is <i>generally</i> okay on Unix and Unix-likes, but it&#x27;s not particularly well-defined. Linux handles it gracefully, others may ETXTBSY or similar depending on how the replacement is done.<p>2. The hack being used on Windows is <i>awful</i>: it involves patching the underlying C runtime, can fail in uncontrolled ways (including in an `atexit` handler), and is fundamentally racy. The state it leaves a failed operation in isn&#x27;t self-healing, and surfaces confusing filesystem state to the user on failure.<p>If you want to replace a running executable on Windows, either ask the user (and have them affirmatively kill the running program) or do the &quot;cooperative rename&quot; trick[1]. It doesn&#x27;t require any unsafety, much less patching the runtime underneath you.<p>[1]: <a href="https:&#x2F;&#x2F;social.msdn.microsoft.com&#x2F;Forums&#x2F;vstudio&#x2F;en-US&#x2F;07fb6078-c41d-4829-a62d-f22dd112360c&#x2F;how-to-replace-exe-file-with-same-updated-exe-file?forum=csharpgeneral" rel="nofollow">https:&#x2F;&#x2F;social.msdn.microsoft.com&#x2F;Forums&#x2F;vstudio&#x2F;en-US&#x2F;07fb6...</a></div><br/><div id="35958936" class="c"><input type="checkbox" id="c-35958936" checked=""/><div class="controls bullet"><span class="by">the_mitsuhiko</span><span>|</span><a href="#35956971">parent</a><span>|</span><a href="#35957172">next</a><span>|</span><label class="collapse" for="c-35958936">[-]</label><label class="expand" for="c-35958936">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it involves patching the underlying C runtime<p>Can you please clarify how this &quot;patches the underlying C runtime&quot;?  What this crate is doing is not particularly out of the ordinary. You will find similar code in quite a few self updating windows executables.<p>&gt; or do the &quot;cooperative rename&quot; trick[1]<p>I&#x27;m not entirely sure how this is much different?  This is pretty much what this is doing.  It spawns a copy of itself (with the exe being marked for self deletion) and then deletes the other executable.</div><br/></div></div><div id="35957172" class="c"><input type="checkbox" id="c-35957172" checked=""/><div class="controls bullet"><span class="by">evanelias</span><span>|</span><a href="#35956971">parent</a><span>|</span><a href="#35958936">prev</a><span>|</span><a href="#35957733">next</a><span>|</span><label class="collapse" for="c-35957172">[-]</label><label class="expand" for="c-35957172">[1 more]</label></div><br/><div class="children"><div class="content">On #1, totally agree, and security systems can add an extra winkle...<p>With code-signed binaries on a Mac, macOS Gatekeeper caches signatures by inode. If the binary is replaced&#x2F;re-written in a way which retains the old inode, and you try to execute it, the OS will SIGKILL the process immediately. Not fun to debug the first time you encounter it!</div><br/></div></div><div id="35957733" class="c"><input type="checkbox" id="c-35957733" checked=""/><div class="controls bullet"><span class="by">bsnnkv</span><span>|</span><a href="#35956971">parent</a><span>|</span><a href="#35957172">prev</a><span>|</span><a href="#35958481">next</a><span>|</span><label class="collapse" for="c-35957733">[-]</label><label class="expand" for="c-35957733">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the breakdown of why this is a bad idea. I was considering using this for a Windows Rust project I maintain, but now I know better. Ideally tradeoffs like these should be mentioned clearly in the readme.</div><br/></div></div></div></div><div id="35958481" class="c"><input type="checkbox" id="c-35958481" checked=""/><div class="controls bullet"><span class="by">agateau</span><span>|</span><a href="#35956971">prev</a><span>|</span><a href="#35958650">next</a><span>|</span><label class="collapse" for="c-35958481">[-]</label><label class="expand" for="c-35958481">[1 more]</label></div><br/><div class="children"><div class="content">A little known fact about executables on Windows is that while it&#x27;s not possible to remove a running executable, it&#x27;s possible to <i>rename</i> it.<p>I use this in Clyde [1]: on Windows, when clyde needs to upgrade itself (which means uninstalling vN and installing vN+1) it renames itself from `clyde.exe` to `_clyde.exe`. I leave the old `_clyde.exe` around, but a nicer implementation could remove on the next start.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;agateau&#x2F;clyde">https:&#x2F;&#x2F;github.com&#x2F;agateau&#x2F;clyde</a></div><br/></div></div><div id="35958650" class="c"><input type="checkbox" id="c-35958650" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#35958481">prev</a><span>|</span><a href="#35958381">next</a><span>|</span><label class="collapse" for="c-35958650">[-]</label><label class="expand" for="c-35958650">[1 more]</label></div><br/><div class="children"><div class="content">Crazy idea, just make your EXE into a stub that loads your actual program, which is implemented in a DLL.  When it&#x27;s time to update, drop a newer DLL in there that the EXE will load instead.  Hopefully you won&#x27;t have to update the stub very often.</div><br/></div></div><div id="35958381" class="c"><input type="checkbox" id="c-35958381" checked=""/><div class="controls bullet"><span class="by">funcDropShadow</span><span>|</span><a href="#35958650">prev</a><span>|</span><a href="#35958379">next</a><span>|</span><label class="collapse" for="c-35958381">[-]</label><label class="expand" for="c-35958381">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand why people think this is a good idea to do at all. Yes it makes updates easier. But each software doing that has to run with the privileges to update itself. Which is in my book a big security downside. Separating rights to install, update, and remove software from the right to run and use it should be complete separate.<p>I admit this is not very nice for private Windows users. But this is one of the strength of Linux distributions.</div><br/><div id="35958952" class="c"><input type="checkbox" id="c-35958952" checked=""/><div class="controls bullet"><span class="by">the_mitsuhiko</span><span>|</span><a href="#35958381">parent</a><span>|</span><a href="#35958379">next</a><span>|</span><label class="collapse" for="c-35958952">[-]</label><label class="expand" for="c-35958952">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But each software doing that has to run with the privileges to update itself. Which is in my book a big security downside.<p>But it does not have to run with those privileges under normal circumstances.  It&#x27;s easy enough to elevate privileges just for the update step.</div><br/></div></div></div></div><div id="35958379" class="c"><input type="checkbox" id="c-35958379" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#35958381">prev</a><span>|</span><a href="#35957857">next</a><span>|</span><label class="collapse" for="c-35958379">[-]</label><label class="expand" for="c-35958379">[3 more]</label></div><br/><div class="children"><div class="content">This is interesting.<p>Google Chrome can patch binaries and the Linux kernel can be patched while running.<p>I would like this capability for general purpose software, hot code reloading. Can do seamless non-breaking changes to a live server without a full restart.<p>Would be useful for Function as a Service and WASM runtimes if you could live patch code running.<p>I generally rely on Kubernetes or CI to do a rolling deploy of software to switch to the new version, but if we could patch a server while running that would be interesting. Would have interesting interactions with socket connections using the old code and connections using the new code and all the complicated states you can get into, if your data structures are different.<p>How do you move data if you added a field to your data structure? Presumably if you added a field, there isn&#x27;t enough memory allocates in the existing data structures... Your malloc is for the wrong size.</div><br/><div id="35958655" class="c"><input type="checkbox" id="c-35958655" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#35958379">parent</a><span>|</span><a href="#35957857">next</a><span>|</span><label class="collapse" for="c-35958655">[-]</label><label class="expand" for="c-35958655">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I would like this capability for general purpose software, hot code reloading. Can do seamless non-breaking changes to a live server without a full restart.</i><p>This is <i>very</i> old-school style, that fell out of favor for... whatever reason this industry likes to make two steps forward, and then 1.9 steps backwards. It survives in the legacy of Smalltalk and Lisp. To a lesser degree, it&#x27;s featured in Erlang, and I hear C# these days.<p>&gt; <i>Would have interesting interactions with socket connections using the old code and connections using the new code and all the complicated states you can get into, if your data structures are different.</i><p>If you make a mental shift - treat the OS as runtime, and processes as functions (and shell as a REPL, and environment variables as dynamic binding...) - then the ideas from Smalltalk and Lisp image-based programming will apply directly. At Kubernetes level, I suppose Erlang&#x27;s take on connecting BEAM runtimes applies as well.<p>&gt; <i>How do you move data if you added a field to your data structure? Presumably if you added a field, there isn&#x27;t enough memory allocates in the existing data structures... Your malloc is for the wrong size.</i><p>If this is C (or Rust, I suppose?), then you can&#x27;t. You have to architect for that from the start. With garbage collected runtimes... I&#x27;m not sure how hard is it with static typing, but with dynamically typed languages it&#x27;s not bad.<p>If you want to see a system that <i>embraces</i> runtime modification of classes, check Lisp (e.g. Common Lisp) or Smalltalk. For example, in case of Common Lisp, if you want to make a substantial runtime modification to some class definition, you have to supply a &quot;old&quot; -&gt; &quot;new&quot; migration function, which will be applied to all existing instances of the old class definition. Note: this is not a hack, it&#x27;s a legitimate feature of the language&#x2F;runtime, and - like everything else - can be operated fully automatically.</div><br/><div id="35959182" class="c"><input type="checkbox" id="c-35959182" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#35958379">root</a><span>|</span><a href="#35958655">parent</a><span>|</span><a href="#35957857">next</a><span>|</span><label class="collapse" for="c-35959182">[-]</label><label class="expand" for="c-35959182">[1 more]</label></div><br/><div class="children"><div class="content">The thing is, you have to test and debug that. Even if I&#x27;m working with Common Lisp, I don&#x27;t necessarily want to go there.<p>Say there are five versions of your image out there, versioned 1 to 5. Users might be doing any of these upgrades:<p><pre><code>        to
  from   1 2 3 4 5
     1     X X X X
     2       X X X
     3         X X
     4           X
</code></pre>
Assuming nobody does downgrades, we have ten combinations to test.<p>Anything you do to reduce the testing comes at the cost of inconvenience to the user. You can support only upgrades by one; so someone going from 1 to 5 has to upgrade to 2, 3 and 4. You can cut off upgrade support for old versions; if a 1 user wants 6, they will have to suffer a stop and restart. That all just seems half-assed; you&#x27;re not doing a perfect job of &quot;no restarts ever&quot;, so why bother.<p>No restart upgrades handle the volatile objects in RAM. Regardless of that, applications have to handle the persistent data formats: like objects written to storage by version 1, 2, 3 or 4, which now have to be processed by 5.<p>People who understand and deal with with upgrades to persistent data are not going to react kindly if you tell them, &quot;hey, you can add to the complexity and amount of work by hot-loading code, and dealing with upgrading across multiple versions of in-RAM volatile objects, too&quot;.</div><br/></div></div></div></div></div></div><div id="35957857" class="c"><input type="checkbox" id="c-35957857" checked=""/><div class="controls bullet"><span class="by">HellsMaddy</span><span>|</span><a href="#35958379">prev</a><span>|</span><a href="#35957139">next</a><span>|</span><label class="collapse" for="c-35957857">[-]</label><label class="expand" for="c-35957857">[1 more]</label></div><br/><div class="children"><div class="content">Is there anything like this for C&#x2F;C++ applications?</div><br/></div></div><div id="35957139" class="c"><input type="checkbox" id="c-35957139" checked=""/><div class="controls bullet"><span class="by">lohnjemon</span><span>|</span><a href="#35957857">prev</a><span>|</span><a href="#35956754">next</a><span>|</span><label class="collapse" for="c-35957139">[-]</label><label class="expand" for="c-35957139">[1 more]</label></div><br/><div class="children"><div class="content">When I had written my shell to the point where I could execute simple commands, this was the first thing that came to my mind using it.<p>Execute the shell -&gt; Modify the source code of the shell with vim -&gt; Remake the shell -&gt; Execute the newly built shell with the old shell<p>Just for fun :)</div><br/></div></div><div id="35956754" class="c"><input type="checkbox" id="c-35956754" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#35957139">prev</a><span>|</span><a href="#35956496">next</a><span>|</span><label class="collapse" for="c-35956754">[-]</label><label class="expand" for="c-35956754">[1 more]</label></div><br/><div class="children"><div class="content">It has an interface and two implementations, UNIX and Windows.</div><br/></div></div><div id="35956496" class="c"><input type="checkbox" id="c-35956496" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#35956754">prev</a><span>|</span><a href="#35956911">next</a><span>|</span><label class="collapse" for="c-35956496">[-]</label><label class="expand" for="c-35956496">[1 more]</label></div><br/><div class="children"><div class="content">Self-modifying code.</div><br/></div></div><div id="35956911" class="c"><input type="checkbox" id="c-35956911" checked=""/><div class="controls bullet"><span class="by">Hello71</span><span>|</span><a href="#35956496">prev</a><span>|</span><label class="collapse" for="c-35956911">[-]</label><label class="expand" for="c-35956911">[3 more]</label></div><br/><div class="children"><div class="content">the windows implementation seems awfully complex. what&#x27;s wrong with something like _popen(&quot;find \&quot;\&quot; &amp; del &quot; + argv[0])? the problem to solve is &quot;we can&#x27;t delete ourselves, so we need something else to do it for us&quot;, but there are a myriad options to choose from, you don&#x27;t have to write it in rust. hell, you&#x27;ve already got the dubious sleep(100) in there, you can even write _popen(&quot;ping 127.0.0.1 &amp; del &quot; + argv[0]) as suggested by stack overflow?</div><br/><div id="35958949" class="c"><input type="checkbox" id="c-35958949" checked=""/><div class="controls bullet"><span class="by">the_mitsuhiko</span><span>|</span><a href="#35956911">parent</a><span>|</span><a href="#35957655">next</a><span>|</span><label class="collapse" for="c-35958949">[-]</label><label class="expand" for="c-35958949">[1 more]</label></div><br/><div class="children"><div class="content">I tried plenty of approaches on windows, this was the one that seems the most reliable and least problematic.  It&#x27;s also the approach other systems already use.</div><br/></div></div><div id="35957655" class="c"><input type="checkbox" id="c-35957655" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#35956911">parent</a><span>|</span><a href="#35958949">prev</a><span>|</span><label class="collapse" for="c-35957655">[-]</label><label class="expand" for="c-35957655">[1 more]</label></div><br/><div class="children"><div class="content">Not a Windows programmer, but doesn&#x27;t it prevent a file from being deleted while it is being used&#x2F;executed? (At least not without black magic?)</div><br/></div></div></div></div></div></div></div></div></div></body></html>