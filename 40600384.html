<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717750850254" as="style"/><link rel="stylesheet" href="styles.css?v=1717750850254"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://codeandbitters.com/main-as-usize/">Let rand = main as usize (2022)</a> <span class="domain">(<a href="https://codeandbitters.com">codeandbitters.com</a>)</span></div><div class="subtext"><span>wonger_</span> | <span>41 comments</span></div><br/><div><div id="40600693" class="c"><input type="checkbox" id="c-40600693" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40603803">next</a><span>|</span><label class="collapse" for="c-40600693">[-]</label><label class="expand" for="c-40600693">[27 more]</label></div><br/><div class="children"><div class="content">&gt; For those expecting to the usual Rust guard rails, it&#x27;s surprising that the compiler allows casting between arbitrary raw pointer types outside of an unsafe block. This feels really dangerous— even though we can&#x27;t do anything with the pointer outside of an unsafe block, creating a raw pointer usually implies that an unsafe block will eventually do something with it. I kind of wish that this pointer casting required unsafe, just because this code should send up red flags, and probably deserves a close look during code review.<p>I think the general philosophy is that unsafe only demarcates potentially unsound code whereas casting between different pointers isn&#x27;t technically unsound even though it can cause unsoundness in unsafe code if done incorrectly. I agree with the author that casting between unrelated pointer types should probably be considered unsafe but would probably require a new edition which would mean Rust 2027 at the earliest (assuming someone is motivated enough to push it through the bureaucracy).</div><br/><div id="40601418" class="c"><input type="checkbox" id="c-40601418" checked=""/><div class="controls bullet"><span class="by">nemothekid</span><span>|</span><a href="#40600693">parent</a><span>|</span><a href="#40602296">next</a><span>|</span><label class="collapse" for="c-40601418">[-]</label><label class="expand" for="c-40601418">[11 more]</label></div><br/><div class="children"><div class="content">&gt;<i>I agree with the author that casting between unrelated pointer types should probably be considered unsafe but would probably require a new edition which would mean Rust 2027 at the earliest</i><p>As I understand it, unsafe pretty much says &quot;what you are doing here may violate memory safety&quot;. Casting doesn&#x27;t do that, only dereferencing. If you&#x27;d like to increase the scope to also include &quot;things that might violate memory safety for another code block&quot;, then shouldn&#x27;t compile either:<p><pre><code>    let mut foo = unsafe { int_ref as *const u32 as usize };
    foo = foo + 1;
    let bar = unsafe {*(foo as *const u32)}
</code></pre>
the mutation of foo is also &quot;unsafe&quot; under this definition, and the compiler shouldn&#x27;t let you modify pointers in any manner.</div><br/><div id="40601828" class="c"><input type="checkbox" id="c-40601828" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40600693">root</a><span>|</span><a href="#40601418">parent</a><span>|</span><a href="#40602296">next</a><span>|</span><label class="collapse" for="c-40601828">[-]</label><label class="expand" for="c-40601828">[10 more]</label></div><br/><div class="children"><div class="content">You’ve changed the goal to something I didn’t state and then demonstrate that it’s a bad idea. I agree it’s impossible to restrict unsoundness to only appear within unsafe, but that’s not the goal.<p>Of course unsafe code can generate unsoundness in safe code. The main difference is that unsoundness would be more bounded somewhere <i>between</i> unsafe blocks as you’ve written which improves code review and the speed with with issues are found.<p>I’ll also note that the +=1 is also potentially unsound in release builds since Rust doesn’t do overflow checks at runtime (although since it presumably originates from a valid address that’s not possible in practice). It’s the one practical tradeoff Rust chose to make to allow UB in sounds code so that code wasn’t overly verbose while retaining good performance at runtime.</div><br/><div id="40602291" class="c"><input type="checkbox" id="c-40602291" checked=""/><div class="controls bullet"><span class="by">nemothekid</span><span>|</span><a href="#40600693">root</a><span>|</span><a href="#40601828">parent</a><span>|</span><a href="#40601904">next</a><span>|</span><label class="collapse" for="c-40602291">[-]</label><label class="expand" for="c-40602291">[3 more]</label></div><br/><div class="children"><div class="content">&gt;<i>You’ve changed the goal to something I didn’t state and then demonstrate that it’s a bad idea.</i><p>No - I guess I should have been more clear but I don&#x27;t think `unsafe` demarcates the boundary between sound and unsound. I think what happens in unsafe are things that potentially memory unsafe or thread unsafe.  Pointer casts are not included in that - I feel that would only provide a false sense of safety.</div><br/><div id="40602808" class="c"><input type="checkbox" id="c-40602808" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40600693">root</a><span>|</span><a href="#40602291">parent</a><span>|</span><a href="#40601904">next</a><span>|</span><label class="collapse" for="c-40602808">[-]</label><label class="expand" for="c-40602808">[2 more]</label></div><br/><div class="children"><div class="content">Except unsafe is used more than just for memory and thread safety. Unsafe can acquire whatever semantics you want it to. It’s just that Rust the standard library and standard language has mandated that memory and thread unsoundness is always unsafe. But I can easily make an additional constraint that I annotate as unsafe and the compiler will help me enforce it (if I recall correctly the embedded guys use this when interacting with hardware even though there’s no memory or thread safety issues &amp; I’ve seen it in other places too). It’s a fairly arbitrary choice about what’s considered safe by default vs unsafe and you can always expand the surface area of unsafe.<p>As for false sense of safety or not, that’s a value judgement whereas we can actually derive metrics about it (eg. build a version of the compiler that require it be annotated unsafe and then investigate now illegal call sites to count how many errors per instance there turned out to be).</div><br/><div id="40603684" class="c"><input type="checkbox" id="c-40603684" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#40600693">root</a><span>|</span><a href="#40602808">parent</a><span>|</span><a href="#40601904">next</a><span>|</span><label class="collapse" for="c-40603684">[-]</label><label class="expand" for="c-40603684">[1 more]</label></div><br/><div class="children"><div class="content">It’s technically true that you can make unsafe mean whatever you want in your own projects, but redefining it to include nondeterministim that doesn’t itself result in UB would be such a fundamental change to the semantics broadly accepted by the rust community that it’s very unlikely they would do so for language constructs like `as`.<p>That said, I think `as` is generally a code smell and the one large professional Rust project I’ve worked on banned it in CI via clippy.</div><br/></div></div></div></div></div></div><div id="40601904" class="c"><input type="checkbox" id="c-40601904" checked=""/><div class="controls bullet"><span class="by">zepton</span><span>|</span><a href="#40600693">root</a><span>|</span><a href="#40601828">parent</a><span>|</span><a href="#40602291">prev</a><span>|</span><a href="#40601968">next</a><span>|</span><label class="collapse" for="c-40601904">[-]</label><label class="expand" for="c-40601904">[3 more]</label></div><br/><div class="children"><div class="content">Overflowing addition is never UB in Rust - it is defined to wrap around in release builds (i.e. it would be a compiler bug if adding 1 to 255_u8 in a release build produced any value other than 0_u8).</div><br/><div id="40602048" class="c"><input type="checkbox" id="c-40602048" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40600693">root</a><span>|</span><a href="#40601904">parent</a><span>|</span><a href="#40601968">next</a><span>|</span><label class="collapse" for="c-40602048">[-]</label><label class="expand" for="c-40602048">[2 more]</label></div><br/><div class="children"><div class="content">Sorry, was thinking of signed integer overflow which while considered sound is simultaneously considered to be a a bug in your code (hence the panic in debug mode and requires the use of wrapping_add if you intend the wrapping).</div><br/><div id="40605227" class="c"><input type="checkbox" id="c-40605227" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#40600693">root</a><span>|</span><a href="#40602048">parent</a><span>|</span><a href="#40601968">next</a><span>|</span><label class="collapse" for="c-40605227">[-]</label><label class="expand" for="c-40605227">[1 more]</label></div><br/><div class="children"><div class="content">Rust behaves as you describe for both signed and unsigned.</div><br/></div></div></div></div></div></div><div id="40601968" class="c"><input type="checkbox" id="c-40601968" checked=""/><div class="controls bullet"><span class="by">sans-seraph</span><span>|</span><a href="#40600693">root</a><span>|</span><a href="#40601828">parent</a><span>|</span><a href="#40601904">prev</a><span>|</span><a href="#40602296">next</a><span>|</span><label class="collapse" for="c-40601968">[-]</label><label class="expand" for="c-40601968">[3 more]</label></div><br/><div class="children"><div class="content">The +=1 in the above code is defined behavior. Unlike in C, the Rust compiler is not allowed to assume that overflow does not happen, and must restrict its optimizations accordingly. The undefined behavior in this code would be a result of the dereference in the next line. If there existed a check to ensure that overflow had not occurred prior to the dereference, then this code would be well-defined. And because overflow is defined behavior in Rust, the aforementioned overflow check could not be optimized away, as it could in C.</div><br/><div id="40602995" class="c"><input type="checkbox" id="c-40602995" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40600693">root</a><span>|</span><a href="#40601968">parent</a><span>|</span><a href="#40602019">next</a><span>|</span><label class="collapse" for="c-40602995">[-]</label><label class="expand" for="c-40602995">[1 more]</label></div><br/><div class="children"><div class="content">overflow of unsigned integers is well-defined in C.<p>You&#x27;re confusing it with overflow of signed integers.</div><br/></div></div><div id="40602019" class="c"><input type="checkbox" id="c-40602019" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40600693">root</a><span>|</span><a href="#40601968">parent</a><span>|</span><a href="#40602995">prev</a><span>|</span><a href="#40602296">next</a><span>|</span><label class="collapse" for="c-40602019">[-]</label><label class="expand" for="c-40602019">[1 more]</label></div><br/><div class="children"><div class="content">Sorry. Not UB but a likely a logical bug in the code (and a potential security exploit).</div><br/></div></div></div></div></div></div></div></div><div id="40602296" class="c"><input type="checkbox" id="c-40602296" checked=""/><div class="controls bullet"><span class="by">EE84M3i</span><span>|</span><a href="#40600693">parent</a><span>|</span><a href="#40601418">prev</a><span>|</span><a href="#40601869">next</a><span>|</span><label class="collapse" for="c-40602296">[-]</label><label class="expand" for="c-40602296">[1 more]</label></div><br/><div class="children"><div class="content">The current behavior is clearly documented in the Rust Reference[1]:<p>&gt;The following language level features cannot be used in the safe subset of Rust:
&gt; Dereferencing a raw pointer.
&gt; Reading or writing a mutable or external static variable.
&gt; Accessing a field of a union, other than to assign to it.
&gt; Calling an unsafe function (including an intrinsic or foreign function).
&gt; Implementing an unsafe trait.<p>It also calls out the behavior in noted in this specific post in &quot;Behavior not considered unsafe&quot;[2]:<p>&gt; Exposing randomized base addresses through pointer leaks<p>[1]: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;unsafety.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;unsafety.html</a><p>[2]: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;behavior-not-considered-unsafe.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;behavior-not-considered-...</a></div><br/></div></div><div id="40601869" class="c"><input type="checkbox" id="c-40601869" checked=""/><div class="controls bullet"><span class="by">haileys</span><span>|</span><a href="#40600693">parent</a><span>|</span><a href="#40602296">prev</a><span>|</span><a href="#40600810">next</a><span>|</span><label class="collapse" for="c-40601869">[-]</label><label class="expand" for="c-40601869">[5 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I kind of wish that this pointer casting required unsafe, just because this code should send up red flags, and probably deserves a close look during code review.</i><p>If a pointer cast performed in safe code can cause unsoundness in unsafe code elsewhere, that&#x27;s a bug in the unsafe code. All bets are off if your unsafe code is that trusting of data it receives from safe code.<p>This is a good argument for why pointer casting <i>should</i> be safe - it forces the point and pushes you to find the right abstraction. No pointer cast done in safe code should ever be able to cause unsoundness.</div><br/><div id="40601966" class="c"><input type="checkbox" id="c-40601966" checked=""/><div class="controls bullet"><span class="by">darby_nine</span><span>|</span><a href="#40600693">root</a><span>|</span><a href="#40601869">parent</a><span>|</span><a href="#40601942">next</a><span>|</span><label class="collapse" for="c-40601966">[-]</label><label class="expand" for="c-40601966">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If a pointer cast performed in safe code can cause unsoundness in unsafe code elsewhere, that&#x27;s a bug in the unsafe code.<p>Converting from pointer to integer (as in the given example) cannot possibly lead to unsafe code that would not have already been unsafe with an arbitrary integer value. There&#x27;s nothing unsafe about accessing an address without dereferencing it.<p>Casting <i>to</i> a pointer from an integer should probably be considered generally unsafe.</div><br/><div id="40602042" class="c"><input type="checkbox" id="c-40602042" checked=""/><div class="controls bullet"><span class="by">haileys</span><span>|</span><a href="#40600693">root</a><span>|</span><a href="#40601966">parent</a><span>|</span><a href="#40601942">next</a><span>|</span><label class="collapse" for="c-40602042">[-]</label><label class="expand" for="c-40602042">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Casting to a pointer from an integer should probably be considered generally unsafe.</i><p>The pointer can&#x27;t be assumed to be valid anyway without other guarantees. It could have been valid at some point, and then freed at another point, and is now dangling.<p>You&#x27;ll notice that std::ptr::null and std::ptr::dangling are also safe functions. This is intentional - the language designers are telling you that you cannot rely on the fact that a piece of data is of a pointer type to trust that it&#x27;s valid.</div><br/></div></div></div></div><div id="40601942" class="c"><input type="checkbox" id="c-40601942" checked=""/><div class="controls bullet"><span class="by">_flux</span><span>|</span><a href="#40600693">root</a><span>|</span><a href="#40601869">parent</a><span>|</span><a href="#40601966">prev</a><span>|</span><a href="#40600810">next</a><span>|</span><label class="collapse" for="c-40601942">[-]</label><label class="expand" for="c-40601942">[2 more]</label></div><br/><div class="children"><div class="content">Unsafe code can rarely validate pointers it receives and must depend on the properties of the other code to work safely. It just doesn&#x27;t depend on the <i>safety</i> properties of that other code.</div><br/><div id="40601981" class="c"><input type="checkbox" id="c-40601981" checked=""/><div class="controls bullet"><span class="by">haileys</span><span>|</span><a href="#40600693">root</a><span>|</span><a href="#40601942">parent</a><span>|</span><a href="#40600810">next</a><span>|</span><label class="collapse" for="c-40601981">[-]</label><label class="expand" for="c-40601981">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. So you must use Rust&#x27;s encapsulation features like modules and visibility to ensure that any particular piece of unsafe code _cannot_ receive a pointer that can&#x27;t be proven to be valid.</div><br/></div></div></div></div></div></div><div id="40600810" class="c"><input type="checkbox" id="c-40600810" checked=""/><div class="controls bullet"><span class="by">blt</span><span>|</span><a href="#40600693">parent</a><span>|</span><a href="#40601869">prev</a><span>|</span><a href="#40605158">next</a><span>|</span><label class="collapse" for="c-40600810">[-]</label><label class="expand" for="c-40600810">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s only dangerous if you can also make the reverse cast, right? From ints to function pointers. Does Rust also allow that in safe code?</div><br/><div id="40601011" class="c"><input type="checkbox" id="c-40601011" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#40600693">root</a><span>|</span><a href="#40600810">parent</a><span>|</span><a href="#40600951">next</a><span>|</span><label class="collapse" for="c-40601011">[-]</label><label class="expand" for="c-40601011">[2 more]</label></div><br/><div class="children"><div class="content">It does not.<p>Oddly enough, it doesn&#x27;t even allow it in unsafe code, not with a normal cast.  You have to use transmute.  I believe this is due to concerns about targets where function and data pointers have different representations.<p><a href="https:&#x2F;&#x2F;rust-lang.github.io&#x2F;unsafe-code-guidelines&#x2F;layout&#x2F;function-pointers.html" rel="nofollow">https:&#x2F;&#x2F;rust-lang.github.io&#x2F;unsafe-code-guidelines&#x2F;layout&#x2F;fu...</a></div><br/><div id="40602018" class="c"><input type="checkbox" id="c-40602018" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#40600693">root</a><span>|</span><a href="#40601011">parent</a><span>|</span><a href="#40600951">next</a><span>|</span><label class="collapse" for="c-40602018">[-]</label><label class="expand" for="c-40602018">[1 more]</label></div><br/><div class="children"><div class="content">I believe it has more to do with the fact that function pointers are effectively &amp;&#x27;static T (static references) and references are forbidden from being null. But it&#x27;s probably a bit of both.<p>In other words `0usize as fn ()` is insta-undefined behavior, and you can&#x27;t have that in safe code.</div><br/></div></div></div></div><div id="40600951" class="c"><input type="checkbox" id="c-40600951" checked=""/><div class="controls bullet"><span class="by">sans-seraph</span><span>|</span><a href="#40600693">root</a><span>|</span><a href="#40600810">parent</a><span>|</span><a href="#40601011">prev</a><span>|</span><a href="#40605158">next</a><span>|</span><label class="collapse" for="c-40600951">[-]</label><label class="expand" for="c-40600951">[4 more]</label></div><br/><div class="children"><div class="content">No, Rust does not allow safe conversions from integers to function pointers. The code `main as usize as fn()` will result in a &quot;non-primitive cast&quot; error. In order to convert from an integer or raw pointer to a function pointer, the unsafe function `std::mem::transmute` must be used.</div><br/><div id="40601308" class="c"><input type="checkbox" id="c-40601308" checked=""/><div class="controls bullet"><span class="by">blt</span><span>|</span><a href="#40600693">root</a><span>|</span><a href="#40600951">parent</a><span>|</span><a href="#40605158">next</a><span>|</span><label class="collapse" for="c-40601308">[-]</label><label class="expand" for="c-40601308">[3 more]</label></div><br/><div class="children"><div class="content">In that case, then a linter warning seems more appropriate for pointer-&gt;int than requiring &quot;unsafe&quot;. I feel &quot;unsafe&quot; should not be diluted to mean &quot;unwise&quot;. But what do I know, I&#x27;m a C++ programmer...</div><br/><div id="40601781" class="c"><input type="checkbox" id="c-40601781" checked=""/><div class="controls bullet"><span class="by">sans-seraph</span><span>|</span><a href="#40600693">root</a><span>|</span><a href="#40601308">parent</a><span>|</span><a href="#40601683">next</a><span>|</span><label class="collapse" for="c-40601781">[-]</label><label class="expand" for="c-40601781">[1 more]</label></div><br/><div class="children"><div class="content">Rust&#x27;s linting tool, Clippy, provides a lint that will produce a warning when a function pointer is cast to any integral type: <a href="https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;master&#x2F;index.html#&#x2F;fn_to_numeric_cast_any" rel="nofollow">https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;master&#x2F;index.html#&#x2F;f...</a><p>The broader topic of whether it is safe, or wise, to cast between pointers and integers in general is an area of active research. Ralf Jung&#x27;s blog is required reading on this topic: <a href="https:&#x2F;&#x2F;www.ralfj.de&#x2F;blog&#x2F;2022&#x2F;04&#x2F;11&#x2F;provenance-exposed.html" rel="nofollow">https:&#x2F;&#x2F;www.ralfj.de&#x2F;blog&#x2F;2022&#x2F;04&#x2F;11&#x2F;provenance-exposed.html</a></div><br/></div></div></div></div></div></div></div></div><div id="40605158" class="c"><input type="checkbox" id="c-40605158" checked=""/><div class="controls bullet"><span class="by">ryukoposting</span><span>|</span><a href="#40600693">parent</a><span>|</span><a href="#40600810">prev</a><span>|</span><a href="#40603064">next</a><span>|</span><label class="collapse" for="c-40605158">[-]</label><label class="expand" for="c-40605158">[1 more]</label></div><br/><div class="children"><div class="content">A key thing to consider is that there&#x27;s nothing innately unsafe about casting a pointer to a number. It&#x27;s when you go the other way around that problems crop up.<p>As long as <i>dereferencing</i> a raw pointer is considered unsafe, you&#x27;re fine. Casting it has no actual effect at the machine level.</div><br/></div></div><div id="40603064" class="c"><input type="checkbox" id="c-40603064" checked=""/><div class="controls bullet"><span class="by">hun3</span><span>|</span><a href="#40600693">parent</a><span>|</span><a href="#40605158">prev</a><span>|</span><a href="#40603803">next</a><span>|</span><label class="collapse" for="c-40603064">[-]</label><label class="expand" for="c-40603064">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I kind of wish that this pointer casting required unsafe, just because this code should send up red flags, and probably deserves a close look during code review.<p>How about a new lint instead?</div><br/></div></div></div></div><div id="40603803" class="c"><input type="checkbox" id="c-40603803" checked=""/><div class="controls bullet"><span class="by">qweqwe14</span><span>|</span><a href="#40600693">prev</a><span>|</span><a href="#40601511">next</a><span>|</span><label class="collapse" for="c-40603803">[-]</label><label class="expand" for="c-40603803">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also the good old trick of measuring duration between two instants and using that as a (crude) randomness source.<p>Also on Linux there&#x27;s the AT_RANDOM entry in the aux vector, which provides any program with 16 random bytes.</div><br/></div></div><div id="40601511" class="c"><input type="checkbox" id="c-40601511" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#40603803">prev</a><span>|</span><a href="#40603889">next</a><span>|</span><label class="collapse" for="c-40601511">[-]</label><label class="expand" for="c-40601511">[1 more]</label></div><br/><div class="children"><div class="content">As an aside getauxval(3) allows access to AT_RANDOM which is &quot;the address of sixteen bytes containing a random value.&quot;</div><br/></div></div><div id="40603889" class="c"><input type="checkbox" id="c-40603889" checked=""/><div class="controls bullet"><span class="by">puzzledobserver</span><span>|</span><a href="#40601511">prev</a><span>|</span><a href="#40602154">next</a><span>|</span><label class="collapse" for="c-40603889">[-]</label><label class="expand" for="c-40603889">[1 more]</label></div><br/><div class="children"><div class="content">Might having correlated random variables (in this case, rand and the address of main) unintentionally cause vulnerabilities like the Debian OpenSSL incident [0]?<p>[0] <a href="https:&#x2F;&#x2F;lists.debian.org&#x2F;debian-security-announce&#x2F;2008&#x2F;msg00152.html" rel="nofollow">https:&#x2F;&#x2F;lists.debian.org&#x2F;debian-security-announce&#x2F;2008&#x2F;msg00...</a></div><br/></div></div><div id="40602154" class="c"><input type="checkbox" id="c-40602154" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#40603889">prev</a><span>|</span><a href="#40602701">next</a><span>|</span><label class="collapse" for="c-40602154">[-]</label><label class="expand" for="c-40602154">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not quite the same, but it made me think of how in the Atari 2600 game <i>Yars&#x27; Revenge</i>, the TV static-like &quot;neutral zone&quot; in the middle of the screen is literally just the game&#x27;s code from the ROM taken as a bitmap and placed in the right part of the console&#x27;s playfield. I think they XOR together two different sections of code, scrolling in different directions.</div><br/></div></div><div id="40602701" class="c"><input type="checkbox" id="c-40602701" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#40602154">prev</a><span>|</span><a href="#40602643">next</a><span>|</span><label class="collapse" for="c-40602701">[-]</label><label class="expand" for="c-40602701">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s basically the XKCD random number generator: <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;221&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;221&#x2F;</a><p>Also on Windows, randomized address space layout changes only on reboot.</div><br/><div id="40603591" class="c"><input type="checkbox" id="c-40603591" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#40602701">parent</a><span>|</span><a href="#40602643">next</a><span>|</span><label class="collapse" for="c-40603591">[-]</label><label class="expand" for="c-40603591">[1 more]</label></div><br/><div class="children"><div class="content">It can change under other (rare) circumstances. Otherwise a collision between an already-chosen base address for one module and an allocation in your process would result in a failure to load that module into your process.</div><br/></div></div></div></div><div id="40602643" class="c"><input type="checkbox" id="c-40602643" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#40602701">prev</a><span>|</span><a href="#40601679">next</a><span>|</span><label class="collapse" for="c-40602643">[-]</label><label class="expand" for="c-40602643">[3 more]</label></div><br/><div class="children"><div class="content">FTA: Even in the best circumstances, a program can only acquire one random value this way<p>Can it?<p><pre><code>  let rand = if(fork() == 0) {main as usize} else {std::process::exit(0)}
</code></pre>
(For those who wonder: I know this code has ‘some’ issues)</div><br/><div id="40602827" class="c"><input type="checkbox" id="c-40602827" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#40602643">parent</a><span>|</span><a href="#40601679">next</a><span>|</span><label class="collapse" for="c-40602827">[-]</label><label class="expand" for="c-40602827">[2 more]</label></div><br/><div class="children"><div class="content">Would fork() alone cause another ASLR roll? I feel like if fork <i>just</i> forks — duplicates the memory space &amp; execution, with all the pages being CoW — the layout of the child is going to be the same as the parent.<p>Ran the slightly modified:<p><pre><code>  fn main() {
      if fork() == 0 {
          dbg!(main as usize);
      } else {
          dbg!(main as usize);
      }
  }
</code></pre>
which got me,<p><pre><code>  [src&#x2F;main.rs:7:9] main as usize = 105397413561856
  [src&#x2F;main.rs:5:9] main as usize = 105397413561856</code></pre></div><br/><div id="40603233" class="c"><input type="checkbox" id="c-40603233" checked=""/><div class="controls bullet"><span class="by">mike_hock</span><span>|</span><a href="#40602643">root</a><span>|</span><a href="#40602827">parent</a><span>|</span><a href="#40601679">next</a><span>|</span><label class="collapse" for="c-40603233">[-]</label><label class="expand" for="c-40603233">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Would fork() alone cause another ASLR roll?<p>No, that&#x27;s fundamentally impossible.</div><br/></div></div></div></div></div></div><div id="40601679" class="c"><input type="checkbox" id="c-40601679" checked=""/><div class="controls bullet"><span class="by">dist-epoch</span><span>|</span><a href="#40602643">prev</a><span>|</span><label class="collapse" for="c-40601679">[-]</label><label class="expand" for="c-40601679">[4 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s debatable whether this is effective at turning away attacks, but that&#x27;s the goal, and ASLR is enabled on almost every operating system in use today.<p>It&#x27;s not debatable at all, ASLR is a significant barrier to attacks.<p>Quote from a random hacking book:<p>&gt; By doing so, it makes it significantly harder for an attacker to predict the location of specific processes and data, such as the stack, heap, and libraries, thereby mitigating certain types of exploits, particularly buffer overflows.<p><a href="https:&#x2F;&#x2F;book.hacktricks.xyz&#x2F;binary-exploitation&#x2F;common-binary-protections-and-bypasses&#x2F;aslr" rel="nofollow">https:&#x2F;&#x2F;book.hacktricks.xyz&#x2F;binary-exploitation&#x2F;common-binar...</a></div><br/><div id="40605855" class="c"><input type="checkbox" id="c-40605855" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40601679">parent</a><span>|</span><a href="#40603607">next</a><span>|</span><label class="collapse" for="c-40605855">[-]</label><label class="expand" for="c-40605855">[1 more]</label></div><br/><div class="children"><div class="content">ASLR is generally pretty weak to completely ineffective against buffer overflows, because the linear layout of things generally does not change. It is more useful against a write-anywhere primitive (…in that you don&#x27;t know where to write to).</div><br/></div></div><div id="40603607" class="c"><input type="checkbox" id="c-40603607" checked=""/><div class="controls bullet"><span class="by">fargle</span><span>|</span><a href="#40601679">parent</a><span>|</span><a href="#40605855">prev</a><span>|</span><label class="collapse" for="c-40603607">[-]</label><label class="expand" for="c-40603607">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s not debatable at all<p>you do appear to be debating it...</div><br/><div id="40605655" class="c"><input type="checkbox" id="c-40605655" checked=""/><div class="controls bullet"><span class="by">g15jv2dp</span><span>|</span><a href="#40601679">root</a><span>|</span><a href="#40603607">parent</a><span>|</span><label class="collapse" for="c-40605655">[-]</label><label class="expand" for="c-40605655">[1 more]</label></div><br/><div class="children"><div class="content">Stating facts is not &quot;debating&quot;.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>