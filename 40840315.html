<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719824481844" as="style"/><link rel="stylesheet" href="styles.css?v=1719824481844"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.ericpfahl.com/from-pattern-matching-to-unification/">Unification in Elixir</a>Â <span class="domain">(<a href="https://www.ericpfahl.com">www.ericpfahl.com</a>)</span></div><div class="subtext"><span>weatherlight</span> | <span>3 comments</span></div><br/><div><div id="40843582" class="c"><input type="checkbox" id="c-40843582" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><label class="collapse" for="c-40843582">[-]</label><label class="expand" for="c-40843582">[2 more]</label></div><br/><div class="children"><div class="content">Type checking (type inference) is the usual application of unification in programming languages (compilers or interpreters). 
Pattern matching does not need unification, because, as mentioned in the beginning of post, the &quot;matching&quot; is done one the left side only (no variables to &quot;match&quot; on the right side).</div><br/><div id="40843729" class="c"><input type="checkbox" id="c-40843729" checked=""/><div class="controls bullet"><span class="by">YeGoblynQueenne</span><span>|</span><a href="#40843582">parent</a><span>|</span><label class="collapse" for="c-40843729">[-]</label><label class="expand" for="c-40843729">[1 more]</label></div><br/><div class="children"><div class="content">The one-sided pattern matching seems to be a peculiarity of Elixir. The post above discusses an implementation of full unification without that restriction. To clarify, unification is not generally restricted to one-sided matching only.<p>Is unification unnecessary for pattern matching? I think that depends on what you meany by &quot;pattern matching&quot;. In programming cirlces &quot;pattern matching&quot; usually means matching strings. Now, unification is Turing-complete pattern matching, meaning that it goes well beyond e.g. regular expressions that can only match the set of strings recognised by regular automata. For instance, in Prolog, you can unify a variable with an entire Prolog program and call the program at runtime, etc. So if you need &quot;pattern matching&quot; only to match strings then you probably don&#x27;t need the full power of unification.<p>If I understand correctly (not an expert) Hindley-Milner type checking, the type checking that uses unification, relies exactly on that ability of unification to match entire programs. Anyway that kind of type checking is indeed pattern matching by unification. So it&#x27;s not different than pattern matching on strings with regular expressions. The difference is only in what kinds of strings can be matched.</div><br/></div></div></div></div></div></div></div></div></div></body></html>