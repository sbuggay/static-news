<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1730797255075" as="style"/><link rel="stylesheet" href="styles.css?v=1730797255075"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jarosz.dev/article/writing-secure-go-code/">Writing secure Go code</a> <span class="domain">(<a href="https://jarosz.dev">jarosz.dev</a>)</span></div><div class="subtext"><span>gus_leonel</span> | <span>187 comments</span></div><br/><div><div id="42045346" class="c"><input type="checkbox" id="c-42045346" checked=""/><div class="controls bullet"><span class="by">rollulus</span><span>|</span><a href="#42045531">next</a><span>|</span><label class="collapse" for="c-42045346">[-]</label><label class="expand" for="c-42045346">[10 more]</label></div><br/><div class="children"><div class="content">As the article also mentions: instead of checking if your program has a dependency on something that contains vulnerabilities, govulncheck checks if vulnerable code is actually reached. I find that so awesome. (And I know, someone is going to point out that hipster language foo does this too and better — it’s not the norm).</div><br/><div id="42049095" class="c"><input type="checkbox" id="c-42049095" checked=""/><div class="controls bullet"><span class="by">lynx23</span><span>|</span><a href="#42045346">parent</a><span>|</span><a href="#42045531">next</a><span>|</span><label class="collapse" for="c-42049095">[-]</label><label class="expand" for="c-42049095">[9 more]</label></div><br/><div class="children"><div class="content">&gt; hipster language<p>Funny, I always considered Go a hipster language for Google fanboys.</div><br/><div id="42049197" class="c"><input type="checkbox" id="c-42049197" checked=""/><div class="controls bullet"><span class="by">silverliver</span><span>|</span><a href="#42045346">root</a><span>|</span><a href="#42049095">parent</a><span>|</span><a href="#42049182">next</a><span>|</span><label class="collapse" for="c-42049197">[-]</label><label class="expand" for="c-42049197">[7 more]</label></div><br/><div class="children"><div class="content">Perhaps, but all I really care about is having a complied, strongly-typed language with a fully-featured modern stdlib and good cross-compilation support that includes wasm. If that comes with an automatic admission to the Google Fanboy Club, then sign me up.<p>What other well-established languages do we have that meet this criteria? I know .net is a strong contender but do we have other options?</div><br/><div id="42049259" class="c"><input type="checkbox" id="c-42049259" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42045346">root</a><span>|</span><a href="#42049197">parent</a><span>|</span><a href="#42049182">next</a><span>|</span><label class="collapse" for="c-42049259">[-]</label><label class="expand" for="c-42049259">[6 more]</label></div><br/><div class="children"><div class="content">Rust &amp; Java also come to mind (yes, Java can be AOT compiled). Erlang too if you want more fearless concurrency if you’re OK with JIT languages. There’s lots of alternatives to Go in its space but it does have mindshare and there’s nothing wrong with staying on the well trodden path even if it’s full of if err != nil instead of sane error chaining built into the language.</div><br/><div id="42049406" class="c"><input type="checkbox" id="c-42049406" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#42045346">root</a><span>|</span><a href="#42049259">parent</a><span>|</span><a href="#42049362">next</a><span>|</span><label class="collapse" for="c-42049406">[-]</label><label class="expand" for="c-42049406">[3 more]</label></div><br/><div class="children"><div class="content">Go &#x2F; golang added <a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;errors" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;errors</a><p>Which includes nested &#x2F; stacked errors and helper functions for checking them.<p>It doesn&#x27;t implement error classes, but you can create a stacked chain of errors which achieves the same sort of &#x27;Handle a classification of error&#x27; (anything which includes that class).<p>Older libraries don&#x27;t use these features, as far as I know.  So it&#x27;s sort of like the half-baked enumerate everything sort of generic functions that older stable versions (like on hacker rank) ship.</div><br/><div id="42049443" class="c"><input type="checkbox" id="c-42049443" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42045346">root</a><span>|</span><a href="#42049406">parent</a><span>|</span><a href="#42049362">next</a><span>|</span><label class="collapse" for="c-42049443">[-]</label><label class="expand" for="c-42049443">[2 more]</label></div><br/><div class="children"><div class="content">I think you missed my complaint was that unlike more modern languages like Rust, Go has way too much boilerplate for error handling and not only does it not have error chaining via a `?` operator, it doesn’t even force you to check the error meaning I’m sure there’s plenty of missed error checks in production code leaving all sorts of vulnerabilities lying around. The package you linked in no way addresses what I wrote.</div><br/><div id="42049664" class="c"><input type="checkbox" id="c-42049664" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#42045346">root</a><span>|</span><a href="#42049443">parent</a><span>|</span><a href="#42049362">next</a><span>|</span><label class="collapse" for="c-42049664">[-]</label><label class="expand" for="c-42049664">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been interested in learning more about Rust, but so far haven&#x27;t had a project that seemed like it&#x27;d be worth learning a whole new language structure.<p>So, I was responding to my _understanding_ of what you had written, which apparently didn&#x27;t adequately explain what you sought to those who haven&#x27;t seen the thing you were trying to reference.<p>I do occasionally use a helper function in golang like &#x27;nilOrPanic()&#x27; which if it&#x27;s given an Error type that isn&#x27;t nil causes a panic(); which isn&#x27;t so useful outside of development or toy exercises.</div><br/></div></div></div></div></div></div><div id="42049362" class="c"><input type="checkbox" id="c-42049362" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42045346">root</a><span>|</span><a href="#42049259">parent</a><span>|</span><a href="#42049406">prev</a><span>|</span><a href="#42049803">next</a><span>|</span><label class="collapse" for="c-42049362">[-]</label><label class="expand" for="c-42049362">[1 more]</label></div><br/><div class="children"><div class="content">Regarding Java, since early 2000 to be more precisely, although it required paying for commercial JDKs like Excelsior JET.<p>Nowadays besides the more well known GraalVM, there is OpenJ9 and its cousin Android since version 5.<p>PTC and Aicas remain as two well known commercial Java vendors, with AOT toolchains, alongside bare metal and real time GC support, although their focus is embedded deployments.</div><br/></div></div><div id="42049803" class="c"><input type="checkbox" id="c-42049803" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42045346">root</a><span>|</span><a href="#42049259">parent</a><span>|</span><a href="#42049362">prev</a><span>|</span><a href="#42049182">next</a><span>|</span><label class="collapse" for="c-42049803">[-]</label><label class="expand" for="c-42049803">[1 more]</label></div><br/><div class="children"><div class="content">Erlang is interpreted. It is in the same class of performance as Python and Ruby. If you want a relatively high-level and performant alternative with great concurrency support your options are C#&#x2F;F# (you are likely find the tooling pleasant) and perhaps JVM languages once they adopt structured concurrency (but you are likely to find the tooling less pleasant).<p>Graal Native Image support is very niche and does not provide the same level of experience as .NET’s NativeAOT nor has tricks up its sleeve like static linking with native libraries.</div><br/></div></div></div></div></div></div><div id="42049182" class="c"><input type="checkbox" id="c-42049182" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#42045346">root</a><span>|</span><a href="#42049095">parent</a><span>|</span><a href="#42049197">prev</a><span>|</span><a href="#42045531">next</a><span>|</span><label class="collapse" for="c-42049182">[-]</label><label class="expand" for="c-42049182">[1 more]</label></div><br/><div class="children"><div class="content">You either die a hipster or live long enough to become mainstream.</div><br/></div></div></div></div></div></div><div id="42045531" class="c"><input type="checkbox" id="c-42045531" checked=""/><div class="controls bullet"><span class="by">wepple</span><span>|</span><a href="#42045346">prev</a><span>|</span><a href="#42045932">next</a><span>|</span><label class="collapse" for="c-42045531">[-]</label><label class="expand" for="c-42045531">[2 more]</label></div><br/><div class="children"><div class="content">Don’t forget about capslock: <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;capslock">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;capslock</a><p>Assess your 3P modules for dangerous capabilities</div><br/><div id="42049606" class="c"><input type="checkbox" id="c-42049606" checked=""/><div class="controls bullet"><span class="by">rollulus</span><span>|</span><a href="#42045531">parent</a><span>|</span><a href="#42045932">next</a><span>|</span><label class="collapse" for="c-42049606">[-]</label><label class="expand" for="c-42049606">[1 more]</label></div><br/><div class="children"><div class="content">Nice, thanks a lot for that!</div><br/></div></div></div></div><div id="42045932" class="c"><input type="checkbox" id="c-42045932" checked=""/><div class="controls bullet"><span class="by">jjcm</span><span>|</span><a href="#42045531">prev</a><span>|</span><a href="#42046061">next</a><span>|</span><label class="collapse" for="c-42045932">[-]</label><label class="expand" for="c-42045932">[26 more]</label></div><br/><div class="children"><div class="content">Great tips in here - I was not aware of `go vet` nor `go test -race`.<p>FWIW, while go is not memory safe, I do find that it&#x27;s much easier to be safe in go than it is in other languages. Its verboseness lends to a very clear understanding of what&#x27;s happening in any given function. I absolutely hated this at the start, but now ~3 years into maintaining a go codebase, I find it quite nice both for debugging as well as editing old code. I know exactly what each function does, and what the structure of data is in any given context.<p>Another interesting side effect is that AI tools seem to work amazingly well with golang, given how context is often local to the function.</div><br/><div id="42048067" class="c"><input type="checkbox" id="c-42048067" checked=""/><div class="controls bullet"><span class="by">uluyol</span><span>|</span><a href="#42045932">parent</a><span>|</span><a href="#42046101">next</a><span>|</span><label class="collapse" for="c-42048067">[-]</label><label class="expand" for="c-42048067">[3 more]</label></div><br/><div class="children"><div class="content">Go very much is memory safe in the absence of data races.<p>Data races cause issues in all languages, though it&#x27;s fair to say that Go is affected slightly more than languages like Java. Rust is a bit special by making data races hard to trigger (impossible in safe code IIUC), but this is not typical.</div><br/><div id="42049398" class="c"><input type="checkbox" id="c-42049398" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42048067">parent</a><span>|</span><a href="#42049506">next</a><span>|</span><label class="collapse" for="c-42049398">[-]</label><label class="expand" for="c-42049398">[1 more]</label></div><br/><div class="children"><div class="content">Kind of, regarding Rust.<p>It is impossible in the context of having all threads accessing in-process memory.<p>If the data can be accessed externally, regardless of the guarantees being uphold on the Rust side, there are no guarantees from third parties accessing the same data.<p>It also doesn&#x27;t prevent other race issues with external data.</div><br/></div></div><div id="42049506" class="c"><input type="checkbox" id="c-42049506" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42048067">parent</a><span>|</span><a href="#42049398">prev</a><span>|</span><a href="#42046101">next</a><span>|</span><label class="collapse" for="c-42049506">[-]</label><label class="expand" for="c-42049506">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, and C is memory safe in absence of memory safety bugs..</div><br/></div></div></div></div><div id="42046101" class="c"><input type="checkbox" id="c-42046101" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42045932">parent</a><span>|</span><a href="#42048067">prev</a><span>|</span><a href="#42048732">next</a><span>|</span><label class="collapse" for="c-42046101">[-]</label><label class="expand" for="c-42046101">[20 more]</label></div><br/><div class="children"><div class="content">Go is memory-safe. It&#x27;s not the definition of &quot;memory-safe language&quot; that it&#x27;s impossible to write memory-unsafe code, only that ordinary code is memory-safe by default.</div><br/><div id="42047696" class="c"><input type="checkbox" id="c-42047696" checked=""/><div class="controls bullet"><span class="by">thinkharderdev</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42046101">parent</a><span>|</span><a href="#42049493">next</a><span>|</span><label class="collapse" for="c-42047696">[-]</label><label class="expand" for="c-42047696">[18 more]</label></div><br/><div class="children"><div class="content">&gt; ordinary code is memory-safe by default<p>What does that mean? What constitutes &quot;ordinary&quot;? I&#x27;m not sure there is any official definition of memory safety, but I would consider it to mean that aside from code that is explicitly marked as unsafe it is impossible to write code that has undefined behavior.</div><br/><div id="42047756" class="c"><input type="checkbox" id="c-42047756" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42047696">parent</a><span>|</span><a href="#42048952">next</a><span>|</span><label class="collapse" for="c-42047756">[-]</label><label class="expand" for="c-42047756">[14 more]</label></div><br/><div class="children"><div class="content">Good definition. I&#x27;ve seen Go beginners trying to append to a slice from multiple goroutines. It works as well as calling push_back on the same vector from multiple threads in C++. It can easily corrupt GC state and lead to segfaults. The beginner didn&#x27;t use any advanced trickery or the unsafe package. Therefore Go is not a memory safe language.</div><br/><div id="42047857" class="c"><input type="checkbox" id="c-42047857" checked=""/><div class="controls bullet"><span class="by">sshine</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42047756">parent</a><span>|</span><a href="#42048610">next</a><span>|</span><label class="collapse" for="c-42047857">[-]</label><label class="expand" for="c-42047857">[9 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Therefore Go is not a memory safe language.</i><p>Interesting.<p>To quote the NSA [1], &quot;<i>Some examples of memory safe languages are Python, Java, C#, Go, Delphi&#x2F;Object Pascal, Swift, Ruby, Rust, and Ada. Memory safe languages provide differing degrees of memory usage protections, so available code hardening defenses, such as compiler options, tool analysis, and operating system configurations, should be used for their protections as well.</i>&quot;<p>The narrow definition of memory safety here is:<p>Go has garbage collection, so you won&#x27;t have memory leaks or use-after-free.<p>Go is powerful enough that beginners can cause segfaults by accidentally abusing internals, okay.<p>I&#x27;m not sure this is a very redeeming property of Go: Being able to crash the GC, without the flexibility of manual memory management.<p>But I&#x27;m not sure I&#x27;d categorize it as &quot;not memory safe&quot; for the same reason C&#x2F;C++ aren&#x27;t (a trade-off).<p>Because I don&#x27;t believe that you can generally leverage this for the kinds of memory exploits made in C&#x2F;C++.<p>I recall that some ML dialects (Standard ML and OCaml) have a library function Obj.magic : &#x27;a -&gt; &#x27;b which escapes the type system. Using this can easily cause segfaults. Does that mean Standard ML and OCaml are not memory safe? Generally, no, they&#x27;re extremely safe if you avoid that feature, which is most likely. This is arguably less safe than Go, since you most likely won&#x27;t accidentally run that function.<p>[1]: <a href="https:&#x2F;&#x2F;media.defense.gov&#x2F;2022&#x2F;Nov&#x2F;10&#x2F;2003112742&#x2F;-1&#x2F;-1&#x2F;0&#x2F;CSI_SOFTWARE_MEMORY_SAFETY.PDF" rel="nofollow">https:&#x2F;&#x2F;media.defense.gov&#x2F;2022&#x2F;Nov&#x2F;10&#x2F;2003112742&#x2F;-1&#x2F;-1&#x2F;0&#x2F;CSI...</a></div><br/><div id="42047897" class="c"><input type="checkbox" id="c-42047897" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42047857">parent</a><span>|</span><a href="#42049543">next</a><span>|</span><label class="collapse" for="c-42047897">[-]</label><label class="expand" for="c-42047897">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;m trying to provide some commentary to OP&#x27;s original term of &quot;ordinary code&quot; three comments above. While this term is inherently ambiguous and subjective, my personal opinion is that appending to slices simultaneously from multiple goroutines count as &quot;ordinary code&quot; but Obj.magic does not.</div><br/><div id="42048177" class="c"><input type="checkbox" id="c-42048177" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42047897">parent</a><span>|</span><a href="#42048182">next</a><span>|</span><label class="collapse" for="c-42048177">[-]</label><label class="expand" for="c-42048177">[5 more]</label></div><br/><div class="children"><div class="content">Yes. And: you will run into correctness bugs quickly if you mutate shared references in Go code. It&#x27;s only my contention that you won&#x27;t create a security vulnerability, in the colloquial understanding of the term (ie: a panic doesn&#x27;t count).</div><br/><div id="42049462" class="c"><input type="checkbox" id="c-42049462" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42048177">parent</a><span>|</span><a href="#42048945">next</a><span>|</span><label class="collapse" for="c-42049462">[-]</label><label class="expand" for="c-42049462">[1 more]</label></div><br/><div class="children"><div class="content">You can, though it&#x27;s much harder than in C or C++ or unsafe Rust for this to be exploitable. A data race on an interface value can give you a corrupted interface value, overwriting the vtable with struct contents. This can happen to lead to arbitrary code execution if you&#x27;re unlucky enough, though in most cases it would be a SIGSEGV. It&#x27;s also very hard for an attacker to craft a payload that can be guaranteed to reach this, though with a microservixe architecture with automatic restarts of failed services, they might get a lot of tries.</div><br/></div></div><div id="42048945" class="c"><input type="checkbox" id="c-42048945" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42048177">parent</a><span>|</span><a href="#42049462">prev</a><span>|</span><a href="#42049532">next</a><span>|</span><label class="collapse" for="c-42048945">[-]</label><label class="expand" for="c-42048945">[2 more]</label></div><br/><div class="children"><div class="content">If I can induce a race that corrupts a data structure so that it leaks data back to me that I shouldn’t have access to, does that count?</div><br/><div id="42049231" class="c"><input type="checkbox" id="c-42049231" checked=""/><div class="controls bullet"><span class="by">melodyogonna</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42048945">parent</a><span>|</span><a href="#42049532">next</a><span>|</span><label class="collapse" for="c-42049231">[-]</label><label class="expand" for="c-42049231">[1 more]</label></div><br/><div class="children"><div class="content">How can you do that?</div><br/></div></div></div></div><div id="42049532" class="c"><input type="checkbox" id="c-42049532" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42048177">parent</a><span>|</span><a href="#42048945">prev</a><span>|</span><a href="#42048182">next</a><span>|</span><label class="collapse" for="c-42049532">[-]</label><label class="expand" for="c-42049532">[1 more]</label></div><br/><div class="children"><div class="content">I mean, a very serious security vulnerability is&#x2F;was row hammering, where an attacker was waiting on flipping a bit they have no access to by continuously flipping neighboring ones. Compared to that a race condition is &quot;trivial&quot; to exploit.</div><br/></div></div></div></div></div></div><div id="42049543" class="c"><input type="checkbox" id="c-42049543" checked=""/><div class="controls bullet"><span class="by">capitol_</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42047857">parent</a><span>|</span><a href="#42047897">prev</a><span>|</span><a href="#42048610">next</a><span>|</span><label class="collapse" for="c-42049543">[-]</label><label class="expand" for="c-42049543">[1 more]</label></div><br/><div class="children"><div class="content">Could you share more of your thoughts on why that kind of memory corruption wouldn&#x27;t be exploitable? Do go have something in place that prevents it?</div><br/></div></div></div></div><div id="42048610" class="c"><input type="checkbox" id="c-42048610" checked=""/><div class="controls bullet"><span class="by">everybodyknows</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42047756">parent</a><span>|</span><a href="#42047857">prev</a><span>|</span><a href="#42048827">next</a><span>|</span><label class="collapse" for="c-42048610">[-]</label><label class="expand" for="c-42048610">[1 more]</label></div><br/><div class="children"><div class="content">&gt; corrupt GC state<p>I understand this to mean the runtime&#x27;s internal state, not visible to user code.  If so, in general we should expect almost any sort of crash mode to be possible.  Seems fair enough to call this &quot;memory-unsafe&quot;.</div><br/></div></div><div id="42048827" class="c"><input type="checkbox" id="c-42048827" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42047756">parent</a><span>|</span><a href="#42048610">prev</a><span>|</span><a href="#42048952">next</a><span>|</span><label class="collapse" for="c-42048827">[-]</label><label class="expand" for="c-42048827">[3 more]</label></div><br/><div class="children"><div class="content">Appending from multiple goroutine to an in un-synchronized slice is &quot;memory safe&quot;, it&#x27;s completely different from c&#x2F;c++.<p>It behave exactly like Java or C# which are also memory safe.</div><br/><div id="42049574" class="c"><input type="checkbox" id="c-42049574" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42048827">parent</a><span>|</span><a href="#42049539">next</a><span>|</span><label class="collapse" for="c-42049574">[-]</label><label class="expand" for="c-42049574">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure of C#, but Java has stronger memory guarantees than Go, even in the presence of a data race.<p>In Java, all primitive types (including Object pointers) are atomically modified. And since all Java writes are primitives (Java doesn&#x27;t have structs), you can never corrupt a data structure at the Java level. Of course, you can still corrupt it at a logical level (break an invariant established in the constructor), but not at the language level.<p>Go has a guarantee that word-sized reads&#x2F;writes are atomic, but Go has plenty of larger objects than that. In particular, interface values are &quot;fat pointers&quot; and exceed the word-size on all platforms, so interface writes are not atomic. Which means another thread can observe an interface value having a vtable from one object but data from another, and can then execute a method from one object on data from another object, potentially re-interpreting fields as values of other types.</div><br/></div></div><div id="42049539" class="c"><input type="checkbox" id="c-42049539" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42048827">parent</a><span>|</span><a href="#42049574">prev</a><span>|</span><a href="#42048952">next</a><span>|</span><label class="collapse" for="c-42049539">[-]</label><label class="expand" for="c-42049539">[1 more]</label></div><br/><div class="children"><div class="content">Not at all. Java or C# can end up in a logical bug from that, but they will never corrupt their runtime. So in java you can just try-catch whatever bad stuff happens there, and go on afterwards.<p>Go programs can literally segfault from a data race. That&#x27;s no memory safety.</div><br/></div></div></div></div></div></div><div id="42048952" class="c"><input type="checkbox" id="c-42048952" checked=""/><div class="controls bullet"><span class="by">danielheath</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42047696">parent</a><span>|</span><a href="#42047756">prev</a><span>|</span><a href="#42047750">next</a><span>|</span><label class="collapse" for="c-42048952">[-]</label><label class="expand" for="c-42048952">[2 more]</label></div><br/><div class="children"><div class="content">Go lets you use `unsafe.Pointer` (or indeed, assembly intrinsics) if you really want to, but those are certainly not used &quot;ordinarily&quot;.</div><br/><div id="42049588" class="c"><input type="checkbox" id="c-42049588" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42048952">parent</a><span>|</span><a href="#42047750">next</a><span>|</span><label class="collapse" for="c-42049588">[-]</label><label class="expand" for="c-42049588">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just about that. Data races can expose an object in a state that was never written from any thread in Go,  potentially corrupting even internal details not exposed. Simply writing a struct value from two different threads can expose this.</div><br/></div></div></div></div><div id="42047750" class="c"><input type="checkbox" id="c-42047750" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42047696">parent</a><span>|</span><a href="#42048952">prev</a><span>|</span><a href="#42049493">next</a><span>|</span><label class="collapse" for="c-42047750">[-]</label><label class="expand" for="c-42047750">[1 more]</label></div><br/><div class="children"><div class="content">An example of extraordinary code would be code that interfaces with and&#x2F;or pulls in non-memory-safe legacy C code.<p>Another example would be code specifically contrived to highlight a soundness problem in the language.<p>I used the term &quot;extraordinary&quot; to avoid exactly this kind of bickering over corner cases that aren&#x27;t relevant to day-to-day software development (or at least, not in ways that aren&#x27;t immediately evident when they come up.)</div><br/></div></div></div></div><div id="42049493" class="c"><input type="checkbox" id="c-42049493" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#42045932">root</a><span>|</span><a href="#42046101">parent</a><span>|</span><a href="#42047696">prev</a><span>|</span><a href="#42048732">next</a><span>|</span><label class="collapse" for="c-42049493">[-]</label><label class="expand" for="c-42049493">[1 more]</label></div><br/><div class="children"><div class="content">But ordinary go code is not memory safe. Data racing can trivially happen just by using the language&#x27;s primitives. It requires no special keyword like unsafe, or native FFI like in other, actually memory safe languages (rust, or of the GCd kind, java, c#, Js)</div><br/></div></div></div></div><div id="42048732" class="c"><input type="checkbox" id="c-42048732" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#42045932">parent</a><span>|</span><a href="#42046101">prev</a><span>|</span><a href="#42049104">next</a><span>|</span><label class="collapse" for="c-42048732">[-]</label><label class="expand" for="c-42048732">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I absolutely hated this at the start, but now ~3 years into maintaining a go codebase, I find it quite nice<p>I&#x27;ve heard this so often. Thanks for sharing :)<p>I find going back to other languages and trying to read other people&#x27;s code is a trial. There&#x27;s always the temptation to write &quot;smart&quot; code that is terse but takes a lot of parsing to understand.<p>I love that I can pick up anyone&#x27;s Go code and it&#x27;s going to make sense almost immediately because everything is explicit, and laid out the same way (including that rhythm of &quot;do the thing, test the error, do the thing, test the error&quot;)</div><br/></div></div><div id="42049104" class="c"><input type="checkbox" id="c-42049104" checked=""/><div class="controls bullet"><span class="by">lynx23</span><span>|</span><a href="#42045932">parent</a><span>|</span><a href="#42048732">prev</a><span>|</span><a href="#42046061">next</a><span>|</span><label class="collapse" for="c-42049104">[-]</label><label class="expand" for="c-42049104">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I know exactly what each function does<p>Isn&#x27;t this basically the same argument that C people have been using since, what, 40 years?</div><br/></div></div></div></div><div id="42046061" class="c"><input type="checkbox" id="c-42046061" checked=""/><div class="controls bullet"><span class="by">tbiehn</span><span>|</span><a href="#42045932">prev</a><span>|</span><a href="#42044457">next</a><span>|</span><label class="collapse" for="c-42046061">[-]</label><label class="expand" for="c-42046061">[1 more]</label></div><br/><div class="children"><div class="content">Semgrep is another great option to get value out of static analysis checks against both the language and a few common frameworks. It remains a popular choice for security folks writing static detection rules (and contributing them to the commons).<p>You can check the open rules here;
<a href="https:&#x2F;&#x2F;github.com&#x2F;semgrep&#x2F;semgrep-rules&#x2F;tree&#x2F;develop&#x2F;go">https:&#x2F;&#x2F;github.com&#x2F;semgrep&#x2F;semgrep-rules&#x2F;tree&#x2F;develop&#x2F;go</a></div><br/></div></div><div id="42044457" class="c"><input type="checkbox" id="c-42044457" checked=""/><div class="controls bullet"><span class="by">goodlinks</span><span>|</span><a href="#42046061">prev</a><span>|</span><a href="#42044190">next</a><span>|</span><label class="collapse" for="c-42044457">[-]</label><label class="expand" for="c-42044457">[42 more]</label></div><br/><div class="children"><div class="content">Does go have a bad security reputation?<p>I get that anything can be insecure and its a constant battle as this article suggests, but i thought it was quite secure and stable generally (say on a par with .net or any other tool you may use to make a web app at least?)</div><br/><div id="42044926" class="c"><input type="checkbox" id="c-42044926" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42044457">parent</a><span>|</span><a href="#42044749">next</a><span>|</span><label class="collapse" for="c-42044926">[-]</label><label class="expand" for="c-42044926">[10 more]</label></div><br/><div class="children"><div class="content">It has essentially the same security properties of all the modern non-C-languages (ie, C, C++, ObjC), with the added bonus of largely being designed after the deserialization pandemic that especially hit Java, Python, and Ruby. ~All these modern languages are fine for security (though: be careful with serialization formats in anything but Go and Rust).<p>Arguably, Rust and Go are the two &quot;most secure&quot; mainstream languages, but in reality I don&#x27;t think it much matters and that you&#x27;re likely to have approximately the same issues shipping in Python as in Rust (ie: logic and systems programming issues, not language-level issues).<p>Be wary of anyone trying to claim that there are <i>significant</i> security differences between any of the &quot;modern&quot; or &quot;high-level&quot; languages. These threads inexorably trend towards language-warring.</div><br/><div id="42045724" class="c"><input type="checkbox" id="c-42045724" checked=""/><div class="controls bullet"><span class="by">pants2</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42044926">parent</a><span>|</span><a href="#42045677">next</a><span>|</span><label class="collapse" for="c-42045724">[-]</label><label class="expand" for="c-42045724">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;d point out that one advantage Go has over Rust in terms of security are the coverage of standard libraries. Go has great support for HTTP clients&#x2F;servers, cryptography primitives, SSH, SQL, JSON, secure RNG, etc. all in officially maintained standard libraries. The Rust ecosystem has some standards here but the most widely used HTTP client, just as an example, is mostly maintained by one guy[1]. I think that adds considerable security risk vs Go&#x27;s net&#x2F;http.<p>1. <a href="https:&#x2F;&#x2F;github.com&#x2F;hyperium&#x2F;hyper&#x2F;graphs&#x2F;contributors">https:&#x2F;&#x2F;github.com&#x2F;hyperium&#x2F;hyper&#x2F;graphs&#x2F;contributors</a></div><br/><div id="42045753" class="c"><input type="checkbox" id="c-42045753" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42045724">parent</a><span>|</span><a href="#42049241">next</a><span>|</span><label class="collapse" for="c-42045753">[-]</label><label class="expand" for="c-42045753">[1 more]</label></div><br/><div class="children"><div class="content">For what it&#x27;s worth, I don&#x27;t believe there&#x27;s any meaningful security difference between Rust and Go.</div><br/></div></div><div id="42049241" class="c"><input type="checkbox" id="c-42049241" checked=""/><div class="controls bullet"><span class="by">silverliver</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42045724">parent</a><span>|</span><a href="#42045753">prev</a><span>|</span><a href="#42045677">next</a><span>|</span><label class="collapse" for="c-42049241">[-]</label><label class="expand" for="c-42049241">[1 more]</label></div><br/><div class="children"><div class="content">Good point. If you consider the size of your dependency graph as a risk, especially for languages that encourage large dependency graphs like JS and Rust, then Go has a very clear advantage.</div><br/></div></div></div></div><div id="42045677" class="c"><input type="checkbox" id="c-42045677" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42044926">parent</a><span>|</span><a href="#42045724">prev</a><span>|</span><a href="#42045668">next</a><span>|</span><label class="collapse" for="c-42045677">[-]</label><label class="expand" for="c-42045677">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Be wary of anyone trying to claim that there are significant security differences between any of the &quot;modern&quot; or &quot;high-level&quot; languages. These threads inexorably trend towards language-warring.</i><p>Hm, I think this is a reasonable take but taken too far. Presumably this out of a desire to avoid people arguing about this-language-feature vs. that-language-feature, but in practice &quot;the language&quot; also gets conflated with the tooling and the ecosystem for that language, and having good tooling and a good ecosystem actually does matter when it comes to security vulns in practice. Indeed, anyone can write SQL injection in any language, but having a culture of finding, reporting, and disseminating those vulnerabilities when they happen, and then having mature tooling to detect where those vulnerable packages are being used, and then having a responsive ecosystem where vulnerable packages get swiftly updated, those are all things that make for more secure languages in practice, even among languages with near-identical feature sets.</div><br/></div></div><div id="42045668" class="c"><input type="checkbox" id="c-42045668" checked=""/><div class="controls bullet"><span class="by">quietbritishjim</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42044926">parent</a><span>|</span><a href="#42045677">prev</a><span>|</span><a href="#42048139">next</a><span>|</span><label class="collapse" for="c-42045668">[-]</label><label class="expand" for="c-42045668">[4 more]</label></div><br/><div class="children"><div class="content">What is the &quot;deserialisation pandemic&quot;? It doesn&#x27;t have obvious web search results, and I&#x27;m struggling to imagine what about deserialisation what be common between Java and Python (except that, in both cases, I&#x27;d surely just use protobuf if I wanted binary serialisation).</div><br/><div id="42046198" class="c"><input type="checkbox" id="c-42046198" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42045668">parent</a><span>|</span><a href="#42045695">next</a><span>|</span><label class="collapse" for="c-42046198">[-]</label><label class="expand" for="c-42046198">[1 more]</label></div><br/><div class="children"><div class="content">In the early 2000&#x2F;2010s there was a popular idea that it&#x27;d be neat to have (de)serialization functionality that could perfectly roundtrip your language&#x27;s native objects, without requiring that the objects be whatever the language uses as plain old data storage. In the happy case it worked super well and basically every language sufficiently dynamic to support it got a library which let you take some in memory objects, write them to disk, then restore them exactly as they were at some later time.<p>This had the obvious-in-retrospect major problem that it meant that your deserialization was functionally equivalent to eval(), and if an attacker could ever control what you deserialized they could execute arbitrary code. Many programmers did not realize this and just plain called deserialization functions on untrusted data, and even when people did become aware that was bad it still turned lots of minor bugs into RCE bugs. It was often a long and painful migration away from insecure deserialization methods because of how darn convenient they were, so it continued to be a problem long after it was well understood that things like pickle were a bad idea.</div><br/></div></div><div id="42045695" class="c"><input type="checkbox" id="c-42045695" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42045668">parent</a><span>|</span><a href="#42046198">prev</a><span>|</span><a href="#42048139">next</a><span>|</span><label class="collapse" for="c-42045695">[-]</label><label class="expand" for="c-42045695">[2 more]</label></div><br/><div class="children"><div class="content">See <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Log4Shell" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Log4Shell</a> , but also historically the mess that is pickling&#x2F;unpickling in Python (see the big scary warning at the top of <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;pickle.html#pickle-python-object-serialization" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;pickle.html#pickle-python-...</a> ), and more broadly any dynamic language that exposes `eval` in any capacity.</div><br/><div id="42045769" class="c"><input type="checkbox" id="c-42045769" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42045695">parent</a><span>|</span><a href="#42048139">next</a><span>|</span><label class="collapse" for="c-42045769">[-]</label><label class="expand" for="c-42045769">[1 more]</label></div><br/><div class="children"><div class="content">For many years, these were the most widespread serverside RCE vulnerabilities; Rails YAML might be the best-known, but there were a bunch of different variants in Java serialization, and a whole cottage subfield of vulnerability research deriving different sequences of objects&#x2F;methods to bounce deserializations through. It was a huge problem, and my perception is that it sort of bled into SSRF (now the scariest vulnerability you&#x27;re likely to have serverside) via XML deserialization.</div><br/></div></div></div></div></div></div><div id="42048139" class="c"><input type="checkbox" id="c-42048139" checked=""/><div class="controls bullet"><span class="by">innocentoldguy</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42044926">parent</a><span>|</span><a href="#42045668">prev</a><span>|</span><a href="#42044749">next</a><span>|</span><label class="collapse" for="c-42048139">[-]</label><label class="expand" for="c-42048139">[1 more]</label></div><br/><div class="children"><div class="content">Elixir is &quot;more secure&quot; than Go due to its isolated processes, functional processing, and immutable data.</div><br/></div></div></div></div><div id="42044749" class="c"><input type="checkbox" id="c-42044749" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#42044457">parent</a><span>|</span><a href="#42044926">prev</a><span>|</span><a href="#42044663">next</a><span>|</span><label class="collapse" for="c-42044749">[-]</label><label class="expand" for="c-42044749">[26 more]</label></div><br/><div class="children"><div class="content">No.<p>Ironically, a flip side of the complaints about how Go lacks power is that a lot of the &quot;standard&quot; security vulnerabilities actually become harder to write. The most obvious one is lacking the &quot;eval&quot; that a dynamic language has; more subtle ones include things like, there is <i>no way</i> to take a string and look up a type or a method in the runtime, so things like the Ruby YAML vuln are not assisted by the language level. To write something like that into Go, you&#x27;d have to actually <i>write it in</i>. Though you can, if you try hard enoough.<p>But, as sibling comments point out, nothing stops you from writing an SQL injection. Command injections are inhibited by the command only taking the &quot;array of strings&quot; form of a command, with no &quot;just pass me a string and we&#x27;ll do shell things to it&quot; provided by the language, but I&#x27;ve dispatched multiple questions about how to run commands correctly in Go by programmers who managed to find []string{&quot;bash&quot;, &quot;-c&quot;, &quot;my command with user input from the web here&quot;}, so the evidence suggests this is still plenty easy enough to write. Putting the wrong perms or no perms on your resources is as easy as anything else; no special support for internal security (compare with E lang and capabilities languages). And the file access is still based on file names rather than inodes, so file-based TOCTOUs are the default in Go (just like pretty much everywhere else) if you aren&#x27;t careful. It comes with no special DOS protection or integrated WAF or anything else. You can still store passwords directly in databases, or as their MD5 sums. The default HTML templating system is fairly safe but you can still concatenate strings outside of the template system and ship them out over an HTTP connection in bad ways. Not every race condition is automatically a security vulnerability, but you can certainly write race conditions in Go that could be security vulnerabilities.<p>I&#x27;d say Go largely lacks the footguns some other languages have, but it still provides you plenty of knives you can stab yourself with and it won&#x27;t stop you.<p>I&#x27;ve been running govulncheck against my repos for a while, and I have seen some real vulnerabilities go by that could have affected my code, but rather than &quot;get arbitrary execution&quot; they tend to be &quot;didn&#x27;t correctly escape output in some particular edge case&quot;, which in the right circumstances can still be serious, but is still at least <i>less</i> concerning than &quot;gets arbitrary execution&quot;.</div><br/><div id="42044930" class="c"><input type="checkbox" id="c-42044930" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42044749">parent</a><span>|</span><a href="#42045080">next</a><span>|</span><label class="collapse" for="c-42044930">[-]</label><label class="expand" for="c-42044930">[15 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d say Go largely lacks the footguns some other languages have<p>With the glaring exception of &quot;I forgot to check the error code&quot;, which you need a linter (e.g. as provided by golangci-lint) for. It&#x27;s critically important for security that you know whether the function you just called gave you a meaningful result! Most other languages either have sum types or exceptions.</div><br/><div id="42044955" class="c"><input type="checkbox" id="c-42044955" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42044930">parent</a><span>|</span><a href="#42045602">next</a><span>|</span><label class="collapse" for="c-42044955">[-]</label><label class="expand" for="c-42044955">[6 more]</label></div><br/><div class="children"><div class="content">No it&#x27;s not. This is what I meant, cross-thread, when I suggested being wary of arguments trying to draw <i>significant</i> distinctions between memory-safe-language X and memory-safe-language Y. Error checking idioms and affordances have profound implications for correctness and for how you build and test code. Programmers have <i>strong</i> preferences. But those implications have only incidental connections to security, if any. Nevertheless &quot;security&quot; is a good claim to throw into a &quot;my language is better&quot; argument.</div><br/><div id="42045180" class="c"><input type="checkbox" id="c-42045180" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42044955">parent</a><span>|</span><a href="#42045602">next</a><span>|</span><label class="collapse" for="c-42045180">[-]</label><label class="expand" for="c-42045180">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t even use Golang, I maybe read two Golang repos a year, I find these errors in almost every repo I look at (probably because of the selection effect: I only look at the code for tools I find bugs in). One of them I remember was a critical vulnerability of exactly this form, so :shrug: Perhaps I&#x27;m just grotesquely unlucky in the Golang projects I see, but that makes maybe 10% of the Golang error-handling bugs I&#x27;ve found to be security bugs.</div><br/><div id="42045185" class="c"><input type="checkbox" id="c-42045185" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42045180">parent</a><span>|</span><a href="#42045602">next</a><span>|</span><label class="collapse" for="c-42045185">[-]</label><label class="expand" for="c-42045185">[4 more]</label></div><br/><div class="children"><div class="content">Sounds memorable. Say more about this critical vulnerability?</div><br/><div id="42045404" class="c"><input type="checkbox" id="c-42045404" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42045185">parent</a><span>|</span><a href="#42045602">next</a><span>|</span><label class="collapse" for="c-42045404">[-]</label><label class="expand" for="c-42045404">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll gesture at it. It&#x27;s not an open source tool, so I can&#x27;t point at the code (and in fact I just checked and I don&#x27;t have perms to see the Jira ticket I caused to be raised!), and I am wary of describing security bugs in company-internal code. But in general terms it was a service that attempted to check whether a request was allowed, and it ignored errors from that check. (I just searched history for a bit to find the error in the absence of any actual details about it, but it was a while ago and I failed.) Sorry this is not a very satisfying answer.</div><br/></div></div></div></div></div></div></div></div><div id="42045602" class="c"><input type="checkbox" id="c-42045602" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42044930">parent</a><span>|</span><a href="#42044955">prev</a><span>|</span><a href="#42048053">next</a><span>|</span><label class="collapse" for="c-42045602">[-]</label><label class="expand" for="c-42045602">[3 more]</label></div><br/><div class="children"><div class="content">Mmm, that&#x27;s fair. I tend to forget about it because it&#x27;s not something I personally struggle with but that doesn&#x27;t mean it&#x27;s not a problem.<p>I&#x27;d still rate it well below a string eval or a default shell interface that takes strings and treats them like shell does. You assert down below that you&#x27;ve seen this lead to a critical vulnerability and I believe you, but in general what happens if you forget to check errors is that sooner or later you get a panic or something else that goes so far off the rails that your program crashes, not that you get privs you shouldn&#x27;t. As I say in another comment, any sort of confusing bit of code in any language <i>could</i> be the linchpin of some specific security vulnerability, but there are still capabilities that lead to more security issues than some other capabilities. Compared to what I&#x27;ve seen in languages like Perl this is still only &quot;medium-grade&quot; at best.<p>And I&#x27;m not trying to &quot;defend&quot; Go, which is part of why I gave the laundry list of issues it still has. It&#x27;s just a matter of perspective; even missing the odd error check here or there is just not the same caliber problem as an environment where people casually blast user-sourced input out to shell because the language makes it easier than doing it right.<p>(Independent of language I consider code that looks like<p><pre><code>    operation = determineOperation()
    if !canIDoOperation(operation) {
        &#x2F;&#x2F; handle failures
    }
    doOperation(operation)
</code></pre>
architecturally broken anyhow. It seems natural code to write, but this is a form of default allow. If you forget to check the operation in one place, or even perhaps forget to write a <i>return</i> in the if clause, the operation proceeds anyhow. You need to write some structure where operations can&#x27;t be reached without a positive affirmation that it is allowed. I&#x27;d bet the code that was broken due to failing to check an error amounted to this in the end. (Edit: Oh, I see you did say that.) And, like I said, this is independent of Go; other than the capabilities-based languages this code can be written in pretty much anything.)</div><br/><div id="42046143" class="c"><input type="checkbox" id="c-42046143" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42045602">parent</a><span>|</span><a href="#42048053">next</a><span>|</span><label class="collapse" for="c-42046143">[-]</label><label class="expand" for="c-42046143">[2 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s a reasonable observation but it isn&#x27;t a fair comparative security criteria. The subtext behind error checking critiques is that languages with idiomatic sum type returns avoid authz vulnerabilities, in the same way that memory-safety in Go eliminates UAF vulnerabilities. But authz vulnerabilities are endemic to the mainstream sum type languages, too; they&#x27;re much more complicated as a bug class than just &quot;am I forced to check return codes before using return values&quot;.<p>Sum types are one of the few things I miss when switching from other languages back to Go. I like them a lot. But I think they&#x27;re wildly overstated as a security feature. Sum type languages have external tooling projects to spot authz vulnerabilities!</div><br/></div></div></div></div><div id="42048053" class="c"><input type="checkbox" id="c-42048053" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42044930">parent</a><span>|</span><a href="#42045602">prev</a><span>|</span><a href="#42045001">next</a><span>|</span><label class="collapse" for="c-42048053">[-]</label><label class="expand" for="c-42048053">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; &quot;I forgot to check the error code&quot;</i><p>How is it that people &quot;forget to check errors&quot; but not other types, even though they are all just 1s and 0s? Or, to put it another way, why do programmers forget how to program as soon as they see the word &quot;error&quot;?<p>It seems to be a real phenomenon, but I can&#x27;t make sense of how it can happen. It is not some subtle thing like misspelling a word in a string constant. You are leaving out entire functionality from your application. It is almost on the order of forgetting to add the main function.</div><br/><div id="42048487" class="c"><input type="checkbox" id="c-42048487" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42048053">parent</a><span>|</span><a href="#42045001">next</a><span>|</span><label class="collapse" for="c-42048487">[-]</label><label class="expand" for="c-42048487">[1 more]</label></div><br/><div class="children"><div class="content">I would think it&#x27;s a mix of not being sure exactly what to do on error and not wanting to undergo the effort of writing error logic. You have to switch from &quot;basic skeletal structure of the program&quot; to &quot;cover all bases&quot;, which isn&#x27;t simple. So it&#x27;s easy to have no or rudimentary error handling, and by the time you want to change it, it&#x27;s hard to change. Like, &quot;malloc can fail, but it would be a lot easier right now if I assume it won&#x27;t&quot;.</div><br/></div></div></div></div><div id="42045001" class="c"><input type="checkbox" id="c-42045001" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42044930">parent</a><span>|</span><a href="#42048053">prev</a><span>|</span><a href="#42045080">next</a><span>|</span><label class="collapse" for="c-42045001">[-]</label><label class="expand" for="c-42045001">[3 more]</label></div><br/><div class="children"><div class="content">as if DoS by exception is any better...</div><br/><div id="42045196" class="c"><input type="checkbox" id="c-42045196" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42045001">parent</a><span>|</span><a href="#42045080">next</a><span>|</span><label class="collapse" for="c-42045196">[-]</label><label class="expand" for="c-42045196">[2 more]</label></div><br/><div class="children"><div class="content">Depends on the application! There&#x27;s a reason we have the concept of &quot;failing closed&quot; vs &quot;failing open&quot;: sometimes (very often, in fact) it&#x27;s correct to shut down under attack, rather than to open up under attack.</div><br/><div id="42045543" class="c"><input type="checkbox" id="c-42045543" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42045196">parent</a><span>|</span><a href="#42045080">next</a><span>|</span><label class="collapse" for="c-42045543">[-]</label><label class="expand" for="c-42045543">[1 more]</label></div><br/><div class="children"><div class="content">The subtext of that comment cuts against the argument you&#x27;re trying to make here: a panic following a missed error check is always fail-closed, but exception recovery is not.</div><br/></div></div></div></div></div></div></div></div><div id="42045080" class="c"><input type="checkbox" id="c-42045080" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42044749">parent</a><span>|</span><a href="#42044930">prev</a><span>|</span><a href="#42046130">next</a><span>|</span><label class="collapse" for="c-42045080">[-]</label><label class="expand" for="c-42045080">[2 more]</label></div><br/><div class="children"><div class="content">One thing to note about data races in Go is that the safe Go subset is only memory-safe if you do not have data races. The original post alludes to that because it mentions the race detector. This situation is different from Java where the expected effect of data races on memory safety is bounded (originally due to the sandbox, now bounded effects are more of QoI aspect). Data races in Java are still bad, and your code may go into infinite loops if you have them (among other things), but they won&#x27;t turn a long into an object reference.<p>The good news is that the Go implementation can be changed to handle data races more gracefully, with some additional run-time overhead and some increase in compiler complexity and run-time library complexity, but without language changes. I expect this to happen eventually, once someone manages to get code execution through a data race in a high-profile Go application and publishes the results.</div><br/><div id="42045174" class="c"><input type="checkbox" id="c-42045174" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42045080">parent</a><span>|</span><a href="#42046130">next</a><span>|</span><label class="collapse" for="c-42045174">[-]</label><label class="expand" for="c-42045174">[1 more]</label></div><br/><div class="children"><div class="content">These arguments would be more compelling if they came with actual exploitable vulnerabilities --- in shipped code, with real threat models --- demonstrating them, but of course the lived experience of professional programmers is that non-contrived Go memory safety vulnerabilities are so rare as to be practically nonexistent.</div><br/></div></div></div></div><div id="42046130" class="c"><input type="checkbox" id="c-42046130" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42044749">parent</a><span>|</span><a href="#42045080">prev</a><span>|</span><a href="#42045259">next</a><span>|</span><label class="collapse" for="c-42046130">[-]</label><label class="expand" for="c-42046130">[2 more]</label></div><br/><div class="children"><div class="content">About footguns, I&#x27;d like to mention an important one: in Go, it&#x27;s hard to deserialize data wrongly. It&#x27;s not like python and typescript where you declare your input data to be one thing, and then receive something else. It&#x27;s a feature that makes server code, which after all is Go&#x27;s niche, considerably more reliable.<p>Safety isn&#x27;t 0% or 100%, and the more a language offers, the better the result. Go is performant, safe, and fairly easy to read and write. What else do you need (in 99.9% of the cases)?</div><br/><div id="42046672" class="c"><input type="checkbox" id="c-42046672" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42046130">parent</a><span>|</span><a href="#42045259">next</a><span>|</span><label class="collapse" for="c-42046672">[-]</label><label class="expand" for="c-42046672">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s not like python and typescript where you declare your input data to be one thing, and then receive something else<p>In Python that&#x27;s likely to lead to a runtime TypeError, not so much in TS since at runtime it&#x27;s JS and JS is weakly typed.<p>Besides, Python has Pydantic which everyone should really should be using. :-)</div><br/></div></div></div></div><div id="42045259" class="c"><input type="checkbox" id="c-42045259" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42044749">parent</a><span>|</span><a href="#42046130">prev</a><span>|</span><a href="#42044663">next</a><span>|</span><label class="collapse" for="c-42045259">[-]</label><label class="expand" for="c-42045259">[6 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d say Go largely lacks the footguns some other languages have<p>It does have a couple of its own. Like ((*SomeStruct)(nil)).(SomeInterface) != nil.<p>And yeah, the error handling is fucked up.</div><br/><div id="42045555" class="c"><input type="checkbox" id="c-42045555" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42045259">parent</a><span>|</span><a href="#42044663">next</a><span>|</span><label class="collapse" for="c-42045555">[-]</label><label class="expand" for="c-42045555">[5 more]</label></div><br/><div class="children"><div class="content">I was referring specifically to security footguns like having a string eval. While one can construct code in which that is the critical error that led to a security vulnerability, that can be said about any confusing bit of code in any language, and I would not judge that to <i>especially</i> lead to security issues.</div><br/><div id="42045838" class="c"><input type="checkbox" id="c-42045838" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42045555">parent</a><span>|</span><a href="#42044663">next</a><span>|</span><label class="collapse" for="c-42045838">[-]</label><label class="expand" for="c-42045838">[4 more]</label></div><br/><div class="children"><div class="content">This actually is a security footgun. In Java or C# you can&#x27;t get security issues by trying to update a reference from multiple threads, because it&#x27;s always atomic. In Go you can create type confusion because interface pointer updates are not atomic.</div><br/><div id="42045971" class="c"><input type="checkbox" id="c-42045971" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42045838">parent</a><span>|</span><a href="#42046151">next</a><span>|</span><label class="collapse" for="c-42045971">[-]</label><label class="expand" for="c-42045971">[2 more]</label></div><br/><div class="children"><div class="content">This sets the bar ludicrously low for &quot;security footgun&quot;. If this is a &quot;security footgun&quot; then what is string evaluation in a dynamic scripting language, a &quot;security foot-nuke&quot;?<p>Granted, there is no sharp line that can be drawn, but given my personal career I&#x27;d say <i>I&#x27;ve encountered it personally at least once</i> is a reasonable bar, if not quite excessively low. (tptacek would have to set the bar somewhere else, given his career.) Concurrency issues causing a security issue because of type confusion on an interface in a Go program is not a &quot;every time I crack open a program, oi, this security vulnerability again&quot; like bad HTML escaping or passing things straight to a shell. I mean, &quot;concurrency issues causing type confusion on an interface&quot; is <i>already</i> not something I&#x27;ve ever personally witnessed, <i>let alone</i> it actually being a security issue rather than a difficult-to-trace panic issue.<p>And I will reiterate, I <i>already</i> say that <i>any</i> bug can become a security issue in the right context. That doesn&#x27;t make them all &quot;security footguns&quot;.</div><br/><div id="42046131" class="c"><input type="checkbox" id="c-42046131" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42045971">parent</a><span>|</span><a href="#42046151">next</a><span>|</span><label class="collapse" for="c-42046131">[-]</label><label class="expand" for="c-42046131">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This sets the bar ludicrously low for &quot;security footgun&quot;. If this is a &quot;security footgun&quot; then what is string evaluation in a dynamic scripting language, a &quot;security foot-nuke&quot;?<p>Not really. Apart from dangerous serialization formats (e.g. Python&#x27;s &quot;pickle&quot;) it&#x27;s not at all easy to eval a string in modern scripting languages.<p>String evals are also not widely used anymore.</div><br/></div></div></div></div><div id="42046151" class="c"><input type="checkbox" id="c-42046151" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42044457">root</a><span>|</span><a href="#42045838">parent</a><span>|</span><a href="#42045971">prev</a><span>|</span><a href="#42044663">next</a><span>|</span><label class="collapse" for="c-42046151">[-]</label><label class="expand" for="c-42046151">[1 more]</label></div><br/><div class="children"><div class="content">Point to a real, exploitable, public vulnerability that exploits this behavior, and then we&#x27;ll all be talking about the same thing.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42044663" class="c"><input type="checkbox" id="c-42044663" checked=""/><div class="controls bullet"><span class="by">valbaca</span><span>|</span><a href="#42044457">parent</a><span>|</span><a href="#42044749">prev</a><span>|</span><a href="#42044586">next</a><span>|</span><label class="collapse" for="c-42044663">[-]</label><label class="expand" for="c-42044663">[1 more]</label></div><br/><div class="children"><div class="content">&gt; i thought it was quite secure and stable generally<p>It is, but security isn&#x27;t a &quot;given&quot; anywhere. XSS, SQL Injection, Dependency  etc can be done by any language, regardless of how &quot;secure&quot; it claims to be.<p>The headings are all pretty general (versioning, tooling, scanning, testing) but the contents are Go-specific.<p>It&#x27;s a pretty good article IMO and could&#x2F;should be replicated for other languages as well.</div><br/></div></div><div id="42044586" class="c"><input type="checkbox" id="c-42044586" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#42044457">parent</a><span>|</span><a href="#42044663">prev</a><span>|</span><a href="#42044762">next</a><span>|</span><label class="collapse" for="c-42044586">[-]</label><label class="expand" for="c-42044586">[1 more]</label></div><br/><div class="children"><div class="content">You can write SQL injection in any language.</div><br/></div></div><div id="42044762" class="c"><input type="checkbox" id="c-42044762" checked=""/><div class="controls bullet"><span class="by">perryh2</span><span>|</span><a href="#42044457">parent</a><span>|</span><a href="#42044586">prev</a><span>|</span><a href="#42044641">next</a><span>|</span><label class="collapse" for="c-42044762">[-]</label><label class="expand" for="c-42044762">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Does go have a bad security reputation?<p>Depends on who&#x27;s behind the keyboard.</div><br/></div></div><div id="42044641" class="c"><input type="checkbox" id="c-42044641" checked=""/><div class="controls bullet"><span class="by">jiehong</span><span>|</span><a href="#42044457">parent</a><span>|</span><a href="#42044762">prev</a><span>|</span><a href="#42047268">next</a><span>|</span><label class="collapse" for="c-42044641">[-]</label><label class="expand" for="c-42044641">[1 more]</label></div><br/><div class="children"><div class="content">You can use outdated dependencies in any language.</div><br/></div></div></div></div><div id="42044190" class="c"><input type="checkbox" id="c-42044190" checked=""/><div class="controls bullet"><span class="by">gus_leonel</span><span>|</span><a href="#42044457">prev</a><span>|</span><a href="#42044645">next</a><span>|</span><label class="collapse" for="c-42044190">[-]</label><label class="expand" for="c-42044190">[1 more]</label></div><br/><div class="children"><div class="content">TIL about `gosec`.</div><br/></div></div><div id="42044645" class="c"><input type="checkbox" id="c-42044645" checked=""/><div class="controls bullet"><span class="by">pram</span><span>|</span><a href="#42044190">prev</a><span>|</span><a href="#42045604">next</a><span>|</span><label class="collapse" for="c-42044645">[-]</label><label class="expand" for="c-42044645">[28 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been maintaining a Go app for about 9 years now and I can just upgrade the Go version + mod for vulnerabilities (GitHub tells me about them automatically idk) and it works with no changes 99% of the time. I can&#x27;t overstate how this makes maintaining it very stress-free.<p>My JS apps on the other hand...</div><br/><div id="42045387" class="c"><input type="checkbox" id="c-42045387" checked=""/><div class="controls bullet"><span class="by">rollulus</span><span>|</span><a href="#42044645">parent</a><span>|</span><a href="#42045348">next</a><span>|</span><label class="collapse" for="c-42045387">[-]</label><label class="expand" for="c-42045387">[5 more]</label></div><br/><div class="children"><div class="content">My few tiny steps in JS world were alienating in that sense: having a brand new install of all tools, doing a “npx create-react-app” and got greeted with “congrats, your app is initialised, it has 13 vulnerable dependencies”.</div><br/><div id="42045588" class="c"><input type="checkbox" id="c-42045588" checked=""/><div class="controls bullet"><span class="by">hombre_fatal</span><span>|</span><a href="#42044645">root</a><span>|</span><a href="#42045387">parent</a><span>|</span><a href="#42046068">next</a><span>|</span><label class="collapse" for="c-42045588">[-]</label><label class="expand" for="c-42045588">[2 more]</label></div><br/><div class="children"><div class="content">Tbf those are development deps rather than production server deps, and the vuln will be something like &quot;DOS possible if you let users craft their own regex string as input to lib.foo(re) in a server ctx&quot; rather than &quot;by using this in development to build your static js app, people get remote access to your dev machine.&quot;</div><br/><div id="42045977" class="c"><input type="checkbox" id="c-42045977" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#42044645">root</a><span>|</span><a href="#42045588">parent</a><span>|</span><a href="#42046068">next</a><span>|</span><label class="collapse" for="c-42045977">[-]</label><label class="expand" for="c-42045977">[1 more]</label></div><br/><div class="children"><div class="content">It is a bit silly then that it reports them as vulnerabilities by default.</div><br/></div></div></div></div><div id="42046068" class="c"><input type="checkbox" id="c-42046068" checked=""/><div class="controls bullet"><span class="by">vdvsvwvwvwvwv</span><span>|</span><a href="#42044645">root</a><span>|</span><a href="#42045387">parent</a><span>|</span><a href="#42045588">prev</a><span>|</span><a href="#42045348">next</a><span>|</span><label class="collapse" for="c-42046068">[-]</label><label class="expand" for="c-42046068">[2 more]</label></div><br/><div class="children"><div class="content">Worse CRA goes from saviour to deprecated, &quot;use nextjs or vite instead&quot; in a blink. Meta should maintain it. Nextjs will probably morph again in the future so you hope investing in learning vite is the answer. JS has this way.<p>Meanwhile Rails is so old it is thinking it needs to find a partner, settle down and buy a picket fenced house.</div><br/><div id="42048077" class="c"><input type="checkbox" id="c-42048077" checked=""/><div class="controls bullet"><span class="by">mplewis</span><span>|</span><a href="#42044645">root</a><span>|</span><a href="#42046068">parent</a><span>|</span><a href="#42045348">next</a><span>|</span><label class="collapse" for="c-42048077">[-]</label><label class="expand" for="c-42048077">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately, in Rails, your major breaking changes without a migration path come from the core team.</div><br/></div></div></div></div></div></div><div id="42045348" class="c"><input type="checkbox" id="c-42045348" checked=""/><div class="controls bullet"><span class="by">dilap</span><span>|</span><a href="#42044645">parent</a><span>|</span><a href="#42045387">prev</a><span>|</span><a href="#42046500">next</a><span>|</span><label class="collapse" for="c-42045348">[-]</label><label class="expand" for="c-42045348">[1 more]</label></div><br/><div class="children"><div class="content">The very first Go code I ever wrote, way back in 2011, still compiles and runs perfectly. It&#x27;s glorious.</div><br/></div></div><div id="42046500" class="c"><input type="checkbox" id="c-42046500" checked=""/><div class="controls bullet"><span class="by">spmurrayzzz</span><span>|</span><a href="#42044645">parent</a><span>|</span><a href="#42045348">prev</a><span>|</span><a href="#42044679">next</a><span>|</span><label class="collapse" for="c-42046500">[-]</label><label class="expand" for="c-42046500">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had similar experiences, but I&#x27;ve noticed my Node.js applications which have few-to-no dependencies behave in the same way as my Go apps in that regard. I might get some deprecation logs from Node letting me know about future changes, but generally they do just work. The apps with a heavy dependency graph are a different story however.<p>This is still a feather in Go&#x27;s cap given the fact that the standard library offers so much out of the box. I don&#x27;t find myself reaching for dependencies that often.</div><br/></div></div><div id="42044679" class="c"><input type="checkbox" id="c-42044679" checked=""/><div class="controls bullet"><span class="by">valbaca</span><span>|</span><a href="#42044645">parent</a><span>|</span><a href="#42046500">prev</a><span>|</span><a href="#42045341">next</a><span>|</span><label class="collapse" for="c-42044679">[-]</label><label class="expand" for="c-42044679">[14 more]</label></div><br/><div class="children"><div class="content">I shudder to think the amount of thousands of engineering hours are spent in my FAANG to keep our Java services just running as-is with updates.<p>And now we&#x27;re moving more to Typescript on Node...UGH.</div><br/><div id="42044889" class="c"><input type="checkbox" id="c-42044889" checked=""/><div class="controls bullet"><span class="by">adhamsalama</span><span>|</span><a href="#42044645">root</a><span>|</span><a href="#42044679">parent</a><span>|</span><a href="#42045341">next</a><span>|</span><label class="collapse" for="c-42044889">[-]</label><label class="expand" for="c-42044889">[13 more]</label></div><br/><div class="children"><div class="content">I thought Java was robust. What&#x27;s the hassle?</div><br/><div id="42045062" class="c"><input type="checkbox" id="c-42045062" checked=""/><div class="controls bullet"><span class="by">coredog64</span><span>|</span><a href="#42044645">root</a><span>|</span><a href="#42044889">parent</a><span>|</span><a href="#42045292">next</a><span>|</span><label class="collapse" for="c-42045062">[-]</label><label class="expand" for="c-42045062">[5 more]</label></div><br/><div class="children"><div class="content">Not OP, but typically Spring and transitive dependencies.  Some package that you don’t even use is pulled in and has a CVE.  Or you upgrade major Spring versions and the API changes underneath you.</div><br/><div id="42045334" class="c"><input type="checkbox" id="c-42045334" checked=""/><div class="controls bullet"><span class="by">okeuro49</span><span>|</span><a href="#42044645">root</a><span>|</span><a href="#42045062">parent</a><span>|</span><a href="#42045608">next</a><span>|</span><label class="collapse" for="c-42045334">[-]</label><label class="expand" for="c-42045334">[1 more]</label></div><br/><div class="children"><div class="content">I recommend Spring Boot, it provides a &quot;blessed&quot; set of dependencies that work with each other. When you want to upgrade, you just need to increase one version (the Spring Boot version).</div><br/></div></div><div id="42045608" class="c"><input type="checkbox" id="c-42045608" checked=""/><div class="controls bullet"><span class="by">blibble</span><span>|</span><a href="#42044645">root</a><span>|</span><a href="#42045062">parent</a><span>|</span><a href="#42045334">prev</a><span>|</span><a href="#42045190">next</a><span>|</span><label class="collapse" for="c-42045608">[-]</label><label class="expand" for="c-42045608">[1 more]</label></div><br/><div class="children"><div class="content">if you don&#x27;t pull in 50 jars to replace the &quot;new&quot; keyword (aka spring DI), then this ceases to be a problem</div><br/></div></div><div id="42045190" class="c"><input type="checkbox" id="c-42045190" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#42044645">root</a><span>|</span><a href="#42045062">parent</a><span>|</span><a href="#42045608">prev</a><span>|</span><a href="#42045292">next</a><span>|</span><label class="collapse" for="c-42045190">[-]</label><label class="expand" for="c-42045190">[2 more]</label></div><br/><div class="children"><div class="content">Have people considered frameworks implementing JAX-RS instead? Or does the breakage happen specifically in extensions to Spring?<p>The only inconvenience I have experienced upgrading a Quarkus backend is renaming javax.* package imports to jakarta.*. Hopefully the next major version requires just as little effort (if not less).<p>I am sure there would have been a lot more work if the project used extensions like the Kubernetes client. But overall, I have had the best experience with tools like Maven (for Java) and Leiningen (for Clojure). It helps to avoid libraries that hack or access JDK internals (e.g. Lombok, or ancient libraries using sun.* internal packages for reflection)</div><br/><div id="42045393" class="c"><input type="checkbox" id="c-42045393" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#42044645">root</a><span>|</span><a href="#42045190">parent</a><span>|</span><a href="#42045292">next</a><span>|</span><label class="collapse" for="c-42045393">[-]</label><label class="expand" for="c-42045393">[1 more]</label></div><br/><div class="children"><div class="content">The main problem is Spring Boot and some other Spring projects like Security.<p>If you would use Spring MVC directly, it is very possible that one could upgrade Spring versions for many years with minimal or no changes at all.<p>However Spring Boot regularly breaks code. And given the fact that it&#x27;s very popular, it means that any Java upgrade is pain. You need to rewrite code, sometimes a lot of code.<p>If you just use JAX-RS, probably simple Spring setup would suffice, but people usually want to slap database, security stuff and other things and everything is provided by Spring, so it&#x27;s not apples-to-apples comparison.</div><br/></div></div></div></div></div></div><div id="42045292" class="c"><input type="checkbox" id="c-42045292" checked=""/><div class="controls bullet"><span class="by">alex-nt</span><span>|</span><a href="#42044645">root</a><span>|</span><a href="#42044889">parent</a><span>|</span><a href="#42045062">prev</a><span>|</span><a href="#42045239">next</a><span>|</span><label class="collapse" for="c-42045292">[-]</label><label class="expand" for="c-42045292">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been working with Java for the last decade and for the past 5Y used the latest LTS versions in a very regulated environment (we have very strict patch deadlines for most CVEs). Rarely we hit issues with migrating to different versions of our dependencies. The most painful one was a small API change in Spring that revealed that we were doing something <i>very bad</i> so it took me 1-2D in between meetings to investigate. It is true though that every few weeks we are hit by a new CVE and we have to patch a lib version, but TBH this is what I expect from a language that has so many eyes on it&#x27;s ecosystem.</div><br/></div></div><div id="42045239" class="c"><input type="checkbox" id="c-42045239" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#42044645">root</a><span>|</span><a href="#42044889">parent</a><span>|</span><a href="#42045292">prev</a><span>|</span><a href="#42045341">next</a><span>|</span><label class="collapse" for="c-42045239">[-]</label><label class="expand" for="c-42045239">[6 more]</label></div><br/><div class="children"><div class="content">Java is fairly robust and plenty of libraries are very low-velocity.<p>JVM itself, however, has had several breaking changes recently. So a lot of organizations are stuck on an ancient version of the language.</div><br/><div id="42046437" class="c"><input type="checkbox" id="c-42046437" checked=""/><div class="controls bullet"><span class="by">akdev1l</span><span>|</span><a href="#42044645">root</a><span>|</span><a href="#42045239">parent</a><span>|</span><a href="#42045341">next</a><span>|</span><label class="collapse" for="c-42046437">[-]</label><label class="expand" for="c-42046437">[5 more]</label></div><br/><div class="children"><div class="content">Not really true imo.<p>I speak from the experience of supervised the upgrade of thousands of services from JDK8 to JDK17<p>There’s few quirks added but:<p>1. JDK17 will happily run JDK8 code without any changes
2. Most of the issues I observed were due to project jigsaw (and were resolved by adding —add-opens as needed)<p>I would expect 17 &gt; 21 upgrade to have basically no issues as an upgrade in place<p>I hate Java but backwards compatibility isn’t one of the reasons why I hate it</div><br/><div id="42046723" class="c"><input type="checkbox" id="c-42046723" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#42044645">root</a><span>|</span><a href="#42046437">parent</a><span>|</span><a href="#42045341">next</a><span>|</span><label class="collapse" for="c-42046723">[-]</label><label class="expand" for="c-42046723">[4 more]</label></div><br/><div class="children"><div class="content">This unfortunately is not true for large codebases. The language and the basic library are extremely stable, but the overall runtime is not. So the 8-&gt;17 switch resulted in lots and lots of regressions.<p>So companies either pay Oracle to maintain the old JDK8, or use something like Amazon Corretto. It&#x27;s so bad that there are companies promising JDK8 support until 2031 at least.<p>And yeah, upgrades past 17 are easy.</div><br/><div id="42046941" class="c"><input type="checkbox" id="c-42046941" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#42044645">root</a><span>|</span><a href="#42046723">parent</a><span>|</span><a href="#42045341">next</a><span>|</span><label class="collapse" for="c-42046941">[-]</label><label class="expand" for="c-42046941">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s so bad that there are companies promising JDK8<p>Come on, that&#x27;s absolutely not the reason behind. That just means that there are banks and such that still run goddamn windows XP completely firewalled off from the internet just because. Similarly, for some companies not touching that ancient codebase and just having it safely run worth the hassle and the money.<p>Java is the most backwards compatible language and it is not even a close competition.</div><br/><div id="42049623" class="c"><input type="checkbox" id="c-42049623" checked=""/><div class="controls bullet"><span class="by">Yasuraka</span><span>|</span><a href="#42044645">root</a><span>|</span><a href="#42046941">parent</a><span>|</span><a href="#42047860">next</a><span>|</span><label class="collapse" for="c-42049623">[-]</label><label class="expand" for="c-42049623">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Java is the most backwards compatible language and it is not even a close competition.<p>In competitions consisting of Java, PHP and Python, I presume?</div><br/></div></div><div id="42047860" class="c"><input type="checkbox" id="c-42047860" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#42044645">root</a><span>|</span><a href="#42046941">parent</a><span>|</span><a href="#42049623">prev</a><span>|</span><a href="#42045341">next</a><span>|</span><label class="collapse" for="c-42047860">[-]</label><label class="expand" for="c-42047860">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Similarly, for some companies not touching that ancient codebase and just having it safely run worth the hassle and the money.
&gt; Java is the most backwards compatible language and it is not even a close competition.<p>It&#x27;s amazing to have two contradicting sentences right next to each other.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42045341" class="c"><input type="checkbox" id="c-42045341" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42044645">parent</a><span>|</span><a href="#42044679">prev</a><span>|</span><a href="#42045323">next</a><span>|</span><label class="collapse" for="c-42045341">[-]</label><label class="expand" for="c-42045341">[1 more]</label></div><br/><div class="children"><div class="content">&gt; GitHub tells me about them automatically idk<p>GitHub tells you about <i>published CVEs</i> which represent a small fraction of actual patched security vulnerabilities in the wild, which typically never get a CVE.</div><br/></div></div><div id="42045323" class="c"><input type="checkbox" id="c-42045323" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#42044645">parent</a><span>|</span><a href="#42045341">prev</a><span>|</span><a href="#42045344">next</a><span>|</span><label class="collapse" for="c-42045323">[-]</label><label class="expand" for="c-42045323">[1 more]</label></div><br/><div class="children"><div class="content">You can run govulncheck as part of your CI pipeline too</div><br/></div></div><div id="42045344" class="c"><input type="checkbox" id="c-42045344" checked=""/><div class="controls bullet"><span class="by">dakiol</span><span>|</span><a href="#42044645">parent</a><span>|</span><a href="#42045323">prev</a><span>|</span><a href="#42046210">next</a><span>|</span><label class="collapse" for="c-42045344">[-]</label><label class="expand" for="c-42045344">[2 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t get it. Is it because your Go app relies in fewer dependencies? If so, it&#x27;s just a matter of numbers I believe. JS apps tend to rely on more dependencies on average... but that doesn&#x27;t need to be that way. I have plain JS apps that still work like the first day (even better than Go apps, since there&#x27;s no compilation step involved).<p>TypeScript apps on the other hand, yeah, they tend to be more fragile (at least from my perspective: the tsc package has dozen of dependencies, so anything can go wrong)</div><br/><div id="42045644" class="c"><input type="checkbox" id="c-42045644" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#42044645">root</a><span>|</span><a href="#42045344">parent</a><span>|</span><a href="#42046210">next</a><span>|</span><label class="collapse" for="c-42045644">[-]</label><label class="expand" for="c-42045644">[1 more]</label></div><br/><div class="children"><div class="content">You can do that in practically any language however that doesn’t mean it’s easy nor the norm.<p>JavaScript has a culture of move fast and break things. Whereas Go has a culture of moving slow and backwards compatibility.<p>It also helps that Go has a pretty extensive stdlibs whereas JavaScript is really more like several distinct language ecosystems wrapped around a common specification. So what works on one JavaScript runtime might not even work on another.</div><br/></div></div></div></div><div id="42046210" class="c"><input type="checkbox" id="c-42046210" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#42044645">parent</a><span>|</span><a href="#42045344">prev</a><span>|</span><a href="#42047259">next</a><span>|</span><label class="collapse" for="c-42046210">[-]</label><label class="expand" for="c-42046210">[1 more]</label></div><br/><div class="children"><div class="content">If JS apps are the standard you measure against you&#x27;ll be happy with most things.</div><br/></div></div></div></div><div id="42045604" class="c"><input type="checkbox" id="c-42045604" checked=""/><div class="controls bullet"><span class="by">K0nserv</span><span>|</span><a href="#42044645">prev</a><span>|</span><a href="#42045369">next</a><span>|</span><label class="collapse" for="c-42045604">[-]</label><label class="expand" for="c-42045604">[51 more]</label></div><br/><div class="children"><div class="content">Somewhat related, I learned a surprising fact recently: Go is not actually memory safe. In particular because atomicity is only guaranteed for word size values, double word values(interface pointers, slices) can introduce memory unsafety in the presence of concurrency[0].<p>It&#x27;s one of those things that feels obvious when you see it.<p>0: <a href="https:&#x2F;&#x2F;blog.stalkr.net&#x2F;2015&#x2F;04&#x2F;golang-data-races-to-break-memory-safety.html" rel="nofollow">https:&#x2F;&#x2F;blog.stalkr.net&#x2F;2015&#x2F;04&#x2F;golang-data-races-to-break-m...</a></div><br/><div id="42045906" class="c"><input type="checkbox" id="c-42045906" checked=""/><div class="controls bullet"><span class="by">atomic128</span><span>|</span><a href="#42045604">parent</a><span>|</span><a href="#42046045">next</a><span>|</span><label class="collapse" for="c-42045906">[-]</label><label class="expand" for="c-42045906">[21 more]</label></div><br/><div class="children"><div class="content">Here is code to circumvent Go&#x27;s memory safety without importing unsafe.<p>get() reads a byte at an arbitrary address and set() writes a byte at an arbitrary address.<p>This is excerpted from BUGFIX 66 (&quot;Hack This Site&quot;):<p><pre><code>  func racer() {
      var (
          ptr1 *uintptr
          ptr2 *byte
          race any
          done = make(chan struct{})
      )
      put := func(x any) {
          for {
              select {
              case &lt;-done:
                  return
              default:
                  race = x
              }
          }
      }
      go put(ptr1)
      go put(&amp;ptr2)
      for {
          var ok bool
          ptr1, ok = race.(*uintptr)
          if ok &amp;&amp; ptr1 != nil {
              close(done)
              break
          }
      }
      get := func(addr uintptr) byte {
          *ptr1 = addr
          return *ptr2
      }
      set := func(addr uintptr, to byte) {
          *ptr1 = addr
          *ptr2 = to
      }
      if get(0xdeadbeef) == 111 {
          set(0xbaaaaaad, 222)
      }
  }</code></pre></div><br/><div id="42045918" class="c"><input type="checkbox" id="c-42045918" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42045906">parent</a><span>|</span><a href="#42046045">next</a><span>|</span><label class="collapse" for="c-42045918">[-]</label><label class="expand" for="c-42045918">[20 more]</label></div><br/><div class="children"><div class="content">&quot;Without importing unsafe&quot; is doing a lot of work for examples like this.</div><br/><div id="42045970" class="c"><input type="checkbox" id="c-42045970" checked=""/><div class="controls bullet"><span class="by">atomic128</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42045918">parent</a><span>|</span><a href="#42046045">next</a><span>|</span><label class="collapse" for="c-42045970">[-]</label><label class="expand" for="c-42045970">[19 more]</label></div><br/><div class="children"><div class="content">This comes from a webpage where the challenge is to compromise the site, despite the fact that Go imports are disallowed (including unsafe). It&#x27;s a puzzle game.<p>To clarify, I think Go is magnificent and I use it for everything. The racer() code is just a curiosity.</div><br/><div id="42046050" class="c"><input type="checkbox" id="c-42046050" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42045970">parent</a><span>|</span><a href="#42046045">next</a><span>|</span><label class="collapse" for="c-42046050">[-]</label><label class="expand" for="c-42046050">[18 more]</label></div><br/><div class="children"><div class="content">Right, it&#x27;s a cool trick. It&#x27;s just not material to real threat models, which is what people imply when they say &quot;Go isn&#x27;t memory safe&quot;.</div><br/><div id="42046429" class="c"><input type="checkbox" id="c-42046429" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046050">parent</a><span>|</span><a href="#42046699">next</a><span>|</span><label class="collapse" for="c-42046429">[-]</label><label class="expand" for="c-42046429">[14 more]</label></div><br/><div class="children"><div class="content">The fact Go has UB under data races has practical implications for sufficiently complex concurrent software. If you can induce a race on a non-trivial object, that&#x27;s UB instantly - you can probably blow up the Go runtime and all bets are off.<p>I would not characterise this fact, which is a design choice in Go, as similar to say a Rust soundness bug, which will sooner or later just get fixed. They aren&#x27;t going to somehow magically fix this problem in Go, it&#x27;s part of the design.</div><br/><div id="42046966" class="c"><input type="checkbox" id="c-42046966" checked=""/><div class="controls bullet"><span class="by">adonovan</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046429">parent</a><span>|</span><a href="#42046461">next</a><span>|</span><label class="collapse" for="c-42046966">[-]</label><label class="expand" for="c-42046966">[3 more]</label></div><br/><div class="children"><div class="content">&gt; They aren&#x27;t going to somehow magically fix this problem in Go, it&#x27;s part of the design.<p>I wouldn&#x27;t be entirely pessimistic.<p>Russ&#x27;s post <a href="https:&#x2F;&#x2F;research.swtch.com&#x2F;gorace" rel="nofollow">https:&#x2F;&#x2F;research.swtch.com&#x2F;gorace</a> mentions a conservative representation for Go&#x27;s data structures (essentially: more indirection) that would make it possible to implement them in a way that was robust to races, at an obvious large performance cost.<p>More recently others have been investigating the possibility of using 128-bit atomic writes (on ARM and x86) to reduce the cost. Go&#x27;s strings and interfaces are both 2-word structures. Slices are three words but by changing the field order atomicity can be achieved with 2-word writes. Of course it would break a lot of code that assumes the representation or the ABI.</div><br/><div id="42047131" class="c"><input type="checkbox" id="c-42047131" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046966">parent</a><span>|</span><a href="#42049565">next</a><span>|</span><label class="collapse" for="c-42047131">[-]</label><label class="expand" for="c-42047131">[1 more]</label></div><br/><div class="children"><div class="content">That code is usually internal.</div><br/></div></div><div id="42049565" class="c"><input type="checkbox" id="c-42049565" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046966">parent</a><span>|</span><a href="#42047131">prev</a><span>|</span><a href="#42046461">next</a><span>|</span><label class="collapse" for="c-42049565">[-]</label><label class="expand" for="c-42049565">[1 more]</label></div><br/><div class="children"><div class="content">I mean, C is also memory safe when run within valgrind.. at an obvious large performance cost.</div><br/></div></div></div></div><div id="42046461" class="c"><input type="checkbox" id="c-42046461" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046429">parent</a><span>|</span><a href="#42046966">prev</a><span>|</span><a href="#42046702">next</a><span>|</span><label class="collapse" for="c-42046461">[-]</label><label class="expand" for="c-42046461">[5 more]</label></div><br/><div class="children"><div class="content">My point has nothing to do with whether the language will achieve &quot;soundness&quot;. It&#x27;s that this is behavior that has not over the last 15 years produced exploitable vulnerabilities, despite extremely high incentives for those vulnerabilities to be unearthed.</div><br/><div id="42046619" class="c"><input type="checkbox" id="c-42046619" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046461">parent</a><span>|</span><a href="#42046702">next</a><span>|</span><label class="collapse" for="c-42046619">[-]</label><label class="expand" for="c-42046619">[4 more]</label></div><br/><div class="children"><div class="content">You don’t need to blow up the runtime to cause a vulnerability due to a data race in Go:<p><a href="https:&#x2F;&#x2F;security.snyk.io&#x2F;vuln&#x2F;SNYK-DEBIAN13-GOLANGGITHUBGORESTYRESTY-6095006" rel="nofollow">https:&#x2F;&#x2F;security.snyk.io&#x2F;vuln&#x2F;SNYK-DEBIAN13-GOLANGGITHUBGORE...</a></div><br/><div id="42046676" class="c"><input type="checkbox" id="c-42046676" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046619">parent</a><span>|</span><a href="#42046702">next</a><span>|</span><label class="collapse" for="c-42046676">[-]</label><label class="expand" for="c-42046676">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a completely different type of vulnerability than the UB that&#x27;s being talked about.<p>&gt; The call to sync.Pool.Get will then return a bytes.Buffer that hasn&#x27;t had bytes.Buffer.Reset called on it.  This dirty buffer will contain the HTTP request body from an unrelated request.<p>This is just a good ol&#x27; logic error, that just so happens to also be a race.</div><br/><div id="42047551" class="c"><input type="checkbox" id="c-42047551" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046676">parent</a><span>|</span><a href="#42046702">next</a><span>|</span><label class="collapse" for="c-42047551">[-]</label><label class="expand" for="c-42047551">[2 more]</label></div><br/><div class="children"><div class="content">These type of UB bugs in Go are a bit of a red herring, since most race conditions arise from improper use of shared mutability, and would still be a problem even in the presence of full memory safety, for instance:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;37669">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;37669</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;48340">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;48340</a><p>These types of race conditions cannot happen in Rust. Not because Rust does not have UB, but because Rust does not allow multiple writable pointers (&quot;mutable borrows&quot;) to the same memory region. If you want shared AND mutable access to memory, you must use a thread-safe construct such as Mutex or Cell — or drop into unsafe code.<p>Rust does not prevent all types of errors of course. Dirty buffer reuse (as in the GP example) is still possible in Rust. You could still have situations where a buffer is returned to a pool without resetting it. But this could only be a pure logic error where you&#x27;ve forgot to reset the buffer and it would occur <i>consistently</i> and thus would be easy to reproduce and debug. In addition, with idiomatic Rust, you could enforce proper buffer cleanup in Rust by wrapping the Buffer with a type that implements Drop.<p>More specifically, the vulnerability mentioned in GP is not possible in Rust. The description is a bit misleading, but the issue was not that the buffer was returned to the pool without being reset, but rather that the same buffer was returned to the pool TWICE under certain conditions, due to a data race. This is not possible in Rust. You cannot put the same owned buffer twice in a pool, due to Rust&#x27;s move semantics (affine types). And if we want to be completely honest, you&#x27;d probably won&#x27;t need to pool buffers in Rust to begin with, since you don&#x27;t need to avoid garbage collection (there is none). In most cases, malloc is going to work good enough as your &quot;pool&quot;.<p>We have a serious problem as an industry, where there is a popular conception of memory safety and type safety as a binary property: a language is either safe or unsafe, either sound or unsound. But it&#x27;s more of a spectrum, and not even a contiguous one at that. This comments thread is split between people who say that large size atomicity UB is not a major issue in practice and people willing to completely rule off Go&#x27;s memory safety based on that. But we could just say Go sits near the safe end of the spectrum of memory safety — it certainly does far better than C. My security concerns with Go, after nearly 9 years of using are mostly about race conditions, memory leaks and lack of better mechanisms to enforce type safety (such as sum types and affine types).</div><br/><div id="42047774" class="c"><input type="checkbox" id="c-42047774" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42047551">parent</a><span>|</span><a href="#42046702">next</a><span>|</span><label class="collapse" for="c-42047774">[-]</label><label class="expand" for="c-42047774">[1 more]</label></div><br/><div class="children"><div class="content">Given the total lack of empirical evidence (that is: language-specific vulnerabilities in the myriad large high-profile Go projects run all over the Internet; instances of bug classes not found in other mainstream memory-safe languages --- &quot;memory-safe&quot; here just to factor C&#x2F;C++ out of that set) for those security concerns, why do you prioritize them?<p>We of course continue to find SQLI, authz, SSRF, metacharacter parsing and cryptography vulnerabilities in Go codebases, the same way we do in literally every general-purpose programming language; what the the vulnerabilities we actually see, over 15 years of explosive growth in use, that are distinctive to Go? It&#x27;s been 4 years since I was a full-time software security person, but I keep up, and did a lot of work in Go before then, and I&#x27;m not aware of anything beyond &quot;if you skip the ,ok on a type conversion you might panic something&quot;.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42046702" class="c"><input type="checkbox" id="c-42046702" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046429">parent</a><span>|</span><a href="#42046461">prev</a><span>|</span><a href="#42046699">next</a><span>|</span><label class="collapse" for="c-42046702">[-]</label><label class="expand" for="c-42046702">[5 more]</label></div><br/><div class="children"><div class="content">I think these are &quot;if a tree falls in a forest and no one is around to hear it, does it make a sound?&quot;-type musings.<p>Whatever the case, it doesn&#x27;t really affect anyone and it doesn&#x27;t really matter.</div><br/><div id="42046924" class="c"><input type="checkbox" id="c-42046924" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046702">parent</a><span>|</span><a href="#42046699">next</a><span>|</span><label class="collapse" for="c-42046924">[-]</label><label class="expand" for="c-42046924">[4 more]</label></div><br/><div class="children"><div class="content">It’s a matter of time. Spectre &#x2F; meltdown were also considered extremely hard to use in practice. Yet they are considered vulnerabilities.<p>In Golang case the data race window to corrupt memory is extremely narrow, so it makes it very hard to trigger it. That together with Go being still quite a niche language results in the fact we see no exploits… yet.</div><br/><div id="42048589" class="c"><input type="checkbox" id="c-42048589" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046924">parent</a><span>|</span><a href="#42046991">next</a><span>|</span><label class="collapse" for="c-42048589">[-]</label><label class="expand" for="c-42048589">[1 more]</label></div><br/><div class="children"><div class="content">I note that of the Spectre&#x2F;Meltdown and similar hardware vulns, even the hard-to-swallow kinds of mitigations for Spectre primarily prevent user-to-kernel hijacking only, which is the most important single property but doesn&#x27;t cover inter-process hijacking. We can more or less patch these vulns completely, but there is a (huge) performance penalty to be weighed as a drawback. I do not know enough to say whether the Go data race bugs are an acceptable risk. Although, not everyone may accept it, namely if it strikes them just once.</div><br/></div></div><div id="42046991" class="c"><input type="checkbox" id="c-42046991" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046924">parent</a><span>|</span><a href="#42048589">prev</a><span>|</span><a href="#42046699">next</a><span>|</span><label class="collapse" for="c-42046991">[-]</label><label class="expand" for="c-42046991">[2 more]</label></div><br/><div class="children"><div class="content">Even if some sort of security bug is discovered tomorrow, then we&#x27;re talking about one issue every 15 years or so. Whoop die doo. That barely even registers in the noise.<p>That it &quot;may&quot; lead to a problem and that it&#x27;s not &quot;sound&quot; is basically just meaningless.</div><br/><div id="42049150" class="c"><input type="checkbox" id="c-42049150" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046991">parent</a><span>|</span><a href="#42046699">next</a><span>|</span><label class="collapse" for="c-42049150">[-]</label><label class="expand" for="c-42049150">[1 more]</label></div><br/><div class="children"><div class="content">How many spectre &#x2F; meltdown related vulnerabilities were detected between 1990 and 2010? Zero. So those chip vendors must be paranoid they patch them - were talking about one issue per 20 years xD Similarly how many hashmap collision attacks existed prior to 2010? Zero, but once people learned they are not just a theoretical problem, suddenly plenty of vulnerabilities were found.<p>Seriously, it doesn’t work like that. It’s not linear. During the first half of those 15 years almost no one heard about Go, and forget about using it in critical systems where vulnerabilities would matter. Even at Google it was (still is?) very niche compared to Java, Python and C++ and is used mostly for userspace clis and orchestration, not the core stuff. There is simply very little incentive to attack systems written Go, when there exist 100x more less secure networked systems written in C or C++.<p>Considering this memory unsafety thing in Go is fortunately very hard to exploit, there is no doubt why attackers don’t target this weakness and it has been so far only a technical curiosity. Also data races in Go are easy to make and can lead to vulnerabilities in a much more direct way, without corrupting the heap. I bet those are exploited first (and there exist CVEs caused by races in Go).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42046699" class="c"><input type="checkbox" id="c-42046699" checked=""/><div class="controls bullet"><span class="by">Yoric</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046050">parent</a><span>|</span><a href="#42046429">prev</a><span>|</span><a href="#42046065">next</a><span>|</span><label class="collapse" for="c-42046699">[-]</label><label class="expand" for="c-42046699">[1 more]</label></div><br/><div class="children"><div class="content">Well, time will tell. As Go usage increases, it becomes a more tempting target, which means that more malicious third-parties will start poring over the code of the std library and the frameworks looking exactly for this kind of vulnerability.<p>The same goes for Rust, Swift or Zig, of course.</div><br/></div></div><div id="42046065" class="c"><input type="checkbox" id="c-42046065" checked=""/><div class="controls bullet"><span class="by">atomic128</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046050">parent</a><span>|</span><a href="#42046699">prev</a><span>|</span><a href="#42046817">next</a><span>|</span><label class="collapse" for="c-42046065">[-]</label><label class="expand" for="c-42046065">[1 more]</label></div><br/><div class="children"><div class="content">I agree.</div><br/></div></div><div id="42046817" class="c"><input type="checkbox" id="c-42046817" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046050">parent</a><span>|</span><a href="#42046065">prev</a><span>|</span><a href="#42046045">next</a><span>|</span><label class="collapse" for="c-42046817">[-]</label><label class="expand" for="c-42046817">[1 more]</label></div><br/><div class="children"><div class="content">How is it not material? You only need to accidentally write and read a map at the same time in language that is supposedly for concurrency (which is why not the same as parallelism, in its case it does largely correlate).<p>This is a ridiculous design issue with big ramifications.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42046045" class="c"><input type="checkbox" id="c-42046045" checked=""/><div class="controls bullet"><span class="by">ronsor</span><span>|</span><a href="#42045604">parent</a><span>|</span><a href="#42045906">prev</a><span>|</span><a href="#42045903">next</a><span>|</span><label class="collapse" for="c-42046045">[-]</label><label class="expand" for="c-42046045">[14 more]</label></div><br/><div class="children"><div class="content">You shouldn&#x27;t be modifying any variable concurrently without a mutex. The only exception to this is if the variable is (1) less than or equal to the CPU word size; (2) is at a CPU word size aligned address; and (3) atomic memory access functions are used to read and write the variable.</div><br/><div id="42046568" class="c"><input type="checkbox" id="c-42046568" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046045">parent</a><span>|</span><a href="#42046126">next</a><span>|</span><label class="collapse" for="c-42046568">[-]</label><label class="expand" for="c-42046568">[3 more]</label></div><br/><div class="children"><div class="content">Even when a value satisfies these architecture-dependent requirements, the language still does not guarantee atomicity of concurrent reads&#x2F;writes, and programs which rely on that assumption are buggy.</div><br/><div id="42046729" class="c"><input type="checkbox" id="c-42046729" checked=""/><div class="controls bullet"><span class="by">Yoric</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046568">parent</a><span>|</span><a href="#42046866">next</a><span>|</span><label class="collapse" for="c-42046729">[-]</label><label class="expand" for="c-42046729">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t this part of the Go memory model (<a href="https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;mem" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;mem</a>)?</div><br/></div></div><div id="42046866" class="c"><input type="checkbox" id="c-42046866" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046568">parent</a><span>|</span><a href="#42046729">prev</a><span>|</span><a href="#42046126">next</a><span>|</span><label class="collapse" for="c-42046866">[-]</label><label class="expand" for="c-42046866">[1 more]</label></div><br/><div class="children"><div class="content">Logic bugs != memory safety bugs.<p>E.g. in java you can mess up your logic with data races, but the racing itself is safe and can never cause the VM to enter an invalid state.</div><br/></div></div></div></div><div id="42046126" class="c"><input type="checkbox" id="c-42046126" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046045">parent</a><span>|</span><a href="#42046568">prev</a><span>|</span><a href="#42045903">next</a><span>|</span><label class="collapse" for="c-42046126">[-]</label><label class="expand" for="c-42046126">[10 more]</label></div><br/><div class="children"><div class="content">Memory safety as long as you don&#x27;t violate certain rules is what C and C++ also have. The problem is that programmers make mistakes because we&#x27;re all human.</div><br/><div id="42046294" class="c"><input type="checkbox" id="c-42046294" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046126">parent</a><span>|</span><a href="#42046519">next</a><span>|</span><label class="collapse" for="c-42046294">[-]</label><label class="expand" for="c-42046294">[7 more]</label></div><br/><div class="children"><div class="content">No, the &quot;mistakes&quot; we talk about with C&#x2F;C++ are so common that it&#x27;s hard to think of a major C&#x2F;C++ project not to have them, and the &quot;mistakes&quot; we&#x27;re talking about with Go or &quot;unsafe&quot; Rust are contrivances built to demonstrate things an actively malicious programmer could do. Equating the two is, obviously, a sleight of hand.</div><br/><div id="42046496" class="c"><input type="checkbox" id="c-42046496" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046294">parent</a><span>|</span><a href="#42046875">next</a><span>|</span><label class="collapse" for="c-42046496">[-]</label><label class="expand" for="c-42046496">[2 more]</label></div><br/><div class="children"><div class="content">To add to this: the built in go race detector is very good at catching data races. It’s a runtime, but I’ve never had a race that couldn’t be reproduced in the race detector trivially.<p>But yes, in theory Go has a memory safety problem because of it. In practice though, it’s that people don’t use the race detector, which is ridiculously easy to do.</div><br/><div id="42046559" class="c"><input type="checkbox" id="c-42046559" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046496">parent</a><span>|</span><a href="#42046875">next</a><span>|</span><label class="collapse" for="c-42046559">[-]</label><label class="expand" for="c-42046559">[1 more]</label></div><br/><div class="children"><div class="content">Ordinary non-race-checked Go code is memory-safe in the sense that we mean it in the field of software security.</div><br/></div></div></div></div><div id="42046875" class="c"><input type="checkbox" id="c-42046875" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046294">parent</a><span>|</span><a href="#42046496">prev</a><span>|</span><a href="#42046519">next</a><span>|</span><label class="collapse" for="c-42046875">[-]</label><label class="expand" for="c-42046875">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s only on Go, leave Rust out of it. Rust&#x27;s safe part is entirely memory safe. Unsafe is the escape hatch, which pretty much every language has in the form of FFI.</div><br/><div id="42047747" class="c"><input type="checkbox" id="c-42047747" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046875">parent</a><span>|</span><a href="#42046519">next</a><span>|</span><label class="collapse" for="c-42047747">[-]</label><label class="expand" for="c-42047747">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not true: idiomatic Rust projects use `unsafe` much more liberally than other languages use FFI, because of shared xor mutable. That&#x27;s not a knock on Rust. I couldn&#x27;t be less interested in Rust vs. Go; I use both and would use them both in different situations.</div><br/><div id="42048557" class="c"><input type="checkbox" id="c-42048557" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42047747">parent</a><span>|</span><a href="#42046519">next</a><span>|</span><label class="collapse" for="c-42048557">[-]</label><label class="expand" for="c-42048557">[2 more]</label></div><br/><div class="children"><div class="content">I doubt that &quot;idiomatic Rust projects use unsafe liberally&quot;. It is a more liberal construct, perhaps, but IMO actual usage is usually reasonable. Unless you mean the standard libary&#x27;s use of unsafe?</div><br/><div id="42048664" class="c"><input type="checkbox" id="c-42048664" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42048557">parent</a><span>|</span><a href="#42046519">next</a><span>|</span><label class="collapse" for="c-42048664">[-]</label><label class="expand" for="c-42048664">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not saying it isn&#x27;t reasonable, just that it serves a different role in Rust than unsafe&#x2F;JNI would in Java: there are things you naturally want to express in Rust, not having anything directly to do with interfacing with external code, that want `unsafe` in order to (carefully) bypass shared xor mutable.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42046519" class="c"><input type="checkbox" id="c-42046519" checked=""/><div class="controls bullet"><span class="by">throwaway894345</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046126">parent</a><span>|</span><a href="#42046294">prev</a><span>|</span><a href="#42045903">next</a><span>|</span><label class="collapse" for="c-42046519">[-]</label><label class="expand" for="c-42046519">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Memory safety as long as you don&#x27;t violate certain rules is what C and C++ also have<p>There are numbers between 0% and 100%, thus it&#x27;s possible that Go can be less than 100% memory safe <i>and</i> still far safer than C or C++.</div><br/><div id="42046555" class="c"><input type="checkbox" id="c-42046555" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046519">parent</a><span>|</span><a href="#42045903">next</a><span>|</span><label class="collapse" for="c-42046555">[-]</label><label class="expand" for="c-42046555">[1 more]</label></div><br/><div class="children"><div class="content">&quot;100% memory safe&quot; is mostly not a thing; it&#x27;s not a concept that gets quantified this way. The closest thing I think you get to a compromised notion of safety that&#x27;s actually noteworthy is Zig&#x27;s allocator behavior (which can in ordinary code theoretically still produce UAF bugs, and UAF bugs --- lifecycle bugs more generally --- are the most pernicious kind of memory safety vulnerability). Most practitioners would still call Zig &quot;memory safe&quot;. You can see how much bigger a deal that behavior is than the one we&#x27;re talking about.<p>I think the basic takeaway here is not to tie yourself up in nots trying to quantify memory safety. There&#x27;s a reason Prossimo calls Go memory safe (not &quot;mostly memory safe&quot;), along with Rust, C#, Java, Swift, Python, and JavaScript. Ordinary code written in any of these languages is just not going to have exploitable memory corruption vulnerabilities. Other vulnerabilities, yes!</div><br/></div></div></div></div></div></div></div></div><div id="42045903" class="c"><input type="checkbox" id="c-42045903" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42045604">parent</a><span>|</span><a href="#42046045">prev</a><span>|</span><a href="#42046650">next</a><span>|</span><label class="collapse" for="c-42045903">[-]</label><label class="expand" for="c-42045903">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s easy to demonstrate contrived abuses of Go concurrency that break memory safety, but despite the enormous popularity of the language, actual shipping vulnerabilities --- <i>mistakes</i> in concurrency, not deliberately-engineered pathological cases, that yield attacker-controlled control over memory --- are basically nonexistent (I can&#x27;t think of a single one; there must be one somewhere!).<p>Basically this is about as credible an argument as claiming that Rust isn&#x27;t memory safe because its libraries have so much `unsafe` code. And that claim: not super credible.<p>Basically, the takeaway in both cases is that it&#x27;s not safe to allow an attacker to <i>write code for you</i> in the language. But everybody assumes that&#x27;s the case anyways, because it&#x27;s the case with virtually every other language (with one very notable, fraught, and well-understood exception), too.</div><br/><div id="42046273" class="c"><input type="checkbox" id="c-42046273" checked=""/><div class="controls bullet"><span class="by">ViewTrick1002</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42045903">parent</a><span>|</span><a href="#42046238">next</a><span>|</span><label class="collapse" for="c-42046273">[-]</label><label class="expand" for="c-42046273">[2 more]</label></div><br/><div class="children"><div class="content">Instead there’s a whole host of subtle footguns which while not leading to true memory unsafety will lead to complete junk data.<p><a href="https:&#x2F;&#x2F;www.uber.com&#x2F;en-SE&#x2F;blog&#x2F;data-race-patterns-in-go&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.uber.com&#x2F;en-SE&#x2F;blog&#x2F;data-race-patterns-in-go&#x2F;</a></div><br/><div id="42046285" class="c"><input type="checkbox" id="c-42046285" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046273">parent</a><span>|</span><a href="#42046238">next</a><span>|</span><label class="collapse" for="c-42046285">[-]</label><label class="expand" for="c-42046285">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t care to litigate program correctness and ergonomics. Those are extremely subjective, and I don&#x27;t feel like I ever get anywhere useful in those kinds of conversations. The most popular backend programming language in the industry is almost certainly Python, and it barely even has types. I still wouldn&#x27;t dunk on it.<p>This thread is about a much narrower question, which is code security. There, I feel like I&#x27;m on much firmer ground drawing and defending conclusions, and my conclusion is that there isn&#x27;t a mainstream general-purpose modern language that is meaningfully more secure than Go (or than Rust, or than Python, etc).</div><br/></div></div></div></div><div id="42046238" class="c"><input type="checkbox" id="c-42046238" checked=""/><div class="controls bullet"><span class="by">shitter</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42045903">parent</a><span>|</span><a href="#42046273">prev</a><span>|</span><a href="#42046650">next</a><span>|</span><label class="collapse" for="c-42046238">[-]</label><label class="expand" for="c-42046238">[3 more]</label></div><br/><div class="children"><div class="content">What is that exception?</div><br/><div id="42046272" class="c"><input type="checkbox" id="c-42046272" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046238">parent</a><span>|</span><a href="#42046650">next</a><span>|</span><label class="collapse" for="c-42046272">[-]</label><label class="expand" for="c-42046272">[2 more]</label></div><br/><div class="children"><div class="content">Browser Javascript.</div><br/><div id="42046597" class="c"><input type="checkbox" id="c-42046597" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046272">parent</a><span>|</span><a href="#42046650">next</a><span>|</span><label class="collapse" for="c-42046597">[-]</label><label class="expand" for="c-42046597">[1 more]</label></div><br/><div class="children"><div class="content">Also embeddable scripting languages like Lua</div><br/></div></div></div></div></div></div></div></div><div id="42046650" class="c"><input type="checkbox" id="c-42046650" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#42045604">parent</a><span>|</span><a href="#42045903">prev</a><span>|</span><a href="#42046985">next</a><span>|</span><label class="collapse" for="c-42046650">[-]</label><label class="expand" for="c-42046650">[5 more]</label></div><br/><div class="children"><div class="content">Go is memory safe by modern standard.<p>If I show you a UB in Rust without the use of unsafe does it means Rust is unsafe?</div><br/><div id="42046751" class="c"><input type="checkbox" id="c-42046751" checked=""/><div class="controls bullet"><span class="by">K0nserv</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046650">parent</a><span>|</span><a href="#42046704">next</a><span>|</span><label class="collapse" for="c-42046751">[-]</label><label class="expand" for="c-42046751">[1 more]</label></div><br/><div class="children"><div class="content">I believe UB without unsafe is considered a bug by the Rust language team.<p>I should’ve said in my original comment, but I don’t mean to dunk on Go. In practice the issues illustrated in the blog post I linked seem unlikely to cause problems in practice, they are interesting nevertheless.</div><br/></div></div><div id="42046704" class="c"><input type="checkbox" id="c-42046704" checked=""/><div class="controls bullet"><span class="by">Yoric</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046650">parent</a><span>|</span><a href="#42046751">prev</a><span>|</span><a href="#42046854">next</a><span>|</span><label class="collapse" for="c-42046704">[-]</label><label class="expand" for="c-42046704">[1 more]</label></div><br/><div class="children"><div class="content">What does that mean?<p>If I follow correctly, assuming that there are no bugs in the compilers&#x2F;interpreters, Go is less memory-safe than Java, C#, Python (with GIL), JavaScript or Rust. The only languages that are less memory safe would be C, C++ or Zig.</div><br/></div></div><div id="42046854" class="c"><input type="checkbox" id="c-42046854" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046650">parent</a><span>|</span><a href="#42046704">prev</a><span>|</span><a href="#42046985">next</a><span>|</span><label class="collapse" for="c-42046854">[-]</label><label class="expand" for="c-42046854">[2 more]</label></div><br/><div class="children"><div class="content">That would mean it, yes. And yeah there is a bug in rust&#x27;s borrow checker which can trigger something like that for some very special, &quot;no human will ever write code like that&quot; case. But this is an implementation detail for a semantically memory safe language, while in go&#x27;s case having UB is a language primitive here.</div><br/><div id="42046933" class="c"><input type="checkbox" id="c-42046933" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#42045604">root</a><span>|</span><a href="#42046854">parent</a><span>|</span><a href="#42046985">next</a><span>|</span><label class="collapse" for="c-42046933">[-]</label><label class="expand" for="c-42046933">[1 more]</label></div><br/><div class="children"><div class="content">The trigger for Go is exactly &quot;no human will ever write code like that&quot;.</div><br/></div></div></div></div></div></div><div id="42046985" class="c"><input type="checkbox" id="c-42046985" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#42045604">parent</a><span>|</span><a href="#42046650">prev</a><span>|</span><a href="#42046342">next</a><span>|</span><label class="collapse" for="c-42046985">[-]</label><label class="expand" for="c-42046985">[1 more]</label></div><br/><div class="children"><div class="content">This is also true of most other &quot;safe&quot; languages.</div><br/></div></div></div></div><div id="42045369" class="c"><input type="checkbox" id="c-42045369" checked=""/><div class="controls bullet"><span class="by">dakiol</span><span>|</span><a href="#42045604">prev</a><span>|</span><a href="#42045712">next</a><span>|</span><label class="collapse" for="c-42045369">[-]</label><label class="expand" for="c-42045369">[12 more]</label></div><br/><div class="children"><div class="content">Go is nice, but the recent trend of using generics for many stuff is making harder and harder to keep Go code readable imho. See an example here <a href="https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2024&#x2F;ranging-over-functions-in-go-123&#x2F;" rel="nofollow">https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2024&#x2F;ranging-over-functions-in...</a><p>I&#x27;m not saying it&#x27;s hard to read, but it&#x27;s harder than previous Go code that used little or no generics at all.</div><br/><div id="42045690" class="c"><input type="checkbox" id="c-42045690" checked=""/><div class="controls bullet"><span class="by">timmytokyo</span><span>|</span><a href="#42045369">parent</a><span>|</span><a href="#42045696">next</a><span>|</span><label class="collapse" for="c-42045690">[-]</label><label class="expand" for="c-42045690">[3 more]</label></div><br/><div class="children"><div class="content">Your example of go code that&#x27;s harder to read is iterators, and I agree with you. There&#x27;s no denying that code like this places a high cognitive load on the reader:<p><pre><code>  func (al *AssocList[K, V]) All() iter.Seq2[K, V] {
    return func(yield func(K, V) bool) {
      for _, p := range al.lst {
        if !yield(p.key, p.value) {
          return
        }
      }
    }
  }
</code></pre>
But the code that actually <i>uses</i> iterators is in my opinion more readable than its non-generic counterpart. So it&#x27;s really a question of how often you&#x27;re expected to write (or read) iterators. And I don&#x27;t expect that most programmers will be writing (or reading) iterators that often.</div><br/><div id="42046881" class="c"><input type="checkbox" id="c-42046881" checked=""/><div class="controls bullet"><span class="by">timmytokyo</span><span>|</span><a href="#42045369">root</a><span>|</span><a href="#42045690">parent</a><span>|</span><a href="#42046626">next</a><span>|</span><label class="collapse" for="c-42046881">[-]</label><label class="expand" for="c-42046881">[1 more]</label></div><br/><div class="children"><div class="content">On further reflection, I think what makes this example particularly difficult to understand is not so much its use of generics, but the way it uses functions.  It&#x27;s a function that returns a function that takes another function as an argument. The generic [K,V] type arguments are actually pretty straightforward.</div><br/></div></div><div id="42046626" class="c"><input type="checkbox" id="c-42046626" checked=""/><div class="controls bullet"><span class="by">chamomeal</span><span>|</span><a href="#42045369">root</a><span>|</span><a href="#42045690">parent</a><span>|</span><a href="#42046881">prev</a><span>|</span><a href="#42045696">next</a><span>|</span><label class="collapse" for="c-42046626">[-]</label><label class="expand" for="c-42046626">[1 more]</label></div><br/><div class="children"><div class="content">I often feel this way about heavy use of typescript generics. The more you lean into the crazy (and awesome) world of generics, the more inscrutable the code becomes to anybody who isn’t a generics wiz. It’s really like an extra language stacked on top of JS. I’ll come back to code I wrote a year ago, and it’ll take me a full day to figure out the types.<p>But the simplicity of using a library or set of functions that have really nice generics? So awesome. The intellisense and type errors alone can almost be a decent form of documentation.<p>The source becomes hard and weird to change, but the end result is a very nice DX</div><br/></div></div></div></div><div id="42045696" class="c"><input type="checkbox" id="c-42045696" checked=""/><div class="controls bullet"><span class="by">Arainach</span><span>|</span><a href="#42045369">parent</a><span>|</span><a href="#42045690">prev</a><span>|</span><a href="#42045641">next</a><span>|</span><label class="collapse" for="c-42045696">[-]</label><label class="expand" for="c-42045696">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious about your objection to the proposal. Sure, generics mean that libraries need a bit more syntax - that&#x27;s true in all languages - but the actual consumption of the AssociationList type here is clean and readable.<p>Most types don&#x27;t need to be generics. Containers do, and I prefer a bit of generics syntax to copy&#x2F;pasting the container ten times for ten types.</div><br/></div></div><div id="42045641" class="c"><input type="checkbox" id="c-42045641" checked=""/><div class="controls bullet"><span class="by">mervz</span><span>|</span><a href="#42045369">parent</a><span>|</span><a href="#42045696">prev</a><span>|</span><a href="#42045704">next</a><span>|</span><label class="collapse" for="c-42045641">[-]</label><label class="expand" for="c-42045641">[3 more]</label></div><br/><div class="children"><div class="content">Meanwhile, error handling still can&#x27;t get any sort of syntactic sugar</div><br/><div id="42048099" class="c"><input type="checkbox" id="c-42048099" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#42045369">root</a><span>|</span><a href="#42045641">parent</a><span>|</span><a href="#42045727">next</a><span>|</span><label class="collapse" for="c-42048099">[-]</label><label class="expand" for="c-42048099">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because nobody has yet solved the side effect problem of the sugar.<p>All the proposals that have ever been given have ultimately boiled down to essentially `return err`, which, while suitable for meme comments on an internet forum, cannot be used in a real production application for many obvious (and some not immediately obvious) reasons.<p>At least under the direction of rsc (the new leadership is still settling into the role so that is less clear), the will to add such sugar was there if a good solution was found. But the solution has yet to be found.</div><br/></div></div><div id="42045727" class="c"><input type="checkbox" id="c-42045727" checked=""/><div class="controls bullet"><span class="by">divan</span><span>|</span><a href="#42045369">root</a><span>|</span><a href="#42045641">parent</a><span>|</span><a href="#42048099">prev</a><span>|</span><a href="#42045704">next</a><span>|</span><label class="collapse" for="c-42045727">[-]</label><label class="expand" for="c-42045727">[1 more]</label></div><br/><div class="children"><div class="content">As with real sugar, we humans don’t have sensors that would tell us when there’s &quot;too much sugar&quot;.</div><br/></div></div></div></div><div id="42045704" class="c"><input type="checkbox" id="c-42045704" checked=""/><div class="controls bullet"><span class="by">zapnuk</span><span>|</span><a href="#42045369">parent</a><span>|</span><a href="#42045641">prev</a><span>|</span><a href="#42045779">next</a><span>|</span><label class="collapse" for="c-42045704">[-]</label><label class="expand" for="c-42045704">[1 more]</label></div><br/><div class="children"><div class="content">Writing custom iterators always looked bad and overly complicated.<p>If it&#x27;s not essentials I&#x27;d rather not allow code like this in my codebase and use some other solution that is more readable.</div><br/></div></div><div id="42045779" class="c"><input type="checkbox" id="c-42045779" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#42045369">parent</a><span>|</span><a href="#42045704">prev</a><span>|</span><a href="#42047254">next</a><span>|</span><label class="collapse" for="c-42045779">[-]</label><label class="expand" for="c-42045779">[2 more]</label></div><br/><div class="children"><div class="content">Indeed. I still try to avoid generics whenever possible, and prefer a solution that doesn&#x27;t use them. Thankfully, there aren&#x27;t many scenarios where they&#x27;re absolutely indispensable.</div><br/><div id="42045820" class="c"><input type="checkbox" id="c-42045820" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#42045369">root</a><span>|</span><a href="#42045779">parent</a><span>|</span><a href="#42047254">next</a><span>|</span><label class="collapse" for="c-42045820">[-]</label><label class="expand" for="c-42045820">[1 more]</label></div><br/><div class="children"><div class="content">Write a generic instantiator that scans your codebase for generic usage, and makes one copy of a generic for every type it&#x27;s used with. Then you can remove all the generics and go back to copy and paste.</div><br/></div></div></div></div></div></div><div id="42044837" class="c"><input type="checkbox" id="c-42044837" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#42045712">prev</a><span>|</span><label class="collapse" for="c-42044837">[-]</label><label class="expand" for="c-42044837">[12 more]</label></div><br/><div class="children"><div class="content">Please note, currently, there are no tools to detect the new footguns created by the new semantics of 3-clause &quot;for;;&quot; loops: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;66156">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;66156</a><p>&gt; The second step is to keep the Go versions in our projects current. Even though we don’t use the latest and greatest language features, bumping the Go version gives us all security patches for discovered vulnerabilities.<p>It is not always a good strategy to use the latest toolchain version. There are often some fresh bugs in it. From the security perspective, it is better to use the previous version, which is also still being maintained.</div><br/><div id="42046965" class="c"><input type="checkbox" id="c-42046965" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#42044837">parent</a><span>|</span><a href="#42044982">next</a><span>|</span><label class="collapse" for="c-42046965">[-]</label><label class="expand" for="c-42046965">[2 more]</label></div><br/><div class="children"><div class="content">Good grief, you&#x27;re still banging on about this. It&#x27;s been well over a year. Literally no one agrees with you. That happens sometimes. But please, accept that and give it a rest already.</div><br/><div id="42049290" class="c"><input type="checkbox" id="c-42049290" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#42044837">root</a><span>|</span><a href="#42046965">parent</a><span>|</span><a href="#42044982">next</a><span>|</span><label class="collapse" for="c-42049290">[-]</label><label class="expand" for="c-42049290">[1 more]</label></div><br/><div class="children"><div class="content">Copernicus was in the same position.<p>:)</div><br/></div></div></div></div><div id="42044982" class="c"><input type="checkbox" id="c-42044982" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#42044837">parent</a><span>|</span><a href="#42046965">prev</a><span>|</span><a href="#42045998">next</a><span>|</span><label class="collapse" for="c-42044982">[-]</label><label class="expand" for="c-42044982">[6 more]</label></div><br/><div class="children"><div class="content">you&#x27;re literally the only person who&#x27;s making a mountain out of a molehill coming up with ever more convoluted code to &quot;prove&quot; the change was a bad thing.</div><br/><div id="42045112" class="c"><input type="checkbox" id="c-42045112" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#42044837">root</a><span>|</span><a href="#42044982">parent</a><span>|</span><a href="#42045340">next</a><span>|</span><label class="collapse" for="c-42045112">[-]</label><label class="expand" for="c-42045112">[3 more]</label></div><br/><div class="children"><div class="content">It indeed is. Please read <a href="https:&#x2F;&#x2F;go101.org&#x2F;blog&#x2F;2024-03-01-for-loop-semantic-changes-in-go-1.22.html" rel="nofollow">https:&#x2F;&#x2F;go101.org&#x2F;blog&#x2F;2024-03-01-for-loop-semantic-changes-...</a> and <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;66156">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;66156</a></div><br/><div id="42045401" class="c"><input type="checkbox" id="c-42045401" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#42044837">root</a><span>|</span><a href="#42045112">parent</a><span>|</span><a href="#42045340">next</a><span>|</span><label class="collapse" for="c-42045401">[-]</label><label class="expand" for="c-42045401">[2 more]</label></div><br/><div class="children"><div class="content">a lot of words and yet no real world issues identified</div><br/><div id="42045485" class="c"><input type="checkbox" id="c-42045485" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#42044837">root</a><span>|</span><a href="#42045401">parent</a><span>|</span><a href="#42045340">next</a><span>|</span><label class="collapse" for="c-42045485">[-]</label><label class="expand" for="c-42045485">[1 more]</label></div><br/><div class="children"><div class="content">The problems are right there. But some people choose to turn a blind eye.</div><br/></div></div></div></div></div></div><div id="42045340" class="c"><input type="checkbox" id="c-42045340" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#42044837">root</a><span>|</span><a href="#42044982">parent</a><span>|</span><a href="#42045112">prev</a><span>|</span><a href="#42045998">next</a><span>|</span><label class="collapse" for="c-42045340">[-]</label><label class="expand" for="c-42045340">[2 more]</label></div><br/><div class="children"><div class="content">.0 is for local development, .1+ is for production</div><br/><div id="42045461" class="c"><input type="checkbox" id="c-42045461" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#42044837">root</a><span>|</span><a href="#42045340">parent</a><span>|</span><a href="#42045998">next</a><span>|</span><label class="collapse" for="c-42045461">[-]</label><label class="expand" for="c-42045461">[1 more]</label></div><br/><div class="children"><div class="content">There might be some bugs in .2: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;70035">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;70035</a></div><br/></div></div></div></div></div></div><div id="42045998" class="c"><input type="checkbox" id="c-42045998" checked=""/><div class="controls bullet"><span class="by">superb_dev</span><span>|</span><a href="#42044837">parent</a><span>|</span><a href="#42044982">prev</a><span>|</span><a href="#42046401">next</a><span>|</span><label class="collapse" for="c-42045998">[-]</label><label class="expand" for="c-42045998">[2 more]</label></div><br/><div class="children"><div class="content">The examples in that ticket are convoluted, who would write code like that? Has this issue been spotted in the wild?<p>I agree that there is some issue and a lint should probably warn you about these, but I doubt a lot of people will run into it.</div><br/><div id="42049311" class="c"><input type="checkbox" id="c-42049311" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#42044837">root</a><span>|</span><a href="#42045998">parent</a><span>|</span><a href="#42046401">next</a><span>|</span><label class="collapse" for="c-42049311">[-]</label><label class="expand" for="c-42049311">[1 more]</label></div><br/><div class="children"><div class="content">You should read that article carefully.<p>Some Go core team members don&#x27;t agree with you: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;66156">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;66156</a></div><br/></div></div></div></div><div id="42046401" class="c"><input type="checkbox" id="c-42046401" checked=""/><div class="controls bullet"><span class="by">01119288523</span><span>|</span><a href="#42044837">parent</a><span>|</span><a href="#42045998">prev</a><span>|</span><label class="collapse" for="c-42046401">[-]</label><label class="expand" for="c-42046401">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;docs.google.com&#x2F;document&#x2F;d&#x2F;1Cb282k7rrSi4awr0HizuRciX-nIYpympfrxGLEt9cgc&#x2F;edit" rel="nofollow">https:&#x2F;&#x2F;docs.google.com&#x2F;document&#x2F;d&#x2F;1Cb282k7rrSi4awr0HizuRciX...</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>