<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1730710881540" as="style"/><link rel="stylesheet" href="styles.css?v=1730710881540"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://spin.atomicobject.com/redis-postgresql/">Do you need Redis? PostgreSQL does queuing, locking, and pub/sub</a> <span class="domain">(<a href="https://spin.atomicobject.com">spin.atomicobject.com</a>)</span></div><div class="subtext"><span>fanf2</span> | <span>116 comments</span></div><br/><div><div id="42036629" class="c"><input type="checkbox" id="c-42036629" checked=""/><div class="controls bullet"><span class="by">pjs_</span><span>|</span><a href="#42037255">next</a><span>|</span><label class="collapse" for="c-42036629">[-]</label><label class="expand" for="c-42036629">[63 more]</label></div><br/><div class="children"><div class="content">Because everyone insists on insanely distributed architectures, most people will never really see the point of Redis, which is that if it is running on the same machine as the application, it can respond in much less than a millisecond. That lets you do stuff in the application that you just can&#x27;t do with Postgres. Postgres kicks ass obviously but it is not running in memory on the same machine as the application.<p>If all you want to do is queues and whatnot, then sure, you don&#x27;t need an in-memory KV store.<p>The point of an in-memory KV store is to do stuff <i>that needs the performance characteristics of RAM</i>. You obviously can&#x27;t get the performance characteristics of RAM over a network connection. This is like, a tautology.</div><br/><div id="42036842" class="c"><input type="checkbox" id="c-42036842" checked=""/><div class="controls bullet"><span class="by">roncesvalles</span><span>|</span><a href="#42036629">parent</a><span>|</span><a href="#42036770">next</a><span>|</span><label class="collapse" for="c-42036842">[-]</label><label class="expand" for="c-42036842">[16 more]</label></div><br/><div class="children"><div class="content">If the setup is that only one local process will use on-machine Redis as an in-memory cache, you&#x27;re better off using the data structures available in your programming language.</div><br/><div id="42039643" class="c"><input type="checkbox" id="c-42039643" checked=""/><div class="controls bullet"><span class="by">bryanrasmussen</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036842">parent</a><span>|</span><a href="#42037216">next</a><span>|</span><label class="collapse" for="c-42039643">[-]</label><label class="expand" for="c-42039643">[1 more]</label></div><br/><div class="children"><div class="content">all the other reasons beside - because at some point I might want to move the data cache off of the single machine and then I can do that with a couple of minutes work, yes then I am back to do I need redis why not use postgres, but I got months of better performance out of redis than I would have with postgres, if I need to move to separate machine I am probably doing good enough I can afford it.<p>Redis helps you get to the point (need cache on separate machines) where you might want to consider moving to postgres, or not because you don&#x27;t feel it warrants the investment of programmer hours at that point.</div><br/></div></div><div id="42037216" class="c"><input type="checkbox" id="c-42037216" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036842">parent</a><span>|</span><a href="#42039643">prev</a><span>|</span><a href="#42038990">next</a><span>|</span><label class="collapse" for="c-42037216">[-]</label><label class="expand" for="c-42037216">[1 more]</label></div><br/><div class="children"><div class="content">Redis can cluster alongside your backend cluster, so you&#x27;ll have the advantage that <i>sometimes</i> the data will be local.</div><br/></div></div><div id="42038990" class="c"><input type="checkbox" id="c-42038990" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036842">parent</a><span>|</span><a href="#42037216">prev</a><span>|</span><a href="#42036979">next</a><span>|</span><label class="collapse" for="c-42038990">[-]</label><label class="expand" for="c-42038990">[5 more]</label></div><br/><div class="children"><div class="content">Why? Most languages are less memory efficient than redis, even in a separate process, and I don’t want to reimplement half of its features.</div><br/><div id="42039660" class="c"><input type="checkbox" id="c-42039660" checked=""/><div class="controls bullet"><span class="by">mgraczyk</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42038990">parent</a><span>|</span><a href="#42039637">prev</a><span>|</span><a href="#42039075">next</a><span>|</span><label class="collapse" for="c-42039660">[-]</label><label class="expand" for="c-42039660">[1 more]</label></div><br/><div class="children"><div class="content">You can do a mutex in like 10 bytes, how could redis be more memory efficient?</div><br/></div></div><div id="42039075" class="c"><input type="checkbox" id="c-42039075" checked=""/><div class="controls bullet"><span class="by">cstadnij</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42038990">parent</a><span>|</span><a href="#42039660">prev</a><span>|</span><a href="#42036979">next</a><span>|</span><label class="collapse" for="c-42039075">[-]</label><label class="expand" for="c-42039075">[2 more]</label></div><br/><div class="children"><div class="content">Because it&#x27;s really, really slow compared to in-language variables? I&#x27;ve not yet ran out of memory because of program variables, and speed shouldn&#x27;t be an argument for low memory footprint when it&#x27;s already at best 1&#x2F;10 of it&#x27;s performance.</div><br/><div id="42039132" class="c"><input type="checkbox" id="c-42039132" checked=""/><div class="controls bullet"><span class="by">speedgoose</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42039075">parent</a><span>|</span><a href="#42036979">next</a><span>|</span><label class="collapse" for="c-42039132">[-]</label><label class="expand" for="c-42039132">[1 more]</label></div><br/><div class="children"><div class="content">Redis locally is good to do IPC though. You have many scenarios where multi local processes have to exchange data. You have alternatives but Redis works and can scale up.</div><br/></div></div></div></div></div></div><div id="42036979" class="c"><input type="checkbox" id="c-42036979" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036842">parent</a><span>|</span><a href="#42038990">prev</a><span>|</span><a href="#42037070">next</a><span>|</span><label class="collapse" for="c-42036979">[-]</label><label class="expand" for="c-42036979">[1 more]</label></div><br/><div class="children"><div class="content">This is the vanillajs.com of data stores.</div><br/></div></div><div id="42037070" class="c"><input type="checkbox" id="c-42037070" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036842">parent</a><span>|</span><a href="#42036979">prev</a><span>|</span><a href="#42036770">next</a><span>|</span><label class="collapse" for="c-42037070">[-]</label><label class="expand" for="c-42037070">[7 more]</label></div><br/><div class="children"><div class="content">Not really. Because then once you restart that process you lose everything.<p>And it&#x27;s far more likely you are continuously upgrading your process than Redis.</div><br/><div id="42038266" class="c"><input type="checkbox" id="c-42038266" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42037070">parent</a><span>|</span><a href="#42039074">next</a><span>|</span><label class="collapse" for="c-42038266">[-]</label><label class="expand" for="c-42038266">[3 more]</label></div><br/><div class="children"><div class="content">If you need that, you can use an embedded data store like leveldb&#x2F;rocksdb or sqlite. Why bring another application running as its own process into the equation?</div><br/><div id="42039039" class="c"><input type="checkbox" id="c-42039039" checked=""/><div class="controls bullet"><span class="by">112233</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42038266">parent</a><span>|</span><a href="#42038490">next</a><span>|</span><label class="collapse" for="c-42039039">[-]</label><label class="expand" for="c-42039039">[1 more]</label></div><br/><div class="children"><div class="content">But having separate applications can give you better perfomance and isolation than one single threaded process?<p>Or do you compare using separate processes to having multiple threads in a single process?</div><br/></div></div><div id="42038490" class="c"><input type="checkbox" id="c-42038490" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42038266">parent</a><span>|</span><a href="#42039039">prev</a><span>|</span><a href="#42039074">next</a><span>|</span><label class="collapse" for="c-42038490">[-]</label><label class="expand" for="c-42038490">[1 more]</label></div><br/><div class="children"><div class="content">Running in its own process, and, better yet, in its own cgroup (container) makes potential bugs in it, including RCEs, harder to exploit. It also makes it easier to limit resources it consumes, monitor its functioning, etc. Upgrading it does not require you to rebuild and redeploy your app, which may be important if a bug or performance regression occurs is triggered, and you need a quick upgrade or downgrade with (near) zero downtime.<p>Ideally every significant part should live in its own universe, only interacting with other parts via well-defined interfaces. Sadly, it&#x27;s either more expensive (even as Unix processes, to say nothing of Windows), slower (Erlang &#x2F; Elixir), or both (microservices).</div><br/></div></div></div></div><div id="42039074" class="c"><input type="checkbox" id="c-42039074" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42037070">parent</a><span>|</span><a href="#42038266">prev</a><span>|</span><a href="#42036770">next</a><span>|</span><label class="collapse" for="c-42039074">[-]</label><label class="expand" for="c-42039074">[3 more]</label></div><br/><div class="children"><div class="content">Either fork the process so the forked copy can dump its data (I think Redis itself does something like this), or launch a new process (with updated code if desired), then migrate the data and open sockets to it through some combination of unix domain sockets and maybe mmap.  Or if we had OS&#x27;s that really used x86 segmentation capability as it was designed for (this is one thing the 386 and later did cleverly) it could all be done with segments.</div><br/><div id="42039281" class="c"><input type="checkbox" id="c-42039281" checked=""/><div class="controls bullet"><span class="by">mcv</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42039074">parent</a><span>|</span><a href="#42036770">next</a><span>|</span><label class="collapse" for="c-42039281">[-]</label><label class="expand" for="c-42039281">[2 more]</label></div><br/><div class="children"><div class="content">Now you&#x27;re making it complicated again.<p>I think a good rule of thumb is:<p>* If you need it from a single process and it doesn&#x27;t need to survive process restarts, just use basic in-process data structures.<p>* If you need it from multiple processes or it needs to survive process restarts, but not system restarts, use redis.<p>* If it needs persistence across system restarts, use a real DB.</div><br/><div id="42039535" class="c"><input type="checkbox" id="c-42039535" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42039281">parent</a><span>|</span><a href="#42036770">next</a><span>|</span><label class="collapse" for="c-42039535">[-]</label><label class="expand" for="c-42039535">[1 more]</label></div><br/><div class="children"><div class="content">Redis is nice but you take a huge speed hit depending on what you&#x27;re doing, compared to using in-memory structures.  Note that Redis can also persist to disk, either by forking or by writing an append-only op log that can be replayed for reloading or replication.  Anyway, you have ignored the case where you want not only the data structures, but also the open network connections to persist across process restarts.  That&#x27;s what passing file descriptors through unix domain sockets lets you do.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42036770" class="c"><input type="checkbox" id="c-42036770" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#42036629">parent</a><span>|</span><a href="#42036842">prev</a><span>|</span><a href="#42036761">next</a><span>|</span><label class="collapse" for="c-42036770">[-]</label><label class="expand" for="c-42036770">[16 more]</label></div><br/><div class="children"><div class="content">&gt; but it is not running in memory on the same machine as the application.<p>What&#x27;s the overhead of postgres vs redis, when run locally? Why do you think postgres <i>isn&#x27;t</i> run locally?<p>There&#x27;s nothing special about postgres. It&#x27;s just a program that runs in another process, just like redis. For local connections, it uses fast pipes, to reduce latency, and you get access to some faster data bulk transfer methods. I&#x27;ve used it in this way on many occasions.</div><br/><div id="42036832" class="c"><input type="checkbox" id="c-42036832" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036770">parent</a><span>|</span><a href="#42036761">next</a><span>|</span><label class="collapse" for="c-42036832">[-]</label><label class="expand" for="c-42036832">[15 more]</label></div><br/><div class="children"><div class="content">PostgreSQL does not have the concept of <i>in-memory</i> tables.<p>Except for temporary tables which are wiped after each session.</div><br/><div id="42037000" class="c"><input type="checkbox" id="c-42037000" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036832">parent</a><span>|</span><a href="#42037204">next</a><span>|</span><label class="collapse" for="c-42037000">[-]</label><label class="expand" for="c-42037000">[7 more]</label></div><br/><div class="children"><div class="content">That&#x27;s simplifying things a bit.<p>Postgres has a shared memory cache, which can be set the same as redis, so your operations will all happen with in memory, with some background stuff putting it onto disk for you in the case your computer shuts off. Storage won&#x27;t be involved.<p>BUT, postgres still has ~6x the latency [1], even when run from memory.<p>[1] <a href="https:&#x2F;&#x2F;medium.com&#x2F;redis-with-raphael-de-lio&#x2F;can-postgres-replace-redis-as-a-cache-f6cba13386dc#:~:text=The%20performance%20comparison%20shows%20that,observed%20for%20Postgres&#x27;%20unlogged%20table" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;redis-with-raphael-de-lio&#x2F;can-postgres-re...</a>.</div><br/><div id="42037098" class="c"><input type="checkbox" id="c-42037098" checked=""/><div class="controls bullet"><span class="by">jeltz</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42037000">parent</a><span>|</span><a href="#42037056">next</a><span>|</span><label class="collapse" for="c-42037098">[-]</label><label class="expand" for="c-42037098">[1 more]</label></div><br/><div class="children"><div class="content">Pretty pointless benchmark since it does not use prepared statements (that much is obvious from the low TPS, plus I confirmed it with how he ran the benchmark). You need to pass &quot;-M prepared&quot; to pgbench. And it is very possible that the Redis benchmark is equally flawed.<p>If you have to parse and plan queries every time PostgreSQL is obviously much slower than Redis. It is much more interesting to see what happens if prepared statements are used.</div><br/></div></div><div id="42037056" class="c"><input type="checkbox" id="c-42037056" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42037000">parent</a><span>|</span><a href="#42037098">prev</a><span>|</span><a href="#42037204">next</a><span>|</span><label class="collapse" for="c-42037056">[-]</label><label class="expand" for="c-42037056">[5 more]</label></div><br/><div class="children"><div class="content">But the whole point here is that PostgreSQL will be used for other tasks e.g. storing all of your business data. So it will be fighting for the shared cache as well as the disk. And of course storage will still be involved as again you can&#x27;t have in-memory only tables.<p>And having a locking system fluctuate in latency between milliseconds and seconds would cause all sorts of headaches.</div><br/><div id="42037195" class="c"><input type="checkbox" id="c-42037195" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42037056">parent</a><span>|</span><a href="#42037296">next</a><span>|</span><label class="collapse" for="c-42037195">[-]</label><label class="expand" for="c-42037195">[3 more]</label></div><br/><div class="children"><div class="content">If you are both small enough that you’re considering cohosting the app and DB, the odds are good that your working set is small enough to comfortably fit into RAM on any decently-sized instance.<p>&gt; And having a locking system fluctuate in latency between milliseconds and seconds would cause all sorts of headaches.<p>With the frequency that a locking system is likely to be used, it’s highly unlikely that those pages would ever get purged from the buffer pool.</div><br/><div id="42037257" class="c"><input type="checkbox" id="c-42037257" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42037195">parent</a><span>|</span><a href="#42037296">next</a><span>|</span><label class="collapse" for="c-42037257">[-]</label><label class="expand" for="c-42037257">[2 more]</label></div><br/><div class="children"><div class="content">Once again. PostgresSQL does not have in-memory tables. So:<p>a) Writes will be happening on a slow, highly contentious disk.<p>b) You have no guarantees that the data will be in-memory.<p>Both of which make it a poor solution for use cases such as locking.</div><br/><div id="42038226" class="c"><input type="checkbox" id="c-42038226" checked=""/><div class="controls bullet"><span class="by">natmaka</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42037257">parent</a><span>|</span><a href="#42037296">next</a><span>|</span><label class="collapse" for="c-42038226">[-]</label><label class="expand" for="c-42038226">[1 more]</label></div><br/><div class="children"><div class="content">As pointed out by blackenedgem above: PostgreSQL has tablespaces, and one may simply declare tables which should stay in RAM in a tablespace built upon a tmpfs with enough reserved RAM to store them all.  There is a only small associated burden (restoring the tablespace while starting PG).</div><br/></div></div></div></div></div></div><div id="42037296" class="c"><input type="checkbox" id="c-42037296" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42037056">parent</a><span>|</span><a href="#42037195">prev</a><span>|</span><a href="#42037204">next</a><span>|</span><label class="collapse" for="c-42037296">[-]</label><label class="expand" for="c-42037296">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And of course storage will still be involved as again you can&#x27;t have in-memory only tables.<p>That&#x27;s fine. If what you want is a single-node deployment combined with in-memory purism them SQLite has your back.</div><br/></div></div></div></div></div></div><div id="42037204" class="c"><input type="checkbox" id="c-42037204" checked=""/><div class="controls bullet"><span class="by">blackenedgem</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036832">parent</a><span>|</span><a href="#42037000">prev</a><span>|</span><a href="#42037043">next</a><span>|</span><label class="collapse" for="c-42037204">[-]</label><label class="expand" for="c-42037204">[2 more]</label></div><br/><div class="children"><div class="content">No but it does have the concept of tablespaces. If you want you can map RAM to a disk location, set that up as a tablespace, then tell postgres to use that tablespace for your given table. Also set the table as UNLOGGED while you&#x27;re at it.<p>A bit more work yes that could be simplified, but fully supported if you control the stack.</div><br/><div id="42038511" class="c"><input type="checkbox" id="c-42038511" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42037204">parent</a><span>|</span><a href="#42037043">next</a><span>|</span><label class="collapse" for="c-42038511">[-]</label><label class="expand" for="c-42038511">[1 more]</label></div><br/><div class="children"><div class="content">Yes. Putting a Postgres tablespace on a RAM disk (tmpfs) does wonders. Even if NVMe may be comparable to RAM by bandwidth, whatever Postgres has to do to ensure that data are written to the durable store as a part of a commit is still significantly slower compared to RAM.<p>Highly recommended for running tests, especially in CI&#x2F;CD pipelines. Doing this simple change can speed up DB-heavy tests 30-50%.</div><br/></div></div></div></div><div id="42037043" class="c"><input type="checkbox" id="c-42037043" checked=""/><div class="controls bullet"><span class="by">pdhborges</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036832">parent</a><span>|</span><a href="#42037204">prev</a><span>|</span><a href="#42037281">next</a><span>|</span><label class="collapse" for="c-42037043">[-]</label><label class="expand" for="c-42037043">[1 more]</label></div><br/><div class="children"><div class="content">Well if your working set fits RAM your tables will be stored in memory in the shared buffers.</div><br/></div></div><div id="42037281" class="c"><input type="checkbox" id="c-42037281" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036832">parent</a><span>|</span><a href="#42037043">prev</a><span>|</span><a href="#42036761">next</a><span>|</span><label class="collapse" for="c-42037281">[-]</label><label class="expand" for="c-42037281">[4 more]</label></div><br/><div class="children"><div class="content">&gt; PostgreSQL does not have the concept of in-memory tables.<p>Is that relevant though? Some benchmarks on the web show Postgres outperforming Redis in reads as well as low-volume writes (less than 1k key-value pairs), and Redis only beating Postgres for high volume key-value writes.</div><br/><div id="42037543" class="c"><input type="checkbox" id="c-42037543" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42037281">parent</a><span>|</span><a href="#42036761">next</a><span>|</span><label class="collapse" for="c-42037543">[-]</label><label class="expand" for="c-42037543">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Redis only beating Postgres for high volume key-value writes<p>I wonder what type of use cases have high volume writes.<p>Maybe queuing, locking and pub&#x2F;sub ?</div><br/><div id="42039687" class="c"><input type="checkbox" id="c-42039687" checked=""/><div class="controls bullet"><span class="by">jeltz</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42037543">parent</a><span>|</span><a href="#42037888">next</a><span>|</span><label class="collapse" for="c-42039687">[-]</label><label class="expand" for="c-42039687">[1 more]</label></div><br/><div class="children"><div class="content">Usually none of them. Queuing is almost never high volume and rarely is pub sub.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42036761" class="c"><input type="checkbox" id="c-42036761" checked=""/><div class="controls bullet"><span class="by">Eikon</span><span>|</span><a href="#42036629">parent</a><span>|</span><a href="#42036770">prev</a><span>|</span><a href="#42036863">next</a><span>|</span><label class="collapse" for="c-42036761">[-]</label><label class="expand" for="c-42036761">[17 more]</label></div><br/><div class="children"><div class="content">You know what performs better than redis in this setup? An hashmap.<p>Why Postgres wouldn’t run on the same server as the app? It’s actually pretty common.</div><br/><div id="42036914" class="c"><input type="checkbox" id="c-42036914" checked=""/><div class="controls bullet"><span class="by">secretmark</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036761">parent</a><span>|</span><a href="#42036841">next</a><span>|</span><label class="collapse" for="c-42036914">[-]</label><label class="expand" for="c-42036914">[2 more]</label></div><br/><div class="children"><div class="content">What if there are multiple processes that require access to a shared cache?</div><br/><div id="42036998" class="c"><input type="checkbox" id="c-42036998" checked=""/><div class="controls bullet"><span class="by">mbreese</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036914">parent</a><span>|</span><a href="#42036841">next</a><span>|</span><label class="collapse" for="c-42036998">[-]</label><label class="expand" for="c-42036998">[1 more]</label></div><br/><div class="children"><div class="content">And I think this is the main use case they were looking for. If you have a web app where each request is a separate process&#x2F;call (not uncommon), and you don’t have a good shared global state, Redis is a great tool. It is an in-memory data structure store that can respond to requests from different processes. I always considered it an evolution from memcached.<p>If you only have one long lived process or good global variable control, then it is much less appealing in the single-server scenario. Similarly, if you require access from multiple hosts, it becomes a less obvious choice (especially if you already have a database in the loop). And redis is also overkill is you’re using it only as a cache.</div><br/></div></div></div></div><div id="42036841" class="c"><input type="checkbox" id="c-42036841" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036761">parent</a><span>|</span><a href="#42036914">prev</a><span>|</span><a href="#42036863">next</a><span>|</span><label class="collapse" for="c-42036841">[-]</label><label class="expand" for="c-42036841">[14 more]</label></div><br/><div class="children"><div class="content">There&#x27;s more to redis than just being a K&#x2F;V store.</div><br/><div id="42036884" class="c"><input type="checkbox" id="c-42036884" checked=""/><div class="controls bullet"><span class="by">strken</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036841">parent</a><span>|</span><a href="#42037310">next</a><span>|</span><label class="collapse" for="c-42036884">[-]</label><label class="expand" for="c-42036884">[8 more]</label></div><br/><div class="children"><div class="content">Perhaps you could elaborate? It would be helpful to understand what Redis can do that cannot be done easily with local memory.<p>Acting as shared memory for an inherently single-CPU language like JS is one I can think of. However, I don&#x27;t use Redis, so you&#x27;d be better placed to drive the discussion forward with examples.</div><br/><div id="42038302" class="c"><input type="checkbox" id="c-42038302" checked=""/><div class="controls bullet"><span class="by">mperham</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036884">parent</a><span>|</span><a href="#42038372">next</a><span>|</span><label class="collapse" for="c-42038302">[-]</label><label class="expand" for="c-42038302">[2 more]</label></div><br/><div class="children"><div class="content">Redis provides low-level persistent data structures which can be used to implement business logic distributed safely across a number of machines. That’s a LOT harder than in-memory in-process.<p>My Sidekiq background job system runs entirely on top of Redis. Structures like Sorted Sets become the basis for indexes. Lists provide extremely fast queue behavior and Hashes map easily to persistent objects. Databases, traditionally, have not performed well when used as queues.<p>Those are the big 3 structures necessary to implement anything: trees, lists and maps.</div><br/><div id="42039337" class="c"><input type="checkbox" id="c-42039337" checked=""/><div class="controls bullet"><span class="by">strken</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42038302">parent</a><span>|</span><a href="#42038372">next</a><span>|</span><label class="collapse" for="c-42039337">[-]</label><label class="expand" for="c-42039337">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a bit confused here, because the original comment was that &quot;most people will never really see the point of Redis, which is that if it is running on the same machine as the application, it can respond in much less than a millisecond&quot;, to which the response was &quot;there&#x27;s more to redis than just being a K&#x2F;V store&quot;.<p>I do see the point of Redis if you have multiple hosts, but I was unsure why someone would use it on just one host.</div><br/></div></div></div></div><div id="42038372" class="c"><input type="checkbox" id="c-42038372" checked=""/><div class="controls bullet"><span class="by">runeblaze</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036884">parent</a><span>|</span><a href="#42038302">prev</a><span>|</span><a href="#42037407">next</a><span>|</span><label class="collapse" for="c-42038372">[-]</label><label class="expand" for="c-42038372">[1 more]</label></div><br/><div class="children"><div class="content">Just to add -- sometimes I use Redis when I don&#x27;t have a trusted impl of HyperLogLog or sorted set (and I have a vague suspicion that I am going to do IPC later -- so not worth it to wrap my own HLL).</div><br/></div></div><div id="42037407" class="c"><input type="checkbox" id="c-42037407" checked=""/><div class="controls bullet"><span class="by">quantadev</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036884">parent</a><span>|</span><a href="#42038372">prev</a><span>|</span><a href="#42036897">next</a><span>|</span><label class="collapse" for="c-42037407">[-]</label><label class="expand" for="c-42037407">[3 more]</label></div><br/><div class="children"><div class="content">I have Docker running in swarm mode where it will spin up multiple load balanced instances of my web app (where requests can get routed randomly to any instance). So I use Redis to store &quot;User Session Information&quot; so the session can be read&#x2F;written from any instance, supposedly faster than using a DB.</div><br/><div id="42037898" class="c"><input type="checkbox" id="c-42037898" checked=""/><div class="controls bullet"><span class="by">tbrownaw</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42037407">parent</a><span>|</span><a href="#42036897">next</a><span>|</span><label class="collapse" for="c-42037898">[-]</label><label class="expand" for="c-42037898">[2 more]</label></div><br/><div class="children"><div class="content">When I&#x27;ve used redis to store web sessions, it is in fact acting as a k&#x2F;v store. The session ID is the key, and the (serialized) session state is the value.</div><br/><div id="42038142" class="c"><input type="checkbox" id="c-42038142" checked=""/><div class="controls bullet"><span class="by">quantadev</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42037898">parent</a><span>|</span><a href="#42036897">next</a><span>|</span><label class="collapse" for="c-42038142">[-]</label><label class="expand" for="c-42038142">[1 more]</label></div><br/><div class="children"><div class="content">Yep, that&#x27;s what I&#x27;m doing too. I bet it&#x27;s the most common use case for Redis.</div><br/></div></div></div></div></div></div><div id="42036897" class="c"><input type="checkbox" id="c-42036897" checked=""/><div class="controls bullet"><span class="by">shakow</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036884">parent</a><span>|</span><a href="#42037407">prev</a><span>|</span><a href="#42037310">next</a><span>|</span><label class="collapse" for="c-42036897">[-]</label><label class="expand" for="c-42036897">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Perhaps you could elaborate?<p>IPC, I suppose?</div><br/></div></div></div></div><div id="42037310" class="c"><input type="checkbox" id="c-42037310" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036841">parent</a><span>|</span><a href="#42036884">prev</a><span>|</span><a href="#42036846">next</a><span>|</span><label class="collapse" for="c-42037310">[-]</label><label class="expand" for="c-42037310">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s more to redis than just being a K&#x2F;V store.<p>That&#x27;s perfectly fine. You can compare Redis to other specialized tools just like you can compare it with Postgres and SQLite.</div><br/></div></div><div id="42036846" class="c"><input type="checkbox" id="c-42036846" checked=""/><div class="controls bullet"><span class="by">Eikon</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036841">parent</a><span>|</span><a href="#42037310">prev</a><span>|</span><a href="#42036850">next</a><span>|</span><label class="collapse" for="c-42036846">[-]</label><label class="expand" for="c-42036846">[1 more]</label></div><br/><div class="children"><div class="content">There’s more data structures in your favorite language std lib than an hashmap, at least, I hope so :)</div><br/></div></div><div id="42036850" class="c"><input type="checkbox" id="c-42036850" checked=""/><div class="controls bullet"><span class="by">ummonk</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036841">parent</a><span>|</span><a href="#42036846">prev</a><span>|</span><a href="#42036863">next</a><span>|</span><label class="collapse" for="c-42036850">[-]</label><label class="expand" for="c-42036850">[3 more]</label></div><br/><div class="children"><div class="content">Like?</div><br/><div id="42036917" class="c"><input type="checkbox" id="c-42036917" checked=""/><div class="controls bullet"><span class="by">noident</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036850">parent</a><span>|</span><a href="#42036863">next</a><span>|</span><label class="collapse" for="c-42036917">[-]</label><label class="expand" for="c-42036917">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;redis.io&#x2F;docs&#x2F;latest&#x2F;commands&#x2F;" rel="nofollow">https:&#x2F;&#x2F;redis.io&#x2F;docs&#x2F;latest&#x2F;commands&#x2F;</a></div><br/><div id="42038221" class="c"><input type="checkbox" id="c-42038221" checked=""/><div class="controls bullet"><span class="by">101011</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036917">parent</a><span>|</span><a href="#42036863">next</a><span>|</span><label class="collapse" for="c-42038221">[-]</label><label class="expand" for="c-42038221">[1 more]</label></div><br/><div class="children"><div class="content">TIL about a Cuckoo Filter.<p>Also, never realized redis has native support for a Bloom Filter.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42036863" class="c"><input type="checkbox" id="c-42036863" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#42036629">parent</a><span>|</span><a href="#42036761">prev</a><span>|</span><a href="#42037152">next</a><span>|</span><label class="collapse" for="c-42036863">[-]</label><label class="expand" for="c-42036863">[2 more]</label></div><br/><div class="children"><div class="content">Overengineering&#x2F;premature distribution is a real problem, but Redis stands for &quot;Remote Dictionary Server.&quot; The purpose is very much not to run it locally! (Though that&#x27;s a legitimate design choice, especially if your language&#x27;s native dictionary doesn&#x27;t support range queries.)</div><br/><div id="42037168" class="c"><input type="checkbox" id="c-42037168" checked=""/><div class="controls bullet"><span class="by">freedomben</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036863">parent</a><span>|</span><a href="#42037152">next</a><span>|</span><label class="collapse" for="c-42037168">[-]</label><label class="expand" for="c-42037168">[1 more]</label></div><br/><div class="children"><div class="content">The purpose may not be primarily or originally to run it locally, but that has definitely become a common use case.<p>That said, anitirez renaming it to lredis or reldis would be epic and one of my favorite moves of all time</div><br/></div></div></div></div><div id="42037152" class="c"><input type="checkbox" id="c-42037152" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#42036629">parent</a><span>|</span><a href="#42036863">prev</a><span>|</span><a href="#42037226">next</a><span>|</span><label class="collapse" for="c-42037152">[-]</label><label class="expand" for="c-42037152">[1 more]</label></div><br/><div class="children"><div class="content">It very well could be running on the same machine, and communicating with the app using unix sockets, which is a hell of a lot faster than TCP. But no one seems to be doing that much either.<p>I feel that the virtualize and distribute everything to hell and back-trend might actually be about to break, there are signs, and G knows it&#x27;s about time. The amounts wasted on cloud providers for apps that would run everything just fine on a single server, the effort wasted configuring their offerings, surreal.</div><br/></div></div><div id="42037226" class="c"><input type="checkbox" id="c-42037226" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#42036629">parent</a><span>|</span><a href="#42037152">prev</a><span>|</span><a href="#42036899">next</a><span>|</span><label class="collapse" for="c-42037226">[-]</label><label class="expand" for="c-42037226">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Because everyone insists on insanely distributed architectures, most people will never really see the point of Redis, which is that if it is running on the same machine as the application, it can respond in much less than a millisecond.<p>I don&#x27;t think this is a realistic scenario at all.<p>If you need a KV store, you want it to be the fastest by keeping it in-memory, you want it to run on each node, and you don&#x27;t care how much it cost to scale vertically, then you do not run a separate process on the same node. You just keep a plain old dictionary data structure. You do not waste cycles deserializing and serializing queries.<p>You only adopt something like Redis when you need far more than that, namely you need to have more than one process access shared data. That&#x27;s at the core of all Redis usecases.<p><a href="https:&#x2F;&#x2F;redis.io&#x2F;docs&#x2F;latest&#x2F;develop&#x2F;interact&#x2F;search-and-query&#x2F;query-use-cases&#x2F;" rel="nofollow">https:&#x2F;&#x2F;redis.io&#x2F;docs&#x2F;latest&#x2F;develop&#x2F;interact&#x2F;search-and-que...</a></div><br/><div id="42038161" class="c"><input type="checkbox" id="c-42038161" checked=""/><div class="controls bullet"><span class="by">nrdvana</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42037226">parent</a><span>|</span><a href="#42038470">next</a><span>|</span><label class="collapse" for="c-42038161">[-]</label><label class="expand" for="c-42038161">[2 more]</label></div><br/><div class="children"><div class="content">I develop and maintain multiple applications that use a worker pool, and are small enough to run on a single host.  We used pg for the user sessions, which get read and written on every single page request.  Some of our apps are Internet-facing, and web crawlers can create sessions that get read and written (recording recent pages) as they browse the site.  We switched to a redis service on the same host as the app and saw 3 main benefits: faster session loading and saving, less disk activity on the Pg server (so all other queries run faster) and less writes to the Pg WAL, so our backups require drastically less GB per day of retention.<p>After the significant success of the first conversion, we&#x27;ve been working to convert all the rest of our apps.<p>And no, host language data structures aren&#x27;t useful because they aren&#x27;t in shared memory between all the worker processes, and even if we found a module that implemented them in shared memory, we like to be able to preserve the sessions across a host restart, and then we&#x27;d need a process to save the data structures to disk and load them back, and by the time we did that we&#x27;d have just reinvented redis.</div><br/><div id="42039635" class="c"><input type="checkbox" id="c-42039635" checked=""/><div class="controls bullet"><span class="by">machine_coffee</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42038161">parent</a><span>|</span><a href="#42038470">next</a><span>|</span><label class="collapse" for="c-42039635">[-]</label><label class="expand" for="c-42039635">[1 more]</label></div><br/><div class="children"><div class="content">This is the best response so far. Session churn creates lots of db activity but lots of it is of low business value. Better to offload to a separate process.<p>Also session data is often Blobs which db&#x27;s don&#x27;t process as efficiently as columnar data.</div><br/></div></div></div></div><div id="42038470" class="c"><input type="checkbox" id="c-42038470" checked=""/><div class="controls bullet"><span class="by">zimpenfish</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42037226">parent</a><span>|</span><a href="#42038161">prev</a><span>|</span><a href="#42036899">next</a><span>|</span><label class="collapse" for="c-42038470">[-]</label><label class="expand" for="c-42038470">[1 more]</label></div><br/><div class="children"><div class="content">&gt; then you do not run a separate process on the same node<p>You might if you want the KV to persist between app restarts (for warm starts.)</div><br/></div></div></div></div><div id="42036899" class="c"><input type="checkbox" id="c-42036899" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42036629">parent</a><span>|</span><a href="#42037226">prev</a><span>|</span><a href="#42037174">next</a><span>|</span><label class="collapse" for="c-42036899">[-]</label><label class="expand" for="c-42036899">[2 more]</label></div><br/><div class="children"><div class="content">Over the network became feasible when HDD got markedly slower than NICs. It’s a nearer thing with NVMe.<p>I want a “redis” with something akin to the Consul client - which is a sidecar that participates in the Raft cluster and keeps up to date, cheaper lookups for all of the processes running on the same box.<p>The few bit of data we needed to invalidate on infrequent writes went into consul, and the rest went into the dumbest (as in boring, not foolish) memcached cluster you can imagine.<p>But as you say there was the network overhead, and what would be lovely is a 2 tier KV store that cached recent reads locally and distributed cache invalidation over Raft. Consistent hashing for the systems of record, broadcast data on put or delete so the local cache stays coherent.</div><br/><div id="42038731" class="c"><input type="checkbox" id="c-42038731" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#42036629">root</a><span>|</span><a href="#42036899">parent</a><span>|</span><a href="#42037174">next</a><span>|</span><label class="collapse" for="c-42038731">[-]</label><label class="expand" for="c-42038731">[1 more]</label></div><br/><div class="children"><div class="content">I always liked the idea of a distributed sidecar like DB.<p>I wonder if something like Cockroach DB might even work for small clusters.</div><br/></div></div></div></div><div id="42037174" class="c"><input type="checkbox" id="c-42037174" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#42036629">parent</a><span>|</span><a href="#42036899">prev</a><span>|</span><a href="#42036808">next</a><span>|</span><label class="collapse" for="c-42037174">[-]</label><label class="expand" for="c-42037174">[1 more]</label></div><br/><div class="children"><div class="content">&gt; [Redis] can respond in much less than a millisecond.<p>I have no idea how fast Redis can get, but it is entirely possible for an RDBMS to execute a query in well under a millisecond. I have instrumentation proving it. If everything is on the same machine, I would wager that IPC would ultimately be the bottleneck for both cases.</div><br/></div></div><div id="42036808" class="c"><input type="checkbox" id="c-42036808" checked=""/><div class="controls bullet"><span class="by">halfcat</span><span>|</span><a href="#42036629">parent</a><span>|</span><a href="#42037174">prev</a><span>|</span><a href="#42038701">next</a><span>|</span><label class="collapse" for="c-42036808">[-]</label><label class="expand" for="c-42036808">[1 more]</label></div><br/><div class="children"><div class="content">Django has caching built in with support for Redis, and it also has an in-memory caching option which they label as “not for production” (because if you have multiple instances  of Django serving requests, their in-memory caches will diverge which is...bad).<p>But for lots of cases, especially internal business tools, we can scale up a single instance for a long time, and this in-memory caching makes things super fast.<p>There’s a library, django-cachalot [1], that handles cache invalidation automatically any time a write happens to a table. That’s a rather blunt way to handle cache invalidation, but it’s wonderful because it will give you a boost for free with virtually no effort on your part, and if your internal business app has infrequent updates it basically runs entirely in RAM, and falls back to regular database queries if the data isn’t in the cache.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;noripyt&#x2F;django-cachalot">https:&#x2F;&#x2F;github.com&#x2F;noripyt&#x2F;django-cachalot</a></div><br/></div></div><div id="42038701" class="c"><input type="checkbox" id="c-42038701" checked=""/><div class="controls bullet"><span class="by">bufferoverflow</span><span>|</span><a href="#42036629">parent</a><span>|</span><a href="#42036808">prev</a><span>|</span><a href="#42036775">next</a><span>|</span><label class="collapse" for="c-42038701">[-]</label><label class="expand" for="c-42038701">[1 more]</label></div><br/><div class="children"><div class="content">Redis is not just in-memory.</div><br/></div></div><div id="42036775" class="c"><input type="checkbox" id="c-42036775" checked=""/><div class="controls bullet"><span class="by">hkon</span><span>|</span><a href="#42036629">parent</a><span>|</span><a href="#42038701">prev</a><span>|</span><a href="#42037255">next</a><span>|</span><label class="collapse" for="c-42036775">[-]</label><label class="expand" for="c-42036775">[1 more]</label></div><br/><div class="children"><div class="content">But then you can have it in memory in your app.</div><br/></div></div></div></div><div id="42037255" class="c"><input type="checkbox" id="c-42037255" checked=""/><div class="controls bullet"><span class="by">mbreese</span><span>|</span><a href="#42036629">prev</a><span>|</span><a href="#42038907">next</a><span>|</span><label class="collapse" for="c-42037255">[-]</label><label class="expand" for="c-42037255">[1 more]</label></div><br/><div class="children"><div class="content">Many arguments here have been from the Redis point of view (and are quite defensive). Of course Redis has niches where it is the better choice.<p>But that’s not what I thought the point of the article was. I think the main argument from the article can be summed up with this line:<p><i>&gt; PostgreSQL has a lot more capabilities than you may expect when you approach it from the perspective of just another SQL database or some mysterious entity that lives behind your ORM.</i><p>To me, this is the key line. If you’re only using your database from behind an ORM (any database, IMO), you’re probably missing functionality. And if you need to add another service (like Redis), you may be better served by using the database you already have setup, rather than adding another dependency.</div><br/></div></div><div id="42038907" class="c"><input type="checkbox" id="c-42038907" checked=""/><div class="controls bullet"><span class="by">jeeybee</span><span>|</span><a href="#42037255">prev</a><span>|</span><a href="#42036966">next</a><span>|</span><label class="collapse" for="c-42038907">[-]</label><label class="expand" for="c-42038907">[1 more]</label></div><br/><div class="children"><div class="content">PGQueuer provides job queuing, locking, and real-time notifications using PostgreSQL&#x27;s FOR UPDATE SKIP LOCKED and LISTEN&#x2F;NOTIFY. It&#x27;s a minimalist alternative for those already using PostgreSQL, avoiding the need for Redis.<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;janbjorge&#x2F;PGQueuer">https:&#x2F;&#x2F;github.com&#x2F;janbjorge&#x2F;PGQueuer</a><p>disclaimer: Im the auther.</div><br/></div></div><div id="42036966" class="c"><input type="checkbox" id="c-42036966" checked=""/><div class="controls bullet"><span class="by">tyre</span><span>|</span><a href="#42038907">prev</a><span>|</span><a href="#42037197">next</a><span>|</span><label class="collapse" for="c-42036966">[-]</label><label class="expand" for="c-42036966">[2 more]</label></div><br/><div class="children"><div class="content">It’s good to understand all of the things Postgres can do. It’s a powerful database.<p>A counterpoint is that the barrier to using redis is tiny and in exchange you have a very high performing system that has extensive library support and takes load from your primary database.<p>If you want to cache API responses, for example, could you do that in Postgres? Sure. And you could support things like TTLs with cron jobs sweeping stale cache values. Or you can just use redis.<p>Advisory locks are cool and useful. They can be a little problematic you want something like PGBouncer and you’re stuck between session advisory locks and transaction interleaving.<p>Having separate systems has downsides (network calls, availability, domain knowledge), but the tradeoffs with Redis of all things are pretty low.</div><br/><div id="42039721" class="c"><input type="checkbox" id="c-42039721" checked=""/><div class="controls bullet"><span class="by">asah</span><span>|</span><a href="#42036966">parent</a><span>|</span><a href="#42037197">next</a><span>|</span><label class="collapse" for="c-42039721">[-]</label><label class="expand" for="c-42039721">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s one less thing to manage in production. Start with postgresql then add niche systems for performance, scaling, cost.</div><br/></div></div></div></div><div id="42037197" class="c"><input type="checkbox" id="c-42037197" checked=""/><div class="controls bullet"><span class="by">TkTech</span><span>|</span><a href="#42036966">prev</a><span>|</span><a href="#42039667">next</a><span>|</span><label class="collapse" for="c-42037197">[-]</label><label class="expand" for="c-42037197">[3 more]</label></div><br/><div class="children"><div class="content">This is a fairly old article, but this has become a very common pattern. For 90% of projects that just need a task queue for sending email or generating reports, you&#x27;re not going to be doing millions of messages a second and anything that simplifies your stack is worth looking at. I&#x27;ve used these patterns so often to work around issues encountered with Celery that I&#x27;ve split them into their own framework, <a href="https:&#x2F;&#x2F;github.com&#x2F;TkTech&#x2F;chancy">https:&#x2F;&#x2F;github.com&#x2F;TkTech&#x2F;chancy</a> (feedback appreciated ;)<p>There are lots of these, several of which are commercial ventures so there&#x27;s definite interest behind it:<p><pre><code>    https:&#x2F;&#x2F;worker.graphile.org&#x2F; (Node.js)
    https:&#x2F;&#x2F;riverqueue.com&#x2F; (Go)
    https:&#x2F;&#x2F;github.com&#x2F;acaloiaro&#x2F;neoq (Go)
    https:&#x2F;&#x2F;github.com&#x2F;contribsys&#x2F;faktory (Go)
    https:&#x2F;&#x2F;github.com&#x2F;sorentwo&#x2F;oban (Elixir)
    https:&#x2F;&#x2F;github.com&#x2F;procrastinate-org&#x2F;procrastinate (Python)</code></pre></div><br/><div id="42039143" class="c"><input type="checkbox" id="c-42039143" checked=""/><div class="controls bullet"><span class="by">sali0</span><span>|</span><a href="#42037197">parent</a><span>|</span><a href="#42038144">next</a><span>|</span><label class="collapse" for="c-42039143">[-]</label><label class="expand" for="c-42039143">[1 more]</label></div><br/><div class="children"><div class="content">Another one for Node is PG-Boss (<a href="https:&#x2F;&#x2F;github.com&#x2F;timgit&#x2F;pg-boss">https:&#x2F;&#x2F;github.com&#x2F;timgit&#x2F;pg-boss</a>)</div><br/></div></div><div id="42038144" class="c"><input type="checkbox" id="c-42038144" checked=""/><div class="controls bullet"><span class="by">trescenzi</span><span>|</span><a href="#42037197">parent</a><span>|</span><a href="#42039143">prev</a><span>|</span><a href="#42039667">next</a><span>|</span><label class="collapse" for="c-42038144">[-]</label><label class="expand" for="c-42038144">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for sharing this. I’ve been trying to find a simple task queue and Huey is ok, but since I’m on Postgres and the tasks I’m queuing are like once an hour, anything redid based has always felt like overkill.</div><br/></div></div></div></div><div id="42039667" class="c"><input type="checkbox" id="c-42039667" checked=""/><div class="controls bullet"><span class="by">maxboone</span><span>|</span><a href="#42037197">prev</a><span>|</span><a href="#42037176">next</a><span>|</span><label class="collapse" for="c-42039667">[-]</label><label class="expand" for="c-42039667">[1 more]</label></div><br/><div class="children"><div class="content">Updates and replication becomes a whole lot trickier when you start using these functionalities in postgres.<p>Sure it&#x27;s possible, but I prefer sticking to more widespread use of postgres.</div><br/></div></div><div id="42037176" class="c"><input type="checkbox" id="c-42037176" checked=""/><div class="controls bullet"><span class="by">h1fra</span><span>|</span><a href="#42039667">prev</a><span>|</span><a href="#42036992">next</a><span>|</span><label class="collapse" for="c-42037176">[-]</label><label class="expand" for="c-42037176">[3 more]</label></div><br/><div class="children"><div class="content">I love postgres but it has some limitations:<p>- Want a KVstore? Do you know autovacuum? Do you know the connections pool limit? Do you want throughput or safety?<p>- Want a queue? is it sequential? Is it throttled? Is it fanout? Is it split by topic?<p>- Want a pubsub? do you care about more than once? do you care about losing messages? do you care about replaying messages?<p>- Want a lock? Do you know the connections pool limit (again)? Do you know about statement_timeout?<p>Yes, you can solve almost all issues listed above, but it&#x27;s not that trivial.</div><br/><div id="42037213" class="c"><input type="checkbox" id="c-42037213" checked=""/><div class="controls bullet"><span class="by">blackenedgem</span><span>|</span><a href="#42037176">parent</a><span>|</span><a href="#42037193">next</a><span>|</span><label class="collapse" for="c-42037213">[-]</label><label class="expand" for="c-42037213">[1 more]</label></div><br/><div class="children"><div class="content">Also: Will your implementation fall over if there&#x27;s a long running transaction that stops vacuum from removing tuples?</div><br/></div></div><div id="42037193" class="c"><input type="checkbox" id="c-42037193" checked=""/><div class="controls bullet"><span class="by">inquisitor27552</span><span>|</span><a href="#42037176">parent</a><span>|</span><a href="#42037213">prev</a><span>|</span><a href="#42036992">next</a><span>|</span><label class="collapse" for="c-42037193">[-]</label><label class="expand" for="c-42037193">[1 more]</label></div><br/><div class="children"><div class="content">this. it&#x27;s like the only thing the market hasn&#x27;t done yet is replace the nanny of my kids and make my wife jealous.</div><br/></div></div></div></div><div id="42036992" class="c"><input type="checkbox" id="c-42036992" checked=""/><div class="controls bullet"><span class="by">Latty</span><span>|</span><a href="#42037176">prev</a><span>|</span><a href="#42038549">next</a><span>|</span><label class="collapse" for="c-42036992">[-]</label><label class="expand" for="c-42036992">[1 more]</label></div><br/><div class="children"><div class="content">A big deal-breaker for Postgres pub&#x2F;sub is the messages have a maximum size of 8000 bytes. The recommended work around is to put data in a table and send IDs, but then you have to deal with garbage collecting that if you don&#x27;t want it to live forever, and you are adding operations to each message.<p>Obviously this can be fine, but for plenty of Redis use cases it really isn&#x27;t equivalent with that limit.</div><br/></div></div><div id="42038549" class="c"><input type="checkbox" id="c-42038549" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42036992">prev</a><span>|</span><a href="#42039353">next</a><span>|</span><label class="collapse" for="c-42038549">[-]</label><label class="expand" for="c-42038549">[1 more]</label></div><br/><div class="children"><div class="content">Queuing, locking, pub&#x2F;sub: check.<p>Caching, often the most important application of Redis: <i>oops</i>.<p>Updates in Postgres are notoriously more expensive than inserts (generate garbage, require vacuuming); durability guarantees, not important for caching, make writes significantly slower.<p>Automatic expiration is very convenient and fool-proof.</div><br/></div></div><div id="42039353" class="c"><input type="checkbox" id="c-42039353" checked=""/><div class="controls bullet"><span class="by">vichle</span><span>|</span><a href="#42038549">prev</a><span>|</span><a href="#42036786">next</a><span>|</span><label class="collapse" for="c-42039353">[-]</label><label class="expand" for="c-42039353">[2 more]</label></div><br/><div class="children"><div class="content">To articulate the articles point further: Start with pg, switch to redis when the need arises.<p>Keep the number of moving parts as low as possible.</div><br/><div id="42039708" class="c"><input type="checkbox" id="c-42039708" checked=""/><div class="controls bullet"><span class="by">Havoc</span><span>|</span><a href="#42039353">parent</a><span>|</span><a href="#42036786">next</a><span>|</span><label class="collapse" for="c-42039708">[-]</label><label class="expand" for="c-42039708">[1 more]</label></div><br/><div class="children"><div class="content">Redis isnt exactly hard to deploy. May as well just use it instead of planning for a switch later that may come with god knows what unforeseen side effects</div><br/></div></div></div></div><div id="42036786" class="c"><input type="checkbox" id="c-42036786" checked=""/><div class="controls bullet"><span class="by">mannyv</span><span>|</span><a href="#42039353">prev</a><span>|</span><a href="#42038357">next</a><span>|</span><label class="collapse" for="c-42036786">[-]</label><label class="expand" for="c-42036786">[16 more]</label></div><br/><div class="children"><div class="content">Lets see pgsql deal with 15000 client connections.</div><br/><div id="42039735" class="c"><input type="checkbox" id="c-42039735" checked=""/><div class="controls bullet"><span class="by">asah</span><span>|</span><a href="#42036786">parent</a><span>|</span><a href="#42036834">next</a><span>|</span><label class="collapse" for="c-42039735">[-]</label><label class="expand" for="c-42039735">[1 more]</label></div><br/><div class="children"><div class="content">Just use connection pooling, which is available point&#x2F;click as AWS RDS Proxy.</div><br/></div></div><div id="42036834" class="c"><input type="checkbox" id="c-42036834" checked=""/><div class="controls bullet"><span class="by">halfcat</span><span>|</span><a href="#42036786">parent</a><span>|</span><a href="#42039735">prev</a><span>|</span><a href="#42038357">next</a><span>|</span><label class="collapse" for="c-42036834">[-]</label><label class="expand" for="c-42036834">[14 more]</label></div><br/><div class="children"><div class="content">It’s really shocking how wide the difference is here between Postgres and MySQL.<p>One of the Planetscale guys did a podcast and said at GitHub every MySQL instance is doing like 50k+ connections while if you need more than 100 connections in Postgres you already need PgBouncer.</div><br/><div id="42037811" class="c"><input type="checkbox" id="c-42037811" checked=""/><div class="controls bullet"><span class="by">throwaway313373</span><span>|</span><a href="#42036786">root</a><span>|</span><a href="#42036834">parent</a><span>|</span><a href="#42037103">next</a><span>|</span><label class="collapse" for="c-42037811">[-]</label><label class="expand" for="c-42037811">[3 more]</label></div><br/><div class="children"><div class="content">Why is it &quot;shocking&quot;?<p>It&#x27;s just an architectural decision to spawn a process per connection that Postgres made long time ago.<p>It&#x27;s a tradeoff like most decisions.<p>Back in the days MySQL had huge issues with scaling to multi-core systems (maybe they fixed it now, I haven&#x27;t used MySQL for a long time) while Postgres never had this problem.<p>When designing an application around Postgres you just have to take into account that:<p>1. opening a new connection is rather expensive, so you should have a connection pool<p>2. opening too many connections is problematic, so you should keep the size of your pool rather small and return connections back into the pool ASAP<p>That&#x27;s it.<p>It&#x27;s not that hard in practice.</div><br/><div id="42038447" class="c"><input type="checkbox" id="c-42038447" checked=""/><div class="controls bullet"><span class="by">brianaker</span><span>|</span><a href="#42036786">root</a><span>|</span><a href="#42037811">parent</a><span>|</span><a href="#42037103">next</a><span>|</span><label class="collapse" for="c-42038447">[-]</label><label class="expand" for="c-42038447">[2 more]</label></div><br/><div class="children"><div class="content">MySQL never had a problem with scaling to multi-core systems; Linux on the other hand did have a problem and its problems became everyone&#x27;s problems. In the early 2000&#x27;s the answer to multi-core Linux issues was to buy a system running one of the commercial UNIX. By 2006 or so this became a non-issue for Linux ( for the most part ).<p>Postgres uses an old design model which predates threads; I have no idea if they have made any progress in updating their design. In the past I have heard the core devs talk about how difficult it would be to do this.<p>Oracle Database moved to a hybrid process&#x2F;thread model at some point, this is the superior solution ( I have no idea if it was done well or not, but from standpoint of how to achieve better leverage of CPU vs IO, this is the way ).<p>If the PG devs had enough time&#x2F;money, I am sure they would move towards a hybrid model where the focus would be on processor affinity with IO being all tied to events.</div><br/><div id="42039033" class="c"><input type="checkbox" id="c-42039033" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#42036786">root</a><span>|</span><a href="#42038447">parent</a><span>|</span><a href="#42037103">next</a><span>|</span><label class="collapse" for="c-42039033">[-]</label><label class="expand" for="c-42039033">[1 more]</label></div><br/><div class="children"><div class="content">Years back (around 10) mysql did have multiple instances of false sharing[0].<p>Unrelated to mysql - I do consider using redis in any capacity a blunder (it&#x27;s likely ok for nodejs users, I suppose)<p>[0]: <a href="http:&#x2F;&#x2F;dimitrik.free.fr&#x2F;MySQL_Connect_2013&#x2F;MySQL_Perf-Connect_2013-Tutorial-dim.pdf" rel="nofollow">http:&#x2F;&#x2F;dimitrik.free.fr&#x2F;MySQL_Connect_2013&#x2F;MySQL_Perf-Connec...</a></div><br/></div></div></div></div></div></div><div id="42037103" class="c"><input type="checkbox" id="c-42037103" checked=""/><div class="controls bullet"><span class="by">CAP_NET_ADMIN</span><span>|</span><a href="#42036786">root</a><span>|</span><a href="#42036834">parent</a><span>|</span><a href="#42037811">prev</a><span>|</span><a href="#42038357">next</a><span>|</span><label class="collapse" for="c-42037103">[-]</label><label class="expand" for="c-42037103">[10 more]</label></div><br/><div class="children"><div class="content">Why would you do 50k+ connections if they can&#x27;t be active all at once either way? Unless you have 50k+ cores and IO beefy enough not to get overwhelmed due to that.<p>You can have as much connections as you want, but you&#x27;ll have to trade it for having lower work mem numbers, which hurts performance. Traditional advice is to keep it below 500 per PostgreSQL instance (I&#x27;d say physical host).<p>I&#x27;ve ran dozens of micro services handling thousands of requests per second with a total connection limit of around 200 of which most was still unused - all without any server-side pooler.</div><br/><div id="42037156" class="c"><input type="checkbox" id="c-42037156" checked=""/><div class="controls bullet"><span class="by">samlambert</span><span>|</span><a href="#42036786">root</a><span>|</span><a href="#42037103">parent</a><span>|</span><a href="#42038357">next</a><span>|</span><label class="collapse" for="c-42037156">[-]</label><label class="expand" for="c-42037156">[9 more]</label></div><br/><div class="children"><div class="content">because people run large amounts of front ends and workers that create a significant amount of connections. it doesn&#x27;t matter if they are all active.</div><br/><div id="42037817" class="c"><input type="checkbox" id="c-42037817" checked=""/><div class="controls bullet"><span class="by">throwaway313373</span><span>|</span><a href="#42036786">root</a><span>|</span><a href="#42037156">parent</a><span>|</span><a href="#42038357">next</a><span>|</span><label class="collapse" for="c-42037817">[-]</label><label class="expand" for="c-42037817">[8 more]</label></div><br/><div class="children"><div class="content">Why would you want every &quot;frontend&quot; keep an open connection all the time?<p>&gt; it doesn&#x27;t matter if they are all active<p>It does, if the connection is inactive (doesn&#x27;t hold an open transaction) you should close it or return it to the pool.</div><br/><div id="42037839" class="c"><input type="checkbox" id="c-42037839" checked=""/><div class="controls bullet"><span class="by">samlambert</span><span>|</span><a href="#42036786">root</a><span>|</span><a href="#42037817">parent</a><span>|</span><a href="#42038357">next</a><span>|</span><label class="collapse" for="c-42037839">[-]</label><label class="expand" for="c-42037839">[7 more]</label></div><br/><div class="children"><div class="content">so you are suggesting you close a connection between queries?</div><br/><div id="42038200" class="c"><input type="checkbox" id="c-42038200" checked=""/><div class="controls bullet"><span class="by">throwaway313373</span><span>|</span><a href="#42036786">root</a><span>|</span><a href="#42037839">parent</a><span>|</span><a href="#42038357">next</a><span>|</span><label class="collapse" for="c-42038200">[-]</label><label class="expand" for="c-42038200">[6 more]</label></div><br/><div class="children"><div class="content">Between queries in the same transaction? No<p>Between transactions? Yes, absolutely<p>In fact, many libraries do it automatically.<p>For example, SQLAlchemy doc explicitly says [0]:<p>&gt; After the commit, the Connection object associated with that transaction is closed, causing its underlying DBAPI connection to be released back to the connection pool associated with the Engine to which the Session is bound.<p>I expect other reasonably sane libs for working with transactional databases do the same.<p>So, if you are doing pooling correctly, you can only run out of available connections if you want to have a lot of long running transactions.<p>So, why would you want every of your 50k frontends keep an open transaction simultaneously?<p>[0] <a href="https:&#x2F;&#x2F;docs.sqlalchemy.org&#x2F;en&#x2F;20&#x2F;orm&#x2F;session_basics.html#committing" rel="nofollow">https:&#x2F;&#x2F;docs.sqlalchemy.org&#x2F;en&#x2F;20&#x2F;orm&#x2F;session_basics.html#co...</a></div><br/><div id="42038304" class="c"><input type="checkbox" id="c-42038304" checked=""/><div class="controls bullet"><span class="by">nrdvana</span><span>|</span><a href="#42036786">root</a><span>|</span><a href="#42038200">parent</a><span>|</span><a href="#42038357">next</a><span>|</span><label class="collapse" for="c-42038304">[-]</label><label class="expand" for="c-42038304">[5 more]</label></div><br/><div class="children"><div class="content">Because there&#x27;s an overhead to make a connection, authenticate, set the default parameters on the connection, etc.  I&#x27;ve never seen a framework that closed db connections between requests.<p>Of course, the better design is to write a nonblocking worker that can run async requests on a single connection, and not need a giant pool of blocking workers, but that is a major architecture plan that can&#x27;t be added late in a project that started as blocking worker pools.  MySQL has always fit well with those large blocking worker pools.  Postgres less so.</div><br/><div id="42038351" class="c"><input type="checkbox" id="c-42038351" checked=""/><div class="controls bullet"><span class="by">throwaway313373</span><span>|</span><a href="#42036786">root</a><span>|</span><a href="#42038304">parent</a><span>|</span><a href="#42038357">next</a><span>|</span><label class="collapse" for="c-42038351">[-]</label><label class="expand" for="c-42038351">[4 more]</label></div><br/><div class="children"><div class="content">As I said, you can return the connection to the connection pool.<p>From the perspective of keeping the number of open connections low it doesn&#x27;t really matter if you close it or return to the pool, because in either case the connection becomes available to other clients.</div><br/><div id="42038692" class="c"><input type="checkbox" id="c-42038692" checked=""/><div class="controls bullet"><span class="by">nrdvana</span><span>|</span><a href="#42036786">root</a><span>|</span><a href="#42038351">parent</a><span>|</span><a href="#42038634">next</a><span>|</span><label class="collapse" for="c-42038692">[-]</label><label class="expand" for="c-42038692">[2 more]</label></div><br/><div class="children"><div class="content">I might not be understanding what you&#x27;re pointing out here.  It sounds to me like sqlalchemy is talking about a pool of connections within one process, in which case releasing back to that pool does <i>not</i> close the connection by that process to the database.  Parent comment is talking about one connection per process with 50k processes.  My comment was that you don&#x27;t need that many processes if each process can handle hundreds of web requests asynchronously.<p>If you are saying that a connection pool can be shared <i>between processes</i> without pgbouncer, that is news to me.</div><br/><div id="42038948" class="c"><input type="checkbox" id="c-42038948" checked=""/><div class="controls bullet"><span class="by">throwaway313373</span><span>|</span><a href="#42036786">root</a><span>|</span><a href="#42038692">parent</a><span>|</span><a href="#42038634">next</a><span>|</span><label class="collapse" for="c-42038948">[-]</label><label class="expand" for="c-42038948">[1 more]</label></div><br/><div class="children"><div class="content">Of course, you&#x27;re right, it is not possible to to share a connection pool between processes without pgbouncer.<p>&gt; Parent comment is talking about one connection per process with 50k processes.<p>It is actually not clear what parent comment was talking about. I don&#x27;t know what exactly did they mean by &quot;front ends&quot;.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42038357" class="c"><input type="checkbox" id="c-42038357" checked=""/><div class="controls bullet"><span class="by">pm90</span><span>|</span><a href="#42036786">prev</a><span>|</span><a href="#42037214">next</a><span>|</span><label class="collapse" for="c-42038357">[-]</label><label class="expand" for="c-42038357">[1 more]</label></div><br/><div class="children"><div class="content">The problem with this is that eventually the database becomes everything to everyone. You start seeing the frontend UIs suffer due to errors with unrelated tables or table locking operations (like migrations).<p>Redis is pretty awesome. So is rabbitmq. When you’re a &lt; 100 person startup, probably stick with postgres. Over 100 and I would seriously start considering adding more specialized platform tools.</div><br/></div></div><div id="42037214" class="c"><input type="checkbox" id="c-42037214" checked=""/><div class="controls bullet"><span class="by">throwaway106382</span><span>|</span><a href="#42038357">prev</a><span>|</span><a href="#42037024">next</a><span>|</span><label class="collapse" for="c-42037214">[-]</label><label class="expand" for="c-42037214">[1 more]</label></div><br/><div class="children"><div class="content">Back in the day Id always have redis around for my rails cache.  We already had it for cache so also using it for job queues and sidekiq was a no brainer.<p>These days with m.2 disks and database based cacheing (solid cache) and first class support in Rails, and postgres able to handle the job queues and things like GoodJob the choice isn’t so clear cut to “just use redis”.<p>I won’t be replacing sidekiq in our current production app any time soon but any new projects would get some serious consideration.</div><br/></div></div><div id="42037024" class="c"><input type="checkbox" id="c-42037024" checked=""/><div class="controls bullet"><span class="by">greatgib</span><span>|</span><a href="#42037214">prev</a><span>|</span><a href="#42036695">next</a><span>|</span><label class="collapse" for="c-42037024">[-]</label><label class="expand" for="c-42037024">[2 more]</label></div><br/><div class="children"><div class="content">I would like to be able to use pgsql for application lock but the api of advisory lock is not good for that un my opinion:<p>There is no namespace or table for that. Meaning that the single common locking space will be shared by all the users&#x2F;apps of your database.<p>The key has to be an int with a quite low limit (like 30k) if  my memory is good. So you can&#x27;t use the key to use for namespacing.</div><br/><div id="42039588" class="c"><input type="checkbox" id="c-42039588" checked=""/><div class="controls bullet"><span class="by">foreigner</span><span>|</span><a href="#42037024">parent</a><span>|</span><a href="#42036695">next</a><span>|</span><label class="collapse" for="c-42039588">[-]</label><label class="expand" for="c-42039588">[1 more]</label></div><br/><div class="children"><div class="content">The key is two ints, not one. I use the first int for namespacing.</div><br/></div></div></div></div><div id="42036695" class="c"><input type="checkbox" id="c-42036695" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#42037024">prev</a><span>|</span><a href="#42038385">next</a><span>|</span><label class="collapse" for="c-42036695">[-]</label><label class="expand" for="c-42036695">[1 more]</label></div><br/><div class="children"><div class="content">Pretty pointless article without doing performance benchmarks.<p>The entire point of Redis that it trades durability and convenience for performance.</div><br/></div></div><div id="42038385" class="c"><input type="checkbox" id="c-42038385" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#42036695">prev</a><span>|</span><a href="#42038167">next</a><span>|</span><label class="collapse" for="c-42038385">[-]</label><label class="expand" for="c-42038385">[1 more]</label></div><br/><div class="children"><div class="content">it’s generally better to avoid the distributed systems problems if you can. Postgres is very flexible and you get very far with it if you use all it has to offer</div><br/></div></div><div id="42038167" class="c"><input type="checkbox" id="c-42038167" checked=""/><div class="controls bullet"><span class="by">onoke</span><span>|</span><a href="#42038385">prev</a><span>|</span><a href="#42039023">next</a><span>|</span><label class="collapse" for="c-42038167">[-]</label><label class="expand" for="c-42038167">[2 more]</label></div><br/><div class="children"><div class="content">The point of view from over 30y carres. I love Postgre, I&#x27;ve known Redis recent. Each have great functions. Every products have unique functions at their early season, but getting fat by adding similarity functions with others. Implementing function is not difficult in there because it is a software, but sometimes it makes lose its the first strength. I&#x27;ve loved Postgre since its v3, but once it had been pushed by MySQL, because of LAMP boom. I wish Postgre does not be a fat system alike Oracle. And also want Redis to take the right direction.
I mean Postgre did not need to support pub&#x2F;sub and so on.</div><br/><div id="42038390" class="c"><input type="checkbox" id="c-42038390" checked=""/><div class="controls bullet"><span class="by">nrdvana</span><span>|</span><a href="#42038167">parent</a><span>|</span><a href="#42039023">next</a><span>|</span><label class="collapse" for="c-42038390">[-]</label><label class="expand" for="c-42038390">[1 more]</label></div><br/><div class="children"><div class="content">Actually pub&#x2F;sub works best when you can commit it in a transaction along with your data changes.  When they are separate systems, you get a race condition where you could commit the change but crash before the event gets published.</div><br/></div></div></div></div><div id="42039023" class="c"><input type="checkbox" id="c-42039023" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#42038167">prev</a><span>|</span><a href="#42036662">next</a><span>|</span><label class="collapse" for="c-42039023">[-]</label><label class="expand" for="c-42039023">[1 more]</label></div><br/><div class="children"><div class="content">Reminder that redis has been forked into valkey - <a href="https:&#x2F;&#x2F;valkey.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;valkey.io&#x2F;</a></div><br/></div></div><div id="42036662" class="c"><input type="checkbox" id="c-42036662" checked=""/><div class="controls bullet"><span class="by">Svoka</span><span>|</span><a href="#42039023">prev</a><span>|</span><a href="#42038098">next</a><span>|</span><label class="collapse" for="c-42036662">[-]</label><label class="expand" for="c-42036662">[1 more]</label></div><br/><div class="children"><div class="content">Consider using SQLite on NAS id you don&#x27;t care about performance to this extent.</div><br/></div></div><div id="42038098" class="c"><input type="checkbox" id="c-42038098" checked=""/><div class="controls bullet"><span class="by">aaronsnoswell</span><span>|</span><a href="#42036662">prev</a><span>|</span><a href="#42036724">next</a><span>|</span><label class="collapse" for="c-42038098">[-]</label><label class="expand" for="c-42038098">[1 more]</label></div><br/><div class="children"><div class="content">Answer: No.</div><br/></div></div><div id="42036724" class="c"><input type="checkbox" id="c-42036724" checked=""/><div class="controls bullet"><span class="by">halfcat</span><span>|</span><a href="#42038098">prev</a><span>|</span><a href="#42036991">next</a><span>|</span><label class="collapse" for="c-42036724">[-]</label><label class="expand" for="c-42036724">[5 more]</label></div><br/><div class="children"><div class="content">The queue approach of `SELECT...FOR UPDATE SKIP LOCKED` is great for low throughput needs. One thing to note: as your throughput increases you will have to deal with bloat.<p>When the processed message rows are deleted, the pages sitting on the disk are not deleted until vacuum is run. If you run an online vacuum it doesn’t delete the page from disk, and a full vacuum (that will free up the disk space) locks the database while it completes the vacuum (which if you’re now dealing with high throughput, is not great).<p>One approach to address bloat without dealing with vacuum is to setup a timestamp-based partition on your queue table. This way you just drop old partitions and it frees the disk space without needing vacuum.</div><br/><div id="42036890" class="c"><input type="checkbox" id="c-42036890" checked=""/><div class="controls bullet"><span class="by">shakow</span><span>|</span><a href="#42036724">parent</a><span>|</span><a href="#42037019">next</a><span>|</span><label class="collapse" for="c-42036890">[-]</label><label class="expand" for="c-42036890">[3 more]</label></div><br/><div class="children"><div class="content">To add some feedback as someone whose company replaced redis with PgSQL after I lobbied for it (leveraging my experience using it in bioinfo HPC beforehand):<p>- agreed, autovacuum is definitely something to keep a close watch on – but as long as disk I&#x2F;Os are fast enough (i.e. not EBS), our queue tables could fill the space freed for PgSQL but not the OS (the non full VACUUM mentioned by my GP), so in the end, assuming the queue did not grow infinitely, actual disk usage stabilized, and we never had to VACUUM FULL outside of buggy (on our side) situations;<p>- high-throughput is relative: we ran in the range of hundreds to thousands of tasks per second without any issue nor any particular customization, so sure, PgSQL will not hold the load if you are Google, but I&#x27;d bet it should satisfy the needs of at least up to the last centile of companies.<p>- I like your idea about timestamp-defined partitions, I will definitely keep this one in mind if the need arises.<p>Now on the pros:<p>- being able to store &amp; manipulate basically all the data handled by our stack from a single source sounds like a minute detail, but actually helps a lot when we have to debug an issue;<p>- being able to use virtually any language and still be able to access all the persistent data from our stack from a single source revealed itself to be an unexpected advantage to develop a quick&#x27;n dirty e.g. python&#x2F;nim&#x2F;racket script to explore data&#x2F;debug&#x2F;generate stats&#x2F;etc.;<p>- our PgSQL machines ran much better “by themselves” than we feared at first, and finally were far from being the main point of contention on day-to-day ops – in the end we just altered a couple of settings and just... let them be;<p>- PgSQL provides a lot of tools to inspect it live, which provides additional help to identify bottlenecks in (i) your server setup and (ii) your stack;<p>- PgSQL support of JSON&#x2F;JSONB is actually very good, and very helpful to store that hard-to-normal-form-ize last part of your data.</div><br/><div id="42036984" class="c"><input type="checkbox" id="c-42036984" checked=""/><div class="controls bullet"><span class="by">halfcat</span><span>|</span><a href="#42036724">root</a><span>|</span><a href="#42036890">parent</a><span>|</span><a href="#42037019">next</a><span>|</span><label class="collapse" for="c-42036984">[-]</label><label class="expand" for="c-42036984">[2 more]</label></div><br/><div class="children"><div class="content">Great response!<p>&gt; <i>”PgSQL provides a lot of tools to inspect it live”</i><p>Any particular tools you like for this?</div><br/><div id="42037119" class="c"><input type="checkbox" id="c-42037119" checked=""/><div class="controls bullet"><span class="by">shakow</span><span>|</span><a href="#42036724">root</a><span>|</span><a href="#42036984">parent</a><span>|</span><a href="#42037019">next</a><span>|</span><label class="collapse" for="c-42037119">[-]</label><label class="expand" for="c-42037119">[1 more]</label></div><br/><div class="children"><div class="content">“Tool” may not be the right word; but being able to live monitor the vacuumer, to understand what table was taking how much space and why, to track min&#x2F;mean&#x2F;max execution time of queries, and, more generally, all the internal metrics that PgSQL exposes through a couple of SELECT has been a boon when debugging or optimizing.</div><br/></div></div></div></div></div></div><div id="42037019" class="c"><input type="checkbox" id="c-42037019" checked=""/><div class="controls bullet"><span class="by">FreakLegion</span><span>|</span><a href="#42036724">parent</a><span>|</span><a href="#42036890">prev</a><span>|</span><a href="#42036991">next</a><span>|</span><label class="collapse" for="c-42037019">[-]</label><label class="expand" for="c-42037019">[1 more]</label></div><br/><div class="children"><div class="content">Plain vacuum is generally all you want. At that point the space is freed for new inserts and updates to the table. Full vacuum is for giving the space back to the OS, which rarely makes sense if you&#x27;ll still be writing more rows. In cases where freeing to the OS really is what you need, though, use something like pg_repack.</div><br/></div></div></div></div><div id="42036991" class="c"><input type="checkbox" id="c-42036991" checked=""/><div class="controls bullet"><span class="by">JackSlateur</span><span>|</span><a href="#42036724">prev</a><span>|</span><a href="#42037052">next</a><span>|</span><label class="collapse" for="c-42036991">[-]</label><label class="expand" for="c-42036991">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Do you need pgsql ? Redis does queuing, locking and pub&#x2F;sub&quot;<p>(I&#x27;ve not read the article: the title alone seems like an orange vs apple sales)</div><br/></div></div><div id="42037052" class="c"><input type="checkbox" id="c-42037052" checked=""/><div class="controls bullet"><span class="by">noident</span><span>|</span><a href="#42036991">prev</a><span>|</span><a href="#42037033">next</a><span>|</span><label class="collapse" for="c-42037052">[-]</label><label class="expand" for="c-42037052">[2 more]</label></div><br/><div class="children"><div class="content">Do you need oranges? Apples have seeds, skin, and grow on trees.<p>Redis has many niches where it is more suitable than a database. In particular, the low latency and simple concurrency model make it a perfect choice for building shared token buckets, for example. For simple operations that need to be executed many times at low latency, SQL is usually not the best choice. And sometimes, you really just need K&#x2F;V and don&#x27;t want to deal with schema migrations, DBA chores, debugging auto vacuum...<p>&gt;Advisory locks allow you to leverage the same locking engine PostgreSQL uses internally for your own application-defined purposes.<p>That is like telling me that I can get across the river in a nuclear submarine instead of walking over the footbridge. PostgreSQL locks cause me plenty of headaches already without my application logic being dependent on them.</div><br/><div id="42037605" class="c"><input type="checkbox" id="c-42037605" checked=""/><div class="controls bullet"><span class="by">Tostino</span><span>|</span><a href="#42037052">parent</a><span>|</span><a href="#42037033">next</a><span>|</span><label class="collapse" for="c-42037605">[-]</label><label class="expand" for="c-42037605">[1 more]</label></div><br/><div class="children"><div class="content">Disagree. If you need a global locking mechanism that all of your back ends can agree on without setting up an additional service, advisory locks are a totally valid use case. All of your back ends already have access to the DB, why bring in another whole service for just the locking that is required to implement some small thing in your giant SaaS product? Just lean on PG and you can go really far.</div><br/></div></div></div></div><div id="42037033" class="c"><input type="checkbox" id="c-42037033" checked=""/><div class="controls bullet"><span class="by">surfingdino</span><span>|</span><a href="#42037052">prev</a><span>|</span><a href="#42038352">next</a><span>|</span><label class="collapse" for="c-42037033">[-]</label><label class="expand" for="c-42037033">[1 more]</label></div><br/><div class="children"><div class="content">I mean, yes, but a fairer comparison would be Redis vs. Memcache. Redis provides functionality missing from Memcache, it is not meant to be an alternative to Postgresql. This article reminds me of one about configuring MySQL to act like a NoSQL datastore, I read when MongoDB hit the limelight. Apples to organges.</div><br/></div></div></div></div></div></div></div></body></html>