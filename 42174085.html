<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732179670512" as="style"/><link rel="stylesheet" href="styles.css?v=1732179670512"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://zed.dev/blog/zed-decoded-rope-optimizations-part-1">Bit-twiddling optimizations in Zed&#x27;s Rope</a> <span class="domain">(<a href="https://zed.dev">zed.dev</a>)</span></div><div class="subtext"><span>misternugget</span> | <span>41 comments</span></div><br/><div><div id="42198090" class="c"><input type="checkbox" id="c-42198090" checked=""/><div class="controls bullet"><span class="by">rgrmrts</span><span>|</span><a href="#42201231">next</a><span>|</span><label class="collapse" for="c-42198090">[-]</label><label class="expand" for="c-42198090">[13 more]</label></div><br/><div class="children"><div class="content">I really like all the blog posts and videos the Zed team has put out, thank you if you’re reading this!<p>Unrelated to this specific post I’m such a fan of Zed. It’s the first feature complete text editor in recent memory that I’ve truly enjoyed using (i.e. it stays out of the way, is really fast, feels well engineered). I’m coming to Zed after years of Emacs which I still have love for but no longer feels like a competitive piece of software (it does not take full advantage of how good computers are today, e.g. gpu rendering or multicore). I really hope Zed stays a fast and lightweight text editor instead of becoming some bloated growth-at-all-cost VC ware (not that they’ve exhibited any signs of that happening). I’d also happily pay for Zed without a subscription based thing for access to LLM features (which I do not use).</div><br/><div id="42198366" class="c"><input type="checkbox" id="c-42198366" checked=""/><div class="controls bullet"><span class="by">seanw444</span><span>|</span><a href="#42198090">parent</a><span>|</span><a href="#42201231">next</a><span>|</span><label class="collapse" for="c-42198366">[-]</label><label class="expand" for="c-42198366">[12 more]</label></div><br/><div class="children"><div class="content">&gt; it does not take full advantage of how good computers are today, e.g. gpu rendering or multicore<p>Why does Emacs need that though? I hear people say this all the time and I don&#x27;t get it. Multicore kind of works against the structure that Emacs touts as a feature. And GPU rendering? In many applications, I totally agree with these complaints. But it&#x27;s a text editor.<p>I tried Zed myself, and it&#x27;s good. But it doesn&#x27;t dethrone Emacs (for me personally).</div><br/><div id="42199042" class="c"><input type="checkbox" id="c-42199042" checked=""/><div class="controls bullet"><span class="by">vinkelhake</span><span>|</span><a href="#42198090">root</a><span>|</span><a href="#42198366">parent</a><span>|</span><a href="#42198660">next</a><span>|</span><label class="collapse" for="c-42199042">[-]</label><label class="expand" for="c-42199042">[3 more]</label></div><br/><div class="children"><div class="content">&gt; But it&#x27;s a text editor.<p>Long time emacs user here (+20 years, yikes). I&#x27;ve used it on all kinds of computers during this time. Even a relatively modest computer from 2024 is an absolute beast compared to something from the year 2000.<p>With that said, there are text editing operations that can cause it to grind to a complete halt, especially working with large files (or very long lines). And it <i>shouldn&#x27;t</i>, you know? I think emacs users sort of internalize which operations they should avoid. It&#x27;s kind of ridiculous to have to do that in a text editor with the massive amounts of compute that our computers have today.</div><br/><div id="42199274" class="c"><input type="checkbox" id="c-42199274" checked=""/><div class="controls bullet"><span class="by">donio</span><span>|</span><a href="#42198090">root</a><span>|</span><a href="#42199042">parent</a><span>|</span><a href="#42198660">next</a><span>|</span><label class="collapse" for="c-42199274">[-]</label><label class="expand" for="c-42199274">[2 more]</label></div><br/><div class="children"><div class="content">&gt; (or very long lines)<p>Long line handling has greatly improved in emacs-29. Multi-megabyte lines are not a problem anymore.</div><br/><div id="42199408" class="c"><input type="checkbox" id="c-42199408" checked=""/><div class="controls bullet"><span class="by">canucker2016</span><span>|</span><a href="#42198090">root</a><span>|</span><a href="#42199274">parent</a><span>|</span><a href="#42198660">next</a><span>|</span><label class="collapse" for="c-42199408">[-]</label><label class="expand" for="c-42199408">[1 more]</label></div><br/><div class="children"><div class="content">from Emacs 29.1 NEWS file, <a href="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;emacs-mirror&#x2F;emacs&#x2F;refs&#x2F;heads&#x2F;master&#x2F;etc&#x2F;NEWS.29" rel="nofollow">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;emacs-mirror&#x2F;emacs&#x2F;refs&#x2F;he...</a><p><pre><code>    ** Emacs is now capable of editing files with very long lines.
    The display of long lines has been optimized, and Emacs should no
    longer choke when a buffer on display contains long lines.  The
    variable &#x27;long-line-threshold&#x27; controls whether and when these display
    optimizations are in effect.

    A companion variable &#x27;large-hscroll-threshold&#x27; controls when another
    set of display optimizations are in effect, which are aimed
    specifically at speeding up display of long lines that are truncated
    on display.</code></pre></div><br/></div></div></div></div></div></div><div id="42198660" class="c"><input type="checkbox" id="c-42198660" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42198090">root</a><span>|</span><a href="#42198366">parent</a><span>|</span><a href="#42199042">prev</a><span>|</span><a href="#42198929">next</a><span>|</span><label class="collapse" for="c-42198660">[-]</label><label class="expand" for="c-42198660">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Multicore kind of works against the structure that Emacs touts as a feature.<p>I have consistent issues with emacs locking up when executing network requests. I&#x27;m sure there&#x27;s a specific bug that could be hunted down and addressed, but this sort of thing shouldn&#x27;t happen much in an editor that&#x27;s multicore by default.<p>I&#x27;m not trying to dismiss emacs&#x27; reasoning, of course, but I can understand being disgruntled with it.<p>The actual rendering I&#x27;ve been quite please by, though!</div><br/><div id="42198822" class="c"><input type="checkbox" id="c-42198822" checked=""/><div class="controls bullet"><span class="by">rgrmrts</span><span>|</span><a href="#42198090">root</a><span>|</span><a href="#42198660">parent</a><span>|</span><a href="#42198929">next</a><span>|</span><label class="collapse" for="c-42198822">[-]</label><label class="expand" for="c-42198822">[5 more]</label></div><br/><div class="children"><div class="content">Yeah this is one reason, or Emacs freezing for up to a minute when updating packages. Also when using an LSP I notice latency.<p>I use Emacs GUI (outside of the terminal) and comparing performance for rending to something like Zed or Sublime is definitely noticeable. It’s great that Emacs is so resource efficient but sometimes I wish it used more of my beefy computer(s).<p>Like I said I still love Emacs and it’s okay for it to make a different set of trade-offs. I honestly didn’t think I’d ever switch editors but here we are!</div><br/><div id="42199061" class="c"><input type="checkbox" id="c-42199061" checked=""/><div class="controls bullet"><span class="by">karthink</span><span>|</span><a href="#42198090">root</a><span>|</span><a href="#42198822">parent</a><span>|</span><a href="#42198923">next</a><span>|</span><label class="collapse" for="c-42199061">[-]</label><label class="expand" for="c-42199061">[2 more]</label></div><br/><div class="children"><div class="content">Removing the interpreter lock for a few specialized tasks (without sweeping runtime changes to Emacs) would be enough to fix most of these issues -- parsing JSON from process output into lisp data in a background thread is one candidate. [1]<p>Installing packages does not need to block either, there is no architectural limitation here.  The Elpaca package manager for Emacs provides async, parallel package updates. Loading packages into the Lisp image will block though, there&#x27;s no way around that.<p>The other big source of input lag is garbage collection, and there are some ongoing efforts to use the MPS library in Emacs for a copying, concurrent GC.  This is a big change and I don&#x27;t know if this experiment will go anywhere, but Eli Zaretskii and co are trying.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;emacs-lsp&#x2F;emacs">https:&#x2F;&#x2F;github.com&#x2F;emacs-lsp&#x2F;emacs</a></div><br/><div id="42202271" class="c"><input type="checkbox" id="c-42202271" checked=""/><div class="controls bullet"><span class="by">erk__</span><span>|</span><a href="#42198090">root</a><span>|</span><a href="#42199061">parent</a><span>|</span><a href="#42198923">next</a><span>|</span><label class="collapse" for="c-42202271">[-]</label><label class="expand" for="c-42202271">[1 more]</label></div><br/><div class="children"><div class="content">Someone made a alternative way of optimizing LSP by converting the JSON to elisp bytecode on the fly: <a href="https:&#x2F;&#x2F;github.com&#x2F;blahgeek&#x2F;emacs-lsp-booster">https:&#x2F;&#x2F;github.com&#x2F;blahgeek&#x2F;emacs-lsp-booster</a></div><br/></div></div></div></div><div id="42198923" class="c"><input type="checkbox" id="c-42198923" checked=""/><div class="controls bullet"><span class="by">seanw444</span><span>|</span><a href="#42198090">root</a><span>|</span><a href="#42198822">parent</a><span>|</span><a href="#42199061">prev</a><span>|</span><a href="#42198929">next</a><span>|</span><label class="collapse" for="c-42198923">[-]</label><label class="expand" for="c-42198923">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s fair I guess. In the case of IO that can be an issue. When I hear multicore, I assume we&#x27;re talking about parallelism, not concurrency.<p>As for LSP, other than the Nim langserver, I&#x27;ve been quite satisfied with Eglot&#x27;s performance. I&#x27;m curious what your setup is like. To be fair, I&#x27;m running a highly customized Doom Emacs config, so it&#x27;s possible I inherited some non-vanilla optimizations I&#x27;m not aware of.</div><br/><div id="42200161" class="c"><input type="checkbox" id="c-42200161" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42198090">root</a><span>|</span><a href="#42198923">parent</a><span>|</span><a href="#42198929">next</a><span>|</span><label class="collapse" for="c-42200161">[-]</label><label class="expand" for="c-42200161">[1 more]</label></div><br/><div class="children"><div class="content">&gt; When I hear multicore, I assume we&#x27;re talking about parallelism, not concurrency.<p>Parallelism trivially enables concurrency. The lack of parallelism magnifies the issues emacs has with concurrency.</div><br/></div></div></div></div></div></div></div></div><div id="42198929" class="c"><input type="checkbox" id="c-42198929" checked=""/><div class="controls bullet"><span class="by">DrBenCarson</span><span>|</span><a href="#42198090">root</a><span>|</span><a href="#42198366">parent</a><span>|</span><a href="#42198660">prev</a><span>|</span><a href="#42201176">next</a><span>|</span><label class="collapse" for="c-42198929">[-]</label><label class="expand" for="c-42198929">[1 more]</label></div><br/><div class="children"><div class="content">“Need” is strong but using GPU rendering is definitely better than CPU rendering and makes things feel very snappy<p>Most new TTY projects use GPUs for that reason</div><br/></div></div><div id="42201176" class="c"><input type="checkbox" id="c-42201176" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#42198090">root</a><span>|</span><a href="#42198366">parent</a><span>|</span><a href="#42198929">prev</a><span>|</span><a href="#42201231">next</a><span>|</span><label class="collapse" for="c-42201176">[-]</label><label class="expand" for="c-42201176">[1 more]</label></div><br/><div class="children"><div class="content">GPU rendering simplifies smooth text scrolling which used to be a thing on some dumb terminals and microcomputers like Amiga that supported it in hardware. Most emulators are locking character cells on a fixed grid and we miss out on such niceties.</div><br/></div></div></div></div></div></div><div id="42201231" class="c"><input type="checkbox" id="c-42201231" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#42198090">prev</a><span>|</span><a href="#42202120">next</a><span>|</span><label class="collapse" for="c-42201231">[-]</label><label class="expand" for="c-42201231">[1 more]</label></div><br/><div class="children"><div class="content">I really want to admire the Zed folks even though they are a new faction in the editor wars where I’m an emacs guy: they take mostly all the things I care about seriously.<p>The are serious about local vs. remote vs. shared. They are serious about hardware acceleration because they care about users who type fast and edit big files. They care about real computer science on how to push the current hardware to serve the user, rather than treating the hardware as a crutch to give the user a slightly worse experience at a fraction of the development cost. They care about code highlighting the snippets on their blog like very similar to the default Zed theme.<p>These are cool, serious people. If they give me emacs key bindings with full paredit-everywhere, I might switch my daily driver.<p>And this is about using modern SIMD-style stuff, branch less stuff, Lemire stuff in a modern and relevant context. Other commenters have pointed out that you can do the mask or popcount better with intrinsically, and yeah, but they probably know that, and B. They got the massive win, the remaining factor of K on the pop count is coming.<p>Long Zed.</div><br/></div></div><div id="42202120" class="c"><input type="checkbox" id="c-42202120" checked=""/><div class="controls bullet"><span class="by">m1keil</span><span>|</span><a href="#42201231">prev</a><span>|</span><a href="#42200228">next</a><span>|</span><label class="collapse" for="c-42202120">[-]</label><label class="expand" for="c-42202120">[1 more]</label></div><br/><div class="children"><div class="content">This is all really cool, but I just want soft wrap to be fixed</div><br/></div></div><div id="42200228" class="c"><input type="checkbox" id="c-42200228" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#42202120">prev</a><span>|</span><a href="#42201015">next</a><span>|</span><label class="collapse" for="c-42200228">[-]</label><label class="expand" for="c-42200228">[1 more]</label></div><br/><div class="children"><div class="content">SIMD can work quite well here too - with 128-bit SIMD (available on both baseline x86-64 and aarch64) this can be just ≤8 loop iterations checking for the newline character (each iteration counting the number of newline characters encountered, and a lzcnt on the last iteration), and similar for characters (assuming valid UTF-8, it&#x27;s a single comparison to test if a byte starts a new char).</div><br/></div></div><div id="42201015" class="c"><input type="checkbox" id="c-42201015" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#42200228">prev</a><span>|</span><a href="#42198301">next</a><span>|</span><label class="collapse" for="c-42201015">[-]</label><label class="expand" for="c-42201015">[4 more]</label></div><br/><div class="children"><div class="content">Why not store just a small u8 count of newlines in a chunk instead of their u128 positions and then only loop through the last chunk for precision?<p>You don&#x27;t need information about the position of newlines in all the chunks located before the one your offset lands on</div><br/><div id="42201548" class="c"><input type="checkbox" id="c-42201548" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#42201015">parent</a><span>|</span><a href="#42198301">next</a><span>|</span><label class="collapse" for="c-42201548">[-]</label><label class="expand" for="c-42201548">[3 more]</label></div><br/><div class="children"><div class="content">As I understand it, they do exactly what you say. TFA is about optimizing the last chunk&#x27;s loop.</div><br/><div id="42201664" class="c"><input type="checkbox" id="c-42201664" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#42201015">root</a><span>|</span><a href="#42201548">parent</a><span>|</span><a href="#42198301">next</a><span>|</span><label class="collapse" for="c-42201664">[-]</label><label class="expand" for="c-42201664">[2 more]</label></div><br/><div class="children"><div class="content">Maybe I got confused, but how do they then count the newlines in all the previous chunks? That information is still needed to calculate the line for a specific position in the last chunk</div><br/><div id="42201856" class="c"><input type="checkbox" id="c-42201856" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#42201015">root</a><span>|</span><a href="#42201664">parent</a><span>|</span><a href="#42198301">next</a><span>|</span><label class="collapse" for="c-42201856">[-]</label><label class="expand" for="c-42201856">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not you who&#x27;s confused, it&#x27;s that this part of the process is not described. We only have some hints, here:<p>&gt; If you called rope.offset_to_point(7234), the Rope would traverse its SumTree to find the Chunk that contains offset 7234 and then, on that Chunk, it would call offset_to_point again.<p>And here:<p>&gt; while the Rope can get us to the right Chunk in O(log(n))<p>I would guess that each node of the SumTree includes the number of newlines of all the chunks before it.</div><br/></div></div></div></div></div></div></div></div><div id="42198301" class="c"><input type="checkbox" id="c-42198301" checked=""/><div class="controls bullet"><span class="by">camel-cdr</span><span>|</span><a href="#42201015">prev</a><span>|</span><a href="#42199624">next</a><span>|</span><label class="collapse" for="c-42198301">[-]</label><label class="expand" for="c-42198301">[5 more]</label></div><br/><div class="children"><div class="content">nth_set_bit_u64: wouldn&#x27;t that be __builtin_ctzll(_pdep_u64(1&lt;&lt;n, v)) with BMI2?</div><br/><div id="42199867" class="c"><input type="checkbox" id="c-42199867" checked=""/><div class="controls bullet"><span class="by">kwillets</span><span>|</span><a href="#42198301">parent</a><span>|</span><a href="#42200581">next</a><span>|</span><label class="collapse" for="c-42199867">[-]</label><label class="expand" for="c-42199867">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s my guess as well.<p>Bitstring rank&#x2F;select is a well-known problem, and the BMI and non-BMI (Hacker&#x27;s Delight) versions are available as a reference.</div><br/></div></div><div id="42200581" class="c"><input type="checkbox" id="c-42200581" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42198301">parent</a><span>|</span><a href="#42199867">prev</a><span>|</span><a href="#42198733">next</a><span>|</span><label class="collapse" for="c-42200581">[-]</label><label class="expand" for="c-42200581">[1 more]</label></div><br/><div class="children"><div class="content">I believe the equivalent ARM64 instructions are in SVE2 which isn’t yet supported on Apple’s M-series chips as of M4, sadly.</div><br/></div></div><div id="42198733" class="c"><input type="checkbox" id="c-42198733" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#42198301">parent</a><span>|</span><a href="#42200581">prev</a><span>|</span><a href="#42199624">next</a><span>|</span><label class="collapse" for="c-42198733">[-]</label><label class="expand" for="c-42198733">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s assuming you&#x27;re ok with your program not running on some older cpus.</div><br/><div id="42200177" class="c"><input type="checkbox" id="c-42200177" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#42198301">root</a><span>|</span><a href="#42198733">parent</a><span>|</span><a href="#42199624">next</a><span>|</span><label class="collapse" for="c-42200177">[-]</label><label class="expand" for="c-42200177">[1 more]</label></div><br/><div class="children"><div class="content">That and that you&#x27;re not willing to entertain splitting the manual version as #[cfg(not(target_feature = &quot;bmi2&quot;))] fallback implementation. For something already down to ~ 1 ns both of those may well be very reasonable assumptions of course.</div><br/></div></div></div></div></div></div><div id="42199624" class="c"><input type="checkbox" id="c-42199624" checked=""/><div class="controls bullet"><span class="by">sapiogram</span><span>|</span><a href="#42198301">prev</a><span>|</span><a href="#42199419">next</a><span>|</span><label class="collapse" for="c-42199624">[-]</label><label class="expand" for="c-42199624">[2 more]</label></div><br/><div class="children"><div class="content">Is there a way to adjust text contrast in light mode in Zed yet? The editor is unfortunately unusable for me, because of how washed out the colors are.</div><br/><div id="42200916" class="c"><input type="checkbox" id="c-42200916" checked=""/><div class="controls bullet"><span class="by">mattbaker</span><span>|</span><a href="#42199624">parent</a><span>|</span><a href="#42199419">next</a><span>|</span><label class="collapse" for="c-42200916">[-]</label><label class="expand" for="c-42200916">[1 more]</label></div><br/><div class="children"><div class="content">There are themes now and a UI to install them, I also didn’t like the washed out colors.</div><br/></div></div></div></div><div id="42199419" class="c"><input type="checkbox" id="c-42199419" checked=""/><div class="controls bullet"><span class="by">ramon156</span><span>|</span><a href="#42199624">prev</a><span>|</span><a href="#42199674">next</a><span>|</span><label class="collapse" for="c-42199419">[-]</label><label class="expand" for="c-42199419">[1 more]</label></div><br/><div class="children"><div class="content">Isnt the tab example wrong? Id assume it to be<p>aa -&gt; -&gt; bb
-&gt; -&gt; bb<p>It only takes up two spaces, after all</div><br/></div></div><div id="42199674" class="c"><input type="checkbox" id="c-42199674" checked=""/><div class="controls bullet"><span class="by">Am4TIfIsER0ppos</span><span>|</span><a href="#42199419">prev</a><span>|</span><a href="#42198106">next</a><span>|</span><label class="collapse" for="c-42199674">[-]</label><label class="expand" for="c-42199674">[1 more]</label></div><br/><div class="children"><div class="content">&gt; opacity: 0;<p>&gt; filter: blur(1px);<p>Wonderful styling!</div><br/></div></div><div id="42198106" class="c"><input type="checkbox" id="c-42198106" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#42199674">prev</a><span>|</span><label class="collapse" for="c-42198106">[-]</label><label class="expand" for="c-42198106">[11 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt;  &#x2F;&#x2F; Parallel bit count intermediates
  &gt;  let a = v - ((v &gt;&gt; 1) &amp; (u64::MAX &#x2F; 3));
  &gt;  let b = (a &amp; (u64::MAX &#x2F; 5)) + ((a &gt;&gt; 2) &amp; (u64::MAX &#x2F; 5));
  &gt;  let c = (b + (b &gt;&gt; 4)) &amp; (u64::MAX &#x2F; 0x11);
  &gt;  let d = (c + (c &gt;&gt; 8)) &amp; (u64::MAX &#x2F; 0x101);

</code></pre>
That &quot;parallel bit count&quot; is almost certainly slower than using two POPCNT instructions on a modern cpu. Should just call __builtin_popcount() and let the compiler do it the most optimal way. Luckily, people do this sort of thing so often that many modern compilers will try (and often succeed) to detect you trying this insanity and convert it to a POPCOUNT (or a pair of POPCOUNTs as the case may be here)</div><br/><div id="42199186" class="c"><input type="checkbox" id="c-42199186" checked=""/><div class="controls bullet"><span class="by">ot</span><span>|</span><a href="#42198106">parent</a><span>|</span><a href="#42198289">next</a><span>|</span><label class="collapse" for="c-42199186">[-]</label><label class="expand" for="c-42199186">[1 more]</label></div><br/><div class="children"><div class="content">What that code does is a per-byte-pair popcount, which is not what the POPCNT instruction does (it computes the popcount for the whole word).<p>On processors with BMI2 the whole algorithm reduces to a PDEP as mentioned in another comment, but if you don&#x27;t have that this is pretty much the best you can do (unless you use lookup tables but those have pros and cons).</div><br/></div></div><div id="42198289" class="c"><input type="checkbox" id="c-42198289" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#42198106">parent</a><span>|</span><a href="#42199186">prev</a><span>|</span><label class="collapse" for="c-42198289">[-]</label><label class="expand" for="c-42198289">[9 more]</label></div><br/><div class="children"><div class="content">Which compilers support __builtin_popcount()? From memory, it&#x27;s a gcc extension. If the compiler selects a CPU POPCOUNT instruction for it, are you sure it will work on all machines that you want to run it on?<p>The above code is completely source- and binary-portable and reasonably fast -- certainly faster than naively looping through the bits, and within a small constant factor of a CPU POPCOUNT instruction.</div><br/><div id="42198679" class="c"><input type="checkbox" id="c-42198679" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#42198106">root</a><span>|</span><a href="#42198289">parent</a><span>|</span><a href="#42198569">next</a><span>|</span><label class="collapse" for="c-42198679">[-]</label><label class="expand" for="c-42198679">[1 more]</label></div><br/><div class="children"><div class="content">Everything supports __builtin_popcount or some variant these days (__popcnt for MSVC). It&#x27;s a complete non-issue, really.<p>And the compiler is not required to lower it to a single instruction. It will if the target architecture is specified appropriately, but there&#x27;s nothing that says it has to explode if it can&#x27;t. In fact, by doing it this way, the compiler is actually more free to generate code in a way that&#x27;s optimal for the architecture in all cases, because all the implementation details are hidden e.g. loads of large constants may be avoided if the compiler is allowed to choose the exact implementation, while using the portable version may tie its hands more depending on how it&#x27;s feeling on that day. Here&#x27;s __builtin_popcount working just fine while targeting a ~20yo architecture without native support for SSE4.2; it can generate this code knowing what the proper instructions and schedules are: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;ra7n5T5f3" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;ra7n5T5f3</a><p>The moral here is that the primitives are there for you to use. Just use them and save yourself and your would-be code reviewer&#x27;s time.</div><br/></div></div><div id="42198569" class="c"><input type="checkbox" id="c-42198569" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#42198106">root</a><span>|</span><a href="#42198289">parent</a><span>|</span><a href="#42198679">prev</a><span>|</span><a href="#42198351">next</a><span>|</span><label class="collapse" for="c-42198569">[-]</label><label class="expand" for="c-42198569">[1 more]</label></div><br/><div class="children"><div class="content">Most vaguely recent compilers will convert naively looping through bits into a native POPCOUNT instruction. The parallel bit count algorithm was not reliably detected until more recently and therefore would sometimes produce unoptimized code, though current versions of gcc&#x2F;clang&#x2F;msvc can all detect it now.<p>Also, pretty much every compiler for a very long time has supported __builtin_popcount or equivalent.</div><br/></div></div><div id="42198351" class="c"><input type="checkbox" id="c-42198351" checked=""/><div class="controls bullet"><span class="by">woadwarrior01</span><span>|</span><a href="#42198106">root</a><span>|</span><a href="#42198289">parent</a><span>|</span><a href="#42198569">prev</a><span>|</span><a href="#42198414">next</a><span>|</span><label class="collapse" for="c-42198351">[-]</label><label class="expand" for="c-42198351">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Which compilers support __builtin_popcount()?<p>Clang supports __builtin_popcount() too. And MSVC has __popcnt().</div><br/></div></div><div id="42198414" class="c"><input type="checkbox" id="c-42198414" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#42198106">root</a><span>|</span><a href="#42198289">parent</a><span>|</span><a href="#42198351">prev</a><span>|</span><label class="collapse" for="c-42198414">[-]</label><label class="expand" for="c-42198414">[5 more]</label></div><br/><div class="children"><div class="content">Your compiler will know <i>the best</i> way to popcount, that is the point of that builtin. It&#x27;ll use the best method - sometimes this one. GCC does this, MSVC does this, clang does this, i think even rust has some way to do it (EDIT: it does:  count_ones()). On archs which lack POPCNT, it will use this method or another, based on knowing the target. On x86 this approach is OK as is. On arm64, for example, it will be suboptimal due to all the literals needed. On armv6m, this method is bad and table lookups are faster.</div><br/><div id="42198709" class="c"><input type="checkbox" id="c-42198709" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#42198106">root</a><span>|</span><a href="#42198414">parent</a><span>|</span><a href="#42199348">next</a><span>|</span><label class="collapse" for="c-42198709">[-]</label><label class="expand" for="c-42198709">[2 more]</label></div><br/><div class="children"><div class="content">Note that by default rustc targets x86-64-v1 when compiling for x86-64, and that lacks the popcount instruction. You need to change the target_cpu to at least  x86-64-v2 or enable the popcount target_feature. This means that even if your cpu is relatively new and you intend to run your 
code on relatively new cpus, rustc will still generate older and slower code for count_ones() using bitshifts and masks. That said, I don&#x27;t see the point in writing them manually if the compiler can generate them for you.</div><br/><div id="42200220" class="c"><input type="checkbox" id="c-42200220" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42198106">root</a><span>|</span><a href="#42198709">parent</a><span>|</span><a href="#42199348">next</a><span>|</span><label class="collapse" for="c-42200220">[-]</label><label class="expand" for="c-42200220">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not unreasonable to think that Rust will change the minimum version and you should always override the target cpu anyway for C++-like toolchains when building production binaries (`-Ctarget-cpu` for rust, `march=` for clang&#x2F;gcc).</div><br/></div></div></div></div><div id="42199348" class="c"><input type="checkbox" id="c-42199348" checked=""/><div class="controls bullet"><span class="by">Findecanor</span><span>|</span><a href="#42198106">root</a><span>|</span><a href="#42198414">parent</a><span>|</span><a href="#42198709">prev</a><span>|</span><label class="collapse" for="c-42199348">[-]</label><label class="expand" for="c-42199348">[2 more]</label></div><br/><div class="children"><div class="content">I once wrote that algorithm, divided into single lines, intending each line to be a single 64-bit ARM instruction.
The compiler did idiom detection, transforming it to &quot;builtin popcnt&quot; and (because 64-bit ARMv8.0 lacks a POPCNT instruction) back to the same algorithm. Only that the emitted code was one instruction larger than my code.<p>64-bit ARM&#x27;s actually has a very peculiar encoding of immediates to arithmetic instructions. It supports <i>only</i> recurring bit patterns such as used by this algorithm. For example &quot;add x2, x3, #3333333333333333&quot; is encoded as one four-byte instruction.</div><br/><div id="42199491" class="c"><input type="checkbox" id="c-42199491" checked=""/><div class="controls bullet"><span class="by">stassats</span><span>|</span><a href="#42198106">root</a><span>|</span><a href="#42199348">parent</a><span>|</span><label class="collapse" for="c-42199491">[-]</label><label class="expand" for="c-42199491">[1 more]</label></div><br/><div class="children"><div class="content">&gt; because 64-bit ARMv8.0 lacks a POPCNT instruction<p>It does have this: <a href="https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;ddi0596&#x2F;2021-09&#x2F;SIMD-FP-Instructions&#x2F;CNT--Population-Count-per-byte-" rel="nofollow">https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;ddi0596&#x2F;2021-09&#x2F;SIMD...</a><p>And GCC happily uses it <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;dTW46f9Kf" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;dTW46f9Kf</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>