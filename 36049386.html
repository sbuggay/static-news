<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1684918865747" as="style"/><link rel="stylesheet" href="styles.css?v=1684918865747"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://shaneosullivan.wordpress.com/2023/05/23/instant-colour-fill-with-html-canvas/">Instant flood fill with HTML Canvas</a> <span class="domain">(<a href="https://shaneosullivan.wordpress.com">shaneosullivan.wordpress.com</a>)</span></div><div class="subtext"><span>shaneos</span> | <span>95 comments</span></div><br/><div><div id="36054232" class="c"><input type="checkbox" id="c-36054232" checked=""/><div class="controls bullet"><span class="by">andersrs</span><span>|</span><a href="#36051907">next</a><span>|</span><label class="collapse" for="c-36054232">[-]</label><label class="expand" for="c-36054232">[8 more]</label></div><br/><div class="children"><div class="content">&gt;  The idea was to build something fun that never shows adverts to them or tricks them into sneaky purchases by “accident”.<p>This part really resonated with me. Google promotes the absolute worst spammy shit these days. I have to browse tech forums to find clean simple games.<p>Last week I was trying to find a simple memory cards game and the search results were complete dog shit so I started building my own memory cards game. In a couple hours I made <a href="https:&#x2F;&#x2F;memorycardsgame.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;memorycardsgame.com&#x2F;</a>. Then browsing a svelte forum I found <a href="https:&#x2F;&#x2F;toddler-games.com" rel="nofollow">https:&#x2F;&#x2F;toddler-games.com</a> which is much further ahead of mine but I&#x27;d never be able to find stuff like this by searching for it. Of course none of the good games are filled with a bunch of SEO spam which is kind of the point.
Since Steve Jobs didn&#x27;t let his kid use an iPad we&#x27;ve decided the game isn&#x27;t needed now.<p>Nice app.</div><br/><div id="36055058" class="c"><input type="checkbox" id="c-36055058" checked=""/><div class="controls bullet"><span class="by">jmkni</span><span>|</span><a href="#36054232">parent</a><span>|</span><a href="#36055111">next</a><span>|</span><label class="collapse" for="c-36055058">[-]</label><label class="expand" for="c-36055058">[1 more]</label></div><br/><div class="children"><div class="content">Not sure I would take parenting advice from Steve Jobs!</div><br/></div></div><div id="36055111" class="c"><input type="checkbox" id="c-36055111" checked=""/><div class="controls bullet"><span class="by">rustybolt</span><span>|</span><a href="#36054232">parent</a><span>|</span><a href="#36055058">prev</a><span>|</span><a href="#36055295">next</a><span>|</span><label class="collapse" for="c-36055111">[-]</label><label class="expand" for="c-36055111">[1 more]</label></div><br/><div class="children"><div class="content">Very nice! A bit of feedback: when you quickly click many cards, they are open at the same time, which makes it trivial to see pairs. So maybe you want to wait opening any cards until the last pair is closed.</div><br/></div></div><div id="36055295" class="c"><input type="checkbox" id="c-36055295" checked=""/><div class="controls bullet"><span class="by">gsliepen</span><span>|</span><a href="#36054232">parent</a><span>|</span><a href="#36055111">prev</a><span>|</span><a href="#36054645">next</a><span>|</span><label class="collapse" for="c-36055295">[-]</label><label class="expand" for="c-36055295">[1 more]</label></div><br/><div class="children"><div class="content">I can also recommend <a href="https:&#x2F;&#x2F;tuxpaint.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tuxpaint.org&#x2F;</a>. I see they also have an app for Android nowadays, but no iOS it seems.</div><br/></div></div><div id="36054645" class="c"><input type="checkbox" id="c-36054645" checked=""/><div class="controls bullet"><span class="by">shaneos</span><span>|</span><a href="#36054232">parent</a><span>|</span><a href="#36055295">prev</a><span>|</span><a href="#36054841">next</a><span>|</span><label class="collapse" for="c-36054645">[-]</label><label class="expand" for="c-36054645">[1 more]</label></div><br/><div class="children"><div class="content">Thanks - that toddler-games.com is really nice. It’s so simply done that even a two year old could enjoy it for hours. My kids are 5 and 7 now so want something a bit more advanced, but I wish I’d found that a few years ago</div><br/></div></div><div id="36054841" class="c"><input type="checkbox" id="c-36054841" checked=""/><div class="controls bullet"><span class="by">tobr</span><span>|</span><a href="#36054232">parent</a><span>|</span><a href="#36054645">prev</a><span>|</span><a href="#36054600">next</a><span>|</span><label class="collapse" for="c-36054841">[-]</label><label class="expand" for="c-36054841">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In a couple hours I made <a href="https:&#x2F;&#x2F;memorycardsgame.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;memorycardsgame.com&#x2F;</a>.<p>Nice! Small bit of feedback: when you click “restart” after winning, the emojis are replaced with new ones right before the flip animation plays, which briefly reveals the solution. I’m assuming that’s a bug and not an intentional hint, as it doesn’t happen the first time.</div><br/></div></div><div id="36054600" class="c"><input type="checkbox" id="c-36054600" checked=""/><div class="controls bullet"><span class="by">tony_antny</span><span>|</span><a href="#36054232">parent</a><span>|</span><a href="#36054841">prev</a><span>|</span><a href="#36054706">next</a><span>|</span><label class="collapse" for="c-36054600">[-]</label><label class="expand" for="c-36054600">[1 more]</label></div><br/><div class="children"><div class="content">I was looking for colouring app two days ago but couldn&#x27;t find a decent one. <a href="https:&#x2F;&#x2F;toddler-games.com" rel="nofollow">https:&#x2F;&#x2F;toddler-games.com</a> seems to be something my niece&#x27;s would love. Thanks.</div><br/></div></div><div id="36054706" class="c"><input type="checkbox" id="c-36054706" checked=""/><div class="controls bullet"><span class="by">taskforcegemini</span><span>|</span><a href="#36054232">parent</a><span>|</span><a href="#36054600">prev</a><span>|</span><a href="#36051907">next</a><span>|</span><label class="collapse" for="c-36054706">[-]</label><label class="expand" for="c-36054706">[1 more]</label></div><br/><div class="children"><div class="content">you made the game for Steve Jobs kid?</div><br/></div></div></div></div><div id="36051907" class="c"><input type="checkbox" id="c-36051907" checked=""/><div class="controls bullet"><span class="by">shaneos</span><span>|</span><a href="#36054232">prev</a><span>|</span><a href="#36055499">next</a><span>|</span><label class="collapse" for="c-36051907">[-]</label><label class="expand" for="c-36051907">[7 more]</label></div><br/><div class="children"><div class="content">Author here: I&#x27;m loving all the suggestions of ways that this might be achievable in either a faster or simpler method!  The code is open source at <a href="https:&#x2F;&#x2F;github.com&#x2F;shaneosullivan&#x2F;example-canvas-fill">https:&#x2F;&#x2F;github.com&#x2F;shaneosullivan&#x2F;example-canvas-fill</a> and I&#x27;d love to see you hackers improve on it and share it with everyone.  Any and all improvements I&#x27;ll happily use going forward in my app.</div><br/><div id="36053903" class="c"><input type="checkbox" id="c-36053903" checked=""/><div class="controls bullet"><span class="by">KRAKRISMOTT</span><span>|</span><a href="#36051907">parent</a><span>|</span><a href="#36055044">next</a><span>|</span><label class="collapse" for="c-36053903">[-]</label><label class="expand" for="c-36053903">[1 more]</label></div><br/><div class="children"><div class="content">Look up the connected regions algorithm (DFS), it might be useful.<p>Here&#x27;s an example 
<a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Connected-component_labeling" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Connected-component_labeling</a><p><a href="https:&#x2F;&#x2F;scikit-image.org&#x2F;docs&#x2F;stable&#x2F;api&#x2F;skimage.measure.html#skimage.measure.label" rel="nofollow">https:&#x2F;&#x2F;scikit-image.org&#x2F;docs&#x2F;stable&#x2F;api&#x2F;skimage.measure.htm...</a><p>I guess you are doing the same thing and memoizing the graph ahead of time. Perhaps find an optimized implementation in wasm and save yourself some maintenance time.</div><br/></div></div><div id="36055044" class="c"><input type="checkbox" id="c-36055044" checked=""/><div class="controls bullet"><span class="by">penteract</span><span>|</span><a href="#36051907">parent</a><span>|</span><a href="#36053903">prev</a><span>|</span><a href="#36054988">next</a><span>|</span><label class="collapse" for="c-36055044">[-]</label><label class="expand" for="c-36055044">[1 more]</label></div><br/><div class="children"><div class="content">Assuming you currently recompute the whole thing on every edit, it might be fairly straightforward to speed it up by reusing the results of the previous run. Areas which do not overlap the edited area shouldn&#x27;t need to be recalculated. Bounding boxes would be a quick way to test overlap.</div><br/></div></div><div id="36054988" class="c"><input type="checkbox" id="c-36054988" checked=""/><div class="controls bullet"><span class="by">sb8244</span><span>|</span><a href="#36051907">parent</a><span>|</span><a href="#36055044">prev</a><span>|</span><a href="#36052322">next</a><span>|</span><label class="collapse" for="c-36054988">[-]</label><label class="expand" for="c-36054988">[2 more]</label></div><br/><div class="children"><div class="content">Sorta random question, but what do you use to generate your diagrams? Mine always look so boring in comparison.</div><br/><div id="36055037" class="c"><input type="checkbox" id="c-36055037" checked=""/><div class="controls bullet"><span class="by">shaneos</span><span>|</span><a href="#36051907">root</a><span>|</span><a href="#36054988">parent</a><span>|</span><a href="#36052322">next</a><span>|</span><label class="collapse" for="c-36055037">[-]</label><label class="expand" for="c-36055037">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;excalidraw.com" rel="nofollow">https:&#x2F;&#x2F;excalidraw.com</a> !! Such an amazing app, free and open source</div><br/></div></div></div></div><div id="36052322" class="c"><input type="checkbox" id="c-36052322" checked=""/><div class="controls bullet"><span class="by">masswerk</span><span>|</span><a href="#36051907">parent</a><span>|</span><a href="#36054988">prev</a><span>|</span><a href="#36055499">next</a><span>|</span><label class="collapse" for="c-36052322">[-]</label><label class="expand" for="c-36052322">[2 more]</label></div><br/><div class="children"><div class="content">I wonder, if assembling an array of paths for outlines may improve things. You can check for a point being in inside path, use paths as hit areas, and you can apply fills. Notably, there wouldn&#x27;t be any need for keeping various mask images in memory anymore. (You wouldn&#x27;t want any curves in this paths, just pixel outlines. It may become a bit tricky with complex paths and negative shapes, though, which may be addressed by composing a mask image on-the-fly.)</div><br/><div id="36054235" class="c"><input type="checkbox" id="c-36054235" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#36051907">root</a><span>|</span><a href="#36052322">parent</a><span>|</span><a href="#36055499">next</a><span>|</span><label class="collapse" for="c-36054235">[-]</label><label class="expand" for="c-36054235">[1 more]</label></div><br/><div class="children"><div class="content">these are interesting ideas!<p>a potential drawback is that it seems like the paths could be several times larger than the original image (consider a checkerboard pattern, where each pixel is its own fill area, or the pathological spiral pattern i suggested in a comment below)</div><br/></div></div></div></div></div></div><div id="36055499" class="c"><input type="checkbox" id="c-36055499" checked=""/><div class="controls bullet"><span class="by">shaan7</span><span>|</span><a href="#36051907">prev</a><span>|</span><a href="#36050988">next</a><span>|</span><label class="collapse" for="c-36055499">[-]</label><label class="expand" for="c-36055499">[1 more]</label></div><br/><div class="children"><div class="content">Oh man this brings back memories. When I was young we did not have Internet at home, so I made a VB6 app for my sister so she could load outlines and color them. So much fun! For both of us :D<p>EDIT: Later I also made a simple LOGO interpreter in VB6 for the same reasons. Turtle fun!</div><br/></div></div><div id="36050988" class="c"><input type="checkbox" id="c-36050988" checked=""/><div class="controls bullet"><span class="by">ianlevesque</span><span>|</span><a href="#36055499">prev</a><span>|</span><a href="#36051500">next</a><span>|</span><label class="collapse" for="c-36050988">[-]</label><label class="expand" for="c-36050988">[8 more]</label></div><br/><div class="children"><div class="content">Ha, painting tablet app feels like a rite of passage for programmer parents. Here&#x27;s mine from that era <a href="https:&#x2F;&#x2F;paints.netlify.app&#x2F;" rel="nofollow">https:&#x2F;&#x2F;paints.netlify.app&#x2F;</a><p>Where it got really interesting later was when one of my kids asked how I made it, how it worked, how they could add new features. So it grew a bunch of adorable haphazard hacks that my oldest implemented.</div><br/><div id="36051853" class="c"><input type="checkbox" id="c-36051853" checked=""/><div class="controls bullet"><span class="by">shaneos</span><span>|</span><a href="#36050988">parent</a><span>|</span><a href="#36051358">next</a><span>|</span><label class="collapse" for="c-36051853">[-]</label><label class="expand" for="c-36051853">[4 more]</label></div><br/><div class="children"><div class="content">Very cute! I started out with basically this, and my kids kept asking me for more and more features :-). Recently they asked to make animations, and that took a chunk of time to get right.  I&#x27;m looking forward to whatever they ask for as they grow more advanced!</div><br/><div id="36052816" class="c"><input type="checkbox" id="c-36052816" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#36050988">root</a><span>|</span><a href="#36051853">parent</a><span>|</span><a href="#36051358">next</a><span>|</span><label class="collapse" for="c-36052816">[-]</label><label class="expand" for="c-36052816">[3 more]</label></div><br/><div class="children"><div class="content">Your kids sound high maintenance; I would consider returning them if they&#x27;re still within the warranty period.</div><br/><div id="36053414" class="c"><input type="checkbox" id="c-36053414" checked=""/><div class="controls bullet"><span class="by">atonse</span><span>|</span><a href="#36050988">root</a><span>|</span><a href="#36052816">parent</a><span>|</span><a href="#36053065">next</a><span>|</span><label class="collapse" for="c-36053414">[-]</label><label class="expand" for="c-36053414">[1 more]</label></div><br/><div class="children"><div class="content">By the time they start giving you attitude, they&#x27;re well past the warranty period.</div><br/></div></div></div></div></div></div><div id="36051358" class="c"><input type="checkbox" id="c-36051358" checked=""/><div class="controls bullet"><span class="by">sharikous</span><span>|</span><a href="#36050988">parent</a><span>|</span><a href="#36051853">prev</a><span>|</span><a href="#36051500">next</a><span>|</span><label class="collapse" for="c-36051358">[-]</label><label class="expand" for="c-36051358">[3 more]</label></div><br/><div class="children"><div class="content">Wonderful, the fact that it runs as expected in multi touch devices has not gone unnoticed!</div><br/><div id="36052368" class="c"><input type="checkbox" id="c-36052368" checked=""/><div class="controls bullet"><span class="by">ianlevesque</span><span>|</span><a href="#36050988">root</a><span>|</span><a href="#36051358">parent</a><span>|</span><a href="#36051500">next</a><span>|</span><label class="collapse" for="c-36052368">[-]</label><label class="expand" for="c-36052368">[2 more]</label></div><br/><div class="children"><div class="content">That’s really essential, even if only for the clumsy thumb left on the screen with a naive grip. Being able to finger paint with all ten fingers is a bonus.</div><br/><div id="36052409" class="c"><input type="checkbox" id="c-36052409" checked=""/><div class="controls bullet"><span class="by">shaneos</span><span>|</span><a href="#36050988">root</a><span>|</span><a href="#36052368">parent</a><span>|</span><a href="#36051500">next</a><span>|</span><label class="collapse" for="c-36052409">[-]</label><label class="expand" for="c-36052409">[1 more]</label></div><br/><div class="children"><div class="content">Yes, ignoring the palm resting on the screen is essential. Doing that along with allowing zooming and pen input takes some creative thinking. It’s non trivial</div><br/></div></div></div></div></div></div></div></div><div id="36051500" class="c"><input type="checkbox" id="c-36051500" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#36050988">prev</a><span>|</span><a href="#36051081">next</a><span>|</span><label class="collapse" for="c-36051500">[-]</label><label class="expand" for="c-36051500">[2 more]</label></div><br/><div class="children"><div class="content">When it comes to performance, I find you really need to experiment with HTML Canvas. Some of the interfaces can be hundreds to thousands of times slower for manipulating the canvas than others.</div><br/><div id="36055294" class="c"><input type="checkbox" id="c-36055294" checked=""/><div class="controls bullet"><span class="by">rikroots</span><span>|</span><a href="#36051500">parent</a><span>|</span><a href="#36051081">next</a><span>|</span><label class="collapse" for="c-36055294">[-]</label><label class="expand" for="c-36055294">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just the Canvas API that surprises, it&#x27;s also how browser JS engines choose to implement those APIs. What works well in Chrome can often cause grief in Firefox or Safari. Working with canvas elements today often feels like frontend development back in the 2000s<p>See for example: <a href="https:&#x2F;&#x2F;benchmarks.slaylines.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;benchmarks.slaylines.io&#x2F;</a></div><br/></div></div></div></div><div id="36051081" class="c"><input type="checkbox" id="c-36051081" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#36051500">prev</a><span>|</span><a href="#36054810">next</a><span>|</span><label class="collapse" for="c-36051081">[-]</label><label class="expand" for="c-36051081">[25 more]</label></div><br/><div class="children"><div class="content">the summary is that they preprocess the image to partition it into a disjoint set of fillable regions, but i feel like this maybe has to be redone whenever you mutate the image<p>maybe other optimization approaches would yield a flood-fill algorithm that just runs fast enough in js; wasm can surely do it<p>like i feel like you can probably loop over the pixels in a scan line until you encounter an obstacle at several tens of megapixels per second<p>as the dumbest possible test of js perf, this code (admittedly not accessing an imagedata object) gets about 250 million iterations per second on my 2.6 gigahertz palmtop in firefox<p><pre><code>    function tri(n) { let x = 0, y = n; while(y--) x += y; return x } 
    s = new Date(); console.log(tri(10_000_000)); console.log(new Date() - s)</code></pre></div><br/><div id="36053088" class="c"><input type="checkbox" id="c-36053088" checked=""/><div class="controls bullet"><span class="by">johnfn</span><span>|</span><a href="#36051081">parent</a><span>|</span><a href="#36051146">next</a><span>|</span><label class="collapse" for="c-36053088">[-]</label><label class="expand" for="c-36053088">[2 more]</label></div><br/><div class="children"><div class="content">A proper flood fill needs to iterate over an enormous ImageData object (or at the very least a huge 2d array) and page in&#x2F;out memory as appropriate. Your code appears to just increment a variable. This is not a valid comparison.</div><br/><div id="36053752" class="c"><input type="checkbox" id="c-36053752" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#36051081">root</a><span>|</span><a href="#36053088">parent</a><span>|</span><a href="#36051146">next</a><span>|</span><label class="collapse" for="c-36053752">[-]</label><label class="expand" for="c-36053752">[1 more]</label></div><br/><div class="children"><div class="content">the comment you are replying to explains that already, right above the code<p>the question of memory access time is quite deep<p>in shane&#x27;s example of flood-filling a 2048 × 2048 image in 16ms, the image is 16 mebibytes; if you have less ram than that, so that you have to page in and out (as your comment says you do), you are not going to be able to do the computation fast enough.  but my hand-me-down cellphone has 256 times that much ram so i guess you&#x27;re using a pentium pro 200 or something, in which case you aren&#x27;t going to be able to run a browser that supports canvas<p>assuming you&#x27;re using a computer from the current millennium, one which has enough ram to run a browser that supports canvas, you won&#x27;t need to do any paging, but you do need to think about dram bandwidth.  probably the required bandwidth to dram is 2 gigabytes per second (one read and one write), while typical current ddr4 systems provide on the order of 30 or 40 gigabytes per second.  that assumes you can keep the memory access reasonably sequential (if your l2 cache is less than those 16 mebibytes).  this is usually the case with a simple line-by-line flood-fill algorithm, like the one used by gw-basic 40 years ago, but there are pathological images where it is not<p>consider a 1-pixel-black&#x2F;1-pixel-white square double spiral that fills the full 4 mebipixels.  whether a fill in the white covers all the white or just half of it depends on every single black pixel, so algorithms that can do this with better locality and a reasonable amount of parallelism are inherently going to be relatively hairy<p>but images like that cause problems for shane&#x27;s existing algorithm too because they will make shane&#x27;s web worker spin for a long time</div><br/></div></div></div></div><div id="36051146" class="c"><input type="checkbox" id="c-36051146" checked=""/><div class="controls bullet"><span class="by">shaneos</span><span>|</span><a href="#36051081">parent</a><span>|</span><a href="#36053088">prev</a><span>|</span><a href="#36051273">next</a><span>|</span><label class="collapse" for="c-36051146">[-]</label><label class="expand" for="c-36051146">[18 more]</label></div><br/><div class="children"><div class="content">If a wasm algorithm can run in under 16ms for arbitrarily large images that would be amazing. Hard to beat pre-computing all possible fills however, as the user perceives it as instant.<p>If you’ve seen a really fast wasm solution I’d love to replace the fill portion with it though.</div><br/><div id="36051436" class="c"><input type="checkbox" id="c-36051436" checked=""/><div class="controls bullet"><span class="by">irskep</span><span>|</span><a href="#36051081">root</a><span>|</span><a href="#36051146">parent</a><span>|</span><a href="#36052275">next</a><span>|</span><label class="collapse" for="c-36051436">[-]</label><label class="expand" for="c-36051436">[9 more]</label></div><br/><div class="children"><div class="content">I think people in this thread are being much too optimistic about browser performance. Writing a loop isn&#x27;t the issue; memory access patterns are. Canvas implementations are just not well suited for the flood fill problem space. (I spent some time with flood fills + canvas ten years ago when I was working on the now-dead library Literally Canvas, but I assume that experience is pretty far out of date now.)<p>Precomputing fill areas is a really good idea for the situation you&#x27;re in!<p>Edit: actually it was 7 years <a href="https:&#x2F;&#x2F;github.com&#x2F;irskep&#x2F;literallycanvas-pro-tools&#x2F;blob&#x2F;master&#x2F;src&#x2F;tools&#x2F;PaintBucket.js">https:&#x2F;&#x2F;github.com&#x2F;irskep&#x2F;literallycanvas-pro-tools&#x2F;blob&#x2F;mas...</a></div><br/><div id="36051644" class="c"><input type="checkbox" id="c-36051644" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#36051081">root</a><span>|</span><a href="#36051436">parent</a><span>|</span><a href="#36053966">next</a><span>|</span><label class="collapse" for="c-36051644">[-]</label><label class="expand" for="c-36051644">[2 more]</label></div><br/><div class="children"><div class="content">you&#x27;re calling fillRect in your inner loop<p>it also has 10 other method and function calls in it, one of which allocates a new 4-element array<p>also it&#x27;s maintaining a stack of pixels to paint instead of looping over a scan line<p>each iteration of the loop paints one pixel<p>i don&#x27;t think canvas memory access patterns are the root of the performance problem<p>i&#x27;m not saying it&#x27;s bad code, just that it doesn&#x27;t justify your conclusion</div><br/><div id="36053775" class="c"><input type="checkbox" id="c-36053775" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#36051081">root</a><span>|</span><a href="#36051644">parent</a><span>|</span><a href="#36053966">next</a><span>|</span><label class="collapse" for="c-36053775">[-]</label><label class="expand" for="c-36053775">[1 more]</label></div><br/><div class="children"><div class="content">actually on further examination i think each four iterations of the loop paint one pixel in the most common case, because each pixel in a large filled area gets visited from each of its neighbors</div><br/></div></div></div></div><div id="36053966" class="c"><input type="checkbox" id="c-36053966" checked=""/><div class="controls bullet"><span class="by">ghusbands</span><span>|</span><a href="#36051081">root</a><span>|</span><a href="#36051436">parent</a><span>|</span><a href="#36051644">prev</a><span>|</span><a href="#36052275">next</a><span>|</span><label class="collapse" for="c-36053966">[-]</label><label class="expand" for="c-36053966">[6 more]</label></div><br/><div class="children"><div class="content">No, JS and Canvas aren&#x27;t the issue, there; the code you wrote will perform terribly in any language on any platform. You used a four-way recursive per-pixel fill algorithm. You should probably do a bit of reading on flood fill algorithms (maybe read the Wikipedia flood fill article).</div><br/><div id="36054762" class="c"><input type="checkbox" id="c-36054762" checked=""/><div class="controls bullet"><span class="by">irskep</span><span>|</span><a href="#36051081">root</a><span>|</span><a href="#36053966">parent</a><span>|</span><a href="#36054031">next</a><span>|</span><label class="collapse" for="c-36054762">[-]</label><label class="expand" for="c-36054762">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right, the code is not performant at all. At the time I was hacking around and just happy to get something working. I think the code is a tempting distraction, but I was trying to say that browser API performance is not always what you would expect and sometimes you need to get creative in order to get the results you want.</div><br/><div id="36054881" class="c"><input type="checkbox" id="c-36054881" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#36051081">root</a><span>|</span><a href="#36054762">parent</a><span>|</span><a href="#36054031">next</a><span>|</span><label class="collapse" for="c-36054881">[-]</label><label class="expand" for="c-36054881">[1 more]</label></div><br/><div class="children"><div class="content">okay but i think we aren&#x27;t being too optimistic about browser performance, memory access patterns aren&#x27;t the problem, and canvas implementations are adequately well suited for the flood fill problem space, which directly contradict three assertions you did actually say, even if they weren&#x27;t what you were trying to say</div><br/></div></div></div></div><div id="36054031" class="c"><input type="checkbox" id="c-36054031" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#36051081">root</a><span>|</span><a href="#36053966">parent</a><span>|</span><a href="#36054762">prev</a><span>|</span><a href="#36052275">next</a><span>|</span><label class="collapse" for="c-36054031">[-]</label><label class="expand" for="c-36054031">[3 more]</label></div><br/><div class="children"><div class="content">it isn&#x27;t recursive in the sense of a function calling itself, just in the mathematical sense of using its own previous output as input<p>i agree that it&#x27;s easy to better its performance substantially, but i wouldn&#x27;t go so far as to say &#x27;perform terribly&#x27;, except in the sense that it&#x27;s far from optimal.  there are applications where it would be adequate</div><br/><div id="36054807" class="c"><input type="checkbox" id="c-36054807" checked=""/><div class="controls bullet"><span class="by">ghusbands</span><span>|</span><a href="#36051081">root</a><span>|</span><a href="#36054031">parent</a><span>|</span><a href="#36052275">next</a><span>|</span><label class="collapse" for="c-36054807">[-]</label><label class="expand" for="c-36054807">[2 more]</label></div><br/><div class="children"><div class="content">There are situations where bubble-sort is adequate, too, but it&#x27;s still not a good idea to use it or claim that it performing badly reflects on the implementation language. The code uses an explicit stack in place of recursion, sure, but that&#x27;s not particularly salient; it&#x27;s just recursion without stack overflow.<p>The code allocates data structures at least eight times per pixel, and tests pixels at least four times. It will perform badly in all languages and so cannot be used as a reliable indication of JS&#x2F;Canvas performance.</div><br/><div id="36054816" class="c"><input type="checkbox" id="c-36054816" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#36051081">root</a><span>|</span><a href="#36054807">parent</a><span>|</span><a href="#36052275">next</a><span>|</span><label class="collapse" for="c-36054816">[-]</label><label class="expand" for="c-36054816">[1 more]</label></div><br/><div class="children"><div class="content">agreed, except that the reason it&#x27;s never a good idea to use bubble sort is that insertion sort is just as simple and always performs much better; there are cases where insertion sort really is the right thing to use despite its usually quadratic performance<p>there might even be a case where the single-loop sort is the right thing to use, despite its abominable performance, because it&#x27;s simpler than bubble sort or insertion sort; i think it&#x27;s 12 amd64 instructions, 40 bytes<p><pre><code>    for (i = 1; i &lt; n; i++)
      if (a[i-1] &gt; a[i]) t = a[i], a[i] = a[i-1], a[i-1] = t, i = 0;
</code></pre>
but i haven&#x27;t seen it yet</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36052275" class="c"><input type="checkbox" id="c-36052275" checked=""/><div class="controls bullet"><span class="by">Falvyu</span><span>|</span><a href="#36051081">root</a><span>|</span><a href="#36051146">parent</a><span>|</span><a href="#36051436">prev</a><span>|</span><a href="#36051194">next</a><span>|</span><label class="collapse" for="c-36052275">[-]</label><label class="expand" for="c-36052275">[4 more]</label></div><br/><div class="children"><div class="content">You can probably make the process extremely fast by replacing the flood-fill approach with a something based on a Connected-Component Labeling algorithm ( <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Connected-component_labeling" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Connected-component_labeling</a> ). There&#x27;s a good amount of literature on the subject and it&#x27;s often included in computer vision libraries (e.g. OpenCV).<p>You&#x27;d first threshold the image by checking if a pixel is &#x27;close enough&#x27; to the clicked pixel. This will create a B&amp;W image. Then you call the CCL on this binary image to produce a labelled image: each pixel will contain the id of its component (i.e. which enclosed space it belongs to). Once you have this, it&#x27;s just a matter of replacing colors on the canvas for pixels with the same id as the clicked pixels.<p>Obviously, that&#x27;s just the &#x27;theory&#x27; part. If you can find a good library that includes one then you&#x27;ll have to integrate it. Otherwise, you&#x27;ll have to re-implement that in Javascript, which is easier said than done and may also not reach the desired performance.</div><br/><div id="36052365" class="c"><input type="checkbox" id="c-36052365" checked=""/><div class="controls bullet"><span class="by">shaneos</span><span>|</span><a href="#36051081">root</a><span>|</span><a href="#36052275">parent</a><span>|</span><a href="#36051194">next</a><span>|</span><label class="collapse" for="c-36052365">[-]</label><label class="expand" for="c-36052365">[3 more]</label></div><br/><div class="children"><div class="content">Thanks, I’ll take a look at the article. This  generally sounds very similar to my pre processing algorithm, setting the id of the enclosing area into each pixel so a fast&#x2F;instant operation can be applied. Am I missing something though? In my solution, the only thing that happens when the user clicks is a fillRect() call. Is your suggestion similarly fast on click?</div><br/><div id="36052538" class="c"><input type="checkbox" id="c-36052538" checked=""/><div class="controls bullet"><span class="by">Falvyu</span><span>|</span><a href="#36051081">root</a><span>|</span><a href="#36052365">parent</a><span>|</span><a href="#36053913">next</a><span>|</span><label class="collapse" for="c-36052538">[-]</label><label class="expand" for="c-36052538">[1 more]</label></div><br/><div class="children"><div class="content">I think the main difference is that the CCL would compute &#x27;enclosed areas&#x27; on the fly. To be more specific, it would first create a mask (black &amp; white) of pixels that are similar to the clicked pixel, and then find connections between foreground&#x2F;white pixels.<p>I don&#x27;t work in web development but accelerating CCL algorithms do happen to be my area of expertise. While their execution time depends on the image content, you can expect them to be in the tens of milliseconds for a 4K image, at least for the &#x27;modern&#x27; one you can find in OpenCV, and on current consumer-level CPUs, without multi-threading.<p>Of course, implementing these newer algorithms isn&#x27;t straightforward. That&#x27;s why you should instead use something like OpenCV if you have the option to.<p>Moreover, if CCL doesn&#x27;t fit what you&#x27;re looking for then you can also check out watershed algorithms ( <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Watershed_%28image_processing%29" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Watershed_%28image_processing%...</a> ). Because they don&#x27;t work on binary image, they <i>might</i> be a better way to describe what you call &#x27;enclosed space&#x27;.</div><br/></div></div><div id="36053913" class="c"><input type="checkbox" id="c-36053913" checked=""/><div class="controls bullet"><span class="by">ghusbands</span><span>|</span><a href="#36051081">root</a><span>|</span><a href="#36052365">parent</a><span>|</span><a href="#36052538">prev</a><span>|</span><a href="#36051194">next</a><span>|</span><label class="collapse" for="c-36053913">[-]</label><label class="expand" for="c-36053913">[1 more]</label></div><br/><div class="children"><div class="content">One visible difference would be that if there are two identically-colored overlapping objects, the article&#x27;s method will treat them as two separate areas, whereas the algorithm mentioned above will treat them as one.<p>There are faster fill algorithms than the above, described on Wikipedia, that don&#x27;t need you to visit the whole image [1]. In particular, span-based filling.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Flood_fill" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Flood_fill</a></div><br/></div></div></div></div></div></div></div></div><div id="36051273" class="c"><input type="checkbox" id="c-36051273" checked=""/><div class="controls bullet"><span class="by">thrashh</span><span>|</span><a href="#36051081">parent</a><span>|</span><a href="#36051146">prev</a><span>|</span><a href="#36054810">next</a><span>|</span><label class="collapse" for="c-36051273">[-]</label><label class="expand" for="c-36051273">[4 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no reason a JIT&#x27;d runtime is going to find this job challenging or slow at all.<p>I don&#x27;t know what OP&#x27;s original code is but maybe OP was calling a Canvas API method for every pixel (super bad).</div><br/><div id="36053062" class="c"><input type="checkbox" id="c-36053062" checked=""/><div class="controls bullet"><span class="by">johnfn</span><span>|</span><a href="#36051081">root</a><span>|</span><a href="#36051273">parent</a><span>|</span><a href="#36051451">next</a><span>|</span><label class="collapse" for="c-36053062">[-]</label><label class="expand" for="c-36053062">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried writing a fast flood fill in JS and it&#x27;s a lot more challenging than you and GP make it out to be. If it&#x27;s really so straightforward, you should produce code. Otherwise, these comments don&#x27;t add much to the discussion.</div><br/><div id="36053788" class="c"><input type="checkbox" id="c-36053788" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#36051081">root</a><span>|</span><a href="#36053062">parent</a><span>|</span><a href="#36051451">next</a><span>|</span><label class="collapse" for="c-36053788">[-]</label><label class="expand" for="c-36053788">[1 more]</label></div><br/><div class="children"><div class="content">i&#x27;d be surprised if someone could do it within the editing window for an hn comment, but it doesn&#x27;t seem like more than a day or two of work for double-digit megapixel fill rates</div><br/></div></div></div></div><div id="36051451" class="c"><input type="checkbox" id="c-36051451" checked=""/><div class="controls bullet"><span class="by">shaneos</span><span>|</span><a href="#36051081">root</a><span>|</span><a href="#36051273">parent</a><span>|</span><a href="#36053062">prev</a><span>|</span><a href="#36054810">next</a><span>|</span><label class="collapse" for="c-36051451">[-]</label><label class="expand" for="c-36051451">[1 more]</label></div><br/><div class="children"><div class="content">I wasn’t calling per pixel :-) even when just visiting each pixel once it would still take 50 - 100ms to fill a large image which the user perceives as lag. I wanted it to be instant</div><br/></div></div></div></div></div></div><div id="36054810" class="c"><input type="checkbox" id="c-36054810" checked=""/><div class="controls bullet"><span class="by">primitivesuave</span><span>|</span><a href="#36051081">prev</a><span>|</span><a href="#36051900">next</a><span>|</span><label class="collapse" for="c-36054810">[-]</label><label class="expand" for="c-36054810">[2 more]</label></div><br/><div class="children"><div class="content">This is a very neat implementation and explanation of a disjoint set algorithm: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Disjoint-set_data_structure" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Disjoint-set_data_structure</a></div><br/></div></div><div id="36051900" class="c"><input type="checkbox" id="c-36051900" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#36054810">prev</a><span>|</span><a href="#36053188">next</a><span>|</span><label class="collapse" for="c-36051900">[-]</label><label class="expand" for="c-36051900">[2 more]</label></div><br/><div class="children"><div class="content">Surprised &quot;jump flooding&quot; hasn&#x27;t been mentioned yet, which is the common technique to accelerate this sort of thing (used for color fills, signed distance field construction, outlines, etc.).</div><br/><div id="36054067" class="c"><input type="checkbox" id="c-36054067" checked=""/><div class="controls bullet"><span class="by">ghusbands</span><span>|</span><a href="#36051900">parent</a><span>|</span><a href="#36053188">next</a><span>|</span><label class="collapse" for="c-36054067">[-]</label><label class="expand" for="c-36054067">[1 more]</label></div><br/><div class="children"><div class="content">Jump-flooding is inexact and can jump over significant edges. The runtimes claimed are also incorrect - as it sets every pixel, it is O(N^2) in the image dimensions, just like flood-filling. If you&#x27;re working with an image and setting pixels, you cannot avoid being O(N^2) in the dimensions of the filled area.</div><br/></div></div></div></div><div id="36053188" class="c"><input type="checkbox" id="c-36053188" checked=""/><div class="controls bullet"><span class="by">TeffenEllis</span><span>|</span><a href="#36051900">prev</a><span>|</span><a href="#36052149">next</a><span>|</span><label class="collapse" for="c-36053188">[-]</label><label class="expand" for="c-36053188">[2 more]</label></div><br/><div class="children"><div class="content">This is very clever! I found out about the canvas composite modes far too late in an animated ASCII art project.<p>IMO, the canvas APIs are a little too esoteric for their own good. It’s almost like a stateful object, but all the commands are executed as side effects. Isn’t front end fun?<p>Please have a look at my project and let me know what you think! The source code is fully annotated for another brave soul who’s working with the dark arts of high performance canvas rendering.<p>- Project page: <a href="https:&#x2F;&#x2F;asciify.sister.software" rel="nofollow">https:&#x2F;&#x2F;asciify.sister.software</a><p>- Demo: <a href="https:&#x2F;&#x2F;asciify.sister.software&#x2F;demo&#x2F;3d&#x2F;" rel="nofollow">https:&#x2F;&#x2F;asciify.sister.software&#x2F;demo&#x2F;3d&#x2F;</a></div><br/><div id="36055185" class="c"><input type="checkbox" id="c-36055185" checked=""/><div class="controls bullet"><span class="by">jvdvegt</span><span>|</span><a href="#36053188">parent</a><span>|</span><a href="#36052149">next</a><span>|</span><label class="collapse" for="c-36055185">[-]</label><label class="expand" for="c-36055185">[1 more]</label></div><br/><div class="children"><div class="content">The demo page is blank for me? (Firefox on Ubuntu, on a AMD laptop).</div><br/></div></div></div></div><div id="36052149" class="c"><input type="checkbox" id="c-36052149" checked=""/><div class="controls bullet"><span class="by">joeldo</span><span>|</span><a href="#36053188">prev</a><span>|</span><a href="#36051160">next</a><span>|</span><label class="collapse" for="c-36052149">[-]</label><label class="expand" for="c-36052149">[2 more]</label></div><br/><div class="children"><div class="content">For vector style graphics (like in the article) - You can achieve this quite simply on the web with SVG DOM.<p>You can add event listeners to the SVG&#x27;s paths&#x2F;groups and apply fill when clicked.</div><br/><div id="36054263" class="c"><input type="checkbox" id="c-36054263" checked=""/><div class="controls bullet"><span class="by">yuchi</span><span>|</span><a href="#36052149">parent</a><span>|</span><a href="#36051160">next</a><span>|</span><label class="collapse" for="c-36054263">[-]</label><label class="expand" for="c-36054263">[1 more]</label></div><br/><div class="children"><div class="content">Even better, you can just use a single listener and on click verify the element under the cursor with document.elementFromPoint</div><br/></div></div></div></div><div id="36051160" class="c"><input type="checkbox" id="c-36051160" checked=""/><div class="controls bullet"><span class="by">TazeTSchnitzel</span><span>|</span><a href="#36052149">prev</a><span>|</span><a href="#36053118">next</a><span>|</span><label class="collapse" for="c-36051160">[-]</label><label class="expand" for="c-36051160">[5 more]</label></div><br/><div class="children"><div class="content">Why does it need separate mask images? Couldn&#x27;t you use the indices in the alpha layer to do the flood-fill by looping over every pixel in the image and changing the colour if the index matches? It would save memory, right? That per-pixel loop should be fast enough, since there&#x27;s just one pass and it&#x27;s simple enough any JS JIT ought to be able to optimise it.</div><br/><div id="36051252" class="c"><input type="checkbox" id="c-36051252" checked=""/><div class="controls bullet"><span class="by">shaneos</span><span>|</span><a href="#36051160">parent</a><span>|</span><a href="#36053118">next</a><span>|</span><label class="collapse" for="c-36051252">[-]</label><label class="expand" for="c-36051252">[4 more]</label></div><br/><div class="children"><div class="content">The speed is achieved by using the fillRect() command with globalCompositeOperation. This is a single draw operation rather than a per pixel algorithm while the user waits. Anything more involved than this would, I think, be slower as perceived by the user</div><br/><div id="36052306" class="c"><input type="checkbox" id="c-36052306" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#36051160">root</a><span>|</span><a href="#36051252">parent</a><span>|</span><a href="#36053118">next</a><span>|</span><label class="collapse" for="c-36052306">[-]</label><label class="expand" for="c-36052306">[3 more]</label></div><br/><div class="children"><div class="content">Makes me wonder if this could be even faster, if you cheated and just generated copies of the masks already colored, for every color available. From looking at the video, I see you have 10-11 colors available at any given moment with possibility of changing them to, presumably, arbitrary RGB value. That means you only need to keep 11 color variants of each mask, which should still fit in RAM. You also need to be able to replace a single group of masks with a new set of masks faster than the user can switch colors in the custom color picker.<p>(I know, it&#x27;s a dumb idea in this case; I&#x27;m posting it as a reminder to both myself and everyone else, that many problems can be solved by checking or caching every possible state.)</div><br/><div id="36054572" class="c"><input type="checkbox" id="c-36054572" checked=""/><div class="controls bullet"><span class="by">shaneos</span><span>|</span><a href="#36051160">root</a><span>|</span><a href="#36052306">parent</a><span>|</span><a href="#36053118">next</a><span>|</span><label class="collapse" for="c-36054572">[-]</label><label class="expand" for="c-36054572">[2 more]</label></div><br/><div class="children"><div class="content">The user can select from thousands of colours unfortunately :-) Tap the top left icon in the app, or just play with it for fun! <a href="https:&#x2F;&#x2F;kidzfun.art" rel="nofollow">https:&#x2F;&#x2F;kidzfun.art</a></div><br/><div id="36055224" class="c"><input type="checkbox" id="c-36055224" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#36051160">root</a><span>|</span><a href="#36054572">parent</a><span>|</span><a href="#36053118">next</a><span>|</span><label class="collapse" for="c-36055224">[-]</label><label class="expand" for="c-36055224">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but <i>at any given moment</i>, they can use only ~12 of them (+ the rainbow thing, now that I played a bit and know how it works). Meaning, you can keep 12 pre-filled variants of each mask, one for each color on the main palette, and recolor all masks of a given color when the user picks a new one from the top-left color picker. I bet you can do this update faster than they can dismiss the color picker and tap on the canvas.<p>I see you have drawing tools there as well, but they seem to be ignored by flood filling (e.g. if I draw a closed circular border myself and use flood-fill on the empty centre, the fill will just paint over my circle border and continue filling to the boundaries of the initial region of the original image) - so they don&#x27;t even make a counterpoint I was worrying they would.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36053118" class="c"><input type="checkbox" id="c-36053118" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#36051160">prev</a><span>|</span><a href="#36050687">next</a><span>|</span><label class="collapse" for="c-36053118">[-]</label><label class="expand" for="c-36053118">[1 more]</label></div><br/><div class="children"><div class="content">Apart from algorithm commentary by folks who are certainly wiser than me on the topic: since you’re already using a worker, you would probably benefit from using OffscreenCanvas[0], which is transferrable to worker threads and otherwise should be optimized for heavier computations.<p>0: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;OffscreenCanvas" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;OffscreenCa...</a></div><br/></div></div><div id="36050687" class="c"><input type="checkbox" id="c-36050687" checked=""/><div class="controls bullet"><span class="by">RandallBrown</span><span>|</span><a href="#36053118">prev</a><span>|</span><a href="#36053519">next</a><span>|</span><label class="collapse" for="c-36050687">[-]</label><label class="expand" for="c-36050687">[13 more]</label></div><br/><div class="children"><div class="content">Seems like there must be a better way?<p><a href="https:&#x2F;&#x2F;paintz.app" rel="nofollow">https:&#x2F;&#x2F;paintz.app</a> seems to be able to do this without precomputing all of the spaces you could flood.</div><br/><div id="36050827" class="c"><input type="checkbox" id="c-36050827" checked=""/><div class="controls bullet"><span class="by">occamrazor</span><span>|</span><a href="#36050687">parent</a><span>|</span><a href="#36050898">next</a><span>|</span><label class="collapse" for="c-36050827">[-]</label><label class="expand" for="c-36050827">[2 more]</label></div><br/><div class="children"><div class="content">The naive method is slow because it repaints the image several times. A faster way is a sort of double buffering: copy the image to an array, perform the fill on the array, copy the array to the canvas image data.<p>The method in TFA is however faster for static images, after the preprocessing.</div><br/><div id="36051003" class="c"><input type="checkbox" id="c-36051003" checked=""/><div class="controls bullet"><span class="by">shaneos</span><span>|</span><a href="#36050687">root</a><span>|</span><a href="#36050827">parent</a><span>|</span><a href="#36050898">next</a><span>|</span><label class="collapse" for="c-36051003">[-]</label><label class="expand" for="c-36051003">[1 more]</label></div><br/><div class="children"><div class="content">There’s a trade off between speed and showing progress to the user. I find it better to show slow progress rather than wait 500 - 1000ms to do it faster, but it depends on the use case</div><br/></div></div></div></div><div id="36050898" class="c"><input type="checkbox" id="c-36050898" checked=""/><div class="controls bullet"><span class="by">evan_</span><span>|</span><a href="#36050687">parent</a><span>|</span><a href="#36050827">prev</a><span>|</span><a href="#36050915">next</a><span>|</span><label class="collapse" for="c-36050898">[-]</label><label class="expand" for="c-36050898">[5 more]</label></div><br/><div class="children"><div class="content">Wikipedia lists a bunch of Flood Fill algorithms. It looks like they all involve some form of checking every pixel one-by-one:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Flood_fill" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Flood_fill</a><p>I was hoping the author had figured out some clever solution involving some implementation detail of HTML Canvas.</div><br/><div id="36051042" class="c"><input type="checkbox" id="c-36051042" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#36050687">root</a><span>|</span><a href="#36050898">parent</a><span>|</span><a href="#36050915">next</a><span>|</span><label class="collapse" for="c-36051042">[-]</label><label class="expand" for="c-36051042">[4 more]</label></div><br/><div class="children"><div class="content">For a typical users use case, I bet you could downscale the image 16x (using the GPU, and therefore very fast), flood fill on the much smaller image (using slow javascript over each pixel), then expand the image up to the original size and reprocess just the border pixels (and there aren&#x27;t many border pixels compared to the total filled area).<p>This method might not produce perfect results when the paint can &#x27;escape&#x27; through a tiny gap that isn&#x27;t visible on the downscaled version...     But at the same time, I suspect most users don&#x27;t actually want the paint to escape through a tiny gap, so that might be the right behaviour.</div><br/><div id="36051209" class="c"><input type="checkbox" id="c-36051209" checked=""/><div class="controls bullet"><span class="by">yetanotherloser</span><span>|</span><a href="#36050687">root</a><span>|</span><a href="#36051042">parent</a><span>|</span><a href="#36052585">next</a><span>|</span><label class="collapse" for="c-36051209">[-]</label><label class="expand" for="c-36051209">[1 more]</label></div><br/><div class="children"><div class="content">Been a long time since I was a kid playing with Deluxe Paint, but &quot;fill except where I missed a tiny gap&quot; would have been exactly what I wished the fill tool would do! I don&#x27;t think I&#x27;ve used a fill tool in earnest since :-(</div><br/></div></div><div id="36052585" class="c"><input type="checkbox" id="c-36052585" checked=""/><div class="controls bullet"><span class="by">eastof</span><span>|</span><a href="#36050687">root</a><span>|</span><a href="#36051042">parent</a><span>|</span><a href="#36051209">prev</a><span>|</span><a href="#36050915">next</a><span>|</span><label class="collapse" for="c-36052585">[-]</label><label class="expand" for="c-36052585">[2 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t you get a super pixelated version of your original image back? Downscaling is lossy.</div><br/><div id="36052918" class="c"><input type="checkbox" id="c-36052918" checked=""/><div class="controls bullet"><span class="by">ajuc</span><span>|</span><a href="#36050687">root</a><span>|</span><a href="#36052585">parent</a><span>|</span><a href="#36050915">next</a><span>|</span><label class="collapse" for="c-36052918">[-]</label><label class="expand" for="c-36052918">[1 more]</label></div><br/><div class="children"><div class="content">You wouldn&#x27;t upscale, you&#x27;d fill 16x16 blocks in original image iterating over downscaled image and if the block wasn&#x27;t all the same color you&#x27;d process it normally. In fact you don&#x27;t need to flood fill in downscaled image, just do edge detection.</div><br/></div></div></div></div></div></div></div></div><div id="36050915" class="c"><input type="checkbox" id="c-36050915" checked=""/><div class="controls bullet"><span class="by">dvh</span><span>|</span><a href="#36050687">parent</a><span>|</span><a href="#36050898">prev</a><span>|</span><a href="#36053519">next</a><span>|</span><label class="collapse" for="c-36050915">[-]</label><label class="expand" for="c-36050915">[5 more]</label></div><br/><div class="children"><div class="content">There is a option in getContext called willReadFrequently that specifies that pixels are read often maybe that would help.</div><br/><div id="36051004" class="c"><input type="checkbox" id="c-36051004" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#36050687">root</a><span>|</span><a href="#36050915">parent</a><span>|</span><a href="#36050979">next</a><span>|</span><label class="collapse" for="c-36051004">[-]</label><label class="expand" for="c-36051004">[1 more]</label></div><br/><div class="children"><div class="content">willReadFrequently disables the use of the GPU.   All canvas operations will be software rendered on the javascript thread.    The actual operations happen not when you make the draw() call, but when you read any pixel of the canvas.</div><br/></div></div><div id="36050979" class="c"><input type="checkbox" id="c-36050979" checked=""/><div class="controls bullet"><span class="by">shaneos</span><span>|</span><a href="#36050687">root</a><span>|</span><a href="#36050915">parent</a><span>|</span><a href="#36051004">prev</a><span>|</span><a href="#36053519">next</a><span>|</span><label class="collapse" for="c-36050979">[-]</label><label class="expand" for="c-36050979">[3 more]</label></div><br/><div class="children"><div class="content">Author here: in the app I use that, it seems to help alright</div><br/><div id="36051000" class="c"><input type="checkbox" id="c-36051000" checked=""/><div class="controls bullet"><span class="by">acqq</span><span>|</span><a href="#36050687">root</a><span>|</span><a href="#36050979">parent</a><span>|</span><a href="#36053519">next</a><span>|</span><label class="collapse" for="c-36051000">[-]</label><label class="expand" for="c-36051000">[2 more]</label></div><br/><div class="children"><div class="content">What are your thoughts on this?<p><a href="http:&#x2F;&#x2F;www.adammil.net&#x2F;blog&#x2F;v126_A_More_Efficient_Flood_Fill.html" rel="nofollow">http:&#x2F;&#x2F;www.adammil.net&#x2F;blog&#x2F;v126_A_More_Efficient_Flood_Fill...</a></div><br/><div id="36052203" class="c"><input type="checkbox" id="c-36052203" checked=""/><div class="controls bullet"><span class="by">shaneos</span><span>|</span><a href="#36050687">root</a><span>|</span><a href="#36051000">parent</a><span>|</span><a href="#36053519">next</a><span>|</span><label class="collapse" for="c-36052203">[-]</label><label class="expand" for="c-36052203">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the link, it’s great write up. I’ll play with his algorithm to see how it works for me, it may speed up the pre-processing. Its still slower to the user than using the pre generated masks however</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36053519" class="c"><input type="checkbox" id="c-36053519" checked=""/><div class="controls bullet"><span class="by">stkdump</span><span>|</span><a href="#36050687">prev</a><span>|</span><a href="#36051187">next</a><span>|</span><label class="collapse" for="c-36053519">[-]</label><label class="expand" for="c-36053519">[1 more]</label></div><br/><div class="children"><div class="content">In the past we had indexed color screen modes. You could draw all pixels to the screen once and give each pixel an index into a color palette. When you would start, they would all be mapped to white, but as you start with coloring, you would then just change the color of the palette entry (truly a O(1) operation) and your graphics card would then do the work at scan time. I guess the closest equivalent nowadays would be to do this inside the pixel shader.</div><br/></div></div><div id="36051187" class="c"><input type="checkbox" id="c-36051187" checked=""/><div class="controls bullet"><span class="by">chrisweekly</span><span>|</span><a href="#36053519">prev</a><span>|</span><a href="#36052509">next</a><span>|</span><label class="collapse" for="c-36051187">[-]</label><label class="expand" for="c-36051187">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of an iOS puzzle game I really enjoyed a year or two ago called &quot;Kami 2&quot;. Picture a canvas with geometric shapes in a few different colors. The goal is to paint the whole canvas in one color, armed with a limited number of &quot;fill&quot; operations. Highly recommended.</div><br/></div></div><div id="36052509" class="c"><input type="checkbox" id="c-36052509" checked=""/><div class="controls bullet"><span class="by">Camillo</span><span>|</span><a href="#36051187">prev</a><span>|</span><a href="#36050522">next</a><span>|</span><label class="collapse" for="c-36052509">[-]</label><label class="expand" for="c-36052509">[5 more]</label></div><br/><div class="children"><div class="content">You could do instant flood-fill on a slow PC in the early 90s. There is no need to precompute this. The possible issues are:<p>1. You&#x27;re using a slow algorithm. This is almost certainly the case, looking at how slowly it run and at the order in which pixels get painted. The Wikipedia page on flood fill is enough to find a good algorithm.<p>2. Possibly, the overhead of individual canvas operations is high, so setting each pixel at once is slow. If this is the case, it would be partially ameliorated by using a span-based algorithm, but you could also run the algorithm on an offscreen byte array and then blit the result to canvas.<p>I would bet money that a 90s state-of-the-art algorithm running in JavaScript on an offscreen array will be perceived as instantaneous on a modern computer.</div><br/><div id="36053864" class="c"><input type="checkbox" id="c-36053864" checked=""/><div class="controls bullet"><span class="by">stkdump</span><span>|</span><a href="#36052509">parent</a><span>|</span><a href="#36054599">next</a><span>|</span><label class="collapse" for="c-36053864">[-]</label><label class="expand" for="c-36053864">[1 more]</label></div><br/><div class="children"><div class="content">Note that you loose 1-2 orders of magnitude just by the screen resolution (in the early nineties we used 640x480, sometimes even 320x200 vs 4K nowadays). Another order of magnitude is lost by using a more high level programming language, which sure you could probably optimize down to factor 2-3. Plus sublinear scaling of stuff like memory latency since the 90s. All in all I agree we should be able to do better, but it is by no means trivial.</div><br/></div></div><div id="36054599" class="c"><input type="checkbox" id="c-36054599" checked=""/><div class="controls bullet"><span class="by">shaneos</span><span>|</span><a href="#36052509">parent</a><span>|</span><a href="#36053864">prev</a><span>|</span><a href="#36052575">next</a><span>|</span><label class="collapse" for="c-36054599">[-]</label><label class="expand" for="c-36054599">[2 more]</label></div><br/><div class="children"><div class="content">If you are right that would be amazing! The demo code is open source, please send a PR with such a flood fill implemented.<p>The requirement is that when the user clicks on a 2k x 2k image it takes 50ms or less, running on a cheap Android tablet. If a better algorithm, perhaps implemented in wasm, can achieve this, I’d love to discard all my complex code and just use it</div><br/><div id="36054783" class="c"><input type="checkbox" id="c-36054783" checked=""/><div class="controls bullet"><span class="by">irskep</span><span>|</span><a href="#36052509">root</a><span>|</span><a href="#36054599">parent</a><span>|</span><a href="#36052575">next</a><span>|</span><label class="collapse" for="c-36054783">[-]</label><label class="expand" for="c-36054783">[1 more]</label></div><br/><div class="children"><div class="content">I love that everybody commenting here here emphatically insists that you must be doing it wrong, but real-world solutions are nowhere to be found. I admire your commitment to keeping a positive tone, but you&#x27;d be justified in feeling some frustration.<p>I do hope a PR shows up in the next few days so the internet can stop having this debate and move on with a good library.</div><br/></div></div></div></div><div id="36052575" class="c"><input type="checkbox" id="c-36052575" checked=""/><div class="controls bullet"><span class="by">buescher</span><span>|</span><a href="#36052509">parent</a><span>|</span><a href="#36054599">prev</a><span>|</span><a href="#36050522">next</a><span>|</span><label class="collapse" for="c-36052575">[-]</label><label class="expand" for="c-36052575">[1 more]</label></div><br/><div class="children"><div class="content">There are fast segment based fill algorithms from the seventies or very early eighties in the literature and reprinted in the first volume of Graphics Gems.  They work very well and do not require the call stack or amount of computation of simpler methods.</div><br/></div></div></div></div><div id="36050522" class="c"><input type="checkbox" id="c-36050522" checked=""/><div class="controls bullet"><span class="by">zachrip</span><span>|</span><a href="#36052509">prev</a><span>|</span><a href="#36052492">next</a><span>|</span><label class="collapse" for="c-36050522">[-]</label><label class="expand" for="c-36050522">[6 more]</label></div><br/><div class="children"><div class="content">This works well for the problem space - does it work well for a drawing app where the canvas is always changing?</div><br/><div id="36052504" class="c"><input type="checkbox" id="c-36052504" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#36050522">parent</a><span>|</span><a href="#36050985">next</a><span>|</span><label class="collapse" for="c-36052504">[-]</label><label class="expand" for="c-36052504">[1 more]</label></div><br/><div class="children"><div class="content">Modifying it to work with a changing canvas shouldn&#x27;t be too difficult.<p>You could simply clear the mask of a bounding box around the changes, and recalculate the masks inside that bounding box. In addition to hitting the &quot;edge&quot; of a drawing area, the algorithm can now also bit the edge of the bounding box and encounter an outside mask - which means the inside mask and outside mask can be ORed to get a new composite mask.<p>You&#x27;d have to take care with the fact that an edit can join two previously-separate areas together, but that&#x27;d also  be a simple OR. The more tricky scenario is an edit splitting an existing area in two. It is reasonably easy to determine that an edit is <i>trying</i> to split an area, but it is not immediately obvious to me how you&#x27;d efficiently determine that no connection between two halves exists <i>outside</i> the edit bounding box: how do you distinguish a &quot;|&quot; turning into a &quot;:&quot; from an &quot;O&quot; turning into a &quot;C&quot;?</div><br/></div></div><div id="36050985" class="c"><input type="checkbox" id="c-36050985" checked=""/><div class="controls bullet"><span class="by">shaneos</span><span>|</span><a href="#36050522">parent</a><span>|</span><a href="#36052504">prev</a><span>|</span><a href="#36051153">next</a><span>|</span><label class="collapse" for="c-36050985">[-]</label><label class="expand" for="c-36050985">[1 more]</label></div><br/><div class="children"><div class="content">It can be made work. Precompute the image when the flood fill tool is activated and it’s fine, since you only have to do it once</div><br/></div></div><div id="36051153" class="c"><input type="checkbox" id="c-36051153" checked=""/><div class="controls bullet"><span class="by">ZiiS</span><span>|</span><a href="#36050522">parent</a><span>|</span><a href="#36050985">prev</a><span>|</span><a href="#36050678">next</a><span>|</span><label class="collapse" for="c-36051153">[-]</label><label class="expand" for="c-36051153">[1 more]</label></div><br/><div class="children"><div class="content">Tbh adding a background pixel only needs to check its four surrounding to see if it joined seperate areas, adding a fourground is harder I expect you need Dijkstra.</div><br/></div></div><div id="36050678" class="c"><input type="checkbox" id="c-36050678" checked=""/><div class="controls bullet"><span class="by">rattray</span><span>|</span><a href="#36050522">parent</a><span>|</span><a href="#36051153">prev</a><span>|</span><a href="#36052492">next</a><span>|</span><label class="collapse" for="c-36050678">[-]</label><label class="expand" for="c-36050678">[2 more]</label></div><br/><div class="children"><div class="content">Interesting – what behavior would you want there? Statically filled area, or a shifting area depending on the other pixels?</div><br/><div id="36050716" class="c"><input type="checkbox" id="c-36050716" checked=""/><div class="controls bullet"><span class="by">RandallBrown</span><span>|</span><a href="#36050522">root</a><span>|</span><a href="#36050678">parent</a><span>|</span><a href="#36052492">next</a><span>|</span><label class="collapse" for="c-36050716">[-]</label><label class="expand" for="c-36050716">[1 more]</label></div><br/><div class="children"><div class="content">For an app like this I would expect it to be static. Basically the same behavior MS Paint has had for decades.</div><br/></div></div></div></div></div></div><div id="36052492" class="c"><input type="checkbox" id="c-36052492" checked=""/><div class="controls bullet"><span class="by">gatkinso</span><span>|</span><a href="#36050522">prev</a><span>|</span><a href="#36053187">next</a><span>|</span><label class="collapse" for="c-36052492">[-]</label><label class="expand" for="c-36052492">[2 more]</label></div><br/><div class="children"><div class="content">I liked the slow version. more fun.</div><br/><div id="36055130" class="c"><input type="checkbox" id="c-36055130" checked=""/><div class="controls bullet"><span class="by">NeoTar</span><span>|</span><a href="#36052492">parent</a><span>|</span><a href="#36053187">next</a><span>|</span><label class="collapse" for="c-36055130">[-]</label><label class="expand" for="c-36055130">[1 more]</label></div><br/><div class="children"><div class="content">I came into the comments to say the same - the slow version is rather charming like the paint software of the eighties&#x2F;nineties.<p>But of course I imagine it would be frustrating after a few times.</div><br/></div></div></div></div><div id="36053187" class="c"><input type="checkbox" id="c-36053187" checked=""/><div class="controls bullet"><span class="by">robomartin</span><span>|</span><a href="#36052492">prev</a><span>|</span><label class="collapse" for="c-36053187">[-]</label><label class="expand" for="c-36053187">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve played with and implemented a range of area fill algorithms in the past.  Optimized span-filling (dating back to the 1990&#x27;s) works very well, is fast, buffer friendly and delivers great results.  Subtleties surface when you have to consider filling around dithered edges and partially transparent elements.  Fur stuff.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Flood_fill" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Flood_fill</a></div><br/></div></div></div></div></div></div></div></body></html>