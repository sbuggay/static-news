<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726218064028" as="style"/><link rel="stylesheet" href="styles.css?v=1726218064028"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://fight-flash-fraud.readthedocs.io/en/latest/">F3 – Fight Flash Fraud</a> <span class="domain">(<a href="https://fight-flash-fraud.readthedocs.io">fight-flash-fraud.readthedocs.io</a>)</span></div><div class="subtext"><span>CTOSian</span> | <span>35 comments</span></div><br/><div><div id="41527113" class="c"><input type="checkbox" id="c-41527113" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#41526285">next</a><span>|</span><label class="collapse" for="c-41527113">[-]</label><label class="expand" for="c-41527113">[1 more]</label></div><br/><div class="children"><div class="content">This appears to be a cross-platform version of h2testw, which is widely recommended for finding the true capacity of a storage device. Another common recommendation is ChipGenius and the various manufacturer-specific tools, which can read the real ID of the NAND ICs, that AFAIK is beyond the ability of nearly all the fakers to change:<p><a href="https:&#x2F;&#x2F;blog.elcomsoft.com&#x2F;2019&#x2F;01&#x2F;identifying-ssd-controller-and-nand-configuration&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.elcomsoft.com&#x2F;2019&#x2F;01&#x2F;identifying-ssd-controlle...</a><p>From the research I&#x27;ve done (mainly related to data recovery), the NAND flash industry seems extremely secretive and shady in many ways --- from the near-zero availability of public datasheets, to the many rebrands&#x2F;&quot;reclaimed&quot;&#x2F;recycled part sources, to what they&#x27;re doing to SLC and higher-reliability technologies. There are also ways to determine how worn-out a NAND IC is, but even those may be reversible with the right physical treatments.</div><br/></div></div><div id="41526285" class="c"><input type="checkbox" id="c-41526285" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41527113">prev</a><span>|</span><a href="#41527527">next</a><span>|</span><label class="collapse" for="c-41526285">[-]</label><label class="expand" for="c-41526285">[6 more]</label></div><br/><div class="children"><div class="content">Somebody should make this up as a handheld device. Something that you can use to inspect new items, and retailers can use to inspect what their suppliers are sending them.<p>Can a Flipper Zero be programmed for this? It connects to Micro SD cards and USB ports.</div><br/><div id="41526689" class="c"><input type="checkbox" id="c-41526689" checked=""/><div class="controls bullet"><span class="by">RockRobotRock</span><span>|</span><a href="#41526285">parent</a><span>|</span><a href="#41527487">next</a><span>|</span><label class="collapse" for="c-41526689">[-]</label><label class="expand" for="c-41526689">[2 more]</label></div><br/><div class="children"><div class="content">A retailer wouldn&#x27;t want to deal with this. They would expect their distributor to weed out the fakes for them. If enough people complain about poor quality drives, you fire them. In my opinion, anyone selling these must be doing it knowingly at this point.<p>Distributors that care probably use something like this: <a href="https:&#x2F;&#x2F;www.ureach-inc.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.ureach-inc.com&#x2F;</a></div><br/><div id="41527806" class="c"><input type="checkbox" id="c-41527806" checked=""/><div class="controls bullet"><span class="by">denkmoon</span><span>|</span><a href="#41526285">root</a><span>|</span><a href="#41526689">parent</a><span>|</span><a href="#41527487">next</a><span>|</span><label class="collapse" for="c-41527806">[-]</label><label class="expand" for="c-41527806">[1 more]</label></div><br/><div class="children"><div class="content">Ah, but we live in the glorious future, where retailers are just fronts for flea-markets filled with third party crap, and claim zero responsibility. You thought you were buying a flash drive from Best Buy? HA, you actually bought it from AHJKHJ Pty Ltd! And no we won&#x27;t help you!</div><br/></div></div></div></div><div id="41527487" class="c"><input type="checkbox" id="c-41527487" checked=""/><div class="controls bullet"><span class="by">pronoiac</span><span>|</span><a href="#41526285">parent</a><span>|</span><a href="#41526689">prev</a><span>|</span><a href="#41527049">next</a><span>|</span><label class="collapse" for="c-41527487">[-]</label><label class="expand" for="c-41527487">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Can a Flipper Zero be programmed for this? It connects to Micro SD cards and USB ports.<p>I wrote something barebones for this on my Synology, using just a shell script and (hardware accelerated) openssl, if memory serves; that acceleration was <i>crucial</i> for handling, say, an 8TB hard drive.</div><br/></div></div><div id="41527049" class="c"><input type="checkbox" id="c-41527049" checked=""/><div class="controls bullet"><span class="by">cyanydeez</span><span>|</span><a href="#41526285">parent</a><span>|</span><a href="#41527487">prev</a><span>|</span><a href="#41527527">next</a><span>|</span><label class="collapse" for="c-41527049">[-]</label><label class="expand" for="c-41527049">[2 more]</label></div><br/><div class="children"><div class="content">Someone unrmployed should offer to MITM amazon purchases and ensure low priced cards get tested and reshipped or files fraud reports.</div><br/><div id="41527994" class="c"><input type="checkbox" id="c-41527994" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#41526285">root</a><span>|</span><a href="#41527049">parent</a><span>|</span><a href="#41527527">next</a><span>|</span><label class="collapse" for="c-41527994">[-]</label><label class="expand" for="c-41527994">[1 more]</label></div><br/><div class="children"><div class="content">This won&#x27;t work because there are multiple sellers on Amazon. I&#x27;d trust the original packaging of the device more than anyone supposedly running these tests for me, especially since they can take hours to complete.</div><br/></div></div></div></div></div></div><div id="41527527" class="c"><input type="checkbox" id="c-41527527" checked=""/><div class="controls bullet"><span class="by">bdcravens</span><span>|</span><a href="#41526285">prev</a><span>|</span><a href="#41526434">next</a><span>|</span><label class="collapse" for="c-41527527">[-]</label><label class="expand" for="c-41527527">[2 more]</label></div><br/><div class="children"><div class="content">Showing my age: based on the title, I assumed it was a ActionScript scanner.</div><br/><div id="41528600" class="c"><input type="checkbox" id="c-41528600" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41527527">parent</a><span>|</span><a href="#41526434">next</a><span>|</span><label class="collapse" for="c-41528600">[-]</label><label class="expand" for="c-41528600">[1 more]</label></div><br/><div class="children"><div class="content">Flash memory was invented by Toshiba in 1980, and marketed starting in 1987.<p>ActionScript dates back to only 1998.</div><br/></div></div></div></div><div id="41526434" class="c"><input type="checkbox" id="c-41526434" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#41527527">prev</a><span>|</span><a href="#41526527">next</a><span>|</span><label class="collapse" for="c-41526434">[-]</label><label class="expand" for="c-41526434">[7 more]</label></div><br/><div class="children"><div class="content">So this always overwrites the device to test it, and I was wondering if that was necessary (say, you had started using it). Presumably you only need to write at most N+1 blocks, where N is the number of blocks the device <i>actually</i> has.l, in order to detect exaggeration. But at that point the fake device will have overwritten all of your files anyway, even if they were theoretically on different blocks (of the exaggerated inventory). So I guess the minimum harm to test a device is to hash all your files, then write at most N+1 (unused) blocks, stopping after each to check if any of your files got harmed. In theory that risks at most one block...<p>Of course, it&#x27;s better to back up the suspect one.</div><br/><div id="41526804" class="c"><input type="checkbox" id="c-41526804" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#41526434">parent</a><span>|</span><a href="#41526753">next</a><span>|</span><label class="collapse" for="c-41526804">[-]</label><label class="expand" for="c-41526804">[2 more]</label></div><br/><div class="children"><div class="content">&gt; hash all your files, then write at most N+1 (unused) blocks, stopping after each to check if any of your files got harmed<p>That strategy adds O(n^2) reads on top of O(n) writes, though.<p>Even reads don&#x27;t come for free on modern multi-level cell NAND (due to read disturb), and for just a thousand blocks, you&#x27;d end up reading the first block a million times.<p>That&#x27;s to say nothing of the time this would take.</div><br/><div id="41529305" class="c"><input type="checkbox" id="c-41529305" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#41526434">root</a><span>|</span><a href="#41526804">parent</a><span>|</span><a href="#41526753">next</a><span>|</span><label class="collapse" for="c-41529305">[-]</label><label class="expand" for="c-41529305">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that&#x27;s definitely a flaw. On reflection I think this is a lost cause and the owner of a suspect device just needs to bite the bullet and use a destructive method.</div><br/></div></div></div></div><div id="41526753" class="c"><input type="checkbox" id="c-41526753" checked=""/><div class="controls bullet"><span class="by">ThatPlayer</span><span>|</span><a href="#41526434">parent</a><span>|</span><a href="#41526804">prev</a><span>|</span><a href="#41527902">next</a><span>|</span><label class="collapse" for="c-41526753">[-]</label><label class="expand" for="c-41526753">[1 more]</label></div><br/><div class="children"><div class="content">This also has the option of f3probe: <a href="https:&#x2F;&#x2F;fight-flash-fraud.readthedocs.io&#x2F;en&#x2F;latest&#x2F;usage.html#f3probe-the-fastest-drive-test" rel="nofollow">https:&#x2F;&#x2F;fight-flash-fraud.readthedocs.io&#x2F;en&#x2F;latest&#x2F;usage.htm...</a></div><br/></div></div><div id="41527902" class="c"><input type="checkbox" id="c-41527902" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#41526434">parent</a><span>|</span><a href="#41526753">prev</a><span>|</span><a href="#41528006">next</a><span>|</span><label class="collapse" for="c-41527902">[-]</label><label class="expand" for="c-41527902">[2 more]</label></div><br/><div class="children"><div class="content">For a new device (ie no existing files on it), wouldn&#x27;t the simplest approach be to full block 1 (whether 512 or 4k bytes) with a series of &quot;1&quot;&#x27;s, block 2 with a series of &quot;2&quot;&#x27;s, (etc).  ie incrementing the number that gets written as the block number being written to is written.<p>Reading that back (either the full device or a random sample) should pretty quickly identify whether things are still in their expected location.</div><br/><div id="41529256" class="c"><input type="checkbox" id="c-41529256" checked=""/><div class="controls bullet"><span class="by">mark254</span><span>|</span><a href="#41526434">root</a><span>|</span><a href="#41527902">parent</a><span>|</span><a href="#41528006">next</a><span>|</span><label class="collapse" for="c-41529256">[-]</label><label class="expand" for="c-41529256">[1 more]</label></div><br/><div class="children"><div class="content">Well, with the remaining trust available at this point you might just as well use something cryptographically secure, like encrypted ones, twos, or simple HMACs of the block number.<p>A too-simple scheme is likely to be detected (and bypassed!) by the firmware a nearly no time.</div><br/></div></div></div></div><div id="41528006" class="c"><input type="checkbox" id="c-41528006" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#41526434">parent</a><span>|</span><a href="#41527902">prev</a><span>|</span><a href="#41526527">next</a><span>|</span><label class="collapse" for="c-41528006">[-]</label><label class="expand" for="c-41528006">[1 more]</label></div><br/><div class="children"><div class="content">You are supposed to check an empty device. Some of the fake ones have firmware that will silently delete files or else fake writes. If you load it with data before confirming it is legit, you are likely to lose that data.</div><br/></div></div></div></div><div id="41526527" class="c"><input type="checkbox" id="c-41526527" checked=""/><div class="controls bullet"><span class="by">bagels</span><span>|</span><a href="#41526434">prev</a><span>|</span><a href="#41528177">next</a><span>|</span><label class="collapse" for="c-41526527">[-]</label><label class="expand" for="c-41526527">[11 more]</label></div><br/><div class="children"><div class="content">How long does this tool take to verify a real drive?<p>&quot;it only writes what’s necessary to test the drive&quot;<p>How does that actually work, wouldn&#x27;t that mean the whole stated capacity would have to be written?</div><br/><div id="41526745" class="c"><input type="checkbox" id="c-41526745" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#41526527">parent</a><span>|</span><a href="#41526590">next</a><span>|</span><label class="collapse" for="c-41526745">[-]</label><label class="expand" for="c-41526745">[4 more]</label></div><br/><div class="children"><div class="content">Define hash(x) that takes an integer and returns a sector-sized hash.<p>Define S = claimed total number of sectors.<p><pre><code>  for(i=0; i&lt;S; ++i) {
    write_sector(i, hash(i))
    for(j=0; j&lt;=i; ++j) {
      if(hash(j) != read_sector(j)) {
        return i
      }
    }
  }
  return S
</code></pre>
The above pseudo code will return the number of sectors the flash drive actually has.</div><br/><div id="41526777" class="c"><input type="checkbox" id="c-41526777" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#41526527">root</a><span>|</span><a href="#41526745">parent</a><span>|</span><a href="#41527120">next</a><span>|</span><label class="collapse" for="c-41526777">[-]</label><label class="expand" for="c-41526777">[2 more]</label></div><br/><div class="children"><div class="content">Write everything before read or you will just get back cached results.</div><br/><div id="41527406" class="c"><input type="checkbox" id="c-41527406" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#41526527">root</a><span>|</span><a href="#41526777">parent</a><span>|</span><a href="#41527120">next</a><span>|</span><label class="collapse" for="c-41527406">[-]</label><label class="expand" for="c-41527406">[1 more]</label></div><br/><div class="children"><div class="content">Cache can only mask performance. It can&#x27;t mask fraudulent reporting of storage capacity. At worst, the test above will return (size of write cache + size of actual storage), but a bargain-bin flash drive is going to have a very small (if any) write cache, so it&#x27;s not going to overestimate by much.</div><br/></div></div></div></div><div id="41527120" class="c"><input type="checkbox" id="c-41527120" checked=""/><div class="controls bullet"><span class="by">bagels</span><span>|</span><a href="#41526527">root</a><span>|</span><a href="#41526745">parent</a><span>|</span><a href="#41526777">prev</a><span>|</span><a href="#41526590">next</a><span>|</span><label class="collapse" for="c-41527120">[-]</label><label class="expand" for="c-41527120">[1 more]</label></div><br/><div class="children"><div class="content">Sure, so if the drive is genuine, or even one sector short (I recognize it&#x27;s more typically a much larger fraction for the fraudulent drives), you&#x27;d still have to write to nearly the full stated capacity to verify.<p>This approach though, seems to require reading the first sector many times.</div><br/></div></div></div></div><div id="41526590" class="c"><input type="checkbox" id="c-41526590" checked=""/><div class="controls bullet"><span class="by">jtriangle</span><span>|</span><a href="#41526527">parent</a><span>|</span><a href="#41526745">prev</a><span>|</span><a href="#41528177">next</a><span>|</span><label class="collapse" for="c-41526590">[-]</label><label class="expand" for="c-41526590">[6 more]</label></div><br/><div class="children"><div class="content">write 0001, read and confirm, repeat until drive is full.<p>For a fake drive, it&#x27;ll take awhile, because the underlying storage is much, much slower than it should be, often usb2 speeds.<p>Realistically, this is just a test that satisfies curiosity without opening the drive. It&#x27;s obvious when you have a fake drive because it won&#x27;t benchmark anywhere near what it should.</div><br/><div id="41527131" class="c"><input type="checkbox" id="c-41527131" checked=""/><div class="controls bullet"><span class="by">bagels</span><span>|</span><a href="#41526527">root</a><span>|</span><a href="#41526590">parent</a><span>|</span><a href="#41526848">next</a><span>|</span><label class="collapse" for="c-41527131">[-]</label><label class="expand" for="c-41527131">[2 more]</label></div><br/><div class="children"><div class="content">From what I understand, some of the fraudulent drives have firmware that just wrap the writes around to the beginning.</div><br/><div id="41527986" class="c"><input type="checkbox" id="c-41527986" checked=""/><div class="controls bullet"><span class="by">ungamedplayer</span><span>|</span><a href="#41526527">root</a><span>|</span><a href="#41527131">parent</a><span>|</span><a href="#41526848">next</a><span>|</span><label class="collapse" for="c-41527986">[-]</label><label class="expand" for="c-41527986">[1 more]</label></div><br/><div class="children"><div class="content">I had or had one in my possession that did exactly this. Another writes above a certain size were simply discarded.</div><br/></div></div></div></div><div id="41527936" class="c"><input type="checkbox" id="c-41527936" checked=""/><div class="controls bullet"><span class="by">sukmaagung</span><span>|</span><a href="#41526527">root</a><span>|</span><a href="#41526590">parent</a><span>|</span><a href="#41526848">prev</a><span>|</span><a href="#41526605">next</a><span>|</span><label class="collapse" for="c-41527936">[-]</label><label class="expand" for="c-41527936">[1 more]</label></div><br/><div class="children"><div class="content">The problem is the fake storage can just overwrite the new data on top existing data. Then you always confirm new data is correct because it broke the old ones.<p>But something like 2TB micro SD when actually it only has 64GB capacity, that will be very long time waiting 2TB to fully written.<p>How about write some file, then verify sometimes the new sometimes the old one, repeat until full.<p>Write(0.h2w)
Write(1.h2w)
Read(1.h2w)
Write(2.h2w)
Write(3.h2w)
Read(3.h2w)
Read(2.h2w)
Write(4.h2w)
Write(5.h2w)
Read(5.h2w)
Write(6.h2w)
Write(7.h2w)
Read(7.h2w)
Read(6.h2w)
Read(4.h2w)
Write(8.h2w)
Write(9.h2w)
Read(9.h2w)
Write(10.h2w)
Write(11.h2w)
Read(11.h2w)
Read(10.h2w)
Write(12.h2w)
Write(13.h2w)
Read(13.h2w)
Write(14.h2w)
Write(15.h2w)
Read(15.h2w)
Read(14.h2w)
Read(12.h2w)
Read(8.h2w)
...Read(0.h2w)</div><br/></div></div><div id="41526605" class="c"><input type="checkbox" id="c-41526605" checked=""/><div class="controls bullet"><span class="by">CaptainOfCoit</span><span>|</span><a href="#41526527">root</a><span>|</span><a href="#41526590">parent</a><span>|</span><a href="#41527936">prev</a><span>|</span><a href="#41528177">next</a><span>|</span><label class="collapse" for="c-41526605">[-]</label><label class="expand" for="c-41526605">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For a fake drive, it&#x27;ll take awhile<p>Or, for any mid to large sized real storage. Writing&#x2F;reading 64GB takes a while, fake or not</div><br/></div></div></div></div></div></div><div id="41528177" class="c"><input type="checkbox" id="c-41528177" checked=""/><div class="controls bullet"><span class="by">notorandit</span><span>|</span><a href="#41526527">prev</a><span>|</span><label class="collapse" for="c-41528177">[-]</label><label class="expand" for="c-41528177">[7 more]</label></div><br/><div class="children"><div class="content">As stated somewhere else, flash fraud has already been committed when you start testing.<p>Once you grab your dubious device, the seller has already got your bucks in exchange of a fake device.<p>You&#x27;ve been already and effectively cheated when those flash devices are being tested against cheats.</div><br/><div id="41528457" class="c"><input type="checkbox" id="c-41528457" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#41528177">parent</a><span>|</span><a href="#41528425">next</a><span>|</span><label class="collapse" for="c-41528457">[-]</label><label class="expand" for="c-41528457">[1 more]</label></div><br/><div class="children"><div class="content">There are one or more platforms in the middle. In the US, if you report a fraud your credit card and Amazon will both go out of their way to refund you (Amazon might require a return but will have options to make that free if they do). Other platforms are similar. You, as a consumer, don&#x27;t have any major problems from the fraud unless you needed a performant device with low delivery times.<p>Whether the fraudster has somebody&#x27;s dollars varies, but for that kind of a scheme they&#x27;re able to just hide in plain sight. If 100 people don&#x27;t test the device (and it works for months or years) and 1 person does, they have a 5-star rating and can just eat the cost of returns. Even if everyone on Hacker News started testing devices it wouldn&#x27;t make a dent in fraudulent profits.</div><br/></div></div><div id="41528425" class="c"><input type="checkbox" id="c-41528425" checked=""/><div class="controls bullet"><span class="by">re</span><span>|</span><a href="#41528177">parent</a><span>|</span><a href="#41528457">prev</a><span>|</span><a href="#41528855">next</a><span>|</span><label class="collapse" for="c-41528425">[-]</label><label class="expand" for="c-41528425">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Once you grab your dubious device, the seller has already got your bucks in exchange of a fake device.<p>Unless you&#x27;re buying your flash device on the street and paying cash, you likely can return it or initiate a chargeback.<p>And even if you can&#x27;t undo the purchase, it&#x27;s better to know whether a device is fraudulent before you start filling it up with real data that you don&#x27;t want to lose.</div><br/></div></div><div id="41528855" class="c"><input type="checkbox" id="c-41528855" checked=""/><div class="controls bullet"><span class="by">jeffhuys</span><span>|</span><a href="#41528177">parent</a><span>|</span><a href="#41528425">prev</a><span>|</span><a href="#41528298">next</a><span>|</span><label class="collapse" for="c-41528855">[-]</label><label class="expand" for="c-41528855">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As stated somewhere else<p>So why state it again? This helps, for instance, people who go on vacation and takes pictures the entire trip, only to come home and realise they have only 16MB of storage, not 16GB, and their pics are gone.</div><br/></div></div><div id="41528298" class="c"><input type="checkbox" id="c-41528298" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#41528177">parent</a><span>|</span><a href="#41528855">prev</a><span>|</span><label class="collapse" for="c-41528298">[-]</label><label class="expand" for="c-41528298">[3 more]</label></div><br/><div class="children"><div class="content">So what? F3 <i>detects</i> frauds, it doesn&#x27;t guarantee that you can <i>avoid</i> them.</div><br/><div id="41528903" class="c"><input type="checkbox" id="c-41528903" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#41528177">root</a><span>|</span><a href="#41528298">parent</a><span>|</span><label class="collapse" for="c-41528903">[-]</label><label class="expand" for="c-41528903">[2 more]</label></div><br/><div class="children"><div class="content">The argument is against the project name: “fighting” flash fraud suggests this project could somehow disincentivize flash fraud. Like how “fighting scammers” means things like taking down scam call centers.</div><br/><div id="41529073" class="c"><input type="checkbox" id="c-41529073" checked=""/><div class="controls bullet"><span class="by">schoen</span><span>|</span><a href="#41528177">root</a><span>|</span><a href="#41528903">parent</a><span>|</span><label class="collapse" for="c-41529073">[-]</label><label class="expand" for="c-41529073">[1 more]</label></div><br/><div class="children"><div class="content">Maybe some consumer protection agency will use the tool in conjunction with random purchases and some kind of enforcement action.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>