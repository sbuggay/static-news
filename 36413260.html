<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687338073373" as="style"/><link rel="stylesheet" href="styles.css?v=1687338073373"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.noulakaz.net/2007/03/18/a-regular-expression-to-check-for-prime-numbers/">A regular expression to check for prime numbers (2007)</a> <span class="domain">(<a href="https://www.noulakaz.net">www.noulakaz.net</a>)</span></div><div class="subtext"><span>tambourine_man</span> | <span>48 comments</span></div><br/><div><div id="36413444" class="c"><input type="checkbox" id="c-36413444" checked=""/><div class="controls bullet"><span class="by">tylerhou</span><span>|</span><a href="#36414896">next</a><span>|</span><label class="collapse" for="c-36413444">[-]</label><label class="expand" for="c-36413444">[26 more]</label></div><br/><div class="children"><div class="content">Technically not a <i>regular</i> expression, as (intuitively) the backreference has to “count” the number of 1’s that were matched. Regular expressions are equivalent to finite state machines, which cannot count arbitrarily high (any state machine that can count arbitrarily high needs an infinite number of states, since there are infinite natural numbers).<p>The 2022 discussion has a more formal proof using the pumping lemma.</div><br/><div id="36414132" class="c"><input type="checkbox" id="c-36414132" checked=""/><div class="controls bullet"><span class="by">retrac</span><span>|</span><a href="#36413444">parent</a><span>|</span><a href="#36415072">next</a><span>|</span><label class="collapse" for="c-36414132">[-]</label><label class="expand" for="c-36414132">[13 more]</label></div><br/><div class="children"><div class="content">&gt; Regular expressions are equivalent to finite state machines, which cannot count arbitrarily high (any state machine that can count arbitrarily high needs an infinite number of states, since there are infinite natural numbers).<p>The machine I&#x27;m using to type this comment is also a finite state machine, as due to having non-infinite memory, it also cannot count arbitrarily high.<p>Informally, regular expressions like in Perl are a kind of string rewriting.  And many string rewriting rules, if they can be iteratively applied, are Turing-complete (with the usual caveat about infinite storage and time).  The usual definition of a regular expression excludes that kind of iterative application, though.  It&#x27;s just a matching pattern; rewriting is technically outside of the concept of a regular expression.</div><br/><div id="36414731" class="c"><input type="checkbox" id="c-36414731" checked=""/><div class="controls bullet"><span class="by">finitemonkey</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36414132">parent</a><span>|</span><a href="#36416085">next</a><span>|</span><label class="collapse" for="c-36414731">[-]</label><label class="expand" for="c-36414731">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The machine I&#x27;m using to type this comment is also a finite state machine, as due to having non-infinite memory, it also cannot count arbitrarily high.<p>Right. And if you really want to push that argument further then there are numbers for which your machine can&#x27;t decide whether they are prime or not. Most of them, in fact, i.e., for all but a finite number of primes and non-primes, your machine can&#x27;t tell.<p>For the theory of computability, this is not a useful model. Neither for complexity theory. Statements like &quot;My machine can sort in constant time&quot; which is arguably true but not useful either. It only holds up to a certain collection size which in a sense makes it both nonsensical and useless. Even concepts like the Chomsky hierarchy with context free languages being one of the prominent components make little sense as long as your computational model is finite state.<p>Instead, we model them as unbounded, to be able to differentiate between classes of computation problems as well as reason about complexity. The Turing Machine is one of the simple and elegant models, but there are others for other purposes.<p>I wish that basic education about the theory of computation would stress more why theory treats things like this, to avoid this kind of confusion. (And then people would need to take those classes as well, and not just claim they can write React apps just fine without a degree.)</div><br/><div id="36415410" class="c"><input type="checkbox" id="c-36415410" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36414731">parent</a><span>|</span><a href="#36416085">next</a><span>|</span><label class="collapse" for="c-36415410">[-]</label><label class="expand" for="c-36415410">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And then people would need to take those classes as well, and not just claim they can write React apps just fine without a degree.<p>Weird tangent. They <i>can</i> write React apps without a degree, can&#x27;t they? What&#x27;s wrong with that?<p>The amount of complexity reasoning you need for something like that is around &quot;this part seems slow, maybe there&#x27;s a better algorithm somewhere&quot; or &quot;that&#x27;s a lot of nested loops, maybe I can do with less&quot;. Knowing more might help in some pretty rare cases but doesn&#x27;t seem like a requirement. On the other hand, knowing the complexity of all algorithms and blindly assuming &quot;good complexity = good performance&quot; while never checking is a recipe for desaster.</div><br/></div></div></div></div><div id="36416085" class="c"><input type="checkbox" id="c-36416085" checked=""/><div class="controls bullet"><span class="by">mjan22640</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36414132">parent</a><span>|</span><a href="#36414731">prev</a><span>|</span><a href="#36415038">next</a><span>|</span><label class="collapse" for="c-36416085">[-]</label><label class="expand" for="c-36416085">[1 more]</label></div><br/><div class="children"><div class="content">A finite self referential algorithm that checks all numbers for being prime does exist. Running it on a finite computer will eventually hit the bounds of the computer, but that is a limitation outside of the algorithm.<p>A finite regular expression that checks all numbers for being prime cannot exist already in principle.</div><br/></div></div><div id="36415038" class="c"><input type="checkbox" id="c-36415038" checked=""/><div class="controls bullet"><span class="by">noctune</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36414132">parent</a><span>|</span><a href="#36416085">prev</a><span>|</span><a href="#36414663">next</a><span>|</span><label class="collapse" for="c-36415038">[-]</label><label class="expand" for="c-36415038">[3 more]</label></div><br/><div class="children"><div class="content">Personally, I use &quot;regex&quot; for the informal string-matching&#x2F;rewriting engines found in most languages and &quot;regular expression&quot; for the formal definition.</div><br/><div id="36415445" class="c"><input type="checkbox" id="c-36415445" checked=""/><div class="controls bullet"><span class="by">FeepingCreature</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36415038">parent</a><span>|</span><a href="#36414663">next</a><span>|</span><label class="collapse" for="c-36415445">[-]</label><label class="expand" for="c-36415445">[2 more]</label></div><br/><div class="children"><div class="content">By which, of course, this submission title is a lie.</div><br/><div id="36415679" class="c"><input type="checkbox" id="c-36415679" checked=""/><div class="controls bullet"><span class="by">necovek</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36415445">parent</a><span>|</span><a href="#36414663">next</a><span>|</span><label class="collapse" for="c-36415679">[-]</label><label class="expand" for="c-36415679">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the GP is the original poster, so them claiming how they &quot;personally&quot; differentiate between the two does not make the submission title a lie.<p>We don&#x27;t know how original poster differentiates.</div><br/></div></div></div></div></div></div><div id="36414663" class="c"><input type="checkbox" id="c-36414663" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36414132">parent</a><span>|</span><a href="#36415038">prev</a><span>|</span><a href="#36415072">next</a><span>|</span><label class="collapse" for="c-36414663">[-]</label><label class="expand" for="c-36414663">[6 more]</label></div><br/><div class="children"><div class="content">&gt; The machine I&#x27;m using to type this comment is also a finite state machine, as due to having non-infinite memory, it also cannot count arbitrarily high.<p>I&#x27;m not sure how that&#x27;s relevant. Even given infinite space, there still wouldn&#x27;t exist a Regular Expression (the CS kind) you could write down in finite time that would match only primes.<p>At least IIRC, it&#x27;s been a 20+ years since I last took a Discrete Math course :)</div><br/><div id="36414737" class="c"><input type="checkbox" id="c-36414737" checked=""/><div class="controls bullet"><span class="by">dheera</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36414663">parent</a><span>|</span><a href="#36415072">next</a><span>|</span><label class="collapse" for="c-36414737">[-]</label><label class="expand" for="c-36414737">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Even given infinite space, there still wouldn&#x27;t exist a Regular Expression (the CS kind) you could write down in finite time that would match only primes.<p>The point is, neither would there exist a non-(Regular Expression) method that could do such, if you&#x27;re running it on a finite state machine (your computer).</div><br/><div id="36414781" class="c"><input type="checkbox" id="c-36414781" checked=""/><div class="controls bullet"><span class="by">tylerhou</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36414737">parent</a><span>|</span><a href="#36415890">next</a><span>|</span><label class="collapse" for="c-36414781">[-]</label><label class="expand" for="c-36414781">[3 more]</label></div><br/><div class="children"><div class="content">But that argument is not interesting. &quot;We can&#x27;t count arbitrarily high because the universe is finite.&quot; Yeah, duh. (Observable universe, for the pedants.)<p>It&#x27;s more interesting to ask: suppose you <i>did</i> have a magical stick of RAM that had infinite storage, and suppose you augmented your computer to store and query that memory. Then -- yes -- your computer could determine whether any number, however large, is prime. An FSM could not.</div><br/><div id="36414940" class="c"><input type="checkbox" id="c-36414940" checked=""/><div class="controls bullet"><span class="by">dheera</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36414781">parent</a><span>|</span><a href="#36415890">next</a><span>|</span><label class="collapse" for="c-36414940">[-]</label><label class="expand" for="c-36414940">[2 more]</label></div><br/><div class="children"><div class="content">If you have an infinite stick of RAM, regular expressions wouldn&#x27;t be FSMs, either, they could have infinite state space. They would terminate in finite time that is exponential in the size of the prime but nevertheless would still halt.</div><br/><div id="36415221" class="c"><input type="checkbox" id="c-36415221" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36414940">parent</a><span>|</span><a href="#36415890">next</a><span>|</span><label class="collapse" for="c-36415221">[-]</label><label class="expand" for="c-36415221">[1 more]</label></div><br/><div class="children"><div class="content">The point being made is that “regular expressions”, in the original CS meaning, do not have stack space or anything analogous. “Regular expressions” in modern programming practice are often different and more powerful, of course.</div><br/></div></div></div></div></div></div><div id="36415890" class="c"><input type="checkbox" id="c-36415890" checked=""/><div class="controls bullet"><span class="by">lapinot</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36414737">parent</a><span>|</span><a href="#36414781">prev</a><span>|</span><a href="#36415072">next</a><span>|</span><label class="collapse" for="c-36415890">[-]</label><label class="expand" for="c-36415890">[1 more]</label></div><br/><div class="children"><div class="content">The important point here was <i>given infinite space</i>.</div><br/></div></div></div></div></div></div></div></div><div id="36415072" class="c"><input type="checkbox" id="c-36415072" checked=""/><div class="controls bullet"><span class="by">johnfn</span><span>|</span><a href="#36413444">parent</a><span>|</span><a href="#36414132">prev</a><span>|</span><a href="#36415892">next</a><span>|</span><label class="collapse" for="c-36415072">[-]</label><label class="expand" for="c-36415072">[3 more]</label></div><br/><div class="children"><div class="content">Come now, every time a colleague says they parsed a file with a regex in javascript, do you turn to them and tell them &quot;well, you didn&#x27;t actually use a _regular_ expression...&quot;</div><br/><div id="36415218" class="c"><input type="checkbox" id="c-36415218" checked=""/><div class="controls bullet"><span class="by">unhammer</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36415072">parent</a><span>|</span><a href="#36415892">next</a><span>|</span><label class="collapse" for="c-36415218">[-]</label><label class="expand" for="c-36415218">[2 more]</label></div><br/><div class="children"><div class="content">Only every time they claim a major mathematical breakthrough using regular expressions.</div><br/><div id="36415856" class="c"><input type="checkbox" id="c-36415856" checked=""/><div class="controls bullet"><span class="by">underdeserver</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36415218">parent</a><span>|</span><a href="#36415892">next</a><span>|</span><label class="collapse" for="c-36415856">[-]</label><label class="expand" for="c-36415856">[1 more]</label></div><br/><div class="children"><div class="content">Nobody claimed that.</div><br/></div></div></div></div></div></div><div id="36415892" class="c"><input type="checkbox" id="c-36415892" checked=""/><div class="controls bullet"><span class="by">evanb</span><span>|</span><a href="#36413444">parent</a><span>|</span><a href="#36415072">prev</a><span>|</span><a href="#36413496">next</a><span>|</span><label class="collapse" for="c-36415892">[-]</label><label class="expand" for="c-36415892">[2 more]</label></div><br/><div class="children"><div class="content">Could the AKS primality test, which showed that PRIMES is in P, be implemented as an honest regular expression?  Presumably not because then we&#x27;d know that PRIMES is not just in P but is a regular language, which would be too good to be true.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;AKS_primality_test" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;AKS_primality_test</a></div><br/><div id="36415946" class="c"><input type="checkbox" id="c-36415946" checked=""/><div class="controls bullet"><span class="by">aleph_minus_one</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36415892">parent</a><span>|</span><a href="#36413496">next</a><span>|</span><label class="collapse" for="c-36415946">[-]</label><label class="expand" for="c-36415946">[1 more]</label></div><br/><div class="children"><div class="content">Via the pumping lemma, you can easily prove that testing whether a number is a prime number cannot be implemented as a regular expression.</div><br/></div></div></div></div><div id="36413496" class="c"><input type="checkbox" id="c-36413496" checked=""/><div class="controls bullet"><span class="by">CoastalCoder</span><span>|</span><a href="#36413444">parent</a><span>|</span><a href="#36415892">prev</a><span>|</span><a href="#36414896">next</a><span>|</span><label class="collapse" for="c-36413496">[-]</label><label class="expand" for="c-36413496">[7 more]</label></div><br/><div class="children"><div class="content">Agreed.  I read the post because the result was so shocking.<p>TIL that the computer-sciencey definition of RE isn&#x27;t the only one in use.</div><br/><div id="36413544" class="c"><input type="checkbox" id="c-36413544" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36413496">parent</a><span>|</span><a href="#36414896">next</a><span>|</span><label class="collapse" for="c-36413544">[-]</label><label class="expand" for="c-36413544">[6 more]</label></div><br/><div class="children"><div class="content">When programmers say regular expression they usually mean Perl Compatible Regular Expressions (PCRE). Or I guess PCRE-compatible expressions, since there are other implementations of the same syntax out there. If you go back far enough in time they were once regular expressions in the computer science sense, but then features got added, and now they are incredibly powerful but can take basically infinite memory and time.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Perl_Compatible_Regular_Expressions" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Perl_Compatible_Regular_Expres...</a></div><br/><div id="36414032" class="c"><input type="checkbox" id="c-36414032" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36413544">parent</a><span>|</span><a href="#36414763">next</a><span>|</span><label class="collapse" for="c-36414032">[-]</label><label class="expand" for="c-36414032">[2 more]</label></div><br/><div class="children"><div class="content">Although general PCRE syntax has clearly won, that’s distinct from the infinite-memory-and-time matter. Engines that don’t use backtracking and can search in linear time (O(regex-size × search-text-size)) have been making a serious comeback in recent years, at only the cost of not supporting lookaround assertions or backreferences. For example, the re2 library, or Rust’s regex crate, both of which are <i>very</i> popular.</div><br/><div id="36414318" class="c"><input type="checkbox" id="c-36414318" checked=""/><div class="controls bullet"><span class="by">knome</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36414032">parent</a><span>|</span><a href="#36414763">next</a><span>|</span><label class="collapse" for="c-36414318">[-]</label><label class="expand" for="c-36414318">[1 more]</label></div><br/><div class="children"><div class="content">Russ Cox has an excellent write up on it.<p>&quot;Regular Expression Matching Can Be Simple And Fast&quot; (2007)<p><a href="https:&#x2F;&#x2F;swtch.com&#x2F;~rsc&#x2F;regexp&#x2F;regexp1.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;swtch.com&#x2F;~rsc&#x2F;regexp&#x2F;regexp1.html</a></div><br/></div></div></div></div><div id="36414763" class="c"><input type="checkbox" id="c-36414763" checked=""/><div class="controls bullet"><span class="by">finitemonkey</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36413544">parent</a><span>|</span><a href="#36414032">prev</a><span>|</span><a href="#36413615">next</a><span>|</span><label class="collapse" for="c-36414763">[-]</label><label class="expand" for="c-36414763">[2 more]</label></div><br/><div class="children"><div class="content">&gt; and now they are incredibly powerful but can take basically infinite memory and time.<p>Which is why the &quot;RE&quot; in the article is excrutiatingly slow, given that it needs to perform insane amounts of backtracking. In contrast, &quot;real&quot; regular expression checkers run in linear time.<p>Also, nitpicking, but they take <i>unbounded</i> time. It&#x27;s still finite.</div><br/><div id="36415059" class="c"><input type="checkbox" id="c-36415059" checked=""/><div class="controls bullet"><span class="by">petters</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36414763">parent</a><span>|</span><a href="#36413615">next</a><span>|</span><label class="collapse" for="c-36415059">[-]</label><label class="expand" for="c-36415059">[1 more]</label></div><br/><div class="children"><div class="content">They said “basically,” so no need to nitpick. And I’m not sure about unbounded; surely it is bounded by a suitable exponential function?</div><br/></div></div></div></div><div id="36413615" class="c"><input type="checkbox" id="c-36413615" checked=""/><div class="controls bullet"><span class="by">disconcision</span><span>|</span><a href="#36413444">root</a><span>|</span><a href="#36413544">parent</a><span>|</span><a href="#36414763">prev</a><span>|</span><a href="#36414896">next</a><span>|</span><label class="collapse" for="c-36413615">[-]</label><label class="expand" for="c-36413615">[1 more]</label></div><br/><div class="children"><div class="content">funnily enough the original POSIX regular expressions (BRE) were strictly less powerful than regular expressions (CS sense), lacking a general alternation operator (though one was provided in ERE)</div><br/></div></div></div></div></div></div></div></div><div id="36414896" class="c"><input type="checkbox" id="c-36414896" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#36413444">prev</a><span>|</span><a href="#36414563">next</a><span>|</span><label class="collapse" for="c-36414896">[-]</label><label class="expand" for="c-36414896">[2 more]</label></div><br/><div class="children"><div class="content">Took me a while to realise that it is not actually validating whether a given number is a prime number or not.<p>It is validating whether a string of consecutive 1&#x27;s has a prime length.<p>In other words, it can&#x27;t tell whether &quot;3&quot; is prime, unless you express it as &quot;111&quot;.<p>Much less exciting.</div><br/><div id="36415166" class="c"><input type="checkbox" id="c-36415166" checked=""/><div class="controls bullet"><span class="by">stefncb</span><span>|</span><a href="#36414896">parent</a><span>|</span><a href="#36414563">next</a><span>|</span><label class="collapse" for="c-36415166">[-]</label><label class="expand" for="c-36415166">[1 more]</label></div><br/><div class="children"><div class="content">Think about it a different way: the regex thing can only deal with unary numbers, like your computer can only deal with binary. It&#x27;s really no different. I&#x27;m not sure if you can write a decimal-to-unary converter in regex but I reckon it&#x27;s possible. At least using the non-regular regex like the original prime program did.</div><br/></div></div></div></div><div id="36414563" class="c"><input type="checkbox" id="c-36414563" checked=""/><div class="controls bullet"><span class="by">hoytech</span><span>|</span><a href="#36414896">prev</a><span>|</span><a href="#36414501">next</a><span>|</span><label class="collapse" for="c-36414563">[-]</label><label class="expand" for="c-36414563">[1 more]</label></div><br/><div class="children"><div class="content">You can also factor integers with Regexp::Exhaustive:<p><a href="https:&#x2F;&#x2F;metacpan.org&#x2F;pod&#x2F;Regexp::Exhaustive#Finding-all-divisors" rel="nofollow noreferrer">https:&#x2F;&#x2F;metacpan.org&#x2F;pod&#x2F;Regexp::Exhaustive#Finding-all-divi...</a><p>And if you&#x27;re in Toronto in 3 weeks time, come see Abigail (the original inventor of the prime number regexp) solve the N-Queens problem with regexp:<p><a href="https:&#x2F;&#x2F;tprc2023.sched.com&#x2F;event&#x2F;1LhoB&#x2F;the-n-queens-problem-by-regexp" rel="nofollow noreferrer">https:&#x2F;&#x2F;tprc2023.sched.com&#x2F;event&#x2F;1LhoB&#x2F;the-n-queens-problem-...</a></div><br/></div></div><div id="36414501" class="c"><input type="checkbox" id="c-36414501" checked=""/><div class="controls bullet"><span class="by">neilk</span><span>|</span><a href="#36414563">prev</a><span>|</span><a href="#36413399">next</a><span>|</span><label class="collapse" for="c-36414501">[-]</label><label class="expand" for="c-36414501">[1 more]</label></div><br/><div class="children"><div class="content">The original exegesis, which prompted this blog post, was by me.<p>I am currently transitioning to a different blog engine, so the page is offline right now, but it&#x27;s still available here<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20220513113609&#x2F;neilk.net&#x2F;blog&#x2F;2000&#x2F;06&#x2F;01&#x2F;abigails-regex-to-test-for-prime-numbers&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20220513113609&#x2F;neilk.net&#x2F;blog&#x2F;20...</a></div><br/></div></div><div id="36413399" class="c"><input type="checkbox" id="c-36413399" checked=""/><div class="controls bullet"><span class="by">shric</span><span>|</span><a href="#36414501">prev</a><span>|</span><a href="#36413493">next</a><span>|</span><label class="collapse" for="c-36413399">[-]</label><label class="expand" for="c-36413399">[2 more]</label></div><br/><div class="children"><div class="content">(2007)<p>Previous discussions (with &gt;25 comments):<p>2015: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9039537">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9039537</a> (67 comments)<p>2022: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30564287">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30564287</a> (121 comments)</div><br/><div id="36414449" class="c"><input type="checkbox" id="c-36414449" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#36413399">parent</a><span>|</span><a href="#36413493">next</a><span>|</span><label class="collapse" for="c-36414449">[-]</label><label class="expand" for="c-36414449">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! Macroexpanded:<p><i>A regular expression to check for prime numbers (2007)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30564287">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30564287</a> - March 2022 (121 comments)<p><i>A regular expression to check for prime numbers</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9039537">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9039537</a> - Feb 2015 (67 comments)<p><i>A regular expression to check for prime numbers</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1486158">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1486158</a> - July 2010 (13 comments)<p><i>Regex to check for prime numbers</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=707236">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=707236</a> - July 2009 (9 comments)<p><i>A regular expression to check for prime numbers</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=58780">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=58780</a> - Sept 2007 (8 comments)</div><br/></div></div></div></div><div id="36413493" class="c"><input type="checkbox" id="c-36413493" checked=""/><div class="controls bullet"><span class="by">pkoird</span><span>|</span><a href="#36413399">prev</a><span>|</span><a href="#36415872">next</a><span>|</span><label class="collapse" for="c-36413493">[-]</label><label class="expand" for="c-36413493">[3 more]</label></div><br/><div class="children"><div class="content">Clever! I&#x27;m kinda being pedantic but I guess using \1 makes it a non-regular expression? I&#x27;m not even sure if it&#x27;s CFG anymore.</div><br/><div id="36413708" class="c"><input type="checkbox" id="c-36413708" checked=""/><div class="controls bullet"><span class="by">shagie</span><span>|</span><a href="#36413493">parent</a><span>|</span><a href="#36415872">next</a><span>|</span><label class="collapse" for="c-36413708">[-]</label><label class="expand" for="c-36413708">[2 more]</label></div><br/><div class="children"><div class="content">Correct.  The \1 holds some external state... but this can be overcome with a different architecture.  If you want to start down that rabbit hole.<p>Extending finite automata to efficiently match Perl-compatible regular expressions <a href="https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;221325349_Extending_finite_automata_to_efficiently_match_Perl-compatible_regular_expressions" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;221325349_Extending...</a><p>&gt; Regular expression matching is a crucial task in several networking applications. Current implementations are based on one of two types of finite state machines. Non-deterministic finite automata (NFAs) have minimal storage demand but have high memory bandwidth requirements. Deterministic finite automata (DFAs) exhibit low and deterministic memory bandwidth requirements at the cost of increased memory space. It has already been shown how the presence of wildcards and repetitions of large character classes can render DFAs and NFAs impractical. Additionally, recent security-oriented rule-sets include patterns with advanced features, namely back-references, which add to the expressive power of traditional regular expressions and cannot therefore be supported through classical finite automata.<p>&gt; In this work, we propose and evaluate an extended finite automaton designed to address these shortcomings. First, the automaton provides an alternative approach to handle character repetitions that limits memory space and bandwidth requirements. Second, it supports back-references without the need for back-tracking in the input string. In our discussion of this proposal, we address practical implementation issues and evaluate the automaton on real-world rule-sets. To our knowledge, this is the first high-speed automaton that can accommodate all the Perl-compatible regular expressions present in the Snort network intrusion and detection system.<p>----<p>The awkward part is that a PCRE is demonstrably more powerful than a regular language, but not as powerful as a CFG (you can write CFGs that can&#x27;t be matched by a PCRE - ([{}]) matching, a^nb^n and so on).  So the question that gets interesting is &quot;can every PCRE be matched by a CFG?&quot;<p>Is it a fork? or is it a non-integer language?<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Chomsky_hierarchy" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Chomsky_hierarchy</a><p>&gt; Note that the set of grammars corresponding to recursive languages is not a member of this hierarchy; these would be properly between Type-0 and Type-1.<p>So there&#x27;s a language between the Turing machine and the linear bounded Turing machine that matches a context sensitive language.<p>Is the PCRE something between Type-2 and Type-3? or is it a Type-3+I?<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Formal_grammar#Other_forms_of_generative_grammars" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Formal_grammar#Other_forms_of_...</a><p>&gt; Many extensions and variations on Chomsky&#x27;s original hierarchy of formal grammars have been developed, both by linguists and by computer scientists, usually either in order to increase their expressive power or in order to make them easier to analyze or parse. ...</div><br/><div id="36414950" class="c"><input type="checkbox" id="c-36414950" checked=""/><div class="controls bullet"><span class="by">davidgay</span><span>|</span><a href="#36413493">root</a><span>|</span><a href="#36413708">parent</a><span>|</span><a href="#36415872">next</a><span>|</span><label class="collapse" for="c-36414950">[-]</label><label class="expand" for="c-36414950">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The awkward part is that a PCRE is demonstrably more powerful than a regular language, but not as powerful as a CFG<p>Hmm, there&#x27;s a reduction of 3-cnf-sat to perl regexps, making them NP-complete. As CFGs are in NP...<p><a href="https:&#x2F;&#x2F;perl.plover.com&#x2F;NPC&#x2F;NPC-3SAT.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;perl.plover.com&#x2F;NPC&#x2F;NPC-3SAT.html</a></div><br/></div></div></div></div></div></div><div id="36415872" class="c"><input type="checkbox" id="c-36415872" checked=""/><div class="controls bullet"><span class="by">underdeserver</span><span>|</span><a href="#36413493">prev</a><span>|</span><a href="#36413383">next</a><span>|</span><label class="collapse" for="c-36415872">[-]</label><label class="expand" for="c-36415872">[1 more]</label></div><br/><div class="children"><div class="content">People are commented &quot;It&#x27;s not a breakthrough! It&#x27;s not CS-y _regular_ expressions!&quot;<p>I suggest relaxing, everyone. It&#x27;s a fun story, not a groundbreaking discovery.</div><br/></div></div><div id="36413383" class="c"><input type="checkbox" id="c-36413383" checked=""/><div class="controls bullet"><span class="by">vignesh_warar</span><span>|</span><a href="#36415872">prev</a><span>|</span><a href="#36415161">next</a><span>|</span><label class="collapse" for="c-36413383">[-]</label><label class="expand" for="c-36413383">[1 more]</label></div><br/><div class="children"><div class="content">Interesting!<p>If anyone is seeking a math formula for primes, here is one: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Formula_for_primes" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Formula_for_primes</a><p>There is also a good YouTube video that explains this: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=j5s0h42GfvM">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=j5s0h42GfvM</a></div><br/></div></div><div id="36415161" class="c"><input type="checkbox" id="c-36415161" checked=""/><div class="controls bullet"><span class="by">medv</span><span>|</span><a href="#36413383">prev</a><span>|</span><a href="#36414562">next</a><span>|</span><label class="collapse" for="c-36415161">[-]</label><label class="expand" for="c-36415161">[1 more]</label></div><br/><div class="children"><div class="content">&gt; To know this, the function first generates “1111111”<p>Not that interesting.</div><br/></div></div><div id="36414562" class="c"><input type="checkbox" id="c-36414562" checked=""/><div class="controls bullet"><span class="by">raldi</span><span>|</span><a href="#36415161">prev</a><span>|</span><a href="#36413362">next</a><span>|</span><label class="collapse" for="c-36414562">[-]</label><label class="expand" for="c-36414562">[1 more]</label></div><br/><div class="children"><div class="content">A better title would be “A regex to check if a string contains a prime number of characters”</div><br/></div></div><div id="36413362" class="c"><input type="checkbox" id="c-36413362" checked=""/><div class="controls bullet"><span class="by">ufo</span><span>|</span><a href="#36414562">prev</a><span>|</span><a href="#36413921">next</a><span>|</span><label class="collapse" for="c-36413362">[-]</label><label class="expand" for="c-36413362">[3 more]</label></div><br/><div class="children"><div class="content">Why does it have &#x2F;^1?$&#x2F; ? Wouldn&#x27;t that accept 0 and 1 as primes?</div><br/><div id="36413390" class="c"><input type="checkbox" id="c-36413390" checked=""/><div class="controls bullet"><span class="by">rperce</span><span>|</span><a href="#36413362">parent</a><span>|</span><a href="#36413373">next</a><span>|</span><label class="collapse" for="c-36413390">[-]</label><label class="expand" for="c-36413390">[1 more]</label></div><br/><div class="children"><div class="content">I encourage you to re-read the article: you check that the number <i>does not</i> match the regex:<p><pre><code>  &gt; Is 7 prime?  
  &gt;
  &gt; To know this, the function first generates “1111111” (from “1” \* 7) and tries to
  &gt; see if that string does not match &#x2F;^1?$|^(11+?)\1+$&#x2F;. If there is no match, then
  &gt; the number is prime.
  &gt;
  &gt; Notice that the regular expression has two parts (separated with the vertical bar |).
  &gt;
  &gt; The first part is &#x2F;^1?$&#x2F; is trivial and matches with beginning of line (^), an
  &gt; optional 1 (1?) and end of line ($) which implies that it matches either the
  &gt; empty string or “1”. This simply indicates that calling that function with n==0
  &gt; or n==1 will correctly return false (as the “1” \* n will match with the first
  &gt; part of the regular expression)
</code></pre>
I agree that the article formatting is a bit misleading.</div><br/></div></div><div id="36413373" class="c"><input type="checkbox" id="c-36413373" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#36413362">parent</a><span>|</span><a href="#36413390">prev</a><span>|</span><a href="#36413921">next</a><span>|</span><label class="collapse" for="c-36413373">[-]</label><label class="expand" for="c-36413373">[1 more]</label></div><br/><div class="children"><div class="content">The regular expression matches all non-primes (in base 1 encoding). 0 and 1 are not prime, so it matches them.</div><br/></div></div></div></div><div id="36415100" class="c"><input type="checkbox" id="c-36415100" checked=""/><div class="controls bullet"><span class="by">sytelus</span><span>|</span><a href="#36413445">prev</a><span>|</span><a href="#36414311">next</a><span>|</span><label class="collapse" for="c-36415100">[-]</label><label class="expand" for="c-36415100">[1 more]</label></div><br/><div class="children"><div class="content">Stunning: <a href="https:&#x2F;&#x2F;chat.openai.com&#x2F;share&#x2F;367fd09d-79cb-4683-a179-e253a8b468f3" rel="nofollow noreferrer">https:&#x2F;&#x2F;chat.openai.com&#x2F;share&#x2F;367fd09d-79cb-4683-a179-e253a8...</a></div><br/></div></div><div id="36414311" class="c"><input type="checkbox" id="c-36414311" checked=""/><div class="controls bullet"><span class="by">aenis</span><span>|</span><a href="#36415100">prev</a><span>|</span><label class="collapse" for="c-36414311">[-]</label><label class="expand" for="c-36414311">[1 more]</label></div><br/><div class="children"><div class="content">In case anyone is wondering, gpt4 provides the same solution. It takes some prodding though, and you get treated with a lecture of how inefficient it is before it provides the solution.<p>&quot;Apologies for any confusion before, and I understand the nature of your request now. It&#x27;s a fun challenge to think about! While it&#x27;s not practically useful or efficient, and it is actually quite limited, a creative theoretical solution exists that involves regular expressions. This specific solution only works for very small numbers due to the inherent limitations of regex. It&#x27;s based on the principle that a number is prime if it cannot be expressed as a product of two smaller natural numbers. We represent the number as a repeated string of 1s, then check for repeating sub-patterns.<p>For instance, this Perl regex checks if a number, represented as unary (a string of 1s), is prime:<p>perl
Copy code
&#x2F;^1?$|^(11+?)\1+$&#x2F;
In this regex:<p>^1?$ checks for the case where you have zero or one &#x27;1&#x27;, which represent the numbers 0 and 1, neither of which are prime.
^(11+?)\1+$ attempts to match the input with a repeating group of &#x27;1&#x27;s. If a match is found, the number is not prime, because a repeating subgroup of &#x27;1&#x27;s represents a divisor.
This pattern should be used in a negative sense: if a string of 1s (representing your number in unary form) matches this pattern, it&#x27;s not prime. If it doesn&#x27;t match, then it is prime.<p>Again, this is quite impractical for real use cases as the unary representation is extremely inefficient, and the computation grows quickly with larger numbers, but it&#x27;s a neat way of showing how flexible and powerful regular expressions can be.&quot;</div><br/></div></div></div></div></div></div></div></body></html>