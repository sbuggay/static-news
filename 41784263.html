<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728723674136" as="style"/><link rel="stylesheet" href="styles.css?v=1728723674136"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/rizsotto/Bear">Bear is a tool that generates a compilation database for Clang tooling</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>nateb2022</span> | <span>17 comments</span></div><br/><div><div id="41812676" class="c"><input type="checkbox" id="c-41812676" checked=""/><div class="controls bullet"><span class="by">AceJohnny2</span><span>|</span><a href="#41815991">next</a><span>|</span><label class="collapse" for="c-41812676">[-]</label><label class="expand" for="c-41812676">[12 more]</label></div><br/><div class="children"><div class="content">If you have control over the build system, clang can generate that directly nowadays, by adding <i>-MJ path</i> to CFLAGS (or equiv). This will save JSON fragments to path (make&#x27;em separate for each compiled file), then you can concatenate all the fragments into a compilation database.<p>I use this approach because on macOS, with SIP, Bear no longer works as it is forbidden from injecting its hooks into the system-protected clang shim. There may be other solutions.<p>(I haven&#x27;t explored the space in a few years. They&#x27;ve historically fared poorly with embedded targets where one file may be compiled many different ways for targeting different platforms)</div><br/><div id="41817232" class="c"><input type="checkbox" id="c-41817232" checked=""/><div class="controls bullet"><span class="by">rbalint</span><span>|</span><a href="#41812676">parent</a><span>|</span><a href="#41812791">next</a><span>|</span><label class="collapse" for="c-41817232">[-]</label><label class="expand" for="c-41817232">[1 more]</label></div><br/><div class="children"><div class="content">If you would like to make similar hooks work again on macOS, check out this guide: <a href="https:&#x2F;&#x2F;firebuild.com&#x2F;setup-macos" rel="nofollow">https:&#x2F;&#x2F;firebuild.com&#x2F;setup-macos</a> .
Firebuild uses similar technique to explore the process tree and create a report with CPU utilizations highlighted in a graphical process tree graph.</div><br/></div></div><div id="41812791" class="c"><input type="checkbox" id="c-41812791" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#41812676">parent</a><span>|</span><a href="#41817232">prev</a><span>|</span><a href="#41815991">next</a><span>|</span><label class="collapse" for="c-41812791">[-]</label><label class="expand" for="c-41812791">[10 more]</label></div><br/><div class="children"><div class="content">One of the major problems approach with this is that you need to run the compile before you can generate this database.</div><br/><div id="41813931" class="c"><input type="checkbox" id="c-41813931" checked=""/><div class="controls bullet"><span class="by">suprjami</span><span>|</span><a href="#41812676">root</a><span>|</span><a href="#41812791">parent</a><span>|</span><a href="#41813926">next</a><span>|</span><label class="collapse" for="c-41813931">[-]</label><label class="expand" for="c-41813931">[2 more]</label></div><br/><div class="children"><div class="content">How do you propose to generate the compilation database without compiling? I would really like that for the Linux kernel.</div><br/><div id="41815224" class="c"><input type="checkbox" id="c-41815224" checked=""/><div class="controls bullet"><span class="by">xxpor</span><span>|</span><a href="#41812676">root</a><span>|</span><a href="#41813931">parent</a><span>|</span><a href="#41813926">next</a><span>|</span><label class="collapse" for="c-41815224">[-]</label><label class="expand" for="c-41815224">[1 more]</label></div><br/><div class="children"><div class="content">You really need build system support. For example, Ninja can generate the file without actually doing the build because it knows everything it _would_ do.</div><br/></div></div></div></div><div id="41815461" class="c"><input type="checkbox" id="c-41815461" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#41812676">root</a><span>|</span><a href="#41812791">parent</a><span>|</span><a href="#41813926">prev</a><span>|</span><a href="#41815991">next</a><span>|</span><label class="collapse" for="c-41815461">[-]</label><label class="expand" for="c-41815461">[6 more]</label></div><br/><div class="children"><div class="content">Is this really a <i>major</i> problem? Is there any tool that supports generating the database <i>without</i> compiling? I think the answer to both of these is &quot;no&quot;. In fact I can&#x27;t even think of a reasonable case where it would be even a minor problem.</div><br/><div id="41815998" class="c"><input type="checkbox" id="c-41815998" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#41812676">root</a><span>|</span><a href="#41815461">parent</a><span>|</span><a href="#41815991">next</a><span>|</span><label class="collapse" for="c-41815998">[-]</label><label class="expand" for="c-41815998">[5 more]</label></div><br/><div class="children"><div class="content">Ninja and CMake do. It&#x27;s especially useful if you want a compilation database for a project that takes an extremely long time to build.</div><br/><div id="41816973" class="c"><input type="checkbox" id="c-41816973" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#41812676">root</a><span>|</span><a href="#41815998">parent</a><span>|</span><a href="#41816460">next</a><span>|</span><label class="collapse" for="c-41816973">[-]</label><label class="expand" for="c-41816973">[1 more]</label></div><br/><div class="children"><div class="content">Iirc there is also a bazel module that does that for bazel projects and only uses the query functionality without running an actual build</div><br/></div></div><div id="41816460" class="c"><input type="checkbox" id="c-41816460" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#41812676">root</a><span>|</span><a href="#41815998">parent</a><span>|</span><a href="#41816973">prev</a><span>|</span><a href="#41815991">next</a><span>|</span><label class="collapse" for="c-41816460">[-]</label><label class="expand" for="c-41816460">[3 more]</label></div><br/><div class="children"><div class="content">CMake does but I think you have to attempt a build to get the database. On the other hand I don&#x27;t think that should be necessary, as it is capable of generating Ninja build files.<p>Almost nobody is writing Ninja files by hand. If you have to write something along those lines by hand, Makefiles would make more sense than Ninja. If Ninja does support exporting commands, it&#x27;s a use case that doesn&#x27;t matter because almost everyone uses CMake-generated Ninja files.</div><br/><div id="41816464" class="c"><input type="checkbox" id="c-41816464" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#41812676">root</a><span>|</span><a href="#41816460">parent</a><span>|</span><a href="#41815991">next</a><span>|</span><label class="collapse" for="c-41816464">[-]</label><label class="expand" for="c-41816464">[2 more]</label></div><br/><div class="children"><div class="content">You do not need to attempt a build with CMake.<p>Also, that&#x27;s kind of the point of mentioning Ninja. Inherently, anything that uses Ninja is in the same boat and doesn&#x27;t need to start a build.</div><br/><div id="41816721" class="c"><input type="checkbox" id="c-41816721" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#41812676">root</a><span>|</span><a href="#41816464">parent</a><span>|</span><a href="#41815991">next</a><span>|</span><label class="collapse" for="c-41816721">[-]</label><label class="expand" for="c-41816721">[1 more]</label></div><br/><div class="children"><div class="content">The only thing I know that uses Ninja is CMake and I&#x27;m sure CMake does not require Ninja to generate the database.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41815991" class="c"><input type="checkbox" id="c-41815991" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#41812676">prev</a><span>|</span><a href="#41816736">next</a><span>|</span><label class="collapse" for="c-41815991">[-]</label><label class="expand" for="c-41815991">[1 more]</label></div><br/><div class="children"><div class="content">I frequently use this to make clangd work well. With CMake-based projects, you can just set CMAKE_EXPORT_COMPILE_COMMANDS then create a symlink from compile_commands.json in your source directory to the CMake build directory. (If you control the CMake file, you can even set this by default and make CMake create this symlink automatically.) To keep the symlink out of Git, you can add it to .gitignore of course, or if you don&#x27;t control that, the lesser-known local equivalent, .git&#x2F;info&#x2F;exclude.<p>I use this often in combination with direnv and Nix flakes for a good developer experience. (Note that if you need to keep the Nix flake VCS-ignored, you&#x27;ll need to tell direnv to explicitly not use a Git fetcher for Nix using something like `use flake path:&#x2F;&#x2F;$PWD` though this isn&#x27;t needed if you can just re-use a Nixpkgs expression, e.g. `use flake nixpkgs#wineWow64Packages.wine-unstable` or so.)<p>One thing that sucks is that it doesn&#x27;t seem to be easy to handle cross-compilation stuff. Wine is a particularly challenging case, as many of the binaries are now cross-compiled with MinGW. It still provides better completion than nothing, but I do wish I could get it to be perfect.<p>When using Nix with MinGW I struggled even harder because Nix&#x27;s MinGW is even weirder... But with enough mangling, you can even convince clangd on Linux to give somewhat decent completions for a MinGW compilation.<p>One obvious disadvantage is that you kind of need a full rebuild to get the compilation database to work correctly. At least in my personal experience, running bear on a partial build seems to not work in an additive fashion, though maybe I was holding it wrong.</div><br/></div></div><div id="41816736" class="c"><input type="checkbox" id="c-41816736" checked=""/><div class="controls bullet"><span class="by">aulin</span><span>|</span><a href="#41815991">prev</a><span>|</span><a href="#41812403">next</a><span>|</span><label class="collapse" for="c-41816736">[-]</label><label class="expand" for="c-41816736">[1 more]</label></div><br/><div class="children"><div class="content">Working with embedded I had mixed success with bear. Old environments that cannot run the latest version, LD preload messing with vendor toolchains.<p>These days I found my peace just writing my own python scripts to parse verbose build logs. You just need to extract filename, base dir, compiler and arguments.
Sometimes you&#x27;re lucky and build system supports dry run and you don&#x27;t even have to run a real build to get the logs.<p>Way less invasive, no need to ask devops for additional tools and you can adapt it to any build system.<p>Whenever I start with a new toolchain, I spend a couple of hours to tweak the parser and I&#x27;m good to go.</div><br/></div></div><div id="41812403" class="c"><input type="checkbox" id="c-41812403" checked=""/><div class="controls bullet"><span class="by">synergy20</span><span>|</span><a href="#41816736">prev</a><span>|</span><a href="#41813772">next</a><span>|</span><label class="collapse" for="c-41812403">[-]</label><label class="expand" for="c-41812403">[1 more]</label></div><br/><div class="children"><div class="content">the compilation database is essential for editors these days, cmake can generate it directly but not all code use cmake, in that case I just use compiledb, which is inactive (there is a newer compiledb-go though), then use bear. somehow bear did not work well for me comparing to compiledb so compiledb(now compiledb-go) is my main tool now.</div><br/></div></div><div id="41813772" class="c"><input type="checkbox" id="c-41813772" checked=""/><div class="controls bullet"><span class="by">BoingBoomTschak</span><span>|</span><a href="#41812403">prev</a><span>|</span><label class="collapse" for="c-41813772">[-]</label><label class="expand" for="c-41813772">[1 more]</label></div><br/><div class="children"><div class="content">Just shilling a single-file almost POSIX sh script I made to do the same: <a href="https:&#x2F;&#x2F;git.sr.ht&#x2F;~q3cpma&#x2F;scripts&#x2F;tree&#x2F;master&#x2F;item&#x2F;mkcdb" rel="nofollow">https:&#x2F;&#x2F;git.sr.ht&#x2F;~q3cpma&#x2F;scripts&#x2F;tree&#x2F;master&#x2F;item&#x2F;mkcdb</a></div><br/></div></div></div></div></div></div></div></body></html>