<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1691917258801" as="style"/><link rel="stylesheet" href="styles.css?v=1691917258801"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://docs.mesa3d.org/drivers/virgl">VirGL – A virtual 3D GPU for use inside QEMU virtual machines</a> <span class="domain">(<a href="https://docs.mesa3d.org">docs.mesa3d.org</a>)</span></div><div class="subtext"><span>skibz</span> | <span>25 comments</span></div><br/><div><div id="37107128" class="c"><input type="checkbox" id="c-37107128" checked=""/><div class="controls bullet"><span class="by">bilegeek</span><span>|</span><a href="#37107104">next</a><span>|</span><label class="collapse" for="c-37107128">[-]</label><label class="expand" for="c-37107128">[1 more]</label></div><br/><div class="children"><div class="content">Note also: it just got an experimental Windows driver!<p>[1]<a href="https:&#x2F;&#x2F;github.com&#x2F;virtio-win&#x2F;kvm-guest-drivers-windows&#x2F;pull&#x2F;943">https:&#x2F;&#x2F;github.com&#x2F;virtio-win&#x2F;kvm-guest-drivers-windows&#x2F;pull...</a></div><br/></div></div><div id="37107104" class="c"><input type="checkbox" id="c-37107104" checked=""/><div class="controls bullet"><span class="by">jimmySixDOF</span><span>|</span><a href="#37107128">prev</a><span>|</span><a href="#37106987">next</a><span>|</span><label class="collapse" for="c-37107104">[-]</label><label class="expand" for="c-37107104">[1 more]</label></div><br/><div class="children"><div class="content">There is a project I am following to embed a Linux machine into mobile VR applications using virtio-gpu &amp; his latest effort gets 200fps.<p>&quot;VR Linux is now testing with working GPU acceleration via the kernel over virtio-gpu. This is a major step forward following on from the Shadertoy device that we made a few months ago. Now we can make OpenGLES Linux programs that are accelerated by the Quest&#x27;s Adreno GPU.&quot;<p>[1] Thread: <a href="https:&#x2F;&#x2F;twitter.com&#x2F;anjin_games&#x2F;status&#x2F;1371870094490537987?t=iZ-yMEaXADglaz7FLAV6tw&amp;s=19" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;anjin_games&#x2F;status&#x2F;1371870094490537987?t...</a></div><br/></div></div><div id="37106987" class="c"><input type="checkbox" id="c-37106987" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#37107104">prev</a><span>|</span><a href="#37106910">next</a><span>|</span><label class="collapse" for="c-37106987">[-]</label><label class="expand" for="c-37106987">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always found it interesting, and a bit unfortunate, that it seems like things like apitrace are generally pretty reliable, but tools like VirGL seem to often have trouble with typical programs. It <i>seems</i> like the problem of accurately serializing what is being done to the GPU using an API is possible, but in practice there is clearly a lot more to it than that. (Of course, in case of remoting, you do not have the benefit of observing the interactions with a known-good driver and with direct memory mapping&#x2F;etc. So, that probably answers the &quot;why&quot; right there.)<p>It&#x27;s been a while, though. Maybe this works really well... I&#x27;m curious to hear if anyone has more recent experience messing with these things.</div><br/></div></div><div id="37106910" class="c"><input type="checkbox" id="c-37106910" checked=""/><div class="controls bullet"><span class="by">w-ll</span><span>|</span><a href="#37106987">prev</a><span>|</span><a href="#37106327">next</a><span>|</span><label class="collapse" for="c-37106910">[-]</label><label class="expand" for="c-37106910">[6 more]</label></div><br/><div class="children"><div class="content">Its virtual... but passthrough, I would like to see something thats virtual but runs on pure cpu x86 or arm, do not care how slow.</div><br/><div id="37106961" class="c"><input type="checkbox" id="c-37106961" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#37106910">parent</a><span>|</span><a href="#37106953">next</a><span>|</span><label class="collapse" for="c-37106961">[-]</label><label class="expand" for="c-37106961">[2 more]</label></div><br/><div class="children"><div class="content">See LLVMpipe a little ways up the list in the left hand pane. It should do exactly what you&#x27;re looking for.<p>It&#x27;s worth noting the terminology &quot;passthrough&quot; means something else in this particular context and VirGL is not considered a passthrough solution (as noted in the &quot;out of scope&quot; section). VirGL is a form of paravirtualization often called &quot;API remoting&quot;.</div><br/><div id="37108023" class="c"><input type="checkbox" id="c-37108023" checked=""/><div class="controls bullet"><span class="by">exDM69</span><span>|</span><a href="#37106910">root</a><span>|</span><a href="#37106961">parent</a><span>|</span><a href="#37106953">next</a><span>|</span><label class="collapse" for="c-37108023">[-]</label><label class="expand" for="c-37108023">[1 more]</label></div><br/><div class="children"><div class="content">Yes, llvmpipe or lavapipe is awesome. It is fully Vulkan 1.3 compliant and the performance is more than adequate for GUI apps, simple 3d apps or running your gfx tests in a CI environment without a GPU.</div><br/></div></div></div></div><div id="37106953" class="c"><input type="checkbox" id="c-37106953" checked=""/><div class="controls bullet"><span class="by">fayalalebrun</span><span>|</span><a href="#37106910">parent</a><span>|</span><a href="#37106961">prev</a><span>|</span><a href="#37107155">next</a><span>|</span><label class="collapse" for="c-37106953">[-]</label><label class="expand" for="c-37106953">[1 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t using a software gl driver like llvmpipe do the trick?</div><br/></div></div><div id="37107155" class="c"><input type="checkbox" id="c-37107155" checked=""/><div class="controls bullet"><span class="by">steeve</span><span>|</span><a href="#37106910">parent</a><span>|</span><a href="#37106953">prev</a><span>|</span><a href="#37107118">next</a><span>|</span><label class="collapse" for="c-37107155">[-]</label><label class="expand" for="c-37107155">[1 more]</label></div><br/><div class="children"><div class="content">There is swiftshader for that, it works very well</div><br/></div></div><div id="37107118" class="c"><input type="checkbox" id="c-37107118" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#37106910">parent</a><span>|</span><a href="#37107155">prev</a><span>|</span><a href="#37106327">next</a><span>|</span><label class="collapse" for="c-37107118">[-]</label><label class="expand" for="c-37107118">[1 more]</label></div><br/><div class="children"><div class="content">On Windows, there&#x27;s a pure software implementation of Direct3D 11 called WARP <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;direct3darticles&#x2F;directx-warp" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;direct3darti...</a></div><br/></div></div></div></div><div id="37106327" class="c"><input type="checkbox" id="c-37106327" checked=""/><div class="controls bullet"><span class="by">slimsag</span><span>|</span><a href="#37106910">prev</a><span>|</span><a href="#37107562">next</a><span>|</span><label class="collapse" for="c-37106327">[-]</label><label class="expand" for="c-37106327">[7 more]</label></div><br/><div class="children"><div class="content">Very interesting; is there anything similar for Vulkan? Does this also work with Vulkan?</div><br/><div id="37106518" class="c"><input type="checkbox" id="c-37106518" checked=""/><div class="controls bullet"><span class="by">koprulusector</span><span>|</span><a href="#37106327">parent</a><span>|</span><a href="#37106427">next</a><span>|</span><label class="collapse" for="c-37106518">[-]</label><label class="expand" for="c-37106518">[2 more]</label></div><br/><div class="children"><div class="content">Vulkan doesn’t come into play here. Vulkan is a graphics API. This project is hardware GPU virtualization in QEMU &#x2F; libvirt.</div><br/><div id="37106613" class="c"><input type="checkbox" id="c-37106613" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#37106327">root</a><span>|</span><a href="#37106518">parent</a><span>|</span><a href="#37106427">next</a><span>|</span><label class="collapse" for="c-37106613">[-]</label><label class="expand" for="c-37106613">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s incorrect, the goal of VirGL is pass the GL commands themselves (Gallium intermediate representation of them, actually), from the guest to the host, so they are executed on the host accelerated Mesa stack. It is not about virtualising the GPU hardware itself.<p>So it makes sense to one day do the same for Vulkan, which is much lower level and might be able to extract more performance.</div><br/></div></div></div></div><div id="37106427" class="c"><input type="checkbox" id="c-37106427" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#37106327">parent</a><span>|</span><a href="#37106518">prev</a><span>|</span><a href="#37107249">next</a><span>|</span><label class="collapse" for="c-37106427">[-]</label><label class="expand" for="c-37106427">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s called Venus: <a href="https:&#x2F;&#x2F;docs.mesa3d.org&#x2F;drivers&#x2F;venus.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.mesa3d.org&#x2F;drivers&#x2F;venus.html</a><p>But not sure how far along it is. virt-manager doesn&#x27;t seem to be aware of it yet.</div><br/><div id="37106466" class="c"><input type="checkbox" id="c-37106466" checked=""/><div class="controls bullet"><span class="by">modeless</span><span>|</span><a href="#37106327">root</a><span>|</span><a href="#37106427">parent</a><span>|</span><a href="#37107249">next</a><span>|</span><label class="collapse" for="c-37106466">[-]</label><label class="expand" for="c-37106466">[1 more]</label></div><br/><div class="children"><div class="content">ChromeOS uses it for Steam support which is generally available now, as well as for Android apps, so it must work reasonably well: <a href="https:&#x2F;&#x2F;chromeos.dev&#x2F;en&#x2F;posts&#x2F;improving-vulkan-availability-with-venus" rel="nofollow noreferrer">https:&#x2F;&#x2F;chromeos.dev&#x2F;en&#x2F;posts&#x2F;improving-vulkan-availability-...</a></div><br/></div></div></div></div><div id="37107249" class="c"><input type="checkbox" id="c-37107249" checked=""/><div class="controls bullet"><span class="by">gregschlom</span><span>|</span><a href="#37106327">parent</a><span>|</span><a href="#37106427">prev</a><span>|</span><a href="#37106503">next</a><span>|</span><label class="collapse" for="c-37107249">[-]</label><label class="expand" for="c-37107249">[1 more]</label></div><br/><div class="children"><div class="content">Gfxstream, used by the android emulator and others.</div><br/></div></div></div></div><div id="37107562" class="c"><input type="checkbox" id="c-37107562" checked=""/><div class="controls bullet"><span class="by">sneak</span><span>|</span><a href="#37106327">prev</a><span>|</span><a href="#37106627">next</a><span>|</span><label class="collapse" for="c-37107562">[-]</label><label class="expand" for="c-37107562">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never been able to get this to work under UTM on an ARM Mac; if anyone knows the magic qemu and VM settings, please drop me an email (email in profile).<p>It would be nice to have fullscreen, full res 3d accelerated VM guests finally.  I&#x27;ve never been able to get this to work as smoothly as I think it should.</div><br/></div></div><div id="37106627" class="c"><input type="checkbox" id="c-37106627" checked=""/><div class="controls bullet"><span class="by">jsomedon</span><span>|</span><a href="#37107562">prev</a><span>|</span><a href="#37107938">next</a><span>|</span><label class="collapse" for="c-37106627">[-]</label><label class="expand" for="c-37106627">[3 more]</label></div><br/><div class="children"><div class="content">uh, this doesn&#x27;t look like what those gpu passthrough things like vfio do, is it a different thing? Or I am more interested in, can this do what vfio do, run games in almost native performance in windows guest vm?</div><br/><div id="37106660" class="c"><input type="checkbox" id="c-37106660" checked=""/><div class="controls bullet"><span class="by">hueho</span><span>|</span><a href="#37106627">parent</a><span>|</span><a href="#37107274">next</a><span>|</span><label class="collapse" for="c-37106660">[-]</label><label class="expand" for="c-37106660">[1 more]</label></div><br/><div class="children"><div class="content">&gt; run games in almost native performance in windows guest vm?<p>No, vfio is still the most recommended option.<p>This is essentially something like VirtualBox or VMWare 3D acceleration - the host is still the &quot;owner&quot; of the GPU, and has to juggle receiving OpenGL commands from the guest and sending the render results back to it, with lots of overhead. But easier for users than setting up passthrough or using proprietary GPU virtualization solutions.<p>People pointed out that there is a similar project for Vulkan, already being used in production for ChromeOS, called Venus. Should be the one to watch nowadays.</div><br/></div></div><div id="37107274" class="c"><input type="checkbox" id="c-37107274" checked=""/><div class="controls bullet"><span class="by">madushan1000</span><span>|</span><a href="#37106627">parent</a><span>|</span><a href="#37106660">prev</a><span>|</span><a href="#37107938">next</a><span>|</span><label class="collapse" for="c-37107274">[-]</label><label class="expand" for="c-37107274">[1 more]</label></div><br/><div class="children"><div class="content">Virgl just sends opengl commands to the host. And it also has to copy some buffers back and forth. So it won&#x27;t be as fast as vfio. But, there is a new feature called VirtGPU DRM native contexts which eliminates some of this overhead and run at near native speeds. Unfortunately it&#x27;s only implemented for adreno&#x2F;msm GPUs for now.I think there is work on the way for Intel and AMD GPUs.</div><br/></div></div></div></div><div id="37107938" class="c"><input type="checkbox" id="c-37107938" checked=""/><div class="controls bullet"><span class="by">gary17the</span><span>|</span><a href="#37106627">prev</a><span>|</span><label class="collapse" for="c-37107938">[-]</label><label class="expand" for="c-37107938">[4 more]</label></div><br/><div class="children"><div class="content">VirGL is definitely an interesting project, but all one has to do to get GPU passthrough working (from a Linux QEMU host to <i>any</i> guest OS) is: 1.) research a cheap, secondary GPU that is natively supported by the guest OS, 2.) plug such a secondary GPU into a PCIe slot on the host and hook it up to the primary monitor with a secondary cable (D-Sub vs. DVI, etc.), 3.) setup Linux to ignore the secondary GPU at boot and configure a QEMU VM for the GPU passthrough. The whole process takes perhaps one or two hours and as works flawlessly, with no stability issues. (Switching across the two GPU cables can be accomplished in software by using Display Data Channel &#x2F;DDC&#x2F; utilities and switching keyboard&#x2F;mouse can be accomplished by using evdev &#x2F;event device&#x2F; passthrough.) More information: <a href="https:&#x2F;&#x2F;github.com&#x2F;kholia&#x2F;OSX-KVM&#x2F;blob&#x2F;master&#x2F;notes.md#gpu-passthrough-notes">https:&#x2F;&#x2F;github.com&#x2F;kholia&#x2F;OSX-KVM&#x2F;blob&#x2F;master&#x2F;notes.md#gpu-p...</a></div><br/><div id="37108002" class="c"><input type="checkbox" id="c-37108002" checked=""/><div class="controls bullet"><span class="by">arghwhat</span><span>|</span><a href="#37107938">parent</a><span>|</span><a href="#37107960">next</a><span>|</span><label class="collapse" for="c-37108002">[-]</label><label class="expand" for="c-37108002">[1 more]</label></div><br/><div class="children"><div class="content">See <a href="https:&#x2F;&#x2F;looking-glass.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;looking-glass.io&#x2F;</a> to get around directly connecting monitors<p>But forwarding real GPUs limits the number of VMs and <i>can</i> cause stability issues if unlucky - PCIe device bugs, especially reset bugs, are not unusual. Had problems with e.g. a forwarded rx580 that would require a hard reboot of the host to fix...<p>Things like Intel GVT-g and VirGL are better solutions, when they can be used.</div><br/></div></div><div id="37107960" class="c"><input type="checkbox" id="c-37107960" checked=""/><div class="controls bullet"><span class="by">denkmoon</span><span>|</span><a href="#37107938">parent</a><span>|</span><a href="#37108002">prev</a><span>|</span><label class="collapse" for="c-37107960">[-]</label><label class="expand" for="c-37107960">[2 more]</label></div><br/><div class="children"><div class="content">Except that requires IOMMU which is not always available nor is it always reliable on consumer motherboards.</div><br/><div id="37108003" class="c"><input type="checkbox" id="c-37108003" checked=""/><div class="controls bullet"><span class="by">gary17the</span><span>|</span><a href="#37107938">root</a><span>|</span><a href="#37107960">parent</a><span>|</span><label class="collapse" for="c-37108003">[-]</label><label class="expand" for="c-37108003">[1 more]</label></div><br/><div class="children"><div class="content">Good point, but I believe that was a serious problem 10 years ago, while these days virtually any decent motherboard properly supports IOMMU, consumer-grade boards included - e.g. any Asus motherboard should work perfectly.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>