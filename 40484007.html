<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716800484453" as="style"/><link rel="stylesheet" href="styles.css?v=1716800484453"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://redirect.cs.umbc.edu/courses/331/resources/papers/Evolution-of-Lisp.pdf">The Evolution of Lisp (1993) [pdf]</a>Â <span class="domain">(<a href="https://redirect.cs.umbc.edu">redirect.cs.umbc.edu</a>)</span></div><div class="subtext"><span>swatson741</span> | <span>82 comments</span></div><br/><div><div id="40484444" class="c"><input type="checkbox" id="c-40484444" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40484195">next</a><span>|</span><label class="collapse" for="c-40484444">[-]</label><label class="expand" for="c-40484444">[2 more]</label></div><br/><div class="children"><div class="content">Uncut version: <a href="https:&#x2F;&#x2F;www.dreamsongs.com&#x2F;Files&#x2F;HOPL2-Uncut.pdf" rel="nofollow">https:&#x2F;&#x2F;www.dreamsongs.com&#x2F;Files&#x2F;HOPL2-Uncut.pdf</a><p>A Pattern of Language Evolution, Gabriel&#x2F;Steele 2008, <a href="https:&#x2F;&#x2F;www.dreamsongs.com&#x2F;Files&#x2F;PatternOfLanguageEvolution.pdf" rel="nofollow">https:&#x2F;&#x2F;www.dreamsongs.com&#x2F;Files&#x2F;PatternOfLanguageEvolution....</a></div><br/><div id="40488323" class="c"><input type="checkbox" id="c-40488323" checked=""/><div class="controls bullet"><span class="by">optimalsolver</span><span>|</span><a href="#40484444">parent</a><span>|</span><a href="#40484195">next</a><span>|</span><label class="collapse" for="c-40488323">[-]</label><label class="expand" for="c-40488323">[1 more]</label></div><br/><div class="children"><div class="content">That website&#x27;s homepage really takes me back to the Old Web:<p><a href="https:&#x2F;&#x2F;www.dreamsongs.com" rel="nofollow">https:&#x2F;&#x2F;www.dreamsongs.com</a></div><br/></div></div></div></div><div id="40484195" class="c"><input type="checkbox" id="c-40484195" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#40484444">prev</a><span>|</span><a href="#40487269">next</a><span>|</span><label class="collapse" for="c-40484195">[-]</label><label class="expand" for="c-40484195">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>The Evolution of Lisp (1993) [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14937424">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14937424</a> - Aug 2017 (17 comments)<p><i>The Evolution of Lisp</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=3528694">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=3528694</a> - Jan 2012 (4 comments and a video re-enactment from 2008: <a href="https:&#x2F;&#x2F;www.infoq.com&#x2F;presentations&#x2F;Lisp-Guy-Steele-Richard-Gabriel&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.infoq.com&#x2F;presentations&#x2F;Lisp-Guy-Steele-Richard-...</a>)<p><i>The Evolution of Lisp [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=2082417">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=2082417</a> - Jan 2011 (1 comment)</div><br/></div></div><div id="40487269" class="c"><input type="checkbox" id="c-40487269" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#40484195">prev</a><span>|</span><a href="#40486093">next</a><span>|</span><label class="collapse" for="c-40487269">[-]</label><label class="expand" for="c-40487269">[1 more]</label></div><br/><div class="children"><div class="content">The abiding value of Lisp may be that it&#x27;s a talking point, in the idea of what a programming language is.<p>Forth has a similar quality. The reductionist sweetspot of &quot;implemented as a stack language&quot; and &quot;one step up from machine code&quot;<p>C is the &quot;no guide rails&quot; conversation. Some would say it&#x27;s one step down from assembly because it has none of the rigour and only some of the speed. That lack of rigour, the ability to cast within a memory region if you know how your structure maps into that region, I find extremely useful. Pascal&#x27;s version of it was more clumsy but that said, perhaps the semicolon (and full stop) alone make Pascal part of the C family.<p>(you can&#x27;t directly compute over a value in both float and int in assembler if you are in the ALU&#x2F;FPU register space. You do &quot;cheats&quot; which are not rigorous, but more rigorous than C)</div><br/></div></div><div id="40486093" class="c"><input type="checkbox" id="c-40486093" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40487269">prev</a><span>|</span><a href="#40484982">next</a><span>|</span><label class="collapse" for="c-40486093">[-]</label><label class="expand" for="c-40486093">[1 more]</label></div><br/><div class="children"><div class="content">Please link to uncut version on Gabriel&#x27;s own site.<p>See <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40484444">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40484444</a></div><br/></div></div><div id="40484982" class="c"><input type="checkbox" id="c-40484982" checked=""/><div class="controls bullet"><span class="by">theodpHN</span><span>|</span><a href="#40486093">prev</a><span>|</span><a href="#40487957">next</a><span>|</span><label class="collapse" for="c-40484982">[-]</label><label class="expand" for="c-40484982">[8 more]</label></div><br/><div class="children"><div class="content">Got a link to fairly simple examples comparing Lisp solutions to those in another more &#x27;mainstream&#x27; language (e.g., C, Python, BASIC, Java) that illustrate the benefits of using Lisp over another language for a &#x27;practical&#x27; application? Thanks!</div><br/><div id="40486348" class="c"><input type="checkbox" id="c-40486348" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#40484982">parent</a><span>|</span><a href="#40485036">next</a><span>|</span><label class="collapse" for="c-40486348">[-]</label><label class="expand" for="c-40486348">[1 more]</label></div><br/><div class="children"><div class="content">&gt; simple examples comparing Lisp ... that illustrate the benefits of using Lisp over another language<p>It depends on what you&#x27;re trying to get out of it. For example, you can grab a simple code of some React components with JSX and ask ChatGPT to write it in Hiccup (Clojure). That would show you how s-expressions can reduce the syntax boilerplate and make it smaller. You can do the same thing with Lua and Fennel - Fennel code would be much shorter and cleaner.<p>However, without proper understanding and using structural editing and connected REPL, you probably won&#x27;t see any benefits right away. Lisp code is not the best to be read off the &quot;dead medium&quot; - paper or screen. It&#x27;s better when you have a connected REPL because it allows you to evaluate every single expression on the fly. Instead of trying to understand what (foo x y z) means, you can evaluate it and immediately see the results. With a connected REPL, you can evaluate them separately (individually), or together. Good talk of relevance: &quot;Stop Writing Dead Programs by Jack Rusher&quot; <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=8Ab3ArE8W3s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=8Ab3ArE8W3s</a><p>Next step in understanding the benefits of Lisp code is learning structural editing. Because everything is a symbolic expression, you can easily move, transpose, change, and replace parts of your program. Instead of rewriting a function of seemingly arbitrary syntax constructs, you&#x27;ll be dealing with well-structured forms that you can easily move around. No, it not the same, better or worse than using refactoring features of your IDE with other (non-lispy) languages. It&#x27;s just different.<p>These two aspects - REPL and structural editing - are really difficult to explain; one has to experience them in person to see if that way of writing software feels appealing to them. And yet, without grokking the basics of these two essential things, IMO, the Lisp experience will not be the same, and you may not get why some people get really excited about Lisps.<p>And If you&#x27;re truly looking for a brain-bender, check out <a href="https:&#x2F;&#x2F;github.com&#x2F;hyperfiddle&#x2F;electric">https:&#x2F;&#x2F;github.com&#x2F;hyperfiddle&#x2F;electric</a>. Dive into the concepts, play with the example demos, and see where it takes you. But be warned: it&#x27;s an incredibly dense project and definitely not for the uninitiated. If you haven&#x27;t written in Clojure before, chances are you won&#x27;t fall in love with its ideas overnight. But it&#x27;s a good example of &quot;practical applications&quot; that are difficult to achieve unless you&#x27;re using a Lisp.</div><br/></div></div><div id="40485036" class="c"><input type="checkbox" id="c-40485036" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#40484982">parent</a><span>|</span><a href="#40486348">prev</a><span>|</span><a href="#40487455">next</a><span>|</span><label class="collapse" for="c-40485036">[-]</label><label class="expand" for="c-40485036">[5 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;rosettacode.org" rel="nofollow">https:&#x2F;&#x2F;rosettacode.org</a><p><a href="https:&#x2F;&#x2F;rosettacode.org&#x2F;wiki&#x2F;Category:Common_Lisp" rel="nofollow">https:&#x2F;&#x2F;rosettacode.org&#x2F;wiki&#x2F;Category:Common_Lisp</a><p>This has a lot of problems solved in multiple languages.</div><br/><div id="40485314" class="c"><input type="checkbox" id="c-40485314" checked=""/><div class="controls bullet"><span class="by">theodpHN</span><span>|</span><a href="#40484982">root</a><span>|</span><a href="#40485036">parent</a><span>|</span><a href="#40487455">next</a><span>|</span><label class="collapse" for="c-40485314">[-]</label><label class="expand" for="c-40485314">[4 more]</label></div><br/><div class="children"><div class="content">Thanks, that is a great site! Will have to look at more, but looking at examples like the following, I&#x27;m not having a Lisp Aha! moment when I compare the Lisp and Julia&#x2F;Python implementations, e.g.,<p>Cheryl&#x27;s birthday <a href="https:&#x2F;&#x2F;rosettacode.org&#x2F;wiki&#x2F;Cheryl%27s_birthday" rel="nofollow">https:&#x2F;&#x2F;rosettacode.org&#x2F;wiki&#x2F;Cheryl%27s_birthday</a><p>Seems like part of the problem is that Lisp is often demonstrated with examples that your average programmer can turn to &#x27;black box&#x27; pre-built functions&#x2F;packages&#x2F;software for. That Lisp can help one extend a programming language to add a CASE statement, for example, is not going to win the hearts and minds of those who are already using a programming language with a built-in CASE statement. It may be neat from an intellectual standpoint, but not from a practical one.<p>And the merits of the example linked to below of how Lisp can be used to implement an in-memory database will surely be completely lost on anyone with access to in-memory database software like DuckDB.<p>Practical Common Lisp: An MP3 Database <a href="https:&#x2F;&#x2F;gigamonkeys.com&#x2F;book&#x2F;practical-an-mp3-database" rel="nofollow">https:&#x2F;&#x2F;gigamonkeys.com&#x2F;book&#x2F;practical-an-mp3-database</a><p>DuckDB: SQL Introduction <a href="https:&#x2F;&#x2F;duckdb.org&#x2F;docs&#x2F;archive&#x2F;0.8&#x2F;sql&#x2F;introduction.html" rel="nofollow">https:&#x2F;&#x2F;duckdb.org&#x2F;docs&#x2F;archive&#x2F;0.8&#x2F;sql&#x2F;introduction.html</a></div><br/><div id="40485456" class="c"><input type="checkbox" id="c-40485456" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#40484982">root</a><span>|</span><a href="#40485314">parent</a><span>|</span><a href="#40487092">next</a><span>|</span><label class="collapse" for="c-40485456">[-]</label><label class="expand" for="c-40485456">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think anyone should expect to get an &quot;Aha! moment&quot; from looking at algorithmic code. That&#x27;s going to be the same in most languages.<p>If you want a &quot;Lisp Aha! moment&quot; you&#x27;d probably be better off looking at something that&#x27;s actually Lisp-centric like <i>Paradigms of AI Programming</i> by Norvig (<a href="https:&#x2F;&#x2F;github.com&#x2F;norvig&#x2F;paip-lisp">https:&#x2F;&#x2F;github.com&#x2F;norvig&#x2F;paip-lisp</a>). You eventually build up to a Prolog to CL compiler written in CL.</div><br/></div></div><div id="40487092" class="c"><input type="checkbox" id="c-40487092" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#40484982">root</a><span>|</span><a href="#40485314">parent</a><span>|</span><a href="#40485456">prev</a><span>|</span><a href="#40487322">next</a><span>|</span><label class="collapse" for="c-40487092">[-]</label><label class="expand" for="c-40487092">[1 more]</label></div><br/><div class="children"><div class="content">The Aha moment for Lisp can not be read.<p>You have to write code and experience it.<p>I mean, of course it has same cool constructs, but, at least for me, its the experience of writing code with it that makes it shine. And that kind of thing is intangible.<p>The iterative development experience is part of it. But, at least, the code I write has a rhythm to it, and I don&#x27;t write other languages the way I write Lisp. Even at the 10,000 foot level, it&#x27;s mot the same. For example, I tend to write more, smaller functions. Like Forth, its very easy to refactor Lisp. Being iterative and interactive, it supports and encourages that kind of thing.<p>Write a little thing, test it. Write another little thing, building on all the other little things, test those. (Note, not &quot;write tests for them&quot;, just...test them. In the listener. &quot;Good! Moving on!&quot;)<p>Find something that interests you, preferably something that&#x27;s not &quot;let&#x27;s glue all of these other libraries together&quot;. Something that&#x27;s going take 500-1000 lines. And, just write. Learn as you go, don&#x27;t worry about being idiomatic.<p>See if anything pops from that.</div><br/></div></div><div id="40487322" class="c"><input type="checkbox" id="c-40487322" checked=""/><div class="controls bullet"><span class="by">vzcx</span><span>|</span><a href="#40484982">root</a><span>|</span><a href="#40485314">parent</a><span>|</span><a href="#40487092">prev</a><span>|</span><a href="#40487455">next</a><span>|</span><label class="collapse" for="c-40487322">[-]</label><label class="expand" for="c-40487322">[1 more]</label></div><br/><div class="children"><div class="content">Since there are other decent dynlangs out there, the benefits are less about the surface language aspect, and more about the process of getting to a solution. These are the system aspects of lisp that enable an incremental development workflow with a lightning-fast feedback loop. While there are important language features that support this, it&#x27;s ultimately a &quot;whole is more than the sum of its parts&quot; effect.<p>I&#x27;d recommend checking out videos of people developing systems in lisp. Off the top of my head:<p>- <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;@CBaggers&#x2F;playlists" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;@CBaggers&#x2F;playlists</a><p>- <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;playlist?list=PLTA6M4yZF0MzsMlNL0N67tIU12OLQ-R5K" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;playlist?list=PLTA6M4yZF0MzsMlNL0N67...</a></div><br/></div></div></div></div></div></div><div id="40487455" class="c"><input type="checkbox" id="c-40487455" checked=""/><div class="controls bullet"><span class="by">molteanu</span><span>|</span><a href="#40484982">parent</a><span>|</span><a href="#40485036">prev</a><span>|</span><a href="#40487957">next</a><span>|</span><label class="collapse" for="c-40487455">[-]</label><label class="expand" for="c-40487455">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;mihaiolteanu.me&#x2F;language-abstractions" rel="nofollow">https:&#x2F;&#x2F;mihaiolteanu.me&#x2F;language-abstractions</a></div><br/></div></div></div></div><div id="40487957" class="c"><input type="checkbox" id="c-40487957" checked=""/><div class="controls bullet"><span class="by">throw156754228</span><span>|</span><a href="#40484982">prev</a><span>|</span><a href="#40485156">next</a><span>|</span><label class="collapse" for="c-40487957">[-]</label><label class="expand" for="c-40487957">[7 more]</label></div><br/><div class="children"><div class="content">What&#x27;s a good resource for learning to write a lisp compiler?</div><br/><div id="40488473" class="c"><input type="checkbox" id="c-40488473" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#40487957">parent</a><span>|</span><a href="#40488344">next</a><span>|</span><label class="collapse" for="c-40488473">[-]</label><label class="expand" for="c-40488473">[1 more]</label></div><br/><div class="children"><div class="content">Look at all of them, then throw them away. Start with a lexer, a parser (pretty easy), the AST is already done, then it&#x27;s all about the eval loop. All you need is sit down until you understand Lisp&#x27;s metacircular evaluator (less than 50 lines or code), which is all you need to implement eval.<p>(I found this while writing this comment: <a href="https:&#x2F;&#x2F;bernsteinbear.com&#x2F;blog&#x2F;lisp&#x2F;12_metacircular&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bernsteinbear.com&#x2F;blog&#x2F;lisp&#x2F;12_metacircular&#x2F;</a>)</div><br/></div></div><div id="40488344" class="c"><input type="checkbox" id="c-40488344" checked=""/><div class="controls bullet"><span class="by">fungiblecog</span><span>|</span><a href="#40487957">parent</a><span>|</span><a href="#40488473">prev</a><span>|</span><a href="#40487970">next</a><span>|</span><label class="collapse" for="c-40488344">[-]</label><label class="expand" for="c-40488344">[1 more]</label></div><br/><div class="children"><div class="content">This: <a href="https:&#x2F;&#x2F;github.com&#x2F;kanaka&#x2F;mal">https:&#x2F;&#x2F;github.com&#x2F;kanaka&#x2F;mal</a></div><br/></div></div><div id="40487970" class="c"><input type="checkbox" id="c-40487970" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#40487957">parent</a><span>|</span><a href="#40488344">prev</a><span>|</span><a href="#40485156">next</a><span>|</span><label class="collapse" for="c-40487970">[-]</label><label class="expand" for="c-40487970">[4 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;buildyourownlisp.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;buildyourownlisp.com&#x2F;</a> is a good start.</div><br/><div id="40488263" class="c"><input type="checkbox" id="c-40488263" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#40487957">root</a><span>|</span><a href="#40487970">parent</a><span>|</span><a href="#40485156">next</a><span>|</span><label class="collapse" for="c-40488263">[-]</label><label class="expand" for="c-40488263">[3 more]</label></div><br/><div class="children"><div class="content">It is a very bad start and teaches writing an interpreter and not a compiler. <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;no-defun-allowed&#x2F;7e3e238c959e27d4919bb4272487d7ad" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;no-defun-allowed&#x2F;7e3e238c959e27d4919...</a></div><br/><div id="40488698" class="c"><input type="checkbox" id="c-40488698" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#40487957">root</a><span>|</span><a href="#40488263">parent</a><span>|</span><a href="#40485156">next</a><span>|</span><label class="collapse" for="c-40488698">[-]</label><label class="expand" for="c-40488698">[2 more]</label></div><br/><div class="children"><div class="content">Do you imagine it to be especially hard or impossible to replace an interpreter with a compiler instead of implementing a compiler from scratch? It makes it harder to have decided on the language design rather than inventing it in parallel?<p>From an interpreted Lisp system to a compiler it&#x27;s mostly a slog of studying compilers and assembly (or machine code) and possibly translating the interpreter, which you can use to bootstrap the compiler implementation if you&#x27;d like.<p>It&#x27;s common path, see <a href="https:&#x2F;&#x2F;mpov.timmorgan.org&#x2F;i-built-a-lisp-compiler&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mpov.timmorgan.org&#x2F;i-built-a-lisp-compiler&#x2F;</a> and <a href="https:&#x2F;&#x2F;bernsteinbear.com&#x2F;blog&#x2F;compiling-a-lisp-0&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bernsteinbear.com&#x2F;blog&#x2F;compiling-a-lisp-0&#x2F;</a> .</div><br/><div id="40488839" class="c"><input type="checkbox" id="c-40488839" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#40487957">root</a><span>|</span><a href="#40488698">parent</a><span>|</span><a href="#40485156">next</a><span>|</span><label class="collapse" for="c-40488839">[-]</label><label class="expand" for="c-40488839">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s especially hard when you don&#x27;t have semantics for your language outside of what your interpreter does. Then the semantics of the language in the book are plain bad: there is only dynamic scoping (oh, and the book often has plain misinformation - the provided definition of &quot;lexical scoping&quot; is wrong), and setting a local variable only affects the innermost LET if you nest environments, since the interpreter deep-copies environments (as it does with everything, to cope with lack of GC).<p>The book also uses something more like fexprs than macros, which I don&#x27;t have an opinion _outside of this book_ on with regards to language UX, but fexprs are generally harder to compile. That is in part because they control if&#x2F;when their arguments are evaluated, but the fexpr-alike things here do not (instead &quot;Q-expressions&quot; delay evaluation like QUOTE). You still would want to do something about calls to EVAL though. The fexpr system _in this book_ also does have bad UX: it only incidentally works with dynamic binding (Shutt&#x27;s lexically scoped fexprs explicitly pass the environment around) and it also leaks every variable binding from the fexpr function into what it evaluates.<p>The book also just doesn&#x27;t cover compilers, so you&#x27;re doing that slog on your own.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40485156" class="c"><input type="checkbox" id="c-40485156" checked=""/><div class="controls bullet"><span class="by">7373737373</span><span>|</span><a href="#40487957">prev</a><span>|</span><a href="#40485766">next</a><span>|</span><label class="collapse" for="c-40485156">[-]</label><label class="expand" for="c-40485156">[11 more]</label></div><br/><div class="children"><div class="content">Is there any old or new Lisp variant with excellent, beginner friendly (or even loving) documentation?</div><br/><div id="40487739" class="c"><input type="checkbox" id="c-40487739" checked=""/><div class="controls bullet"><span class="by">nicklecompte</span><span>|</span><a href="#40485156">parent</a><span>|</span><a href="#40486564">next</a><span>|</span><label class="collapse" for="c-40487739">[-]</label><label class="expand" for="c-40487739">[1 more]</label></div><br/><div class="children"><div class="content">Racket might be the best bet, especially since it comes with a graphical IDE - Emacs is a big stumbling block for beginners. Racket also has lots of tools that make it fun and practical for learners (e.g. creating static websites, simple GUI applications). Things like this seems like the best way to learn without getting bored or frustrated: <a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;quick&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;quick&#x2F;</a></div><br/></div></div><div id="40486564" class="c"><input type="checkbox" id="c-40486564" checked=""/><div class="controls bullet"><span class="by">nicklaf</span><span>|</span><a href="#40485156">parent</a><span>|</span><a href="#40487739">prev</a><span>|</span><a href="#40485740">next</a><span>|</span><label class="collapse" for="c-40486564">[-]</label><label class="expand" for="c-40486564">[1 more]</label></div><br/><div class="children"><div class="content">Check out Conrad Barski&#x27;s Land of Lisp: <a href="http:&#x2F;&#x2F;landoflisp.com&#x2F;" rel="nofollow">http:&#x2F;&#x2F;landoflisp.com&#x2F;</a></div><br/></div></div><div id="40485740" class="c"><input type="checkbox" id="c-40485740" checked=""/><div class="controls bullet"><span class="by">sourcepluck</span><span>|</span><a href="#40485156">parent</a><span>|</span><a href="#40486564">prev</a><span>|</span><a href="#40486465">next</a><span>|</span><label class="collapse" for="c-40485740">[-]</label><label class="expand" for="c-40485740">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;janet.guide&#x2F;" rel="nofollow">https:&#x2F;&#x2F;janet.guide&#x2F;</a> this document can definitely be described as loving.</div><br/></div></div><div id="40486465" class="c"><input type="checkbox" id="c-40486465" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#40485156">parent</a><span>|</span><a href="#40485740">prev</a><span>|</span><a href="#40485326">next</a><span>|</span><label class="collapse" for="c-40486465">[-]</label><label class="expand" for="c-40486465">[3 more]</label></div><br/><div class="children"><div class="content">Emacs Lisp is known for its great documentation, but I bet you&#x27;re not asking about that. Try Fennel - it&#x27;s a zero-overhead Lisp-&gt;Lua compiler. &#x27;Zero-overhead&#x27; means that Fennel compiles directly to Lua without adding any extra runtime costs or abstractions beyond those present in standard Lua, ensuring Fennel code runs as efficiently as native Lua code. It has a relatively small set of features and is a very lovely language. I use it for dealing with things that need Lua - Hammerspoon, AwesomeWM, Neovim, etc. I jokingly call Fennel &quot;the best Lua formatter&quot; because Fennel code looks much more compact, cleaner, and easier to reason about than Lua. Lua syntax is weird, and I can never figure out how to format it for the best readability; standard tools and formatters rarely help here, sometimes making things even worse. The problem I almost never had with Fennel.</div><br/><div id="40486731" class="c"><input type="checkbox" id="c-40486731" checked=""/><div class="controls bullet"><span class="by">speedster217</span><span>|</span><a href="#40485156">root</a><span>|</span><a href="#40486465">parent</a><span>|</span><a href="#40485326">next</a><span>|</span><label class="collapse" for="c-40486731">[-]</label><label class="expand" for="c-40486731">[2 more]</label></div><br/><div class="children"><div class="content">Can you share an example of Fennel with AwesomeWM?</div><br/><div id="40486780" class="c"><input type="checkbox" id="c-40486780" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#40485156">root</a><span>|</span><a href="#40486731">parent</a><span>|</span><a href="#40485326">next</a><span>|</span><label class="collapse" for="c-40486780">[-]</label><label class="expand" for="c-40486780">[1 more]</label></div><br/><div class="children"><div class="content">There are plenty: <a href="https:&#x2F;&#x2F;github.com&#x2F;search?ref=simplesearch&amp;q=language%3A%22Fennel%22+awesomewm">https:&#x2F;&#x2F;github.com&#x2F;search?ref=simplesearch&amp;q=language%3A%22F...</a><p>Here&#x27;s mine, <a href="https:&#x2F;&#x2F;github.com&#x2F;agzam&#x2F;awesomewm.d&#x2F;blob&#x2F;main&#x2F;src&#x2F;_init.fnl">https:&#x2F;&#x2F;github.com&#x2F;agzam&#x2F;awesomewm.d&#x2F;blob&#x2F;main&#x2F;src&#x2F;_init.fnl</a><p>Beware though, I&#x27;m not highly experienced in using and configuring Awesome (especially for beautification), the code is not meant to be shared and it has tons of dirty parts (result of my experimentation), I only built what I needed for my personal use.<p>Bigger (more public) project built on Fennel is <a href="https:&#x2F;&#x2F;github.com&#x2F;agzam&#x2F;spacehammer">https:&#x2F;&#x2F;github.com&#x2F;agzam&#x2F;spacehammer</a> It&#x27;s for Hammerspoon though, and my guess you&#x27;re using Linux, not Mac.<p>One of the aspects I still haven&#x27;t figured out is the &quot;proper Fennel REPL&quot;, it makes certain things less joyful to write or troubleshoot, but even without it, I see some benefits in using Fennel instead of Lua - it&#x27;s more compact, more FP-oriented, has macros, and it&#x27;s a Lisp - I can use structural editing.</div><br/></div></div></div></div></div></div><div id="40485326" class="c"><input type="checkbox" id="c-40485326" checked=""/><div class="controls bullet"><span class="by">swatson741</span><span>|</span><a href="#40485156">parent</a><span>|</span><a href="#40486465">prev</a><span>|</span><a href="#40485239">next</a><span>|</span><label class="collapse" for="c-40485326">[-]</label><label class="expand" for="c-40485326">[2 more]</label></div><br/><div class="children"><div class="content">R6RS has a book that describes everything simply except for setting up the interpreter. [1]<p>Racket has all of that and everything else you need to get started like tooling and modules. [2]<p>Both lisps are no nonsense scheme variants.<p>[1](<a href="https:&#x2F;&#x2F;www.scheme.com&#x2F;tspl4&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.scheme.com&#x2F;tspl4&#x2F;</a>)
[2](<a href="https:&#x2F;&#x2F;racket-lang.org" rel="nofollow">https:&#x2F;&#x2F;racket-lang.org</a>)</div><br/><div id="40486702" class="c"><input type="checkbox" id="c-40486702" checked=""/><div class="controls bullet"><span class="by">ethagnawl</span><span>|</span><a href="#40485156">root</a><span>|</span><a href="#40485326">parent</a><span>|</span><a href="#40485239">next</a><span>|</span><label class="collapse" for="c-40486702">[-]</label><label class="expand" for="c-40486702">[1 more]</label></div><br/><div class="children"><div class="content">I was going to suggest Racket, too. Its documentation is some of the best I&#x27;ve ever come across. It doesn&#x27;t hurt that it&#x27;s beautiful, too. I smile every time I use Racket or its documentation.</div><br/></div></div></div></div><div id="40485239" class="c"><input type="checkbox" id="c-40485239" checked=""/><div class="controls bullet"><span class="by">pgt</span><span>|</span><a href="#40485156">parent</a><span>|</span><a href="#40485326">prev</a><span>|</span><a href="#40487145">next</a><span>|</span><label class="collapse" for="c-40485239">[-]</label><label class="expand" for="c-40485239">[1 more]</label></div><br/><div class="children"><div class="content">Clojure: <a href="http:&#x2F;&#x2F;clojurescriptkoans.com&#x2F;" rel="nofollow">http:&#x2F;&#x2F;clojurescriptkoans.com&#x2F;</a></div><br/></div></div><div id="40487145" class="c"><input type="checkbox" id="c-40487145" checked=""/><div class="controls bullet"><span class="by">citizen_friend</span><span>|</span><a href="#40485156">parent</a><span>|</span><a href="#40485239">prev</a><span>|</span><a href="#40485766">next</a><span>|</span><label class="collapse" for="c-40487145">[-]</label><label class="expand" for="c-40487145">[1 more]</label></div><br/><div class="children"><div class="content">Sicp for scheme</div><br/></div></div></div></div><div id="40485766" class="c"><input type="checkbox" id="c-40485766" checked=""/><div class="controls bullet"><span class="by">gjvc</span><span>|</span><a href="#40485156">prev</a><span>|</span><a href="#40484263">next</a><span>|</span><label class="collapse" for="c-40485766">[-]</label><label class="expand" for="c-40485766">[1 more]</label></div><br/><div class="children"><div class="content">anyone got the .tex source for this?</div><br/></div></div><div id="40484263" class="c"><input type="checkbox" id="c-40484263" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#40485766">prev</a><span>|</span><a href="#40484584">next</a><span>|</span><label class="collapse" for="c-40484263">[-]</label><label class="expand" for="c-40484263">[31 more]</label></div><br/><div class="children"><div class="content">People should clarify what they mean by &quot;Lisp&quot;. It&#x27;s not a programming language or even a family of languages, it&#x27;s a whole different computing system which just happens to have a programming language syntax on top. To get the most out of it and benefit from the powerful CL REPL, one needs to use Emacs (also written in Lisp).<p>Some variants just drop that part and focus on the language only. Clojure and Racket are in that category. They lack the full power of CL; so they&#x27;re just Lisp-syntax languages, not an actual Lisp.<p>Maybe this high barrier to entry is why Lisp hasn&#x27;t caught on even after 30 years of CL standardization. People often don&#x27;t want to learn a new IDE to get the most out of Lisp. And if they stick to their current IDEs, they only get a glimpse of Lisp through its syntax (and much limited macro system). At that point, it&#x27;s questionable whether whatever remains of Lisp does indeed provide any advantage over more mainstream languages (e.g., instead of learning Clojure, why not just learn a functional language like Elixir or Haskell? It&#x27;s not like Clojure gives you the full Lisp power anyway.)<p>Addendum: As one of the comments below mentioned (thank you @lispm), what I meant by &quot;dropping the full power of Lisp&quot; is the ability to modify a running program (continuation&#x2F;restart system). Does Clojure REPL drop you in a new REPL in case of errors so you can literally change the running code or enter value for a missing variable?</div><br/><div id="40484501" class="c"><input type="checkbox" id="c-40484501" checked=""/><div class="controls bullet"><span class="by">amszmidt</span><span>|</span><a href="#40484263">parent</a><span>|</span><a href="#40484524">next</a><span>|</span><label class="collapse" for="c-40484501">[-]</label><label class="expand" for="c-40484501">[6 more]</label></div><br/><div class="children"><div class="content">Alas there are two schools -- those that consider Lisp to be a language with its cradle defined by JMC&#x27;s &quot;Recursive Functions of Symbolic Expressions and Their Computation by Machine&quot; and descendants thereof (Lisp1.5, MACLISP, Lisp Machine Lisp, Common Lisp, Emacs Lisp, ...).  Sort of like with C, where Objective-C is clearly a &quot;C&quot;, similar with C++.<p>Then there is another school which considers the meta programability, REPL, syntax, ... the more philosophical notion of Lisp (Scheme, Clojure, Racket, Arc, ...).  Some have no similarity with Lisp 1.5 descendants, and only share a superficial similarity.<p>Lisp seems to be the only language where people really want to argue that they are a Lisp, nobody tries to argue that Javascript, Java, PHP etc are &quot;a C&quot; (similar syntax? semantics?).  Does it even matter what is &quot;a Lisp&quot;?<p>The barrier for Lisp (be it one school or the other) is about as high as Python, you type the name of the implementation and do stuff.  CL specifically doesn&#x27;t say anything interesting about the REPL (e.g., SBCL doesn&#x27;t even allow by default to navigate forms on the command line), so to say that it is &quot;powerful&quot; is very misleading.  Similar about the requirement of Emacs, you can use anything you like.</div><br/><div id="40487560" class="c"><input type="checkbox" id="c-40487560" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40484501">parent</a><span>|</span><a href="#40485127">next</a><span>|</span><label class="collapse" for="c-40487560">[-]</label><label class="expand" for="c-40487560">[1 more]</label></div><br/><div class="children"><div class="content">There is a third school: those who consider &quot;Lisp&quot; to refer to, in a historic context, a specific old language that is no longer in use (which was actually called LISP), and in a modern context to a fairly diverse family of languages.<p>People don&#x27;t argue whether Javascript is &quot;a C&quot;. However, people do argue whether GNU C is C. Some pedants insist that only ISO C is C and that, for instance, GNU extensions like nested functions are not C. (And are off topic in the usenet newsgroup comp.lang.c.)<p>To me, C++ is a dialect of C. In fact, you can write production code in a language that compiles as either C or C++ and behaves the same way, with similar executable size and performance. When you do that, there are obviously C++ features you cannot use, but also C features you cannot use.</div><br/></div></div><div id="40485127" class="c"><input type="checkbox" id="c-40485127" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40484501">parent</a><span>|</span><a href="#40487560">prev</a><span>|</span><a href="#40484524">next</a><span>|</span><label class="collapse" for="c-40485127">[-]</label><label class="expand" for="c-40485127">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Lisp seems to be the only language where people really want to argue that they are a Lisp, nobody tries to argue that Javascript, Java, PHP etc are &quot;a C&quot; (similar syntax? semantics?). Does it even matter what is &quot;a Lisp&quot;?</i><p>Lisp is far from being the only family of languages. There&#x27;s the APL family, with k, j, q. There are the many Forths, to the point where it&#x27;s been quipped that the language has more implementations than users. The C family rather clearly includes C++, Objective C, and D, as well as C itself (Swift and Rust are arguable here).<p>I wouldn&#x27;t put the three languages you named in the C family, but they&#x27;re all Algols in a manner of speaking. At least, I routinely describe them that way, and people tend to understand what I mean. The reason no one argues that those languages are in the C family is just the broad and informal consensus that ABI compatibility is the most important feature, rather than syntax.<p>Any time there&#x27;s taxonomy going on, you&#x27;ll have lumpers and splitters. I&#x27;m a lumper where Lisps are concerned. I would call Dylan and Julia Lisps, and have done so.<p>If anything, what makes Lisp unique here is a faction of Common Lisp users who feel strongly that the only Lisp is Common, and historical variants which lead up to the Hyperspec (elisp being grandfathered in on that basis). I&#x27;ve never entirely understood this, but I don&#x27;t let it bother me. That appears to be the source of the argument you reference in the section of your post I&#x27;ve quoted.</div><br/><div id="40487647" class="c"><input type="checkbox" id="c-40487647" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40485127">parent</a><span>|</span><a href="#40487261">next</a><span>|</span><label class="collapse" for="c-40487647">[-]</label><label class="expand" for="c-40487647">[2 more]</label></div><br/><div class="children"><div class="content">Does it matter what is a Lisp? We can answer it like this.<p>Yes, it matters in the following way. New languages being touted as Lisps, which deviate from the Lisp characteristics, cause confusion.<p>For instance, nowadays you read comments like: &quot;I tried Lisp for a while but couldn&#x27;t get used to doing everything using immutable sequences, nice as the pure functional paradigm might be conceptually&quot;. Obviously, that person is referring to Clojure, and since Clojure is promoted as a Lisp, they believe that all that is true of Clojure is true of Lisp.<p>People believe such misleading statements which is then harmful to the real Lisps. Someone out there will avoid using Common Lisp believing that they would be required to do everything using immutable sequences or hashes.</div><br/><div id="40488520" class="c"><input type="checkbox" id="c-40488520" checked=""/><div class="controls bullet"><span class="by">Capricorn2481</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40487647">parent</a><span>|</span><a href="#40487261">next</a><span>|</span><label class="collapse" for="c-40488520">[-]</label><label class="expand" for="c-40488520">[1 more]</label></div><br/><div class="children"><div class="content">People already say CL is functional, whether they&#x27;ve used Clojure or not. It&#x27;s a common misconception. The problem is most people on Hackernews are talking about languages they&#x27;ve barely used.<p>Incidentally it&#x27;s MORE confusing for people to say Clojure is not a LISP.</div><br/></div></div></div></div><div id="40487261" class="c"><input type="checkbox" id="c-40487261" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40485127">parent</a><span>|</span><a href="#40487647">prev</a><span>|</span><a href="#40484524">next</a><span>|</span><label class="collapse" for="c-40487261">[-]</label><label class="expand" for="c-40487261">[1 more]</label></div><br/><div class="children"><div class="content">You took clause #1 .. family of language and ignored clause #2 .. where people argue about admissability into the family.<p>The point is not &quot;only family&quot; its &quot;only family, where people argue about being in the family&quot;<p>I think it&#x27;s actually not the only language family where people argue about admission. But that doesn&#x27;t seem to be your point.<p>Your point seems to be &quot;there are other families&quot;</div><br/></div></div></div></div></div></div><div id="40484524" class="c"><input type="checkbox" id="c-40484524" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#40484263">parent</a><span>|</span><a href="#40484501">prev</a><span>|</span><a href="#40484340">next</a><span>|</span><label class="collapse" for="c-40484524">[-]</label><label class="expand" for="c-40484524">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Clojure and Racket are in that category. They lack the full power of CL; so they&#x27;re just Lisp-syntax languages, not an actual Lisp.<p>That&#x27;s pretty debatable that Clojure and Racket lack the &quot;full power of Common Lisp&quot;. For one, they&#x27;re all three different languages, each one having something the other doesn&#x27;t. And another is that Racket is not a Lisp and doesn&#x27;t purport to be. It&#x27;s very much in the Scheme camp, but even then it is clearly it&#x27;s own thing.</div><br/></div></div><div id="40484340" class="c"><input type="checkbox" id="c-40484340" checked=""/><div class="controls bullet"><span class="by">tvink</span><span>|</span><a href="#40484263">parent</a><span>|</span><a href="#40484524">prev</a><span>|</span><a href="#40486258">next</a><span>|</span><label class="collapse" for="c-40484340">[-]</label><label class="expand" for="c-40484340">[3 more]</label></div><br/><div class="children"><div class="content">Why do you say that one needs to use Emacs? Like, I love using Emacs for the elisp and having the power of a full lisp machine, but for CL I didn&#x27;t find sly-mode&#x2F;slime to offer anything particular paradigm-shiftingly more powerful than the vim&#x2F;nvim adaptions?<p>This very side is written in CL in vi, if I&#x27;m not mistaken?</div><br/><div id="40484371" class="c"><input type="checkbox" id="c-40484371" checked=""/><div class="controls bullet"><span class="by">kagevf</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40484340">parent</a><span>|</span><a href="#40484528">next</a><span>|</span><label class="collapse" for="c-40484371">[-]</label><label class="expand" for="c-40484371">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s written in arc, a lisp language Paul Graham created. I think you&#x27;re right about vi, though.</div><br/></div></div><div id="40484528" class="c"><input type="checkbox" id="c-40484528" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40484340">parent</a><span>|</span><a href="#40484371">prev</a><span>|</span><a href="#40486258">next</a><span>|</span><label class="collapse" for="c-40484528">[-]</label><label class="expand" for="c-40484528">[1 more]</label></div><br/><div class="children"><div class="content">The site is written in Arc, which is a language written in an older version of Racket.</div><br/></div></div></div></div><div id="40486258" class="c"><input type="checkbox" id="c-40486258" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#40484263">parent</a><span>|</span><a href="#40484340">prev</a><span>|</span><a href="#40484425">next</a><span>|</span><label class="collapse" for="c-40486258">[-]</label><label class="expand" for="c-40486258">[12 more]</label></div><br/><div class="children"><div class="content">Oh, come on. Next, you&#x27;re going to claim that Clojure is not &quot;an actual Lisp&quot; because it contains neither &quot;Common&quot; nor &quot;Lisp&quot; in the name? Clojure is a proper Lisp. Period. It&#x27;s homoiconic, it has macros, it is a Lisp-1 Lisp, not &quot;kind of a Lisp-1 thing&quot; or &quot;a thing with a Lispy syntax.&quot; It is a proper, legit, respectable addition to the family of Lisps. Yes, it&#x27;s not a Common Lisp, but it&#x27;s a Lisp nevertheless. A three-wheeled car is still considered a car. While it may fall into a specific category of vehicles and sometimes be classified as a motorcycle or under a special designation depending on the jurisdiction, it is generally recognized as a type of car.<p>&gt; why not just learn a functional language like Elixir or Haskell<p>Have you ever considered that specifically because Clojure borrowed some ideas from Lisp, some from object-oriented languages, and some from FP, it makes it a really good choice for certain applications and developers?<p>Besides, is it really a big deal not to have proper continuation&#x2F;restart in Clojure? It really depends. For many use cases, the error handling techniques in Clojure are adequate and align well with its functional paradigms. I&#x27;ve been using Clojure for several years and haven&#x27;t heard anyone seriously complaining about the lack of continuations, despite many former Common Lispers now being full-time Clojuristas. There are also some philosophical differences: The philosophy behind Clojure focuses on simplicity and building software with different tools and techniques, which can achieve similar robustness in practice. So, I don&#x27;t know. Sure, I personally wouldn&#x27;t mind having built-in support for continuations in Clojure, and there were some attempts to bring that via libraries, but this was never a &quot;high priority thing&quot; for Clojurists. If in 17 years of existence of Clojure (and almost 40 years of Emacs Lisp), that never became a thing everyone wants, I guess it&#x27;s not as critical as you paint it to be.</div><br/><div id="40488010" class="c"><input type="checkbox" id="c-40488010" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40486258">parent</a><span>|</span><a href="#40487428">next</a><span>|</span><label class="collapse" for="c-40488010">[-]</label><label class="expand" for="c-40488010">[2 more]</label></div><br/><div class="children"><div class="content">&quot;continuations&quot; are not in standard Common Lisp. They are a Scheme feature (-&gt; functions which capture a state of computation). Common Lisp has a standardized exception handling system called the &quot;Condition system&quot;, it features conditions (-&gt; exception classes), handlers and restarts. It provides a non-terminating exception handling system, also often with a user interface -&gt; the user can choose a restarts via some menu system or in the REPL. Something similar is in Smalltalk, which provides excellent tools for error handling and debugging.<p>Lisps prior to Common Lisp usually had elaborate ways to handle runtime errors and extensive REPL interfaces for it, for example the break loop -&gt; a REPL in the error context. The most prominent and widely cited was the one of Interlisp, which featured also user facing automatic error repair (-&gt; DWIM).<p>Whenever I see a Lisp, which doesn&#x27;t stop at an error and then let me look at it, I feel sad.<p>GNU Emacs is an application (a text editor) -&gt; debug-on-error is by default NIL. That makes sense in an application.<p>&gt; that never became a thing everyone wants, I guess it&#x27;s not as critical as you paint it to be.<p>People asked for it, it seems. But the answer was no.<p>See for example &quot;<a href="https:&#x2F;&#x2F;vimeo.com&#x2F;223309989" rel="nofollow">https:&#x2F;&#x2F;vimeo.com&#x2F;223309989</a>&quot;, &quot;REPL driven development&quot;. It was a topic in the Q&amp;A at the end.<p>Also: Since JVM&#x2F;Java already has a built-in exception handling, why build another one?<p>There are some libraries...</div><br/><div id="40488079" class="c"><input type="checkbox" id="c-40488079" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40488010">parent</a><span>|</span><a href="#40487428">next</a><span>|</span><label class="collapse" for="c-40488079">[-]</label><label class="expand" for="c-40488079">[1 more]</label></div><br/><div class="children"><div class="content">Ah... it&#x27;s that thing that stars a debugger when you hit an exception, right?</div><br/></div></div></div></div><div id="40487428" class="c"><input type="checkbox" id="c-40487428" checked=""/><div class="controls bullet"><span class="by">vzcx</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40486258">parent</a><span>|</span><a href="#40488010">prev</a><span>|</span><a href="#40484425">next</a><span>|</span><label class="collapse" for="c-40487428">[-]</label><label class="expand" for="c-40487428">[9 more]</label></div><br/><div class="children"><div class="content">Lisp is a family of languages. They share a common ancestry. That family is larger than Common Lisp, although Common Lisp is might be the last living descendant. While there are common traits among members of the family (parenthesized notation, certain special forms, symbol names), the presence of these traits does not itself define the family any more than having fins implies that an animal must be a member of the fish family.<p>A language is not only its syntax, but also it&#x27;s semantics. Lisp is not just parentheses or even &#x27;homoiconicity.&#x27; In addition to the surface syntax, there is a shared cultural understanding of what certain symbols mean, how they fit together into a system, what a symbol even is, and so on.<p>Given that, while there is some surface resemblance to lisp, it&#x27;s plainly obvious to me that Clojure does not belong in that family. This is not a dig at Clojure! Clojure makes a lot of people happy and productive, and that&#x27;s great. It&#x27;s my third favorite language on the JVM. But when you take a closer look at some very core design decisions made in Clojure you&#x27;ll find that they depart strongly enough from all the other languages in the Lisp family that it belongs to a distinct language family. A few of them:<p>- Reader doesn&#x27;t intern symbols<p>- EQUAL symbols aren&#x27;t EQ<p>- Introduction of vars<p>- Cons doesn&#x27;t cons<p>- No numeric tower<p>- Backquote behavior<p>These things don&#x27;t necessarily come up in day-to-day programming, so it might seem like quibbling, but these are fairly central differences in meaning.<p>I think it&#x27;s sensible to consider &quot;Clojures&quot; as a distinct language family. Rhere are languages like Fennel and Hy that are clearly Clojures, and I&#x27;m sure there will be more.</div><br/><div id="40488549" class="c"><input type="checkbox" id="c-40488549" checked=""/><div class="controls bullet"><span class="by">Capricorn2481</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40487428">parent</a><span>|</span><a href="#40487628">next</a><span>|</span><label class="collapse" for="c-40488549">[-]</label><label class="expand" for="c-40488549">[1 more]</label></div><br/><div class="children"><div class="content">What would be the point of equal symbols being EQ in a functional language? They are effectively EQ because it can compare by value quickly.<p>Also, is there anything good about cons? It seems like the most obtuse way to do a sequence unless you need something funky that you could implement yourself.</div><br/></div></div><div id="40487628" class="c"><input type="checkbox" id="c-40487628" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40487428">parent</a><span>|</span><a href="#40488549">prev</a><span>|</span><a href="#40484425">next</a><span>|</span><label class="collapse" for="c-40487628">[-]</label><label class="expand" for="c-40487628">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not here to debate taxonomy. Rich Hickey says: &quot;Clojure is a dialect of Lisp and shares with Lisp the code-as-data philosophy and a powerful macro system.&quot; No disrespect, but unless Alan Kay or Guy Steele come to your side and convince Rich to stop calling Clojure a Lisp, I&#x27;ll be calling it that. Sorry, maybe Mr. Hickey knows better than I do about the language he created?</div><br/><div id="40487893" class="c"><input type="checkbox" id="c-40487893" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40487628">parent</a><span>|</span><a href="#40484425">next</a><span>|</span><label class="collapse" for="c-40487893">[-]</label><label class="expand" for="c-40487893">[6 more]</label></div><br/><div class="children"><div class="content">&quot;Being a Lisp&quot; or &quot;being a dialect of Lisp&quot;, these are two different things for me.<p>But even the &quot;dialect of Lisp&quot; actually is more like &quot;spiritual dialect of Lisp&quot;.<p>Clojure was from the beginning designed with exactly ZERO backwards compatibility to Lisp. Exactly ZERO of the existing Lisp programs&#x2F;libraries could work. It was even difficult to port them. It&#x27;s basically a kind of &quot;dialect&quot; with new operators and data structures, which interprets prior concepts in new ways and mixes in new stuff.<p>But it was designed with compatibility to Java and the JVM -&gt; one could not reuse existing Lisp code, but one could reuse existing Java code -&gt; since Clojure was hosted on the Java and had integrated calling Java code. Reusing Java was more important, because the goal was to work in a Java industry. Thus there wasn&#x27;t a version of Clojure on top of Lisp, only versions on top of languages&#x2F;infrastructures like JavaScript or .net, because there was another source of reuse.<p>If we look at the above linked paper &quot;The Evolution of Lisp&quot;, then &quot;Evolution&quot; actually meant &quot;Evolution&quot;, not &quot;Restart&quot; -&gt; the language evolved by improving, adding, extending, removing, ... around a core design.<p>Clojure was designed as a new dialect, free of the baggage from the past, with a completely fresh start. Reusing existing code or evolving an existing language was a non-goal. It was newly designed as a hosted implementation (-&gt; the Lisp runtime was gone), it was designed with lazy data structures at its core (-&gt; the Lisp linked lists were gone), it was an opinioned new design, based upon of what Rich Hickey liked about Lisp and what would help him to be employed as a consultant in a Java world -&gt; by developing upon and within the Java stack of standards, tools and libraries.<p>And that&#x27;s fine for him. Rich Hickey had his goals and succeeded with them. Other people found it useful, too.</div><br/><div id="40488011" class="c"><input type="checkbox" id="c-40488011" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40487893">parent</a><span>|</span><a href="#40488368">next</a><span>|</span><label class="collapse" for="c-40488011">[-]</label><label class="expand" for="c-40488011">[3 more]</label></div><br/><div class="children"><div class="content">Okay, look. My native tongue is Russian. In Russian, &quot;being a Russian&quot; has two forms: &quot;Ð ÑÑÑÐºÐ¸Ð¹&quot; and &quot;Ð Ð¾ÑÑÐ¸Ð¹ÑÐºÐ¸Ð¹.&quot; &quot;Ethnic Russian&quot; and &quot;a Resident of Russia.&quot; When translated to English, the difference gets blended, but in Russian, it still exists. We can imagine some completely imaginary English dialects in which &quot;Lisp&quot; would have a different meaning, can&#x27;t we? We can even add some weird rules similar to &quot;Ð Ð¾ÑÑÐ¸Ð¹ÑÐºÐ¸Ð¹ Ð¤Ð»Ð°Ð³&quot; and &quot;Ð ÑÑÑÐºÐ¸Ð¹ Ð¤Ð»Ð°Ð³,&quot; which would be translated depending on the context and time differently. We would have to find ways to describe &quot;the subtle differences of &#x27;Lisp&#x27; in different contexts.&quot; We can pretend we&#x27;re talking in different dialects where &quot;Lisp&quot; means different things. We can create all sorts of rules and standards. But at the end of the day, for most people, Lisp is like &quot;porn&quot; in the sense that &quot;if it is, you know it.&quot; I&#x27;m in that school. Clojure is a Lisp to me. Call me a religious idiot. If people can&#x27;t tell the difference between Common Lisp, Lisp, and Clojure, call them idiots. I don&#x27;t know, usually when I mean to say &quot;Common Lisp&quot; I&#x27;d say it, or I would use &quot;CL&quot; and people usually know what I meant. Then I don&#x27;t know what we&#x27;re arguing about.</div><br/><div id="40488362" class="c"><input type="checkbox" id="c-40488362" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40488011">parent</a><span>|</span><a href="#40488213">next</a><span>|</span><label class="collapse" for="c-40488362">[-]</label><label class="expand" for="c-40488362">[1 more]</label></div><br/><div class="children"><div class="content">I usually don&#x27;t want to call people &quot;idiots&quot;, but I would want to prevent confusion. Even though English is a Germanic language, it&#x27;s not German. It&#x27;s a matter of expectation. If a book title says &quot;Lerne Deutsch&quot; it&#x27;s not meant to mean &quot;Learn English&quot;. Same for &quot;Learn Lisp&quot; and &quot;Learn Clojure&quot;. Both books usually will be about different languages. For example there was a book &quot;The Little Lisper&quot;, for Scheme it was renamed the &quot;The Little Schemer&quot;. People then knew that the book is using the Scheme dialect of Lisp and not Lisp itself.<p>Btw., even though &quot;lernen&quot; and &quot;learn&quot; are coming from a common language background (Proto German, also called Common Germanic, no joke -&gt; <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Proto-Germanic_language" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Proto-Germanic_language</a>) and here mean the same.</div><br/></div></div></div></div><div id="40488368" class="c"><input type="checkbox" id="c-40488368" checked=""/><div class="controls bullet"><span class="by">ventuspilot</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40487893">parent</a><span>|</span><a href="#40488011">prev</a><span>|</span><a href="#40484425">next</a><span>|</span><label class="collapse" for="c-40488368">[-]</label><label class="expand" for="c-40488368">[2 more]</label></div><br/><div class="children"><div class="content">-&gt; the Lisp linked lists were gone<p>Cons cells and linked lists are not completely gone, though:<p><pre><code>    user=&gt; (cons 1 (cons 2 nil))
    (1 2)
</code></pre>
Cons cells however are somewhat limited in that the second argument to cons must be an ISeq.</div><br/><div id="40488412" class="c"><input type="checkbox" id="c-40488412" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40488368">parent</a><span>|</span><a href="#40484425">next</a><span>|</span><label class="collapse" for="c-40488412">[-]</label><label class="expand" for="c-40488412">[1 more]</label></div><br/><div class="children"><div class="content">and then you get this in Clojure:<p><pre><code>  user=&gt; (list? (cons 1 &#x27;(2 3)))
  false
  user=&gt; (cons 1 &#x27;(2 3))
  (1 2 3)
</code></pre>
That&#x27;s &quot;strange&quot;, isn&#x27;t it? It prints as (1 2 3), but it is not a list? So there are things which print as lists, but aren&#x27;t lists? What? Which also means that when we print it and read it back, it will be of a different type and list? will be true?!<p><pre><code>  ELISP&gt; (listp (cons 1 &#x27;(2 3)))
  t
</code></pre>
Puh, Emacs Lisp got it right.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40484425" class="c"><input type="checkbox" id="c-40484425" checked=""/><div class="controls bullet"><span class="by">dimitar</span><span>|</span><a href="#40484263">parent</a><span>|</span><a href="#40486258">prev</a><span>|</span><a href="#40485102">next</a><span>|</span><label class="collapse" for="c-40484425">[-]</label><label class="expand" for="c-40484425">[1 more]</label></div><br/><div class="children"><div class="content">Clojure also has a powerful REPL allowing you to interact with running processes in Emacs and in other editors and IDEa</div><br/></div></div><div id="40485102" class="c"><input type="checkbox" id="c-40485102" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#40484263">parent</a><span>|</span><a href="#40484425">prev</a><span>|</span><a href="#40484396">next</a><span>|</span><label class="collapse" for="c-40485102">[-]</label><label class="expand" for="c-40485102">[3 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need to use Emacs to write Lisp, just like you don&#x27;t need to use the ISPF dataset editor to write COBOL.<p>That said, unlike COBOL, most of whose programmers these days use Visual Studio Code or a modern IDE, Emacs is still the best readily available support one can get for Lisp programming -- and that&#x27;s kind of a black mark against Lisp. I really wish Allegro or somebody would deliver a modern IDE for an affordable price, or at least good VSCode plugin support.</div><br/><div id="40485650" class="c"><input type="checkbox" id="c-40485650" checked=""/><div class="controls bullet"><span class="by">massysett</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40485102">parent</a><span>|</span><a href="#40484396">next</a><span>|</span><label class="collapse" for="c-40485650">[-]</label><label class="expand" for="c-40485650">[2 more]</label></div><br/><div class="children"><div class="content">Some folks prefer the LispWorks IDE.</div><br/><div id="40486422" class="c"><input type="checkbox" id="c-40486422" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40485650">parent</a><span>|</span><a href="#40484396">next</a><span>|</span><label class="collapse" for="c-40486422">[-]</label><label class="expand" for="c-40486422">[1 more]</label></div><br/><div class="children"><div class="content">LispWorks is great but the Personal Edition isn&#x27;t good for much beyond classroom exercises and even some of the hobbyist versions can run you four figs. Not exactly enticing for those looking to get started.</div><br/></div></div></div></div></div></div><div id="40484396" class="c"><input type="checkbox" id="c-40484396" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40484263">parent</a><span>|</span><a href="#40485102">prev</a><span>|</span><a href="#40484584">next</a><span>|</span><label class="collapse" for="c-40484396">[-]</label><label class="expand" for="c-40484396">[4 more]</label></div><br/><div class="children"><div class="content">Clojure isnât an âactualâ Lisp because itâs not Common Lisp? Are you serious? Purity spiral much?</div><br/><div id="40484499" class="c"><input type="checkbox" id="c-40484499" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40484396">parent</a><span>|</span><a href="#40484584">next</a><span>|</span><label class="collapse" for="c-40484499">[-]</label><label class="expand" for="c-40484499">[3 more]</label></div><br/><div class="children"><div class="content">Parent stated that some variations drop the &#x27;whole different computing system&#x27; part of Lisp; which makes them Lisp-syntax languages rather than actual Lisps. I believe he means things like modifying a class and updating all existing instances without having to restart the application, the continuation&#x2F;restart system, and so on.<p>As an aside, please remember the guidelines: &#x27;Please respond to the strongest plausible interpretation of what someone says, not a weaker one that&#x27;s easier to criticize. Assume good faith.&#x27;</div><br/><div id="40484549" class="c"><input type="checkbox" id="c-40484549" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40484499">parent</a><span>|</span><a href="#40484584">next</a><span>|</span><label class="collapse" for="c-40484549">[-]</label><label class="expand" for="c-40484549">[2 more]</label></div><br/><div class="children"><div class="content">The comment was well within the guidelines and is a viable point. When people make broad statements on Lisp like the original great-grandparent comment, they really need to clarify whether they&#x27;re talking about Common Lisp or Lisp-likes. The original LISP doesn&#x27;t have the features that Common Lisp has, so it&#x27;d be weird indeed to say that LISP wasn&#x27;t an actual Lisp.<p>In retrospect, the comment was talking about Common Lisp and not just Lisp-likes and tried to make the distinction but did a poor job of it with comments like:<p>&gt; Clojure and Racket are in that category. They lack the full power of CL; so they&#x27;re just Lisp-syntax languages, not an actual Lisp.</div><br/><div id="40484647" class="c"><input type="checkbox" id="c-40484647" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40484263">root</a><span>|</span><a href="#40484549">parent</a><span>|</span><a href="#40484584">next</a><span>|</span><label class="collapse" for="c-40484647">[-]</label><label class="expand" for="c-40484647">[1 more]</label></div><br/><div class="children"><div class="content">Common Lisp and&#x2F;or its implementations (and a bunch of other dialects) have most most of the features of the original LISP directly, often with minor changes, like many of its operators and data structures (like the linked list). It was designed to be largely backwards compatible with earlier LISP. Original LISP implementation features like the self hosting machine code compiler, loading of natively compiled code and the ability to save&#x2F;restore images of the Lisp heap (which really was already in the 1960s LISP) are also provided by various later Lisp implementations, incl. several CL implementations.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40484584" class="c"><input type="checkbox" id="c-40484584" checked=""/><div class="controls bullet"><span class="by">aj7</span><span>|</span><a href="#40484263">prev</a><span>|</span><a href="#40484540">next</a><span>|</span><label class="collapse" for="c-40484584">[-]</label><label class="expand" for="c-40484584">[7 more]</label></div><br/><div class="children"><div class="content">Paul Graham felt all development should be in Lisp.  Problem is readability by maintainers in the future.  To facilitate that, the number of characters in the comments would have to exceed that in the code.</div><br/><div id="40484677" class="c"><input type="checkbox" id="c-40484677" checked=""/><div class="controls bullet"><span class="by">CaptainOfCoit</span><span>|</span><a href="#40484584">parent</a><span>|</span><a href="#40484630">next</a><span>|</span><label class="collapse" for="c-40484677">[-]</label><label class="expand" for="c-40484677">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Problem is readability by maintainers in the future<p>Sounds like a problem that exists in every single programming language to date. And the reason that problem appears is not because of the languages themselves.</div><br/><div id="40485775" class="c"><input type="checkbox" id="c-40485775" checked=""/><div class="controls bullet"><span class="by">giovannibonetti</span><span>|</span><a href="#40484584">root</a><span>|</span><a href="#40484677">parent</a><span>|</span><a href="#40484630">next</a><span>|</span><label class="collapse" for="c-40485775">[-]</label><label class="expand" for="c-40485775">[1 more]</label></div><br/><div class="children"><div class="content">Some languages are designed with a strong focus in simplicity and great compiler errors to overcome that issue as much as possible. Gleam and Elm are some of them.</div><br/></div></div></div></div><div id="40484630" class="c"><input type="checkbox" id="c-40484630" checked=""/><div class="controls bullet"><span class="by">barrell</span><span>|</span><a href="#40484584">parent</a><span>|</span><a href="#40484677">prev</a><span>|</span><a href="#40486713">next</a><span>|</span><label class="collapse" for="c-40484630">[-]</label><label class="expand" for="c-40484630">[1 more]</label></div><br/><div class="children"><div class="content">Even with all those comments, it still ends up being less characters than other languages :D</div><br/></div></div><div id="40486713" class="c"><input type="checkbox" id="c-40486713" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#40484584">parent</a><span>|</span><a href="#40484630">prev</a><span>|</span><a href="#40484540">next</a><span>|</span><label class="collapse" for="c-40486713">[-]</label><label class="expand" for="c-40486713">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Problem is readability by maintainers in the future.<p>Of course. That&#x27;s why some massive projects got abandoned because nobody understood the code they were originally written in. Does anyone even remember Emacs, or AutoCAD, or Datomic? There were companies that went bankrupt because their Lisp codebases became obsolete. Remember Cisco? Or Apple (those idiots tried to build their payment system in Clojure), or Walmart? Or NASA (before they succumbed to the will of evil Elon). Maybe smaller companies like Pitch, or Funding Circle, or CircleCI, or Grammarly? No? Sigh, nobody cares anymore about the history of dead programming languages.</div><br/><div id="40488563" class="c"><input type="checkbox" id="c-40488563" checked=""/><div class="controls bullet"><span class="by">Capricorn2481</span><span>|</span><a href="#40484584">root</a><span>|</span><a href="#40486713">parent</a><span>|</span><a href="#40484540">next</a><span>|</span><label class="collapse" for="c-40488563">[-]</label><label class="expand" for="c-40488563">[2 more]</label></div><br/><div class="children"><div class="content">Do you have anything suggesting these weren&#x27;t just abandoned like most projects are? Is there some interview with the CTO saying &quot;Lisp made this impossible&quot;?<p>We abandoned a project in Python. Is Python unusable?</div><br/><div id="40488579" class="c"><input type="checkbox" id="c-40488579" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#40484584">root</a><span>|</span><a href="#40488563">parent</a><span>|</span><a href="#40484540">next</a><span>|</span><label class="collapse" for="c-40488579">[-]</label><label class="expand" for="c-40488579">[1 more]</label></div><br/><div class="children"><div class="content">I have weird sense of sarcasm, sorry.</div><br/></div></div></div></div></div></div></div></div><div id="40484540" class="c"><input type="checkbox" id="c-40484540" checked=""/><div class="controls bullet"><span class="by">aj7</span><span>|</span><a href="#40484584">prev</a><span>|</span><label class="collapse" for="c-40484540">[-]</label><label class="expand" for="c-40484540">[11 more]</label></div><br/><div class="children"><div class="content">Lisp is far and away the best of the nonreadable programming languages.</div><br/><div id="40484593" class="c"><input type="checkbox" id="c-40484593" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#40484540">parent</a><span>|</span><a href="#40484546">next</a><span>|</span><label class="collapse" for="c-40484593">[-]</label><label class="expand" for="c-40484593">[3 more]</label></div><br/><div class="children"><div class="content">It takes getting used to it, just like every other programming language syntax.<p>If you are comparing it to the ones you are used to, of course you&#x27;ll find it harder.<p>(IMO, I don&#x27;t like the Lisp syntax, but it&#x27;s really not &quot;non-readable&quot;.)</div><br/><div id="40485097" class="c"><input type="checkbox" id="c-40485097" checked=""/><div class="controls bullet"><span class="by">7373737373</span><span>|</span><a href="#40484540">root</a><span>|</span><a href="#40484593">parent</a><span>|</span><a href="#40484546">next</a><span>|</span><label class="collapse" for="c-40485097">[-]</label><label class="expand" for="c-40485097">[2 more]</label></div><br/><div class="children"><div class="content">It is hard to read though. As a beginner or someone unfamiliar with a new codebase you never know whether you are recursing into a special form or not. If you are, the semantics and order in which you ought to read and understand and further recurse into the argument list changes completely.<p>How other programming languages limit the depth of this recursion and the variation&#x2F;complexity of a code block, by splitting the semantics into a limited set of reusable syntactic constructs is very powerful. It is sad that most aren&#x27;t homoiconic though.</div><br/><div id="40486123" class="c"><input type="checkbox" id="c-40486123" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#40484540">root</a><span>|</span><a href="#40485097">parent</a><span>|</span><a href="#40484546">next</a><span>|</span><label class="collapse" for="c-40486123">[-]</label><label class="expand" for="c-40486123">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It is hard to read though.<p>What isn&#x27;t? Java or C# with deep hierarchies of nested classes and tons of boilerplate, extensive use of interfaces or overuse of exception checking?<p>Python with its magic methods and decorators and misindentation?<p>Javascript with the callback hell, inconsistent type coersion and sometimes tricky async code?<p>Ruby with its weird metaprogramming and monkey patching?<p>C with the pointers mental acrobatics and pre-processor macros?<p>Perl with weird default vars like $_ and tons of regexps?<p>Haskell with its monadic structures and heavy use of weird symbols and operators?<p>PHP with the crapload of its historical baggage, global vars and inconsistent, non-standardized function naming?<p>Any programming language can be considered hard to read, quirky, slow, inconsistent, or lacking some feature. Everyone knows there are only three God-given, bullet-proof, guaranteed ways to write robust, fast, consistent, bug-free and scalable software. Three... Humankind has yet to discover those.</div><br/></div></div></div></div></div></div><div id="40484546" class="c"><input type="checkbox" id="c-40484546" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#40484540">parent</a><span>|</span><a href="#40484593">prev</a><span>|</span><a href="#40485927">next</a><span>|</span><label class="collapse" for="c-40484546">[-]</label><label class="expand" for="c-40484546">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s all the way up at the best readable ones instead :)</div><br/></div></div><div id="40485927" class="c"><input type="checkbox" id="c-40485927" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#40484540">parent</a><span>|</span><a href="#40484546">prev</a><span>|</span><a href="#40484847">next</a><span>|</span><label class="collapse" for="c-40485927">[-]</label><label class="expand" for="c-40485927">[5 more]</label></div><br/><div class="children"><div class="content">Pfff... The Lisp syntax is one of the simplest, comprehensible, readable, no-BS sugar things. People with shallow experience often say it looks weird, but with some hands-on experience, you soon appreciate its elegance and power. The consistent, minimalist syntax becomes second nature and reveals its true beauty and functionality.<p>You can easily read Lisp code off your phone screen - it wraps around, but retains the structure. Try that trick with pretty much any non-lispy language - even &quot;the most elegant Python&quot; fails there, face flat.<p>EDN &amp; Transit is far better than JSON - EDN is more flexible and expressive than JSON, making it a superior choice for data serialization. It&#x27;s also more than two times smaller and cleaner, commas are completely optional.<p>Hiccup is better than JSX &amp; HTML - far more easier, cleaner, shorter and nicer to work with.<p>similarly,<p>s-expressions are better that XML &amp; Yaml;<p>CL&#x27;s PLISTs and ALISTs &amp; Clojure maps are better than Dicts&#x2F;Hashes in other languages.<p>Basically, you can leverage the expressiveness and simplicity of Lisp-like syntax to offer structured, readable, and powerful data representations. Add to that the ability to evaluate any given form on the fly through a connected REPL, basically &quot;trying things while you read them,&quot; and that changes everything you thought you knew about the readability of code.<p>Those who call Lisp &quot;non-readable&quot; I suppose, in fact, never tried to actually read it. Of course, if you never learn a language, it would remain incomprehensible.</div><br/><div id="40487364" class="c"><input type="checkbox" id="c-40487364" checked=""/><div class="controls bullet"><span class="by">vsuperpower2020</span><span>|</span><a href="#40484540">root</a><span>|</span><a href="#40485927">parent</a><span>|</span><a href="#40484847">next</a><span>|</span><label class="collapse" for="c-40487364">[-]</label><label class="expand" for="c-40487364">[4 more]</label></div><br/><div class="children"><div class="content">&quot;Pfff...&quot;? You&#x27;re getting a little too defensive over someone not liking your language. You&#x27;re just asserting that the language is easy to read and saying that anyone who disagrees just hasn&#x27;t read it. This is some sad fanboy behavior that I don&#x27;t like to see.</div><br/><div id="40487568" class="c"><input type="checkbox" id="c-40487568" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#40484540">root</a><span>|</span><a href="#40487364">parent</a><span>|</span><a href="#40484847">next</a><span>|</span><label class="collapse" for="c-40487568">[-]</label><label class="expand" for="c-40487568">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve got your attention though, haven&#x27;t I? :)<p>Defensive? No. I don&#x27;t think Lisp needs defending.<p>Lisp is an idea. Good ideas need no defending. The invention of Lisp is one of the greatest events in the recent history of symbolic communication. It can be put in the same category as cave drawings, cuneiform, Egyptian hieroglyphs, and mathematical notation in the sense that they all represent systems of symbolic communication.<p>My &quot;Pfff...&quot; really comes from not understanding why people would say things like &quot;Lisp is hard to read&quot; when, in truth, it&#x27;s probably the best tool we humans have for its designated purpose. Lisp emphasizes simplicity and uniformity, which can enhance readability and ease of understanding programs. With a big caveat, though, Lisp&#x27;s readability improves with practice and familiarity. Many people find Lisp structures to be clear and expressive for symbolic manipulation and functional programming tasks. Okay, I mean I get it. Let&#x27;s say I can, for example, look inside &quot;Principia Mathematica&quot; and completely find it unreadable. Yeah, I would. But wouldn&#x27;t it be weird of me to go to a forum for mathematics and tell them that their math is unreadable? They&#x27;d probably decide that I&#x27;m trolling.</div><br/><div id="40487753" class="c"><input type="checkbox" id="c-40487753" checked=""/><div class="controls bullet"><span class="by">vsuperpower2020</span><span>|</span><a href="#40484540">root</a><span>|</span><a href="#40487568">parent</a><span>|</span><a href="#40484847">next</a><span>|</span><label class="collapse" for="c-40487753">[-]</label><label class="expand" for="c-40487753">[2 more]</label></div><br/><div class="children"><div class="content">You got my attention that one time, sure. That&#x27;s all you get.</div><br/><div id="40487851" class="c"><input type="checkbox" id="c-40487851" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#40484540">root</a><span>|</span><a href="#40487753">parent</a><span>|</span><a href="#40484847">next</a><span>|</span><label class="collapse" for="c-40487851">[-]</label><label class="expand" for="c-40487851">[1 more]</label></div><br/><div class="children"><div class="content">Awwww. I thought we were becoming friends. I used a smiley face and shit... :[</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>