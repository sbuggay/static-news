<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705222856642" as="style"/><link rel="stylesheet" href="styles.css?v=1705222856642"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dl.acm.org/doi/10.1145/3593856.3595909">Towards Modern Development of Cloud Applications (2023)</a> <span class="domain">(<a href="https://dl.acm.org">dl.acm.org</a>)</span></div><div class="subtext"><span>signa11</span> | <span>15 comments</span></div><br/><div><div id="38988440" class="c"><input type="checkbox" id="c-38988440" checked=""/><div class="controls bullet"><span class="by">saulrh</span><span>|</span><a href="#38988498">next</a><span>|</span><label class="collapse" for="c-38988440">[-]</label><label class="expand" for="c-38988440">[1 more]</label></div><br/><div class="children"><div class="content">This looks like it parallels the shift from MapReduce&#x27;s paradigm of one binary per execution graph node to FlumeJava (and Apache Beam&#x27;s) monolithic binary for all worker nodes that reconfigures itself as necessary for each stage. My experience is that Flume&#x2F;Beam is a lot nicer in almost all ways, so I&#x27;m not surprised that the same thing works for services too.</div><br/></div></div><div id="38988498" class="c"><input type="checkbox" id="c-38988498" checked=""/><div class="controls bullet"><span class="by">erulabs</span><span>|</span><a href="#38988440">prev</a><span>|</span><a href="#38988529">next</a><span>|</span><label class="collapse" for="c-38988498">[-]</label><label class="expand" for="c-38988498">[2 more]</label></div><br/><div class="children"><div class="content">Interesting! This has been my recommended pattern for a for years now: a monorepo with multiple entrypoints. Worker and api and emailer etc etc services are running independently, but it’s one codebase running with different options. All the developer benefits of a monolith and all the devops benefits of sane and isolated deployments.</div><br/><div id="38988545" class="c"><input type="checkbox" id="c-38988545" checked=""/><div class="controls bullet"><span class="by">rezonant</span><span>|</span><a href="#38988498">parent</a><span>|</span><a href="#38988529">next</a><span>|</span><label class="collapse" for="c-38988545">[-]</label><label class="expand" for="c-38988545">[1 more]</label></div><br/><div class="children"><div class="content">Also often allows you to simplify the development experience dramatically-- instead of spinning up twenty processes and running a complex live rebuild process or manually rebuilding and restarting certain parts, you just need to start the whole thing, because in development it all runs in a single process (or, at least less processes than you do when it is run in production)</div><br/></div></div></div></div><div id="38988529" class="c"><input type="checkbox" id="c-38988529" checked=""/><div class="controls bullet"><span class="by">rezonant</span><span>|</span><a href="#38988498">prev</a><span>|</span><a href="#38988599">next</a><span>|</span><label class="collapse" for="c-38988529">[-]</label><label class="expand" for="c-38988529">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been experimenting with this sort of thing for awhile, but without automation to determine the deployment topology (nice!). Lacking a better name, I&#x27;ve been calling it a monolithic micro service architecture. Obviously nothing here prevents you from creating a distributed monolith, but it can allow a smaller team to enjoy better horizontal scaling without as much cost, while still retaining ease of forward development.</div><br/></div></div><div id="38988599" class="c"><input type="checkbox" id="c-38988599" checked=""/><div class="controls bullet"><span class="by">progbits</span><span>|</span><a href="#38988529">prev</a><span>|</span><a href="#38988479">next</a><span>|</span><label class="collapse" for="c-38988599">[-]</label><label class="expand" for="c-38988599">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;serviceweaver.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;serviceweaver.dev&#x2F;</a><p>Because it is a bit buried in the paper, this is the prototype implementation they talk about.</div><br/></div></div><div id="38988479" class="c"><input type="checkbox" id="c-38988479" checked=""/><div class="controls bullet"><span class="by">sgt101</span><span>|</span><a href="#38988599">prev</a><span>|</span><a href="#38988552">next</a><span>|</span><label class="collapse" for="c-38988479">[-]</label><label class="expand" for="c-38988479">[1 more]</label></div><br/><div class="children"><div class="content">Bold claims...<p>Performance is evaluated against a single example implementation (section 6.1) and 9x improvement was achieved when co-locating into a single process. To be fair this seems a reasonable thing to do if you can get the application to be efficient enough to allow it - but there may be very good reasons not to do it in many applications.</div><br/></div></div><div id="38988552" class="c"><input type="checkbox" id="c-38988552" checked=""/><div class="controls bullet"><span class="by">tlarkworthy</span><span>|</span><a href="#38988479">prev</a><span>|</span><a href="#38988429">next</a><span>|</span><label class="collapse" for="c-38988552">[-]</label><label class="expand" for="c-38988552">[2 more]</label></div><br/><div class="children"><div class="content">I am a big proponent of the fat lambda paradigm, but it falls short in a few areas and then you need to split
- security boundaries (e.g. isolating user code)
- dependency overheads</div><br/></div></div><div id="38988429" class="c"><input type="checkbox" id="c-38988429" checked=""/><div class="controls bullet"><span class="by">iamgopal</span><span>|</span><a href="#38988552">prev</a><span>|</span><a href="#38988450">next</a><span>|</span><label class="collapse" for="c-38988429">[-]</label><label class="expand" for="c-38988429">[2 more]</label></div><br/><div class="children"><div class="content">Isn’t this prevailing wisdom among HN crowd ?</div><br/><div id="38988463" class="c"><input type="checkbox" id="c-38988463" checked=""/><div class="controls bullet"><span class="by">saulrh</span><span>|</span><a href="#38988429">parent</a><span>|</span><a href="#38988450">next</a><span>|</span><label class="collapse" for="c-38988463">[-]</label><label class="expand" for="c-38988463">[1 more]</label></div><br/><div class="children"><div class="content">I think that this might actually be something new - you have the same topology as a microservice architecture, but rather than actually programming and deploying one binary per microservice, you build a single binary with all of the functionality and it gets deployed as a fleet of microservices, running a different subset of all of that functionality depending on what it&#x27;s deployed as. Which means you have only one build and one deploy step and atomic deploys, like a monolith, but you also get to scale each component independently and isolate data like with microservices. A really nice looking middle ground.</div><br/></div></div></div></div><div id="38988450" class="c"><input type="checkbox" id="c-38988450" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#38988429">prev</a><span>|</span><a href="#38988504">next</a><span>|</span><label class="collapse" for="c-38988450">[-]</label><label class="expand" for="c-38988450">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like DCOM?</div><br/></div></div><div id="38988504" class="c"><input type="checkbox" id="c-38988504" checked=""/><div class="controls bullet"><span class="by">m0llusk</span><span>|</span><a href="#38988450">prev</a><span>|</span><a href="#38988487">next</a><span>|</span><label class="collapse" for="c-38988504">[-]</label><label class="expand" for="c-38988504">[1 more]</label></div><br/><div class="children"><div class="content">So shipping two applications that use the same authentication service is a mistake?</div><br/></div></div><div id="38988487" class="c"><input type="checkbox" id="c-38988487" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#38988504">prev</a><span>|</span><label class="collapse" for="c-38988487">[-]</label><label class="expand" for="c-38988487">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used this paradigm for a long time. What&#x27;s new here ?<p>Basically your code has no concept of &quot;network boundary&quot;, there&#x27;s only package import each other, there&#x27;s no &quot;microservice&quot;.<p>But when deploying, i can choose which package to be deployed as a service.</div><br/><div id="38988508" class="c"><input type="checkbox" id="c-38988508" checked=""/><div class="controls bullet"><span class="by">kitd</span><span>|</span><a href="#38988487">parent</a><span>|</span><label class="collapse" for="c-38988508">[-]</label><label class="expand" for="c-38988508">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s new is that you don&#x27;t choose, the runtime does, generating the cross-network interface as needed.</div><br/></div></div></div></div></div></div></div></div></div></body></html>