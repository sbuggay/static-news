<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692608464110" as="style"/><link rel="stylesheet" href="styles.css?v=1692608464110"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://itsbehnam.com/It-s-Lambdas-All-the-Way-Down-eb33012f54bb4708af001e0214910698">It’s lambdas all the way down</a> <span class="domain">(<a href="https://itsbehnam.com">itsbehnam.com</a>)</span></div><div class="subtext"><span>behnamoh</span> | <span>58 comments</span></div><br/><div><div id="37206974" class="c"><input type="checkbox" id="c-37206974" checked=""/><div class="controls bullet"><span class="by">lapinot</span><span>|</span><a href="#37204375">next</a><span>|</span><label class="collapse" for="c-37206974">[-]</label><label class="expand" for="c-37206974">[1 more]</label></div><br/><div class="children"><div class="content">Church-encodings are cute but closures take space, more specifically an unbounded amount of it (for the code, unless you defunctionalize it)! Hence it is much more practical to have a primitive notion of <i>inert</i> data that can be inspected and which has a fixed or at least predictable size. Although there are also other more efficient lambda-encodings like Scott-encoding &#x2F; Mendler-style algebras.<p>See <a href="https:&#x2F;&#x2F;firsov.ee&#x2F;efficient-lambda&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;firsov.ee&#x2F;efficient-lambda&#x2F;</a>, it&#x27;s a very cool paper. But it also shows it&#x27;s very tricky to give a type to these encodings. In the end you&#x27;re almost always better off building &quot;real&quot; datatypes with records and ADTs unless your only goal is to have a minimal theory.</div><br/></div></div><div id="37204375" class="c"><input type="checkbox" id="c-37204375" checked=""/><div class="controls bullet"><span class="by">overgard</span><span>|</span><a href="#37206974">prev</a><span>|</span><a href="#37202754">next</a><span>|</span><label class="collapse" for="c-37204375">[-]</label><label class="expand" for="c-37204375">[11 more]</label></div><br/><div class="children"><div class="content">I think there are really two types of programming languages, &quot;idea&quot; languages and &quot;practical&quot; languages.<p>&quot;Idea&quot; languages take a concept and try to build almost everything out of it. So like, lisp with lambdas, or smalltalk with message passing, or prolog with logic statements, etc.<p>Then there are &quot;practical&quot; languages, which don&#x27;t necessarily have a &quot;core&quot; idea; more likely they&#x27;re defined by the domains they&#x27;re useful in and have a grab bag of ideas. So like C++, typescript, etc.<p>I think &quot;idea&quot; languages have their appeal because they seem elegant, and as coders, we often try to take a novel idea as far as we can. Usually, that ends up being too far. Like, if you&#x27;re building a React app, and you go overboard, maybe everything becomes a reactive component even when expressing things in that way can be awkward and your component isn&#x27;t really a ui &quot;component&quot;. Or if you&#x27;re writing in a functional language, all the sudden loops become recursion and you&#x27;re praying that it has tail call optimization. If you&#x27;re writing java, maybe you see dependency injection everywhere. I think we just have this urge to see how many nails our shiny hammer can hit, even to the point of diminishing returns.<p>Anyway, I guess all I&#x27;m saying is that even if you can express something as turtles all the way down, you might not necessarily want to build your house out of turtles.</div><br/><div id="37204940" class="c"><input type="checkbox" id="c-37204940" checked=""/><div class="controls bullet"><span class="by">rr808</span><span>|</span><a href="#37204375">parent</a><span>|</span><a href="#37206622">next</a><span>|</span><label class="collapse" for="c-37204940">[-]</label><label class="expand" for="c-37204940">[8 more]</label></div><br/><div class="children"><div class="content">The Bjarne Stroustrup division is very similar: &quot;There are only two kinds of languages: the ones people complain about and the ones nobody uses&quot;</div><br/><div id="37205151" class="c"><input type="checkbox" id="c-37205151" checked=""/><div class="controls bullet"><span class="by">agalunar</span><span>|</span><a href="#37204375">root</a><span>|</span><a href="#37204940">parent</a><span>|</span><a href="#37205918">next</a><span>|</span><label class="collapse" for="c-37205151">[-]</label><label class="expand" for="c-37205151">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never really liked that quote. It&#x27;s just a way of saying that nothing&#x27;s perfect, and of course nothing is perfect, but that doesn&#x27;t mean you shouldn&#x27;t try to improve them. The quote has always struck me as defensive in a way that stops discussion. It&#x27;s okay (in fact, more than okay) to say that a complaint is founded on an unsound premise or that a proposed change is a bad idea, but calling other languages useless or unwanted (or implying something to that effect) in response to criticisms of C++ is a bit of deflection, as if saying &quot;well, at least people are productive in it&quot;, and I don&#x27;t think particularly constructive. I think you can start a constructive comment this way, though: &quot;despite its problems, people are still productive in C++ and I think <i>x, y</i> and <i>z</i> are reasons why, so <i>x, y,</i> and <i>z</i> ought to be kept, &amp;c&quot;. And in some other context, I think this observation is meaningful: all the languages that are commonly used are complained about, so a complaint about C++ does not <i>necessarily</i> imply that it&#x27;s worse than any other commonly used language.</div><br/><div id="37206103" class="c"><input type="checkbox" id="c-37206103" checked=""/><div class="controls bullet"><span class="by">agalunar</span><span>|</span><a href="#37204375">root</a><span>|</span><a href="#37205151">parent</a><span>|</span><a href="#37205918">next</a><span>|</span><label class="collapse" for="c-37206103">[-]</label><label class="expand" for="c-37206103">[1 more]</label></div><br/><div class="children"><div class="content">ah, to be clear, I&#x27;m not saying I disliked the parent comment by rr808! I was just tangentially ruminating on the quotation.</div><br/></div></div></div></div><div id="37205918" class="c"><input type="checkbox" id="c-37205918" checked=""/><div class="controls bullet"><span class="by">mlazos</span><span>|</span><a href="#37204375">root</a><span>|</span><a href="#37204940">parent</a><span>|</span><a href="#37205151">prev</a><span>|</span><a href="#37206271">next</a><span>|</span><label class="collapse" for="c-37205918">[-]</label><label class="expand" for="c-37205918">[1 more]</label></div><br/><div class="children"><div class="content">I don’t remember where I saw this - but ofc there’s haskell, which is both!</div><br/></div></div><div id="37206271" class="c"><input type="checkbox" id="c-37206271" checked=""/><div class="controls bullet"><span class="by">pulse7</span><span>|</span><a href="#37204375">root</a><span>|</span><a href="#37204940">parent</a><span>|</span><a href="#37205918">prev</a><span>|</span><a href="#37206622">next</a><span>|</span><label class="collapse" for="c-37206271">[-]</label><label class="expand" for="c-37206271">[4 more]</label></div><br/><div class="children"><div class="content">So Java must be heavily used...</div><br/><div id="37206563" class="c"><input type="checkbox" id="c-37206563" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#37204375">root</a><span>|</span><a href="#37206271">parent</a><span>|</span><a href="#37206305">next</a><span>|</span><label class="collapse" for="c-37206563">[-]</label><label class="expand" for="c-37206563">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;TIOBE_index#&#x2F;media&#x2F;File:Tiobeindex.png" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;TIOBE_index#&#x2F;media&#x2F;File:Tiobei...</a></div><br/></div></div><div id="37206305" class="c"><input type="checkbox" id="c-37206305" checked=""/><div class="controls bullet"><span class="by">pluijzer</span><span>|</span><a href="#37204375">root</a><span>|</span><a href="#37206271">parent</a><span>|</span><a href="#37206563">prev</a><span>|</span><a href="#37206463">next</a><span>|</span><label class="collapse" for="c-37206305">[-]</label><label class="expand" for="c-37206305">[1 more]</label></div><br/><div class="children"><div class="content">yes it is. Outside of the startup culture it is everywhere.</div><br/></div></div><div id="37206463" class="c"><input type="checkbox" id="c-37206463" checked=""/><div class="controls bullet"><span class="by">gherkinnn</span><span>|</span><a href="#37204375">root</a><span>|</span><a href="#37206271">parent</a><span>|</span><a href="#37206305">prev</a><span>|</span><a href="#37206622">next</a><span>|</span><label class="collapse" for="c-37206463">[-]</label><label class="expand" for="c-37206463">[1 more]</label></div><br/><div class="children"><div class="content">Of course it is. I pass on a lot of jobs for just that reason.</div><br/></div></div></div></div></div></div><div id="37206622" class="c"><input type="checkbox" id="c-37206622" checked=""/><div class="controls bullet"><span class="by">k__</span><span>|</span><a href="#37204375">parent</a><span>|</span><a href="#37204940">prev</a><span>|</span><a href="#37206597">next</a><span>|</span><label class="collapse" for="c-37206622">[-]</label><label class="expand" for="c-37206622">[1 more]</label></div><br/><div class="children"><div class="content">React got pretty far with it&#x27;s turtles.</div><br/></div></div><div id="37206597" class="c"><input type="checkbox" id="c-37206597" checked=""/><div class="controls bullet"><span class="by">nikanj</span><span>|</span><a href="#37204375">parent</a><span>|</span><a href="#37206622">prev</a><span>|</span><a href="#37202754">next</a><span>|</span><label class="collapse" for="c-37206597">[-]</label><label class="expand" for="c-37206597">[1 more]</label></div><br/><div class="children"><div class="content">There was a decent xkcd comic about this in 2007 <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;224&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;xkcd.com&#x2F;224&#x2F;</a><p>Essentially all of our biggest software systems are made with php, c++, java etc. Elegance and beauty somehow always lose to the hack-together-itude of other languages</div><br/></div></div></div></div><div id="37202754" class="c"><input type="checkbox" id="c-37202754" checked=""/><div class="controls bullet"><span class="by">Hirrolot</span><span>|</span><a href="#37204375">prev</a><span>|</span><a href="#37203705">next</a><span>|</span><label class="collapse" for="c-37202754">[-]</label><label class="expand" for="c-37202754">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Surprisingly, these particles were found decades ago by Alonzo Church, the inventor of Lambda calculus long before electronic computers even existed!!<p>Lambda calculus is not the simplest computational device based on functions; with SKI calculus, you only need to define two combinators (S and K) to perform any conceivable computation. Going further, you can define the full SKI calculus with only a single combinator called Iota, so in fact, you only need one function to perform any computation. Yes, Turing tarpits exist, why that should be a revelation? Practical programming languages (both functional and imperative and object-oriented) tend to find a compromise between a minimal core and ergonomics, otherwise the result will be disastrous.</div><br/><div id="37205819" class="c"><input type="checkbox" id="c-37205819" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#37202754">parent</a><span>|</span><a href="#37206123">next</a><span>|</span><label class="collapse" for="c-37205819">[-]</label><label class="expand" for="c-37205819">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Surprisingly, these particles were found decades ago by Alonzo Church, the inventor of Lambda calculus long before electronic computers even existed!!<p>John McCarthy has introduced his lambda notation in October 1958, being inspired by the work of Alonzo Church, but it had very little to do with Lambda calculus.<p>The essential innovation brought at that time by John McCarthy to programming languages was that, unlike in earlier programming languages like Fortran, where a function definition was a separate section of a program source file, where an identifier had to be bound to a function definition, a McCarthy function definition behaves just as a constant value, very similarly to a character string constant, integer constant or floating-point constant, so it can appear in any place where a constant can appear, it can be assigned to an identifier, but it can also be used directly as an argument in the invocation of another function.<p>Once the new semantics of a function definition was established, the syntactic notation for it was a minor detail. A possible notation would have been to enclose any function definition in a special pair of parentheses, like a character string constant that is enclosed in quotation marks. Because this was not feasible due to the limited character set that was available, the chosen syntax was that of a LISP special form, which needs a keyword, for which the choice was &quot;lambda&quot;.<p>To distinguish in a function definition the parameters used for function invocation, Alonzo Church had enclosed them in a pair of special parentheses, where the leading parenthesis was a small Greek lambda character and the trailing parenthesis was a raised middle dot.<p>This provided the inspiration for the &quot;lambda&quot; keyword. Perhaps McCarthy was also inspired by Church&#x27;s work to change the handling of function definitions to be like that of any other values, but that is the maximum extent of the relationship between Lambda calculus and LISP.<p>Nevertheless, the LISP &quot;lambda&quot; notation played an important role in attracting attention upon the work of Alonzo Church, so in the following decade there was much research in functional languages that was much more strongly influenced by Lambda calculus than LISP was.</div><br/></div></div><div id="37206123" class="c"><input type="checkbox" id="c-37206123" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#37202754">parent</a><span>|</span><a href="#37205819">prev</a><span>|</span><a href="#37204189">next</a><span>|</span><label class="collapse" for="c-37206123">[-]</label><label class="expand" for="c-37206123">[1 more]</label></div><br/><div class="children"><div class="content">&gt; with only a single combinator called Iota<p>iota is just the pair of S and K: λp.p S K = λp.p (λxλyλz. x z (y z)) (λxλy. x)<p>The simplest possible single point combinator basis (in terms of size in bits) is this slight variant of S:<p><pre><code>    A = λxλyλz. x z (y (λ_.z))
</code></pre>
Writing S and K in terms of A is an interesting challenge, requiring more than 10 As each...</div><br/></div></div><div id="37204189" class="c"><input type="checkbox" id="c-37204189" checked=""/><div class="controls bullet"><span class="by">jekude</span><span>|</span><a href="#37202754">parent</a><span>|</span><a href="#37206123">prev</a><span>|</span><a href="#37206015">next</a><span>|</span><label class="collapse" for="c-37204189">[-]</label><label class="expand" for="c-37204189">[2 more]</label></div><br/><div class="children"><div class="content">Came here to recommend that the author check out Combinatory Logic (SKI, Iota, Jot, etc). Although not practical, it is pretty incredible how simple&#x2F;minimal systems can serve as the axiomatic foundation for essentially all of math&#x2F;logic.</div><br/><div id="37204929" class="c"><input type="checkbox" id="c-37204929" checked=""/><div class="controls bullet"><span class="by">msla</span><span>|</span><a href="#37202754">root</a><span>|</span><a href="#37204189">parent</a><span>|</span><a href="#37206015">next</a><span>|</span><label class="collapse" for="c-37204929">[-]</label><label class="expand" for="c-37204929">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also the Unlambda programming language:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Unlambda" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Unlambda</a><p><a href="http:&#x2F;&#x2F;www.madore.org&#x2F;~david&#x2F;programs&#x2F;unlambda&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;www.madore.org&#x2F;~david&#x2F;programs&#x2F;unlambda&#x2F;</a></div><br/></div></div></div></div><div id="37206015" class="c"><input type="checkbox" id="c-37206015" checked=""/><div class="controls bullet"><span class="by">slaymaker1907</span><span>|</span><a href="#37202754">parent</a><span>|</span><a href="#37204189">prev</a><span>|</span><a href="#37202772">next</a><span>|</span><label class="collapse" for="c-37206015">[-]</label><label class="expand" for="c-37206015">[1 more]</label></div><br/><div class="children"><div class="content">Lambda calculus is somewhat interesting in my opinion because in addition to being really simple, it’s actually a pretty usable language. You could use it as a basic template language without much modification. The same cannot be said for Turing machines or SKI calculus (the latter in particular since it has no natural IO mechanism).</div><br/></div></div><div id="37202772" class="c"><input type="checkbox" id="c-37202772" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#37202754">parent</a><span>|</span><a href="#37206015">prev</a><span>|</span><a href="#37203705">next</a><span>|</span><label class="collapse" for="c-37202772">[-]</label><label class="expand" for="c-37202772">[3 more]</label></div><br/><div class="children"><div class="content">this is true, but lambda calculus is somewhat usable by a human. how many people have written runnin code in combinators (I have, sadly)</div><br/><div id="37203082" class="c"><input type="checkbox" id="c-37203082" checked=""/><div class="controls bullet"><span class="by">alexisread</span><span>|</span><a href="#37202754">root</a><span>|</span><a href="#37202772">parent</a><span>|</span><a href="#37202875">next</a><span>|</span><label class="collapse" for="c-37203082">[-]</label><label class="expand" for="c-37203082">[1 more]</label></div><br/><div class="children"><div class="content">Well, anyone who has written in Forth kinda has, though it&#x27;s interesting that few projects take it further (Factor).<p>Joy has a great set of pages explaing it&#x27;s SKI basis
<a href="https:&#x2F;&#x2F;hypercubed.github.io&#x2F;joy&#x2F;html&#x2F;forth-joy.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;hypercubed.github.io&#x2F;joy&#x2F;html&#x2F;forth-joy.html</a></div><br/></div></div><div id="37202875" class="c"><input type="checkbox" id="c-37202875" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#37202754">root</a><span>|</span><a href="#37202772">parent</a><span>|</span><a href="#37203082">prev</a><span>|</span><a href="#37203705">next</a><span>|</span><label class="collapse" for="c-37202875">[-]</label><label class="expand" for="c-37202875">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.ioccc.org&#x2F;years-spoiler.html#1998_fanf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.ioccc.org&#x2F;years-spoiler.html#1998_fanf</a><p>One of several IOCCC winners based on lazy evaluation.</div><br/></div></div></div></div></div></div><div id="37203705" class="c"><input type="checkbox" id="c-37203705" checked=""/><div class="controls bullet"><span class="by">twoodfin</span><span>|</span><a href="#37202754">prev</a><span>|</span><a href="#37203583">next</a><span>|</span><label class="collapse" for="c-37203705">[-]</label><label class="expand" for="c-37203705">[1 more]</label></div><br/><div class="children"><div class="content">I distinctly remember the moment 25 years ago, at around 2:00 am in bed in my dorm, the semester I was taking SICP:<p>“cons doesn’t need to be a special form! Closures are general purpose data structures!”<p>I raced (all of 6 feet) to my… hmm at that point must have been the old Gateway 2000 with an AMD K5 brain transplant… and spun up the Edwin environment to confirm my hypothesis.<p>Up there with getting married and having kids as the great life events of all time.</div><br/></div></div><div id="37203583" class="c"><input type="checkbox" id="c-37203583" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#37203705">prev</a><span>|</span><a href="#37203195">next</a><span>|</span><label class="collapse" for="c-37203583">[-]</label><label class="expand" for="c-37203583">[2 more]</label></div><br/><div class="children"><div class="content">&gt; He made an error in the code: evcon. and evlis. should come before eval..<p>A note: That&#x27;s not an error. The code works just fine in Common Lisp because CL doesn&#x27;t care about the order of definitions so long as the definitions are made prior to execution. Given that both `evcon.` and `evlis.` also call `eval.`, there is no way to create a canonical linear ordering of the three functions aside from aesthetic preference. You will get similar warnings if you put them before or put them after `eval.`.</div><br/><div id="37206756" class="c"><input type="checkbox" id="c-37206756" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#37203583">parent</a><span>|</span><a href="#37203195">next</a><span>|</span><label class="collapse" for="c-37206756">[-]</label><label class="expand" for="c-37206756">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The code works just fine in Common Lisp<p>It would work fine in Lisp in general, since Lisp is typically late bound and can call global functions via the symbols. Thus in a function writing a call to an undefined function is not an error. The function only needs to exist at runtime, even then in many debuggers it could added and the computation can be resumed.</div><br/></div></div></div></div><div id="37203195" class="c"><input type="checkbox" id="c-37203195" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#37203583">prev</a><span>|</span><a href="#37205105">next</a><span>|</span><label class="collapse" for="c-37203195">[-]</label><label class="expand" for="c-37203195">[1 more]</label></div><br/><div class="children"><div class="content">This article uses the factorial function on Church numerals as motivation for discussing recursion and the Y-combinator.
Yet Church numerals have enough recursion &quot;built-in&quot; to compute factorials directly:<p><pre><code>    fac = λn.λf. n F (λx.f) (λx.x) where F = (λc.λn.n(c(λf.λx.n f(f x))))
</code></pre>
For example, fac 3 evaluates as (writing Church numerals simply as 1,2...)<p><pre><code>    λf. F (F (F (λx.f))) 1
    = λf. 1 (F (F (λx.f))  2)
    = λf. 1 (2 (F (λx.f)   3))
    = λf. 1 (2 (3 ((λx.f)  4)))
    = λf. 1 (2 (3 f))
    = 6</code></pre></div><br/></div></div><div id="37205105" class="c"><input type="checkbox" id="c-37205105" checked=""/><div class="controls bullet"><span class="by">mkw5053</span><span>|</span><a href="#37203195">prev</a><span>|</span><a href="#37202978">next</a><span>|</span><label class="collapse" for="c-37205105">[-]</label><label class="expand" for="c-37205105">[1 more]</label></div><br/><div class="children"><div class="content">If anyone is looking for a book on lambda calculus, I really enjoyed An Introduction to Functional Programming Through Lambda Calculus by Greg Michaelson [1]<p>[1] <a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Introduction-Functional-Programming-Calculus-Mathematics&#x2F;dp&#x2F;0486478831" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.amazon.com&#x2F;Introduction-Functional-Programming-C...</a></div><br/></div></div><div id="37202978" class="c"><input type="checkbox" id="c-37202978" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#37205105">prev</a><span>|</span><a href="#37203169">next</a><span>|</span><label class="collapse" for="c-37202978">[-]</label><label class="expand" for="c-37202978">[3 more]</label></div><br/><div class="children"><div class="content">Thanks everyone for showing interest in my article. the traffic quickly exceeded my cloudflare account limits, resulting in it being inaccessible for a while. I&#x27;ve upgraded my plan now and the link works.</div><br/><div id="37204781" class="c"><input type="checkbox" id="c-37204781" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#37202978">parent</a><span>|</span><a href="#37203169">next</a><span>|</span><label class="collapse" for="c-37204781">[-]</label><label class="expand" for="c-37204781">[2 more]</label></div><br/><div class="children"><div class="content">Out of curiosity, what was the limit you hit?</div><br/><div id="37204934" class="c"><input type="checkbox" id="c-37204934" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#37202978">root</a><span>|</span><a href="#37204781">parent</a><span>|</span><a href="#37203169">next</a><span>|</span><label class="collapse" for="c-37204934">[-]</label><label class="expand" for="c-37204934">[1 more]</label></div><br/><div class="children"><div class="content">I think it was around 10k requests.</div><br/></div></div></div></div></div></div><div id="37203169" class="c"><input type="checkbox" id="c-37203169" checked=""/><div class="controls bullet"><span class="by">benburton</span><span>|</span><a href="#37202978">prev</a><span>|</span><a href="#37202699">next</a><span>|</span><label class="collapse" for="c-37203169">[-]</label><label class="expand" for="c-37203169">[2 more]</label></div><br/><div class="children"><div class="content">Unrelated to the content of this post... this looks to be hosted on Notion. Is that a reasonable option for a personal blog? I do a lot of writing in Notion for work and I would love to transition into something more public. I don&#x27;t really want to mess around with Jekyll, Medium, or Substack. Public Notion feels sort of compelling.</div><br/><div id="37203313" class="c"><input type="checkbox" id="c-37203313" checked=""/><div class="controls bullet"><span class="by">rcarr</span><span>|</span><a href="#37203169">parent</a><span>|</span><a href="#37202699">next</a><span>|</span><label class="collapse" for="c-37203313">[-]</label><label class="expand" for="c-37203313">[1 more]</label></div><br/><div class="children"><div class="content">Might want to check out Obsidian and Obsidian Publish</div><br/></div></div></div></div><div id="37202699" class="c"><input type="checkbox" id="c-37202699" checked=""/><div class="controls bullet"><span class="by">ignoramous</span><span>|</span><a href="#37203169">prev</a><span>|</span><a href="#37204274">next</a><span>|</span><label class="collapse" for="c-37202699">[-]</label><label class="expand" for="c-37202699">[4 more]</label></div><br/><div class="children"><div class="content">I mean, if you look at all these SSA compilers for imperative languages, then it is indeed functional programming all the way down.</div><br/><div id="37202825" class="c"><input type="checkbox" id="c-37202825" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#37202699">parent</a><span>|</span><a href="#37204274">next</a><span>|</span><label class="collapse" for="c-37202825">[-]</label><label class="expand" for="c-37202825">[3 more]</label></div><br/><div class="children"><div class="content">I wonder if there is a similar factoring that would factor out mutability. a log I guess.</div><br/><div id="37203002" class="c"><input type="checkbox" id="c-37203002" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#37202699">root</a><span>|</span><a href="#37202825">parent</a><span>|</span><a href="#37204274">next</a><span>|</span><label class="collapse" for="c-37203002">[-]</label><label class="expand" for="c-37203002">[2 more]</label></div><br/><div class="children"><div class="content">That is what SSA is: single static assignment.</div><br/><div id="37203098" class="c"><input type="checkbox" id="c-37203098" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#37202699">root</a><span>|</span><a href="#37203002">parent</a><span>|</span><a href="#37204274">next</a><span>|</span><label class="collapse" for="c-37203098">[-]</label><label class="expand" for="c-37203098">[1 more]</label></div><br/><div class="children"><div class="content">for locally scoped variables, not for referents</div><br/></div></div></div></div></div></div></div></div><div id="37204274" class="c"><input type="checkbox" id="c-37204274" checked=""/><div class="controls bullet"><span class="by">charred_patina</span><span>|</span><a href="#37202699">prev</a><span>|</span><a href="#37205139">next</a><span>|</span><label class="collapse" for="c-37204274">[-]</label><label class="expand" for="c-37204274">[2 more]</label></div><br/><div class="children"><div class="content">Every time I read a post about the sublime nature of Lisp I end up feeling stupid. I read SICP and didn&#x27;t really &quot;get&quot; it. I felt like it was just another language, but the structure of the language makes it a bit more obvious how scoping and closures work-- as well as being easier to compose functions of functions. Forth gave me a little bit more of an &quot;aha&quot; moment, but still no enlightenment.<p>I have never used either language to actually build anything useful, so maybe that&#x27;s part of it.</div><br/><div id="37205155" class="c"><input type="checkbox" id="c-37205155" checked=""/><div class="controls bullet"><span class="by">Exuma</span><span>|</span><a href="#37204274">parent</a><span>|</span><a href="#37205139">next</a><span>|</span><label class="collapse" for="c-37205155">[-]</label><label class="expand" for="c-37205155">[1 more]</label></div><br/><div class="children"><div class="content">Try this. I didn’t really see how cool lisp was until I followed this<p><a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;quick&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;quick&#x2F;</a><p>It’s one thing to read it. It’s another to try it. Download the racket app and just do these fun 10 steps and that’s it.</div><br/></div></div></div></div><div id="37205139" class="c"><input type="checkbox" id="c-37205139" checked=""/><div class="controls bullet"><span class="by">Exuma</span><span>|</span><a href="#37204274">prev</a><span>|</span><a href="#37203142">next</a><span>|</span><label class="collapse" for="c-37205139">[-]</label><label class="expand" for="c-37205139">[1 more]</label></div><br/><div class="children"><div class="content">One of my all time favorites: <a href="https:&#x2F;&#x2F;tomstu.art&#x2F;programming-with-nothing" rel="nofollow noreferrer">https:&#x2F;&#x2F;tomstu.art&#x2F;programming-with-nothing</a></div><br/></div></div><div id="37203142" class="c"><input type="checkbox" id="c-37203142" checked=""/><div class="controls bullet"><span class="by">grumblingdev</span><span>|</span><a href="#37205139">prev</a><span>|</span><a href="#37204955">next</a><span>|</span><label class="collapse" for="c-37203142">[-]</label><label class="expand" for="c-37203142">[2 more]</label></div><br/><div class="children"><div class="content">Just started getting into Lisp.<p>I realized that when I call a bunch of functions one after the other, I want to be able to reference them. I would have to put them in an array.<p>Then I thought why do I have to make this choice case by case. If only everything was a list…<p>I now want to see how I can shoehorn this into TypeScript. Maybe with macros or transpilation or something.<p>Then I want to see what cool things I can now do.<p>The only thing that gives me pause is that the language is insane to read and when you look at the implementation of Lisp defun and defmacro the code gets pretty wacky.<p>Figuring out what is a primative and what is just lists is very difficult.<p>I wonder if there is a less purist Lisp out there that looks nicer.</div><br/><div id="37203158" class="c"><input type="checkbox" id="c-37203158" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#37203142">parent</a><span>|</span><a href="#37204955">next</a><span>|</span><label class="collapse" for="c-37203158">[-]</label><label class="expand" for="c-37203158">[1 more]</label></div><br/><div class="children"><div class="content">this comes up alot. Dylan did this. I guess the curse and the salvation is that you get used to it pretty quickly. I really don&#x27;t think syntax is all that fundamental - its all fine up to a point (lookin at you perl)</div><br/></div></div></div></div><div id="37204955" class="c"><input type="checkbox" id="c-37204955" checked=""/><div class="controls bullet"><span class="by">bfung</span><span>|</span><a href="#37203142">prev</a><span>|</span><a href="#37203071">next</a><span>|</span><label class="collapse" for="c-37204955">[-]</label><label class="expand" for="c-37204955">[7 more]</label></div><br/><div class="children"><div class="content">closures are a poor man&#x27;s objects…</div><br/><div id="37206185" class="c"><input type="checkbox" id="c-37206185" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#37204955">parent</a><span>|</span><a href="#37205664">next</a><span>|</span><label class="collapse" for="c-37206185">[-]</label><label class="expand" for="c-37206185">[5 more]</label></div><br/><div class="children"><div class="content">I am not at all convinced that it is useful to have closures in a programming language.<p>The implementation of closures is completely unnecessary for any of the features that exist in functional languages or in any programming languages.<p>The avoidance of closures becomes possible when the programming language includes the restriction that inside a function body the only external variables (i.e. which are neither parameters nor local variables) that are visible are those that are allocated statically, either as process-local or as thread-local.<p>This restriction is similar with the restrictions from C or from traditional C++, but it is less constraining, because nested functions are allowed, they just cannot see the stack-allocated variables from enclosing blocks, unless they are passed as parameters.<p>Any useful thing that can be implemented with stack-allocated variables captured inside a closure can also be done with statically-allocated variables, but in a much more efficient way and in a way that is less prone to subtle bugs. Other applications of closures in LISPy languages are just workarounds for the impossibility of defining record or structure types. In any language with user-defined data types such closure applications are not needed.<p>The only significant difference between a language with closures and one without closures, from the programmer POV, is that in a language without closures for each variable that is accessed inside a function body without being passed as a parameter, the programmer must add an allocation-class specifier, such as &quot;static&quot; or &quot;thread_local&quot;.<p>This is a good thing in my opinion, because sometimes bugs are caused by unintentionally accessing external variables, which are automatically captured in closures.<p>A &quot;purely&quot; functional program must not access inside function bodies any variables that are not passed as parameters. Avoiding to write explicit &quot;static&quot; annotations, in order to make closures masquerade as functions, does not change the fact that such functions are no longer pure functions, but automata, which is good, whenever this is necessary.<p>When there are no closures, any function pointer can be just a simple pointer and any higher-order functions can have a faster implementation, which is better for any functional language. Closures add a completely unnecessary overhead.</div><br/><div id="37206755" class="c"><input type="checkbox" id="c-37206755" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#37204955">root</a><span>|</span><a href="#37206185">parent</a><span>|</span><a href="#37206246">next</a><span>|</span><label class="collapse" for="c-37206755">[-]</label><label class="expand" for="c-37206755">[1 more]</label></div><br/><div class="children"><div class="content">Different languages deal with the constraint you describe in interesting ways.<p>PHP has the “use” keyword, which captures variables explicitly. You can’t capture anything in the outer frame otherwise.<p>I wonder now if this has any performance implications.<p>In Rust, every captured variable is statically checked. The compiler knows that you capture a mutable reference for example. This often means that you need to express additional constraints in order to satisfy ownership semantics.<p>Now again, I wonder what the implications are on the generated code.</div><br/></div></div><div id="37206246" class="c"><input type="checkbox" id="c-37206246" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#37204955">root</a><span>|</span><a href="#37206185">parent</a><span>|</span><a href="#37206755">prev</a><span>|</span><a href="#37205664">next</a><span>|</span><label class="collapse" for="c-37206246">[-]</label><label class="expand" for="c-37206246">[3 more]</label></div><br/><div class="children"><div class="content">Note that Java fits your definition (though it allows one extra type of variable to be accessed, members of the current instance). It is probably the only popular language that supports local functions but not closures.<p>Also, C++ doesn&#x27;t suffer from the problem of accidentally capturing variables, since it requires you to explicitly state which variables from the external env you want to reference (with the [a, b] syntax at the start of a lambda declaration; a lambda starting with [] fits your desired constraints).</div><br/><div id="37206321" class="c"><input type="checkbox" id="c-37206321" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#37204955">root</a><span>|</span><a href="#37206246">parent</a><span>|</span><a href="#37205664">next</a><span>|</span><label class="collapse" for="c-37206321">[-]</label><label class="expand" for="c-37206321">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for pointing to Java. I have not thought about it, because I use Java only very seldom.<p>The members of the current instance are not really an extra type of variable.<p>They are the members of one hidden function parameter. While they are distinguished in the source code, in the translated machine code there is no difference between them and the explicit function parameters.<p>I agree that this is a good feature of C++, that it avoids the bugs caused by accidental captures by giving control to the programmer on what may be captured.<p>Nevertheless, perhaps it would have been possible to have a simpler implementation of the C++ lambda-declared functions than with the current function objects, by simply disallowing the capture of stack-allocated local variables.</div><br/><div id="37206849" class="c"><input type="checkbox" id="c-37206849" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#37204955">root</a><span>|</span><a href="#37206321">parent</a><span>|</span><a href="#37205664">next</a><span>|</span><label class="collapse" for="c-37206849">[-]</label><label class="expand" for="c-37206849">[1 more]</label></div><br/><div class="children"><div class="content">C++11 closures are very thin sugar over locally defined structures with an overloaded operator(), which you have been able to define since forever, so I think they do not present any significant implementation complexity.</div><br/></div></div></div></div></div></div></div></div><div id="37205664" class="c"><input type="checkbox" id="c-37205664" checked=""/><div class="controls bullet"><span class="by">solomonb</span><span>|</span><a href="#37204955">parent</a><span>|</span><a href="#37206185">prev</a><span>|</span><a href="#37203071">next</a><span>|</span><label class="collapse" for="c-37205664">[-]</label><label class="expand" for="c-37205664">[1 more]</label></div><br/><div class="children"><div class="content">&quot;At that moment, Anton became enlightened.&quot;</div><br/></div></div></div></div><div id="37203071" class="c"><input type="checkbox" id="c-37203071" checked=""/><div class="controls bullet"><span class="by">Supermancho</span><span>|</span><a href="#37204955">prev</a><span>|</span><a href="#37202600">next</a><span>|</span><label class="collapse" for="c-37203071">[-]</label><label class="expand" for="c-37203071">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s procedural programming all the way down (why stop at lambdas?) : <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=mrY6xrWp3Gs">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=mrY6xrWp3Gs</a></div><br/></div></div><div id="37202600" class="c"><input type="checkbox" id="c-37202600" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#37203071">prev</a><span>|</span><a href="#37203670">next</a><span>|</span><label class="collapse" for="c-37202600">[-]</label><label class="expand" for="c-37202600">[1 more]</label></div><br/><div class="children"><div class="content">[b] Lisp claims another soul. [&#x2F;b]</div><br/></div></div><div id="37203670" class="c"><input type="checkbox" id="c-37203670" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#37202600">prev</a><span>|</span><a href="#37203327">next</a><span>|</span><label class="collapse" for="c-37203670">[-]</label><label class="expand" for="c-37203670">[5 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s not lambdas all the way down.  Lisp machines are long gone.<p>I really wish people would stop teaching the &quot;metacircular&quot; stuff so early.  <i>McCarthy</i> even missed metacircularity.  It took a genuine genius on the level of Stephen Russell to &quot;get it&quot; and convert everything to a functional programming language.<p>Tell people to implement a Lisp down on the imperative language of the machine.  Suddenly, you will <i>get it</i>.  Mutability is a pain in the ass.  Recursion has issues.  Garbage collection isn&#x27;t optional--it&#x27;s <i>required</i> because all of your &quot;lambda&quot; shenanigans are beating the hell out of the allocator and cons-ing up trash like a victim of &quot;Hoarders&quot;.<p>Once you see the guts, suddenly metacircularity makes sense.  It also isn&#x27;t particularly interesting anymore.</div><br/><div id="37204161" class="c"><input type="checkbox" id="c-37204161" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#37203670">parent</a><span>|</span><a href="#37206074">next</a><span>|</span><label class="collapse" for="c-37204161">[-]</label><label class="expand" for="c-37204161">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Lisp machines are long gone.<p>They also had assembly and microcode (and Maclisp got scoping wrong until CL, anyway). So those weren&#x27;t much better if you want to measure &quot;purity&quot;.<p>&gt; Tell people to implement a Lisp down on the imperative language of the machine. ...<p>Somehow there is no end to the difficulty of mapping an imperative language to another, as evidenced by the size of LLVM. One picks one&#x27;s poison, I guess.</div><br/><div id="37204293" class="c"><input type="checkbox" id="c-37204293" checked=""/><div class="controls bullet"><span class="by">jfoutz</span><span>|</span><a href="#37203670">root</a><span>|</span><a href="#37204161">parent</a><span>|</span><a href="#37206074">next</a><span>|</span><label class="collapse" for="c-37204293">[-]</label><label class="expand" for="c-37204293">[1 more]</label></div><br/><div class="children"><div class="content">you can hack up eval, map, and apply in c without too much headache. I&#x27;d recommend int char and some sort of string representation as primitive. I&#x27;d also recommend not garbage collecting, and just malloc everything. Like, a weekend of effort for a really really bad implementation. So much magic disappears. Well, I guess this sort of assumes you know what a pointer is. If not, it&#x27;s going to be a tough slog regardless.<p>as a second pass, check out the later parts of sicp and expose some array type, and implement the gc in scheme.<p>also I&#x27;ll never pass up an opportunity to reference 3imp. <a href="http:&#x2F;&#x2F;agl.cs.unm.edu&#x2F;~williams&#x2F;cs491&#x2F;three-imp.pdf" rel="nofollow noreferrer">http:&#x2F;&#x2F;agl.cs.unm.edu&#x2F;~williams&#x2F;cs491&#x2F;three-imp.pdf</a><p>I know, I know, scheme is a vespa and CL is a Ferrari. For someone who learns more bottom up, the bare minimum of scheme, but all the way is amazing.</div><br/></div></div></div></div><div id="37206074" class="c"><input type="checkbox" id="c-37206074" checked=""/><div class="controls bullet"><span class="by">pro-kythera</span><span>|</span><a href="#37203670">parent</a><span>|</span><a href="#37204161">prev</a><span>|</span><a href="#37205226">next</a><span>|</span><label class="collapse" for="c-37206074">[-]</label><label class="expand" for="c-37206074">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Tell people to implement a Lisp down on the imperative language of the machine.<p>FWIW, my understanding is that the statement &quot;God exists&quot; in Aristotle is equivalent to the statement: &quot;You cannot say it is <i>X</i>s all the way down; there must be a base layer which is unchangeable (which we call God).&quot;<p>Could there be a hint here that programming-deity is either: a) imperitive at heart; or b) inordinately fond of garbage collection?</div><br/></div></div></div></div><div id="37203327" class="c"><input type="checkbox" id="c-37203327" checked=""/><div class="controls bullet"><span class="by">crawfordcomeaux</span><span>|</span><a href="#37203670">prev</a><span>|</span><a href="#37202779">next</a><span>|</span><label class="collapse" for="c-37203327">[-]</label><label class="expand" for="c-37203327">[2 more]</label></div><br/><div class="children"><div class="content">Maybe off topic....what emerges when we don&#x27;t go down to boolean as atomic and instead have a multivariate logical foundation that contains uncertainty?</div><br/><div id="37203634" class="c"><input type="checkbox" id="c-37203634" checked=""/><div class="controls bullet"><span class="by">alexisread</span><span>|</span><a href="#37203327">parent</a><span>|</span><a href="#37202779">next</a><span>|</span><label class="collapse" for="c-37203634">[-]</label><label class="expand" for="c-37203634">[1 more]</label></div><br/><div class="children"><div class="content">I guess you get a combinatorial explosion for binary operators:
<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Three-valued_logic" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Three-valued_logic</a><p>That&#x27;s not to say that you can&#x27;t get some value out of it. SQL is probably the closest language currently to implement TVL, and there have been recent works on datalog as well:
<a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2202.01718.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2202.01718.pdf</a><p>Datalog has generally better defined reasoning than SQL, and can kinda serve duty for typechecking, formal verification.
It&#x27;s worth noting that many languages have the (disjointed) concept of uninitialised values which are equivalent to TVL (Also note nullable types in eg. C#). As such, from a practical perspective, TVL is pushed out as much as possible from code, I suspect it&#x27;s of more use for data.</div><br/></div></div></div></div></div></div></div></div></div></body></html>