<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685610079720" as="style"/><link rel="stylesheet" href="styles.css?v=1685610079720"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/OAI/moonwalk">OpenAPI v4 (aka Moonwalk) Proposal</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>mooreds</span> | <span>115 comments</span></div><br/><div><div id="36145131" class="c"><input type="checkbox" id="c-36145131" checked=""/><div class="controls bullet"><span class="by">mbell</span><span>|</span><a href="#36144968">next</a><span>|</span><label class="collapse" for="c-36145131">[-]</label><label class="expand" for="c-36145131">[36 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried using OpenAPI a few times, it&#x27;s been...lackluster... I probably won&#x27;t use it again.<p>Here are my gripes:<p>1) For me one of the biggest selling points is client code gen (<a href="https:&#x2F;&#x2F;github.com&#x2F;OpenAPITools&#x2F;openapi-generator">https:&#x2F;&#x2F;github.com&#x2F;OpenAPITools&#x2F;openapi-generator</a>). Basically it sucks, or at least it sucks in enough languages to spoil it. The value prop here is define the API once, code gen the client for Ruby, Python and Scala (or insert your languages here). Often there are a half dozen clients for each language, often they are simply broken (the generated code just straight up doesn&#x27;t compile). Of the ones that do work, you get random PRs accepted that impose a completely different ideological approach to how the client works. It really seems like any PR is accepted with no overarching guidance.<p>2) JSONSchema is too limited. We use it for a lot of things, but it just makes some things incredibly hard. This is compounded by the seemingly limitless number of version or drafts of the spec. If your goal is interop, which it probably is if you are using JSON, you have to go our and research what the lower common denominator draft spec JSONSchema support is for the various languages you want to use and limit yourself to that (probably draft 4, or draft 7).<p>On the pros side:<p>It does make pretty docs - kinda wish it would just focus on this and in the process not be as strict, I think it would be a better project.</div><br/><div id="36148830" class="c"><input type="checkbox" id="c-36148830" checked=""/><div class="controls bullet"><span class="by">moondowner</span><span>|</span><a href="#36145131">parent</a><span>|</span><a href="#36145963">next</a><span>|</span><label class="collapse" for="c-36148830">[-]</label><label class="expand" for="c-36148830">[1 more]</label></div><br/><div class="children"><div class="content">The Java generator is pretty good, many big companies are using it for generating both client and server code, I&#x27;m especially happy with the Java Spring Boot generator, I&#x27;ve been using it for both reactive and &#x27;standard&#x27; code generation.</div><br/></div></div><div id="36145963" class="c"><input type="checkbox" id="c-36145963" checked=""/><div class="controls bullet"><span class="by">simplesager</span><span>|</span><a href="#36145131">parent</a><span>|</span><a href="#36148830">prev</a><span>|</span><a href="#36145866">next</a><span>|</span><label class="collapse" for="c-36145963">[-]</label><label class="expand" for="c-36145963">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m working on a company <a href="https:&#x2F;&#x2F;speakeasyapi.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;speakeasyapi.dev&#x2F;</a> with the goal of helping companies in this ecosystem get great production quality client sdks, terraform providers, cli(s) and all the developer surfaces you may want supported for our API. We also manage the spec and publishing workflow for you so all you have to do is build your API and we&#x27;ll do the rest.<p>Feel free to email me at sagar@speakeasyapi.dev or join our slack (<a href="https:&#x2F;&#x2F;join.slack.com&#x2F;t&#x2F;speakeasy-dev&#x2F;shared_invite&#x2F;zt-1cwb3flxz-lS5SyZxAsF_3NOq5xc8Cjw" rel="nofollow">https:&#x2F;&#x2F;join.slack.com&#x2F;t&#x2F;speakeasy-dev&#x2F;shared_invite&#x2F;zt-1cwb...</a>) . We&#x27;re in open beta and working with a few great companies already and we&#x27;d be happy for you to try out the platform for free!</div><br/><div id="36148862" class="c"><input type="checkbox" id="c-36148862" checked=""/><div class="controls bullet"><span class="by">coplowe</span><span>|</span><a href="#36145131">root</a><span>|</span><a href="#36145963">parent</a><span>|</span><a href="#36146102">next</a><span>|</span><label class="collapse" for="c-36148862">[-]</label><label class="expand" for="c-36148862">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been working with Speakeasy for a couple of month now to produce client libraries for our customers to use. They&#x27;ve finally made an OAS-based code generator that&#x27;s great. In fact, it&#x27;s getting even better with useful functionality being released on an almost biweekly basis. I would strongly recommend Sagar and the Speakeasy team to anyone looking to support high quality client libraries for your customers.</div><br/></div></div><div id="36146102" class="c"><input type="checkbox" id="c-36146102" checked=""/><div class="controls bullet"><span class="by">bebop</span><span>|</span><a href="#36145131">root</a><span>|</span><a href="#36145963">parent</a><span>|</span><a href="#36148862">prev</a><span>|</span><a href="#36148179">next</a><span>|</span><label class="collapse" for="c-36146102">[-]</label><label class="expand" for="c-36146102">[1 more]</label></div><br/><div class="children"><div class="content">We at Airbyte are happy users of the speakeasy platform. The CLI generator is easy to get started with and generate nice api clients that are constantly getting better. Their api developer platform does a great job of managing new client builds and deploys to the package repositories as well. Super please with the experience so far.</div><br/></div></div><div id="36148179" class="c"><input type="checkbox" id="c-36148179" checked=""/><div class="controls bullet"><span class="by">spjain</span><span>|</span><a href="#36145131">root</a><span>|</span><a href="#36145963">parent</a><span>|</span><a href="#36146102">prev</a><span>|</span><a href="#36146052">next</a><span>|</span><label class="collapse" for="c-36148179">[-]</label><label class="expand" for="c-36148179">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the thought process behind the product with API Keys? Why do you build those for your end user, and what&#x27;s the goal of someone using that. Unless I&#x27;m misinterpreting.</div><br/></div></div><div id="36146052" class="c"><input type="checkbox" id="c-36146052" checked=""/><div class="controls bullet"><span class="by">n_f</span><span>|</span><a href="#36145131">root</a><span>|</span><a href="#36145963">parent</a><span>|</span><a href="#36148179">prev</a><span>|</span><a href="#36146132">next</a><span>|</span><label class="collapse" for="c-36146052">[-]</label><label class="expand" for="c-36146052">[1 more]</label></div><br/><div class="children"><div class="content">Definitely check out Speakeasy— we&#x27;ve been using them and the experience + team are fantastic</div><br/></div></div><div id="36146132" class="c"><input type="checkbox" id="c-36146132" checked=""/><div class="controls bullet"><span class="by">rileybrook</span><span>|</span><a href="#36145131">root</a><span>|</span><a href="#36145963">parent</a><span>|</span><a href="#36146052">prev</a><span>|</span><a href="#36145866">next</a><span>|</span><label class="collapse" for="c-36146132">[-]</label><label class="expand" for="c-36146132">[1 more]</label></div><br/><div class="children"><div class="content">+1 to Speakeasy ~ Our end-users love to use the SDKs that are automatically generated through Speakeasy, based off our API.</div><br/></div></div></div></div><div id="36145866" class="c"><input type="checkbox" id="c-36145866" checked=""/><div class="controls bullet"><span class="by">GOATS-</span><span>|</span><a href="#36145131">parent</a><span>|</span><a href="#36145963">prev</a><span>|</span><a href="#36147381">next</a><span>|</span><label class="collapse" for="c-36145866">[-]</label><label class="expand" for="c-36145866">[6 more]</label></div><br/><div class="children"><div class="content">I find it odd that you&#x27;ve struggled so much with generating API clients. I&#x27;ve generated C# and TypeScript (Angular&#x27;s HttpClient and React Query) clients for my API and never had any issues with them. With that being said, I didn&#x27;t use OpenAPI&#x27;s Java-based code generators and rather used ones made by third-party developers such as NSwag[0] and openapi-codegen[1].<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;RicoSuter&#x2F;NSwag">https:&#x2F;&#x2F;github.com&#x2F;RicoSuter&#x2F;NSwag</a><p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;fabien0102&#x2F;openapi-codegen">https:&#x2F;&#x2F;github.com&#x2F;fabien0102&#x2F;openapi-codegen</a></div><br/><div id="36146778" class="c"><input type="checkbox" id="c-36146778" checked=""/><div class="controls bullet"><span class="by">dcre</span><span>|</span><a href="#36145131">root</a><span>|</span><a href="#36145866">parent</a><span>|</span><a href="#36147865">next</a><span>|</span><label class="collapse" for="c-36146778">[-]</label><label class="expand" for="c-36146778">[1 more]</label></div><br/><div class="children"><div class="content">You said it yourself — the “official” generator is <i>awful</i> and very hard to modify or extend (well, you didn’t say that, but I’m saying it) and while there are many alternatives, they’re not always easy to find. I had some success with swagger-typescript-api[1], but eventually got tired of it and wrote my own generator. Despite looking around quite a bit at what’s available, I never heard of openapi-codegen, which looks quite good.<p>I think it’s a pretty big problem for many devs that so many of the options are mediocre and they’re quite difficult to evaluate unless you have a lot of experience, and even then it takes a lot of time.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;acacode&#x2F;swagger-typescript-api">https:&#x2F;&#x2F;github.com&#x2F;acacode&#x2F;swagger-typescript-api</a></div><br/></div></div><div id="36147865" class="c"><input type="checkbox" id="c-36147865" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#36145131">root</a><span>|</span><a href="#36145866">parent</a><span>|</span><a href="#36146778">prev</a><span>|</span><a href="#36148120">next</a><span>|</span><label class="collapse" for="c-36147865">[-]</label><label class="expand" for="c-36147865">[1 more]</label></div><br/><div class="children"><div class="content">Nswag leaves much to be desired.  I deployed an OpenAPI server and the initial deployment partners using nswag begged us to change the API to suit an issue that was reported and nswag hadn&#x27;t fixed in years.  I respectfully told them to pound sand and deal with it manually or better yet be a good citizen on <i>the ecosystem that they are using for free</i> and contribute a patch.  Last I checked they were still manually patching their codegen on each deploy. &#x2F;Shrug<p>Nswag has important issues that are many years old <i>still</i> in their backlog.<p>1.6k issues, oldest unresolved 7 years old:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;RicoSuter&#x2F;NSwag&#x2F;issues?q=is%3Aissue+is%3Aopen+sort%3Acreated-asc">https:&#x2F;&#x2F;github.com&#x2F;RicoSuter&#x2F;NSwag&#x2F;issues?q=is%3Aissue+is%3A...</a></div><br/></div></div><div id="36148120" class="c"><input type="checkbox" id="c-36148120" checked=""/><div class="controls bullet"><span class="by">johnny_reilly</span><span>|</span><a href="#36145131">root</a><span>|</span><a href="#36145866">parent</a><span>|</span><a href="#36147865">prev</a><span>|</span><a href="#36145977">next</a><span>|</span><label class="collapse" for="c-36148120">[-]</label><label class="expand" for="c-36148120">[1 more]</label></div><br/><div class="children"><div class="content">This.  I&#x27;ve found you can get a long way with NSwag, and the barrier to entry is low.  I&#x27;ve got a post that walks through how to get a TypeScript and a C# client generated.<p><a href="https:&#x2F;&#x2F;johnnyreilly.com&#x2F;generate-typescript-and-csharp-clients-with-nswag" rel="nofollow">https:&#x2F;&#x2F;johnnyreilly.com&#x2F;generate-typescript-and-csharp-clie...</a></div><br/></div></div><div id="36145977" class="c"><input type="checkbox" id="c-36145977" checked=""/><div class="controls bullet"><span class="by">SCUSKU</span><span>|</span><a href="#36145131">root</a><span>|</span><a href="#36145866">parent</a><span>|</span><a href="#36148120">prev</a><span>|</span><a href="#36147381">next</a><span>|</span><label class="collapse" for="c-36145977">[-]</label><label class="expand" for="c-36145977">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using redux toolkit&#x27;s OpenAPI code generator for a side project and it&#x27;s been pretty good. The documentation is a bit lacking and it could certainly use more work to make names more customizable. The generated code comes out looking very much machine generated. But I love that RTKQuery (redux toolkit query) has client side caching so that if I use a query param that was already used before, it will remember and just serve from the local cache.<p>But it&#x27;s been nice being able to make a backend change, run the code generator, and then be able to use whatever API in react. I hope this type of stuff gets developed more!<p>[0] - <a href="https:&#x2F;&#x2F;github.com&#x2F;reduxjs&#x2F;redux-toolkit&#x2F;tree&#x2F;master&#x2F;packages&#x2F;rtk-query-codegen-openapi">https:&#x2F;&#x2F;github.com&#x2F;reduxjs&#x2F;redux-toolkit&#x2F;tree&#x2F;master&#x2F;package...</a></div><br/><div id="36147312" class="c"><input type="checkbox" id="c-36147312" checked=""/><div class="controls bullet"><span class="by">cjonas</span><span>|</span><a href="#36145131">root</a><span>|</span><a href="#36145977">parent</a><span>|</span><a href="#36147381">next</a><span>|</span><label class="collapse" for="c-36147312">[-]</label><label class="expand" for="c-36147312">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had the same experience and gripes as the comment op, but RTKquery is one of the better experiences I&#x27;ve had with OpenApi based tooling.<p>But ya... JSONschema is confusing and doesn&#x27;t really support type composition the way you think it would.<p>If your API model is simple, then you&#x27;ll probably have decent experience with clients... But if you need &quot;allOf&#x2F;anyOf&#x2F;oneOf&quot; and to restrict &quot;additionalProps&quot;, you&#x27;re probably going to have a rough time...</div><br/></div></div></div></div></div></div><div id="36147381" class="c"><input type="checkbox" id="c-36147381" checked=""/><div class="controls bullet"><span class="by">seer</span><span>|</span><a href="#36145131">parent</a><span>|</span><a href="#36145866">prev</a><span>|</span><a href="#36145847">next</a><span>|</span><label class="collapse" for="c-36147381">[-]</label><label class="expand" for="c-36147381">[1 more]</label></div><br/><div class="children"><div class="content">I think that’s what most people are using it for, but having a single expressive (debatable) language to describe the contract an api offers has soo much potential.<p>GraphQL promised us apis that we can trust - since both the client <i>and</i> the server were implemented with the same schema, you would know for sure which requests the api would respond to and how, if it tried to do something outside of the schema, the server lib itself would through a 500 error. This allowed you to generate lean, typesafe clients.<p>OpenAPI kinda allows you to do that but for any other http api - I’ve written some code to use the schema as a “source of truth” for the server code as well, proving at compile time that the code will do the correct requests and responses for all the endpoints, paths and methods. So if you are reading the schema, you <i>know</i> for sure that the api is going to return this, and any change has to start from modifying the api.<p>And in turn this allows a “contract first” dev where all parties agree on the api change first, and then go to implement their changes, using the schema as an actual contract.<p>Combine this with languages with expressive type systems, and it allows you a style of coding thats quite nice - “if it compiles it is guaranteed to be correct”. Now of course this does not catch all bugs, but kinda confines them to mostly business logic errors, and frees you from needing to write tons of manual unit tests for every request.<p>Oh as a bonus it can be used for runtime request validation as well, which allows you to have types generated for those as well, for the client _and_ the server! Makes changes in the api a lot more predictable.<p>Client &#x2F; server code generation can also be implemented as just type generation with no actual code being created, sidestepping a lot of complaints about code generators.<p>I did package it up as OS <a href="https:&#x2F;&#x2F;github.com&#x2F;ovotech&#x2F;laminar">https:&#x2F;&#x2F;github.com&#x2F;ovotech&#x2F;laminar</a> but no longer have access to maintain it as I no longer work there unfortunately.</div><br/></div></div><div id="36145847" class="c"><input type="checkbox" id="c-36145847" checked=""/><div class="controls bullet"><span class="by">dandevs</span><span>|</span><a href="#36145131">parent</a><span>|</span><a href="#36147381">prev</a><span>|</span><a href="#36145316">next</a><span>|</span><label class="collapse" for="c-36145847">[-]</label><label class="expand" for="c-36145847">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m one of the builders of an open source project (<a href="https:&#x2F;&#x2F;buildwithfern.com&#x2F;docs">https:&#x2F;&#x2F;buildwithfern.com&#x2F;docs</a>) to improve API codegen. We built Fern as an alternative to OpenAPI, but of course we&#x27;re fully compatible with it.<p>The generators are open source: <a href="https:&#x2F;&#x2F;github.com&#x2F;fern-api&#x2F;fern">https:&#x2F;&#x2F;github.com&#x2F;fern-api&#x2F;fern</a><p>We rewrote the code generators from scratch in the language that they generate code in (e.g., the python generator is written in python). We shied away from templating - it&#x27;s easier but the generated code feels less human.<p>Want to talk client library codegen? Join the Fern Discord: <a href="https:&#x2F;&#x2F;discord.com&#x2F;invite&#x2F;JkkXumPzcG" rel="nofollow">https:&#x2F;&#x2F;discord.com&#x2F;invite&#x2F;JkkXumPzcG</a></div><br/><div id="36148192" class="c"><input type="checkbox" id="c-36148192" checked=""/><div class="controls bullet"><span class="by">spjain</span><span>|</span><a href="#36145131">root</a><span>|</span><a href="#36145847">parent</a><span>|</span><a href="#36145907">next</a><span>|</span><label class="collapse" for="c-36148192">[-]</label><label class="expand" for="c-36148192">[1 more]</label></div><br/><div class="children"><div class="content">Speed of development on these guys is huge, and have enjoyed using their SDKs. Community is getting involved in building things like auto-retry with backoff and other pretty helpful features in SDKs. Big fan of these guys!</div><br/></div></div><div id="36145907" class="c"><input type="checkbox" id="c-36145907" checked=""/><div class="controls bullet"><span class="by">thesandlord</span><span>|</span><a href="#36145131">root</a><span>|</span><a href="#36145847">parent</a><span>|</span><a href="#36148192">prev</a><span>|</span><a href="#36146059">next</a><span>|</span><label class="collapse" for="c-36145907">[-]</label><label class="expand" for="c-36145907">[1 more]</label></div><br/><div class="children"><div class="content">Just wanted to chime in and say we are a big fan of Fern! It makes developing our APIs 10x easier as we get full end-to-end type safety and code completion, but the really great part is we get idiomatic client and server SDKs as well as OpenAPI output that we use to autogen documentation. Our small team of two engineers are able to ship multiple client facing SDKs because we are built on Fern!</div><br/></div></div></div></div><div id="36145316" class="c"><input type="checkbox" id="c-36145316" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#36145131">parent</a><span>|</span><a href="#36145847">prev</a><span>|</span><a href="#36145648">next</a><span>|</span><label class="collapse" for="c-36145316">[-]</label><label class="expand" for="c-36145316">[1 more]</label></div><br/><div class="children"><div class="content">Sad to see it isn&#x27;t just me.  I had very real vibes of &quot;surely I&#x27;m holding this wrong&quot; in my building an OpenAPI file.  And you didn&#x27;t even mention tools to help deploy, just to help make a client.<p>To add my difficulty, the document generation inside Sphinx was less than up to date.  Such that I didn&#x27;t even get the pretty docs.</div><br/></div></div><div id="36145648" class="c"><input type="checkbox" id="c-36145648" checked=""/><div class="controls bullet"><span class="by">rattray</span><span>|</span><a href="#36145131">parent</a><span>|</span><a href="#36145316">prev</a><span>|</span><a href="#36146506">next</a><span>|</span><label class="collapse" for="c-36145648">[-]</label><label class="expand" for="c-36145648">[3 more]</label></div><br/><div class="children"><div class="content">FWIW, there are a few companies cropping up now doing better codegen for client libraries. I&#x27;m starting one of them: <a href="https:&#x2F;&#x2F;stainlessapi.com" rel="nofollow">https:&#x2F;&#x2F;stainlessapi.com</a><p>Unfortunately we don&#x27;t yet have a &quot;try now&quot; button, and our codegen is still closed-source, but you can see some of the libraries we&#x27;ve generated for companies like Modern Treasury and sign up for the waitlist on our homepage.<p>Always happy to chat codegen over email etc.</div><br/><div id="36145756" class="c"><input type="checkbox" id="c-36145756" checked=""/><div class="controls bullet"><span class="by">saarons</span><span>|</span><a href="#36145131">root</a><span>|</span><a href="#36145648">parent</a><span>|</span><a href="#36145865">next</a><span>|</span><label class="collapse" for="c-36145756">[-]</label><label class="expand" for="c-36145756">[1 more]</label></div><br/><div class="children"><div class="content">CTO of Modern Treasury here. We&#x27;re very happy with the quality of the client libraries being generated by Stainless. It also integrates nicely into our workflow, we&#x27;ve got the releases almost fully automated whenever new API routes are added or changed.</div><br/></div></div><div id="36145865" class="c"><input type="checkbox" id="c-36145865" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#36145131">root</a><span>|</span><a href="#36145648">parent</a><span>|</span><a href="#36145756">prev</a><span>|</span><a href="#36146506">next</a><span>|</span><label class="collapse" for="c-36145865">[-]</label><label class="expand" for="c-36145865">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m looking for a codegen tool for client SDKs for my product, would love to use your product. My email is in my profile, if you want to chat.</div><br/></div></div></div></div><div id="36146506" class="c"><input type="checkbox" id="c-36146506" checked=""/><div class="controls bullet"><span class="by">layoric</span><span>|</span><a href="#36145131">parent</a><span>|</span><a href="#36145648">prev</a><span>|</span><a href="#36146031">next</a><span>|</span><label class="collapse" for="c-36146506">[-]</label><label class="expand" for="c-36146506">[2 more]</label></div><br/><div class="children"><div class="content">I agree that codegen + docs is actually where most of the value is. The problem I think is in the design. Having an intermediate spec makes all the downstream tooling for codegen + docs need to handle all the complexity. Any information lost  (because the spec is in sufficient for whatever use case), you end up with a worst of both worlds situation, your code or docs gen tooling is less direct to use, and now is missing context.<p>Another way of handling this is getting the server your are interacting with to be able to generate the code directly based on their own internal knowledge of how the APIs are put together. This puts more onus on the library creators to support languages etc, but provides a much better experience and better chance things will &#x27;just work&#x27; as there are just less moving parts.<p>ServiceStack is a .NET library that does this with &#x27;Add ServiceStack Reference&#x27;[0] which enables a direct generation of Request and Response DTOs with the APIs for the specific server you are integrating with. IDE integration is straight forward since pulling the generated code is just another web service call. Additional language generation are integrated directly. It had trade offs but I&#x27;m yet to see a better dev experience.<p>[0] <a href="https:&#x2F;&#x2F;servicestack.net&#x2F;add-servicestack-reference" rel="nofollow">https:&#x2F;&#x2F;servicestack.net&#x2F;add-servicestack-reference</a><p>(Disclaimer I work for ServiceStack).</div><br/><div id="36146596" class="c"><input type="checkbox" id="c-36146596" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#36145131">root</a><span>|</span><a href="#36146506">parent</a><span>|</span><a href="#36146031">next</a><span>|</span><label class="collapse" for="c-36146596">[-]</label><label class="expand" for="c-36146596">[1 more]</label></div><br/><div class="children"><div class="content">I find the code gen less valuable than having a machine-readable spec that I can test against.</div><br/></div></div></div></div><div id="36146031" class="c"><input type="checkbox" id="c-36146031" checked=""/><div class="controls bullet"><span class="by">madeofpalk</span><span>|</span><a href="#36145131">parent</a><span>|</span><a href="#36146506">prev</a><span>|</span><a href="#36145634">next</a><span>|</span><label class="collapse" for="c-36146031">[-]</label><label class="expand" for="c-36146031">[1 more]</label></div><br/><div class="children"><div class="content">To your first point - you may think it detracts from perceived value, but you can just write your own code generator for openapi - it&#x27;s not <i>that</i> hard, and you&#x27;ll probably end up with a higher quality client that more fits your preferred pattern better.<p>This is still a win because you can still generate all your clients in sync with your API spec rather than doing all that manually.</div><br/></div></div><div id="36145634" class="c"><input type="checkbox" id="c-36145634" checked=""/><div class="controls bullet"><span class="by">onetrickwolf</span><span>|</span><a href="#36145131">parent</a><span>|</span><a href="#36146031">prev</a><span>|</span><a href="#36146021">next</a><span>|</span><label class="collapse" for="c-36145634">[-]</label><label class="expand" for="c-36145634">[2 more]</label></div><br/><div class="children"><div class="content">Yeah I had this experience too. I figured at least there&#x27;d be static checking that would at least make sure we aren&#x27;t going off spec but there isn&#x27;t really. So you just have a spec that slowly becomes out of sync with the code until it&#x27;s basically useless. Just seems like double work for almost no benefit.</div><br/><div id="36145790" class="c"><input type="checkbox" id="c-36145790" checked=""/><div class="controls bullet"><span class="by">LelouBil</span><span>|</span><a href="#36145131">root</a><span>|</span><a href="#36145634">parent</a><span>|</span><a href="#36146021">next</a><span>|</span><label class="collapse" for="c-36145790">[-]</label><label class="expand" for="c-36145790">[1 more]</label></div><br/><div class="children"><div class="content">It depends on the tools you use. You can use tester proxies that validate all requests and responses to the specs, or you can do server code gen (with interfaces&#x2F;Subclasses for example in Java) so you are forced to adhere to the specs.</div><br/></div></div></div></div><div id="36146021" class="c"><input type="checkbox" id="c-36146021" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#36145131">parent</a><span>|</span><a href="#36145634">prev</a><span>|</span><a href="#36145545">next</a><span>|</span><label class="collapse" for="c-36146021">[-]</label><label class="expand" for="c-36146021">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>For me one of the biggest selling points is client code gen. Basically it sucks</i><p>I agree that the official codegen is not that great.  One of my former colleagues started guardrail[0] to offer better client -- and server -- codegen in Scala for a few different http&#x2F;rest frameworks.  Later, I added support for Java and some Java frameworks.  (I haven&#x27;t worked on the project in over a year, but from what I understand, it&#x27;s still moving forward.)<p>Obviously that&#x27;s a fairly limited set of languages and frameworks compared to what the official generators offer, and there are some OpenAPI features that it doesn&#x27;t support, but guardrail is a good alternative if you&#x27;re a Java or Scala developer.<p>&gt; <i>JSONSchema is too limited</i><p>I&#x27;ve run into some of the problems you&#x27;ve described, which can be a big bummer.  For new APIs I&#x27;d designed, I took the approach of designing the API in a way that I knew I could express in OpenAPI without too much trouble, using only the features I knew guardrail supported well (or features I knew I could add support for without too much trouble).  It&#x27;s not really the ideal way to design an API, but after years of that sort of work, I realized one of the worst parts of building APIs is the tedious and error-prone process of building server routes or a client for it, and I wanted to optimize away as much of that as possible.<p>Ultimately my view is that if you are writing API clients and servers by hand, you&#x27;re doing it wrong.  Even if you end up writing your own bespoke API definition format and your own code generators, that&#x27;s still better than doing it manually.  Obviously, if something like OpenAPI meets your needs, that&#x27;s great.  And even if you don&#x27;t like the output of the existing code generators, you can still write your own; there are a bunch of parser libraries for the format that will make things a lot easier, and it really isn&#x27;t that difficult to do, especially if you pare your feature support down to the specifics of what you need.<p>[0] <a href="https:&#x2F;&#x2F;guardrail.dev" rel="nofollow">https:&#x2F;&#x2F;guardrail.dev</a></div><br/></div></div><div id="36145545" class="c"><input type="checkbox" id="c-36145545" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#36145131">parent</a><span>|</span><a href="#36146021">prev</a><span>|</span><a href="#36145899">next</a><span>|</span><label class="collapse" for="c-36145545">[-]</label><label class="expand" for="c-36145545">[2 more]</label></div><br/><div class="children"><div class="content">I actually got the OpenAPI docgen magic to work 100% all the way into Azure API Management Service such that our branded portal&#x27;s docs were being updated based upon code comments each time upon merge. It really is something to marvel at. <i>It actually worked</i>.<p>That said, I didn&#x27;t like the amount of moving pieces, annotation soup in code, etc. I got rid of all of it. Instead of relying on a fancy developer web portal with automagically updating docs, I am maintaining demo integration projects in repositories our vendors will have access to. I feel like this will break a hell of a lot less over time and would be more flexible with regard to human factors. Troubleshooting OpenAPI tooling is not something I want myself or my team worrying about right now.</div><br/><div id="36146300" class="c"><input type="checkbox" id="c-36146300" checked=""/><div class="controls bullet"><span class="by">ciwchris</span><span>|</span><a href="#36145131">root</a><span>|</span><a href="#36145545">parent</a><span>|</span><a href="#36145899">next</a><span>|</span><label class="collapse" for="c-36146300">[-]</label><label class="expand" for="c-36146300">[1 more]</label></div><br/><div class="children"><div class="content">Good to know. I&#x27;d like to learn about the process you had set up and the number of moving pieces it required. Have you written about this process? Can I read about it somewhere?</div><br/></div></div></div></div><div id="36145899" class="c"><input type="checkbox" id="c-36145899" checked=""/><div class="controls bullet"><span class="by">sthuck</span><span>|</span><a href="#36145131">parent</a><span>|</span><a href="#36145545">prev</a><span>|</span><a href="#36145724">next</a><span>|</span><label class="collapse" for="c-36145899">[-]</label><label class="expand" for="c-36145899">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s always nice to read and know I am not an opinionated asshole, and other people share the misery. I admit I&#x27;ve been duped using OpenAPI. Generating the schema via FastAPI and Nest.js works pretty well. But like you we have been sorely disappointment by the codegen.<p>Anyone care to suggest alternatives though, assuming we want to call from node to python? I actually believe that having api packages with types is one of the only things startups should take from the enterprise world. I thought about GRPC, I had good experience with it as a developer, but the previous company had a team of people dedicated just to help with the tooling around GRPC and Protobufs.<p>So I picked OpenAPI, figuring simple is better, and plaintext over http is simpler. and currently I do believe it&#x27;s better than nothing, but not by much. I am actually in the process of trying to write my own codegen and seeing how far I can get with it.<p>are protobuf&#x27;s with GRPC really the way to go nowadays? should a startup of 20 developers just give up and document api in some shared knowledge base and that&#x27;s it?</div><br/><div id="36146140" class="c"><input type="checkbox" id="c-36146140" checked=""/><div class="controls bullet"><span class="by">easton</span><span>|</span><a href="#36145131">root</a><span>|</span><a href="#36145899">parent</a><span>|</span><a href="#36146594">next</a><span>|</span><label class="collapse" for="c-36146140">[-]</label><label class="expand" for="c-36146140">[1 more]</label></div><br/><div class="children"><div class="content">NSwag does a wonderful job of generating TypeScript clients from OpenAPI specs. Definitely give it a shot before killing your current setup.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;RicoSuter&#x2F;NSwag">https:&#x2F;&#x2F;github.com&#x2F;RicoSuter&#x2F;NSwag</a> (It sucks in any OpenAPI yml, not just ones from Swashbuckle&#x2F;C#)</div><br/></div></div><div id="36146594" class="c"><input type="checkbox" id="c-36146594" checked=""/><div class="controls bullet"><span class="by">dsinghvi</span><span>|</span><a href="#36145131">root</a><span>|</span><a href="#36145899">parent</a><span>|</span><a href="#36146140">prev</a><span>|</span><a href="#36145724">next</a><span>|</span><label class="collapse" for="c-36146594">[-]</label><label class="expand" for="c-36146594">[1 more]</label></div><br/><div class="children"><div class="content">@sthuck I&#x27;m working on an alternative in this space called Fern. Like gRPC, you define your schema and use it to generate client libraries + server code. Fern integrates with FastAPI&#x2F;Express&#x2F;Spring and generates clients in Python, Typescript, and Java.<p>Checkout out this demo: <a href="https:&#x2F;&#x2F;www.loom.com&#x2F;share&#x2F;42de542022de4e55a1349383c7a465eb" rel="nofollow">https:&#x2F;&#x2F;www.loom.com&#x2F;share&#x2F;42de542022de4e55a1349383c7a465eb</a>. Feel free to join our discord as well: <a href="https:&#x2F;&#x2F;discord.com&#x2F;invite&#x2F;JkkXumPzcG" rel="nofollow">https:&#x2F;&#x2F;discord.com&#x2F;invite&#x2F;JkkXumPzcG</a>.</div><br/></div></div></div></div><div id="36145724" class="c"><input type="checkbox" id="c-36145724" checked=""/><div class="controls bullet"><span class="by">groestl</span><span>|</span><a href="#36145131">parent</a><span>|</span><a href="#36145899">prev</a><span>|</span><a href="#36145274">next</a><span>|</span><label class="collapse" for="c-36145724">[-]</label><label class="expand" for="c-36145724">[1 more]</label></div><br/><div class="children"><div class="content">1) hits home. The lack of a proper AST, &quot;logicless&quot; Mustache templates for code generation, lack of tests,... Also, OpenAPI seems to allow features in the language before at least a handfull of first class code generators have support for that feature, just because one generator supports it. And not that the others refuse, they just produce broken code</div><br/></div></div><div id="36145274" class="c"><input type="checkbox" id="c-36145274" checked=""/><div class="controls bullet"><span class="by">jontro</span><span>|</span><a href="#36145131">parent</a><span>|</span><a href="#36145724">prev</a><span>|</span><a href="#36144968">next</a><span>|</span><label class="collapse" for="c-36145274">[-]</label><label class="expand" for="c-36145274">[1 more]</label></div><br/><div class="children"><div class="content">As for point 1) I fully agree. I&#x27;m using it a lot currently due to lack of alternatives, mainly with java. Swagger codegen is the one I&#x27;ve had most success with, but both openapi and swagger codegen shares the same problems.<p>For internal projects we use grpc which is a breeze to use in comparison.</div><br/></div></div></div></div><div id="36144968" class="c"><input type="checkbox" id="c-36144968" checked=""/><div class="controls bullet"><span class="by">furyofantares</span><span>|</span><a href="#36145131">prev</a><span>|</span><a href="#36145015">next</a><span>|</span><label class="collapse" for="c-36144968">[-]</label><label class="expand" for="c-36144968">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;m certainly not going to be the only one who, confused, read fairly far in before realizing I didn&#x27;t see the P in OpenAPI.</div><br/><div id="36145124" class="c"><input type="checkbox" id="c-36145124" checked=""/><div class="controls bullet"><span class="by">jeron</span><span>|</span><a href="#36144968">parent</a><span>|</span><a href="#36145006">next</a><span>|</span><label class="collapse" for="c-36145124">[-]</label><label class="expand" for="c-36145124">[1 more]</label></div><br/><div class="children"><div class="content">reminds me of when Snap-On tools had a nice bump in stock price prior to Snapchat IPO</div><br/></div></div><div id="36145006" class="c"><input type="checkbox" id="c-36145006" checked=""/><div class="controls bullet"><span class="by">stefankuehnel</span><span>|</span><a href="#36144968">parent</a><span>|</span><a href="#36145124">prev</a><span>|</span><a href="#36145453">next</a><span>|</span><label class="collapse" for="c-36145006">[-]</label><label class="expand" for="c-36145006">[1 more]</label></div><br/><div class="children"><div class="content">You are definitely not the only one. It happened to me too. xD</div><br/></div></div><div id="36145453" class="c"><input type="checkbox" id="c-36145453" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#36144968">parent</a><span>|</span><a href="#36145006">prev</a><span>|</span><a href="#36147077">next</a><span>|</span><label class="collapse" for="c-36145453">[-]</label><label class="expand" for="c-36145453">[1 more]</label></div><br/><div class="children"><div class="content">OpenAI&#x27;s plugins are based on OpenAPI.</div><br/></div></div><div id="36147077" class="c"><input type="checkbox" id="c-36147077" checked=""/><div class="controls bullet"><span class="by">low_tech_punk</span><span>|</span><a href="#36144968">parent</a><span>|</span><a href="#36145453">prev</a><span>|</span><a href="#36145716">next</a><span>|</span><label class="collapse" for="c-36147077">[-]</label><label class="expand" for="c-36147077">[1 more]</label></div><br/><div class="children"><div class="content">How about <a href="https:&#x2F;&#x2F;github.com&#x2F;chatgp">https:&#x2F;&#x2F;github.com&#x2F;chatgp</a></div><br/></div></div><div id="36145716" class="c"><input type="checkbox" id="c-36145716" checked=""/><div class="controls bullet"><span class="by">Eduard</span><span>|</span><a href="#36144968">parent</a><span>|</span><a href="#36147077">prev</a><span>|</span><a href="#36147218">next</a><span>|</span><label class="collapse" for="c-36145716">[-]</label><label class="expand" for="c-36145716">[2 more]</label></div><br/><div class="children"><div class="content">The <a href="https:&#x2F;&#x2F;github.com&#x2F;OAI&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;OAI&#x2F;</a> Github group name is indeed deceptive.</div><br/><div id="36145894" class="c"><input type="checkbox" id="c-36145894" checked=""/><div class="controls bullet"><span class="by">samspenc</span><span>|</span><a href="#36144968">root</a><span>|</span><a href="#36145716">parent</a><span>|</span><a href="#36147218">next</a><span>|</span><label class="collapse" for="c-36145894">[-]</label><label class="expand" for="c-36145894">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if it was just a matter of them getting that GitHub handle way before OpenAI was a real thing.<p>Update: per Wikipedia, looks like OpenAPI was founded in 2010-11 so that would make sense <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;OpenAPI_Specification" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;OpenAPI_Specification</a></div><br/></div></div></div></div><div id="36147218" class="c"><input type="checkbox" id="c-36147218" checked=""/><div class="controls bullet"><span class="by">jsight</span><span>|</span><a href="#36144968">parent</a><span>|</span><a href="#36145716">prev</a><span>|</span><a href="#36145028">next</a><span>|</span><label class="collapse" for="c-36147218">[-]</label><label class="expand" for="c-36147218">[1 more]</label></div><br/><div class="children"><div class="content">I mean, chatgpt does a decent job of working with openapi docs.</div><br/></div></div><div id="36145028" class="c"><input type="checkbox" id="c-36145028" checked=""/><div class="controls bullet"><span class="by">__jonas</span><span>|</span><a href="#36144968">parent</a><span>|</span><a href="#36147218">prev</a><span>|</span><a href="#36145002">next</a><span>|</span><label class="collapse" for="c-36145028">[-]</label><label class="expand" for="c-36145028">[1 more]</label></div><br/><div class="children"><div class="content">you are not to be honest, and I work with Swagger APIs every day…</div><br/></div></div><div id="36145002" class="c"><input type="checkbox" id="c-36145002" checked=""/><div class="controls bullet"><span class="by">nvrmnd</span><span>|</span><a href="#36144968">parent</a><span>|</span><a href="#36145028">prev</a><span>|</span><a href="#36145015">next</a><span>|</span><label class="collapse" for="c-36145002">[-]</label><label class="expand" for="c-36145002">[1 more]</label></div><br/><div class="children"><div class="content">yes, I can confirm this.</div><br/></div></div></div></div><div id="36145015" class="c"><input type="checkbox" id="c-36145015" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#36144968">prev</a><span>|</span><a href="#36145150">next</a><span>|</span><label class="collapse" for="c-36145015">[-]</label><label class="expand" for="c-36145015">[2 more]</label></div><br/><div class="children"><div class="content">Hard not to have major WSDL flashbacks in the OpenAPI project I have running right now.  Between the lack of support for the latest OpenAPI to generated documentation in Sphinx, custom attributes needed for AWS API Gateway deployment, and the general grossness of adding the OPTIONS requests for CORS access, nothing has worked as easily as I would have thought it would.  Especially given so much of the hype.<p>Worse, too many of the client generation libraries all look to be abandoned.  With no real indication for me to know which would have a good future.</div><br/><div id="36147363" class="c"><input type="checkbox" id="c-36147363" checked=""/><div class="controls bullet"><span class="by">jjice</span><span>|</span><a href="#36145015">parent</a><span>|</span><a href="#36145150">next</a><span>|</span><label class="collapse" for="c-36147363">[-]</label><label class="expand" for="c-36147363">[1 more]</label></div><br/><div class="children"><div class="content">I consume WSDLs and produce OpenAPI very regularly and you&#x27;re very right that we&#x27;ve reinvented the wheel. On the bright side, REST APIs are much easier to work with ad hoc and Open API (not sure if this is really because of the format or we just care more now) often has better associated docs.</div><br/></div></div></div></div><div id="36145150" class="c"><input type="checkbox" id="c-36145150" checked=""/><div class="controls bullet"><span class="by">stickfigure</span><span>|</span><a href="#36145015">prev</a><span>|</span><a href="#36148537">next</a><span>|</span><label class="collapse" for="c-36145150">[-]</label><label class="expand" for="c-36145150">[2 more]</label></div><br/><div class="children"><div class="content">I just wish they&#x27;d stop using map keys. Use arrays:<p><pre><code>    paths:
      - name: &quot;speakers&quot;
        requests:
          - name: createSpeaker
            method: post
</code></pre>
This structure would have allowed adding request name to the schema without breaking everything.<p>This really goes for anyone building REST&#x2F;JSON APIs. Please avoid dynamic keys; whatever you think the &quot;primary key&quot; is today, it may be different tomorrow. Clients can easily hash an array of objects into a map if they need it.</div><br/><div id="36145262" class="c"><input type="checkbox" id="c-36145262" checked=""/><div class="controls bullet"><span class="by">echelon</span><span>|</span><a href="#36145150">parent</a><span>|</span><a href="#36148537">next</a><span>|</span><label class="collapse" for="c-36145262">[-]</label><label class="expand" for="c-36145262">[1 more]</label></div><br/><div class="children"><div class="content">Why not accept map keys as nullable similar to what non-required fields in protobuf do? Wouldn&#x27;t arrays open you up to duplication?<p>More broadly, I&#x27;m interested in sparse field updates vs. full payload updates and how each of these handle nullable &#x2F; emptyable fields. I haven&#x27;t seen any protocol or standard handle these well.</div><br/></div></div></div></div><div id="36148537" class="c"><input type="checkbox" id="c-36148537" checked=""/><div class="controls bullet"><span class="by">martypitt</span><span>|</span><a href="#36145150">prev</a><span>|</span><a href="#36146210">next</a><span>|</span><label class="collapse" for="c-36148537">[-]</label><label class="expand" for="c-36148537">[1 more]</label></div><br/><div class="children"><div class="content">One of the gripes I have about OpenAPI is that it has a very low signal-to-noise ratio.  It was bad in JSON, it&#x27;s just as bad in YAML, with an added whitespace pedantry.<p>It&#x27;s great to see a number of alternatives listed in this thread - there&#x27;s much more active development in this space then I was aware of, and I hope that some of it gets upstreamed back into OpenAPI.<p>I&#x27;ll shamelessly plug our tool in this space - Taxi (<a href="https:&#x2F;&#x2F;github.com&#x2F;taxilang&#x2F;taxilang">https:&#x2F;&#x2F;github.com&#x2F;taxilang&#x2F;taxilang</a>), which has a dedicated DSL (not YAML) you can either use standalone, or embeddedd within OpenAPI.<p>I also happen to think that (for internal teams at least), generating clients on ${apiSpec} is a form of tight coupling, where producer and consumer become tied together.  If you can avoid it, you should, as it allows producers and consumers to stay loosely coupled and evolve independetly without the gymnastics of avoiding breaking changes.<p>I&#x27;ve talked about this before, with proposed solutions.[0]<p>[0]<a href="https:&#x2F;&#x2F;orbitalhq.com&#x2F;blog&#x2F;2023-01-16-using-semantic-metadata" rel="nofollow">https:&#x2F;&#x2F;orbitalhq.com&#x2F;blog&#x2F;2023-01-16-using-semantic-metadat...</a></div><br/></div></div><div id="36146210" class="c"><input type="checkbox" id="c-36146210" checked=""/><div class="controls bullet"><span class="by">bterlson</span><span>|</span><a href="#36148537">prev</a><span>|</span><a href="#36148369">next</a><span>|</span><label class="collapse" for="c-36146210">[-]</label><label class="expand" for="c-36146210">[5 more]</label></div><br/><div class="children"><div class="content">Since there&#x27;s a lot of show and tell going on, I&#x27;ll jump in too I suppose.<p>I work on a tool in this space called TypeSpec (aka.ms&#x2F;typespec) that aims to address some of the authoring concerns folks have with OpenAPI. We&#x27;re a language that feels a lot like TypeScript, with support for high-level features you might be used to in a more typical PL, but compiles to high quality OpenAPI 3.0 you can feed into your existing code&#x2F;docs generation pipeline. You can see this in action on our playground: <a href="https:&#x2F;&#x2F;cadlplayground.z22.web.core.windows.net" rel="nofollow">https:&#x2F;&#x2F;cadlplayground.z22.web.core.windows.net</a>. We also support protobuf and (once my PR gets merged) JSON Schema targets.<p>We&#x27;re not yet to beta (obviously, no website even) but we&#x27;re hoping to get there relatively soon. Happy to hear any thoughts, especially from folks using OpenAPI.</div><br/><div id="36147088" class="c"><input type="checkbox" id="c-36147088" checked=""/><div class="controls bullet"><span class="by">dcre</span><span>|</span><a href="#36146210">parent</a><span>|</span><a href="#36146886">next</a><span>|</span><label class="collapse" for="c-36147088">[-]</label><label class="expand" for="c-36147088">[2 more]</label></div><br/><div class="children"><div class="content">I looked through the docs and now I have a question! It seems like part of the advantage here is being able to represent things in the spec that OpenAPI might have a hard time with. For example, a ResultsPage&lt;T&gt; template represents structure that&#x27;s shared across a bunch of paginated endpoints regardless of the type of the items. In OpenAPI, each of those responses has to get its own type (ResultsPageA, ResultsPageB, etc.), and presumably in the generated OpenAPI spec, the fact of that shared structure must be lost, and therefore cannot be picked up by client generators that work on the OpenAPI spec.<p>How do you think about the relation to OpenAPI v3 (i.e., setting aside possible improvements in v4) — is the goal of TypeSpec to avoid doing things that are too far afield from what you can represent in OpenAPI, or is the OpenAPI thing more like a bridge to adoption so people can use their existing generators, but in the future you imagine people generating clients from TypeSpec directly?</div><br/><div id="36147392" class="c"><input type="checkbox" id="c-36147392" checked=""/><div class="controls bullet"><span class="by">bterlson</span><span>|</span><a href="#36146210">root</a><span>|</span><a href="#36147088">parent</a><span>|</span><a href="#36146886">next</a><span>|</span><label class="collapse" for="c-36147392">[-]</label><label class="expand" for="c-36147392">[1 more]</label></div><br/><div class="children"><div class="content">This is a great question. We think OpenAPI is great and TypeSpec is a great way to write OpenAPI, but OpenAPI has some challenges generating high quality, language ideomatic code for complex services. Generating code straight from TypeSpec can drive better codegen in some cases such as the one you mention, especially when combined with custom libraries and emitters. Incidentally, this is how we are creating many client libraries for Azure services.<p>That said, these are not opposing choices really, or a bridge to anything. OpenAPI works great for probably most http services, has a huge ecosystem, and enjoys wide support across the industry so I&#x27;d expect many folks to continue to leverage our OpenAPI emitter to take advantage of that.<p>In general we don&#x27;t limit ourselves to things which can be trivially compiled to OpenAPI but try to be super general purpose. We support protobuf and intend to support more protocols going forward, and also have experimented with generating other things like JSON RPC, ORMs, db migrations, etc.</div><br/></div></div></div></div><div id="36146886" class="c"><input type="checkbox" id="c-36146886" checked=""/><div class="controls bullet"><span class="by">dcre</span><span>|</span><a href="#36146210">parent</a><span>|</span><a href="#36147088">prev</a><span>|</span><a href="#36148369">next</a><span>|</span><label class="collapse" for="c-36146886">[-]</label><label class="expand" for="c-36146886">[2 more]</label></div><br/><div class="children"><div class="content">This is great. After a couple of years fighting OpenAPI in various ways, I can definitely see the case for giving the spec its own proper language that’s not JSON. Seems inspired by GraphQL’s really nice specs (IMO the only nice thing about GraphQL).</div><br/><div id="36146973" class="c"><input type="checkbox" id="c-36146973" checked=""/><div class="controls bullet"><span class="by">bterlson</span><span>|</span><a href="#36146210">root</a><span>|</span><a href="#36146886">parent</a><span>|</span><a href="#36148369">next</a><span>|</span><label class="collapse" for="c-36146973">[-]</label><label class="expand" for="c-36146973">[1 more]</label></div><br/><div class="children"><div class="content">Thank you! We take most of our inspiration from TypeScript and sometimes C#, but I agree that gql demonstrates the value of terse, highly readable specs quite nicely.</div><br/></div></div></div></div></div></div><div id="36148369" class="c"><input type="checkbox" id="c-36148369" checked=""/><div class="controls bullet"><span class="by">koreth1</span><span>|</span><a href="#36146210">prev</a><span>|</span><a href="#36148638">next</a><span>|</span><label class="collapse" for="c-36148369">[-]</label><label class="expand" for="c-36148369">[1 more]</label></div><br/><div class="children"><div class="content">The projects I work on generate OpenAPI docs at runtime based on annotations in the server source code, so they&#x27;re always guaranteed to be in sync with the actual API. We&#x27;ve had to add some custom logic to clean things up a bit (e.g., in places where we have custom JSON serialization logic) but luckily the library we&#x27;re using has hooks for that purpose and it hasn&#x27;t been a huge pain point.<p>But like others have said, the client code generators leave a lot to be desired. For example, I have yet to find one that properly deals with recursive data structures like an arbitrarily-nested tree structure with multiple node types. Several of them just flat-out crash, and the ones that don&#x27;t generate code that won&#x27;t compile or that bombs out. We&#x27;ve had to resort to hacks like tagging the recursive structures&#x27; descriptions with magic keywords that trigger a postprocessing step to fix up the generated code.<p>But I don&#x27;t really view this as a problem with OpenAPI per se. The data structures in question can be correctly and unambiguously described in the OpenAPI JSON document.</div><br/></div></div><div id="36148638" class="c"><input type="checkbox" id="c-36148638" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#36148369">prev</a><span>|</span><a href="#36146475">next</a><span>|</span><label class="collapse" for="c-36148638">[-]</label><label class="expand" for="c-36148638">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve found OpenAPI to be fine to work with until you start trying to do really silly things with query parameters or multipart bodies, etc.<p>I can understand why OpenAPI has those issues though - it is because OpenAPI is aiming to DOCUMENT APIs rather than SPECIFY them. That is a hard task given how wide a set of things you can do with HTTP.<p>So be charitable when comparing OpenAPI to XYZ API specification tool.</div><br/></div></div><div id="36146475" class="c"><input type="checkbox" id="c-36146475" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#36148638">prev</a><span>|</span><a href="#36147154">next</a><span>|</span><label class="collapse" for="c-36146475">[-]</label><label class="expand" for="c-36146475">[15 more]</label></div><br/><div class="children"><div class="content">The big weak point I&#x27;ve always seen in OpenAPI is that every change in the server needs to be mirrored in the spec. This opens up a lot of surface area for mistakes.<p>What I really want is a way to generate clients from the <i>server source</i>. I realize that this would require a highly opinionated web server with strong typing on all endpoints, but that just sounds like extra value to me.<p>Are there any web frameworks that enable generating clients like this, whether through a generated OpenAPI spec or otherwise?</div><br/><div id="36147990" class="c"><input type="checkbox" id="c-36147990" checked=""/><div class="controls bullet"><span class="by">lyu07282</span><span>|</span><a href="#36146475">parent</a><span>|</span><a href="#36148330">next</a><span>|</span><label class="collapse" for="c-36147990">[-]</label><label class="expand" for="c-36147990">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Are there any web frameworks that enable generating clients like this, whether through a generated OpenAPI spec or otherwise?<p>I think perhaps you just never realized this has been common practice for a long time...<p>There are lots and lots of web service frameworks that do that: FastAPI in Python, Spring in Java, Play in Scala (iheartradio&#x2F;play-swagger), rocket&#x2F;okapi in Rust, many many more. You just need some introspection it&#x27;s not a difficult thing to do.</div><br/></div></div><div id="36148330" class="c"><input type="checkbox" id="c-36148330" checked=""/><div class="controls bullet"><span class="by">tkfu</span><span>|</span><a href="#36146475">parent</a><span>|</span><a href="#36147990">prev</a><span>|</span><a href="#36146667">next</a><span>|</span><label class="collapse" for="c-36148330">[-]</label><label class="expand" for="c-36148330">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;re using tapir (<a href="https:&#x2F;&#x2F;tapir.softwaremill.com&#x2F;en&#x2F;latest&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tapir.softwaremill.com&#x2F;en&#x2F;latest&#x2F;</a>), and are pretty happy with it.</div><br/></div></div><div id="36146667" class="c"><input type="checkbox" id="c-36146667" checked=""/><div class="controls bullet"><span class="by">oddevan</span><span>|</span><a href="#36146475">parent</a><span>|</span><a href="#36148330">prev</a><span>|</span><a href="#36148167">next</a><span>|</span><label class="collapse" for="c-36146667">[-]</label><label class="expand" for="c-36146667">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m trying to go in this direction with an API I&#x27;m building at the moment in PHP: <a href="https:&#x2F;&#x2F;github.com&#x2F;smolblog&#x2F;smolblog-core&#x2F;tree&#x2F;feature&#x2F;api-buildout&#x2F;src&#x2F;Api">https:&#x2F;&#x2F;github.com&#x2F;smolblog&#x2F;smolblog-core&#x2F;tree&#x2F;feature&#x2F;api-b...</a> It uses a combination of definition-in-code (also used to translate the endpoint classes to the outside framework), reflection, and PHP annotations to generate the OpenAPI spec which I&#x27;m loading into Swagger to do testing.</div><br/></div></div><div id="36148167" class="c"><input type="checkbox" id="c-36148167" checked=""/><div class="controls bullet"><span class="by">ssijak</span><span>|</span><a href="#36146475">parent</a><span>|</span><a href="#36146667">prev</a><span>|</span><a href="#36146899">next</a><span>|</span><label class="collapse" for="c-36148167">[-]</label><label class="expand" for="c-36148167">[1 more]</label></div><br/><div class="children"><div class="content">Something like:<p><a href="https:&#x2F;&#x2F;ts-rest.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ts-rest.com&#x2F;</a><p>or <a href="https:&#x2F;&#x2F;github.com&#x2F;sukovanej&#x2F;effect-http">https:&#x2F;&#x2F;github.com&#x2F;sukovanej&#x2F;effect-http</a> ?<p>there are several others in TS world.</div><br/></div></div><div id="36146899" class="c"><input type="checkbox" id="c-36146899" checked=""/><div class="controls bullet"><span class="by">dcre</span><span>|</span><a href="#36146475">parent</a><span>|</span><a href="#36148167">prev</a><span>|</span><a href="#36147112">next</a><span>|</span><label class="collapse" for="c-36146899">[-]</label><label class="expand" for="c-36146899">[1 more]</label></div><br/><div class="children"><div class="content">Plenty of frameworks let you generate the spec from your server code. Nest.js is one off the top of my head. Generate the spec from your server code, version it in-repo, and write a test to run in CI that makes sure the spec is up to date with the code.</div><br/></div></div><div id="36147112" class="c"><input type="checkbox" id="c-36147112" checked=""/><div class="controls bullet"><span class="by">breul99</span><span>|</span><a href="#36146475">parent</a><span>|</span><a href="#36146899">prev</a><span>|</span><a href="#36146496">next</a><span>|</span><label class="collapse" for="c-36147112">[-]</label><label class="expand" for="c-36147112">[1 more]</label></div><br/><div class="children"><div class="content">There are various tools that will do some  of this, utoipa [1] for rust and 
play-swagger [2] for scala + play that I&#x27;ve used in the past and enjoyed. They generate a significant portion of your spec for you, then a client can be generated from the spec.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;juhaku&#x2F;utoipa">https:&#x2F;&#x2F;github.com&#x2F;juhaku&#x2F;utoipa</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;iheartradio&#x2F;play-swagger">https:&#x2F;&#x2F;github.com&#x2F;iheartradio&#x2F;play-swagger</a></div><br/></div></div><div id="36146496" class="c"><input type="checkbox" id="c-36146496" checked=""/><div class="controls bullet"><span class="by">arcanemachiner</span><span>|</span><a href="#36146475">parent</a><span>|</span><a href="#36147112">prev</a><span>|</span><a href="#36146554">next</a><span>|</span><label class="collapse" for="c-36146496">[-]</label><label class="expand" for="c-36146496">[2 more]</label></div><br/><div class="children"><div class="content">Django Rest Framework + drf-spectacular. It needs a couple tweaks here and there but it&#x27;s great.<p>Apparently django-ninja (a different REST framework for Django) also generates an OpenAPI spec but I haven&#x27;t tried it.</div><br/><div id="36146967" class="c"><input type="checkbox" id="c-36146967" checked=""/><div class="controls bullet"><span class="by">cachance</span><span>|</span><a href="#36146475">root</a><span>|</span><a href="#36146496">parent</a><span>|</span><a href="#36146554">next</a><span>|</span><label class="collapse" for="c-36146967">[-]</label><label class="expand" for="c-36146967">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve also had success with drf + drf-spectacular and then using the output OpenAPI spec to generate a typescript-react client with a third-party code generator.<p>It mostly just works, like you said, and almost acts as a framework guardrail: if the inferred client types are comprehensive and unsurprising then the view tends to be concise; a wonky type indicates there may be something nonstandard in the view that could be fixed by cleaner framework-abiding code.</div><br/></div></div></div></div><div id="36146554" class="c"><input type="checkbox" id="c-36146554" checked=""/><div class="controls bullet"><span class="by">danappelxx</span><span>|</span><a href="#36146475">parent</a><span>|</span><a href="#36146496">prev</a><span>|</span><a href="#36146962">next</a><span>|</span><label class="collapse" for="c-36146554">[-]</label><label class="expand" for="c-36146554">[4 more]</label></div><br/><div class="children"><div class="content">I suspect OpenAPI advocates would argue you should start with the spec and use it to generate both the client and server. This is already a common pattern in other RPC definition languages such as gRPC. You _could_ write a server to match the gRPC spec, but why would you?</div><br/><div id="36148089" class="c"><input type="checkbox" id="c-36148089" checked=""/><div class="controls bullet"><span class="by">clintonb</span><span>|</span><a href="#36146475">root</a><span>|</span><a href="#36146554">parent</a><span>|</span><a href="#36146664">next</a><span>|</span><label class="collapse" for="c-36148089">[-]</label><label class="expand" for="c-36148089">[1 more]</label></div><br/><div class="children"><div class="content">Not sure if I’m an advocate, but definitely a fan. I use frameworks (e.g., Django REST Framework, Nest.js) to build the server and generate my OpenAPI spec. I find it faster than writing YAML&#x2F;JSON manually, and I end up with a half-working server at the end of it all.</div><br/></div></div><div id="36146664" class="c"><input type="checkbox" id="c-36146664" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#36146475">root</a><span>|</span><a href="#36146554">parent</a><span>|</span><a href="#36148089">prev</a><span>|</span><a href="#36146962">next</a><span>|</span><label class="collapse" for="c-36146664">[-]</label><label class="expand" for="c-36146664">[2 more]</label></div><br/><div class="children"><div class="content">That works great if you&#x27;re starting from scratch, but not so much if you&#x27;re on a brownfield project. The way the generators are written, even generating a new endpoint can&#x27;t be done after code has been written because it generates a whole file with route stubs.</div><br/><div id="36147095" class="c"><input type="checkbox" id="c-36147095" checked=""/><div class="controls bullet"><span class="by">danappelxx</span><span>|</span><a href="#36146475">root</a><span>|</span><a href="#36146664">parent</a><span>|</span><a href="#36146962">next</a><span>|</span><label class="collapse" for="c-36147095">[-]</label><label class="expand" for="c-36147095">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, but if you’re asking for a solution that will generate a spec from your code, the more proven path is to generate code from a spec. Gives you more and costs less.<p>In my opinion the problem is that there’s some APIs that are impossible to represent with OpenAPI — that’s the real challenge they should be solving with this version, not reducing spec line count.</div><br/></div></div></div></div></div></div><div id="36146962" class="c"><input type="checkbox" id="c-36146962" checked=""/><div class="controls bullet"><span class="by">doublerebel</span><span>|</span><a href="#36146475">parent</a><span>|</span><a href="#36146554">prev</a><span>|</span><a href="#36146490">next</a><span>|</span><label class="collapse" for="c-36146962">[-]</label><label class="expand" for="c-36146962">[1 more]</label></div><br/><div class="children"><div class="content">In addition to the many other solutions mentioned, Cloudflare can export an OpenAPI spec from the proxied traffic.<p>Optic&#x2F;UseOptic does a similar traffic watch and spec export from local builds.</div><br/></div></div></div></div><div id="36147154" class="c"><input type="checkbox" id="c-36147154" checked=""/><div class="controls bullet"><span class="by">denkmoon</span><span>|</span><a href="#36146475">prev</a><span>|</span><a href="#36147645">next</a><span>|</span><label class="collapse" for="c-36147154">[-]</label><label class="expand" for="c-36147154">[2 more]</label></div><br/><div class="children"><div class="content">Every time I try to use an OpenAPI document to generate client code, it fails, I talk to the customer and they say &quot;oh no don&#x27;t do that, it&#x27;s not meant for generating code from&quot;. Not an indictment on OpenAPI but it&#x27;s truly bizarre how people use it.</div><br/><div id="36148070" class="c"><input type="checkbox" id="c-36148070" checked=""/><div class="controls bullet"><span class="by">clintonb</span><span>|</span><a href="#36147154">parent</a><span>|</span><a href="#36147645">next</a><span>|</span><label class="collapse" for="c-36148070">[-]</label><label class="expand" for="c-36148070">[1 more]</label></div><br/><div class="children"><div class="content">I’m working with a spec that used GUIDs for their operation IDs. This limits TypeScript code generation to typescript-node, which prepends an underscore on the method names. Otherwise, those starting with numbers would be invalid.</div><br/></div></div></div></div><div id="36147645" class="c"><input type="checkbox" id="c-36147645" checked=""/><div class="controls bullet"><span class="by">seer</span><span>|</span><a href="#36147154">prev</a><span>|</span><a href="#36148299">next</a><span>|</span><label class="collapse" for="c-36147645">[-]</label><label class="expand" for="c-36147645">[2 more]</label></div><br/><div class="children"><div class="content">&gt; A side effect of giving names to requests and responses is that it makes the predictions from AIs like GitHub Copilot significantly more effective.<p>Hmm first time I see an api try to cator to AI tools rather than the other way around, feels like we’ve turned a corner for AI tools. Wonder what will happen when we start to design code &#x2F; libraries &#x2F; languages with this in mind.<p>I have a feeling there will be a “designed for ai” language that is going to sweep our industry, maybe turn the languages of today in the same place as assembly&#x2F;forth - nice for some specific applications, but not mainstream…</div><br/><div id="36147662" class="c"><input type="checkbox" id="c-36147662" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#36147645">parent</a><span>|</span><a href="#36148299">next</a><span>|</span><label class="collapse" for="c-36147662">[-]</label><label class="expand" for="c-36147662">[1 more]</label></div><br/><div class="children"><div class="content">I’ve thought of this as well. Maybe even inline assembly which might actually be something like JS&#x2F;python&#x2F;rust. It might look like inline SQL does now.</div><br/></div></div></div></div><div id="36148299" class="c"><input type="checkbox" id="c-36148299" checked=""/><div class="controls bullet"><span class="by">RamblingCTO</span><span>|</span><a href="#36147645">prev</a><span>|</span><a href="#36146267">next</a><span>|</span><label class="collapse" for="c-36148299">[-]</label><label class="expand" for="c-36148299">[1 more]</label></div><br/><div class="children"><div class="content">I was always a big proponent of openAPI. But the reality is: the client generators are often times lacking, spewing out shitty code with ages old dependencies. You sometimes have to make weird mental acrobatics to get your API reality modelled.<p>Then, not directly related, you have the problem of each service having to have their own client. Maintenance doubles.<p>We&#x27;re going down the graphQL federation with &quot;one graph&quot; for backend services path now. Surely not a holy grail but way better than openAPI.</div><br/></div></div><div id="36146267" class="c"><input type="checkbox" id="c-36146267" checked=""/><div class="controls bullet"><span class="by">ohnoesjmr</span><span>|</span><a href="#36148299">prev</a><span>|</span><a href="#36145737">next</a><span>|</span><label class="collapse" for="c-36146267">[-]</label><label class="expand" for="c-36146267">[1 more]</label></div><br/><div class="children"><div class="content">Maybe its just me, but I&#x27;d always pick gRPC, a lot less headaches than the community (un)maintained codegen for some random language.</div><br/></div></div><div id="36145737" class="c"><input type="checkbox" id="c-36145737" checked=""/><div class="controls bullet"><span class="by">dandevs</span><span>|</span><a href="#36146267">prev</a><span>|</span><a href="#36146395">next</a><span>|</span><label class="collapse" for="c-36145737">[-]</label><label class="expand" for="c-36145737">[1 more]</label></div><br/><div class="children"><div class="content">While I have many thoughts about OpenAPI&#x27;s ease-of-use and readability, I&#x27;m going to focus my commentary on the proposal at hand.<p>1. &quot;The primary goal of this proposal for a major new version of OpenAPI is to make it more approachable in order.&quot;
-&gt; This is a sound objective. I&#x27;m glad to see less nested structures that will improve readability. It&#x27;ll make it easier to scroll the JSON&#x2F;YAML and follow the logic.<p>2. &quot;OpenAPI has become the defacto standard for API descriptions.&quot;
-&gt; With OpenAI&#x27;s choice to pick OpenAPI as the standard for ChatGPT plugins, this is more true than ever. It&#x27;s great to see that now giving names to responses will make it easier for AIs (i.e., ChatGPT, Copilot) to call an API more accurately.<p>3. No mention of improving the quality of codegen (e.g., client libs, server stubs). Surprised that Moonwalk is silent on this topic.</div><br/></div></div><div id="36146395" class="c"><input type="checkbox" id="c-36146395" checked=""/><div class="controls bullet"><span class="by">addcn</span><span>|</span><a href="#36145737">prev</a><span>|</span><a href="#36146088">next</a><span>|</span><label class="collapse" for="c-36146395">[-]</label><label class="expand" for="c-36146395">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think a new spec is going to make it easier for more teams to use OpenAPI. This isn’t the problem…<p>What we really need is better tooling to help developers maintain the spec and built generators on top of it.<p>I’ve been building open source API version control tools built on top of OpenAPI. It’s an easy way to keep your spec up-to-date just by looking at test traffic. If it detects a diff, it will update the OpenAPI sort of like a snapshot test. <a href="https:&#x2F;&#x2F;www.useoptic.com&#x2F;cli">https:&#x2F;&#x2F;www.useoptic.com&#x2F;cli</a></div><br/></div></div><div id="36146088" class="c"><input type="checkbox" id="c-36146088" checked=""/><div class="controls bullet"><span class="by">alpb</span><span>|</span><a href="#36146395">prev</a><span>|</span><a href="#36145429">next</a><span>|</span><label class="collapse" for="c-36146088">[-]</label><label class="expand" for="c-36146088">[2 more]</label></div><br/><div class="children"><div class="content">&gt; In this simple example, the moonwalk version has 20% less lines and one less level of indentation.<p>It doesn&#x27;t sounds like a notable change given a lot of OpenAPI specs are generated and not necessarily read by humans?</div><br/><div id="36147131" class="c"><input type="checkbox" id="c-36147131" checked=""/><div class="controls bullet"><span class="by">zeroimpl</span><span>|</span><a href="#36146088">parent</a><span>|</span><a href="#36145429">next</a><span>|</span><label class="collapse" for="c-36147131">[-]</label><label class="expand" for="c-36147131">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. I&#x27;m still using 2.0. I don&#x27;t write the JSON directly (except for the JSON Schema part), nor do I look at it directly. These major backwards-incompatible changes don&#x27;t seem like the right move to me, they fragment the tooling and make it difficult for a given library to support multiple versions.<p>This is almost like calling JSON as XML 2.0.</div><br/></div></div></div></div><div id="36145429" class="c"><input type="checkbox" id="c-36145429" checked=""/><div class="controls bullet"><span class="by">hahnbee</span><span>|</span><a href="#36146088">prev</a><span>|</span><a href="#36145616">next</a><span>|</span><label class="collapse" for="c-36145429">[-]</label><label class="expand" for="c-36145429">[4 more]</label></div><br/><div class="children"><div class="content">OpenAPI triggers me so much... It&#x27;s so painful to use.</div><br/><div id="36146377" class="c"><input type="checkbox" id="c-36146377" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#36145429">parent</a><span>|</span><a href="#36145764">next</a><span>|</span><label class="collapse" for="c-36146377">[-]</label><label class="expand" for="c-36146377">[1 more]</label></div><br/><div class="children"><div class="content">My experience has been the opposite: I&#x27;ve much much much preferred it over the tedium and error-prone-ness of manually writing API clients and server routes.</div><br/></div></div><div id="36145764" class="c"><input type="checkbox" id="c-36145764" checked=""/><div class="controls bullet"><span class="by">dandevs</span><span>|</span><a href="#36145429">parent</a><span>|</span><a href="#36146377">prev</a><span>|</span><a href="#36145433">next</a><span>|</span><label class="collapse" for="c-36145764">[-]</label><label class="expand" for="c-36145764">[1 more]</label></div><br/><div class="children"><div class="content">I feel like this line in the Moonwalk proposal was written for you! &quot;Deep nesting can become unnecessarily cumbersome for reading and writing OpenAPI descriptions.&quot;</div><br/></div></div><div id="36145433" class="c"><input type="checkbox" id="c-36145433" checked=""/><div class="controls bullet"><span class="by">hahnbee</span><span>|</span><a href="#36145429">parent</a><span>|</span><a href="#36145764">prev</a><span>|</span><a href="#36145616">next</a><span>|</span><label class="collapse" for="c-36145433">[-]</label><label class="expand" for="c-36145433">[1 more]</label></div><br/><div class="children"><div class="content">of course im glad they are putting in efforts to improve it though :)</div><br/></div></div></div></div><div id="36145616" class="c"><input type="checkbox" id="c-36145616" checked=""/><div class="controls bullet"><span class="by">cassepipe</span><span>|</span><a href="#36145429">prev</a><span>|</span><a href="#36148010">next</a><span>|</span><label class="collapse" for="c-36145616">[-]</label><label class="expand" for="c-36145616">[1 more]</label></div><br/><div class="children"><div class="content">I recently stumbled upon ts-rest which is a contract library, you create a with subcontracts from which you can derive clients which each have their methods, I personally think it&#x27;s easier and less work that generating clients methods<p>Sorry if that&#x27;s not very clear, better read : <a href="https:&#x2F;&#x2F;ts-rest.com&#x2F;docs&#x2F;intro" rel="nofollow">https:&#x2F;&#x2F;ts-rest.com&#x2F;docs&#x2F;intro</a><p>Also, it integrates well with OpenAPI to document the API<p>I am using it between NestJs and SvelteKit and it&#x27;s great</div><br/></div></div><div id="36148010" class="c"><input type="checkbox" id="c-36148010" checked=""/><div class="controls bullet"><span class="by">wiremock</span><span>|</span><a href="#36145616">prev</a><span>|</span><a href="#36146878">next</a><span>|</span><label class="collapse" for="c-36148010">[-]</label><label class="expand" for="c-36148010">[1 more]</label></div><br/><div class="children"><div class="content">We follow the Moonwalk project in WireMock, because the new features clearly provide some opportunities for better API integration testing and request&#x2F;response validation that us now embedded in WireMock 3 Beta.<p>Our TL;DR: the standard looks interesting, the developer tools need a lot of love. The whole world is using JSON&#x2F;YAML these days, but developer experience for JSON Schema is lightyears behind &quot;legacy&quot; XSD</div><br/></div></div><div id="36145647" class="c"><input type="checkbox" id="c-36145647" checked=""/><div class="controls bullet"><span class="by">iron-s</span><span>|</span><a href="#36146878">prev</a><span>|</span><a href="#36145093">next</a><span>|</span><label class="collapse" for="c-36145647">[-]</label><label class="expand" for="c-36145647">[1 more]</label></div><br/><div class="children"><div class="content">Having full support for the uriTemplates makes reverse mapping impossible, so I suspect adoption of the proposal in the API gateways will be close to 0</div><br/></div></div><div id="36145093" class="c"><input type="checkbox" id="c-36145093" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#36145647">prev</a><span>|</span><a href="#36146058">next</a><span>|</span><label class="collapse" for="c-36145093">[-]</label><label class="expand" for="c-36145093">[7 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    pathResponses:
      notFound:
        status: 404
        contentType: application&#x2F;http-problem
    apiResponses:
      serverError:
        status: 5XX
        contentType: application&#x2F;http-problem

</code></pre>
Can&#x27;t stuff like this be implicit rather than needing to be defined?   Or, to say it another way, we&#x27;re building this over HTTP, which already defines these things and many others.</div><br/><div id="36145184" class="c"><input type="checkbox" id="c-36145184" checked=""/><div class="controls bullet"><span class="by">junto</span><span>|</span><a href="#36145093">parent</a><span>|</span><a href="#36145166">next</a><span>|</span><label class="collapse" for="c-36145184">[-]</label><label class="expand" for="c-36145184">[2 more]</label></div><br/><div class="children"><div class="content">It’s explicit in the responses you should expect for a given request, versus what you should expect. For example if the specification defined that a 404 is a valid use case then null or empty list is not considered an exception, but if it isn’t defined in the spec and you receive a 404 unexpectedly, then you can treat it as an exception rather than a valid response.</div><br/><div id="36145870" class="c"><input type="checkbox" id="c-36145870" checked=""/><div class="controls bullet"><span class="by">cies</span><span>|</span><a href="#36145093">root</a><span>|</span><a href="#36145184">parent</a><span>|</span><a href="#36145166">next</a><span>|</span><label class="collapse" for="c-36145870">[-]</label><label class="expand" for="c-36145870">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. Also you want to be able to give, for instance, 400s a body that&#x27;s JSON schema&#x27;d</div><br/></div></div></div></div><div id="36145166" class="c"><input type="checkbox" id="c-36145166" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#36145093">parent</a><span>|</span><a href="#36145184">prev</a><span>|</span><a href="#36145335">next</a><span>|</span><label class="collapse" for="c-36145166">[-]</label><label class="expand" for="c-36145166">[2 more]</label></div><br/><div class="children"><div class="content">Ugh, or try having a mostly common response with just a slight mutation (eg the data is array of Company rather than Contact). Verbose for what could be a &quot;mixing&quot; or &quot;sub-class&quot; or something.</div><br/><div id="36146380" class="c"><input type="checkbox" id="c-36146380" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#36145093">root</a><span>|</span><a href="#36145166">parent</a><span>|</span><a href="#36145335">next</a><span>|</span><label class="collapse" for="c-36146380">[-]</label><label class="expand" for="c-36146380">[1 more]</label></div><br/><div class="children"><div class="content">OpenAPI does support &quot;subclassing&quot; via allOf and oneOf.</div><br/></div></div></div></div><div id="36145335" class="c"><input type="checkbox" id="c-36145335" checked=""/><div class="controls bullet"><span class="by">contravariant</span><span>|</span><a href="#36145093">parent</a><span>|</span><a href="#36145166">prev</a><span>|</span><a href="#36146058">next</a><span>|</span><label class="collapse" for="c-36145335">[-]</label><label class="expand" for="c-36145335">[2 more]</label></div><br/><div class="children"><div class="content">This way you can provide a schema for the error such that a client can parse the response. It makes sense for an API schema to include it.</div><br/><div id="36145804" class="c"><input type="checkbox" id="c-36145804" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#36145093">root</a><span>|</span><a href="#36145335">parent</a><span>|</span><a href="#36146058">next</a><span>|</span><label class="collapse" for="c-36145804">[-]</label><label class="expand" for="c-36145804">[1 more]</label></div><br/><div class="children"><div class="content">This. And it may not be immediately obvious if you’re not familiar with RFC 7807, but in the example the responses’ content types specify their schema.</div><br/></div></div></div></div></div></div><div id="36146058" class="c"><input type="checkbox" id="c-36146058" checked=""/><div class="controls bullet"><span class="by">gibsonf1</span><span>|</span><a href="#36145093">prev</a><span>|</span><a href="#36145022">next</a><span>|</span><label class="collapse" for="c-36146058">[-]</label><label class="expand" for="c-36146058">[1 more]</label></div><br/><div class="children"><div class="content">I recommend <a href="https:&#x2F;&#x2F;solidproject.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;solidproject.org&#x2F;</a> for both data ownership&#x2F;control and global machine interoperability.</div><br/></div></div><div id="36145022" class="c"><input type="checkbox" id="c-36145022" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#36146058">prev</a><span>|</span><a href="#36144939">next</a><span>|</span><label class="collapse" for="c-36145022">[-]</label><label class="expand" for="c-36145022">[10 more]</label></div><br/><div class="children"><div class="content">I wish OpenAPI had a stronger mapping to typescript types.</div><br/><div id="36145932" class="c"><input type="checkbox" id="c-36145932" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#36145022">parent</a><span>|</span><a href="#36147360">next</a><span>|</span><label class="collapse" for="c-36145932">[-]</label><label class="expand" for="c-36145932">[2 more]</label></div><br/><div class="children"><div class="content">It’s definitely possible, with a (fair) bit of glue code.<p>In the past, I wrapped io-ts with OpenAPI docgen logic. This worked <i>great</i>: ~every network boundary type was defined once, providing runtime parse&#x2F;validation and serialization, inferred static types, and API documentation all at once.<p>Unfortunately I didn’t get permission to open source the solution. But if I ever get bandwidth to build its spiritual successor, I’ll tackle it from the opposite direction: the OpenAPI&#x2F;JSON Schema specs are very well suited to <i>define</i> the underlying primitives for a zod&#x2F;io-ts like solution. The great thing about inverting the direction is that it defers “generating” anything to the static type system, ie there’s much less surface area for the runtime and doc schemas to diverge.<p>It also provides opportunities to enrich static types with more information in a general way (eg “brand” a number with its valid range, or a string as a valid email address). This would allow the benefits of runtime checks at API boundaries to be treated as static checks internally without additional&#x2F;redundant internal runtime overhead.</div><br/><div id="36146569" class="c"><input type="checkbox" id="c-36146569" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#36145022">root</a><span>|</span><a href="#36145932">parent</a><span>|</span><a href="#36147360">next</a><span>|</span><label class="collapse" for="c-36146569">[-]</label><label class="expand" for="c-36146569">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been wanting to write a tool that takes in a open api spec and generates zod&#x2F;io-ts for a while now but I haven’t had the time. That sounds very useful though unfortunate you can’t open it up!</div><br/></div></div></div></div><div id="36147360" class="c"><input type="checkbox" id="c-36147360" checked=""/><div class="controls bullet"><span class="by">varanauskas</span><span>|</span><a href="#36145022">parent</a><span>|</span><a href="#36145932">prev</a><span>|</span><a href="#36146385">next</a><span>|</span><label class="collapse" for="c-36147360">[-]</label><label class="expand" for="c-36147360">[2 more]</label></div><br/><div class="children"><div class="content">I’m trying to achieve generator-less mapping from OpenAPI to Typescript types at <a href="https:&#x2F;&#x2F;github.com&#x2F;varanauskas&#x2F;oatx">https:&#x2F;&#x2F;github.com&#x2F;varanauskas&#x2F;oatx</a></div><br/><div id="36147681" class="c"><input type="checkbox" id="c-36147681" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#36145022">root</a><span>|</span><a href="#36147360">parent</a><span>|</span><a href="#36146385">next</a><span>|</span><label class="collapse" for="c-36147681">[-]</label><label class="expand" for="c-36147681">[1 more]</label></div><br/><div class="children"><div class="content">Nice! So this goes OpenAPI -&gt; JSON Schema -&gt; typescript?</div><br/></div></div></div></div><div id="36146385" class="c"><input type="checkbox" id="c-36146385" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#36145022">parent</a><span>|</span><a href="#36147360">prev</a><span>|</span><a href="#36145880">next</a><span>|</span><label class="collapse" for="c-36146385">[-]</label><label class="expand" for="c-36146385">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that more a function of the code generator you use, than the specification format itself?</div><br/></div></div><div id="36145880" class="c"><input type="checkbox" id="c-36145880" checked=""/><div class="controls bullet"><span class="by">theogravity</span><span>|</span><a href="#36145022">parent</a><span>|</span><a href="#36146385">prev</a><span>|</span><a href="#36148260">next</a><span>|</span><label class="collapse" for="c-36145880">[-]</label><label class="expand" for="c-36145880">[1 more]</label></div><br/><div class="children"><div class="content">This is a problem I also encountered. I created my own OpenAPI generator with hacks around the AST generation to support a field for specifying the TS type of the Request &#x2F; Response<p>If the spec supports a field to specify the type for a component, that would help a lot with static type generation.</div><br/></div></div><div id="36148260" class="c"><input type="checkbox" id="c-36148260" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#36145022">parent</a><span>|</span><a href="#36145880">prev</a><span>|</span><a href="#36145174">next</a><span>|</span><label class="collapse" for="c-36148260">[-]</label><label class="expand" for="c-36148260">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s possible to use Typescript Class to map to openapi spec.</div><br/></div></div><div id="36145174" class="c"><input type="checkbox" id="c-36145174" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#36145022">parent</a><span>|</span><a href="#36148260">prev</a><span>|</span><a href="#36145477">next</a><span>|</span><label class="collapse" for="c-36145174">[-]</label><label class="expand" for="c-36145174">[1 more]</label></div><br/><div class="children"><div class="content">Or let us describe an custom type (GUID&#x2F;ULID&#x2F;UUID)</div><br/></div></div><div id="36145477" class="c"><input type="checkbox" id="c-36145477" checked=""/><div class="controls bullet"><span class="by">adobrawy</span><span>|</span><a href="#36145022">parent</a><span>|</span><a href="#36145174">prev</a><span>|</span><a href="#36144939">next</a><span>|</span><label class="collapse" for="c-36145477">[-]</label><label class="expand" for="c-36145477">[1 more]</label></div><br/><div class="children"><div class="content">Do you mean TypeAPI?</div><br/></div></div></div></div><div id="36144939" class="c"><input type="checkbox" id="c-36144939" checked=""/><div class="controls bullet"><span class="by">gjvc</span><span>|</span><a href="#36145022">prev</a><span>|</span><a href="#36145204">next</a><span>|</span><label class="collapse" for="c-36144939">[-]</label><label class="expand" for="c-36144939">[1 more]</label></div><br/><div class="children"><div class="content"><i>In this simple example, the moonwalk version has 20% less lines and one less level of indentation.</i><p>and no different in understandability.</div><br/></div></div><div id="36145204" class="c"><input type="checkbox" id="c-36145204" checked=""/><div class="controls bullet"><span class="by">danappelxx</span><span>|</span><a href="#36144939">prev</a><span>|</span><a href="#36145812">next</a><span>|</span><label class="collapse" for="c-36145204">[-]</label><label class="expand" for="c-36145204">[2 more]</label></div><br/><div class="children"><div class="content">does it add support for streams?</div><br/><div id="36146128" class="c"><input type="checkbox" id="c-36146128" checked=""/><div class="controls bullet"><span class="by">myvoiceismypass</span><span>|</span><a href="#36145204">parent</a><span>|</span><a href="#36145812">next</a><span>|</span><label class="collapse" for="c-36146128">[-]</label><label class="expand" for="c-36146128">[1 more]</label></div><br/><div class="children"><div class="content">See <a href="https:&#x2F;&#x2F;www.asyncapi.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.asyncapi.com&#x2F;</a> for the equivalent event based spec &amp; tooling.</div><br/></div></div></div></div><div id="36145812" class="c"><input type="checkbox" id="c-36145812" checked=""/><div class="controls bullet"><span class="by">web3-is-a-scam</span><span>|</span><a href="#36145204">prev</a><span>|</span><label class="collapse" for="c-36145812">[-]</label><label class="expand" for="c-36145812">[2 more]</label></div><br/><div class="children"><div class="content">OpenAPI is so crap, it’s the main driving factor for adopting graphql in our organization.  Any time we need to go back and add or change existing non-graphql http apis…pulling teeth is preferable.</div><br/><div id="36145857" class="c"><input type="checkbox" id="c-36145857" checked=""/><div class="controls bullet"><span class="by">AndrewKemendo</span><span>|</span><a href="#36145812">parent</a><span>|</span><label class="collapse" for="c-36145857">[-]</label><label class="expand" for="c-36145857">[1 more]</label></div><br/><div class="children"><div class="content">Can you say what is so hard so we can know ahead of time the issues before running into them?</div><br/></div></div></div></div></div></div></div></div></div></body></html>