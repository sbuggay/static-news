<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1695200461593" as="style"/><link rel="stylesheet" href="styles.css?v=1695200461593"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://rachelbythebay.com/w/2023/09/19/badlib/">Add extra stuff to a “standard” encoding? Sure, why not</a> <span class="domain">(<a href="https://rachelbythebay.com">rachelbythebay.com</a>)</span></div><div class="subtext"><span>l0b0</span> | <span>51 comments</span></div><br/><div><div id="37580916" class="c"><input type="checkbox" id="c-37580916" checked=""/><div class="controls bullet"><span class="by">jimmytucson</span><span>|</span><a href="#37580519">next</a><span>|</span><label class="collapse" for="c-37580916">[-]</label><label class="expand" for="c-37580916">[8 more]</label></div><br/><div class="children"><div class="content">&gt; author decided it was a good idea to prepend the message with the message length encoded as a varint.<p>&gt; WHY? Oh, why?!<p>Uh oh. Is this my HN moment?<p>This is exactly how I implemented it at my company. We had to write many protobuf messages to one file in bulk (in parallel). I did a fair amount of research before designing this and didn’t find any standard for separating protobuf messages (in fact, found that there explicitly isn’t a standard in that protobuf doesn’t care). So I thought rather than using  some “special” control character, like a null byte, which would inevitably be not-so-special and collide with somebody else’s (like Schema Registry’s “magic byte”), I’d use something meaningful like the number of bytes the following record is.<p>As for why I chose varint instead of just picking an interger size, well for one I got nerd-sniped by varint encoding and thought it would be cool to try and implement it in Scala. Secondly, I thought if I chose a fixed size integer, no matter what size I pick, my users will always surprise me and exceed it at least once, and when that happens, kaboom! I wanted to future proof this without wasting 64 goddamn bytes in front of each message, and also I got nerd-sniped, OK?!?<p>Someone on my team recently shared one of these files outside the company and so I really hope she’s not talking about me but that’s a crazy coincidence if not!</div><br/><div id="37581066" class="c"><input type="checkbox" id="c-37581066" checked=""/><div class="controls bullet"><span class="by">pavlov</span><span>|</span><a href="#37580916">parent</a><span>|</span><a href="#37580965">next</a><span>|</span><label class="collapse" for="c-37581066">[-]</label><label class="expand" for="c-37581066">[3 more]</label></div><br/><div class="children"><div class="content"><i>&gt; “I wanted to future proof this without wasting 64 goddamn bytes in front of each message”</i><p>64 bytes would be a 512-bit integer. That seems like excessive future proofing for the length of any message that would be transmitted before the Sun runs out of fuel.</div><br/><div id="37581464" class="c"><input type="checkbox" id="c-37581464" checked=""/><div class="controls bullet"><span class="by">xlogout</span><span>|</span><a href="#37580916">root</a><span>|</span><a href="#37581066">parent</a><span>|</span><a href="#37580965">next</a><span>|</span><label class="collapse" for="c-37581464">[-]</label><label class="expand" for="c-37581464">[2 more]</label></div><br/><div class="children"><div class="content">Fun fact: just 103 more bits and it would be enough to address every point in the observable universe distinguishible by Planck length [1].<p>Not my thought originally, I heard it from somewhere else but can&#x27;t find it. Possibly from Foone Turing.<p>[1] <a href="https:&#x2F;&#x2F;www.wolframalpha.com&#x2F;input?i=log2%28+volume+of+universe+%2F+planck+length%5E3+%29" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.wolframalpha.com&#x2F;input?i=log2%28+volume+of+unive...</a></div><br/><div id="37581532" class="c"><input type="checkbox" id="c-37581532" checked=""/><div class="controls bullet"><span class="by">benj111</span><span>|</span><a href="#37580916">root</a><span>|</span><a href="#37581464">parent</a><span>|</span><a href="#37580965">next</a><span>|</span><label class="collapse" for="c-37581532">[-]</label><label class="expand" for="c-37581532">[1 more]</label></div><br/><div class="children"><div class="content">Tbf though, I&#x27;m sure the number of cat pics floating about the internet dwarfs this number, so it depends on the data I suppose.<p>Plus rather simple things like pi could create rather a long message.</div><br/></div></div></div></div></div></div><div id="37580965" class="c"><input type="checkbox" id="c-37580965" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37580916">parent</a><span>|</span><a href="#37581066">prev</a><span>|</span><a href="#37581365">next</a><span>|</span><label class="collapse" for="c-37580965">[-]</label><label class="expand" for="c-37580965">[1 more]</label></div><br/><div class="children"><div class="content">You can also define a wrapper message with a single repeated field. The resulting encoding would be `varint(field id * 8 + 1) varint(length)` plus the actual message, so it can be also easily generated from and parsed back into a raw byte sequence without protoc.</div><br/></div></div><div id="37581365" class="c"><input type="checkbox" id="c-37581365" checked=""/><div class="controls bullet"><span class="by">NavinF</span><span>|</span><a href="#37580916">parent</a><span>|</span><a href="#37580965">prev</a><span>|</span><a href="#37581629">next</a><span>|</span><label class="collapse" for="c-37581365">[-]</label><label class="expand" for="c-37581365">[2 more]</label></div><br/><div class="children"><div class="content">&gt; didn’t find any standard for separating protobuf messages<p>The fact that protobufs are not self-delimiting is an endless source of frustration, but I know of 2 standards for doing this:<p>- SerializeDelimited* is part of the protobuf library: <a href="https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;blob&#x2F;main&#x2F;src&#x2F;google&#x2F;protobuf&#x2F;util&#x2F;delimited_message_util.cc">https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;blob&#x2F;main&#x2F;src&#x2F;go...</a><p>- Riegeli is &quot;a file format for storing a sequence of string records, typically serialized protocol buffers. It supports dense compression, fast decoding, seeking, detection and optional skipping of data corruption, filtering of proto message fields for even faster decoding, and parallel encoding&quot;: <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;riegeli">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;riegeli</a></div><br/><div id="37581615" class="c"><input type="checkbox" id="c-37581615" checked=""/><div class="controls bullet"><span class="by">harvie</span><span>|</span><a href="#37580916">root</a><span>|</span><a href="#37581365">parent</a><span>|</span><a href="#37581629">next</a><span>|</span><label class="collapse" for="c-37581615">[-]</label><label class="expand" for="c-37581615">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;msgpack.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;msgpack.org&#x2F;</a></div><br/></div></div></div></div><div id="37581629" class="c"><input type="checkbox" id="c-37581629" checked=""/><div class="controls bullet"><span class="by">blauditore</span><span>|</span><a href="#37580916">parent</a><span>|</span><a href="#37581365">prev</a><span>|</span><a href="#37580519">next</a><span>|</span><label class="collapse" for="c-37581629">[-]</label><label class="expand" for="c-37581629">[1 more]</label></div><br/><div class="children"><div class="content">Prepending the message with a delimiter (size varint) is pretty common, even part of the reference Java implementation: <a href="https:&#x2F;&#x2F;protobuf.dev&#x2F;reference&#x2F;java&#x2F;api-docs&#x2F;com&#x2F;google&#x2F;protobuf&#x2F;MessageLite.html#writeDelimitedTo-java.io.OutputStream-" rel="nofollow noreferrer">https:&#x2F;&#x2F;protobuf.dev&#x2F;reference&#x2F;java&#x2F;api-docs&#x2F;com&#x2F;google&#x2F;prot...</a></div><br/></div></div></div></div><div id="37580519" class="c"><input type="checkbox" id="c-37580519" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37580916">prev</a><span>|</span><a href="#37580625">next</a><span>|</span><label class="collapse" for="c-37580519">[-]</label><label class="expand" for="c-37580519">[3 more]</label></div><br/><div class="children"><div class="content">I actually went through all projects listed in [1] because I remember this very quirk. It turns out that there are many such libraries that have two variants of encode&#x2F;decode functions, where the second variant prepends a varint length. In my brief inspection there do exist a few libraries with only the second variant (e.g. Rust quick-protobuf), which is legitimately problematic [2].<p>But if the project in question was indeed protobuf.js (see loeg&#x27;s comments), it clearly distinguishes encode&#x2F;decode vs. encodeDelimited&#x2F;decodeDelimited. So I believe the project should not be blamed, and the better question would be why so many people chose to add this exact helper. Well, because Google itself also had the same helper [3] [4]! So at this point protobuf should just standardize this simple framing format [5], instead of claiming that protobuf has no obligation to define one.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;blob&#x2F;main&#x2F;docs&#x2F;third_party.md">https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;blob&#x2F;main&#x2F;docs&#x2F;t...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;tafia&#x2F;quick-protobuf&#x2F;issues&#x2F;130">https:&#x2F;&#x2F;github.com&#x2F;tafia&#x2F;quick-protobuf&#x2F;issues&#x2F;130</a><p>[3] <a href="https:&#x2F;&#x2F;protobuf.dev&#x2F;reference&#x2F;java&#x2F;api-docs&#x2F;com&#x2F;google&#x2F;protobuf&#x2F;MessageLite#writeDelimitedTo-java.io.OutputStream-" rel="nofollow noreferrer">https:&#x2F;&#x2F;protobuf.dev&#x2F;reference&#x2F;java&#x2F;api-docs&#x2F;com&#x2F;google&#x2F;prot...</a><p>[4] <a href="https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;blob&#x2F;main&#x2F;src&#x2F;google&#x2F;protobuf&#x2F;util&#x2F;delimited_message_util.cc">https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;blob&#x2F;main&#x2F;src&#x2F;go...</a><p>[5] Use an explicitly different name though, so that the meaning of &quot;encoding&#x2F;decoding protobuf messages&quot; doesn&#x27;t change.</div><br/><div id="37580737" class="c"><input type="checkbox" id="c-37580737" checked=""/><div class="controls bullet"><span class="by">cowsandmilk</span><span>|</span><a href="#37580519">parent</a><span>|</span><a href="#37580625">next</a><span>|</span><label class="collapse" for="c-37580737">[-]</label><label class="expand" for="c-37580737">[2 more]</label></div><br/><div class="children"><div class="content">Yep, and this variant to the encoding is documented at <a href="https:&#x2F;&#x2F;protobuf.dev&#x2F;programming-guides&#x2F;techniques&#x2F;#streaming" rel="nofollow noreferrer">https:&#x2F;&#x2F;protobuf.dev&#x2F;programming-guides&#x2F;techniques&#x2F;#streamin...</a><p>Definitely seems to be a routine addition to the standard supported by many libraries.</div><br/><div id="37580760" class="c"><input type="checkbox" id="c-37580760" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37580519">root</a><span>|</span><a href="#37580737">parent</a><span>|</span><a href="#37580625">next</a><span>|</span><label class="collapse" for="c-37580760">[-]</label><label class="expand" for="c-37580760">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Yep, and this variant to the encoding is documented at [...]<p>It only suggests the length prefix and doesn&#x27;t define the exact encoding at all.</div><br/></div></div></div></div></div></div><div id="37580625" class="c"><input type="checkbox" id="c-37580625" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#37580519">prev</a><span>|</span><a href="#37581769">next</a><span>|</span><label class="collapse" for="c-37580625">[-]</label><label class="expand" for="c-37580625">[17 more]</label></div><br/><div class="children"><div class="content">Stepping up an abstraction level in this discussion...does anyone have any insight into _why_ an encoding format wouldn&#x27;t want to have length prefixes standardized as part of the expected header of a message? From what I can tell, there isn&#x27;t a strong argument against it; assuming you&#x27;re comfortable with limiting messages to under 2^32 bits, prefixing an unsigned length should only take four bytes per message, which doesn&#x27;t seem like it would ever be a bottleneck, and it allows the receiving side of a message to know up front exactly how much memory to allocate, and it makes it much easier to write correct parsing code that also handles edge cases (e.g. making it obvious to explicitly handle a message that&#x27;s much larger than the amount of memory you&#x27;re willing to allocate). The fact that there are formats out there that don&#x27;t mandate length prefixing makes me think I might be missing something though, so I&#x27;d be interested to hear counterarguments.</div><br/><div id="37580717" class="c"><input type="checkbox" id="c-37580717" checked=""/><div class="controls bullet"><span class="by">gizmo686</span><span>|</span><a href="#37580625">parent</a><span>|</span><a href="#37581721">next</a><span>|</span><label class="collapse" for="c-37580717">[-]</label><label class="expand" for="c-37580717">[6 more]</label></div><br/><div class="children"><div class="content">In general, the issue is with composition. Your full message is someone else field. Having a header that only occurs in message initial position breaks this.<p>For protobuffs in particular, I have no idea. If you look at the encoding [0], you will see that the notion of submessages are explicitly supported. However, submessages are preceeded by a length field, which makes the lack of a length field at the start of the top-level message a rather glaring omission. The best arguement I can see is that submessages use a tag-length-value scheme instead of length-value-tag. This is because in general protobufs use a tag-value scheme, and certain types have the begining of the value be a length field. This means that to have a consistent and composable format, you would need to message length to start at the second byte of the message. Still, that would probably be good enough for 90% of the instances where people want to apply a length header.<p>[0] <a href="https:&#x2F;&#x2F;protobuf.dev&#x2F;programming-guides&#x2F;encoding&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;protobuf.dev&#x2F;programming-guides&#x2F;encoding&#x2F;</a></div><br/><div id="37580803" class="c"><input type="checkbox" id="c-37580803" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37580625">root</a><span>|</span><a href="#37580717">parent</a><span>|</span><a href="#37581416">next</a><span>|</span><label class="collapse" for="c-37580803">[-]</label><label class="expand" for="c-37580803">[3 more]</label></div><br/><div class="children"><div class="content">Protobuf is sort of unique in the serialization format that it can be indefinitely extended in principle. (BSON is close, but has an explicit document size prefix.) For example, given the following definition:<p><pre><code>    message Foo {
        repeated string bar = 1;
    }
</code></pre>
Any repetition of `09 03 41 42 43` (a value &quot;ABC&quot; for the field #1), including an empty sequence, is a valid protobuf message. In the other words there is no explicit encoding for &quot;this is a message&quot;! Submessages have to be delimited because otherwise they wouldn&#x27;t be distinguishable from the parent message.</div><br/><div id="37581747" class="c"><input type="checkbox" id="c-37581747" checked=""/><div class="controls bullet"><span class="by">nly</span><span>|</span><a href="#37580625">root</a><span>|</span><a href="#37580803">parent</a><span>|</span><a href="#37581469">next</a><span>|</span><label class="collapse" for="c-37581747">[-]</label><label class="expand" for="c-37581747">[1 more]</label></div><br/><div class="children"><div class="content">Yes, &quot;submessages&quot;in Protobuf have the same field serialisation as strings<p>The field bytes dont really encode tag and type, they encode tag and <i>size</i> (fixed 32bit, 64bit or variable length)<p>Protobuf is a TLV format. In that regard, it&#x27;s not unique at all.</div><br/></div></div><div id="37581469" class="c"><input type="checkbox" id="c-37581469" checked=""/><div class="controls bullet"><span class="by">DougBTX</span><span>|</span><a href="#37580625">root</a><span>|</span><a href="#37580803">parent</a><span>|</span><a href="#37581747">prev</a><span>|</span><a href="#37581416">next</a><span>|</span><label class="collapse" for="c-37581469">[-]</label><label class="expand" for="c-37581469">[1 more]</label></div><br/><div class="children"><div class="content">This is an interesting design decision between protobuf and cap’n proto, one has “repeated field of type X” while the other has “field of type list of X”. So one allows adding a repeated&#x2F;optional field to a schema without re-encoding any messages, while the other supports “field of type list of lists of X” etc.</div><br/></div></div></div></div><div id="37581416" class="c"><input type="checkbox" id="c-37581416" checked=""/><div class="controls bullet"><span class="by">pyrale</span><span>|</span><a href="#37580625">root</a><span>|</span><a href="#37580717">parent</a><span>|</span><a href="#37580803">prev</a><span>|</span><a href="#37581721">next</a><span>|</span><label class="collapse" for="c-37581416">[-]</label><label class="expand" for="c-37581416">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Having a header that only occurs in message initial position breaks this.<p>Why would it break it? It may make it slightly harder to parse, but since the header also determines the end of the message, anyone parsing the outer message would have a clear understanding that the inner header can be safely ignored as long as the stated outer length has not been matched.</div><br/><div id="37581776" class="c"><input type="checkbox" id="c-37581776" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#37580625">root</a><span>|</span><a href="#37581416">parent</a><span>|</span><a href="#37581721">next</a><span>|</span><label class="collapse" for="c-37581776">[-]</label><label class="expand" for="c-37581776">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it&#x27;s not clear to me why this is an issue either. I&#x27;d expect that parsers would be written as &quot;parse length, if it&#x27;s valid, allocate that many bytes and read them in, then parse those bytes as a message&quot;.</div><br/></div></div></div></div></div></div><div id="37581721" class="c"><input type="checkbox" id="c-37581721" checked=""/><div class="controls bullet"><span class="by">bloak</span><span>|</span><a href="#37580625">parent</a><span>|</span><a href="#37580717">prev</a><span>|</span><a href="#37580723">next</a><span>|</span><label class="collapse" for="c-37581721">[-]</label><label class="expand" for="c-37581721">[2 more]</label></div><br/><div class="children"><div class="content">Streaming has already been mentioned. Efficiency might be another argument. If your messages are typically being sent through a channel that already has a way of indicating the end of the message then having to express the length inside the message as well would be a useless overhead in bytes sent and code complexity.</div><br/><div id="37581788" class="c"><input type="checkbox" id="c-37581788" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#37580625">root</a><span>|</span><a href="#37581721">parent</a><span>|</span><a href="#37580723">next</a><span>|</span><label class="collapse" for="c-37581788">[-]</label><label class="expand" for="c-37581788">[1 more]</label></div><br/><div class="children"><div class="content">This assumes that only messages from controlled sources will be received though, right? If you&#x27;re receiving messages over a TCP socket or something similar, that seems like a potentially flawed assumption; I&#x27;d think anything parsing messages coming from the network should be written in a way that explicitly accounts for malicious messages coming from the other side of a connection.<p>EDIT: I&#x27;m also still not any more convinced that four bytes per message would ever be a bottleneck for any general purpose protocol, but I&#x27;d be curious to hear of a case where that would actually be an issue.</div><br/></div></div></div></div><div id="37580723" class="c"><input type="checkbox" id="c-37580723" checked=""/><div class="controls bullet"><span class="by">throwaway8163</span><span>|</span><a href="#37580625">parent</a><span>|</span><a href="#37581721">prev</a><span>|</span><a href="#37580671">next</a><span>|</span><label class="collapse" for="c-37580723">[-]</label><label class="expand" for="c-37580723">[2 more]</label></div><br/><div class="children"><div class="content">Some compression formats such as gzip support encoding streams.<p>This is useful when you don&#x27;t know the size in advance, or if you compress on demand and want the receiver to start reading while the sender is still compressing.<p>One example could be a web service where you request dynamic content (like a huge CSV file). The client can start downloading earlier, and the server doesn&#x27;t need to create a temporary file. The web service will stream the results directly and encoding it in chunks.</div><br/><div id="37580753" class="c"><input type="checkbox" id="c-37580753" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37580625">root</a><span>|</span><a href="#37580723">parent</a><span>|</span><a href="#37580671">next</a><span>|</span><label class="collapse" for="c-37580753">[-]</label><label class="expand" for="c-37580753">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Some compression formats such as gzip support encoding streams.<p>More accurately speaking gzip (and many other compressed file formats) has the file size information, but that information should (or can, for others) be appended after the data. Protobuf doesn&#x27;t have any such information, so a better analogue would be the DEFLATE compressed bytestream format.</div><br/></div></div></div></div><div id="37580671" class="c"><input type="checkbox" id="c-37580671" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#37580625">parent</a><span>|</span><a href="#37580723">prev</a><span>|</span><a href="#37580819">next</a><span>|</span><label class="collapse" for="c-37580671">[-]</label><label class="expand" for="c-37580671">[1 more]</label></div><br/><div class="children"><div class="content">You may want to have yield&#x2F;streaming senantics where length is not know in advance.</div><br/></div></div><div id="37580819" class="c"><input type="checkbox" id="c-37580819" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#37580625">parent</a><span>|</span><a href="#37580671">prev</a><span>|</span><a href="#37580657">next</a><span>|</span><label class="collapse" for="c-37580819">[-]</label><label class="expand" for="c-37580819">[3 more]</label></div><br/><div class="children"><div class="content">Among other things, length prefixing is annoying when streaming; it basically requires you to buffer the entire message, even if you could more efficiently stream it in chunks, because you need to know the length ahead of time, which you may very well not.</div><br/><div id="37581143" class="c"><input type="checkbox" id="c-37581143" checked=""/><div class="controls bullet"><span class="by">cjbgkagh</span><span>|</span><a href="#37580625">root</a><span>|</span><a href="#37580819">parent</a><span>|</span><a href="#37580657">next</a><span>|</span><label class="collapse" for="c-37581143">[-]</label><label class="expand" for="c-37581143">[2 more]</label></div><br/><div class="children"><div class="content">If you have random access, you could leave some space and then go back and fill in the actual length value. Would work better with fixed size integer as you know ahead of time how much space to leave.</div><br/><div id="37581515" class="c"><input type="checkbox" id="c-37581515" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#37580625">root</a><span>|</span><a href="#37581143">parent</a><span>|</span><a href="#37580657">next</a><span>|</span><label class="collapse" for="c-37581515">[-]</label><label class="expand" for="c-37581515">[1 more]</label></div><br/><div class="children"><div class="content">If you’re streaming, you generally don’t have random access.</div><br/></div></div></div></div></div></div><div id="37580657" class="c"><input type="checkbox" id="c-37580657" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37580625">parent</a><span>|</span><a href="#37580819">prev</a><span>|</span><a href="#37581769">next</a><span>|</span><label class="collapse" for="c-37580657">[-]</label><label class="expand" for="c-37580657">[2 more]</label></div><br/><div class="children"><div class="content">The length should be known in advance in order to be written, so the message cannot be incrementally written. You need more complex framing scheme like Consistent Overhead Byte Stuffing for that. And many applications do want a variable number of length bytes because i) 4 bytes is actually too long for short messages and ii) some message <i>can</i> exceed 2^32 bytes. Not to say the generic varint encoding is good for this purpose, though [1].<p>[1] If you ever have to design one, make sure that reading the first byte is enough to determine the number of subsequent length bytes.</div><br/><div id="37581818" class="c"><input type="checkbox" id="c-37581818" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#37580625">root</a><span>|</span><a href="#37580657">parent</a><span>|</span><a href="#37581769">next</a><span>|</span><label class="collapse" for="c-37581818">[-]</label><label class="expand" for="c-37581818">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 4 bytes is actually too long for short messages<p>Would it ever be an actual bottleneck though? If it&#x27;s not actually impeding throughput, I feel like this is more of an aesthetic argument than a technical one, and one where I&#x27;d happily sacrifice aesthetics to make the code simpler.<p>&gt; some message can exceed 2^32 bytes<p>Fair enough, but that just makes the question &quot;would 8 bytes per message ever actually be a bottleneck&quot;, which I&#x27;m still not convinced would ever be the case</div><br/></div></div></div></div></div></div><div id="37581769" class="c"><input type="checkbox" id="c-37581769" checked=""/><div class="controls bullet"><span class="by">nly</span><span>|</span><a href="#37580625">prev</a><span>|</span><a href="#37580338">next</a><span>|</span><label class="collapse" for="c-37581769">[-]</label><label class="expand" for="c-37581769">[1 more]</label></div><br/><div class="children"><div class="content">Pedantry regarding the article:<p>The field prefix byte in Protobuf doesn&#x27;t really encode &quot;tag and type&quot; as stated in the article, it encodes tag and size (whether the field is fixed 64bit, fixed 32bit, varint, or variable size)<p>This is pretty self evident when you look at how submessages are encoded the same way as strings, both are just arbitrary variable length blobs.<p>You cannot reliable determine from a Protobuf message whether a  field is an integer, a double, a bool, or an enum without the schema.<p>Protobufs is a TLV format that just happens to have a compact binary encoding.</div><br/></div></div><div id="37580338" class="c"><input type="checkbox" id="c-37580338" checked=""/><div class="controls bullet"><span class="by">kpw94</span><span>|</span><a href="#37581769">prev</a><span>|</span><a href="#37581607">next</a><span>|</span><label class="collapse" for="c-37580338">[-]</label><label class="expand" for="c-37580338">[4 more]</label></div><br/><div class="children"><div class="content">&gt; we started looking at this protobuf library he had selected, and sure enough, the author decided it was a good idea to prepend the message with the message length encoded as a varint.<p>&gt; WHY? Oh, why?!<p>&gt; And yes, it turns out that other people have noticed this anomaly. It&#x27;s screwed up encoding and decoding in their projects, unsurprisingly. We found a (still-open) bug report from 2018, among others<p>If anyone knows which library&#x2F;language these issues the author is talking about are in, please tell us. I&#x27;d like to avoid that library if possible</div><br/><div id="37580423" class="c"><input type="checkbox" id="c-37580423" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#37580338">parent</a><span>|</span><a href="#37580520">next</a><span>|</span><label class="collapse" for="c-37580423">[-]</label><label class="expand" for="c-37580423">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If anyone knows which library&#x2F;language these issues the author is talking about are in, please tell us.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;protobufjs&#x2F;protobuf.js&#x2F;issues&#x2F;987">https:&#x2F;&#x2F;github.com&#x2F;protobufjs&#x2F;protobuf.js&#x2F;issues&#x2F;987</a> maybe (based on &quot;And yes, that string in this post is entirely deliberate&quot;).</div><br/></div></div><div id="37580520" class="c"><input type="checkbox" id="c-37580520" checked=""/><div class="controls bullet"><span class="by">WirelessGigabit</span><span>|</span><a href="#37580338">parent</a><span>|</span><a href="#37580423">prev</a><span>|</span><a href="#37580411">next</a><span>|</span><label class="collapse" for="c-37580520">[-]</label><label class="expand" for="c-37580520">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;protobufjs&#x2F;protobuf.js&#x2F;wiki&#x2F;How-to-reverse-engineer-a-buffer-by-hand">https:&#x2F;&#x2F;github.com&#x2F;protobufjs&#x2F;protobuf.js&#x2F;wiki&#x2F;How-to-revers...</a><p>Prepending the message with the length means the message is length-limited. Seems standard practice here.</div><br/></div></div><div id="37580411" class="c"><input type="checkbox" id="c-37580411" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#37580338">parent</a><span>|</span><a href="#37580520">prev</a><span>|</span><a href="#37581607">next</a><span>|</span><label class="collapse" for="c-37580411">[-]</label><label class="expand" for="c-37580411">[1 more]</label></div><br/><div class="children"><div class="content">I feel like I recall seeing something similar in nanopb.</div><br/></div></div></div></div><div id="37581607" class="c"><input type="checkbox" id="c-37581607" checked=""/><div class="controls bullet"><span class="by">blauditore</span><span>|</span><a href="#37580338">prev</a><span>|</span><a href="#37580459">next</a><span>|</span><label class="collapse" for="c-37581607">[-]</label><label class="expand" for="c-37581607">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t this <i>exactly</i> what `writeDelimitedTo` does? <a href="https:&#x2F;&#x2F;protobuf.dev&#x2F;reference&#x2F;java&#x2F;api-docs&#x2F;com&#x2F;google&#x2F;protobuf&#x2F;MessageLite.html#writeDelimitedTo-java.io.OutputStream-" rel="nofollow noreferrer">https:&#x2F;&#x2F;protobuf.dev&#x2F;reference&#x2F;java&#x2F;api-docs&#x2F;com&#x2F;google&#x2F;prot...</a><p>I thought this was common and well-known, but apparently not.</div><br/></div></div><div id="37580459" class="c"><input type="checkbox" id="c-37580459" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#37581607">prev</a><span>|</span><a href="#37580417">next</a><span>|</span><label class="collapse" for="c-37580459">[-]</label><label class="expand" for="c-37580459">[3 more]</label></div><br/><div class="children"><div class="content"><i>They don&#x27;t have their own framing.</i><p>...and thus it was added.<p><i>We finally had to get down to individual bytes from the network dump to try to sort it out.</i><p>The perils of abstraction strike again. Chances are that if you had just written the code to directly send and receive the data you wanted, since you control both ends and know exactly what the bytes will be, you&#x27;d never have run into this.</div><br/><div id="37580489" class="c"><input type="checkbox" id="c-37580489" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37580459">parent</a><span>|</span><a href="#37580573">next</a><span>|</span><label class="collapse" for="c-37580489">[-]</label><label class="expand" for="c-37580489">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Chances are that if you had just written the code to directly send and receive the data you wanted, since you control both ends and know exactly what the bytes will be, you&#x27;d never have run into this.<p>Instead you would have run into different problems..</div><br/></div></div><div id="37580573" class="c"><input type="checkbox" id="c-37580573" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37580459">parent</a><span>|</span><a href="#37580489">prev</a><span>|</span><a href="#37580417">next</a><span>|</span><label class="collapse" for="c-37580573">[-]</label><label class="expand" for="c-37580573">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s indeed a shame that protobuf has so many bit patterns available for the first byte (lowermost 3 bits can&#x27;t be 6 or 7, and 4 cannot be also used alone), and some of them could have been used for a unified length-delimited framing format.</div><br/></div></div></div></div><div id="37580417" class="c"><input type="checkbox" id="c-37580417" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#37580459">prev</a><span>|</span><a href="#37581636">next</a><span>|</span><label class="collapse" for="c-37580417">[-]</label><label class="expand" for="c-37580417">[5 more]</label></div><br/><div class="children"><div class="content">On one side it&#x27;s not great, it could be made more obvious to the library user.<p>On the other side, if they wrote multiple projects and never noticed the behavior, how bad can it be ?<p>It would be interesting if that extra header optimized the processing a lot, pushing other libraries to have it as an option.</div><br/><div id="37580454" class="c"><input type="checkbox" id="c-37580454" checked=""/><div class="controls bullet"><span class="by">alexchamberlain</span><span>|</span><a href="#37580417">parent</a><span>|</span><a href="#37581636">next</a><span>|</span><label class="collapse" for="c-37580454">[-]</label><label class="expand" for="c-37580454">[4 more]</label></div><br/><div class="children"><div class="content">&gt; On the other side, if they wrote multiple projects and never noticed the behavior, how bad can it be ?<p>Many projects will choose a standard encoding to give them language independence, but start by using the same language and libraries on both ends of the pipe. Therefore,you might not notice the library is incompatible until quite late in a project&#x27;s development when you try to replace a component with a seemingly compatible, alternative implementation.</div><br/><div id="37580663" class="c"><input type="checkbox" id="c-37580663" checked=""/><div class="controls bullet"><span class="by">0xDEAFBEAD</span><span>|</span><a href="#37580417">root</a><span>|</span><a href="#37580454">parent</a><span>|</span><a href="#37581636">next</a><span>|</span><label class="collapse" for="c-37580663">[-]</label><label class="expand" for="c-37580663">[3 more]</label></div><br/><div class="children"><div class="content">It looks like Protobuf actually has a test suite to ensure compliance with the protocol:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;tree&#x2F;main&#x2F;conformance#readme">https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;tree&#x2F;main&#x2F;confor...</a><p>Seems like a good idea for protocols in general to have an official test suite, as a way to address this problem</div><br/><div id="37580736" class="c"><input type="checkbox" id="c-37580736" checked=""/><div class="controls bullet"><span class="by">sa46</span><span>|</span><a href="#37580417">root</a><span>|</span><a href="#37580663">parent</a><span>|</span><a href="#37581636">next</a><span>|</span><label class="collapse" for="c-37580736">[-]</label><label class="expand" for="c-37580736">[2 more]</label></div><br/><div class="children"><div class="content">The conformance suite tests encode and decode for single messages; you wouldn’t run it for a custom framing implementation; The gRPC interop tests are closer to what you’d want.<p>Framing appears higher up the stack, as an RPC transport, or structured storage like the recordio format referenced by the author. The article sounds like the client expected application&#x2F;protobuf but the server sent application&#x2F;custom-protobuf-framing.</div><br/><div id="37580821" class="c"><input type="checkbox" id="c-37580821" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37580417">root</a><span>|</span><a href="#37580736">parent</a><span>|</span><a href="#37581636">next</a><span>|</span><label class="collapse" for="c-37580821">[-]</label><label class="expand" for="c-37580821">[1 more]</label></div><br/><div class="children"><div class="content">I think it is easy to confuse the serialization format from framing because many serialization formats do self-delimit. And the protobuf terminology of &quot;message&quot; may suggest framing...</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37581636" class="c"><input type="checkbox" id="c-37581636" checked=""/><div class="controls bullet"><span class="by">notpushkin</span><span>|</span><a href="#37580417">prev</a><span>|</span><a href="#37581198">next</a><span>|</span><label class="collapse" for="c-37581636">[-]</label><label class="expand" for="c-37581636">[1 more]</label></div><br/><div class="children"><div class="content">Website looks down to me, here&#x27;s an archive copy: <a href="https:&#x2F;&#x2F;archive.ph&#x2F;OkylM" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.ph&#x2F;OkylM</a></div><br/></div></div><div id="37581198" class="c"><input type="checkbox" id="c-37581198" checked=""/><div class="controls bullet"><span class="by">basicoperation</span><span>|</span><a href="#37581636">prev</a><span>|</span><a href="#37580525">next</a><span>|</span><label class="collapse" for="c-37581198">[-]</label><label class="expand" for="c-37581198">[1 more]</label></div><br/><div class="children"><div class="content">I spent several hours earlier this year helping a colleague debug a protobuf deserialisation error, where I noticed that the first byte was a varint-encoded length of the rest of the data! He did eventually get things working, though I never followed up on the root cause.<p>I can’t wait to get back from vacation to ask if it was this.</div><br/></div></div><div id="37580525" class="c"><input type="checkbox" id="c-37580525" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#37581198">prev</a><span>|</span><a href="#37580329">next</a><span>|</span><label class="collapse" for="c-37580525">[-]</label><label class="expand" for="c-37580525">[1 more]</label></div><br/><div class="children"><div class="content">This is very similar to a trap I fell into with some off-brand LZ4 libraries that are laying around on Github. One, called &quot;golz4&quot; sounded harmless but it&#x27;s actually designed to be compatible with this python mistake: <a href="https:&#x2F;&#x2F;python-lz4.readthedocs.io&#x2F;en&#x2F;stable&#x2F;lz4.block.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;python-lz4.readthedocs.io&#x2F;en&#x2F;stable&#x2F;lz4.block.html</a><p>Length-prefixing an otherwise standard format, by default, kept me confused for some hours.</div><br/></div></div><div id="37580329" class="c"><input type="checkbox" id="c-37580329" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#37580525">prev</a><span>|</span><label class="collapse" for="c-37580329">[-]</label><label class="expand" for="c-37580329">[5 more]</label></div><br/><div class="children"><div class="content">What library was that, so I know to avoid it?</div><br/><div id="37580415" class="c"><input type="checkbox" id="c-37580415" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#37580329">parent</a><span>|</span><a href="#37580414">next</a><span>|</span><label class="collapse" for="c-37580415">[-]</label><label class="expand" for="c-37580415">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;protobufjs&#x2F;protobuf.js&#x2F;issues&#x2F;987">https:&#x2F;&#x2F;github.com&#x2F;protobufjs&#x2F;protobuf.js&#x2F;issues&#x2F;987</a> maybe (based on &quot;And yes, that string in this post is entirely deliberate&quot;).</div><br/><div id="37580780" class="c"><input type="checkbox" id="c-37580780" checked=""/><div class="controls bullet"><span class="by">cowsandmilk</span><span>|</span><a href="#37580329">root</a><span>|</span><a href="#37580415">parent</a><span>|</span><a href="#37580442">next</a><span>|</span><label class="collapse" for="c-37580780">[-]</label><label class="expand" for="c-37580780">[1 more]</label></div><br/><div class="children"><div class="content">Seems like protoduf.js has the exact same methods as Google’s implementations with the same names (encode&#x2F;decode to not prepend with length, encodeDelimited&#x2F;decodeDelimited for prepending length). It is hard for me to say they’re adding to the standard when they’re just replicating Google’s libraries.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;protobufjs&#x2F;protobuf.js#toolset">https:&#x2F;&#x2F;github.com&#x2F;protobufjs&#x2F;protobuf.js#toolset</a></div><br/></div></div><div id="37580442" class="c"><input type="checkbox" id="c-37580442" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#37580329">root</a><span>|</span><a href="#37580415">parent</a><span>|</span><a href="#37580780">prev</a><span>|</span><a href="#37580414">next</a><span>|</span><label class="collapse" for="c-37580442">[-]</label><label class="expand" for="c-37580442">[1 more]</label></div><br/><div class="children"><div class="content">Ah yes, you&#x27;ve got it.</div><br/></div></div></div></div><div id="37580414" class="c"><input type="checkbox" id="c-37580414" checked=""/><div class="controls bullet"><span class="by">upon_drumhead</span><span>|</span><a href="#37580329">parent</a><span>|</span><a href="#37580415">prev</a><span>|</span><label class="collapse" for="c-37580414">[-]</label><label class="expand" for="c-37580414">[1 more]</label></div><br/><div class="children"><div class="content">KRPC perhaps<p><a href="https:&#x2F;&#x2F;krpc.github.io&#x2F;krpc&#x2F;communication-protocols&#x2F;tcpip.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;krpc.github.io&#x2F;krpc&#x2F;communication-protocols&#x2F;tcpip.ht...</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>