<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729587670586" as="style"/><link rel="stylesheet" href="styles.css?v=1729587670586"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jakearchibald.com/2024/how-should-selectedoption-work/">How should the new &lt;selectedoption&gt; element work?</a>Â <span class="domain">(<a href="https://jakearchibald.com">jakearchibald.com</a>)</span></div><div class="subtext"><span>jaffathecake</span> | <span>14 comments</span></div><br/><div><div id="41911890" class="c"><input type="checkbox" id="c-41911890" checked=""/><div class="controls bullet"><span class="by">gabesullice</span><span>|</span><a href="#41912195">next</a><span>|</span><label class="collapse" for="c-41911890">[-]</label><label class="expand" for="c-41911890">[1 more]</label></div><br/><div class="children"><div class="content">IMO, this whole cloning idea is overcomplicated. Let the duplication of markup happen server side or in React (or whatever).<p>If the developer wants a &lt;selectedoption&gt;, they should fill it with &lt;option&gt; elements that correspond to the &lt;option&gt; elements that appear in the dropdown. Each option could reuse the &lt;label for=&quot;&quot;&gt; pattern to associate them with their counterpart.<p>Then, when an option is selected by the end user, the corresponding option inside the &lt;selectedoption&gt; would get a `selected` attribute.<p>The default CSS would be:<p>selectedoption &gt; option { display: none; }
selectedoption &gt; option[selected] { display: block; }<p>This gives complete control to the developer, works fine without JS, and wouldn&#x27;t have shocking side effects.<p>As they say, &quot;duplication is cheaper than the wrong abstraction&quot;.</div><br/></div></div><div id="41912195" class="c"><input type="checkbox" id="c-41912195" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41911890">prev</a><span>|</span><a href="#41880272">next</a><span>|</span><label class="collapse" for="c-41912195">[-]</label><label class="expand" for="c-41912195">[2 more]</label></div><br/><div class="children"><div class="content">I think it is worthwhile to revisit the starting motivation of customizing `&lt;select&gt;`. There would be generally two camps:<p>1. Declarative camp, where people expect two differently stylable copies of `&lt;option&gt;` somewhere in `&lt;select&gt;`. I don&#x27;t think the exact copying mechanism and timing is very important here, as long as it can be safely done and works without JS.<p>2. Programmable camp, where people want the full control over appearance and behavior. We can reasonably assume that JS is required for this camp, and they generally have better understanding of what gets rendered or not in the first place.<p>Given both requirements, it seems wise to couple the clone timing with the event processing, which most cases in the second camp would have to do anyway. In the other words, the `input` event would have the default behavior of full cloning, and that default behavior should be prevented via `e.preventDefault()`. The second camp will almost always use this option and can use their own `MutationObserver` or similar to implement edge cases described in the OP. The timing and extent for the default behavior can be then optimized without affecting the second camp. It is even possible to distinguish two camps via different values of the `appearance` CSS property.<p>Sidetrack: It seems that `&lt;selectedoption&gt;` indeed exists mainly to distinguish two camps? But that leaves many edge cases like multiple `&lt;selectedoption&gt;` elements I believe. Maybe something like `&lt;select reflect=&quot;foo&quot;&gt;&lt;button&gt;&lt;option id=&quot;foo&quot;&gt;...&lt;&#x2F;option&gt;&lt;&#x2F;button&gt;...&lt;&#x2F;select&gt;` might be more appropriate. (`&lt;output&gt;` was my initial thought, but `&lt;option&gt;` would be more regular since it can&#x27;t nest.)</div><br/><div id="41912426" class="c"><input type="checkbox" id="c-41912426" checked=""/><div class="controls bullet"><span class="by">jaffathecake</span><span>|</span><a href="#41912195">parent</a><span>|</span><a href="#41880272">next</a><span>|</span><label class="collapse" for="c-41912426">[-]</label><label class="expand" for="c-41912426">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the `input` event would have the default behavior of full cloning<p>Hm, it feels like, when the selected option is changed via user interaction, the &lt;selectedoption&gt; should be populated before the event fires.<p>But this is really besides the point, because not all selected-option-changes come with an input event, eg programatic change, including to the content of the currently selected option, which the post focuses on.<p>&gt; that leaves many edge cases like multiple `&lt;selectedoption&gt;` elements I believe<p>That isn&#x27;t really a big problem. It&#x27;s something the platform already deals with all over the place, like multiple &lt;title&gt; elements, multiple elements with the same ID etc etc.</div><br/></div></div></div></div><div id="41880272" class="c"><input type="checkbox" id="c-41880272" checked=""/><div class="controls bullet"><span class="by">dfabulich</span><span>|</span><a href="#41912195">prev</a><span>|</span><a href="#41887930">next</a><span>|</span><label class="collapse" for="c-41880272">[-]</label><label class="expand" for="c-41880272">[4 more]</label></div><br/><div class="children"><div class="content">I think it should be Option 2, &quot;Automatically reset the content when anything in the selected &lt;option&gt; changes.&quot;<p>But furthermore, I think it should be possible to turn &lt;selectedoption&gt; mirroring entirely off, e.g. with an attribute like &lt;selectedoption mirroring=&quot;none&quot;&gt;, and I think most developers using reactive frameworks should prefer to do that.<p>If I&#x27;m using any reactive framework designed to do targeted DOM updates, I want my framework to be in complete control. When an option is selected, I&#x27;ll populate &lt;selectedoption&gt; myself. When an &lt;option&gt; is modified, I modified it, and I know which &lt;option&gt; is selected, so I&#x27;ll perform a targeted DOM update of &lt;selectedoption&gt; as well.<p>You had a whole separate podcast episode about how&#x2F;why having the browser itself do targeted DOM updates is an enormous can of worms, mostly for attribute vs. property reasons. <a href="https:&#x2F;&#x2F;offthemainthread.tech&#x2F;episode&#x2F;putting-react-in-the-browser&#x2F;" rel="nofollow">https:&#x2F;&#x2F;offthemainthread.tech&#x2F;episode&#x2F;putting-react-in-the-b...</a> And anyway, every framework wants to handle mutations differently, and framework designers are in consensus that we haven&#x27;t picked a clear winner yet. So, as nice as it would be if we had a replaceHTML API that everybody loved, we don&#x27;t have that now, and we shouldn&#x27;t hold up customizable &lt;select&gt; for this.<p>&lt;selectedoption&gt; mirroring is for folks who don&#x27;t want to use any JavaScript (and I think that&#x27;s a good thing). In that case, mirroring all updates automatically, synchronously, is the simplest thing that can possibly work.<p>Developers who want optimal performance want full control, and they just want to turn mirroring entirely off.</div><br/><div id="41880380" class="c"><input type="checkbox" id="c-41880380" checked=""/><div class="controls bullet"><span class="by">jaffathecake</span><span>|</span><a href="#41880272">parent</a><span>|</span><a href="#41887930">next</a><span>|</span><label class="collapse" for="c-41880380">[-]</label><label class="expand" for="c-41880380">[3 more]</label></div><br/><div class="children"><div class="content">Thanks for the feedback! Fwiw, there&#x27;s no point populating &lt;selectedoption&gt; yourself. Just don&#x27;t use &lt;selectedoption&gt;. It&#x27;s optional. That&#x27;s probably what I&#x27;d do in most cases where I&#x27;m using a framework.</div><br/><div id="41880555" class="c"><input type="checkbox" id="c-41880555" checked=""/><div class="controls bullet"><span class="by">dfabulich</span><span>|</span><a href="#41880272">root</a><span>|</span><a href="#41880380">parent</a><span>|</span><a href="#41887930">next</a><span>|</span><label class="collapse" for="c-41880555">[-]</label><label class="expand" for="c-41880555">[2 more]</label></div><br/><div class="children"><div class="content">Good to know.<p>Say, is there a bug in Chrome Canary 132? When I opt into customizable &lt;select&gt;, &quot;change&quot; events stop firing.<p><pre><code>    &lt;style&gt; select, ::picker(select) { appearance: base-select; } &lt;&#x2F;style&gt;
    &lt;select&gt;
    &lt;option value=&quot;one&quot;&gt;one&lt;&#x2F;option&gt;
    &lt;option value=&quot;two&quot;&gt;two&lt;&#x2F;option&gt;
    &lt;option value=&quot;three&quot;&gt;three&lt;&#x2F;option&gt;
    &lt;&#x2F;select&gt;
    &lt;script&gt;
    document.querySelector(&#x27;select&#x27;).addEventListener(&#x27;change&#x27;, e =&gt; {
        console.log(e);
    })
    &lt;&#x2F;script&gt;
</code></pre>
And another. When I add &lt;selectedoption&gt;, I get a warning in the console, &quot;A descendant of a &lt;select&gt; does not follow the content model. &lt;selectedoption&gt; one &lt;&#x2F;selectedoption&gt; &quot;<p><pre><code>    &lt;style&gt; select, ::picker(select) { appearance: base-select; } &lt;&#x2F;style&gt;
    &lt;select&gt;
    &lt;button&gt;&lt;selectedoption&gt;&lt;&#x2F;selectedoption&gt;&lt;&#x2F;button&gt;
    &lt;option value=&quot;one&quot;&gt;one&lt;&#x2F;option&gt;
    &lt;option value=&quot;two&quot;&gt;two&lt;&#x2F;option&gt;
    &lt;option value=&quot;three&quot;&gt;three&lt;&#x2F;option&gt;
    &lt;&#x2F;select&gt;</code></pre></div><br/><div id="41880615" class="c"><input type="checkbox" id="c-41880615" checked=""/><div class="controls bullet"><span class="by">jaffathecake</span><span>|</span><a href="#41880272">root</a><span>|</span><a href="#41880555">parent</a><span>|</span><a href="#41887930">next</a><span>|</span><label class="collapse" for="c-41880615">[-]</label><label class="expand" for="c-41880615">[1 more]</label></div><br/><div class="children"><div class="content">Those sound like bugs but I&#x27;m not really familiar with the implementation. I haven&#x27;t played with it much either. I&#x27;m just an outsider interested in the feature design.</div><br/></div></div></div></div></div></div></div></div><div id="41887930" class="c"><input type="checkbox" id="c-41887930" checked=""/><div class="controls bullet"><span class="by">TheFlyingFish</span><span>|</span><a href="#41880272">prev</a><span>|</span><a href="#41886293">next</a><span>|</span><label class="collapse" for="c-41887930">[-]</label><label class="expand" for="c-41887930">[2 more]</label></div><br/><div class="children"><div class="content">My feeling is that the most important situation to consider here is where the updating happens from third-party JS. If you&#x27;re writing your own JS, it isn&#x27;t that much harder to just target the selectedoption as well as the original one, and if you&#x27;re using a full-fat framework like React or whatever it&#x27;s downright easy. So I think the benefit of providing an explicit API to trigger a clone is limited.<p>So that leaves the various automatic options, either synchronous, debounced, or the fancy targeted version. This seems like a pretty straightforward complexity&#x2F;performance tradeoff to me, with the synchronous version being the simplest (both to implement and to understand) and going up from there.<p>With that in mind, I&#x27;m inclined toward the middle option (changes are synced automatically, but batched in the next microtask) since it feels like the best balance of complexity&#x2F;usability. Seems like it would eliminate some of the biggest performance footguns, without being too much of a bear to implement or too difficult to understand.<p>On the other hand, I would personally also be ok with no syncing at all, just the initial clone when an option is selected, if it would mean we get this feature sooner. Really looking forward to not having to roll my own dropdowns.</div><br/><div id="41912435" class="c"><input type="checkbox" id="c-41912435" checked=""/><div class="controls bullet"><span class="by">jaffathecake</span><span>|</span><a href="#41887930">parent</a><span>|</span><a href="#41886293">next</a><span>|</span><label class="collapse" for="c-41912435">[-]</label><label class="expand" for="c-41912435">[1 more]</label></div><br/><div class="children"><div class="content">&gt; With that in mind, I&#x27;m inclined toward the middle option (changes are synced automatically, but batched in the next microtask)<p>fwiw, this is relatively easy to do yourself. Set up a mutation observer, and clone when the callback fires on a mutation within the selected option.</div><br/></div></div></div></div><div id="41886293" class="c"><input type="checkbox" id="c-41886293" checked=""/><div class="controls bullet"><span class="by">butchler</span><span>|</span><a href="#41887930">prev</a><span>|</span><a href="#41911693">next</a><span>|</span><label class="collapse" for="c-41886293">[-]</label><label class="expand" for="c-41886293">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re using a framework like React to manage updates to the DOM, then you probably don&#x27;t want to use selectedoption in the first place because it&#x27;s just as easy and more flexible&#x2F;predictable to use the framework&#x27;s existing patterns for keeping different parts of the DOM in sync.<p>So the main target audience for selectedoption is probably people not using a framework, and using no or little JavaScript. That audience probably would want selectedoption to &quot;just work&quot; without having to manually call a function to reset things. So while option 1 seems like a reasonable option to me personally as someone who mainly works with React, it&#x27;s probably not what most people using selectedoption would want.<p>Option 2 just has too much potential for introducing hard to debug and hard to fix performance issues, so I feel like it&#x27;s automatically not the best choice. Its main advantage is that it&#x27;s probably the most straightforward to understand&#x2F;explain.<p>Option 4 would help with the performance issues, but it sounds like it would be a nightmare for browsers to implement. It would also be a bit difficult to explain to devs how exactly it works and what edge cases need to be considered (like mutating the selectedoption &quot;fork&quot; potentially causing issues).<p>So by process of elimination option 3 seems like the best to me. It solves the performance issues but it&#x27;s still pretty easy to understand&#x2F;explain. It&#x27;s main disadvantage seems to be that from the perspective of code running synchronously it&#x27;s possible for the selectedoption and option to get out of sync, but 1) it&#x27;s a bit hard to imagine a practical use case for needing to do this kind of comparison and 2) simply waiting until the next microtask before doing the comparison would probably be an easy fix even if this is a problem in some cases.<p>For all of these options, it might be useful for there to be some way to intercept the default behavior. For example maybe there could be some event such that calling .preventDefault() inside an event handler has the side effect of preventing the selectedoption from being reset, if resetting it is not desired. Of course you don&#x27;t need to use selectedoption at all if the automatic resetting is not desired, but maybe there will be some cases where you only want to make an exception in a few cases but generally do want the selectedoption default behavior.</div><br/></div></div><div id="41911693" class="c"><input type="checkbox" id="c-41911693" checked=""/><div class="controls bullet"><span class="by">parasti</span><span>|</span><a href="#41886293">prev</a><span>|</span><a href="#41912020">next</a><span>|</span><label class="collapse" for="c-41911693">[-]</label><label class="expand" for="c-41911693">[1 more]</label></div><br/><div class="children"><div class="content">First option is clearly best just because it lets developers decide. Every select library should have a method like this and I breathe a sigh of relief every time I find one.</div><br/></div></div><div id="41912020" class="c"><input type="checkbox" id="c-41912020" checked=""/><div class="controls bullet"><span class="by">transfire</span><span>|</span><a href="#41911693">prev</a><span>|</span><label class="collapse" for="c-41912020">[-]</label><label class="expand" for="c-41912020">[2 more]</label></div><br/><div class="children"><div class="content">Who is in charge of these HTML changes? This is horrible. Itâs bad enough that for the last three decades weâve have to use the `selected` attribute, now we are going to have a `button` in `select` with a `selectedoption` tag?<p>Please, just No!<p>The CSS for the style of the element belongs with the `select` tag. And all that should be needed to demark the selected option is a matching `value` attribute.<p>I get the sense that the people currently working on HTML and CSS are front-end designers and not programmers. We need functional design, polymorphism and simplicity, not just more kitchen sinks.</div><br/><div id="41912353" class="c"><input type="checkbox" id="c-41912353" checked=""/><div class="controls bullet"><span class="by">diggan</span><span>|</span><a href="#41912020">parent</a><span>|</span><label class="collapse" for="c-41912353">[-]</label><label class="expand" for="c-41912353">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Who is in charge of these HTML changes? This is horrible.<p>We all are, so thank you for this horrible proposed-but-not-yet-implemented change!<p>Jokes aside, you can participate in the discussion yourself here: <a href="https:&#x2F;&#x2F;github.com&#x2F;whatwg&#x2F;html&#x2F;issues&#x2F;10520">https:&#x2F;&#x2F;github.com&#x2F;whatwg&#x2F;html&#x2F;issues&#x2F;10520</a><p>But be warned, you will probably not be able to convince people with just &quot;Please, just no!&quot;.<p>&gt; I get the sense that the people currently working on HTML and CSS are front-end designers and not programmers.<p>Yeah, that makes sense, it&#x27;s a markup language, not a programming language. The targeted audience for HTML and CSS is way bigger than just programmers. For the people who want to build imperative UIs or even &quot;immediate mode&quot; GUIs there are a ton of options out there already.<p>I get the sense that people complaining about HTML&#x2F;CSS not being like a programming language enough are programmers, not document authors.</div><br/></div></div></div></div></div></div></div></div></div></body></html>