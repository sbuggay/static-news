<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733043654022" as="style"/><link rel="stylesheet" href="styles.css?v=1733043654022"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://chipsandcheese.com/p/amd-disables-zen-4s-loop-buffer">AMD Disables Zen 4&#x27;s Loop Buffer</a> <span class="domain">(<a href="https://chipsandcheese.com">chipsandcheese.com</a>)</span></div><div class="subtext"><span>luyu_wu</span> | <span>75 comments</span></div><br/><div><div id="42284415" class="c"><input type="checkbox" id="c-42284415" checked=""/><div class="controls bullet"><span class="by">Pannoniae</span><span>|</span><a href="#42287182">next</a><span>|</span><label class="collapse" for="c-42284415">[-]</label><label class="expand" for="c-42284415">[1 more]</label></div><br/><div class="children"><div class="content">From another article:<p>&quot;Both the fetch+decode and op cache pipelines can be active at the same time, and both feed into the in-order micro-op queue. Zen 4 could use its micro-op queue as a loop buffer, but Zen 5 does not. I asked why the loop buffer was gone in Zen 5 in side conversations. They quickly pointed out that the loop buffer wasn’t deleted. Rather, Zen 5’s frontend was a new design and the loop buffer never got added back. As to why, they said the loop buffer was primarily a power optimization. It could help IPC in some cases, but the primary goal was to let Zen 4 shut off much of the frontend in small loops. Adding any feature has an engineering cost, which has to be balanced against potential benefits. Just as with having dual decode clusters service a single thread, whether the loop buffer was worth engineer time was apparently “no”.&quot;</div><br/></div></div><div id="42287182" class="c"><input type="checkbox" id="c-42287182" checked=""/><div class="controls bullet"><span class="by">Loic</span><span>|</span><a href="#42284415">prev</a><span>|</span><a href="#42284716">next</a><span>|</span><label class="collapse" for="c-42287182">[-]</label><label class="expand" for="c-42287182">[1 more]</label></div><br/><div class="children"><div class="content">For me the most interesting paragraph in the article is:<p>&gt; Perhaps the best way of looking at Zen 4&#x27;s loop buffer is that it signals the company has engineering bandwidth to go try things. Maybe it didn&#x27;t go anywhere this time. But letting engineers experiment with a low risk, low impact feature is a great way to build confidence. I look forward to seeing more of that confidence in the future.</div><br/></div></div><div id="42284716" class="c"><input type="checkbox" id="c-42284716" checked=""/><div class="controls bullet"><span class="by">shantara</span><span>|</span><a href="#42287182">prev</a><span>|</span><a href="#42284424">next</a><span>|</span><label class="collapse" for="c-42284716">[-]</label><label class="expand" for="c-42284716">[19 more]</label></div><br/><div class="children"><div class="content">This is a wild guess, but could this feature be disabled in an attempt at preventing some publicly undisclosed hardware vulnerability?</div><br/><div id="42287126" class="c"><input type="checkbox" id="c-42287126" checked=""/><div class="controls bullet"><span class="by">BartjeD</span><span>|</span><a href="#42284716">parent</a><span>|</span><a href="#42284847">next</a><span>|</span><label class="collapse" for="c-42287126">[-]</label><label class="expand" for="c-42287126">[1 more]</label></div><br/><div class="children"><div class="content">Quitely disabling it is also a big risk. Because you&#x27;re signalling that in all probablity you were aware of the severity of the issue; Enough so that you took steps to patch it.<p>If you don&#x27;t disclose the vulnerability then affected parties cannot start taking countermeasures, except out of sheer paranoia.<p>Disclosing a vulnerability is a way shift liability onto the end user. You didn&#x27;t update? Then don&#x27;t complain. Only rarely do disclosures lead to product liability. I don&#x27;t remember this (liability) happening with Meltdown and Spectre either. So wouldn&#x27;t assume this is AMD being secretive.</div><br/></div></div><div id="42284847" class="c"><input type="checkbox" id="c-42284847" checked=""/><div class="controls bullet"><span class="by">throw_away_x1y2</span><span>|</span><a href="#42284716">parent</a><span>|</span><a href="#42287126">prev</a><span>|</span><a href="#42285016">next</a><span>|</span><label class="collapse" for="c-42284847">[-]</label><label class="expand" for="c-42284847">[15 more]</label></div><br/><div class="children"><div class="content">Bingo.<p>I can&#x27;t say more.  :(</div><br/><div id="42285102" class="c"><input type="checkbox" id="c-42285102" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42284716">root</a><span>|</span><a href="#42284847">parent</a><span>|</span><a href="#42285016">next</a><span>|</span><label class="collapse" for="c-42285102">[-]</label><label class="expand" for="c-42285102">[14 more]</label></div><br/><div class="children"><div class="content">Have we learned nothing from Spectre and Meltdown?... :(</div><br/><div id="42285327" class="c"><input type="checkbox" id="c-42285327" checked=""/><div class="controls bullet"><span class="by">rincebrain</span><span>|</span><a href="#42284716">root</a><span>|</span><a href="#42285102">parent</a><span>|</span><a href="#42285288">next</a><span>|</span><label class="collapse" for="c-42285327">[-]</label><label class="expand" for="c-42285327">[5 more]</label></div><br/><div class="children"><div class="content">The problem is that we&#x27;re more or less stuck with this class of problem unless we end up with something that looks like a Xeon Phi without shared resources and run calculations on many, many truly independent cores, or we accept that the worst and best case performance cases are identical (which I don&#x27;t foresee anyone really agreeing to).<p>Or, framed differently, if Intel or AMD announced a new gamer CPU tomorrow that was 3x faster in most games but utterly unsafe against all Meltdown&#x2F;Spectre-class vulns, how fast do you think they&#x27;d sell out?</div><br/><div id="42285390" class="c"><input type="checkbox" id="c-42285390" checked=""/><div class="controls bullet"><span class="by">thechao</span><span>|</span><a href="#42284716">root</a><span>|</span><a href="#42285327">parent</a><span>|</span><a href="#42285288">next</a><span>|</span><label class="collapse" for="c-42285390">[-]</label><label class="expand" for="c-42285390">[4 more]</label></div><br/><div class="children"><div class="content">Larabee was fun to program, but I think it&#x27;d have an even worse time hardening memory sideband effects: the barrel processor (which was necessary to have anything like reasonable performance) was humorously easy to use for cross-process exfiltration. Like... it was so easy, we actually used it as an IPC mechanism.</div><br/><div id="42285460" class="c"><input type="checkbox" id="c-42285460" checked=""/><div class="controls bullet"><span class="by">wheybags</span><span>|</span><a href="#42284716">root</a><span>|</span><a href="#42285390">parent</a><span>|</span><a href="#42285549">next</a><span>|</span><label class="collapse" for="c-42285460">[-]</label><label class="expand" for="c-42285460">[2 more]</label></div><br/><div class="children"><div class="content">&gt; it was so easy, we actually used it as an IPC mechanism.<p>Can you elaborate on that? It sounds interesting</div><br/><div id="42286005" class="c"><input type="checkbox" id="c-42286005" checked=""/><div class="controls bullet"><span class="by">thechao</span><span>|</span><a href="#42284716">root</a><span>|</span><a href="#42285460">parent</a><span>|</span><a href="#42285549">next</a><span>|</span><label class="collapse" for="c-42286005">[-]</label><label class="expand" for="c-42286005">[1 more]</label></div><br/><div class="children"><div class="content">Now you’re asking me technical details from more than a decade ago. My recollection is that you could map one of the caches between cores — there were uncached-write-through instructions. By reverse engineering the cache’s hash, you could write to a specific cache-line; the uc-write would push it up into the correct line and the “other core” could snoop that line from its side with a lazy read-and-clear. The whole thing was janky-AF, but way the hell faster than sending a message around the ring. (My recollection was that the three interlocking rings could make the longest-range message take hundreds of cycles.)</div><br/></div></div></div></div><div id="42285549" class="c"><input type="checkbox" id="c-42285549" checked=""/><div class="controls bullet"><span class="by">rincebrain</span><span>|</span><a href="#42284716">root</a><span>|</span><a href="#42285390">parent</a><span>|</span><a href="#42285460">prev</a><span>|</span><a href="#42285288">next</a><span>|</span><label class="collapse" for="c-42285549">[-]</label><label class="expand" for="c-42285549">[1 more]</label></div><br/><div class="children"><div class="content">Sure, absolutely, there&#x27;s large numbers of additional classes of side effects you would need to harden against if you wanted to eliminate everything, I was mostly thinking specifically of something with an enormous number of cores without the 4-way SMT as a high-level description.<p>I was always morbidly curious about programming those, but never to the point of actually buying one, and I always had more things to do in the day than time in past life when we had a few of the cards in my office.</div><br/></div></div></div></div></div></div><div id="42285288" class="c"><input type="checkbox" id="c-42285288" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#42284716">root</a><span>|</span><a href="#42285102">parent</a><span>|</span><a href="#42285327">prev</a><span>|</span><a href="#42285150">next</a><span>|</span><label class="collapse" for="c-42285288">[-]</label><label class="expand" for="c-42285288">[1 more]</label></div><br/><div class="children"><div class="content">I imagine this is more of a functional issue. i.e., the loop buffer caused corruption of the instruction stream under some weird specific circumstances. Spectre and Meltdown are not functional issues but rather just side channel issues.<p>This should be fun, however, for someone with enough time to chase down and try and find the bug. Depending on the consequences of the bug and the conditions under which it hits, maybe you could even write an exploit (either going from JavaScript to the browser or from user mode to the kernel) with it :) Though, I strongly suspect that reverse engineering and weaponizing the bug without any insider knowledge will be exceedingly difficult. And, anyways, there&#x27;s also a decent chance this issue just leads to a hang&#x2F;livelock&#x2F;MCE which would make it pointless to exploit.</div><br/></div></div><div id="42285150" class="c"><input type="checkbox" id="c-42285150" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#42284716">root</a><span>|</span><a href="#42285102">parent</a><span>|</span><a href="#42285288">prev</a><span>|</span><a href="#42285182">next</a><span>|</span><label class="collapse" for="c-42285150">[-]</label><label class="expand" for="c-42285150">[2 more]</label></div><br/><div class="children"><div class="content">Complex systems are complex?</div><br/><div id="42285213" class="c"><input type="checkbox" id="c-42285213" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42284716">root</a><span>|</span><a href="#42285150">parent</a><span>|</span><a href="#42285182">next</a><span>|</span><label class="collapse" for="c-42285213">[-]</label><label class="expand" for="c-42285213">[1 more]</label></div><br/><div class="children"><div class="content">Sadly you&#x27;re right. And obviously we&#x27;re not about to give up on high IPC. I get it and I&#x27;m not judging -- it&#x27;s just a bit saddening.</div><br/></div></div></div></div><div id="42285182" class="c"><input type="checkbox" id="c-42285182" checked=""/><div class="controls bullet"><span class="by">StressedDev</span><span>|</span><a href="#42284716">root</a><span>|</span><a href="#42285102">parent</a><span>|</span><a href="#42285150">prev</a><span>|</span><a href="#42285343">next</a><span>|</span><label class="collapse" for="c-42285182">[-]</label><label class="expand" for="c-42285182">[1 more]</label></div><br/><div class="children"><div class="content">A lot has been learned.  Unfortunately, people still make mistakes and hardware will continue to have security vulnerabilities.</div><br/></div></div><div id="42285343" class="c"><input type="checkbox" id="c-42285343" checked=""/><div class="controls bullet"><span class="by">Am4TIfIsER0ppos</span><span>|</span><a href="#42284716">root</a><span>|</span><a href="#42285102">parent</a><span>|</span><a href="#42285182">prev</a><span>|</span><a href="#42285579">next</a><span>|</span><label class="collapse" for="c-42285343">[-]</label><label class="expand" for="c-42285343">[2 more]</label></div><br/><div class="children"><div class="content">We learned that processor manufacturers love &quot;bugs&quot; that get solved by making them or your code slower giving you incentive to buy a newer one to restore the performance.</div><br/><div id="42285630" class="c"><input type="checkbox" id="c-42285630" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#42284716">root</a><span>|</span><a href="#42285343">parent</a><span>|</span><a href="#42285579">next</a><span>|</span><label class="collapse" for="c-42285630">[-]</label><label class="expand" for="c-42285630">[1 more]</label></div><br/><div class="children"><div class="content">This seems unnecessarily cynical. Are you saying Intel&#x2F;AMD are intentionally crippling CPUs?</div><br/></div></div></div></div><div id="42285579" class="c"><input type="checkbox" id="c-42285579" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#42284716">root</a><span>|</span><a href="#42285102">parent</a><span>|</span><a href="#42285343">prev</a><span>|</span><a href="#42285016">next</a><span>|</span><label class="collapse" for="c-42285579">[-]</label><label class="expand" for="c-42285579">[2 more]</label></div><br/><div class="children"><div class="content">I was told the lesson is to avoid Intel and only buy AMD because they don&#x27;t make mistakes.</div><br/><div id="42285662" class="c"><input type="checkbox" id="c-42285662" checked=""/><div class="controls bullet"><span class="by">UberFly</span><span>|</span><a href="#42284716">root</a><span>|</span><a href="#42285579">parent</a><span>|</span><a href="#42285016">next</a><span>|</span><label class="collapse" for="c-42285662">[-]</label><label class="expand" for="c-42285662">[1 more]</label></div><br/><div class="children"><div class="content">No one said to buy AMD because they don&#x27;t make mistakes. AMD just currently makes a better product overall.</div><br/></div></div></div></div></div></div></div></div><div id="42285016" class="c"><input type="checkbox" id="c-42285016" checked=""/><div class="controls bullet"><span class="by">bell-cot</span><span>|</span><a href="#42284716">parent</a><span>|</span><a href="#42284847">prev</a><span>|</span><a href="#42285086">next</a><span>|</span><label class="collapse" for="c-42285016">[-]</label><label class="expand" for="c-42285016">[1 more]</label></div><br/><div class="children"><div class="content">The Article more-or-less speculates that:<p>&gt; Zen 4 is AMD&#x27;s first attempt at putting a loop buffer into a high performance CPU. Validation is always difficult, especially when implementing a feature for the first time. It&#x27;s not crazy to imagine that AMD internally discovered a bug that no one else hit, and decided to turn off the loop buffer out of an abundance of caution. I can&#x27;t think of any other reason AMD would mess with Zen 4&#x27;s frontend this far into the core&#x27;s lifecycle.</div><br/></div></div><div id="42285086" class="c"><input type="checkbox" id="c-42285086" checked=""/><div class="controls bullet"><span class="by">bhouston</span><span>|</span><a href="#42284716">parent</a><span>|</span><a href="#42285016">prev</a><span>|</span><a href="#42284424">next</a><span>|</span><label class="collapse" for="c-42285086">[-]</label><label class="expand" for="c-42285086">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, my first thoughts too.</div><br/></div></div></div></div><div id="42284424" class="c"><input type="checkbox" id="c-42284424" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#42284716">prev</a><span>|</span><a href="#42284377">next</a><span>|</span><label class="collapse" for="c-42284424">[-]</label><label class="expand" for="c-42284424">[17 more]</label></div><br/><div class="children"><div class="content">The article seems to suggest that the loop buffer provides no performance benefit and no power benefit.<p>If so, it might be a classic case of &quot;Team of engineers spent months working on new shiny feature which turned out to not actually have any benefit, but was shipped anyway, possibly so someone could save face&quot;.<p>I see this in software teams when someone suggests it&#x27;s time to rewrite the codebase to get rid of legacy bloat and increase performance.    Yet, when the project is done, there are more lines of code and performance is worse.<p>In both cases, the project shouldn&#x27;t have shipped.</div><br/><div id="42284569" class="c"><input type="checkbox" id="c-42284569" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#42284424">parent</a><span>|</span><a href="#42284530">next</a><span>|</span><label class="collapse" for="c-42284569">[-]</label><label class="expand" for="c-42284569">[3 more]</label></div><br/><div class="children"><div class="content">&gt; but was shipped anyway, possibly so someone could save face<p>Was shipped anyway because it can be disabled with a firmware update and because drastically altering physical hardware layouts mid design was likely to have worse impacts.</div><br/><div id="42285541" class="c"><input type="checkbox" id="c-42285541" checked=""/><div class="controls bullet"><span class="by">eek2121</span><span>|</span><a href="#42284424">root</a><span>|</span><a href="#42284569">parent</a><span>|</span><a href="#42285030">next</a><span>|</span><label class="collapse" for="c-42285541">[-]</label><label class="expand" for="c-42285541">[1 more]</label></div><br/><div class="children"><div class="content">Well that and changing a chip can take years due to redesigning, putting through validation, RTM, and time to create.<p>Building chips is a multiyear process and most folks don’t understand this.</div><br/></div></div><div id="42285030" class="c"><input type="checkbox" id="c-42285030" checked=""/><div class="controls bullet"><span class="by">readyplayernull</span><span>|</span><a href="#42284424">root</a><span>|</span><a href="#42284569">parent</a><span>|</span><a href="#42285541">prev</a><span>|</span><a href="#42284530">next</a><span>|</span><label class="collapse" for="c-42285030">[-]</label><label class="expand" for="c-42285030">[1 more]</label></div><br/><div class="children"><div class="content">That bathroom with a door to the kitchen.</div><br/></div></div></div></div><div id="42284530" class="c"><input type="checkbox" id="c-42284530" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#42284424">parent</a><span>|</span><a href="#42284569">prev</a><span>|</span><a href="#42286945">next</a><span>|</span><label class="collapse" for="c-42284530">[-]</label><label class="expand" for="c-42284530">[6 more]</label></div><br/><div class="children"><div class="content">&gt; but was shipped anyway, possibly so someone could save face<p>no. once the core has it and you realize it doesn&#x27;t help much, it absolutely is a risk to remove it.</div><br/><div id="42284676" class="c"><input type="checkbox" id="c-42284676" checked=""/><div class="controls bullet"><span class="by">glzone1</span><span>|</span><a href="#42284424">root</a><span>|</span><a href="#42284530">parent</a><span>|</span><a href="#42286945">next</a><span>|</span><label class="collapse" for="c-42284676">[-]</label><label class="expand" for="c-42284676">[5 more]</label></div><br/><div class="children"><div class="content">No kidding. I was adjacent to a tape out w some last minute tweaks - ugh. The problem is the current cycle time is very slow and costly and u spend as much time validating things as you do designing. It’s not programming.</div><br/><div id="42284970" class="c"><input type="checkbox" id="c-42284970" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42284424">root</a><span>|</span><a href="#42284676">parent</a><span>|</span><a href="#42286972">next</a><span>|</span><label class="collapse" for="c-42284970">[-]</label><label class="expand" for="c-42284970">[1 more]</label></div><br/><div class="children"><div class="content">Once interviewed at a place which made sensors that was used a lot in the oil industry. Once you put a sensor on the bottom of the ocean 100+ meters (300+ feet) down, they&#x27;re not getting serviced any time soon.<p>They showed me the facilities, and the vast majority was taken up by testing and validation rigs. The sensors would go through many stages, taking several weeks.<p>The final stage had an adjacent room with a viewing window and a nice couch, so a representative for the client could watch the final tests before bringing the sensors back.<p>Quite the opposite to the &quot;just publish a patch&quot; mentality that&#x27;s so prevalent these days.</div><br/></div></div><div id="42286972" class="c"><input type="checkbox" id="c-42286972" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#42284424">root</a><span>|</span><a href="#42284676">parent</a><span>|</span><a href="#42284970">prev</a><span>|</span><a href="#42284771">next</a><span>|</span><label class="collapse" for="c-42286972">[-]</label><label class="expand" for="c-42286972">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It’s not programming.<p>Even for software it’s often risky to remove code once it’s in there. Lots of software products are shipped with tons of unused code and assets because no one’s got time to validate nothing’s gonna go wrong when you remove them. Check out some game teardowns, they often have dead assets from years ago, sometimes even completely unrelated things from the studio’s past projects.<p>Of course it’s 100x worse for hardware projects.</div><br/></div></div><div id="42284771" class="c"><input type="checkbox" id="c-42284771" checked=""/><div class="controls bullet"><span class="by">hajile</span><span>|</span><a href="#42284424">root</a><span>|</span><a href="#42284676">parent</a><span>|</span><a href="#42286972">prev</a><span>|</span><a href="#42286945">next</a><span>|</span><label class="collapse" for="c-42284771">[-]</label><label class="expand" for="c-42284771">[2 more]</label></div><br/><div class="children"><div class="content">If you work on a critical piece of software (especially one you can&#x27;t update later), you absolutely can spend way more time validating than you do writing code.<p>The ease of pushing updates encourages lazy coding.</div><br/><div id="42285020" class="c"><input type="checkbox" id="c-42285020" checked=""/><div class="controls bullet"><span class="by">chefandy</span><span>|</span><a href="#42284424">root</a><span>|</span><a href="#42284771">parent</a><span>|</span><a href="#42286945">next</a><span>|</span><label class="collapse" for="c-42285020">[-]</label><label class="expand" for="c-42285020">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The ease of pushing updates encourages lazy coding.<p>Certainly in some cases, but in others, it just shifts the economics: Obviously, fault tolerance can be laborious and time consuming, and that time and labor is taken from something else. When the natures of your dev and distribution pipelines render faults less disruptive, and you  have a good foundational codebase and code review process that pay attention to security and core stability, quickly creating 3 working features can be much, much more valuable than making sure 1 working feature will never ever generate a support ticket.</div><br/></div></div></div></div></div></div></div></div><div id="42286945" class="c"><input type="checkbox" id="c-42286945" checked=""/><div class="controls bullet"><span class="by">01100011</span><span>|</span><a href="#42284424">parent</a><span>|</span><a href="#42284530">prev</a><span>|</span><a href="#42285325">next</a><span>|</span><label class="collapse" for="c-42286945">[-]</label><label class="expand" for="c-42286945">[1 more]</label></div><br/><div class="children"><div class="content">Working at.. a very popular HW company.. I&#x27;ll say that we(the SW folks) are currently obsessed with &#x27;doing something&#x27; even if the thing we&#x27;re doing hasn&#x27;t fully been proven to have benefits outside of some narrow use cases or targeted benchmarks.  It&#x27;s very frustrating, but no one wants to put the time in to do the research up front.  It&#x27;s easier to just move forward with a new project because upper management stays happy and doesn&#x27;t ask questions.</div><br/></div></div><div id="42285325" class="c"><input type="checkbox" id="c-42285325" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#42284424">parent</a><span>|</span><a href="#42286945">prev</a><span>|</span><a href="#42286913">next</a><span>|</span><label class="collapse" for="c-42285325">[-]</label><label class="expand" for="c-42285325">[2 more]</label></div><br/><div class="children"><div class="content">The article also mentions they had trouble measuring power usage in general so we can&#x27;t necessarily (and, really, shouldn&#x27;t) conclude that it has no impact whatsoever. I highly doubt that AMD&#x27;s engineering teams are so unprincipled as to allow people to add HW features with no value (why would you dedicate area and power to a feature which doesn&#x27;t do anything?), and so I&#x27;m inclined to give them the benefit of the doubt here and assume that Chips &#x27;n Cheese simply couldn&#x27;t measure the impact.</div><br/><div id="42286923" class="c"><input type="checkbox" id="c-42286923" checked=""/><div class="controls bullet"><span class="by">clamchowder</span><span>|</span><a href="#42284424">root</a><span>|</span><a href="#42285325">parent</a><span>|</span><a href="#42286913">next</a><span>|</span><label class="collapse" for="c-42286923">[-]</label><label class="expand" for="c-42286923">[1 more]</label></div><br/><div class="children"><div class="content">Note - I saw the article through from start to finish. For power measurements I modified my memory bandwidth test to read AMD&#x27;s core energy status MSR, and modified the instruction bandwidth testing part to create a loop within the test array. (<a href="https:&#x2F;&#x2F;github.com&#x2F;clamchowder&#x2F;Microbenchmarks&#x2F;commit&#x2F;6942abee3688a28605db8026ff7f977c7b2e5b21">https:&#x2F;&#x2F;github.com&#x2F;clamchowder&#x2F;Microbenchmarks&#x2F;commit&#x2F;6942ab...</a>)<p>Remember most of the technical analysis on Chips and Cheese is a one person effort, and I simply don&#x27;t have infinite free time or equipment to dig deeper into power. That&#x27;s why I wrote &quot;Perhaps some more mainstream tech outlets will figure out AMD disabled the loop buffer at some point, and do testing that I personally lack the time and resources to carry out.&quot;</div><br/></div></div></div></div><div id="42286913" class="c"><input type="checkbox" id="c-42286913" checked=""/><div class="controls bullet"><span class="by">iforgotpassword</span><span>|</span><a href="#42284424">parent</a><span>|</span><a href="#42285325">prev</a><span>|</span><a href="#42286885">next</a><span>|</span><label class="collapse" for="c-42286913">[-]</label><label class="expand" for="c-42286913">[1 more]</label></div><br/><div class="children"><div class="content">Well the other possibility is that the power benchmarks are accurate: the buffer did save power, but then they figured out an even better optimization on the microcodes level that would make the regular path save even more power, so the buffer actually became a power hog.</div><br/></div></div><div id="42286885" class="c"><input type="checkbox" id="c-42286885" checked=""/><div class="controls bullet"><span class="by">EVa5I7bHFq9mnYK</span><span>|</span><a href="#42284424">parent</a><span>|</span><a href="#42286913">prev</a><span>|</span><a href="#42285093">next</a><span>|</span><label class="collapse" for="c-42286885">[-]</label><label class="expand" for="c-42286885">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; when the project is done, there are more lines of code and performance is worse<p>There is an added benefit though - that the new programmers now are fluent in the code base. That benefit might be worth more than LOCs or performance.</div><br/></div></div><div id="42285093" class="c"><input type="checkbox" id="c-42285093" checked=""/><div class="controls bullet"><span class="by">ksaj</span><span>|</span><a href="#42284424">parent</a><span>|</span><a href="#42286885">prev</a><span>|</span><a href="#42286292">next</a><span>|</span><label class="collapse" for="c-42285093">[-]</label><label class="expand" for="c-42285093">[1 more]</label></div><br/><div class="children"><div class="content">&quot;the project shouldn&#x27;t have shipped.&quot;<p>Tell that to the share holders. As a public company, they can very quickly lose enormous amounts of money by being behind or below on just about anything.</div><br/></div></div><div id="42286292" class="c"><input type="checkbox" id="c-42286292" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42284424">parent</a><span>|</span><a href="#42285093">prev</a><span>|</span><a href="#42284377">next</a><span>|</span><label class="collapse" for="c-42286292">[-]</label><label class="expand" for="c-42286292">[1 more]</label></div><br/><div class="children"><div class="content">Only on Hacker News will you get CPU validation fanfiction.</div><br/></div></div></div></div><div id="42284377" class="c"><input type="checkbox" id="c-42284377" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#42284424">prev</a><span>|</span><a href="#42284678">next</a><span>|</span><label class="collapse" for="c-42284377">[-]</label><label class="expand" for="c-42284377">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Strangely, the game sees a 5% performance loss with the loop buffer disabled when pinned to the non-VCache die. I have no explanation for this, […]<p>With more detailed power measurements, it could be possible to determine if this is thermal&#x2F;power budget related?  It does sound like the feature was intended to conserve power…</div><br/><div id="42285578" class="c"><input type="checkbox" id="c-42285578" checked=""/><div class="controls bullet"><span class="by">eek2121</span><span>|</span><a href="#42284377">parent</a><span>|</span><a href="#42286780">next</a><span>|</span><label class="collapse" for="c-42285578">[-]</label><label class="expand" for="c-42285578">[2 more]</label></div><br/><div class="children"><div class="content">He didn’t provide enough detail here. The second CCD on a Ryzen chip is not as well binned as the first one even on. non-X3D chips. Also, EVERY chip is different.<p>Most of the cores on CCD0 of my non-X3D chip hit 5.6-5.75ghz. CCD 1 has cores topping out at 5.4-5.5ghz.<p>V-Cache chips for Zen 4 have a huge clock penalty, however the Cache more than makes up for it.<p>Did he test CCD1 on the same chip with both the feature disabled and enabled? Did he attempt to isolate other changes like security fixes as well? He admitted “no” in his article.<p>The only proper way to test would be to find a way to disable the feature on a bios that has it enabled and test both scenarios across the same chip, and even then the result may still not be accurate due to other possible branch conditions. A full performance profile could bring accuracy, but I suspect only an AMD engineer could do that…</div><br/><div id="42286745" class="c"><input type="checkbox" id="c-42286745" checked=""/><div class="controls bullet"><span class="by">clamchowder</span><span>|</span><a href="#42284377">root</a><span>|</span><a href="#42285578">parent</a><span>|</span><a href="#42286780">next</a><span>|</span><label class="collapse" for="c-42286745">[-]</label><label class="expand" for="c-42286745">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I tested on CCD1 (the non-vcache CCD) on both BIOS versions.</div><br/></div></div></div></div><div id="42286780" class="c"><input type="checkbox" id="c-42286780" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42284377">parent</a><span>|</span><a href="#42285578">prev</a><span>|</span><a href="#42284678">next</a><span>|</span><label class="collapse" for="c-42286780">[-]</label><label class="expand" for="c-42286780">[1 more]</label></div><br/><div class="children"><div class="content">He mentioned that it was disabled somewhere between the two UEFI versions he tested. Presumably there are other changes included, so his measurements are not strict A&#x2F;B testing.</div><br/></div></div></div></div><div id="42284678" class="c"><input type="checkbox" id="c-42284678" checked=""/><div class="controls bullet"><span class="by">eek2121</span><span>|</span><a href="#42284377">prev</a><span>|</span><a href="#42286957">next</a><span>|</span><label class="collapse" for="c-42284678">[-]</label><label class="expand" for="c-42284678">[5 more]</label></div><br/><div class="children"><div class="content">It sounds to me like it was too small to make any real difference except in very specific scenarios and a larger one would have been too expensive to implement compared to the benefit.<p>That being said, some workloads will see a small regression, however AMD has made some
small performance improvements since launch.<p>They should have just made it a BIOS option for Zen 4. The fact they do not appear to have done so does indicate the possibility of a bug or security issue.</div><br/><div id="42285070" class="c"><input type="checkbox" id="c-42285070" checked=""/><div class="controls bullet"><span class="by">crest</span><span>|</span><a href="#42284678">parent</a><span>|</span><a href="#42286957">next</a><span>|</span><label class="collapse" for="c-42285070">[-]</label><label class="expand" for="c-42285070">[4 more]</label></div><br/><div class="children"><div class="content">Them *quietly* disabling a feature that few users will notice yet complicates the frontend suggests they pulled this chicken bit because they wanted to avoid or delay disclosing a hardware bug to the general public, but already push the mitigation. Fucking vendors! Will they ever learn? <i>sigh</i></div><br/><div id="42287118" class="c"><input type="checkbox" id="c-42287118" checked=""/><div class="controls bullet"><span class="by">BartjeD</span><span>|</span><a href="#42284678">root</a><span>|</span><a href="#42285070">parent</a><span>|</span><a href="#42286467">next</a><span>|</span><label class="collapse" for="c-42287118">[-]</label><label class="expand" for="c-42287118">[1 more]</label></div><br/><div class="children"><div class="content">Quitely disabling it is also a big risk. Because you&#x27;re signalling that in all probablity you were aware of the severity of the issue; Enough so that you took steps to patch it.<p>If you don&#x27;t disclose the vulnerability then affected parties cannot start taking countermeasures, except out of sheer paranoia.<p>Disclosing a vulnerability is a way shift liability onto the end user. You didn&#x27;t update? Then don&#x27;t complain. Only rarely do disclosures lead to product liability. I don&#x27;t remember this (liability) happening with Meltdown and Spectre either. So wouldn&#x27;t assume this is AMD being secretive.</div><br/></div></div><div id="42286467" class="c"><input type="checkbox" id="c-42286467" checked=""/><div class="controls bullet"><span class="by">dannyw</span><span>|</span><a href="#42284678">root</a><span>|</span><a href="#42285070">parent</a><span>|</span><a href="#42287118">prev</a><span>|</span><a href="#42286383">next</a><span>|</span><label class="collapse" for="c-42286467">[-]</label><label class="expand" for="c-42286467">[1 more]</label></div><br/><div class="children"><div class="content">Every modern CPU has dozens of hardware bugs that aren’t disclosed and quietly patched away or not mentioned.</div><br/></div></div><div id="42286383" class="c"><input type="checkbox" id="c-42286383" checked=""/><div class="controls bullet"><span class="by">whaleofatw2022</span><span>|</span><a href="#42284678">root</a><span>|</span><a href="#42285070">parent</a><span>|</span><a href="#42286467">prev</a><span>|</span><a href="#42286957">next</a><span>|</span><label class="collapse" for="c-42286383">[-]</label><label class="expand" for="c-42286383">[1 more]</label></div><br/><div class="children"><div class="content">Devils advocate... if this is being actively exploited or is easily exploitable, the delay in announcement can prevent other actions.</div><br/></div></div></div></div></div></div><div id="42286957" class="c"><input type="checkbox" id="c-42286957" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#42284678">prev</a><span>|</span><a href="#42284190">next</a><span>|</span><label class="collapse" for="c-42286957">[-]</label><label class="expand" for="c-42286957">[1 more]</label></div><br/><div class="children"><div class="content">Interesting that in the Cortex-A15 this is a &quot;key design feature&quot;. Are there any numbers about its effect other chips?<p>I guess this could also be used as an optimization target at least on devices that are more long lived designs (eg consoles).</div><br/></div></div><div id="42284190" class="c"><input type="checkbox" id="c-42284190" checked=""/><div class="controls bullet"><span class="by">syntaxing</span><span>|</span><a href="#42286957">prev</a><span>|</span><a href="#42284454">next</a><span>|</span><label class="collapse" for="c-42284190">[-]</label><label class="expand" for="c-42284190">[6 more]</label></div><br/><div class="children"><div class="content">Interesting read, one thing I don’t understand is how much space does loop buffer take on the die? I’m curious with it removed, on future chips could you use the space for something more useful like a bigger L2 cache?</div><br/><div id="42284579" class="c"><input type="checkbox" id="c-42284579" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#42284190">parent</a><span>|</span><a href="#42284326">next</a><span>|</span><label class="collapse" for="c-42284579">[-]</label><label class="expand" for="c-42284579">[2 more]</label></div><br/><div class="children"><div class="content">I think most modern chips are routing constrained and not floorspace constrained.  You can build tons of features but getting them all power and normalized signals is an absolute chore.</div><br/></div></div><div id="42284326" class="c"><input type="checkbox" id="c-42284326" checked=""/><div class="controls bullet"><span class="by">Remnant44</span><span>|</span><a href="#42284190">parent</a><span>|</span><a href="#42284579">prev</a><span>|</span><a href="#42284964">next</a><span>|</span><label class="collapse" for="c-42284326">[-]</label><label class="expand" for="c-42284326">[1 more]</label></div><br/><div class="children"><div class="content">My understanding is that it&#x27;s a pretty small optimization on the front end. It doesn&#x27;t have a lot of entries to begin with (144) so the amount of space saved is probably negligible. Theoretically, the loop buffer would let you save power or improve performance in a tight loop. In practice, it doesn&#x27;t seem to do either, and AMD removed it completely for Zen 5.</div><br/></div></div><div id="42284964" class="c"><input type="checkbox" id="c-42284964" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#42284190">parent</a><span>|</span><a href="#42284326">prev</a><span>|</span><a href="#42284324">next</a><span>|</span><label class="collapse" for="c-42284964">[-]</label><label class="expand" for="c-42284964">[1 more]</label></div><br/><div class="children"><div class="content">Judging from the diagrams, the loop buffer is using the same storage as the micro-op queue that&#x27;s there anyway. If that is accurate (and it does seem plausible), then the area cost is just some additional control logic. I suspect the most expensive part is detecting a loop in the first place, but that&#x27;s probably quite small compared to the size of the queue.</div><br/></div></div><div id="42284324" class="c"><input type="checkbox" id="c-42284324" checked=""/><div class="controls bullet"><span class="by">progbits</span><span>|</span><a href="#42284190">parent</a><span>|</span><a href="#42284964">prev</a><span>|</span><a href="#42284454">next</a><span>|</span><label class="collapse" for="c-42284324">[-]</label><label class="expand" for="c-42284324">[1 more]</label></div><br/><div class="children"><div class="content">It says 144 micro-op entries per core. Not sure how many bytes that is, but L2 caches these days are around 1MB per core, so assuming the loop buffer die space is mostly storage (sounds like it) then it wouldn&#x27;t make a notable difference.</div><br/></div></div></div></div><div id="42284454" class="c"><input type="checkbox" id="c-42284454" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#42284190">prev</a><span>|</span><a href="#42285840">next</a><span>|</span><label class="collapse" for="c-42284454">[-]</label><label class="expand" for="c-42284454">[2 more]</label></div><br/><div class="children"><div class="content">In the &quot;power&quot; section, it seems the analysis doesn&#x27;t divide by the number of instructions executed per second.<p>Energy used per instruction is almost certainly the metric that should be considered to see the benefits of this loop buffer, not energy used per second (power, watts).</div><br/><div id="42285671" class="c"><input type="checkbox" id="c-42285671" checked=""/><div class="controls bullet"><span class="by">eek2121</span><span>|</span><a href="#42284454">parent</a><span>|</span><a href="#42285840">next</a><span>|</span><label class="collapse" for="c-42285671">[-]</label><label class="expand" for="c-42285671">[1 more]</label></div><br/><div class="children"><div class="content">Every instruction takes a different amount of clock cycles (and this varies between architectures or iterations of an architecture such as Zen 4-Zen 5), so that is not feasible unless running the workload produced the exact same instructions per cycle, which is impossible due to multi threading&#x2F;tasking. Even order and the contents of RAM matters since both can change everything.<p>While you can somewhat isolate for this by doing hundreds of runs for both on and off, that takes tons of time and still won’t be 100% accurate.<p>Even disabling the feature can cause the code to use a different branch which may shift everything around.<p>I am not specifically familiar with this issue, but I have seen cases where disabling a feature shifted the load from integer units to the FPU or the GPU as an example, or added 2 additional instructions while taking away 5.</div><br/></div></div></div></div><div id="42285840" class="c"><input type="checkbox" id="c-42285840" checked=""/><div class="controls bullet"><span class="by">CalChris</span><span>|</span><a href="#42284454">prev</a><span>|</span><a href="#42286335">next</a><span>|</span><label class="collapse" for="c-42285840">[-]</label><label class="expand" for="c-42285840">[2 more]</label></div><br/><div class="children"><div class="content">If it saved power wouldn’t that lead to less thermal throttling and thus improved performance? That power had to matter in the first place or it wouldn’t have been worth it in the first place.</div><br/><div id="42285992" class="c"><input type="checkbox" id="c-42285992" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#42285840">parent</a><span>|</span><a href="#42286335">next</a><span>|</span><label class="collapse" for="c-42285992">[-]</label><label class="expand" for="c-42285992">[1 more]</label></div><br/><div class="children"><div class="content">Not necessarily. Let&#x27;s say this optimization can save 0.1w in certain situations. If one of those situations is common when the chip is idle just keeping wifi alive, well hey that&#x27;s 0.1w in a ~1w total draw scenario, that&#x27;s 10% that&#x27;s huge!<p>But when the CPU is pulling 100w under load? Well now we&#x27;re talking an amount so small it&#x27;s irrelevant. Maybe with a well calibrated scope you could figure out if it was on or not.<p>Since this is in the micro-op queue in the front end, it&#x27;s going to be more about that very low total power draw side of things where this comes into play. So this would have been something they were doing to see if it helped for the laptop skus, not for the desktop ones.</div><br/></div></div></div></div><div id="42286335" class="c"><input type="checkbox" id="c-42286335" checked=""/><div class="controls bullet"><span class="by">mleonhard</span><span>|</span><a href="#42285840">prev</a><span>|</span><a href="#42284573">next</a><span>|</span><label class="collapse" for="c-42286335">[-]</label><label class="expand" for="c-42286335">[1 more]</label></div><br/><div class="children"><div class="content">It looks like they disabled a feature flag.  I didn&#x27;t expect to see such things in CPUs.</div><br/></div></div><div id="42284573" class="c"><input type="checkbox" id="c-42284573" checked=""/><div class="controls bullet"><span class="by">rasz</span><span>|</span><a href="#42286335">prev</a><span>|</span><a href="#42285680">next</a><span>|</span><label class="collapse" for="c-42284573">[-]</label><label class="expand" for="c-42284573">[4 more]</label></div><br/><div class="children"><div class="content">Anecdotally one of very few differences between 1979 68000 and 1982 68010 was addition of &quot;loop mode&quot;, a 6 byte Loop Buffer :)</div><br/><div id="42284750" class="c"><input type="checkbox" id="c-42284750" checked=""/><div class="controls bullet"><span class="by">crest</span><span>|</span><a href="#42284573">parent</a><span>|</span><a href="#42286222">next</a><span>|</span><label class="collapse" for="c-42284750">[-]</label><label class="expand" for="c-42284750">[2 more]</label></div><br/><div class="children"><div class="content">Much more importantly they fixed the MMU support. The original 68000 lost some state required to recover from a page fault the workaround was ugly and expensive: run two CPUs &quot;time shifted&quot; by one cycle and inject a recoverable interrupt on the second CPU. Apparently it was still cheaper than the alternatives at the time if you wanted a CPU with MMU, a 32 bit ISA and a 24 bit address bus. Must have been a wild time.</div><br/><div id="42286340" class="c"><input type="checkbox" id="c-42286340" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#42284573">root</a><span>|</span><a href="#42284750">parent</a><span>|</span><a href="#42286222">next</a><span>|</span><label class="collapse" for="c-42286340">[-]</label><label class="expand" for="c-42286340">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; run two CPUs &quot;time shifted&quot; by one cycle and inject a recoverable interrupt on the second CPU.</i><p>That&#x27;s not quite how it was implemented.<p>Instead, the second 68000 was halted and disconnected from the bus until the first 68000 (the executor) trigged a fault. Then the first 68000 would be held in halt, disconnected from the bus and the second 68000 (the fixer) would take over the bus to run the fault handler code.<p>After the fault had been handled, the first 68000 could be released from halt and it would resume execution of the instruction, with all state intact.<p>As for the cost of a second 68000, extra logic and larger PCBs? Well, the of the Motorola 68451 MMU (or equivalent) absolutely dwarfed the cost of everything else, so adding a second CPU really wasn&#x27;t a big deal.<p>Technically it didn&#x27;t need to be another 68000, any CPU would do. But it&#x27;s simpler to use a single ISA.<p>For more details, see Motorola&#x27;s application note here: 
<a href="http:&#x2F;&#x2F;marc.retronik.fr&#x2F;motorola&#x2F;68K&#x2F;68000&#x2F;Application%20Notes&#x2F;DC001_Virtual_Memory_Using_The_MC68000_and_the_MC68451_MMU_%5BMotorola_1982_9p%5D.pdf" rel="nofollow">http:&#x2F;&#x2F;marc.retronik.fr&#x2F;motorola&#x2F;68K&#x2F;68000&#x2F;Application%20Not...</a></div><br/></div></div></div></div><div id="42286222" class="c"><input type="checkbox" id="c-42286222" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#42284573">parent</a><span>|</span><a href="#42284750">prev</a><span>|</span><a href="#42285680">next</a><span>|</span><label class="collapse" for="c-42286222">[-]</label><label class="expand" for="c-42286222">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s neat.  For small loop buffers, I quite like the GreenArrays forth core.  It has 18 bit words that hold 4 instructions each, and one of the opcodes decrements a loop counter and goes back to the start of the word.  And it can run appreciably faster while it&#x27;s doing that.</div><br/></div></div></div></div><div id="42285680" class="c"><input type="checkbox" id="c-42285680" checked=""/><div class="controls bullet"><span class="by">ksec</span><span>|</span><a href="#42284573">prev</a><span>|</span><a href="#42285069">next</a><span>|</span><label class="collapse" for="c-42285680">[-]</label><label class="expand" for="c-42285680">[2 more]</label></div><br/><div class="children"><div class="content">Wondering if Loop Buffer is still there with Zen 5?<p>( Idly waiting for x86 to try and compete with ARM on efficiency. Unfortunately I dont see Zen 6 or Panther Lake getting close. )</div><br/><div id="42285772" class="c"><input type="checkbox" id="c-42285772" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#42285680">parent</a><span>|</span><a href="#42285069">next</a><span>|</span><label class="collapse" for="c-42285772">[-]</label><label class="expand" for="c-42285772">[1 more]</label></div><br/><div class="children"><div class="content">It is not.</div><br/></div></div></div></div></div></div></div></div></div></body></html>