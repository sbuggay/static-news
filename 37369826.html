<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693818074588" as="style"/><link rel="stylesheet" href="styles.css?v=1693818074588"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://raft.github.io">The Raft Consensus Algorithm (2015)</a> <span class="domain">(<a href="https://raft.github.io">raft.github.io</a>)</span></div><div class="subtext"><span>oumua_don17</span> | <span>73 comments</span></div><br/><div><div id="37370718" class="c"><input type="checkbox" id="c-37370718" checked=""/><div class="controls bullet"><span class="by">lpage</span><span>|</span><a href="#37370460">next</a><span>|</span><label class="collapse" for="c-37370718">[-]</label><label class="expand" for="c-37370718">[5 more]</label></div><br/><div class="children"><div class="content">Maelstrom [1], a workbench for learning distributed systems from the creator of Jepsen, includes a simple (model-checked) implementation of Raft and an excellent tutorial on implementing it.<p>Raft is a simple algorithm, but as others have noted, the original paper includes many correctness details often brushed over in toy implementations. Furthermore, the fallibility of real-world hardware (handling memory&#x2F;disk corruption and grey failures), the requirements of real-world systems with tight latency SLAs, and a need for things like flexible quorum&#x2F;dynamic cluster membership make implementing it for production a long and daunting task. The commit history of etcd and hashicorp&#x2F;raft, likely the two most battle-tested open source implementations of raft that still surface correctness bugs on the regular tell you all you need to know.<p>The tigerbeetle team talks in detail about the real-world aspects of distributed systems on imperfect hardware&#x2F;non-abstracted system models, and why they chose viewstamp replication, which predates Paxos but looks more like Raft.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;jepsen-io&#x2F;maelstrom&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;jepsen-io&#x2F;maelstrom&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;tigerbeetle&#x2F;tigerbeetle&#x2F;blob&#x2F;main&#x2F;docs&#x2F;DESIGN.md">https:&#x2F;&#x2F;github.com&#x2F;tigerbeetle&#x2F;tigerbeetle&#x2F;blob&#x2F;main&#x2F;docs&#x2F;DE...</a></div><br/><div id="37375261" class="c"><input type="checkbox" id="c-37375261" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#37370718">parent</a><span>|</span><a href="#37373040">next</a><span>|</span><label class="collapse" for="c-37375261">[-]</label><label class="expand" for="c-37375261">[1 more]</label></div><br/><div class="children"><div class="content">&gt; [Viewstamped replication] predates Paxos but looks more like Raft.<p>Heidi Howard and Richard Mortier’s paper[1] on the topic of Paxos vs Raft has (multi-decree) Paxos and Raft written out in a way that makes it clear that they are very, very close. I’m very far from knowing what consequences (if any) this has for the implementation concerns you state, but the paper is lovely and I wanted to plug it. (There was also a presentation[2], but IMO the text works better when you want to refer back and forth.)<p>[1] <a href="https:&#x2F;&#x2F;doi.org&#x2F;10.1145&#x2F;3380787.3393681" rel="nofollow noreferrer">https:&#x2F;&#x2F;doi.org&#x2F;10.1145&#x2F;3380787.3393681</a><p>[2] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=0K6kt39wyH0">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=0K6kt39wyH0</a></div><br/></div></div><div id="37373040" class="c"><input type="checkbox" id="c-37373040" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#37370718">parent</a><span>|</span><a href="#37375261">prev</a><span>|</span><a href="#37378097">next</a><span>|</span><label class="collapse" for="c-37373040">[-]</label><label class="expand" for="c-37373040">[1 more]</label></div><br/><div class="children"><div class="content">The view-stamped replication paper was surprisingly readable - I&#x27;d never looked at consensus algorithms before in my life and I found I could kind of follow it after a couple of reads.<p><a href="https:&#x2F;&#x2F;dspace.mit.edu&#x2F;bitstream&#x2F;handle&#x2F;1721.1&#x2F;71763&#x2F;MIT-CSAIL-TR-2012-021.pdf?sequence=1" rel="nofollow noreferrer">https:&#x2F;&#x2F;dspace.mit.edu&#x2F;bitstream&#x2F;handle&#x2F;1721.1&#x2F;71763&#x2F;MIT-CSA...</a></div><br/></div></div><div id="37378097" class="c"><input type="checkbox" id="c-37378097" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#37370718">parent</a><span>|</span><a href="#37373040">prev</a><span>|</span><a href="#37371297">next</a><span>|</span><label class="collapse" for="c-37378097">[-]</label><label class="expand" for="c-37378097">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t forget heterogeneous network topologies and the fact that some members make absolutely terrible leaders.</div><br/></div></div><div id="37371297" class="c"><input type="checkbox" id="c-37371297" checked=""/><div class="controls bullet"><span class="by">m00dy</span><span>|</span><a href="#37370718">parent</a><span>|</span><a href="#37378097">prev</a><span>|</span><a href="#37370460">next</a><span>|</span><label class="collapse" for="c-37371297">[-]</label><label class="expand" for="c-37371297">[1 more]</label></div><br/><div class="children"><div class="content">looks like a great playground to get familiar with ds</div><br/></div></div></div></div><div id="37370460" class="c"><input type="checkbox" id="c-37370460" checked=""/><div class="controls bullet"><span class="by">eatonphil</span><span>|</span><a href="#37370718">prev</a><span>|</span><a href="#37371442">next</a><span>|</span><label class="collapse" for="c-37370460">[-]</label><label class="expand" for="c-37370460">[4 more]</label></div><br/><div class="children"><div class="content">I had a fun time recently implementing Raft leader election and log replication (i.e. I didn&#x27;t get to snapshotting&#x2F;checkpointing). One of the most challenging projects I&#x27;ve tried to do.<p>The Raft paper is very gentle to read, and gives you a great intuition on its own. Even if you don&#x27;t want to implement it, you probably use software that uses it: like etcd or consul or cockroach or tidb, etc.<p>I collected all the resources I found useful while doing it here: <a href="https:&#x2F;&#x2F;github.com&#x2F;eatonphil&#x2F;goraft#references">https:&#x2F;&#x2F;github.com&#x2F;eatonphil&#x2F;goraft#references</a>. This includes Diego Ongaro&#x27;s thesis and his TLA+ spec.<p>Some people say Figure 2 of the Raft paper has everything you need but I&#x27;m pretty sure that&#x27;s just not true. It&#x27;s a little bit more vague than looking at the TLA+ spec to me anyway.</div><br/><div id="37370746" class="c"><input type="checkbox" id="c-37370746" checked=""/><div class="controls bullet"><span class="by">agonz253</span><span>|</span><a href="#37370460">parent</a><span>|</span><a href="#37370491">next</a><span>|</span><label class="collapse" for="c-37370746">[-]</label><label class="expand" for="c-37370746">[1 more]</label></div><br/><div class="children"><div class="content">This looks great. However, without a truly comprehensive test suite it’s guaranteed to have a great many subtle bugs :). I recommend trying to hook it up with the tests from MIT’s distributed systems course: <a href="https:&#x2F;&#x2F;pdos.csail.mit.edu&#x2F;6.824&#x2F;labs&#x2F;lab-raft.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;pdos.csail.mit.edu&#x2F;6.824&#x2F;labs&#x2F;lab-raft.html</a>.<p>It looks as though it would take only a minor refactoring at least for the leader election and log replication.</div><br/></div></div><div id="37370491" class="c"><input type="checkbox" id="c-37370491" checked=""/><div class="controls bullet"><span class="by">kevdev</span><span>|</span><a href="#37370460">parent</a><span>|</span><a href="#37370746">prev</a><span>|</span><a href="#37371442">next</a><span>|</span><label class="collapse" for="c-37370491">[-]</label><label class="expand" for="c-37370491">[2 more]</label></div><br/><div class="children"><div class="content">Figure 2 is great, but I would agree the entire paper is needed if you are implementing raft. There are a few specifics in the paper that you need when implementing it.<p>P.S. love your blog :)</div><br/><div id="37370588" class="c"><input type="checkbox" id="c-37370588" checked=""/><div class="controls bullet"><span class="by">eatonphil</span><span>|</span><a href="#37370460">root</a><span>|</span><a href="#37370491">parent</a><span>|</span><a href="#37371442">next</a><span>|</span><label class="collapse" for="c-37370588">[-]</label><label class="expand" for="c-37370588">[1 more]</label></div><br/><div class="children"><div class="content">Cheers!<p>&gt; Figure 2 is great, but I would agree the entire paper is needed if you are implementing raft. There are a few specifics in the paper that you need when implementing it.<p>It was more than that. I&#x27;m blanking on what it was but there were parts where I really couldn&#x27;t find <i>anything</i> about the intended behavior in the paper (let alone in Figure 2) except for in Diego&#x27;s thesis or in the TLA+ spec.<p>Though maybe I was just not reading the paper correctly.</div><br/></div></div></div></div></div></div><div id="37371442" class="c"><input type="checkbox" id="c-37371442" checked=""/><div class="controls bullet"><span class="by">henrik_w</span><span>|</span><a href="#37370460">prev</a><span>|</span><a href="#37370679">next</a><span>|</span><label class="collapse" for="c-37371442">[-]</label><label class="expand" for="c-37371442">[2 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t resist posting this (from Classic Programmer Paintings)<p>“Raft Consensus Algorithm Failure”,Théodore Géricault, 1819<p><a href="https:&#x2F;&#x2F;classicprogrammerpaintings.com&#x2F;post&#x2F;614108749635928064&#x2F;raft-consensus-algorithm-failure-th%C3%A9odore" rel="nofollow noreferrer">https:&#x2F;&#x2F;classicprogrammerpaintings.com&#x2F;post&#x2F;6141087496359280...</a></div><br/><div id="37376372" class="c"><input type="checkbox" id="c-37376372" checked=""/><div class="controls bullet"><span class="by">harryfyx</span><span>|</span><a href="#37371442">parent</a><span>|</span><a href="#37370679">next</a><span>|</span><label class="collapse" for="c-37376372">[-]</label><label class="expand" for="c-37376372">[1 more]</label></div><br/><div class="children"><div class="content">Raft has a TLA+ proof, which should make it &quot;bug free&quot;. I understand your post is a joke, but I wonder if there are actually any errors.</div><br/></div></div></div></div><div id="37370679" class="c"><input type="checkbox" id="c-37370679" checked=""/><div class="controls bullet"><span class="by">galenmarchetti</span><span>|</span><a href="#37371442">prev</a><span>|</span><a href="#37375667">next</a><span>|</span><label class="collapse" for="c-37370679">[-]</label><label class="expand" for="c-37370679">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re interested in consensus algorithms, you might be interested in this book that I used in a theoretical course on distributed system called &quot;Reasoning about Knowledge&quot; (<a href="https:&#x2F;&#x2F;mitpress.mit.edu&#x2F;9780262562003&#x2F;reasoning-about-knowledge&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;mitpress.mit.edu&#x2F;9780262562003&#x2F;reasoning-about-knowl...</a>).<p>You have to invest a bit in learning about modal logic, but once you do get past that part, this book provides proofs of why things like Raft or Paxos work that are super intuitive and straightforward. Basically pushing the complexity of proving these algorithms into the logic structure used to form the proof (in an intuitive way). Highly recommend, changed how I think about consensus!</div><br/></div></div><div id="37375667" class="c"><input type="checkbox" id="c-37375667" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#37370679">prev</a><span>|</span><a href="#37374009">next</a><span>|</span><label class="collapse" for="c-37375667">[-]</label><label class="expand" for="c-37375667">[1 more]</label></div><br/><div class="children"><div class="content">The last time I was working in a setting where a rock-solid Chubby-alike under serious load was constantly top of mind was some years ago, and at that time you used ZK if failure wasn’t an option.<p>But AFAIK people have been putting heavy, heavy work on Raft-based options like etcd and Consul and others for many years now.<p>Is one of those systems like the new best default? Certainly the conceptual clarity and elegance of Raft seem like things that would show up in performance and reliability, but I’m just dated on this.<p>What are people (who aren’t at Google or married to GCP) using as the best practices default when the stakes are high in 2023?<p>I think there’s a production-grade Rust implementation of Raft from IIRC TikV, and a rock-solid, high performance lock server seems squarely in the sweet spot for Rust. Are people using that?</div><br/></div></div><div id="37374009" class="c"><input type="checkbox" id="c-37374009" checked=""/><div class="controls bullet"><span class="by">bjornasm</span><span>|</span><a href="#37375667">prev</a><span>|</span><a href="#37371351">next</a><span>|</span><label class="collapse" for="c-37374009">[-]</label><label class="expand" for="c-37374009">[4 more]</label></div><br/><div class="children"><div class="content">Here is their answer to their own question - &quot;What is Raft?&quot;<p>&gt;Raft is a consensus algorithm that is designed to be easy to understand. It&#x27;s equivalent to Paxos in fault-tolerance and performance. The difference is that it&#x27;s decomposed into relatively independent subproblems, and it cleanly addresses all major pieces needed for practical systems. We hope Raft will make consensus available to a wider audience, and that this wider audience will be able to develop a variety of higher quality consensus-based systems than are available today.<p>After reading that I still have no idea. They are not alone in doing this, but I think its a shame that people don&#x27;t spend the extra time and effort in properly describing their work.</div><br/><div id="37374899" class="c"><input type="checkbox" id="c-37374899" checked=""/><div class="controls bullet"><span class="by">BirdieNZ</span><span>|</span><a href="#37374009">parent</a><span>|</span><a href="#37375247">next</a><span>|</span><label class="collapse" for="c-37374899">[-]</label><label class="expand" for="c-37374899">[2 more]</label></div><br/><div class="children"><div class="content">Arguably it&#x27;s a good description because it automatically filters out audiences who don&#x27;t know what it means; if you&#x27;re building a distributed system and looking at different consensus algorithms then it&#x27;s a simple and clear explanation, but if you aren&#x27;t then it&#x27;s not a relevant algorithm for you anyway!<p>The general class of consensus algorithms are for trying to solve the problem of what to do when you have multiple replicas of a data store across several physical devices, when one or many of the devices or their connections fail in some fashion. They are titled &quot;consensus&quot; because the machines need to come to a consensus for what decision to make about a piece of data when a failure event occurs.<p>For example, you have three servers all replicating the same SQL database:<p>(A) - (B) - (C)<p>The network connection linking (C) to the other two drops; (A) and (B) are notified and (B) is promoted to be the primary (it receives the writes and then distributes them to the replicas).<p>However, (C) doesn&#x27;t know what&#x27;s happened, and continues to receive some writes. The network connection is restored, and now (A) and (B) and (C) need to decide what to do. (B) and (C) have both independently received a different set of writes, and the servers need to come to a consensus on what to do with the data.<p>This is what Raft, Paxos etc. are attempting to solve in a consistent and performant fashion.</div><br/><div id="37376488" class="c"><input type="checkbox" id="c-37376488" checked=""/><div class="controls bullet"><span class="by">abraae</span><span>|</span><a href="#37374009">root</a><span>|</span><a href="#37374899">parent</a><span>|</span><a href="#37375247">next</a><span>|</span><label class="collapse" for="c-37376488">[-]</label><label class="expand" for="c-37376488">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Arguably it&#x27;s a good description because it automatically filters out audiences who don&#x27;t know what it means; if you&#x27;re building a distributed system and looking at different consensus algorithms then it&#x27;s a simple and clear explanation, but if you aren&#x27;t then it&#x27;s not a relevant algorithm for you anyway!<p>Somewhat discourteous to the 99% of people who don&#x27;t fall into the target audience - you&#x27;re leaving it to them to thrash around until they work out for themselves they&#x27;re at the wrong bar.</div><br/></div></div></div></div><div id="37375247" class="c"><input type="checkbox" id="c-37375247" checked=""/><div class="controls bullet"><span class="by">oasisaimlessly</span><span>|</span><a href="#37374009">parent</a><span>|</span><a href="#37374899">prev</a><span>|</span><a href="#37371351">next</a><span>|</span><label class="collapse" for="c-37375247">[-]</label><label class="expand" for="c-37375247">[1 more]</label></div><br/><div class="children"><div class="content">Did you try reading the next paragraph (&quot;Hold on—what is consensus?&quot;)?<p>Sometimes concepts are too &quot;big&quot; to be introduced to someone with no background in a single paragraph; such is life. However, the linked article is a great intro if you manage to keep reading.</div><br/></div></div></div></div><div id="37371351" class="c"><input type="checkbox" id="c-37371351" checked=""/><div class="controls bullet"><span class="by">lucb1e</span><span>|</span><a href="#37374009">prev</a><span>|</span><a href="#37370463">next</a><span>|</span><label class="collapse" for="c-37371351">[-]</label><label class="expand" for="c-37371351">[3 more]</label></div><br/><div class="children"><div class="content">If anyone else doesn&#x27;t understand what the visualisation is supposed to show, note that you can click on one of the nodes and make them fail. Particularly try this with the current &quot;leader&quot; (the thing that&#x27;s sending and receiving all the packets). Press the little pause icon next to the first slider to turn it back into a clock and resume the simulation.<p>Has someone else figured out what the spreadsheet on the right is? It looks broken to me (but so I thought the rest of the simulation was before understanding that it only shows the happy flow by default), as it always remains empty. The clickable elements I discovered so far are the two sliders, the clock&#x2F;pause icon, and the individual servers.</div><br/><div id="37372417" class="c"><input type="checkbox" id="c-37372417" checked=""/><div class="controls bullet"><span class="by">sethev</span><span>|</span><a href="#37371351">parent</a><span>|</span><a href="#37370463">next</a><span>|</span><label class="collapse" for="c-37372417">[-]</label><label class="expand" for="c-37372417">[2 more]</label></div><br/><div class="children"><div class="content">It shows the state of each replica&#x27;s log. Click on the leader and select &#x27;request&#x27; to simulate sending a command. If you take a replica offline, you can see that it falls behind and then gets caught up when it comes back.</div><br/><div id="37372982" class="c"><input type="checkbox" id="c-37372982" checked=""/><div class="controls bullet"><span class="by">lucb1e</span><span>|</span><a href="#37371351">root</a><span>|</span><a href="#37372417">parent</a><span>|</span><a href="#37370463">next</a><span>|</span><label class="collapse" for="c-37372982">[-]</label><label class="expand" for="c-37372982">[1 more]</label></div><br/><div class="children"><div class="content">Ah, thanks, though I pushed that button a couple times (also before your comment) but it didn&#x27;t&#x2F;doesn&#x27;t do anything that I can tell.</div><br/></div></div></div></div></div></div><div id="37370463" class="c"><input type="checkbox" id="c-37370463" checked=""/><div class="controls bullet"><span class="by">kevdev</span><span>|</span><a href="#37371351">prev</a><span>|</span><a href="#37371481">next</a><span>|</span><label class="collapse" for="c-37370463">[-]</label><label class="expand" for="c-37370463">[2 more]</label></div><br/><div class="children"><div class="content">I love this site. When I was learning &amp; implementing raft in my distributed systems course, this page was invaluable. Plus the paper itself is pretty easy to read.</div><br/><div id="37370583" class="c"><input type="checkbox" id="c-37370583" checked=""/><div class="controls bullet"><span class="by">dwheeler</span><span>|</span><a href="#37370463">parent</a><span>|</span><a href="#37371481">next</a><span>|</span><label class="collapse" for="c-37370583">[-]</label><label class="expand" for="c-37370583">[1 more]</label></div><br/><div class="children"><div class="content">I teach a class distributed systems, and this site is one of the references. Thanks for making Raft so clear!</div><br/></div></div></div></div><div id="37371481" class="c"><input type="checkbox" id="c-37371481" checked=""/><div class="controls bullet"><span class="by">henrik_w</span><span>|</span><a href="#37370463">prev</a><span>|</span><a href="#37374836">next</a><span>|</span><label class="collapse" for="c-37371481">[-]</label><label class="expand" for="c-37371481">[1 more]</label></div><br/><div class="children"><div class="content">When I was studying the Raft algorithm a year and a half ago, I found this video on it by John Ousterhout to be a good complement:<p>Designing for Understandability: The Raft Consensus Algorithm<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=vYp4LYbnnW8">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=vYp4LYbnnW8</a></div><br/></div></div><div id="37374836" class="c"><input type="checkbox" id="c-37374836" checked=""/><div class="controls bullet"><span class="by">maxpert</span><span>|</span><a href="#37371481">prev</a><span>|</span><a href="#37370533">next</a><span>|</span><label class="collapse" for="c-37374836">[-]</label><label class="expand" for="c-37374836">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve written a whole SQLite replication system that works on top of RAFT ( <a href="https:&#x2F;&#x2F;github.com&#x2F;maxpert&#x2F;marmot">https:&#x2F;&#x2F;github.com&#x2F;maxpert&#x2F;marmot</a> ). Best part is RAFT has a well understood and strong library ecosystem as well. I started of with libraries and when I noticed I am reimplementing distributed streams, I just took off the shelf implementation (<a href="https:&#x2F;&#x2F;docs.nats.io&#x2F;nats-concepts&#x2F;jetstream" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.nats.io&#x2F;nats-concepts&#x2F;jetstream</a>) and embedded it in system. I love the simplicity and reasoning that comes with RAFT. However I am playing with epaxos these days (<a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~dga&#x2F;papers&#x2F;epaxos-sosp2013.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~dga&#x2F;papers&#x2F;epaxos-sosp2013.pdf</a>), because then I can truly decentralize the implementation for truly masterless implementation. Right now I&#x27;ve added sharding mechanism on various streams so that in high load cases masters can be distributed across nodes too.</div><br/></div></div><div id="37370533" class="c"><input type="checkbox" id="c-37370533" checked=""/><div class="controls bullet"><span class="by">jmholla</span><span>|</span><a href="#37374836">prev</a><span>|</span><a href="#37370603">next</a><span>|</span><label class="collapse" for="c-37370533">[-]</label><label class="expand" for="c-37370533">[17 more]</label></div><br/><div class="children"><div class="content">Are there consensus algorithms that don&#x27;t require changes go through a leader? In many distributed systems, you want to distribute intake as well.</div><br/><div id="37378135" class="c"><input type="checkbox" id="c-37378135" checked=""/><div class="controls bullet"><span class="by">_benedict</span><span>|</span><a href="#37370533">parent</a><span>|</span><a href="#37370725">next</a><span>|</span><label class="collapse" for="c-37378135">[-]</label><label class="expand" for="c-37378135">[1 more]</label></div><br/><div class="children"><div class="content">Leaderless protocols exist in the literature (EPaxos, Caesar, Tempo, ...). These systems usually have a &quot;leader&quot; per transaction, but the leader role is uncontested in normal operation, as it is self-declared by the coordinator of the transaction, so an election only takes place if the coordinator of that transaction fails for whatever reason. Multiple leaders may exist concurrently for any given datum&#x2F;key the operation involves.<p>Cassandra is currently developing a leaderless protocol in this vein called Accord. In fact, Cassandra is already using a leaderless protocol for its LWTs; an optimised variant of classic (single-decree) Paxos, but this has significant overheads when competing transactions are declared for the same key at the same time.</div><br/></div></div><div id="37370725" class="c"><input type="checkbox" id="c-37370725" checked=""/><div class="controls bullet"><span class="by">vhiremath4</span><span>|</span><a href="#37370533">parent</a><span>|</span><a href="#37378135">prev</a><span>|</span><a href="#37375870">next</a><span>|</span><label class="collapse" for="c-37370725">[-]</label><label class="expand" for="c-37370725">[1 more]</label></div><br/><div class="children"><div class="content">There are algos which prioritize high fault tolerance and do so by increasing the number of leaders (or the minimum number of nodes that must have a copy of the lookup data).<p>One such algo is Chord:<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Chord_(peer-to-peer)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Chord_(peer-to-peer)</a><p>It’s a peer-to-peer ring of nodes which have their values consistently hashed between them. The network leverages these things called “finger tables” which essentially store replication information in the form of a table. This table can have information which is incorrect or outdated and the peer you go to can tell you to go to another peer (usually the “next”&#x2F;“successor”) until you find the value (or don’t).<p>Reason this algo can be used with no “leader” is because it can also work by just going to a node and doing a linear scan across all nodes. You don’t need a thumb table to speed up queries.</div><br/></div></div><div id="37375870" class="c"><input type="checkbox" id="c-37375870" checked=""/><div class="controls bullet"><span class="by">Vervious</span><span>|</span><a href="#37370533">parent</a><span>|</span><a href="#37370725">prev</a><span>|</span><a href="#37371786">next</a><span>|</span><label class="collapse" for="c-37375870">[-]</label><label class="expand" for="c-37375870">[1 more]</label></div><br/><div class="children"><div class="content">Not really; there are algorithms where many nodes propose proposals in parallel, but eventually only one of those proposals gets finalized (or they maintain only a partial ordering, not a full ordering). (See Bullshark and redbelly iirc)<p>The main issue is that someone has got to pick a final ordering. If there’s a universe of millions of possible orderings it seems that the most efficient way is to have a single node pick a single one.</div><br/></div></div><div id="37371786" class="c"><input type="checkbox" id="c-37371786" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#37370533">parent</a><span>|</span><a href="#37375870">prev</a><span>|</span><a href="#37370903">next</a><span>|</span><label class="collapse" for="c-37371786">[-]</label><label class="expand" for="c-37371786">[2 more]</label></div><br/><div class="children"><div class="content">Electing a leader and sending changes through the leader simplifies the system and improves throughput and predictability in the presence of contention.<p>If your transactions are on independent topics, you can distribute the load by sharding leaders: assign ranges of the key space to different leaders and manipulate the elections so each node has a reasonable share of leadership.<p>You can go leaderless and structure each write as essentially an election: broadcast the tenative transaction (or a request to transact, if the transaction is large enough) to all nodes, if you get a quorum of acceptance, you win and can commit the transaction. But if multiple nodes attempt transactions near the same time, consensus may be time consuming. If you have many nodes, and they all have pending transactions for the same topic, electing a leader and sending all transactions through the leader is going to be a lot faster than establishing consensus on every transaction individually.</div><br/><div id="37373687" class="c"><input type="checkbox" id="c-37373687" checked=""/><div class="controls bullet"><span class="by">lostcolony</span><span>|</span><a href="#37370533">root</a><span>|</span><a href="#37371786">parent</a><span>|</span><a href="#37370903">next</a><span>|</span><label class="collapse" for="c-37373687">[-]</label><label class="expand" for="c-37373687">[1 more]</label></div><br/><div class="children"><div class="content">Or more succinctly - a quorum agreeing to a leader to serialize writes through is both less work than trying to get a quorum to agree on every individual write, and equally as consistent.</div><br/></div></div></div></div><div id="37370903" class="c"><input type="checkbox" id="c-37370903" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#37370533">parent</a><span>|</span><a href="#37371786">prev</a><span>|</span><a href="#37371186">next</a><span>|</span><label class="collapse" for="c-37370903">[-]</label><label class="expand" for="c-37370903">[1 more]</label></div><br/><div class="children"><div class="content">Paxos doesn&#x27;t favour any node above any other node.<p>That said, if you&#x27;re trying to distribute for the purpose of throughput, then it might be more efficient to only need one leader rather than the quorum that Paxos requires.  Only speculating though.<p>Paxos is also more efficient if calls go to the same place each time - you avoid contention and revotes, etc.</div><br/></div></div><div id="37371186" class="c"><input type="checkbox" id="c-37371186" checked=""/><div class="controls bullet"><span class="by">havnagiggle</span><span>|</span><a href="#37370533">parent</a><span>|</span><a href="#37370903">prev</a><span>|</span><a href="#37372985">next</a><span>|</span><label class="collapse" for="c-37371186">[-]</label><label class="expand" for="c-37371186">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a sharded paxos with a shardmaster. Essentially each shard has its own paxos consensus.</div><br/></div></div><div id="37372985" class="c"><input type="checkbox" id="c-37372985" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#37370533">parent</a><span>|</span><a href="#37371186">prev</a><span>|</span><a href="#37370658">next</a><span>|</span><label class="collapse" for="c-37372985">[-]</label><label class="expand" for="c-37372985">[1 more]</label></div><br/><div class="children"><div class="content">I think in this case there&#x27;s no longer a &#x27;consensus&#x27; - since any node can accept any write immediately.<p>Look into CRDTs, which are essentially algebraic laws for systems that do this and are guaranteed to eventually converge.</div><br/></div></div><div id="37370658" class="c"><input type="checkbox" id="c-37370658" checked=""/><div class="controls bullet"><span class="by">darkmarmot</span><span>|</span><a href="#37370533">parent</a><span>|</span><a href="#37372985">prev</a><span>|</span><a href="#37373272">next</a><span>|</span><label class="collapse" for="c-37370658">[-]</label><label class="expand" for="c-37370658">[1 more]</label></div><br/><div class="children"><div class="content">Many systems have lots of leaders to handle concurrency. Ours has millions of them for instance.</div><br/></div></div><div id="37373272" class="c"><input type="checkbox" id="c-37373272" checked=""/><div class="controls bullet"><span class="by">Racing0461</span><span>|</span><a href="#37370533">parent</a><span>|</span><a href="#37370658">prev</a><span>|</span><a href="#37370628">next</a><span>|</span><label class="collapse" for="c-37373272">[-]</label><label class="expand" for="c-37373272">[1 more]</label></div><br/><div class="children"><div class="content">The original dynamo paper (not dynamodb, its predecessor) didn&#x27;t use leader election. it used quorom with some speed hacks (hinted handoffs and sloppy quorom)</div><br/></div></div><div id="37370628" class="c"><input type="checkbox" id="c-37370628" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#37370533">parent</a><span>|</span><a href="#37373272">prev</a><span>|</span><a href="#37370675">next</a><span>|</span><label class="collapse" for="c-37370628">[-]</label><label class="expand" for="c-37370628">[5 more]</label></div><br/><div class="children"><div class="content">Blockchains</div><br/><div id="37370667" class="c"><input type="checkbox" id="c-37370667" checked=""/><div class="controls bullet"><span class="by">Rhapso</span><span>|</span><a href="#37370533">root</a><span>|</span><a href="#37370628">parent</a><span>|</span><a href="#37370675">next</a><span>|</span><label class="collapse" for="c-37370667">[-]</label><label class="expand" for="c-37370667">[4 more]</label></div><br/><div class="children"><div class="content">No, those only allow 1 leader and 1 intake at a time. They just pick the leader by proof of waste first.</div><br/><div id="37371305" class="c"><input type="checkbox" id="c-37371305" checked=""/><div class="controls bullet"><span class="by">lucb1e</span><span>|</span><a href="#37370533">root</a><span>|</span><a href="#37370667">parent</a><span>|</span><a href="#37370675">next</a><span>|</span><label class="collapse" for="c-37371305">[-]</label><label class="expand" for="c-37371305">[3 more]</label></div><br/><div class="children"><div class="content">I think you may be confusing proof of work with blockchain as a general principle. (I&#x27;m not a fan of this cryptocurrency tech anymore either, my comment is purely about the technical properties which can be interesting to study.)</div><br/><div id="37374237" class="c"><input type="checkbox" id="c-37374237" checked=""/><div class="controls bullet"><span class="by">Detrytus</span><span>|</span><a href="#37370533">root</a><span>|</span><a href="#37371305">parent</a><span>|</span><a href="#37370675">next</a><span>|</span><label class="collapse" for="c-37374237">[-]</label><label class="expand" for="c-37374237">[2 more]</label></div><br/><div class="children"><div class="content">No, GP is right. Without Proof of Work blockchains have no leader - think about Git repo with multiple branches: which one is main? Nothing in blockchain itself determines this, only we, humans chose to name one of them &quot;main&quot; (formerly &quot;master&quot;).</div><br/><div id="37374483" class="c"><input type="checkbox" id="c-37374483" checked=""/><div class="controls bullet"><span class="by">lucb1e</span><span>|</span><a href="#37370533">root</a><span>|</span><a href="#37374237">parent</a><span>|</span><a href="#37370675">next</a><span>|</span><label class="collapse" for="c-37374483">[-]</label><label class="expand" for="c-37374483">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Without Proof of Work blockchains have no leader<p>But, proof of stake?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37370675" class="c"><input type="checkbox" id="c-37370675" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#37370533">parent</a><span>|</span><a href="#37370628">prev</a><span>|</span><a href="#37370603">next</a><span>|</span><label class="collapse" for="c-37370675">[-]</label><label class="expand" for="c-37370675">[1 more]</label></div><br/><div class="children"><div class="content">This paper[1] discusses “termination detection” which consensus can directly be built on with trivial proof. It assumes a single environment, and while mathematically that is a kind of graph node it really maps to all outside sources of input and not a cluster member.<p>[1] <a href="https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;EWD&#x2F;transcriptions&#x2F;EWD06xx&#x2F;EWD687a.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;EWD&#x2F;transcriptions&#x2F;EWD06xx&#x2F;E...</a></div><br/></div></div></div></div><div id="37370603" class="c"><input type="checkbox" id="c-37370603" checked=""/><div class="controls bullet"><span class="by">63</span><span>|</span><a href="#37370533">prev</a><span>|</span><a href="#37375941">next</a><span>|</span><label class="collapse" for="c-37370603">[-]</label><label class="expand" for="c-37370603">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Raft is a consensus algorithm that is designed to be easy to understand.<p>&gt; Consensus typically arises in the context of replicated state machines, a general approach to building fault-tolerant systems.<p>I recognize that I&#x27;m not the intended audience but I do think I would be a lot more capable of understanding this article if it used less jargon or at least defined what it meant. I&#x27;m only mentioning this because ease of understanding is an explicit goal.<p>Can someone give a real world example of where this would be used in a production app? I&#x27;m sure it&#x27;s very practical but I&#x27;m getting caught up in trying to understand what it&#x27;s saying</div><br/><div id="37370665" class="c"><input type="checkbox" id="c-37370665" checked=""/><div class="controls bullet"><span class="by">galenmarchetti</span><span>|</span><a href="#37370603">parent</a><span>|</span><a href="#37370925">next</a><span>|</span><label class="collapse" for="c-37370665">[-]</label><label class="expand" for="c-37370665">[2 more]</label></div><br/><div class="children"><div class="content">Consensus algorithms underly distributed databases like Cassandra, or distributed caches like Redis. (in fact Redis does use a version of Raft).<p>Simple use case, you&#x27;re running a database across three servers, so that users can ping any one of the servers and it still works (fault tolerance).<p>User X pings server A to write something to a table. User Y pings server B to read from that table.<p>How do you make sure that User Y reads what User X wrote, so that User X and User Y are on the same page with what happened?<p>That&#x27;s the consensus algo</div><br/><div id="37370761" class="c"><input type="checkbox" id="c-37370761" checked=""/><div class="controls bullet"><span class="by">couchand</span><span>|</span><a href="#37370603">root</a><span>|</span><a href="#37370665">parent</a><span>|</span><a href="#37370925">next</a><span>|</span><label class="collapse" for="c-37370761">[-]</label><label class="expand" for="c-37370761">[1 more]</label></div><br/><div class="children"><div class="content">Not to be too pedantic, but the step of actually shipping those changes across servers is usually outside the scope of consensus algorithms.  Generally they are limited to picking a single server to act as a short-term leader. That server then is responsible for managing the data itself.<p>Though you can conceive of a system where all data flows through the consensus algorithm, practically speaking that would introduce significant overhead at a granularity where it isn&#x27;t adding value.<p>There isn&#x27;t neceasarily one dictator for the whole cluster, but rather usually they are scoped to each domain that requires serialization.</div><br/></div></div></div></div><div id="37370925" class="c"><input type="checkbox" id="c-37370925" checked=""/><div class="controls bullet"><span class="by">dcchuck</span><span>|</span><a href="#37370603">parent</a><span>|</span><a href="#37370665">prev</a><span>|</span><a href="#37370669">next</a><span>|</span><label class="collapse" for="c-37370925">[-]</label><label class="expand" for="c-37370925">[1 more]</label></div><br/><div class="children"><div class="content">Simplest terms - your app needs several different services or instances of a service to agree upon a value. There are a lot of reasons you can&#x27;t use things like the system clock to agree upon when something happened for example - this is where RAFT steps in.<p>You&#x27;ll see &quot;fault-tolerant&quot; and &quot;replicated state machines&quot; often alongside them. Let&#x27;s break those down in this context.<p>For &quot;fault-tolerance&quot; - think production environments where I need to plan for hardware failure. If one of my services goes down, I want to be able to continue operating - so we run a few copies of the app, and when one goes down, another operating instance will step up.<p>In that case - how do we pick what&#x27;s in charge? How do all copies agree on things while everything is working smoothly? Raft.<p>For &quot;replicated state machines&quot; - let&#x27;s stay in this world of fault-tolerance, where we have multiple instances of our app running. In each service, could reside a state machine. The state machine promises to take any ordered series of events, and always arrive at the same value. Meaning - if all of our instances get the same events in the same order, they will all have the same state. Determinism.<p>This is where it all comes together, and why I think the jargon becomes tightly coupled to an &quot;easy to understand&quot; definition.<p>You will reach for replicated state machines when you need deterministic state across multiple service instances. But the replicated state machines need a way to agree on order and messages received. That&#x27;s the contract - if you give everything all the messages in the same order, everything will be in the same state.<p>But how do we agree on order? How do we agree on what messages were actually received? Just because &quot;Client A&quot; sends a messages &quot;1&quot;, and &quot;2&#x27;, in a specific order does not guaranteed it is delivered at all, let alone in that order.<p>Raft creates &quot;consensus&quot; around these values. It allows the copies to settle on which messages were actually received and when.<p>So, you could use other approaches to manage &quot;all your service copies getting along&quot; but a replicated state machine is a nice approach. That replicated state machine architecture needs some way to agree on order, and Raft is a great choice for that.</div><br/></div></div><div id="37370669" class="c"><input type="checkbox" id="c-37370669" checked=""/><div class="controls bullet"><span class="by">adunk</span><span>|</span><a href="#37370603">parent</a><span>|</span><a href="#37370925">prev</a><span>|</span><a href="#37370823">next</a><span>|</span><label class="collapse" for="c-37370669">[-]</label><label class="expand" for="c-37370669">[2 more]</label></div><br/><div class="children"><div class="content">Wikipedia has a nice list of software using the algorithm: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Raft_(algorithm)#Production_use_of_Raft" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Raft_(algorithm)#Production_us...</a></div><br/><div id="37373162" class="c"><input type="checkbox" id="c-37373162" checked=""/><div class="controls bullet"><span class="by">oriettaxx</span><span>|</span><a href="#37370603">root</a><span>|</span><a href="#37370669">parent</a><span>|</span><a href="#37370823">next</a><span>|</span><label class="collapse" for="c-37373162">[-]</label><label class="expand" for="c-37373162">[1 more]</label></div><br/><div class="children"><div class="content">apparently there is no reference to Docker in swarm mode, where it is used to decide what node should be the Leader</div><br/></div></div></div></div><div id="37370823" class="c"><input type="checkbox" id="c-37370823" checked=""/><div class="controls bullet"><span class="by">uw_rob</span><span>|</span><a href="#37370603">parent</a><span>|</span><a href="#37370669">prev</a><span>|</span><a href="#37374044">next</a><span>|</span><label class="collapse" for="c-37370823">[-]</label><label class="expand" for="c-37370823">[1 more]</label></div><br/><div class="children"><div class="content">Think databases which run across many different machines.<p>Distributed databases are often conceptually modeled as a state machine. Writes are then mutations on the state machine.<p>With a starting state (empty database), if everyone agrees that on a fixed list of mutations which are executed in a rigidity defined ordering, you will get the same final state.<p>Which makes sense, right? If you run the following commands on an empty database, you would expect the same final state:<p>1. CREATE TABLE FOO (Columns = A, B)
1. INSERT INTO FOO (1, 2)
1. INSERT INTO FOO (3, 4)<p>Which would be:<p>```
FOO:
|A|B|
|-|-|
|1|2|
|3|4|
```<p>So where does &quot;consensus&quot; come into play? Consensus is needed to determine `mutation 4`. If the user can send a request to HOST 1 saying &#x27;Mutation 4. should be `INSERT INTO FOO (5, 6)`&#x27; then HOST 1 will need to coordinate together with all of the other hosts and hopefully all of the hosts can agree that this is the 4th mutation and then enact that change on their local replica.<p>This ordering of mutations is called the transaction log.<p>So, why is this such a hard problem? Most of the reasons are in [Fallacies of distributed computing](<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fallacies_of_distributed_computing" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fallacies_of_distributed_compu...</a>) but the tl;dr is that everything in distributed computing is hard because hardware is unreliable and anything that can go wrong will go wrong. Also, because multiple things can be happening at the same time in multiple places so it&#x27;s hard to figure out who came first, etc.<p>RAFT is such an algorithm to let all of these hosts coordinate together in a fault tolerant way to figure out the 4th mutation.<p>Disclaimer: The above is just one use of RAFT. Another way RAFT is used in distributed databases is as a mechanism for the hosts to coordinate a hierarchy of communicate among themselves and when a host in the hierarchy is having problems RAFT can be used again to figure out another hierarchy. (Think consensus is reached on leader election to improve throughput)</div><br/></div></div><div id="37374044" class="c"><input type="checkbox" id="c-37374044" checked=""/><div class="controls bullet"><span class="by">bjornasm</span><span>|</span><a href="#37370603">parent</a><span>|</span><a href="#37370823">prev</a><span>|</span><a href="#37375941">next</a><span>|</span><label class="collapse" for="c-37374044">[-]</label><label class="expand" for="c-37374044">[1 more]</label></div><br/><div class="children"><div class="content">Made a similar comment as this. If it is for a wider audience etc you would think it would be beneficial to explain it in a way that the wider audience understands.</div><br/></div></div></div></div><div id="37375941" class="c"><input type="checkbox" id="c-37375941" checked=""/><div class="controls bullet"><span class="by">Vervious</span><span>|</span><a href="#37370603">prev</a><span>|</span><a href="#37371577">next</a><span>|</span><label class="collapse" for="c-37375941">[-]</label><label class="expand" for="c-37375941">[2 more]</label></div><br/><div class="children"><div class="content">Consensus protocol researcher here. For what it’s worth, I think that the plethora of blockchain research in the last 10 years has made consensus much easier to understand. Raft (in particular, with all of its subtleties) reads (and implements) like Greek in comparison.<p>For a new beginner to consensus protocols, today, I would start them with Bitcoin, and then move onto Paxos&#x2F;Tendermint&#x2F;Simplex, and skip Raft entirely. (Simplex is my paper, a simplified version of PBFT).</div><br/><div id="37376769" class="c"><input type="checkbox" id="c-37376769" checked=""/><div class="controls bullet"><span class="by">woooooo</span><span>|</span><a href="#37375941">parent</a><span>|</span><a href="#37371577">next</a><span>|</span><label class="collapse" for="c-37376769">[-]</label><label class="expand" for="c-37376769">[1 more]</label></div><br/><div class="children"><div class="content">Not a consensus protocol researcher.<p>It seems like blockchain brings a bunch of extra stuff, complexity and cost?  Raft seems comparatively simple to me.<p>What does blockchain bring that&#x27;s easier to maintain and harder to fuck up than &quot;elect a leader and replicate a log&quot;?</div><br/></div></div></div></div><div id="37371577" class="c"><input type="checkbox" id="c-37371577" checked=""/><div class="controls bullet"><span class="by">htowerad3242</span><span>|</span><a href="#37375941">prev</a><span>|</span><a href="#37376093">next</a><span>|</span><label class="collapse" for="c-37371577">[-]</label><label class="expand" for="c-37371577">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a shame many undergraduate CS curricula are allergic to distributed systems and type systems.<p>Even the grad program I was looking at is hot dog water.<p>I&#x27;ve been playing with raft and paxos. Employers will not care as these were learned out-of-band from degree mills.</div><br/></div></div><div id="37376093" class="c"><input type="checkbox" id="c-37376093" checked=""/><div class="controls bullet"><span class="by">valzam</span><span>|</span><a href="#37371577">prev</a><span>|</span><a href="#37374605">next</a><span>|</span><label class="collapse" for="c-37376093">[-]</label><label class="expand" for="c-37376093">[1 more]</label></div><br/><div class="children"><div class="content">Obligatory plug: <a href="http:&#x2F;&#x2F;nil.csail.mit.edu&#x2F;6.824&#x2F;2022&#x2F;schedule.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;nil.csail.mit.edu&#x2F;6.824&#x2F;2022&#x2F;schedule.html</a><p>MIT Distributed Systems course where Raft is implemented as a class assignment (assignment 2). The test suite around the assignment is incredibly valuable and !will! find bugs in your Raft implementation. The assignment is broken up into distinct steps to help people not get stuck when doing everything at once. It is still very challenging to implement everything, especially to get the performance tests to pass.</div><br/></div></div><div id="37374605" class="c"><input type="checkbox" id="c-37374605" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#37376093">prev</a><span>|</span><a href="#37370481">next</a><span>|</span><label class="collapse" for="c-37374605">[-]</label><label class="expand" for="c-37374605">[1 more]</label></div><br/><div class="children"><div class="content">I took a crack at finding the interesting past related threads. Any others?<p>(I&#x27;ve left out posts about particular implementations, extensions, and so on—there are too many. The intention is threads about the algorithm itself.)<p><i>Raft Is So Fetch: The Raft Consensus Algorithm Explained Through Mean Girls</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33071069">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33071069</a> - Oct 2022 (53 comments)<p><i>Raft Consensus Animated (2014)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32484584">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32484584</a> - Aug 2022 (67 comments)<p><i>Why use Paxos instead of Raft?</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32467962">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32467962</a> - Aug 2022 (45 comments)<p><i>In Search of an Understandable Consensus Algorithm (2014) [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29837995">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29837995</a> - Jan 2022 (12 comments)<p><i>Raft Consensus Protocol</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29079079">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29079079</a> - Nov 2021 (51 comments)<p><i>Paxos vs. Raft: Have we reached consensus on distributed consensus?</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27831576">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27831576</a> - July 2021 (48 comments)<p><i>Raft Visualization</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25326645">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25326645</a> - Dec 2020 (35 comments)<p><i>Raft: A Fantastical and Absurd Exploration</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23129707">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23129707</a> - May 2020 (1 comment)<p><i>Understanding Raft Consensus</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23128787">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23128787</a> - May 2020 (3 comments)<p><i>In Search of an Understandable Consensus Algorithm (2014) [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23113419">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23113419</a> - May 2020 (26 comments)<p><i>Paxos vs. Raft: Have we reached consensus on distributed consensus?</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22994420">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22994420</a> - April 2020 (65 comments)<p><i>Raft Is So Fetch: The Raft Consensus Algorithm Explained Through Mean Girls</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22520040">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22520040</a> - March 2020 (4 comments)<p><i>Implementing Raft: Part 2: Commands and Log Replication</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22451959">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22451959</a> - Feb 2020 (16 comments)<p><i>Building a Large-Scale Distributed Storage System Based on Raft</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21447528">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21447528</a> - Nov 2019 (5 comments)<p><i>In Search of an Understandable Consensus Algorithm [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14724883">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14724883</a> - July 2017 (14 comments)<p><i>Instructors&#x27; Guide to Raft</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11300428">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11300428</a> - March 2016 (3 comments)<p><i>Fuzzing Raft for Fun and Publication</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10432062">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10432062</a> - Oct 2015 (10 comments)<p><i>Prove Raft Correct</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10017549">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10017549</a> - Aug 2015 (27 comments)<p><i>Scaling Raft</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9725094">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9725094</a> - June 2015 (12 comments)<p><i>Raft Consensus Algorithm</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9613493">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9613493</a> - May 2015 (24 comments)<p><i>Creator of Raft is speaking at our meetup. What questions do you want answered?</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9351794">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9351794</a> - April 2015 (6 comments)<p><i>Replicating SQLite using Raft Consensus</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9092110">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9092110</a> - Feb 2015 (21 comments)<p><i>Raft Refloated: Do We Have Consensus? [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9015085">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9015085</a> - Feb 2015 (4 comments)<p><i>Analysis of Raft Consensus [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8736868">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8736868</a> - Dec 2014 (3 comments)<p><i>The Raft Consensus Algorithm</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8527440">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8527440</a> - Oct 2014 (27 comments)<p><i>Raft: Understandable Distributed Consensus</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8271957">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8271957</a> - Sept 2014 (79 comments)<p><i>Raft - The Understandable Distributed Protocol</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=6859101">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=6859101</a> - Dec 2013 (10 comments)<p><i>Raft, a scrutable successor to Paxos</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=5624627">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=5624627</a> - April 2013 (2 comments)</div><br/></div></div><div id="37370481" class="c"><input type="checkbox" id="c-37370481" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#37374605">prev</a><span>|</span><a href="#37370449">next</a><span>|</span><label class="collapse" for="c-37370481">[-]</label><label class="expand" for="c-37370481">[4 more]</label></div><br/><div class="children"><div class="content">Anyone using object storage like S3 for cluster coordination&#x2F;election instead?</div><br/><div id="37371500" class="c"><input type="checkbox" id="c-37371500" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#37370481">parent</a><span>|</span><a href="#37373295">next</a><span>|</span><label class="collapse" for="c-37371500">[-]</label><label class="expand" for="c-37371500">[1 more]</label></div><br/><div class="children"><div class="content">Not sure about S3. Iirc they relatively recently implemented consistent writes.<p>But this article explains how to &quot;piggyback&quot; on stores providing consistent writes in order to implement your own little leader election Algo on top of a foundation layer<p><a href="https:&#x2F;&#x2F;cloud.google.com&#x2F;blog&#x2F;topics&#x2F;developers-practitioners&#x2F;implementing-leader-election-google-cloud-storage" rel="nofollow noreferrer">https:&#x2F;&#x2F;cloud.google.com&#x2F;blog&#x2F;topics&#x2F;developers-practitioner...</a></div><br/></div></div><div id="37373295" class="c"><input type="checkbox" id="c-37373295" checked=""/><div class="controls bullet"><span class="by">cweld510</span><span>|</span><a href="#37370481">parent</a><span>|</span><a href="#37371500">prev</a><span>|</span><a href="#37371149">next</a><span>|</span><label class="collapse" for="c-37373295">[-]</label><label class="expand" for="c-37373295">[1 more]</label></div><br/><div class="children"><div class="content">I think S3 is too slow to put in your control plane’s critical path; better to use something like Redis.</div><br/></div></div><div id="37371149" class="c"><input type="checkbox" id="c-37371149" checked=""/><div class="controls bullet"><span class="by">hotpotamus</span><span>|</span><a href="#37370481">parent</a><span>|</span><a href="#37373295">prev</a><span>|</span><a href="#37370449">next</a><span>|</span><label class="collapse" for="c-37371149">[-]</label><label class="expand" for="c-37371149">[1 more]</label></div><br/><div class="children"><div class="content">I want to say that jgroups has an S3 coordination method. I came across quite a few methods while trying to set up a Keycloak cluster in Docker Swarm, but ultimately the Kubernetes DNS method worked best for my case (Swarm seems close enough that I was able to use it with no problem). I&#x27;d also note that my understanding is that Swarm uses the Raft algorithm.</div><br/></div></div></div></div><div id="37370449" class="c"><input type="checkbox" id="c-37370449" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#37370481">prev</a><span>|</span><a href="#37371113">next</a><span>|</span><label class="collapse" for="c-37370449">[-]</label><label class="expand" for="c-37370449">[7 more]</label></div><br/><div class="children"><div class="content">Is Raft byzantine-fault-tolerant though? Can it be made so?<p>Paxos can: <a href="http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Paxos_(computer_science)#Byzantine_Paxos" rel="nofollow noreferrer">http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Paxos_(computer_science)#Byzant...</a></div><br/><div id="37370494" class="c"><input type="checkbox" id="c-37370494" checked=""/><div class="controls bullet"><span class="by">posix86</span><span>|</span><a href="#37370449">parent</a><span>|</span><a href="#37372559">next</a><span>|</span><label class="collapse" for="c-37370494">[-]</label><label class="expand" for="c-37370494">[1 more]</label></div><br/><div class="children"><div class="content">It assumes no malicious agents. If you&#x27;re malicious you can take control over everything with a single message (advertise being the leader of the next term).</div><br/></div></div><div id="37372559" class="c"><input type="checkbox" id="c-37372559" checked=""/><div class="controls bullet"><span class="by">sethev</span><span>|</span><a href="#37370449">parent</a><span>|</span><a href="#37370494">prev</a><span>|</span><a href="#37370455">next</a><span>|</span><label class="collapse" for="c-37372559">[-]</label><label class="expand" for="c-37372559">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a BFT version: <a href="https:&#x2F;&#x2F;www.scs.stanford.edu&#x2F;17au-cs244b&#x2F;labs&#x2F;projects&#x2F;clow_jiang.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.scs.stanford.edu&#x2F;17au-cs244b&#x2F;labs&#x2F;projects&#x2F;clow_...</a></div><br/></div></div><div id="37370455" class="c"><input type="checkbox" id="c-37370455" checked=""/><div class="controls bullet"><span class="by">kevdev</span><span>|</span><a href="#37370449">parent</a><span>|</span><a href="#37372559">prev</a><span>|</span><a href="#37370592">next</a><span>|</span><label class="collapse" for="c-37370455">[-]</label><label class="expand" for="c-37370455">[1 more]</label></div><br/><div class="children"><div class="content">Raft is not byzantine fault tolerant.</div><br/></div></div><div id="37370592" class="c"><input type="checkbox" id="c-37370592" checked=""/><div class="controls bullet"><span class="by">dwheeler</span><span>|</span><a href="#37370449">parent</a><span>|</span><a href="#37370455">prev</a><span>|</span><a href="#37370856">next</a><span>|</span><label class="collapse" for="c-37370592">[-]</label><label class="expand" for="c-37370592">[1 more]</label></div><br/><div class="children"><div class="content">Raft cannot handle Byzatune faults by itself. There are variant algorithms that can.</div><br/></div></div><div id="37370856" class="c"><input type="checkbox" id="c-37370856" checked=""/><div class="controls bullet"><span class="by">u320</span><span>|</span><a href="#37370449">parent</a><span>|</span><a href="#37370592">prev</a><span>|</span><a href="#37371706">next</a><span>|</span><label class="collapse" for="c-37370856">[-]</label><label class="expand" for="c-37370856">[1 more]</label></div><br/><div class="children"><div class="content">Paxos is a family of algorithms of which Raft is a member. You can change Raft in various ways but then it&#x27;s not Raft anymore, but it can still be Paxos. So of course Paxos can &quot;do more&quot;.</div><br/></div></div><div id="37371706" class="c"><input type="checkbox" id="c-37371706" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#37370449">parent</a><span>|</span><a href="#37370856">prev</a><span>|</span><a href="#37371113">next</a><span>|</span><label class="collapse" for="c-37371706">[-]</label><label class="expand" for="c-37371706">[1 more]</label></div><br/><div class="children"><div class="content">No, Raft is mostly for learning the basics of distributed consensus afaik.</div><br/></div></div></div></div><div id="37370576" class="c"><input type="checkbox" id="c-37370576" checked=""/><div class="controls bullet"><span class="by">badcarbine</span><span>|</span><a href="#37371113">prev</a><span>|</span><label class="collapse" for="c-37370576">[-]</label><label class="expand" for="c-37370576">[5 more]</label></div><br/><div class="children"><div class="content">ELI5</div><br/><div id="37371098" class="c"><input type="checkbox" id="c-37371098" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#37370576">parent</a><span>|</span><a href="#37370928">next</a><span>|</span><label class="collapse" for="c-37371098">[-]</label><label class="expand" for="c-37371098">[1 more]</label></div><br/><div class="children"><div class="content">* 1 computer will eventually break (or one service will crash, or be replaced).  To keep processing requests, you need more than 1 computer.<p>* Two-or-more computers can be fed conflicting information.<p>* Consensus algorithms prevent such conflicts from being accepted by the system.<p>* Raft is one such algorithm.  It operates by choosing a leader and then routing all requests via that leader, so that no observers will see a different sequence of requests.</div><br/></div></div><div id="37370928" class="c"><input type="checkbox" id="c-37370928" checked=""/><div class="controls bullet"><span class="by">quest88</span><span>|</span><a href="#37370576">parent</a><span>|</span><a href="#37371098">prev</a><span>|</span><a href="#37371773">next</a><span>|</span><label class="collapse" for="c-37370928">[-]</label><label class="expand" for="c-37370928">[2 more]</label></div><br/><div class="children"><div class="content">You need to at least try.</div><br/><div id="37371071" class="c"><input type="checkbox" id="c-37371071" checked=""/><div class="controls bullet"><span class="by">badcarbine</span><span>|</span><a href="#37370576">root</a><span>|</span><a href="#37370928">parent</a><span>|</span><a href="#37371773">next</a><span>|</span><label class="collapse" for="c-37371071">[-]</label><label class="expand" for="c-37371071">[1 more]</label></div><br/><div class="children"><div class="content">You need to, too.</div><br/></div></div></div></div><div id="37371773" class="c"><input type="checkbox" id="c-37371773" checked=""/><div class="controls bullet"><span class="by">cweagans</span><span>|</span><a href="#37370576">parent</a><span>|</span><a href="#37370928">prev</a><span>|</span><label class="collapse" for="c-37371773">[-]</label><label class="expand" for="c-37371773">[1 more]</label></div><br/><div class="children"><div class="content"><a href="http:&#x2F;&#x2F;thesecretlivesofdata.com&#x2F;raft&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;thesecretlivesofdata.com&#x2F;raft&#x2F;</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>