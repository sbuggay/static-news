<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1691485263556" as="style"/><link rel="stylesheet" href="styles.css?v=1691485263556"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://developers.redhat.com/articles/2023/08/02/beginners-guide-git-version-control">A beginner&#x27;s guide to Git version control</a>Â <span class="domain">(<a href="https://developers.redhat.com">developers.redhat.com</a>)</span></div><div class="subtext"><span>freedude</span> | <span>203 comments</span></div><br/><div><div id="37041853" class="c"><input type="checkbox" id="c-37041853" checked=""/><div class="controls bullet"><span class="by">mlsu</span><span>|</span><a href="#37040865">next</a><span>|</span><label class="collapse" for="c-37041853">[-]</label><label class="expand" for="c-37041853">[42 more]</label></div><br/><div class="children"><div class="content">Git is one of those things that people (including myself) have frequently derided for being &quot;unintuitive&quot;, &quot;full of footguns&quot;, etc.<p>But after looking at other source control options, I find it to be an absolute joy to use -- even for very complex tasks. The VC problem itself is where the complexity lies. Any tool that deals with collaborative working on document will present the same issues that Git does. Maybe worse.<p>Be thankful that you can use any tool you want to create plain-text diffs; that git performs operations quickly; that resets, undo&#x27;s, etc are possible; that the precise history (both of the actual state and the steps taken to get there) is entirely legible; that each command performs a single, well-defined, and well documented atomic operation; that the tool is extensible, command-line script-able, usable locally, free; that it keeps the size of a repository small; that it is scalable across any number of contributors working simultaneously.<p>Some, all, or none of these may be true with other tools.<p>Anyone ever had to do a diff of a Microsoft Visio document by hand? Anyone had to manually type in the name of a document and its revision by hand into a web form? Anyone ever spent an afternoon working on a document, only to realize that someone else already made the changes you made but forgot to update the filaname which caused their changes not to be visible to you? Programmers are spoiled with the best tools in version control. People in other domains are doing this, <i>without even knowing that they are doing this</i>. They are making commits, merging, rebasing, etc.. without even having a word to describe it.</div><br/><div id="37045661" class="c"><input type="checkbox" id="c-37045661" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37041853">parent</a><span>|</span><a href="#37041985">next</a><span>|</span><label class="collapse" for="c-37045661">[-]</label><label class="expand" for="c-37045661">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But after looking at other source control options,<p>...<p>&gt; Anyone ever had to do a diff of a Microsoft Visio document by hand? Anyone had to manually type in the name of a document and its revision by hand into a web form? Anyone ever spent an afternoon working on a document, only to realize that someone else already made the changes you made but forgot to update the filaname which caused their changes not to be visible to you? Programmers are spoiled with the best tools in version control. People in other domains are doing this, without even knowing that they are doing this. They are making commits, merging, rebasing, etc.. without even having a word to describe it.<p>I don&#x27;t see what that last paragraph has to do with git being any good. You&#x27;re  looking at the difficulty of collaboration without revision control, and saying &quot;this shows how good this particular revision control system is&quot;.<p>If you think git is good because of that last paragraph, then it&#x27;s no better than CVS.</div><br/><div id="37045926" class="c"><input type="checkbox" id="c-37045926" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37045661">parent</a><span>|</span><a href="#37041985">next</a><span>|</span><label class="collapse" for="c-37045926">[-]</label><label class="expand" for="c-37045926">[1 more]</label></div><br/><div class="children"><div class="content">That isn&#x27;t the point there. It&#x27;s that we should be thankfuly for text-based tools in general, compared to most other professions&#x27; experience of digital collaboration.</div><br/></div></div></div></div><div id="37041985" class="c"><input type="checkbox" id="c-37041985" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37041853">parent</a><span>|</span><a href="#37045661">prev</a><span>|</span><a href="#37042336">next</a><span>|</span><label class="collapse" for="c-37041985">[-]</label><label class="expand" for="c-37041985">[9 more]</label></div><br/><div class="children"><div class="content">Yes and no.<p>Git beautifully matches the problem of collaboration at a fundamental level.<p>The abstractions, the data structures... if not flawless then at least very, very good. (And that is enough to overcome any number of other issues.)<p>The complaints are the inconsistency of the interface. E.g. `git branch`</div><br/><div id="37042057" class="c"><input type="checkbox" id="c-37042057" checked=""/><div class="controls bullet"><span class="by">mlsu</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37041985">parent</a><span>|</span><a href="#37044825">next</a><span>|</span><label class="collapse" for="c-37042057">[-]</label><label class="expand" for="c-37042057">[5 more]</label></div><br/><div class="children"><div class="content">Yes, But I would say that is a minor issue; I appreciate that there actually is lots of documentation for the precise and unchanging behavior of `git branch`!<p>Instead of:<p>&quot;Oh, email this to doc management. Depends on who you get. If you get Nancy, she will double check that your rev C filename matches with your rev D filename in the changes section. Matteo does it differently though, sometimes you do need to include redlines for minor AND major changes, even if the major version gets rev&#x27;d. Oh, that doc doesn&#x27;t have any minor changes at all. I don&#x27;t really know why, but you better not include minor changes because that will be flagged for sure, only on this document though, for every other one you should have C-&gt;D in the footer. Oh that one, the template never got updated so you actually have to type it in manually. Yeah, no idea why it does that.<p>It would be great if you got the change review back by Wednesday because regulatory has a preliminary product summative scheduled Monday. There&#x27;s a confluence page for which doc manager should be CC&#x27;d for each document to get the review back in time.&quot;</div><br/><div id="37043798" class="c"><input type="checkbox" id="c-37043798" checked=""/><div class="controls bullet"><span class="by">throw0101a</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37042057">parent</a><span>|</span><a href="#37044825">next</a><span>|</span><label class="collapse" for="c-37043798">[-]</label><label class="expand" for="c-37043798">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Yes, But I would say that is a minor issue;</i><p>&quot;Just memorize these shell commands and type them to sync up. If you get errors, save your work elsewhere, delete the project, and download a a fresh copy.&quot;<p>* <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1597&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;xkcd.com&#x2F;1597&#x2F;</a></div><br/><div id="37045160" class="c"><input type="checkbox" id="c-37045160" checked=""/><div class="controls bullet"><span class="by">Blackthorn</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37043798">parent</a><span>|</span><a href="#37044813">next</a><span>|</span><label class="collapse" for="c-37045160">[-]</label><label class="expand" for="c-37045160">[1 more]</label></div><br/><div class="children"><div class="content">I wish people would do a little bit of yak shaving when they run into errors (usually some form of merge conflict when pulling) to learn how to fix them, roll back, etc. They would learn how to appreciate the power and flexibility of git then.<p>I&#x27;ve helped people in my own open source project when they hit git roadblocks. They&#x27;ve never needed to save out their work and wipe their repo. There was always a solution within git and once they learned it, they really understood how version control worked much better.</div><br/></div></div><div id="37044813" class="c"><input type="checkbox" id="c-37044813" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37043798">parent</a><span>|</span><a href="#37045160">prev</a><span>|</span><a href="#37044776">next</a><span>|</span><label class="collapse" for="c-37044813">[-]</label><label class="expand" for="c-37044813">[1 more]</label></div><br/><div class="children"><div class="content">If you deeply understand git, I recommend keeping that to yourself, unless you want to be named in git.txt.<p>But being the guy who sort of understood svnmerge.py was <i>much</i> worse.</div><br/></div></div><div id="37044776" class="c"><input type="checkbox" id="c-37044776" checked=""/><div class="controls bullet"><span class="by">mdwalters</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37043798">parent</a><span>|</span><a href="#37044813">prev</a><span>|</span><a href="#37044825">next</a><span>|</span><label class="collapse" for="c-37044776">[-]</label><label class="expand" for="c-37044776">[1 more]</label></div><br/><div class="children"><div class="content">There truly is a XKCD for everything...</div><br/></div></div></div></div></div></div><div id="37044825" class="c"><input type="checkbox" id="c-37044825" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37041985">parent</a><span>|</span><a href="#37042057">prev</a><span>|</span><a href="#37042336">next</a><span>|</span><label class="collapse" for="c-37044825">[-]</label><label class="expand" for="c-37044825">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The abstractions, [â¦] 
The complaints are the inconsistency of the interface. E.g. `git branch`<p>Surely âgit branchâ is âthe abstractionsâ?</div><br/><div id="37044959" class="c"><input type="checkbox" id="c-37044959" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37044825">parent</a><span>|</span><a href="#37042336">next</a><span>|</span><label class="collapse" for="c-37044959">[-]</label><label class="expand" for="c-37044959">[2 more]</label></div><br/><div class="children"><div class="content">Git branches are a model&#x2F;concept&#x2F;abstraction.<p>`git branch` is a CLI command.</div><br/><div id="37045696" class="c"><input type="checkbox" id="c-37045696" checked=""/><div class="controls bullet"><span class="by">LudwigNagasena</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37044959">parent</a><span>|</span><a href="#37042336">next</a><span>|</span><label class="collapse" for="c-37045696">[-]</label><label class="expand" for="c-37045696">[1 more]</label></div><br/><div class="children"><div class="content">Public functions&#x2F;commands are supposed to abstract internal functions&#x2F;commands.</div><br/></div></div></div></div></div></div></div></div><div id="37042336" class="c"><input type="checkbox" id="c-37042336" checked=""/><div class="controls bullet"><span class="by">sverhagen</span><span>|</span><a href="#37041853">parent</a><span>|</span><a href="#37041985">prev</a><span>|</span><a href="#37044412">next</a><span>|</span><label class="collapse" for="c-37042336">[-]</label><label class="expand" for="c-37042336">[12 more]</label></div><br/><div class="children"><div class="content">Up to 2011 I used Subversion. Then I worked for a year for a company that used CVS. So, by comparison, my time with Subversion looks trouble-free, as you can imagine. I&#x27;ve worked in Git ever since, but every time Git makes my feet hurt, I think back with fond memories to Subversion and TortoiseSVN, probably unwarranted so.</div><br/><div id="37042566" class="c"><input type="checkbox" id="c-37042566" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37042336">parent</a><span>|</span><a href="#37045354">next</a><span>|</span><label class="collapse" for="c-37042566">[-]</label><label class="expand" for="c-37042566">[8 more]</label></div><br/><div class="children"><div class="content">Donât even have to go that far back. Mercurial is&#x2F;was a way better ux over a very similar feature set.</div><br/><div id="37043982" class="c"><input type="checkbox" id="c-37043982" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37042566">parent</a><span>|</span><a href="#37045354">next</a><span>|</span><label class="collapse" for="c-37043982">[-]</label><label class="expand" for="c-37043982">[7 more]</label></div><br/><div class="children"><div class="content">I wonder why mercurial didn&#x27;t win.<p>I think it was the performance.</div><br/><div id="37044324" class="c"><input type="checkbox" id="c-37044324" checked=""/><div class="controls bullet"><span class="by">HWR_14</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37043982">parent</a><span>|</span><a href="#37045492">next</a><span>|</span><label class="collapse" for="c-37044324">[-]</label><label class="expand" for="c-37044324">[2 more]</label></div><br/><div class="children"><div class="content">Mercurial was optimized for performance on windows. On other OSes it was worse. But the reason it didn&#x27;t win isn&#x27;t that.<p>It was GitHub. GitHub changed it from &quot;use one of several analogous products&quot;[0] to network effects.<p>[0] Joel, founder of StackOverflow, had a GitHub like competitor that used either git or mercurial commands on the same repository. Just as one example of how similar they are.</div><br/><div id="37044941" class="c"><input type="checkbox" id="c-37044941" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37044324">parent</a><span>|</span><a href="#37045492">next</a><span>|</span><label class="collapse" for="c-37044941">[-]</label><label class="expand" for="c-37044941">[1 more]</label></div><br/><div class="children"><div class="content">But bitbucket supported both</div><br/></div></div></div></div><div id="37045492" class="c"><input type="checkbox" id="c-37045492" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37043982">parent</a><span>|</span><a href="#37044324">prev</a><span>|</span><a href="#37045305">next</a><span>|</span><label class="collapse" for="c-37045492">[-]</label><label class="expand" for="c-37045492">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I wonder why mercurial didn&#x27;t win.<p>Because it&#x27;s called Github, not Mercurialhub ;) (I bet if Github would have chosen Mercurial instead, the popularity would be reversed, at the time I switched to Github I was just looking for an alternative to SourceForge for hosting my open source stuff, but didn&#x27;t care much about the actual version control system).</div><br/></div></div><div id="37045305" class="c"><input type="checkbox" id="c-37045305" checked=""/><div class="controls bullet"><span class="by">madisp</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37043982">parent</a><span>|</span><a href="#37045492">prev</a><span>|</span><a href="#37045108">next</a><span>|</span><label class="collapse" for="c-37045305">[-]</label><label class="expand" for="c-37045305">[1 more]</label></div><br/><div class="children"><div class="content">For me it definitely was performance. 5 years ago or so I ended up using a mercurial-git bridge just to use git on a team where everyone was on hg.<p>IIRC git grep search took seconds compared to more than a minute with hg grep.</div><br/></div></div><div id="37045108" class="c"><input type="checkbox" id="c-37045108" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37043982">parent</a><span>|</span><a href="#37045305">prev</a><span>|</span><a href="#37044278">next</a><span>|</span><label class="collapse" for="c-37045108">[-]</label><label class="expand" for="c-37045108">[1 more]</label></div><br/><div class="children"><div class="content">Mercurial is 30% faster than gitâ¦ to type. Imo it didnât win bc git was cooler because kernel</div><br/></div></div><div id="37044278" class="c"><input type="checkbox" id="c-37044278" checked=""/><div class="controls bullet"><span class="by">nordsieck</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37043982">parent</a><span>|</span><a href="#37045108">prev</a><span>|</span><a href="#37045354">next</a><span>|</span><label class="collapse" for="c-37044278">[-]</label><label class="expand" for="c-37044278">[1 more]</label></div><br/><div class="children"><div class="content">IMO, it really helped that Linux&#x2F;Linus had a lot more fame. At the time there was drama around Bitkeeper, which Linux found acceptable, but was closed source.</div><br/></div></div></div></div></div></div><div id="37045354" class="c"><input type="checkbox" id="c-37045354" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37042336">parent</a><span>|</span><a href="#37042566">prev</a><span>|</span><a href="#37043948">next</a><span>|</span><label class="collapse" for="c-37045354">[-]</label><label class="expand" for="c-37045354">[1 more]</label></div><br/><div class="children"><div class="content">I have exactly opposite experience with Subversion and Tortoise Git from pre 2011.<p>For me it was annoying and janky any conflicts were blocking me for ages. With git itâs a breeze and I would never ever want to go back.</div><br/></div></div><div id="37043948" class="c"><input type="checkbox" id="c-37043948" checked=""/><div class="controls bullet"><span class="by">CivBase</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37042336">parent</a><span>|</span><a href="#37045354">prev</a><span>|</span><a href="#37044412">next</a><span>|</span><label class="collapse" for="c-37043948">[-]</label><label class="expand" for="c-37043948">[2 more]</label></div><br/><div class="children"><div class="content">I started with Git and now work with Subversion. SVN is definitely <i>simpler</i> but I find myself regularly getting frustrated with its relative lack of features and the wait times inherant to centralized version control systems.<p>If I could go back to Git I would in a heartbeat.</div><br/><div id="37044179" class="c"><input type="checkbox" id="c-37044179" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37043948">parent</a><span>|</span><a href="#37044412">next</a><span>|</span><label class="collapse" for="c-37044179">[-]</label><label class="expand" for="c-37044179">[1 more]</label></div><br/><div class="children"><div class="content">You have two options.  You can use the git-svn bridge or manage your own patches.<p>git-svn has a lot of good features that are specific to it, so itâs worth learning it like a new tool rather than a git feature.  Get comfortable with it from some tutorials, then read the man page from top to bottom.  Itâs worth it.<p>The cheapo version is to git init and checkout of your source code, pretend itâs a git project, and then produce a patch for your branch at the end.  You might even be able to use svn and git commands in the same directory?  git for managing your private âwork in progressâ branches, locally, and svn to track upstream and submit work.</div><br/></div></div></div></div></div></div><div id="37044412" class="c"><input type="checkbox" id="c-37044412" checked=""/><div class="controls bullet"><span class="by">8ig8</span><span>|</span><a href="#37041853">parent</a><span>|</span><a href="#37042336">prev</a><span>|</span><a href="#37044601">next</a><span>|</span><label class="collapse" for="c-37044412">[-]</label><label class="expand" for="c-37044412">[1 more]</label></div><br/><div class="children"><div class="content">Have you spent much time using Fossil?<p><a href="https:&#x2F;&#x2F;fossil-scm.org&#x2F;home&#x2F;doc&#x2F;trunk&#x2F;www&#x2F;index.wiki" rel="nofollow noreferrer">https:&#x2F;&#x2F;fossil-scm.org&#x2F;home&#x2F;doc&#x2F;trunk&#x2F;www&#x2F;index.wiki</a></div><br/></div></div><div id="37044601" class="c"><input type="checkbox" id="c-37044601" checked=""/><div class="controls bullet"><span class="by">nvy</span><span>|</span><a href="#37041853">parent</a><span>|</span><a href="#37044412">prev</a><span>|</span><a href="#37043956">next</a><span>|</span><label class="collapse" for="c-37044601">[-]</label><label class="expand" for="c-37044601">[3 more]</label></div><br/><div class="children"><div class="content">&gt;But after looking at other source control options, I find it to be an absolute joy to use<p>Git is objectively pretty janky, though, so it seems to me this statement is an indictment of Subversion and CVS rather than some statement about the virtues of git.<p>I think it&#x27;s much like the case with Wireguard.  It&#x27;s not that wireguard is some super amazing thing to deserve such adulation; it just sucks (a lot) less than what came before it.</div><br/><div id="37044790" class="c"><input type="checkbox" id="c-37044790" checked=""/><div class="controls bullet"><span class="by">mlsu</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37044601">parent</a><span>|</span><a href="#37043956">next</a><span>|</span><label class="collapse" for="c-37044790">[-]</label><label class="expand" for="c-37044790">[2 more]</label></div><br/><div class="children"><div class="content">Nope, I&#x27;m not even talking about subversion or CVS (although, I certainly prefer git to those, and it&#x27;s a fun discussion).<p>I am talking about patched-together workflows developed at regulatory agencies, law offices and the like; collaborative editing of... non-code &quot;information&quot;.<p>People who are doing &quot;version control&quot; but don&#x27;t know <i>that they are</i> doing version control. They are editing documents in parallel. They are changing documents and recording the changes with a paper trail and diffs. They are working on separate parts of the same document in parallel, and managing the conflicts that appear in those documents when they are rev&#x27;d. They are sending their changes to someone else to have them reviewed before they are rev&#x27;d. Version control.<p>Their workflows and their tools are positively prehistoric compared to what is being discussed here.</div><br/><div id="37044966" class="c"><input type="checkbox" id="c-37044966" checked=""/><div class="controls bullet"><span class="by">nvy</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37044790">parent</a><span>|</span><a href="#37043956">next</a><span>|</span><label class="collapse" for="c-37044966">[-]</label><label class="expand" for="c-37044966">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m an aerospace engineer so I know all about Windows shops that operate on the &quot;RequirementsSpec-final (3) Nate&#x27;s comments.docx&quot; school of version control.<p>Half the industry runs on excel spreadsheets.  I feel your pain.</div><br/></div></div></div></div></div></div><div id="37043956" class="c"><input type="checkbox" id="c-37043956" checked=""/><div class="controls bullet"><span class="by">howinteresting</span><span>|</span><a href="#37041853">parent</a><span>|</span><a href="#37044601">prev</a><span>|</span><a href="#37040865">next</a><span>|</span><label class="collapse" for="c-37043956">[-]</label><label class="expand" for="c-37043956">[14 more]</label></div><br/><div class="children"><div class="content">Simple question: why is there no git undo command shipped in box? There is absolutely no technical barrier to shipping such a command.</div><br/><div id="37046184" class="c"><input type="checkbox" id="c-37046184" checked=""/><div class="controls bullet"><span class="by">williamdclt</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37043956">parent</a><span>|</span><a href="#37044663">next</a><span>|</span><label class="collapse" for="c-37046184">[-]</label><label class="expand" for="c-37046184">[1 more]</label></div><br/><div class="children"><div class="content">There is absolutely a ton of technical barrier to shipping this. I don&#x27;t know that much about internals, and I can imagine quite a few off the top of my head.<p>For example: a number of operations are not reversible in the current git model because they&#x27;re not tracked. We&#x27;d need git to start tracking uncommitted changes so that it can restore them on `undo`. That&#x27;s a fundamental change to how git works and I doubt that the idea would be entertained</div><br/></div></div><div id="37044663" class="c"><input type="checkbox" id="c-37044663" checked=""/><div class="controls bullet"><span class="by">jsunderland323</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37043956">parent</a><span>|</span><a href="#37046184">prev</a><span>|</span><a href="#37045307">next</a><span>|</span><label class="collapse" for="c-37044663">[-]</label><label class="expand" for="c-37044663">[5 more]</label></div><br/><div class="children"><div class="content">Do you mean literally deleting your last commit? That would break a lot of the guarantees gained from the append only graph that git exploits for nearly everything it does. I think undo is too ambiguous in the context of vcs that it would be risky to introduce as a part of the cli api. What would you expect undo to do?</div><br/><div id="37044832" class="c"><input type="checkbox" id="c-37044832" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37044663">parent</a><span>|</span><a href="#37045809">next</a><span>|</span><label class="collapse" for="c-37044832">[-]</label><label class="expand" for="c-37044832">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    git reset âhard HEAD~1
</code></pre>
It is already part of the CLI API.<p>Or it could use the ref log (possibly augmented) as a literal undo log, and follow that.<p>&gt; That would break a lot of the guarantees gained from the append only graph that git exploits for nearly everything it does.<p>The graph is really not append-only.</div><br/><div id="37045239" class="c"><input type="checkbox" id="c-37045239" checked=""/><div class="controls bullet"><span class="by">wtallis</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37044832">parent</a><span>|</span><a href="#37045809">next</a><span>|</span><label class="collapse" for="c-37045239">[-]</label><label class="expand" for="c-37045239">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The graph is really not append-only.<p>The commit graph is effectively append-only, but the named pointers <i>into</i> that graph can be reassigned at will, which means some commits can become (more or less) unreachable and eligible for garbage collection.</div><br/></div></div></div></div><div id="37045809" class="c"><input type="checkbox" id="c-37045809" checked=""/><div class="controls bullet"><span class="by">howinteresting</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37044663">parent</a><span>|</span><a href="#37044832">prev</a><span>|</span><a href="#37045307">next</a><span>|</span><label class="collapse" for="c-37045809">[-]</label><label class="expand" for="c-37045809">[2 more]</label></div><br/><div class="children"><div class="content">No, I mean undoing your last action performed with git. Can be a commit, an amend, a reset. whatever.</div><br/><div id="37045934" class="c"><input type="checkbox" id="c-37045934" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37045809">parent</a><span>|</span><a href="#37045307">next</a><span>|</span><label class="collapse" for="c-37045934">[-]</label><label class="expand" for="c-37045934">[1 more]</label></div><br/><div class="children"><div class="content">What about a push :)</div><br/></div></div></div></div></div></div><div id="37045307" class="c"><input type="checkbox" id="c-37045307" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37043956">parent</a><span>|</span><a href="#37044663">prev</a><span>|</span><a href="#37043966">next</a><span>|</span><label class="collapse" for="c-37045307">[-]</label><label class="expand" for="c-37045307">[3 more]</label></div><br/><div class="children"><div class="content">&gt; why is there no git undo command shipped in box? There is absolutely no technical barrier to shipping such a command.<p>To undo something you gotta know what <i>thing-that-you-did</i> to undo in the first place.<p>This is often achieved using the command design pattern, but git does not record commands, nor has such a concept. It only has state.<p>Let&#x27;s imagine it does record commands, what should a purported magical &quot;undo&quot; right after each one of these commands?<p><pre><code>    - git branch topic
    - git branch -f topic cafebead
    - git checkout topic
    - git checkout cafebead
    - git checkout -- file
    - git commit # detached
    - git commit # on branch
    - git commit --amend
    - git reset HEAD^
    - git reset --hard HEAD^
    - git add foo
    - git rm foo
    - git rm --cached bar
    - git merge a b c # merge succeeds
    - git merge a b c # merge fails
    - git merge a b c # merge fails, resolve conflicts, add, continue
    - git merge --abort
    - git cherry-pick
    - git cherry-pick --abort
    - git rebase main
    - git rebase --onto main cafebead^ topic
    - git rebase -i # pick, reword, drop commits, one fails
    - git rebase -i # pick, reword, drop commits, one fails, fix, add, continue
    - git rebase --abort
    - git stash
    - git fetch
    - git pull
</code></pre>
You could come up with answers to that, but then, they would make sense only with one use case of what you intended to do with each command. To cater for that you&#x27;d start to need &quot;git undo --this-way&quot; or &quot;--that-way&quot;. Any command that cannot be undone would break undo. Any external tool would need to operate using only commands, or it would break undo. Any external too or script extending git by chaining commands would need to implement new commands <i>with undo</i> for it not to break undo (otherwise &quot;git undo&quot; would only undo the last one). Also, consider that there may be files untracked in the tree and tracked in other branches, become tracked midway through a merge or rebase and whatnot. It becomes stupendously complex stupendously fast.<p>If &quot;git undo&quot; were made for beginner users to make it more approachable, then it would fail as soon as the user faced a non-undoable situation and not understand why (&quot;this undo is stupid!&quot;). If &quot;git undo&quot; were made for advanced users to make it more convenient, then it would fail as soon as the user used advanced tools or scripts breaking undo.<p>What git chose to do is to be the simplest possible tool: it&#x27;s a DAG made out of commits that can be labeled, and its commands operate on the DAG and labels (with a staging area so that commit creation is transactional). Commits are not removed until they&#x27;re GC&#x27;d and &quot;undoing&quot; is moving back labels to be pointing to commits as they were before, so not having &quot;git undo&quot; is not even dangerous.<p>To make &quot;git undo&quot; robust, git would need to hide and&#x2F;or change its core design + API + UI, which would make it not-git. I&#x27;d argue that part of the success of git is these &quot;internals&quot; (which are its actual interface) made it spectacularly easy to script, extend, compose, write alternative implementations of...<p>The only way to implement &quot;git undo&quot; is to embrace the database-like design (stage manipulation with git add and git rm are preparing a transaction that gets committed with git commit) and explicitly start (git start &#x2F; git begin, records current work tree + refs + index state) and end (git end, a.k.a discard recorded state) or rollback (git undo &#x2F; git rollback, restore recorded state).<p><pre><code>    BEGIN TRANSACTION             git begin
    INSERT INTO ...               echo &gt;&gt; foo &amp;&amp; git add foo &amp;&amp; git commit
    UPDATE ... WHERE              git cherry-pick bar
    DELETE ... (SELECT ...)       git rm baz &amp;&amp; git commit
    COMMIT &#x2F;&#x2F; or ROLLBACK         git end # or git rollback
</code></pre>
Now you gave me some ideas... hold my beer...</div><br/><div id="37045737" class="c"><input type="checkbox" id="c-37045737" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37045307">parent</a><span>|</span><a href="#37045860">next</a><span>|</span><label class="collapse" for="c-37045737">[-]</label><label class="expand" for="c-37045737">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You could come up with answers to that, but then, they would make sense only with one use case of what you intended to do with each command. To cater for that you&#x27;d start to need &quot;git undo --this-way&quot; or &quot;--that-way&quot;.<p>I don&#x27;t think so. Lots of software products that support &quot;undo&quot; support undoing across a greater many actions than git provides, and yet they are able to perform the undo just fine; they don&#x27;t need a special &quot;undo --paint&quot; and &quot;undo --move-object&quot; and &quot;undo --reset-to-default&quot;.<p>There&#x27;s literally nothing special about what git does that can&#x27;t be covered by a general &quot;undo&quot; command which looks at the last git command executed in the local repository and maps that specific intention to an action.<p>When this is not possible (in the middle of a rebase, for example), simply tell the user (as git currently does) that $ACTION is not possible while performing a rebase.</div><br/></div></div><div id="37045860" class="c"><input type="checkbox" id="c-37045860" checked=""/><div class="controls bullet"><span class="by">howinteresting</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37045307">parent</a><span>|</span><a href="#37045737">prev</a><span>|</span><a href="#37043966">next</a><span>|</span><label class="collapse" for="c-37045860">[-]</label><label class="expand" for="c-37045860">[1 more]</label></div><br/><div class="children"><div class="content">This can all be figured out. The only real requirements are careful discipline and a commitment to getting the user experience right.<p>Having an undo command is likely the most leveraged thing by far the git developers can do to make new users unafraid of it. Screw up somehow? Just undo.</div><br/></div></div></div></div><div id="37043966" class="c"><input type="checkbox" id="c-37043966" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37043956">parent</a><span>|</span><a href="#37045307">prev</a><span>|</span><a href="#37040865">next</a><span>|</span><label class="collapse" for="c-37043966">[-]</label><label class="expand" for="c-37043966">[4 more]</label></div><br/><div class="children"><div class="content">Like, git revert? Or git reset?</div><br/><div id="37044315" class="c"><input type="checkbox" id="c-37044315" checked=""/><div class="controls bullet"><span class="by">nordsieck</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37043966">parent</a><span>|</span><a href="#37045829">next</a><span>|</span><label class="collapse" for="c-37044315">[-]</label><label class="expand" for="c-37044315">[1 more]</label></div><br/><div class="children"><div class="content">It would be a wrapper: something like:<p>* git branch hidden current<p>* git do-the-command-here<p>* if we call git undo, checkout the hidden branch, otherwise delete it<p>In practice, I think a lot of people call `git lg` often enough that they can just git reset --hard to a recent commit hash, or they manually create a just-in-case branch if they&#x27;re going to do something risky&#x2F;dangerous.</div><br/></div></div><div id="37045829" class="c"><input type="checkbox" id="c-37045829" checked=""/><div class="controls bullet"><span class="by">howinteresting</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37043966">parent</a><span>|</span><a href="#37044315">prev</a><span>|</span><a href="#37044293">next</a><span>|</span><label class="collapse" for="c-37045829">[-]</label><label class="expand" for="c-37045829">[1 more]</label></div><br/><div class="children"><div class="content">Look at the last repository-altering operation you ran and reverse the effects of it. Add a --dry-run to see what it would do, and print out the command it runs as a way to teach people more advanced things about Git.<p>Microsoft Word has undo. Git can as well.</div><br/></div></div><div id="37044293" class="c"><input type="checkbox" id="c-37044293" checked=""/><div class="controls bullet"><span class="by">hinoki</span><span>|</span><a href="#37041853">root</a><span>|</span><a href="#37043966">parent</a><span>|</span><a href="#37045829">prev</a><span>|</span><a href="#37040865">next</a><span>|</span><label class="collapse" for="c-37044293">[-]</label><label class="expand" for="c-37044293">[1 more]</label></div><br/><div class="children"><div class="content">git reflog?<p>All of those need you to know what youâre doing and what exactly you want to undo</div><br/></div></div></div></div></div></div></div></div><div id="37040865" class="c"><input type="checkbox" id="c-37040865" checked=""/><div class="controls bullet"><span class="by">criddell</span><span>|</span><a href="#37041853">prev</a><span>|</span><a href="#37045747">next</a><span>|</span><label class="collapse" for="c-37040865">[-]</label><label class="expand" for="c-37040865">[26 more]</label></div><br/><div class="children"><div class="content">This image helped me a lot:<p><a href="https:&#x2F;&#x2F;nitter.net&#x2F;pic&#x2F;orig&#x2F;media%2FFjJ62xKXkAYfFjt.jpg" rel="nofollow noreferrer">https:&#x2F;&#x2F;nitter.net&#x2F;pic&#x2F;orig&#x2F;media%2FFjJ62xKXkAYfFjt.jpg</a></div><br/><div id="37044232" class="c"><input type="checkbox" id="c-37044232" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#37040865">parent</a><span>|</span><a href="#37041689">next</a><span>|</span><label class="collapse" for="c-37044232">[-]</label><label class="expand" for="c-37044232">[9 more]</label></div><br/><div class="children"><div class="content">I donât recommend git pull to anyone.  The magical ways that .git&#x2F;config sets up tracked vs untracked branches are too opaque for me.<p>Itâs always been much easier to understand (and explain) whatâs going on when you separate fetch from rebase&#x2F;merge*, and I feel like all these âjust re clone and start againâ memes are all because peopleâs branch tracking broke and they wanted magical âgit push # no further argsâ to work properly again.<p>Once you know how to âgit push remote myref:theirrefâ you become much less dependent on magic.  Knowing about &#x2F; having to know about how it works internally is the fun &#x2F; tedium of git.<p>*Just kidding about doing git merge, btw.  Linear history for life!</div><br/><div id="37044655" class="c"><input type="checkbox" id="c-37044655" checked=""/><div class="controls bullet"><span class="by">nvy</span><span>|</span><a href="#37040865">root</a><span>|</span><a href="#37044232">parent</a><span>|</span><a href="#37044743">next</a><span>|</span><label class="collapse" for="c-37044655">[-]</label><label class="expand" for="c-37044655">[6 more]</label></div><br/><div class="children"><div class="content">Yep.  I&#x27;ve been using git for years and still don&#x27;t really understand the difference between fetch, checkout, and pull.<p>The official docs are dogshit so I just don&#x27;t have time to figure out the minutiae.</div><br/><div id="37044745" class="c"><input type="checkbox" id="c-37044745" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#37040865">root</a><span>|</span><a href="#37044655">parent</a><span>|</span><a href="#37044759">next</a><span>|</span><label class="collapse" for="c-37044745">[-]</label><label class="expand" for="c-37044745">[3 more]</label></div><br/><div class="children"><div class="content">Fetch means âsafely fetch new data from one of your remotes without affecting any of your local workâ.<p>Pull means âdo what fetch does, but with the spicy bonus risk that your precious work will be modified in an unexpected way depending on when and how you checked out the branch youâre on, what version of git you are using, and what config options you have set.â</div><br/><div id="37045786" class="c"><input type="checkbox" id="c-37045786" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37040865">root</a><span>|</span><a href="#37044745">parent</a><span>|</span><a href="#37045609">next</a><span>|</span><label class="collapse" for="c-37045786">[-]</label><label class="expand" for="c-37045786">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Pull means âdo what fetch does, but with the spicy bonus risk that your precious work will be modified in an unexpected way depending on when and how you checked out the branch youâre on, what version of git you are using, and what config options you have set.â<p>That&#x27;s going to happen anyway when you need to rebase&#x2F;merge. May as well type one command (pull), deal with the conflicts and continue, rather than type command, type another command, deal with the conflicts and continue.<p>Unless you have some other strategy that does not include rebasing or merging upstream changes, there&#x27;s no advantage to not pulling. And, TBH, if you workflow is &quot;this branch is worked on while specifically ignoring other changes by other people&quot;, then you have bigger problems than version control.</div><br/></div></div><div id="37045609" class="c"><input type="checkbox" id="c-37045609" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#37040865">root</a><span>|</span><a href="#37044745">parent</a><span>|</span><a href="#37045786">prev</a><span>|</span><a href="#37044759">next</a><span>|</span><label class="collapse" for="c-37045609">[-]</label><label class="expand" for="c-37045609">[1 more]</label></div><br/><div class="children"><div class="content">Can pull screw up your working directory if you haven&#x27;t committed something? I thought that was reserved for `reset --hard`.<p>In any case, I always teach people to commit more. As long as you commit, you can&#x27;t lose anything.</div><br/></div></div></div></div><div id="37044759" class="c"><input type="checkbox" id="c-37044759" checked=""/><div class="controls bullet"><span class="by">skinner927</span><span>|</span><a href="#37040865">root</a><span>|</span><a href="#37044655">parent</a><span>|</span><a href="#37044745">prev</a><span>|</span><a href="#37044743">next</a><span>|</span><label class="collapse" for="c-37044759">[-]</label><label class="expand" for="c-37044759">[2 more]</label></div><br/><div class="children"><div class="content">Fetch updates your local repository (which is behind the scenes, separate from your literal local files).<p>Checkout modifies local files to be like whatever youâre checking out.<p>And pullâs only purpose is to screw up your local files. :)</div><br/><div id="37044944" class="c"><input type="checkbox" id="c-37044944" checked=""/><div class="controls bullet"><span class="by">nvy</span><span>|</span><a href="#37040865">root</a><span>|</span><a href="#37044759">parent</a><span>|</span><a href="#37044743">next</a><span>|</span><label class="collapse" for="c-37044944">[-]</label><label class="expand" for="c-37044944">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Fetch updates your local repository (which is behind the scenes, separate from your literal local files).<p>Therein lies the chief problem with git: it&#x27;s a leaky abstraction.  Nobody actually should give a flying shit about commit hashes and ^HEAD or whatever it&#x27;s called.<p>All the newbie tutorials you find waste so much time on that, but what people really care about when they start using git is &quot;what the fuck happened to my files and how do I get them back the way they were&quot;.<p>Git docs and tutorials are breathtakingly bad at showing this.</div><br/></div></div></div></div></div></div><div id="37044743" class="c"><input type="checkbox" id="c-37044743" checked=""/><div class="controls bullet"><span class="by">skinner927</span><span>|</span><a href="#37040865">root</a><span>|</span><a href="#37044232">parent</a><span>|</span><a href="#37044655">prev</a><span>|</span><a href="#37041689">next</a><span>|</span><label class="collapse" for="c-37044743">[-]</label><label class="expand" for="c-37044743">[2 more]</label></div><br/><div class="children"><div class="content">git pull with fast-forward (--ff-only) is the only sane way to use git pull (if one must use git pull).<p>The most powerful one most people donât use is reset. Soft and hard resets are my bread and butter. I donât even bother with interactive rebases for squashing. I do a soft reset against origin&#x2F;&lt;branch&gt; and create a new commit.</div><br/><div id="37045808" class="c"><input type="checkbox" id="c-37045808" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#37040865">root</a><span>|</span><a href="#37044743">parent</a><span>|</span><a href="#37041689">next</a><span>|</span><label class="collapse" for="c-37045808">[-]</label><label class="expand" for="c-37045808">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d add `git pull --rebase` to that</div><br/></div></div></div></div></div></div><div id="37041689" class="c"><input type="checkbox" id="c-37041689" checked=""/><div class="controls bullet"><span class="by">tempest_</span><span>|</span><a href="#37040865">parent</a><span>|</span><a href="#37044232">prev</a><span>|</span><a href="#37044399">next</a><span>|</span><label class="collapse" for="c-37041689">[-]</label><label class="expand" for="c-37041689">[5 more]</label></div><br/><div class="children"><div class="content">Honestly the picture shown in that thread are fine and most people I have met grok those commands really quick.<p>The issue is git&#x27;s interface is terrible and very powerful. Which means when something goes awry and they land outside those 5 or 6 commands they often have no idea how to fix it. Which invariably leads to a copy paste of their changes and a delete and re-clone.<p>Honestly I really like mercurial. I found its interface better but in this day and age all the tooling is built around git so ...</div><br/><div id="37042433" class="c"><input type="checkbox" id="c-37042433" checked=""/><div class="controls bullet"><span class="by">boneitis</span><span>|</span><a href="#37040865">root</a><span>|</span><a href="#37041689">parent</a><span>|</span><a href="#37044172">next</a><span>|</span><label class="collapse" for="c-37042433">[-]</label><label class="expand" for="c-37042433">[2 more]</label></div><br/><div class="children"><div class="content">&gt; ..when something goes awry and they land outside those 5 or 6 commands..<p>Yes, this. I have no problem adding, rm-ing, branching, making and accepting PRs, etc. These are what the overwhelming majority of git for dummies tutorials cover. (I&#x27;ve even paid for a very well-known and well-reviewed course and completed it.) And, these photos upthread are fantastic for that initial git-101 progression.<p>Then, I eventually landed my first tech-sector job and still haven&#x27;t picked up much more since. My solution to every ounce of apprehension is deleting and re-cloning out of paralysis and fear.<p>I find great difficulty in being able to glean a repository&#x27;s &quot;environment&quot; in a sense analogous to gleaning the environment of an initially compromised machine (the foothold) when you&#x27;ve popped a fresh shell on a boot2root box. (I thank the digital gods for IppSec and his hands-on videos that teach you how to clear up the fog of war around you!)</div><br/><div id="37044053" class="c"><input type="checkbox" id="c-37044053" checked=""/><div class="controls bullet"><span class="by">slavik81</span><span>|</span><a href="#37040865">root</a><span>|</span><a href="#37042433">parent</a><span>|</span><a href="#37044172">next</a><span>|</span><label class="collapse" for="c-37044053">[-]</label><label class="expand" for="c-37044053">[1 more]</label></div><br/><div class="children"><div class="content">&gt; My solution to every ounce of apprehension is deleting and re-cloning out of paralysis and fear.<p>Having worked with older version control systems, I found that to be one of the best things about git. If I had a problem with a version control system like AccuRev, that sort of simple fix was not possible. Your every action resulted in a change of the server state, so if you got your workspace into a confusing state, the confusion would be synced to every machine.<p>These days I understand git well enough that I can fix just about any mistake, but the &#x27;delete and start over&#x27; workflow was extremely valuable to me as a beginner. Knowing that there was a foolproof fallback of just deleting and recloning let me experiment without fear.</div><br/></div></div></div></div><div id="37044172" class="c"><input type="checkbox" id="c-37044172" checked=""/><div class="controls bullet"><span class="by">rapnie</span><span>|</span><a href="#37040865">root</a><span>|</span><a href="#37041689">parent</a><span>|</span><a href="#37042433">prev</a><span>|</span><a href="#37043811">next</a><span>|</span><label class="collapse" for="c-37044172">[-]</label><label class="expand" for="c-37044172">[1 more]</label></div><br/><div class="children"><div class="content">The other day Jujutsu featured on HN, with git as a possible back-end. Describing itself as &quot;both simple and powerful&quot; with a combination of practices adopted from multiple tools:<p>&gt; Jujutsu is a Git-compatible DVCS. It combines features from Git (data model, speed), Mercurial (anonymous branching, simple CLI free from &quot;the index&quot;, revsets, powerful history-rewriting), and Pijul&#x2F;Darcs (first-class conflicts), with features not found in most of them (working-copy-as-a-commit, undo functionality, automatic rebase, safe replication via rsync, Dropbox, or distributed file system).<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36952796">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36952796</a></div><br/></div></div><div id="37043811" class="c"><input type="checkbox" id="c-37043811" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#37040865">root</a><span>|</span><a href="#37041689">parent</a><span>|</span><a href="#37044172">prev</a><span>|</span><a href="#37044399">next</a><span>|</span><label class="collapse" for="c-37043811">[-]</label><label class="expand" for="c-37043811">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The issue is git&#x27;s interface is terrible and very powerful.<p>Git is basically that a programming language. The time you need to &quot;master&quot; git is comparable to &quot;master&quot; a programming language.<p>I&#x27;m being writing code for more than half of my lifetime so far, and every time I need to use an unusual git command I feel like a script kiddo who copies and pastes from SO.</div><br/></div></div></div></div><div id="37044399" class="c"><input type="checkbox" id="c-37044399" checked=""/><div class="controls bullet"><span class="by">Nezteb</span><span>|</span><a href="#37040865">parent</a><span>|</span><a href="#37041689">prev</a><span>|</span><a href="#37041550">next</a><span>|</span><label class="collapse" for="c-37044399">[-]</label><label class="expand" for="c-37044399">[1 more]</label></div><br/><div class="children"><div class="content">Original source along with some of their other git content: (Nitter search sometimes returns no results, so just refresh if that happens)<p>- <a href="https:&#x2F;&#x2F;nitter.net&#x2F;search?f=tweets&amp;q=from:@NikkiSiapno+git&amp;f-images=on&amp;since=&amp;until=&amp;near=" rel="nofollow noreferrer">https:&#x2F;&#x2F;nitter.net&#x2F;search?f=tweets&amp;q=from:@NikkiSiapno+git&amp;f...</a><p>- <a href="https:&#x2F;&#x2F;nitter.net&#x2F;search?f=tweets&amp;q=from:@ChrisStaud+git&amp;f-images=on&amp;since=&amp;until=&amp;near=" rel="nofollow noreferrer">https:&#x2F;&#x2F;nitter.net&#x2F;search?f=tweets&amp;q=from:@ChrisStaud+git&amp;f-...</a><p>For folks who enjoy visual guides, here are a few more I&#x27;m aware of:<p>- <a href="http:&#x2F;&#x2F;marklodato.github.io&#x2F;visual-git-guide&#x2F;index-en.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;marklodato.github.io&#x2F;visual-git-guide&#x2F;index-en.html</a><p>- <a href="https:&#x2F;&#x2F;mukulrathi.com&#x2F;git-beginner-cheatsheet&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;mukulrathi.com&#x2F;git-beginner-cheatsheet&#x2F;</a></div><br/></div></div><div id="37041550" class="c"><input type="checkbox" id="c-37041550" checked=""/><div class="controls bullet"><span class="by">boneitis</span><span>|</span><a href="#37040865">parent</a><span>|</span><a href="#37044399">prev</a><span>|</span><a href="#37041955">next</a><span>|</span><label class="collapse" for="c-37041550">[-]</label><label class="expand" for="c-37041550">[3 more]</label></div><br/><div class="children"><div class="content">As someone who&#x27;s having a very difficult time coming to grips with git, would really appreciate another source for this. It does not load for me, in the eight ways I have tried to load it (two devices each on a different IP, on two browsers, with that %2F left encoded and attempted with it unencoded.)</div><br/><div id="37041579" class="c"><input type="checkbox" id="c-37041579" checked=""/><div class="controls bullet"><span class="by">6581</span><span>|</span><a href="#37040865">root</a><span>|</span><a href="#37041550">parent</a><span>|</span><a href="#37044768">next</a><span>|</span><label class="collapse" for="c-37041579">[-]</label><label class="expand" for="c-37041579">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;twitter.com&#x2F;bibryam&#x2F;status&#x2F;1601499207977693184" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;bibryam&#x2F;status&#x2F;1601499207977693184</a><p><a href="https:&#x2F;&#x2F;twitter.com&#x2F;bibryam&#x2F;status&#x2F;1609979930351132683" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;bibryam&#x2F;status&#x2F;1609979930351132683</a></div><br/></div></div><div id="37044768" class="c"><input type="checkbox" id="c-37044768" checked=""/><div class="controls bullet"><span class="by">Given_47</span><span>|</span><a href="#37040865">root</a><span>|</span><a href="#37041550">parent</a><span>|</span><a href="#37041579">prev</a><span>|</span><a href="#37041955">next</a><span>|</span><label class="collapse" for="c-37044768">[-]</label><label class="expand" for="c-37044768">[1 more]</label></div><br/><div class="children"><div class="content">For posterity hereâs [1] a list of Nitter instances. The flagship one (Nitter.net) always gets overloaded<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;zedeus&#x2F;nitter&#x2F;wiki&#x2F;Instances">https:&#x2F;&#x2F;github.com&#x2F;zedeus&#x2F;nitter&#x2F;wiki&#x2F;Instances</a></div><br/></div></div></div></div><div id="37041955" class="c"><input type="checkbox" id="c-37041955" checked=""/><div class="controls bullet"><span class="by">messe</span><span>|</span><a href="#37040865">parent</a><span>|</span><a href="#37041550">prev</a><span>|</span><a href="#37043619">next</a><span>|</span><label class="collapse" for="c-37041955">[-]</label><label class="expand" for="c-37041955">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s missing:<p><pre><code>    git diff &gt; ..&#x2F;i-messed-up.patch
    cd .. &amp;&amp; rm -rf $REPO
    git clone $REMOTE
    cd $REPO &amp;&amp; git apply ..&#x2F;i-messed-up.patch</code></pre></div><br/><div id="37044151" class="c"><input type="checkbox" id="c-37044151" checked=""/><div class="controls bullet"><span class="by">u801e</span><span>|</span><a href="#37040865">root</a><span>|</span><a href="#37041955">parent</a><span>|</span><a href="#37042126">next</a><span>|</span><label class="collapse" for="c-37044151">[-]</label><label class="expand" for="c-37044151">[1 more]</label></div><br/><div class="children"><div class="content">Though, if you know enough to edit diffs by hand, you could use git apply --cached to stage parts of the diff in a way to make a sensible set of commits instead of a single commit for a large change.</div><br/></div></div><div id="37042126" class="c"><input type="checkbox" id="c-37042126" checked=""/><div class="controls bullet"><span class="by">cakemuncher</span><span>|</span><a href="#37040865">root</a><span>|</span><a href="#37041955">parent</a><span>|</span><a href="#37044151">prev</a><span>|</span><a href="#37043619">next</a><span>|</span><label class="collapse" for="c-37042126">[-]</label><label class="expand" for="c-37042126">[2 more]</label></div><br/><div class="children"><div class="content">Why apply i-messed-up on main&#x2F;master? Am I missing a meme here? What&#x27;s the point of this?</div><br/><div id="37043962" class="c"><input type="checkbox" id="c-37043962" checked=""/><div class="controls bullet"><span class="by">Pxtl</span><span>|</span><a href="#37040865">root</a><span>|</span><a href="#37042126">parent</a><span>|</span><a href="#37043619">next</a><span>|</span><label class="collapse" for="c-37043962">[-]</label><label class="expand" for="c-37043962">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s basically automating the workflow described here:<p><a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1597&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;xkcd.com&#x2F;1597&#x2F;</a></div><br/></div></div></div></div></div></div><div id="37043619" class="c"><input type="checkbox" id="c-37043619" checked=""/><div class="controls bullet"><span class="by">PlunderBunny</span><span>|</span><a href="#37040865">parent</a><span>|</span><a href="#37041955">prev</a><span>|</span><a href="#37041330">next</a><span>|</span><label class="collapse" for="c-37043619">[-]</label><label class="expand" for="c-37043619">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m probably showing my ignorance of what is possible&#x2F;required, but I&#x27;d like to see a GUI front-end for Git that looked like the background of this image, where each commit was a lozenge that I could just drag from one column to the other. Maybe individual files could be circles inside the lozenges.
Just drag-and-drop, and the front-end figures out all the underlying Git commands to use.</div><br/></div></div><div id="37041330" class="c"><input type="checkbox" id="c-37041330" checked=""/><div class="controls bullet"><span class="by">nelsonfigueroa</span><span>|</span><a href="#37040865">parent</a><span>|</span><a href="#37043619">prev</a><span>|</span><a href="#37043987">next</a><span>|</span><label class="collapse" for="c-37041330">[-]</label><label class="expand" for="c-37041330">[1 more]</label></div><br/><div class="children"><div class="content">Wow this is great. Wish I came across something like this back when I was learning git.</div><br/></div></div><div id="37043987" class="c"><input type="checkbox" id="c-37043987" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37040865">parent</a><span>|</span><a href="#37041330">prev</a><span>|</span><a href="#37045747">next</a><span>|</span><label class="collapse" for="c-37043987">[-]</label><label class="expand" for="c-37043987">[1 more]</label></div><br/><div class="children"><div class="content">Wow that is great!</div><br/></div></div></div></div><div id="37045747" class="c"><input type="checkbox" id="c-37045747" checked=""/><div class="controls bullet"><span class="by">ciberado</span><span>|</span><a href="#37040865">prev</a><span>|</span><a href="#37046148">next</a><span>|</span><label class="collapse" for="c-37045747">[-]</label><label class="expand" for="c-37045747">[2 more]</label></div><br/><div class="children"><div class="content">I have contradictory feelings regarding git. For more than ten years, I was using it daily without really understanding the internals... and I was often confused and frustrated. After investing some time learning how the Directed Acyclic Graph works, suddenly everything made much more sense.<p>And, yes: it is good to learn the underlying fundamentals of the technology we are using. But, on the other hand, it denotes a rather poor abstraction from the UX point of view, imho.<p>Now, when I deliver git training, I start by explaining the DAG and how there is no magic, only git. By the way, the notes and exercises of the course are in my GitHub account[1], feel free to check it out if you think it can be useful.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;ciberado&#x2F;git-workshop">https:&#x2F;&#x2F;github.com&#x2F;ciberado&#x2F;git-workshop</a> (<a href="https:&#x2F;&#x2F;ciberado.github.io&#x2F;git-workshop&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;ciberado.github.io&#x2F;git-workshop&#x2F;</a>)</div><br/><div id="37045974" class="c"><input type="checkbox" id="c-37045974" checked=""/><div class="controls bullet"><span class="by">not_your_vase</span><span>|</span><a href="#37045747">parent</a><span>|</span><a href="#37046148">next</a><span>|</span><label class="collapse" for="c-37045974">[-]</label><label class="expand" for="c-37045974">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately knowing DAG&#x27;s inside out will not save anyone who decides to open <i>man git</i> and related pages. Git is not magic. It&#x27;s just the dictionary example of what you get when software developers start coding without adult supervision. Lots of cool stuff, but usability and user-friendliness is not one them.</div><br/></div></div></div></div><div id="37046148" class="c"><input type="checkbox" id="c-37046148" checked=""/><div class="controls bullet"><span class="by">h1fra</span><span>|</span><a href="#37045747">prev</a><span>|</span><a href="#37039465">next</a><span>|</span><label class="collapse" for="c-37046148">[-]</label><label class="expand" for="c-37046148">[1 more]</label></div><br/><div class="children"><div class="content">In my 10 years of using Git I think I have used mostly these commands: 
&quot;git pull --rebase&quot;, &quot;git add -p&quot;, &quot;git commit -m&quot; and &quot;git push&quot;<p>Everything else can be googled&#x2F;learned when needed. I think I just wish the default flags were more sane and command&#x27;s name would be less &quot;internal&quot;.</div><br/></div></div><div id="37039465" class="c"><input type="checkbox" id="c-37039465" checked=""/><div class="controls bullet"><span class="by">gpspake</span><span>|</span><a href="#37046148">prev</a><span>|</span><a href="#37040979">next</a><span>|</span><label class="collapse" for="c-37039465">[-]</label><label class="expand" for="c-37039465">[49 more]</label></div><br/><div class="children"><div class="content">I think this is a good guide. Git tends to be an emotional topic for a lot of people - myself included - and the hill I dramatically die on time and time again is that I think, tragically, this is about where developers stop learning git. I think operations like rebase, cherrypick, and squash are just as important as some of the ones you first encounter. Especially when you&#x27;re working with other people. I use them every day and I see some of the spaghetti experienced developers pile on the graph because they only know merge. I guess my point is &quot;don&#x27;t sleep on rebasing&quot; :)</div><br/><div id="37039907" class="c"><input type="checkbox" id="c-37039907" checked=""/><div class="controls bullet"><span class="by">jkubicek</span><span>|</span><a href="#37039465">parent</a><span>|</span><a href="#37040019">next</a><span>|</span><label class="collapse" for="c-37039907">[-]</label><label class="expand" for="c-37039907">[47 more]</label></div><br/><div class="children"><div class="content">Git is one of those tools that exposes so much of the underlying infrastructure that people just can&#x27;t help diving in and making their own lives so much more difficult.<p>After using git for well over a decade, I&#x27;m completely convinced that if you find yourself frequently rebasing&#x2F;cherry-picking&#x2F;reflogging you&#x27;re using git wrong.</div><br/><div id="37041146" class="c"><input type="checkbox" id="c-37041146" checked=""/><div class="controls bullet"><span class="by">no_wizard</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37039907">parent</a><span>|</span><a href="#37040996">next</a><span>|</span><label class="collapse" for="c-37041146">[-]</label><label class="expand" for="c-37041146">[15 more]</label></div><br/><div class="children"><div class="content">rebase and cherry picking are both cornerstones of trunk based development workflows, and those have proven to be extremely successful in my experience, vs other methods (like Git Flow, the GitHub overly simplistic branch per feature and merge approach, which <i>feels</i> like trunk based but isn&#x27;t etc.)<p>rebase makes roll backs extremely easy if you need to roll back specific commits because of bugs and makes releases easier via cherry picking (so you don&#x27;t slow down trunk merges just to do a release) and allow for fine grained continuous deployment that is harder to achieve than without it.<p>It is my experience however, that either <i>everyone</i> needs to rebase or you end up with issues eventually when only some developers are and other ones aren&#x27;t.<p>I don&#x27;t care as much for squashing myself as a general case, as you lose fine grained per commit rollback strategies though</div><br/><div id="37045670" class="c"><input type="checkbox" id="c-37045670" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37041146">parent</a><span>|</span><a href="#37041542">next</a><span>|</span><label class="collapse" for="c-37045670">[-]</label><label class="expand" for="c-37045670">[1 more]</label></div><br/><div class="children"><div class="content">Blindly squashing every branch into one commit is lame and done by people who have either never had to bisect a bug or too lazy to figure out how to properly rebase. Where squashing is important is turning a work in progress branch into a series of commits for the master branch. There shouldn&#x27;t be any commits fixing your own shit, for example. I don&#x27;t want to see one commit where you do the work then five commits fixing your own work. Nobody needs to see that. It only makes things worse.</div><br/></div></div><div id="37041542" class="c"><input type="checkbox" id="c-37041542" checked=""/><div class="controls bullet"><span class="by">nordsieck</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37041146">parent</a><span>|</span><a href="#37045670">prev</a><span>|</span><a href="#37040996">next</a><span>|</span><label class="collapse" for="c-37041542">[-]</label><label class="expand" for="c-37041542">[13 more]</label></div><br/><div class="children"><div class="content">&gt; It is my experience however, that either everyone needs to rebase or you end up with issues eventually when only some developers are and other ones aren&#x27;t.<p>The only time I merge is when I&#x27;m working on a shared remote branch. I haven&#x27;t found a workflow (although I&#x27;m all ears if you have any suggestions).</div><br/><div id="37042102" class="c"><input type="checkbox" id="c-37042102" checked=""/><div class="controls bullet"><span class="by">sixstringtheory</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37041542">parent</a><span>|</span><a href="#37040996">next</a><span>|</span><label class="collapse" for="c-37042102">[-]</label><label class="expand" for="c-37042102">[12 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s my current workflow:<p>1. write some code on a local branch<p>2. upstream has new revisions? rebase my branch on top<p>3. if not finished with my task yet, go to 1<p>4. if ready for review, open PR<p>5. if accepted, squash and merge<p>6. if changes are requested, write more code<p>7. upstream got more commits causing a conflict? don&#x27;t rebase! it will screw up the PR history on GitHub and can cause issues for reviewers who might&#x27;ve checked out your branch locally and maybe done some experiments. merge upstream into your local branch. then you can push fast-forwardable commits.<p>8. push new commits to PR and go to 5<p>I used to think of rebasing as just rewriting commit history. But now I also think of it as altering the history of collaboration that is captured in a PR. So I switched from <i>rebasing onto</i> new upstream base branch commits and force pushing to PRs that already had reviews, to <i>merging in</i> new upstream base branch changes. I only do this after someone else has done anything on my PR; if I open it but nobody has reviewed yet, I&#x27;ll do the rebase&#x2F;forcepush to keep it current until someone does.<p>I prefer squashing to merge because I prefer the default branch to have one commit per unit of collaborative work. The way different people split up commits on a branch is arbitrary and varies widely; you&#x27;ll never get more than 2 engineers to agree on a convention here. Keep all the messy stuff in the PR, and you can always revert one of those individual commits if you want finer-grained rollback. If you want a PR to have generated more than one commit, then it should be more than one PR.</div><br/><div id="37042210" class="c"><input type="checkbox" id="c-37042210" checked=""/><div class="controls bullet"><span class="by">seba_dos1</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37042102">parent</a><span>|</span><a href="#37042756">next</a><span>|</span><label class="collapse" for="c-37042210">[-]</label><label class="expand" for="c-37042210">[8 more]</label></div><br/><div class="children"><div class="content">&gt; I only do this after someone else has done anything on my PR; if I open it but nobody has reviewed yet, I&#x27;ll do the rebase&#x2F;forcepush to keep it current until someone does.<p>I believe the only reason to do so is GitHub&#x27;s lackluster PR UI. Force-pushing with an updated version of a branch after a review works reasonably well with GitLab&#x27;s MRs.<p>&gt; I prefer squashing to merge because I prefer the default branch to have one commit per unit of collaborative work.<p>There&#x27;s no reason to squash when you can create merge commits from fast-forwardable state instead (again, one of the easily achievable options in GitLab&#x27;s UI; GitHub doesn&#x27;t make it easy AFAIK). This way you don&#x27;t lose commit granularity while you can still obtain the &quot;one commit per unit of work&quot; view with simple `git log --first-parent` (or do the opposite and skip the merge commits with `git log --no-merges`).</div><br/><div id="37042293" class="c"><input type="checkbox" id="c-37042293" checked=""/><div class="controls bullet"><span class="by">nordsieck</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37042210">parent</a><span>|</span><a href="#37043906">next</a><span>|</span><label class="collapse" for="c-37042293">[-]</label><label class="expand" for="c-37042293">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Force-pushing with an updated version of a branch after a review works reasonably well with GitLab&#x27;s MRs.<p>The problem I run into is that other people have different workflows.<p>If they `git checkout remote&#x2F;branch`, then everything&#x27;s fine. But if they want to make a local copy of the branch, it&#x27;ll get all messed up if I force-push. And I only want to adopt practices that are as robust as possible in the face of the possible ways other people could work.</div><br/><div id="37044291" class="c"><input type="checkbox" id="c-37044291" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37042293">parent</a><span>|</span><a href="#37043906">next</a><span>|</span><label class="collapse" for="c-37044291">[-]</label><label class="expand" for="c-37044291">[1 more]</label></div><br/><div class="children"><div class="content">For me, individual feature branches feel private, even if theyâve been pushed to a hub repository for others to view and pull.  I wouldnât push to someone elseâs branch and I frequently force push to my own branch without worrying what it will do to others repositories.<p>The only thing that is sacred is the main&#x2F;master branch.  Everything is else just a speculative idea that, until reviewed and applied to master, is ephemeral.<p>(Iâve tried collaborating on a branch before but at the end of the process itâs hard to review because you either feel like the other party is rubber stamping their own code alongside yours, or you need to find a third party reviewer which spoils the 1:1 nature of almost every other code review I do.)</div><br/></div></div></div></div><div id="37043906" class="c"><input type="checkbox" id="c-37043906" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37042210">parent</a><span>|</span><a href="#37042293">prev</a><span>|</span><a href="#37042756">next</a><span>|</span><label class="collapse" for="c-37043906">[-]</label><label class="expand" for="c-37043906">[5 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s no reason to squash when you can create merge commits from fast-forwardable state instead<p>Sure there is.  Less noise commits.</div><br/><div id="37044113" class="c"><input type="checkbox" id="c-37044113" checked=""/><div class="controls bullet"><span class="by">seba_dos1</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37043906">parent</a><span>|</span><a href="#37042756">next</a><span>|</span><label class="collapse" for="c-37044113">[-]</label><label class="expand" for="c-37044113">[4 more]</label></div><br/><div class="children"><div class="content">Did you mean to say &quot;less value in commit graph&quot;?<p>It&#x27;s literally just a matter of a single command line argument to switch between views of whole MRs and individual commits, and both those views can be incredibly useful (especially during bisection).</div><br/><div id="37044290" class="c"><input type="checkbox" id="c-37044290" checked=""/><div class="controls bullet"><span class="by">sixstringtheory</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37044113">parent</a><span>|</span><a href="#37042756">next</a><span>|</span><label class="collapse" for="c-37044290">[-]</label><label class="expand" for="c-37044290">[3 more]</label></div><br/><div class="children"><div class="content">I still havenât tried your suggestion, but would it be able to show only merge commits from PRs already merged into main, while still showing all commits on my local work branches I have in progress?</div><br/><div id="37044353" class="c"><input type="checkbox" id="c-37044353" checked=""/><div class="controls bullet"><span class="by">seba_dos1</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37044290">parent</a><span>|</span><a href="#37042756">next</a><span>|</span><label class="collapse" for="c-37044353">[-]</label><label class="expand" for="c-37044353">[2 more]</label></div><br/><div class="children"><div class="content">`git log --first-parent` shows you only the list of commits accessible from HEAD by traversing their first parents. So, yes - your local work will usually have commits with just a single parent, so nothing will get skipped until it gets to merge commits.<p>It&#x27;s also useful to skip noise if you happen to merge the upstream branch back into your topic branch for some reason.<p>Also, there&#x27;s always `git log main..`, or even `git log main..topicbranch`. Combined with `--oneline` and perhaps `--graph`, `git log` is a really powerful tool to visualize repository state (and something that&#x27;s incredibly lobotomized on popular Web frontends, unfortunately - I often end up cloning a repo to browse its history just because the Web UI is useless).</div><br/><div id="37044570" class="c"><input type="checkbox" id="c-37044570" checked=""/><div class="controls bullet"><span class="by">sixstringtheory</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37044353">parent</a><span>|</span><a href="#37042756">next</a><span>|</span><label class="collapse" for="c-37044570">[-]</label><label class="expand" for="c-37044570">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, thatâs helpful info. Iâve been using git log --graph --oneline --decorate for a long time, so will try it with --first-parent as well!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37042756" class="c"><input type="checkbox" id="c-37042756" checked=""/><div class="controls bullet"><span class="by">jkubicek</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37042102">parent</a><span>|</span><a href="#37042210">prev</a><span>|</span><a href="#37040996">next</a><span>|</span><label class="collapse" for="c-37042756">[-]</label><label class="expand" for="c-37042756">[3 more]</label></div><br/><div class="children"><div class="content">My workflow is almost identical to yours except step #2. Why rebase on main when you can just merge from main? It&#x27;s much simpler, less likely to get hairy merge conflicts. If you&#x27;re going to squash your PR anyway, the end result is identical.</div><br/><div id="37044676" class="c"><input type="checkbox" id="c-37044676" checked=""/><div class="controls bullet"><span class="by">phito</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37042756">parent</a><span>|</span><a href="#37044274">next</a><span>|</span><label class="collapse" for="c-37044676">[-]</label><label class="expand" for="c-37044676">[1 more]</label></div><br/><div class="children"><div class="content">I really don&#x27;t get all these people who insist on usingrebase instead of merge. Who wants to spend time resolving meaningless conflicts?! Every time I try it, I instantly regret it.</div><br/></div></div><div id="37044274" class="c"><input type="checkbox" id="c-37044274" checked=""/><div class="controls bullet"><span class="by">sixstringtheory</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37042756">parent</a><span>|</span><a href="#37044676">prev</a><span>|</span><a href="#37040996">next</a><span>|</span><label class="collapse" for="c-37044274">[-]</label><label class="expand" for="c-37044274">[1 more]</label></div><br/><div class="children"><div class="content">I like being able to see the graph with my commits lined up on top of the latest main revision. It helps me order my work in my head. Thereâs probably a bunch of other ways to visualize that, I just havenât learned them yet.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37040996" class="c"><input type="checkbox" id="c-37040996" checked=""/><div class="controls bullet"><span class="by">Espressosaurus</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37039907">parent</a><span>|</span><a href="#37041146">prev</a><span>|</span><a href="#37041518">next</a><span>|</span><label class="collapse" for="c-37040996">[-]</label><label class="expand" for="c-37040996">[4 more]</label></div><br/><div class="children"><div class="content">I agree that if you&#x27;re having to use the reflog frequently, you&#x27;re using git wrong (not least of which because the reflog is not designed for readability and understanding the context where it came from).<p>But for the rest? If you&#x27;re working in a repo with more than 5 people, rebase, cherry-pick, and squash are necessary to keep your sanity. Merge nodes are awful once you get beyond more than maybe 3 developers.</div><br/><div id="37043913" class="c"><input type="checkbox" id="c-37043913" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37040996">parent</a><span>|</span><a href="#37042704">next</a><span>|</span><label class="collapse" for="c-37043913">[-]</label><label class="expand" for="c-37043913">[2 more]</label></div><br/><div class="children"><div class="content">I usually use reflog to answer the question &quot;What was the name of the branch I was just working on again?&quot;<p>What&#x27;s supposed to be wrong with that?</div><br/><div id="37045845" class="c"><input type="checkbox" id="c-37045845" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37043913">parent</a><span>|</span><a href="#37042704">next</a><span>|</span><label class="collapse" for="c-37045845">[-]</label><label class="expand" for="c-37045845">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s perfectly reasonable IMO.<p>If you just need to checkout the last branch you can also `git checkout -`</div><br/></div></div></div></div><div id="37042704" class="c"><input type="checkbox" id="c-37042704" checked=""/><div class="controls bullet"><span class="by">jkubicek</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37040996">parent</a><span>|</span><a href="#37043913">prev</a><span>|</span><a href="#37041518">next</a><span>|</span><label class="collapse" for="c-37042704">[-]</label><label class="expand" for="c-37042704">[1 more]</label></div><br/><div class="children"><div class="content">Someone else pointed out that it&#x27;s probably confusing that I didn&#x27;t mention that I do religiously squash my branches before committing, so we still have multiple developers with a clean main branch and no merge commits.</div><br/></div></div></div></div><div id="37041518" class="c"><input type="checkbox" id="c-37041518" checked=""/><div class="controls bullet"><span class="by">jsunderland323</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37039907">parent</a><span>|</span><a href="#37040996">prev</a><span>|</span><a href="#37040636">next</a><span>|</span><label class="collapse" for="c-37041518">[-]</label><label class="expand" for="c-37041518">[5 more]</label></div><br/><div class="children"><div class="content">If youâre doing collaborative trunk based development then youâre only cherry-picking. So far Dave Farley is the only person Iâve ever heard advocate for this but it does have its place in the universe. Cherry picking is not destructive to history fwiw.<p>Thereâs absolutely nothing wrong with rebasing&#x2F;squashing&#x2F;amending&#x2F;resetting heads on personal feature branches. In fact, itâs a pretty good practice if you make messy history and can make PRs less of an eyesore. I think the confusion comes up about when destructive history operations are appropriate because the git cli client does not have a concept of protected (shared) branches vs feature branches.<p>As long as you keep history destructive operations away from shared branches, youâre good.</div><br/><div id="37042413" class="c"><input type="checkbox" id="c-37042413" checked=""/><div class="controls bullet"><span class="by">seba_dos1</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37041518">parent</a><span>|</span><a href="#37042797">next</a><span>|</span><label class="collapse" for="c-37042413">[-]</label><label class="expand" for="c-37042413">[2 more]</label></div><br/><div class="children"><div class="content">In some cases, you&#x27;re still good even when rewriting shared branches.<p>At work we&#x27;re maintaining a downstream Linux tree with a few hundred patches on top of mainline. The tree gets frequently rebased on top of new upstream releases, and some changes are being progressively upstreamed. It&#x27;s much easier to reason about the remaining downstream changes and deal with conflicts when rebasing than when merging upstream releases back into the downstream tree. Of course you can&#x27;t expect to be able to carelessly `git pull` in such workflow, but if you&#x27;re working with people who actually know how to use git it&#x27;s not really a big deal.<p>Naturally, this particular project uses a special workflow that fits its needs. It doesn&#x27;t usually make sense to rewrite shared branches in projects where you&#x27;re the upstream.</div><br/></div></div><div id="37042797" class="c"><input type="checkbox" id="c-37042797" checked=""/><div class="controls bullet"><span class="by">jkubicek</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37041518">parent</a><span>|</span><a href="#37042413">prev</a><span>|</span><a href="#37040636">next</a><span>|</span><label class="collapse" for="c-37042797">[-]</label><label class="expand" for="c-37042797">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand this:<p>&gt; If youâre doing collaborative trunk based development then youâre only cherry-picking.<p>All my work is collaborative trunk based development, and I never cherry-pick.<p>&gt; Thereâs absolutely nothing wrong with rebasing&#x2F;squashing&#x2F;amending&#x2F;resetting heads on personal feature branches.<p>I agree that there&#x27;s nothing _wrong_ with it, just that it&#x27;s unnecessary. If your branches are focused on a single feature and you&#x27;re always squashing your PRs to main, the cleanliness of the branch while you&#x27;re working on it is unimportant.</div><br/><div id="37044208" class="c"><input type="checkbox" id="c-37044208" checked=""/><div class="controls bullet"><span class="by">doix</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37042797">parent</a><span>|</span><a href="#37040636">next</a><span>|</span><label class="collapse" for="c-37044208">[-]</label><label class="expand" for="c-37044208">[1 more]</label></div><br/><div class="children"><div class="content">&gt; always squashing your PRs to main, the cleanliness of the branch while you&#x27;re working on it is unimportant.<p>I&#x27;m personally not a fan of always squashing, for large features you lose a lot of history. I like a merge commit in some cases, you can still undo everything easily and most git commands support --first-parent so you can &quot;pretend&quot; everything was squashed in certain cases. But when you&#x27;re got blaming, you have a lot more context to go off.</div><br/></div></div></div></div></div></div><div id="37040636" class="c"><input type="checkbox" id="c-37040636" checked=""/><div class="controls bullet"><span class="by">RandallBrown</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37039907">parent</a><span>|</span><a href="#37041518">prev</a><span>|</span><a href="#37041238">next</a><span>|</span><label class="collapse" for="c-37040636">[-]</label><label class="expand" for="c-37040636">[5 more]</label></div><br/><div class="children"><div class="content">I use rebase multiple times per day. Mostly for putting my changes on top of the latest development branch, but also for squashing commits.<p>I&#x27;m curious why you don&#x27;t like it?</div><br/><div id="37040840" class="c"><input type="checkbox" id="c-37040840" checked=""/><div class="controls bullet"><span class="by">jkubicek</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37040636">parent</a><span>|</span><a href="#37043926">next</a><span>|</span><label class="collapse" for="c-37040840">[-]</label><label class="expand" for="c-37040840">[2 more]</label></div><br/><div class="children"><div class="content">My branches are always focused on a single atomic changeâ , so if I want the tip of my branch to be up-to-date with main (or the dev branch or whatever), merging from that branch accomplishes the same thing with a lower likelihood of conflicts.<p>I always squashâ¡ before pushing a PR, so the end result is identical to a carefully rebased PR.<p>â  occasionally branches will need to be split into separate commits, but that&#x27;s not my default working style<p>â¡ I know `squash` is a rebase under the hood, but it won&#x27;t ever result in conflicts, so I&#x27;m happy to use it with every PR</div><br/><div id="37041594" class="c"><input type="checkbox" id="c-37041594" checked=""/><div class="controls bullet"><span class="by">nordsieck</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37040840">parent</a><span>|</span><a href="#37043926">next</a><span>|</span><label class="collapse" for="c-37041594">[-]</label><label class="expand" for="c-37041594">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;d get a lot less pushback if you mentioned that you squash every branch before merging in your original comment. That actually seems like a pretty good policy if you can keep your branches relatively small.</div><br/></div></div></div></div><div id="37043926" class="c"><input type="checkbox" id="c-37043926" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37040636">parent</a><span>|</span><a href="#37040840">prev</a><span>|</span><a href="#37041238">next</a><span>|</span><label class="collapse" for="c-37043926">[-]</label><label class="expand" for="c-37043926">[2 more]</label></div><br/><div class="children"><div class="content">How&#x2F;why do you use rebase for squashing?</div><br/><div id="37044167" class="c"><input type="checkbox" id="c-37044167" checked=""/><div class="controls bullet"><span class="by">seba_dos1</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37043926">parent</a><span>|</span><a href="#37041238">next</a><span>|</span><label class="collapse" for="c-37044167">[-]</label><label class="expand" for="c-37044167">[1 more]</label></div><br/><div class="children"><div class="content">Rebase is pretty much just an automation for cherry-picking and squashing, and interactive rebase is the primary and most convenient way to put the branch you have worked on into shape before presenting it to someone else.<p>When I hear about people not using rebase in their daily workflow, I imagine myself 10 years ago when I barely knew git and couldn&#x27;t really use it as a helpful tool like I do today. It&#x27;s almost like looking back to before I started using VCS in the first place - somehow I did manage to not use one for years (even collaborated via FTP!), but now it seems impossible. Usually most of the useful magic with git happens before anything gets pushed out, and `git rebase` has a huge part in it.</div><br/></div></div></div></div></div></div><div id="37041238" class="c"><input type="checkbox" id="c-37041238" checked=""/><div class="controls bullet"><span class="by">lcnPylGDnU4H9OF</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37039907">parent</a><span>|</span><a href="#37040636">prev</a><span>|</span><a href="#37044174">next</a><span>|</span><label class="collapse" for="c-37041238">[-]</label><label class="expand" for="c-37041238">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m completely convinced that if you find yourself frequently [cherry-picking] you&#x27;re using git wrong.<p>A previous employer had a multi-tenant application that was deployed as a client-specific application which loaded the &quot;core&quot; as a dependency. They didn&#x27;t really know how to do versioning and most version changes were just arbitrary &quot;I feel like we should call it 1.8 now&quot;.<p>At one point I ended up maintaining a client-specific branch of the core dependency on version 1.10 (branch was 1.10-$CLIENT) while the &quot;main&quot; branch was 2.3 or something. For context, it went 1.10 to 2.0 because <i>general cognitive dissonance</i>.<p>This meant any change that needed to be made in the application core for this particular client also needed to be cherry-picked in some direction, usually by making the change on the client branch and cherry-picking it back as necessary. In some cases another client -- naturally, they would be on a separate branch like 2.3-$CLIENT -- also wanted that change so it needed to be cherry-picked again to that branch.<p>The result was a minimum of two PRs, one a cherry-pick of the others&#x27; commits (one commit unless I felt like spending my time in self-loathing), that I would make for every change. Not knocking cherry-pick at all; it&#x27;s wonderfully useful when used correctly. That&#x27;s just the result of non-technical decision-makers making decisions about technical tools.<p>On the plus side, I learned a ton about git in that job.</div><br/></div></div><div id="37044174" class="c"><input type="checkbox" id="c-37044174" checked=""/><div class="controls bullet"><span class="by">u801e</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37039907">parent</a><span>|</span><a href="#37041238">prev</a><span>|</span><a href="#37040074">next</a><span>|</span><label class="collapse" for="c-37044174">[-]</label><label class="expand" for="c-37044174">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m completely convinced that if you find yourself frequently rebasing&#x2F;cherry-picking&#x2F;reflogging you&#x27;re using git wrong.<p>A lot of people want to use git as a checkpoint&#x2F;backup system, and commits and associated changes reflect that.  The rebasing&#x2F;cherry-picking&#x2F;reflogging is one way to update the set of commits on the branch in order to make a set of meaningful commits for the feature branch they&#x27;re working on.</div><br/></div></div><div id="37040074" class="c"><input type="checkbox" id="c-37040074" checked=""/><div class="controls bullet"><span class="by">hughesjj</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37039907">parent</a><span>|</span><a href="#37044174">prev</a><span>|</span><a href="#37043986">next</a><span>|</span><label class="collapse" for="c-37040074">[-]</label><label class="expand" for="c-37040074">[9 more]</label></div><br/><div class="children"><div class="content">.... Why not rebase before merging into main?</div><br/><div id="37040718" class="c"><input type="checkbox" id="c-37040718" checked=""/><div class="controls bullet"><span class="by">jkubicek</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37040074">parent</a><span>|</span><a href="#37040348">next</a><span>|</span><label class="collapse" for="c-37040718">[-]</label><label class="expand" for="c-37040718">[5 more]</label></div><br/><div class="children"><div class="content">Resolving rebase conflicts is technically and conceptually much more difficult than resolving merge conflicts, with the added bonus that rebasing can sometimes force you to resolve conflicts for each commit in your branch.<p>Here&#x27;s how I think everyone should use git:<p>1. Create a new branch for your changes
2. Make commits and merge from main with wild abandon
3. One final merge from main
4. Squash everything into a single commit, push a PR<p>If you keep your branch focused on only a single change, the end result is a tight, focused, single commit PR that merges cleanly into main and didn&#x27;t involve any complex or error-prone shenanigans.</div><br/><div id="37044204" class="c"><input type="checkbox" id="c-37044204" checked=""/><div class="controls bullet"><span class="by">hughesjj</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37040718">parent</a><span>|</span><a href="#37041779">next</a><span>|</span><label class="collapse" for="c-37044204">[-]</label><label class="expand" for="c-37044204">[1 more]</label></div><br/><div class="children"><div class="content">So, I get the &quot;squash your feature branch into a single commit before merging upstream&quot;, but what does doing &quot;git merge main&quot; instead of &quot;git rebase -i main&quot; give you?  (Assume I have my global git config to remember conflict resolutions via rerere)</div><br/></div></div><div id="37041779" class="c"><input type="checkbox" id="c-37041779" checked=""/><div class="controls bullet"><span class="by">skeeter2020</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37040718">parent</a><span>|</span><a href="#37044204">prev</a><span>|</span><a href="#37042262">next</a><span>|</span><label class="collapse" for="c-37041779">[-]</label><label class="expand" for="c-37041779">[1 more]</label></div><br/><div class="children"><div class="content">This is a very common workflow for larger OS projects, and I think it translates really well to corporate environments too. It reinforces some work&#x2F;feature discipline and gives you a nice clean history.</div><br/></div></div><div id="37042262" class="c"><input type="checkbox" id="c-37042262" checked=""/><div class="controls bullet"><span class="by">crispyambulance</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37040718">parent</a><span>|</span><a href="#37041779">prev</a><span>|</span><a href="#37040348">next</a><span>|</span><label class="collapse" for="c-37042262">[-]</label><label class="expand" for="c-37042262">[2 more]</label></div><br/><div class="children"><div class="content">This is how I do it. Almost never touch rebase. 
Also, I hate git :-)</div><br/><div id="37042806" class="c"><input type="checkbox" id="c-37042806" checked=""/><div class="controls bullet"><span class="by">jkubicek</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37042262">parent</a><span>|</span><a href="#37040348">next</a><span>|</span><label class="collapse" for="c-37042806">[-]</label><label class="expand" for="c-37042806">[1 more]</label></div><br/><div class="children"><div class="content">I love git, but I also never touch rebase.<p>It&#x27;s there when I need it, but I also work in such a way to never need it.</div><br/></div></div></div></div></div></div><div id="37040348" class="c"><input type="checkbox" id="c-37040348" checked=""/><div class="controls bullet"><span class="by">entangledqubit</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37040074">parent</a><span>|</span><a href="#37040718">prev</a><span>|</span><a href="#37043986">next</a><span>|</span><label class="collapse" for="c-37040348">[-]</label><label class="expand" for="c-37040348">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a big fan of that practice but I get the impression that rebasing scares a lot of devs that either didn&#x27;t take the time to learn git or are still recovering from that one time that their change got too far away from mainline.   That latter reason is why I prefer the practice actually...</div><br/><div id="37044277" class="c"><input type="checkbox" id="c-37044277" checked=""/><div class="controls bullet"><span class="by">hughesjj</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37040348">parent</a><span>|</span><a href="#37040565">next</a><span>|</span><label class="collapse" for="c-37044277">[-]</label><label class="expand" for="c-37044277">[1 more]</label></div><br/><div class="children"><div class="content">When in doubt, git diff main&gt;~&#x2F;patch.out<p>(... &amp;&amp; Git checkout main &amp;&amp; git pull --rebase &amp;&amp; git checkout -B clean_branch &amp;&amp; git apply ~&#x2F;patch.out)<p>(I like the light rhyming of the first part)</div><br/></div></div><div id="37040565" class="c"><input type="checkbox" id="c-37040565" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37040348">parent</a><span>|</span><a href="#37044277">prev</a><span>|</span><a href="#37043986">next</a><span>|</span><label class="collapse" for="c-37040565">[-]</label><label class="expand" for="c-37040565">[1 more]</label></div><br/><div class="children"><div class="content">Or they were taught Git the wrong way, by memorizing a bunch of commands, as in TFA.</div><br/></div></div></div></div></div></div><div id="37043986" class="c"><input type="checkbox" id="c-37043986" checked=""/><div class="controls bullet"><span class="by">p1necone</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37039907">parent</a><span>|</span><a href="#37040074">prev</a><span>|</span><a href="#37040561">next</a><span>|</span><label class="collapse" for="c-37043986">[-]</label><label class="expand" for="c-37043986">[3 more]</label></div><br/><div class="children"><div class="content">As long as you <i>never ever</i> cherry-pick from one branch to another when the source branch is intended to eventually be actually merged (directly or indirectly) into the destination branch I think it has its use cases.<p>If you break this rule you could be in for dealing with some atrocious merge conflicts though, so I try not to do it unless the branch I&#x27;m cherry picking from is a definite actual dead end (e.g. the change was an urgent hotfix against an old release branch and your workflow doesn&#x27;t involve merging those back into main&#x2F;master).</div><br/><div id="37044158" class="c"><input type="checkbox" id="c-37044158" checked=""/><div class="controls bullet"><span class="by">doix</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37043986">parent</a><span>|</span><a href="#37040561">next</a><span>|</span><label class="collapse" for="c-37044158">[-]</label><label class="expand" for="c-37044158">[2 more]</label></div><br/><div class="children"><div class="content">Is that really an issue? When you rebase, git automatically figures out that you&#x27;ve cherry-picked something and will skip it.<p>I will occasionally chery-pick something from master, do my work etc. Before making my PR, I&#x27;ll rebase against master and potentially squash&#x2F;reorganize my commits. When the PR eventually gets merged to master there aren&#x27;t any problems.<p>I don&#x27;t think I ever merge without rebasing though, so maybe rebase has been saving me from any potential problems.</div><br/><div id="37044446" class="c"><input type="checkbox" id="c-37044446" checked=""/><div class="controls bullet"><span class="by">p1necone</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37044158">parent</a><span>|</span><a href="#37040561">next</a><span>|</span><label class="collapse" for="c-37044446">[-]</label><label class="expand" for="c-37044446">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I very rarely rebase, just autosquash PR commits into one on merge to master (and also delete the source branch to avoid similar headaches) + making sure PRs are fairly small and focused. Regular merges where commits have been cherry picked from one side to another, and then later also unmerged changes have touched those same files tend to result in a lot of spurious merge conflicts.</div><br/></div></div></div></div></div></div><div id="37040561" class="c"><input type="checkbox" id="c-37040561" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37039907">parent</a><span>|</span><a href="#37043986">prev</a><span>|</span><a href="#37043179">next</a><span>|</span><label class="collapse" for="c-37040561">[-]</label><label class="expand" for="c-37040561">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using Git for the same length of time, but I have not reached this conclusion. That&#x27;s the problem with teaching someone how to use a very powerful flexible tool that accommodates a variety of workflows and styles: different people use it differently.</div><br/></div></div><div id="37043179" class="c"><input type="checkbox" id="c-37043179" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37039907">parent</a><span>|</span><a href="#37040561">prev</a><span>|</span><a href="#37042046">next</a><span>|</span><label class="collapse" for="c-37043179">[-]</label><label class="expand" for="c-37043179">[1 more]</label></div><br/><div class="children"><div class="content">How do you pull a critical fix across branches w&#x2F;o the occasional cherry pick?  What do you do instead?</div><br/></div></div><div id="37042046" class="c"><input type="checkbox" id="c-37042046" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#37039465">root</a><span>|</span><a href="#37039907">parent</a><span>|</span><a href="#37043179">prev</a><span>|</span><a href="#37040019">next</a><span>|</span><label class="collapse" for="c-37042046">[-]</label><label class="expand" for="c-37042046">[1 more]</label></div><br/><div class="children"><div class="content">I canât imagine using VC for exploratory programming without rebase or something equivalent. I donât want to bother writing a meaningful commit message for a change Iâm probably going to throw away. I also donât want to push a history like âWIP, WIP, works now, broke again, WIPâ and thatâs what it looks like at a first pass when Iâm moving quickly.<p>Instead I squash away the garbage and push out a reasonable looking chain of commits with nice descriptions.</div><br/></div></div></div></div><div id="37040019" class="c"><input type="checkbox" id="c-37040019" checked=""/><div class="controls bullet"><span class="by">zwieback</span><span>|</span><a href="#37039465">parent</a><span>|</span><a href="#37039907">prev</a><span>|</span><a href="#37040979">next</a><span>|</span><label class="collapse" for="c-37040019">[-]</label><label class="expand" for="c-37040019">[1 more]</label></div><br/><div class="children"><div class="content">If you use those commands in your local repo to keep the central shared repo clean  then yeah, rebase and friends are great.</div><br/></div></div></div></div><div id="37040979" class="c"><input type="checkbox" id="c-37040979" checked=""/><div class="controls bullet"><span class="by">noiv</span><span>|</span><a href="#37039465">prev</a><span>|</span><a href="#37040467">next</a><span>|</span><label class="collapse" for="c-37040979">[-]</label><label class="expand" for="c-37040979">[4 more]</label></div><br/><div class="children"><div class="content">I like the guide, but that simply scrolling the page adds entries to the browser&#x27;s history makes me cry.</div><br/><div id="37046277" class="c"><input type="checkbox" id="c-37046277" checked=""/><div class="controls bullet"><span class="by">everybodyknows</span><span>|</span><a href="#37040979">parent</a><span>|</span><a href="#37041575">next</a><span>|</span><label class="collapse" for="c-37046277">[-]</label><label class="expand" for="c-37046277">[1 more]</label></div><br/><div class="children"><div class="content">* * *</div><br/></div></div><div id="37041575" class="c"><input type="checkbox" id="c-37041575" checked=""/><div class="controls bullet"><span class="by">suralind</span><span>|</span><a href="#37040979">parent</a><span>|</span><a href="#37046277">prev</a><span>|</span><a href="#37041461">next</a><span>|</span><label class="collapse" for="c-37041575">[-]</label><label class="expand" for="c-37041575">[1 more]</label></div><br/><div class="children"><div class="content">The scrolling is indeed terrible.</div><br/></div></div><div id="37041461" class="c"><input type="checkbox" id="c-37041461" checked=""/><div class="controls bullet"><span class="by">noddingham</span><span>|</span><a href="#37040979">parent</a><span>|</span><a href="#37041575">prev</a><span>|</span><a href="#37040467">next</a><span>|</span><label class="collapse" for="c-37041461">[-]</label><label class="expand" for="c-37041461">[1 more]</label></div><br/><div class="children"><div class="content">Agreed that is awful</div><br/></div></div></div></div><div id="37040467" class="c"><input type="checkbox" id="c-37040467" checked=""/><div class="controls bullet"><span class="by">StevenXC</span><span>|</span><a href="#37040979">prev</a><span>|</span><a href="#37040739">next</a><span>|</span><label class="collapse" for="c-37040467">[-]</label><label class="expand" for="c-37040467">[14 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been working a bit the past week on a guide for a workshop I&#x27;ll be running in a few months to get research mathematicians productive using just GitHub&#x27;s UI. [0] So the purpose is not identical by any means. But I&#x27;m curious whether it&#x27;s appropriate that this RedHat guide seems to go straight into &quot;what commands do I run&quot; rather than answering&#x2F;illustrating &quot;how does Git model the history of a software project&#x27;s files&quot;.<p>[0]: <a href="http:&#x2F;&#x2F;jmm2024.clontz.org&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;jmm2024.clontz.org&#x2F;</a></div><br/><div id="37040506" class="c"><input type="checkbox" id="c-37040506" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#37040467">parent</a><span>|</span><a href="#37040619">next</a><span>|</span><label class="collapse" for="c-37040506">[-]</label><label class="expand" for="c-37040506">[10 more]</label></div><br/><div class="children"><div class="content">The #1 mistake in trying to teach people Git is jumping right to commands without developing a mental model first. It leads to nothing but confusion down the line, and reliance on copy&#x2F;paste of snippets and scripts to get anything done. Effective usage of Git depends heavily on having a basic understanding of how it works, moreso than a lot of other tools.</div><br/><div id="37046247" class="c"><input type="checkbox" id="c-37046247" checked=""/><div class="controls bullet"><span class="by">williamdclt</span><span>|</span><a href="#37040467">root</a><span>|</span><a href="#37040506">parent</a><span>|</span><a href="#37041148">next</a><span>|</span><label class="collapse" for="c-37046247">[-]</label><label class="expand" for="c-37046247">[1 more]</label></div><br/><div class="children"><div class="content">Mental models are famously quasi-impossible to transfer. Almost nobody really groks new concepts with theoretical explanations, practical experience is needed almost immediately</div><br/></div></div><div id="37041148" class="c"><input type="checkbox" id="c-37041148" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37040467">root</a><span>|</span><a href="#37040506">parent</a><span>|</span><a href="#37046247">prev</a><span>|</span><a href="#37040619">next</a><span>|</span><label class="collapse" for="c-37041148">[-]</label><label class="expand" for="c-37041148">[8 more]</label></div><br/><div class="children"><div class="content">Definitely a mistake, though you can explain Git&#x27;s data model in about 2 minutes.<p>I would say a bigger mistake is starting with the command line. A good GUI is absolutely instrumental to understanding Git, and it lets you avoid Git&#x27;s terrible CLI for as long as possible.</div><br/><div id="37041805" class="c"><input type="checkbox" id="c-37041805" checked=""/><div class="controls bullet"><span class="by">skeeter2020</span><span>|</span><a href="#37040467">root</a><span>|</span><a href="#37041148">parent</a><span>|</span><a href="#37041742">next</a><span>|</span><label class="collapse" for="c-37041805">[-]</label><label class="expand" for="c-37041805">[4 more]</label></div><br/><div class="children"><div class="content">I disagree for two reasons:<p>1. the git commands map so cleanly to the states
2. there are so many terrible GUI interfaces that try and coddle the developer, really hiding the intent<p>I think the real problem is the flexibility allows for a lot of totally unintended but &quot;legal&quot; actions, from which it is really hard to recover <i>because</i> it&#x27;s not your standard workflow.</div><br/><div id="37042528" class="c"><input type="checkbox" id="c-37042528" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#37040467">root</a><span>|</span><a href="#37041805">parent</a><span>|</span><a href="#37043896">next</a><span>|</span><label class="collapse" for="c-37042528">[-]</label><label class="expand" for="c-37042528">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the git commands map so cleanly to the states<p>I disagree. &quot;checkout&quot; does literally 2 unrelated things, one of them destructive with no safety checks. &quot;reset&quot; kind of moves HEAD around, but does a bunch of other stuff in the process. &quot;Rebase&quot; has a lot of magical (albeit useful) behavior involved in determining what exactly gets rebased. Etc.<p>&gt; there are so many terrible GUI interfaces that try and coddle the developer, really hiding the intent<p>I agree. The CLI is confusing and occasionally obfuscates the data model, so adding yet another confusing obfuscating layer isn&#x27;t going to really help. That said, a really <i>good</i> GUI that doesn&#x27;t try to hide what&#x27;s going on, would be a useful learning aid.</div><br/></div></div><div id="37043896" class="c"><input type="checkbox" id="c-37043896" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#37040467">root</a><span>|</span><a href="#37041805">parent</a><span>|</span><a href="#37042528">prev</a><span>|</span><a href="#37045382">next</a><span>|</span><label class="collapse" for="c-37043896">[-]</label><label class="expand" for="c-37043896">[1 more]</label></div><br/><div class="children"><div class="content">2. Don&#x27;t pick a terrible one when teaching. What kind of reason is that?</div><br/></div></div><div id="37045382" class="c"><input type="checkbox" id="c-37045382" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37040467">root</a><span>|</span><a href="#37041805">parent</a><span>|</span><a href="#37043896">prev</a><span>|</span><a href="#37041742">next</a><span>|</span><label class="collapse" for="c-37045382">[-]</label><label class="expand" for="c-37045382">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I definitely agree on the proliferation of terrible GUIs. As someone else said, pick a good one when teaching.<p>&gt; the git commands map so cleanly to the states<p>They absolutely don&#x27;t. Someone already mentioned the mess of &quot;checkout&quot; and &quot;reset&quot; but that&#x27;s only half the issue. The naming is a <i>huge</i> issue with learning.<p>The worst is the &quot;index&quot; which is apparently named after the data structure used to store it. Such a bad name that it&#x27;s often called the &quot;staging area&quot; instead. But even that is bad. Why isn&#x27;t it just called the &quot;draft commit&quot;? That immediately tells you what it is.<p>Another example is reset&#x27;s soft&#x2F;mixed&#x2F;hard. Terrible meaningless names. They might as well have been called 1, 2 and 3.<p>And there&#x27;s more! It&#x27;s not just the mapping and the naming. The actual CLI is stupidly inconsistent too. Flags have wildly different meanings depending on the command. You do the same action in totally different ways depending on insignificant differences (e.g. git reset --hard Vs git branch -f).<p>I have to look up the command to delete a remote branch every single time I use it because it&#x27;s just so unintuitive.<p>I think people love the Git data model (which is great) sooo much that they <i>think</i> they love all of Git.</div><br/></div></div></div></div><div id="37041742" class="c"><input type="checkbox" id="c-37041742" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#37040467">root</a><span>|</span><a href="#37041148">parent</a><span>|</span><a href="#37041805">prev</a><span>|</span><a href="#37041642">next</a><span>|</span><label class="collapse" for="c-37041742">[-]</label><label class="expand" for="c-37041742">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A good GUI is absolutely instrumental to understanding Git, and it lets you avoid Git&#x27;s terrible CLI for as long as possible.<p>Depends on the user.<p>If they are already an active user of the Terminal, they should be able to learn the git cli without ever touching a GUI.<p>The git cli has some warts for sure, and some weird inconsistencies. But with a bit of practice and some good documents about the correct mental model to have, you get used to it and you learn to use it very effectively.</div><br/></div></div><div id="37041642" class="c"><input type="checkbox" id="c-37041642" checked=""/><div class="controls bullet"><span class="by">memefrog</span><span>|</span><a href="#37040467">root</a><span>|</span><a href="#37041148">parent</a><span>|</span><a href="#37041742">prev</a><span>|</span><a href="#37041516">next</a><span>|</span><label class="collapse" for="c-37041642">[-]</label><label class="expand" for="c-37041642">[1 more]</label></div><br/><div class="children"><div class="content">I totally disagree.  GUIs inevitably confuse people about git.  I have never met anyone that used a GUI for git that actually understood it.</div><br/></div></div><div id="37041516" class="c"><input type="checkbox" id="c-37041516" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#37040467">root</a><span>|</span><a href="#37041148">parent</a><span>|</span><a href="#37041642">prev</a><span>|</span><a href="#37040619">next</a><span>|</span><label class="collapse" for="c-37041516">[-]</label><label class="expand" for="c-37041516">[1 more]</label></div><br/><div class="children"><div class="content">Interesting about starting with the GUI. I can see it being useful in a controlled learning environment where you start with the GUI and gradually transition to the CLI. But if you stay on the GUI too long the student might suffer because they eventually will need to use the CLI, or at least understand its vocabulary, in order to read the documentation and get help from other people.</div><br/></div></div></div></div></div></div><div id="37040619" class="c"><input type="checkbox" id="c-37040619" checked=""/><div class="controls bullet"><span class="by">abdullahkhalids</span><span>|</span><a href="#37040467">parent</a><span>|</span><a href="#37040506">prev</a><span>|</span><a href="#37041668">next</a><span>|</span><label class="collapse" for="c-37040619">[-]</label><label class="expand" for="c-37040619">[1 more]</label></div><br/><div class="children"><div class="content">You should almost certainly talk about the way the history is stored. Both because it is essential to understand how git works, but also, if you drop in some of the mathematics that git uses, the mathematicians will enjoy it more.</div><br/></div></div><div id="37041668" class="c"><input type="checkbox" id="c-37041668" checked=""/><div class="controls bullet"><span class="by">gdprrrr</span><span>|</span><a href="#37040467">parent</a><span>|</span><a href="#37040619">prev</a><span>|</span><a href="#37040739">next</a><span>|</span><label class="collapse" for="c-37041668">[-]</label><label class="expand" for="c-37041668">[2 more]</label></div><br/><div class="children"><div class="content">Definitely mention &quot;directed acyclic graph&quot;</div><br/><div id="37042033" class="c"><input type="checkbox" id="c-37042033" checked=""/><div class="controls bullet"><span class="by">StevenXC</span><span>|</span><a href="#37040467">root</a><span>|</span><a href="#37041668">parent</a><span>|</span><a href="#37040739">next</a><span>|</span><label class="collapse" for="c-37042033">[-]</label><label class="expand" for="c-37042033">[1 more]</label></div><br/><div class="children"><div class="content">I prefer &quot;partial order&quot; but I&#x27;m closer to a set theorist than I am a combinatorist lol.</div><br/></div></div></div></div></div></div><div id="37040739" class="c"><input type="checkbox" id="c-37040739" checked=""/><div class="controls bullet"><span class="by">jehb</span><span>|</span><a href="#37040467">prev</a><span>|</span><a href="#37044057">next</a><span>|</span><label class="collapse" for="c-37040739">[-]</label><label class="expand" for="c-37040739">[1 more]</label></div><br/><div class="children"><div class="content">Fun fact, when I worked at Red Hat for many years on the Opensource.com project, we created a collection of dozens of great articles on the ins and outs of git, written by open source community members. You can still find most of those articles here:<p><a href="https:&#x2F;&#x2F;opensource.com&#x2F;tags&#x2F;git" rel="nofollow noreferrer">https:&#x2F;&#x2F;opensource.com&#x2F;tags&#x2F;git</a><p>Unfortunately, the team who ran site got caught up in Red Hat&#x27;s layoffs earlier this year and the site has been sitting in limbo ever since, so I don&#x27;t know what will happen to it long term.</div><br/></div></div><div id="37044057" class="c"><input type="checkbox" id="c-37044057" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#37040739">prev</a><span>|</span><a href="#37044716">next</a><span>|</span><label class="collapse" for="c-37044057">[-]</label><label class="expand" for="c-37044057">[2 more]</label></div><br/><div class="children"><div class="content">Someone might appreciate the write-up I did after using git for a couple of years:<p><a href="https:&#x2F;&#x2F;ardour.org&#x2F;files&#x2F;gitintro.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;ardour.org&#x2F;files&#x2F;gitintro.pdf</a><p>If I say so myself, I think it&#x27;s better than TFA from redhat.</div><br/><div id="37044636" class="c"><input type="checkbox" id="c-37044636" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#37044057">parent</a><span>|</span><a href="#37044716">next</a><span>|</span><label class="collapse" for="c-37044636">[-]</label><label class="expand" for="c-37044636">[1 more]</label></div><br/><div class="children"><div class="content">This was a nice document. But could you expand what happens after step 4 of your last workflow if you get a conflict with the rebase? You say:<p><pre><code>    &gt; and then tell git to continue attempting to apply your changes.
</code></pre>
Sorry, I just donât know what that means. Redo step 4? Does rebase fail on the first conflict? It seems that when you get a rebase conflict your in the middle of a process but dumped to the command line. Itâs not clear how you move forward (I guess repeat step 4) but more importantly how do you go back to the start before you did step 4?</div><br/></div></div></div></div><div id="37044716" class="c"><input type="checkbox" id="c-37044716" checked=""/><div class="controls bullet"><span class="by">hmble</span><span>|</span><a href="#37044057">prev</a><span>|</span><a href="#37042104">next</a><span>|</span><label class="collapse" for="c-37044716">[-]</label><label class="expand" for="c-37044716">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for sharing this. It inspired me to not worry about whether content already exists or not, we can surely write once again in our way again.<p>Earlier than this post, my thought was that &quot;What value can I add by writing about git? Theres already tons of articles for that.&quot;<p>Seeing this post from Redhat, motivated me to write whatever I feel like writing, even if it has been written before.<p>Thank You</div><br/></div></div><div id="37042104" class="c"><input type="checkbox" id="c-37042104" checked=""/><div class="controls bullet"><span class="by">seba_dos1</span><span>|</span><a href="#37044716">prev</a><span>|</span><a href="#37040932">next</a><span>|</span><label class="collapse" for="c-37042104">[-]</label><label class="expand" for="c-37042104">[1 more]</label></div><br/><div class="children"><div class="content">Teaching git by showing commands is like teaching how to write letters by showing LibreOffice Writer&#x27;s toolbars. It only makes sense when you&#x27;re moving from another similar DVCS that you already understand and know what you&#x27;re operating on by using it.</div><br/></div></div><div id="37040932" class="c"><input type="checkbox" id="c-37040932" checked=""/><div class="controls bullet"><span class="by">smokel</span><span>|</span><a href="#37042104">prev</a><span>|</span><a href="#37040965">next</a><span>|</span><label class="collapse" for="c-37040932">[-]</label><label class="expand" for="c-37040932">[9 more]</label></div><br/><div class="children"><div class="content">How can it be that we are still using plain text files for editing code?<p>Wouldn&#x27;t the grass be greener if a variable were stored as a unique key, making refactoring trivial?  Wouldn&#x27;t the birds sing louder if formatting were just a view on the underlying data?  And wouldn&#x27;t the sun shine really brightly if diffs were to operate directly on the abstract syntax tree?<p>I fear that this has to do with the great problem of interoperability, and of people not always wanting to work together.  What would be a constructive way to coordinate ourselves out of this silliness?</div><br/><div id="37041746" class="c"><input type="checkbox" id="c-37041746" checked=""/><div class="controls bullet"><span class="by">OkayPhysicist</span><span>|</span><a href="#37040932">parent</a><span>|</span><a href="#37044071">next</a><span>|</span><label class="collapse" for="c-37041746">[-]</label><label class="expand" for="c-37041746">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;re in a very, very strong local maxima with plain text source code. In order for a rich-data source language to work you&#x27;d need to implement, competitively with what we have for text, the language itself (which is already a hard sell, look at how difficult it is for even phenomenal languages to gain a foothold) including built-in macro and codegen systems, a compiler, at least one fully-featured editor, complete with linting and code suggestion and search and an input mechanism competitive with just typing out text, possibly more than one to support the wide range of opinions about editors ranging from IDEs to Vim, source control integrated with means for sharing and collaborating on said code, and every other convenience you get for free from choosing plain text.<p>Basically, you need to sit down and build the greatest programming language ever conceived, complete with a world class ecosystem, and then convince people that this is truly a revolution software development, and you probably won&#x27;t make a dime off it because proprietary programming languages are evil.<p>Good luck?</div><br/></div></div><div id="37044071" class="c"><input type="checkbox" id="c-37044071" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#37040932">parent</a><span>|</span><a href="#37041746">prev</a><span>|</span><a href="#37041082">next</a><span>|</span><label class="collapse" for="c-37044071">[-]</label><label class="expand" for="c-37044071">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not about &quot;not always wanting to work together&quot;.<p>It&#x27;s about &quot;i want to be able to pick the tools i use&quot;, which in turn means &quot;the underlying data we operate on needs to use a format&#x2F;storage mechanism that any reasonable candidate for a tool can use&quot;<p>And the answer to that quandry is: plain text files.</div><br/></div></div><div id="37041082" class="c"><input type="checkbox" id="c-37041082" checked=""/><div class="controls bullet"><span class="by">zakary</span><span>|</span><a href="#37040932">parent</a><span>|</span><a href="#37044071">prev</a><span>|</span><a href="#37041267">next</a><span>|</span><label class="collapse" for="c-37041082">[-]</label><label class="expand" for="c-37041082">[1 more]</label></div><br/><div class="children"><div class="content">Those do sound like good ideas. Why donât you try making a proof of concept? Iâd definitely give it a go</div><br/></div></div><div id="37041267" class="c"><input type="checkbox" id="c-37041267" checked=""/><div class="controls bullet"><span class="by">PlunderBunny</span><span>|</span><a href="#37040932">parent</a><span>|</span><a href="#37041082">prev</a><span>|</span><a href="#37041566">next</a><span>|</span><label class="collapse" for="c-37041267">[-]</label><label class="expand" for="c-37041267">[1 more]</label></div><br/><div class="children"><div class="content">Not to mention that comments could point to bits of code without being in the code. We could show them to the user like tooltips (or like the sweet sweet balloon help from macOS Classic - how I miss it so much!)</div><br/></div></div><div id="37041566" class="c"><input type="checkbox" id="c-37041566" checked=""/><div class="controls bullet"><span class="by">suralind</span><span>|</span><a href="#37040932">parent</a><span>|</span><a href="#37041267">prev</a><span>|</span><a href="#37041851">next</a><span>|</span><label class="collapse" for="c-37041566">[-]</label><label class="expand" for="c-37041566">[3 more]</label></div><br/><div class="children"><div class="content">You may be interested in difftastic for doing diffs based on the AST. One problem with this approach is that when you have a lot of changes (tens of lines, maybe hundreds), it gets slow.<p>The tool is great thou, and is my default diffing tool.</div><br/><div id="37043996" class="c"><input type="checkbox" id="c-37043996" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#37040932">root</a><span>|</span><a href="#37041566">parent</a><span>|</span><a href="#37044584">next</a><span>|</span><label class="collapse" for="c-37043996">[-]</label><label class="expand" for="c-37043996">[1 more]</label></div><br/><div class="children"><div class="content">Great potential tool especially when it adds structured data output for easier integration with other tools</div><br/></div></div><div id="37044584" class="c"><input type="checkbox" id="c-37044584" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#37040932">root</a><span>|</span><a href="#37041566">parent</a><span>|</span><a href="#37043996">prev</a><span>|</span><a href="#37041851">next</a><span>|</span><label class="collapse" for="c-37044584">[-]</label><label class="expand" for="c-37044584">[1 more]</label></div><br/><div class="children"><div class="content">We need a way to not break the AST when we extend the language.</div><br/></div></div></div></div><div id="37041851" class="c"><input type="checkbox" id="c-37041851" checked=""/><div class="controls bullet"><span class="by">jdougan</span><span>|</span><a href="#37040932">parent</a><span>|</span><a href="#37041566">prev</a><span>|</span><a href="#37040965">next</a><span>|</span><label class="collapse" for="c-37041851">[-]</label><label class="expand" for="c-37041851">[1 more]</label></div><br/><div class="children"><div class="content">Look up &quot;Intentional Programming&quot;, but watch out for patents.</div><br/></div></div></div></div><div id="37040965" class="c"><input type="checkbox" id="c-37040965" checked=""/><div class="controls bullet"><span class="by">jasoneckert</span><span>|</span><a href="#37040932">prev</a><span>|</span><a href="#37044197">next</a><span>|</span><label class="collapse" for="c-37040965">[-]</label><label class="expand" for="c-37040965">[1 more]</label></div><br/><div class="children"><div class="content">Not a bad guide, but the Linux&#x2F;Windows differentiation is a bit deceiving.<p>For example, &#x27;git config --global user.name &quot;username&quot;&#x27; and &#x27;git config --global user.email &quot;useremail&quot;&#x27; are required for Git users on any system before a commit is made, but since it follows the &#x27;Git Configuration: Windows&#x27; title, it reads as if it&#x27;s a Windows-specific configuration.<p>Additionally, $HOME&#x2F;.gitconfig is also used by Linux (and UNIX and macOS) systems to store this configuration.</div><br/></div></div><div id="37044197" class="c"><input type="checkbox" id="c-37044197" checked=""/><div class="controls bullet"><span class="by">arkj</span><span>|</span><a href="#37040965">prev</a><span>|</span><a href="#37044213">next</a><span>|</span><label class="collapse" for="c-37044197">[-]</label><label class="expand" for="c-37044197">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; When using the git commit command, we recommend always including two arguments: -an and -m.<p>This advice will mislead beginners for whom the article is written.</div><br/></div></div><div id="37044213" class="c"><input type="checkbox" id="c-37044213" checked=""/><div class="controls bullet"><span class="by">542458</span><span>|</span><a href="#37044197">prev</a><span>|</span><a href="#37041530">next</a><span>|</span><label class="collapse" for="c-37044213">[-]</label><label class="expand" for="c-37044213">[2 more]</label></div><br/><div class="children"><div class="content">On the topic of Git, I vaguely remember somebody mentioning that Google was looking at wrapping Git with something else to simplify it. Anybody remember what that project is?</div><br/><div id="37044231" class="c"><input type="checkbox" id="c-37044231" checked=""/><div class="controls bullet"><span class="by">resonious</span><span>|</span><a href="#37044213">parent</a><span>|</span><a href="#37041530">next</a><span>|</span><label class="collapse" for="c-37044231">[-]</label><label class="expand" for="c-37044231">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s &quot;jj&quot;, which started as a Google employee&#x27;s hobby project but they put him full time on it. Not sure how much G plans to push this, but they are endorsing it at least.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;martinvonz&#x2F;jj">https:&#x2F;&#x2F;github.com&#x2F;martinvonz&#x2F;jj</a><p>I&#x27;ve been using it myself lately and it&#x27;s pretty cool. Takes some getting used to, but actually pretty easy to recover from screw ups, unlike git.</div><br/></div></div></div></div><div id="37041530" class="c"><input type="checkbox" id="c-37041530" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#37044213">prev</a><span>|</span><a href="#37041624">next</a><span>|</span><label class="collapse" for="c-37041530">[-]</label><label class="expand" for="c-37041530">[1 more]</label></div><br/><div class="children"><div class="content">OT: scrolling creates browser history entries that have to be skipped back, back, etc to go back--new ways to break user expectations.</div><br/></div></div><div id="37041624" class="c"><input type="checkbox" id="c-37041624" checked=""/><div class="controls bullet"><span class="by">725686</span><span>|</span><a href="#37041530">prev</a><span>|</span><a href="#37040994">next</a><span>|</span><label class="collapse" for="c-37041624">[-]</label><label class="expand" for="c-37041624">[1 more]</label></div><br/><div class="children"><div class="content">I always recommend getting started with git with &quot;Git For Ages 4 And Up&quot; by Michael G. Shwern:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=1ffBJ4sVUb4&amp;t=10s">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=1ffBJ4sVUb4&amp;t=10s</a></div><br/></div></div><div id="37040994" class="c"><input type="checkbox" id="c-37040994" checked=""/><div class="controls bullet"><span class="by">loubbrad</span><span>|</span><a href="#37041624">prev</a><span>|</span><a href="#37040872">next</a><span>|</span><label class="collapse" for="c-37040994">[-]</label><label class="expand" for="c-37040994">[1 more]</label></div><br/><div class="children"><div class="content">Leaving this here (not self promo):<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=hZS96dwKvt0">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=hZS96dwKvt0</a><p>By far the best non-beginner git tutorial I&#x27;ve ever found.</div><br/></div></div><div id="37040872" class="c"><input type="checkbox" id="c-37040872" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37040994">prev</a><span>|</span><a href="#37043863">next</a><span>|</span><label class="collapse" for="c-37040872">[-]</label><label class="expand" for="c-37040872">[30 more]</label></div><br/><div class="children"><div class="content">My dream is that someday weâll all use a VCS that is so simple the internet doesnât have literally tens of thousands of blog posts pretending itâs simple. Somedayâ¦</div><br/><div id="37041307" class="c"><input type="checkbox" id="c-37041307" checked=""/><div class="controls bullet"><span class="by">PlunderBunny</span><span>|</span><a href="#37040872">parent</a><span>|</span><a href="#37041660">next</a><span>|</span><label class="collapse" for="c-37041307">[-]</label><label class="expand" for="c-37041307">[5 more]</label></div><br/><div class="children"><div class="content">Yeah. Maybe I&#x27;m making excuses, but tools should be easy to use and get out of the way - they&#x27;re not what we&#x27;re being paid for. People say &#x27;knowing how to use your tools properly is part of your craft&#x27;, but I feel Git is more like someone asked for a cabinet and instead we gave them a hammer, some nails, and some timber and said &#x27;but this is so much better than just giving you a cabinet!&#x27;</div><br/><div id="37042422" class="c"><input type="checkbox" id="c-37042422" checked=""/><div class="controls bullet"><span class="by">sixstringtheory</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37041307">parent</a><span>|</span><a href="#37041660">next</a><span>|</span><label class="collapse" for="c-37042422">[-]</label><label class="expand" for="c-37042422">[4 more]</label></div><br/><div class="children"><div class="content">I see it more like someone asked for a cabinet and hired you, the carpenter, to plane, route, chamfer, mitre, join, hammer, nail, screw and glue the wood into place.<p>You absolutely need to know the right tools and techniques, of which there are many. For instance, nails and screws are not interchangeable, and they&#x27;re made with a variety of metals and coatings for specific applications.<p>Just about anyone can hammer a nail into a piece of wood. It is quite difficult to put together a high quality finished piece of woodwork. Same is true for software.</div><br/><div id="37042853" class="c"><input type="checkbox" id="c-37042853" checked=""/><div class="controls bullet"><span class="by">PlunderBunny</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37042422">parent</a><span>|</span><a href="#37041660">next</a><span>|</span><label class="collapse" for="c-37042853">[-]</label><label class="expand" for="c-37042853">[3 more]</label></div><br/><div class="children"><div class="content">I can sort-of see your point, but (stretching the analogy way too far), imagine I&#x27;m the interior decorator and I&#x27;m asking for a cabinet among other things. My expertise is not in making the cabinet. Relating it back to being a software developer, my expertise is in the problem domain and the business logic.<p>I don&#x27;t think Git is stupid or fundamentally wrong, just that the interface we&#x27;re all using (even the GUI interfaces) are just thin veneers over the underlying API, which is confusing to many people, and that Git could be more productive for most developers when we have an abstraction that is easier to understand.<p>I&#x27;ve seen people much smarter than me fumbling around to solve problems with Git.</div><br/><div id="37044100" class="c"><input type="checkbox" id="c-37044100" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37042853">parent</a><span>|</span><a href="#37041660">next</a><span>|</span><label class="collapse" for="c-37044100">[-]</label><label class="expand" for="c-37044100">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Relating it back to being a software developer, my expertise is in the problem domain and the business logic.<p>That&#x27;s your problem right there.<p>You&#x27;re a craftsman. You have three sets of inputs: raw materials, designs and tools.<p>You&#x27;ve chosen to focus on raw materials and designs, and have decided that mastery of the tools (or some subset of the tools) is not important.<p>A cabinet maker who said &quot;my expertise is in complex corner joinery and standalone rectangular forms&quot; would be laughed at if they also added &quot;i find japanese saws and routers problematic&quot;.<p>Yes, tools are tricky. Tools are hard. But tools are an equal part of the task triangle, and you owe it yourself to build up your own scaffolding of understanding for the tools as you do for the other components.</div><br/><div id="37044378" class="c"><input type="checkbox" id="c-37044378" checked=""/><div class="controls bullet"><span class="by">PlunderBunny</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37044100">parent</a><span>|</span><a href="#37041660">next</a><span>|</span><label class="collapse" for="c-37044378">[-]</label><label class="expand" for="c-37044378">[1 more]</label></div><br/><div class="children"><div class="content">Sure, a source code repository is an essential tool. But if you have a company that has a room (or several rooms) full of developers that work on a product, the expertise (arguably, the whole raison d&#x27;Ãªtre) of that company is in the things that only they do. The tools are necessary, but you don&#x27;t want every developer to have to devote any more time than is necessary to learning&#x2F;using a tool.<p>I&#x27;m not arguing against source control, I&#x27;m arguing against a tool that so complicated and is obviously so hard to master might work against us as much as it work for us.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37041660" class="c"><input type="checkbox" id="c-37041660" checked=""/><div class="controls bullet"><span class="by">memefrog</span><span>|</span><a href="#37040872">parent</a><span>|</span><a href="#37041307">prev</a><span>|</span><a href="#37041289">next</a><span>|</span><label class="collapse" for="c-37041660">[-]</label><label class="expand" for="c-37041660">[2 more]</label></div><br/><div class="children"><div class="content">People blog about things they learn about.  Lots of people use git so they blog about it.<p>Nobody is pretending it is simple.  It is simple.</div><br/><div id="37041803" class="c"><input type="checkbox" id="c-37041803" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37041660">parent</a><span>|</span><a href="#37041289">next</a><span>|</span><label class="collapse" for="c-37041803">[-]</label><label class="expand" for="c-37041803">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It is simple.<p>No, it isnât.</div><br/></div></div></div></div><div id="37041289" class="c"><input type="checkbox" id="c-37041289" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37040872">parent</a><span>|</span><a href="#37041660">prev</a><span>|</span><a href="#37041077">next</a><span>|</span><label class="collapse" for="c-37041289">[-]</label><label class="expand" for="c-37041289">[3 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s because it <i>is</i> simple, but Git&#x27;s terrible CLI makes it hard to learn. Once you&#x27;ve learnt it you can ignore all of the terrible interface and just think about the actual operations you want to do which are generally very simple.<p>I could explain Git&#x27;s data model and what the operations do to my wife. I don&#x27;t think I could actually teach her how to use the git command line though.</div><br/><div id="37044015" class="c"><input type="checkbox" id="c-37044015" checked=""/><div class="controls bullet"><span class="by">Pxtl</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37041289">parent</a><span>|</span><a href="#37041077">next</a><span>|</span><label class="collapse" for="c-37044015">[-]</label><label class="expand" for="c-37044015">[2 more]</label></div><br/><div class="children"><div class="content">The core is simple.  Misfeatures like the stage and the stash and submodules are not part of the simple core.  The workflow where we have no good way to hide history besides destroying it is simple but also stupid, particularly when destroying history also destroys your ability to collaborate or even merge your own code cleanly.</div><br/><div id="37044112" class="c"><input type="checkbox" id="c-37044112" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37044015">parent</a><span>|</span><a href="#37041077">next</a><span>|</span><label class="collapse" for="c-37044112">[-]</label><label class="expand" for="c-37044112">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll get your hands on my git stash when I&#x27;m dead and buried and turned to dust in the ground.<p>Not to worry, you&#x27;ll probably still be alive for that.</div><br/></div></div></div></div></div></div><div id="37041077" class="c"><input type="checkbox" id="c-37041077" checked=""/><div class="controls bullet"><span class="by">Espressosaurus</span><span>|</span><a href="#37040872">parent</a><span>|</span><a href="#37041289">prev</a><span>|</span><a href="#37043863">next</a><span>|</span><label class="collapse" for="c-37041077">[-]</label><label class="expand" for="c-37041077">[19 more]</label></div><br/><div class="children"><div class="content">We had our chance and decided that worse is better, so here we are.</div><br/><div id="37041649" class="c"><input type="checkbox" id="c-37041649" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37041077">parent</a><span>|</span><a href="#37041234">next</a><span>|</span><label class="collapse" for="c-37041649">[-]</label><label class="expand" for="c-37041649">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious, if you are referring to mercurial, how is it better?<p>I&#x27;ve never used it so I&#x27;m wondering what I&#x27;m &quot;missing out&quot; on!</div><br/></div></div><div id="37041234" class="c"><input type="checkbox" id="c-37041234" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37041077">parent</a><span>|</span><a href="#37041649">prev</a><span>|</span><a href="#37043863">next</a><span>|</span><label class="collapse" for="c-37041234">[-]</label><label class="expand" for="c-37041234">[17 more]</label></div><br/><div class="children"><div class="content">Mercurial was simpler but it was also written in slooooow Python so overall it wasn&#x27;t really better.</div><br/><div id="37041326" class="c"><input type="checkbox" id="c-37041326" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37041234">parent</a><span>|</span><a href="#37043863">next</a><span>|</span><label class="collapse" for="c-37041326">[-]</label><label class="expand" for="c-37041326">[16 more]</label></div><br/><div class="children"><div class="content">Re-implementing a good API in a better language is relatively easy. Replacing a bad API is nigh impossible. :(<p>Mistakes were made.</div><br/><div id="37041696" class="c"><input type="checkbox" id="c-37041696" checked=""/><div class="controls bullet"><span class="by">memefrog</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37041326">parent</a><span>|</span><a href="#37045323">next</a><span>|</span><label class="collapse" for="c-37041696">[-]</label><label class="expand" for="c-37041696">[14 more]</label></div><br/><div class="children"><div class="content">It is easy to replace a &quot;bad API&quot;.  There are a million alternative CLIs and GUIs for git.<p>They haven&#x27;t caught on because it turns out git&#x27;s CLI isnt actually bad.  It feels complex because it feels like what it is doing is simpler than is presented.  But in fact it is solving quite a complicated distributed database program, transactionally, with editable history.  The CLI hides a lot of that but cant hide it all.  But you do need the flexibility.</div><br/><div id="37042635" class="c"><input type="checkbox" id="c-37042635" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37041696">parent</a><span>|</span><a href="#37045323">next</a><span>|</span><label class="collapse" for="c-37042635">[-]</label><label class="expand" for="c-37042635">[13 more]</label></div><br/><div class="children"><div class="content">Hard disagree.<p>Perforce is idiot proof. I can teach a non-programmer who has never even heard of revision control how to use Perforce in literally 10 minutes. They will never shoot themselves in the foot. They will never lose work. They will never, ever need to nuke and reclone their repo.<p>Perforce has other issues of course. But Git has both a bad CLI and a bad model. Maybe its particular model is strictly required for the Linux kernel. However for 99% of developers that are centralized on GitHub the model ranges from âmediocre fitâ to âdownright brokenâ.</div><br/><div id="37045410" class="c"><input type="checkbox" id="c-37045410" checked=""/><div class="controls bullet"><span class="by">memefrog</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37042635">parent</a><span>|</span><a href="#37045457">next</a><span>|</span><label class="collapse" for="c-37045410">[-]</label><label class="expand" for="c-37045410">[1 more]</label></div><br/><div class="children"><div class="content">&gt;They will never shoot themselves in the foot. They will never lose work. They will never, ever need to nuke and reclone their repo.<p>You never need to do these things in git either.  People only &#x27;nuke and re-clone their repo&#x27; because they google something and get awful StackOverflow answers written by idiots that tell them to do that.  It&#x27;s not how you&#x27;re meant to do things in git.<p>You&#x27;re very unlikely to actually lose history in git unless you go out of your way to do so.  I mean, you might not actually commit your changes, but I&#x27;d hardly call that &#x27;losing work&#x27;.  What&#x27;s the alternative, autosaving into your history?  No thanks.  But once something&#x27;s committed, it is hard to delete it.  The reflog exists.</div><br/></div></div><div id="37045457" class="c"><input type="checkbox" id="c-37045457" checked=""/><div class="controls bullet"><span class="by">lentil_soup</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37042635">parent</a><span>|</span><a href="#37045410">prev</a><span>|</span><a href="#37044128">next</a><span>|</span><label class="collapse" for="c-37045457">[-]</label><label class="expand" for="c-37045457">[3 more]</label></div><br/><div class="children"><div class="content">Another +1 for Perforce from me, it&#x27;s just so much simpler for non dev users. It&#x27;s of course a no-go if you really need the distributed nature of git, but as you say, for the majority of users that use GitHub&#x2F;GitLab it&#x27;s an option.<p>The philosophical difference I&#x27;ve found using both is that Perforce is file centric and git is commit centric. In perforce you have the file tree and then the history of each file, with git it&#x27;s flipped. This is why I find it so hard in git to see how a particular file has evolved, with Perforce it&#x27;s second nature. Perforce is so good at telling you why a particular line of code is there, I miss that so much in git.</div><br/><div id="37045534" class="c"><input type="checkbox" id="c-37045534" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37045457">parent</a><span>|</span><a href="#37044128">next</a><span>|</span><label class="collapse" for="c-37045534">[-]</label><label class="expand" for="c-37045534">[2 more]</label></div><br/><div class="children"><div class="content">God how I wish Git had something as good as Perforceâs timelapse view.</div><br/><div id="37046037" class="c"><input type="checkbox" id="c-37046037" checked=""/><div class="controls bullet"><span class="by">lentil_soup</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37045534">parent</a><span>|</span><a href="#37044128">next</a><span>|</span><label class="collapse" for="c-37046037">[-]</label><label class="expand" for="c-37046037">[1 more]</label></div><br/><div class="children"><div class="content">Glad to know I&#x27;m not the only one! I keep wondering if I&#x27;m misunderstanding something in git since I couldn&#x27;t find something like the timelapse view.<p>I&#x27;ve even considered trying to code something similar to ease the pain!</div><br/></div></div></div></div></div></div><div id="37044128" class="c"><input type="checkbox" id="c-37044128" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37042635">parent</a><span>|</span><a href="#37045457">prev</a><span>|</span><a href="#37045323">next</a><span>|</span><label class="collapse" for="c-37044128">[-]</label><label class="expand" for="c-37044128">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Perforce is idiot proof.<p>&gt; Perforce has other issues of course.<p>Claim: You can&#x27;t solve the issues with perforce without making it no longer idiot proof.<p>I&#x27;ve used perforce. For distributed development, it&#x27;s a total non-starter.</div><br/><div id="37044755" class="c"><input type="checkbox" id="c-37044755" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37044128">parent</a><span>|</span><a href="#37044960">next</a><span>|</span><label class="collapse" for="c-37044755">[-]</label><label class="expand" for="c-37044755">[3 more]</label></div><br/><div class="children"><div class="content">Just curious about this because Iâve never had any direct experience. All of my uses of any version control (save very early work with RCS) has been to a central server.<p>But âdistributedâ must mean something other than that, especially how git is presented (i.e. technically there is no center).<p>So, do folks doing distributed development routinely push changes in a peer to peer fashion? Alice, Bob, and Charlene are collaborating with Alice and Bob working on one feature while Alice and Charlene work on another, pushing incremental changes to each other but only sending the completed feature&#x2F;branch to their non-collaborating peers when theyâre complete.<p>Does that happen often or is it just the âcommit early, commit often to the local copyâ that distributed devs are really using? âI can edit on a planeâ scenarios.</div><br/><div id="37045099" class="c"><input type="checkbox" id="c-37045099" checked=""/><div class="controls bullet"><span class="by">memefrog</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37044755">parent</a><span>|</span><a href="#37044960">next</a><span>|</span><label class="collapse" for="c-37045099">[-]</label><label class="expand" for="c-37045099">[2 more]</label></div><br/><div class="children"><div class="content">&gt;So, do folks doing distributed development routinely push changes in a peer to peer fashion? Alice, Bob, and Charlene are collaborating with Alice and Bob working on one feature while Alice and Charlene work on another, pushing incremental changes to each other but only sending the completed feature&#x2F;branch to their non-collaborating peers when theyâre complete.<p>Yes.  The prototypical example is the Linux kernel, which is what git was originally created for.  There, there are a large number of different trees.  Linus&#x27;s tree is &#x27;standard&#x27; Linux, but there are the various stable trees, there are trees for various subsystems, there&#x27;s the continuous integration tree &#x27;linux-next&#x27;, and others.  Those trees&#x27; changes are all intended to eventually reach Linus&#x27;s tree.  But there are other trees which aren&#x27;t, they host patchsets that sit on top of Linux &quot;proper&quot; but aren&#x27;t intended to ever be upstreamed.<p>&gt;Does that happen often or is it just the âcommit early, commit often to the local copyâ that distributed devs are really using? âI can edit on a planeâ scenarios.<p>In practice, not many open source projects are big enough and distributed enough that they need to do what Linux does.  This aspect of it is very useful too: that you can code on a plane, that you can code in the bath, that you can code in a shack in the woods, etc.</div><br/><div id="37045655" class="c"><input type="checkbox" id="c-37045655" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37045099">parent</a><span>|</span><a href="#37044960">next</a><span>|</span><label class="collapse" for="c-37045655">[-]</label><label class="expand" for="c-37045655">[1 more]</label></div><br/><div class="children"><div class="content">Good description of the Linux trees, thanks!<p>&gt; This aspect of it is very useful too: that you can code on a plane, that you can code in the bath, that you can code in a shack in the woods, etc.<p>Even turbo-centralized Perforce supports offline mode. Distributed systems enable offline mode, but offline mode does not require a hyper distributed system!</div><br/></div></div></div></div></div></div><div id="37044960" class="c"><input type="checkbox" id="c-37044960" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37044128">parent</a><span>|</span><a href="#37044755">prev</a><span>|</span><a href="#37045323">next</a><span>|</span><label class="collapse" for="c-37044960">[-]</label><label class="expand" for="c-37044960">[4 more]</label></div><br/><div class="children"><div class="content">&gt; For distributed development, it&#x27;s a total non-starter.<p>Define distributed development. Do you mean like Linux with thousands of random contributors? Or do you mean a game team distributed across the globe? Or a AAAA team with big, scattered offices?<p>Perforce is not a good fit for Linux! Itâs effectively the only game in town for almost all game devs.<p>&gt; You can&#x27;t solve the issues with perforce without making it no longer idiot proof.<p>I think Iâd take that bet. Becoming idiot proof isnât hard. The trick is for all commits to be automatically backed up in the central hub. And for commits to be locked and stable once made.<p>Gitâs ability to re-write history is, imho, a huge mistake and I donât <i>think</i> actually necessary to support Linux. Flattening on PR merge doesnât require a rewrite.</div><br/><div id="37045128" class="c"><input type="checkbox" id="c-37045128" checked=""/><div class="controls bullet"><span class="by">memefrog</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37044960">parent</a><span>|</span><a href="#37045323">next</a><span>|</span><label class="collapse" for="c-37045128">[-]</label><label class="expand" for="c-37045128">[3 more]</label></div><br/><div class="children"><div class="content">&gt;I think Iâd take that bet. Becoming idiot proof isnât hard. The trick is for all commits to be automatically backed up in the central hub.<p>That&#x27;s the last thing I want.  Random WIP commits being sent off to some central hub?  Fuck that, man.  Fuck that.<p>&gt;And for commits to be locked and stable once made. Gitâs ability to re-write history is, imho, a huge mistake and I donât think actually necessary to support Linux. Flattening on PR merge doesnât require a rewrite.<p>Being able to re-write history is absolutely necessary.  I seriously doubt you&#x27;ve ever looked at a patch series posted for any free software project if you say that rewriting history isn&#x27;t necessary.<p>To put it quite simply: <i>my</i> data is under <i>my</i> control.  I can do whatever I want with it.  I commit frequently because it is useful to be able to go back in history through changes as I make them.  For the purpose of publication, it is not useful to see the various stages I went through when thinking about how to solve a problem.  That&#x27;s not what git history is for.  It&#x27;s for presenting a logical series of changes in a way that is easy to understand and bisect.  Flattening on &#x27;PR merge&#x27; is abysmal.  I don&#x27;t want one massive commit.  I want a series of logical commits.</div><br/><div id="37045377" class="c"><input type="checkbox" id="c-37045377" checked=""/><div class="controls bullet"><span class="by">lentil_soup</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37045128">parent</a><span>|</span><a href="#37045621">next</a><span>|</span><label class="collapse" for="c-37045377">[-]</label><label class="expand" for="c-37045377">[1 more]</label></div><br/><div class="children"><div class="content">But in Perforce you can have your own private branch, in practice it feels not much different than having a local git one. You can then merge to main as you want.</div><br/></div></div><div id="37045621" class="c"><input type="checkbox" id="c-37045621" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37045128">parent</a><span>|</span><a href="#37045377">prev</a><span>|</span><a href="#37045323">next</a><span>|</span><label class="collapse" for="c-37045621">[-]</label><label class="expand" for="c-37045621">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s the last thing I want. Random WIP commits being sent off to some central hub? Fuck that, man. Fuck that.<p>This is where youâre objectively wrong. I have this feature available to me today. Itâs a killer feature. Itâs amazing. Having it has zero downsides. Not having it is a pain in the ass and makes life worse.<p>Imagine this. Youâre working at a company with thousands of engineers. Everyone is making stacks and stacks of local commits. At various points in time people push their commit(s) to code review. If approved it gets merged into master.<p>Now imagine if anyone could check out any commit from any employee just by typing âgit checkout #####â. Thatâs it. Thatâs the feature. If you browse the repo it is perfectly clean. Thereâs no dirt or noise. This includes letting you checkout your own commit on one of your five different machines&#x2F;platforms&#x2F;cloud servers without having to push or pull or any of that shit. Commit on one machine and checkout on another. Itâs pure automagic.<p>&gt; Flattening on &#x27;PR merge&#x27; is abysmal. I don&#x27;t want one massive commit. I want a series of logical commits.<p>Sure fine. Shape the series of commits however you want. As few or as many as you want. With nice clean messages. The world is your oyster. But those are <i>new</i> commits. The initial commits should be, imho, unaltered (and unmerged). They can be GCâd months&#x2F;years down the road if needed.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37045323" class="c"><input type="checkbox" id="c-37045323" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37040872">root</a><span>|</span><a href="#37041326">parent</a><span>|</span><a href="#37041696">prev</a><span>|</span><a href="#37043863">next</a><span>|</span><label class="collapse" for="c-37045323">[-]</label><label class="expand" for="c-37045323">[1 more]</label></div><br/><div class="children"><div class="content">So relatively simple that it took 12 years to even begin? Can you really blame people for using Git when it took them 9 years to even accept that Python performance was a problem?<p><a href="https:&#x2F;&#x2F;mail.python.org&#x2F;pipermail&#x2F;python-dev&#x2F;2014-May&#x2F;134528.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;mail.python.org&#x2F;pipermail&#x2F;python-dev&#x2F;2014-May&#x2F;134528...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="37043863" class="c"><input type="checkbox" id="c-37043863" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#37040872">prev</a><span>|</span><a href="#37043323">next</a><span>|</span><label class="collapse" for="c-37043863">[-]</label><label class="expand" for="c-37043863">[1 more]</label></div><br/><div class="children"><div class="content">Beginners should use a good GUI client that would obviate the need to remember a whole bunch of commands in the guide while also being more expressive</div><br/></div></div><div id="37043323" class="c"><input type="checkbox" id="c-37043323" checked=""/><div class="controls bullet"><span class="by">Tommstein</span><span>|</span><a href="#37043863">prev</a><span>|</span><a href="#37040533">next</a><span>|</span><label class="collapse" for="c-37043323">[-]</label><label class="expand" for="c-37043323">[2 more]</label></div><br/><div class="children"><div class="content">I am reminded of this thread I came across when Bram Moolenaar died the other day: <a href="https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;vim_dev&#x2F;c&#x2F;ivkq22t3LQM" rel="nofollow noreferrer">https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;vim_dev&#x2F;c&#x2F;ivkq22t3LQM</a> . Choice quotes:<p>&gt; <i>It will be good if someone can suggest the git
commands for that.</i><p>&gt; <i>I tried creating diffs from the tagged commits, but those
are a bit messy too. I&#x27;ll not try to fix more, unless someone can tell
me the git commands that will make something better.</i><p>Consider that even the creator of Vim, a text editor so esoteric that the running joke is that no one even knows how to exit it at first, was repeatedly asking for help with Git commands. Let that sink in.</div><br/><div id="37043580" class="c"><input type="checkbox" id="c-37043580" checked=""/><div class="controls bullet"><span class="by">PlunderBunny</span><span>|</span><a href="#37043323">parent</a><span>|</span><a href="#37040533">next</a><span>|</span><label class="collapse" for="c-37043580">[-]</label><label class="expand" for="c-37043580">[1 more]</label></div><br/><div class="children"><div class="content">My version of this is: &quot;Tell me which button to smash to make this problem go away.&quot;</div><br/></div></div></div></div><div id="37040533" class="c"><input type="checkbox" id="c-37040533" checked=""/><div class="controls bullet"><span class="by">chiefalchemist</span><span>|</span><a href="#37043323">prev</a><span>|</span><a href="#37040854">next</a><span>|</span><label class="collapse" for="c-37040533">[-]</label><label class="expand" for="c-37040533">[5 more]</label></div><br/><div class="children"><div class="content">This guide would benefit from some visuals. That is, what is happening, and why. Else, for beginners, just listing commands is too abstract. It would also help to elaborate a bit on why, or at least walk though a merge conflict, &#x27;cause ultimately, that&#x27;s what beginners need to be aware of. That is, Dev A made changes a file and Dev B also made changes to that file. Boom! But this is why we use Git.</div><br/><div id="37040570" class="c"><input type="checkbox" id="c-37040570" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#37040533">parent</a><span>|</span><a href="#37040854">next</a><span>|</span><label class="collapse" for="c-37040570">[-]</label><label class="expand" for="c-37040570">[4 more]</label></div><br/><div class="children"><div class="content">The Git book, Pro Git, does a decent job of this. Also <a href="https:&#x2F;&#x2F;learngitbranching.js.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;learngitbranching.js.org&#x2F;</a></div><br/><div id="37041426" class="c"><input type="checkbox" id="c-37041426" checked=""/><div class="controls bullet"><span class="by">chiefalchemist</span><span>|</span><a href="#37040533">root</a><span>|</span><a href="#37040570">parent</a><span>|</span><a href="#37040854">next</a><span>|</span><label class="collapse" for="c-37041426">[-]</label><label class="expand" for="c-37041426">[3 more]</label></div><br/><div class="children"><div class="content">I believe that on GitHub there are also visual examples.<p>For me, ultimately, Git is best understood when there are visuals. The command line is cool, but if there&#x27;s a tool that begs for a UI it&#x27;s Git.<p>Yeah, I know there are Git UI tools, so many the article should have suggested some of those as well?</div><br/><div id="37041564" class="c"><input type="checkbox" id="c-37041564" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#37040533">root</a><span>|</span><a href="#37041426">parent</a><span>|</span><a href="#37040854">next</a><span>|</span><label class="collapse" for="c-37041564">[-]</label><label class="expand" for="c-37041564">[2 more]</label></div><br/><div class="children"><div class="content">I have yet to find a Git GUI that really feels right. Recommendations?</div><br/><div id="37046251" class="c"><input type="checkbox" id="c-37046251" checked=""/><div class="controls bullet"><span class="by">chiefalchemist</span><span>|</span><a href="#37040533">root</a><span>|</span><a href="#37041564">parent</a><span>|</span><a href="#37040854">next</a><span>|</span><label class="collapse" for="c-37046251">[-]</label><label class="expand" for="c-37046251">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using GitKraken which is paid (@ a fair $60 p&#x2F;y). But I also see FOSS options mentioned on HN from time to time and intend to explore one of those. Perhaps I&#x27;ll do an Ask HN later today?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37040854" class="c"><input type="checkbox" id="c-37040854" checked=""/><div class="controls bullet"><span class="by">micw</span><span>|</span><a href="#37040533">prev</a><span>|</span><a href="#37041647">next</a><span>|</span><label class="collapse" for="c-37040854">[-]</label><label class="expand" for="c-37040854">[1 more]</label></div><br/><div class="children"><div class="content">A short explaination what remotes are and how to configure it would be helpfull. Otherwise, the &quot;git push&quot; command would fail and the tutorial gives no hint, why.</div><br/></div></div><div id="37041647" class="c"><input type="checkbox" id="c-37041647" checked=""/><div class="controls bullet"><span class="by">spiritplumber</span><span>|</span><a href="#37040854">prev</a><span>|</span><a href="#37041502">next</a><span>|</span><label class="collapse" for="c-37041647">[-]</label><label class="expand" for="c-37041647">[2 more]</label></div><br/><div class="children"><div class="content">Stupid question: how do I move stuff from &quot;master&quot; to, IDK, &quot;main&quot; or similar, while preserving history?</div><br/><div id="37041894" class="c"><input type="checkbox" id="c-37041894" checked=""/><div class="controls bullet"><span class="by">yCombLinks</span><span>|</span><a href="#37041647">parent</a><span>|</span><a href="#37041502">next</a><span>|</span><label class="collapse" for="c-37041894">[-]</label><label class="expand" for="c-37041894">[1 more]</label></div><br/><div class="children"><div class="content">Cherry pick if you want an entire commit</div><br/></div></div></div></div><div id="37041502" class="c"><input type="checkbox" id="c-37041502" checked=""/><div class="controls bullet"><span class="by">LargeTomato</span><span>|</span><a href="#37041647">prev</a><span>|</span><a href="#37043975">next</a><span>|</span><label class="collapse" for="c-37041502">[-]</label><label class="expand" for="c-37041502">[1 more]</label></div><br/><div class="children"><div class="content">Honestly Redhat puts out some really solid documentation and blog posts. It&#x27;s a shame what they&#x27;re doing with rhel.</div><br/></div></div><div id="37043975" class="c"><input type="checkbox" id="c-37043975" checked=""/><div class="controls bullet"><span class="by">Pxtl</span><span>|</span><a href="#37041502">prev</a><span>|</span><label class="collapse" for="c-37043975">[-]</label><label class="expand" for="c-37043975">[1 more]</label></div><br/><div class="children"><div class="content">Unrelated to content of article but the fact that scrolling the article pushes sections onto the history stack (instead of replacing the top of the stack) is exceptionally rude.  I should not have to hit back 10 times just because I skimmed through the subject headings.</div><br/></div></div></div></div></div></div></div></body></html>