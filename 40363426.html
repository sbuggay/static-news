<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715936463905" as="style"/><link rel="stylesheet" href="styles.css?v=1715936463905"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/SPLWare/esProc/wiki/Simplifying-JOIN-syntax-(JOIN-Simplification-and-Acceleration-Series-3)">Simplifying Join Syntax</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>Judyrabbit</span> | <span>13 comments</span></div><br/><div><div id="40387654" class="c"><input type="checkbox" id="c-40387654" checked=""/><div class="controls bullet"><span class="by">funcDropShadow</span><span>|</span><a href="#40387821">next</a><span>|</span><label class="collapse" for="c-40387654">[-]</label><label class="expand" for="c-40387654">[1 more]</label></div><br/><div class="children"><div class="content">The presented idea shortens the given examples, but is not composable. What happens if you have 1:N instead of 1:1 relation? Or even a N:M relation. Where do you specify whether you want an innner &#x2F; outer &#x2F; left &#x2F; right join? 
This proposal works for some simple queries but fails to capture the generality of the relational model.<p>So, from a language development point of view, one has to ask: Is this special case worth the extra syntactical sugar? It has the downside, that when a query evolves and falls out of the special case you have to reformulate the syntactical sugar yourself. This creates friction, and it is still necessary to understand the relational model.<p>Other commenters mentioned Neo4j as an example where similar ideas have been implemented. From my limited experience with Neo4j, I&#x27;d say it makes a lot of sense there, because graph queries will often fall into the sub class of queries, that can benefit from the syntactical sugar.<p>All in all, I would not call this a simplification. Syntactical sugar never is a simplification. It is an &quot;easification&quot;. It makes certain examples easy and hides what is going on, without really abstracting it away.</div><br/></div></div><div id="40387821" class="c"><input type="checkbox" id="c-40387821" checked=""/><div class="controls bullet"><span class="by">atemerev</span><span>|</span><a href="#40387654">prev</a><span>|</span><a href="#40386616">next</a><span>|</span><label class="collapse" for="c-40387821">[-]</label><label class="expand" for="c-40387821">[1 more]</label></div><br/><div class="children"><div class="content">See “natural join”, which already exists in SQL; I use it all the time.</div><br/></div></div><div id="40386616" class="c"><input type="checkbox" id="c-40386616" checked=""/><div class="controls bullet"><span class="by">asplake</span><span>|</span><a href="#40387821">prev</a><span>|</span><a href="#40386936">next</a><span>|</span><label class="collapse" for="c-40386616">[-]</label><label class="expand" for="c-40386616">[1 more]</label></div><br/><div class="children"><div class="content">“As all joins involve the primary key…”<p>Often but not always the case<p>Edit: at least not in SQL, and therefore SQL databases. If the language being described here isn&#x27;t actually SQL, that could still be a problem.</div><br/></div></div><div id="40386936" class="c"><input type="checkbox" id="c-40386936" checked=""/><div class="controls bullet"><span class="by">david_p</span><span>|</span><a href="#40386616">prev</a><span>|</span><a href="#40387320">next</a><span>|</span><label class="collapse" for="c-40386936">[-]</label><label class="expand" for="c-40386936">[1 more]</label></div><br/><div class="children"><div class="content">I love the idea of a simplified SQL syntax for joins.<p>I have been working with graph databases for years now: these databases had to solve this problem from day one, because of the focus on relationships between entities.<p>I must point out that Neo4j was the first to propose a syntax that made traversal feel simple and natural again: the Cypher query language.<p>Neo4 and other industry players have spent years working on a new standard query language for graph databases that was released in April this year: GQL. GQL is the first database query language normalized by ISO since SQL, so it’s a big deal.<p>Anyway, if you wanna learn more about GQL, that a look at 
<a href="https:&#x2F;&#x2F;www.gqlstandards.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.gqlstandards.org&#x2F;</a></div><br/></div></div><div id="40387320" class="c"><input type="checkbox" id="c-40387320" checked=""/><div class="controls bullet"><span class="by">fjfaase</span><span>|</span><a href="#40386936">prev</a><span>|</span><a href="#40386996">next</a><span>|</span><label class="collapse" for="c-40387320">[-]</label><label class="expand" for="c-40387320">[1 more]</label></div><br/><div class="children"><div class="content">I think it is important to realize that relational, object-oriented and structured data (such as XML and JSON) are all implementation of an often far more richer data model. Would it not be better to implement something for the richer data model, such that querying relational data models to produce JSON (for example) would become trivial?<p>A long time ago, I made some attempts about this: <a href="https:&#x2F;&#x2F;www.iwriteiam.nl&#x2F;AoP_spec_stat.html" rel="nofollow">https:&#x2F;&#x2F;www.iwriteiam.nl&#x2F;AoP_spec_stat.html</a> Not so long ago, I worked a bit on a data oriented language with cursors, compounds and components: <a href="https:&#x2F;&#x2F;github.com&#x2F;FransFaase&#x2F;DataLang">https:&#x2F;&#x2F;github.com&#x2F;FransFaase&#x2F;DataLang</a>.</div><br/></div></div><div id="40386996" class="c"><input type="checkbox" id="c-40386996" checked=""/><div class="controls bullet"><span class="by">maweki</span><span>|</span><a href="#40387320">prev</a><span>|</span><a href="#40367258">next</a><span>|</span><label class="collapse" for="c-40386996">[-]</label><label class="expand" for="c-40386996">[1 more]</label></div><br/><div class="children"><div class="content">This implicit JOIN feature is already present in HQL and also in Jooq. It&#x27;s very convenient, especially when you use a star-like table structure where the important data table is basically just IDs and references.<p><a href="https:&#x2F;&#x2F;www.jooq.org&#x2F;doc&#x2F;latest&#x2F;manual&#x2F;coming-from-jpa&#x2F;from-jpa-implicit-join&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.jooq.org&#x2F;doc&#x2F;latest&#x2F;manual&#x2F;coming-from-jpa&#x2F;from-...</a></div><br/></div></div><div id="40367258" class="c"><input type="checkbox" id="c-40367258" checked=""/><div class="controls bullet"><span class="by">bionhoward</span><span>|</span><a href="#40386996">prev</a><span>|</span><a href="#40387256">next</a><span>|</span><label class="collapse" for="c-40367258">[-]</label><label class="expand" for="c-40367258">[2 more]</label></div><br/><div class="children"><div class="content">Cool idea! I always thought this was the purpose of cypher match statements but your syntax is much shorter and more familiar dot-pathing<p>One idea would be for the x.y.z to use functions like<p>x.y(argument).z<p>This way you could parameterize the traversals and it’d wind up looking like gremlin in sql</div><br/><div id="40374609" class="c"><input type="checkbox" id="c-40374609" checked=""/><div class="controls bullet"><span class="by">Judyrabbit</span><span>|</span><a href="#40367258">parent</a><span>|</span><a href="#40387256">next</a><span>|</span><label class="collapse" for="c-40374609">[-]</label><label class="expand" for="c-40374609">[1 more]</label></div><br/><div class="children"><div class="content">x.y(argument).z should be OK in syntax, but it is hard to implement. we can not predict which data type y(argument) would return, and if it can perform dot operation further.
We have implemented DQL(The  syntax mentioned here) by translating to SQL. But we priovide only Chinese version now, we will release the English version serveral months later, please keep an eye out if you&#x27;re interested</div><br/></div></div></div></div><div id="40387256" class="c"><input type="checkbox" id="c-40387256" checked=""/><div class="controls bullet"><span class="by">pavi2410</span><span>|</span><a href="#40367258">prev</a><span>|</span><a href="#40386744">next</a><span>|</span><label class="collapse" for="c-40387256">[-]</label><label class="expand" for="c-40387256">[1 more]</label></div><br/><div class="children"><div class="content">SOQL in Salesforce supports &quot;relationship queries&quot; that works on both directions, viz, parent-to-child and child-to-parent.<p><a href="https:&#x2F;&#x2F;developer.salesforce.com&#x2F;docs&#x2F;atlas.en-us.soql_sosl.meta&#x2F;soql_sosl&#x2F;sforce_api_calls_soql_select_examples.htm" rel="nofollow">https:&#x2F;&#x2F;developer.salesforce.com&#x2F;docs&#x2F;atlas.en-us.soql_sosl....</a></div><br/></div></div><div id="40386744" class="c"><input type="checkbox" id="c-40386744" checked=""/><div class="controls bullet"><span class="by">beagle3</span><span>|</span><a href="#40387256">prev</a><span>|</span><a href="#40382219">next</a><span>|</span><label class="collapse" for="c-40386744">[-]</label><label class="expand" for="c-40386744">[1 more]</label></div><br/><div class="children"><div class="content">A 30 year old implementation of the same idea (even slightly better IMHO) can be found in kdb+&#x2F;ksql&#x2F;shakti, you can see examples and comparison in <a href="https:&#x2F;&#x2F;shakti.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;shakti.com&#x2F;</a> (press document, then sql.d - no idea how to link directly). And yes, it is by Arthur Whitney and related to the [in]famous K</div><br/></div></div><div id="40382219" class="c"><input type="checkbox" id="c-40382219" checked=""/><div class="controls bullet"><span class="by">PeterZaitsev</span><span>|</span><a href="#40386744">prev</a><span>|</span><a href="#40386896">next</a><span>|</span><label class="collapse" for="c-40382219">[-]</label><label class="expand" for="c-40382219">[1 more]</label></div><br/><div class="children"><div class="content">There are many good ideas to improve SQL,  though it is not easy to get traction as it is such an old standard with so many implementations</div><br/></div></div><div id="40386896" class="c"><input type="checkbox" id="c-40386896" checked=""/><div class="controls bullet"><span class="by">tucnak</span><span>|</span><a href="#40382219">prev</a><span>|</span><label class="collapse" for="c-40386896">[-]</label><label class="expand" for="c-40386896">[1 more]</label></div><br/><div class="children"><div class="content">More geniuses trying to &quot;improve&quot; SQL, and yet the only party to succeed in doing this is Postgres people, of actual relational SQL database—by means of dialect.</div><br/></div></div></div></div></div></div></div></body></html>