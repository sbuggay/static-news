<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700038872302" as="style"/><link rel="stylesheet" href="styles.css?v=1700038872302"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/eunomia-bpf/bpftime">Bpftime: Userspace eBPF runtime for fast Uprobe and Syscall hook and Plugins</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>dnsmichi</span> | <span>8 comments</span></div><br/><div><div id="38274156" class="c"><input type="checkbox" id="c-38274156" checked=""/><div class="controls bullet"><span class="by">yunwei37</span><span>|</span><a href="#38273824">next</a><span>|</span><label class="collapse" for="c-38274156">[-]</label><label class="expand" for="c-38274156">[1 more]</label></div><br/><div class="children"><div class="content">We talked about it in LPC 23 today, and the slides: <a href="https:&#x2F;&#x2F;lpc.events&#x2F;event&#x2F;17&#x2F;contributions&#x2F;1639" rel="nofollow noreferrer">https:&#x2F;&#x2F;lpc.events&#x2F;event&#x2F;17&#x2F;contributions&#x2F;1639</a><p>Stream: <a href="https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=zDNZY0HQOMw&amp;t=1765s">https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=zDNZY0HQOMw&amp;t=1765s</a><p>The draft paper: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2311.07923" rel="nofollow noreferrer">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2311.07923</a></div><br/></div></div><div id="38273824" class="c"><input type="checkbox" id="c-38273824" checked=""/><div class="controls bullet"><span class="by">rendaw</span><span>|</span><a href="#38274156">prev</a><span>|</span><a href="#38272755">next</a><span>|</span><label class="collapse" for="c-38273824">[-]</label><label class="expand" for="c-38273824">[3 more]</label></div><br/><div class="children"><div class="content">This looks really cool.  Like all eBPF though, what sort of eBPF verification is it doing and is it possible to do the verification in CI?<p>With eBPF the common gotcha is you can compile totally invalid eBPF code, with no compile errors, only to find out at go time (and only to be able to find out at go time).</div><br/><div id="38274252" class="c"><input type="checkbox" id="c-38274252" checked=""/><div class="controls bullet"><span class="by">brancz</span><span>|</span><a href="#38273824">parent</a><span>|</span><a href="#38274137">next</a><span>|</span><label class="collapse" for="c-38274252">[-]</label><label class="expand" for="c-38274252">[1 more]</label></div><br/><div class="children"><div class="content">I happen to work on a system-wide profiler[1] that is eBPF-based, and what we do is load our bpf programs on various kernels[2] using qemu. This is important as the jit and verifier change significantly across kernel versions and we want to make sure we maintain compatibility.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;parca-dev&#x2F;parca-agent">https:&#x2F;&#x2F;github.com&#x2F;parca-dev&#x2F;parca-agent</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;parca-dev&#x2F;parca-agent&#x2F;blob&#x2F;54434c02773a8a8463926f108f86ddff2ff78689&#x2F;kerneltest&#x2F;vmtest.sh#L87">https:&#x2F;&#x2F;github.com&#x2F;parca-dev&#x2F;parca-agent&#x2F;blob&#x2F;54434c02773a8a...</a></div><br/></div></div><div id="38274137" class="c"><input type="checkbox" id="c-38274137" checked=""/><div class="controls bullet"><span class="by">yunwei37</span><span>|</span><a href="#38273824">parent</a><span>|</span><a href="#38274252">prev</a><span>|</span><a href="#38272755">next</a><span>|</span><label class="collapse" for="c-38274137">[-]</label><label class="expand" for="c-38274137">[1 more]</label></div><br/><div class="children"><div class="content">Thanks!<p>This project can use a standalone eBPF verifier in this project: <a href="https:&#x2F;&#x2F;github.com&#x2F;vbpf&#x2F;ebpf-verifier">https:&#x2F;&#x2F;github.com&#x2F;vbpf&#x2F;ebpf-verifier</a><p>It can also use kernel verifier to verify the programs, then “offload”the BPF byte code from kernel, and runs it in userspace.</div><br/></div></div></div></div><div id="38272755" class="c"><input type="checkbox" id="c-38272755" checked=""/><div class="controls bullet"><span class="by">victoryang00</span><span>|</span><a href="#38273824">prev</a><span>|</span><a href="#38273754">next</a><span>|</span><label class="collapse" for="c-38272755">[-]</label><label class="expand" for="c-38272755">[1 more]</label></div><br/><div class="children"><div class="content">A full version of the preliminary descriptions and results can be found here <a href="http:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2311.07923" rel="nofollow noreferrer">http:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2311.07923</a>. Thanks for the advise for cross boundary communication brought on the LPC, we will integrate!</div><br/></div></div><div id="38273754" class="c"><input type="checkbox" id="c-38273754" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#38272755">prev</a><span>|</span><label class="collapse" for="c-38273754">[-]</label><label class="expand" for="c-38273754">[2 more]</label></div><br/><div class="children"><div class="content">Sounds a lot like DTrace user defined probe tracing.</div><br/><div id="38273903" class="c"><input type="checkbox" id="c-38273903" checked=""/><div class="controls bullet"><span class="by">ahl</span><span>|</span><a href="#38273754">parent</a><span>|</span><label class="collapse" for="c-38273903">[-]</label><label class="expand" for="c-38273903">[1 more]</label></div><br/><div class="children"><div class="content">Uprobes has—I believe—DTrace USDT-like functionality. This seems interesting and different: sending the tracing facility into the traced&#x2F;victim process. Whereas DTrace and ePBF typically trap into the kernel to execute and event, this approach allows for potentially much less overhead.<p>How important is enabled probe effect? Of that I’m less sure.</div><br/></div></div></div></div></div></div></div></div></div></body></html>