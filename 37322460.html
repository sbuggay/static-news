<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693472463117" as="style"/><link rel="stylesheet" href="styles.css?v=1693472463117"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://petereliaskraft.net/blog/epoxy">How to get transactions between almost any data stores</a> <span class="domain">(<a href="https://petereliaskraft.net">petereliaskraft.net</a>)</span></div><div class="subtext"><span>KraftyOne</span> | <span>75 comments</span></div><br/><div><div id="37326917" class="c"><input type="checkbox" id="c-37326917" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#37332262">next</a><span>|</span><label class="collapse" for="c-37326917">[-]</label><label class="expand" for="c-37326917">[1 more]</label></div><br/><div class="children"><div class="content">Paper: <a href="http:&#x2F;&#x2F;petereliaskraft.net&#x2F;res&#x2F;p2732-kraft.pdf" rel="nofollow noreferrer">http:&#x2F;&#x2F;petereliaskraft.net&#x2F;res&#x2F;p2732-kraft.pdf</a></div><br/></div></div><div id="37332262" class="c"><input type="checkbox" id="c-37332262" checked=""/><div class="controls bullet"><span class="by">hcarvalhoalves</span><span>|</span><a href="#37326917">prev</a><span>|</span><a href="#37334100">next</a><span>|</span><label class="collapse" for="c-37332262">[-]</label><label class="expand" for="c-37332262">[16 more]</label></div><br/><div class="children"><div class="content">&gt; The canonical example of a transaction is transferring money between bank accounts: to transfer $100 from me to you, the bank runs a transaction which withdraws $100 from my account and deposits $100 in your account. By running both operations in one transaction …<p>I know it’s canon at this point, but please stop using this example people. No bank ever worked this way, and often outsiders who hear about this example get the wrong idea.</div><br/><div id="37334045" class="c"><input type="checkbox" id="c-37334045" checked=""/><div class="controls bullet"><span class="by">rgoulter</span><span>|</span><a href="#37332262">parent</a><span>|</span><a href="#37332482">next</a><span>|</span><label class="collapse" for="c-37334045">[-]</label><label class="expand" for="c-37334045">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s an intuitive example which should be used instead?</div><br/></div></div><div id="37332482" class="c"><input type="checkbox" id="c-37332482" checked=""/><div class="controls bullet"><span class="by">maxfan8</span><span>|</span><a href="#37332262">parent</a><span>|</span><a href="#37334045">prev</a><span>|</span><a href="#37333516">next</a><span>|</span><label class="collapse" for="c-37332482">[-]</label><label class="expand" for="c-37332482">[12 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious -- how do banks actually do this, then?</div><br/><div id="37332529" class="c"><input type="checkbox" id="c-37332529" checked=""/><div class="controls bullet"><span class="by">eximius</span><span>|</span><a href="#37332262">root</a><span>|</span><a href="#37332482">parent</a><span>|</span><a href="#37333516">next</a><span>|</span><label class="collapse" for="c-37332529">[-]</label><label class="expand" for="c-37332529">[11 more]</label></div><br/><div class="children"><div class="content">Ledgers. They record a list of transactions, they don&#x27;t just plus or minus the balance.</div><br/><div id="37332546" class="c"><input type="checkbox" id="c-37332546" checked=""/><div class="controls bullet"><span class="by">yawaramin</span><span>|</span><a href="#37332262">root</a><span>|</span><a href="#37332529">parent</a><span>|</span><a href="#37332587">next</a><span>|</span><label class="collapse" for="c-37332546">[-]</label><label class="expand" for="c-37332546">[8 more]</label></div><br/><div class="children"><div class="content">But to record a transfer with a list of transactions, you need at least two transactions, and you need to write both transactions atomically in the ledger. Otherwise you end up with the same problem.</div><br/><div id="37332880" class="c"><input type="checkbox" id="c-37332880" checked=""/><div class="controls bullet"><span class="by">csomar</span><span>|</span><a href="#37332262">root</a><span>|</span><a href="#37332546">parent</a><span>|</span><a href="#37332635">next</a><span>|</span><label class="collapse" for="c-37332880">[-]</label><label class="expand" for="c-37332880">[1 more]</label></div><br/><div class="children"><div class="content">You only need one single transaction. The value of each account is deduced from the list of transactions that happened with checkpoints (fancy caching) once in a while.</div><br/></div></div><div id="37332635" class="c"><input type="checkbox" id="c-37332635" checked=""/><div class="controls bullet"><span class="by">tbrownaw</span><span>|</span><a href="#37332262">root</a><span>|</span><a href="#37332546">parent</a><span>|</span><a href="#37332880">prev</a><span>|</span><a href="#37332667">next</a><span>|</span><label class="collapse" for="c-37332635">[-]</label><label class="expand" for="c-37332635">[1 more]</label></div><br/><div class="children"><div class="content">Eventual consistency is a thing.<p>Or, are you old enough to have learned to reconcile a checkbook? Where you keep track of all the checks you write and what your balance should be, and then mark them as confirmed when they show up on your (monthly, because paper via usps) bank statements?</div><br/></div></div><div id="37332667" class="c"><input type="checkbox" id="c-37332667" checked=""/><div class="controls bullet"><span class="by">throwaway290</span><span>|</span><a href="#37332262">root</a><span>|</span><a href="#37332546">parent</a><span>|</span><a href="#37332635">prev</a><span>|</span><a href="#37332571">next</a><span>|</span><label class="collapse" for="c-37332667">[-]</label><label class="expand" for="c-37332667">[2 more]</label></div><br/><div class="children"><div class="content">Or you can throw both transactions into an event queue and let the worker process each whenever it gets to it. You get the point...</div><br/><div id="37333522" class="c"><input type="checkbox" id="c-37333522" checked=""/><div class="controls bullet"><span class="by">zaphirplane</span><span>|</span><a href="#37332262">root</a><span>|</span><a href="#37332667">parent</a><span>|</span><a href="#37332571">next</a><span>|</span><label class="collapse" for="c-37333522">[-]</label><label class="expand" for="c-37333522">[1 more]</label></div><br/><div class="children"><div class="content">Then the source account could not have the funds for the transaction at the time the operation is ... transacted</div><br/></div></div></div></div><div id="37332571" class="c"><input type="checkbox" id="c-37332571" checked=""/><div class="controls bullet"><span class="by">pstuart</span><span>|</span><a href="#37332262">root</a><span>|</span><a href="#37332546">parent</a><span>|</span><a href="#37332667">prev</a><span>|</span><a href="#37332587">next</a><span>|</span><label class="collapse" for="c-37332571">[-]</label><label class="expand" for="c-37332571">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Double-entry_bookkeeping" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Double-entry_bookkeeping</a></div><br/><div id="37332664" class="c"><input type="checkbox" id="c-37332664" checked=""/><div class="controls bullet"><span class="by">hakunin</span><span>|</span><a href="#37332262">root</a><span>|</span><a href="#37332571">parent</a><span>|</span><a href="#37332587">next</a><span>|</span><label class="collapse" for="c-37332664">[-]</label><label class="expand" for="c-37332664">[2 more]</label></div><br/><div class="children"><div class="content">This is a checksum-like trick for manual record keeping, and isn&#x27;t specifically relevant to the grandparent. It isn&#x27;t required in digital world. The grandparent talks about having to write 2 separate transactions in 2 accounts in such a way that either both are successfully written, or none are written. This means that there must be transactionality between 2 services, regardless of balance being cached or not.</div><br/><div id="37333541" class="c"><input type="checkbox" id="c-37333541" checked=""/><div class="controls bullet"><span class="by">indigo945</span><span>|</span><a href="#37332262">root</a><span>|</span><a href="#37332664">parent</a><span>|</span><a href="#37332587">next</a><span>|</span><label class="collapse" for="c-37333541">[-]</label><label class="expand" for="c-37333541">[1 more]</label></div><br/><div class="children"><div class="content">The point is that there is no such thing as &quot;2 separate transactions in 2 accounts&quot; in banking. There is one global ledger that contains transaction between <i>all</i> accounts - if you move money from account A to account B, you append one entry to the ledger that says that some sum of money moved from A to B. Then if you need to calculate an account balance, you look at all transactions in the ledger, filter by the account ID, and calculate the total. (You can then cache this result, for performance benefits, but this changes nothing about the way it works.)<p>This is really more like a CRDT than like transaction control.<p>It&#x27;s also where Bitcoin took its inspiration from, the blockchain is just one big ledger with some hashing on top.</div><br/></div></div></div></div></div></div></div></div><div id="37332587" class="c"><input type="checkbox" id="c-37332587" checked=""/><div class="controls bullet"><span class="by">ComodoHacker</span><span>|</span><a href="#37332262">root</a><span>|</span><a href="#37332529">parent</a><span>|</span><a href="#37332546">prev</a><span>|</span><a href="#37332585">next</a><span>|</span><label class="collapse" for="c-37332587">[-]</label><label class="expand" for="c-37332587">[1 more]</label></div><br/><div class="children"><div class="content">But usually they also store current balances in a separate table, and updating them is also part of the transaction.</div><br/></div></div><div id="37332585" class="c"><input type="checkbox" id="c-37332585" checked=""/><div class="controls bullet"><span class="by">tbrownaw</span><span>|</span><a href="#37332262">root</a><span>|</span><a href="#37332529">parent</a><span>|</span><a href="#37332587">prev</a><span>|</span><a href="#37333516">next</a><span>|</span><label class="collapse" for="c-37332585">[-]</label><label class="expand" for="c-37332585">[1 more]</label></div><br/><div class="children"><div class="content">I believe the modern term is &quot;event sourcing&quot;.</div><br/></div></div></div></div></div></div><div id="37333516" class="c"><input type="checkbox" id="c-37333516" checked=""/><div class="controls bullet"><span class="by">runeks</span><span>|</span><a href="#37332262">parent</a><span>|</span><a href="#37332482">prev</a><span>|</span><a href="#37334100">next</a><span>|</span><label class="collapse" for="c-37333516">[-]</label><label class="expand" for="c-37333516">[2 more]</label></div><br/><div class="children"><div class="content">I will keep using this example. It&#x27;s a good example for illustrating why transactions are necessary and what they are. And it&#x27;s not relevant whether or not banks actually work this way.</div><br/><div id="37333589" class="c"><input type="checkbox" id="c-37333589" checked=""/><div class="controls bullet"><span class="by">solidsnack9000</span><span>|</span><a href="#37332262">root</a><span>|</span><a href="#37333516">parent</a><span>|</span><a href="#37334100">next</a><span>|</span><label class="collapse" for="c-37333589">[-]</label><label class="expand" for="c-37333589">[1 more]</label></div><br/><div class="children"><div class="content">The counterargument is that it&#x27;s not a situation where transactions are actually used so it&#x27;s not a good example for why transactions are necessary.</div><br/></div></div></div></div></div></div><div id="37334100" class="c"><input type="checkbox" id="c-37334100" checked=""/><div class="controls bullet"><span class="by">robertkoss</span><span>|</span><a href="#37332262">prev</a><span>|</span><a href="#37330927">next</a><span>|</span><label class="collapse" for="c-37334100">[-]</label><label class="expand" for="c-37334100">[1 more]</label></div><br/><div class="children"><div class="content">Interesting to see Matei&#x27;s name on the paper. Maybe Epoxy ends up at Databricks to enable updates across, e.g., Delta Lake &amp; a traditional DWH simultaneously, for, let&#x27;s say, migrations. Who knows :)</div><br/></div></div><div id="37330927" class="c"><input type="checkbox" id="c-37330927" checked=""/><div class="controls bullet"><span class="by">jongjong</span><span>|</span><a href="#37334100">prev</a><span>|</span><a href="#37327683">next</a><span>|</span><label class="collapse" for="c-37330927">[-]</label><label class="expand" for="c-37330927">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a bit confused why OP says that because two-phase commits are not natively supported by various databases, that it&#x27;s not a viable strategy. It&#x27;s possible to implement &#x27;two-phase commits&#x27; manually through a simple algorithm. You just need an extra field to keep track of whether or note the record is &#x27;pending&#x27; or &#x27;settled&#x27; and also some additional fields for creation date and settlement date. The main process just copies over all the records as &#x27;pending&#x27; state then you have another parallel process&#x2F;task which goes over all the pending records in order and changes them to &#x27;settled&#x27; if some condition (e.g. some related records in different tables&#x2F;collections also exist) is met. Records need to be settled in a particular order to protect from failure of the settlement process itself but it&#x27;s not particularly difficult to implement. Also, you need good indexing for fast&#x2F;efficient cross-table&#x2F;collection lookups (you especially need indexing on date fields in order to quickly look up and settle records in the same order as they were inserted starting from the last settled record).<p>I did something like this a while ago; some operations in my system inserted multiple records into different collections (into a database which did not support atomic transactions) and I needed to guarantee that when a record existed in a particular collection in the &#x27;settled&#x27; state that it would guarantee the existence of a matching record in a different collection. It was very reliable. I believe I didn&#x27;t even end up needing to launch a separate process for the settlement logic since I was using Node.js, I just used an async task scheduled to run on an interval. The front end would just ignore records until they were in the settled state (but you could also show them as pending).<p>Another thing which really helps is using UUIDs are IDs as it guarantees idempotence so you don&#x27;t have to worry about double-insertion in case of process failure&#x2F;restart. You can just re-process some records that you may have already processed with no side effects; you just need to check that the error is an insertion conflict and continue.</div><br/><div id="37333573" class="c"><input type="checkbox" id="c-37333573" checked=""/><div class="controls bullet"><span class="by">indigo945</span><span>|</span><a href="#37330927">parent</a><span>|</span><a href="#37331105">next</a><span>|</span><label class="collapse" for="c-37333573">[-]</label><label class="expand" for="c-37333573">[1 more]</label></div><br/><div class="children"><div class="content">If a transaction A adds 10 records, and they&#x27;re currently being settled, with 5 of them being pending and 5 of them being settled, how do you ensure that a concurrent transaction B either sees all of them as settled, or none of them?</div><br/></div></div><div id="37331105" class="c"><input type="checkbox" id="c-37331105" checked=""/><div class="controls bullet"><span class="by">marklar423</span><span>|</span><a href="#37330927">parent</a><span>|</span><a href="#37333573">prev</a><span>|</span><a href="#37327683">next</a><span>|</span><label class="collapse" for="c-37331105">[-]</label><label class="expand" for="c-37331105">[2 more]</label></div><br/><div class="children"><div class="content">How did you handle cleaning up aborted &#x2F; rolled back transactions after binaries restarted? Or did you just let the pending records hang around forever.</div><br/><div id="37331344" class="c"><input type="checkbox" id="c-37331344" checked=""/><div class="controls bullet"><span class="by">unmole</span><span>|</span><a href="#37330927">root</a><span>|</span><a href="#37331105">parent</a><span>|</span><a href="#37327683">next</a><span>|</span><label class="collapse" for="c-37331344">[-]</label><label class="expand" for="c-37331344">[1 more]</label></div><br/><div class="children"><div class="content">When a node rejoins after a restart, have all other nodes drop any pending transactions initiated by the node in question. I implemented something similar for a distributed filesystem and it worked pretty well.</div><br/></div></div></div></div></div></div><div id="37327683" class="c"><input type="checkbox" id="c-37327683" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#37330927">prev</a><span>|</span><a href="#37333464">next</a><span>|</span><label class="collapse" for="c-37327683">[-]</label><label class="expand" for="c-37327683">[3 more]</label></div><br/><div class="children"><div class="content">Thank you for submitting this and thank you to the authors.<p>I am curious how this kind of thing can scale. What I&#x27;m inspired by this article is the idea of applying multiversion semantics to datastores that aren&#x27;t multiversioned.<p>Sounds like if you have a transactionally sound store of &quot;versions&quot; and a way to query every datastore with a version field, you could implement point in time consistency, because the current version would only change when all datastores are updated. You still have to wait for all datastores to be updated, so that part is similar to 2 phase commit.<p>My understanding is that two phase commit does not scale and is slow because of all the round trips, but we still want linearizability and strong consistency in systems.<p>I tried to implement an asynchronously replicating data protocol but it is eventually consistent, not linearizable (it fails the Jepsen linearizability test)<p><a href="https:&#x2F;&#x2F;github.com&#x2F;samsquire&#x2F;eventually-consistent-mesh">https:&#x2F;&#x2F;github.com&#x2F;samsquire&#x2F;eventually-consistent-mesh</a><p>I&#x27;m a beginner in this area but I have a toy multiversion concurrency control implementation that uses Java threads. (See MVCC.java and TransactionC.java) the key statements of code is in commit() and shouldRestart().<p><a href="https:&#x2F;&#x2F;github.com&#x2F;samsquire&#x2F;multiversion-concurrency-control">https:&#x2F;&#x2F;github.com&#x2F;samsquire&#x2F;multiversion-concurrency-contro...</a><p>Dropbox does something 2 phase commit with their cross shard replication which is interesting
<a href="https:&#x2F;&#x2F;dropbox.tech&#x2F;infrastructure&#x2F;cross-shard-transactions-at-10-million-requests-per-second" rel="nofollow noreferrer">https:&#x2F;&#x2F;dropbox.tech&#x2F;infrastructure&#x2F;cross-shard-transactions...</a></div><br/><div id="37328598" class="c"><input type="checkbox" id="c-37328598" checked=""/><div class="controls bullet"><span class="by">KraftyOne</span><span>|</span><a href="#37327683">parent</a><span>|</span><a href="#37333464">next</a><span>|</span><label class="collapse" for="c-37328598">[-]</label><label class="expand" for="c-37328598">[2 more]</label></div><br/><div class="children"><div class="content">While we haven&#x27;t tested this, I suspect the main scaling bottleneck in practice is the primary database, as every Epoxy transaction goes through it.  If you wanted to run Epoxy at large scale, you&#x27;d need a primary that supports very high transaction throughput.</div><br/><div id="37332576" class="c"><input type="checkbox" id="c-37332576" checked=""/><div class="controls bullet"><span class="by">yawaramin</span><span>|</span><a href="#37327683">root</a><span>|</span><a href="#37328598">parent</a><span>|</span><a href="#37333464">next</a><span>|</span><label class="collapse" for="c-37332576">[-]</label><label class="expand" for="c-37332576">[1 more]</label></div><br/><div class="children"><div class="content">Would 4M qps be enough? :-)<p>SQLite can achieve this with some help: <a href="https:&#x2F;&#x2F;blog.expensify.com&#x2F;2018&#x2F;01&#x2F;08&#x2F;scaling-sqlite-to-4m-qps-on-a-single-server&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.expensify.com&#x2F;2018&#x2F;01&#x2F;08&#x2F;scaling-sqlite-to-4m-q...</a><p>More seriously, I suspect that plain SQLite by itself, running in process in the main service, writing to a &#x27;:memory:&#x27; database for ultimate speed or perhaps to a local file with WAL mode for slightly more durability, could achieve pretty nice efficiency and work as the main transaction manager database.</div><br/></div></div></div></div></div></div><div id="37333464" class="c"><input type="checkbox" id="c-37333464" checked=""/><div class="controls bullet"><span class="by">mh-cx</span><span>|</span><a href="#37327683">prev</a><span>|</span><a href="#37329681">next</a><span>|</span><label class="collapse" for="c-37333464">[-]</label><label class="expand" for="c-37333464">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We then ask the primary database for a snapshot, a list of all past primary database transactions whose effects are visible to our new transaction.<p>I wonder what happens for records with many changes during their lifetime. Wouldn&#x27;t the size of such a snapshot grow infinetely for them?</div><br/></div></div><div id="37329681" class="c"><input type="checkbox" id="c-37329681" checked=""/><div class="controls bullet"><span class="by">tabeth</span><span>|</span><a href="#37333464">prev</a><span>|</span><a href="#37327473">next</a><span>|</span><label class="collapse" for="c-37329681">[-]</label><label class="expand" for="c-37329681">[7 more]</label></div><br/><div class="children"><div class="content">An interesting idea, but if I’m understanding the problem trying to be solved - might be better suited by durable execution (two examples being Azure’s durable functions, and Temporal.io).<p>In practice transactions between arbitrary data stores would result in potentially boundless and unpredictable latency, no?<p>Also, is Postgres strongly consistent and linearizable)? One alternative would be using a database with stronger consistency guarantees (Spanner is but not open source, FoundationDB is but has limitations on transactions unless you implement mvcc yourself, which to be fair you are).</div><br/><div id="37330442" class="c"><input type="checkbox" id="c-37330442" checked=""/><div class="controls bullet"><span class="by">KraftyOne</span><span>|</span><a href="#37329681">parent</a><span>|</span><a href="#37330174">next</a><span>|</span><label class="collapse" for="c-37330442">[-]</label><label class="expand" for="c-37330442">[1 more]</label></div><br/><div class="children"><div class="content">Durable execution is good for atomicity, but this approach also gives you isolation.  If you&#x27;re doing updates on both Postgres and Mongo and you want to guarantee both updates happen, Temporal can do that.  But if you want isolation, for example the guarantee that any operation that can see the Postgres update can also see the MongoDB update, then you need distributed transactions like in Epoxy.</div><br/></div></div><div id="37330174" class="c"><input type="checkbox" id="c-37330174" checked=""/><div class="controls bullet"><span class="by">jeremyjh</span><span>|</span><a href="#37329681">parent</a><span>|</span><a href="#37330442">prev</a><span>|</span><a href="#37330291">next</a><span>|</span><label class="collapse" for="c-37330174">[-]</label><label class="expand" for="c-37330174">[3 more]</label></div><br/><div class="children"><div class="content">Consistency is a property of distributed databases. Stock Postgres is not distributed, and thus gets strong consistency for free.<p>There is still a concept of (transaction) isolation levels, and the ANSI SQL standard defines a transaction mode READ UNCOMMITTED that could give you inconsistent results, but Postgres ignores that and treats it as READ COMMITTED.</div><br/><div id="37333143" class="c"><input type="checkbox" id="c-37333143" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#37329681">root</a><span>|</span><a href="#37330174">parent</a><span>|</span><a href="#37330196">next</a><span>|</span><label class="collapse" for="c-37333143">[-]</label><label class="expand" for="c-37333143">[1 more]</label></div><br/><div class="children"><div class="content">in terms of ACID
&quot;Consistency ensures that a transaction can only bring the database from one consistent state to another, preserving database invariants: any data written to the database must be valid according to all defined rules, including constraints, cascades, triggers, and any combination thereof. This prevents database corruption by an illegal transaction. Referential integrity guarantees the primary key–foreign key relationship.&quot;
So no it&#x27;s not free</div><br/></div></div><div id="37330196" class="c"><input type="checkbox" id="c-37330196" checked=""/><div class="controls bullet"><span class="by">tabeth</span><span>|</span><a href="#37329681">root</a><span>|</span><a href="#37330174">parent</a><span>|</span><a href="#37333143">prev</a><span>|</span><a href="#37330291">next</a><span>|</span><label class="collapse" for="c-37330196">[-]</label><label class="expand" for="c-37330196">[1 more]</label></div><br/><div class="children"><div class="content">Yeah you are right - I thought the primary in this case was distributed since most of the shims were (CouchDB, Mongo, etc).</div><br/></div></div></div></div><div id="37330291" class="c"><input type="checkbox" id="c-37330291" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37329681">parent</a><span>|</span><a href="#37330174">prev</a><span>|</span><a href="#37331152">next</a><span>|</span><label class="collapse" for="c-37330291">[-]</label><label class="expand" for="c-37330291">[1 more]</label></div><br/><div class="children"><div class="content">Durable execution is an equivalent alternative.<p>Replication speed could be bad, I don&#x27;t see a reason to expect that.<p>PostgreSQL can have serializable transactions though that is not the default isolation level.</div><br/></div></div><div id="37331152" class="c"><input type="checkbox" id="c-37331152" checked=""/><div class="controls bullet"><span class="by">victor106</span><span>|</span><a href="#37329681">parent</a><span>|</span><a href="#37330291">prev</a><span>|</span><a href="#37327473">next</a><span>|</span><label class="collapse" for="c-37331152">[-]</label><label class="expand" for="c-37331152">[1 more]</label></div><br/><div class="children"><div class="content">What about Mongodb?</div><br/></div></div></div></div><div id="37327473" class="c"><input type="checkbox" id="c-37327473" checked=""/><div class="controls bullet"><span class="by">jiaaro</span><span>|</span><a href="#37329681">prev</a><span>|</span><a href="#37332777">next</a><span>|</span><label class="collapse" for="c-37327473">[-]</label><label class="expand" for="c-37327473">[2 more]</label></div><br/><div class="children"><div class="content">Does Epoxy use postgres&#x27; own transaction ids across datastores? If not, does it implement its own &quot;transaction id horizon&quot; like postgres has so that you can assume all transactions before a certain counter are committed?</div><br/><div id="37327525" class="c"><input type="checkbox" id="c-37327525" checked=""/><div class="controls bullet"><span class="by">KraftyOne</span><span>|</span><a href="#37327473">parent</a><span>|</span><a href="#37332777">next</a><span>|</span><label class="collapse" for="c-37327525">[-]</label><label class="expand" for="c-37327525">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, our implementation uses Postgres transaction IDs across data stores.</div><br/></div></div></div></div><div id="37332777" class="c"><input type="checkbox" id="c-37332777" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#37327473">prev</a><span>|</span><a href="#37327237">next</a><span>|</span><label class="collapse" for="c-37332777">[-]</label><label class="expand" for="c-37332777">[1 more]</label></div><br/><div class="children"><div class="content">So what you essentially did is to add a virtual arbiter...</div><br/></div></div><div id="37327237" class="c"><input type="checkbox" id="c-37327237" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#37332777">prev</a><span>|</span><a href="#37329260">next</a><span>|</span><label class="collapse" for="c-37327237">[-]</label><label class="expand" for="c-37327237">[3 more]</label></div><br/><div class="children"><div class="content">Does this mean Epoxy must execute all the calls to the underlying services?  If so, how is the data to be stored in each db communicated to Epoxy?</div><br/><div id="37328193" class="c"><input type="checkbox" id="c-37328193" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#37327237">parent</a><span>|</span><a href="#37327495">next</a><span>|</span><label class="collapse" for="c-37328193">[-]</label><label class="expand" for="c-37328193">[1 more]</label></div><br/><div class="children"><div class="content">The way it should probably work is through hooks that you can implement yourself.</div><br/></div></div><div id="37327495" class="c"><input type="checkbox" id="c-37327495" checked=""/><div class="controls bullet"><span class="by">jiaaro</span><span>|</span><a href="#37327237">parent</a><span>|</span><a href="#37328193">prev</a><span>|</span><a href="#37329260">next</a><span>|</span><label class="collapse" for="c-37327495">[-]</label><label class="expand" for="c-37327495">[1 more]</label></div><br/><div class="children"><div class="content">Based on the paper Dang linked, it appears that epoxy is involved in all queries to all data stores it coordinates</div><br/></div></div></div></div><div id="37329260" class="c"><input type="checkbox" id="c-37329260" checked=""/><div class="controls bullet"><span class="by">FrameworkFred</span><span>|</span><a href="#37327237">prev</a><span>|</span><a href="#37328793">next</a><span>|</span><label class="collapse" for="c-37329260">[-]</label><label class="expand" for="c-37329260">[1 more]</label></div><br/><div class="children"><div class="content">I think I followed that pretty well (I&#x27;ll maybe need to read it again to be sure)...very nice, well done!</div><br/></div></div><div id="37328793" class="c"><input type="checkbox" id="c-37328793" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#37329260">prev</a><span>|</span><a href="#37329981">next</a><span>|</span><label class="collapse" for="c-37328793">[-]</label><label class="expand" for="c-37328793">[2 more]</label></div><br/><div class="children"><div class="content">use a tp monitor? such things have been around for a very long time. i  remember writing code to interface with one in the 90s, and a bit later. but things like cics and tuxedo were there long before that.</div><br/></div></div><div id="37329981" class="c"><input type="checkbox" id="c-37329981" checked=""/><div class="controls bullet"><span class="by">banq</span><span>|</span><a href="#37328793">prev</a><span>|</span><a href="#37327729">next</a><span>|</span><label class="collapse" for="c-37329981">[-]</label><label class="expand" for="c-37329981">[10 more]</label></div><br/><div class="children"><div class="content">The Saga is Antipattern
<a href="https:&#x2F;&#x2F;sergiy-yevtushenko.medium.com&#x2F;the-saga-is-antipattern-a4bb677d8e0f" rel="nofollow noreferrer">https:&#x2F;&#x2F;sergiy-yevtushenko.medium.com&#x2F;the-saga-is-antipatter...</a><p>Microservices distributed transactions are an anti pattern</div><br/><div id="37333018" class="c"><input type="checkbox" id="c-37333018" checked=""/><div class="controls bullet"><span class="by">ryanjshaw</span><span>|</span><a href="#37329981">parent</a><span>|</span><a href="#37330084">next</a><span>|</span><label class="collapse" for="c-37333018">[-]</label><label class="expand" for="c-37333018">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t understand anything written in that post. Saga was mentioned 5 times: once in the title, once in a tag, and 3 times in the 1st paragraph. I would have benefited from an example, as everything was too abstract for me to follow.</div><br/></div></div><div id="37330084" class="c"><input type="checkbox" id="c-37330084" checked=""/><div class="controls bullet"><span class="by">hakunin</span><span>|</span><a href="#37329981">parent</a><span>|</span><a href="#37333018">prev</a><span>|</span><a href="#37330316">next</a><span>|</span><label class="collapse" for="c-37330084">[-]</label><label class="expand" for="c-37330084">[2 more]</label></div><br/><div class="children"><div class="content">In most cases microservices are an anti-pattern, because they are trying to solve problems that can be solved without incurring their complexity and sacrifices.<p>However, I remember that Sagas originally were proposed to deal with multiple 3rd party APIs. The example was &quot;book flight, hotel, rental car&quot;. If you&#x27;re dealing with necessarily separate systems, then there&#x27;s probably a place for sagas.</div><br/><div id="37330566" class="c"><input type="checkbox" id="c-37330566" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#37329981">root</a><span>|</span><a href="#37330084">parent</a><span>|</span><a href="#37330316">next</a><span>|</span><label class="collapse" for="c-37330566">[-]</label><label class="expand" for="c-37330566">[1 more]</label></div><br/><div class="children"><div class="content">The author talks about this too<p>&gt; As soon as we start doing separation of domains according to data governance, we may quickly realize that in the vast majority of cases, microservices look a lot like traditional monoliths and the domain they should handle is big. Or realize that traditional monoliths are, in fact, microservices. This happens because most organizations have only a very limited number of truly independent domains. Most often — one.</div><br/></div></div></div></div><div id="37330316" class="c"><input type="checkbox" id="c-37330316" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37329981">parent</a><span>|</span><a href="#37330084">prev</a><span>|</span><a href="#37330041">next</a><span>|</span><label class="collapse" for="c-37330316">[-]</label><label class="expand" for="c-37330316">[5 more]</label></div><br/><div class="children"><div class="content">How so?<p>If I want to pay for and book a flight and hotel.....<p>You have to implement distributed transactions. (Either that or YOLO.)</div><br/><div id="37332164" class="c"><input type="checkbox" id="c-37332164" checked=""/><div class="controls bullet"><span class="by">numbsafari</span><span>|</span><a href="#37329981">root</a><span>|</span><a href="#37330316">parent</a><span>|</span><a href="#37330041">next</a><span>|</span><label class="collapse" for="c-37332164">[-]</label><label class="expand" for="c-37332164">[4 more]</label></div><br/><div class="children"><div class="content">This is not true, and not YOLO, either.<p>You have four separate businesses (at least): a bank, an airline, a hotel, and booking agency.<p>There&#x27;s no way that some random booking agency is getting an XA transaction (or other distributed transaction protocol) implemented between the disparate systems it is orchestrating.<p>It has to maintain conversational state with each of those systems in the domain&#x2F;model of the exposed APIs of each in order to coordinate a resolution. Even if you could do that with an distributed transaction coordinated between those disparate entities, the possible failure states of each are such that you likely wouldn&#x27;t want to. For example: go ahead and book the flight and pay for it if you can, but don&#x27;t rollback the whole thing if the hotel ends up needing to decline for some reason.<p>These business models exist today as real world systems, and they aren&#x27;t implemented using distributed transactions.</div><br/><div id="37333327" class="c"><input type="checkbox" id="c-37333327" checked=""/><div class="controls bullet"><span class="by">silon42</span><span>|</span><a href="#37329981">root</a><span>|</span><a href="#37332164">parent</a><span>|</span><a href="#37333108">next</a><span>|</span><label class="collapse" for="c-37333327">[-]</label><label class="expand" for="c-37333327">[1 more]</label></div><br/><div class="children"><div class="content">This what basically what a Saga is... a process that uses custom protocols to resolve the state of multiple entities to a consistent valid state.<p>Sure, avoid Sagas when possible (use a DB transaction if you can merge microservices), but when you aren&#x27;t setting system boundaries (aka your world isn&#x27;t a single system supporting XA everwhere), the Saga is a completely valid and necessary mechanism.</div><br/></div></div><div id="37333108" class="c"><input type="checkbox" id="c-37333108" checked=""/><div class="controls bullet"><span class="by">yathaid</span><span>|</span><a href="#37329981">root</a><span>|</span><a href="#37332164">parent</a><span>|</span><a href="#37333327">prev</a><span>|</span><a href="#37332183">next</a><span>|</span><label class="collapse" for="c-37333108">[-]</label><label class="expand" for="c-37333108">[1 more]</label></div><br/><div class="children"><div class="content">Tell me you are implementing distributed transactions without telling me you are using distributed transactions! :)</div><br/></div></div><div id="37332183" class="c"><input type="checkbox" id="c-37332183" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37329981">root</a><span>|</span><a href="#37332164">parent</a><span>|</span><a href="#37333108">prev</a><span>|</span><a href="#37330041">next</a><span>|</span><label class="collapse" for="c-37332183">[-]</label><label class="expand" for="c-37332183">[1 more]</label></div><br/><div class="children"><div class="content">Those are in the abstract and literal sense, distributed transactions.</div><br/></div></div></div></div></div></div></div></div><div id="37327729" class="c"><input type="checkbox" id="c-37327729" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#37329981">prev</a><span>|</span><a href="#37328592">next</a><span>|</span><label class="collapse" for="c-37327729">[-]</label><label class="expand" for="c-37327729">[10 more]</label></div><br/><div class="children"><div class="content">Distributed transactions have been around for a while.</div><br/><div id="37328695" class="c"><input type="checkbox" id="c-37328695" checked=""/><div class="controls bullet"><span class="by">kerblang</span><span>|</span><a href="#37327729">parent</a><span>|</span><a href="#37328305">next</a><span>|</span><label class="collapse" for="c-37328695">[-]</label><label class="expand" for="c-37328695">[3 more]</label></div><br/><div class="children"><div class="content">The author already acknowledged that there are other ways to do distributed transactions<p>&gt; The traditional solution is to use two-phase commit through a protocol like X&#x2F;Open XA. However, while XA is supported by most big relational databases like Postgres and MySQL, it&#x27;s not supported by popular newer data stores like MongoDB, Cassandra, or Elasticsearch</div><br/><div id="37329201" class="c"><input type="checkbox" id="c-37329201" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#37327729">root</a><span>|</span><a href="#37328695">parent</a><span>|</span><a href="#37328305">next</a><span>|</span><label class="collapse" for="c-37329201">[-]</label><label class="expand" for="c-37329201">[2 more]</label></div><br/><div class="children"><div class="content">Inaccurate:<p>Cassandra has a distributed transaction based on paxos, and I think a raft version is in the works.<p>I admittedly skimmed the article, but the notion of a central coordinator for the transaction isn&#x27;t really a scalable solution. In the stated use case, heterogeneous stores, it&#x27;s kind of what you&#x27;re stuck with to some degree.<p>But... why not use a purely distributed central store like Cassandra or Zookeeper (I think zoo is masterless?) rather than Postgres?<p>IMO this doesn&#x27;t have a chance of standing up to a network partition like Aphyr would throw at it, but then again I didn&#x27;t graduate from Stanford.</div><br/><div id="37329265" class="c"><input type="checkbox" id="c-37329265" checked=""/><div class="controls bullet"><span class="by">rubiquity</span><span>|</span><a href="#37327729">root</a><span>|</span><a href="#37329201">parent</a><span>|</span><a href="#37328305">next</a><span>|</span><label class="collapse" for="c-37329265">[-]</label><label class="expand" for="c-37329265">[1 more]</label></div><br/><div class="children"><div class="content">The author is specifically talking about XA.</div><br/></div></div></div></div></div></div><div id="37328305" class="c"><input type="checkbox" id="c-37328305" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#37327729">parent</a><span>|</span><a href="#37328695">prev</a><span>|</span><a href="#37328592">next</a><span>|</span><label class="collapse" for="c-37328305">[-]</label><label class="expand" for="c-37328305">[6 more]</label></div><br/><div class="children"><div class="content">across heterogeneous data stores?</div><br/><div id="37328603" class="c"><input type="checkbox" id="c-37328603" checked=""/><div class="controls bullet"><span class="by">gregw2</span><span>|</span><a href="#37327729">root</a><span>|</span><a href="#37328305">parent</a><span>|</span><a href="#37328668">next</a><span>|</span><label class="collapse" for="c-37328603">[-]</label><label class="expand" for="c-37328603">[2 more]</label></div><br/><div class="children"><div class="content">How heterogeneous do you mean? But basically, &quot;yes&quot;.<p>IBM had CICS transactions back in the day for some definition of heterogeneity.  Tuxedo did this in the 80s across broader platforms. In the 90s (when I heard of it) there was an open standard created for it: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;X&#x2F;Open_XA" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;X&#x2F;Open_XA</a> so that Unix-y type systems had some agreement on how to do it without buying mainframe&#x2F;tuxedo-y type components. And around or a bit after then, Microsoft created its own &quot;Distributed Transaction Coordinator&quot;.  This is not my area of expertise but I&#x27;ve heard about it throughout the last 30 years.<p>The NoSQL side of heterogeneous is newer than the 90s but even there, I found in 2 minutes a paper from 2006, 17 years ago, on the topic: <a href="https:&#x2F;&#x2F;www.researchgate.net&#x2F;profile&#x2F;Akon-Dey&#x2F;publication&#x2F;282156834_Scalable_Distributed_Transactions_across_Heterogeneous_Stores&#x2F;links&#x2F;56058b9608ae5e8e3f32b98d&#x2F;Scalable-Distributed-Transactions-across-Heterogeneous-Stores.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.researchgate.net&#x2F;profile&#x2F;Akon-Dey&#x2F;publication&#x2F;28...</a><p>This is definitely a wheel that gets reinvented.</div><br/><div id="37330933" class="c"><input type="checkbox" id="c-37330933" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#37327729">root</a><span>|</span><a href="#37328603">parent</a><span>|</span><a href="#37328668">next</a><span>|</span><label class="collapse" for="c-37330933">[-]</label><label class="expand" for="c-37330933">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d understood distributed transactions to be a vendor-specific thing. I&#x27;d never have realized I could have IMS&#x2F;DB,  DB2, and MSSQL all in the same txn.</div><br/></div></div></div></div><div id="37328389" class="c"><input type="checkbox" id="c-37328389" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#37327729">root</a><span>|</span><a href="#37328305">parent</a><span>|</span><a href="#37328668">prev</a><span>|</span><a href="#37328592">next</a><span>|</span><label class="collapse" for="c-37328389">[-]</label><label class="expand" for="c-37328389">[2 more]</label></div><br/><div class="children"><div class="content">Yep.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Distributed_transaction" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Distributed_transaction</a></div><br/><div id="37330906" class="c"><input type="checkbox" id="c-37330906" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#37327729">root</a><span>|</span><a href="#37328389">parent</a><span>|</span><a href="#37328592">next</a><span>|</span><label class="collapse" for="c-37330906">[-]</label><label class="expand" for="c-37330906">[1 more]</label></div><br/><div class="children"><div class="content">TIL</div><br/></div></div></div></div></div></div></div></div><div id="37328592" class="c"><input type="checkbox" id="c-37328592" checked=""/><div class="controls bullet"><span class="by">numbsafari</span><span>|</span><a href="#37327729">prev</a><span>|</span><label class="collapse" for="c-37328592">[-]</label><label class="expand" for="c-37328592">[12 more]</label></div><br/><div class="children"><div class="content">Again with the straw man example of a bank transfer.<p>Another article you didn’t need to read because it talks about a problem you likely don’t have because the author can’t be bothered to come up with actual, real world examples.</div><br/><div id="37330236" class="c"><input type="checkbox" id="c-37330236" checked=""/><div class="controls bullet"><span class="by">jeremyjh</span><span>|</span><a href="#37328592">parent</a><span>|</span><a href="#37328899">next</a><span>|</span><label class="collapse" for="c-37330236">[-]</label><label class="expand" for="c-37330236">[1 more]</label></div><br/><div class="children"><div class="content">People who have a use for this technology don&#x27;t need a real world example, they already know where they would apply it.<p>Its true that most people don&#x27;t need it at all, and I cringe at the thought of a second wave of micro-service muppets stitching it all together with something like this, but there are actually real-world examples. I&#x27;m not going to offer you any though, due to your belligerence in the other comments.<p>A bank transfer is a good example because it is easy to understand, regardless of your background.</div><br/></div></div><div id="37328899" class="c"><input type="checkbox" id="c-37328899" checked=""/><div class="controls bullet"><span class="by">koromak</span><span>|</span><a href="#37328592">parent</a><span>|</span><a href="#37330236">prev</a><span>|</span><a href="#37330337">next</a><span>|</span><label class="collapse" for="c-37328899">[-]</label><label class="expand" for="c-37328899">[4 more]</label></div><br/><div class="children"><div class="content">Fine. I&#x27;ve got a Document database for user data, AWS Cognito for user ID&#x27;s and authentication, Stripe for payments, and Postgres for a subset of user profile data that interacts with application data.<p>Common actions like Create, Delete, and some Updates touch all of these services. Automatic transactions between these would be fantastic. Especially on the billing side, some billing flows involve multiple trips between Stripe and our DB, batching the whole process inside a guaranteed reversable transaction would be lovely.<p>Of course we&#x27;re not going to get that with Stripe and Cognito as they expose bespoke API&#x27;s, but the idea still holds.</div><br/><div id="37329076" class="c"><input type="checkbox" id="c-37329076" checked=""/><div class="controls bullet"><span class="by">numbsafari</span><span>|</span><a href="#37328592">root</a><span>|</span><a href="#37328899">parent</a><span>|</span><a href="#37330337">next</a><span>|</span><label class="collapse" for="c-37329076">[-]</label><label class="expand" for="c-37329076">[3 more]</label></div><br/><div class="children"><div class="content">Except it doesn’t, really. You don’t usually want your user sitting around waiting for all those services to talk to each other before they a notification that the process is complete or not.<p>Further, those complex interactions between those various services will be much hard to debug and tweak when trying to provide support to end users. Can’t pay your bill because Cognito is down? Can’t grant access because Stripe is down? The data warehouse is doing an index build so you can’t do any transactions? Guess we should turn off the website between 2AM and 4AM ET to allow for data warehouse rebuilds.<p>There’s a reason we don’t do things this way.</div><br/><div id="37333118" class="c"><input type="checkbox" id="c-37333118" checked=""/><div class="controls bullet"><span class="by">yathaid</span><span>|</span><a href="#37328592">root</a><span>|</span><a href="#37329076">parent</a><span>|</span><a href="#37333125">next</a><span>|</span><label class="collapse" for="c-37333118">[-]</label><label class="expand" for="c-37333118">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; You don’t usually want your user sitting around waiting for all those services to talk to each other before they a notification that the process is complete or not.<p>I have had this exact use case in a problem I was solving where the user was waiting at the other end. Please do not presume that only the problems you have solved are worth solving or exist in the real world.</div><br/></div></div><div id="37333125" class="c"><input type="checkbox" id="c-37333125" checked=""/><div class="controls bullet"><span class="by">yathaid</span><span>|</span><a href="#37328592">root</a><span>|</span><a href="#37329076">parent</a><span>|</span><a href="#37333118">prev</a><span>|</span><a href="#37330337">next</a><span>|</span><label class="collapse" for="c-37333125">[-]</label><label class="expand" for="c-37333125">[1 more]</label></div><br/><div class="children"><div class="content">Also this:<p>&gt;&gt; Can’t pay your bill because Cognito is down?<p>I mean, if your AuthN and AuthZ is down, what else would you do ?!!<p>&gt;&gt; There’s a reason we don’t do things this way.<p>The smugness in this line is astounding. I don&#x27;t think I can express how wrong you are.</div><br/></div></div></div></div></div></div><div id="37330337" class="c"><input type="checkbox" id="c-37330337" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37328592">parent</a><span>|</span><a href="#37328899">prev</a><span>|</span><a href="#37328647">next</a><span>|</span><label class="collapse" for="c-37330337">[-]</label><label class="expand" for="c-37330337">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s used because it doesn&#x27;t require a page of backstory</div><br/></div></div><div id="37328647" class="c"><input type="checkbox" id="c-37328647" checked=""/><div class="controls bullet"><span class="by">marktani</span><span>|</span><a href="#37328592">parent</a><span>|</span><a href="#37330337">prev</a><span>|</span><label class="collapse" for="c-37328647">[-]</label><label class="expand" for="c-37328647">[5 more]</label></div><br/><div class="children"><div class="content">can you share a more helpful real world example?<p>as someone who hasn&#x27;t implemented transactions in microservices before, I have only seen the bank transfer example and it seems adequate and easy to understand - I wouldn&#x27;t know what limitations it has</div><br/><div id="37328732" class="c"><input type="checkbox" id="c-37328732" checked=""/><div class="controls bullet"><span class="by">numbsafari</span><span>|</span><a href="#37328592">root</a><span>|</span><a href="#37328647">parent</a><span>|</span><label class="collapse" for="c-37328732">[-]</label><label class="expand" for="c-37328732">[4 more]</label></div><br/><div class="children"><div class="content">It doesn’t exist. This isn’t how banks transfer funds between accounts.<p>It’s fake. As a result, you can’t actually evaluate the engineering trade offs of the proposed solution.<p>Here’s the thing: do you even need transactions (in the sense of ACID transactions that are resolved heuristically, as described in this article) between your microservices? Likely not.<p>And what are the implications of having to wait around for PGSQL and Mongo negotiate a transaction between a third data store? Probably blocking and latency and all the associated problems which will lead to … not use transaction across service boundaries.</div><br/><div id="37331047" class="c"><input type="checkbox" id="c-37331047" checked=""/><div class="controls bullet"><span class="by">jen20</span><span>|</span><a href="#37328592">root</a><span>|</span><a href="#37328732">parent</a><span>|</span><label class="collapse" for="c-37331047">[-]</label><label class="expand" for="c-37331047">[3 more]</label></div><br/><div class="children"><div class="content">The trick is to work out what you would do if you had to implement the entire system on paper in a 50s style office with triplicate carbon paper. Then do that, but with computers.</div><br/><div id="37333135" class="c"><input type="checkbox" id="c-37333135" checked=""/><div class="controls bullet"><span class="by">yathaid</span><span>|</span><a href="#37328592">root</a><span>|</span><a href="#37331047">parent</a><span>|</span><label class="collapse" for="c-37333135">[-]</label><label class="expand" for="c-37333135">[2 more]</label></div><br/><div class="children"><div class="content">That is not a trick, it is a false analogy. Two humans in eyesight line can be assured that they have exchanged messages successfully. Two computers cannot due to recursing acknowledgements (byzantine generals).</div><br/><div id="37333209" class="c"><input type="checkbox" id="c-37333209" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#37328592">root</a><span>|</span><a href="#37333135">parent</a><span>|</span><label class="collapse" for="c-37333209">[-]</label><label class="expand" for="c-37333209">[1 more]</label></div><br/><div class="children"><div class="content">More realistically; Two humans in eyesight line can <i>believe</i> that they have exchanged messages successfully.<p>Both parties misunderstanding the other is a common trope in movies and novels for a reason.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>