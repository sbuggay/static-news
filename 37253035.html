<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692954061573" as="style"/><link rel="stylesheet" href="styles.css?v=1692954061573"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.usenix.org/publications/loginonline/freebsd-firecracker">FreeBSD on Firecracker</a> <span class="domain">(<a href="https://www.usenix.org">www.usenix.org</a>)</span></div><div class="subtext"><span>jmmv</span> | <span>93 comments</span></div><br/><div><div id="37259415" class="c"><input type="checkbox" id="c-37259415" checked=""/><div class="controls bullet"><span class="by">Havoc</span><span>|</span><a href="#37253580">next</a><span>|</span><label class="collapse" for="c-37259415">[-]</label><label class="expand" for="c-37259415">[2 more]</label></div><br/><div class="children"><div class="content">Toyed around with firecracker a bit. Does what it promises on boot times, but still a pretty gnarly experience. e.g. After doing a victory dance for getting it to boot I was rather deflated to find out that getting networking takes another lengthy tutorial</div><br/><div id="37259555" class="c"><input type="checkbox" id="c-37259555" checked=""/><div class="controls bullet"><span class="by">bborud</span><span>|</span><a href="#37259415">parent</a><span>|</span><a href="#37253580">next</a><span>|</span><label class="collapse" for="c-37259555">[-]</label><label class="expand" for="c-37259555">[1 more]</label></div><br/><div class="children"><div class="content">I think there is definitively room for someone to add a lot of value to this by creating some automation tools. It would be really nice to be able to download a single binary, fire it up, have both a web interface and an API available, be able to configure it quickly, have it download whatever it needs for you etc.</div><br/></div></div></div></div><div id="37253580" class="c"><input type="checkbox" id="c-37253580" checked=""/><div class="controls bullet"><span class="by">garganzol</span><span>|</span><a href="#37259415">prev</a><span>|</span><a href="#37256896">next</a><span>|</span><label class="collapse" for="c-37253580">[-]</label><label class="expand" for="c-37253580">[56 more]</label></div><br/><div class="children"><div class="content">I never really realized that Firecracker VM is a full-blown machine and not just some sort of a Linux container tech. At first, it may sound like an ineffective approach, but if you take a closer look on a real-world usage example such as fly.io, you will be surprised: micro-VMs are very small and capable.</div><br/><div id="37253975" class="c"><input type="checkbox" id="c-37253975" checked=""/><div class="controls bullet"><span class="by">mjb</span><span>|</span><a href="#37253580">parent</a><span>|</span><a href="#37253646">next</a><span>|</span><label class="collapse" for="c-37253975">[-]</label><label class="expand" for="c-37253975">[9 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re interested in learning more about that, check out our NSDI&#x27;20 paper on how we chose this direction (<a href="https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;nsdi20&#x2F;presentation&#x2F;agache" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;nsdi20&#x2F;presentation&#x2F;agache</a>) and the Firecracker source and docs (<a href="https:&#x2F;&#x2F;github.com&#x2F;firecracker-microvm&#x2F;firecracker">https:&#x2F;&#x2F;github.com&#x2F;firecracker-microvm&#x2F;firecracker</a>).<p>Thanks to KVM, and to the minimal hardware support (no PCI, no ACPI, etc), Firecracker&#x27;s source is rather simple and even relatively readable for non-experts.</div><br/><div id="37255624" class="c"><input type="checkbox" id="c-37255624" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37253975">parent</a><span>|</span><a href="#37253646">next</a><span>|</span><label class="collapse" for="c-37255624">[-]</label><label class="expand" for="c-37255624">[8 more]</label></div><br/><div class="children"><div class="content"><i>Firecracker&#x27;s source is rather simple and even relatively readable for non-experts.</i><p>... as long as they&#x27;re experienced at writing Rust.  As a Rust newbie it took me a long time to figure out simple things like &quot;where is <i>foo</i> implemented&quot;, due to the twisty maze of crates and uses directives.<p>I totally get why this code is written in Rust, but it would have made my life much easier if it were written in C. ;-)</div><br/><div id="37256099" class="c"><input type="checkbox" id="c-37256099" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37255624">parent</a><span>|</span><a href="#37257099">next</a><span>|</span><label class="collapse" for="c-37256099">[-]</label><label class="expand" for="c-37256099">[5 more]</label></div><br/><div class="children"><div class="content">&gt; it took me a long time to figure out simple things like &quot;where is <i>foo</i> implemented&quot;<p>Out of curiosity, what development setup do you use?<p>I imagine that with vanilla EMacs or vanilla Vim you’d have to do quite a bit of spelunking to answer that sort of question.<p>With a full-blown IDE like for example JetBrains CLion with Rust plug-in installed, it is most of the time a matter of right-click -&gt; go to definition &#x2F; go to type declaration. (Although heavy use of Rust macros can in some cases confuse the system and make it unable to resolve definitions&#x2F;declarations.)<p>And with JetBrains CLion you still have Vim keybindings available as a plug-in.<p>I switched from Vim to CLion + plug-ins years ago and haven’t looked back since. (Vanilla Vim is still on my servers though so that when I ssh in and want to edit some config files or whatever I can do so in the terminal.)</div><br/><div id="37256366" class="c"><input type="checkbox" id="c-37256366" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37256099">parent</a><span>|</span><a href="#37256657">next</a><span>|</span><label class="collapse" for="c-37256366">[-]</label><label class="expand" for="c-37256366">[3 more]</label></div><br/><div class="children"><div class="content">My development environment for this was mostly &quot;nano in an SSH session&quot;.  (Among other reasons, I can&#x27;t even build Firecracker locally.)  For FreeBSD work that&#x27;s just fine since grep can find things for me.  It didn&#x27;t work so well for Firecracker.</div><br/><div id="37257066" class="c"><input type="checkbox" id="c-37257066" checked=""/><div class="controls bullet"><span class="by">danielheath</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37256366">parent</a><span>|</span><a href="#37256657">next</a><span>|</span><label class="collapse" for="c-37257066">[-]</label><label class="expand" for="c-37257066">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised `grep` didn&#x27;t work for finding implementations. Did you find out why? Was it eg searching first-party source code but not crates?</div><br/><div id="37257233" class="c"><input type="checkbox" id="c-37257233" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37257066">parent</a><span>|</span><a href="#37256657">next</a><span>|</span><label class="collapse" for="c-37257233">[-]</label><label class="expand" for="c-37257233">[1 more]</label></div><br/><div class="children"><div class="content">Figuring out how to get all the crate source code extracted was the first step, yes.  But when after that, the object oriented nature meant that there were often many different <i>foo</i> functions, so I had to dig through the code to figure out what type of object I was dealing with and which type each of the different <i>foo</i> implementations dealt with.<p>Whereas in FreeBSD I just grep for ^foo and the one and only line returned is where foo is implemented -- because if there&#x27;s different versions of <i>foo</i>, they have different names.<p>Namespaces sound good in principle but they impose a mental load of &quot;developers need to know what namespace they&#x27;re currently in&quot; -- which is fine for the original developer but much harder for someone jumping into the code for the first time.</div><br/></div></div></div></div></div></div><div id="37256657" class="c"><input type="checkbox" id="c-37256657" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37256099">parent</a><span>|</span><a href="#37256366">prev</a><span>|</span><a href="#37257099">next</a><span>|</span><label class="collapse" for="c-37256657">[-]</label><label class="expand" for="c-37256657">[1 more]</label></div><br/><div class="children"><div class="content">Etags makes answering that fairly simple in a C codebase and emacs can be an lsp client.</div><br/></div></div></div></div><div id="37257099" class="c"><input type="checkbox" id="c-37257099" checked=""/><div class="controls bullet"><span class="by">nonsense_stream</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37255624">parent</a><span>|</span><a href="#37256099">prev</a><span>|</span><a href="#37255849">next</a><span>|</span><label class="collapse" for="c-37257099">[-]</label><label class="expand" for="c-37257099">[1 more]</label></div><br/><div class="children"><div class="content">In comparison, I remember spending much less time finding &quot;where is foo implemented&quot; in Rust than in C++, and also found Rust std to be much more readable than C&#x27;s when I wasn&#x27;t familiar with each language. But I can see how rust with all the procedural macros, crates, traits could become a maze for people most familiar with C, and I probably don&#x27;t feel that because of my C++ background.</div><br/></div></div><div id="37255849" class="c"><input type="checkbox" id="c-37255849" checked=""/><div class="controls bullet"><span class="by">tmpX7dMeXU</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37255624">parent</a><span>|</span><a href="#37257099">prev</a><span>|</span><a href="#37253646">next</a><span>|</span><label class="collapse" for="c-37255849">[-]</label><label class="expand" for="c-37255849">[1 more]</label></div><br/><div class="children"><div class="content">“Writing things in C to appease the C people” is reasoning that can’t possibly die soon enough. You’ve had a good run.</div><br/></div></div></div></div></div></div><div id="37253646" class="c"><input type="checkbox" id="c-37253646" checked=""/><div class="controls bullet"><span class="by">NovemberWhiskey</span><span>|</span><a href="#37253580">parent</a><span>|</span><a href="#37253975">prev</a><span>|</span><a href="#37253676">next</a><span>|</span><label class="collapse" for="c-37253646">[-]</label><label class="expand" for="c-37253646">[31 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no way an &quot;enterprise grade&quot; cloud vendor like AWS would allow co-tenancy of containers (for ECS, Lambda etc) from different customers within a single VM - it&#x27;s the reason Firecracker exists.</div><br/><div id="37254122" class="c"><input type="checkbox" id="c-37254122" checked=""/><div class="controls bullet"><span class="by">nilptr</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37253646">parent</a><span>|</span><a href="#37258651">next</a><span>|</span><label class="collapse" for="c-37254122">[-]</label><label class="expand" for="c-37254122">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s no way an &quot;enterprise grade&quot; cloud vendor like AWS would allow co-tenancy of containers (for ECS, Lambda etc) from different customers within a single VM - it&#x27;s the reason Firecracker exists.<p>I won&#x27;t speak for AWS, but your assumption about what &quot;enterprise grade&quot; cloud vendors do is dead wrong. I know, because I&#x27;m working on maintaining one of these systems.</div><br/><div id="37254235" class="c"><input type="checkbox" id="c-37254235" checked=""/><div class="controls bullet"><span class="by">lima</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37254122">parent</a><span>|</span><a href="#37258651">next</a><span>|</span><label class="collapse" for="c-37254235">[-]</label><label class="expand" for="c-37254235">[2 more]</label></div><br/><div class="children"><div class="content">Lots of enterprise grade cloud vendors trust the Linux kernel boundary WAY too much...</div><br/><div id="37254536" class="c"><input type="checkbox" id="c-37254536" checked=""/><div class="controls bullet"><span class="by">jen20</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37254235">parent</a><span>|</span><a href="#37258651">next</a><span>|</span><label class="collapse" for="c-37254536">[-]</label><label class="expand" for="c-37254536">[1 more]</label></div><br/><div class="children"><div class="content">“Enterprise grade” deserves scare quotes for those people of course!</div><br/></div></div></div></div></div></div><div id="37258651" class="c"><input type="checkbox" id="c-37258651" checked=""/><div class="controls bullet"><span class="by">sharts</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37253646">parent</a><span>|</span><a href="#37254122">prev</a><span>|</span><a href="#37253921">next</a><span>|</span><label class="collapse" for="c-37258651">[-]</label><label class="expand" for="c-37258651">[1 more]</label></div><br/><div class="children"><div class="content">I think bryan cantrill founded a company (joyent? or triton?) to do just that several years ago. It may have been based on solaris&#x2F;smartos zones which is that exact use case w&#x2F; very secure&#x2F;isolated containers.</div><br/></div></div><div id="37253921" class="c"><input type="checkbox" id="c-37253921" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37253646">parent</a><span>|</span><a href="#37258651">prev</a><span>|</span><a href="#37254005">next</a><span>|</span><label class="collapse" for="c-37253921">[-]</label><label class="expand" for="c-37253921">[18 more]</label></div><br/><div class="children"><div class="content">Does google?  I know they use gvisor in production, which is ultimately enforced by a normal kernel (with a ton of sandboxing on top of it).</div><br/><div id="37254144" class="c"><input type="checkbox" id="c-37254144" checked=""/><div class="controls bullet"><span class="by">eddythompson80</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37253921">parent</a><span>|</span><a href="#37254005">next</a><span>|</span><label class="collapse" for="c-37254144">[-]</label><label class="expand" for="c-37254144">[17 more]</label></div><br/><div class="children"><div class="content">Google is moving away from gvisor as well.<p>The &quot;process sandbox&quot; wars are over. Everybody lost, hypervisors won. That&#x27;s it. It feels incredibly wasteful after all. Hypervisors don&#x27;t share mm, scheduler, etc. It&#x27;s a lot of wasted resources. Google came in with gvisor at the last minute to try to say &quot;no, sandboxes aren&#x27;t dead. Look at our approach with gvisor&quot;. They lost too and are now moving away from it.</div><br/><div id="37255290" class="c"><input type="checkbox" id="c-37255290" checked=""/><div class="controls bullet"><span class="by">Rapzid</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37254144">parent</a><span>|</span><a href="#37255232">next</a><span>|</span><label class="collapse" for="c-37255290">[-]</label><label class="expand" for="c-37255290">[4 more]</label></div><br/><div class="children"><div class="content">Really? Has gvisor ever been popped? Has there ever even been a single high-profile compromise caused by a container escape? Shared hosting was a thing and considered &quot;safe enough&quot; for decades and that&#x27;s all process isolation.<p>Can&#x27;t help but feel the security concerns are overblown. To support my claim; Well, Google IS using gvisor as part of their GKE sandboxing security..</div><br/><div id="37255893" class="c"><input type="checkbox" id="c-37255893" checked=""/><div class="controls bullet"><span class="by">eddythompson80</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37255290">parent</a><span>|</span><a href="#37255368">next</a><span>|</span><label class="collapse" for="c-37255893">[-]</label><label class="expand" for="c-37255893">[1 more]</label></div><br/><div class="children"><div class="content">shared this link on another reply, but google moved away from gvisor to hypervisor for cloud run. It won&#x27;t be long before they do for GKE as well<p><a href="https:&#x2F;&#x2F;cloud.google.com&#x2F;blog&#x2F;products&#x2F;serverless&#x2F;cloud-run-jobs-and-second-generation-execution-environment-ga" rel="nofollow noreferrer">https:&#x2F;&#x2F;cloud.google.com&#x2F;blog&#x2F;products&#x2F;serverless&#x2F;cloud-run-...</a></div><br/></div></div><div id="37255368" class="c"><input type="checkbox" id="c-37255368" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37255290">parent</a><span>|</span><a href="#37255893">prev</a><span>|</span><a href="#37256413">next</a><span>|</span><label class="collapse" for="c-37255368">[-]</label><label class="expand" for="c-37255368">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know what &quot;popped&quot; means here, but so far as I know there&#x27;s never been a major incident caused by a flaw in gvisor. But gvisor is a much more intricate and carefully controlled system than standard Linux containers. Obviously, there have been tons of container escape compromises.</div><br/></div></div><div id="37256413" class="c"><input type="checkbox" id="c-37256413" checked=""/><div class="controls bullet"><span class="by">jsolson</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37255290">parent</a><span>|</span><a href="#37255368">prev</a><span>|</span><a href="#37255232">next</a><span>|</span><label class="collapse" for="c-37256413">[-]</label><label class="expand" for="c-37256413">[1 more]</label></div><br/><div class="children"><div class="content">Note that GKE Sandbox allows GKE users to sandbox the workloads running on GKE nodes. The GKE nodes themselves are still GCE VMs.</div><br/></div></div></div></div><div id="37255232" class="c"><input type="checkbox" id="c-37255232" checked=""/><div class="controls bullet"><span class="by">RainbowFriends</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37254144">parent</a><span>|</span><a href="#37255290">prev</a><span>|</span><a href="#37254241">next</a><span>|</span><label class="collapse" for="c-37255232">[-]</label><label class="expand" for="c-37255232">[5 more]</label></div><br/><div class="children"><div class="content">Citation needed. gvisor seems to be under active development and just added support for the systrap platform, deprecating ptrace: <a href="https:&#x2F;&#x2F;gvisor.dev&#x2F;blog&#x2F;2023&#x2F;04&#x2F;28&#x2F;systrap-release&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;gvisor.dev&#x2F;blog&#x2F;2023&#x2F;04&#x2F;28&#x2F;systrap-release&#x2F;</a></div><br/><div id="37255876" class="c"><input type="checkbox" id="c-37255876" checked=""/><div class="controls bullet"><span class="by">eddythompson80</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37255232">parent</a><span>|</span><a href="#37255361">next</a><span>|</span><label class="collapse" for="c-37255876">[-]</label><label class="expand" for="c-37255876">[3 more]</label></div><br/><div class="children"><div class="content">Cloud run has abandoned gvisor in their &quot;second generation&quot; execution environment for containers<p><a href="https:&#x2F;&#x2F;cloud.google.com&#x2F;blog&#x2F;products&#x2F;serverless&#x2F;cloud-run-jobs-and-second-generation-execution-environment-ga" rel="nofollow noreferrer">https:&#x2F;&#x2F;cloud.google.com&#x2F;blog&#x2F;products&#x2F;serverless&#x2F;cloud-run-...</a><p>Obviously there might be many reasons for that, but as someone who worked on a similar gvisor tech for another company, it&#x27;s dead in the water. No security expert or consultant will ever sign off on a process isolation model. Despite of architecture, audits, reviews, etc. There is just too much surface area for anyone to feel comfortable signing off on hostile multi-tenants with process isolation regardless of the sandboxing tech.<p>Not saying that there are no bugs in hypervisors, but the surface area is so so much smaller.</div><br/><div id="37257821" class="c"><input type="checkbox" id="c-37257821" checked=""/><div class="controls bullet"><span class="by">coryrc</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37255876">parent</a><span>|</span><a href="#37256415">next</a><span>|</span><label class="collapse" for="c-37257821">[-]</label><label class="expand" for="c-37257821">[1 more]</label></div><br/><div class="children"><div class="content">The first sentence pretty much sums it up: &quot;Cloud Run’s new execution environment provides increased CPU and network performance and lets you mount network file systems.&quot; It&#x27;s not a secret that performance is slower under gvisor and there are compatibility issues: <a href="https:&#x2F;&#x2F;gvisor.dev&#x2F;docs&#x2F;architecture_guide&#x2F;performance&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;gvisor.dev&#x2F;docs&#x2F;architecture_guide&#x2F;performance&#x2F;</a><p>Disclaimer: I work on this product but wasn&#x27;t involved in this decision.</div><br/></div></div><div id="37256415" class="c"><input type="checkbox" id="c-37256415" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37255876">parent</a><span>|</span><a href="#37257821">prev</a><span>|</span><a href="#37255361">next</a><span>|</span><label class="collapse" for="c-37256415">[-]</label><label class="expand" for="c-37256415">[1 more]</label></div><br/><div class="children"><div class="content">gvisor isn&#x27;t simply a process isolation model. Security experts will certainly sign off on gvisor for some multitenant workloads. The reason Google is moving from it, to the extent they are, is that hypervisors are more performant for more common workloads.</div><br/></div></div></div></div><div id="37255361" class="c"><input type="checkbox" id="c-37255361" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37255232">parent</a><span>|</span><a href="#37255876">prev</a><span>|</span><a href="#37254241">next</a><span>|</span><label class="collapse" for="c-37255361">[-]</label><label class="expand" for="c-37255361">[1 more]</label></div><br/><div class="children"><div class="content">Everything google does “seems under active development” until they kill it<p>… stadia anyone?</div><br/></div></div></div></div><div id="37254241" class="c"><input type="checkbox" id="c-37254241" checked=""/><div class="controls bullet"><span class="by">lima</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37254144">parent</a><span>|</span><a href="#37255232">prev</a><span>|</span><a href="#37254373">next</a><span>|</span><label class="collapse" for="c-37254241">[-]</label><label class="expand" for="c-37254241">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Google is moving away from gvisor as well.</i><p>I&#x27;ve been wondering about this - are they really?</div><br/><div id="37254584" class="c"><input type="checkbox" id="c-37254584" checked=""/><div class="controls bullet"><span class="by">beardedwizard</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37254241">parent</a><span>|</span><a href="#37254373">next</a><span>|</span><label class="collapse" for="c-37254584">[-]</label><label class="expand" for="c-37254584">[2 more]</label></div><br/><div class="children"><div class="content">I have seen zero evidence of this; but if it&#x27;s true I would love to learn more. The real action is in side channel vulnerabilities bypassing all manner of protections.</div><br/><div id="37255936" class="c"><input type="checkbox" id="c-37255936" checked=""/><div class="controls bullet"><span class="by">eddythompson80</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37254584">parent</a><span>|</span><a href="#37254373">next</a><span>|</span><label class="collapse" for="c-37255936">[-]</label><label class="expand" for="c-37255936">[1 more]</label></div><br/><div class="children"><div class="content">see<p><a href="https:&#x2F;&#x2F;cloud.google.com&#x2F;blog&#x2F;products&#x2F;serverless&#x2F;cloud-run-jobs-and-second-generation-execution-environment-ga" rel="nofollow noreferrer">https:&#x2F;&#x2F;cloud.google.com&#x2F;blog&#x2F;products&#x2F;serverless&#x2F;cloud-run-...</a></div><br/></div></div></div></div></div></div><div id="37254373" class="c"><input type="checkbox" id="c-37254373" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37254144">parent</a><span>|</span><a href="#37254241">prev</a><span>|</span><a href="#37256542">next</a><span>|</span><label class="collapse" for="c-37254373">[-]</label><label class="expand" for="c-37254373">[1 more]</label></div><br/><div class="children"><div class="content">In a way, it feels like a sweet revenge for microkernels.</div><br/></div></div><div id="37256542" class="c"><input type="checkbox" id="c-37256542" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37254144">parent</a><span>|</span><a href="#37254373">prev</a><span>|</span><a href="#37254005">next</a><span>|</span><label class="collapse" for="c-37256542">[-]</label><label class="expand" for="c-37256542">[3 more]</label></div><br/><div class="children"><div class="content">Tbf gvisor was pretty much DOA by design. Hypervisors are alright, but nowadays security expectations go much lower than ring-1.</div><br/><div id="37256747" class="c"><input type="checkbox" id="c-37256747" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37256542">parent</a><span>|</span><a href="#37254005">next</a><span>|</span><label class="collapse" for="c-37256747">[-]</label><label class="expand" for="c-37256747">[2 more]</label></div><br/><div class="children"><div class="content">Can you expand on this? What do you mean &quot;security expectations go lower than ring-1&quot;, and how does that relate to gvisor?</div><br/><div id="37258938" class="c"><input type="checkbox" id="c-37258938" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37256747">parent</a><span>|</span><a href="#37254005">next</a><span>|</span><label class="collapse" for="c-37258938">[-]</label><label class="expand" for="c-37258938">[1 more]</label></div><br/><div class="children"><div class="content">For example what Microsoft is doing at firmware level for Azure.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37254005" class="c"><input type="checkbox" id="c-37254005" checked=""/><div class="controls bullet"><span class="by">basique</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37253646">parent</a><span>|</span><a href="#37253921">prev</a><span>|</span><a href="#37255112">next</a><span>|</span><label class="collapse" for="c-37254005">[-]</label><label class="expand" for="c-37254005">[2 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t Cloudflare Workers multitenant? Although, if you want to be cynical, that could be a reason they aren&#x27;t &#x27;enterprise grade™&#x27;.</div><br/><div id="37254029" class="c"><input type="checkbox" id="c-37254029" checked=""/><div class="controls bullet"><span class="by">tyingq</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37254005">parent</a><span>|</span><a href="#37255112">next</a><span>|</span><label class="collapse" for="c-37254029">[-]</label><label class="expand" for="c-37254029">[1 more]</label></div><br/><div class="children"><div class="content">They are using v8 isolates, which is maybe easier to do in a sound way than the whole broad space of containers.  Previous discussion: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31740885">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31740885</a></div><br/></div></div></div></div><div id="37255112" class="c"><input type="checkbox" id="c-37255112" checked=""/><div class="controls bullet"><span class="by">mochomocha</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37253646">parent</a><span>|</span><a href="#37254005">prev</a><span>|</span><a href="#37253681">next</a><span>|</span><label class="collapse" for="c-37255112">[-]</label><label class="expand" for="c-37255112">[2 more]</label></div><br/><div class="children"><div class="content">Both Lambda firecracker VMs and t2 instances are multi-tenant and oversubscribed.</div><br/><div id="37255376" class="c"><input type="checkbox" id="c-37255376" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37255112">parent</a><span>|</span><a href="#37253681">next</a><span>|</span><label class="collapse" for="c-37255376">[-]</label><label class="expand" for="c-37255376">[1 more]</label></div><br/><div class="children"><div class="content">I take them to mean &quot;multiple tenants sharing a kernel&quot;; I think everyone understands that AWS and GCP have multitenant hypervisor hosts.</div><br/></div></div></div></div><div id="37255453" class="c"><input type="checkbox" id="c-37255453" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37253646">parent</a><span>|</span><a href="#37253681">prev</a><span>|</span><a href="#37253676">next</a><span>|</span><label class="collapse" for="c-37255453">[-]</label><label class="expand" for="c-37255453">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s no way an &quot;enterprise grade&quot; cloud vendor like AWS would allow co-tenancy of containers (...)<p>I don&#x27;t think your beliefs are well founded. AWS&#x27;s EC2 by default only supoprts shared tenancy, and dedicated instances are a premium service.</div><br/><div id="37258601" class="c"><input type="checkbox" id="c-37258601" checked=""/><div class="controls bullet"><span class="by">cthalupa</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37255453">parent</a><span>|</span><a href="#37255471">next</a><span>|</span><label class="collapse" for="c-37258601">[-]</label><label class="expand" for="c-37258601">[1 more]</label></div><br/><div class="children"><div class="content">But the parent specifically called out co-tenancy of &#x2F;containers&#x2F;. EC2 instances are not containers.</div><br/></div></div><div id="37255471" class="c"><input type="checkbox" id="c-37255471" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37255453">parent</a><span>|</span><a href="#37258601">prev</a><span>|</span><a href="#37253676">next</a><span>|</span><label class="collapse" for="c-37255471">[-]</label><label class="expand" for="c-37255471">[1 more]</label></div><br/><div class="children"><div class="content">I take them to mean shared kernels.</div><br/></div></div></div></div></div></div><div id="37253676" class="c"><input type="checkbox" id="c-37253676" checked=""/><div class="controls bullet"><span class="by">seabrookmx</span><span>|</span><a href="#37253580">parent</a><span>|</span><a href="#37253646">prev</a><span>|</span><a href="#37255117">next</a><span>|</span><label class="collapse" for="c-37253676">[-]</label><label class="expand" for="c-37253676">[1 more]</label></div><br/><div class="children"><div class="content">Well they&#x27;re not a &quot;full-blown&quot; machine, in that they do cut out a lot of things unnecessary for Lambda&#x27;s (and incidentally, fly.io&#x27;s) use case. ACPI is one example given in the article.<p>But yes, they do virtualize hardware not the kernel. I&#x27;m willing to bet you could swap out vanilla containerd with firecracker-containerd for most users and they wouldn&#x27;t notice a difference given they initialize so fast.</div><br/></div></div><div id="37255117" class="c"><input type="checkbox" id="c-37255117" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#37253580">parent</a><span>|</span><a href="#37253676">prev</a><span>|</span><a href="#37257124">next</a><span>|</span><label class="collapse" for="c-37255117">[-]</label><label class="expand" for="c-37255117">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;m very surprised the standard isn&#x27;t to build a microkernel that emulates Linux userspace (or *NIX userspace) and is tailored towards the subset of virtual hardware that Firecracker and QEMU provide. I don&#x27;t get the impression that implementing a new target for a PL is all that difficult, so if you create a psuedo-OS like WASI&#x2F;WASM and send PRs to the supported languages you could cut out most of the overhead.<p>The &quot;hardest&quot; part is probably sufficiently emulating Linux userspace accurately: it&#x27;s a big surface area. That&#x27;s why I think creating a pseudo-OS target is the best route.</div><br/><div id="37255380" class="c"><input type="checkbox" id="c-37255380" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37255117">parent</a><span>|</span><a href="#37257124">next</a><span>|</span><label class="collapse" for="c-37255380">[-]</label><label class="expand" for="c-37255380">[9 more]</label></div><br/><div class="children"><div class="content">You&#x27;re describing gvisor.</div><br/><div id="37255609" class="c"><input type="checkbox" id="c-37255609" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37255380">parent</a><span>|</span><a href="#37257124">next</a><span>|</span><label class="collapse" for="c-37255609">[-]</label><label class="expand" for="c-37255609">[8 more]</label></div><br/><div class="children"><div class="content">No, I&#x27;m not. Gvisor is a security layer around Linux containers that emulates and constrains syscalls. It specifically runs on top of a container platform and kernel. What I&#x27;m suggesting is a stripped down Linux-like kernel that is really good at running exactly one process. I&#x27;m describing a microkernel.</div><br/><div id="37255674" class="c"><input type="checkbox" id="c-37255674" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37255609">parent</a><span>|</span><a href="#37257124">next</a><span>|</span><label class="collapse" for="c-37255674">[-]</label><label class="expand" for="c-37255674">[7 more]</label></div><br/><div class="children"><div class="content">gvisor emulates a big chunk of the Linux system call interface, and, remarkably, a further large chunk of Linux kernel state. It&#x27;s architecturally similar to uml (though not as complete; like Firecracker, it&#x27;s optimized to a specific set of workloads).<p>gvisor is not like a seccomp-bpf process sandbox that just ACLs system calls.</div><br/><div id="37256040" class="c"><input type="checkbox" id="c-37256040" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37255674">parent</a><span>|</span><a href="#37257124">next</a><span>|</span><label class="collapse" for="c-37256040">[-]</label><label class="expand" for="c-37256040">[6 more]</label></div><br/><div class="children"><div class="content">Ok, I oversimplified a bit. Regardless, I&#x27;m suggesting something that still runs in emulated hardware isolation and implements drivers for Firecracker&#x2F;QEMU&#x27;s subset of hardware.</div><br/><div id="37256078" class="c"><input type="checkbox" id="c-37256078" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37256040">parent</a><span>|</span><a href="#37257124">next</a><span>|</span><label class="collapse" for="c-37256078">[-]</label><label class="expand" for="c-37256078">[5 more]</label></div><br/><div class="children"><div class="content">gvisor does emulate some hardware. See, for instance, its network stack.<p>At any rate: why is this better than just using KVM and Firecracker? The big problem with gvisor is that the emulation you&#x27;re talking about has pretty tough overhead.</div><br/><div id="37256703" class="c"><input type="checkbox" id="c-37256703" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37256078">parent</a><span>|</span><a href="#37257124">next</a><span>|</span><label class="collapse" for="c-37256703">[-]</label><label class="expand" for="c-37256703">[4 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s you get the best of both gvisor and Firecracker: efficient use of resources (ie. not running a full Linux kernel + scheduler, and most importantly, network stack for every lambda) while getting the isolation that comes from virtualization. You can achieve this in one of 2 ways: make a new kernel and add support for targeting it in the supported languages, or strip the Linux kernel down and reimplement the parts that aren&#x27;t optimized for you short-lived VM lifecycle (scheduler, network stack, etc.).</div><br/><div id="37256734" class="c"><input type="checkbox" id="c-37256734" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37256703">parent</a><span>|</span><a href="#37257124">next</a><span>|</span><label class="collapse" for="c-37256734">[-]</label><label class="expand" for="c-37256734">[3 more]</label></div><br/><div class="children"><div class="content">Stripping the Linux kernel down is what people do with Firecracker. I&#x27;m curious what savings you see in the Linux networking stack. You could compile it out and just rely on vsocks, but now you&#x27;re breaking everyone&#x27;s code and you&#x27;re not winning anything on performance.</div><br/><div id="37257023" class="c"><input type="checkbox" id="c-37257023" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37256734">parent</a><span>|</span><a href="#37257124">next</a><span>|</span><label class="collapse" for="c-37257023">[-]</label><label class="expand" for="c-37257023">[2 more]</label></div><br/><div class="children"><div class="content">Perhaps I&#x27;m off base (I&#x27;m not an expert in this area), but I recall reading that one of the major challenges with Lambda was the latency that initializing the network stack introduces. Perhaps that&#x27;s been solved by now, but my naive idea is to have the guest not really run it&#x27;s own network stack (at least the MAC&#x2F;IP portion of it) and instead delegate the entire stack (IP and all) to the virtual device, which can be implemented by Firecracker&#x2F;QEMU&#x2F;whatever. I guess at that point, the amount of mangling you&#x27;d need to do to the kernel probably isn&#x27;t worth it and you should just use Gvisor... ah oh well.<p>Regardless, I&#x27;m still surprised microkernels aren&#x27;t more popular in this space, but perhaps the losing the ecosystem of Linux libs&#x2F;applications is a non-starter.<p>Even if the idea wasn&#x27;t fruitful, the conversation was fun. Thanks for engaging and challenging my bad ideas!<p>Edit: I&#x27;ve also realized I was thinking of Unikernels, not microkernels and I&#x27;ve been calling it the wrong thing all night. *sigh*</div><br/><div id="37258034" class="c"><input type="checkbox" id="c-37258034" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37257023">parent</a><span>|</span><a href="#37257124">next</a><span>|</span><label class="collapse" for="c-37258034">[-]</label><label class="expand" for="c-37258034">[1 more]</label></div><br/><div class="children"><div class="content">FWIW, Linux itself has plenty of support for TCP offload engines.  I don&#x27;t think Firecracker uses that at the moment, but there&#x27;s no reason why it has to be that way if that&#x27;s a true bottleneck in the system.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37257124" class="c"><input type="checkbox" id="c-37257124" checked=""/><div class="controls bullet"><span class="by">dikei</span><span>|</span><a href="#37253580">parent</a><span>|</span><a href="#37255117">prev</a><span>|</span><a href="#37257605">next</a><span>|</span><label class="collapse" for="c-37257124">[-]</label><label class="expand" for="c-37257124">[1 more]</label></div><br/><div class="children"><div class="content">KVM is amazing.<p>Beside Firecracker, there&#x27;re all sorts of micro-VM being developed right now, such as crosvm, cloud-hypervisor, Kata&#x27;s Dragonball, all on top of KVM.</div><br/></div></div><div id="37257605" class="c"><input type="checkbox" id="c-37257605" checked=""/><div class="controls bullet"><span class="by">ekianjo</span><span>|</span><a href="#37253580">parent</a><span>|</span><a href="#37257124">prev</a><span>|</span><a href="#37253677">next</a><span>|</span><label class="collapse" for="c-37257605">[-]</label><label class="expand" for="c-37257605">[1 more]</label></div><br/><div class="children"><div class="content">Thats what powers lambda on aws</div><br/></div></div><div id="37253677" class="c"><input type="checkbox" id="c-37253677" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#37253580">parent</a><span>|</span><a href="#37257605">prev</a><span>|</span><a href="#37256896">next</a><span>|</span><label class="collapse" for="c-37253677">[-]</label><label class="expand" for="c-37253677">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a full blown VM, it has limitations.</div><br/><div id="37253753" class="c"><input type="checkbox" id="c-37253753" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#37253580">root</a><span>|</span><a href="#37253677">parent</a><span>|</span><a href="#37256896">next</a><span>|</span><label class="collapse" for="c-37253753">[-]</label><label class="expand" for="c-37253753">[1 more]</label></div><br/><div class="children"><div class="content">It is a full blown VM, it has limitations.</div><br/></div></div></div></div></div></div><div id="37256896" class="c"><input type="checkbox" id="c-37256896" checked=""/><div class="controls bullet"><span class="by">nocarrier</span><span>|</span><a href="#37253580">prev</a><span>|</span><a href="#37254218">next</a><span>|</span><label class="collapse" for="c-37256896">[-]</label><label class="expand" for="c-37256896">[1 more]</label></div><br/><div class="children"><div class="content">Once Colin&#x27;s patches land on FreeBSD and Firecracker, the total boot time for the kernel is under 20ms. Absolutely incredible times that we live in.</div><br/></div></div><div id="37254218" class="c"><input type="checkbox" id="c-37254218" checked=""/><div class="controls bullet"><span class="by">mnsc</span><span>|</span><a href="#37256896">prev</a><span>|</span><a href="#37254396">next</a><span>|</span><label class="collapse" for="c-37254218">[-]</label><label class="expand" for="c-37254218">[2 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s the recent BSDCan talk from Colin that was posted a couple of days ago.<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;MT3cdeuRTzs?si=l6baNriUjcvy0ZOE" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;MT3cdeuRTzs?si=l6baNriUjcvy0ZOE</a></div><br/><div id="37255577" class="c"><input type="checkbox" id="c-37255577" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#37254218">parent</a><span>|</span><a href="#37254396">next</a><span>|</span><label class="collapse" for="c-37255577">[-]</label><label class="expand" for="c-37255577">[1 more]</label></div><br/><div class="children"><div class="content">FWIW, this is basically the same material -- after my BSDCan talk the FreeBSD Journal said &quot;hey, that was a great talk, can you turn it into an article for us&quot;, and after the FreeBSD Journal article was published ;login: asked if they could republish it.</div><br/></div></div></div></div><div id="37254396" class="c"><input type="checkbox" id="c-37254396" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#37254218">prev</a><span>|</span><a href="#37253407">next</a><span>|</span><label class="collapse" for="c-37254396">[-]</label><label class="expand" for="c-37254396">[2 more]</label></div><br/><div class="children"><div class="content">qemu has microvm, inspired by firecracker<p><a href="https:&#x2F;&#x2F;qemu.readthedocs.io&#x2F;en&#x2F;latest&#x2F;system&#x2F;i386&#x2F;microvm.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;qemu.readthedocs.io&#x2F;en&#x2F;latest&#x2F;system&#x2F;i386&#x2F;microvm.ht...</a></div><br/><div id="37255067" class="c"><input type="checkbox" id="c-37255067" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#37254396">parent</a><span>|</span><a href="#37253407">next</a><span>|</span><label class="collapse" for="c-37255067">[-]</label><label class="expand" for="c-37255067">[1 more]</label></div><br/><div class="children"><div class="content">I wonder how many of these workarounds are needed with QEMU! Some of course will be needed because they are fixes for bugs in FreeBSD.</div><br/></div></div></div></div><div id="37253407" class="c"><input type="checkbox" id="c-37253407" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#37254396">prev</a><span>|</span><a href="#37256535">next</a><span>|</span><label class="collapse" for="c-37253407">[-]</label><label class="expand" for="c-37253407">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny how many one second pauses turn out to be less than necessary. How many sysadmins took meaningful action because the system paused when they had an invalid machine uuid?</div><br/><div id="37255594" class="c"><input type="checkbox" id="c-37255594" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#37253407">parent</a><span>|</span><a href="#37256535">next</a><span>|</span><label class="collapse" for="c-37255594">[-]</label><label class="expand" for="c-37255594">[5 more]</label></div><br/><div class="children"><div class="content">Probably a significant proportion of the sysadmins who experienced that one-second pause.<p>The &quot;print a message telling the user that we&#x27;re rebooting, then wait a second to let them read the console before we go ahead and reboot&quot;, on the other hand...</div><br/><div id="37256480" class="c"><input type="checkbox" id="c-37256480" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#37253407">root</a><span>|</span><a href="#37255594">parent</a><span>|</span><a href="#37258549">next</a><span>|</span><label class="collapse" for="c-37256480">[-]</label><label class="expand" for="c-37256480">[3 more]</label></div><br/><div class="children"><div class="content">Maybe I&#x27;m just different. I&#x27;ve watched a great many openbsd boot sequences, which tend to have a great many pauses, and I&#x27;ve never paid any special attention to the lines that come before pauses vs lines that come after pauses.</div><br/><div id="37256540" class="c"><input type="checkbox" id="c-37256540" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#37253407">root</a><span>|</span><a href="#37256480">parent</a><span>|</span><a href="#37258549">next</a><span>|</span><label class="collapse" for="c-37256540">[-]</label><label class="expand" for="c-37256540">[2 more]</label></div><br/><div class="children"><div class="content">I suspect that FreeBSD has fewer pauses than OpenBSD... especially after the work I&#x27;ve done over the past few years to speed it up.<p>If anyone in the OpenBSD world is interested in speeding up your boot process I&#x27;d be happy to share tips and code.  It&#x27;s a bit daunting to start with but with some good tools it becomes a lot of fun.</div><br/><div id="37258341" class="c"><input type="checkbox" id="c-37258341" checked=""/><div class="controls bullet"><span class="by">pseudostem</span><span>|</span><a href="#37253407">root</a><span>|</span><a href="#37256540">parent</a><span>|</span><a href="#37258549">next</a><span>|</span><label class="collapse" for="c-37258341">[-]</label><label class="expand" for="c-37258341">[1 more]</label></div><br/><div class="children"><div class="content">Thank you! That would be me. I am clueless on amd64 on how to speed up the boot process and maybe change a few fonts during boot.<p>I understand the reasons for no &quot;how-tos&quot;. But sometimes they make sense for people like me. I wouldn&#x27;t mind delving a bit deeper given some direction.</div><br/></div></div></div></div></div></div><div id="37258549" class="c"><input type="checkbox" id="c-37258549" checked=""/><div class="controls bullet"><span class="by">slim</span><span>|</span><a href="#37253407">root</a><span>|</span><a href="#37255594">parent</a><span>|</span><a href="#37256480">prev</a><span>|</span><a href="#37256535">next</a><span>|</span><label class="collapse" for="c-37258549">[-]</label><label class="expand" for="c-37258549">[1 more]</label></div><br/><div class="children"><div class="content">if the machine boots in 20ms, I think that message is actually useful, because something would reboot your machine and you&#x27;d think you got logged out because you blinked</div><br/></div></div></div></div></div></div><div id="37256535" class="c"><input type="checkbox" id="c-37256535" checked=""/><div class="controls bullet"><span class="by">ruslan</span><span>|</span><a href="#37253407">prev</a><span>|</span><a href="#37254686">next</a><span>|</span><label class="collapse" for="c-37256535">[-]</label><label class="expand" for="c-37256535">[1 more]</label></div><br/><div class="children"><div class="content">&gt; on a virtual machine with 1 CPU and 128 MB of RAM, the FreeBSD kernel can boot in under 20 ms;<p>Oh, my... how could I achieve the same on real hardware without VMs ? ;)</div><br/></div></div><div id="37254686" class="c"><input type="checkbox" id="c-37254686" checked=""/><div class="controls bullet"><span class="by">laurencerowe</span><span>|</span><a href="#37256535">prev</a><span>|</span><a href="#37254323">next</a><span>|</span><label class="collapse" for="c-37254686">[-]</label><label class="expand" for="c-37254686">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a shame neither AWS nor macOS on ARM support nested virtualization. It would would make it far easier to develop and deploy Firecracker based tech.</div><br/><div id="37254832" class="c"><input type="checkbox" id="c-37254832" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#37254686">parent</a><span>|</span><a href="#37255395">next</a><span>|</span><label class="collapse" for="c-37254832">[-]</label><label class="expand" for="c-37254832">[2 more]</label></div><br/><div class="children"><div class="content">FWIW, AWS a1.metal instances are pretty small and thereby reasonably cost effective for working with virtualization tech.</div><br/><div id="37255304" class="c"><input type="checkbox" id="c-37255304" checked=""/><div class="controls bullet"><span class="by">Rapzid</span><span>|</span><a href="#37254686">root</a><span>|</span><a href="#37254832">parent</a><span>|</span><a href="#37255395">next</a><span>|</span><label class="collapse" for="c-37255304">[-]</label><label class="expand" for="c-37255304">[1 more]</label></div><br/><div class="children"><div class="content">Their metal offerings are puny in general though(as in, not a ton of options).</div><br/></div></div></div></div><div id="37255395" class="c"><input type="checkbox" id="c-37255395" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#37254686">parent</a><span>|</span><a href="#37254832">prev</a><span>|</span><a href="#37254323">next</a><span>|</span><label class="collapse" for="c-37255395">[-]</label><label class="expand" for="c-37255395">[1 more]</label></div><br/><div class="children"><div class="content">Afaik you can do virtualisation on the .metal variants.<p>Actually you can do virtualisation on any instance type afaik, but only with .metal instances you can use hardware acceleration.</div><br/></div></div></div></div><div id="37254323" class="c"><input type="checkbox" id="c-37254323" checked=""/><div class="controls bullet"><span class="by">doublerabbit</span><span>|</span><a href="#37254686">prev</a><span>|</span><a href="#37255566">next</a><span>|</span><label class="collapse" for="c-37254323">[-]</label><label class="expand" for="c-37254323">[17 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not wanting to sound snoody. What use-cases do firecracker instances and the likes chime?<p>I use FreeBSD for everything from my colocated servers, to my own PC. By no means am I developer; seasoned Unix Admin at best. Bare-metal forever but welcome to the future. Especially anything that contributes to the OS.<p>However I hear buzz words like Lambda and Firecracker and really have no idea where the usage is. I get docker, containers, barely understand k8s but why do you need to spin up a VM only to tear it down compared to where you could just spin up a VM and use it when you really need to. Always there, always when.<p>Is it purely a cloud experience, cost saving exercise?</div><br/><div id="37254791" class="c"><input type="checkbox" id="c-37254791" checked=""/><div class="controls bullet"><span class="by">r3trohack3r</span><span>|</span><a href="#37254323">parent</a><span>|</span><a href="#37255169">next</a><span>|</span><label class="collapse" for="c-37254791">[-]</label><label class="expand" for="c-37254791">[1 more]</label></div><br/><div class="children"><div class="content">Instances of an application are created as part of the request&#x2F;response lifecycle.<p>Allows you to build a compute plane where any node in the plane can service the traffic for any application.<p>Any one application can dynamically grow to consume the available free compute of the plane as needed in response to changes in traffic patterns.<p>Applications use no resources when they aren&#x27;t handling traffic.<p>Growing the capacity of the compute plane means bringing more nodes online.<p>Can&#x27;t come up with a use case for this beyond managing many large-scale deployments. If you aren&#x27;t working &quot;at scale&quot; this is something that would sit below a vendor boundary for you.</div><br/></div></div><div id="37255169" class="c"><input type="checkbox" id="c-37255169" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#37254323">parent</a><span>|</span><a href="#37254791">prev</a><span>|</span><a href="#37254784">next</a><span>|</span><label class="collapse" for="c-37255169">[-]</label><label class="expand" for="c-37255169">[6 more]</label></div><br/><div class="children"><div class="content">The main use case if for seldom used APIs.  If I run a service where the API isn&#x27;t used often, but I need it quick when it is, Lambdas or something like it are perfect.<p>As it turns out, a lot of APIs for phone apps fit this category.  You don&#x27;t want a machine sitting around idle 99% of the time to answer those API calls.</div><br/><div id="37256090" class="c"><input type="checkbox" id="c-37256090" checked=""/><div class="controls bullet"><span class="by">alberth</span><span>|</span><a href="#37254323">root</a><span>|</span><a href="#37255169">parent</a><span>|</span><a href="#37256049">next</a><span>|</span><label class="collapse" for="c-37256090">[-]</label><label class="expand" for="c-37256090">[2 more]</label></div><br/><div class="children"><div class="content">Dumb question, then why not stick that API on a machine&#x2F;service that does need to be used 99% of time.</div><br/><div id="37257180" class="c"><input type="checkbox" id="c-37257180" checked=""/><div class="controls bullet"><span class="by">nonsense_stream</span><span>|</span><a href="#37254323">root</a><span>|</span><a href="#37256090">parent</a><span>|</span><a href="#37256049">next</a><span>|</span><label class="collapse" for="c-37257180">[-]</label><label class="expand" for="c-37257180">[1 more]</label></div><br/><div class="children"><div class="content">Because the API also needs some separation. The same reason you would want your services isolated in VMs instead of all running in one bare metal.</div><br/></div></div></div></div><div id="37256049" class="c"><input type="checkbox" id="c-37256049" checked=""/><div class="controls bullet"><span class="by">assimpleaspossi</span><span>|</span><a href="#37254323">root</a><span>|</span><a href="#37255169">parent</a><span>|</span><a href="#37256090">prev</a><span>|</span><a href="#37254784">next</a><span>|</span><label class="collapse" for="c-37256049">[-]</label><label class="expand" for="c-37256049">[3 more]</label></div><br/><div class="children"><div class="content">This sounds like a hack around a programming problem that needs to be fixed.</div><br/><div id="37258229" class="c"><input type="checkbox" id="c-37258229" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#37254323">root</a><span>|</span><a href="#37256049">parent</a><span>|</span><a href="#37254784">next</a><span>|</span><label class="collapse" for="c-37258229">[-]</label><label class="expand" for="c-37258229">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t even understand what that means.  What programming problem?</div><br/><div id="37259201" class="c"><input type="checkbox" id="c-37259201" checked=""/><div class="controls bullet"><span class="by">assimpleaspossi</span><span>|</span><a href="#37254323">root</a><span>|</span><a href="#37258229">parent</a><span>|</span><a href="#37254784">next</a><span>|</span><label class="collapse" for="c-37259201">[-]</label><label class="expand" for="c-37259201">[1 more]</label></div><br/><div class="children"><div class="content">If you rarely need an API but set something up like this just to rarely use it, it seems one needs to write their own code for this functionality and not go through hoops to run someone else&#x27;s. That just sounds so bizarre.</div><br/></div></div></div></div></div></div></div></div><div id="37254784" class="c"><input type="checkbox" id="c-37254784" checked=""/><div class="controls bullet"><span class="by">wnolens</span><span>|</span><a href="#37254323">parent</a><span>|</span><a href="#37255169">prev</a><span>|</span><a href="#37254654">next</a><span>|</span><label class="collapse" for="c-37254784">[-]</label><label class="expand" for="c-37254784">[1 more]</label></div><br/><div class="children"><div class="content">&gt; just spin up a VM and use it when you really need to. Always there, always when<p>and always charging you :)</div><br/></div></div><div id="37254654" class="c"><input type="checkbox" id="c-37254654" checked=""/><div class="controls bullet"><span class="by">turtlebits</span><span>|</span><a href="#37254323">parent</a><span>|</span><a href="#37254784">prev</a><span>|</span><a href="#37255375">next</a><span>|</span><label class="collapse" for="c-37254654">[-]</label><label class="expand" for="c-37254654">[1 more]</label></div><br/><div class="children"><div class="content">Just about every single company can benefit from scaling as traffic is never consistent 24&#x2F;7.  Most don&#x27;t bother as the effort outweighs the savings, but the potential is there.  Things like lambda and firecracker make it much easier.</div><br/></div></div><div id="37255375" class="c"><input type="checkbox" id="c-37255375" checked=""/><div class="controls bullet"><span class="by">sangnoir</span><span>|</span><a href="#37254323">parent</a><span>|</span><a href="#37254654">prev</a><span>|</span><a href="#37254646">next</a><span>|</span><label class="collapse" for="c-37255375">[-]</label><label class="expand" for="c-37255375">[1 more]</label></div><br/><div class="children"><div class="content">&gt; why do you need to spin up a VM only to tear it down compared to where you could just spin up a VM and use it when you really need to. Always there, always when<p>Firecracker has a much amaller overhead compared to regular VMs - which makes the (time and compute) costs of spinning up new VMs really low. This can be an advantage, depending on how chunky your workloads are - the less chunky they are - the more they can take advantage of finer-grained scaling.</div><br/></div></div><div id="37254646" class="c"><input type="checkbox" id="c-37254646" checked=""/><div class="controls bullet"><span class="by">lproven</span><span>|</span><a href="#37254323">parent</a><span>|</span><a href="#37255375">prev</a><span>|</span><a href="#37254515">next</a><span>|</span><label class="collapse" for="c-37254646">[-]</label><label class="expand" for="c-37254646">[2 more]</label></div><br/><div class="children"><div class="content">... &quot;snooty&quot;?<p><a href="https:&#x2F;&#x2F;www.merriam-webster.com&#x2F;dictionary&#x2F;snooty" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.merriam-webster.com&#x2F;dictionary&#x2F;snooty</a></div><br/><div id="37256952" class="c"><input type="checkbox" id="c-37256952" checked=""/><div class="controls bullet"><span class="by">zaps</span><span>|</span><a href="#37254323">root</a><span>|</span><a href="#37254646">parent</a><span>|</span><a href="#37254515">next</a><span>|</span><label class="collapse" for="c-37256952">[-]</label><label class="expand" for="c-37256952">[1 more]</label></div><br/><div class="children"><div class="content">snotty</div><br/></div></div></div></div><div id="37254515" class="c"><input type="checkbox" id="c-37254515" checked=""/><div class="controls bullet"><span class="by">Datagenerator</span><span>|</span><a href="#37254323">parent</a><span>|</span><a href="#37254646">prev</a><span>|</span><a href="#37254428">next</a><span>|</span><label class="collapse" for="c-37254515">[-]</label><label class="expand" for="c-37254515">[1 more]</label></div><br/><div class="children"><div class="content">IoT devices can execute short lived actions by calling remote Functions. The provider wants complete isolation and wipes these micro VMs after every few seconds and let&#x27;s the user pay for use. The response from these can be anything, voice, data or API responses.</div><br/></div></div><div id="37254428" class="c"><input type="checkbox" id="c-37254428" checked=""/><div class="controls bullet"><span class="by">artificial</span><span>|</span><a href="#37254323">parent</a><span>|</span><a href="#37254515">prev</a><span>|</span><a href="#37254908">next</a><span>|</span><label class="collapse" for="c-37254428">[-]</label><label class="expand" for="c-37254428">[1 more]</label></div><br/><div class="children"><div class="content">FaaS, function as a service. Depending on how software is packaged and the expectations the richness a VM, like Firecraker, provides may be useful. Many of these tradeoffs are for velocity, I can run X easily on Y.</div><br/></div></div><div id="37254908" class="c"><input type="checkbox" id="c-37254908" checked=""/><div class="controls bullet"><span class="by">willsmith72</span><span>|</span><a href="#37254323">parent</a><span>|</span><a href="#37254428">prev</a><span>|</span><a href="#37255475">next</a><span>|</span><label class="collapse" for="c-37254908">[-]</label><label class="expand" for="c-37254908">[1 more]</label></div><br/><div class="children"><div class="content">Instead of (or alongside) a CDN, you can deploy mini services around the world at the &quot;edge&quot;</div><br/></div></div><div id="37255475" class="c"><input type="checkbox" id="c-37255475" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#37254323">parent</a><span>|</span><a href="#37254908">prev</a><span>|</span><a href="#37255566">next</a><span>|</span><label class="collapse" for="c-37255475">[-]</label><label class="expand" for="c-37255475">[1 more]</label></div><br/><div class="children"><div class="content">&gt; However I hear buzz words like Lambda and Firecracker and and really have no idea where the usage is.<p>Sometimes you just want to slap some lines pf code together and run them from time to time, and don’t need a whole server (physical or virtual) for that.<p>Sometimes you have no idea if you’ll have to run a piece of code 100 times a day or 10’000’000 times a day.<p>Sometimes you don’t feel like paying a whole month for and maintaining a whole instance for a cronjob that lasts 20 seconds, and maybe it runs once a week.</div><br/></div></div></div></div><div id="37255566" class="c"><input type="checkbox" id="c-37255566" checked=""/><div class="controls bullet"><span class="by">getcrunk</span><span>|</span><a href="#37254323">prev</a><span>|</span><label class="collapse" for="c-37255566">[-]</label><label class="expand" for="c-37255566">[1 more]</label></div><br/><div class="children"><div class="content">So firecracker vs v8 isolates if only doing js or wasm?</div><br/></div></div></div></div></div></div></div></body></html>