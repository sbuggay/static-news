<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1738486854908" as="style"/><link rel="stylesheet" href="styles.css?v=1738486854908"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.ralfj.de/blog/2020/12/14/provenance.html">Pointers Are Complicated II, or: We need better language specs (2020)</a> <span class="domain">(<a href="https://www.ralfj.de">www.ralfj.de</a>)</span></div><div class="subtext"><span>ksec</span> | <span>44 comments</span></div><br/><div><div id="42905068" class="c"><input type="checkbox" id="c-42905068" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#42907035">next</a><span>|</span><label class="collapse" for="c-42905068">[-]</label><label class="expand" for="c-42905068">[1 more]</label></div><br/><div class="children"><div class="content">Great series of blog posts, I link them every chance I get.<p>Important to note that in the years since this post was written, provenance has become an explicitly accepted consideration of the Rust memory model ( <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;ptr&#x2F;index.html#provenance" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;ptr&#x2F;index.html#provenance</a> ), and standard APIs have been stabilized for working with pointers in ways that preserve provenance: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;ptr&#x2F;index.html#strict-provenance" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;ptr&#x2F;index.html#strict-provenan...</a></div><br/></div></div><div id="42907035" class="c"><input type="checkbox" id="c-42907035" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42905068">prev</a><span>|</span><a href="#42906378">next</a><span>|</span><label class="collapse" for="c-42907035">[-]</label><label class="expand" for="c-42907035">[1 more]</label></div><br/><div class="children"><div class="content">I found provenance easiest to think about after learning CHERI, since there the provenance isn&#x27;t just an abstract concept that allows better optimisation; it&#x27;s actually real data in the capability that affects whether it works at all, irrespective of optimisations. You literally <i>can&#x27;t</i> cast an integer to a pointer, even in assembly.</div><br/></div></div><div id="42906378" class="c"><input type="checkbox" id="c-42906378" checked=""/><div class="controls bullet"><span class="by">IgorPartola</span><span>|</span><a href="#42907035">prev</a><span>|</span><a href="#42905621">next</a><span>|</span><label class="collapse" for="c-42906378">[-]</label><label class="expand" for="c-42906378">[3 more]</label></div><br/><div class="children"><div class="content">I have some questions. First, do pointers that do not come from specifying a statically sized array also have provenance? That is if I say `char* c; size_t n = get_user_input(); c = malloc(n);` does c have provenance? If after the above I created an array like so `char str[n]` and then assigned such that it pointed to the same region of memory that malloc() returned, then would the provenance of both pointer be equal?<p>Also, in Rust why are pointer to integer casts allowed at all if they lose provenance?<p>Also, why exactly is one past end of bounds a valid pointer you can calculate?<p>Also, it seems like you cannot just create a random pointer to an unallocated address, not just that you can’t write to it. Is that correct?<p>Lastly, is provenance just a fancy way of saying metadata? Is there a reason something like “pointer metadata” or “object metadata” wasn’t used?</div><br/><div id="42906442" class="c"><input type="checkbox" id="c-42906442" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#42906378">parent</a><span>|</span><a href="#42905621">next</a><span>|</span><label class="collapse" for="c-42906442">[-]</label><label class="expand" for="c-42906442">[2 more]</label></div><br/><div class="children"><div class="content">&gt;That is if I say `char* c; size_t n = get_user_input(); c = malloc(n);` does c have provenance?<p>Yes.<p>&gt;If after the above I created an array like so `char str[n]` and then assigned such that it pointed to the same region of memory that malloc() returned, then would the provenance of both pointer be equal?<p>Yes.<p>&gt;Also, in Rust why are pointer to integer casts allowed at all if they lose provenance?<p>It would be a breaking change to remove the ability to cast. Instead Rust added API to extract the provenance when casting from ptr to int and then add provenance back when casting from int to ptr.<p>&gt;Also, why exactly is one past end of bounds a valid pointer you can calculate?<p>It&#x27;s useful to allow it to make `if (ptr &lt; end)` with exclusive `end` possible. The alternative of only allowing `if (ptr &lt;= end)` with inclusive `end` is not as trivial if it needs to handle empty ranges (the exclusive version can just use `end = start` to denote an empty range).<p>&gt;Lastly, is provenance just a fancy way of saying metadata?<p>Pointer metadata in Rust at least refers to a different thing, namely the second half of fat pointers. For slice pointers the fat pointer contains data ptr and length, so the length is the metadata. For trait object pointers the fat pointer contains data ptr and vtable ptr, so the vtable ptr is the metadata.</div><br/><div id="42906981" class="c"><input type="checkbox" id="c-42906981" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42906378">root</a><span>|</span><a href="#42906442">parent</a><span>|</span><a href="#42905621">next</a><span>|</span><label class="collapse" for="c-42906981">[-]</label><label class="expand" for="c-42906981">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s useful to allow it to make `if (ptr &lt; end)` with exclusive `end` possible. The alternative of only allowing `if (ptr &lt;= end)` with inclusive `end` is not as trivial if it needs to handle empty ranges (the exclusive version can just use `end = start` to denote an empty range).<p>As an aside: I find it fascinating that half-open ranges turn out to be - universally as far as I can tell - the right choice for ranges in software. As well as being able to store an empty range, they also allow you to calculate the length of the range by trivially subtracting end - start.</div><br/></div></div></div></div></div></div><div id="42905621" class="c"><input type="checkbox" id="c-42905621" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42906378">prev</a><span>|</span><a href="#42905481">next</a><span>|</span><label class="collapse" for="c-42905621">[-]</label><label class="expand" for="c-42905621">[32 more]</label></div><br/><div class="children"><div class="content">&gt; one of the three optimizations is incorrect ... but which one is it?<p>&gt; The final optimization notices that q is never written to<p>Isn&#x27;t it obviously this assumption that&#x27;s blatantly wrong? You have no clue q is never written to because the address was saved somewhere and you clearly have no idea what happened to the address afterward. It could&#x27;ve obviously been used to write to the variable. Is that so complicated?<p>This feels like saying &quot;I closed my eyes. I no longer see you. You are clearly not in front of me anymore, so I punch into the air and hit you. Which of my assumptions was wrong?&quot; Such a mystery!</div><br/><div id="42906947" class="c"><input type="checkbox" id="c-42906947" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#42905621">parent</a><span>|</span><a href="#42906390">next</a><span>|</span><label class="collapse" for="c-42906947">[-]</label><label class="expand" for="c-42906947">[2 more]</label></div><br/><div class="children"><div class="content">In the <i>input to the final optimization</i>, there is only one store between the place where q is allocated and the place where q is used.<p>That one store is clearly identified as going into p, not into q.<p>Therefore, it&#x27;s quite reasonable to conclude that q has not been changed.<p>If we weren&#x27;t allowed to conclude that, we would almost never be able to put stack variables into registers, and that would make even simple programs run a lot slower.<p>(The other point, which is another argument that it&#x27;s the second optimization that should be considered incorrect, is that the program before the final optimization has a store to p[1], which is an out-of-bounds access into an array, which should be considered an error in all reasonable programming languages.)</div><br/><div id="42907000" class="c"><input type="checkbox" id="c-42907000" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906947">parent</a><span>|</span><a href="#42906390">next</a><span>|</span><label class="collapse" for="c-42907000">[-]</label><label class="expand" for="c-42907000">[1 more]</label></div><br/><div class="children"><div class="content">&gt;In the input to the final optimization, there is only one store between the place where q is allocated and the place where q is used. That one store is clearly identified as going into p, not into q.<p>&gt; Therefore, it&#x27;s quite reasonable to conclude that q has not been changed.<p>No, that is in fact unreasonable and does not follow at all.<p>You are completely ignoring any relationships the program might have established between the two at the point at which *(p+1) is written to.<p>Namely, you are ignoring that the program has already established iq == ip at that point. Which means the program already established (uintptr_t)q == (uintptr_t)(p+1). Which means the program already established q == p + 1. Which means *q == *(p + 1). Thus in the last optimization you must assume *q may have been modified. Of course you (the compiler) are welcome to give up on analyzing that chain of logic at any point at which it seems too difficult, but if you break that chain of logic, you cannot make violating assumptions in a subsequent step.</div><br/></div></div></div></div><div id="42906390" class="c"><input type="checkbox" id="c-42906390" checked=""/><div class="controls bullet"><span class="by">Lvl999Noob</span><span>|</span><a href="#42905621">parent</a><span>|</span><a href="#42906947">prev</a><span>|</span><a href="#42905702">next</a><span>|</span><label class="collapse" for="c-42906390">[-]</label><label class="expand" for="c-42906390">[5 more]</label></div><br/><div class="children"><div class="content">I do not agree with you.<p>What you are saying is that compiler must keep the variable ordering on the stack the same. That is the only way that `&amp;(p+1) == &amp;q` would hold consistently.<p>Now if we have `char p[1] = {0}; int a; char q[1] = {0};` the compiler cannot move p and q together so that a can properly aligned with less padding (I assume alignment is a concern on stack space as well?). The compiler also cannot do any loop invariant hoisting. It cannot remove any unused variables. Because all of them can change the behavior of the program just be existing. Any random pointer could have been aliasing one of those positions.<p>Every single optimisation would require full program analysis to determine whether something could possibly alias. And if you do any non trivial pointer arithmetic (after integer casting) or use user input in it, you lose that. Not just in that place but everywhere in the program.</div><br/><div id="42906531" class="c"><input type="checkbox" id="c-42906531" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906390">parent</a><span>|</span><a href="#42905702">next</a><span>|</span><label class="collapse" for="c-42906531">[-]</label><label class="expand" for="c-42906531">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I do not agree with you. What you are saying is that compiler must keep the variable ordering on the stack the same. That is the only way that `&amp;(p+1) == &amp;q` would hold consistently.<p>I think we&#x27;re speaking past each other because that is in no way what I&#x27;m saying.<p>All I said was: there was a memory write... to an address... that came from an integer... that came from somewhere (a pointer). Since the compiler presumably has no idea where that &quot;somewhere&quot; was, it could&#x27;ve been q. It can&#x27;t prove that it isn&#x27;t q, because it knows that q&#x27;s address was taken somewhere, and it has no idea where that address went. Hence it can&#x27;t assume the target of the write can&#x27;t have been q.<p>This assumes nothing about stacks, frames, or the ordering of any variables. You could order them any way you want and what I said would hold. It&#x27;s literally just discussing how information could&#x27;ve flowed from one point to another.</div><br/><div id="42906574" class="c"><input type="checkbox" id="c-42906574" checked=""/><div class="controls bullet"><span class="by">Lvl999Noob</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906531">parent</a><span>|</span><a href="#42905702">next</a><span>|</span><label class="collapse" for="c-42906574">[-]</label><label class="expand" for="c-42906574">[3 more]</label></div><br/><div class="children"><div class="content">It can&#x27;t prove it isn&#x27;t q even if q&#x27;s address was never taken though. It does not matter that q&#x27;s address was taken. p+1 would still point to q. If you have a pointer in scope, you can no longer remove or reorder any write at all. Those pointers could have been pointing to volatile locations for all the compiler knows. If there is multithreading, it cannot remove any write at all since the other thread could have had a pointer to that location.<p>It no longer matters that a variable did not have its address taken at any point since that address could have been taken via pointer arithmetic from somewhere else.</div><br/><div id="42906600" class="c"><input type="checkbox" id="c-42906600" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906574">parent</a><span>|</span><a href="#42905702">next</a><span>|</span><label class="collapse" for="c-42906600">[-]</label><label class="expand" for="c-42906600">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It can&#x27;t prove it isn&#x27;t q even if q&#x27;s address was never taken though.<p>I was imprecise with the wording.<p>What I meant is that, when q&#x27;s address is taken and shoved into an integer, the compiler (assuming it gives up upon seeing integer conversion) fails to prove that the address points <i>provably outside</i> q on that path. Thus it needs to assume that the address <i>might</i>, in fact, <i>provably point inside</i> q (i.e. it <i>might</i> be <i>guaranteed</i> to overlap q). Thus it cannot assume q is unmodified.<p>If q&#x27;s address was never taken, then the compiler could prove that q&#x27;s address was unknown on that path, and thus could be anything. Because this proves there could exist an execution where the target doesn&#x27;t overlap q, then the compiler could assume that an unmodified q is a valid execution. i.e. it could assume q is unmodified.<p>To put it in perhaps clearer terms: when the address of q is untaken, that means the program&#x27;s (defined) behavior is completely invariant with respect to (i.e. symmetric w.r.t., i.e. independent of) q&#x27;s address. Thus it can act as if the target of the write is not q (...because we just established the program&#x27;s defined behavior is independent of q&#x27;s address). Whereas it <i>cannot</i> make that assumption when q&#x27;s address is leaked somewhere.<p>Does that make sense?</div><br/><div id="42907132" class="c"><input type="checkbox" id="c-42907132" checked=""/><div class="controls bullet"><span class="by">Lvl999Noob</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906600">parent</a><span>|</span><a href="#42905702">next</a><span>|</span><label class="collapse" for="c-42907132">[-]</label><label class="expand" for="c-42907132">[1 more]</label></div><br/><div class="children"><div class="content">Hmmm... that sounds like exposed provenance (<a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;std&#x2F;ptr&#x2F;index.html#exposed-provenance" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;std&#x2F;ptr&#x2F;index.html#exposed-...</a>) to me. When a pointer loses its provenance, its allocation is put in the global exposed list. Any pointer without a clear provenance then can alias any (all) of the exposed provenance allocations. What you are saying is that you want all pointers to behave this way. While that can prevent miscompiles, I would assume that that would also lead to massive slowdowns in runtime performance.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42905702" class="c"><input type="checkbox" id="c-42905702" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42905621">parent</a><span>|</span><a href="#42906390">prev</a><span>|</span><a href="#42905481">next</a><span>|</span><label class="collapse" for="c-42905702">[-]</label><label class="expand" for="c-42905702">[24 more]</label></div><br/><div class="children"><div class="content">How come? Assuming we&#x27;re in a function, the `q` in question has just been allocated on the stack, and its address never left the context of the fragment, e.g. was never used as an argument of any function call; even the `print` receives the value of `q[0]`, not the address. Nothing else should <i>know</i> where `q` even is, let alone modify it behind the scenes.<p>What am I missing?</div><br/><div id="42905906" class="c"><input type="checkbox" id="c-42905906" checked=""/><div class="controls bullet"><span class="by">jkrejcha</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42905702">parent</a><span>|</span><a href="#42905756">next</a><span>|</span><label class="collapse" for="c-42905906">[-]</label><label class="expand" for="c-42905906">[11 more]</label></div><br/><div class="children"><div class="content">Because for many conforming (not necessarily strictly conforming) programs, <i>should</i> and <i>does</i> are different things and many programs are written to be conforming rather than strictly conforming (hence why most non-trivial sane projects (including Clang in some cases, amusingly enough) builds themselves with flags that disable many of these style of checks).<p>The argument goes like this<p>Assuming that p lives at 0x0 and q lives at 0x1 (this is the only interesting case anyway, if this isn&#x27;t the case the program clearly prints nothing)...<p>p[0] = {0}
q[0] = {0}<p>Line 1: ip = undefined, iq = undefined<p>Line 2: ip = 0x0 + 1 = 0x1 (assigned), iq = undefined<p>Line 3: ip = 0x1, iq = 0x1 (assigned)<p>Line 4: ip = 0x1, iq = 0x1 (ip == iq, so take branch, goto line 5)<p>Line 5: ip = 0x1, iq = 0x1<p>- p[1] = 0x10.<p>- Because p([0]) is at 0x0, p[1] must be at 0x1<p>- (address of p[1]) = 0x1 and (address of q[0]) = 0x1 and 0x1 == 0x1<p>- Therefore because these pointers have the same address, these two objects obviously must alias each other at this point<p>Line 6: print(q[0]); -- should print 10 because p[1] = 10 which means q[0] = 10 which because they&#x27;re at the same location<p>The argument against this is that a pointer really is a address and some hidden data that tracks what allocation it was, therefore you can&#x27;t treat p[1] as equaling q[0]. I find myself tending to agree with the original argument (this is C after all) rather than this counterargument, but I understand it nonetheless.<p>This touches a pain point on the evolution of C in general. C is a lot of the times the domain of stuff of it being a &quot;portable assembler&quot;[1] which many programmers who are writing C code for things like operating system kernels and other systems level code expect and like, but because a lot of these make non-strictly conforming programs, many popular compilers are writing optimizations in their evolution that attempt to target strictly conforming programs only at the expense of... well a lot of the reason people use (and have to use) C.<p>[1]: Many might take issue with the characterization of C, but it&#x27;s how it was characterized even in things like the 1st ed of &quot;The C Programming Language&quot;.</div><br/><div id="42906645" class="c"><input type="checkbox" id="c-42906645" checked=""/><div class="controls bullet"><span class="by">jkrejcha</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42905906">parent</a><span>|</span><a href="#42906234">next</a><span>|</span><label class="collapse" for="c-42906645">[-]</label><label class="expand" for="c-42906645">[1 more]</label></div><br/><div class="children"><div class="content">Note: the fact that this was actually done through q[0] rather than p[1] isn&#x27;t really material for the argument, but this was an error I made in the original argumentation (that I can&#x27;t go back and edit now) so just wanting to make that correction.<p>If anything, it makes the argument stronger, as the program as written is valid syntactically and semantically rather than relying on undefined behavior.</div><br/></div></div><div id="42906234" class="c"><input type="checkbox" id="c-42906234" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42905906">parent</a><span>|</span><a href="#42906645">prev</a><span>|</span><a href="#42906001">next</a><span>|</span><label class="collapse" for="c-42906234">[-]</label><label class="expand" for="c-42906234">[5 more]</label></div><br/><div class="children"><div class="content">Ah, I see, it&#x27;s trivial out-of-bounds array access, and the compiler&#x27;s inability to notice that. The cause of innumerable data corruption bugs, crashes, and exploits.<p>I wish C did not have <i>implicit</i> pointer aliasing; it already has explicit aliasing via `union`. (And a different handling of nulls. And no UD. And a pony. Sadly, I don&#x27;t have a time machine to travel back to 1969.)</div><br/><div id="42906658" class="c"><input type="checkbox" id="c-42906658" checked=""/><div class="controls bullet"><span class="by">jkrejcha</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906234">parent</a><span>|</span><a href="#42906513">next</a><span>|</span><label class="collapse" for="c-42906658">[-]</label><label class="expand" for="c-42906658">[2 more]</label></div><br/><div class="children"><div class="content">So worth noting that the original code actually exhibits no undefined behavior as written (only q is accessed). I erred in my original argument by looking at the &quot;first optimization&quot; being applied.<p>I&#x27;d still argue that the third optimization would be incorrect here, if a program can determine that p+1 = q and replacing q with p+1 is legal, then it obviously knows that those two locations alias (kinda by definition of being able to replace that) and therefore can&#x27;t apply the 3rd optimization.</div><br/><div id="42907099" class="c"><input type="checkbox" id="c-42907099" checked=""/><div class="controls bullet"><span class="by">fuhsnn</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906658">parent</a><span>|</span><a href="#42906513">next</a><span>|</span><label class="collapse" for="c-42907099">[-]</label><label class="expand" for="c-42907099">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I&#x27;d still argue that the third optimization would be incorrect here<p>That&#x27;s my take as well, to apply it more defensively, any writes cannot be proven in-bounds should be considered clobbering q&#x27;s state.</div><br/></div></div></div></div><div id="42906513" class="c"><input type="checkbox" id="c-42906513" checked=""/><div class="controls bullet"><span class="by">jkrejcha</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906234">parent</a><span>|</span><a href="#42906658">prev</a><span>|</span><a href="#42906001">next</a><span>|</span><label class="collapse" for="c-42906513">[-]</label><label class="expand" for="c-42906513">[2 more]</label></div><br/><div class="children"><div class="content">I mean yes in this case the problem is you&#x27;re doing a dereference out-of-bounds, which makes a program not strictly conforming.<p>The problem tends to be is that the real world is much more (essentially) complex and the domain of C is that which needs to be able to deal with that essential complexity, which includes things like type punning and int-to-ptr casts and the like which makes programs not strictly conforming. As it stands, a lot of these rules make it impossible to implement a lot of... C libraries... in ISO C, let alone things like operating system kernels and the like.<p>&gt; And no UD<p>I assume this means undefined behavior? But in any case, undefined behavior is okay to have in a language, it&#x27;s good for when there are no portable semantics for a particular operation or failure mode[1]. It&#x27;s generally essential (although some undefined behaviors would definitely be better served being implementation defined or unspecified).<p>It is also okay for programmers to eschew this portability (so if they want to narrow their focus from &quot;anything that can run strictly conforming C&quot; to a superset that targets say a specific memory model or set of processors).<p>[1]: For example, at an extreme example, what happens if the CPU starts burning up? Obviously the standard can&#x27;t describe such semantics for how a program should behave in the face of this.</div><br/><div id="42906607" class="c"><input type="checkbox" id="c-42906607" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906513">parent</a><span>|</span><a href="#42906001">next</a><span>|</span><label class="collapse" for="c-42906607">[-]</label><label class="expand" for="c-42906607">[1 more]</label></div><br/><div class="children"><div class="content">I agree, type punning exists, this is why I mentioned `union`, invented to make some type punning easier. An <i>explicit</i> mechanism like that is essential. Doing it implicitly is, to my mind, too dangerous to be beneficial.<p>Same with undefined behavior. I&#x27;m fine with <i>implementation-dependent</i> behavior (like what size is `int`, etc). But modern compilers see UD and feel free to do anything, even removing the code in question. Such things should not be silent, or even a warning. Instead it should be something like `unsafe` sections in Rust: &quot;I know what I&#x27;m doing, the usual safety assumptions are irrelevant here, do what I literally say&quot;. Doing weird things is sometimes required e.g. to handle memory-mapped hardware registers, etc. But such areas should be clearly delineated, for they are usually few. They also tend to not be portable.<p>A CPU burning up, hardware malfunctioning, etc is usually a situation where all bets are off. An unanticipated pointer aliasing in a trivial program running on perfectly working hardware is a different case.</div><br/></div></div></div></div></div></div><div id="42906001" class="c"><input type="checkbox" id="c-42906001" checked=""/><div class="controls bullet"><span class="by">RossBencina</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42905906">parent</a><span>|</span><a href="#42906234">prev</a><span>|</span><a href="#42905756">next</a><span>|</span><label class="collapse" for="c-42906001">[-]</label><label class="expand" for="c-42906001">[4 more]</label></div><br/><div class="children"><div class="content">&gt; which many programmers who are writing C code for things like operating system kernels and other systems level code expect and like<p>Strong agree. Isn&#x27;t this the whole point of C? I don&#x27;t have any insight into why the standards committee could see it any other way. It seems like the whole situation got hijacked by optimization writers who had somehow lost touch with their users. But maybe there is a more coherent explanation of how this happend.</div><br/><div id="42906245" class="c"><input type="checkbox" id="c-42906245" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906001">parent</a><span>|</span><a href="#42905756">next</a><span>|</span><label class="collapse" for="c-42906245">[-]</label><label class="expand" for="c-42906245">[3 more]</label></div><br/><div class="children"><div class="content">Do you suppose that most C programmers enjoy the fact that random aliasing and free out-of-bounds array access can lead to silent data corruption, as shown in the example?</div><br/><div id="42906447" class="c"><input type="checkbox" id="c-42906447" checked=""/><div class="controls bullet"><span class="by">IgorPartola</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906245">parent</a><span>|</span><a href="#42905756">next</a><span>|</span><label class="collapse" for="c-42906447">[-]</label><label class="expand" for="c-42906447">[2 more]</label></div><br/><div class="children"><div class="content">This example isn’t showing silent data corruption due to out of bounds array access. It is showing that LLVM and others do not correctly apply optimizations to the original code. The program is correct and does what it’s supposed to in the original example.</div><br/><div id="42906675" class="c"><input type="checkbox" id="c-42906675" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906447">parent</a><span>|</span><a href="#42905756">next</a><span>|</span><label class="collapse" for="c-42906675">[-]</label><label class="expand" for="c-42906675">[1 more]</label></div><br/><div class="children"><div class="content">You mean, accessing an array member past the declared array bounds and overwriting another variable that happens to be allocated right next to it is what the programmer should have consciously planned to do here?<p>IMHO, a planned aliasing would look like a union. The declaration we see does not even guarantee that q follows p in the address space, or maybe even that p and q are adjacent.<p>(I know that int[0] sort of means &quot;no bounds&quot;, and I think it should be an error for a stack-allocated variable which ought to have definite bounds.)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42905756" class="c"><input type="checkbox" id="c-42905756" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42905702">parent</a><span>|</span><a href="#42905906">prev</a><span>|</span><a href="#42905481">next</a><span>|</span><label class="collapse" for="c-42905756">[-]</label><label class="expand" for="c-42905756">[12 more]</label></div><br/><div class="children"><div class="content">&gt; Nothing else should know where `q` even is, let alone modify it behind the scenes. What am I missing?<p>The variable iq knows where q is, no?<p><pre><code>  uintptr_t iq = (uintptr_t)q;
</code></pre>
If you (the compiler) can&#x27;t analyze beyond that, that&#x27;s the end of the story: the address escaped <i>somewhere</i>.<p>If you can... well then not only that, but a decision was made on it:<p><pre><code>  if (iq == ip)
</code></pre>
And then a write was performed on an address that you clearly can&#x27;t prove was uncontaminated with q&#x27;s address:<p><pre><code>  *(char*)iq = 10;</code></pre></div><br/><div id="42906369" class="c"><input type="checkbox" id="c-42906369" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42905756">parent</a><span>|</span><a href="#42906019">next</a><span>|</span><label class="collapse" for="c-42906369">[-]</label><label class="expand" for="c-42906369">[4 more]</label></div><br/><div class="children"><div class="content">In the original code, it stores through q.<p>In the optimized example:<p><pre><code>  *(char*)iq = 10 -&gt; *(char*)(uintptr_t)(p + 1) = 10
</code></pre>
After that optimization pass, there is no store to q. C assumes that you can not store to a different object without doing out-of-bounds pointer arithmetic and that out-of-bounds pointer arithmetic is illegal, therefore it assumes that q is not stored during that store.<p>The problem is that the optimizer replaced a plain store through q with a illegal out-of-bounds pointer arithmetic store (because it was sneakily done in non-pointer land). That causes the &quot;safety&quot; checking (that can check less because of that invariant) to be insufficient. The problem is not leaking q, it is blindly replacing a legal construct with an &quot;illegal&quot; construct.<p>The specific problem here being the pointer cast which turned a integer into a pointer. You have no clue where that points to without analyzing the value of that integer. As such, the assumption should be: &quot;can store anywhere, all loads everywhere in the program are suspect&quot; when that occurs. You can then utilize pointer provenance to prove that &quot;no, we do know where this can point to, the optimization&#x2F;caching party is back on&quot;.<p>Leaking did not occur because they saved the address of q. &quot;Leaking&quot; occurred because they cast a integer to a pointer which can &quot;leak&quot; a pointer to literally anything.</div><br/><div id="42906790" class="c"><input type="checkbox" id="c-42906790" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906369">parent</a><span>|</span><a href="#42906019">next</a><span>|</span><label class="collapse" for="c-42906790">[-]</label><label class="expand" for="c-42906790">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Leaking did not occur because they saved the address of q. &quot;Leaking&quot; occurred because they cast a integer to a pointer which can &quot;leak&quot; a pointer to literally anything.<p>No - please see the following comment, I respond to this same comment there: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42906600">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42906600</a></div><br/><div id="42907110" class="c"><input type="checkbox" id="c-42907110" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906790">parent</a><span>|</span><a href="#42906019">next</a><span>|</span><label class="collapse" for="c-42907110">[-]</label><label class="expand" for="c-42907110">[2 more]</label></div><br/><div class="children"><div class="content">I agree that you could choose semantics such that as soon as you take the address of a object that any store anywhere could alias it, so it is no longer legal to ever cache the value unless you prove the store does not overlap.<p>But, the key thing here is that if the programmer wrote:<p><pre><code>  *(p+1) = 10;
  print(q[0]); 
</code></pre>
It is entirely reasonable and legal for the compiler to optimize that to:<p><pre><code>  *(p+1) = 10;
  print(0);
</code></pre>
Because the abstract model says that stores to one object can not alias another object. You, as the programmer, are required to not author out-of-bounds stores and a good compiler could detect illegal constructs.<p>However, in this case, the optimizer transformed a legal, well-formed construct into a illegal construct and then optimized as if it was always a illegal construct. Focusing on directly preventing such transforms and why such transforms should be illegal (pointing out the legal -&gt; illegal thing they enable) minimizes the changes needed to the model.</div><br/><div id="42907292" class="c"><input type="checkbox" id="c-42907292" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42907110">parent</a><span>|</span><a href="#42906019">next</a><span>|</span><label class="collapse" for="c-42907292">[-]</label><label class="expand" for="c-42907292">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But, the key thing here is that if the programmer wrote *(p+1) = 10; print(q[0]); it is entirely reasonable and legal for the compiler to optimize that to *(p+1) = 10; print(0); Because the abstract model says that stores to one object can not alias another object.<p><i>If</i> the programmer wrote that... but that&#x27;s not what the programmer wrote. The programmer wrote *(char*)iq = 10 which was provably (!) equivalent to <i>both</i> *(char*)(uintptr_t)q = 10 as well as *(char*)(uintptr_t)(p+1) = 10. That means the compiler can&#x27;t just replace it with the latter while ignoring the former -- it must carry the aliasing constraints implied by the former into the latter.<p>&gt; However, in this case, the optimizer transformed a legal, well-formed construct into a illegal construct and then optimized as if it was always a illegal construct. Focusing on directly preventing such transforms and why such transforms should be illegal (pointing out the legal -&gt; illegal thing they enable) minimizes the changes needed to the model.<p>I see where the confusion is.<p>You&#x27;re missing this sentence: <i>&quot;I am using C syntax here just as a convenient way to write programs in LLVM IR.&quot;</i> The intermediate transformations you see there <i>are not C</i> code.<p>You&#x27;re looking at the compiler as &quot;optimize C to faster C, then codegen&quot;. In which case you can blame step 2 (the replacement of *(char*)(uintptr_t)(p+1) with *(p+1)) as the violating culprit, due to strict aliasing.<p>Which... would be fine if you view it that way, I don&#x27;t mind too much if you do.<p>But I&#x27;m looking at the compiler as &quot;codegen for C, then optimize&quot; (which is closer to what LLVM does), in which case the &quot;*(p+1) = 10&quot; you see in the 2nd optimization step isn&#x27;t <i>C</i> code anymore, it&#x27;s LLVM IR that the author tried to transcribe in some made-up language that superficially resembles C! You can&#x27;t really say &quot;this is a legal transformation&quot; anymore because it&#x27;s not the C code anymore, it&#x27;s just some internal compiler gibberish that someone tried to display with a imitation-C syntax to make it easier to read. The aliasing rules no longer apply there, because it&#x27;s not actually C... it&#x27;s LLVM IR.<p>Which is why I said &quot;q is never written to&quot; (step 3) is the violation. Because as I saw it, step 2 was fine, because <i>it wasn&#x27;t C</i>. In fact it would be illegal for the compiler to transform the original program into that and continue to treat that as equivalent C.</div><br/></div></div></div></div></div></div></div></div><div id="42906019" class="c"><input type="checkbox" id="c-42906019" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42905756">parent</a><span>|</span><a href="#42906369">prev</a><span>|</span><a href="#42905481">next</a><span>|</span><label class="collapse" for="c-42906019">[-]</label><label class="expand" for="c-42906019">[7 more]</label></div><br/><div class="children"><div class="content">That&#x27;s sort of the crux of the issue: what constitutes exposing a pointer?<p>Half the time, within the compiler, a pointer-to-integer conversion is essentially a nop cast instruction that can be optimized away if unused or freely deleted (e.g., roundtrip pointer-to-integer-to-pointer) or slide addressing information before and after the pointer. The other half the time, it&#x27;s an important leaks-the-address operation that can&#x27;t be triggered because, you know, that causes things to be leaked. It&#x27;s Schrödinger&#x27;s side effects, they both matter and don&#x27;t matter, and you don&#x27;t know if it ends up doing so or not until you open the box. It&#x27;s a complete mess, and ultimately entirely incoherent, inconsistent semantics that is begging for a fix.<p>Even worse, if you read all the compiler documentation, you&#x27;ll find strong assertions that provenance is carried solely by data dependence (including through integers). The compiler optimizations for integers explicitly disclaim preservation of data dependence, which is why the leading model for pointer provenance (PVNI) is &quot;integers don&#x27;t have provenance, therefore pointer-to-int is an address-exposing operation.&quot; But even more annoyingly, the semantics at the IR level imply that memory is untyped, which kind of means every load or store of a pointer is an implicit integer conversion, but that doesn&#x27;t actually happen in practice, except that memory is frequently converted to an integer if you&#x27;re just copying from one block of memory to another and it&#x27;s just a mess of several optimizations are broken in weird, unexpected ways that no one really realized until people started trying to apply formal semantics to compiler optimizations and found these soundness holes.<p>And the most annoying part of all are the people sitting on the sidelines yelling at us &quot;pointers are integers, why are you guys making this all so complicated?&quot;</div><br/><div id="42906885" class="c"><input type="checkbox" id="c-42906885" checked=""/><div class="controls bullet"><span class="by">jkrejcha</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906019">parent</a><span>|</span><a href="#42906967">next</a><span>|</span><label class="collapse" for="c-42906885">[-]</label><label class="expand" for="c-42906885">[4 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s sort of the crux of the issue: what constitutes exposing a pointer?<p>A lot of the people who subscribe to &quot;optimization 3 is clearly wrong&quot; make the argument that the answer is... everything is always exposed, whether it be (uintptr_t)0x42, some valid stack pointer, or anywhere else for that matter. This certainly tracks with the model that many C (and systems programmers, more generally) expect the language semantics to represent.<p>It disables a lot of optimizations to make these assumptions, but the argument generally is that many of those optimizations were likely extremely tenuous in the first place and have potentially dubious benefits outside of contrived benchmarks. This also was the point of the &quot;restrict&quot; and &quot;register&quot; keywords to tell the compiler &quot;hey you can assume these things don&#x27;t alias with each other&quot; or &quot;hey use registers for this variable&quot;, etc.<p>It&#x27;s clear that a demand for this type of language semantics exists, as most large projects you can probably think of have flags that disable a lot of the alias assumptions (everything from Linux to Firefox to Clang (in some cases) to Chrome, etc) and some compilers (such as MSVC) don&#x27;t bother with many of the alias assumptions in the first place (which affects anything built with those compilers).</div><br/><div id="42906922" class="c"><input type="checkbox" id="c-42906922" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906885">parent</a><span>|</span><a href="#42906967">next</a><span>|</span><label class="collapse" for="c-42906922">[-]</label><label class="expand" for="c-42906922">[3 more]</label></div><br/><div class="children"><div class="content">&gt; A lot of the people who subscribe to &quot;optimization 3 is clearly wrong&quot; make the argument that the answer is... everything is always exposed<p>For anyone reading this, note that that&#x27;s <i>not</i> what I&#x27;m arguing -- my argument very specifically depends on the exposure of q: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42906600">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42906600</a></div><br/><div id="42906974" class="c"><input type="checkbox" id="c-42906974" checked=""/><div class="controls bullet"><span class="by">jkrejcha</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906922">parent</a><span>|</span><a href="#42906967">next</a><span>|</span><label class="collapse" for="c-42906974">[-]</label><label class="expand" for="c-42906974">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, this does make the &quot;read pointer from user input&quot; case (which is actually sometimes useful) a bit weird however but it seems pretty obvious that ptr-to-int should probably be exposing at the very least</div><br/><div id="42907042" class="c"><input type="checkbox" id="c-42907042" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906974">parent</a><span>|</span><a href="#42906967">next</a><span>|</span><label class="collapse" for="c-42907042">[-]</label><label class="expand" for="c-42907042">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Yeah, this does make the &quot;read pointer from user input&quot; case (which is actually sometimes useful) a bit weird<p>I think it works out quite reasonably and elegantly, actually.<p>If you can prove that an address wasn&#x27;t leaked -- then you can assume the program behavior is independent of any pointer read from user input, and thus optimize as if the pointer wasn&#x27;t read from user input.<p>Otherwise, you assume the address <i>was</i> leaked, and thus must act as if the target might overlap said address.<p>&gt; however but it seems pretty obvious that ptr-to-int should probably be exposing at the very least<p>I don&#x27;t think that&#x27;s necessary, but it&#x27;s certainly a valid way to write a compiler. (I say this because I don&#x27;t think (void)(uintptr_t)ptr; should be considered exposing, for example.)</div><br/></div></div></div></div></div></div></div></div><div id="42906967" class="c"><input type="checkbox" id="c-42906967" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906019">parent</a><span>|</span><a href="#42906885">prev</a><span>|</span><a href="#42905481">next</a><span>|</span><label class="collapse" for="c-42906967">[-]</label><label class="expand" for="c-42906967">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really get if you&#x27;re agreeing or disagreeing with me (or just discussing something else entirely), but to answer this bit:<p>&gt; That&#x27;s sort of the crux of the issue: what constitutes exposing a pointer?<p>Doesn&#x27;t the answer ought to be that an exposure of a (source) pointer P1 to some (target) pointer P2 ought to be &quot;any potential dependence of P2 on P1&quot;?<p>If you can prove the two are independent, then you can assume P1 is not exposed to P2. That is the case when, for example, the address P1 is never used anywhere. It is also the case when P1 is converted to an integer, but then the integer is discarded immediately. It&#x27;s up to you how deeply you want to analyze the dataflow -- and it&#x27;s perfectly fine if you want to assume integers lack provenance -- but whatever you do needs to needs to be consistent with the above.<p>All of which is to say, I don&#x27;t see how &quot;what constitutes exposing a pointer&quot; would be a hard question.</div><br/><div id="42907149" class="c"><input type="checkbox" id="c-42907149" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#42905621">root</a><span>|</span><a href="#42906967">parent</a><span>|</span><a href="#42905481">next</a><span>|</span><label class="collapse" for="c-42907149">[-]</label><label class="expand" for="c-42907149">[1 more]</label></div><br/><div class="children"><div class="content">&gt; All of which is to say, I don&#x27;t see how &quot;what constitutes exposing a pointer&quot; would be a hard question.<p>It&#x27;s a hard question because any coherent semantics you come up with breaks optimizations that are obviously correct™. This is difficult to convey in toy examples, because in toy examples, there&#x27;s clearly enough information present that the optimizer could do the right thing™ if it were smart enough.<p>The other thing to keep in mind is that optimization generally works on semi-mangled forms of the source code, so if you have a pointer-to-integer that has no use at the IR level, that doesn&#x27;t necessarily mean that the pointer-to-integer had no use at the source code level (and same for the converse, incidentally--the IR might materialize uses that didn&#x27;t exist at the source code level).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42905481" class="c"><input type="checkbox" id="c-42905481" checked=""/><div class="controls bullet"><span class="by">grandempire</span><span>|</span><a href="#42905621">prev</a><span>|</span><a href="#42904922">next</a><span>|</span><label class="collapse" for="c-42905481">[-]</label><label class="expand" for="c-42905481">[3 more]</label></div><br/><div class="children"><div class="content">Certain C optimizations are difficult to implement due to pointers. But that doesn&#x27;t make pointers themselves complicated.<p>Most of the C community agrees that strict aliasing assumptions are more trouble than they are worth.</div><br/><div id="42905611" class="c"><input type="checkbox" id="c-42905611" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#42905481">parent</a><span>|</span><a href="#42904922">next</a><span>|</span><label class="collapse" for="c-42905611">[-]</label><label class="expand" for="c-42905611">[2 more]</label></div><br/><div class="children"><div class="content">Strict aliasing isn&#x27;t the root problem here, because Rust, which doesn&#x27;t have C-style strict aliasing, would similarly exhibit the same theoretical miscompilation in the absence of provenance.</div><br/><div id="42905787" class="c"><input type="checkbox" id="c-42905787" checked=""/><div class="controls bullet"><span class="by">grandempire</span><span>|</span><a href="#42905481">root</a><span>|</span><a href="#42905611">parent</a><span>|</span><a href="#42904922">next</a><span>|</span><label class="collapse" for="c-42905787">[-]</label><label class="expand" for="c-42905787">[1 more]</label></div><br/><div class="children"><div class="content">strict aliasing is an example of questionable optimizations from hard to verify assumptions.</div><br/></div></div></div></div></div></div><div id="42904922" class="c"><input type="checkbox" id="c-42904922" checked=""/><div class="controls bullet"><span class="by">quuxplusone</span><span>|</span><a href="#42905481">prev</a><span>|</span><a href="#42906961">next</a><span>|</span><label class="collapse" for="c-42904922">[-]</label><label class="expand" for="c-42904922">[2 more]</label></div><br/><div class="children"><div class="content">(2020)</div><br/><div id="42904935" class="c"><input type="checkbox" id="c-42904935" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#42904922">parent</a><span>|</span><a href="#42906961">next</a><span>|</span><label class="collapse" for="c-42904935">[-]</label><label class="expand" for="c-42904935">[1 more]</label></div><br/><div class="children"><div class="content">Added. Thanks!</div><br/></div></div></div></div><div id="42906961" class="c"><input type="checkbox" id="c-42906961" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42904922">prev</a><span>|</span><label class="collapse" for="c-42906961">[-]</label><label class="expand" for="c-42906961">[1 more]</label></div><br/><div class="children"><div class="content">What this really says is that C giving one-past-the-end pointers meaningful semantics may have been a mistake. So was trying to give aliasing of writable objects meaningful semantics.</div><br/></div></div></div></div></div></div></div></body></html>