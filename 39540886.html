<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709197271225" as="style"/><link rel="stylesheet" href="styles.css?v=1709197271225"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/ZigEmbeddedGroup/microzig">MicroZig: Unified abstraction layer and HAL for Zig on several microcontrollers</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>homarp</span> | <span>50 comments</span></div><br/><div><div id="39541421" class="c"><input type="checkbox" id="c-39541421" checked=""/><div class="controls bullet"><span class="by">MatthiasPortzel</span><span>|</span><a href="#39543854">next</a><span>|</span><label class="collapse" for="c-39541421">[-]</label><label class="expand" for="c-39541421">[5 more]</label></div><br/><div class="children"><div class="content">I started a new project with MicroZig just the other week. It’s working (with the RP2040), and that alone is a huge deal, since writing Zig is much more ergonomic than C with Arduino. It makes cross-compiling for testing in simulation locally trivial as well.<p>However, the project is still not very mature. They just refactored into the repo you see since I started using it. Support for RP2040 is good, but the HAL for other microcontrollers seems less supported. (And it seems to be written in such a way that code isn’t shared between HALs for different microcontrollers.) It’s targeting stable Zig (instead of HEAD), which is an unusual choice for Zig projects, since Zig is also in an immature state and updates rapidly. There’s zero documentation except for the source, but that’s par for Zig projects.<p>Zig has the potential to be huge for embedded, once these APIs are fleshed out and stabilize. It’s already more enjoyable than writing C.</div><br/><div id="39542726" class="c"><input type="checkbox" id="c-39542726" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#39541421">parent</a><span>|</span><a href="#39545409">next</a><span>|</span><label class="collapse" for="c-39542726">[-]</label><label class="expand" for="c-39542726">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m interested in this too, though I&#x27;ve had mixed experiences in the past using third party HALs for microcontrollers only to discover that they have gaps in API coverage or can only expose the most common use-cases. There was always lot of examples and documentation for the &quot;easy&quot; stuff like GPIOs, timers, ADCs, serial port, etc, but once you got into USB, Ethernet, or RTOS integration then things rapidly got much scarier.</div><br/></div></div><div id="39545409" class="c"><input type="checkbox" id="c-39545409" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#39541421">parent</a><span>|</span><a href="#39542726">prev</a><span>|</span><a href="#39544692">next</a><span>|</span><label class="collapse" for="c-39545409">[-]</label><label class="expand" for="c-39545409">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Support for RP2040 is good,<p>I&#x27;ve done a fair bit of stuff with embedded Rust and the main reason for this is manufacturer documentation. The RP2040 is really in its own tier of documentation quality, nothing comes close. Other chipsets are so bad that the Rust SVD codegen has a way for maintainers to fix errata.<p>I&#x27;ve concluded that I&#x27;m only going to use RP2040s going forward.</div><br/></div></div><div id="39544692" class="c"><input type="checkbox" id="c-39544692" checked=""/><div class="controls bullet"><span class="by">tredre3</span><span>|</span><a href="#39541421">parent</a><span>|</span><a href="#39545409">prev</a><span>|</span><a href="#39542108">next</a><span>|</span><label class="collapse" for="c-39544692">[-]</label><label class="expand" for="c-39544692">[1 more]</label></div><br/><div class="children"><div class="content">Arduino is C++, not C! Of course that changes nothing to what you said :) .</div><br/></div></div><div id="39542108" class="c"><input type="checkbox" id="c-39542108" checked=""/><div class="controls bullet"><span class="by">wredue</span><span>|</span><a href="#39541421">parent</a><span>|</span><a href="#39544692">prev</a><span>|</span><a href="#39543854">next</a><span>|</span><label class="collapse" for="c-39542108">[-]</label><label class="expand" for="c-39542108">[1 more]</label></div><br/><div class="children"><div class="content">I just recently switched off stable to 0.12 and I honestly didn’t run in to too much in the way of changes. It is a bit unusual for zig projects currently BUT zig changes are slowing.<p>Additionally, Andrew himself has stated he wants 0.12 to be a version where zig devs should feel comfortable pinning to stable. I know stable now is 0.11, but the changes are not egregious at the moment. Not sure if that’s still the deal.</div><br/></div></div></div></div><div id="39543854" class="c"><input type="checkbox" id="c-39543854" checked=""/><div class="controls bullet"><span class="by">jeff_ciesielski</span><span>|</span><a href="#39541421">prev</a><span>|</span><a href="#39541306">next</a><span>|</span><label class="collapse" for="c-39543854">[-]</label><label class="expand" for="c-39543854">[13 more]</label></div><br/><div class="children"><div class="content">I used Zig (not MicroZig, just rolled my own HAL) for the bootloader and firmware on a soft RISC-V SOC + custom peripherals recently and had somewhat mixed, though positive feelings about it.<p>On the positive side:<p>- As a &#x27;safer c&#x27;, getting things up and running was a breeze, writing code largely felt intuitive.<p>- The additions to C (slices&#x2F;iterators, enhanced structs, arbitrarily sized integers) are excellent<p>- It produces fairly small firmware images (useful when stuffing a boot rom in logic&#x2F;EBRAM)<p>- Easier (than C IMO) to get up and running with formatted IO vs retargeting libc<p>- Comptime is neat, and you can build some decent low-cost abstractions with it (ex: I built a comptime heavy write-through cache for key-value  storage that required very little overhead and largely self-generated based on a simple struct)<p>- I really enjoy the use of structs for function+data organization. It maps well to hardware instances, giving you an &#x27;object&#x27; like feeling without OOP ick.<p>On the negative side:<p>- The compiler is still a seriously moving target. Upgrading sometimes meant rather large refactors.<p>- Documentation is somewhat poor IMO.<p>- As a long time user of Nim (including on really lean embedded targets), compared to hygienic macros, comptime falls way short.<p>- The lack of first class interfaces&#x2F;traits&#x2F;typeclasses is not my favorite.  The currently suggested alternatives are so un-ergonomic I&#x27;d almost call them hostile.<p>All-in-all, I&#x27;m excited to see where Zig ends up. After nearly 20 years writing embedded code I&#x27;m really (really really really) tired of C. The embedded systems community really needs to embrace better tools.</div><br/><div id="39544164" class="c"><input type="checkbox" id="c-39544164" checked=""/><div class="controls bullet"><span class="by">AceJohnny2</span><span>|</span><a href="#39543854">parent</a><span>|</span><a href="#39544699">next</a><span>|</span><label class="collapse" for="c-39544164">[-]</label><label class="expand" for="c-39544164">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>After nearly 20 years writing embedded code I&#x27;m really (really really really) tired of C. The embedded systems community really needs to embrace better tools.</i><p>Hear hear, brother!<p>I get particularly frustrated about the second point, and I&#x27;ve made it my career goal to get my teams to update their tools and processes. For example, when I joined my current team, <i>they didn&#x27;t compile debug symbols and didn&#x27;t know how to use a debugger on our system!</i> Hell, in 2024 I still have colleagues who prefer to use a .dis and .map file than leverage the debug symbols... &quot;What is this &quot;mixed code and disassembly&quot; display you speak of&quot;</div><br/><div id="39547112" class="c"><input type="checkbox" id="c-39547112" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#39543854">root</a><span>|</span><a href="#39544164">parent</a><span>|</span><a href="#39544699">next</a><span>|</span><label class="collapse" for="c-39547112">[-]</label><label class="expand" for="c-39547112">[2 more]</label></div><br/><div class="children"><div class="content">I know people who insist on putting register addresses (in hex) in their code rather than make a variable because &quot;it&#x27;s easier to debug by comparing to the user guide. If it was a variable, you would have to look up its value every time&quot;. It looks somewhat like this:<p><pre><code>   *(int*)(0xf003) |= 39;</code></pre></div><br/><div id="39547157" class="c"><input type="checkbox" id="c-39547157" checked=""/><div class="controls bullet"><span class="by">AceJohnny2</span><span>|</span><a href="#39543854">root</a><span>|</span><a href="#39547112">parent</a><span>|</span><a href="#39544699">next</a><span>|</span><label class="collapse" for="c-39547157">[-]</label><label class="expand" for="c-39547157">[1 more]</label></div><br/><div class="children"><div class="content">Oh deer god.<p>We&#x27;ve never been <i>that</i> bad, but we are still using macros for registers instead of block structure pointers, which we have access to...<p>(although I&#x27;ll grant that structures can be risky due to undefined packing rules)</div><br/></div></div></div></div></div></div><div id="39544699" class="c"><input type="checkbox" id="c-39544699" checked=""/><div class="controls bullet"><span class="by">cgh</span><span>|</span><a href="#39543854">parent</a><span>|</span><a href="#39544164">prev</a><span>|</span><a href="#39545882">next</a><span>|</span><label class="collapse" for="c-39544699">[-]</label><label class="expand" for="c-39544699">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The lack of first class interfaces&#x2F;traits&#x2F;typeclasses is not my favorite. The currently suggested alternatives are so un-ergonomic I&#x27;d almost call them hostile.<p>The use of anytype as a sort of universal interface is my least favourite part of Zig. I’ve seen enough griping about it that I’m hopeful something happens here.</div><br/></div></div><div id="39545882" class="c"><input type="checkbox" id="c-39545882" checked=""/><div class="controls bullet"><span class="by">vrinsd</span><span>|</span><a href="#39543854">parent</a><span>|</span><a href="#39544699">prev</a><span>|</span><a href="#39545237">next</a><span>|</span><label class="collapse" for="c-39545882">[-]</label><label class="expand" for="c-39545882">[3 more]</label></div><br/><div class="children"><div class="content">Hey Jeff,<p>Can you share what your experience has been like with Nim on embedded targets?  Both Nim and Zig are on my wishlist to try out for embedded but I&#x27;m doing C and RTOSes for the next few projects.<p>Ada with Ravenscar seems like another &quot;seems like it solves a lot of common problems intelligently&quot; but I haven&#x27;t had much time to try it being a simple proof of concept.</div><br/><div id="39546085" class="c"><input type="checkbox" id="c-39546085" checked=""/><div class="controls bullet"><span class="by">girvo</span><span>|</span><a href="#39543854">root</a><span>|</span><a href="#39545882">parent</a><span>|</span><a href="#39545237">next</a><span>|</span><label class="collapse" for="c-39546085">[-]</label><label class="expand" for="c-39546085">[2 more]</label></div><br/><div class="children"><div class="content">I use Nim at work for embedded firmware development right now, and we evaluated Zig but it was a year and a half ago when we started the project, Zig just wasn’t as far along as it is now.<p>I’m currently in the process of writing a nice HAL&#x2F;dev framework agnostic FreeRTOS binding in Nim, which maybe you’ll find useful once we can post it?</div><br/><div id="39546352" class="c"><input type="checkbox" id="c-39546352" checked=""/><div class="controls bullet"><span class="by">SV_BubbleTime</span><span>|</span><a href="#39543854">root</a><span>|</span><a href="#39546085">parent</a><span>|</span><a href="#39545237">next</a><span>|</span><label class="collapse" for="c-39546352">[-]</label><label class="expand" for="c-39546352">[1 more]</label></div><br/><div class="children"><div class="content">Do neither of these languages have better concurrency tools than porting FreeRTOS?</div><br/></div></div></div></div></div></div><div id="39545237" class="c"><input type="checkbox" id="c-39545237" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#39543854">parent</a><span>|</span><a href="#39545882">prev</a><span>|</span><a href="#39544728">next</a><span>|</span><label class="collapse" for="c-39545237">[-]</label><label class="expand" for="c-39545237">[2 more]</label></div><br/><div class="children"><div class="content">&gt; - As a long time user of Nim (including on really lean embedded targets)<p>Could you expound on how you used Nim on &quot;really lean embedded targets&quot;?</div><br/><div id="39546106" class="c"><input type="checkbox" id="c-39546106" checked=""/><div class="controls bullet"><span class="by">girvo</span><span>|</span><a href="#39543854">root</a><span>|</span><a href="#39545237">parent</a><span>|</span><a href="#39544728">next</a><span>|</span><label class="collapse" for="c-39546106">[-]</label><label class="expand" for="c-39546106">[1 more]</label></div><br/><div class="children"><div class="content">Nim is “just C” at the end of the day, so by leveraging the —-compileOnly flag you can use Nim anywhere you can use C<p>Now that arc&#x2F;orc are the default memory management strategy, it’s even possible to keep some of the niceties from the standard library when doing so — but that will depend on your target of course.<p>Even going the “no heap allocation” route is totally feasible, you sort of end up using Nim as a nicer C syntax with extra features. All of the libraries we write for work have two interfaces, one that returns (possible heap allocated) results, and one that takes a buffer pointer (as a var openArray[T] param) in instead.</div><br/></div></div></div></div><div id="39544728" class="c"><input type="checkbox" id="c-39544728" checked=""/><div class="controls bullet"><span class="by">wredue</span><span>|</span><a href="#39543854">parent</a><span>|</span><a href="#39545237">prev</a><span>|</span><a href="#39541306">next</a><span>|</span><label class="collapse" for="c-39544728">[-]</label><label class="expand" for="c-39544728">[3 more]</label></div><br/><div class="children"><div class="content">&gt;- As a long time user of Nim (including on really lean embedded targets), compared to hygienic macros, comptime falls way short.<p>In what way? Comptime should be generally capable of anything macros are.<p>&gt;- The lack of first class interfaces&#x2F;traits&#x2F;typeclasses is not my favorite. The currently suggested alternatives are so un-ergonomic I&#x27;d almost call them hostile.<p>Terribly difficult to implement without breaking a major language tenant of “no hidden control flow”.<p>But I found that once I left behind OO style of thinking, I haven’t missed this all that much. For the rare time I do generalize like this, you can literally just check at comptime that the passed in type provides the necessary decls. It’s not terribly complex or hostile (although tooling could use some work around it)</div><br/><div id="39544946" class="c"><input type="checkbox" id="c-39544946" checked=""/><div class="controls bullet"><span class="by">jeff_ciesielski</span><span>|</span><a href="#39543854">root</a><span>|</span><a href="#39544728">parent</a><span>|</span><a href="#39541306">next</a><span>|</span><label class="collapse" for="c-39544946">[-]</label><label class="expand" for="c-39544946">[2 more]</label></div><br/><div class="children"><div class="content">&gt; In what way? Comptime should be generally capable of anything macros are.<p>I started to reply to this with &#x27;Comptime is generally capable of doing anything that Nim&#x27;s templates can accomplish (but not it&#x27;s macros)&#x27;, but I stopped myself because even though Zig&#x27;s comptime is more akin to Nim&#x27;s templates than its macros (in my opinion), Nim templates are more powerful as they allow you to embed arbitrary blocks of code to implement constructs similar to python&#x27;s context managers (which I&#x27;m fairly certain you can&#x27;t do with comptime).<p>W&#x2F;R&#x2F;T Macros vs Comptime, you can&#x27;t create arbitrarily complex DSLs with comptime the way you can with a Nim&#x27;s macros as you don&#x27;t have full control over AST generation.<p>All that said, the power you&#x27;d get from a Macro or Template system like Nim&#x27;s don&#x27;t really jive with Zig&#x27;s whole &quot;no hidden control flow&quot; thing.<p>&gt;Terribly difficult to implement without breaking a major language tenant of “no hidden control flow”.<p>I dunno if I agree with that, even very simple rust-like traits that simply enforce that a struct implemented a given interface at compile time (static dispatch only) would go a long way without compromising obvious control flow IMO.<p>&gt;But I found that once I left behind OO style of thinking, I haven’t missed this all that much. For the rare time I do generalize like this, you can literally just check at comptime that the passed in type provides the necessary decls. It’s not terribly complex or hostile (although tooling could use some work around it)<p>Respectfully, I don&#x27;t view it as OO thinking (I think typeclasses come from SML...). Making polymorphism reasonably ergonomic goes a long way towards code reuse and (again, only my humble opinion here) would help with what some of the folks in this comment section are talking about w&#x2F;r&#x2F;t code re-use and generalizing a HAL layer in a consistent way without forcing users (or library authors) to write a bunch of ad-hoc code to check that functions exist on a given struct, or manually implementing dispatch tables.</div><br/><div id="39546635" class="c"><input type="checkbox" id="c-39546635" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#39543854">root</a><span>|</span><a href="#39544946">parent</a><span>|</span><a href="#39541306">next</a><span>|</span><label class="collapse" for="c-39546635">[-]</label><label class="expand" for="c-39546635">[1 more]</label></div><br/><div class="children"><div class="content">I would generally agree that polymorphism is necessary, except maybe for embedded systems. You want more of a closed world system there, not an open world system that permits arbitrary extensions.<p>By open world, I&#x27;m thinking of abstractions like closures and interfaces which permit arbitrary extension and require dynamic dispatch. Given any fixed set of such abstractions, you can simulate in a closed world system via something like defunctionalization during whole program compilation, which is what you do on embedded systems. You can probably do a defunctionalization transformation with comptime, and that gets you better visibility on the state of the system in a way that&#x27;s not possible with a truly open world system.</div><br/></div></div></div></div></div></div></div></div><div id="39541306" class="c"><input type="checkbox" id="c-39541306" checked=""/><div class="controls bullet"><span class="by">nippoo</span><span>|</span><a href="#39543854">prev</a><span>|</span><a href="#39545711">next</a><span>|</span><label class="collapse" for="c-39541306">[-]</label><label class="expand" for="c-39541306">[5 more]</label></div><br/><div class="children"><div class="content">The fragmented state of the microcontroller market is pretty dire. Especially as there&#x27;s more higher-level features being baked in to modern micros, every different manufacturer is implementing different APIs to do the same basic thing (whether that be I2C or things like MIPI-CSI). Having a unified API would really help portability (and would enable people to build workable emulators!)</div><br/><div id="39541444" class="c"><input type="checkbox" id="c-39541444" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#39541306">parent</a><span>|</span><a href="#39545823">next</a><span>|</span><label class="collapse" for="c-39541444">[-]</label><label class="expand" for="c-39541444">[3 more]</label></div><br/><div class="children"><div class="content">fyi since you seem to be interested in this: rust has a few options including the embedded_hal crate with impls for everything from various microcontrollers to desktop linux.<p><a href="https:&#x2F;&#x2F;docs.rs&#x2F;embedded-hal&#x2F;latest&#x2F;embedded_hal&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;embedded-hal&#x2F;latest&#x2F;embedded_hal&#x2F;</a></div><br/><div id="39542273" class="c"><input type="checkbox" id="c-39542273" checked=""/><div class="controls bullet"><span class="by">KallDrexx</span><span>|</span><a href="#39541306">root</a><span>|</span><a href="#39541444">parent</a><span>|</span><a href="#39542038">next</a><span>|</span><label class="collapse" for="c-39542273">[-]</label><label class="expand" for="c-39542273">[1 more]</label></div><br/><div class="children"><div class="content">Despite my day job involving rust, I struggled pretty hard getting Rust working adequately for my little GPU project on both pi pico and an esp32s3.  Both had debugg-ability issues, missing features that would have required advanced FFI integrations to be added, and things just wouldn&#x27;t even work.  I spent a week on it making no progress, and with only an hour an evening I had to do anything it was frustrating.<p>I then spent 2 days brushing up on C and got things up and running with ESP-IDF painlessly.  I&#x27;ve been iterating really fast on C just fine, and the few times I wish I had Rust&#x27;s features have been eclipsed by the advanced ESP-IDF api&#x27;s I&#x27;ve needed to use that didn&#x27;t have support in the Rust HALs.</div><br/></div></div><div id="39542038" class="c"><input type="checkbox" id="c-39542038" checked=""/><div class="controls bullet"><span class="by">the__alchemist</span><span>|</span><a href="#39541306">root</a><span>|</span><a href="#39541444">parent</a><span>|</span><a href="#39542273">prev</a><span>|</span><a href="#39545823">next</a><span>|</span><label class="collapse" for="c-39542038">[-]</label><label class="expand" for="c-39542038">[1 more]</label></div><br/><div class="children"><div class="content">Sounds great in theory (writing MCU-agnostic libraries for peripherals), but I&#x27;ve found it unusable in practice due to the clunky API and incompatibility with DMA, interrupt-based-flow, least-common-denominator functionality etc.<p>The new direction that library and related is Async with Embassy, which... is also not something I want to use.</div><br/></div></div></div></div><div id="39545823" class="c"><input type="checkbox" id="c-39545823" checked=""/><div class="controls bullet"><span class="by">petra</span><span>|</span><a href="#39541306">parent</a><span>|</span><a href="#39541444">prev</a><span>|</span><a href="#39545711">next</a><span>|</span><label class="collapse" for="c-39545823">[-]</label><label class="expand" for="c-39545823">[1 more]</label></div><br/><div class="children"><div class="content">Modm.io is a a unified API for microcontrollers.</div><br/></div></div></div></div><div id="39545711" class="c"><input type="checkbox" id="c-39545711" checked=""/><div class="controls bullet"><span class="by">roland35</span><span>|</span><a href="#39541306">prev</a><span>|</span><a href="#39543361">next</a><span>|</span><label class="collapse" for="c-39545711">[-]</label><label class="expand" for="c-39545711">[2 more]</label></div><br/><div class="children"><div class="content">I appreciate that zig is an easily searchable name for a programming language. You’d think after Java and python that’d we’d have better options, but no!  Now there is Go, Rust, etc etc</div><br/><div id="39545876" class="c"><input type="checkbox" id="c-39545876" checked=""/><div class="controls bullet"><span class="by">Ar-Curunir</span><span>|</span><a href="#39545711">parent</a><span>|</span><a href="#39543361">next</a><span>|</span><label class="collapse" for="c-39545876">[-]</label><label class="expand" for="c-39545876">[1 more]</label></div><br/><div class="children"><div class="content">is it that much more difficult to append a `lang` after go, rust etc?</div><br/></div></div></div></div><div id="39543361" class="c"><input type="checkbox" id="c-39543361" checked=""/><div class="controls bullet"><span class="by">TimSchumann</span><span>|</span><a href="#39545711">prev</a><span>|</span><a href="#39543137">next</a><span>|</span><label class="collapse" for="c-39543361">[-]</label><label class="expand" for="c-39543361">[1 more]</label></div><br/><div class="children"><div class="content">Word on the street is the badges at the next Software You Can Love conference will be running this.</div><br/></div></div><div id="39543137" class="c"><input type="checkbox" id="c-39543137" checked=""/><div class="controls bullet"><span class="by">spiritplumber</span><span>|</span><a href="#39543361">prev</a><span>|</span><a href="#39542121">next</a><span>|</span><label class="collapse" for="c-39543137">[-]</label><label class="expand" for="c-39543137">[2 more]</label></div><br/><div class="children"><div class="content">You know what you doing! Move Zig for great justice.</div><br/><div id="39544039" class="c"><input type="checkbox" id="c-39544039" checked=""/><div class="controls bullet"><span class="by">just_steve_h</span><span>|</span><a href="#39543137">parent</a><span>|</span><a href="#39542121">next</a><span>|</span><label class="collapse" for="c-39544039">[-]</label><label class="expand" for="c-39544039">[1 more]</label></div><br/><div class="children"><div class="content">YOU HAVE NO CHANCE TO SURVIVE MAKE YOUR TIME</div><br/></div></div></div></div><div id="39542121" class="c"><input type="checkbox" id="c-39542121" checked=""/><div class="controls bullet"><span class="by">cnln</span><span>|</span><a href="#39543137">prev</a><span>|</span><a href="#39544975">next</a><span>|</span><label class="collapse" for="c-39542121">[-]</label><label class="expand" for="c-39542121">[7 more]</label></div><br/><div class="children"><div class="content">I literally just posted on my blog about my adventures writing an OLED driver in MicroZig, it was a really fun little project<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39540761">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39540761</a></div><br/><div id="39542165" class="c"><input type="checkbox" id="c-39542165" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39542121">parent</a><span>|</span><a href="#39544975">next</a><span>|</span><label class="collapse" for="c-39542165">[-]</label><label class="expand" for="c-39542165">[6 more]</label></div><br/><div class="children"><div class="content">That&#x27;s great and if you email hn@ycombinator.com in, say, a couple months*, we can send you a repost invite for it.<p>* i.e. enough time to flush the hivemind caches so the thread won&#x27;t feel repetitive</div><br/><div id="39542482" class="c"><input type="checkbox" id="c-39542482" checked=""/><div class="controls bullet"><span class="by">sgt</span><span>|</span><a href="#39542121">root</a><span>|</span><a href="#39542165">parent</a><span>|</span><a href="#39542209">next</a><span>|</span><label class="collapse" for="c-39542482">[-]</label><label class="expand" for="c-39542482">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t it better just to repost with a query parameter like ?foobar ?</div><br/><div id="39543937" class="c"><input type="checkbox" id="c-39543937" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39542121">root</a><span>|</span><a href="#39542482">parent</a><span>|</span><a href="#39542209">next</a><span>|</span><label class="collapse" for="c-39543937">[-]</label><label class="expand" for="c-39543937">[1 more]</label></div><br/><div class="children"><div class="content">Oh the issue isn&#x27;t a technical one. It&#x27;s that once there&#x27;s been a big discussion about a topic (in this case MicroZig) the community appetite for a second thread about roughly the same thing (in this case, another MicroZig thread) drops off sharply. However, if you wait long enough then it becomes fresh again and a new thread is ok. That&#x27;s what I facetiously call letting the hivemind caches clear.</div><br/></div></div></div></div><div id="39542209" class="c"><input type="checkbox" id="c-39542209" checked=""/><div class="controls bullet"><span class="by">cnln</span><span>|</span><a href="#39542121">root</a><span>|</span><a href="#39542165">parent</a><span>|</span><a href="#39542482">prev</a><span>|</span><a href="#39544975">next</a><span>|</span><label class="collapse" for="c-39542209">[-]</label><label class="expand" for="c-39542209">[3 more]</label></div><br/><div class="children"><div class="content">Great, thanks!</div><br/><div id="39542456" class="c"><input type="checkbox" id="c-39542456" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#39542121">root</a><span>|</span><a href="#39542209">parent</a><span>|</span><a href="#39544975">next</a><span>|</span><label class="collapse" for="c-39542456">[-]</label><label class="expand" for="c-39542456">[2 more]</label></div><br/><div class="children"><div class="content">Meta: you have typod the name of the microcontroller as <i>RP4020</i> twice, might be worth fixing. Nice post, otherwise!<p>Edit: typos, ironically. Mobile phone text editing ~ftw.</div><br/><div id="39542641" class="c"><input type="checkbox" id="c-39542641" checked=""/><div class="controls bullet"><span class="by">cnln</span><span>|</span><a href="#39542121">root</a><span>|</span><a href="#39542456">parent</a><span>|</span><a href="#39544975">next</a><span>|</span><label class="collapse" for="c-39542641">[-]</label><label class="expand" for="c-39542641">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, I&#x27;ll fix that</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39544975" class="c"><input type="checkbox" id="c-39544975" checked=""/><div class="controls bullet"><span class="by">22c</span><span>|</span><a href="#39542121">prev</a><span>|</span><a href="#39543284">next</a><span>|</span><label class="collapse" for="c-39544975">[-]</label><label class="expand" for="c-39544975">[3 more]</label></div><br/><div class="children"><div class="content">ESP32 and STM32 support is very welcome!<p>I have been following <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;5467">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;5467</a> for a while and progress seemed to have slowed significantly</div><br/><div id="39545195" class="c"><input type="checkbox" id="c-39545195" checked=""/><div class="controls bullet"><span class="by">kassane</span><span>|</span><a href="#39544975">parent</a><span>|</span><a href="#39543284">next</a><span>|</span><label class="collapse" for="c-39545195">[-]</label><label class="expand" for="c-39545195">[2 more]</label></div><br/><div class="children"><div class="content">Unfortunately, the upstream zig toolchain (LLVM codegen) does not support the Xtensa architecture (opaque CPU features), but it is possible to use riscv32 for esp32 from the C2&#x2F;C3&#x2F;C6, H2 and the new P4 release.<p>I&#x27;m currently working on a fork of the zig toolchain with espressif-LLVM to support Xtensa.[1]
It is now possible to test with esp-idf instead of microzig for baremetal (Blink) yet.<p>[1] <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;kassane&#x2F;7bdb782a1984d0c6581ae7b44e1fc0c2" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;kassane&#x2F;7bdb782a1984d0c6581ae7b44e1f...</a></div><br/><div id="39545766" class="c"><input type="checkbox" id="c-39545766" checked=""/><div class="controls bullet"><span class="by">22c</span><span>|</span><a href="#39544975">root</a><span>|</span><a href="#39545195">parent</a><span>|</span><a href="#39543284">next</a><span>|</span><label class="collapse" for="c-39545766">[-]</label><label class="expand" for="c-39545766">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I remember reading about it&#x27;s relation to LLVM issues etc. I also think there was another (languishing) fork of the entire zig repo which had some support for Xtensa which I couldn&#x27;t find at the time, but I found it.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ominitay&#x2F;zig&#x2F;tree&#x2F;xtensa">https:&#x2F;&#x2F;github.com&#x2F;ominitay&#x2F;zig&#x2F;tree&#x2F;xtensa</a><p>Edit: I see you are the same kassane from the GitHub thread. Thank you for your efforts on Xtensa support! Would be great to have it out-of-the-box at some point.</div><br/></div></div></div></div></div></div><div id="39543284" class="c"><input type="checkbox" id="c-39543284" checked=""/><div class="controls bullet"><span class="by">UncleOxidant</span><span>|</span><a href="#39544975">prev</a><span>|</span><a href="#39543141">next</a><span>|</span><label class="collapse" for="c-39543284">[-]</label><label class="expand" for="c-39543284">[3 more]</label></div><br/><div class="children"><div class="content">Are there similar efforts for other languages? Or could this be a starting point for a language-neutral, multi-board&#x2F;microcontroller  HAL?</div><br/><div id="39543634" class="c"><input type="checkbox" id="c-39543634" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#39543284">parent</a><span>|</span><a href="#39543141">next</a><span>|</span><label class="collapse" for="c-39543634">[-]</label><label class="expand" for="c-39543634">[2 more]</label></div><br/><div class="children"><div class="content">There are lots of similar efforts, but they tend to be half-finished on many platforms that they supposedly support.<p>(Also, how is this one language-neutral?)</div><br/><div id="39543706" class="c"><input type="checkbox" id="c-39543706" checked=""/><div class="controls bullet"><span class="by">UncleOxidant</span><span>|</span><a href="#39543284">root</a><span>|</span><a href="#39543634">parent</a><span>|</span><a href="#39543141">next</a><span>|</span><label class="collapse" for="c-39543706">[-]</label><label class="expand" for="c-39543706">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not langauge-neutral. But I suppose one could imagine zig at the bottom level on the bare metal and other languages being able to call into that zig layer.</div><br/></div></div></div></div></div></div><div id="39543141" class="c"><input type="checkbox" id="c-39543141" checked=""/><div class="controls bullet"><span class="by">spiritplumber</span><span>|</span><a href="#39543284">prev</a><span>|</span><a href="#39541443">next</a><span>|</span><label class="collapse" for="c-39543141">[-]</label><label class="expand" for="c-39543141">[1 more]</label></div><br/><div class="children"><div class="content">Are there any plans to put this on the Parallax Propeller as well?</div><br/></div></div><div id="39541443" class="c"><input type="checkbox" id="c-39541443" checked=""/><div class="controls bullet"><span class="by">Cyberdog</span><span>|</span><a href="#39543141">prev</a><span>|</span><label class="collapse" for="c-39541443">[-]</label><label class="expand" for="c-39541443">[7 more]</label></div><br/><div class="children"><div class="content">I got this working on a RPi 2040 during my most recent microcontroller phase several months back. I know Zig can be oddly divisive here on HN but can we at least agree that it&#x27;s a good thing to have alternatives to Python in this space?</div><br/><div id="39541754" class="c"><input type="checkbox" id="c-39541754" checked=""/><div class="controls bullet"><span class="by">nrclark</span><span>|</span><a href="#39541443">parent</a><span>|</span><a href="#39542120">next</a><span>|</span><label class="collapse" for="c-39541754">[-]</label><label class="expand" for="c-39541754">[4 more]</label></div><br/><div class="children"><div class="content">In the microcontroller space, I think Zig is more of a replacement for C&#x2F;C++. It&#x27;s a compiled language, intended to produce optimized code that hits cost&#x2F;performance targets.<p>Micropython and friends are well-suited for education&#x2F;hobby use, protoptyping, and maybe some commercial applications that aren&#x27;t sensitive to cost or realtime characteristics. But since they don&#x27;t really compete with C&#x2F;C++, they also don&#x27;t really compete with Zig.</div><br/><div id="39547129" class="c"><input type="checkbox" id="c-39547129" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39541443">root</a><span>|</span><a href="#39541754">parent</a><span>|</span><a href="#39541872">next</a><span>|</span><label class="collapse" for="c-39547129">[-]</label><label class="expand" for="c-39547129">[1 more]</label></div><br/><div class="children"><div class="content">BASIC, Pascal have been doing it for decades already, to the point the likes of Mikroe and Parallax don&#x27;t have any issue staying in business selling compilers.</div><br/></div></div><div id="39541872" class="c"><input type="checkbox" id="c-39541872" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#39541443">root</a><span>|</span><a href="#39541754">parent</a><span>|</span><a href="#39547129">prev</a><span>|</span><a href="#39542312">next</a><span>|</span><label class="collapse" for="c-39541872">[-]</label><label class="expand" for="c-39541872">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s true that micropython doesn&#x27;t compete with zig, but zig is simple enough&#x2F;no-fuss enough (imagine deployment strategies baked with one line in a build.zig) that it might compete with micropython.</div><br/></div></div><div id="39542312" class="c"><input type="checkbox" id="c-39542312" checked=""/><div class="controls bullet"><span class="by">Cyberdog</span><span>|</span><a href="#39541443">root</a><span>|</span><a href="#39541754">parent</a><span>|</span><a href="#39541872">prev</a><span>|</span><a href="#39542120">next</a><span>|</span><label class="collapse" for="c-39542312">[-]</label><label class="expand" for="c-39542312">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right of course, but if you pick up a 2040 and you&#x27;re a newbie to microcontrollers (as I am), all of the documentation and first-party tools push you towards using Python, which I&#x27;ve never been too fond of and I started looking for alternatives as soon as I finished the last chapter of the manual. The alternatives are always there but they presume a level of experience (and C skills) that I just don&#x27;t have. Having experimented with Zig I was glad to eventually find MicroZig. I remember that using it wasn&#x27;t quite as easy as &quot;push button, watch LED blink&quot; as it was when I was using Python and Thonny but if a n00b like me could figure it out, anyone can.</div><br/></div></div></div></div><div id="39542120" class="c"><input type="checkbox" id="c-39542120" checked=""/><div class="controls bullet"><span class="by">jakewins</span><span>|</span><a href="#39541443">parent</a><span>|</span><a href="#39541754">prev</a><span>|</span><a href="#39542687">next</a><span>|</span><label class="collapse" for="c-39542120">[-]</label><label class="expand" for="c-39542120">[1 more]</label></div><br/><div class="children"><div class="content">Agreed! I’ve similarly had good experiences with Rust on the rp2040, using embassy which builds on the rust HALs.</div><br/></div></div><div id="39542687" class="c"><input type="checkbox" id="c-39542687" checked=""/><div class="controls bullet"><span class="by">KerrAvon</span><span>|</span><a href="#39541443">parent</a><span>|</span><a href="#39542120">prev</a><span>|</span><label class="collapse" for="c-39542687">[-]</label><label class="expand" for="c-39542687">[1 more]</label></div><br/><div class="children"><div class="content">God, yes. Ruby is also at least somewhat usable in the space, FWIW; I&#x27;ve done RPi hacking with it in the past.</div><br/></div></div></div></div></div></div></div></div></div></body></html>