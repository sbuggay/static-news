<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720602064561" as="style"/><link rel="stylesheet" href="styles.css?v=1720602064561"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/zherczeg/sljit">Sljit: Platform independent low-level JIT compiler</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>nateb2022</span> | <span>19 comments</span></div><br/><div><div id="40915506" class="c"><input type="checkbox" id="c-40915506" checked=""/><div class="controls bullet"><span class="by">the_duke</span><span>|</span><a href="#40915569">next</a><span>|</span><label class="collapse" for="c-40915506">[-]</label><label class="expand" for="c-40915506">[4 more]</label></div><br/><div class="children"><div class="content">Interesting, first time I heard about sljit.<p>&gt; Although sljit does not support higher level features such as automatic register allocation<p>I don&#x27;t quite see how it can be architecture independent if it doesn&#x27;t do register allocation. Does it use a small fixed amount of virtual registers which work on every target? Or does it spill virtual registers to memory if required?<p>&gt; The key design principle of sljit is that it does not try to be smarter than the developer.<p>&gt; This principle is achieved by providing control over the generated machine code like assembly languages.<p>So it sounds like this is essentially your LLVM backend, taking care of going from intermediate representation to machine code.<p>Optimisations have to be done separately.<p>I see how a lightweight code generator could be quite useful, is sljit used in any larger projects?</div><br/><div id="40915755" class="c"><input type="checkbox" id="c-40915755" checked=""/><div class="controls bullet"><span class="by">tnodir</span><span>|</span><a href="#40915506">parent</a><span>|</span><a href="#40916151">next</a><span>|</span><label class="collapse" for="c-40915755">[-]</label><label class="expand" for="c-40915755">[1 more]</label></div><br/><div class="children"><div class="content">&gt; is sljit used in any larger projects?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;PCRE2Project&#x2F;pcre2&#x2F;tree&#x2F;master&#x2F;src&#x2F;sljit">https:&#x2F;&#x2F;github.com&#x2F;PCRE2Project&#x2F;pcre2&#x2F;tree&#x2F;master&#x2F;src&#x2F;sljit</a></div><br/></div></div><div id="40916151" class="c"><input type="checkbox" id="c-40916151" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#40915506">parent</a><span>|</span><a href="#40915755">prev</a><span>|</span><a href="#40916002">next</a><span>|</span><label class="collapse" for="c-40916151">[-]</label><label class="expand" for="c-40916151">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t quite see how it can be architecture independent if it doesn&#x27;t do register allocation. Does it use a small fixed amount of virtual registers which work on every target? Or does it spill virtual registers to memory if required?<p>If it&#x27;s low level and platform independent, that probably means more that it provides the tools to the user to work on many platforms, rather than it does the work for many platforms for the user.<p>Jit libraries like this are building blocks, not a turnkey interpreter to native execution pipeline.</div><br/></div></div><div id="40916002" class="c"><input type="checkbox" id="c-40916002" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#40915506">parent</a><span>|</span><a href="#40916151">prev</a><span>|</span><a href="#40915569">next</a><span>|</span><label class="collapse" for="c-40916002">[-]</label><label class="expand" for="c-40916002">[1 more]</label></div><br/><div class="children"><div class="content">I think the idea is that if you bring-your-own register allocator, it&#x27;s easy to configure it to use the right number of registers for a given target.<p>The &quot;LIR representation&quot; itself is machine independent, but a given stream of LIR instructions won&#x27;t necessarily be portable. (If I&#x27;m understanding correctly)</div><br/></div></div></div></div><div id="40915569" class="c"><input type="checkbox" id="c-40915569" checked=""/><div class="controls bullet"><span class="by">steego</span><span>|</span><a href="#40915506">prev</a><span>|</span><a href="#40923886">next</a><span>|</span><label class="collapse" for="c-40915569">[-]</label><label class="expand" for="c-40915569">[2 more]</label></div><br/><div class="children"><div class="content">From the website:<p><pre><code>    The engine strikes a good balance between performance and 
    maintainability. The LIR code can be compiled to many CPU 
    architectures, and the performance of the generated code 
    is very close to code written in assembly languages. 
    Although sljit does not support higher level features 
    such as automatic register allocation, it can be a code 
    generator backend for other JIT compiler libraries. 
    Developing these intermediate libraries takes far 
    less time, because they only needs to support a single 
    backend.
</code></pre>
<a href="https:&#x2F;&#x2F;zherczeg.github.io&#x2F;sljit&#x2F;" rel="nofollow">https:&#x2F;&#x2F;zherczeg.github.io&#x2F;sljit&#x2F;</a><p>I&#x27;d love to see some examples of other projects incorporating this library.</div><br/><div id="40920339" class="c"><input type="checkbox" id="c-40920339" checked=""/><div class="controls bullet"><span class="by">pierrebai</span><span>|</span><a href="#40915569">parent</a><span>|</span><a href="#40923886">next</a><span>|</span><label class="collapse" for="c-40920339">[-]</label><label class="expand" for="c-40920339">[1 more]</label></div><br/><div class="children"><div class="content">Looking at the code, &quot;maintainability&quot; is quite relative: it might be maintainable by the original author, but the code has no comment and is chuck-full of magic constants without any explanations. Or&#x27;ing this hex value, and&#x27;ing that other hex value, etc.</div><br/></div></div></div></div><div id="40923886" class="c"><input type="checkbox" id="c-40923886" checked=""/><div class="controls bullet"><span class="by">namjh</span><span>|</span><a href="#40915569">prev</a><span>|</span><a href="#40920287">next</a><span>|</span><label class="collapse" for="c-40923886">[-]</label><label class="expand" for="c-40923886">[2 more]</label></div><br/><div class="children"><div class="content">Interesting project and kind of tangential topic, will JIT compilers still be widely adopted given they are considered a critical attack vector when it misbehaves? I wonder if there is an effort to formally verify its safety or do a complete redesign to ensure it.</div><br/><div id="40924545" class="c"><input type="checkbox" id="c-40924545" checked=""/><div class="controls bullet"><span class="by">scheme271</span><span>|</span><a href="#40923886">parent</a><span>|</span><a href="#40920287">next</a><span>|</span><label class="collapse" for="c-40924545">[-]</label><label class="expand" for="c-40924545">[1 more]</label></div><br/><div class="children"><div class="content">JIT compilers provide so much performance boost to code that I don&#x27;t see how they could be realistically dropped. It&#x27;d be like not using speculative execution on cpus because of spectre and similar attacks.</div><br/></div></div></div></div><div id="40920287" class="c"><input type="checkbox" id="c-40920287" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40923886">prev</a><span>|</span><a href="#40917131">next</a><span>|</span><label class="collapse" for="c-40920287">[-]</label><label class="expand" for="c-40920287">[2 more]</label></div><br/><div class="children"><div class="content">What is the advantage relative to GNU Lightning, which seems like its most direct competitor.</div><br/><div id="40924919" class="c"><input type="checkbox" id="c-40924919" checked=""/><div class="controls bullet"><span class="by">fp64</span><span>|</span><a href="#40920287">parent</a><span>|</span><a href="#40917131">next</a><span>|</span><label class="collapse" for="c-40924919">[-]</label><label class="expand" for="c-40924919">[1 more]</label></div><br/><div class="children"><div class="content">2-clause BSD vs LGPL-2 can be an advantage, depending on your perspective</div><br/></div></div></div></div><div id="40917131" class="c"><input type="checkbox" id="c-40917131" checked=""/><div class="controls bullet"><span class="by">gizmo</span><span>|</span><a href="#40920287">prev</a><span>|</span><a href="#40917403">next</a><span>|</span><label class="collapse" for="c-40917131">[-]</label><label class="expand" for="c-40917131">[4 more]</label></div><br/><div class="children"><div class="content">Although I only looked at the code briefly I suspect it will very hard to get good performance from the API as provided[1].<p>It looks like you have to do a function call for every high level assembly instruction which in turn does quite a bit of work. See `emit_x86_instruction`[2], most of which is redundant and most of which can be done ahead of time. To JIT quickly you want to work with templates if at all possible. Precompile those templates for the relevant architecture. Then at runtime you just patch the precompiled machine code with the correct addresses and registers. This extra speed really matters because if JITing code is cheap you can compile functions multiple times, inline aggressively and do many other optimizations that wouldn&#x27;t be economical otherwise.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;zherczeg&#x2F;sljit&#x2F;blob&#x2F;master&#x2F;test_src&#x2F;sljitTestCall.h">https:&#x2F;&#x2F;github.com&#x2F;zherczeg&#x2F;sljit&#x2F;blob&#x2F;master&#x2F;test_src&#x2F;sljit...</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;zherczeg&#x2F;sljit&#x2F;blob&#x2F;master&#x2F;sljit_src&#x2F;sljitNativeX86_64.c">https:&#x2F;&#x2F;github.com&#x2F;zherczeg&#x2F;sljit&#x2F;blob&#x2F;master&#x2F;sljit_src&#x2F;slji...</a></div><br/><div id="40920993" class="c"><input type="checkbox" id="c-40920993" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#40917131">parent</a><span>|</span><a href="#40917436">next</a><span>|</span><label class="collapse" for="c-40920993">[-]</label><label class="expand" for="c-40920993">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I suspect it will very hard to get good performance from the API as provided<p>PCRE2&#x27;s jit engine, which is powered by sljit, is one of the fastest regex engines in existence (according to my own benchmarks): <a href="https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;rebar?tab=readme-ov-file#summary-of-search-time-benchmarks">https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;rebar?tab=readme-ov-file#summa...</a></div><br/></div></div><div id="40917436" class="c"><input type="checkbox" id="c-40917436" checked=""/><div class="controls bullet"><span class="by">jhoechtl</span><span>|</span><a href="#40917131">parent</a><span>|</span><a href="#40920993">prev</a><span>|</span><a href="#40921134">next</a><span>|</span><label class="collapse" for="c-40917436">[-]</label><label class="expand" for="c-40917436">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Although I only looked at the code briefly I suspect it will very hard to get good performance from the API as provided[1].<p>Let Common Sense reign. If the target Plattform I remains abstract, it will be a generic machine code translation. No way for sensible performance.<p>I would love to see a Lua transpiler.</div><br/></div></div><div id="40921134" class="c"><input type="checkbox" id="c-40921134" checked=""/><div class="controls bullet"><span class="by">jonstewart</span><span>|</span><a href="#40917131">parent</a><span>|</span><a href="#40917436">prev</a><span>|</span><a href="#40917403">next</a><span>|</span><label class="collapse" for="c-40921134">[-]</label><label class="expand" for="c-40921134">[1 more]</label></div><br/><div class="children"><div class="content">Zoltan did an amazing job integrating sljit into PCRE. I wonder how many millions of tons of CO2 emissions it’s prevented? Maybe faster jits are possible, but this is one that’s moved the needle.</div><br/></div></div></div></div><div id="40917403" class="c"><input type="checkbox" id="c-40917403" checked=""/><div class="controls bullet"><span class="by">pierrec</span><span>|</span><a href="#40917131">prev</a><span>|</span><a href="#40917689">next</a><span>|</span><label class="collapse" for="c-40917403">[-]</label><label class="expand" for="c-40917403">[1 more]</label></div><br/><div class="children"><div class="content">Since this is stackless, does it support checkpointing and resuming the execution state? This is sometimes a reason for making execution stackless, but I guess the JIT might make this more difficult. I can&#x27;t find any mention of this in the readme or project page so I&#x27;m guessing no, but it would be neat.</div><br/></div></div><div id="40917689" class="c"><input type="checkbox" id="c-40917689" checked=""/><div class="controls bullet"><span class="by">ufo</span><span>|</span><a href="#40917403">prev</a><span>|</span><a href="#40915425">next</a><span>|</span><label class="collapse" for="c-40917689">[-]</label><label class="expand" for="c-40917689">[2 more]</label></div><br/><div class="children"><div class="content">Does it support deoptimization back to bytecode? That&#x27;s useful for dynamic language JITs.</div><br/><div id="40920236" class="c"><input type="checkbox" id="c-40920236" checked=""/><div class="controls bullet"><span class="by">blacklion</span><span>|</span><a href="#40917689">parent</a><span>|</span><a href="#40915425">next</a><span>|</span><label class="collapse" for="c-40920236">[-]</label><label class="expand" for="c-40920236">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t have bytecode. Its intermediate language is set of C constants and C function calls. No bytecode, no AST, nothing. It could help you emit &quot;add these two registers&quot; instructions on any supported architecture with same API call and it is almost it.</div><br/></div></div></div></div><div id="40915425" class="c"><input type="checkbox" id="c-40915425" checked=""/><div class="controls bullet"><span class="by">mllev</span><span>|</span><a href="#40917689">prev</a><span>|</span><label class="collapse" for="c-40915425">[-]</label><label class="expand" for="c-40915425">[1 more]</label></div><br/><div class="children"><div class="content">Well this is epic</div><br/></div></div></div></div></div></div></div></body></html>