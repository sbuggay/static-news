<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1690275648550" as="style"/><link rel="stylesheet" href="styles.css?v=1690275648550"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lock.cmpxchg8b.com/zenbleed.html">Zenbleed</a> <span class="domain">(<a href="https://lock.cmpxchg8b.com">lock.cmpxchg8b.com</a>)</span></div><div class="subtext"><span>loeg</span> | <span>257 comments</span></div><br/><div><div id="36849914" class="c"><input type="checkbox" id="c-36849914" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#36851906">next</a><span>|</span><label class="collapse" for="c-36849914">[-]</label><label class="expand" for="c-36849914">[73 more]</label></div><br/><div class="children"><div class="content">This is super cool. This exploit will be one of the canonical examples that just running something in a VM does not mean it&#x27;s safe. We&#x27;ve always known about VM breakout, but this is a no-breakout massive exploit that is simple to execute and gives big payoffs.<p>Remember: just because this one bug gets fixed in microcode doesn&#x27;t mean there&#x27;s not another one of these waiting to be discovered. Many (most?) 0-days are known about by black-hats-for-hire well before they&#x27;re made public.<p>CPU vulnerabilities found in the past few years:<p><pre><code>  https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Meltdown_(security_vulnerability)
  https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Spectre_(security_vulnerability)
  https:&#x2F;&#x2F;aepicleak.com&#x2F;
  https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Software_Guard_Extensions#SGAxe
  https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Software_Guard_Extensions#LVI
  https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Software_Guard_Extensions#Plundervolt
  https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Software_Guard_Extensions#MicroScope_replay_attack
  https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Software_Guard_Extensions#Enclave_attack
  https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Software_Guard_Extensions#Prime+Probe_attack
  https:&#x2F;&#x2F;www.vusec.net&#x2F;projects&#x2F;crosstalk&#x2F;
  https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hertzbleed
  https:&#x2F;&#x2F;www.securityweek.com&#x2F;amd-processors-expose-sensitive-data-new-squip-attack&#x2F;</code></pre></div><br/><div id="36851099" class="c"><input type="checkbox" id="c-36851099" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#36849914">parent</a><span>|</span><a href="#36851886">next</a><span>|</span><label class="collapse" for="c-36851099">[-]</label><label class="expand" for="c-36851099">[17 more]</label></div><br/><div class="children"><div class="content">The problem is, VMs aren&#x27;t really &quot;Virtual Machines&quot; anymore. You&#x27;re not parsing opcodes in a big switch statement, you&#x27;re running instructions on the actual CPU, with a few hardware flags that the CPU says will guarantee no data or instruction overlap. It promises! But that&#x27;s a hard promise to make in reality.</div><br/><div id="36854456" class="c"><input type="checkbox" id="c-36854456" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36851099">parent</a><span>|</span><a href="#36858303">next</a><span>|</span><label class="collapse" for="c-36854456">[-]</label><label class="expand" for="c-36854456">[3 more]</label></div><br/><div class="children"><div class="content">&gt; you&#x27;re running instructions on the actual CPU<p>Just how many times is the average operating system workload (with or without a virtual machine also running a second average operating system workload) context switching a second?<p>Like... unless I&#x27;m wrong... the kernel is the main process, and then it slices up processes&#x2F;threads, and each time those run, they have their own EAX&#x2F;EBX&#x2F;ECX&#x2F;ESP&#x2F;EBP&#x2F;EIP&#x2F;etc. (I know it&#x27;s RAX, etc. for 64-bit now)<p>How many cycles is a thread&#x2F;process given before it context switches to the next one? How is it managing all of the pushfd&#x2F;popfd, etc. between them? Is this not how modern operating systems work, am I misunderstanding?</div><br/><div id="36854842" class="c"><input type="checkbox" id="c-36854842" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36854456">parent</a><span>|</span><a href="#36854716">next</a><span>|</span><label class="collapse" for="c-36854842">[-]</label><label class="expand" for="c-36854842">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How many cycles is a thread&#x2F;process given before it context switches to the next one?<p>Depends on a lot of things. If it&#x27;s a compute heavy task, and there&#x27;s no I&#x2F;O interrupts, the task gets one &quot;timeslice&quot;, timeslices vary, but typical times are somewhere in the neighborhood of 1 ms to 100 ms. If it&#x27;s an I&#x2F;O heavy task, chances are the task returns from a syscall with new data to read (or because a write finished), does a little bit of work, then does another syscall with I&#x2F;O. Lots of context switches in network heavy code (io_uring seems promising).<p>&gt; How is it managing all of the pushfd&#x2F;popfd, etc. between them?<p>The basic plan is when the kernel takes an interrupt (or gets a syscall, which is an interrupt on some systems and other mechanisms on others), the kernel (or the cpu) loads the kernel stack pointer for the current thread, then it pushes all the (relevant) cpu registers onto the stack, then the kernel business it taken care of, the scheduler decides which userspace thread to return to (which might be the same one that was interrupted or not), the destination thread&#x27;s kernel stack is switched to, registers are popped, then the thread&#x27;s userspace stack is switched to, then userspace execution resumes.</div><br/></div></div><div id="36854716" class="c"><input type="checkbox" id="c-36854716" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36854456">parent</a><span>|</span><a href="#36854842">prev</a><span>|</span><a href="#36858303">next</a><span>|</span><label class="collapse" for="c-36854716">[-]</label><label class="expand" for="c-36854716">[1 more]</label></div><br/><div class="children"><div class="content">Usually a few hundred to a few thousand times a second.</div><br/></div></div></div></div><div id="36858303" class="c"><input type="checkbox" id="c-36858303" checked=""/><div class="controls bullet"><span class="by">stingraycharles</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36851099">parent</a><span>|</span><a href="#36854456">prev</a><span>|</span><a href="#36855621">next</a><span>|</span><label class="collapse" for="c-36858303">[-]</label><label class="expand" for="c-36858303">[2 more]</label></div><br/><div class="children"><div class="content">Isn’t the typical solution here to pin each VM to certain CPUs &#x2F; cores?</div><br/></div></div><div id="36855621" class="c"><input type="checkbox" id="c-36855621" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36851099">parent</a><span>|</span><a href="#36858303">prev</a><span>|</span><a href="#36853411">next</a><span>|</span><label class="collapse" for="c-36855621">[-]</label><label class="expand" for="c-36855621">[2 more]</label></div><br/><div class="children"><div class="content">The big switch statement wouldn&#x27;t necessarily protect you either.</div><br/><div id="36859663" class="c"><input type="checkbox" id="c-36859663" checked=""/><div class="controls bullet"><span class="by">distcs</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36855621">parent</a><span>|</span><a href="#36853411">next</a><span>|</span><label class="collapse" for="c-36859663">[-]</label><label class="expand" for="c-36859663">[1 more]</label></div><br/><div class="children"><div class="content">Why do comments like this just make a bold claim and then wander off as if the claim stands for itself? No explanation. No insight. I mean why should we just take your word for it?<p>I&#x27;d like to be educated here why a big switch statement wouldn&#x27;t necessarily protect us from these CPU vulnerabilities? Anyone willing to help?</div><br/></div></div></div></div><div id="36853411" class="c"><input type="checkbox" id="c-36853411" checked=""/><div class="controls bullet"><span class="by">msla</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36851099">parent</a><span>|</span><a href="#36855621">prev</a><span>|</span><a href="#36851886">next</a><span>|</span><label class="collapse" for="c-36853411">[-]</label><label class="expand" for="c-36853411">[9 more]</label></div><br/><div class="children"><div class="content">This is because VM means two different things and has for a long time:<p>IBM&#x27;s VM was and is a hypervisor. It dates to the mid 1960s, in the form of CP-40, and it didn&#x27;t run opcodes in software, but in hardware.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;IBM_CP-40" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;IBM_CP-40</a><p>p-code machines, which interpret bytecode, date back almost as far, such as the O-code machine for BCPL.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;BCPL" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;BCPL</a><p>Getting people to distinguish between these concepts is probably a lost cause.</div><br/><div id="36854873" class="c"><input type="checkbox" id="c-36854873" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36853411">parent</a><span>|</span><a href="#36856137">next</a><span>|</span><label class="collapse" for="c-36854873">[-]</label><label class="expand" for="c-36854873">[6 more]</label></div><br/><div class="children"><div class="content">Looking at the IBM&#x27;s tech from the sixties is somehow weirdly depressing: it&#x27;s unbelievable how much of the architectural stuff they&#x27;ve invented already by the 1970.</div><br/><div id="36854984" class="c"><input type="checkbox" id="c-36854984" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36854873">parent</a><span>|</span><a href="#36855351">next</a><span>|</span><label class="collapse" for="c-36854984">[-]</label><label class="expand" for="c-36854984">[1 more]</label></div><br/><div class="children"><div class="content">Not depressing, but inspiring. So many great architectural ideas can be made accessible to millions of consumers, not limited to a few thousand megacorps.</div><br/></div></div><div id="36855351" class="c"><input type="checkbox" id="c-36855351" checked=""/><div class="controls bullet"><span class="by">meepmorp</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36854873">parent</a><span>|</span><a href="#36854984">prev</a><span>|</span><a href="#36856137">next</a><span>|</span><label class="collapse" for="c-36855351">[-]</label><label class="expand" for="c-36855351">[4 more]</label></div><br/><div class="children"><div class="content">I remember seeing VMware for the first time and thinking that the PC world had finally entered the 1970s.</div><br/><div id="36857099" class="c"><input type="checkbox" id="c-36857099" checked=""/><div class="controls bullet"><span class="by">cduzz</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36855351">parent</a><span>|</span><a href="#36856137">next</a><span>|</span><label class="collapse" for="c-36857099">[-]</label><label class="expand" for="c-36857099">[3 more]</label></div><br/><div class="children"><div class="content">Close, but not quite -- you can&#x27;t nest the VMs the way you can on &quot;big iron&quot;</div><br/><div id="36857218" class="c"><input type="checkbox" id="c-36857218" checked=""/><div class="controls bullet"><span class="by">jlawer</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36857099">parent</a><span>|</span><a href="#36856137">next</a><span>|</span><label class="collapse" for="c-36857218">[-]</label><label class="expand" for="c-36857218">[2 more]</label></div><br/><div class="children"><div class="content">I know Nested Virtualisation is a thing on both KVM and hyper-v, what is different about what you could do on &quot;big iron&quot;</div><br/><div id="36858050" class="c"><input type="checkbox" id="c-36858050" checked=""/><div class="controls bullet"><span class="by">vetrom</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36857218">parent</a><span>|</span><a href="#36856137">next</a><span>|</span><label class="collapse" for="c-36858050">[-]</label><label class="expand" for="c-36858050">[1 more]</label></div><br/><div class="children"><div class="content">A VM nest in &quot;big iron&quot; isn&#x27;t a special case. It&#x27;s a context push with comparatively exhaustively defined costs, side effects, and implications.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36856137" class="c"><input type="checkbox" id="c-36856137" checked=""/><div class="controls bullet"><span class="by">mr_toad</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36853411">parent</a><span>|</span><a href="#36854873">prev</a><span>|</span><a href="#36851886">next</a><span>|</span><label class="collapse" for="c-36856137">[-]</label><label class="expand" for="c-36856137">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Getting people to distinguish between these concepts is probably a lost cause.<p>I think people here of all places should distinguish between these concepts.<p>There are big performance and security implications of the two approaches.</div><br/><div id="36857426" class="c"><input type="checkbox" id="c-36857426" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36856137">parent</a><span>|</span><a href="#36851886">next</a><span>|</span><label class="collapse" for="c-36857426">[-]</label><label class="expand" for="c-36857426">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think anyone has ever been confused because of the conflation of these two terms. The context typically makes it very clear.</div><br/></div></div></div></div></div></div></div></div><div id="36851886" class="c"><input type="checkbox" id="c-36851886" checked=""/><div class="controls bullet"><span class="by">trebligdivad</span><span>|</span><a href="#36849914">parent</a><span>|</span><a href="#36851099">prev</a><span>|</span><a href="#36850515">next</a><span>|</span><label class="collapse" for="c-36851886">[-]</label><label class="expand" for="c-36851886">[1 more]</label></div><br/><div class="children"><div class="content">The comparison to Meltdown&#x2F;Spectre are a bit misleading though - they were a whole new form of attack based on timing where the CPU did exactly what it should have done; This zenbleed case is a good old fashioned bug though - data in a register that shouldn&#x27;t be.</div><br/></div></div><div id="36850515" class="c"><input type="checkbox" id="c-36850515" checked=""/><div class="controls bullet"><span class="by">c7DJTLrn</span><span>|</span><a href="#36849914">parent</a><span>|</span><a href="#36851886">prev</a><span>|</span><a href="#36859418">next</a><span>|</span><label class="collapse" for="c-36850515">[-]</label><label class="expand" for="c-36850515">[3 more]</label></div><br/><div class="children"><div class="content">Running untrusted code whether in a sandbox, container, or VM, has not been safe since at least Rowhammer, maybe before. I believe a lot of these exploits are down to software and hardware people not talking. Software people make assumptions about the isolation guarantees, hardware people don&#x27;t speak up when said assumptions are made.</div><br/><div id="36854731" class="c"><input type="checkbox" id="c-36854731" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36850515">parent</a><span>|</span><a href="#36857435">next</a><span>|</span><label class="collapse" for="c-36854731">[-]</label><label class="expand" for="c-36854731">[1 more]</label></div><br/><div class="children"><div class="content">That is not true in this case. It&#x27;s just a CPU bug; not even a side channel.</div><br/></div></div><div id="36857435" class="c"><input type="checkbox" id="c-36857435" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36850515">parent</a><span>|</span><a href="#36854731">prev</a><span>|</span><a href="#36859418">next</a><span>|</span><label class="collapse" for="c-36857435">[-]</label><label class="expand" for="c-36857435">[1 more]</label></div><br/><div class="children"><div class="content">Hardware people are the ones making those promises, so I don&#x27;t think that&#x27;s right at all. And Rowhammer is a way overstated vulnerability - there are all sorts of practical issues with it, especially if you&#x27;re on modern, patched hardware.</div><br/></div></div></div></div><div id="36859418" class="c"><input type="checkbox" id="c-36859418" checked=""/><div class="controls bullet"><span class="by">alecco</span><span>|</span><a href="#36849914">parent</a><span>|</span><a href="#36850515">prev</a><span>|</span><a href="#36850784">next</a><span>|</span><label class="collapse" for="c-36859418">[-]</label><label class="expand" for="c-36859418">[1 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t VMs zero all registers when switching? It shouldn&#x27;t be much more latency than a typical context switch. Also purge CPU cache to be safe.</div><br/></div></div><div id="36850784" class="c"><input type="checkbox" id="c-36850784" checked=""/><div class="controls bullet"><span class="by">Bluecobra</span><span>|</span><a href="#36849914">parent</a><span>|</span><a href="#36859418">prev</a><span>|</span><a href="#36857582">next</a><span>|</span><label class="collapse" for="c-36850784">[-]</label><label class="expand" for="c-36850784">[14 more]</label></div><br/><div class="children"><div class="content">Yup!  I worked at a few companies that would co-mingle Internet facing&#x2F;DMZ VMs with internal VMs.  When pointing this out and recommending we should airgap these VMs to it&#x27;s own dedicated hypervisor it always fell on deaf ears. Jokes on them I guess.</div><br/><div id="36854002" class="c"><input type="checkbox" id="c-36854002" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36850784">parent</a><span>|</span><a href="#36857582">next</a><span>|</span><label class="collapse" for="c-36854002">[-]</label><label class="expand" for="c-36854002">[13 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure AWS&#x2F;Azure&#x2F;GCP don’t assign separate boxes to every customer, and somehow they’re fine.</div><br/><div id="36859535" class="c"><input type="checkbox" id="c-36859535" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36854002">parent</a><span>|</span><a href="#36854130">next</a><span>|</span><label class="collapse" for="c-36859535">[-]</label><label class="expand" for="c-36859535">[1 more]</label></div><br/><div class="children"><div class="content">They keep breaches quiet so we don&#x27;t know how porous their security is in practice.</div><br/></div></div><div id="36854130" class="c"><input type="checkbox" id="c-36854130" checked=""/><div class="controls bullet"><span class="by">yencabulator</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36854002">parent</a><span>|</span><a href="#36859535">prev</a><span>|</span><a href="#36857452">next</a><span>|</span><label class="collapse" for="c-36854130">[-]</label><label class="expand" for="c-36854130">[6 more]</label></div><br/><div class="children"><div class="content">You can pay AWS a premium to make sure you&#x27;re the only tenant on the physical machine. You can also split your own stuff into multiple tenants, and keep those separate too.</div><br/><div id="36857674" class="c"><input type="checkbox" id="c-36857674" checked=""/><div class="controls bullet"><span class="by">segfaultbuserr</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36854130">parent</a><span>|</span><a href="#36855036">next</a><span>|</span><label class="collapse" for="c-36857674">[-]</label><label class="expand" for="c-36857674">[3 more]</label></div><br/><div class="children"><div class="content">Eric Brandwine (VP&#x2F;DE @ AWS) said publicly in 2019 that EC2 had never scheduled different tenants on the same physical core at the same time, even before we learned about these kinds of side-channel attacks.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=kQ4H6XO-iao&amp;t=2485s">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=kQ4H6XO-iao&amp;t=2485s</a></div><br/><div id="36858082" class="c"><input type="checkbox" id="c-36858082" checked=""/><div class="controls bullet"><span class="by">vetrom</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36857674">parent</a><span>|</span><a href="#36857714">next</a><span>|</span><label class="collapse" for="c-36858082">[-]</label><label class="expand" for="c-36858082">[1 more]</label></div><br/><div class="children"><div class="content">Even before then, the sufficiently paranoid (but still bound to AWS for whatever reason) would track usage&#x2F;steal&#x2F;IO reporting along with best guesses for Amazon hardware expidenture and use that information to size instances to attempt to coincide with 1:1 node membership.</div><br/></div></div><div id="36857714" class="c"><input type="checkbox" id="c-36857714" checked=""/><div class="controls bullet"><span class="by">yencabulator</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36857674">parent</a><span>|</span><a href="#36858082">prev</a><span>|</span><a href="#36855036">next</a><span>|</span><label class="collapse" for="c-36857714">[-]</label><label class="expand" for="c-36857714">[1 more]</label></div><br/><div class="children"><div class="content">Yes (lowest vCPU seems to be 2 everywhere), and that protects against this attack. However, this thread was talking about airgapping hosts, which is needed for the general threat of VM escapes.</div><br/></div></div></div></div><div id="36855036" class="c"><input type="checkbox" id="c-36855036" checked=""/><div class="controls bullet"><span class="by">nicolas_17</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36854130">parent</a><span>|</span><a href="#36857674">prev</a><span>|</span><a href="#36857452">next</a><span>|</span><label class="collapse" for="c-36855036">[-]</label><label class="expand" for="c-36855036">[2 more]</label></div><br/><div class="children"><div class="content">At which point you don&#x27;t really need the flexibility of AWS and you might as well get a Dedicated Server elsewhere?</div><br/><div id="36855054" class="c"><input type="checkbox" id="c-36855054" checked=""/><div class="controls bullet"><span class="by">yencabulator</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36855036">parent</a><span>|</span><a href="#36857452">next</a><span>|</span><label class="collapse" for="c-36855054">[-]</label><label class="expand" for="c-36855054">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;ll still let you do the elastic scaling stuff, billing for actual usage instead of racked hardware.</div><br/></div></div></div></div></div></div><div id="36857452" class="c"><input type="checkbox" id="c-36857452" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36854002">parent</a><span>|</span><a href="#36854130">prev</a><span>|</span><a href="#36856192">next</a><span>|</span><label class="collapse" for="c-36857452">[-]</label><label class="expand" for="c-36857452">[2 more]</label></div><br/><div class="children"><div class="content">Yes but the Firecracker VMs are pinned to specific cores. So no two tenants never share a CPU core. Other than Rowhammer, has there been a hardware vulnerability of this nature that has worked x-core? I don&#x27;t recall.<p>Still, I think that if your company is handling user data it&#x27;s worth seriously considering dedicated instances for any service that encounters plaintext user information.</div><br/><div id="36859539" class="c"><input type="checkbox" id="c-36859539" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36857452">parent</a><span>|</span><a href="#36856192">next</a><span>|</span><label class="collapse" for="c-36859539">[-]</label><label class="expand" for="c-36859539">[1 more]</label></div><br/><div class="children"><div class="content">Interesting. Physical cores or SMT virtual cores? Is there a link to their docs about this?</div><br/></div></div></div></div><div id="36856192" class="c"><input type="checkbox" id="c-36856192" checked=""/><div class="controls bullet"><span class="by">akyuu</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36854002">parent</a><span>|</span><a href="#36857452">prev</a><span>|</span><a href="#36854847">next</a><span>|</span><label class="collapse" for="c-36856192">[-]</label><label class="expand" for="c-36856192">[1 more]</label></div><br/><div class="children"><div class="content">Not sure if they&#x27;re actually fine, some researchers have exploited this vulnerability on AWS instances that use affected EPYC CPUs: <a href="https:&#x2F;&#x2F;twitter.com&#x2F;0xdabbad00&#x2F;status&#x2F;1683581484337348608" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;0xdabbad00&#x2F;status&#x2F;1683581484337348608</a></div><br/></div></div><div id="36854847" class="c"><input type="checkbox" id="c-36854847" checked=""/><div class="controls bullet"><span class="by">Bluecobra</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36854002">parent</a><span>|</span><a href="#36856192">prev</a><span>|</span><a href="#36856278">next</a><span>|</span><label class="collapse" for="c-36854847">[-]</label><label class="expand" for="c-36854847">[1 more]</label></div><br/><div class="children"><div class="content">Good point, I should have clarified that I was talking about on-prem VMs e.g. VMWare.</div><br/></div></div><div id="36856278" class="c"><input type="checkbox" id="c-36856278" checked=""/><div class="controls bullet"><span class="by">mr_toad</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36854002">parent</a><span>|</span><a href="#36854847">prev</a><span>|</span><a href="#36857582">next</a><span>|</span><label class="collapse" for="c-36856278">[-]</label><label class="expand" for="c-36856278">[1 more]</label></div><br/><div class="children"><div class="content">Just running on a separate core would avoid this bug.</div><br/></div></div></div></div></div></div><div id="36850512" class="c"><input type="checkbox" id="c-36850512" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#36849914">parent</a><span>|</span><a href="#36857582">prev</a><span>|</span><a href="#36850723">next</a><span>|</span><label class="collapse" for="c-36850512">[-]</label><label class="expand" for="c-36850512">[15 more]</label></div><br/><div class="children"><div class="content">In the end, I&#x27;m thinking <i>most</i> of these are related to branch prediction?<p>It strikes me that it&#x27;s either that branch prediction is so inherently complex enough it&#x27;s always going to be vulnerable to this <i>and&#x2F;or</i> it just so defies the way most of us intuitively think about code paths &#x2F; instruction execution that it&#x27;s hard to conceive of the edge cases until too late?<p>At what point does the complexity of CPU architectures become so difficult to reason about that we just accept the performance penalty of keeping it simpler?</div><br/><div id="36850801" class="c"><input type="checkbox" id="c-36850801" checked=""/><div class="controls bullet"><span class="by">paulmd</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36850512">parent</a><span>|</span><a href="#36850766">next</a><span>|</span><label class="collapse" for="c-36850801">[-]</label><label class="expand" for="c-36850801">[1 more]</label></div><br/><div class="children"><div class="content">More generally, most of them are related to speculative execution, where branch mis-prediction is a common gadget to induce speculative mis-execution.<p>Speculation is hard, it&#x27;s sort of akin to the idea of introducing multithreading into a program, you are explicitly choosing to tilt at the windmill of pure technical correctness because in a highly concurrent application every error will occur fairly routinely.  Speculation is great too, in combination with out-of-order execution it&#x27;s a multithreading-like boon to overall performance, because now you can resolve several chunks of code in parallel instead of one at a time.  It&#x27;s just also a minefield of correctness issues, but the alternative would be losing something like the equivalent of 10 years of performance gains (going back to like ARM A53 performance).<p>The recent thing is that &quot;observably correct&quot; needs to include timings.  If you can just guess at what the data might be, and the program runs faster if you&#x27;re correct, that&#x27;s basically the same thing as reading the data by another means.  It&#x27;s a timing oracle attack.<p>(in this case AMD just fucked up though, there&#x27;s no timing attack, this is just implemented wrong and this instruction can speculate against changes that haven&#x27;t propagated to other parts of the pipeline yet)<p>The cache is the other problem, modern processors are built with every tenant sharing this single big L3 cache and it turns out that it also needs to be proof against timing attacks for data present in the cache too.</div><br/></div></div><div id="36850766" class="c"><input type="checkbox" id="c-36850766" checked=""/><div class="controls bullet"><span class="by">Tuna-Fish</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36850512">parent</a><span>|</span><a href="#36850801">prev</a><span>|</span><a href="#36852065">next</a><span>|</span><label class="collapse" for="c-36850766">[-]</label><label class="expand" for="c-36850766">[5 more]</label></div><br/><div class="children"><div class="content">&gt; At what point does the complexity of CPU architectures become so difficult to reason about that we just accept the performance penalty of keeping it simpler?<p>Never for branch prediction. It just gets you too much performance. If it becomes too much of a problem, the solution is greater isolation of workloads.</div><br/><div id="36854835" class="c"><input type="checkbox" id="c-36854835" checked=""/><div class="controls bullet"><span class="by">hedgehog</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36850766">parent</a><span>|</span><a href="#36852065">next</a><span>|</span><label class="collapse" for="c-36854835">[-]</label><label class="expand" for="c-36854835">[4 more]</label></div><br/><div class="children"><div class="content">In certain cases isolation and simplicity overlap, I suspect for example that the dangers of SMT implementation complexity are part of why Apple didn&#x27;t implement it for their respective CPUs. Likely we&#x27;ll see this elsewhere too, for example Amazon may not ever push to have SMT in their Graviton chips (the early generations are off the shelf cores from ARM where they didn&#x27;t have a readily available choice).</div><br/><div id="36855727" class="c"><input type="checkbox" id="c-36855727" checked=""/><div class="controls bullet"><span class="by">asdfasgasdgasdg</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36854835">parent</a><span>|</span><a href="#36855876">next</a><span>|</span><label class="collapse" for="c-36855727">[-]</label><label class="expand" for="c-36855727">[1 more]</label></div><br/><div class="children"><div class="content">I could be mistaken, but I don&#x27;t think Zenbleed has anything to do with SMT, based on my reading of the document. There is a mention of hyperthreads sharing the same physical registers, but you can spy on anything happening on the same physical core, because the register file is shared across the whole core.<p>It even says so in the document:<p><pre><code>    Note that it is not sufficient to disable SMT.
</code></pre>
Apple&#x27;s chips don&#x27;t have this vulnerability, but it&#x27;s not because they don&#x27;t have SMT. They just didn&#x27;t write this particular defect into their CPU implementation.</div><br/></div></div><div id="36855876" class="c"><input type="checkbox" id="c-36855876" checked=""/><div class="controls bullet"><span class="by">meithecatte</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36854835">parent</a><span>|</span><a href="#36855727">prev</a><span>|</span><a href="#36852065">next</a><span>|</span><label class="collapse" for="c-36855876">[-]</label><label class="expand" for="c-36855876">[2 more]</label></div><br/><div class="children"><div class="content">Eh, as long as you assign both hyper-threads to the same tenant, and schedule them at the same time, you should be fine.</div><br/><div id="36859747" class="c"><input type="checkbox" id="c-36859747" checked=""/><div class="controls bullet"><span class="by">throwawaylinux</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36855876">parent</a><span>|</span><a href="#36852065">next</a><span>|</span><label class="collapse" for="c-36859747">[-]</label><label class="expand" for="c-36859747">[1 more]</label></div><br/><div class="children"><div class="content">Not really if that&#x27;s an attack you&#x27;re concerned about, because guests can attack the hypervisor via the same mechanisms. You would need to gang schedule to ensure all threads of a core were only either in host or guest.</div><br/></div></div></div></div></div></div></div></div><div id="36852065" class="c"><input type="checkbox" id="c-36852065" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36850512">parent</a><span>|</span><a href="#36850766">prev</a><span>|</span><a href="#36856262">next</a><span>|</span><label class="collapse" for="c-36852065">[-]</label><label class="expand" for="c-36852065">[1 more]</label></div><br/><div class="children"><div class="content">&gt;At what point does the complexity of CPU architectures become so difficult to reason about that we just accept the performance penalty of keeping it simpler?<p>Basically never for anything that&#x27;s at all CPU-bound, that growth in complexity is really the only thing that&#x27;s been powering single-threaded CPU performance improvements since Dennard scaling stopped in about 2006 (and by that time they were already plenty complex: by the late 90s and early 2000&#x27;s x86 CPUs were firmly superscalar, out-of-order, branch-predicting and speculative executing devices). If your workload can be made fast without needing that stuff (i.e. no branches and easily parallelised), you&#x27;re probably using a GPU instead nowadays.</div><br/></div></div><div id="36856262" class="c"><input type="checkbox" id="c-36856262" checked=""/><div class="controls bullet"><span class="by">kiririn</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36850512">parent</a><span>|</span><a href="#36852065">prev</a><span>|</span><a href="#36850707">next</a><span>|</span><label class="collapse" for="c-36856262">[-]</label><label class="expand" for="c-36856262">[1 more]</label></div><br/><div class="children"><div class="content">You can rent one of the Atom Kimsufi boxes (N2800) to experience first hand a cpu with no speculative execution. The performance is dire, but at least it hasn’t gotten worse over the years - they are immune to just about everything</div><br/></div></div><div id="36850707" class="c"><input type="checkbox" id="c-36850707" checked=""/><div class="controls bullet"><span class="by">c7DJTLrn</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36850512">parent</a><span>|</span><a href="#36856262">prev</a><span>|</span><a href="#36858115">next</a><span>|</span><label class="collapse" for="c-36850707">[-]</label><label class="expand" for="c-36850707">[2 more]</label></div><br/><div class="children"><div class="content">We demanded more performance and we got what we demanded. I doubt manufacturers are going to walk back on branch prediction no matter how flawed it is. They&#x27;ll add some more mitigations and features which will be broken-on-arrival.</div><br/><div id="36857768" class="c"><input type="checkbox" id="c-36857768" checked=""/><div class="controls bullet"><span class="by">myself248</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36850707">parent</a><span>|</span><a href="#36858115">next</a><span>|</span><label class="collapse" for="c-36857768">[-]</label><label class="expand" for="c-36857768">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t demand more performance. My 2008-era AthlonX2 would still be relevant if web browsers hadn&#x27;t gotten so bloated. I still use it for real desktop applications, i.e. everything that isn&#x27;t in Electron.</div><br/></div></div></div></div><div id="36858115" class="c"><input type="checkbox" id="c-36858115" checked=""/><div class="controls bullet"><span class="by">vetrom</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36850512">parent</a><span>|</span><a href="#36850707">prev</a><span>|</span><a href="#36851319">next</a><span>|</span><label class="collapse" for="c-36858115">[-]</label><label class="expand" for="c-36858115">[1 more]</label></div><br/><div class="children"><div class="content">Theres VLIW&#x2F;&#x27;preprediction&#x27;&#x2F;some other technical name I forget for infrastructures which instead ask you to explicitly schedule instruction&#x2F;data&#x2F;branch prediction. If I remember, the two biggest examples I can think of were IA64 and Alpha. I wanna think HP-PA did the same but I&#x27;m not clear on that one.<p>For various reasons, all these infras eventually lost out in the market due to market pressure (and cost&#x2F;watt&#x2F;IPC, I guess).</div><br/></div></div><div id="36851319" class="c"><input type="checkbox" id="c-36851319" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36850512">parent</a><span>|</span><a href="#36858115">prev</a><span>|</span><a href="#36851033">next</a><span>|</span><label class="collapse" for="c-36851319">[-]</label><label class="expand" for="c-36851319">[2 more]</label></div><br/><div class="children"><div class="content">If you pin the VM to a different core&#x2F;CPU, would that do anything to mitigate? Or are the OS affinity guarantees not that strong?</div><br/><div id="36854751" class="c"><input type="checkbox" id="c-36854751" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36851319">parent</a><span>|</span><a href="#36851033">next</a><span>|</span><label class="collapse" for="c-36854751">[-]</label><label class="expand" for="c-36854751">[1 more]</label></div><br/><div class="children"><div class="content">In this case, it would avoid the exploit, because it requires a shared register file.</div><br/></div></div></div></div><div id="36851033" class="c"><input type="checkbox" id="c-36851033" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36850512">parent</a><span>|</span><a href="#36851319">prev</a><span>|</span><a href="#36850723">next</a><span>|</span><label class="collapse" for="c-36851033">[-]</label><label class="expand" for="c-36851033">[1 more]</label></div><br/><div class="children"><div class="content">Speculative execution, not branch prediction.</div><br/></div></div></div></div><div id="36850723" class="c"><input type="checkbox" id="c-36850723" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#36849914">parent</a><span>|</span><a href="#36850512">prev</a><span>|</span><a href="#36856588">next</a><span>|</span><label class="collapse" for="c-36850723">[-]</label><label class="expand" for="c-36850723">[17 more]</label></div><br/><div class="children"><div class="content">In the case of the VM won&#x27;t registers be wiped when entering&#x2F;exiting the VM?</div><br/><div id="36855266" class="c"><input type="checkbox" id="c-36855266" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36850723">parent</a><span>|</span><a href="#36851023">next</a><span>|</span><label class="collapse" for="c-36855266">[-]</label><label class="expand" for="c-36855266">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that the <i>logical</i> registers don&#x27;t have a 1:1 relation to the <i>physical</i> registers.<p>For example, let&#x27;s imagine a toy architecture with two registers: r0 and r1. We can create a little assembly snippet using them: &quot;r0 = load(addr1); r1 = load(addr2); r0 = r0 + r1; store(addr3, r0)&quot;. Pretty simple.<p>Now, what happens if we want to do that <i>twice</i>? Well, we get something like &quot;r0 = load(addr1); r1 = load(addr2); r0 = r0 + r1; store(addr3, r0); r0 = load(addr4); r1 = load(addr5); r0 = r0 + r1; store(addr6, r0)&quot;. Because there is no overlap between the accessed memory sections, they are completely independent. In theory they could even execute at the same time - but that is impossible because they use the same registers.<p>This can be solved by adding more physical registers to the CPU, let&#x27;s call them R0-R6. During execution the CPU can now analyze and rewrite the original assembly into &quot;R1 = load(addr1); R4 = load(addr4); R2 = load(addr2); R5 = load(addr5); R3 = R1 + R2; R6 = R4 + R5; store(addr3, R3); store(addr6, R6)&quot;. This means we can now start the loads for the second addition before the first addition is done, which means we have to wait less time for the data to arrive when we finally want to actually do the second addition. To the user nothing has changed and the results are identical!<p>The issue here is that when entering&#x2F;exiting a VM you can definitely clear the logical registers r0&amp;r1, but there is no guarantee that you are <i>actually</i> clearing the physical registers. On a hardware level, &quot;clearing a register&quot; now means &quot;mark logical register as empty&quot;. The CPU makes sure that any future use of that <i>logical</i> register results in it behaving <i>as if</i> it has been clear, but there is no need to touch the content of the <i>physical</i> register. It just gets marked as &quot;free for use&quot;. The only way that physical register becomes available again is after a write, after all, and that write would by definition overwrite the stale content - so clearing it would be pointless. Unless your CPU misbehaves and you run into this new bug, of course.</div><br/></div></div><div id="36851023" class="c"><input type="checkbox" id="c-36851023" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36850723">parent</a><span>|</span><a href="#36855266">prev</a><span>|</span><a href="#36856588">next</a><span>|</span><label class="collapse" for="c-36851023">[-]</label><label class="expand" for="c-36851023">[15 more]</label></div><br/><div class="children"><div class="content">The problem is the freed entries in the register file.  A VM can, at least, use this bug to read registers from a non-VM thread running on the adjacent SMT&#x2F;HT of a single physical core.  I suspect a VM could also read registers from other processes scheduled on the same SMT&#x2F;HT.</div><br/><div id="36851127" class="c"><input type="checkbox" id="c-36851127" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36851023">parent</a><span>|</span><a href="#36852689">next</a><span>|</span><label class="collapse" for="c-36851127">[-]</label><label class="expand" for="c-36851127">[13 more]</label></div><br/><div class="children"><div class="content">Are people running multiple untrusted VMs without turning SMT off? Even letting them share caches seems like asking for trouble.</div><br/><div id="36852451" class="c"><input type="checkbox" id="c-36852451" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36851127">parent</a><span>|</span><a href="#36851395">next</a><span>|</span><label class="collapse" for="c-36852451">[-]</label><label class="expand" for="c-36852451">[7 more]</label></div><br/><div class="children"><div class="content">Not only do people do this, it&#x27;s generally how VPS providers work. Most machines barely use the CPU most of the time (web servers etc.) so reserving a full CPU core for a VPS is horribly inefficient. It doesn&#x27;t matter anyway, because SMT isn&#x27;t relevant for this particular bug.<p>With SMT allowing twice the cores on a CPU for most workloads, disabling it would double the cost for most providers!<p>There are VPS providers that will let you rent dedicated CPU cores, but they often cost 4-5x more than a normal virtual CPU. Overprovisioning is how virtual servers are available for cheap!</div><br/><div id="36852745" class="c"><input type="checkbox" id="c-36852745" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36852451">parent</a><span>|</span><a href="#36852557">next</a><span>|</span><label class="collapse" for="c-36852745">[-]</label><label class="expand" for="c-36852745">[4 more]</label></div><br/><div class="children"><div class="content">SMT is relevant in the VM case of this bug because it determines whether this bug is restricted to data outside the VM or not.<p>Providers usually won&#x27;t disable SMT completely, they&#x27;d run a scheduler which only allows 1 VM to use both SMT threads of a core. Ultra cheap VPS providers may still find that not worth the pennies though as if you sell a majority of single core VPS then the majority of your SMT threads are still unavailable even with the scheduler approach.<p>Fully dedicated cores aren&#x27;t necessarily required because in the timesliced case the registers are unloaded and reloaded when different VMs are shuffled on and off the core. That said, they definitely prevent the cross-vm-data-leak case of this bug.</div><br/><div id="36853103" class="c"><input type="checkbox" id="c-36853103" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36852745">parent</a><span>|</span><a href="#36852557">next</a><span>|</span><label class="collapse" for="c-36853103">[-]</label><label class="expand" for="c-36853103">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Fully dedicated cores aren&#x27;t necessarily required because in the timesliced case the registers are unloaded and reloaded when different VMs are shuffled on and off the core. That said, they definitely prevent the cross-vm-data-leak case of this bug.<p>Registers are unloaded and reloaded when different processes &#x2F; threads are scheduled within a running VM too. That <i>should</i> protect the register contents, but because of this issue, it doesn&#x27;t, so I don&#x27;t see why it would if it&#x27;s a hypervisor switching VMs instead of an OS switching processes. If you&#x27;re running a vulnerable processor on a vulnerable microcode, it seems like you can potentially read things put into the vulnerable registers by anything else running on the same physical core, regardless of context.</div><br/><div id="36856989" class="c"><input type="checkbox" id="c-36856989" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36853103">parent</a><span>|</span><a href="#36852557">next</a><span>|</span><label class="collapse" for="c-36856989">[-]</label><label class="expand" for="c-36856989">[2 more]</label></div><br/><div class="children"><div class="content">Context switching for processes is done in software (i.e. the OS) via traps because TSS does not store all the registers and it doesn&#x27;t offer a way to be selective to what the process actually needs to load (=slower). This limits its visibility to what&#x27;s in the actively mapped registers as well as not guaranteeing the procedure even tries to reload all the registers. In this case, even if the OS does restore  certain registers it has no way to know the processor left specific bits of one speculatively set in the register file.<p>On the other hand, &quot;context switching&quot; for VMs is done via hardware commands like VMSAVE&#x2F;VMLOAD or VMWRITE&#x2F;VMREAD which do save&#x2F;load the entire guest register context, including the hidden context not accessible by software which this CVE is relying on. Not that it isn&#x27;t impossible for this to be broken as well, but it&#x27;s a completely different procedure and one the hardware is actually responsible for completely clearing instead of &quot;supposed to be reset by software&quot;.<p>So while the CVE still affects processes inside of VMs the loading&#x2F;unloading behavior inter VM should actually behave as a working sandbox and protect against cross-VM leaks, barring the note by lieg on SMT still possibly being a problem (I don&#x27;t know enough about how the hardware maintains the register table between SMT threads of different VMs to say for sure but I&#x27;m willing to guess it&#x27;s still vulnerable on register remappings).<p>There may well be other reasons I&#x27;m completely mistaken here but they&#x27;d have to explain why the inter-VM context restore is broken not why it works for inter-process restore. The article already explains why the latter happens, but it doesn&#x27;t make a claim about the former.</div><br/><div id="36857836" class="c"><input type="checkbox" id="c-36857836" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36856989">parent</a><span>|</span><a href="#36852557">next</a><span>|</span><label class="collapse" for="c-36857836">[-]</label><label class="expand" for="c-36857836">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t easily find good documentation on the instructions you mentioned; but are you sure those save and load the whole register file, and not just the visible registers? There are some registers that are not typically explicitly visible, that I&#x27;d expect to also be saved or at least manipulable in a hypervisor, but just like the cache state isn&#x27;t saved, I wouldn&#x27;t expect the register file to be saved.<p>If we assume the register file isn&#x27;t saved, just the visible registers, what&#x27;s happening is the visible registers are restored, but the speculative dance causes one of the other values in the register file to become visible. If that&#x27;s one of the restored registers, no big deal, but if it was someone else&#x27;s value, there&#x27;s the exploit.<p>If you look at the exploit example, the trick is that when the register rename happens, you are re-using a register file entry, but the upper bits aren&#x27;t cleared, they&#x27;re just using a flag to indicate the bits are cleared; then when rolling back the mispredicted vzeroupper unsets the flag, the upper bits of the register file entry are revealed.</div><br/></div></div></div></div></div></div></div></div><div id="36852557" class="c"><input type="checkbox" id="c-36852557" checked=""/><div class="controls bullet"><span class="by">KeplerBoy</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36852451">parent</a><span>|</span><a href="#36852745">prev</a><span>|</span><a href="#36851395">next</a><span>|</span><label class="collapse" for="c-36852557">[-]</label><label class="expand" for="c-36852557">[2 more]</label></div><br/><div class="children"><div class="content">Well you don&#x27;t have to reserve any CPU Cores per VM. There&#x27;s no law saying you can&#x27;t have more VMs than logical cores. They&#x27;re just processes after all and we can have thousands of them.</div><br/><div id="36853891" class="c"><input type="checkbox" id="c-36853891" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36852557">parent</a><span>|</span><a href="#36851395">next</a><span>|</span><label class="collapse" for="c-36853891">[-]</label><label class="expand" for="c-36853891">[1 more]</label></div><br/><div class="children"><div class="content">Of course not, but the vulnerability works by exploiting the shared register file so to mitigate this entire class of vulnerabilities, you&#x27;d need to dedicate a CPU core and as much of its associated cache as possible to a single VM.</div><br/></div></div></div></div></div></div><div id="36851395" class="c"><input type="checkbox" id="c-36851395" checked=""/><div class="controls bullet"><span class="by">Astronaut3315</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36851127">parent</a><span>|</span><a href="#36852451">prev</a><span>|</span><a href="#36852319">next</a><span>|</span><label class="collapse" for="c-36851395">[-]</label><label class="expand" for="c-36851395">[2 more]</label></div><br/><div class="children"><div class="content">This specific CVE still applies even if SMT is off, per the article.</div><br/><div id="36852483" class="c"><input type="checkbox" id="c-36852483" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36851395">parent</a><span>|</span><a href="#36852319">next</a><span>|</span><label class="collapse" for="c-36852483">[-]</label><label class="expand" for="c-36852483">[1 more]</label></div><br/><div class="children"><div class="content">In the context of this conversation, SMT on&#x2F;off is relevant to what scope of the vulnerability has with VMs beyond the claim in the article that the issue is in some way present inside VMs.</div><br/></div></div></div></div><div id="36852319" class="c"><input type="checkbox" id="c-36852319" checked=""/><div class="controls bullet"><span class="by">bbojan</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36851127">parent</a><span>|</span><a href="#36851395">prev</a><span>|</span><a href="#36851182">next</a><span>|</span><label class="collapse" for="c-36852319">[-]</label><label class="expand" for="c-36852319">[2 more]</label></div><br/><div class="children"><div class="content">The fine article states that simply turning off SMT doesn&#x27;t help with this particular exploit.</div><br/><div id="36852493" class="c"><input type="checkbox" id="c-36852493" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36852319">parent</a><span>|</span><a href="#36851182">next</a><span>|</span><label class="collapse" for="c-36852493">[-]</label><label class="expand" for="c-36852493">[1 more]</label></div><br/><div class="children"><div class="content">In the context of this conversation, SMT on&#x2F;off is relevant to what scope of the vulnerability has with VMs beyond the claim in the article that the issue is in some way present inside VMs.</div><br/></div></div></div></div><div id="36851182" class="c"><input type="checkbox" id="c-36851182" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36851127">parent</a><span>|</span><a href="#36852319">prev</a><span>|</span><a href="#36852689">next</a><span>|</span><label class="collapse" for="c-36851182">[-]</label><label class="expand" for="c-36851182">[1 more]</label></div><br/><div class="children"><div class="content">Someone, somewhere is, of course.  I don&#x27;t know if the hyperscalers do, or not.</div><br/></div></div></div></div><div id="36852689" class="c"><input type="checkbox" id="c-36852689" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36851023">parent</a><span>|</span><a href="#36851127">prev</a><span>|</span><a href="#36856588">next</a><span>|</span><label class="collapse" for="c-36852689">[-]</label><label class="expand" for="c-36852689">[1 more]</label></div><br/><div class="children"><div class="content">Ah, this is a good point for those still using hypervisor schedulers which allow mapping different VMs to the same core.</div><br/></div></div></div></div></div></div><div id="36856588" class="c"><input type="checkbox" id="c-36856588" checked=""/><div class="controls bullet"><span class="by">api</span><span>|</span><a href="#36849914">parent</a><span>|</span><a href="#36850723">prev</a><span>|</span><a href="#36853224">next</a><span>|</span><label class="collapse" for="c-36856588">[-]</label><label class="expand" for="c-36856588">[2 more]</label></div><br/><div class="children"><div class="content">I’m quite surprised there hasn’t been a cloud apocalypse yet where something just runs rampant through AWS or something.</div><br/><div id="36857843" class="c"><input type="checkbox" id="c-36857843" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#36849914">root</a><span>|</span><a href="#36856588">parent</a><span>|</span><a href="#36853224">next</a><span>|</span><label class="collapse" for="c-36857843">[-]</label><label class="expand" for="c-36857843">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s still early days for the cloud. I&#x27;m pretty sure such a thing will happen sooner or later.</div><br/></div></div></div></div><div id="36853224" class="c"><input type="checkbox" id="c-36853224" checked=""/><div class="controls bullet"><span class="by">stcredzero</span><span>|</span><a href="#36849914">parent</a><span>|</span><a href="#36856588">prev</a><span>|</span><a href="#36851906">next</a><span>|</span><label class="collapse" for="c-36853224">[-]</label><label class="expand" for="c-36853224">[1 more]</label></div><br/><div class="children"><div class="content"><i>this is a no-breakout massive exploit that is simple to execute and gives big payoffs</i><p>Wouldn&#x27;t we be able to avoid the &quot;big payoffs&quot; of no-breakout exploits if we had specialized hardware handle the secrets?</div><br/></div></div></div></div><div id="36851906" class="c"><input type="checkbox" id="c-36851906" checked=""/><div class="controls bullet"><span class="by">nemetroid</span><span>|</span><a href="#36849914">prev</a><span>|</span><a href="#36850148">next</a><span>|</span><label class="collapse" for="c-36851906">[-]</label><label class="expand" for="c-36851906">[8 more]</label></div><br/><div class="children"><div class="content">The README in the tar file with the exploit (linked at &quot;If you want to test the exploit, the code is available here&quot;) contains some more details, including a timeline:<p>- `2023-05-09` A component of our CPU validation pipeline generates an anomalous result.<p>- `2023-05-12` We successfully isolate and reproduce the issue. Investigation continues.<p>- `2023-05-14` We are now aware of the scope and severity of the issue.<p>- `2023-05-15` We draft a brief status report and share our findings with AMD PSIRT.<p>- `2023-05-17` AMD acknowledge our report and confirm they can reproduce the issue.<p>- `2023-05-17` We complete development of a reliable PoC and share it with AMD.<p>- `2023-05-19` We begin to notify major kernel and hypervisor vendors.<p>- `2023-05-23` We receive a beta microcode update for Rome from AMD.<p>- `2023-05-24` We confirm the update fixes the issue and notify AMD.<p>- `2023-05-30` AMD inform us they have sent a SN (security notice) to partners.<p>- `2023-06-12` Meeting with AMD to discuss status and details.<p>- `2023-07-20` AMD unexpectedly publish patches, earlier than an agreed embargo date.<p>- `2023-07-21` As the fix is now public, we propose privately notifying major
               distributions that they should begin preparing updated firmware
               packages.<p>- `2023-07-24` Public disclosure.</div><br/><div id="36852390" class="c"><input type="checkbox" id="c-36852390" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#36851906">parent</a><span>|</span><a href="#36850148">next</a><span>|</span><label class="collapse" for="c-36852390">[-]</label><label class="expand" for="c-36852390">[7 more]</label></div><br/><div class="children"><div class="content">&gt; AMD unexpectedly publish patches, earlier than an agreed embargo date.<p>&gt; As the fix is now public, we propose privately notifying major distributions that they should begin preparing updated firmware packages.<p>AMD had to drop the ball somewhere didn&#x27;t it.</div><br/><div id="36853696" class="c"><input type="checkbox" id="c-36853696" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#36851906">root</a><span>|</span><a href="#36852390">parent</a><span>|</span><a href="#36850148">next</a><span>|</span><label class="collapse" for="c-36853696">[-]</label><label class="expand" for="c-36853696">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s <i>good</i> that they published patches early, isn&#x27;t it?</div><br/><div id="36853788" class="c"><input type="checkbox" id="c-36853788" checked=""/><div class="controls bullet"><span class="by">robryk</span><span>|</span><a href="#36851906">root</a><span>|</span><a href="#36853696">parent</a><span>|</span><a href="#36853791">next</a><span>|</span><label class="collapse" for="c-36853788">[-]</label><label class="expand" for="c-36853788">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;d want the delay between first publication of X and the microcode update making its way into releases of OSes to be smallest, for various values of X (mention of a vulnerability, microcode patch, description of vulnerability, PoC). Making various OS releasers aware that a microcode patch that fixes a vulnerability will be published on a given date before that date decreases that for most values of X.</div><br/></div></div><div id="36853791" class="c"><input type="checkbox" id="c-36853791" checked=""/><div class="controls bullet"><span class="by">taviso</span><span>|</span><a href="#36851906">root</a><span>|</span><a href="#36853696">parent</a><span>|</span><a href="#36853788">prev</a><span>|</span><a href="#36853839">next</a><span>|</span><label class="collapse" for="c-36853791">[-]</label><label class="expand" for="c-36853791">[3 more]</label></div><br/><div class="children"><div class="content">Yes. It was unexpected, but good. Not a complaint.</div><br/><div id="36859505" class="c"><input type="checkbox" id="c-36859505" checked=""/><div class="controls bullet"><span class="by">underdeserver</span><span>|</span><a href="#36851906">root</a><span>|</span><a href="#36853791">parent</a><span>|</span><a href="#36853924">next</a><span>|</span><label class="collapse" for="c-36859505">[-]</label><label class="expand" for="c-36859505">[1 more]</label></div><br/><div class="children"><div class="content">Won&#x27;t that theoretically allow malicious actors to study the patch and exploit the now 1-day vulnerability?<p>Not that I think it&#x27;s realistic to develop an exploit and gain real value in three days, but theoretically, if all parties had taken more than three days to distribute and apply the patches?</div><br/></div></div><div id="36853924" class="c"><input type="checkbox" id="c-36853924" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#36851906">root</a><span>|</span><a href="#36853791">parent</a><span>|</span><a href="#36859505">prev</a><span>|</span><a href="#36853839">next</a><span>|</span><label class="collapse" for="c-36853924">[-]</label><label class="expand" for="c-36853924">[1 more]</label></div><br/><div class="children"><div class="content">Uh, okay. I thought the embargo date was set so you could have enough time to inform the distros. Not the case, then.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36850148" class="c"><input type="checkbox" id="c-36850148" checked=""/><div class="controls bullet"><span class="by">eric__cartman</span><span>|</span><a href="#36851906">prev</a><span>|</span><a href="#36849221">next</a><span>|</span><label class="collapse" for="c-36850148">[-]</label><label class="expand" for="c-36850148">[12 more]</label></div><br/><div class="children"><div class="content">This is incredibly scary. On my Zen 2 box (Ryzen 3600) logging the output of the exploit running as an unprivileged user while copying and pasting a string into a text editor in the background (I used Kate), resulted in pieces of the string being logged into the output of zenbleed. And this is after a few seconds of runtime mind you, not even a full minute.<p>Thankfully the exploit is highly dependent on a specific asm routine so exploiting it from JS or WASM in a browser should be extremely difficult. Otherwise a nefarious tab left open for hours in the background could exfiltrate without an issue.<p>I&#x27;m eagerly waiting for Fedora maintainers to push the new microcode so the kernel can update it during the boot process.</div><br/><div id="36851051" class="c"><input type="checkbox" id="c-36851051" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36850148">parent</a><span>|</span><a href="#36856891">next</a><span>|</span><label class="collapse" for="c-36851051">[-]</label><label class="expand" for="c-36851051">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Thankfully the exploit is highly dependent on a specific asm routine so exploiting it from JS or WASM in a browser should be extremely difficult. Otherwise a nefarious tab left open for hours in the background could exfiltrate without an issue.<p>At least one commentor here claims to be able to reproduce this with javascript: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36849767">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36849767</a> .</div><br/><div id="36852478" class="c"><input type="checkbox" id="c-36852478" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#36850148">root</a><span>|</span><a href="#36851051">parent</a><span>|</span><a href="#36856891">next</a><span>|</span><label class="collapse" for="c-36852478">[-]</label><label class="expand" for="c-36852478">[2 more]</label></div><br/><div class="children"><div class="content">A very bold claim with zero evidence.</div><br/><div id="36854959" class="c"><input type="checkbox" id="c-36854959" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#36850148">root</a><span>|</span><a href="#36852478">parent</a><span>|</span><a href="#36856891">next</a><span>|</span><label class="collapse" for="c-36854959">[-]</label><label class="expand" for="c-36854959">[1 more]</label></div><br/><div class="children"><div class="content">What about it is very bold? The instruction sequence mentioned seems pretty reasonable and not at all out of the question for a JavaScript JIT to generate.</div><br/></div></div></div></div></div></div><div id="36856891" class="c"><input type="checkbox" id="c-36856891" checked=""/><div class="controls bullet"><span class="by">slappy7</span><span>|</span><a href="#36850148">parent</a><span>|</span><a href="#36851051">prev</a><span>|</span><a href="#36851745">next</a><span>|</span><label class="collapse" for="c-36856891">[-]</label><label class="expand" for="c-36856891">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Thankfully the exploit is highly dependent on a specific asm routine so exploiting it from JS or WASM in a browser should be extremely difficult.<p>I assume that once&#x2F;if a method is found it will be applicable broadly though. At the same time, hopefully software patches in V8 and SpiderMonkey will be able to mitigate this further and sooner.<p>But a JS exploit would require some way to exfiltrate data and presumably doing that would be quite difficult to hide entirely.</div><br/></div></div><div id="36851745" class="c"><input type="checkbox" id="c-36851745" checked=""/><div class="controls bullet"><span class="by">zekica</span><span>|</span><a href="#36850148">parent</a><span>|</span><a href="#36856891">prev</a><span>|</span><a href="#36853484">next</a><span>|</span><label class="collapse" for="c-36851745">[-]</label><label class="expand" for="c-36851745">[1 more]</label></div><br/><div class="children"><div class="content">I tried on my zen 2 box, and the same things works even when the exploit is run in a KVM.</div><br/></div></div><div id="36853484" class="c"><input type="checkbox" id="c-36853484" checked=""/><div class="controls bullet"><span class="by">kludge41</span><span>|</span><a href="#36850148">parent</a><span>|</span><a href="#36851745">prev</a><span>|</span><a href="#36849221">next</a><span>|</span><label class="collapse" for="c-36853484">[-]</label><label class="expand" for="c-36853484">[6 more]</label></div><br/><div class="children"><div class="content">How do you build the POC? I get &quot;No such file or directory&quot; and error 127 on Ubuntu.</div><br/><div id="36853578" class="c"><input type="checkbox" id="c-36853578" checked=""/><div class="controls bullet"><span class="by">eric__cartman</span><span>|</span><a href="#36850148">root</a><span>|</span><a href="#36853484">parent</a><span>|</span><a href="#36849221">next</a><span>|</span><label class="collapse" for="c-36853578">[-]</label><label class="expand" for="c-36853578">[5 more]</label></div><br/><div class="children"><div class="content">I had to run make on the uncompressed folder. Perhaps the build-essential package doesn&#x27;t come with NASM in Ubuntu? I&#x27;ll need a bit more info on the error if you want me to try and help you :)</div><br/><div id="36857383" class="c"><input type="checkbox" id="c-36857383" checked=""/><div class="controls bullet"><span class="by">JonathonW</span><span>|</span><a href="#36850148">root</a><span>|</span><a href="#36853578">parent</a><span>|</span><a href="#36853698">next</a><span>|</span><label class="collapse" for="c-36857383">[-]</label><label class="expand" for="c-36857383">[1 more]</label></div><br/><div class="children"><div class="content">The parent commenter seems to have figured this out, but to clarify a bit for posterity:  build-essential does not come with nasm on Ubuntu (or upstream Debian, AFAICT).  It has to be installed separately for the Zenbleed PoC to compile (if not already installed).</div><br/></div></div><div id="36853698" class="c"><input type="checkbox" id="c-36853698" checked=""/><div class="controls bullet"><span class="by">kludge41</span><span>|</span><a href="#36850148">root</a><span>|</span><a href="#36853578">parent</a><span>|</span><a href="#36857383">prev</a><span>|</span><a href="#36849221">next</a><span>|</span><label class="collapse" for="c-36853698">[-]</label><label class="expand" for="c-36853698">[3 more]</label></div><br/><div class="children"><div class="content">After extracting the POC and installing build-essential, I still get this:
nasm  -O0 -felf64 -o zenleak.o zenleak.asm
make: nasm: No such file or directory
make: ** [Makefile:11: zenleak.o] Error 127</div><br/><div id="36853753" class="c"><input type="checkbox" id="c-36853753" checked=""/><div class="controls bullet"><span class="by">eric__cartman</span><span>|</span><a href="#36850148">root</a><span>|</span><a href="#36853698">parent</a><span>|</span><a href="#36849221">next</a><span>|</span><label class="collapse" for="c-36853753">[-]</label><label class="expand" for="c-36853753">[2 more]</label></div><br/><div class="children"><div class="content">Install the nasm package. It&#x27;s probably not included in build-essencial.</div><br/><div id="36855078" class="c"><input type="checkbox" id="c-36855078" checked=""/><div class="controls bullet"><span class="by">kludge41</span><span>|</span><a href="#36850148">root</a><span>|</span><a href="#36853753">parent</a><span>|</span><a href="#36849221">next</a><span>|</span><label class="collapse" for="c-36855078">[-]</label><label class="expand" for="c-36855078">[1 more]</label></div><br/><div class="children"><div class="content">Thank you. I guess I should&#x27;ve read the error better, but I thought nasm was the thing complaining.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36849221" class="c"><input type="checkbox" id="c-36849221" checked=""/><div class="controls bullet"><span class="by">mrpippy</span><span>|</span><a href="#36850148">prev</a><span>|</span><a href="#36853437">next</a><span>|</span><label class="collapse" for="c-36849221">[-]</label><label class="expand" for="c-36849221">[24 more]</label></div><br/><div class="children"><div class="content">It feels like not-a-coincidence that OpenBSD added AMD microcode loading in the last 3 days.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36838511">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36838511</a></div><br/><div id="36851528" class="c"><input type="checkbox" id="c-36851528" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#36849221">parent</a><span>|</span><a href="#36850339">next</a><span>|</span><label class="collapse" for="c-36851528">[-]</label><label class="expand" for="c-36851528">[1 more]</label></div><br/><div class="children"><div class="content">This may or may not also be relevant (I actually have no idea): <a href="https:&#x2F;&#x2F;www.phoronix.com&#x2F;news&#x2F;Fedora-Server-Alert-FW-Updates" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.phoronix.com&#x2F;news&#x2F;Fedora-Server-Alert-FW-Updates</a></div><br/></div></div><div id="36850339" class="c"><input type="checkbox" id="c-36850339" checked=""/><div class="controls bullet"><span class="by">hammock</span><span>|</span><a href="#36849221">parent</a><span>|</span><a href="#36851528">prev</a><span>|</span><a href="#36853437">next</a><span>|</span><label class="collapse" for="c-36850339">[-]</label><label class="expand" for="c-36850339">[22 more]</label></div><br/><div class="children"><div class="content">Explain that like I’m 5?</div><br/><div id="36850366" class="c"><input type="checkbox" id="c-36850366" checked=""/><div class="controls bullet"><span class="by">laverya</span><span>|</span><a href="#36849221">root</a><span>|</span><a href="#36850339">parent</a><span>|</span><a href="#36853437">next</a><span>|</span><label class="collapse" for="c-36850366">[-]</label><label class="expand" for="c-36850366">[21 more]</label></div><br/><div class="children"><div class="content">The patch for this exploit is to load AMD&#x27;s updated microcode.</div><br/><div id="36850492" class="c"><input type="checkbox" id="c-36850492" checked=""/><div class="controls bullet"><span class="by">dumdumchan</span><span>|</span><a href="#36849221">root</a><span>|</span><a href="#36850366">parent</a><span>|</span><a href="#36851606">next</a><span>|</span><label class="collapse" for="c-36850492">[-]</label><label class="expand" for="c-36850492">[9 more]</label></div><br/><div class="children"><div class="content">Is apt update &amp;&amp; apt upgrade enough for pop-os users?</div><br/><div id="36851171" class="c"><input type="checkbox" id="c-36851171" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#36849221">root</a><span>|</span><a href="#36850492">parent</a><span>|</span><a href="#36850807">next</a><span>|</span><label class="collapse" for="c-36851171">[-]</label><label class="expand" for="c-36851171">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;ll need to reboot for the microcode to be updated</div><br/></div></div><div id="36850807" class="c"><input type="checkbox" id="c-36850807" checked=""/><div class="controls bullet"><span class="by">CameronNemo</span><span>|</span><a href="#36849221">root</a><span>|</span><a href="#36850492">parent</a><span>|</span><a href="#36851171">prev</a><span>|</span><a href="#36851606">next</a><span>|</span><label class="collapse" for="c-36850807">[-]</label><label class="expand" for="c-36850807">[7 more]</label></div><br/><div class="children"><div class="content">Probably eventually yes, but if you are really concerned you need to discuss it with your distro maintainers.</div><br/><div id="36851037" class="c"><input type="checkbox" id="c-36851037" checked=""/><div class="controls bullet"><span class="by">gabereiser</span><span>|</span><a href="#36849221">root</a><span>|</span><a href="#36850807">parent</a><span>|</span><a href="#36851606">next</a><span>|</span><label class="collapse" for="c-36851037">[-]</label><label class="expand" for="c-36851037">[6 more]</label></div><br/><div class="children"><div class="content">This. Not everyone is as quick as say Arch or Fedora in updating&#x2F;patching. Please reach out to your maintainers of the distro you use.</div><br/><div id="36851843" class="c"><input type="checkbox" id="c-36851843" checked=""/><div class="controls bullet"><span class="by">vladvasiliu</span><span>|</span><a href="#36849221">root</a><span>|</span><a href="#36851037">parent</a><span>|</span><a href="#36851822">next</a><span>|</span><label class="collapse" for="c-36851843">[-]</label><label class="expand" for="c-36851843">[4 more]</label></div><br/><div class="children"><div class="content">Even Arch seems out of date as of 24 jul 2023 17:55 UTC.<p>The latest amd firmware version is 20230625.</div><br/><div id="36853322" class="c"><input type="checkbox" id="c-36853322" checked=""/><div class="controls bullet"><span class="by">LtdJorge</span><span>|</span><a href="#36849221">root</a><span>|</span><a href="#36851843">parent</a><span>|</span><a href="#36857763">next</a><span>|</span><label class="collapse" for="c-36853322">[-]</label><label class="expand" for="c-36853322">[1 more]</label></div><br/><div class="children"><div class="content">Gentoo already has it, however the latest ebuild is still masked, so one would need to put &quot;sys-kernel&#x2F;linux-firmware ~amd64&quot; inside a file in &#x2F;etc&#x2F;portage&#x2F;package.accept_keywords, or better yet, always run the git version, using * instead of ~amd64.<p>Apart from that, it&#x27;s necessary to &quot;sudo emaint sync -A &amp;&amp; sudo emerge -av sys-kernel&#x2F;linux-firmware&quot;, while checking that the correct files are included in the savedconfig file if using it. After that, rebuild the kernel or the initramfs and reboot.</div><br/></div></div><div id="36857903" class="c"><input type="checkbox" id="c-36857903" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#36849221">root</a><span>|</span><a href="#36851843">parent</a><span>|</span><a href="#36857763">prev</a><span>|</span><a href="#36851822">next</a><span>|</span><label class="collapse" for="c-36857903">[-]</label><label class="expand" for="c-36857903">[1 more]</label></div><br/><div class="children"><div class="content">The 6.4.6 kernel has mitigations, but the arch “linux” package is still at 6.4.5.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36851606" class="c"><input type="checkbox" id="c-36851606" checked=""/><div class="controls bullet"><span class="by">jahsome</span><span>|</span><a href="#36849221">root</a><span>|</span><a href="#36850366">parent</a><span>|</span><a href="#36850492">prev</a><span>|</span><a href="#36853437">next</a><span>|</span><label class="collapse" for="c-36851606">[-]</label><label class="expand" for="c-36851606">[11 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure five year olds know what microcode is. I&#x27;m 35, been in tech nearly 20 years and don&#x27;t recall having heard that specific term before today.</div><br/><div id="36851799" class="c"><input type="checkbox" id="c-36851799" checked=""/><div class="controls bullet"><span class="by">eindiran</span><span>|</span><a href="#36849221">root</a><span>|</span><a href="#36851606">parent</a><span>|</span><a href="#36853104">next</a><span>|</span><label class="collapse" for="c-36851799">[-]</label><label class="expand" for="c-36851799">[3 more]</label></div><br/><div class="children"><div class="content">The whole &quot;explain like I&#x27;m 5&quot; thing is ridiculous. A huge percentage of topics simply cannot be broken down to an average 5 year old in a way that makes the conversation worth having at all. The 5 year old has no context about why in recent years there has been a huge push towards running your own code on other people&#x27;s computers using various isolation techniques, or why people are trying to exploit that. The 5 year old has no context for what the exploits actually are, or how to mitigate them. Even if you break all of those things down into 5 year old bitesized chunks, you end up with boring word soup completely disconnected from the meaningful parts of the conversation.<p>Really what ELI5 is, is a technique to allow the asker to not have to look anything up. From the parent comment, you can look up &quot;patch&quot;, &quot;AMD&quot;, &quot;microcode&quot;; or you can demand &quot;ELI5!&quot; and have someone else type up long, careful definitions that don&#x27;t reference context or words that a 5 year old doesn&#x27;t know.<p>Regarding what microcode is, here is a good explanation of the differences between microcode and firmware:<p><a href="https:&#x2F;&#x2F;superuser.com&#x2F;questions&#x2F;1283788&#x2F;what-exactly-is-microcode-and-how-does-it-differ-from-firmware" rel="nofollow noreferrer">https:&#x2F;&#x2F;superuser.com&#x2F;questions&#x2F;1283788&#x2F;what-exactly-is-micr...</a></div><br/><div id="36852776" class="c"><input type="checkbox" id="c-36852776" checked=""/><div class="controls bullet"><span class="by">byvirtueof</span><span>|</span><a href="#36849221">root</a><span>|</span><a href="#36851799">parent</a><span>|</span><a href="#36853278">next</a><span>|</span><label class="collapse" for="c-36852776">[-]</label><label class="expand" for="c-36852776">[1 more]</label></div><br/><div class="children"><div class="content">I agree that many topics are hard to explain to a five year old, but ELI5 can be very helpful in forcing people to simplify their writing. Many people explain things in an unnecessarily complex way, and ELI5 at least makes them think about the target audience.</div><br/></div></div><div id="36853278" class="c"><input type="checkbox" id="c-36853278" checked=""/><div class="controls bullet"><span class="by">jahsome</span><span>|</span><a href="#36849221">root</a><span>|</span><a href="#36851799">parent</a><span>|</span><a href="#36852776">prev</a><span>|</span><a href="#36853104">next</a><span>|</span><label class="collapse" for="c-36853278">[-]</label><label class="expand" for="c-36853278">[1 more]</label></div><br/><div class="children"><div class="content">Sure, I can look it up (and I did) but this is a <i>discussion</i> section, so why not prompt a discussion by asking for a simple explanation?<p>Appreciate the link! I&#x27;m not OP but that&#x27;s exactly what I was looking for.</div><br/></div></div></div></div><div id="36853104" class="c"><input type="checkbox" id="c-36853104" checked=""/><div class="controls bullet"><span class="by">wolf550e</span><span>|</span><a href="#36849221">root</a><span>|</span><a href="#36851606">parent</a><span>|</span><a href="#36851799">prev</a><span>|</span><a href="#36857732">next</a><span>|</span><label class="collapse" for="c-36853104">[-]</label><label class="expand" for="c-36853104">[4 more]</label></div><br/><div class="children"><div class="content">A Grandchild&#x27;s Guide to Using Grandpa&#x27;s Computer a.k.a. &quot;If Dr. Zeuss were a Technical Writer&quot; was written in 1994 and mentions microcode.<p>Microcode updates are always discussed when talking about microarchitectural security vulnerabilities (and other scary CPU errata like <a href="https:&#x2F;&#x2F;lkml.org&#x2F;lkml&#x2F;2023&#x2F;3&#x2F;8&#x2F;976" rel="nofollow noreferrer">https:&#x2F;&#x2F;lkml.org&#x2F;lkml&#x2F;2023&#x2F;3&#x2F;8&#x2F;976</a>).<p>Microcode is always mentioned when discussing CPU design evolution.</div><br/><div id="36854489" class="c"><input type="checkbox" id="c-36854489" checked=""/><div class="controls bullet"><span class="by">jahsome</span><span>|</span><a href="#36849221">root</a><span>|</span><a href="#36853104">parent</a><span>|</span><a href="#36857732">next</a><span>|</span><label class="collapse" for="c-36854489">[-]</label><label class="expand" for="c-36854489">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny that it&#x27;s &quot;always&quot; mentioned, yet it&#x27;s not familiar to me. Also curious the Wikipedia article for CPU design doesn&#x27;t mention it, since it&#x27;s &quot;always&quot; referenced.<p>Just because something is familiar to you, or even large swaths of a given population, doesn&#x27;t mean everyone should be expected to know it.<p>I love learning new things. I love discovering topics I know nothing about, and I love picking the brains of those passionate about them. But the condescension from a certain type of tech nerd sucks all the fun out of learning. I&#x27;ve certainly been guilty of this in the past.</div><br/><div id="36855833" class="c"><input type="checkbox" id="c-36855833" checked=""/><div class="controls bullet"><span class="by">serf</span><span>|</span><a href="#36849221">root</a><span>|</span><a href="#36854489">parent</a><span>|</span><a href="#36857732">next</a><span>|</span><label class="collapse" for="c-36855833">[-]</label><label class="expand" for="c-36855833">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s funny that it&#x27;s &quot;always&quot; mentioned, yet it&#x27;s not familiar to me. Also curious the Wikipedia article for CPU design doesn&#x27;t mention it, since it&#x27;s &quot;always&quot; referenced.<p>you&#x27;re not going to convince others that microcode is some kind of foreign concept to CPUs just because you yourself were unfamiliar.<p>Yes, it can be a downer to discover that you&#x27;re more naive in a subject than you had previously thought you were more familiar.<p>&gt;Also curious the Wikipedia article for CPU design doesn&#x27;t mention it, since it&#x27;s &quot;always&quot; referenced.<p>microcode is something that is implemented by CPUs that are too big and expensive to replace -- it&#x27;s not something that is fundamental to processor designs. It&#x27;s something we now live with to prevent things like the &#x27;pentium bug&#x27; from costing Intel many-many dollars after a consumer-products forced recall&#x2F;replacement.<p>At this point in history I think that if someone wants to consider themselves to be well-versed or knowledgeable about consumer CPUs then learning about microcode is a hard requirement. It&#x27;s a false metaphor now to consider a CPU to be an unchanging entity, and that&#x27;s important to at least be aware of -- it&#x27;s literally one of the only ways that t<p>Since wikipedia is the source du joure, here : <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Microcode" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Microcode</a><p>p.s. : I think it&#x27;s a strange as you that the processor wiki page doesn&#x27;t at least mention microcode, I guess they&#x27;re trying to keep it &#x27;pure&#x27;.</div><br/><div id="36857141" class="c"><input type="checkbox" id="c-36857141" checked=""/><div class="controls bullet"><span class="by">jahsome</span><span>|</span><a href="#36849221">root</a><span>|</span><a href="#36855833">parent</a><span>|</span><a href="#36857732">next</a><span>|</span><label class="collapse" for="c-36857141">[-]</label><label class="expand" for="c-36857141">[1 more]</label></div><br/><div class="children"><div class="content">When did I say it&#x27;s a foreign concept? I said it&#x27;s not common knowledge for five year olds, and in reply, someone stated it&#x27;s &quot;always&quot; mentioned. I was simply demonstrating that it&#x27;s not &quot;always&quot; mentioned.<p>&gt; At this point in history I think that if someone wants to consider themselves to be well-versed or knowledgeable about consumer CPUs then learning about microcode is a hard requirement.<p>This statement strikes me as hyperbolic. A CPU&#x2F;hardware engineer, or even security-conscious software engineer, sure. But I can&#x27;t understand why there is a reason for a consumer to care.</div><br/></div></div></div></div></div></div></div></div><div id="36857732" class="c"><input type="checkbox" id="c-36857732" checked=""/><div class="controls bullet"><span class="by">marmakoide</span><span>|</span><a href="#36849221">root</a><span>|</span><a href="#36851606">parent</a><span>|</span><a href="#36853104">prev</a><span>|</span><a href="#36851670">next</a><span>|</span><label class="collapse" for="c-36857732">[-]</label><label class="expand" for="c-36857732">[1 more]</label></div><br/><div class="children"><div class="content">I can explain to a 35 years old in tech.<p>A modern generalist CPU is made of many smaller, simpler, specialized CPUs : there&#x27;s a whole orchestra inside.<p>Amongst those smaller CPUs, there&#x27;s a master : it&#x27;ll see to decoding of instruction, sending jobs to the various CPU units, and fetching the results of said jobs. That master is running a program, executing ... microcode ! And of course, if there is a program, there are bugs. CPUs have bugs since CPUs were invented.<p>Microcode itself was present in early CPUs, (say, the Z80), but hardcoded. Nowadays, microcode can be uploaded to a CPU to fix bugs.</div><br/></div></div><div id="36851670" class="c"><input type="checkbox" id="c-36851670" checked=""/><div class="controls bullet"><span class="by">enedil</span><span>|</span><a href="#36849221">root</a><span>|</span><a href="#36851606">parent</a><span>|</span><a href="#36857732">prev</a><span>|</span><a href="#36851834">next</a><span>|</span><label class="collapse" for="c-36851670">[-]</label><label class="expand" for="c-36851670">[1 more]</label></div><br/><div class="children"><div class="content">But well educated five year olds from good schools would know it.</div><br/></div></div><div id="36851834" class="c"><input type="checkbox" id="c-36851834" checked=""/><div class="controls bullet"><span class="by">heywhatupboys</span><span>|</span><a href="#36849221">root</a><span>|</span><a href="#36851606">parent</a><span>|</span><a href="#36851670">prev</a><span>|</span><a href="#36853437">next</a><span>|</span><label class="collapse" for="c-36851834">[-]</label><label class="expand" for="c-36851834">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m not sure five year olds know what microcode is<p>Sounds like cope being outprogrammed by a kindergartner i Roblox</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36853437" class="c"><input type="checkbox" id="c-36853437" checked=""/><div class="controls bullet"><span class="by">dTP90pN</span><span>|</span><a href="#36849221">prev</a><span>|</span><a href="#36849093">next</a><span>|</span><label class="collapse" for="c-36853437">[-]</label><label class="expand" for="c-36853437">[4 more]</label></div><br/><div class="children"><div class="content">&gt; AMD have released an microcode update for affected processors.<p>I don&#x27;t think that is correct. AMD has released a microcode update[0] for family 17h models 0x31 and 0xa0, which corresponds to Rome, Castle Peak and Mendocino as per WikiChip [1].<p>So far, there seems to be no microcode update for Renoir, Grey Hawk, Lucienne, Matisse and Van Gogh. Fortunately, the newly released kernels can and do simply set the chicken bit for those. [2]<p>[0] <a href="https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;firmware&#x2F;linux-firmware.git&#x2F;commit&#x2F;?id=0bc3126c9cfa0b8c761483215c25382f831a7c6f" rel="nofollow noreferrer">https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;firmware&#x2F;lin...</a><p>[1] <a href="https:&#x2F;&#x2F;en.wikichip.org&#x2F;wiki&#x2F;amd&#x2F;cpuid#Family_23_.2817h.29" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikichip.org&#x2F;wiki&#x2F;amd&#x2F;cpuid#Family_23_.2817h.29</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;commit&#x2F;522b1d69219d8f083173819fde04f994aa051a98">https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;commit&#x2F;522b1d69219d8f08317...</a></div><br/><div id="36853590" class="c"><input type="checkbox" id="c-36853590" checked=""/><div class="controls bullet"><span class="by">dTP90pN</span><span>|</span><a href="#36853437">parent</a><span>|</span><a href="#36849093">next</a><span>|</span><label class="collapse" for="c-36853590">[-]</label><label class="expand" for="c-36853590">[3 more]</label></div><br/><div class="children"><div class="content">More details:<p>`good_revs` as per the kernel: <a href="https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;commit&#x2F;522b1d69219d8f083173819fde04f994aa051a98#diff-de2b53cae08d8bbbea0a1d691be722a7bbfec5cb32b20f5fbf13949b75fecc5fR990-R995">https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;commit&#x2F;522b1d69219d8f08317...</a><p>Currently published revs (&quot;Patch&quot;) (git HEAD):<p><a href="https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;firmware&#x2F;linux-firmware.git&#x2F;tree&#x2F;amd-ucode&#x2F;README" rel="nofollow noreferrer">https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;firmware&#x2F;lin...</a><p>As of this writing, only two of the five `good_rev`s have been published.</div><br/><div id="36855758" class="c"><input type="checkbox" id="c-36855758" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36853437">root</a><span>|</span><a href="#36853590">parent</a><span>|</span><a href="#36849093">next</a><span>|</span><label class="collapse" for="c-36855758">[-]</label><label class="expand" for="c-36855758">[2 more]</label></div><br/><div class="children"><div class="content">What does that chicken bit do?</div><br/><div id="36857885" class="c"><input type="checkbox" id="c-36857885" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#36853437">root</a><span>|</span><a href="#36855758">parent</a><span>|</span><a href="#36849093">next</a><span>|</span><label class="collapse" for="c-36857885">[-]</label><label class="expand" for="c-36857885">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.phoronix.com&#x2F;news&#x2F;Linux-AMD-Spectral-Chicken" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.phoronix.com&#x2F;news&#x2F;Linux-AMD-Spectral-Chicken</a></div><br/></div></div></div></div></div></div></div></div><div id="36849093" class="c"><input type="checkbox" id="c-36849093" checked=""/><div class="controls bullet"><span class="by">lopkeny12ko</span><span>|</span><a href="#36853437">prev</a><span>|</span><a href="#36849268">next</a><span>|</span><label class="collapse" for="c-36849093">[-]</label><label class="expand" for="c-36849093">[27 more]</label></div><br/><div class="children"><div class="content">Relevant snippet:<p>This technique is CVE-2023-20593 and it works on all Zen 2 class processors, which includes at least the following products:<p><pre><code>    AMD Ryzen 3000 Series Processors
    AMD Ryzen PRO 3000 Series Processors
    AMD Ryzen Threadripper 3000 Series Processors
    AMD Ryzen 4000 Series Processors with Radeon Graphics
    AMD Ryzen PRO 4000 Series Processors
    AMD Ryzen 5000 Series Processors with Radeon Graphics
    AMD Ryzen 7020 Series Processors with Radeon Graphics
    AMD EPYC “Rome” Processors</code></pre></div><br/><div id="36850040" class="c"><input type="checkbox" id="c-36850040" checked=""/><div class="controls bullet"><span class="by">tremon</span><span>|</span><a href="#36849093">parent</a><span>|</span><a href="#36851428">next</a><span>|</span><label class="collapse" for="c-36850040">[-]</label><label class="expand" for="c-36850040">[5 more]</label></div><br/><div class="children"><div class="content">Do they mean &quot;only confirmed on Zen2&quot;, or is the problem definitely confined to only this architecture?<p>Is it likely that this same technique (or similar) also works on earlier (Zen&#x2F;Zen+) or later (Zen3) cores, but they just haven&#x27;t been able to demonstrate it yet?</div><br/><div id="36850127" class="c"><input type="checkbox" id="c-36850127" checked=""/><div class="controls bullet"><span class="by">paulmd</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36850040">parent</a><span>|</span><a href="#36854958">next</a><span>|</span><label class="collapse" for="c-36850127">[-]</label><label class="expand" for="c-36850127">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s Tavis Ormandy, and he reported it to AMD, so <i>one would assume</i> they tried it on related hardware and it&#x27;s not working.</div><br/></div></div><div id="36854958" class="c"><input type="checkbox" id="c-36854958" checked=""/><div class="controls bullet"><span class="by">zacmps</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36850040">parent</a><span>|</span><a href="#36850127">prev</a><span>|</span><a href="#36850526">next</a><span>|</span><label class="collapse" for="c-36854958">[-]</label><label class="expand" for="c-36854958">[1 more]</label></div><br/><div class="children"><div class="content">I tested on a Zen 3 Epyc and wasn&#x27;t able to get the POC to work, so I think it probably is just Zen 2.</div><br/></div></div><div id="36850526" class="c"><input type="checkbox" id="c-36850526" checked=""/><div class="controls bullet"><span class="by">rincebrain</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36850040">parent</a><span>|</span><a href="#36854958">prev</a><span>|</span><a href="#36854347">next</a><span>|</span><label class="collapse" for="c-36850526">[-]</label><label class="expand" for="c-36850526">[1 more]</label></div><br/><div class="children"><div class="content">At least the stock exploit code he provided said &quot;nope I can&#x27;t get shit to leak&quot; on my 5900X.</div><br/></div></div><div id="36854347" class="c"><input type="checkbox" id="c-36854347" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36850040">parent</a><span>|</span><a href="#36850526">prev</a><span>|</span><a href="#36851428">next</a><span>|</span><label class="collapse" for="c-36854347">[-]</label><label class="expand" for="c-36854347">[1 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t repro on 2920x (Zen+).</div><br/></div></div></div></div><div id="36851428" class="c"><input type="checkbox" id="c-36851428" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#36849093">parent</a><span>|</span><a href="#36850040">prev</a><span>|</span><a href="#36850559">next</a><span>|</span><label class="collapse" for="c-36851428">[-]</label><label class="expand" for="c-36851428">[3 more]</label></div><br/><div class="children"><div class="content">Looks like my 2700x narrowly misses this one, assuming 7020 series is affected and not 7000 series.</div><br/><div id="36852081" class="c"><input type="checkbox" id="c-36852081" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36851428">parent</a><span>|</span><a href="#36851869">next</a><span>|</span><label class="collapse" for="c-36852081">[-]</label><label class="expand" for="c-36852081">[1 more]</label></div><br/><div class="children"><div class="content">Yeah -- Ryzen 2700x is Zen+, not Zen 2.  Current understanding is that Zen+ is not affected.</div><br/></div></div><div id="36851869" class="c"><input type="checkbox" id="c-36851869" checked=""/><div class="controls bullet"><span class="by">_flux</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36851428">parent</a><span>|</span><a href="#36852081">prev</a><span>|</span><a href="#36850559">next</a><span>|</span><label class="collapse" for="c-36851869">[-]</label><label class="expand" for="c-36851869">[1 more]</label></div><br/><div class="children"><div class="content">The wording &quot;at least&quot; suggests the list might not be exhaustive.</div><br/></div></div></div></div><div id="36850559" class="c"><input type="checkbox" id="c-36850559" checked=""/><div class="controls bullet"><span class="by">ye-olde-sysrq</span><span>|</span><a href="#36849093">parent</a><span>|</span><a href="#36851428">prev</a><span>|</span><a href="#36849433">next</a><span>|</span><label class="collapse" for="c-36850559">[-]</label><label class="expand" for="c-36850559">[4 more]</label></div><br/><div class="children"><div class="content">So are Ryzen 5000&#x27;s without Radeon not vulnerable? I guess said processors are zen 3?<p>I have an &quot;AMD Ryzen 9 5950x Desktop Processor&quot; which appears to be Zen 3. I think I&#x27;m good?<p>(Not that I&#x27;m running untrusted workloads, but yknow, fortune favors the prepared)</div><br/><div id="36850788" class="c"><input type="checkbox" id="c-36850788" checked=""/><div class="controls bullet"><span class="by">Tuna-Fish</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36850559">parent</a><span>|</span><a href="#36849433">next</a><span>|</span><label class="collapse" for="c-36850788">[-]</label><label class="expand" for="c-36850788">[3 more]</label></div><br/><div class="children"><div class="content">You are likely frequently running untrusted workloads. As javascript in a browser. I don&#x27;t know about this one, but at least meltdown was fully exploitable from js.<p>But yes, you are fine, 5950x is Zen3.</div><br/><div id="36850858" class="c"><input type="checkbox" id="c-36850858" checked=""/><div class="controls bullet"><span class="by">CameronNemo</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36850788">parent</a><span>|</span><a href="#36854542">next</a><span>|</span><label class="collapse" for="c-36850858">[-]</label><label class="expand" for="c-36850858">[1 more]</label></div><br/><div class="children"><div class="content">I was under the impression that 5600g and 5600u were Zen3, but being the APU models they have Radeon graphics.<p>Anecdotally, I tried to reproduce on my 5600g but couldn&#x27;t. Which is surprising because they claim it works on 5700u...<p>Edit: just discovered that while my 5600g is Zen3, the 5700u is Zen2. Lol.</div><br/></div></div><div id="36854542" class="c"><input type="checkbox" id="c-36854542" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36850788">parent</a><span>|</span><a href="#36850858">prev</a><span>|</span><a href="#36849433">next</a><span>|</span><label class="collapse" for="c-36854542">[-]</label><label class="expand" for="c-36854542">[1 more]</label></div><br/><div class="children"><div class="content">I wish Firefox would use PR_SCHED_CORE to reduce the likelihood of such leakage...</div><br/></div></div></div></div></div></div><div id="36849433" class="c"><input type="checkbox" id="c-36849433" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#36849093">parent</a><span>|</span><a href="#36850559">prev</a><span>|</span><a href="#36850836">next</a><span>|</span><label class="collapse" for="c-36849433">[-]</label><label class="expand" for="c-36849433">[3 more]</label></div><br/><div class="children"><div class="content">FYI, Ryzen 3000 APUs aren&#x27;t Zen 2.</div><br/><div id="36849584" class="c"><input type="checkbox" id="c-36849584" checked=""/><div class="controls bullet"><span class="by">neogodless</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36849433">parent</a><span>|</span><a href="#36849601">next</a><span>|</span><label class="collapse" for="c-36849584">[-]</label><label class="expand" for="c-36849584">[1 more]</label></div><br/><div class="children"><div class="content">&gt; AMD Ryzen 3000 Series Processors<p>The above are desktop. If they meant APUs, it would list &quot;Ryzen 3000 Series Processors with Radeon Graphics.&quot;</div><br/></div></div><div id="36849601" class="c"><input type="checkbox" id="c-36849601" checked=""/><div class="controls bullet"><span class="by">timw4mail</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36849433">parent</a><span>|</span><a href="#36849584">prev</a><span>|</span><a href="#36850836">next</a><span>|</span><label class="collapse" for="c-36849601">[-]</label><label class="expand" for="c-36849601">[1 more]</label></div><br/><div class="children"><div class="content">They are Zen+, aren&#x27;t they?</div><br/></div></div></div></div><div id="36850836" class="c"><input type="checkbox" id="c-36850836" checked=""/><div class="controls bullet"><span class="by">eugene3306</span><span>|</span><a href="#36849093">parent</a><span>|</span><a href="#36849433">prev</a><span>|</span><a href="#36850545">next</a><span>|</span><label class="collapse" for="c-36850836">[-]</label><label class="expand" for="c-36850836">[10 more]</label></div><br/><div class="children"><div class="content">and how about playstation 5 ?<p>and also xbox and that thing from valve?</div><br/><div id="36851030" class="c"><input type="checkbox" id="c-36851030" checked=""/><div class="controls bullet"><span class="by">javajosh</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36850836">parent</a><span>|</span><a href="#36850545">next</a><span>|</span><label class="collapse" for="c-36851030">[-]</label><label class="expand" for="c-36851030">[9 more]</label></div><br/><div class="children"><div class="content">I mean, the PS5 is running a Zen 2 processor [0] so I would assume it&#x27;s vulnerable. In general I would assume that AAA games are safe. Websites and smaller games made by malefactors will be the issue. (Note that AAA game makers have little interest in antagonizing the audience, OTOH they also will push limits to install anti-cheat mechanisms. On balance I&#x27;d trust them.)<p>0 - <a href="https:&#x2F;&#x2F;blog.playstation.com&#x2F;2020&#x2F;03&#x2F;18&#x2F;unveiling-new-details-of-playstation-5-hardware-technical-specs&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.playstation.com&#x2F;2020&#x2F;03&#x2F;18&#x2F;unveiling-new-detail...</a></div><br/><div id="36852120" class="c"><input type="checkbox" id="c-36852120" checked=""/><div class="controls bullet"><span class="by">darkwater</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36851030">parent</a><span>|</span><a href="#36850545">next</a><span>|</span><label class="collapse" for="c-36852120">[-]</label><label class="expand" for="c-36852120">[8 more]</label></div><br/><div class="children"><div class="content">I think the interesting point here might be one could be able to extract some secret from memory of a PS5, like to break some kind of encryption</div><br/><div id="36854620" class="c"><input type="checkbox" id="c-36854620" checked=""/><div class="controls bullet"><span class="by">tracker1</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36852120">parent</a><span>|</span><a href="#36852353">next</a><span>|</span><label class="collapse" for="c-36854620">[-]</label><label class="expand" for="c-36854620">[1 more]</label></div><br/><div class="children"><div class="content">Interresting, could well be a path to jailbreaking the PS5... although, not sure if that has or hasn&#x27;t already happened.  For XBox Series, you can just use dev mode in the first place.</div><br/></div></div><div id="36852353" class="c"><input type="checkbox" id="c-36852353" checked=""/><div class="controls bullet"><span class="by">FirmwareBurner</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36852120">parent</a><span>|</span><a href="#36854620">prev</a><span>|</span><a href="#36850545">next</a><span>|</span><label class="collapse" for="c-36852353">[-]</label><label class="expand" for="c-36852353">[6 more]</label></div><br/><div class="children"><div class="content">What valuable secrets do people have on their PS5&#x2F;Xbox? You also need a way to deploy the malicious payload on those platforms which, due to their closed nature, is very difficult to do.</div><br/><div id="36854294" class="c"><input type="checkbox" id="c-36854294" checked=""/><div class="controls bullet"><span class="by">kmeisthax</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36852353">parent</a><span>|</span><a href="#36852943">next</a><span>|</span><label class="collapse" for="c-36854294">[-]</label><label class="expand" for="c-36854294">[3 more]</label></div><br/><div class="children"><div class="content">The valuable secret here would be the keys that let you decrypt and copy games. The threat models of locked-down platforms are incredibly strange.</div><br/><div id="36854769" class="c"><input type="checkbox" id="c-36854769" checked=""/><div class="controls bullet"><span class="by">FirmwareBurner</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36854294">parent</a><span>|</span><a href="#36852943">next</a><span>|</span><label class="collapse" for="c-36854769">[-]</label><label class="expand" for="c-36854769">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a good point but I can&#x27;t believe that every console doesn&#x27;t have it&#x27;s own unique set of keys so that if you compromise one before SW patches land, it won&#x27;t be much use in the ecosystem.</div><br/><div id="36855062" class="c"><input type="checkbox" id="c-36855062" checked=""/><div class="controls bullet"><span class="by">kmeisthax</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36854769">parent</a><span>|</span><a href="#36852943">next</a><span>|</span><label class="collapse" for="c-36855062">[-]</label><label class="expand" for="c-36855062">[1 more]</label></div><br/><div class="children"><div class="content">It depends. I&#x27;m going to speak in general terms, since I obviously don&#x27;t know how every single system works, but per-console keys are used for pairing system storage to the motherboard and <i>maybe</i> keeping save data from being copied from user to user. Most CDNs don&#x27;t really provide the option for on-the-fly per user encryption, so instead you serve up games encrypted with title keys and then issue each console a title key that&#x27;s encrypted with a per-console key. Disc games need to be encrypted with keys that every system already has, otherwise you can&#x27;t actually use the disc to play the game.<p>As for the value of being able to do &#x27;hero attacks&#x27; on game consoles, let me point out that once you have a cleartext dump of a game, you&#x27;ve already done most of the work. The Xbox 360 was actually very well secured, to the point where it was easier to hack a disc drive to inject fake authentication data into a normal DVD-R than to actually hack a 360&#x27;s CPU to run copied games. That&#x27;s why we didn&#x27;t have widely-accessible homebrew on that platform for the longest time. Furthermore, you can make emulators that just don&#x27;t care about authenticating media (because why would they) and run cleartext games on those.</div><br/></div></div></div></div></div></div><div id="36852943" class="c"><input type="checkbox" id="c-36852943" checked=""/><div class="controls bullet"><span class="by">AdmiralAsshat</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36852353">parent</a><span>|</span><a href="#36854294">prev</a><span>|</span><a href="#36853379">next</a><span>|</span><label class="collapse" for="c-36852943">[-]</label><label class="expand" for="c-36852943">[1 more]</label></div><br/><div class="children"><div class="content">At least with the PS3, I seem to recall that I couldn&#x27;t extract any of my games&#x27; save data from the hard-drive of my PS3 unit that went dead due to RROD (or was it YLOD?) because the hard-drive was encrypted using the PS3&#x27;s serial key as part of the encryption.<p>I don&#x27;t know if that mechanism persists into the PS4&#x2F;PS5.</div><br/></div></div><div id="36853379" class="c"><input type="checkbox" id="c-36853379" checked=""/><div class="controls bullet"><span class="by">javajosh</span><span>|</span><a href="#36849093">root</a><span>|</span><a href="#36852353">parent</a><span>|</span><a href="#36852943">prev</a><span>|</span><a href="#36850545">next</a><span>|</span><label class="collapse" for="c-36853379">[-]</label><label class="expand" for="c-36853379">[1 more]</label></div><br/><div class="children"><div class="content">Oh, I can imagine lots of uses for a bevy of PS5&#x27;s, assuming you can gain remote control. What do you do with a botnet? What do you do with a botnet with a pretty good GPU? What do you do with an always-on microphone in people&#x27;s living rooms?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36850545" class="c"><input type="checkbox" id="c-36850545" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#36849093">parent</a><span>|</span><a href="#36850836">prev</a><span>|</span><a href="#36849268">next</a><span>|</span><label class="collapse" for="c-36850545">[-]</label><label class="expand" for="c-36850545">[1 more]</label></div><br/><div class="children"><div class="content">Whew, my 5600X looks like it avoided this one too. :)</div><br/></div></div></div></div><div id="36849268" class="c"><input type="checkbox" id="c-36849268" checked=""/><div class="controls bullet"><span class="by">sounds</span><span>|</span><a href="#36849093">prev</a><span>|</span><a href="#36853833">next</a><span>|</span><label class="collapse" for="c-36849268">[-]</label><label class="expand" for="c-36849268">[28 more]</label></div><br/><div class="children"><div class="content">The site is getting hugged to death. <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230724143835&#x2F;https:&#x2F;&#x2F;lock.cmpxchg8b.com&#x2F;zenbleed.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230724143835&#x2F;https:&#x2F;&#x2F;lock.cmpx...</a></div><br/><div id="36849788" class="c"><input type="checkbox" id="c-36849788" checked=""/><div class="controls bullet"><span class="by">ksec</span><span>|</span><a href="#36849268">parent</a><span>|</span><a href="#36849818">next</a><span>|</span><label class="collapse" for="c-36849788">[-]</label><label class="expand" for="c-36849788">[22 more]</label></div><br/><div class="children"><div class="content">It is a simple static HTML page, how is it possible in 2023 a static site could be hugged to death. In most cases HN traffic barely hits 100 page view per second.</div><br/><div id="36850048" class="c"><input type="checkbox" id="c-36850048" checked=""/><div class="controls bullet"><span class="by">taviso</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36849788">parent</a><span>|</span><a href="#36850028">next</a><span>|</span><label class="collapse" for="c-36850048">[-]</label><label class="expand" for="c-36850048">[17 more]</label></div><br/><div class="children"><div class="content">welp, that&#x27;s unfortunate indeed.<p>It&#x27;s a single-core 128 MB VPS, which seemed fine for my boring static html articles. I guess I underestimated the interest.</div><br/><div id="36850952" class="c"><input type="checkbox" id="c-36850952" checked=""/><div class="controls bullet"><span class="by">javajosh</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36850048">parent</a><span>|</span><a href="#36851207">next</a><span>|</span><label class="collapse" for="c-36850952">[-]</label><label class="expand" for="c-36850952">[2 more]</label></div><br/><div class="children"><div class="content">As an aside, I&#x27;d be curious to now how your VPS failed. Memory? Bandwidth?</div><br/><div id="36856444" class="c"><input type="checkbox" id="c-36856444" checked=""/><div class="controls bullet"><span class="by">taviso</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36850952">parent</a><span>|</span><a href="#36851207">next</a><span>|</span><label class="collapse" for="c-36856444">[-]</label><label class="expand" for="c-36856444">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not really sure, cpu and bandwidth utilization were fine. Memory usage was high, but not oom high. It continued serving over http just fine, perhaps there was some automated rate limiting by my provider.<p>I&#x27;ll have to debug when things cool down.<p>I&#x27;m aware 128M is ludicrous in 2023... &quot;a fun challenge&quot;, I thought to myself. I can be a dummy.</div><br/></div></div></div></div><div id="36851207" class="c"><input type="checkbox" id="c-36851207" checked=""/><div class="controls bullet"><span class="by">yakubin</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36850048">parent</a><span>|</span><a href="#36850952">prev</a><span>|</span><a href="#36850265">next</a><span>|</span><label class="collapse" for="c-36851207">[-]</label><label class="expand" for="c-36851207">[8 more]</label></div><br/><div class="children"><div class="content">FWIW, enabling gzip&#x2F;zstd compression in your HTTP server could help.</div><br/><div id="36851723" class="c"><input type="checkbox" id="c-36851723" checked=""/><div class="controls bullet"><span class="by">ransackdev</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36851207">parent</a><span>|</span><a href="#36853607">next</a><span>|</span><label class="collapse" for="c-36851723">[-]</label><label class="expand" for="c-36851723">[5 more]</label></div><br/><div class="children"><div class="content">A single core machine already overloaded is going to get even worse introducing the cpu overhead of gzipping response bodies (assuming it’s cpu bound and not IO bound)<p>Cache control headers will help with return traffic<p>More cpu cores<p>If using nginx ensure sendfile is enabled and workers are set to auto or tuned for your setup<p>Check ulimit file handle limits<p>Offload static assets to cdn<p>Since it’s a static html site, you could even host on s3, netlify, etc</div><br/><div id="36852369" class="c"><input type="checkbox" id="c-36852369" checked=""/><div class="controls bullet"><span class="by">jwilk</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36851723">parent</a><span>|</span><a href="#36857508">next</a><span>|</span><label class="collapse" for="c-36852369">[-]</label><label class="expand" for="c-36852369">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a static file. You need to compress it only once, not for every response.</div><br/><div id="36854129" class="c"><input type="checkbox" id="c-36854129" checked=""/><div class="controls bullet"><span class="by">ptx</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36852369">parent</a><span>|</span><a href="#36857508">next</a><span>|</span><label class="collapse" for="c-36854129">[-]</label><label class="expand" for="c-36854129">[1 more]</label></div><br/><div class="children"><div class="content">...and here&#x27;s how to do it in Apache:
<a href="https:&#x2F;&#x2F;httpd.apache.org&#x2F;docs&#x2F;2.4&#x2F;mod&#x2F;mod_deflate.html#precompressed" rel="nofollow noreferrer">https:&#x2F;&#x2F;httpd.apache.org&#x2F;docs&#x2F;2.4&#x2F;mod&#x2F;mod_deflate.html#preco...</a></div><br/></div></div></div></div><div id="36857508" class="c"><input type="checkbox" id="c-36857508" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36851723">parent</a><span>|</span><a href="#36852369">prev</a><span>|</span><a href="#36852203">next</a><span>|</span><label class="collapse" for="c-36857508">[-]</label><label class="expand" for="c-36857508">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A single core machine already overloaded is going to get even worse introducing the cpu overhead of gzipping response bodies (assuming it’s cpu bound and not IO bound)<p>Unless your CPU is burning due to additional system calls being made.</div><br/></div></div><div id="36852203" class="c"><input type="checkbox" id="c-36852203" checked=""/><div class="controls bullet"><span class="by">brazzledazzle</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36851723">parent</a><span>|</span><a href="#36857508">prev</a><span>|</span><a href="#36853607">next</a><span>|</span><label class="collapse" for="c-36852203">[-]</label><label class="expand" for="c-36852203">[1 more]</label></div><br/><div class="children"><div class="content">Could even host on github pages with a cname.</div><br/></div></div></div></div><div id="36853607" class="c"><input type="checkbox" id="c-36853607" checked=""/><div class="controls bullet"><span class="by">wolf550e</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36851207">parent</a><span>|</span><a href="#36851723">prev</a><span>|</span><a href="#36850265">next</a><span>|</span><label class="collapse" for="c-36853607">[-]</label><label class="expand" for="c-36853607">[2 more]</label></div><br/><div class="children"><div class="content">Only with something like mod_asis (<a href="https:&#x2F;&#x2F;httpd.apache.org&#x2F;docs&#x2F;2.4&#x2F;mod&#x2F;mod_asis.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;httpd.apache.org&#x2F;docs&#x2F;2.4&#x2F;mod&#x2F;mod_asis.html</a>) to serve already compressed content. Actually running zlib on every request will only make it worse.</div><br/><div id="36856039" class="c"><input type="checkbox" id="c-36856039" checked=""/><div class="controls bullet"><span class="by">yakubin</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36853607">parent</a><span>|</span><a href="#36850265">next</a><span>|</span><label class="collapse" for="c-36856039">[-]</label><label class="expand" for="c-36856039">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Actually running zlib on every request will only make it worse.</i><p>I wouldn&#x27;t be so sure, given that without zlib HTTP connections take longer, thereby increasing the size of the wait queue and the number of parallel connections.</div><br/></div></div></div></div></div></div><div id="36850265" class="c"><input type="checkbox" id="c-36850265" checked=""/><div class="controls bullet"><span class="by">tamimio</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36850048">parent</a><span>|</span><a href="#36851207">prev</a><span>|</span><a href="#36850498">next</a><span>|</span><label class="collapse" for="c-36850265">[-]</label><label class="expand" for="c-36850265">[1 more]</label></div><br/><div class="children"><div class="content">Doesn’t matter, great article!</div><br/></div></div><div id="36850498" class="c"><input type="checkbox" id="c-36850498" checked=""/><div class="controls bullet"><span class="by">account42</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36850048">parent</a><span>|</span><a href="#36850265">prev</a><span>|</span><a href="#36850028">next</a><span>|</span><label class="collapse" for="c-36850498">[-]</label><label class="expand" for="c-36850498">[5 more]</label></div><br/><div class="children"><div class="content">Interesting, do you mind sharing what software you use to serve the static html and what kind of traffic its getting.</div><br/><div id="36851114" class="c"><input type="checkbox" id="c-36851114" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36850498">parent</a><span>|</span><a href="#36850028">next</a><span>|</span><label class="collapse" for="c-36851114">[-]</label><label class="expand" for="c-36851114">[4 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  HTTP&#x2F;1.1 200 OK
  Date: Mon, 24 Jul 2023 17:05:06 GMT
  Server: Apache</code></pre></div><br/><div id="36852177" class="c"><input type="checkbox" id="c-36852177" checked=""/><div class="controls bullet"><span class="by">brazzledazzle</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36851114">parent</a><span>|</span><a href="#36850028">next</a><span>|</span><label class="collapse" for="c-36852177">[-]</label><label class="expand" for="c-36852177">[3 more]</label></div><br/><div class="children"><div class="content">I do not miss performance tuning apache.</div><br/><div id="36852616" class="c"><input type="checkbox" id="c-36852616" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36852177">parent</a><span>|</span><a href="#36850028">next</a><span>|</span><label class="collapse" for="c-36852616">[-]</label><label class="expand" for="c-36852616">[2 more]</label></div><br/><div class="children"><div class="content">In my personal experience, the first step in tuning Apache was &quot;put a nginx server in front of it&quot;. Running out of workers (either processes in the prefork model, or threads otherwise) was in my experience way too easy, especially when keepalive is enabled (even a couple of seconds of keepalive can be painful). The async model used by nginx can handle a lot more connections before running out of resources.</div><br/><div id="36852889" class="c"><input type="checkbox" id="c-36852889" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36852616">parent</a><span>|</span><a href="#36850028">next</a><span>|</span><label class="collapse" for="c-36852889">[-]</label><label class="expand" for="c-36852889">[1 more]</label></div><br/><div class="children"><div class="content">Apache has been defaulting to event mpm for over a decade.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36850028" class="c"><input type="checkbox" id="c-36850028" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36849788">parent</a><span>|</span><a href="#36850048">prev</a><span>|</span><a href="#36850061">next</a><span>|</span><label class="collapse" for="c-36850028">[-]</label><label class="expand" for="c-36850028">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a security writeup so it&#x27;s probably run by a security expert who is not an expert at running high traffic websites.  Most likely there is something on the page that causes a database hit.  Possibly the page content itself.</div><br/></div></div><div id="36850061" class="c"><input type="checkbox" id="c-36850061" checked=""/><div class="controls bullet"><span class="by">marcus0x62</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36849788">parent</a><span>|</span><a href="#36850028">prev</a><span>|</span><a href="#36851455">next</a><span>|</span><label class="collapse" for="c-36850061">[-]</label><label class="expand" for="c-36850061">[1 more]</label></div><br/><div class="children"><div class="content">I imagine they are also getting traffic from sources other than HN.</div><br/></div></div><div id="36851455" class="c"><input type="checkbox" id="c-36851455" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36849788">parent</a><span>|</span><a href="#36850061">prev</a><span>|</span><a href="#36849818">next</a><span>|</span><label class="collapse" for="c-36851455">[-]</label><label class="expand" for="c-36851455">[1 more]</label></div><br/><div class="children"><div class="content">100rps for most articles. I bet this is at least double that, and he&#x27;s using apache which by default I think is still thread per connection.</div><br/></div></div></div></div><div id="36849818" class="c"><input type="checkbox" id="c-36849818" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#36849268">parent</a><span>|</span><a href="#36849788">prev</a><span>|</span><a href="#36849312">next</a><span>|</span><label class="collapse" for="c-36849818">[-]</label><label class="expand" for="c-36849818">[1 more]</label></div><br/><div class="children"><div class="content">Faster link: <a href="https:&#x2F;&#x2F;archive.is&#x2F;QAwvQ" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.is&#x2F;QAwvQ</a></div><br/></div></div><div id="36849312" class="c"><input type="checkbox" id="c-36849312" checked=""/><div class="controls bullet"><span class="by">AdmiralAsshat</span><span>|</span><a href="#36849268">parent</a><span>|</span><a href="#36849818">prev</a><span>|</span><a href="#36849366">next</a><span>|</span><label class="collapse" for="c-36849312">[-]</label><label class="expand" for="c-36849312">[1 more]</label></div><br/><div class="children"><div class="content">And now we&#x27;ve hugged the archive to death. Nice job!</div><br/></div></div><div id="36849366" class="c"><input type="checkbox" id="c-36849366" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36849268">parent</a><span>|</span><a href="#36849312">prev</a><span>|</span><a href="#36853833">next</a><span>|</span><label class="collapse" for="c-36849366">[-]</label><label class="expand" for="c-36849366">[3 more]</label></div><br/><div class="children"><div class="content">The original still loads (eventually) for me.  YMMV.</div><br/><div id="36849491" class="c"><input type="checkbox" id="c-36849491" checked=""/><div class="controls bullet"><span class="by">nevi-me</span><span>|</span><a href="#36849268">root</a><span>|</span><a href="#36849366">parent</a><span>|</span><a href="#36853833">next</a><span>|</span><label class="collapse" for="c-36849491">[-]</label><label class="expand" for="c-36849491">[2 more]</label></div><br/><div class="children"><div class="content">XMMV or ZMMV could also apply</div><br/></div></div></div></div></div></div><div id="36853833" class="c"><input type="checkbox" id="c-36853833" checked=""/><div class="controls bullet"><span class="by">akyuu</span><span>|</span><a href="#36849268">prev</a><span>|</span><a href="#36853442">next</a><span>|</span><label class="collapse" for="c-36853833">[-]</label><label class="expand" for="c-36853833">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.amd.com&#x2F;en&#x2F;resources&#x2F;product-security&#x2F;bulletin&#x2F;amd-sb-7008.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.amd.com&#x2F;en&#x2F;resources&#x2F;product-security&#x2F;bulletin&#x2F;a...</a><p>According to AMD&#x27;s security bulletin, firmware updates for non-EPYC CPUs won&#x27;t be released until the end of the year. What should users do until then, disable the chicken bit and take the performance hit?</div><br/><div id="36853855" class="c"><input type="checkbox" id="c-36853855" checked=""/><div class="controls bullet"><span class="by">stefan_</span><span>|</span><a href="#36853833">parent</a><span>|</span><a href="#36853442">next</a><span>|</span><label class="collapse" for="c-36853855">[-]</label><label class="expand" for="c-36853855">[2 more]</label></div><br/><div class="children"><div class="content">Are they out of their mind? This is not a &quot;medium&quot;.</div><br/><div id="36854393" class="c"><input type="checkbox" id="c-36854393" checked=""/><div class="controls bullet"><span class="by">qhwudbebd</span><span>|</span><a href="#36853833">root</a><span>|</span><a href="#36853855">parent</a><span>|</span><a href="#36853442">next</a><span>|</span><label class="collapse" for="c-36854393">[-]</label><label class="expand" for="c-36854393">[1 more]</label></div><br/><div class="children"><div class="content">Presumably classified as severity &#x27;medium&#x27; in an attempt to look marginally less negligent when announcing that they can&#x27;t be bothered to issue microcode updates for most CPU models until Nov or Dec.</div><br/></div></div></div></div></div></div><div id="36853442" class="c"><input type="checkbox" id="c-36853442" checked=""/><div class="controls bullet"><span class="by">LtdJorge</span><span>|</span><a href="#36853833">prev</a><span>|</span><a href="#36850914">next</a><span>|</span><label class="collapse" for="c-36853442">[-]</label><label class="expand" for="c-36853442">[1 more]</label></div><br/><div class="children"><div class="content">This is both as cool as it is scary. I managed to &quot;exfiltrate&quot; pieces of my Bitwarden password (could easily be reconstructed), ssh login password, and bank credentials in a minute of running from a 10MB sample.</div><br/></div></div><div id="36850914" class="c"><input type="checkbox" id="c-36850914" checked=""/><div class="controls bullet"><span class="by">jrmg</span><span>|</span><a href="#36853442">prev</a><span>|</span><a href="#36850047">next</a><span>|</span><label class="collapse" for="c-36850914">[-]</label><label class="expand" for="c-36850914">[13 more]</label></div><br/><div class="children"><div class="content"><i>AMD have released an microcode update for affected processors. Your BIOS or Operating System vendor may already have an update available that includes it.</i><p>I don’t really understand how CPU microcode updates work. If I’m keeping Ubuntu up to date, will this just happen automatically?</div><br/><div id="36851087" class="c"><input type="checkbox" id="c-36851087" checked=""/><div class="controls bullet"><span class="by">tremon</span><span>|</span><a href="#36850914">parent</a><span>|</span><a href="#36851274">next</a><span>|</span><label class="collapse" for="c-36851087">[-]</label><label class="expand" for="c-36851087">[7 more]</label></div><br/><div class="children"><div class="content">If you already have the package amd64-microcode installed (highly likely), then yes it will be updated automatically.<p><a href="https:&#x2F;&#x2F;packages.ubuntu.com&#x2F;search?keywords=amd64-microcode" rel="nofollow noreferrer">https:&#x2F;&#x2F;packages.ubuntu.com&#x2F;search?keywords=amd64-microcode</a></div><br/><div id="36851117" class="c"><input type="checkbox" id="c-36851117" checked=""/><div class="controls bullet"><span class="by">jrmg</span><span>|</span><a href="#36850914">root</a><span>|</span><a href="#36851087">parent</a><span>|</span><a href="#36851274">next</a><span>|</span><label class="collapse" for="c-36851117">[-]</label><label class="expand" for="c-36851117">[6 more]</label></div><br/><div class="children"><div class="content">Great, thanks.<p>Sort of weirds me out that my OS can just silently update my CPU - I didn’t realize I was giving it that level of control… I guess it’s good vs the alternative of no-one actually updating for exploits like his though.</div><br/><div id="36851920" class="c"><input type="checkbox" id="c-36851920" checked=""/><div class="controls bullet"><span class="by">sp332</span><span>|</span><a href="#36850914">root</a><span>|</span><a href="#36851117">parent</a><span>|</span><a href="#36851521">next</a><span>|</span><label class="collapse" for="c-36851920">[-]</label><label class="expand" for="c-36851920">[1 more]</label></div><br/><div class="children"><div class="content"><i>Active microcode updates are stored in volatile memory and thus have to be applied during each system boot.</i><p><a href="https:&#x2F;&#x2F;wiki.gentoo.org&#x2F;wiki&#x2F;Microcode" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.gentoo.org&#x2F;wiki&#x2F;Microcode</a></div><br/></div></div><div id="36851521" class="c"><input type="checkbox" id="c-36851521" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#36850914">root</a><span>|</span><a href="#36851117">parent</a><span>|</span><a href="#36851920">prev</a><span>|</span><a href="#36852213">next</a><span>|</span><label class="collapse" for="c-36851521">[-]</label><label class="expand" for="c-36851521">[2 more]</label></div><br/><div class="children"><div class="content">It does not upgrade your cpu, it loads up the firemware when you boot Linux.</div><br/><div id="36851978" class="c"><input type="checkbox" id="c-36851978" checked=""/><div class="controls bullet"><span class="by">jrmg</span><span>|</span><a href="#36850914">root</a><span>|</span><a href="#36851521">parent</a><span>|</span><a href="#36852213">next</a><span>|</span><label class="collapse" for="c-36851978">[-]</label><label class="expand" for="c-36851978">[1 more]</label></div><br/><div class="children"><div class="content">That’s reassuring, thanks (not sure why you’re getting downvoted!)</div><br/></div></div></div></div><div id="36852213" class="c"><input type="checkbox" id="c-36852213" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36850914">root</a><span>|</span><a href="#36851117">parent</a><span>|</span><a href="#36851521">prev</a><span>|</span><a href="#36851274">next</a><span>|</span><label class="collapse" for="c-36852213">[-]</label><label class="expand" for="c-36852213">[2 more]</label></div><br/><div class="children"><div class="content">As opposed to updating any other piece of software in the system directly?  The OS has always had full control.</div><br/><div id="36856073" class="c"><input type="checkbox" id="c-36856073" checked=""/><div class="controls bullet"><span class="by">ChadNauseam</span><span>|</span><a href="#36850914">root</a><span>|</span><a href="#36852213">parent</a><span>|</span><a href="#36851274">next</a><span>|</span><label class="collapse" for="c-36856073">[-]</label><label class="expand" for="c-36856073">[1 more]</label></div><br/><div class="children"><div class="content">The implication was that you could boot a malicious OS, then boot into a different OS with the same processor and get pwned. As other commenters mentioned, this mechanism doesn&#x27;t create that risk because the update has to be applied each boot.</div><br/></div></div></div></div></div></div></div></div><div id="36851274" class="c"><input type="checkbox" id="c-36851274" checked=""/><div class="controls bullet"><span class="by">sdht0</span><span>|</span><a href="#36850914">parent</a><span>|</span><a href="#36851087">prev</a><span>|</span><a href="#36850967">next</a><span>|</span><label class="collapse" for="c-36851274">[-]</label><label class="expand" for="c-36851274">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.cyberciti.biz&#x2F;faq&#x2F;install-update-intel-microcode-firmware-linux&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cyberciti.biz&#x2F;faq&#x2F;install-update-intel-microcode...</a></div><br/></div></div><div id="36850967" class="c"><input type="checkbox" id="c-36850967" checked=""/><div class="controls bullet"><span class="by">naikrovek</span><span>|</span><a href="#36850914">parent</a><span>|</span><a href="#36851274">prev</a><span>|</span><a href="#36850047">next</a><span>|</span><label class="collapse" for="c-36850967">[-]</label><label class="expand" for="c-36850967">[4 more]</label></div><br/><div class="children"><div class="content">no.<p>microcode changes are provided to the CPU at boot time and are only valid early in the boot process.  the machine UEFI&#x2F;BIOS must apply them.</div><br/><div id="36850987" class="c"><input type="checkbox" id="c-36850987" checked=""/><div class="controls bullet"><span class="by">tremon</span><span>|</span><a href="#36850914">root</a><span>|</span><a href="#36850967">parent</a><span>|</span><a href="#36850047">next</a><span>|</span><label class="collapse" for="c-36850987">[-]</label><label class="expand" for="c-36850987">[3 more]</label></div><br/><div class="children"><div class="content">Linux can (and does) apply microcode patches during kernel boot.</div><br/><div id="36854819" class="c"><input type="checkbox" id="c-36854819" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#36850914">root</a><span>|</span><a href="#36850987">parent</a><span>|</span><a href="#36857648">next</a><span>|</span><label class="collapse" for="c-36854819">[-]</label><label class="expand" for="c-36854819">[1 more]</label></div><br/><div class="children"><div class="content">for example use journalctl -k -g microcode to see log messages related to this: (intel cpu, so revision does not relate to anything AMD)<p>&gt; microcode: microcode updated early to revision 0xa6, date = 2022-06-28</div><br/></div></div><div id="36857648" class="c"><input type="checkbox" id="c-36857648" checked=""/><div class="controls bullet"><span class="by">naikrovek</span><span>|</span><a href="#36850914">root</a><span>|</span><a href="#36850987">parent</a><span>|</span><a href="#36854819">prev</a><span>|</span><a href="#36850047">next</a><span>|</span><label class="collapse" for="c-36857648">[-]</label><label class="expand" for="c-36857648">[1 more]</label></div><br/><div class="children"><div class="content">oh.<p>every time I think I&#x27;m right, I&#x27;m wrong, and every time I think I&#x27;m wrong, I&#x27;m right.<p>except here.  I&#x27;m always wrong, here.</div><br/></div></div></div></div></div></div></div></div><div id="36850047" class="c"><input type="checkbox" id="c-36850047" checked=""/><div class="controls bullet"><span class="by">wzdd</span><span>|</span><a href="#36850914">prev</a><span>|</span><a href="#36854488">next</a><span>|</span><label class="collapse" for="c-36850047">[-]</label><label class="expand" for="c-36850047">[2 more]</label></div><br/><div class="children"><div class="content">Really lovely writeup. I liked the discussion of determining how can you tell if a randomly-generated program performed correctly. The obvious approach is to just run it on an &quot;oracle&quot; -- another processor or simulator -- and see if it behaves the same way. But if you&#x27;re checking for microarchitectural effects with tight timing windows you can also write the same program with various stalls, fences, nops and so on -- things which shouldn&#x27;t affect the output (for single-threaded code) but which will result in the CPU doing significantly different things microarchitecturally. That way the CPU can be its own oracle.</div><br/><div id="36850772" class="c"><input type="checkbox" id="c-36850772" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#36850047">parent</a><span>|</span><a href="#36854488">next</a><span>|</span><label class="collapse" for="c-36850772">[-]</label><label class="expand" for="c-36850772">[1 more]</label></div><br/><div class="children"><div class="content">This part was super interesting, especially the differences between fuzzing software and hardware. I also liked the <i>chicken bit</i>.</div><br/></div></div></div></div><div id="36854488" class="c"><input type="checkbox" id="c-36854488" checked=""/><div class="controls bullet"><span class="by">blinkingled</span><span>|</span><a href="#36850047">prev</a><span>|</span><a href="#36849940">next</a><span>|</span><label class="collapse" for="c-36854488">[-]</label><label class="expand" for="c-36854488">[3 more]</label></div><br/><div class="children"><div class="content">On my Zen2 &#x2F; Renoir based system the PoC exploit continues to work albeit slowly even after updating the microcode (linked from TFA) that has the fix for this issue. The wrmsr stops it fully in its track.<p>Edit: just realized it must have been that the initramfs image is not updated with the manually updated firmware in &#x2F;lib&#x2F;firmware.<p>Edit2: Updated the initramfs and even if the benchmark.sh fails, .&#x2F;zenbleed -v2 still picks out and prints strings which doesn&#x27;t happen with the wrmsr solution.</div><br/><div id="36854655" class="c"><input type="checkbox" id="c-36854655" checked=""/><div class="controls bullet"><span class="by">johnp_</span><span>|</span><a href="#36854488">parent</a><span>|</span><a href="#36849940">next</a><span>|</span><label class="collapse" for="c-36854655">[-]</label><label class="expand" for="c-36854655">[2 more]</label></div><br/><div class="children"><div class="content">linux-firmware does not carry any microcode update for Renoir (yet). Or what do you mean by &quot;TFA&quot;?<p>The fixed Renoir microcode should have revision &gt;= 0x0860010b as per the kernel: <a href="https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;commit&#x2F;522b1d69219d8f083173819fde04f994aa051a98#diff-de2b53cae08d8bbbea0a1d691be722a7bbfec5cb32b20f5fbf13949b75fecc5fR991-R995">https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;commit&#x2F;522b1d69219d8f08317...</a></div><br/><div id="36855550" class="c"><input type="checkbox" id="c-36855550" checked=""/><div class="controls bullet"><span class="by">blinkingled</span><span>|</span><a href="#36854488">root</a><span>|</span><a href="#36854655">parent</a><span>|</span><a href="#36849940">next</a><span>|</span><label class="collapse" for="c-36855550">[-]</label><label class="expand" for="c-36855550">[1 more]</label></div><br/><div class="children"><div class="content">TFA == The Fine Article :)<p>Updated microcode shows 0x08600106 revision so I guess that explains it.</div><br/></div></div></div></div></div></div><div id="36849940" class="c"><input type="checkbox" id="c-36849940" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#36854488">prev</a><span>|</span><a href="#36850553">next</a><span>|</span><label class="collapse" for="c-36849940">[-]</label><label class="expand" for="c-36849940">[9 more]</label></div><br/><div class="children"><div class="content">No details on the performance impact of the microcode update. <i>Presumably</i> it disables speculative execution of vzeroupper?</div><br/><div id="36850041" class="c"><input type="checkbox" id="c-36850041" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#36849940">parent</a><span>|</span><a href="#36850553">next</a><span>|</span><label class="collapse" for="c-36850041">[-]</label><label class="expand" for="c-36850041">[8 more]</label></div><br/><div class="children"><div class="content">Or adds a guard.<p>They mention perf issues for the workaround but they&#x27;re notably absent from the microcode commentary.<p>I wonder what this is going to do to the new AMD hardware AWS is trying to roll out, which is supposed to be a substantial performance bump over the previous generation.</div><br/><div id="36851403" class="c"><input type="checkbox" id="c-36851403" checked=""/><div class="controls bullet"><span class="by">infinityio</span><span>|</span><a href="#36849940">root</a><span>|</span><a href="#36850041">parent</a><span>|</span><a href="#36851467">next</a><span>|</span><label class="collapse" for="c-36851403">[-]</label><label class="expand" for="c-36851403">[6 more]</label></div><br/><div class="children"><div class="content">It looks like this is a Zen 2-only exploit, so it shouldn&#x27;t have any impact - AWS are likely already running hardware that isn&#x27;t vulnerable to this</div><br/><div id="36851478" class="c"><input type="checkbox" id="c-36851478" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#36849940">root</a><span>|</span><a href="#36851403">parent</a><span>|</span><a href="#36858142">next</a><span>|</span><label class="collapse" for="c-36851478">[-]</label><label class="expand" for="c-36851478">[4 more]</label></div><br/><div class="children"><div class="content">The way Spectre and Meltdown played out, you&#x27;ll have to excuse me if I stand outside the blast radius while we figure out if there&#x27;s a chapter 2, 3 or 4 to this story.<p>They&#x27;ve proven Zen 2 has this problem. They haven&#x27;t proven no other AMD processors have it. A bunch of people looking to make names for themselves are probably busily testing every other AMD processor for a similar exploit.</div><br/><div id="36851888" class="c"><input type="checkbox" id="c-36851888" checked=""/><div class="controls bullet"><span class="by">heywhatupboys</span><span>|</span><a href="#36849940">root</a><span>|</span><a href="#36851478">parent</a><span>|</span><a href="#36858142">next</a><span>|</span><label class="collapse" for="c-36851888">[-]</label><label class="expand" for="c-36851888">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The way Spectre and Meltdown played out, you&#x27;ll have to excuse me if I stand outside the blast radius while we figure out if there&#x27;s a chapter 2, 3 or 4 to this story.<p>I am OOTL on this one, do you have some information you could share?</div><br/><div id="36852237" class="c"><input type="checkbox" id="c-36852237" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36849940">root</a><span>|</span><a href="#36851888">parent</a><span>|</span><a href="#36854855">next</a><span>|</span><label class="collapse" for="c-36852237">[-]</label><label class="expand" for="c-36852237">[1 more]</label></div><br/><div class="children"><div class="content">There has been a long trickle of similar bugs to Spectre&#x2F;Meltdown coming out long after the initial bugs and &quot;fixes&quot; were published.  (The early fixes were all, in some sense, incomplete.)</div><br/></div></div><div id="36854855" class="c"><input type="checkbox" id="c-36854855" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#36849940">root</a><span>|</span><a href="#36851888">parent</a><span>|</span><a href="#36852237">prev</a><span>|</span><a href="#36858142">next</a><span>|</span><label class="collapse" for="c-36854855">[-]</label><label class="expand" for="c-36854855">[1 more]</label></div><br/><div class="children"><div class="content">There was a list of vulnerabilities in this comment up top: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36849914">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36849914</a></div><br/></div></div></div></div></div></div><div id="36858142" class="c"><input type="checkbox" id="c-36858142" checked=""/><div class="controls bullet"><span class="by">Dunedan</span><span>|</span><a href="#36849940">root</a><span>|</span><a href="#36851403">parent</a><span>|</span><a href="#36851478">prev</a><span>|</span><a href="#36851467">next</a><span>|</span><label class="collapse" for="c-36858142">[-]</label><label class="expand" for="c-36858142">[1 more]</label></div><br/><div class="children"><div class="content">AWS does offer Zen 2 based EC2 instances though (C5a family for example).</div><br/></div></div></div></div><div id="36851467" class="c"><input type="checkbox" id="c-36851467" checked=""/><div class="controls bullet"><span class="by">jeffffff</span><span>|</span><a href="#36849940">root</a><span>|</span><a href="#36850041">parent</a><span>|</span><a href="#36851403">prev</a><span>|</span><a href="#36850553">next</a><span>|</span><label class="collapse" for="c-36851467">[-]</label><label class="expand" for="c-36851467">[1 more]</label></div><br/><div class="children"><div class="content">shouldn&#x27;t have any effect, the new amd hardware is zen 4 and this only affects zen 2</div><br/></div></div></div></div></div></div><div id="36850553" class="c"><input type="checkbox" id="c-36850553" checked=""/><div class="controls bullet"><span class="by">artisanspam</span><span>|</span><a href="#36849940">prev</a><span>|</span><a href="#36851824">next</a><span>|</span><label class="collapse" for="c-36850553">[-]</label><label class="expand" for="c-36850553">[10 more]</label></div><br/><div class="children"><div class="content">Why does disabling SMT not fully prevent this? I don&#x27;t know the details of Zen 2 architecture, but register files are usually implemented as SRAM on the CPU-die itself. So unless the core is running SMT, I don&#x27;t understand how another thread could be accessing the register file to write a secret.</div><br/><div id="36851032" class="c"><input type="checkbox" id="c-36851032" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#36850553">parent</a><span>|</span><a href="#36850587">next</a><span>|</span><label class="collapse" for="c-36851032">[-]</label><label class="expand" for="c-36851032">[5 more]</label></div><br/><div class="children"><div class="content">Because unless you pin the threads to certain CPU cores (e.g. in Linux by using the taskset command, or in Windows by using the Set Affinity command in Task Manager), they are migrated very frequently between cores.<p>So even with SMT disabled, each core will execute sequentially many threads, switching every few milliseconds from one thread to another, and each context switch does not modify the hidden registers, it just restores the architecturally visible registers.</div><br/><div id="36855229" class="c"><input type="checkbox" id="c-36855229" checked=""/><div class="controls bullet"><span class="by">dontlaugh</span><span>|</span><a href="#36850553">root</a><span>|</span><a href="#36851032">parent</a><span>|</span><a href="#36850587">next</a><span>|</span><label class="collapse" for="c-36855229">[-]</label><label class="expand" for="c-36855229">[4 more]</label></div><br/><div class="children"><div class="content">Pinning doesn’t help either, since there will always be more threads than cores. Scheduling all those threads and even blocking on IO will cause context switches.</div><br/><div id="36855892" class="c"><input type="checkbox" id="c-36855892" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#36850553">root</a><span>|</span><a href="#36855229">parent</a><span>|</span><a href="#36850587">next</a><span>|</span><label class="collapse" for="c-36855892">[-]</label><label class="expand" for="c-36855892">[3 more]</label></div><br/><div class="children"><div class="content">I do not know how that is done in Windows, but in Linux it is possible to reserve  some cores to be used only for the threads that you assign to them and for no other threads.<p>This is done frequently for high-performance applications.</div><br/><div id="36857221" class="c"><input type="checkbox" id="c-36857221" checked=""/><div class="controls bullet"><span class="by">comonoid</span><span>|</span><a href="#36850553">root</a><span>|</span><a href="#36855892">parent</a><span>|</span><a href="#36850587">next</a><span>|</span><label class="collapse" for="c-36857221">[-]</label><label class="expand" for="c-36857221">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Pigeonhole_principle" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Pigeonhole_principle</a></div><br/><div id="36859622" class="c"><input type="checkbox" id="c-36859622" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#36850553">root</a><span>|</span><a href="#36857221">parent</a><span>|</span><a href="#36850587">next</a><span>|</span><label class="collapse" for="c-36859622">[-]</label><label class="expand" for="c-36859622">[1 more]</label></div><br/><div class="children"><div class="content">That does not apply when some cores are reserved for manual thread assignment, because the scheduler no longer throws pigeons in those holes, but schedules threads only on the other cores.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36850587" class="c"><input type="checkbox" id="c-36850587" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#36850553">parent</a><span>|</span><a href="#36851032">prev</a><span>|</span><a href="#36851824">next</a><span>|</span><label class="collapse" for="c-36850587">[-]</label><label class="expand" for="c-36850587">[4 more]</label></div><br/><div class="children"><div class="content">Because the context switch only affects architectural state not microarchitectural state.</div><br/><div id="36850771" class="c"><input type="checkbox" id="c-36850771" checked=""/><div class="controls bullet"><span class="by">artisanspam</span><span>|</span><a href="#36850553">root</a><span>|</span><a href="#36850587">parent</a><span>|</span><a href="#36851824">next</a><span>|</span><label class="collapse" for="c-36850771">[-]</label><label class="expand" for="c-36850771">[3 more]</label></div><br/><div class="children"><div class="content">Yes I understand that but I was struggling to think of a sequence of instructions that would cause this secret leaking on a single thread.<p>But a simple example is `vzeroupper` followed by anything that writes a secret to the same register file entry would be leaked on a subsequent flush.</div><br/><div id="36855507" class="c"><input type="checkbox" id="c-36855507" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#36850553">root</a><span>|</span><a href="#36850771">parent</a><span>|</span><a href="#36852830">next</a><span>|</span><label class="collapse" for="c-36855507">[-]</label><label class="expand" for="c-36855507">[1 more]</label></div><br/><div class="children"><div class="content">It depends a bit on the exact details of the implementation, but there are several possibilities imaginable.<p>For example, a failed speculation of vzeroupper <i>could</i> result in it erroneously claiming a register by clearing the zero flag on the <i>wrong</i> register - which would mean that the previous data of that register is now suddenly available. If that register has not been touched since a context switch, it could leak data from another process.<p>The linked article has an animation which suggests that it clears the zero flag on the previously-used register - which indeed requires the victim to reuse the register in the small amount of time between it being marked as zero and the zero being cleared again.<p>However, the linked Github repo states:<p>&gt; The undefined portion of our ymm register will contain random data from the register file. [..] Note that this is not a timing attack or a side channel, the full values can simply be read as fast as you can access them.<p>This suggests that it does indeed do something akin to clearing the zero flag of a random register.</div><br/></div></div><div id="36852830" class="c"><input type="checkbox" id="c-36852830" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#36850553">root</a><span>|</span><a href="#36850771">parent</a><span>|</span><a href="#36855507">prev</a><span>|</span><a href="#36851824">next</a><span>|</span><label class="collapse" for="c-36852830">[-]</label><label class="expand" for="c-36852830">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not quite right. The attacker doss the vzeroupper rollback. Any registers in the physical file that haven&#x27;t been overwritten can be exposed as a result, regardless of what the victim did.</div><br/></div></div></div></div></div></div></div></div><div id="36851824" class="c"><input type="checkbox" id="c-36851824" checked=""/><div class="controls bullet"><span class="by">kristjank</span><span>|</span><a href="#36850553">prev</a><span>|</span><a href="#36856063">next</a><span>|</span><label class="collapse" for="c-36851824">[-]</label><label class="expand" for="c-36851824">[1 more]</label></div><br/><div class="children"><div class="content">At least it&#x27;s fixed in microcode, unlike some recent exploits (Spectre and Meltdown come to mind)</div><br/></div></div><div id="36856063" class="c"><input type="checkbox" id="c-36856063" checked=""/><div class="controls bullet"><span class="by">farhanhubble</span><span>|</span><a href="#36851824">prev</a><span>|</span><a href="#36856158">next</a><span>|</span><label class="collapse" for="c-36856063">[-]</label><label class="expand" for="c-36856063">[1 more]</label></div><br/><div class="children"><div class="content">What a beautiful article! All my memories from the computer architecture class came rushing back.</div><br/></div></div><div id="36856158" class="c"><input type="checkbox" id="c-36856158" checked=""/><div class="controls bullet"><span class="by">SamuelAdams</span><span>|</span><a href="#36856063">prev</a><span>|</span><a href="#36855793">next</a><span>|</span><label class="collapse" for="c-36856158">[-]</label><label class="expand" for="c-36856158">[1 more]</label></div><br/><div class="children"><div class="content">To me this is the buried lede:<p>&gt; It was challenging to get the details right, but I used this to teach my fuzzer to find interesting instruction sequences. This allowed me to discover features like merge optimization automatically, without any input from me!<p>What happens when AI can start fuzzing software? Seems like a golden opportunity for opsec folks.</div><br/></div></div><div id="36856481" class="c"><input type="checkbox" id="c-36856481" checked=""/><div class="controls bullet"><span class="by">slappy7</span><span>|</span><a href="#36855793">prev</a><span>|</span><a href="#36852699">next</a><span>|</span><label class="collapse" for="c-36856481">[-]</label><label class="expand" for="c-36856481">[1 more]</label></div><br/><div class="children"><div class="content">Anybody know how to disable the chicken bit on Windows?<p>They&#x27;re not planning to fix this until fucking December...</div><br/></div></div><div id="36852699" class="c"><input type="checkbox" id="c-36852699" checked=""/><div class="controls bullet"><span class="by">href</span><span>|</span><a href="#36856481">prev</a><span>|</span><a href="#36851864">next</a><span>|</span><label class="collapse" for="c-36852699">[-]</label><label class="expand" for="c-36852699">[4 more]</label></div><br/><div class="children"><div class="content">Can anyone explain the `wrmsr -a 0xc0011029 $(($(rdmsr -c 0xc0011029) | (1&lt;&lt;9)))`?  It seems to help on my system, but I don&#x27;t understand what it does, and I don&#x27;t know how to unset it.</div><br/><div id="36853844" class="c"><input type="checkbox" id="c-36853844" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#36852699">parent</a><span>|</span><a href="#36853557">next</a><span>|</span><label class="collapse" for="c-36853844">[-]</label><label class="expand" for="c-36853844">[1 more]</label></div><br/><div class="children"><div class="content">CPU designers know that some features are risky. Much like how web apps may often have &quot;feature flags&quot; that can be flipped on and off by operators in case a feature goes wrong, CPUs have &quot;chicken bits&quot; that control various performance enhancing tricks and exotic instructions. By flipping that bit you disable the optimization.</div><br/></div></div><div id="36853557" class="c"><input type="checkbox" id="c-36853557" checked=""/><div class="controls bullet"><span class="by">taviso</span><span>|</span><a href="#36852699">parent</a><span>|</span><a href="#36853844">prev</a><span>|</span><a href="#36853052">next</a><span>|</span><label class="collapse" for="c-36853557">[-]</label><label class="expand" for="c-36853557">[1 more]</label></div><br/><div class="children"><div class="content">An msr is a &quot;model specific register&quot;, a chicken bit can configure cpu features.<p>They don&#x27;t persist across a reboot, so you can&#x27;t break anything. You can undo what you just did without a reboot, just use `... &amp; ~(1 &lt;&lt; 9)` instead (unset the bit instead of set it).</div><br/></div></div><div id="36853052" class="c"><input type="checkbox" id="c-36853052" checked=""/><div class="controls bullet"><span class="by">mmastrac</span><span>|</span><a href="#36852699">parent</a><span>|</span><a href="#36853557">prev</a><span>|</span><a href="#36851864">next</a><span>|</span><label class="collapse" for="c-36853052">[-]</label><label class="expand" for="c-36853052">[1 more]</label></div><br/><div class="children"><div class="content">This sets the chicken bit: <a href="https:&#x2F;&#x2F;www.phoronix.com&#x2F;news&#x2F;Linux-AMD-Spectral-Chicken" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.phoronix.com&#x2F;news&#x2F;Linux-AMD-Spectral-Chicken</a></div><br/></div></div></div></div><div id="36851864" class="c"><input type="checkbox" id="c-36851864" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#36852699">prev</a><span>|</span><a href="#36851237">next</a><span>|</span><label class="collapse" for="c-36851864">[-]</label><label class="expand" for="c-36851864">[7 more]</label></div><br/><div class="children"><div class="content">Off-topic question, but can some experts tell me why it is safe for `strlen()` and friends to use vector instructions when they can technically read out of bounds?</div><br/><div id="36852130" class="c"><input type="checkbox" id="c-36852130" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36851864">parent</a><span>|</span><a href="#36851237">next</a><span>|</span><label class="collapse" for="c-36852130">[-]</label><label class="expand" for="c-36852130">[6 more]</label></div><br/><div class="children"><div class="content">Essentially because memory mappings and RAM work at page granularity, rather than bytes.  If a read from in-bounds in a page isn&#x27;t going to fault, a read later in the same page isn&#x27;t going to fault either (even if it is past the end of the particular object).<p>You can see this in glibc&#x27;s implementation, which checks for crossing page boundaries: <a href="https:&#x2F;&#x2F;sourceware.org&#x2F;git&#x2F;?p=glibc.git;a=blob;f=sysdeps&#x2F;x86_64&#x2F;multiarch&#x2F;strlen-avx2.S;h=ef47a45cb6289ef9a7ff076521006ca5990c4180;hb=HEAD#l68" rel="nofollow noreferrer">https:&#x2F;&#x2F;sourceware.org&#x2F;git&#x2F;?p=glibc.git;a=blob;f=sysdeps&#x2F;x86...</a> (line ~68)</div><br/><div id="36852276" class="c"><input type="checkbox" id="c-36852276" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#36851864">root</a><span>|</span><a href="#36852130">parent</a><span>|</span><a href="#36851237">next</a><span>|</span><label class="collapse" for="c-36852276">[-]</label><label class="expand" for="c-36852276">[5 more]</label></div><br/><div class="children"><div class="content">Ah, so <i>that&#x27;s</i> why there is special code in Valgrind to handle glibc and friends!</div><br/><div id="36853170" class="c"><input type="checkbox" id="c-36853170" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36851864">root</a><span>|</span><a href="#36852276">parent</a><span>|</span><a href="#36851237">next</a><span>|</span><label class="collapse" for="c-36853170">[-]</label><label class="expand" for="c-36853170">[4 more]</label></div><br/><div class="children"><div class="content">I think capability-pointer machines like CHERI might need in-bounds-only variants of these functions, too.</div><br/><div id="36854921" class="c"><input type="checkbox" id="c-36854921" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#36851864">root</a><span>|</span><a href="#36853170">parent</a><span>|</span><a href="#36851237">next</a><span>|</span><label class="collapse" for="c-36854921">[-]</label><label class="expand" for="c-36854921">[3 more]</label></div><br/><div class="children"><div class="content">Generally CHERI tracks things for 16-byte regions</div><br/><div id="36855410" class="c"><input type="checkbox" id="c-36855410" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36851864">root</a><span>|</span><a href="#36854921">parent</a><span>|</span><a href="#36855268">next</a><span>|</span><label class="collapse" for="c-36855410">[-]</label><label class="expand" for="c-36855410">[1 more]</label></div><br/><div class="children"><div class="content">Implementations using 32- or 64-byte (256 or 512 bit) vector extensions would run afoul of 16-byte granularity.  While it is not common yet, ARM SVE allows vector sizes larger than 128 bits -- e.g., Graviton3 has 256-bit SVE and Fujitsu A64FX has 512-bit.  (x86 has had 256 and 512 bit vector instructions for some time, but current CHERI development seems to be on ARM.)</div><br/></div></div><div id="36855268" class="c"><input type="checkbox" id="c-36855268" checked=""/><div class="controls bullet"><span class="by">Liquid_Fire</span><span>|</span><a href="#36851864">root</a><span>|</span><a href="#36854921">parent</a><span>|</span><a href="#36855410">prev</a><span>|</span><a href="#36851237">next</a><span>|</span><label class="collapse" for="c-36855268">[-]</label><label class="expand" for="c-36855268">[1 more]</label></div><br/><div class="children"><div class="content">I think you might be confusing the tracking of validity of capabilities themselves (which could indeed be at a 16 byte granularity for an otherwise 64-bit system) with the bounds of a capability, which can be as small as 1 byte.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36851237" class="c"><input type="checkbox" id="c-36851237" checked=""/><div class="controls bullet"><span class="by">codedokode</span><span>|</span><a href="#36851864">prev</a><span>|</span><a href="#36852457">next</a><span>|</span><label class="collapse" for="c-36851237">[-]</label><label class="expand" for="c-36851237">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand how a microcode update could fix this. I assume microcode is used for slow operations like triginometric functions, and doesn&#x27;t affect how registers are allocated or renamed. Or does the update simply disables some optimizations using &quot;chicken bits&quot;? And by the way, is there a list of such bits?</div><br/><div id="36851295" class="c"><input type="checkbox" id="c-36851295" checked=""/><div class="controls bullet"><span class="by">sebzim4500</span><span>|</span><a href="#36851237">parent</a><span>|</span><a href="#36853665">next</a><span>|</span><label class="collapse" for="c-36851295">[-]</label><label class="expand" for="c-36851295">[3 more]</label></div><br/><div class="children"><div class="content">Everything a modern CPU runs is microcode. There are a few x86 instructions that translate to a single microcode instruction, but most are translated to several.</div><br/><div id="36856230" class="c"><input type="checkbox" id="c-36856230" checked=""/><div class="controls bullet"><span class="by">blibble</span><span>|</span><a href="#36851237">root</a><span>|</span><a href="#36851295">parent</a><span>|</span><a href="#36853665">next</a><span>|</span><label class="collapse" for="c-36856230">[-]</label><label class="expand" for="c-36856230">[2 more]</label></div><br/><div class="children"><div class="content">this hasn&#x27;t been the case since the 486</div><br/><div id="36859638" class="c"><input type="checkbox" id="c-36859638" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#36851237">root</a><span>|</span><a href="#36856230">parent</a><span>|</span><a href="#36853665">next</a><span>|</span><label class="collapse" for="c-36859638">[-]</label><label class="expand" for="c-36859638">[1 more]</label></div><br/><div class="children"><div class="content">Which part? And what&#x27;s the reality now?</div><br/></div></div></div></div></div></div><div id="36853665" class="c"><input type="checkbox" id="c-36853665" checked=""/><div class="controls bullet"><span class="by">wolf550e</span><span>|</span><a href="#36851237">parent</a><span>|</span><a href="#36851295">prev</a><span>|</span><a href="#36852457">next</a><span>|</span><label class="collapse" for="c-36853665">[-]</label><label class="expand" for="c-36853665">[1 more]</label></div><br/><div class="children"><div class="content">The designers leave themselves an ability to override any instruction using the microcode so they can patch any instruction. They don&#x27;t use the microcode only to implement complex instructions that require loops.</div><br/></div></div></div></div><div id="36852457" class="c"><input type="checkbox" id="c-36852457" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#36851237">prev</a><span>|</span><a href="#36849143">next</a><span>|</span><label class="collapse" for="c-36852457">[-]</label><label class="expand" for="c-36852457">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t expect it to as it&#x27;s Zen3, but still tried: doesn&#x27;t repro on my 5950X.</div><br/></div></div><div id="36849092" class="c"><input type="checkbox" id="c-36849092" checked=""/><div class="controls bullet"><span class="by">causi</span><span>|</span><a href="#36849143">prev</a><span>|</span><a href="#36849637">next</a><span>|</span><label class="collapse" for="c-36849092">[-]</label><label class="expand" for="c-36849092">[9 more]</label></div><br/><div class="children"><div class="content"><i>AMD Ryzen 5000 Series Processors with Radeon Graphics</i><p>Does this mean Ryzen CPUs without integrated graphics are fine?</div><br/><div id="36849127" class="c"><input type="checkbox" id="c-36849127" checked=""/><div class="controls bullet"><span class="by">gruez</span><span>|</span><a href="#36849092">parent</a><span>|</span><a href="#36849487">next</a><span>|</span><label class="collapse" for="c-36849127">[-]</label><label class="expand" for="c-36849127">[5 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s all Zen 2 CPUs, which include both desktop CPUs (with or without integrated graphics, laptop CPUs, and server CPUs. The reason why the product list is so confusing is that AMD reuses architectures across generations. You&#x27;d think that all ryzen 5000 series CPUs have the same microarchitecture, but they don&#x27;t). It&#x27;s much easier to consult this list instead: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Zen_2#Products" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Zen_2#Products</a></div><br/><div id="36849697" class="c"><input type="checkbox" id="c-36849697" checked=""/><div class="controls bullet"><span class="by">paulmd</span><span>|</span><a href="#36849092">root</a><span>|</span><a href="#36849127">parent</a><span>|</span><a href="#36849487">next</a><span>|</span><label class="collapse" for="c-36849697">[-]</label><label class="expand" for="c-36849697">[4 more]</label></div><br/><div class="children"><div class="content">FYI this list isn&#x27;t exhaustive.  And I went to recommend the wikichips link and it&#x27;s not exhaustive either.<p><a href="https:&#x2F;&#x2F;en.wikichip.org&#x2F;wiki&#x2F;amd&#x2F;microarchitectures&#x2F;zen_2#All_Zen_2_Chips" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikichip.org&#x2F;wiki&#x2F;amd&#x2F;microarchitectures&#x2F;zen_2#Al...</a><p>Both of them are missing the newer 7000-family products with Zen2 like 7520U etc.<p><a href="https:&#x2F;&#x2F;www.amd.com&#x2F;en&#x2F;products&#x2F;apu&#x2F;amd-ryzen-5-7520u" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.amd.com&#x2F;en&#x2F;products&#x2F;apu&#x2F;amd-ryzen-5-7520u</a><p><a href="https:&#x2F;&#x2F;www.amd.com&#x2F;en&#x2F;products&#x2F;apu&#x2F;amd-ryzen-3-7320u" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.amd.com&#x2F;en&#x2F;products&#x2F;apu&#x2F;amd-ryzen-3-7320u</a><p><a href="https:&#x2F;&#x2F;www.amd.com&#x2F;en&#x2F;products&#x2F;apu&#x2F;amd-athlon-gold-7220u" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.amd.com&#x2F;en&#x2F;products&#x2F;apu&#x2F;amd-athlon-gold-7220u</a></div><br/><div id="36849852" class="c"><input type="checkbox" id="c-36849852" checked=""/><div class="controls bullet"><span class="by">neogodless</span><span>|</span><a href="#36849092">root</a><span>|</span><a href="#36849697">parent</a><span>|</span><a href="#36849928">next</a><span>|</span><label class="collapse" for="c-36849852">[-]</label><label class="expand" for="c-36849852">[1 more]</label></div><br/><div class="children"><div class="content">The 7520U and 7530U are listed on the linked Wikipedia page. Look under &quot;Ultra-mobile APUs&quot;.<p>The Athlon is missing, though.</div><br/></div></div><div id="36849928" class="c"><input type="checkbox" id="c-36849928" checked=""/><div class="controls bullet"><span class="by">tremon</span><span>|</span><a href="#36849092">root</a><span>|</span><a href="#36849697">parent</a><span>|</span><a href="#36849852">prev</a><span>|</span><a href="#36849487">next</a><span>|</span><label class="collapse" for="c-36849928">[-]</label><label class="expand" for="c-36849928">[2 more]</label></div><br/><div class="children"><div class="content"><i>products&#x2F;apu&#x2F;amd-athlon</i><p>Wait... now there&#x27;s also APU&#x27;s under the AMD Athlon brand? I know that people are happy when AMD&#x27;s product offerings are on-par or outperforming Intel, but they didn&#x27;t have to outdo Intel in the consumer confusion arena as well.</div><br/><div id="36850097" class="c"><input type="checkbox" id="c-36850097" checked=""/><div class="controls bullet"><span class="by">paulmd</span><span>|</span><a href="#36849092">root</a><span>|</span><a href="#36849928">parent</a><span>|</span><a href="#36849487">next</a><span>|</span><label class="collapse" for="c-36850097">[-]</label><label class="expand" for="c-36850097">[1 more]</label></div><br/><div class="children"><div class="content">Has been for a while.<p><a href="https:&#x2F;&#x2F;www.techpowerup.com&#x2F;cpu-specs&#x2F;athlon-200ge.c2073" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.techpowerup.com&#x2F;cpu-specs&#x2F;athlon-200ge.c2073</a><p>Intel also used the Pentium branding for low-end processors (below i3 and in the Atom lineup), and followed it up with the rather perplexing move of using their company name as the sole branding for their worst products (&quot;Intel Processor&quot;).</div><br/></div></div></div></div></div></div></div></div><div id="36849487" class="c"><input type="checkbox" id="c-36849487" checked=""/><div class="controls bullet"><span class="by">lgl</span><span>|</span><a href="#36849092">parent</a><span>|</span><a href="#36849127">prev</a><span>|</span><a href="#36849212">next</a><span>|</span><label class="collapse" for="c-36849487">[-]</label><label class="expand" for="c-36849487">[2 more]</label></div><br/><div class="children"><div class="content">The only series 5000 cpu&#x27;s that are still using Zen2 architecture are apparently the 5300U, 5500U and 5700U, which all use socket FP6 (mobile&#x2F;embedded).<p>So I&#x27;m guessing it shouldn&#x27;t affect any of the more recent and very popular Zen3 cpus like the 5600, 5700 etc. I personally own a 5600, which are a great bang for buck.</div><br/><div id="36849608" class="c"><input type="checkbox" id="c-36849608" checked=""/><div class="controls bullet"><span class="by">paulmd</span><span>|</span><a href="#36849092">root</a><span>|</span><a href="#36849487">parent</a><span>|</span><a href="#36849212">next</a><span>|</span><label class="collapse" for="c-36849608">[-]</label><label class="expand" for="c-36849608">[1 more]</label></div><br/><div class="children"><div class="content">Lucienne (5700U&#x2F;5500U&#x2F;5300U) are the only Zen2s in the 5000 series at present (afaik), but AMD continues to re-use the Zen2 architecture in the 7000 series (7520U, etc), as well as many semicustom products like Steam Deck.<p>It&#x27;s in rather a sweet-spot as far as performance-power-area, so this isn&#x27;t entirely a bad thing.  Zen3&#x27;s main innovation was unifying the CCXs&#x2F;caches, but if you only have a 4C, or you want to be able to power-gate a CCX (and its attendant IF links&#x2F;caches) down entirely, Zen2 does that better, and it&#x27;s slightly smaller.  We&#x27;ll be seeing Zen2 products for years to come, most likely.</div><br/></div></div></div></div><div id="36849212" class="c"><input type="checkbox" id="c-36849212" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#36849092">parent</a><span>|</span><a href="#36849487">prev</a><span>|</span><a href="#36849637">next</a><span>|</span><label class="collapse" for="c-36849212">[-]</label><label class="expand" for="c-36849212">[1 more]</label></div><br/><div class="children"><div class="content">No this means AMD&#x27;s numbering scheme is intentionally obtuse. This has nothing to do with graphics, but with the CPU core, Zen 2.</div><br/></div></div></div></div><div id="36849637" class="c"><input type="checkbox" id="c-36849637" checked=""/><div class="controls bullet"><span class="by">hprotagonist</span><span>|</span><a href="#36849092">prev</a><span>|</span><a href="#36849344">next</a><span>|</span><label class="collapse" for="c-36849637">[-]</label><label class="expand" for="c-36849637">[2 more]</label></div><br/><div class="children"><div class="content">ah, not the color theme. Hamming distance strikes again!<p><a href="https:&#x2F;&#x2F;kippura.org&#x2F;zenburnpage" rel="nofollow noreferrer">https:&#x2F;&#x2F;kippura.org&#x2F;zenburnpage</a></div><br/><div id="36851911" class="c"><input type="checkbox" id="c-36851911" checked=""/><div class="controls bullet"><span class="by">heywhatupboys</span><span>|</span><a href="#36849637">parent</a><span>|</span><a href="#36849344">next</a><span>|</span><label class="collapse" for="c-36851911">[-]</label><label class="expand" for="c-36851911">[1 more]</label></div><br/><div class="children"><div class="content">I knew there were color schemes for the color blind.<p>Schemes for the blind are news to me though</div><br/></div></div></div></div><div id="36857053" class="c"><input type="checkbox" id="c-36857053" checked=""/><div class="controls bullet"><span class="by">badrabbit</span><span>|</span><a href="#36849344">prev</a><span>|</span><a href="#36851135">next</a><span>|</span><label class="collapse" for="c-36857053">[-]</label><label class="expand" for="c-36857053">[1 more]</label></div><br/><div class="children"><div class="content">Nice writeup, very easy to read. This guy is  a bonafide legend, the whole time, based on his writing style I thought it was someone new to the field explaining in detail because it was hard for him to  get it as well, but I see his name at the end and recalled all the epic findings of his. Very humble&#x2F;nice guy, even in person I hear (rare for well accomplished people in tech).<p>One thing I don&#x27;t get though, if amd64 is affected, shouldn&#x27;t the complementary instructions in X64&#x2F;intel also be affected? Does intel move around RAT referenced values instead of just setting&#x2F;unsetting the z-bit?</div><br/></div></div><div id="36851135" class="c"><input type="checkbox" id="c-36851135" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#36857053">prev</a><span>|</span><a href="#36849278">next</a><span>|</span><label class="collapse" for="c-36851135">[-]</label><label class="expand" for="c-36851135">[2 more]</label></div><br/><div class="children"><div class="content">This link seems hugged to death, so here&#x27;s an alternate source: AMD &#x27;Zenbleed&#x27; Bug Allows Data Theft From Zen 2 Processors, Patches Coming: &lt;<a href="https:&#x2F;&#x2F;www.tomshardware.com&#x2F;news&#x2F;zenbleed-bug-allows-data-theft-from-amds-zen-2-processors-patches-released" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.tomshardware.com&#x2F;news&#x2F;zenbleed-bug-allows-data-t...</a>&gt;</div><br/><div id="36851544" class="c"><input type="checkbox" id="c-36851544" checked=""/><div class="controls bullet"><span class="by">ItsTotallyOn</span><span>|</span><a href="#36851135">parent</a><span>|</span><a href="#36849278">next</a><span>|</span><label class="collapse" for="c-36851544">[-]</label><label class="expand" for="c-36851544">[1 more]</label></div><br/><div class="children"><div class="content">This story has comments from AMD, too.</div><br/></div></div></div></div></div></div></div></div></div></body></html>