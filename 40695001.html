<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1718614868161" as="style"/><link rel="stylesheet" href="styles.css?v=1718614868161"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jameshfisher.com/2018/02/20/c-inline-assembly-hello-world/">Hello world in C inline assembly (2020)</a>Â <span class="domain">(<a href="https://jameshfisher.com">jameshfisher.com</a>)</span></div><div class="subtext"><span>aragonite</span> | <span>18 comments</span></div><br/><div><div id="40703314" class="c"><input type="checkbox" id="c-40703314" checked=""/><div class="controls bullet"><span class="by">jmillikin</span><span>|</span><a href="#40702956">next</a><span>|</span><label class="collapse" for="c-40703314">[-]</label><label class="expand" for="c-40703314">[1 more]</label></div><br/><div class="children"><div class="content">As other comments have noted, the asm statement needs to have its input&#x2F;output registers specified to ensure the compiler doesn&#x27;t erase the &quot;unused&quot; values.<p>Working example: <a href="https:&#x2F;&#x2F;john-millikin.com&#x2F;unix-syscalls#linux-x86-64-gnu-c" rel="nofollow">https:&#x2F;&#x2F;john-millikin.com&#x2F;unix-syscalls#linux-x86-64-gnu-c</a><p>Adapted to use main():<p><pre><code>  static const int STDOUT = 1;
  static const int SYSCALL_WRITE = 1;
  static const char message[] = &quot;Hello, world!\n&quot;;
  static const int message_len = sizeof(message);

  int main() {
   register int         rax __asm__ (&quot;rax&quot;) = SYSCALL_WRITE;
   register int         rdi __asm__ (&quot;rdi&quot;) = STDOUT;
   register const char *rsi __asm__ (&quot;rsi&quot;) = message;
   register int         rdx __asm__ (&quot;rdx&quot;) = message_len;
   __asm__ __volatile__ (&quot;syscall&quot;
    : &quot;+r&quot; (rax)
    : &quot;r&quot; (rax), &quot;r&quot; (rdi), &quot;r&quot; (rsi), &quot;r&quot; (rdx)
    : &quot;rcx&quot;, &quot;r11&quot;);
   return 0;
  }
</code></pre>
Test with:<p><pre><code>  $ gcc -o hello hello.c
  $ .&#x2F;hello
  Hello, world!</code></pre></div><br/></div></div><div id="40702956" class="c"><input type="checkbox" id="c-40702956" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#40703314">prev</a><span>|</span><a href="#40695096">next</a><span>|</span><label class="collapse" for="c-40702956">[-]</label><label class="expand" for="c-40702956">[6 more]</label></div><br/><div class="children"><div class="content">Actually more readable than the AT&amp;T syntax :)<p>But does this work on both GCC and Clang, and is safe from being optimized away? <i>edit: the answer is no</i><p>Turbo Pascal had an integrated assembler that could use symbols (and even complex types) defined anywhere in the program, like this:<p><pre><code>    procedure HelloWorld; assembler;
    const Message: String = &#x27;Hello, world!&#x27;^M^J;  {Msg+CR+LF}
    asm
        mov  ah,$40  {DOS system call number for write}
        mov  bx,1    {standard output}
        xor  ch,ch   {clear high byte of length}
        mov  cl,Message.byte[0]
        mov  dx,offset Message+1
        int  $21
    end;</code></pre></div><br/><div id="40703336" class="c"><input type="checkbox" id="c-40703336" checked=""/><div class="controls bullet"><span class="by">boffinAudio</span><span>|</span><a href="#40702956">parent</a><span>|</span><a href="#40695096">next</a><span>|</span><label class="collapse" for="c-40703336">[-]</label><label class="expand" for="c-40703336">[5 more]</label></div><br/><div class="children"><div class="content">Thanks for making me extremely sentimental for the hundreds of Turbo Pascal projects I did back in the day - this particular example highlights the elegance and clarity of the language, which we still seem to resist in our modern tooling.</div><br/><div id="40703388" class="c"><input type="checkbox" id="c-40703388" checked=""/><div class="controls bullet"><span class="by">g15jv2dp</span><span>|</span><a href="#40702956">root</a><span>|</span><a href="#40703336">parent</a><span>|</span><a href="#40695096">next</a><span>|</span><label class="collapse" for="c-40703388">[-]</label><label class="expand" for="c-40703388">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really see what&#x27;s &quot;elegant&quot; about the code, could you elaborate? (This isn&#x27;t a jab at GP. I&#x27;m just curious about what I&#x27;m not seeing.)</div><br/><div id="40703458" class="c"><input type="checkbox" id="c-40703458" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#40702956">root</a><span>|</span><a href="#40703388">parent</a><span>|</span><a href="#40703496">next</a><span>|</span><label class="collapse" for="c-40703458">[-]</label><label class="expand" for="c-40703458">[2 more]</label></div><br/><div class="children"><div class="content">You might want to compare it to the &quot;proper&quot; version of the inline asm code, from this comment: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40703314">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40703314</a><p>Modern C is neither &quot;low-level&quot; or &quot;high-level&quot;. It&#x27;s defined for an abstract machine where integers can&#x27;t overflow, null pointers can&#x27;t be referenced, etc. And unless you follow all the rules, and add proper annotations for things like inline assembly, the compiler is free to do <i>anything</i> to your code.<p>The one advantage to this approach is that modern compilers can turn megabytes of auto-generated crap produced by string substitution macros into halfway decent machine language.<p>(And I freely admit that specifically Turbo Pascal produced <i>really</i> bad code, worse even than C compilers at the time, but the syntax is oh so much nicer IMHO)</div><br/><div id="40703647" class="c"><input type="checkbox" id="c-40703647" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40702956">root</a><span>|</span><a href="#40703458">parent</a><span>|</span><a href="#40703496">next</a><span>|</span><label class="collapse" for="c-40703647">[-]</label><label class="expand" for="c-40703647">[1 more]</label></div><br/><div class="children"><div class="content">I believe that MSVC inline asm allows referencing variables in the  asm as it can parse and understand the asm (at least before they got rid of inline asm completely for 64 bit code).<p>AFAIK GCC does not attempt to parse the asm by design, as it is meant to be used for code that the compiler might not understand, so you have to describe input, outputs and side effects with annotations.</div><br/></div></div></div></div><div id="40703496" class="c"><input type="checkbox" id="c-40703496" checked=""/><div class="controls bullet"><span class="by">boffinAudio</span><span>|</span><a href="#40702956">root</a><span>|</span><a href="#40703388">parent</a><span>|</span><a href="#40703458">prev</a><span>|</span><a href="#40695096">next</a><span>|</span><label class="collapse" for="c-40703496">[-]</label><label class="expand" for="c-40703496">[1 more]</label></div><br/><div class="children"><div class="content">I think its elegant because the distinction between Pascal and Assembly is made using the Pascal <i>asm .. end;</i> keywords, and in that block one can also access the Pascal variables without much fuss involving the assembler.<p>I find that really nice to read and to look at, whereas the examples given in the original article are prone to syntax overload, what with all the intermixing - for example, the variable declarations having what &#x27;look&#x27; like attributes - but are really assembly instructions, emitted.<p>I guess one would have had to have enjoyed writing Turbo Pascal code, though, to see this particular aesthetic. A lot of folks do, some don&#x27;t ..</div><br/></div></div></div></div></div></div></div></div><div id="40695096" class="c"><input type="checkbox" id="c-40695096" checked=""/><div class="controls bullet"><span class="by">onderweg</span><span>|</span><a href="#40702956">prev</a><span>|</span><a href="#40703184">next</a><span>|</span><label class="collapse" for="c-40695096">[-]</label><label class="expand" for="c-40695096">[3 more]</label></div><br/><div class="children"><div class="content">Is anyone aware of a similar example, for ARM assembly on macOS?</div><br/><div id="40703398" class="c"><input type="checkbox" id="c-40703398" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#40695096">parent</a><span>|</span><a href="#40702845">next</a><span>|</span><label class="collapse" for="c-40703398">[-]</label><label class="expand" for="c-40703398">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    int
    main(void) {
        register const char *msg asm(&quot;x1&quot;) = &quot;hello, world!\n&quot;;
        asm volatile (
            &quot;mov w0, #1\n&quot;
            &quot;mov w2, #14\n&quot;
            &quot;mov w16, #4\n&quot;
            &quot;svc #128\n&quot;
            :
            : &quot;r&quot; (msg)
        );
    }</code></pre></div><br/></div></div><div id="40702845" class="c"><input type="checkbox" id="c-40702845" checked=""/><div class="controls bullet"><span class="by">brontitall</span><span>|</span><a href="#40695096">parent</a><span>|</span><a href="#40703398">prev</a><span>|</span><a href="#40703184">next</a><span>|</span><label class="collapse" for="c-40702845">[-]</label><label class="expand" for="c-40702845">[1 more]</label></div><br/><div class="children"><div class="content">Not inline, but this was linked in a comment on HN a few days ago<p><a href="https:&#x2F;&#x2F;github.com&#x2F;below&#x2F;HelloSilicon">https:&#x2F;&#x2F;github.com&#x2F;below&#x2F;HelloSilicon</a></div><br/></div></div></div></div><div id="40703184" class="c"><input type="checkbox" id="c-40703184" checked=""/><div class="controls bullet"><span class="by">msla</span><span>|</span><a href="#40695096">prev</a><span>|</span><a href="#40703123">next</a><span>|</span><label class="collapse" for="c-40703184">[-]</label><label class="expand" for="c-40703184">[3 more]</label></div><br/><div class="children"><div class="content">When I compile it with GCC 12, this machine code results:<p><pre><code>    1129:       f3 0f 1e fa             endbr64 
    112d:       55                      push   rbp
    112e:       48 89 e5                mov    rbp,rsp
    1131:       b8 01 00 00 00          mov    eax,0x1
    1136:       bf 01 00 00 00          mov    edi,0x1
    113b:       48 8d 05 c2 0e 00 00    lea    rax,[rip+0xec2]        # 2004 &lt;_IO_stdin_used+0x4&gt;
    1142:       48 89 c6                mov    rsi,rax
    1145:       ba 0f 00 00 00          mov    edx,0xf
    114a:       0f 05                   syscall 
    114c:       b8 00 00 00 00          mov    eax,0x0
    1151:       5d                      pop    rbp
    1152:       c3                      ret    
</code></pre>
Can you spot the error?<p>.
.
.
.
.
.<p>The code biffs rax when it loads the string address, so the system call number is lost, and the code ends up not printing anything. Moving the string assignment to be the very first line in main fixes it.<p>BTW, Clang 14 with no optimization accepts the code without issue but compiles it without using any of the registers; it just stores the values to memory locations and runs the syscall opcode. With O1 optimization or higher, it optimizes away everything except the syscall opcode.</div><br/><div id="40703587" class="c"><input type="checkbox" id="c-40703587" checked=""/><div class="controls bullet"><span class="by">khrbtxyz</span><span>|</span><a href="#40703184">parent</a><span>|</span><a href="#40703243">next</a><span>|</span><label class="collapse" for="c-40703587">[-]</label><label class="expand" for="c-40703587">[1 more]</label></div><br/><div class="children"><div class="content">The exact same thing happens with GCC 12 with 32-bit MIPS.<p><pre><code>  #include &lt;asm&#x2F;unistd.h&gt;
   
  char msg[] = &quot;hello, world!\n&quot;;
   
  int main(void)
  {
      register int syscall_no asm(&quot;v0&quot;) = __NR_write;
      register int arg1       asm(&quot;a0&quot;) = 1;
      register char *arg2     asm(&quot;a1&quot;) = msg;
      register int arg3       asm(&quot;a2&quot;) = sizeof(msg) - 1;
   
      asm(&quot;syscall&quot;);
   
      return 0;
  }

  root@OpenWrt:~# objdump --disassemble=main
  00400580 &lt;main&gt;:
    400580: 27bdfff8  addiu sp,sp,-8
    400584: afbe0004  sw s8,4(sp)
    400588: 03a0f025  move s8,sp
    40058c: 24020fa4  li v0,4004
    400590: 24040001  li a0,1
    400594: 3c020041  lui v0,0x41
    400598: 24450650  addiu a1,v0,1616
    40059c: 2406000e  li a2,14
    4005a0: 0000000c  syscall</code></pre></div><br/></div></div><div id="40703243" class="c"><input type="checkbox" id="c-40703243" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#40703184">parent</a><span>|</span><a href="#40703587">prev</a><span>|</span><a href="#40703123">next</a><span>|</span><label class="collapse" for="c-40703243">[-]</label><label class="expand" for="c-40703243">[1 more]</label></div><br/><div class="children"><div class="content">With an older version, it works (as long as there is no optimization at least, with -O2 all the register init code disappears):<p>$ gcc -v<p>... gcc version 10.2.1 20210110 (Debian 10.2.1-6)<p><pre><code>    0000000000001125 &lt;main&gt;:
        1125: 55                    push   %rbp
        1126: 48 89 e5              mov    %rsp,%rbp
        1129: b8 01 00 00 00        mov    $0x1,%eax
        112e: bf 01 00 00 00        mov    $0x1,%edi
        1133: 48 8d 35 ca 0e 00 00  lea    0xeca(%rip),%rsi        # 2004 &lt;_IO_stdin_used+0x4&gt;
        113a: ba 0e 00 00 00        mov    $0xe,%edx
        113f: 0f 05                 syscall 
</code></pre>
No idea why a newer version produces worse code in this case (though of course, this way of doing inline assembly isn&#x27;t &quot;correct&quot; anyway, so nasal demons may result)</div><br/></div></div></div></div><div id="40703123" class="c"><input type="checkbox" id="c-40703123" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#40703184">prev</a><span>|</span><label class="collapse" for="c-40703123">[-]</label><label class="expand" for="c-40703123">[4 more]</label></div><br/><div class="children"><div class="content">Never seen inline assembly written quite like that, is this actually correct code? I&#x27;m concerned that normally register annotation is just a hint, and that the assembly blocks are not marked volatile - and that the compiler may therefore be free to rewrite this code in many breaking ways.<p>Edit: Ah a basic asm blocks is implicitly volatile. I&#x27;m still a little concerned the compiler could get clever and decide the register variables are unused and optimize them out.</div><br/><div id="40703198" class="c"><input type="checkbox" id="c-40703198" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#40703123">parent</a><span>|</span><a href="#40703257">next</a><span>|</span><label class="collapse" for="c-40703198">[-]</label><label class="expand" for="c-40703198">[2 more]</label></div><br/><div class="children"><div class="content">Tried it with GCC, and without any optimization it does print the message. With &quot;-O2&quot; however, we get this:<p><pre><code>    Disassembly of section .text:
    
    0000000000001040 &lt;main&gt;:
        1040: 0f 05                 syscall 
        1042: 31 c0                 xor    %eax,%eax
        1044: c3                    retq   
</code></pre>
Everything <i>except</i> the syscall instruction has been optimized away!</div><br/><div id="40703362" class="c"><input type="checkbox" id="c-40703362" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#40703123">root</a><span>|</span><a href="#40703198">parent</a><span>|</span><a href="#40703257">next</a><span>|</span><label class="collapse" for="c-40703362">[-]</label><label class="expand" for="c-40703362">[1 more]</label></div><br/><div class="children"><div class="content">Now that&#x27;s incredibly cursed. Could do basically anything and swallows the error too!</div><br/></div></div></div></div><div id="40703257" class="c"><input type="checkbox" id="c-40703257" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40703123">parent</a><span>|</span><a href="#40703198">prev</a><span>|</span><label class="collapse" for="c-40703257">[-]</label><label class="expand" for="c-40703257">[1 more]</label></div><br/><div class="children"><div class="content">I think that named register variables (a GCC extension) are meant to be live in asm block by design, so they shouldn&#x27;t be optimized away.<p>Still I would use extended asm.<p>edit: from the docs: &quot;The only supported use for [Specifying Registers for Local Variables] is to specify registers for input and output operands when calling Extended asm&quot;.<p>So the example is UB.</div><br/></div></div></div></div></div></div></div></div></div></body></html>