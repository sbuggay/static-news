<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710579650748" as="style"/><link rel="stylesheet" href="styles.css?v=1710579650748"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://danluu.com/butler-lampson-1999/">What&#x27;s worked in Computer Science: 1999 vs. 2015 (2015)</a> <span class="domain">(<a href="http://danluu.com">danluu.com</a>)</span></div><div class="subtext"><span>not_a_boat</span> | <span>118 comments</span></div><br/><div><div id="39718326" class="c"><input type="checkbox" id="c-39718326" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#39718392">next</a><span>|</span><label class="collapse" for="c-39718326">[-]</label><label class="expand" for="c-39718326">[24 more]</label></div><br/><div class="children"><div class="content">I would like to suggest that the classical taxonomy of RISC&#x2F;CISC dichotomy is basically non-existent nowadays -- namely because both sides have influenced each other. It is well known that CISC has taken a lot of inspirations from RISC designs (such as having a lot more registers in x64), and RISC designs also taken some inspirations from CISC (such as having SIMD&#x2F;vectorization units). In other words, the line between RISC and CISC has been very fine lately.<p>Also, at the end of the day, they all turned into μops. If I remember Jim Keller correctly, ARM and x86, they are basically the same in the back nowadays, its just the frontend and their decoding units are different. And that&#x27;s why he strongly suggested AMD to also adapt Zen design with ARM ISA during his tenure there, oh I think it is called K12.<p>I think there is another blurry line between superscalar and VLIW architecture, too.</div><br/><div id="39718685" class="c"><input type="checkbox" id="c-39718685" checked=""/><div class="controls bullet"><span class="by">abainbridge</span><span>|</span><a href="#39718326">parent</a><span>|</span><a href="#39722416">next</a><span>|</span><label class="collapse" for="c-39718685">[-]</label><label class="expand" for="c-39718685">[16 more]</label></div><br/><div class="children"><div class="content">Yep. RISC was interesting when gate budgets for CPU pipelines were seriously limited. It was interesting because before RISC the industry had been merrily spending the gate budget increase on adding lots of use-specific instructions. The RISC people pointed out that if you removed support for all the fancy instructions you had enough gate budget for the ALU to be nicely pipelined, and then you could wind up the clock rate greatly and this was worth much more than the fancy instructions.<p>For decades now we&#x27;ve had enough gate budget to have nicely pipelined designs with complex instruction sets, so that&#x27;s what everyone does. RISC solves a problem that no longer exists.</div><br/><div id="39719465" class="c"><input type="checkbox" id="c-39719465" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#39718326">root</a><span>|</span><a href="#39718685">parent</a><span>|</span><a href="#39719745">next</a><span>|</span><label class="collapse" for="c-39719465">[-]</label><label class="expand" for="c-39719465">[11 more]</label></div><br/><div class="children"><div class="content">You are not quite right about pipelined design being faster. At least, not without substantial effort.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;R2000_microprocessor" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;R2000_microprocessor</a><p>&quot;The R2000 is a 32-bit microprocessor chip set developed by MIPS Computer Systems that implemented the MIPS I instruction set architecture (ISA)...&quot;<p>&quot;The R2000 was available in 8.3, 12.5 and 15 MHz grades...&quot;<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;I386" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;I386</a><p>&quot;The Intel 386, originally released as 80386 and later renamed i386, is a 32-bit microprocessor introduced in 1985...&quot;<p>&quot;Max. CPU clock rate: 12.5 MHz to 40 MHz&quot;<p>As you can see, 80386 was released a year earlier than R2000 and was about 1.5 times faster than MIPS implementation from the start.<p>The critical path is, usually, in addition&#x2F;subtraction, which should be complete in one cycle in both 80386 and in R2000. To pipeline addition you need a superpipelined CPU, one that has several stages for computation. Even seemingly simple computation of condition codes can make clock cycle 10% longer (SPARC vs MIPS) if your CPU is just simply pipelined.<p>BTW, some Pentiums did computed 32-bit addition in two cycles, all in name of higher clock frequencies.</div><br/><div id="39720360" class="c"><input type="checkbox" id="c-39720360" checked=""/><div class="controls bullet"><span class="by">abainbridge</span><span>|</span><a href="#39718326">root</a><span>|</span><a href="#39719465">parent</a><span>|</span><a href="#39721086">next</a><span>|</span><label class="collapse" for="c-39720360">[-]</label><label class="expand" for="c-39720360">[6 more]</label></div><br/><div class="children"><div class="content">Interesting. An R2000 did run programs faster than a 80386, right? This was a few years before my time.<p>From a quick google now, it looks like the R2000 was about 3x better than the 80386 at Dhrystone MIPS&#x2F;MHz. I guess an accurate comparison of how the R2000 and 80386 spent they gate budget and what they got in return would involve a lot of detail.<p>I remember my compsci professor giving us the computer architecture course in about 1997, and he dispaired at how all the clever RISC stuff in the Patterson and Hennessey seemed irrelevant when Intel could just throw money at the implementation (and fab, I guess) and produce competitive chips despite their (allegedly) inferior architecture.</div><br/><div id="39720994" class="c"><input type="checkbox" id="c-39720994" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#39718326">root</a><span>|</span><a href="#39720360">parent</a><span>|</span><a href="#39721724">next</a><span>|</span><label class="collapse" for="c-39720994">[-]</label><label class="expand" for="c-39720994">[4 more]</label></div><br/><div class="children"><div class="content">My point is that you cannot get design much faster in terms of clock frequency by just pipelining. Pipeline unrolls state machine and overlaps different executions of the state machines. But the bottleneck, which is addition, is there in all designs and you need additional effort to break it.<p>(also MIPS has [i]ntelocked [p]ipeline [s]tages - that &quot;IPS&quot; in MIPS; I implemented it, I know - exception in execution should inform other stages about failure)<p>By the 1997 Intel has already bought Elbrus II design team, lead by Pentkovski [1]. That Pentkovski guy made Elbrus 2 a superscalar CPU with a stack machine front-end. E.g., Elbrus 2 executed stack operations in a superscalar fashion. You can entertain yourself by figuring out how complex or simple can that be.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Vladimir_Pentkovski" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Vladimir_Pentkovski</a><p>So at the time your professor complained about Intel&#x27;s inferior architecture being faster, that inferior architecture implementation has a translation unit inside it to translate x86 opcodes into superscalar-ready uops.</div><br/><div id="39721748" class="c"><input type="checkbox" id="c-39721748" checked=""/><div class="controls bullet"><span class="by">peterfirefly</span><span>|</span><a href="#39718326">root</a><span>|</span><a href="#39720994">parent</a><span>|</span><a href="#39721724">next</a><span>|</span><label class="collapse" for="c-39721748">[-]</label><label class="expand" for="c-39721748">[3 more]</label></div><br/><div class="children"><div class="content">Addition was not the bottle neck for the 386.  It had a FO4 delay of 80+ per clock.  An adder is much faster.<p>Maybe you meant that it was (one, just one!, of many of) the bottle neck(s) in an optimized implementation?</div><br/><div id="39721853" class="c"><input type="checkbox" id="c-39721853" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#39718326">root</a><span>|</span><a href="#39721748">parent</a><span>|</span><a href="#39721724">next</a><span>|</span><label class="collapse" for="c-39721853">[-]</label><label class="expand" for="c-39721853">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Addition was not the bottle neck for the 386.<p>It is a bottleneck for MIPS, SPARC, Alpha and not for 386. How so?</div><br/><div id="39721978" class="c"><input type="checkbox" id="c-39721978" checked=""/><div class="controls bullet"><span class="by">peterfirefly</span><span>|</span><a href="#39718326">root</a><span>|</span><a href="#39721853">parent</a><span>|</span><a href="#39721724">next</a><span>|</span><label class="collapse" for="c-39721978">[-]</label><label class="expand" for="c-39721978">[1 more]</label></div><br/><div class="children"><div class="content">The 386 wastes so many FO4 gate delays on other things.  I thought I made that extremely clear?</div><br/></div></div></div></div></div></div></div></div><div id="39721724" class="c"><input type="checkbox" id="c-39721724" checked=""/><div class="controls bullet"><span class="by">peterfirefly</span><span>|</span><a href="#39718326">root</a><span>|</span><a href="#39720360">parent</a><span>|</span><a href="#39720994">prev</a><span>|</span><a href="#39721086">next</a><span>|</span><label class="collapse" for="c-39721724">[-]</label><label class="expand" for="c-39721724">[1 more]</label></div><br/><div class="children"><div class="content">And the R2000 was implemented in 2µm and the (early) 386 was implemented in 1.5µm.  Double-metal for both.  Didn&#x27;t bother to look up die size.</div><br/></div></div></div></div><div id="39721086" class="c"><input type="checkbox" id="c-39721086" checked=""/><div class="controls bullet"><span class="by">smcin</span><span>|</span><a href="#39718326">root</a><span>|</span><a href="#39719465">parent</a><span>|</span><a href="#39720360">prev</a><span>|</span><a href="#39719745">next</a><span>|</span><label class="collapse" for="c-39721086">[-]</label><label class="expand" for="c-39721086">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not apples-to-apples to compare raw clock rates between semiconductor processes; Intel&#x27;s 386 was intially fabbed on 1.5μ then shrunk to 1.0μ process (Intel CHMOS III and IV), whereas MIPS R2000 was 2.0μ, fabless and relied on Sierra, Toshiba, then in 1987 LSI, IDT and other licensees [0][1].<p>Back in the 1980s&#x2F;90s&#x2F;2000s, Intel was consistently a process generation or two ahead of competitors. That was one of their main sources of advantage.<p>Just imagine if MIPS had been able to fab on Intel process.<p>[0]: <a href="https:&#x2F;&#x2F;www.righto.com&#x2F;2023&#x2F;10&#x2F;intel-386-die-versions.html" rel="nofollow">https:&#x2F;&#x2F;www.righto.com&#x2F;2023&#x2F;10&#x2F;intel-386-die-versions.html</a><p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;R2000_microprocessor" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;R2000_microprocessor</a></div><br/><div id="39721181" class="c"><input type="checkbox" id="c-39721181" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#39718326">root</a><span>|</span><a href="#39721086">parent</a><span>|</span><a href="#39719745">next</a><span>|</span><label class="collapse" for="c-39721181">[-]</label><label class="expand" for="c-39721181">[3 more]</label></div><br/><div class="children"><div class="content">And you are also confirm that in order to have higher clock frequency you need more than just pipelining.<p>Thank you.<p>I also think that 1.5x difference in clock speeds cannot be directly attributed to the difference between node size (lambda): difference in lambdas 1.3(3)=2.0&#x2F;1.5 at the introduction of the 80386 and R2000 is noticeably less than 1.47=12.5&#x2F;8.5.</div><br/><div id="39721683" class="c"><input type="checkbox" id="c-39721683" checked=""/><div class="controls bullet"><span class="by">smcin</span><span>|</span><a href="#39718326">root</a><span>|</span><a href="#39721181">parent</a><span>|</span><a href="#39719745">next</a><span>|</span><label class="collapse" for="c-39721683">[-]</label><label class="expand" for="c-39721683">[2 more]</label></div><br/><div class="children"><div class="content">Smaller transistors are faster, but the relationship between clock frequency and 1&#x2F;feature size isn&#x27;t necessarily linear like you&#x27;re assuming.<p><a href="https:&#x2F;&#x2F;cs.stackexchange.com&#x2F;questions&#x2F;27875&#x2F;moores-law-and-clock-speed" rel="nofollow">https:&#x2F;&#x2F;cs.stackexchange.com&#x2F;questions&#x2F;27875&#x2F;moores-law-and-...</a></div><br/><div id="39721842" class="c"><input type="checkbox" id="c-39721842" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#39718326">root</a><span>|</span><a href="#39721683">parent</a><span>|</span><a href="#39719745">next</a><span>|</span><label class="collapse" for="c-39721842">[-]</label><label class="expand" for="c-39721842">[1 more]</label></div><br/><div class="children"><div class="content">My assumption is that speedup is less than lambda&#x27;s ratio.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39719745" class="c"><input type="checkbox" id="c-39719745" checked=""/><div class="controls bullet"><span class="by">bananabiscuit</span><span>|</span><a href="#39718326">root</a><span>|</span><a href="#39718685">parent</a><span>|</span><a href="#39719465">prev</a><span>|</span><a href="#39722416">next</a><span>|</span><label class="collapse" for="c-39719745">[-]</label><label class="expand" for="c-39719745">[4 more]</label></div><br/><div class="children"><div class="content">Is there something about RISC that is still makes it better than CISC when it comes to per-watt performance? Seems like nobody has any success making an x86 processor that&#x27;s as power efficient as ARM or RISC.</div><br/><div id="39721576" class="c"><input type="checkbox" id="c-39721576" checked=""/><div class="controls bullet"><span class="by">simne</span><span>|</span><a href="#39718326">root</a><span>|</span><a href="#39719745">parent</a><span>|</span><a href="#39719967">next</a><span>|</span><label class="collapse" for="c-39721576">[-]</label><label class="expand" for="c-39721576">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is there something about RISC that is still makes it better than CISC when it comes to per-watt performance?<p>CLASSIC CISC was micro-coded (for example, IBM S&#x2F;360 have feature, you could make your custom microcode for compatibility with your inherited equipment, like IBM-1401 machines or IBM-7XXX series, or for other purposes), and RISC was with pipeline from birth.<p>Second thing, as I understand, many CISC existed as multiple chips board or even as multiple boards, so have great losses on wires, but RISC appear in 1990s as one die immediately (only external cache added as additional IC), but I could mistake on this.<p>&gt; nobody has any success making an x86 processor that&#x27;s as power efficient as ARM or RISC<p>Rumors said, Intel Atom (essentially CMOS version of Pentium first generations) was very good in mobiles, but ARM far succeed it on software support of huge number of power saving features (modern ARM SOC allows to turn off near any part of chip any time and OS support this), and because of lack of software support, smartphones with Intel have poor time on battery.<p>More or less official info said, that Intel made bad power conversion circuit, so Atom consumes too much in mode between deep sleep and full speed, but I don&#x27;t believe them, as this is too obvious mistake for hardware developer.</div><br/></div></div><div id="39719967" class="c"><input type="checkbox" id="c-39719967" checked=""/><div class="controls bullet"><span class="by">card_zero</span><span>|</span><a href="#39718326">root</a><span>|</span><a href="#39719745">parent</a><span>|</span><a href="#39721576">prev</a><span>|</span><a href="#39723784">next</a><span>|</span><label class="collapse" for="c-39719967">[-]</label><label class="expand" for="c-39719967">[1 more]</label></div><br/><div class="children"><div class="content">Have there been recent attempts? Maybe it&#x27;s just, like, speciation, by this point in time.</div><br/></div></div><div id="39723784" class="c"><input type="checkbox" id="c-39723784" checked=""/><div class="controls bullet"><span class="by">mcbishop</span><span>|</span><a href="#39718326">root</a><span>|</span><a href="#39719745">parent</a><span>|</span><a href="#39719967">prev</a><span>|</span><a href="#39722416">next</a><span>|</span><label class="collapse" for="c-39723784">[-]</label><label class="expand" for="c-39723784">[1 more]</label></div><br/><div class="children"><div class="content">A great discussion on this: Lex Fridman&#x27;s interview of David Patterson.</div><br/></div></div></div></div></div></div><div id="39722416" class="c"><input type="checkbox" id="c-39722416" checked=""/><div class="controls bullet"><span class="by">simne</span><span>|</span><a href="#39718326">parent</a><span>|</span><a href="#39718685">prev</a><span>|</span><a href="#39720357">next</a><span>|</span><label class="collapse" for="c-39722416">[-]</label><label class="expand" for="c-39722416">[1 more]</label></div><br/><div class="children"><div class="content">&gt; classical taxonomy of RISC&#x2F;CISC dichotomy is basically non-existent nowadays<p>After digest information about IBM 360, I decided, we lost CISCs. One of most important feature of 360 was customizable microcode, which you could load on system boot and got effectively different hardware (like with FPGA emulators of Amiga&#x27;s). It was widely used to emulate old hardware, like IBM 1401 or IBM 7xxx series. But I have not seen this feature in 390 documentation, so looks like their 360 emulation become just software (and with achievements of semiconductors in 1990s it looks like adequate, to switch to software emulation).<p>I must admit, ARM marketed feature of customized microcode, to add new instructions (they have standardized place in instruction set, named &quot;custom coprocessor instructions&quot;, so if you have enough money, you could make special ARM with your additional instructions), but it is nothing if compare to 360.</div><br/></div></div><div id="39720357" class="c"><input type="checkbox" id="c-39720357" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#39718326">parent</a><span>|</span><a href="#39722416">prev</a><span>|</span><a href="#39720020">next</a><span>|</span><label class="collapse" for="c-39720357">[-]</label><label class="expand" for="c-39720357">[1 more]</label></div><br/><div class="children"><div class="content">RISC&#x2F;CISC is near the top of the list of &quot;things emphasized in education that bear little relevance in practice&quot;. RISC isn&#x27;t so much a single coherent design idea as a collection of ideas, some of which have won out (more register files), and some of which haven&#x27;t (avoid instructions that take multiple clock cycles). The architectures from the days the &quot;debate&quot; was more relevant that have had the most success are the ones which most thoroughly blurred the lines between classical RISC and CISC--namely, Arm and x86.<p>&gt; I think there is another blurry line between superscalar and VLIW architecture, too.<p>No, the line is pretty damn sharp. The core idea behind VLIW is that having hardware doing dynamic scheduling (as superscalar does) is silly and the compiler should be responsible for statically scheduling all instructions. The only blur here is that both VLIW and superscalar envision having multiple execution units that can be simultaneously scheduled with work, but who is responsible for doing that scheduling is pretty distinct.</div><br/></div></div><div id="39720020" class="c"><input type="checkbox" id="c-39720020" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#39718326">parent</a><span>|</span><a href="#39720357">prev</a><span>|</span><a href="#39721448">next</a><span>|</span><label class="collapse" for="c-39720020">[-]</label><label class="expand" for="c-39720020">[1 more]</label></div><br/><div class="children"><div class="content">I agree that the line is pretty thin, but would draw it as: fixed-width versus variable-width. I think the M? line of Apple CPUs, with extremely-wide parallel decode, has been a game changer. The performance per watt is really off the charts. That&#x27;s partly due to integrated RAM and all, but mostly due to microarchitectural changes, which I believe to be a massive step function in superscalar bandwidth (wider decode, huge ROB, huge numbers of ports). It seems like the power-hungry decode stage has been tamed, and I think this is because of fixed-width instructions in arm.</div><br/></div></div><div id="39721448" class="c"><input type="checkbox" id="c-39721448" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#39718326">parent</a><span>|</span><a href="#39720020">prev</a><span>|</span><a href="#39718964">next</a><span>|</span><label class="collapse" for="c-39721448">[-]</label><label class="expand" for="c-39721448">[1 more]</label></div><br/><div class="children"><div class="content">&gt; RISC designs also taken some inspirations from CISC (such as having SIMD&#x2F;vectorization units)<p>I think that one went the other way: for example the PlayStation 2 used a MIPS chip with 256-bit SIMD instructions (the TMPR 5900) as well as a dedicated GPU (the so-called “emotion engine”)</div><br/></div></div><div id="39718964" class="c"><input type="checkbox" id="c-39718964" checked=""/><div class="controls bullet"><span class="by">CalChris</span><span>|</span><a href="#39718326">parent</a><span>|</span><a href="#39721448">prev</a><span>|</span><a href="#39718392">next</a><span>|</span><label class="collapse" for="c-39718964">[-]</label><label class="expand" for="c-39718964">[3 more]</label></div><br/><div class="children"><div class="content">A 20,000 gate minimal RISC-V RV32E controller CPU isn&#x27;t going to use μops. In 2024, RISC-V has turned that 2015 No into an unqualified Yes even if the microarchitecture of more complex OOO RISC-V systems resemble the microarchitectures of similarly complex x86 and ARM CPUs.</div><br/><div id="39719379" class="c"><input type="checkbox" id="c-39719379" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#39718326">root</a><span>|</span><a href="#39718964">parent</a><span>|</span><a href="#39720897">next</a><span>|</span><label class="collapse" for="c-39719379">[-]</label><label class="expand" for="c-39719379">[1 more]</label></div><br/><div class="children"><div class="content">To the extent that RISC-V is successful it&#x27;s due to openness&#x2F;freeness; RISC has nothing to do with it. An open &quot;CISC-V&quot; community would have been just as successful (and people wouldn&#x27;t gripe about instruction fusion).</div><br/></div></div><div id="39720897" class="c"><input type="checkbox" id="c-39720897" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#39718326">root</a><span>|</span><a href="#39718964">parent</a><span>|</span><a href="#39719379">prev</a><span>|</span><a href="#39718392">next</a><span>|</span><label class="collapse" for="c-39720897">[-]</label><label class="expand" for="c-39720897">[1 more]</label></div><br/><div class="children"><div class="content">I have made a few of those RISC-V CPUs.  The minute the &quot;M&quot; instruction set shows up (with division), a macro&#x2F;micro-op split becomes worth it if you want to minimize gate count or maximize speed.</div><br/></div></div></div></div></div></div><div id="39718392" class="c"><input type="checkbox" id="c-39718392" checked=""/><div class="controls bullet"><span class="by">silvestrov</span><span>|</span><a href="#39718326">prev</a><span>|</span><a href="#39718160">next</a><span>|</span><label class="collapse" for="c-39718392">[-]</label><label class="expand" for="c-39718392">[20 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say that &quot;<i>pure</i> Functional programming&quot; has become a no.<p>But &quot;Functional programming approach&quot; has been subsumed into existing programming languages, e.g. records in Java.  You get most of the benefit of FP while keeping all of the other good stuf from an imperative language.</div><br/><div id="39720242" class="c"><input type="checkbox" id="c-39720242" checked=""/><div class="controls bullet"><span class="by">tubthumper8</span><span>|</span><a href="#39718392">parent</a><span>|</span><a href="#39718887">next</a><span>|</span><label class="collapse" for="c-39720242">[-]</label><label class="expand" for="c-39720242">[4 more]</label></div><br/><div class="children"><div class="content">Definitely agree that mainstream languages are adopting functional features, but records aren&#x27;t a functional feature.<p>Records are basic data modeling and something that has been around since the beginning of programming languages, whether procedural or functional. It&#x27;s one of the bare minimums of having a type system, and Java didn&#x27;t have this due to the misguided belief that &quot;everything is an object&quot;. I think records being added is more of a symptom of that belief weakening.<p>There are functional features that have made it over to Java which are the things related to <i>functions</i>, i.e. lambdas and such which are a welcome addition.</div><br/><div id="39720886" class="c"><input type="checkbox" id="c-39720886" checked=""/><div class="controls bullet"><span class="by">gardenhedge</span><span>|</span><a href="#39718392">root</a><span>|</span><a href="#39720242">parent</a><span>|</span><a href="#39718887">next</a><span>|</span><label class="collapse" for="c-39720886">[-]</label><label class="expand" for="c-39720886">[3 more]</label></div><br/><div class="children"><div class="content">Java records are object-oriented construct</div><br/><div id="39724204" class="c"><input type="checkbox" id="c-39724204" checked=""/><div class="controls bullet"><span class="by">ildjarn</span><span>|</span><a href="#39718392">root</a><span>|</span><a href="#39720886">parent</a><span>|</span><a href="#39723570">next</a><span>|</span><label class="collapse" for="c-39724204">[-]</label><label class="expand" for="c-39724204">[1 more]</label></div><br/><div class="children"><div class="content">OOP is about bundling state and behaviour into units that hide their internal mechanisms by some kind of interface.<p>Records can have no state - compared to regular classes - so they are an anti-OOP feature.</div><br/></div></div><div id="39723570" class="c"><input type="checkbox" id="c-39723570" checked=""/><div class="controls bullet"><span class="by">tubthumper8</span><span>|</span><a href="#39718392">root</a><span>|</span><a href="#39720886">parent</a><span>|</span><a href="#39724204">prev</a><span>|</span><a href="#39718887">next</a><span>|</span><label class="collapse" for="c-39723570">[-]</label><label class="expand" for="c-39723570">[1 more]</label></div><br/><div class="children"><div class="content">Maybe. It depends what the definition of &quot;object-oriented&quot; is, which depends what the definition of &quot;object&quot; is. Neither of which has any semblance of agreement among programmers.<p>Many people would define an object as something that has externally visible <i>behavior</i> and internally hidden _data_. Objects could never be compared to each other for equality, because one could not access the internal data, only its public behavior. However, Java records can be compared for equality which objects would not.<p>Java records also cannot be extended from. Inheritance is the only uniquely OOP feature, which doesn&#x27;t apply here either.<p>So I&#x27;m not sure that Java records are an object-oriented construct. First, the precise definition of OO should be established, and then we&#x27;ll see</div><br/></div></div></div></div></div></div><div id="39718887" class="c"><input type="checkbox" id="c-39718887" checked=""/><div class="controls bullet"><span class="by">unregistereddev</span><span>|</span><a href="#39718392">parent</a><span>|</span><a href="#39720242">prev</a><span>|</span><a href="#39719272">next</a><span>|</span><label class="collapse" for="c-39718887">[-]</label><label class="expand" for="c-39718887">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d agree with this and add that pattern matching and functional interfaces are additional examples of tools from the FP toolbox being subsumed into existing programming languages.<p>Pure functional programming seems tempting. In small projects it can produce beautiful, readable code. In large projects I&#x27;ve only seen it result in messes, and I still haven&#x27;t decided whether that&#x27;s due to limitations of functional purity, due to the team (and myself) misusing features that we don&#x27;t understand, or both.</div><br/></div></div><div id="39719272" class="c"><input type="checkbox" id="c-39719272" checked=""/><div class="controls bullet"><span class="by">ildjarn</span><span>|</span><a href="#39718392">parent</a><span>|</span><a href="#39718887">prev</a><span>|</span><a href="#39719514">next</a><span>|</span><label class="collapse" for="c-39719272">[-]</label><label class="expand" for="c-39719272">[7 more]</label></div><br/><div class="children"><div class="content">What mainstream languages have a good suite of FP features though?<p>If you try to write mostly pure code in Java I’m afraid you’re in for a bad time, despite the (big!) improvements of records and lambdas.<p>Minimum viable FP starts at OCaml, F#, Scala and Closure, yet none of these are mainstream.</div><br/><div id="39723194" class="c"><input type="checkbox" id="c-39723194" checked=""/><div class="controls bullet"><span class="by">anon291</span><span>|</span><a href="#39718392">root</a><span>|</span><a href="#39719272">parent</a><span>|</span><a href="#39719697">next</a><span>|</span><label class="collapse" for="c-39723194">[-]</label><label class="expand" for="c-39723194">[2 more]</label></div><br/><div class="children"><div class="content">Hold on... Purity and functional programming are different things. Functional programs can be pure but not necessarily.<p>Functional programming means functions are first class citizens and can be constructed on the fly. Modern python, c++, rust, even java now do this.<p>Purity is a nice to have (and arguably rusts borrow system enforces a kind of purity).</div><br/><div id="39724184" class="c"><input type="checkbox" id="c-39724184" checked=""/><div class="controls bullet"><span class="by">ildjarn</span><span>|</span><a href="#39718392">root</a><span>|</span><a href="#39723194">parent</a><span>|</span><a href="#39719697">next</a><span>|</span><label class="collapse" for="c-39724184">[-]</label><label class="expand" for="c-39724184">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Functional programming means functions are first class citizens and can be constructed on the fly.<p>FP is much more than this one language feature.</div><br/></div></div></div></div><div id="39719697" class="c"><input type="checkbox" id="c-39719697" checked=""/><div class="controls bullet"><span class="by">AS37</span><span>|</span><a href="#39718392">root</a><span>|</span><a href="#39719272">parent</a><span>|</span><a href="#39723194">prev</a><span>|</span><a href="#39723739">next</a><span>|</span><label class="collapse" for="c-39719697">[-]</label><label class="expand" for="c-39719697">[3 more]</label></div><br/><div class="children"><div class="content">I code in C# and use a ton of LINQ when writing business logic. It&#x27;s FP-ish enough to avoid logic mistakes. The mediator design pattern, which is kind of bringing another FP paradigm to the OO world, also features heavily.</div><br/><div id="39719942" class="c"><input type="checkbox" id="c-39719942" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#39718392">root</a><span>|</span><a href="#39719697">parent</a><span>|</span><a href="#39720568">next</a><span>|</span><label class="collapse" for="c-39719942">[-]</label><label class="expand" for="c-39719942">[1 more]</label></div><br/><div class="children"><div class="content">I think this is the point really, not that mainstream, &quot;general purpose&quot; languages support FP well, but that FP ideas and aspects have been adapted into many of them.</div><br/></div></div><div id="39720568" class="c"><input type="checkbox" id="c-39720568" checked=""/><div class="controls bullet"><span class="by">ildjarn</span><span>|</span><a href="#39718392">root</a><span>|</span><a href="#39719697">parent</a><span>|</span><a href="#39719942">prev</a><span>|</span><a href="#39723739">next</a><span>|</span><label class="collapse" for="c-39720568">[-]</label><label class="expand" for="c-39720568">[1 more]</label></div><br/><div class="children"><div class="content">C# LINQ, being a round-about implementation of do-notation, is a pretty advanced FP feature, and beyond most mainstream languages. C# is certainly a step up over Java etc.<p>However, most developers wouldn’t understand, say, a result monad implemented via LINQ, so you’re still fighting the ecosystem somewhat.</div><br/></div></div></div></div><div id="39723739" class="c"><input type="checkbox" id="c-39723739" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#39718392">root</a><span>|</span><a href="#39719272">parent</a><span>|</span><a href="#39719697">prev</a><span>|</span><a href="#39719514">next</a><span>|</span><label class="collapse" for="c-39723739">[-]</label><label class="expand" for="c-39723739">[1 more]</label></div><br/><div class="children"><div class="content">Java streams.<p>java.time<p>Valhalla even</div><br/></div></div></div></div><div id="39719514" class="c"><input type="checkbox" id="c-39719514" checked=""/><div class="controls bullet"><span class="by">macintux</span><span>|</span><a href="#39718392">parent</a><span>|</span><a href="#39719272">prev</a><span>|</span><a href="#39718160">next</a><span>|</span><label class="collapse" for="c-39719514">[-]</label><label class="expand" for="c-39719514">[7 more]</label></div><br/><div class="children"><div class="content">Hybrid languages are sub-optimal in a lot of ways. One of the joys of functional programming are the guarantees that imperative languages can&#x27;t offer (primarily immutability).</div><br/><div id="39719907" class="c"><input type="checkbox" id="c-39719907" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#39718392">root</a><span>|</span><a href="#39719514">parent</a><span>|</span><a href="#39723472">next</a><span>|</span><label class="collapse" for="c-39719907">[-]</label><label class="expand" for="c-39719907">[4 more]</label></div><br/><div class="children"><div class="content">The moment you have any database or filesystem or remote-service, the hybridization starts anyway.<p>Sure, technically a single computer&#x27;s local RAM is being managed with strict guidelines, but that correlates less and less to overall application state and behavior these days.</div><br/><div id="39720183" class="c"><input type="checkbox" id="c-39720183" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#39718392">root</a><span>|</span><a href="#39719907">parent</a><span>|</span><a href="#39722845">next</a><span>|</span><label class="collapse" for="c-39720183">[-]</label><label class="expand" for="c-39720183">[2 more]</label></div><br/><div class="children"><div class="content">The promise of FRP was to solve this problem. It makes &quot;state change&quot; a first class object, and organizes your code around it.<p>The problem is that nobody made an usable FRP system yet. It&#x27;s not obvious why it&#x27;s so hard, and everything feels like it should be easy. But everybody just keep failing.</div><br/></div></div><div id="39722845" class="c"><input type="checkbox" id="c-39722845" checked=""/><div class="controls bullet"><span class="by">macintux</span><span>|</span><a href="#39718392">root</a><span>|</span><a href="#39719907">parent</a><span>|</span><a href="#39720183">prev</a><span>|</span><a href="#39723472">next</a><span>|</span><label class="collapse" for="c-39722845">[-]</label><label class="expand" for="c-39722845">[1 more]</label></div><br/><div class="children"><div class="content">True, but you can isolate side effects.<p>Knowing that a small collection of functions is not referentially transparent is better than having to deal with any part of the program potentially changing your state.</div><br/></div></div></div></div><div id="39723472" class="c"><input type="checkbox" id="c-39723472" checked=""/><div class="controls bullet"><span class="by">dehrmann</span><span>|</span><a href="#39718392">root</a><span>|</span><a href="#39719514">parent</a><span>|</span><a href="#39719907">prev</a><span>|</span><a href="#39719818">next</a><span>|</span><label class="collapse" for="c-39723472">[-]</label><label class="expand" for="c-39723472">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Hybrid languages are sub-optimal in a lot of ways.<p>The real world is messy and stateful.</div><br/></div></div><div id="39719818" class="c"><input type="checkbox" id="c-39719818" checked=""/><div class="controls bullet"><span class="by">jprival</span><span>|</span><a href="#39718392">root</a><span>|</span><a href="#39719514">parent</a><span>|</span><a href="#39723472">prev</a><span>|</span><a href="#39718160">next</a><span>|</span><label class="collapse" for="c-39719818">[-]</label><label class="expand" for="c-39719818">[1 more]</label></div><br/><div class="children"><div class="content">“Functional style” doesn’t offer the same guarantees, sure, but I wouldn’t underestimate the structural and readability benefits it can offer for certain kinds of tasks.</div><br/></div></div></div></div></div></div><div id="39718160" class="c"><input type="checkbox" id="c-39718160" checked=""/><div class="controls bullet"><span class="by">ipython</span><span>|</span><a href="#39718392">prev</a><span>|</span><a href="#39719908">next</a><span>|</span><label class="collapse" for="c-39718160">[-]</label><label class="expand" for="c-39718160">[11 more]</label></div><br/><div class="children"><div class="content">Fascinating about how ARM has made tremendous strides in the “high end” market since 2015. I would argue that I would categorize RISC as a “yes” with its absolute dominance on mobile and now moving into data center not to mention all the embedded use cases.</div><br/><div id="39718435" class="c"><input type="checkbox" id="c-39718435" checked=""/><div class="controls bullet"><span class="by">t43562</span><span>|</span><a href="#39718160">parent</a><span>|</span><a href="#39719413">next</a><span>|</span><label class="collapse" for="c-39718435">[-]</label><label class="expand" for="c-39718435">[4 more]</label></div><br/><div class="children"><div class="content">I think the battle between RISC and CISC is overshadowed by the battle between non-x86 and x86.  On average are new designs more RISC than CISC? I don&#x27;t know but that&#x27;s different from numbers of chips of a certain type sold.<p>RISC showed what you could do with a clean sheet and the battle has really been about whether we can afford the cost of changing to a new instruction set just because it&#x27;s better by a bit.</div><br/><div id="39718847" class="c"><input type="checkbox" id="c-39718847" checked=""/><div class="controls bullet"><span class="by">zer00eyz</span><span>|</span><a href="#39718160">root</a><span>|</span><a href="#39718435">parent</a><span>|</span><a href="#39719413">next</a><span>|</span><label class="collapse" for="c-39718847">[-]</label><label class="expand" for="c-39718847">[3 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; by the battle between non-x86 and x86.<p>68000 -&gt; PowerPC -&gt; x86 -&gt; arm<p>Apple has been through 4 architectures in 30 years. Given enough money and tyranny (as in &quot;were doing this&quot; kind of leadership, vs committee) its apparently not that terrible.</div><br/><div id="39721711" class="c"><input type="checkbox" id="c-39721711" checked=""/><div class="controls bullet"><span class="by">peterfirefly</span><span>|</span><a href="#39718160">root</a><span>|</span><a href="#39718847">parent</a><span>|</span><a href="#39721623">next</a><span>|</span><label class="collapse" for="c-39721711">[-]</label><label class="expand" for="c-39721711">[1 more]</label></div><br/><div class="children"><div class="content">Add the transition to &quot;32-bit clean&quot; on 68K (and some trouble with caches) + 32-to-64-bit transitions on PPC and x86.</div><br/></div></div><div id="39721623" class="c"><input type="checkbox" id="c-39721623" checked=""/><div class="controls bullet"><span class="by">simne</span><span>|</span><a href="#39718160">root</a><span>|</span><a href="#39718847">parent</a><span>|</span><a href="#39721711">prev</a><span>|</span><a href="#39719413">next</a><span>|</span><label class="collapse" for="c-39721623">[-]</label><label class="expand" for="c-39721623">[1 more]</label></div><br/><div class="children"><div class="content">And rumors said, they even considered IBM RS-6000, but pushed to make simplified PowerPC, and IBM had not very good times, so agreed.</div><br/></div></div></div></div></div></div><div id="39719413" class="c"><input type="checkbox" id="c-39719413" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#39718160">parent</a><span>|</span><a href="#39718435">prev</a><span>|</span><a href="#39719363">next</a><span>|</span><label class="collapse" for="c-39719413">[-]</label><label class="expand" for="c-39719413">[3 more]</label></div><br/><div class="children"><div class="content">I still have to agree with Dan. &quot;If there&#x27;s any threat to x86, it&#x27;s ARM, and it&#x27;s their business model that&#x27;s a threat, not their ISA.&quot;</div><br/><div id="39720061" class="c"><input type="checkbox" id="c-39720061" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#39718160">root</a><span>|</span><a href="#39719413">parent</a><span>|</span><a href="#39719363">next</a><span>|</span><label class="collapse" for="c-39720061">[-]</label><label class="expand" for="c-39720061">[2 more]</label></div><br/><div class="children"><div class="content">I would have believed this before the M1, but now I think fixed-width instructions are great for parallel decode, so there&#x27;s a real threat now which is attributable to RISC.</div><br/><div id="39720917" class="c"><input type="checkbox" id="c-39720917" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#39718160">root</a><span>|</span><a href="#39720061">parent</a><span>|</span><a href="#39719363">next</a><span>|</span><label class="collapse" for="c-39720917">[-]</label><label class="expand" for="c-39720917">[1 more]</label></div><br/><div class="children"><div class="content">Fixed-width decode only one of the ideas of &quot;RISC,&quot; but not the main one.  I would argue that modern ARM is almost as much of a CISC-y abomination as was x86 in 1999.  ARM has a lot of instructions that do multiple things and are very non-RISC.<p>POWER is probably the most RISC-y architecture in use at the high end right now, but it still looks like CISC to the people who originally came up with that idea.</div><br/></div></div></div></div></div></div><div id="39719363" class="c"><input type="checkbox" id="c-39719363" checked=""/><div class="controls bullet"><span class="by">bdw5204</span><span>|</span><a href="#39718160">parent</a><span>|</span><a href="#39719413">prev</a><span>|</span><a href="#39719908">next</a><span>|</span><label class="collapse" for="c-39719363">[-]</label><label class="expand" for="c-39719363">[3 more]</label></div><br/><div class="children"><div class="content">At the moment, x86 is mainly hanging on in legacy spaces because of backward compatibility. Everything new is RISC including Apple&#x27;s newer Macs. Windows computers still run on x86 because people buy Windows to run legacy code. Playstation and Xbox run on x86 because that makes porting games from Windows more convenient.<p>My view, even when I was studying RISC V in grad school around 6 years ago, was that RISC is clearly superior technically and this would only become more obvious with Moore&#x27;s Law dying. I think subsequent events are only confirming this view. The strongest evidence for it is that nobody would even think about making a new CISC architecture that isn&#x27;t x86.</div><br/><div id="39719741" class="c"><input type="checkbox" id="c-39719741" checked=""/><div class="controls bullet"><span class="by">bluescrn</span><span>|</span><a href="#39718160">root</a><span>|</span><a href="#39719363">parent</a><span>|</span><a href="#39719908">next</a><span>|</span><label class="collapse" for="c-39719741">[-]</label><label class="expand" for="c-39719741">[2 more]</label></div><br/><div class="children"><div class="content">&gt; At the moment, x86 is mainly hanging on in legacy spaces because of backward compatibility.<p>x86 platforms also tend to let you run your own code, and are associated with &#x27;proper computers&#x2F;proper operating systems&#x27; where you have full access to your own device.<p>The vast majority of non-x86 devices are of the &#x27;locked down and dumbed-down&#x27; variety. Content consumption devices built around monopolistic App Stores and touch-centric UIs. They tend to be entirely non-upgradable and, increasingly, actively repair-resistant, too.<p>The market for a &#x27;real computer&#x27; may be shrinking, but it&#x27;s premature to call them &#x27;legacy devices&#x27;.<p>(It&#x27;d be nice if serious ARM-based PCs became more of an option though, not just little devices like the Pi, or glued-in-battery Apple products, but fully-upgradeable replacements for a high-end x86 workstation or gaming PC)</div><br/><div id="39720255" class="c"><input type="checkbox" id="c-39720255" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#39718160">root</a><span>|</span><a href="#39719741">parent</a><span>|</span><a href="#39719908">next</a><span>|</span><label class="collapse" for="c-39720255">[-]</label><label class="expand" for="c-39720255">[1 more]</label></div><br/><div class="children"><div class="content">&gt; not just little devices like the Pi<p>What you are dismissing is by-the-book disruptive competition.</div><br/></div></div></div></div></div></div></div></div><div id="39719908" class="c"><input type="checkbox" id="c-39719908" checked=""/><div class="controls bullet"><span class="by">oconnor663</span><span>|</span><a href="#39718160">prev</a><span>|</span><a href="#39718196">next</a><span>|</span><label class="collapse" for="c-39719908">[-]</label><label class="expand" for="c-39719908">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Lampson further remarks that to do parallel programming, what you need to do is put all your parallelism into a little box and then have a wizard go write the code in that box. Not much has changed since 2009.<p>I would like to see a reevaluation of this take with respect to Rust. When we&#x27;re talking about Rust&#x27;s safety features, we usually focus on memory safety, because that has the biggest impact on security. But there are lots of memory safe languages, and I think it&#x27;s actually Rust&#x27;s thread safety features that are the most unique. (Lots of shared type system machinery between both sets of features.)</div><br/></div></div><div id="39718196" class="c"><input type="checkbox" id="c-39718196" checked=""/><div class="controls bullet"><span class="by">sampo</span><span>|</span><a href="#39719908">prev</a><span>|</span><a href="#39719098">next</a><span>|</span><label class="collapse" for="c-39718196">[-]</label><label class="expand" for="c-39718196">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Fancy type systems<p>We are taking steps to this direction. By adding optional typing to dynamic languages Python and JavaScript&#x2F;TypeScript. And then type checker tools and local programming style guides are making using these maybe less optional, and more mandatory.</div><br/><div id="39718358" class="c"><input type="checkbox" id="c-39718358" checked=""/><div class="controls bullet"><span class="by">t43562</span><span>|</span><a href="#39718196">parent</a><span>|</span><a href="#39720070">next</a><span>|</span><label class="collapse" for="c-39718358">[-]</label><label class="expand" for="c-39718358">[4 more]</label></div><br/><div class="children"><div class="content">IMO the day python types become mandatory there will be a fork.<p>It would be such a total betrayal of it&#x27;s reason for existing that we would have to invent another untyped or duck-typed language again.</div><br/><div id="39719250" class="c"><input type="checkbox" id="c-39719250" checked=""/><div class="controls bullet"><span class="by">kfajdsl</span><span>|</span><a href="#39718196">root</a><span>|</span><a href="#39718358">parent</a><span>|</span><a href="#39718504">next</a><span>|</span><label class="collapse" for="c-39719250">[-]</label><label class="expand" for="c-39719250">[1 more]</label></div><br/><div class="children"><div class="content">For me the primary purpose of TypeScript is to give my editor information about interfaces so I don’t have to do the menial back and forth of accidentally making a typo in a function name, object param, etc.<p>I find myself using less type hints in Python because the story for REPL driven development is so much better than JavaScript, and that takes most of the pain away.</div><br/></div></div><div id="39718504" class="c"><input type="checkbox" id="c-39718504" checked=""/><div class="controls bullet"><span class="by">sampo</span><span>|</span><a href="#39718196">root</a><span>|</span><a href="#39718358">parent</a><span>|</span><a href="#39719250">prev</a><span>|</span><a href="#39718636">next</a><span>|</span><label class="collapse" for="c-39718504">[-]</label><label class="expand" for="c-39718504">[1 more]</label></div><br/><div class="children"><div class="content">I mean, your company or your project may require you to write type hints and use a type checker tool. Not that Python the language makes typing mandatory.</div><br/></div></div><div id="39718636" class="c"><input type="checkbox" id="c-39718636" checked=""/><div class="controls bullet"><span class="by">chasd00</span><span>|</span><a href="#39718196">root</a><span>|</span><a href="#39718358">parent</a><span>|</span><a href="#39718504">prev</a><span>|</span><a href="#39720070">next</a><span>|</span><label class="collapse" for="c-39718636">[-]</label><label class="expand" for="c-39718636">[1 more]</label></div><br/><div class="children"><div class="content">nagware like Typescript have turned type bolt-ons into a religion almost. It has its place but really gets in the way in others. Hence, the reason untyped languages exist in the first place.</div><br/></div></div></div></div><div id="39720070" class="c"><input type="checkbox" id="c-39720070" checked=""/><div class="controls bullet"><span class="by">slaymaker1907</span><span>|</span><a href="#39718196">parent</a><span>|</span><a href="#39718358">prev</a><span>|</span><a href="#39720177">next</a><span>|</span><label class="collapse" for="c-39720070">[-]</label><label class="expand" for="c-39720070">[2 more]</label></div><br/><div class="children"><div class="content">Sum types have definitely been making a big splash. I&#x27;d also look at how C++ has added concepts and Go has added generics. Local type inference is also commonplace too, even Java has it.</div><br/><div id="39721785" class="c"><input type="checkbox" id="c-39721785" checked=""/><div class="controls bullet"><span class="by">peterfirefly</span><span>|</span><a href="#39718196">root</a><span>|</span><a href="#39720070">parent</a><span>|</span><a href="#39720177">next</a><span>|</span><label class="collapse" for="c-39721785">[-]</label><label class="expand" for="c-39721785">[1 more]</label></div><br/><div class="children"><div class="content">Even C23 has it.</div><br/></div></div></div></div><div id="39720177" class="c"><input type="checkbox" id="c-39720177" checked=""/><div class="controls bullet"><span class="by">acchow</span><span>|</span><a href="#39718196">parent</a><span>|</span><a href="#39720070">prev</a><span>|</span><a href="#39719098">next</a><span>|</span><label class="collapse" for="c-39720177">[-]</label><label class="expand" for="c-39720177">[2 more]</label></div><br/><div class="children"><div class="content">Those would be considered basic type systems. For &quot;fancy&quot;, you gotta dive deeper into the lambda cube (tho generics I guess in 1999 would be fancy and one step in).</div><br/><div id="39723112" class="c"><input type="checkbox" id="c-39723112" checked=""/><div class="controls bullet"><span class="by">Ar-Curunir</span><span>|</span><a href="#39718196">root</a><span>|</span><a href="#39720177">parent</a><span>|</span><a href="#39719098">next</a><span>|</span><label class="collapse" for="c-39723112">[-]</label><label class="expand" for="c-39723112">[1 more]</label></div><br/><div class="children"><div class="content">The borrow-checker is pretty fancy.</div><br/></div></div></div></div></div></div><div id="39719098" class="c"><input type="checkbox" id="c-39719098" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#39718196">prev</a><span>|</span><a href="#39718452">next</a><span>|</span><label class="collapse" for="c-39719098">[-]</label><label class="expand" for="c-39719098">[1 more]</label></div><br/><div class="children"><div class="content">Good &#x27;jcranmer on the RISC-CISC thing:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39481940">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39481940</a></div><br/></div></div><div id="39718452" class="c"><input type="checkbox" id="c-39718452" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#39719098">prev</a><span>|</span><a href="#39719106">next</a><span>|</span><label class="collapse" for="c-39718452">[-]</label><label class="expand" for="c-39718452">[2 more]</label></div><br/><div class="children"><div class="content">I guess from some sense, all web apps and all GUI apps using the GPU are using parallelism.  That&#x27;s almost everything.  Those are both leveraging shared-nothing type architectures so you can think in a single thread and apply it to concurrent work loads for parallelism.<p>Does that not count?  What would satisfy this category?</div><br/><div id="39723499" class="c"><input type="checkbox" id="c-39723499" checked=""/><div class="controls bullet"><span class="by">dehrmann</span><span>|</span><a href="#39718452">parent</a><span>|</span><a href="#39719106">next</a><span>|</span><label class="collapse" for="c-39723499">[-]</label><label class="expand" for="c-39723499">[1 more]</label></div><br/><div class="children"><div class="content">I think the dream of parallelism in 1999 was that CPUs aren&#x27;t going to get much faster in terms of clock cycles, so how will algorithms run on more data. This is a bit dumbed-down, but things like sorting in parallel.<p>It turns out that local data didn&#x27;t quite scale like that, we got more ram and SSDs, and that coordination usually makes small-scale parallel algorithms prohibitively expensive. Where parallelism does work today is some flavor of SIMD like vector instructions, parallel matrix multiplication on a GPU, or map-reduce.</div><br/></div></div></div></div><div id="39719106" class="c"><input type="checkbox" id="c-39719106" checked=""/><div class="controls bullet"><span class="by">keybored</span><span>|</span><a href="#39718452">prev</a><span>|</span><a href="#39722830">next</a><span>|</span><label class="collapse" for="c-39719106">[-]</label><label class="expand" for="c-39719106">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    Yes                      Maybe
    Firefox Reader Mode      CSS</code></pre></div><br/><div id="39719708" class="c"><input type="checkbox" id="c-39719708" checked=""/><div class="controls bullet"><span class="by">MattGrommes</span><span>|</span><a href="#39719106">parent</a><span>|</span><a href="#39722830">next</a><span>|</span><label class="collapse" for="c-39719708">[-]</label><label class="expand" for="c-39719708">[1 more]</label></div><br/><div class="children"><div class="content">Also, Reading Mode in the sidebar of Chrome.<p>The days of square monitors and wall-to-wall text have been over for a while.</div><br/></div></div></div></div><div id="39722830" class="c"><input type="checkbox" id="c-39722830" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39719106">prev</a><span>|</span><a href="#39721395">next</a><span>|</span><label class="collapse" for="c-39722830">[-]</label><label class="expand" for="c-39722830">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>What&#x27;s worked in Computer Science (2015)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15796515">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15796515</a> - Nov 2017 (62 comments)<p><i>What&#x27;s Worked in Computer Science</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10623600">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10623600</a> - Nov 2015 (63 comments)</div><br/></div></div><div id="39721395" class="c"><input type="checkbox" id="c-39721395" checked=""/><div class="controls bullet"><span class="by">simne</span><span>|</span><a href="#39722830">prev</a><span>|</span><a href="#39718041">next</a><span>|</span><label class="collapse" for="c-39721395">[-]</label><label class="expand" for="c-39721395">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That Intel ceded the low end of the market might seem ironic considering Intel&#x27;s origins, but they&#x27;ve always been aggressive about moving upmarket<p>Will see. Intel after 2023 is not like before 2023, when it lost its dominance to AMD and partially to Nvidia and ARM (Apple-M2).<p>Now lowest end CPUs become RISC-V and ARM pushing to become one of leaders.<p>x86 is strong, but who knows, how long it could dominate under pressure.<p>And if we count not desktops but all personal devices, ARM is already won (on just smartphones, now more ARM CPUs than people on Earth, and Data Centers share of ARM CPUs growing).<p>Only one final thing I could copypaste from &quot;X-files&quot; - &quot;truth is out of there&quot;.</div><br/><div id="39722756" class="c"><input type="checkbox" id="c-39722756" checked=""/><div class="controls bullet"><span class="by">simne</span><span>|</span><a href="#39721395">parent</a><span>|</span><a href="#39718041">next</a><span>|</span><label class="collapse" for="c-39722756">[-]</label><label class="expand" for="c-39722756">[1 more]</label></div><br/><div class="children"><div class="content">After digest information about IBM 360, I decided, we lost CISCs. One of most important feature of 360 was customizable microcode, which you could load on system boot and got effectively different hardware (like with FPGA emulators of Amiga&#x27;s). It was widely used to emulate old hardware, like IBM 1401 or IBM 7xxx series. But I have not seen this feature in 390 documentation, so looks like their 360 emulation become just software (and with achievements of semiconductors in 1990s it looks like adequate, to switch to software emulation).<p>This was not only feature of 360th, for example Xerox Alto, also have documented feature to alter microcode when need (as I hear, they have special framework to work with it, just like we now work with Assembler when need), and I hear rumors that something similar was shipped with DEC mini-computers, but for micro-computers, this feature practically disappeared.<p>Even when we have &quot;microcode update&quot; feature in many modern CPUs, but it is usually undocumented feature, to which nobody have access outside CPU manufacturers (only could upload encrypted binary, supplied by manufacturer to fix bugs). As I said, in 360th, this was documented standard feature, you could use if need.<p>I must admit, ARM marketed feature of customized microcode, to add new instructions (they have standardized place in instruction set, named &quot;custom coprocessor instructions&quot;, so if you have enough money, you could make special ARM with your additional instructions, you could even order some additions on die), but it is nothing if compare to 360.<p>And I could tell from FPGA cooking, not all things implemented in FPGAs as hardware logic pipelines. When speed accepting, many people using in FPGA practically  microcode engines (very common thing is 1-bit CPU, which is very similar to CISC microcode engine, and programmed in Assembler, very similar to early 8-bits; some people prefer full-featured CPU, like 8048 or even more).</div><br/></div></div></div></div><div id="39718041" class="c"><input type="checkbox" id="c-39718041" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#39721395">prev</a><span>|</span><a href="#39718183">next</a><span>|</span><label class="collapse" for="c-39718041">[-]</label><label class="expand" for="c-39718041">[5 more]</label></div><br/><div class="children"><div class="content">The phone networks and basic infrastructure for the internet in many countries wouldn’t work without Erlang. Which is functional… but maybe that doesn’t count?</div><br/><div id="39718736" class="c"><input type="checkbox" id="c-39718736" checked=""/><div class="controls bullet"><span class="by">caditinpiscinam</span><span>|</span><a href="#39718041">parent</a><span>|</span><a href="#39718183">next</a><span>|</span><label class="collapse" for="c-39718736">[-]</label><label class="expand" for="c-39718736">[4 more]</label></div><br/><div class="children"><div class="content">On the other hand, the banking infrastructure in many countries wouldn&#x27;t work without COBOL, scientific research wouldn&#x27;t work without MATLAB, and healthcare wouldn&#x27;t work without MUMPS. Many languages and paradigms, good and bad, end up entrenched within an industry.</div><br/><div id="39720459" class="c"><input type="checkbox" id="c-39720459" checked=""/><div class="controls bullet"><span class="by">jnxx</span><span>|</span><a href="#39718041">root</a><span>|</span><a href="#39718736">parent</a><span>|</span><a href="#39721679">next</a><span>|</span><label class="collapse" for="c-39720459">[-]</label><label class="expand" for="c-39720459">[2 more]</label></div><br/><div class="children"><div class="content">&gt; COBOL<p>&gt; MATLAB<p>&gt; MUMPS<p>One of each uglier than the one before. But:<p>Is there something we can learn from these examples? Are there good reasons for these languages being adopted? And are the Racket designers with their approach of &quot;a language to define interoperable DSLs&quot; up to something?</div><br/><div id="39721646" class="c"><input type="checkbox" id="c-39721646" checked=""/><div class="controls bullet"><span class="by">caditinpiscinam</span><span>|</span><a href="#39718041">root</a><span>|</span><a href="#39720459">parent</a><span>|</span><a href="#39721679">next</a><span>|</span><label class="collapse" for="c-39721646">[-]</label><label class="expand" for="c-39721646">[1 more]</label></div><br/><div class="children"><div class="content">I think programming languages are more like spoken languages than we give them credit for. Their design is more intentional, but the processes by which they spread, compete, and evolve is similarly difficult to pin down.</div><br/></div></div></div></div><div id="39721679" class="c"><input type="checkbox" id="c-39721679" checked=""/><div class="controls bullet"><span class="by">simne</span><span>|</span><a href="#39718041">root</a><span>|</span><a href="#39718736">parent</a><span>|</span><a href="#39720459">prev</a><span>|</span><a href="#39718183">next</a><span>|</span><label class="collapse" for="c-39721679">[-]</label><label class="expand" for="c-39721679">[1 more]</label></div><br/><div class="children"><div class="content">You forget FORTRAN (was very popular for scientific computing, and nearest neighbor with COBOL in S&#x2F;360 environment) :)))</div><br/></div></div></div></div></div></div><div id="39718127" class="c"><input type="checkbox" id="c-39718127" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#39718183">prev</a><span>|</span><a href="#39718106">next</a><span>|</span><label class="collapse" for="c-39718127">[-]</label><label class="expand" for="c-39718127">[13 more]</label></div><br/><div class="children"><div class="content">Fancy type systems have come a long way since then. (TypeScript, for example.)</div><br/><div id="39718639" class="c"><input type="checkbox" id="c-39718639" checked=""/><div class="controls bullet"><span class="by">pyuser583</span><span>|</span><a href="#39718127">parent</a><span>|</span><a href="#39718106">next</a><span>|</span><label class="collapse" for="c-39718639">[-]</label><label class="expand" for="c-39718639">[12 more]</label></div><br/><div class="children"><div class="content">TS really stands out as amazing. It’s realized a lot of the promise of strong typing.</div><br/><div id="39718944" class="c"><input type="checkbox" id="c-39718944" checked=""/><div class="controls bullet"><span class="by">malcolmgreaves</span><span>|</span><a href="#39718127">root</a><span>|</span><a href="#39718639">parent</a><span>|</span><a href="#39719296">next</a><span>|</span><label class="collapse" for="c-39718944">[-]</label><label class="expand" for="c-39718944">[2 more]</label></div><br/><div class="children"><div class="content">I agree that TypeScript is quite amazing. And that it&#x27;s indeed improved the programs created that run in the browser or on `node`.<p>However, I wanted to point out something that I think often gets overlooked when folks talk about TypeScript. I&#x27;d argue that TS has realized it for the web programming masses, who usually don&#x27;t have any computer science education and thus are unaware of computing fundamentals such as types. TS hasn&#x27;t realized the promise of strong typing only because it has been quite late to the game, so to speak.<p>I do think I understand where you&#x27;re coming from. Web programmers are the largest group of programming-related professionals. Bringing CS wins to this large group absolutely does bring the largest gains and impact to industry.<p>There have been many programming languages created decades before TypeScript that have realized the promise of strong typing. Unfortunately, I think this road took too long. Collectively, people have known about these ideas since John Backus&#x27;s 1977 Turing Award Lecture [1] -- &quot;Can Programming Be Liberated from the von Neumann Style? A Functional Style and Its Algebra of Programs&quot;<p>Anyways, I digress. Hopefully this was insightful! Have a great day :)<p>[1] <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;359576.359579" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;359576.359579</a></div><br/><div id="39721206" class="c"><input type="checkbox" id="c-39721206" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#39718127">root</a><span>|</span><a href="#39718944">parent</a><span>|</span><a href="#39719296">next</a><span>|</span><label class="collapse" for="c-39721206">[-]</label><label class="expand" for="c-39721206">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;hypercubed.github.io&#x2F;joy&#x2F;joy.html" rel="nofollow">https:&#x2F;&#x2F;hypercubed.github.io&#x2F;joy&#x2F;joy.html</a></div><br/></div></div></div></div><div id="39719296" class="c"><input type="checkbox" id="c-39719296" checked=""/><div class="controls bullet"><span class="by">ildjarn</span><span>|</span><a href="#39718127">root</a><span>|</span><a href="#39718639">parent</a><span>|</span><a href="#39718944">prev</a><span>|</span><a href="#39718996">next</a><span>|</span><label class="collapse" for="c-39719296">[-]</label><label class="expand" for="c-39719296">[1 more]</label></div><br/><div class="children"><div class="content">TS has a powerful type system that behaves in strange and counter intuitive ways, particular for people coming from JS. It doesn’t even have a spec, really. I would prefer something less powerful but more predictable, personally.</div><br/></div></div><div id="39718996" class="c"><input type="checkbox" id="c-39718996" checked=""/><div class="controls bullet"><span class="by">cgh</span><span>|</span><a href="#39718127">root</a><span>|</span><a href="#39718639">parent</a><span>|</span><a href="#39719296">prev</a><span>|</span><a href="#39718106">next</a><span>|</span><label class="collapse" for="c-39718996">[-]</label><label class="expand" for="c-39718996">[8 more]</label></div><br/><div class="children"><div class="content">How so? It looks a lot like a less-rich Java, whose type system has existed for literally decades. In fact, the generics syntax and type erasure was directly influenced by Java.</div><br/><div id="39721815" class="c"><input type="checkbox" id="c-39721815" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#39718127">root</a><span>|</span><a href="#39718996">parent</a><span>|</span><a href="#39719310">next</a><span>|</span><label class="collapse" for="c-39721815">[-]</label><label class="expand" for="c-39721815">[1 more]</label></div><br/><div class="children"><div class="content">I haven’t used Java in many years, but TypeScript’s structural types give it a different flavor than I remember from Java. Unlike in Java, most of the types I define aren’t classes or interfaces. It’s just data that has an expected shape.<p>Check out the design of Zod, for example. I have a bunch of Zod types for the validation of incoming JSON messages. This automatically generates the corresponding TypeScript types through the magic of type inference.<p>It’s quite easy to create discriminated unions, which are just structs where one field has a fixed value.</div><br/></div></div><div id="39719310" class="c"><input type="checkbox" id="c-39719310" checked=""/><div class="controls bullet"><span class="by">ildjarn</span><span>|</span><a href="#39718127">root</a><span>|</span><a href="#39718996">parent</a><span>|</span><a href="#39721815">prev</a><span>|</span><a href="#39720334">next</a><span>|</span><label class="collapse" for="c-39719310">[-]</label><label class="expand" for="c-39719310">[3 more]</label></div><br/><div class="children"><div class="content">Typescript has far more powerful type constructs than Java.</div><br/><div id="39720424" class="c"><input type="checkbox" id="c-39720424" checked=""/><div class="controls bullet"><span class="by">za3faran</span><span>|</span><a href="#39718127">root</a><span>|</span><a href="#39719310">parent</a><span>|</span><a href="#39720334">next</a><span>|</span><label class="collapse" for="c-39720424">[-]</label><label class="expand" for="c-39720424">[2 more]</label></div><br/><div class="children"><div class="content">Such as?</div><br/><div id="39720550" class="c"><input type="checkbox" id="c-39720550" checked=""/><div class="controls bullet"><span class="by">ildjarn</span><span>|</span><a href="#39718127">root</a><span>|</span><a href="#39720424">parent</a><span>|</span><a href="#39720334">next</a><span>|</span><label class="collapse" for="c-39720550">[-]</label><label class="expand" for="c-39720550">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;codemix&#x2F;ts-sql">https:&#x2F;&#x2F;github.com&#x2F;codemix&#x2F;ts-sql</a></div><br/></div></div></div></div></div></div><div id="39720334" class="c"><input type="checkbox" id="c-39720334" checked=""/><div class="controls bullet"><span class="by">acchow</span><span>|</span><a href="#39718127">root</a><span>|</span><a href="#39718996">parent</a><span>|</span><a href="#39719310">prev</a><span>|</span><a href="#39719197">next</a><span>|</span><label class="collapse" for="c-39720334">[-]</label><label class="expand" for="c-39720334">[1 more]</label></div><br/><div class="children"><div class="content">Tho Typescript does have structural types, mapped types, union types, optional types, type aliases..... Bunch of useful type features.</div><br/></div></div><div id="39719197" class="c"><input type="checkbox" id="c-39719197" checked=""/><div class="controls bullet"><span class="by">coev</span><span>|</span><a href="#39718127">root</a><span>|</span><a href="#39718996">parent</a><span>|</span><a href="#39720334">prev</a><span>|</span><a href="#39719338">next</a><span>|</span><label class="collapse" for="c-39719197">[-]</label><label class="expand" for="c-39719197">[1 more]</label></div><br/><div class="children"><div class="content">More like indirectly influenced by Java by way of C# (Anders Hejlsberg designed both C# and TS)</div><br/></div></div><div id="39719338" class="c"><input type="checkbox" id="c-39719338" checked=""/><div class="controls bullet"><span class="by">pionar</span><span>|</span><a href="#39718127">root</a><span>|</span><a href="#39718996">parent</a><span>|</span><a href="#39719197">prev</a><span>|</span><a href="#39718106">next</a><span>|</span><label class="collapse" for="c-39719338">[-]</label><label class="expand" for="c-39719338">[1 more]</label></div><br/><div class="children"><div class="content">I disagree. The language was probably more inspired by C#, which is itself inspired by Java. Type erasure is just part of transpiling to JS.</div><br/></div></div></div></div></div></div></div></div><div id="39718106" class="c"><input type="checkbox" id="c-39718106" checked=""/><div class="controls bullet"><span class="by">blt</span><span>|</span><a href="#39718127">prev</a><span>|</span><a href="#39718334">next</a><span>|</span><label class="collapse" for="c-39718106">[-]</label><label class="expand" for="c-39718106">[3 more]</label></div><br/><div class="children"><div class="content">The link to &quot;Microsoft&#x27;s driver verification tool&quot;, which &quot;has probably had more impact than all formal chip design tools combined&quot;, is broken. Does anyone know which tool this meant?</div><br/><div id="39718207" class="c"><input type="checkbox" id="c-39718207" checked=""/><div class="controls bullet"><span class="by">eimrine</span><span>|</span><a href="#39718106">parent</a><span>|</span><a href="#39718173">next</a><span>|</span><label class="collapse" for="c-39718207">[-]</label><label class="expand" for="c-39718207">[1 more]</label></div><br/><div class="children"><div class="content">The document is still searchable: <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;wp-content&#x2F;uploads&#x2F;2016&#x2F;02&#x2F;tr-2004-08.pdf" rel="nofollow">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;wp-content&#x2F;uploads&#x2F;...</a></div><br/></div></div><div id="39718173" class="c"><input type="checkbox" id="c-39718173" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#39718106">parent</a><span>|</span><a href="#39718207">prev</a><span>|</span><a href="#39718334">next</a><span>|</span><label class="collapse" for="c-39718173">[-]</label><label class="expand" for="c-39718173">[1 more]</label></div><br/><div class="children"><div class="content">That link is archived here:<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20160416132849&#x2F;http:&#x2F;&#x2F;research.microsoft.com&#x2F;pubs&#x2F;70038&#x2F;tr-2004-08.pdf" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20160416132849&#x2F;http:&#x2F;&#x2F;research.m...</a></div><br/></div></div></div></div><div id="39718334" class="c"><input type="checkbox" id="c-39718334" checked=""/><div class="controls bullet"><span class="by">hosh</span><span>|</span><a href="#39718106">prev</a><span>|</span><a href="#39718666">next</a><span>|</span><label class="collapse" for="c-39718334">[-]</label><label class="expand" for="c-39718334">[5 more]</label></div><br/><div class="children"><div class="content">Do GPUs and TPUs for AI count towards parallelism?</div><br/><div id="39719445" class="c"><input type="checkbox" id="c-39719445" checked=""/><div class="controls bullet"><span class="by">sophacles</span><span>|</span><a href="#39718334">parent</a><span>|</span><a href="#39718527">prev</a><span>|</span><a href="#39718666">next</a><span>|</span><label class="collapse" for="c-39719445">[-]</label><label class="expand" for="c-39719445">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think so, they still tend to fall into the &quot;Lampson further remarks that to do parallel programming, what you need to do is put all your parallelism into a little box and then have a wizard go write the code in that box.&quot; statment, for the most part.</div><br/><div id="39720497" class="c"><input type="checkbox" id="c-39720497" checked=""/><div class="controls bullet"><span class="by">jnxx</span><span>|</span><a href="#39718334">root</a><span>|</span><a href="#39719445">parent</a><span>|</span><a href="#39721990">prev</a><span>|</span><a href="#39718666">next</a><span>|</span><label class="collapse" for="c-39720497">[-]</label><label class="expand" for="c-39720497">[1 more]</label></div><br/><div class="children"><div class="content">What could be a different case is Clojure. But I am not sure, and the performance characteristics of Clojure make it well-suited for server-style concurrency, but not so much for high-performance parallelism.</div><br/></div></div></div></div></div></div><div id="39718666" class="c"><input type="checkbox" id="c-39718666" checked=""/><div class="controls bullet"><span class="by">Legend2440</span><span>|</span><a href="#39718334">prev</a><span>|</span><a href="#39718218">next</a><span>|</span><label class="collapse" for="c-39718666">[-]</label><label class="expand" for="c-39718666">[3 more]</label></div><br/><div class="children"><div class="content">Neural networks:<p>1999 - No<p>2015 - Not really<p>2024 - Yes?</div><br/><div id="39719397" class="c"><input type="checkbox" id="c-39719397" checked=""/><div class="controls bullet"><span class="by">Calavar</span><span>|</span><a href="#39718666">parent</a><span>|</span><a href="#39718218">next</a><span>|</span><label class="collapse" for="c-39719397">[-]</label><label class="expand" for="c-39719397">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say 2005 to 2010 is probably more probably more appropriate for not really. By 2015, neural networks were already a really hot research topic. Just off the top of my head, the seq2seq paper was published in 2014 and U-Net and ResNet were published in 2015.</div><br/><div id="39719674" class="c"><input type="checkbox" id="c-39719674" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#39718666">root</a><span>|</span><a href="#39719397">parent</a><span>|</span><a href="#39718218">next</a><span>|</span><label class="collapse" for="c-39719674">[-]</label><label class="expand" for="c-39719674">[1 more]</label></div><br/><div class="children"><div class="content">This is eliding most of the history of neural networks as a hot reasearch topics.  Since the late 50&#x27;s early 1960s they&#x27;ve had several resurgences in interest, e.g. 80s RNNs, 90s stuff around several centers.   Hell people were doing interesting things with them commercially in the 90&#x27;s.  The late 90s and early 00&#x27;s had a lot of other interest (kernel methods, SVMs) but NN folks kept plugging, and the hardware to hit the next level was just around the corner.<p>The resurgence you&#x27;re noting are papers with a 10 year tail before them (hell, most of the deep concepts were initiated decades before but lacked both the data sources and efficient hardware to really work them out).<p>This stuff has a long and deeply connected history.</div><br/></div></div></div></div></div></div><div id="39718218" class="c"><input type="checkbox" id="c-39718218" checked=""/><div class="controls bullet"><span class="by">aleign</span><span>|</span><a href="#39718666">prev</a><span>|</span><a href="#39718468">next</a><span>|</span><label class="collapse" for="c-39718218">[-]</label><label class="expand" for="c-39718218">[5 more]</label></div><br/><div class="children"><div class="content">What is &quot;capabilities&quot; supposed to mean?</div><br/><div id="39718246" class="c"><input type="checkbox" id="c-39718246" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#39718218">parent</a><span>|</span><a href="#39720504">next</a><span>|</span><label class="collapse" for="c-39718246">[-]</label><label class="expand" for="c-39718246">[3 more]</label></div><br/><div class="children"><div class="content">Probably Capability based security<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Capability-based_security" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Capability-based_security</a></div><br/><div id="39718349" class="c"><input type="checkbox" id="c-39718349" checked=""/><div class="controls bullet"><span class="by">narrator</span><span>|</span><a href="#39718218">root</a><span>|</span><a href="#39718246">parent</a><span>|</span><a href="#39718284">next</a><span>|</span><label class="collapse" for="c-39718349">[-]</label><label class="expand" for="c-39718349">[1 more]</label></div><br/><div class="children"><div class="content">Funny how in the 90s security was an enterprise feature and now better security and cryptography than we had in the 90s is on every $15 android phone.</div><br/></div></div><div id="39718284" class="c"><input type="checkbox" id="c-39718284" checked=""/><div class="controls bullet"><span class="by">aleign</span><span>|</span><a href="#39718218">root</a><span>|</span><a href="#39718246">parent</a><span>|</span><a href="#39718349">prev</a><span>|</span><a href="#39720504">next</a><span>|</span><label class="collapse" for="c-39718284">[-]</label><label class="expand" for="c-39718284">[1 more]</label></div><br/><div class="children"><div class="content">Thank you :)</div><br/></div></div></div></div><div id="39720504" class="c"><input type="checkbox" id="c-39720504" checked=""/><div class="controls bullet"><span class="by">jnxx</span><span>|</span><a href="#39718218">parent</a><span>|</span><a href="#39718246">prev</a><span>|</span><a href="#39718468">next</a><span>|</span><label class="collapse" for="c-39720504">[-]</label><label class="expand" for="c-39720504">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What is &quot;capabilities&quot; supposed to mean?<p>&quot;Is this app allowed to read your contacts?&quot;</div><br/></div></div></div></div><div id="39718468" class="c"><input type="checkbox" id="c-39718468" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39718218">prev</a><span>|</span><a href="#39718077">next</a><span>|</span><label class="collapse" for="c-39718468">[-]</label><label class="expand" for="c-39718468">[5 more]</label></div><br/><div class="children"><div class="content">Interesting how much has changed since 2015. Apple&#x27;s M chips have made RISC is a clear yes now. Rust has a pretty fancy type system. Not Haskell-fancy but still. Functional programming is pretty much an expected feature now.</div><br/><div id="39718828" class="c"><input type="checkbox" id="c-39718828" checked=""/><div class="controls bullet"><span class="by">aleph_minus_one</span><span>|</span><a href="#39718468">parent</a><span>|</span><a href="#39718077">next</a><span>|</span><label class="collapse" for="c-39718828">[-]</label><label class="expand" for="c-39718828">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Apple&#x27;s M chips have made RISC is a clear yes now.<p>ARM is not a pure RISC architecture (even though its instruction set is somewhat inspired by those ideas behind RISC that stood the test of time).</div><br/><div id="39718916" class="c"><input type="checkbox" id="c-39718916" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39718468">root</a><span>|</span><a href="#39718828">parent</a><span>|</span><a href="#39718077">next</a><span>|</span><label class="collapse" for="c-39718916">[-]</label><label class="expand" for="c-39718916">[3 more]</label></div><br/><div class="children"><div class="content">What counts as &quot;pure RISC&quot;?</div><br/><div id="39721745" class="c"><input type="checkbox" id="c-39721745" checked=""/><div class="controls bullet"><span class="by">simne</span><span>|</span><a href="#39718468">root</a><span>|</span><a href="#39718916">parent</a><span>|</span><a href="#39719370">next</a><span>|</span><label class="collapse" for="c-39721745">[-]</label><label class="expand" for="c-39721745">[1 more]</label></div><br/><div class="children"><div class="content">Good question. Now things are complicated. When all beginning, CISC CPUs was not one chip but board or even cabinet (like IBM S&#x2F;360), and they featured customizable microcode, so you could even load different microcode on different CPUs in system.<p>As I know, very powerful feature of S&#x2F;360 series was to supply custom microcode to make machine compatible with older IBM hardware, like 1401 series or 7xxx series (or to make your own architecture if you wish and if you have enough money).<p>I have not hear about customizable microcode in RISC (to be honest, I hear, it exists in ARM, but it is rare used option, if compare with IBM 360).</div><br/></div></div><div id="39719370" class="c"><input type="checkbox" id="c-39719370" checked=""/><div class="controls bullet"><span class="by">SV_BubbleTime</span><span>|</span><a href="#39718468">root</a><span>|</span><a href="#39718916">parent</a><span>|</span><a href="#39721745">prev</a><span>|</span><a href="#39718077">next</a><span>|</span><label class="collapse" for="c-39719370">[-]</label><label class="expand" for="c-39719370">[1 more]</label></div><br/><div class="children"><div class="content">Ask the Scottish.<p>Elsewhere in the comment section is describe the question isn’t RISC&#x2F;CISC, it’s x86&#x2F;Nonx86. And far more interesting since those lines are still fairly well established.</div><br/></div></div></div></div></div></div></div></div><div id="39718827" class="c"><input type="checkbox" id="c-39718827" checked=""/><div class="controls bullet"><span class="by">Divver</span><span>|</span><a href="#39718077">prev</a><span>|</span><a href="#39718441">next</a><span>|</span><label class="collapse" for="c-39718827">[-]</label><label class="expand" for="c-39718827">[1 more]</label></div><br/><div class="children"><div class="content">I wish this was updated for 2024<p>His RISC being “No” most would agree is somewhat incorrect though it seemed correct back in 2015.<p>But it kinda goes to show how these yes&#x2F;maybe&#x2F;no things can evolve unexpectedly over time and not be to taken as gospel that will stand the test of time.</div><br/></div></div><div id="39718441" class="c"><input type="checkbox" id="c-39718441" checked=""/><div class="controls bullet"><span class="by">sys_64738</span><span>|</span><a href="#39718827">prev</a><span>|</span><label class="collapse" for="c-39718441">[-]</label><label class="expand" for="c-39718441">[2 more]</label></div><br/><div class="children"><div class="content">Formal Methods was for people who didn&#x27;t want to write any code.</div><br/></div></div></div></div></div></div></div></body></html>