<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724662868663" as="style"/><link rel="stylesheet" href="styles.css?v=1724662868663"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.emacswiki.org/emacs/WhyDoesElispSuck">Why Does Elisp Suck</a> <span class="domain">(<a href="https://www.emacswiki.org">www.emacswiki.org</a>)</span></div><div class="subtext"><span>enthdegree</span> | <span>53 comments</span></div><br/><div><div id="41354871" class="c"><input type="checkbox" id="c-41354871" checked=""/><div class="controls bullet"><span class="by">dokyun</span><span>|</span><a href="#41355226">next</a><span>|</span><label class="collapse" for="c-41354871">[-]</label><label class="expand" for="c-41354871">[4 more]</label></div><br/><div class="children"><div class="content">I am going to go out on a limb here and defend Elisp. I think that for what it was designed to be (a complete scripting language for a text editor) it does everything that it needs to do very well, and much more. Much of these arguments do basically boil down to &quot;Emacs Lisp basically isn&#x27;t [some other language]&quot;, or misconceptions about the philosophy of how the system is designed.<p>I have hacked a considerable amount in both Elisp and CL and I can state that I actually prefer the way Elisp does some things over the way Common Lisp does--this is not to say that CL does things the wrong way--the matter is that they have different purposes. Emacs combined with Elisp in itself constitutes a complete programming system; all of its components are designed around it.<p>The language being integrated into Emacs makes writing Elisp programs a very fluid and intuitive experience: things like the fact that the documentation and the place where a function was defined is available at any time makes &#x2F;understanding&#x2F; the system easy, and the actual documentation itself is often quite well written, and the Info manuals will most often explain everything you need to know about a package. Common Lisp+SLIME shares some of this convenience, but not to the extent that Elisp truly does.<p>Certain points like the fact that Emacs isn&#x27;t multithreaded are thrown around by people who don&#x27;t have the intuition that multithreading isn&#x27;t the right thing for a lot of applications. The added complexity that multithreading would add to Emacs would seriously outweigh the usefulness it would provide. Emacs already has a decent process model, and having to deal with only a single shared state makes programs much cleaner.<p>At the very least if it all comes down to a dick measuring contest, the base GNU Emacs provides 100000000x more utility in its packages in a fraction of the memory space than VS code or Vim ever will. Emacs has its fair share of killer apps like Magit that provide such a clean interface to something that it makes using it worth it for that alone.</div><br/><div id="41354935" class="c"><input type="checkbox" id="c-41354935" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#41354871">parent</a><span>|</span><a href="#41355226">next</a><span>|</span><label class="collapse" for="c-41354935">[-]</label><label class="expand" for="c-41354935">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Certain points like the fact that Emacs isn&#x27;t multithreaded are thrown around by people who don&#x27;t have the intuition that multithreading isn&#x27;t the right thing for a lot of applications.<p>GNU Emacs has a lot of applications where it is the right thing. It&#x27;s no longer the simple editor. It comes with more than a million lines of Lisp code implementing all kinds of complex features: like various network client applications, IDEs, ...<p>&gt; Common Lisp+SLIME shares some of this convenience, but not to the extent that Elisp truly does<p>SLIME is mostly implemented in Emacs Lisp. A lot of other Lisp systems can locate all source code and all documentation. It&#x27;s not so much a special feature of Emacs Lisp, but its development environment. It&#x27;s also not necessary that the IDE and Lisp runs in the same process &#x2F; same machine to be able to look up documentation and code. It may be convenient in GNU Emacs, but any such editor can provide such features for programming language implementations.</div><br/><div id="41355041" class="c"><input type="checkbox" id="c-41355041" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#41354871">root</a><span>|</span><a href="#41354935">parent</a><span>|</span><a href="#41355226">next</a><span>|</span><label class="collapse" for="c-41355041">[-]</label><label class="expand" for="c-41355041">[2 more]</label></div><br/><div class="children"><div class="content">&gt; GNU Emacs has a lot of applications where it is the right thing. It&#x27;s no longer the simple editor. It comes with more than a million lines of Lisp code implementing all kinds of complex features: like various network client applications, IDEs, ...<p>Multi-threading has landed in emacs anyway, by the way: <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;emacs&#x2F;manual&#x2F;html_node&#x2F;elisp&#x2F;Threads.html" rel="nofollow">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;emacs&#x2F;manual&#x2F;html_node&#x2F;elisp&#x2F;Th...</a></div><br/><div id="41355066" class="c"><input type="checkbox" id="c-41355066" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#41354871">root</a><span>|</span><a href="#41355041">parent</a><span>|</span><a href="#41355226">next</a><span>|</span><label class="collapse" for="c-41355066">[-]</label><label class="expand" for="c-41355066">[1 more]</label></div><br/><div class="children"><div class="content">see the word &quot;limited&quot; in the documentation. It&#x27;s some kind of &quot;cooperative thread&quot; mechanism...</div><br/></div></div></div></div></div></div></div></div><div id="41354379" class="c"><input type="checkbox" id="c-41354379" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#41355226">prev</a><span>|</span><a href="#41354235">next</a><span>|</span><label class="collapse" for="c-41354379">[-]</label><label class="expand" for="c-41354379">[3 more]</label></div><br/><div class="children"><div class="content">I’m fanatical about having and using the best tools. I take a great deal of pride in it.<p>I take great care with my VSCode extensions and their configuration. I likewise take great care with neovim and having it set up properly.<p>Modern Emacs Lisp is easily the best environment among my daily drivers for interacting with my editor in real time.<p>Of anything modern I only know Zed a little: Zed in theory might be better than Emacs.<p>Outside of maybe Zed, which I haven’t mastered, Emacs Lisp is bar nothing the best tool-making tool for serious hackers.</div><br/><div id="41355173" class="c"><input type="checkbox" id="c-41355173" checked=""/><div class="controls bullet"><span class="by">poulpy123</span><span>|</span><a href="#41354379">parent</a><span>|</span><a href="#41354828">next</a><span>|</span><label class="collapse" for="c-41355173">[-]</label><label class="expand" for="c-41355173">[1 more]</label></div><br/><div class="children"><div class="content">Why is zed better ? (Real question I don&#x27;t know it)</div><br/></div></div><div id="41354828" class="c"><input type="checkbox" id="c-41354828" checked=""/><div class="controls bullet"><span class="by">throwaway48540</span><span>|</span><a href="#41354379">parent</a><span>|</span><a href="#41355173">prev</a><span>|</span><a href="#41354235">next</a><span>|</span><label class="collapse" for="c-41354828">[-]</label><label class="expand" for="c-41354828">[1 more]</label></div><br/><div class="children"><div class="content">Do you have your configuration available somewhere? Would love to see some VSCode inspiration.</div><br/></div></div></div></div><div id="41354235" class="c"><input type="checkbox" id="c-41354235" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#41354379">prev</a><span>|</span><a href="#41353961">next</a><span>|</span><label class="collapse" for="c-41354235">[-]</label><label class="expand" for="c-41354235">[10 more]</label></div><br/><div class="children"><div class="content">This seems to be missing the elephant in the room - <i>elisp</i> doesn&#x27;t suck, it is just a lisp. It is annoying having to learn a specific lisp just to edit Emacs, but whatever. Other lisps are better if you want to add lisp to your application.<p>The <i>Emacs data model</i> sucks. There are APIs that do who-knows-what combined with your personal extensions that modify behaviour who-knows-how, figuring out how to describe UI components is no fun, text editing is surprisingly hard from a programmers perspective, there are decades of accumulated different ways of doing things and it is unclear where to start or what has been obsoleted. The names made sense in the 70s but unfortunately it is 2024 and &quot;Windows&quot; means something different now. I wouldn&#x27;t even exactly blame Emacs for any of this since some of it seems to be essential complexity of the domain.<p><i>EDIT</i> Example, picked completely at random:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;clojure-emacs&#x2F;cider&#x2F;tree&#x2F;master&#x2F;dev">https:&#x2F;&#x2F;github.com&#x2F;clojure-emacs&#x2F;cider&#x2F;tree&#x2F;master&#x2F;dev</a><p><pre><code>    (defun cider-tramp-prefix (&amp;optional buffer)
      &quot;Use the filename for BUFFER to determine a tramp prefix.
    Defaults to the current buffer.  Return the tramp prefix, or nil
    if BUFFER is local.&quot;
      (let* ((buffer (or buffer (current-buffer)))
             (name (or (buffer-file-name buffer)
                       (with-current-buffer buffer
                         default-directory))))
        (when (tramp-tramp-file-p name)
          (with-parsed-tramp-file-name name v
            (with-no-warnings
              (cider-make-tramp-prefix v-method v-user v-host v-port))))))
</code></pre>
Here is a random function from CIDER. The code is simple enough, the lisp is no problem. Immediately we see we&#x27;re interacting from one extension to another, have to understand Emacs buffers, need to know how warnings are displayed, have to understand parsing as a domain, and appear to have a network involved. That is a lot of work to debug one function when something is misbehaving. Not an unreasonable situation, but nonetheless a barrier. Then on top of that I have to go look up what let* is and why it is presumably different from let. One more thing I don&#x27;t want to do. Emacs lisp sucks.<p><i>EDITEDIT</i> Tramp isn&#x27;t an extension, it is part of core emacs. We live and learn.<p><i>EDITEDITEDIT</i> Spoke too quickly, it looks like it is a GNU-supported extension. This is the sort of trivia that got me using Doom Emacs.</div><br/><div id="41354432" class="c"><input type="checkbox" id="c-41354432" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#41354235">parent</a><span>|</span><a href="#41354518">next</a><span>|</span><label class="collapse" for="c-41354432">[-]</label><label class="expand" for="c-41354432">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  Then on top of that I have to go look up what let* is and why it is presumably different from let.<p>I don&#x27;t think this is a problem for elisp; isn&#x27;t `let*` in Common Lisp as well?</div><br/><div id="41354466" class="c"><input type="checkbox" id="c-41354466" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#41354235">root</a><span>|</span><a href="#41354432">parent</a><span>|</span><a href="#41354518">next</a><span>|</span><label class="collapse" for="c-41354466">[-]</label><label class="expand" for="c-41354466">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s in standards for Common Lisp, ISLISP and Scheme.</div><br/></div></div></div></div><div id="41354518" class="c"><input type="checkbox" id="c-41354518" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#41354235">parent</a><span>|</span><a href="#41354432">prev</a><span>|</span><a href="#41354348">next</a><span>|</span><label class="collapse" for="c-41354518">[-]</label><label class="expand" for="c-41354518">[1 more]</label></div><br/><div class="children"><div class="content">Your complaints, while being understandable can be addressed with simply reading of the manual and source code. There are various lips out there and as soon as I know Emacs has its own, I would seek the manual for that.  There are wealth of documentation on emacs and its ecosystem, and it predates a lot of standards. The terminology can be strange, but you can readily find some glossary.</div><br/></div></div><div id="41354348" class="c"><input type="checkbox" id="c-41354348" checked=""/><div class="controls bullet"><span class="by">g15jv2dp</span><span>|</span><a href="#41354235">parent</a><span>|</span><a href="#41354518">prev</a><span>|</span><a href="#41354772">next</a><span>|</span><label class="collapse" for="c-41354348">[-]</label><label class="expand" for="c-41354348">[4 more]</label></div><br/><div class="children"><div class="content">&gt; This seems to be missing the elephant in the room - elisp doesn&#x27;t suck, it is just a lisp.<p>The article lists a few defaults of elisp that aren&#x27;t shared by all lisps. What do you mean by this sentence?</div><br/><div id="41354409" class="c"><input type="checkbox" id="c-41354409" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#41354235">root</a><span>|</span><a href="#41354348">parent</a><span>|</span><a href="#41354772">next</a><span>|</span><label class="collapse" for="c-41354409">[-]</label><label class="expand" for="c-41354409">[3 more]</label></div><br/><div class="children"><div class="content">There isn&#x27;t anything profoundly wrong with Elisp. Emacs needs a programming language, Elisp is a programming language and that is the end of the story, more or less.<p>You can level complaints against Elisp. You can level complaints against anything. They aren&#x27;t a big deal - Elisp supports variables, loops and if statements and that is enough to implement a text editor to a first approximation.<p>If the slate was wiped clean, the Emacs community would probably prefer that Emacs was written with Common Lisp. Then Emacs wouldn&#x27;t need its own lisp reference manual.</div><br/><div id="41354991" class="c"><input type="checkbox" id="c-41354991" checked=""/><div class="controls bullet"><span class="by">guenthert</span><span>|</span><a href="#41354235">root</a><span>|</span><a href="#41354409">parent</a><span>|</span><a href="#41354772">next</a><span>|</span><label class="collapse" for="c-41354991">[-]</label><label class="expand" for="c-41354991">[2 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t speak for the Emacs community, but like to caution that Common Lisp is a large language and IMHO would be too much a burden to learn for someone just to customize or extend the editor.  I&#x27;d rather think it&#x27;s the Common Lisp community who would prefer Emacs to be written using CL ;-)</div><br/><div id="41355100" class="c"><input type="checkbox" id="c-41355100" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#41354235">root</a><span>|</span><a href="#41354991">parent</a><span>|</span><a href="#41354772">next</a><span>|</span><label class="collapse" for="c-41355100">[-]</label><label class="expand" for="c-41355100">[1 more]</label></div><br/><div class="children"><div class="content">Emacs Lisp gets there anyway, somehow. Just decades later.<p>Examples:<p>Lexical binding. SCHEME in 1975, Common Lisp in 1984. GNU Emacs in 2012.<p>Native compiled code. LISP 1 got that in 1960. There are now native compiled code builds of GNU Emacs since a few years.<p>Cooperative threading. Common Lisp had that in the 80s. Other Lisp dialects probably earlier. Now concurrent native threads would be a thing, so that Emacs Lisp too can take advantage of preemptive single and multi-core threading.</div><br/></div></div></div></div></div></div></div></div><div id="41354772" class="c"><input type="checkbox" id="c-41354772" checked=""/><div class="controls bullet"><span class="by">evdubs</span><span>|</span><a href="#41354235">parent</a><span>|</span><a href="#41354348">prev</a><span>|</span><a href="#41354530">next</a><span>|</span><label class="collapse" for="c-41354772">[-]</label><label class="expand" for="c-41354772">[1 more]</label></div><br/><div class="children"><div class="content">Have I reached Lisp enlightenment (TM) if I read that and felt that the code was fine?</div><br/></div></div><div id="41354530" class="c"><input type="checkbox" id="c-41354530" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#41354235">parent</a><span>|</span><a href="#41354772">prev</a><span>|</span><a href="#41353961">next</a><span>|</span><label class="collapse" for="c-41354530">[-]</label><label class="expand" for="c-41354530">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Then on top of that I have to go look up what let* is and why it is presumably different from let. One more thing I don&#x27;t want to do. Emacs lisp sucks.<p>Don&#x27;t modern languages require you to also look up definitions of functions. Learning peculiarities like this in Common Lisp (eg equality) really opened my eyes to how much &quot;magic&quot; there is modern high level languages. Personally I dont like magic and lisps tend to be the most magic free high level languages</div><br/></div></div></div></div><div id="41353961" class="c"><input type="checkbox" id="c-41353961" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#41354235">prev</a><span>|</span><a href="#41355006">next</a><span>|</span><label class="collapse" for="c-41353961">[-]</label><label class="expand" for="c-41353961">[5 more]</label></div><br/><div class="children"><div class="content">This wiki page raises some good points, for example, the stateful nature of some of the APIs:<p><pre><code>  Instead of returning a data structure of the match results (eg from a call to match-string), the match results are mutated in global memory and accessed in separate function calls. This is both less functional in style and more error prone. For example, if save-match-data is not used appropriately, then library functions can trample on the match data which a higher level function is in the middle of using.
</code></pre>
But in some other parts it reads like two or more personalities stuck in the same body shouting at each other using the same mouth:<p><pre><code>  EmacsLisp Isn&#x27;t Scheme

  This, from my highly unscientific sample, is far and away the most popular reason EmacsLisp sucks. Well, that’s good to know. EmacsLisp is also not Perl, or COBOL, or IBM 1130 assembler, or a bicycle, or an orange. Thanks for the help!</code></pre></div><br/><div id="41354250" class="c"><input type="checkbox" id="c-41354250" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#41353961">parent</a><span>|</span><a href="#41355117">next</a><span>|</span><label class="collapse" for="c-41354250">[-]</label><label class="expand" for="c-41354250">[1 more]</label></div><br/><div class="children"><div class="content">Fairly amusing that just today I was looking at some elisp code I wrote a few years ago. A comment I had inserted:<p><pre><code>     ;; Also, I need the ~save-match-data~ because apparently
     ;; ~split-string~ messes up the match information. I spent hours
     ;; debugging this.</code></pre></div><br/></div></div><div id="41355117" class="c"><input type="checkbox" id="c-41355117" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#41353961">parent</a><span>|</span><a href="#41354250">prev</a><span>|</span><a href="#41355049">next</a><span>|</span><label class="collapse" for="c-41355117">[-]</label><label class="expand" for="c-41355117">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me I often wished (and tried~) to make a purely functional regex lib in elisp</div><br/></div></div><div id="41355049" class="c"><input type="checkbox" id="c-41355049" checked=""/><div class="controls bullet"><span class="by">sproutini</span><span>|</span><a href="#41353961">parent</a><span>|</span><a href="#41355117">prev</a><span>|</span><a href="#41353986">next</a><span>|</span><label class="collapse" for="c-41355049">[-]</label><label class="expand" for="c-41355049">[1 more]</label></div><br/><div class="children"><div class="content">The problem with that statement isn&#x27;t that some APIs use state but that the reason those APIs need state wasn&#x27;t documented.</div><br/></div></div><div id="41353986" class="c"><input type="checkbox" id="c-41353986" checked=""/><div class="controls bullet"><span class="by">djaouen</span><span>|</span><a href="#41353961">parent</a><span>|</span><a href="#41355049">prev</a><span>|</span><a href="#41355006">next</a><span>|</span><label class="collapse" for="c-41353986">[-]</label><label class="expand" for="c-41353986">[1 more]</label></div><br/><div class="children"><div class="content">That’s the charm of EmacsWiki.  It really is community-edited!</div><br/></div></div></div></div><div id="41355006" class="c"><input type="checkbox" id="c-41355006" checked=""/><div class="controls bullet"><span class="by">sorry_i_lisp</span><span>|</span><a href="#41353961">prev</a><span>|</span><a href="#41354903">next</a><span>|</span><label class="collapse" for="c-41355006">[-]</label><label class="expand" for="c-41355006">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m actually writing some Emacs Lisp right now, because I want $FEATURE in Emacs. I&#x27;ve been away from Emacs Lisp for awhile in the land of Clojure and I&#x27;m reimporting certain things the way they are done there.<p>Libraries that help with that, even though the major underlying structure isn&#x27;t immutable data structures make Emacs Lisp bearable are: s.el, ht.el, dash.el
It would be great if there was namespacing and less global state pollution.<p>Of course if you want to integrate with the rest of the Emacs ecosystem and you want some libraries that help you out make things nice means learning a whole different ballgame. Like wanting to use the great transient.el. That&#x27;s super stateful and based on eieio.el. (Although transient.el is relatively good about hiding that behind a good API surface.)<p>Overall, even though I wish it was based on a functional core and Clojure&#x27;s immutable data structure, concurrency, namespacing and its great EDN reader, I just accept the pragmatism on the human scale that if I want a great text based interface that interacts with the rest of my text driven workflow Emacs is a good choice and Emacs Lisp is acceptable.</div><br/></div></div><div id="41354903" class="c"><input type="checkbox" id="c-41354903" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#41355006">prev</a><span>|</span><a href="#41354813">next</a><span>|</span><label class="collapse" for="c-41354903">[-]</label><label class="expand" for="c-41354903">[2 more]</label></div><br/><div class="children"><div class="content">With regards to lexical scope, yes elisp has that now, but it didn&#x27;t for so long that a ton of existing code, including the standard library and editor interfaces was written without it, and there is a TON of global state.</div><br/><div id="41354999" class="c"><input type="checkbox" id="c-41354999" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#41354903">parent</a><span>|</span><a href="#41354813">next</a><span>|</span><label class="collapse" for="c-41354999">[-]</label><label class="expand" for="c-41354999">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>and there is a TON of global state.</i><p>And that&#x27;s usually good, because the whole point of Emacs is to make it easy to inspect and manipulate it. It&#x27;s one case where information hiding and encapsulation - including lexical scope - get annoying very quickly.</div><br/></div></div></div></div><div id="41354813" class="c"><input type="checkbox" id="c-41354813" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#41354903">prev</a><span>|</span><a href="#41353672">next</a><span>|</span><label class="collapse" for="c-41354813">[-]</label><label class="expand" for="c-41354813">[2 more]</label></div><br/><div class="children"><div class="content">Feels odd to actually like elisp.  :(<p>There are some surprises.  And I do think common lisp has a lot of better parts.  But, at the end of the day I find elisp fine for a scripting like language.  And I love how accessible every line of elisp in my machine is.</div><br/><div id="41354831" class="c"><input type="checkbox" id="c-41354831" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#41354813">parent</a><span>|</span><a href="#41353672">next</a><span>|</span><label class="collapse" for="c-41354831">[-]</label><label class="expand" for="c-41354831">[1 more]</label></div><br/><div class="children"><div class="content">I also find a lot of the user code well written. Helps to have various IDE support from the Editor and built-in documentation.</div><br/></div></div></div></div><div id="41353672" class="c"><input type="checkbox" id="c-41353672" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#41354813">prev</a><span>|</span><a href="#41353901">next</a><span>|</span><label class="collapse" for="c-41353672">[-]</label><label class="expand" for="c-41353672">[13 more]</label></div><br/><div class="children"><div class="content">I dream of combining wlroots and GNU Guile to make a graphic-first and multi-threaded by default Emacsen that does not aim to be source compatible with Emacs Lisp.</div><br/><div id="41353863" class="c"><input type="checkbox" id="c-41353863" checked=""/><div class="controls bullet"><span class="by">ducktective</span><span>|</span><a href="#41353672">parent</a><span>|</span><a href="#41354257">next</a><span>|</span><label class="collapse" for="c-41353863">[-]</label><label class="expand" for="c-41353863">[5 more]</label></div><br/><div class="children"><div class="content">Why wlroots? Isn&#x27;t it better to target an abstraction api over the various GPU libraries (vulkan, metal etc)?<p>And I would have asked about Guile too but that is another matter.<p>I think LEM&#x27;s approach is better here in utilizing SDL and common lisp. If they write an ELisp interpreter and somehow translate Emacs editor api so plugins would work in LEM too, that would be ideal.</div><br/><div id="41354064" class="c"><input type="checkbox" id="c-41354064" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#41353672">root</a><span>|</span><a href="#41353863">parent</a><span>|</span><a href="#41354257">next</a><span>|</span><label class="collapse" for="c-41354064">[-]</label><label class="expand" for="c-41354064">[4 more]</label></div><br/><div class="children"><div class="content">Guile is the GNU extension language. Seems like the best candidate for an emacs replacement.</div><br/><div id="41354100" class="c"><input type="checkbox" id="c-41354100" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41353672">root</a><span>|</span><a href="#41354064">parent</a><span>|</span><a href="#41354174">next</a><span>|</span><label class="collapse" for="c-41354100">[-]</label><label class="expand" for="c-41354100">[1 more]</label></div><br/><div class="children"><div class="content">There was already a project to port  emacs to run on guile. Guile supports both emacs lisp and scheme for this reason. The project seems to have run out of steam but it was mostly working at one point AFAIK.</div><br/></div></div><div id="41354174" class="c"><input type="checkbox" id="c-41354174" checked=""/><div class="controls bullet"><span class="by">ducktective</span><span>|</span><a href="#41353672">root</a><span>|</span><a href="#41354064">parent</a><span>|</span><a href="#41354100">prev</a><span>|</span><a href="#41354257">next</a><span>|</span><label class="collapse" for="c-41354174">[-]</label><label class="expand" for="c-41354174">[2 more]</label></div><br/><div class="children"><div class="content">Well, an Emacsen that hopes achieving the same degree of popularity as Emacs should be usable in Windows too. Last I checked, Guile had problems in Windows...</div><br/><div id="41354844" class="c"><input type="checkbox" id="c-41354844" checked=""/><div class="controls bullet"><span class="by">rbanffy</span><span>|</span><a href="#41353672">root</a><span>|</span><a href="#41354174">parent</a><span>|</span><a href="#41354257">next</a><span>|</span><label class="collapse" for="c-41354844">[-]</label><label class="expand" for="c-41354844">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn’t consider running directly on Windows a hard requirement. You can run it under WSL[1|2] for instance, or bundle a very minimal WSL distribution that only runs your software.</div><br/></div></div></div></div></div></div></div></div><div id="41354257" class="c"><input type="checkbox" id="c-41354257" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#41353672">parent</a><span>|</span><a href="#41353863">prev</a><span>|</span><a href="#41353832">next</a><span>|</span><label class="collapse" for="c-41354257">[-]</label><label class="expand" for="c-41354257">[1 more]</label></div><br/><div class="children"><div class="content">&gt; that does not aim to be source compatible with Emacs Lisp.<p>But then who would use it?</div><br/></div></div><div id="41353832" class="c"><input type="checkbox" id="c-41353832" checked=""/><div class="controls bullet"><span class="by">djaouen</span><span>|</span><a href="#41353672">parent</a><span>|</span><a href="#41354257">prev</a><span>|</span><a href="#41354066">next</a><span>|</span><label class="collapse" for="c-41353832">[-]</label><label class="expand" for="c-41353832">[3 more]</label></div><br/><div class="children"><div class="content">Many have tried, but few have succeeded at creating an Emacs-replacement.<p>Good luck!</div><br/><div id="41354885" class="c"><input type="checkbox" id="c-41354885" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41353672">root</a><span>|</span><a href="#41353832">parent</a><span>|</span><a href="#41354066">next</a><span>|</span><label class="collapse" for="c-41354885">[-]</label><label class="expand" for="c-41354885">[2 more]</label></div><br/><div class="children"><div class="content">I would say, that with Enrich Gamma at the steering wheel, and Microsoft&#x27;s money, VSCode is succeeding pretty well.</div><br/><div id="41355013" class="c"><input type="checkbox" id="c-41355013" checked=""/><div class="controls bullet"><span class="by">guenthert</span><span>|</span><a href="#41353672">root</a><span>|</span><a href="#41354885">parent</a><span>|</span><a href="#41354066">next</a><span>|</span><label class="collapse" for="c-41355013">[-]</label><label class="expand" for="c-41355013">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d think that VSCode eats into the &#x27;market share&#x27; of Eclipse and the like, but I can&#x27;t see it as replacement for Emacs at all.</div><br/></div></div></div></div></div></div><div id="41354066" class="c"><input type="checkbox" id="c-41354066" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#41353672">parent</a><span>|</span><a href="#41353832">prev</a><span>|</span><a href="#41353901">next</a><span>|</span><label class="collapse" for="c-41354066">[-]</label><label class="expand" for="c-41354066">[3 more]</label></div><br/><div class="children"><div class="content">On similar lines I&#x27;ve wondered about reimplementing the C parts of Emacs in Common Lisp. At that point Elisp would be a hosted language, letting you benefit from all the existing packages.</div><br/><div id="41354279" class="c"><input type="checkbox" id="c-41354279" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#41353672">root</a><span>|</span><a href="#41354066">parent</a><span>|</span><a href="#41353901">next</a><span>|</span><label class="collapse" for="c-41354279">[-]</label><label class="expand" for="c-41354279">[2 more]</label></div><br/><div class="children"><div class="content">Lem is an Emacs using CL (also instead of Emacs Lisp): <a href="https:&#x2F;&#x2F;lem-project.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lem-project.github.io&#x2F;</a></div><br/><div id="41354410" class="c"><input type="checkbox" id="c-41354410" checked=""/><div class="controls bullet"><span class="by">alt0_</span><span>|</span><a href="#41353672">root</a><span>|</span><a href="#41354279">parent</a><span>|</span><a href="#41353901">next</a><span>|</span><label class="collapse" for="c-41354410">[-]</label><label class="expand" for="c-41354410">[1 more]</label></div><br/><div class="children"><div class="content">It is also graphical, and multi-threaded!</div><br/></div></div></div></div></div></div></div></div><div id="41353901" class="c"><input type="checkbox" id="c-41353901" checked=""/><div class="controls bullet"><span class="by">HexDecOctBin</span><span>|</span><a href="#41353672">prev</a><span>|</span><a href="#41354512">next</a><span>|</span><label class="collapse" for="c-41353901">[-]</label><label class="expand" for="c-41353901">[3 more]</label></div><br/><div class="children"><div class="content">Is a MOP (like CLOS) going to bring substantial advantage to extensibility? My intuition says yes, but I can&#x27;t test this hypothesis without thousands of plugin developers. Has any (meta) study even been done?</div><br/><div id="41354670" class="c"><input type="checkbox" id="c-41354670" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41353901">parent</a><span>|</span><a href="#41354512">next</a><span>|</span><label class="collapse" for="c-41354670">[-]</label><label class="expand" for="c-41354670">[2 more]</label></div><br/><div class="children"><div class="content">I think Elisp already implements a lot of things that CLOS would give you, like around method combinators (with defadvice, if I remember correctly). It&#x27;s probably more ad-hoc, and you might want some extra customizations on top, but I&#x27;m not sure.</div><br/><div id="41354700" class="c"><input type="checkbox" id="c-41354700" checked=""/><div class="controls bullet"><span class="by">dokyun</span><span>|</span><a href="#41353901">root</a><span>|</span><a href="#41354670">parent</a><span>|</span><a href="#41354512">next</a><span>|</span><label class="collapse" for="c-41354700">[-]</label><label class="expand" for="c-41354700">[1 more]</label></div><br/><div class="children"><div class="content">Elisp already has a (partial, but for most purposes complete) implementation of CLOS as part of the cl-lib package.</div><br/></div></div></div></div></div></div><div id="41354512" class="c"><input type="checkbox" id="c-41354512" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#41353901">prev</a><span>|</span><label class="collapse" for="c-41354512">[-]</label><label class="expand" for="c-41354512">[8 more]</label></div><br/><div class="children"><div class="content">The only reason I immagine people might not be happy with elisp is when they reach a point and wish their emacs was their operating system - ie they wish elisp was a systems language - and dont want to learn C</div><br/><div id="41354585" class="c"><input type="checkbox" id="c-41354585" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#41354512">parent</a><span>|</span><label class="collapse" for="c-41354585">[-]</label><label class="expand" for="c-41354585">[7 more]</label></div><br/><div class="children"><div class="content">I would think that people might wish Emacs Lisp would be a more capable application programming language. For example for an editor with such extensive capabilities, it would be useful that the language would provide preemptive scheduled threads and related constructs.<p>On my old Lisp Machine, Zmacs ran in a multi-threaded Lisp roughly in the early 80s. Multiple Zmacs windows each had their own thread. Applications had their own thread. GC has its own threads. Even the mouse has its own thread. It still works that way.<p>But you don&#x27;t need a Lisp Machine OS with threaded Lisp for that. Many current implementations of Lisp support multi-threading. An example is SBCL, a natively compiled Common Lisp, which supports native threads on its platforms. Thus an editor written on top of SBCL could make use of that. IDEs of LispWorks and Allegro CL are also multi-threaded and they have their own implementations of Emacs, written in Common Lisp.<p>Compare with GNU Emacs, where Emacs Lisp lacks this feature. Wouldn&#x27;t you want an mail thread not block the rest of Lisp code? Some Lisp action in the REPL not to block the rest of Lisp code?<p>Multi-threaded Lisp architectures are more complex. Emacs Lisp tried to be simple. But the stuff written in it long ago was outgrowing the provided simplicity. For a capable extension language it was &quot;good enough&quot; for a long time. For an &quot;application development platform&quot; it&#x27;s not. Lack of multi-threading in Emacs Lisp and the GNU Emacs architecture is an example.</div><br/><div id="41355231" class="c"><input type="checkbox" id="c-41355231" checked=""/><div class="controls bullet"><span class="by">amszmidt</span><span>|</span><a href="#41354512">root</a><span>|</span><a href="#41354585">parent</a><span>|</span><a href="#41354702">next</a><span>|</span><label class="collapse" for="c-41355231">[-]</label><label class="expand" for="c-41355231">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Compare with GNU Emacs, where Emacs Lisp lacks this feature. Wouldn&#x27;t you want an mail thread not block the rest of Lisp code? Some Lisp action in the REPL not to block the rest of Lisp code?<p>Emacs Lisp does have threads; <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;emacs&#x2F;manual&#x2F;html_node&#x2F;elisp&#x2F;Threads.html" rel="nofollow">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;emacs&#x2F;manual&#x2F;html_node&#x2F;elisp&#x2F;Th...</a></div><br/></div></div><div id="41354702" class="c"><input type="checkbox" id="c-41354702" checked=""/><div class="controls bullet"><span class="by">ducktective</span><span>|</span><a href="#41354512">root</a><span>|</span><a href="#41354585">parent</a><span>|</span><a href="#41355231">prev</a><span>|</span><label class="collapse" for="c-41354702">[-]</label><label class="expand" for="c-41354702">[5 more]</label></div><br/><div class="children"><div class="content">&gt;On Lisp Machine, Zmacs ran in a multi-threaded Lisp<p>I wonder what the processing architecture of those Lisp machines were like. Did their &quot;cpu&quot;(?) had special circuitry for implementing lists, CAR and CDR? Was this multi-threaded-ness something built-in in hardware?</div><br/><div id="41354728" class="c"><input type="checkbox" id="c-41354728" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#41354512">root</a><span>|</span><a href="#41354702">parent</a><span>|</span><label class="collapse" for="c-41354728">[-]</label><label class="expand" for="c-41354728">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Did their &quot;cpu&quot;(?) had special circuitry for implementing lists, CAR and CDR?<p>It was implemented in Microcode on the CPU.<p>&gt; Was this multi-threaded-ness something built-in in hardware?<p>Some. The process scheduler was written in Lisp. See for an early example on the MIT Lisp Machine: <a href="https:&#x2F;&#x2F;github.com&#x2F;mietek&#x2F;mit-cadr-system-software&#x2F;blob&#x2F;master&#x2F;src&#x2F;lispm2&#x2F;proces.150">https:&#x2F;&#x2F;github.com&#x2F;mietek&#x2F;mit-cadr-system-software&#x2F;blob&#x2F;mast...</a></div><br/><div id="41355070" class="c"><input type="checkbox" id="c-41355070" checked=""/><div class="controls bullet"><span class="by">dokyun</span><span>|</span><a href="#41354512">root</a><span>|</span><a href="#41354728">parent</a><span>|</span><label class="collapse" for="c-41355070">[-]</label><label class="expand" for="c-41355070">[3 more]</label></div><br/><div class="children"><div class="content">I think you should clarify that the Lisp machines (at least the early ones that you speak of) were not &#x27;multi-threaded&#x27; in the sense of multiprocessing--the only multiprocessing they did was running independent Lisp systems on each of their processors, if they had more than one.</div><br/><div id="41355198" class="c"><input type="checkbox" id="c-41355198" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#41354512">root</a><span>|</span><a href="#41355070">parent</a><span>|</span><a href="#41355214">next</a><span>|</span><label class="collapse" for="c-41355198">[-]</label><label class="expand" for="c-41355198">[1 more]</label></div><br/><div class="children"><div class="content">From the 1981 4th edition Lisp Machine Manual, page 428ff<p>&gt; 25. Processes<p>&gt; The Lisp Machine supports multi-processing; several computations can be executed &quot;concurrently&quot; by placing each in a separate process. A process is like a processor, simulated by software. Each process has its own &quot;program counter&quot;, its own stack of function calls and its own special-variable binding environment in which to execute its computation. (This is implemented with stack groups, see chapter 12, page 163.)<p>These computers could send&#x2F;receive network traffic, handle the GUI, read from disk, while the user would have processes for each application and window.<p>On my mid 1980s Symbolics 3640 I could compile a Lisp application from scratch in a Lisp REPL for half an hour, while I was using Zmacs to edit code. The practical limitations were CPU speed, memory size, disk speed and the Garbage collector. A full GC would halt everything else. Better incremental GCs helped a lot.<p>In GNU Emacs last I tried I could not use two IELM repls executing Lisp code at the same time. One would block the rest of GNU Emacs Lisp code.</div><br/></div></div><div id="41355214" class="c"><input type="checkbox" id="c-41355214" checked=""/><div class="controls bullet"><span class="by">amszmidt</span><span>|</span><a href="#41354512">root</a><span>|</span><a href="#41355070">parent</a><span>|</span><a href="#41355198">prev</a><span>|</span><label class="collapse" for="c-41355214">[-]</label><label class="expand" for="c-41355214">[1 more]</label></div><br/><div class="children"><div class="content">There is a bit to much simplification here, and confusing terminology going on here.  Lisp Machines did not have &quot;processes&quot; (as in, Unix processes); a Lisp Machine process just a function - with some special properties.<p>The Lisp Machine only had one processor for the Lisp Machine, and it did absolutely support multi-processing and multi-threading.<p>A good explanation can be found in the Lisp Machine manual:<p><pre><code>  https:&#x2F;&#x2F;tumbleweed.nu&#x2F;r&#x2F;lm-3&#x2F;uv&#x2F;chinual.html#Processes
  https:&#x2F;&#x2F;tumbleweed.nu&#x2F;r&#x2F;lm-3&#x2F;uv&#x2F;chinual.html#Stack-Groups
</code></pre>
Which is also where all current work on the MIT Lisp Machine is being done. :-)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>