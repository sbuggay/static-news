<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1691744463831" as="style"/><link rel="stylesheet" href="styles.css?v=1691744463831"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://interrupt.memfault.com/blog/a-modern-c-dev-env">A Modern C Development Environment</a> <span class="domain">(<a href="https://interrupt.memfault.com">interrupt.memfault.com</a>)</span></div><div class="subtext"><span>5ADBEEF</span> | <span>193 comments</span></div><br/><div><div id="37084830" class="c"><input type="checkbox" id="c-37084830" checked=""/><div class="controls bullet"><span class="by">zer8k</span><span>|</span><a href="#37084692">next</a><span>|</span><label class="collapse" for="c-37084830">[-]</label><label class="expand" for="c-37084830">[18 more]</label></div><br/><div class="children"><div class="content">Not bad except for visual studio devcontainers. Absolutely gross solution to a problem I&#x27;ve never faced in over a decade of professional development. I can see docker in some cases (rarely) for C programming. But devcontainers? That&#x27;s like reaching around your head to touch your nose. I know plenty of people that use them and every time I watch them to try to glean some insight I am left more confused than I started. It seems so stilted. I always get &quot;its a better experience!&quot; but never any explanation why. Like everyone who uses them watched the same Microsoft sponsored youtube video selling them.<p>None of this solves C&#x27;s only REAL problem (in my opinion) which is the lack of dependency management. Most everything else can be done with a makefile and a half decent editor. No need to step up into vscode if you don&#x27;t want to. Clang LSPs are basically everywhere and <i>just fine</i>.</div><br/><div id="37086550" class="c"><input type="checkbox" id="c-37086550" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#37084830">parent</a><span>|</span><a href="#37085540">next</a><span>|</span><label class="collapse" for="c-37086550">[-]</label><label class="expand" for="c-37086550">[1 more]</label></div><br/><div class="children"><div class="content">I am not sure what kind of dependency management you mention.<p>For several decades, I have never compiled any C project otherwise than with auto-generated dependencies between files, which are generated by the compiler and used by make.<p>I never write by hand dependencies for a makefile.<p>It is true that many open-source projects have horrible makefiles, but I have never understood why anyone has written such makefiles, when the GNU make manual explains the right way and that explanation already existed at least a quarter of a century ago.</div><br/></div></div><div id="37085540" class="c"><input type="checkbox" id="c-37085540" checked=""/><div class="controls bullet"><span class="by">rgoulter</span><span>|</span><a href="#37084830">parent</a><span>|</span><a href="#37086550">prev</a><span>|</span><a href="#37085925">next</a><span>|</span><label class="collapse" for="c-37085540">[-]</label><label class="expand" for="c-37085540">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Absolutely gross solution to a problem I&#x27;ve never faced in over a decade of professional development. .... None of this solves C&#x27;s only REAL problem (in my opinion) which is the lack of dependency management.<p>I&#x27;d juxtapose these two sentences.<p>As I understand things. Those who know Nix swear by it. You can declare a development environment which will provide the toolchain and the libraries you need to build your software.<p>Some things do seem inelegant about Docker containers. e.g. Building the images with Dockerfiles feels fragile. Running containers means high friction to accessing the build environment from the host machine.<p>Those downsides aside, AFAIU the VSCode devcontainers aim to provide that &quot;wow it just works&quot; experience that the Nix people love, without having to pay the steep learning curve of learning Nix.</div><br/><div id="37085838" class="c"><input type="checkbox" id="c-37085838" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#37084830">root</a><span>|</span><a href="#37085540">parent</a><span>|</span><a href="#37085925">next</a><span>|</span><label class="collapse" for="c-37085838">[-]</label><label class="expand" for="c-37085838">[1 more]</label></div><br/><div class="children"><div class="content">&gt; None of this solves C&#x27;s only REAL problem (in my opinion) which is the lack of dependency management.<p>I thought this too for a long time, but the more I&#x27;m exposed to languages with &quot;proper&quot; dependency management the more I appreciate the C way of just copying external library sources into the project (and I only consider libraries which make this easy, e.g. if they come with their own complex build system files they already lost - just give me a bunch of headers and source files, and maybe a readme with a list of configuration defines).</div><br/></div></div></div></div><div id="37085925" class="c"><input type="checkbox" id="c-37085925" checked=""/><div class="controls bullet"><span class="by">Eddygandr</span><span>|</span><a href="#37084830">parent</a><span>|</span><a href="#37085540">prev</a><span>|</span><a href="#37084974">next</a><span>|</span><label class="collapse" for="c-37085925">[-]</label><label class="expand" for="c-37085925">[2 more]</label></div><br/><div class="children"><div class="content">Devcontainers are the main reason I use vscode. Being able to git pull a project on a new starters laptop with only docker installed and have everything there, shared across everyone’s workstation, is great. It helps reduce developers local computer settings causing issues. It’s not as complicated to teach as Nix. I’ve never heard someone dislike it before tbh!</div><br/><div id="37086059" class="c"><input type="checkbox" id="c-37086059" checked=""/><div class="controls bullet"><span class="by">petepete</span><span>|</span><a href="#37084830">root</a><span>|</span><a href="#37085925">parent</a><span>|</span><a href="#37084974">next</a><span>|</span><label class="collapse" for="c-37086059">[-]</label><label class="expand" for="c-37086059">[1 more]</label></div><br/><div class="children"><div class="content">I love them even though I don&#x27;t use them myself. They let less technical members of my teams like content and interaction designers run apps in two clicks. Often they don&#x27;t have admin rights on their computers to install the necessary tools so it eliminates that problem too.</div><br/></div></div></div></div><div id="37084974" class="c"><input type="checkbox" id="c-37084974" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#37084830">parent</a><span>|</span><a href="#37085925">prev</a><span>|</span><a href="#37085086">next</a><span>|</span><label class="collapse" for="c-37084974">[-]</label><label class="expand" for="c-37084974">[3 more]</label></div><br/><div class="children"><div class="content">My solution: git submodules + every project stores its main sources in src&#x2F; + Makefile that recursively searches for &quot;src&#x2F;*.c&quot; files and compiles them to a big ol object collection.<p>It&#x27;s obviously not infinitely scaleable because you could end up with name conflicts for object files, or some modules might require custom build settings. But it works well enough to nest my own projects 3-4 layers deep without issue.</div><br/><div id="37085178" class="c"><input type="checkbox" id="c-37085178" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#37084830">root</a><span>|</span><a href="#37084974">parent</a><span>|</span><a href="#37085086">next</a><span>|</span><label class="collapse" for="c-37085178">[-]</label><label class="expand" for="c-37085178">[2 more]</label></div><br/><div class="children"><div class="content">git submodules have ruined my life on multiple teams enough to never want them. They&#x27;re good enough for a dev team of 2-3 but don&#x27;t scale very well. git subtree can be a bit better. But ultimately you probably want a working package manager.</div><br/><div id="37086338" class="c"><input type="checkbox" id="c-37086338" checked=""/><div class="controls bullet"><span class="by">eonwe</span><span>|</span><a href="#37084830">root</a><span>|</span><a href="#37085178">parent</a><span>|</span><a href="#37085086">next</a><span>|</span><label class="collapse" for="c-37086338">[-]</label><label class="expand" for="c-37086338">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard this often.<p>Why don&#x27;t they scale?
I used them for some years for a team of ten or so people who all first had to learn to understand how they worked so might that be the problem?</div><br/></div></div></div></div></div></div><div id="37085086" class="c"><input type="checkbox" id="c-37085086" checked=""/><div class="controls bullet"><span class="by">haberman</span><span>|</span><a href="#37084830">parent</a><span>|</span><a href="#37084974">prev</a><span>|</span><a href="#37086252">next</a><span>|</span><label class="collapse" for="c-37085086">[-]</label><label class="expand" for="c-37085086">[7 more]</label></div><br/><div class="children"><div class="content">&gt; I can see docker in some cases (rarely) for C programming. But devcontainers? That&#x27;s like reaching around your head to touch your nose.<p>I thought devcontainers were merely a way of telling VSCode to host your dev environment in a Docker container.  I&#x27;m confused about what distinction you are drawing here.</div><br/><div id="37085148" class="c"><input type="checkbox" id="c-37085148" checked=""/><div class="controls bullet"><span class="by">zer8k</span><span>|</span><a href="#37084830">root</a><span>|</span><a href="#37085086">parent</a><span>|</span><a href="#37086252">next</a><span>|</span><label class="collapse" for="c-37085148">[-]</label><label class="expand" for="c-37085148">[6 more]</label></div><br/><div class="children"><div class="content">&gt; I thought devcontainers were merely a way of telling VSCode to host your dev environment in a Docker container.<p>Right, which is gross. It gets worse when you start talking about using them practically in an enterprise-ish environment. There, they end up being a less effective Xen-style programming interface. It&#x27;s too bloated for most cases. The distinction I make is building with docker (for cross compilation or whatever) vs hosting your <i>entire</i> dev environment in a container.</div><br/><div id="37085392" class="c"><input type="checkbox" id="c-37085392" checked=""/><div class="controls bullet"><span class="by">MrJohz</span><span>|</span><a href="#37084830">root</a><span>|</span><a href="#37085148">parent</a><span>|</span><a href="#37085756">next</a><span>|</span><label class="collapse" for="c-37085392">[-]</label><label class="expand" for="c-37085392">[3 more]</label></div><br/><div class="children"><div class="content">But why is it &quot;gross&quot;? I&#x27;d have thought it would be especially useful in C development where headers and other development packages are typically installed globally on a machine - it would allow you to have multiple isolated environments, the correct packages (and versions) in each of those environments, and your editor&#x2F;LSP&#x2F;IDE would be able to interact with that isolated environment pretty much out of the box.<p>I don&#x27;t really see the difference between just building via docker, and doing static analysis, incremental builds, running tests, etc inside docker. Surely the goal in all these scenarios is the same: a reproducible environment for every developer on the project?</div><br/><div id="37085560" class="c"><input type="checkbox" id="c-37085560" checked=""/><div class="controls bullet"><span class="by">rgoulter</span><span>|</span><a href="#37084830">root</a><span>|</span><a href="#37085392">parent</a><span>|</span><a href="#37085756">next</a><span>|</span><label class="collapse" for="c-37085560">[-]</label><label class="expand" for="c-37085560">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a higher friction to working with that isolated environment.<p>It&#x27;s hard to take stuff out of a running container; and it&#x27;s hard to access files&#x2F;programs on the host from within the container.<p>There may be advantages to running inside a container; but it largely feels like when there are easier ways for quickly making programs available to the host (e.g. virtual environments, or asdf version manager), then most tools aim for that first.</div><br/><div id="37085727" class="c"><input type="checkbox" id="c-37085727" checked=""/><div class="controls bullet"><span class="by">seabrookmx</span><span>|</span><a href="#37084830">root</a><span>|</span><a href="#37085560">parent</a><span>|</span><a href="#37085756">next</a><span>|</span><label class="collapse" for="c-37085727">[-]</label><label class="expand" for="c-37085727">[1 more]</label></div><br/><div class="children"><div class="content">Honest question.. have you used dev containers? Because these seem like solved problems.<p>Bind mounts let you easily move files in&#x2F;out of the container (and are already set up by devcontainers). And the whole point is to _not_ access programs on the host, you want that isolation so that the environment is reproducible and everything you need to build is defined in the dev container.<p>It just needs your build toolchain and libs.. you don&#x27;t need to use the shell from the container to run random unix utils or curl for instance.</div><br/></div></div></div></div></div></div><div id="37085756" class="c"><input type="checkbox" id="c-37085756" checked=""/><div class="controls bullet"><span class="by">seabrookmx</span><span>|</span><a href="#37084830">root</a><span>|</span><a href="#37085148">parent</a><span>|</span><a href="#37085392">prev</a><span>|</span><a href="#37085423">next</a><span>|</span><label class="collapse" for="c-37085756">[-]</label><label class="expand" for="c-37085756">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s too bloated for most cases<p>Bloated how? Which cases?<p>Any C app (or even Python app, since python libs like to depend on C libraries) with non-trivial dependencies get very annoying to configure across a range of distros (even worse if you include MacOS and&#x2F;or Windows).<p>`sudo apt install libpng-dev` vs `sudo dnf libpng-devel` etc.<p>Rather than document and test all those different configs, devcontainers is a really easy way to avoid this pain for example applications or ones that will only ever ship to one distro&#x2F;OS. And if you&#x27;re running on Linux atleast, there&#x27;s literally no overhead (containers are just processes tagged with C-groups, after all).</div><br/></div></div><div id="37085423" class="c"><input type="checkbox" id="c-37085423" checked=""/><div class="controls bullet"><span class="by">taberiand</span><span>|</span><a href="#37084830">root</a><span>|</span><a href="#37085148">parent</a><span>|</span><a href="#37085756">prev</a><span>|</span><a href="#37086252">next</a><span>|</span><label class="collapse" for="c-37085423">[-]</label><label class="expand" for="c-37085423">[1 more]</label></div><br/><div class="children"><div class="content">Why is it gross? Performance issues? It works well* for creating a reliable environment for all developers involved in a project.<p>* granted I did just spend half a day last week figuring out that WSL environment variables are not correctly applied to the containerEnv, but otherwise they&#x27;ve been solid</div><br/></div></div></div></div></div></div><div id="37086252" class="c"><input type="checkbox" id="c-37086252" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37084830">parent</a><span>|</span><a href="#37085086">prev</a><span>|</span><a href="#37084980">next</a><span>|</span><label class="collapse" for="c-37086252">[-]</label><label class="expand" for="c-37086252">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. Compiler toolchains belong in version control. This doesn&#x27;t make total sense for &quot;libraries&quot; on GitHub. But for anything corporate and closed you should 1000% commit full toolchains in source control. Builds shouldn&#x27;t use anything from the local environment.<p>Of course Git kinda sucks and isn&#x27;t good at hosting toolchains. So I&#x27;m putting a heavy emphasis on &quot;should&quot;.</div><br/></div></div><div id="37084980" class="c"><input type="checkbox" id="c-37084980" checked=""/><div class="controls bullet"><span class="by">SV_BubbleTime</span><span>|</span><a href="#37084830">parent</a><span>|</span><a href="#37086252">prev</a><span>|</span><a href="#37084692">next</a><span>|</span><label class="collapse" for="c-37084980">[-]</label><label class="expand" for="c-37084980">[1 more]</label></div><br/><div class="children"><div class="content">There is a big advantage in devcontainers if you are cross compiling like for embedded and working with multiple computers and people.<p>The tool chains for ARM GCC on windows are a real pain to path correctly for multiple systems. Not to mention the same issue for OpenOCD, Debug, etc.</div><br/></div></div></div></div><div id="37084692" class="c"><input type="checkbox" id="c-37084692" checked=""/><div class="controls bullet"><span class="by">manofmanysmiles</span><span>|</span><a href="#37084830">prev</a><span>|</span><a href="#37082355">next</a><span>|</span><label class="collapse" for="c-37084692">[-]</label><label class="expand" for="c-37084692">[5 more]</label></div><br/><div class="children"><div class="content">Having spent a decade building embedded C, its refreshing to see that I&#x27;m not the only one who sees the value in doing things well.<p>Every single one of the steps here, though they may seem excessive provide immense value, not at first, but as the project grows, matures, and needs to exist for decades.<p>I am rather surprised at all the negativity here. I assume that it&#x27;s either few of the people commenting have worked on embedded systems, or the few that do do not have an appreciation for maintaining a large project for the long term.<p>Attitudes like I&#x27;m seeing expressed here are reinforcing my desire to get away from embedded, or at last work with people that don&#x27;t wish to stay stuck in the stone age.<p>I&#x27;m not intending to argue here, just surprised and a bit sad at the reactions, and happy that some people, at least at memfault share my values.</div><br/><div id="37084940" class="c"><input type="checkbox" id="c-37084940" checked=""/><div class="controls bullet"><span class="by">randmeerkat</span><span>|</span><a href="#37084692">parent</a><span>|</span><a href="#37086078">next</a><span>|</span><label class="collapse" for="c-37084940">[-]</label><label class="expand" for="c-37084940">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Attitudes like I&#x27;m seeing expressed here are reinforcing my desire to get away from embedded, or at last work with people that don&#x27;t wish to stay stuck in the stone age.<p>I hate to break it to you, but there’s the same problems on the SWE side too. The problem is never the stack, it’s the culture. If you’re tired of embedded, that’s fine, but remember to ask culture questions for your next position.</div><br/><div id="37085057" class="c"><input type="checkbox" id="c-37085057" checked=""/><div class="controls bullet"><span class="by">manofmanysmiles</span><span>|</span><a href="#37084692">root</a><span>|</span><a href="#37084940">parent</a><span>|</span><a href="#37086078">next</a><span>|</span><label class="collapse" for="c-37085057">[-]</label><label class="expand" for="c-37085057">[2 more]</label></div><br/><div class="children"><div class="content">That’s disheartening, but not surprising.<p>&gt; remember to ask culture questions for your next position.<p>I will definitely take that under advisement. Any places you recommend I look into?</div><br/><div id="37085355" class="c"><input type="checkbox" id="c-37085355" checked=""/><div class="controls bullet"><span class="by">randmeerkat</span><span>|</span><a href="#37084692">root</a><span>|</span><a href="#37085057">parent</a><span>|</span><a href="#37086078">next</a><span>|</span><label class="collapse" for="c-37085355">[-]</label><label class="expand" for="c-37085355">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That’s disheartening, but not surprising.<p>Don’t be discouraged, it’s just life.<p>&gt; I will definitely take that under advisement. Any places you recommend I look into?<p>Ask yourself what you want? What do you want in a leader? What do you want in a company? Be picky, be patient, if you can, maybe start something yourself. I wish I could tell you what would be the right fit for you, but I can’t. All I can say is don’t lose hope, but at the same time don’t expect too much either. We’re all just trying to figure out this thing called life, whether we’re embedded engineers, SWEs, or even sales for that matter.</div><br/></div></div></div></div></div></div><div id="37086078" class="c"><input type="checkbox" id="c-37086078" checked=""/><div class="controls bullet"><span class="by">Sakos</span><span>|</span><a href="#37084692">parent</a><span>|</span><a href="#37084940">prev</a><span>|</span><a href="#37082355">next</a><span>|</span><label class="collapse" for="c-37086078">[-]</label><label class="expand" for="c-37086078">[1 more]</label></div><br/><div class="children"><div class="content">I think the article is great too. There&#x27;s a complete dearth of decent guides for how to setup a C&#x2F;C++ environment with dependencies, including some sort of build system, and it&#x27;s often been my biggest stumbling block. Everybody assumes you know how all this works and most guides are either way too basic (&quot;just do make&quot; like the comment below) or it&#x27;s highly technical documentation that overwhelms anybody who isn&#x27;t already familiar with C development.</div><br/></div></div></div></div><div id="37082355" class="c"><input type="checkbox" id="c-37082355" checked=""/><div class="controls bullet"><span class="by">ryan-c</span><span>|</span><a href="#37084692">prev</a><span>|</span><a href="#37084423">next</a><span>|</span><label class="collapse" for="c-37082355">[-]</label><label class="expand" for="c-37082355">[94 more]</label></div><br/><div class="children"><div class="content">At the risk of being featured in a future episode of &quot;Hacker News reacts to (Dropbox|iPhone)&quot;...<p>...a Makefile and vim (or emacs, or even nano, I&#x27;m not going to judge your kink) are fine. If they are not fine, then C is probably not the right language for the project.</div><br/><div id="37084320" class="c"><input type="checkbox" id="c-37084320" checked=""/><div class="controls bullet"><span class="by">cushychicken</span><span>|</span><a href="#37082355">parent</a><span>|</span><a href="#37082485">next</a><span>|</span><label class="collapse" for="c-37084320">[-]</label><label class="expand" for="c-37084320">[4 more]</label></div><br/><div class="children"><div class="content">Docker is a godsend when you&#x27;re a solo embedded consultant and a former customer comes to you five years later with an urgent firmware feature request and cash in hand.<p>If you don&#x27;t have the exact machine any more, then it&#x27;s &quot;Good luck getting the toolchain and build environment from the vendor!&quot;<p>Docker has saved my bacon at least twice in this manner.</div><br/><div id="37084444" class="c"><input type="checkbox" id="c-37084444" checked=""/><div class="controls bullet"><span class="by">publicmail</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37084320">parent</a><span>|</span><a href="#37085270">next</a><span>|</span><label class="collapse" for="c-37084444">[-]</label><label class="expand" for="c-37084444">[1 more]</label></div><br/><div class="children"><div class="content">Yep. I use VMs though. I still have to build for some embedded platforms that are based on the 2.4 Linux kernel…</div><br/></div></div><div id="37085270" class="c"><input type="checkbox" id="c-37085270" checked=""/><div class="controls bullet"><span class="by">fbdab103</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37084320">parent</a><span>|</span><a href="#37084444">prev</a><span>|</span><a href="#37085549">next</a><span>|</span><label class="collapse" for="c-37085270">[-]</label><label class="expand" for="c-37085270">[1 more]</label></div><br/><div class="children"><div class="content">Would a five year old Docker image still work? I mean, probably, but for long term maintenance of a build environment, I would feel significantly better with a VM.</div><br/></div></div><div id="37085549" class="c"><input type="checkbox" id="c-37085549" checked=""/><div class="controls bullet"><span class="by">raverbashing</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37084320">parent</a><span>|</span><a href="#37085270">prev</a><span>|</span><a href="#37082485">next</a><span>|</span><label class="collapse" for="c-37085549">[-]</label><label class="expand" for="c-37085549">[1 more]</label></div><br/><div class="children"><div class="content">Yeah (and I agree) but it doesn&#x27;t have to be docker<p>It can be a vm, even a chroot.<p>Also the compatibility questions and docker &quot;opacity&quot; come to mind.<p>A QEMU VM sounds like a better propositions</div><br/></div></div></div></div><div id="37082485" class="c"><input type="checkbox" id="c-37082485" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#37082355">parent</a><span>|</span><a href="#37084320">prev</a><span>|</span><a href="#37082624">next</a><span>|</span><label class="collapse" for="c-37082485">[-]</label><label class="expand" for="c-37082485">[27 more]</label></div><br/><div class="children"><div class="content">&gt; If they are not fine, then C is probably not the right language for the project.<p>This is called gatekeeping and it’s not helpful.<p>It’s fine to write C in vim&#x2F;emacs&#x2F;nano if you want.<p>It’s fine to write C in Visual Studio Code if you want.<p>It’s fine to write C in CLion if you want.<p>There is nothing wrong with any approach and no need to gatekeeper an entire programming language based on editor preference.</div><br/><div id="37082901" class="c"><input type="checkbox" id="c-37082901" checked=""/><div class="controls bullet"><span class="by">rfrey</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082485">parent</a><span>|</span><a href="#37084042">next</a><span>|</span><label class="collapse" for="c-37082901">[-]</label><label class="expand" for="c-37082901">[3 more]</label></div><br/><div class="children"><div class="content">I did not read this as gatekeeping, rather I read it as an opinion on the suitability of C for kinds of project. If vim + make isn&#x27;t enough, then C is probably not the appropriate language. Not that you shouldn&#x27;t use C if you don&#x27;t use vim + make.<p>We always talk about how good engineers &quot;choose the right tool for the job&quot;. I don&#x27;t think expressing an opinion on what the right kind of job is for a particular tool should be out of bounds. (Setting aside whether the opinion is correct or not.)</div><br/><div id="37083712" class="c"><input type="checkbox" id="c-37083712" checked=""/><div class="controls bullet"><span class="by">marmakoide</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082901">parent</a><span>|</span><a href="#37082928">next</a><span>|</span><label class="collapse" for="c-37083712">[-]</label><label class="expand" for="c-37083712">[1 more]</label></div><br/><div class="children"><div class="content">For niche embedded devices, you often end-up with a half-baked C compiler and assembler, nothing else.</div><br/></div></div><div id="37082928" class="c"><input type="checkbox" id="c-37082928" checked=""/><div class="controls bullet"><span class="by">shortrounddev2</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082901">parent</a><span>|</span><a href="#37083712">prev</a><span>|</span><a href="#37084042">next</a><span>|</span><label class="collapse" for="c-37082928">[-]</label><label class="expand" for="c-37082928">[1 more]</label></div><br/><div class="children"><div class="content">C is much easier to develop with using gdb</div><br/></div></div></div></div><div id="37084042" class="c"><input type="checkbox" id="c-37084042" checked=""/><div class="controls bullet"><span class="by">ryan-c</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082485">parent</a><span>|</span><a href="#37082901">prev</a><span>|</span><a href="#37083619">next</a><span>|</span><label class="collapse" for="c-37084042">[-]</label><label class="expand" for="c-37084042">[2 more]</label></div><br/><div class="children"><div class="content">Editor preference was not intended to be the focus of my comment, it was more me being incredulous that someone would build something in C which necessitated Docker.<p>If someone wants to do that anyway, I am going to be perplexed that C was the language choice rather than golang or rust, and perhaps worried about C being a footgun WRT security, but whatever.</div><br/><div id="37084773" class="c"><input type="checkbox" id="c-37084773" checked=""/><div class="controls bullet"><span class="by">metabagel</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37084042">parent</a><span>|</span><a href="#37083619">next</a><span>|</span><label class="collapse" for="c-37084773">[-]</label><label class="expand" for="c-37084773">[1 more]</label></div><br/><div class="children"><div class="content">I think the point of Docker is a reproducible build environment.</div><br/></div></div></div></div><div id="37083619" class="c"><input type="checkbox" id="c-37083619" checked=""/><div class="controls bullet"><span class="by">jonahx</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082485">parent</a><span>|</span><a href="#37084042">prev</a><span>|</span><a href="#37082536">next</a><span>|</span><label class="collapse" for="c-37083619">[-]</label><label class="expand" for="c-37083619">[5 more]</label></div><br/><div class="children"><div class="content">&gt; This is called gatekeeping and it’s not helpful.<p>What a bad faith interpretation.<p>It&#x27;s advice based on the poster&#x27;s experience, stated with both qualification and good humor.  You are free to ignore it.  I appreciated it.</div><br/><div id="37083702" class="c"><input type="checkbox" id="c-37083702" checked=""/><div class="controls bullet"><span class="by">95014_refugee</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083619">parent</a><span>|</span><a href="#37082536">next</a><span>|</span><label class="collapse" for="c-37083702">[-]</label><label class="expand" for="c-37083702">[4 more]</label></div><br/><div class="children"><div class="content">It is gatekeeping. The poster was not offering advice, they were being actively discouraging. You can argue shades of grey, but at the end of the day this is an unsolicited discouragement, and an arbitrary out-grouping.<p>The fact that you don&#x27;t see this as problematic, is problematic.</div><br/><div id="37083903" class="c"><input type="checkbox" id="c-37083903" checked=""/><div class="controls bullet"><span class="by">lcnPylGDnU4H9OF</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083702">parent</a><span>|</span><a href="#37083848">next</a><span>|</span><label class="collapse" for="c-37083903">[-]</label><label class="expand" for="c-37083903">[1 more]</label></div><br/><div class="children"><div class="content">&gt; a Makefile and vim (or emacs, or even nano, I&#x27;m not going to judge your kink)<p>The advice is common enough that it has a wikipedia page: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;KISS_principle" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;KISS_principle</a>.<p>There is no gatekeeping. There is a suggestion that C is best used for projects that have builds no more complex than a Makefile configuration. There is explicitly no ~judgement~ limit on what ~kink~ text editor one may use to edit the files.</div><br/></div></div><div id="37083848" class="c"><input type="checkbox" id="c-37083848" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083702">parent</a><span>|</span><a href="#37083903">prev</a><span>|</span><a href="#37085808">next</a><span>|</span><label class="collapse" for="c-37083848">[-]</label><label class="expand" for="c-37083848">[1 more]</label></div><br/><div class="children"><div class="content">the fact that they don&#x27;t see it as problematic means that they didn&#x27;t misinterpret the comment the way you did, which is because they know things you don&#x27;t<p>thus hegemonic institutions reinscribe the kyriarchy generation after generation by perpetuating a hierarchical opposition between &quot;knowledge&quot; and so-called &quot;ignorance&quot;, which is socially constructed to be inferior, less than, but which serves the purpose of distinguishing the graduates of elite institutions (to which access is mediated by the financial privilege of the bourgeoisie) from the subaltern underclass; thus &quot;knowledge&quot; serves the interests of capitalism by reproducing oppressive class divisions, enabling the continued exploitation of the working class<p>what could be more problematic than that?<p>but if you&#x27;re interested in learning something and not just playing word games to gain status by putting others down, i problematically mansplained what you&#x27;re missing in <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37083233">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37083233</a></div><br/></div></div><div id="37085808" class="c"><input type="checkbox" id="c-37085808" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083702">parent</a><span>|</span><a href="#37083848">prev</a><span>|</span><a href="#37082536">next</a><span>|</span><label class="collapse" for="c-37085808">[-]</label><label class="expand" for="c-37085808">[1 more]</label></div><br/><div class="children"><div class="content">The proposed solution of a text editor and makefile is a <i>lot</i> easier to setup than the what&#x27;s proposed in the blog post, I would call this the opposite of gatekeeping.</div><br/></div></div></div></div></div></div><div id="37082536" class="c"><input type="checkbox" id="c-37082536" checked=""/><div class="controls bullet"><span class="by">the-printer</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082485">parent</a><span>|</span><a href="#37083619">prev</a><span>|</span><a href="#37083590">next</a><span>|</span><label class="collapse" for="c-37082536">[-]</label><label class="expand" for="c-37082536">[13 more]</label></div><br/><div class="children"><div class="content">Is it really gatekeeping? Does this opinion (that was valid and useful to me) carry any preventive force that the term suggests?</div><br/><div id="37082666" class="c"><input type="checkbox" id="c-37082666" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082536">parent</a><span>|</span><a href="#37082661">next</a><span>|</span><label class="collapse" for="c-37082666">[-]</label><label class="expand" for="c-37082666">[2 more]</label></div><br/><div class="children"><div class="content">The colloquial definition of &quot;gatekeeping&quot; doesn&#x27;t require literal preventative force.<p>See <a href="https:&#x2F;&#x2F;www.urbandictionary.com&#x2F;define.php?term=Gatekeeping" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.urbandictionary.com&#x2F;define.php?term=Gatekeeping</a></div><br/><div id="37083163" class="c"><input type="checkbox" id="c-37083163" checked=""/><div class="controls bullet"><span class="by">the-printer</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082666">parent</a><span>|</span><a href="#37082661">next</a><span>|</span><label class="collapse" for="c-37083163">[-]</label><label class="expand" for="c-37083163">[1 more]</label></div><br/><div class="children"><div class="content">I get that, but even figuratively, it&#x27;s a relatively harmless opinion that can only achieve as much by way of influence or control as readers are willing to allow the anonymous commenter to hold over them. There&#x27;s more to learn if we confront the opinion by its premises (as shown by other responses to the comment) than by subjective moral grounds.</div><br/></div></div></div></div><div id="37082661" class="c"><input type="checkbox" id="c-37082661" checked=""/><div class="controls bullet"><span class="by">bryancoxwell</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082536">parent</a><span>|</span><a href="#37082666">prev</a><span>|</span><a href="#37082721">next</a><span>|</span><label class="collapse" for="c-37082661">[-]</label><label class="expand" for="c-37082661">[8 more]</label></div><br/><div class="children"><div class="content">It dissuades people who aren’t comfortable with Makefiles and Vim from using C, so I’d agree it’s gatekeep-y.</div><br/><div id="37084425" class="c"><input type="checkbox" id="c-37084425" checked=""/><div class="controls bullet"><span class="by">seabird</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082661">parent</a><span>|</span><a href="#37083233">next</a><span>|</span><label class="collapse" for="c-37084425">[-]</label><label class="expand" for="c-37084425">[2 more]</label></div><br/><div class="children"><div class="content">If vim and make are spooking somebody, they need to turn tail and run the fuck away from C. I love it to death, but it&#x27;s a frustrating experience from another era. vim and make are the least of your worries when dealing with it.</div><br/><div id="37085831" class="c"><input type="checkbox" id="c-37085831" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37084425">parent</a><span>|</span><a href="#37083233">next</a><span>|</span><label class="collapse" for="c-37085831">[-]</label><label class="expand" for="c-37085831">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but it&#x27;s a frustrating experience from another era<p>Are you using C99 features? I find the &quot;new&quot; features extremely enjoyable, it feels like a different language compared to C89 or the common C&#x2F;C++ subset.</div><br/></div></div></div></div><div id="37083233" class="c"><input type="checkbox" id="c-37083233" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082661">parent</a><span>|</span><a href="#37084425">prev</a><span>|</span><a href="#37082721">next</a><span>|</span><label class="collapse" for="c-37083233">[-]</label><label class="expand" for="c-37083233">[5 more]</label></div><br/><div class="children"><div class="content">i think that&#x27;s the opposite of the intent<p>they&#x27;re saying that you don&#x27;t need to be comfortable with ides and fancy debuggers and cmake and language servers and game development engines and ci pipelines and all kinds of complicated stuff to write c successfully<p>a bare-bones text editor and the most minimal build system are plenty<p>and if they aren&#x27;t plenty, they&#x27;re not saying that&#x27;s a problem with you, but with c<p>i don&#x27;t agree (ctags, valgrind, git, and gdb go a long way towards making c usable, and evidently c is the best language for a lot of things even ctags and gdb struggle with, like linux kernel drivers, and cmake evidently helps a lot if you care about ms-windows) but that&#x27;s what they said, and you totally misunderstood them because you somehow got the idea that vim and make are some kind of super advanced tools rather than relics from the 01980s<p>they&#x27;re maybe a bit unprepossessing at first glance but mostly what they are is simple and primitive<p>think of using a hammer rather than a cam-driven turret lathe<p>you can go lower tech than make too now that cpus and c compilers are so fast<p><pre><code>    while sleep 1; do  # ci pipeline
      gcc -Wall -funny -mtune=i69 *.c -lm -liberty -letmypeoplego -o proggie &amp;&amp;  # build system
      .&#x2F;proggie --run-tests  # test runner
    done
</code></pre>
c compiles fast enough that this scales to several thousand lines of code, c++ very much does not<p>of course you need a testing framework<p><pre><code>    if (!strcmp(argv[1], &quot;--run-tests&quot;)) return run_tests();
</code></pre>
... three seconds latair ...<p><pre><code>    int run_tests()
    {
        return test_ui() ||
               test_network() ||
               test_parsing();
    }

    int test_parsing()
    {
        assert(trees_equal(parse(&quot;3+4&quot;),
                           parse(&quot;3 + 4&quot;)));
        assert(!trees_equal(parse(&quot;3+4&quot;),
                            parse(&quot;3 + 5&quot;)));
      ...
    }
</code></pre>
now i&#x27;m not saying you shouldn&#x27;t write a test runner in unity and distribute your ci pipeline with zmq and mqtt and whatever the fuck.  better ux is worth my weight in gold, and i have programmer gut.  also zmq is metal as fuck<p>what i <i>am</i> saying is that the difference between no test runner and an infinite loop in bash is <i>much bigger</i> than the difference between the bash loop and circleci or gitlab pipelines.  so don&#x27;t be intimidated by articles like this which make it sound like you need a team of phds to set up a test runner. writing tests and running them is what helps, not so much stylishness<p>except for version control.  a build script in shell is a serviceable alternative to make, but cp -a proggie&#x2F;src snapshot.$(date +%Y-%m-%d) is not a serviceable alternative to git<p>also if 3d test runners with inotify and particle systems with custom shaders mean that people write more tests and see the tests fail sooner after they break shit, that could make a real difference</div><br/><div id="37083998" class="c"><input type="checkbox" id="c-37083998" checked=""/><div class="controls bullet"><span class="by">ryan-c</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083233">parent</a><span>|</span><a href="#37082721">next</a><span>|</span><label class="collapse" for="c-37083998">[-]</label><label class="expand" for="c-37083998">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a he (some other folks used &quot;they&quot; which is fine), but this is otherwise a pretty good interpretation - it absolutely was a dig at C, not elitism.<p>If you&#x27;re going to learn a bunch of modern tooling and start a green field project that justifies that complexity, C is <i>generally</i> a poor choice. Learn a modern language.<p>I use C somewhat regularly, including for kernel stuff, embedded, and legacy code.<p>Mostly, though, when I use C, it&#x27;s because I&#x27;m doing a small thing that I need to be very fast, and I haven&#x27;t yet bothered to get comfortable with Rust.</div><br/><div id="37084053" class="c"><input type="checkbox" id="c-37084053" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083998">parent</a><span>|</span><a href="#37082721">next</a><span>|</span><label class="collapse" for="c-37084053">[-]</label><label class="expand" for="c-37084053">[3 more]</label></div><br/><div class="children"><div class="content">oops, i&#x27;m sorry i misgendered you.  i think i have fixed it now, but now the editing window has closed<p>on your other points i mostly agree, except that if i write a library in any popular &#x27;modern&#x27; language, it can only be called from that language, which seems like a missed opportunity<p>and when i went back and compared development time logs, the development speed advantages of modern languages seem to be only a factor of 2 or 3 over c, once i get beyond a few hundred lines<p>which i guess is why linux, firefox, cpython, gcc, apache, poppler, libvte, and so on are written in c or occasionally c++. it&#x27;s not because the authors didn&#x27;t know about common lisp, scheme, ml, smalltalk, and so on, or couldn&#x27;t figure out how to write a garbage collector<p>rust and some other unpopular modern languages look like they might change that situation (nim, zig, koka, a couple of others i can&#x27;t think of right now)</div><br/><div id="37084221" class="c"><input type="checkbox" id="c-37084221" checked=""/><div class="controls bullet"><span class="by">ryan-c</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37084053">parent</a><span>|</span><a href="#37084637">next</a><span>|</span><label class="collapse" for="c-37084221">[-]</label><label class="expand" for="c-37084221">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sorry, I&#x27;m having trouble hearing over the sound of that poor load bearing &quot;generally&quot; creaking under the stress of the thread. ;-)<p>Yeah, the &quot;C is the universal ABI&quot; problem is... annoying. Hopefully <i>something</i> safer eventually replaces it in that niche.<p>Also, I think the main reason I use a lot of the tools I do is just &quot;suck cost fallacy&quot;.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37082721" class="c"><input type="checkbox" id="c-37082721" checked=""/><div class="controls bullet"><span class="by">sophacles</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082536">parent</a><span>|</span><a href="#37082661">prev</a><span>|</span><a href="#37083590">next</a><span>|</span><label class="collapse" for="c-37082721">[-]</label><label class="expand" for="c-37082721">[2 more]</label></div><br/><div class="children"><div class="content">The term has become common on the web to refer to enthusiasts trying to control how people enjoy&#x2F;use a term or participate in an activity - for instance &quot;real fans only like the stuff from before $album&quot; or &quot;only filthy casuals play the game that way&quot; (or &quot;you shouldn&#x27;t use C if you want modern, good tooling&quot;). This might be worth reading through:<p><a href="https:&#x2F;&#x2F;www.urbandictionary.com&#x2F;define.php?term=Gatekeeping" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.urbandictionary.com&#x2F;define.php?term=Gatekeeping</a></div><br/></div></div></div></div><div id="37083590" class="c"><input type="checkbox" id="c-37083590" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082485">parent</a><span>|</span><a href="#37082536">prev</a><span>|</span><a href="#37083327">next</a><span>|</span><label class="collapse" for="c-37083590">[-]</label><label class="expand" for="c-37083590">[1 more]</label></div><br/><div class="children"><div class="content">You can write C how ever you want, doesn&#x27;t mean it&#x27;s the right language for the project. My team uses C++ a lot like Java, and turns out Java was the better tool for our use case.</div><br/></div></div><div id="37084211" class="c"><input type="checkbox" id="c-37084211" checked=""/><div class="controls bullet"><span class="by">thr_gt</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082485">parent</a><span>|</span><a href="#37083327">prev</a><span>|</span><a href="#37082624">next</a><span>|</span><label class="collapse" for="c-37084211">[-]</label><label class="expand" for="c-37084211">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re using vsc then C is absolutely not the right language. If your code can&#x27;t fit in your head when you&#x27;re writing it then you have no hope of debugging it. Vsc very much encourages your code to grow as large as the machine you&#x27;re wiring it in can handle.</div><br/></div></div></div></div><div id="37082624" class="c"><input type="checkbox" id="c-37082624" checked=""/><div class="controls bullet"><span class="by">heisenzombie</span><span>|</span><a href="#37082355">parent</a><span>|</span><a href="#37082485">prev</a><span>|</span><a href="#37083349">next</a><span>|</span><label class="collapse" for="c-37082624">[-]</label><label class="expand" for="c-37082624">[10 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t quite understand the sentiment.<p>So, let&#x27;s say we have a project. For whatever technical (or social, historical, religious...) reason, C is chosen as the right language.<p>Why does that imply that the programmers on that project should therefore write that C code in a terminal, with no linter, code formatter, static analysis, test runner, etc.?</div><br/><div id="37082951" class="c"><input type="checkbox" id="c-37082951" checked=""/><div class="controls bullet"><span class="by">icedchai</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082624">parent</a><span>|</span><a href="#37083797">next</a><span>|</span><label class="collapse" for="c-37082951">[-]</label><label class="expand" for="c-37082951">[4 more]</label></div><br/><div class="children"><div class="content">20 years ago, I worked on a C and C++ project that supported a billion dollar business. Almost everyone used vi. They used none of those other tools, and there were maybe a half dozen unit tests in the whole project.  I sure hope times have changed.</div><br/><div id="37083164" class="c"><input type="checkbox" id="c-37083164" checked=""/><div class="controls bullet"><span class="by">haggy102</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082951">parent</a><span>|</span><a href="#37083797">next</a><span>|</span><label class="collapse" for="c-37083164">[-]</label><label class="expand" for="c-37083164">[3 more]</label></div><br/><div class="children"><div class="content">Why not advocate for better testing? What was preventing you from spending more time unit testing code running a billion dollar business?</div><br/><div id="37083786" class="c"><input type="checkbox" id="c-37083786" checked=""/><div class="controls bullet"><span class="by">post-it</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083164">parent</a><span>|</span><a href="#37083791">next</a><span>|</span><label class="collapse" for="c-37083786">[-]</label><label class="expand" for="c-37083786">[1 more]</label></div><br/><div class="children"><div class="content">A project manager, probably. &quot;Advocating for XYZ&quot; costs emotional capital that I&#x27;m not necessarily willing to devote to a particular project, or to my employer at all.</div><br/></div></div><div id="37083791" class="c"><input type="checkbox" id="c-37083791" checked=""/><div class="controls bullet"><span class="by">frutiger</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083164">parent</a><span>|</span><a href="#37083786">prev</a><span>|</span><a href="#37083797">next</a><span>|</span><label class="collapse" for="c-37083791">[-]</label><label class="expand" for="c-37083791">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What was preventing you from spending more time unit testing code running a billion dollar business?<p>Presumably they were busy generating billions of dollars of revenue.</div><br/></div></div></div></div></div></div><div id="37083797" class="c"><input type="checkbox" id="c-37083797" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082624">parent</a><span>|</span><a href="#37082951">prev</a><span>|</span><a href="#37084067">next</a><span>|</span><label class="collapse" for="c-37083797">[-]</label><label class="expand" for="c-37083797">[2 more]</label></div><br/><div class="children"><div class="content">The point that I think everyone else is missing is that C is actually hard to work with and write correctly. If your project is sophisticated enough that you can&#x27;t get by with basic tools, then maybe C isn&#x27;t the best language for your project.</div><br/><div id="37084385" class="c"><input type="checkbox" id="c-37084385" checked=""/><div class="controls bullet"><span class="by">dotnet00</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083797">parent</a><span>|</span><a href="#37084067">next</a><span>|</span><label class="collapse" for="c-37084385">[-]</label><label class="expand" for="c-37084385">[1 more]</label></div><br/><div class="children"><div class="content">I think this idea of &quot;basic tools&quot; is highly debatable, especially with developers who are young enough for heavy IDEs like visual studio to have been their intro to coding (or similarly for people who enjoy programming but aren&#x27;t so invested in the entire computer software stack to really care about knowing their environment particularly well).<p>Eg while I enjoy understanding all the layers of software in a computer and am perfectly comfortable with vim and a makefile (although I prefer vscode and cmake), most of the other developers I work with are just as competent with C, but can&#x27;t really function if they can&#x27;t use visual studio. To them visual studio is the basic tool and vim+make are advanced tools.</div><br/></div></div></div></div><div id="37084067" class="c"><input type="checkbox" id="c-37084067" checked=""/><div class="controls bullet"><span class="by">ryan-c</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082624">parent</a><span>|</span><a href="#37083797">prev</a><span>|</span><a href="#37082810">next</a><span>|</span><label class="collapse" for="c-37084067">[-]</label><label class="expand" for="c-37084067">[1 more]</label></div><br/><div class="children"><div class="content">The only intended implication was &quot;C is generally not appropriate for complex projects&quot;.<p>There are, of course, <i>always</i> exceptions.</div><br/></div></div><div id="37082810" class="c"><input type="checkbox" id="c-37082810" checked=""/><div class="controls bullet"><span class="by">isaacremuant</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082624">parent</a><span>|</span><a href="#37084067">prev</a><span>|</span><a href="#37083349">next</a><span>|</span><label class="collapse" for="c-37082810">[-]</label><label class="expand" for="c-37082810">[2 more]</label></div><br/><div class="children"><div class="content">Weird strawman. Those tools all run on terminals.  IDEs use tools that run on terminals.<p>Teams can use a combination of different IDEs and run the tools at different levels or their pipelines, which necessitate that they be automatable (and not GUI only).</div><br/><div id="37083491" class="c"><input type="checkbox" id="c-37083491" checked=""/><div class="controls bullet"><span class="by">circuit10</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082810">parent</a><span>|</span><a href="#37083349">next</a><span>|</span><label class="collapse" for="c-37083491">[-]</label><label class="expand" for="c-37083491">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re missing the point, they aren&#x27;t saying &quot;your development process should never involve a terminal&quot; but rather &quot;you don&#x27;t necessarily have to use this bare-bones setup which happens to be terminal based&quot;</div><br/></div></div></div></div></div></div><div id="37083349" class="c"><input type="checkbox" id="c-37083349" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#37082355">parent</a><span>|</span><a href="#37082624">prev</a><span>|</span><a href="#37082927">next</a><span>|</span><label class="collapse" for="c-37083349">[-]</label><label class="expand" for="c-37083349">[5 more]</label></div><br/><div class="children"><div class="content">...or even Notepad.<p>I write a lot of pure Win32 C, and I don&#x27;t even need a Makefile for the majority of my projects because they&#x27;re just compiled as a single file and quickly enough that I don&#x27;t bother with anything more than necessary.<p>IMHO the &quot;tool fetish&quot; that a lot of (mostly newer) programmers seem to have is an artifact of a mentality that favours complexity and novelty over simplicity and efficiency. They will waste tons of time and resources configuring and debugging (often with little understanding) huge complex monstrosities of &quot;development environments&quot;, and end up feeling more productive, but in reality aren&#x27;t.<p>This article just further confirms what I&#x27;d already expected with the word &quot;modern&quot;.</div><br/><div id="37083391" class="c"><input type="checkbox" id="c-37083391" checked=""/><div class="controls bullet"><span class="by">monsieurbanana</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083349">parent</a><span>|</span><a href="#37082927">next</a><span>|</span><label class="collapse" for="c-37083391">[-]</label><label class="expand" for="c-37083391">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll take the notepad bit as satire.<p>I think simplicity is underrated too, but I hope you&#x27;ll agree that your single c file use case is rather niche.</div><br/><div id="37084117" class="c"><input type="checkbox" id="c-37084117" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083391">parent</a><span>|</span><a href="#37083719">next</a><span>|</span><label class="collapse" for="c-37084117">[-]</label><label class="expand" for="c-37084117">[1 more]</label></div><br/><div class="children"><div class="content">For a lot of small and even medium-size C projects, one file is enough. IMHO having dozens of tiny files with only a few dozen lines each is an antipattern.</div><br/></div></div><div id="37083719" class="c"><input type="checkbox" id="c-37083719" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083391">parent</a><span>|</span><a href="#37084117">prev</a><span>|</span><a href="#37083632">next</a><span>|</span><label class="collapse" for="c-37083719">[-]</label><label class="expand" for="c-37083719">[1 more]</label></div><br/><div class="children"><div class="content">I wrote my first Java code in Notepad and compiled it from command.com (as Windows 9x still called it). It was... fine, I guess? For the era? Not what I would want to do but far from unmanageable.</div><br/></div></div><div id="37083632" class="c"><input type="checkbox" id="c-37083632" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083391">parent</a><span>|</span><a href="#37083719">prev</a><span>|</span><a href="#37082927">next</a><span>|</span><label class="collapse" for="c-37083632">[-]</label><label class="expand" for="c-37083632">[1 more]</label></div><br/><div class="children"><div class="content">and pure-Win32 is also niche</div><br/></div></div></div></div></div></div><div id="37082927" class="c"><input type="checkbox" id="c-37082927" checked=""/><div class="controls bullet"><span class="by">shortrounddev2</span><span>|</span><a href="#37082355">parent</a><span>|</span><a href="#37083349">prev</a><span>|</span><a href="#37082965">next</a><span>|</span><label class="collapse" for="c-37082927">[-]</label><label class="expand" for="c-37082927">[6 more]</label></div><br/><div class="children"><div class="content">I used to do that for years, and then I discovered gdb and IDE integrations with it (code blocks, codelite) and later visual studio. I have no idea why anyone would subject themselves to developing without breakpoints in 2023 other than to larp as an 80s MIT hacker</div><br/><div id="37082946" class="c"><input type="checkbox" id="c-37082946" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082927">parent</a><span>|</span><a href="#37084162">next</a><span>|</span><label class="collapse" for="c-37082946">[-]</label><label class="expand" for="c-37082946">[3 more]</label></div><br/><div class="children"><div class="content">I started writing in C with an IDE then realized much later on that I don&#x27;t really need breakpoints, I just log stuff. Whatever I&#x27;m testing often won&#x27;t easily work in the debugger (or won&#x27;t reproduce the bug there due to timing), and even when it does, it&#x27;s not significantly easier than logging.<p>Also, every new job I&#x27;ve had, I&#x27;ve watched my coworkers spend like a week trying to figure out how to make the IDE work with whatever environment, which then changes later... I just skip that.</div><br/><div id="37083341" class="c"><input type="checkbox" id="c-37083341" checked=""/><div class="controls bullet"><span class="by">uxp8u61q</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082946">parent</a><span>|</span><a href="#37083071">next</a><span>|</span><label class="collapse" for="c-37083341">[-]</label><label class="expand" for="c-37083341">[1 more]</label></div><br/><div class="children"><div class="content">Debuggers have logpoints as well as breakpoints. Learning to use a debugger grants you access to this kind of basic &quot;log-debugging&quot; with the option to use more advanced techniques (traditional breakpoints, break on value change, etc) at your fingertips.<p>&gt; Also, every new job I&#x27;ve had, I&#x27;ve watched my coworkers spend like a week trying to figure out how to make the IDE work with whatever environment, which then changes later... I just skip that.<p>A single week to achieve better productivity? That&#x27;s a sweet deal. It&#x27;s about as much time as you need to figure out how the work email works, learn how to get to the cafeteria from your desk quickly, and so on. It&#x27;s absurd to think that you&#x27;ll be 100% productive that first week anyway, so why not use the opportunity to familiarize yourself with the tooling as well?</div><br/></div></div><div id="37083071" class="c"><input type="checkbox" id="c-37083071" checked=""/><div class="controls bullet"><span class="by">shortrounddev2</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082946">parent</a><span>|</span><a href="#37083341">prev</a><span>|</span><a href="#37084162">next</a><span>|</span><label class="collapse" for="c-37083071">[-]</label><label class="expand" for="c-37083071">[1 more]</label></div><br/><div class="children"><div class="content">Personally with visual studio and vcpkg, I never have an issues with setting up the environment. Vcpkg in particular makes it easy to note have to do manual linking, and it handles x86 vs x64 automatically as well.</div><br/></div></div></div></div><div id="37084162" class="c"><input type="checkbox" id="c-37084162" checked=""/><div class="controls bullet"><span class="by">xdennis</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082927">parent</a><span>|</span><a href="#37082946">prev</a><span>|</span><a href="#37082965">next</a><span>|</span><label class="collapse" for="c-37084162">[-]</label><label class="expand" for="c-37084162">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s current year!<p>But in all seriousness. Using a debugger can be useful, and even though I&#x27;ve given it a try numerous times, I mostly avoid it because it doesn&#x27;t fit the way I think.<p>Debugging is about searching for the source of the problem. With print debugging I&#x27;m always leaving behind breadcrumbs which I can inspect all at once at the end. If I&#x27;m going down a wrong path I delete the wrong ones and add new ones until I find the issue.<p>With a debugger I have to mouse around, put breakpoints, run the code, inspect where I&#x27;m at, step through, decide that this breakpoint is useless, and have to have all this state in my mind. If I get lost, I have to start from scratch.<p>Print debugging matches my way of thinking much more.</div><br/><div id="37084540" class="c"><input type="checkbox" id="c-37084540" checked=""/><div class="controls bullet"><span class="by">SAI_Peregrinus</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37084162">parent</a><span>|</span><a href="#37082965">next</a><span>|</span><label class="collapse" for="c-37084540">[-]</label><label class="expand" for="c-37084540">[1 more]</label></div><br/><div class="children"><div class="content">Logpoints! They&#x27;re like breakpoints, but they don&#x27;t stop execution. And they don&#x27;t require whatever you&#x27;re writing C for to have any sort of console output. Of course you do need to have a debug port enabled, which often isn&#x27;t the case for production hardware so you get stuck printf debugging by blinking an LED and probing it with a logic analyzer. Royal PITA.</div><br/></div></div></div></div></div></div><div id="37082965" class="c"><input type="checkbox" id="c-37082965" checked=""/><div class="controls bullet"><span class="by">tesseract</span><span>|</span><a href="#37082355">parent</a><span>|</span><a href="#37082927">prev</a><span>|</span><a href="#37083697">next</a><span>|</span><label class="collapse" for="c-37082965">[-]</label><label class="expand" for="c-37082965">[4 more]</label></div><br/><div class="children"><div class="content">A big usecase for C is embedded systems projects where wrangling cross-compilers, debug dongles, etc. can become a big headache especially when trying to keep multiple developers&#x27; local toolchains in sync or when managing multiple projects with different requirements for the development environment.</div><br/><div id="37083305" class="c"><input type="checkbox" id="c-37083305" checked=""/><div class="controls bullet"><span class="by">thenickdude</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082965">parent</a><span>|</span><a href="#37083390">next</a><span>|</span><label class="collapse" for="c-37083305">[-]</label><label class="expand" for="c-37083305">[1 more]</label></div><br/><div class="children"><div class="content">PlatformIO is a dream for this, running build on a project automatically downloads the required toolchains for the target and orchestrates the build process for you.</div><br/></div></div><div id="37083390" class="c"><input type="checkbox" id="c-37083390" checked=""/><div class="controls bullet"><span class="by">5ADBEEF</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082965">parent</a><span>|</span><a href="#37083305">prev</a><span>|</span><a href="#37083697">next</a><span>|</span><label class="collapse" for="c-37083390">[-]</label><label class="expand" for="c-37083390">[2 more]</label></div><br/><div class="children"><div class="content">For me, it&#x27;s Zephyr</div><br/><div id="37083647" class="c"><input type="checkbox" id="c-37083647" checked=""/><div class="controls bullet"><span class="by">sitzkrieg</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083390">parent</a><span>|</span><a href="#37083697">next</a><span>|</span><label class="collapse" for="c-37083647">[-]</label><label class="expand" for="c-37083647">[1 more]</label></div><br/><div class="children"><div class="content">im a bit of a rtos baby but (mostly in ti&#x27;s really nice rtos), i&#x27;d throw my hat in for Zephyr + nordics stuff (i think?) for all the build automagic<p>but i also think &#x27;plain&#x27; ol (now amazon) freertos is pretty cool still</div><br/></div></div></div></div></div></div><div id="37083697" class="c"><input type="checkbox" id="c-37083697" checked=""/><div class="controls bullet"><span class="by">marmakoide</span><span>|</span><a href="#37082355">parent</a><span>|</span><a href="#37082965">prev</a><span>|</span><a href="#37082647">next</a><span>|</span><label class="collapse" for="c-37083697">[-]</label><label class="expand" for="c-37083697">[2 more]</label></div><br/><div class="children"><div class="content">There are small projects, hobby projects, and large industrial projects. For hobby projects in C, I am myself very happy with a shell, make, a text editor, git and valgrind.<p>Imagine developing an embedded device for medical or aerospace hardware : you are going to provide lost of effort into testing. You are going to work with teams of people with varied abilities and experience : it&#x27;s going to get a little bureaucratic, there are going to have rules and guidelines. Enforcing those with tools remove part of the friction, if done well.</div><br/><div id="37083941" class="c"><input type="checkbox" id="c-37083941" checked=""/><div class="controls bullet"><span class="by">nvy</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083697">parent</a><span>|</span><a href="#37082647">next</a><span>|</span><label class="collapse" for="c-37083941">[-]</label><label class="expand" for="c-37083941">[1 more]</label></div><br/><div class="children"><div class="content">Avionics code isn&#x27;t written by hand any more.  We (society) can&#x27;t write sufficiently reliable C such that pilots and passengers can rely on it.  Writing C by hand these days is hubris, in my opinion.<p>Most avionics these days are done in Simulink, and then you hit the Autocode button.</div><br/></div></div></div></div><div id="37082647" class="c"><input type="checkbox" id="c-37082647" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#37082355">parent</a><span>|</span><a href="#37083697">prev</a><span>|</span><a href="#37085804">next</a><span>|</span><label class="collapse" for="c-37082647">[-]</label><label class="expand" for="c-37082647">[6 more]</label></div><br/><div class="children"><div class="content">A dockerfile gives a clean, repeatable build environment. If there is ever a toolchain that needed that, it&#x27;s native toolchains like gcc and clang.</div><br/><div id="37083085" class="c"><input type="checkbox" id="c-37083085" checked=""/><div class="controls bullet"><span class="by">seabass-labrax</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082647">parent</a><span>|</span><a href="#37082966">next</a><span>|</span><label class="collapse" for="c-37083085">[-]</label><label class="expand" for="c-37083085">[3 more]</label></div><br/><div class="children"><div class="content">That reads almost like a disparagement of GCC&#x2F;Clang; the reality is you can just build on pretty much any host system directly and it will work. Having clean and repeatable builds is extremely useful, and Docker is a reasonable way to do that, but that shouldn&#x27;t mask the importance of understanding the native runtime dependencies of the program once used outside of that one container. A concrete example of that: don&#x27;t compile a C program in an Alpine Linux Docker image with dynamic linking, or it you won&#x27;t be able to run the resultant binary on a RHEL machine. This is contrast to languages which run atop a virtual machine or interpreter, where the details of the <i>build</i> environment rarely matter on the <i>runtime</i> machine.</div><br/><div id="37084892" class="c"><input type="checkbox" id="c-37084892" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083085">parent</a><span>|</span><a href="#37083181">next</a><span>|</span><label class="collapse" for="c-37084892">[-]</label><label class="expand" for="c-37084892">[1 more]</label></div><br/><div class="children"><div class="content">If your code is using a version of GCC that&#x27;s many years old, then the compiler will have changed sufficiently that code can break.</div><br/></div></div><div id="37083181" class="c"><input type="checkbox" id="c-37083181" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083085">parent</a><span>|</span><a href="#37084892">prev</a><span>|</span><a href="#37082966">next</a><span>|</span><label class="collapse" for="c-37083181">[-]</label><label class="expand" for="c-37083181">[1 more]</label></div><br/><div class="children"><div class="content">Its a disparagement at the fact they&#x27;re dated, rather than the software itself.<p>GCC searches by default in &#x2F;usr&#x2F;include and friends, (and a similar set of paths for library paths), meaning that one random library you downloaded 11 years ago is now perpetually on your search path.</div><br/></div></div></div></div><div id="37082966" class="c"><input type="checkbox" id="c-37082966" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082647">parent</a><span>|</span><a href="#37083085">prev</a><span>|</span><a href="#37085804">next</a><span>|</span><label class="collapse" for="c-37082966">[-]</label><label class="expand" for="c-37082966">[2 more]</label></div><br/><div class="children"><div class="content">Exactly. The one dev environment I can name where a Dockerfile really isn&#x27;t useful is also the highest-level, NodeJS.</div><br/><div id="37083187" class="c"><input type="checkbox" id="c-37083187" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082966">parent</a><span>|</span><a href="#37085804">next</a><span>|</span><label class="collapse" for="c-37083187">[-]</label><label class="expand" for="c-37083187">[1 more]</label></div><br/><div class="children"><div class="content">I write a decent amount of go, and it&#x27;s not wildly useful there either but I still use them as the rest of the tooling is good enough that it works for me.</div><br/></div></div></div></div></div></div><div id="37085804" class="c"><input type="checkbox" id="c-37085804" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#37082355">parent</a><span>|</span><a href="#37082647">prev</a><span>|</span><a href="#37082715">next</a><span>|</span><label class="collapse" for="c-37085804">[-]</label><label class="expand" for="c-37085804">[1 more]</label></div><br/><div class="children"><div class="content">IMHO any proposed solution (for any programming language) should also include a step-debugger that&#x27;s directly integrated into the edit-compile-test workflow, otherwise people don&#x27;t know what they are missing out on.</div><br/></div></div><div id="37082715" class="c"><input type="checkbox" id="c-37082715" checked=""/><div class="controls bullet"><span class="by">xaduha</span><span>|</span><a href="#37082355">parent</a><span>|</span><a href="#37085804">prev</a><span>|</span><a href="#37082556">next</a><span>|</span><label class="collapse" for="c-37082715">[-]</label><label class="expand" for="c-37082715">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If they are not fine, then C is probably not the right language for the project.<p>It&#x27;s for C&#x2F;C++ as author says, not just for C. And even if you&#x27;re using Qt and write mostly QML you still need some C++ and it&#x27;s much easier with code completion. I&#x27;d rather use VSCode than Qt Creator for that and I&#x27;m certainly not going back to vim.</div><br/></div></div><div id="37082556" class="c"><input type="checkbox" id="c-37082556" checked=""/><div class="controls bullet"><span class="by">sfpotter</span><span>|</span><a href="#37082355">parent</a><span>|</span><a href="#37082715">prev</a><span>|</span><a href="#37082677">next</a><span>|</span><label class="collapse" for="c-37082556">[-]</label><label class="expand" for="c-37082556">[2 more]</label></div><br/><div class="children"><div class="content">Strongly recommend using meson or CMake instead of Make unless you have a very specific reason you can’t use one of these tools.</div><br/><div id="37082685" class="c"><input type="checkbox" id="c-37082685" checked=""/><div class="controls bullet"><span class="by">jjgreen</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082556">parent</a><span>|</span><a href="#37082677">next</a><span>|</span><label class="collapse" for="c-37082685">[-]</label><label class="expand" for="c-37082685">[1 more]</label></div><br/><div class="children"><div class="content">I once had to compile cmake from source (the cmake version of something I needed to build was lower that the OS version of cmake).  Not a fun afternoon.</div><br/></div></div></div></div><div id="37085644" class="c"><input type="checkbox" id="c-37085644" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37082355">parent</a><span>|</span><a href="#37082677">prev</a><span>|</span><a href="#37082872">next</a><span>|</span><label class="collapse" for="c-37085644">[-]</label><label class="expand" for="c-37085644">[2 more]</label></div><br/><div class="children"><div class="content">A the macho man attitude, why are they writing C in first place.<p>Real developers only code in Assembly with ed.</div><br/><div id="37085812" class="c"><input type="checkbox" id="c-37085812" checked=""/><div class="controls bullet"><span class="by">teddyh</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37085644">parent</a><span>|</span><a href="#37082872">next</a><span>|</span><label class="collapse" for="c-37085812">[-]</label><label class="expand" for="c-37085812">[1 more]</label></div><br/><div class="children"><div class="content">&lt;<a href="https:&#x2F;&#x2F;xkcd.com&#x2F;378&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;xkcd.com&#x2F;378&#x2F;</a>&gt;</div><br/></div></div></div></div><div id="37082872" class="c"><input type="checkbox" id="c-37082872" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#37082355">parent</a><span>|</span><a href="#37085644">prev</a><span>|</span><a href="#37082936">next</a><span>|</span><label class="collapse" for="c-37082872">[-]</label><label class="expand" for="c-37082872">[17 more]</label></div><br/><div class="children"><div class="content">I write a bunch of C for various projects of mine and i do it in an editor with some C understanding (it varies by which, but the latest combo is Kate with a Clang-based LSP, however i&#x27;ve also used &quot;plain&quot; text editors with barely if at all any understanding like Notepad++ and Geany, both of which give you at best word completion with words they picked up from the buffer without actually knowing what they mean).<p>I also write Free Pascal using Lazarus, an IDE which actually understands the language at a deep level.<p>The experience writing the latter is <i>way</i> *WAY* better than the former and my opinion to that isn&#x27;t &quot;just write more in Free Pascal&quot; but &quot;i want an IDE for C that is at least as good as Lazarus is for Free Pascal&quot;.<p>I want a C IDE that, among others:<p>1. Can understand the code so that when i, e.g., want to rename the identifier &quot;foo&quot; it doesn&#x27;t try to rename it as a keyword but knows if it refers to a local variable, global variable or struct member and only update references to that.<p>2. Can understand the code so that if i use a symbol defined in a header file that the current module doesn&#x27;t include by itself it can put it in the includes section automatically (or at least ask me to) instead of waiting for the compiler to fail. If there is some conflict (e.g. because the symbol definition depends on macros or whatever) it should be able to understand that.<p>3. Can understand the code so that it can move structs, functions, etc around in modules and update header files and their uses in other modules automatically.<p>4. Can understand the code so that it can convert a struct defined in a header file to an opaque struct and vice versa, for the former being able to tell me which existing code would break and offer fixes (e.g. automatically creating accessor functions for the members).<p>5. Can understand the code so that it can expand macros in place visually, allow me to edit the macros expanded in-place while actually modifying the header file (or wherever the macro is defined) and also quickly tell me where the macro is used in other places.<p>6. Can understand the code so that it can convert code to functions, expand functions inline (with any local variables being placed at a decent position and any conflicts handled - it can ask for example if it sees the inline code to use &quot;for (i=1; i&lt;10;&quot; and the existing code also has a &quot;int i&quot; if it should reuse the &quot;int i&quot; or replace it with heuristics that provide decent defaults), add&#x2F;remove arguments (with automatic updates wherever they are used), etc.<p>7. Can understand the code so that one can create queries like &quot;replace all string literals to non-static functions whose name matches the &#x27;^foo_.*$&#x27; regex with calls to macro &#x27;TXT&#x27; and the same string literal as the parameter to macro&quot;.<p>8. Has a debugger that works with all the basics (breakpoints, step in&#x2F;through&#x2F;out, watches, etc) and...<p>9. The debugger can modify a variable while the program is running.<p>10. The debugger can make function calls while the program is running.<p>11. The debugger can modify a function while the program is running (any new calls are done to that function).<p>12. The debugger can watch data over time and be able to display values in various means like various graph types.<p>13. The debugger can tell you where (in code) some use-after-free was originally allocated and then where it was freed and where it was used, all with nicely shown arrows, hyperlinks and graphics directly inside the editor instead of you having to manually parse (in your head) some callstack. Similar for other types of errors like accessing invalid pointers, array data out of range (should tell you both the range and the accessed index where that can be statically inferred), etc.<p>14. The debugger can put conditional breakpoints which:<p>14a. Can call functions defined in the program.<p>14b. Can check if the breakpoint comes from a specific callstack (e.g. break if function &quot;foo&quot; is called from &quot;bar&quot; but not from &quot;baz&quot;).<p>14c. Can access local variables and arguments up the callstack (obviously the breakpoint will only break where that is possible).<p>15. There is a profiler that works and...<p>16. The profiler can create call-based profiles (think gprof) and statistics-based profiles (think perf).<p>17. The profiler can record the full callstack instead of just the function name.<p>18. The profiler can create full call diagrams (see Luke Stackwalker[0] as an example) as well as flamegraphs (see some perl script for perf i don&#x27;t remember).<p>19. The profiler can keep track not only <i>where* but also </i>when* a sample was taken so it can create profile timelines. Actually just have it do everything i had a profiler i wrote some time ago for Free Pascal[1], including be able to be instrumented by the running program, filter via thread, call stack depth, etc.<p>20. The profiler can call functions in the profiled program to create additional profile (e.g. if you want to count how many files are opened or how many rays your raytracer is casting or whatever so you can use the full profiler functionality instead of hacking up your own)<p>21. There is a static analysis tool that works and...<p>22. ...works like whatever Xcode&#x27;s integration with Clang&#x27;s analyzer is, i do not have much experience with those but i remember using it a couple of times years ago and thinking it was neat. I haven&#x27;t seen any other graphical integration of a code analysis tool, pretty much every other analyzer feels like compiler warnings++. More of the graphical approach and less of the warnings++ approach please.<p>23. There is some form of project management &#x2F; build tool &#x2F; whatever that the IDE uses and...<p>24. The IDE can let you setup various &quot;configurations&quot; for build options (including preprocessor defines, which files&#x2F;objects&#x2F;libraries are to be included, etc) that can be mixed and matched at will (e.g. a &quot;lightweight&quot; and &quot;full&quot; configuration set could be mixed with a &quot;win32&quot; and &quot;linux&quot; configuration set with the latter relying on the &quot;unix&quot; configuration and none of those would need you to duplicate any information).<p>25. The IDE can know about libraries, be able to locate them as well as place them in appropriate locations when you are building a library. Libraries should be able to be built as both statically and dynamically linked if that is needed. If a library A relies on another library B and a program uses library A it should not need to also specify library B too - in the exceptional case where that is needed (e.g. there are alternative versions of library B) it should allow that but it should not be necessary.<p>26. Setting up the above should not need to be done via arcane text files but via a nice GUI that doesn&#x27;t hate the user - e.g. using a library should not need you to type it&#x27;s name but allow you to check next to its name in a listbox with checkboxes (with name filtering and categories). It should also know about different system libraries for the same thing (e.g. OpenGL in Windows, Linux and Mac is accessed via different ways). This should be configurable, not hardcoded - a custom library should also be able to use that functionality. Note that all of this can be stored in text files (e.g. for easier VCS support) but not needed.<p>27. More of a #26b but i think it deserves its own point: in addition the IDE should have deep knowledge of what a library offers and like #2 if it knows a symbol being offered by a library it should automatically add it to your project&#x27;s requirements.<p>28. Again more of a #27b but also a #2b: it should be able to clean up any unused stuff (either automatic or explicitly). In total i should, e.g, be able to use OpenGL by typing &quot;gl&quot;, pressing the auto-complete key (ctrl+space or whatever) and have the IDE suggest all the &quot;gl&quot; prefixed functions like &quot;glClear&quot;, then once i select &quot;glClear&quot; (or whatever), the IDE adds the #include &lt;GL&#x2F;gl.h&gt; header and the libgl library in the dependencies. If i press Ctrl-Z to undo that, the header files and library dependencies (if added) will be removed. If i press Ctrl+S to save or some other key to cleanup the project (depending on the configuration), any unused headers and libraries should be removed.<p>I could write for more but basically i&#x27;d like an IDE (i haven&#x27;t touched topics like VCS support and how i&#x27;d like to be able to see <i>and use</i> different version of the code from inside the IDE - like e.g. go back in time to a different function while the debugger is running - or anything that has to do with GUIs) that is smart and helps me get rid of all the manual drudge,<p>(also FWIW little of the above is provided by Lazarus and i&#x27;d also like Lazarus to do all that where it makes sense but it still does more than pretty much any C IDE i&#x27;ve used)<p>[0] <a href="https:&#x2F;&#x2F;lukestackwalker.sourceforge.net&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;lukestackwalker.sourceforge.net&#x2F;</a><p>[1] <a href="http:&#x2F;&#x2F;runtimeterror.com&#x2F;tools&#x2F;fpwprof&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;runtimeterror.com&#x2F;tools&#x2F;fpwprof&#x2F;</a></div><br/><div id="37084091" class="c"><input type="checkbox" id="c-37084091" checked=""/><div class="controls bullet"><span class="by">harry8</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082872">parent</a><span>|</span><a href="#37083451">next</a><span>|</span><label class="collapse" for="c-37084091">[-]</label><label class="expand" for="c-37084091">[6 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;projects.eclipse.org&#x2F;projects&#x2F;tools.cdt" rel="nofollow noreferrer">https:&#x2F;&#x2F;projects.eclipse.org&#x2F;projects&#x2F;tools.cdt</a><p>Really. I&#x27;m not kidding. It&#x27;s all there. Not for everybody but &#x2F;clearly&#x2F; very much for you. (Unless you move the incredibly complex goalpost you&#x27;ve set up here).<p>It has a learning curve to configure and to use but if the above 28 is what you want as you say you &#x2F;can&#x2F; have them all.<p>All of them. For real. Working. It&#x27;s on you now.<p>29. vim or emacs keybindings if you want that.</div><br/><div id="37085296" class="c"><input type="checkbox" id="c-37085296" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37084091">parent</a><span>|</span><a href="#37083451">next</a><span>|</span><label class="collapse" for="c-37085296">[-]</label><label class="expand" for="c-37085296">[5 more]</label></div><br/><div class="children"><div class="content">All of them? Including things like the modify a function while the application is running, either directly or using an old version from VCS and things like know all the available libraries, the symbols they export and what header files to include to use them and then be able to do that &quot;type gl, press ctrl+space (or whatever), have glClear (or whatever) show up and have the IDE automatically add #include &lt;GL&#x2F;gl.h&gt; at the top and &#x27;libgl&#x27; as a required library on Linux, &#x27;opengl32&#x27; on Windows and &#x27;OpenGL framework&#x27; on Mac OS X with Ctrl+Z undoing all that stuff&quot;?<p>If so i&#x27;d be impressed - and TBH ~17 years ago i did use Eclipse CDE and found it superior for C and even C++ code compared to what i saw people praise MSVC for (though MSVC&#x27;s debugger was better than the GDB front-end functionality Eclipse CDE provided), so i don&#x27;t think it is unlikely. I do remember it having some neat integration with Trac back then too. I mainly stopped using it because the computer i had at the time struggled to run both Eclipse and Mozilla at the same time :-P. But ~17 years ago i always praised it with the only annoyance (resource usage aside) being that weird &quot;workspace&quot; approach, but that was minor.<p>I didn&#x27;t think much about it because it seemed to have fallen out of fashion since then so i thought it is just limping along.<p>I think i&#x27;ll be trying it out then :-) perhaps it is time to go back to Eclipse CDT if that is the case.<p>EDIT: eh, tried it, not impressed. First of all Eclipse crashes or hangs almost every time i try to edit the settings.<p>Then i tried to make a test library, &quot;librola&quot; (random name) to be used by a program &quot;rolathing&quot;. First i made the library using the managed C project with the &quot;Linux GCC&quot; toolchain that was already available. Typed some methods &quot;int rola_init&quot; (dummy, sets some static initialized variable to 1), &quot;int rola_gimme&quot; (returns 42) and &quot;void rola_shutdown&quot; (sets the initialized variable to 0).<p>1. I forgot to mention it in the above but Lazarus and other IDEs already have this anyway and it seems Eclipse CDT also has it, except it doesn&#x27;t work: i tried to have the IDE generate the bodies for these functions in a C file (that didn&#x27;t exist yet) using the &quot;Implement methods&quot; command that seemed the most appropriate (and i couldn&#x27;t find anything else anyway) but that didn&#x27;t work. I thought it was because there wasn&#x27;t a C file so i made an empty one with the same name as the header file but again it didn&#x27;t work - even after adding an #include in the C file for the header file it didn&#x27;t seem to match the two. So i typed these by hand even though i believe it should either use the C file with the same name as the H file (a common use) or at least ask me.<p>2. I made a C program with managed C project and added a new &quot;main.c&quot; file to it. I typed &quot;rol&quot; and pressed ctrl+space to see any suggestions and there were none, so it basically failed #2 and #28 above. I typed the code manually, used printf to print out the return value of &quot;rola_gimme&quot; and even after saving there were no errors or warnings at all even though the C file had no include files at all.<p>3. Tried to compile and as expected, it failed. There were no quick-fixes or anything else i could do from inside the IDE - there was an &quot;info&quot; message that i should include stdio.h to get the printf definition but the IDE wouldn&#x27;t help there by adding it itself, i had to manually type the code. And TBH most likely that message came from the compiler and the IDE was oblivious to it anyway. Obviously no message about which file to include to get the rola_init, rola_gimme and rola_shutdown definitions, let alone doing those for me.<p>I lost interest at that point because it not only was unstable but also failed at the first thing i tried that would show the IDE really understood the source code. Note that this whole &quot;automatically add header files&quot; isn&#x27;t even something i came up with, i remember a trial version of C++ Builder i tried years ago to do that and while i didn&#x27;t check to see if it only does it for the header files that come with it or also for your own libraries, the latter would be an obvious thing to do anyway as the library was already part of the workspace and thus known to the IDE - and Eclipse didn&#x27;t do either anyway.<p>But just in case, i tried to at least try the debugger so i thought to add the reference manually - which i did but Eclipse crashed every time i pressed the &quot;Apply and close&quot; button. However restarting it seemed to have the setting applied anyway so i could at least try the debugger. And at the end i couldn&#x27;t figure out how to convince Eclipse to use the shared library project next to the program project, no matter what i tried (i&#x27;m sure there is a way but IMO all i should have to do is, as i wrote in #26, check the library&#x27;s name in a listbox with all the available libraries - and FWIW there was such a thing but it did absolutely nothing, Eclipse only started realizing there is a library somewhere when i started adding in paths, etc, manually but i failed to make it build).<p>So at least i wrote a &quot;int foo() { return 42; }&quot; (in more than one line :-P) in main.c and then have an endless loop in &quot;main&quot; and run the program under the debugger. The program wrote a bunch of &quot;42&quot;s in the stdout so i put a breakpoint in &quot;return 42;&quot; and modified it to &quot;return 48;&quot; - then continued and... nothing happened, it kept outputing &quot;42&quot;. I tried to rebuild the &quot;current source file&quot; and even &quot;rebuild all&quot; but it didn&#x27;t change, i had to restart the program, thus failing (as far as i can tell) #11.<p>On a semi-positive side i made a &quot;int lala(int x, int y) { return x*y; }&quot; and the debugger was able to run this function, but then when i tried it with something a little more practical like implementing a very simple strlen &quot;int lala(char* s){ int l = 0; for (;*s;++s,++l); return l; }&quot; it failed with some weird errors.<p>So, eh, i don&#x27;t think Eclipse CDT is it :-P.</div><br/><div id="37085530" class="c"><input type="checkbox" id="c-37085530" checked=""/><div class="controls bullet"><span class="by">harry8</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37085296">parent</a><span>|</span><a href="#37083451">next</a><span>|</span><label class="collapse" for="c-37085530">[-]</label><label class="expand" for="c-37085530">[4 more]</label></div><br/><div class="children"><div class="content">Well I missed that. No you can&#x27;t modify running code in C and hope it&#x27;s going to end well unless your C program is carefully designed to allow that.<p>You&#x27;ll have to set paths on the installation or project so it knows where the relevant libraries and headers are. You won&#x27;t configure it all correctly in the first week.<p>If you do give it a go, use a makefile project. If you&#x27;re using something else to build, just have the call to that in the Makefile and nothing much else. Maybe it does cmake etc now? Haven&#x27;t tried. I only use it occasionally nowadays. Brilliant for any refactor.</div><br/><div id="37085622" class="c"><input type="checkbox" id="c-37085622" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37085530">parent</a><span>|</span><a href="#37083451">next</a><span>|</span><label class="collapse" for="c-37085622">[-]</label><label class="expand" for="c-37085622">[3 more]</label></div><br/><div class="children"><div class="content">Check my edit, i did try things and didn&#x27;t work out as i described in my post.</div><br/><div id="37085712" class="c"><input type="checkbox" id="c-37085712" checked=""/><div class="controls bullet"><span class="by">harry8</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37085622">parent</a><span>|</span><a href="#37083451">next</a><span>|</span><label class="collapse" for="c-37085712">[-]</label><label class="expand" for="c-37085712">[2 more]</label></div><br/><div class="children"><div class="content">You have to want it to succeed and do some work to make it function the way you want. It does work if you care to put some time into it when you&#x27;re &#x2F;learning&#x2F; how it all works. I did, works great for me but isn&#x27;t my nirvana. Just another useful tool.<p>&gt;So, eh, i don&#x27;t think Eclipse CDT is it :-P.<p>Don&#x27;t confuse, &quot;I didn&#x27;t get it to work first time with very little effort&quot; &quot;does not work&quot; Also note that like any complex tool, once you&#x27;ve worked it out, which takes time, you don&#x27;t have to do that again. Like the people who say vi is garbage because you can&#x27;t quit.<p>If you don&#x27;t spend the time and give up early, that&#x27;s fine too and shows you how much you do or don&#x27;t want these things and &#x2F;any&#x2F; answer there is by definition correct.<p>Edit: Editing a post above a response with wholly new info is a pain, don&#x27;t do that. Just hit reply.</div><br/><div id="37085890" class="c"><input type="checkbox" id="c-37085890" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37085712">parent</a><span>|</span><a href="#37083451">next</a><span>|</span><label class="collapse" for="c-37085890">[-]</label><label class="expand" for="c-37085890">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Don&#x27;t confuse, &quot;I didn&#x27;t get it to work first time with very little effort&quot; &quot;does not work&quot; Also note that like any complex tool, once you&#x27;ve worked it out, which takes time, you don&#x27;t have to do that again.<p>I don&#x27;t confuse the two, the program didn&#x27;t do what i explicitly wrote in my post. If you think it can do what i asked, please explain how, because right now from what i can see it fails to do what i want from it. I didn&#x27;t try everything i mentioned because it failed at pretty much everything i tried from the very first thing, so it didn&#x27;t give me any confidence to keep on trying.<p>Also you seem to misunderstand something important even from my initial post: almost everything i wrote can be done by stringing together various tools and&#x2F;or have various workaround, even the &quot;modify code while it runs&quot; could be done by using one of the libraries or tools mentioned elsewhere.<p>But the point is having the IDE actually do all that in a single place and with <i>good UX</i> (for example i didn&#x27;t mentioned the part about checking a library&#x27;s name in a listbox of libraries in a project&#x27;s settings for fun, i mentioned because i expect at least that sort of user experience and convenience for the user! Eclipse CDE fails at that part because it needs all filling all sorts of forms in various places to see the library - my requirement wont be met by ignoring the requirement, the entire point of it was to request good user experience).<p>It is all about having a good user experience, if the program fails at that, it fails at the core of what i asked.<p>&gt; Edit: Editing a post above a response with wholly new info is a pain, don&#x27;t do that. Just hit reply.<p>When i edited the post there wasn&#x27;t any reply, you replied while i was typing the edit.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37083451" class="c"><input type="checkbox" id="c-37083451" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082872">parent</a><span>|</span><a href="#37084091">prev</a><span>|</span><a href="#37083485">next</a><span>|</span><label class="collapse" for="c-37083451">[-]</label><label class="expand" for="c-37083451">[1 more]</label></div><br/><div class="children"><div class="content">Your list got long so I did not read it all.<p>I wrote some simple C a while ago and my go to IDE (which ostensibly says it supports C&#x2F;C++ out of the box) wasn’t working, and since this was just a dabble, I was really not interested in fighting the IDE.<p>And, mind, I haven’t touched C in 20 years.<p>So I fired up Xcode. And, boy, that was easy. For my silly thing, I fat fingered and left thumbed my way to success.<p>No doubt Xcode has its critics and limits, but for my 3 hour project, I got to focus on my code and not the IDE.<p>I have another, more substantial pure C, not Mac specific, project I’m thinking of starting, and I’ll go with Xcode until it fails me.</div><br/></div></div><div id="37083485" class="c"><input type="checkbox" id="c-37083485" checked=""/><div class="controls bullet"><span class="by">kvemkon</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082872">parent</a><span>|</span><a href="#37083451">prev</a><span>|</span><a href="#37082952">next</a><span>|</span><label class="collapse" for="c-37083485">[-]</label><label class="expand" for="c-37083485">[2 more]</label></div><br/><div class="children"><div class="content">&gt; 9. The debugger can modify a variable while the program is running.<p>&gt; 11. The debugger can modify a function while the program is running (any new calls are done to that function).<p>Another words: hot code reloading &#x2F; swapping [1].<p>And I would add:<p>&gt; You record a failure once, then debug the recording, deterministically, as many times as you want. The same execution is replayed every time. [2]<p>[1] e.g. <a href="https:&#x2F;&#x2F;github.com&#x2F;ddovod&#x2F;jet-live">https:&#x2F;&#x2F;github.com&#x2F;ddovod&#x2F;jet-live</a>, <a href="https:&#x2F;&#x2F;github.com&#x2F;crosire&#x2F;blink">https:&#x2F;&#x2F;github.com&#x2F;crosire&#x2F;blink</a>, <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;68">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;68</a><p>[2] <a href="https:&#x2F;&#x2F;rr-project.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;rr-project.org&#x2F;</a></div><br/><div id="37085261" class="c"><input type="checkbox" id="c-37085261" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083485">parent</a><span>|</span><a href="#37082952">next</a><span>|</span><label class="collapse" for="c-37085261">[-]</label><label class="expand" for="c-37085261">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Another words: hot code reloading &#x2F; swapping [1].<p>Indeed, though without the use of external libraries, be for C and integrated seamlessly into the IDE - and it needs to work on Linux since that is what i&#x27;m using :-) (i&#x27;ve used MSVC&#x27;s edit-and-run or whatever is called at the past though it was kinda finicky if it worked or not).</div><br/></div></div></div></div><div id="37082952" class="c"><input type="checkbox" id="c-37082952" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082872">parent</a><span>|</span><a href="#37083485">prev</a><span>|</span><a href="#37082936">next</a><span>|</span><label class="collapse" for="c-37082952">[-]</label><label class="expand" for="c-37082952">[7 more]</label></div><br/><div class="children"><div class="content">You seem to know what you want. Have you actively looked for an IDE to use with C? Why don&#x27;t you think any of the available options is better than your current setup?</div><br/><div id="37083097" class="c"><input type="checkbox" id="c-37083097" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082952">parent</a><span>|</span><a href="#37082936">next</a><span>|</span><label class="collapse" for="c-37083097">[-]</label><label class="expand" for="c-37083097">[6 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know of any IDE that provides even half of what i want TBH.<p>On Linux (which is my main OS these days) pretty much all options involve a text editor with some plugin&#x2F;addon to somehow understand C plus the ability to call a makefile or some other command. Of all those Kate (KDE&#x27;s &quot;advanced&quot; text editor)  with an LSP plugin and a Clang-based LSP seems to be good enough.<p>Though it is really more of a &quot;least bad&quot; than &quot;actually good&quot; situation.</div><br/><div id="37083944" class="c"><input type="checkbox" id="c-37083944" checked=""/><div class="controls bullet"><span class="by">ftaghn</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083097">parent</a><span>|</span><a href="#37083833">next</a><span>|</span><label class="collapse" for="c-37083944">[-]</label><label class="expand" for="c-37083944">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t know of any IDE that provides even half of what i want TBH.<p>&gt; On Linux (which is my main OS these days) pretty much all options involve a text editor<p>You obviously haven&#x27;t looked hard enough.
CLion fulfills a decent amount of what you&#x27;re looking for.
<a href="https:&#x2F;&#x2F;www.jetbrains.com&#x2F;clion&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.jetbrains.com&#x2F;clion&#x2F;</a><p>A lot more limited, but still much more capable as an IDE than text editors is KDevelop, for example your request here :<p>&gt; (i haven&#x27;t touched topics like VCS support and how i&#x27;d like to be able to see and use different version of the code from inside the IDE - like e.g. go back in time to a different function while the debugger is running - or anything that has to do with GUIs)<p><a href="https:&#x2F;&#x2F;kdevelop.org&#x2F;features&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;kdevelop.org&#x2F;features&#x2F;</a><p>&gt; An especially useful feature is the Annotate border, which shows who last changed a line and when. Showing the diff which introduced this change is just one click away!<p>Also example snippet of the debugging integration :<p>&gt; You can also hover the mouse over a symbol in your code, e.g. a variable; KDevelop will then show the current value of that symbol and offer to stop the program during execution the next time this variable&#x27;s value changes.<p><a href="https:&#x2F;&#x2F;docs.kde.org&#x2F;trunk5&#x2F;en&#x2F;kdevelop&#x2F;kdevelop&#x2F;debugging-programs-in-kdevelop.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.kde.org&#x2F;trunk5&#x2F;en&#x2F;kdevelop&#x2F;kdevelop&#x2F;debugging-p...</a></div><br/><div id="37085224" class="c"><input type="checkbox" id="c-37085224" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083944">parent</a><span>|</span><a href="#37083833">next</a><span>|</span><label class="collapse" for="c-37085224">[-]</label><label class="expand" for="c-37085224">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You obviously haven&#x27;t looked hard enough. CLion fulfills a decent amount of what you&#x27;re looking for. <a href="https:&#x2F;&#x2F;www.jetbrains.com&#x2F;clion&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.jetbrains.com&#x2F;clion&#x2F;</a><p>CLion has the problem of being a proprietary program that requires online validation, which is a big hard no for me.<p>Also IMO the fact that you point out KDevelop being able to show a per-line commit and the current value of a variable, both being among the minimum you can expect from an IDE tell me you didn&#x27;t read what i wrote that i wanted, so by extension i doubt CLion also does anything close to what i wrote.<p>I don&#x27;t &quot;just&quot; expect &quot;some&quot; debugger integration or &quot;some&quot; VCS integration, i explicitly wrote things like the debugger being able to call a function in the running program or modify a function while the program is called or being able to replace the current function with an older version of the function taken out of VCS. Among a ton of other things.<p>What you show KDevelop to do aren&#x27;t anything special, even non-IDE &quot;programmers&#x27; text editors&quot; can do them.</div><br/><div id="37085964" class="c"><input type="checkbox" id="c-37085964" checked=""/><div class="controls bullet"><span class="by">trinix912</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37085224">parent</a><span>|</span><a href="#37083833">next</a><span>|</span><label class="collapse" for="c-37085964">[-]</label><label class="expand" for="c-37085964">[1 more]</label></div><br/><div class="children"><div class="content">You can still try CLion (the trial version) and see if it’s what you’re after. You don’t <i>have</i> to use it but IMHO complaining so much about there not being a decent IDE without even trying the proprietary ones isn’t very fruitful. CLion is what Borland was back in the 90s.</div><br/></div></div></div></div></div></div><div id="37083833" class="c"><input type="checkbox" id="c-37083833" checked=""/><div class="controls bullet"><span class="by">spookie</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083097">parent</a><span>|</span><a href="#37083944">prev</a><span>|</span><a href="#37082936">next</a><span>|</span><label class="collapse" for="c-37083833">[-]</label><label class="expand" for="c-37083833">[2 more]</label></div><br/><div class="children"><div class="content">Have you looked at KDevelop? I mean, the underlying tech is still the same, but I find it more pleasant to work with.</div><br/><div id="37085247" class="c"><input type="checkbox" id="c-37085247" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37083833">parent</a><span>|</span><a href="#37082936">next</a><span>|</span><label class="collapse" for="c-37085247">[-]</label><label class="expand" for="c-37085247">[1 more]</label></div><br/><div class="children"><div class="content">Yes, though i don&#x27;t remember why i decided against KDevelop, i remember installing it at least a couple of times, finding some annoyance and removing it. I do remember liking QtCreator more but that was in comparison to KDevelop.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37082936" class="c"><input type="checkbox" id="c-37082936" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37082355">parent</a><span>|</span><a href="#37082872">prev</a><span>|</span><a href="#37082900">next</a><span>|</span><label class="collapse" for="c-37082936">[-]</label><label class="expand" for="c-37082936">[1 more]</label></div><br/><div class="children"><div class="content">My last project in C had a CMake file that generated a Makefile, idk if you consider that too much.</div><br/></div></div><div id="37082900" class="c"><input type="checkbox" id="c-37082900" checked=""/><div class="controls bullet"><span class="by">Scarbutt</span><span>|</span><a href="#37082355">parent</a><span>|</span><a href="#37082936">prev</a><span>|</span><a href="#37082553">next</a><span>|</span><label class="collapse" for="c-37082900">[-]</label><label class="expand" for="c-37082900">[1 more]</label></div><br/><div class="children"><div class="content">Docker provides an extra layer of &quot;safety&quot; for rogue third party packages. Better than installing those rogue packages directly to the host.</div><br/></div></div><div id="37082553" class="c"><input type="checkbox" id="c-37082553" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37082355">parent</a><span>|</span><a href="#37082900">prev</a><span>|</span><a href="#37083134">next</a><span>|</span><label class="collapse" for="c-37082553">[-]</label><label class="expand" for="c-37082553">[2 more]</label></div><br/><div class="children"><div class="content">&gt; ...a Makefile and vim (or emacs, or even nano, I&#x27;m not going to judge your kink) are fine. If they are not fine, then C is probably not the right language for the project.<p>Sorry buddy, you might believe Makefiles are fine only if you are  not aware of the most basic requirements of a build system.  CMake does stuff like running sanity checks on libraries, configure them for you with minimal effort, and even add platform-specific configuration easily. Did you know that cmake started as a Makefile generator? Why do you think people need that?<p>Makefiles alone were never enough, as the development of tools such as the autotools family demonstrated decades ago. Claiming otherwise just seems naive flexing from someone who has no real world experience whatsoever.</div><br/><div id="37082779" class="c"><input type="checkbox" id="c-37082779" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#37082355">root</a><span>|</span><a href="#37082553">parent</a><span>|</span><a href="#37083134">next</a><span>|</span><label class="collapse" for="c-37082779">[-]</label><label class="expand" for="c-37082779">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Did you know that cmake started as a Makefile generator? Why do you think people need that?<p>I like make myself, but I’m honest enough to acknowledge that the whole autotools suite (autoconf&#x2F;automake) was born to, essentially, generate makefiles.<p>Which is not 100% make’s complexity’s fault though… the toolchains have their own complexity (even more so when a project must build across platforms)…</div><br/></div></div></div></div></div></div><div id="37084423" class="c"><input type="checkbox" id="c-37084423" checked=""/><div class="controls bullet"><span class="by">demondemidi</span><span>|</span><a href="#37082355">prev</a><span>|</span><a href="#37082437">next</a><span>|</span><label class="collapse" for="c-37084423">[-]</label><label class="expand" for="c-37084423">[2 more]</label></div><br/><div class="children"><div class="content">This should be titled &quot;A Modern -OPEN SOURCE- C Development Environment&quot;.<p>If you work in the embedded space for a large OEM, ODM, or integration house, you won&#x27;t see any of this ... you will see all commercial environments with big price tags for seats e.g. compilers will be ARMC, Green Hills, IAR; for DAST you&#x27;ll see tools from Synopsys or Cadence (same for virtual prototyping); lots of ISO compliance tools from hard-to-remember small companies that do that for a living and charge a cool mil to setup and audit ... for CI&#x2F;CD you will likely see GitLab if not home grown suites. Gnu tools are some of the worst. Containers? 30+ years at this with 10 major contracts with big companies (and dozens of smaller ones) and I&#x27;ve only seen one company use containers and that was for virtual prototyping. C environments move at 1&#x2F;100th the speed of webdev because product cycles happen in 6-12 months: literally no time to bring up a new system that breaks everything (and for no real benefit).</div><br/><div id="37085743" class="c"><input type="checkbox" id="c-37085743" checked=""/><div class="controls bullet"><span class="by">DoingIsLearning</span><span>|</span><a href="#37084423">parent</a><span>|</span><a href="#37082437">next</a><span>|</span><label class="collapse" for="c-37085743">[-]</label><label class="expand" for="c-37085743">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you work in the embedded space for a large OEM, ODM, or integration house<p>&gt; Containers? 30+ years at this with 10 major contracts with big companies (and dozens of smaller ones) and I&#x27;ve only seen one company use containers and that was for virtual prototyping.<p>There are _a_lot_ of small and medium size businesses working with embedded devices with limited on-site resources, and those will usually use external contractors. In that case containers are very useful to share an Automated Test environment. The alternative is a long back and forth or spending time on-site supporting teams with wildly varying skill levels.<p>Also as someone else mentioned when an old client asks for a new feature, the ability to take a snapshot in time is a huge time saver, rather than trying to replicate that build environment from scratch.</div><br/></div></div></div></div><div id="37082437" class="c"><input type="checkbox" id="c-37082437" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#37084423">prev</a><span>|</span><a href="#37083955">next</a><span>|</span><label class="collapse" for="c-37082437">[-]</label><label class="expand" for="c-37082437">[5 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  since the container is executed in a VM, the I&#x2F;O performance is significantly worse compared to a container 
  that is run natively. For compiled languages or for any process that creates a lot of files, this impact can be 
  significant since the overhead can be up to 100x of what you’re experiencing natively
</code></pre>
Uhhhhhhh. I don&#x27;t know what VM you&#x27;re using... but if the I&#x2F;O in your VM is 100x slower than the host, you can fix that. It should not take a minute and a half to write a single file.</div><br/><div id="37082634" class="c"><input type="checkbox" id="c-37082634" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#37082437">parent</a><span>|</span><a href="#37082716">next</a><span>|</span><label class="collapse" for="c-37082634">[-]</label><label class="expand" for="c-37082634">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m guessing OP is on Docker for Mac. This isn&#x27;t so much a VM is slow, it&#x27;s that file IO on docker for mac on mounted volumes is <i>dog</i> slow. (It&#x27;s not exactly ripping fast on windows either).<p>If you don&#x27;t mount the intermediate directory, it&#x27;ll be <i>way</i> faster. Alternatively, use OrbStack (I feel like I&#x27;m shilling this a lot recently, I&#x27;m just a happy user), and the problem goes away.</div><br/><div id="37083596" class="c"><input type="checkbox" id="c-37083596" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#37082437">root</a><span>|</span><a href="#37082634">parent</a><span>|</span><a href="#37082716">next</a><span>|</span><label class="collapse" for="c-37083596">[-]</label><label class="expand" for="c-37083596">[1 more]</label></div><br/><div class="children"><div class="content">And for everyone who has these problems and aren&#x27;t, like, people who need access to Photoshop, it&#x27;s &quot;native performance&quot; on Linux cuz there&#x27;s no VM layer.<p>It could be that the VSCode remote container stuff also gets around this problem somewhat by working &quot;in container&quot;, effectively opting out of the Mac-&gt;Docker FS stack issues (especially with file watching....).<p>The fact that we have an enumerable number of tools that write files and somehow ended up with a bunch of stuff built on file watching instead of signaling to a build daemon on file save&#x2F;checkout is... It feels cleaner but in practice is a mess of downstream problems.</div><br/></div></div></div></div><div id="37082716" class="c"><input type="checkbox" id="c-37082716" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#37082437">parent</a><span>|</span><a href="#37082634">prev</a><span>|</span><a href="#37083955">next</a><span>|</span><label class="collapse" for="c-37082716">[-]</label><label class="expand" for="c-37082716">[2 more]</label></div><br/><div class="children"><div class="content">Sounds like a case of &quot;Running Docker Desktop on a Mac and editing file on filesystem mounted from host&quot;.</div><br/><div id="37082797" class="c"><input type="checkbox" id="c-37082797" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#37082437">root</a><span>|</span><a href="#37082716">parent</a><span>|</span><a href="#37083955">next</a><span>|</span><label class="collapse" for="c-37082797">[-]</label><label class="expand" for="c-37082797">[1 more]</label></div><br/><div class="children"><div class="content">More like: writing to an overlay filesystem mounted on top of several more overlay filesystem running in a linux virtual machine started by docker desktop on a mac.</div><br/></div></div></div></div></div></div><div id="37083955" class="c"><input type="checkbox" id="c-37083955" checked=""/><div class="controls bullet"><span class="by">hsn915</span><span>|</span><a href="#37082437">prev</a><span>|</span><a href="#37084230">next</a><span>|</span><label class="collapse" for="c-37083955">[-]</label><label class="expand" for="c-37083955">[3 more]</label></div><br/><div class="children"><div class="content">I was hoping one can setup a &quot;modern&quot; C development environment without resorting to Docker.<p>Using Docker for setup a C development environment indicates that there are too many moving parts and the development environment is essentially very complex and that there&#x27;s nothing that one do about it.<p>I wish more people would write such guides with the aim of reducing the development environment to its essentials that can be installed system-wide without being disruptive and thus not needing &quot;Docker&quot;.</div><br/><div id="37086340" class="c"><input type="checkbox" id="c-37086340" checked=""/><div class="controls bullet"><span class="by">piaste</span><span>|</span><a href="#37083955">parent</a><span>|</span><a href="#37084409">next</a><span>|</span><label class="collapse" for="c-37086340">[-]</label><label class="expand" for="c-37086340">[1 more]</label></div><br/><div class="children"><div class="content">Oh, you can surely install a minimal development environment system-wide.<p>Once.<p>Containers just enable you to do it more than once. And they leave you a plaintext napkin with the list of stuff you installed.</div><br/></div></div><div id="37084409" class="c"><input type="checkbox" id="c-37084409" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#37083955">parent</a><span>|</span><a href="#37086340">prev</a><span>|</span><a href="#37084230">next</a><span>|</span><label class="collapse" for="c-37084409">[-]</label><label class="expand" for="c-37084409">[1 more]</label></div><br/><div class="children"><div class="content">Using docker merely ensures the environment can be quickly reproduced anywhere, anytime it is needed.<p>It is entirely optional, yet extremely useful.</div><br/></div></div></div></div><div id="37084382" class="c"><input type="checkbox" id="c-37084382" checked=""/><div class="controls bullet"><span class="by">cushychicken</span><span>|</span><a href="#37084230">prev</a><span>|</span><a href="#37085840">next</a><span>|</span><label class="collapse" for="c-37084382">[-]</label><label class="expand" for="c-37084382">[1 more]</label></div><br/><div class="children"><div class="content">To everyone dogpiling on this guy: a better title would be &quot;A Modern <i>Embedded</i> C Development Environment&quot;.<p>There&#x27;s a bunch of problems that Docker solves for embedded toolchains that other C developers don&#x27;t need to care about.</div><br/></div></div><div id="37085840" class="c"><input type="checkbox" id="c-37085840" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#37084382">prev</a><span>|</span><a href="#37085760">next</a><span>|</span><label class="collapse" for="c-37085840">[-]</label><label class="expand" for="c-37085840">[2 more]</label></div><br/><div class="children"><div class="content">`apt install` is just installing a whole lot of utilities without specifying any version. This environment will only last a couple of years (and that&#x27;s generous because the kind of stuff you&#x27;re installing, like cmake, gcc, curl, maybe ruby(?) tend to be stable, but at some point one of them will break something you were using).<p>It&#x27;s the old dilema everyone faces: pin every dependency version to guarantee you have a stable environment that will work in 20 years as long as things can still be downloaded? OR use the latest of everything, making a hugely unstable environment you have to keep fixing every few months, but at least get the latest &quot;security patches&quot; and other improvements (as well as new bugs)?</div><br/><div id="37086362" class="c"><input type="checkbox" id="c-37086362" checked=""/><div class="controls bullet"><span class="by">piaste</span><span>|</span><a href="#37085840">parent</a><span>|</span><a href="#37085760">next</a><span>|</span><label class="collapse" for="c-37086362">[-]</label><label class="expand" for="c-37086362">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, not pinning versions in a container build is bad practice imo.<p>Though, I haven&#x27;t used Debian-based distros in a while, but does apt actually <i>serve</i> really old versions of its packages? I vaguely seem to remember that you could realistically only `apt install` the last few versions of a package.</div><br/></div></div></div></div><div id="37085760" class="c"><input type="checkbox" id="c-37085760" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#37085840">prev</a><span>|</span><a href="#37083356">next</a><span>|</span><label class="collapse" for="c-37085760">[-]</label><label class="expand" for="c-37085760">[1 more]</label></div><br/><div class="children"><div class="content">I hope beginners don&#x27;t get the impression that all this is needed for developing in C. If you want a free (as in beer) and &#x27;good enough&#x27; multi-platform solution without tinkering, just use VSCode with 2 extensions:<p>- <a href="https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=ms-vscode.cpptools" rel="nofollow noreferrer">https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=ms-vscod...</a><p>- <a href="https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=ms-vscode.cmake-tools" rel="nofollow noreferrer">https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=ms-vscod...</a><p>This gives you a cmake-based IDE-like setup that works across Linux, macOS and Windows (and also allows to build and debug UI applications with the native OS APIs).</div><br/></div></div><div id="37083356" class="c"><input type="checkbox" id="c-37083356" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#37085760">prev</a><span>|</span><a href="#37083013">next</a><span>|</span><label class="collapse" for="c-37083356">[-]</label><label class="expand" for="c-37083356">[2 more]</label></div><br/><div class="children"><div class="content">For my past few C&#x2F;C++ projects, my very enjoyable development environment has been:<p>* XCode<p>* Makefile<p>That&#x27;s really it. If I found myself needing to set up Docker... I&#x27;d just go outside and garden instead or something.</div><br/><div id="37083368" class="c"><input type="checkbox" id="c-37083368" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#37083356">parent</a><span>|</span><a href="#37083013">next</a><span>|</span><label class="collapse" for="c-37083368">[-]</label><label class="expand" for="c-37083368">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, as soon as the article started talking about setting up a Docker instance to compile some C code I was out.  It&#x27;s like they went out of their way to make a C compile take as long as a modern language.</div><br/></div></div></div></div><div id="37083013" class="c"><input type="checkbox" id="c-37083013" checked=""/><div class="controls bullet"><span class="by">guessbest</span><span>|</span><a href="#37083356">prev</a><span>|</span><a href="#37082725">next</a><span>|</span><label class="collapse" for="c-37083013">[-]</label><label class="expand" for="c-37083013">[2 more]</label></div><br/><div class="children"><div class="content">As much as I hate to say it, XCode is a really good C development environment that also works with C++. I&#x27;ve never had to mess with a makefile.</div><br/><div id="37083886" class="c"><input type="checkbox" id="c-37083886" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#37083013">parent</a><span>|</span><a href="#37082725">next</a><span>|</span><label class="collapse" for="c-37083886">[-]</label><label class="expand" for="c-37083886">[1 more]</label></div><br/><div class="children"><div class="content">For all IDEs I’ve used, this meant a dead simple makefile, nothing to mess with. When I had to, I had to mess with these fancy envs even more, or they just couldn’t do it.<p>But if you meant that learning make is harder than using an IDE, then I agree. But why specifically XCode then? Lots of IDEs know C&#x2F;C++ off the shelf.</div><br/></div></div></div></div><div id="37082725" class="c"><input type="checkbox" id="c-37082725" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#37083013">prev</a><span>|</span><a href="#37085019">next</a><span>|</span><label class="collapse" for="c-37082725">[-]</label><label class="expand" for="c-37082725">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a big containers fan, they work really well (assuming you&#x27;re not developing with MSVC). They give you a repeatable build environment, which is a boon for something like C where you&#x27;re implicitly depending on system include paths for versioning.<p>I said this elsewhere, but you&#x27;ll get a pretty decent perf boost if you set your build intermediate directory outside your mounted volume.<p>Instead of rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*, running `apt-get clean` as part of that layer will help more.<p>Wrapping docker commands with makefiles is sad times. Use <a href="https:&#x2F;&#x2F;magefile.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;magefile.org&#x2F;</a> or a task runner instead. Try to avoid making it a scripting language dependency.<p>Installing ruby to install a build system when you&#x27;re using cmake in the container is a bit bonkers, and the cause of the majority of the &quot;bloat&quot; here. I&#x27;d replace it with calls to cmake and unity directly. (And honestly, if you&#x27;re going as far as using cmake, I&#x27;d ditch C altogether and usea subset of C++ with gtest)<p>But honestly, that&#x27;s about all I can complain about. This is a neat, modern workflow.</div><br/><div id="37083188" class="c"><input type="checkbox" id="c-37083188" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#37082725">parent</a><span>|</span><a href="#37086272">next</a><span>|</span><label class="collapse" for="c-37083188">[-]</label><label class="expand" for="c-37083188">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m a big containers fan, they work really well (assuming you&#x27;re not developing with MSVC). They give you a repeatable build environment, which is a boon for something like C where you&#x27;re implicitly depending on system include paths for versioning.<p>For development, I actually don&#x27;t like &quot;repeatable build environments&quot;. I like using a different, continuously updated systems, I consider having a different environment for CI&#x2F;CD and for development to be a good thing. It is one of the best way to test for compatibility problems, a kind of dogfooding.<p>Plus, it is nice working on a system you are comfortable with, and without the performance penalties of virtualization&#x2F;containerization.<p>For releasing and testing however, containers are great.</div><br/></div></div><div id="37086272" class="c"><input type="checkbox" id="c-37086272" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37082725">parent</a><span>|</span><a href="#37083188">prev</a><span>|</span><a href="#37085019">next</a><span>|</span><label class="collapse" for="c-37086272">[-]</label><label class="expand" for="c-37086272">[2 more]</label></div><br/><div class="children"><div class="content">&gt; where you&#x27;re implicitly depending on system include paths for versioning<p>The correct thing to do, imho, is check-in toolchains to version control.</div><br/><div id="37086417" class="c"><input type="checkbox" id="c-37086417" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#37082725">root</a><span>|</span><a href="#37086272">parent</a><span>|</span><a href="#37085019">next</a><span>|</span><label class="collapse" for="c-37086417">[-]</label><label class="expand" for="c-37086417">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that works really well.  I used to use the predecessor of &quot;Turnkey&quot; [0] for unreal engine, and it worked absolutely great for that problem.<p>[0] <a href="https:&#x2F;&#x2F;docs.unrealengine.com&#x2F;5.0&#x2F;en-US&#x2F;setting-up-turnkey-for-your-organization-in-unreal-engine&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.unrealengine.com&#x2F;5.0&#x2F;en-US&#x2F;setting-up-turnkey-f...</a></div><br/></div></div></div></div></div></div><div id="37085019" class="c"><input type="checkbox" id="c-37085019" checked=""/><div class="controls bullet"><span class="by">xvilka</span><span>|</span><a href="#37082725">prev</a><span>|</span><a href="#37082957">next</a><span>|</span><label class="collapse" for="c-37085019">[-]</label><label class="expand" for="c-37085019">[2 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t use Debian or Ubuntu as Docker base for this since they always ship heavily outdated software. Alpine as a base offers slimmer image but also updated tools and libraries, including GCC and Clang. Article speaks about GCC 10 which is prehistoric by today standards.</div><br/><div id="37086376" class="c"><input type="checkbox" id="c-37086376" checked=""/><div class="controls bullet"><span class="by">piaste</span><span>|</span><a href="#37085019">parent</a><span>|</span><a href="#37082957">next</a><span>|</span><label class="collapse" for="c-37086376">[-]</label><label class="expand" for="c-37086376">[1 more]</label></div><br/><div class="children"><div class="content">Can the dev environment and toolchain be affected by Alpine being musl-based?</div><br/></div></div></div></div><div id="37082957" class="c"><input type="checkbox" id="c-37082957" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#37085019">prev</a><span>|</span><a href="#37085951">next</a><span>|</span><label class="collapse" for="c-37082957">[-]</label><label class="expand" for="c-37082957">[1 more]</label></div><br/><div class="children"><div class="content">The cost in learning curve and weird edge cases on NixOS &#x2F; flakes is debatable for any language ecosystem with some kind of Python-style virtual env or Rust-style (correctly) build the world.<p>In C&#x2F;C++ land? Nix is the virtual env. It’s the only sane choice for that as a user land stack.</div><br/></div></div><div id="37085951" class="c"><input type="checkbox" id="c-37085951" checked=""/><div class="controls bullet"><span class="by">InvOfSmallC</span><span>|</span><a href="#37082957">prev</a><span>|</span><a href="#37085037">next</a><span>|</span><label class="collapse" for="c-37085951">[-]</label><label class="expand" for="c-37085951">[1 more]</label></div><br/><div class="children"><div class="content">I have a side job of teacher at university, sometimes I have to teach C fundamentals. I was looking into giving my students a standard setup. This looks awesome.<p>Have my thanks.</div><br/></div></div><div id="37085037" class="c"><input type="checkbox" id="c-37085037" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#37085951">prev</a><span>|</span><a href="#37082687">next</a><span>|</span><label class="collapse" for="c-37085037">[-]</label><label class="expand" for="c-37085037">[1 more]</label></div><br/><div class="children"><div class="content">The setup described is incredibly involved ... I&#x27;m doing some ESP32 experiments and plan to investigate PlatformIO which seems to provide solutions to most of the problems described in the OP. PIO supports a bunch of platforms and also provides a way to create your own if necessary [1].<p>1: <a href="https:&#x2F;&#x2F;docs.platformio.org&#x2F;en&#x2F;latest&#x2F;platforms&#x2F;creating_platform.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.platformio.org&#x2F;en&#x2F;latest&#x2F;platforms&#x2F;creating_pla...</a></div><br/></div></div><div id="37082687" class="c"><input type="checkbox" id="c-37082687" checked=""/><div class="controls bullet"><span class="by">anon7331</span><span>|</span><a href="#37085037">prev</a><span>|</span><a href="#37084808">next</a><span>|</span><label class="collapse" for="c-37082687">[-]</label><label class="expand" for="c-37082687">[1 more]</label></div><br/><div class="children"><div class="content">My idea of a C development environment has always been Vim, Tmux and a decent compiler.</div><br/></div></div><div id="37084808" class="c"><input type="checkbox" id="c-37084808" checked=""/><div class="controls bullet"><span class="by">nitwit005</span><span>|</span><a href="#37082687">prev</a><span>|</span><a href="#37085187">next</a><span>|</span><label class="collapse" for="c-37084808">[-]</label><label class="expand" for="c-37084808">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Dockerfiles are not stable. A Dockerfile that built just fine yesterday might fail to build today. There are simply too many external dependencies.<p>&gt; Docker is not platform-independent. Especially if you’re running a container on other CPU architectures, e.g., Apple ARM, you’ll notice that some things don’t run. We’ll see this later.<p>And it keeps going on about how Docker doesn&#x27;t really solve the problem.</div><br/></div></div><div id="37085187" class="c"><input type="checkbox" id="c-37085187" checked=""/><div class="controls bullet"><span class="by">travisgriggs</span><span>|</span><a href="#37084808">prev</a><span>|</span><a href="#37085649">next</a><span>|</span><label class="collapse" for="c-37085187">[-]</label><label class="expand" for="c-37085187">[1 more]</label></div><br/><div class="children"><div class="content">I switched from fighting VSCode and plug-in hell to Nova with Seadragon a couple of months ago. At the end of the trial window, I had no problem ponying up money for Nova. I don’t even know where to start on the myriad little ways I like Nova better.</div><br/></div></div><div id="37085649" class="c"><input type="checkbox" id="c-37085649" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37085187">prev</a><span>|</span><a href="#37083375">next</a><span>|</span><label class="collapse" for="c-37085649">[-]</label><label class="expand" for="c-37085649">[1 more]</label></div><br/><div class="children"><div class="content">Great article, specially by going into unit testing and use of static analysis tooling.</div><br/></div></div><div id="37083375" class="c"><input type="checkbox" id="c-37083375" checked=""/><div class="controls bullet"><span class="by">antiviral</span><span>|</span><a href="#37085649">prev</a><span>|</span><a href="#37082231">next</a><span>|</span><label class="collapse" for="c-37083375">[-]</label><label class="expand" for="c-37083375">[7 more]</label></div><br/><div class="children"><div class="content">The C language is like &#x27;an elegant weapon for a more civilized age.&#x27;<p>This article reminds me of an idea I once had: to write a memory manager&#x2F;garbage collector for C. The challenge is to know the scope of a dynamically managed chunk of memory. Using that, the memory can be automatically garbage-collected, but this is difficult since C wasn&#x27;t designed for this in mind.<p>I&#x27;m curious if anyone has any other experiences they can share.</div><br/><div id="37086364" class="c"><input type="checkbox" id="c-37086364" checked=""/><div class="controls bullet"><span class="by">BaculumMeumEst</span><span>|</span><a href="#37083375">parent</a><span>|</span><a href="#37083404">next</a><span>|</span><label class="collapse" for="c-37086364">[-]</label><label class="expand" for="c-37086364">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;journal.stuffwithstuff.com&#x2F;2013&#x2F;12&#x2F;08&#x2F;babys-first-garbage-collector&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;journal.stuffwithstuff.com&#x2F;2013&#x2F;12&#x2F;08&#x2F;babys-first-ga...</a></div><br/></div></div><div id="37083404" class="c"><input type="checkbox" id="c-37083404" checked=""/><div class="controls bullet"><span class="by">bobowzki</span><span>|</span><a href="#37083375">parent</a><span>|</span><a href="#37086364">prev</a><span>|</span><a href="#37083405">next</a><span>|</span><label class="collapse" for="c-37083404">[-]</label><label class="expand" for="c-37083404">[4 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.hboehm.info&#x2F;gc&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.hboehm.info&#x2F;gc&#x2F;</a></div><br/><div id="37083417" class="c"><input type="checkbox" id="c-37083417" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#37083375">root</a><span>|</span><a href="#37083404">parent</a><span>|</span><a href="#37083655">next</a><span>|</span><label class="collapse" for="c-37083417">[-]</label><label class="expand" for="c-37083417">[1 more]</label></div><br/><div class="children"><div class="content">That was my first reaction as well, I haven&#x27;t really used it, but it&#x27;s an interesting tool.</div><br/></div></div><div id="37083655" class="c"><input type="checkbox" id="c-37083655" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#37083375">root</a><span>|</span><a href="#37083404">parent</a><span>|</span><a href="#37083417">prev</a><span>|</span><a href="#37083405">next</a><span>|</span><label class="collapse" for="c-37083655">[-]</label><label class="expand" for="c-37083655">[2 more]</label></div><br/><div class="children"><div class="content">I did this once - a compacting collector for C. it was a really trivial mark&#x2F;sweep - and as I recall you had to write functions for each type to perform the object graph traversal. for artificial memory-intensive workloads it was around 8x the performance of boehm.</div><br/><div id="37085508" class="c"><input type="checkbox" id="c-37085508" checked=""/><div class="controls bullet"><span class="by">antiviral</span><span>|</span><a href="#37083375">root</a><span>|</span><a href="#37083655">parent</a><span>|</span><a href="#37083405">next</a><span>|</span><label class="collapse" for="c-37085508">[-]</label><label class="expand" for="c-37085508">[1 more]</label></div><br/><div class="children"><div class="content">Is this anything you&#x27;d be willing to share publicly?<p>How did you determine the scope of a chunk of memory? I believe you need this to run any of the GC algorithms.<p>I checked the hboehm documentation (1) and in the section on &quot;Locating roots&quot; it says &quot;you don&#x27;t want to know&quot;:<p>-Runtime stack(s): you don&#x27;t really want to know.Need consistent caller-save reg. snapshot<p>-Static data segments: you don&#x27;t want to know that either.<p>-Very platform dependent
 But you only have to do it once per platform.<p>(1) <a href="https:&#x2F;&#x2F;www.hboehm.info&#x2F;gc&#x2F;04tutorial.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.hboehm.info&#x2F;gc&#x2F;04tutorial.pdf</a></div><br/></div></div></div></div></div></div></div></div><div id="37082231" class="c"><input type="checkbox" id="c-37082231" checked=""/><div class="controls bullet"><span class="by">anotherhue</span><span>|</span><a href="#37083375">prev</a><span>|</span><a href="#37083235">next</a><span>|</span><label class="collapse" for="c-37082231">[-]</label><label class="expand" for="c-37082231">[17 more]</label></div><br/><div class="children"><div class="content">Also see:<p>Make Zig Your C&#x2F;C++ Build System<p><a href="https:&#x2F;&#x2F;zig.news&#x2F;kristoff&#x2F;make-zig-your-c-c-build-system-28g5" rel="nofollow noreferrer">https:&#x2F;&#x2F;zig.news&#x2F;kristoff&#x2F;make-zig-your-c-c-build-system-28g...</a><p>Edit: this is a better demo (thanks jmull) <a href="https:&#x2F;&#x2F;andrewkelley.me&#x2F;post&#x2F;zig-cc-powerful-drop-in-replacement-gcc-clang.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;andrewkelley.me&#x2F;post&#x2F;zig-cc-powerful-drop-in-replace...</a></div><br/><div id="37084896" class="c"><input type="checkbox" id="c-37084896" checked=""/><div class="controls bullet"><span class="by">gkfasdfasdf</span><span>|</span><a href="#37082231">parent</a><span>|</span><a href="#37082384">next</a><span>|</span><label class="collapse" for="c-37084896">[-]</label><label class="expand" for="c-37084896">[2 more]</label></div><br/><div class="children"><div class="content">I thought zig was removing &#x27;zig cc&#x27; support?</div><br/><div id="37086469" class="c"><input type="checkbox" id="c-37086469" checked=""/><div class="controls bullet"><span class="by">ttrei</span><span>|</span><a href="#37082231">root</a><span>|</span><a href="#37084896">parent</a><span>|</span><a href="#37082384">next</a><span>|</span><label class="collapse" for="c-37086469">[-]</label><label class="expand" for="c-37086469">[1 more]</label></div><br/><div class="children"><div class="content">Not really:
<a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;16270#issuecomment-1616115039">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;16270#issuecomment-161...</a></div><br/></div></div></div></div><div id="37082384" class="c"><input type="checkbox" id="c-37082384" checked=""/><div class="controls bullet"><span class="by">david2ndaccount</span><span>|</span><a href="#37082231">parent</a><span>|</span><a href="#37084896">prev</a><span>|</span><a href="#37083235">next</a><span>|</span><label class="collapse" for="c-37082384">[-]</label><label class="expand" for="c-37082384">[14 more]</label></div><br/><div class="children"><div class="content">Doesn’t seem to offer much over just using clang.</div><br/><div id="37082510" class="c"><input type="checkbox" id="c-37082510" checked=""/><div class="controls bullet"><span class="by">klardotsh</span><span>|</span><a href="#37082231">root</a><span>|</span><a href="#37082384">parent</a><span>|</span><a href="#37082444">next</a><span>|</span><label class="collapse" for="c-37082510">[-]</label><label class="expand" for="c-37082510">[12 more]</label></div><br/><div class="children"><div class="content">Other than the complete lack of writing CMake, Makefiles, autoconf, or any number of other end-user-configuration complicated systems as such, and other than the trivial statically-linked cross-compilation support, sure, I guess it&#x27;s &quot;just&quot; a wrapper around clang, if you squint.</div><br/><div id="37084596" class="c"><input type="checkbox" id="c-37084596" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#37082231">root</a><span>|</span><a href="#37082510">parent</a><span>|</span><a href="#37082575">next</a><span>|</span><label class="collapse" for="c-37084596">[-]</label><label class="expand" for="c-37084596">[1 more]</label></div><br/><div class="children"><div class="content">Out of curiosity, what DO you write instead of Makefiles in this case?<p>I’m genuinely curious if it’s actually easier, but I’m assuming you’re just using a different tool, maybe without as much historical baggage (and incompatible implementations)…</div><br/></div></div><div id="37082575" class="c"><input type="checkbox" id="c-37082575" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37082231">root</a><span>|</span><a href="#37082510">parent</a><span>|</span><a href="#37084596">prev</a><span>|</span><a href="#37082529">next</a><span>|</span><label class="collapse" for="c-37082575">[-]</label><label class="expand" for="c-37082575">[5 more]</label></div><br/><div class="children"><div class="content">&gt; or any number of other end-user-configuration complicated systems as such<p>If you think that cmake is complicated, when in reality all it does is set targets using a declarative stye, then programming might not be for you.</div><br/><div id="37082592" class="c"><input type="checkbox" id="c-37082592" checked=""/><div class="controls bullet"><span class="by">klardotsh</span><span>|</span><a href="#37082231">root</a><span>|</span><a href="#37082575">parent</a><span>|</span><a href="#37082791">next</a><span>|</span><label class="collapse" for="c-37082592">[-]</label><label class="expand" for="c-37082592">[1 more]</label></div><br/><div class="children"><div class="content">Personal attacks are pretty unnecessary here, thanks. This kind of comment is what gives (some) C developers the reputation they have in some circles, I guess.</div><br/></div></div><div id="37082791" class="c"><input type="checkbox" id="c-37082791" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#37082231">root</a><span>|</span><a href="#37082575">parent</a><span>|</span><a href="#37082592">prev</a><span>|</span><a href="#37082529">next</a><span>|</span><label class="collapse" for="c-37082791">[-]</label><label class="expand" for="c-37082791">[3 more]</label></div><br/><div class="children"><div class="content">&gt; when in reality all it does is set targets using a declarative stye<p>That&#x27;s like the hello world of cmake builds<p>Bigger cmake builds are doing dependency resolution, configuration tests, and configuration for development or release builds&#x2F;installs.<p>Go poke at the cmake logs and result artifacts in Debug&#x2F;Release build types and see if it&#x27;s &quot;just declaring targets.&quot;</div><br/><div id="37083059" class="c"><input type="checkbox" id="c-37083059" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37082231">root</a><span>|</span><a href="#37082791">parent</a><span>|</span><a href="#37082529">next</a><span>|</span><label class="collapse" for="c-37083059">[-]</label><label class="expand" for="c-37083059">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Bigger cmake builds are doing dependency resolution,<p>find_package(foo)<p>#...<p>target_link_libraries(myapp foo::Static)<p>&gt; configuration tests,<p>I don&#x27;t know what you mean by configuration tests. I don&#x27;t think I ever added any test resembling that description other than sanity checks in cmake find modules and sanity checks on projects just for convenience.<p>&gt; and configuration for development or release builds<p>Those are not handled by cmake other than setting a flag that&#x27;s used in the code.<p>&gt; &#x2F;installs.<p>You don&#x27;t need to do anything other than setting the install target.<p><a href="https:&#x2F;&#x2F;cmake.org&#x2F;cmake&#x2F;help&#x2F;latest&#x2F;command&#x2F;install.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;cmake.org&#x2F;cmake&#x2F;help&#x2F;latest&#x2F;command&#x2F;install.html</a><p>I think you&#x27;re either wildly exaggerating or you&#x27;ve been creating your own problems.</div><br/><div id="37085157" class="c"><input type="checkbox" id="c-37085157" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#37082231">root</a><span>|</span><a href="#37083059">parent</a><span>|</span><a href="#37082529">next</a><span>|</span><label class="collapse" for="c-37085157">[-]</label><label class="expand" for="c-37085157">[1 more]</label></div><br/><div class="children"><div class="content">Ok. How does find_package work? Hint: you need to understand how cmake module paths are discovered and their precedence, and you&#x27;ll probably see a cmake folder in a build with the actual logic behind it as a .cmake file for each dependency. Depending on what package manager you&#x27;re using you may not need this, or if you support many you&#x27;ll need to own it.<p>&gt; I don&#x27;t know what you mean by configuration tests.<p>When you run cmake -S &lt;my project&gt; -B build folder you&#x27;ll see a bunch of output. What this output corresponds to may include a number of tests that either succeed or fail to indicate whether the project will build. For example, the aforementioned find_package logic, finding the compiler tool chain (especially if cross compiling), testing for random shit like endianness, etc.<p>&gt; Those are not handled by cmake other than setting a flag that&#x27;s used in the code.<p><pre><code>    if(STREQ ${CMAKE_BUILD_TYPE} Release)
        ....
    endif()
</code></pre>
Is ridiculously common with the &quot;...&quot; filled in by various things like setting optimization flags, paths within the build directory, etc<p>&gt; You don&#x27;t need to do anything other than setting the install target.<p>No but you should probably understand what RPATH is and why it&#x27;s set in release builds but not installed artifacts or why doing something that seems obvious like checking the checksum of your built object is the same as the installed one might fail.<p>The point is that cmake does a lot of work and it&#x27;s not <i>just</i> declaring targets. Builds are hard.</div><br/></div></div></div></div></div></div></div></div><div id="37082529" class="c"><input type="checkbox" id="c-37082529" checked=""/><div class="controls bullet"><span class="by">david2ndaccount</span><span>|</span><a href="#37082231">root</a><span>|</span><a href="#37082510">parent</a><span>|</span><a href="#37082575">prev</a><span>|</span><a href="#37082444">next</a><span>|</span><label class="collapse" for="c-37082529">[-]</label><label class="expand" for="c-37082529">[5 more]</label></div><br/><div class="children"><div class="content">If you aren’t supporting more than one compiler, almost all of those tools vanish. You can just use clang.</div><br/><div id="37082569" class="c"><input type="checkbox" id="c-37082569" checked=""/><div class="controls bullet"><span class="by">klardotsh</span><span>|</span><a href="#37082231">root</a><span>|</span><a href="#37082529">parent</a><span>|</span><a href="#37082614">next</a><span>|</span><label class="collapse" for="c-37082569">[-]</label><label class="expand" for="c-37082569">[2 more]</label></div><br/><div class="children"><div class="content">If you aren&#x27;t supporting more than one compiler, aren&#x27;t needing to compile anything in parallel, aren&#x27;t needing to find and link shared libraries on the system, aren&#x27;t needing to deal with <i>any number of real complexities that happen when building C software</i>, then sure, build.sh calling clang a few times manually is absolutely reasonable. (And again: cross-compilation is a real concern: shipping for amd64 only is not enough in 2023). And to be clear - there are plenty of small-scale projects that fit this description! But to simply hand-wave away `zig build` or other modernized build systems and say &quot;just use clang directly&quot; seems a bit dishonest or incomplete to me.</div><br/><div id="37082649" class="c"><input type="checkbox" id="c-37082649" checked=""/><div class="controls bullet"><span class="by">david2ndaccount</span><span>|</span><a href="#37082231">root</a><span>|</span><a href="#37082569">parent</a><span>|</span><a href="#37082614">next</a><span>|</span><label class="collapse" for="c-37082649">[-]</label><label class="expand" for="c-37082649">[1 more]</label></div><br/><div class="children"><div class="content">Note that I am not advocating for just having a few shell scripts that invoke clang. The context is someone saying to use `zig build`, and linking a blog post where all they do is compile redis from scratch, including all dependencies from source except for libc. In that context, `zig build` is just a wrapper around clang. Nowhere in their comment or linked blog post is the issue of these real complexities you allude to addressed at all.<p>Now I personally would rather not use a pre 1.0 release of an entirely different programming language to compile my C projects instead of a cross-platform C compiler, but people can do whatever they want.</div><br/></div></div></div></div><div id="37082614" class="c"><input type="checkbox" id="c-37082614" checked=""/><div class="controls bullet"><span class="by">reverius42</span><span>|</span><a href="#37082231">root</a><span>|</span><a href="#37082529">parent</a><span>|</span><a href="#37082569">prev</a><span>|</span><a href="#37083680">next</a><span>|</span><label class="collapse" for="c-37082614">[-]</label><label class="expand" for="c-37082614">[1 more]</label></div><br/><div class="children"><div class="content">Or more than one operating system, or more than one stdlib, etc., etc.</div><br/></div></div><div id="37083680" class="c"><input type="checkbox" id="c-37083680" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#37082231">root</a><span>|</span><a href="#37082529">parent</a><span>|</span><a href="#37082614">prev</a><span>|</span><a href="#37082444">next</a><span>|</span><label class="collapse" for="c-37083680">[-]</label><label class="expand" for="c-37083680">[1 more]</label></div><br/><div class="children"><div class="content">to be fair - my goto move on a smallish project when autoconf barfs is &#x27;cc *.c -o foo&#x27;. it works pretty damn often, sometimes you need to throw in some -I action</div><br/></div></div></div></div></div></div><div id="37082444" class="c"><input type="checkbox" id="c-37082444" checked=""/><div class="controls bullet"><span class="by">jmull</span><span>|</span><a href="#37082231">root</a><span>|</span><a href="#37082384">parent</a><span>|</span><a href="#37082510">prev</a><span>|</span><a href="#37083235">next</a><span>|</span><label class="collapse" for="c-37082444">[-]</label><label class="expand" for="c-37082444">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s some more info why you might use this instead of plain clang.<p><a href="https:&#x2F;&#x2F;andrewkelley.me&#x2F;post&#x2F;zig-cc-powerful-drop-in-replacement-gcc-clang.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;andrewkelley.me&#x2F;post&#x2F;zig-cc-powerful-drop-in-replace...</a></div><br/></div></div></div></div></div></div><div id="37083235" class="c"><input type="checkbox" id="c-37083235" checked=""/><div class="controls bullet"><span class="by">jedisct1</span><span>|</span><a href="#37082231">prev</a><span>|</span><a href="#37083156">next</a><span>|</span><label class="collapse" for="c-37083235">[-]</label><label class="expand" for="c-37083235">[1 more]</label></div><br/><div class="children"><div class="content">Forget cmake in 2023.<p>Using Zig is way easier, faster and more flexible.<p>I&#x27;m not talking about Zig as a language, but as a toolchain to compile C&#x2F;C++ code.</div><br/></div></div><div id="37083156" class="c"><input type="checkbox" id="c-37083156" checked=""/><div class="controls bullet"><span class="by">patrick451</span><span>|</span><a href="#37083235">prev</a><span>|</span><a href="#37082849">next</a><span>|</span><label class="collapse" for="c-37083156">[-]</label><label class="expand" for="c-37083156">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had jobs where we used a containerized dev evironment like this. I&#x27;ve had others where we just installed all the dependencies to our dev machines. The container environment is hands down the worse experience of the two. Similar to this tutorial, if you don&#x27;t want to use the blessed editor, you end up maintaining your own docker container. Similarly if you want to use tools not installed into the official container (say, ripgrep).<p>I&#x27;ll take updating a dependency on my dev machine every now and then (which could be largely eliminated if we had used something like conan) over maintaining my own docker image any day. You can also largely eliminate relying on system headers through --sysroot, which cmake supports.<p>Another issue we had, which this tutorial doesn&#x27;t appear to address, is that these containers run as root, so files created in them on a mounted folder easily end up as owned by root. Which can create all sorts of mayhem. The only reliable solution I have seen is to dynamically change the container users uid and gid on login, but this often doesn&#x27;t seem to get implemented.</div><br/></div></div><div id="37082849" class="c"><input type="checkbox" id="c-37082849" checked=""/><div class="controls bullet"><span class="by">pengaru</span><span>|</span><a href="#37083156">prev</a><span>|</span><a href="#37083401">next</a><span>|</span><label class="collapse" for="c-37082849">[-]</label><label class="expand" for="c-37082849">[2 more]</label></div><br/><div class="children"><div class="content">This post has very little to do with C development and far more to do with using Docker to have quasi-reproducible development environments.<p>Quasi because when your provisioning automation is doing things like `apt update` and grabbing the latest and greatest toolchains from third party repos, you&#x27;re still producing an entirely unpredictable result.</div><br/><div id="37085028" class="c"><input type="checkbox" id="c-37085028" checked=""/><div class="controls bullet"><span class="by">SV_BubbleTime</span><span>|</span><a href="#37082849">parent</a><span>|</span><a href="#37083401">next</a><span>|</span><label class="collapse" for="c-37085028">[-]</label><label class="expand" for="c-37085028">[1 more]</label></div><br/><div class="children"><div class="content">I was a little confused why the article didn’t recommend pulling specific versions by hash.</div><br/></div></div></div></div><div id="37083401" class="c"><input type="checkbox" id="c-37083401" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#37082849">prev</a><span>|</span><a href="#37085117">next</a><span>|</span><label class="collapse" for="c-37083401">[-]</label><label class="expand" for="c-37083401">[1 more]</label></div><br/><div class="children"><div class="content">You can do all of this, but aside from some oddball project setups, virtually no one else in the C or C++ ecosystem does this. Everyone uses CMake (C++), or even just Makefiles (C).<p>You are working against yourself, because eventually you will need to learn CMake and Make when you have to interop with other projects.<p>In day-to-day use, I find that there is very little that is actually modern about C or C++, and that&#x27;s OK. Just focus on getting things done, and build up a working knowledge of all of the practical stupid things you have to do when working with C and C++ projects.<p>Like, it&#x27;s bewildering that there are no cross-platform CMake recipes for building an app. Totally wild. But everyone slogs through this stupid nonsense while other platforms hand it to you on a platter. Just deal with it. There are other hills to die on that are wildly more important. Help others that struggle with arcane CMake b.s.</div><br/></div></div><div id="37082744" class="c"><input type="checkbox" id="c-37082744" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#37085117">prev</a><span>|</span><label class="collapse" for="c-37082744">[-]</label><label class="expand" for="c-37082744">[12 more]</label></div><br/><div class="children"><div class="content">&gt; A Modern C Development Environment<p>OK fine<p>&gt; 09 Aug 2023<p>huh? the correct answer to this question should be &quot;get a time machine and go back to 2003 or something. why people insist on carrying on with C in the face of its glaring issues is beyond me. I am not advocating for any specific language, because several other languages are around that might be a better fit. Rust, Zig, D, Nim, Go. just please let C die already.</div><br/><div id="37082898" class="c"><input type="checkbox" id="c-37082898" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#37082744">parent</a><span>|</span><a href="#37083171">next</a><span>|</span><label class="collapse" for="c-37082898">[-]</label><label class="expand" for="c-37082898">[5 more]</label></div><br/><div class="children"><div class="content">From the languages you listed, only Zig is somewhat suitable as a C replacement, and it hasn&#x27;t even reached v1.0.</div><br/><div id="37083016" class="c"><input type="checkbox" id="c-37083016" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#37082744">root</a><span>|</span><a href="#37082898">parent</a><span>|</span><a href="#37083171">next</a><span>|</span><label class="collapse" for="c-37083016">[-]</label><label class="expand" for="c-37083016">[4 more]</label></div><br/><div class="children"><div class="content">&gt; suitable as a C replacement<p>nope. they all are. all depends on the use case. if your use case is &quot;must do 100% of what C can do, no exceptions&quot; then of course that leaves one option. but for many programmers the trade offs today are not in favor of C, and haven&#x27;t been for some years.</div><br/><div id="37083127" class="c"><input type="checkbox" id="c-37083127" checked=""/><div class="controls bullet"><span class="by">WhereIsTheTruth</span><span>|</span><a href="#37082744">root</a><span>|</span><a href="#37083016">parent</a><span>|</span><a href="#37083171">next</a><span>|</span><label class="collapse" for="c-37083127">[-]</label><label class="expand" for="c-37083127">[3 more]</label></div><br/><div class="children"><div class="content">Programmers doesn&#x27;t define requirements, the task define the requirements<p>If you need to target very tiny boards, none from that list are suitable C replacements, _maybe_ zig  and D with betterC since they both provide an inline assembler<p>Otherwise we&#x27;ll end up with companies using Raspberry Pi 4 for their fleet of scooters because &quot;i can run nodejs on it&quot; (hyperbole, but you get the idea) <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37016842">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37016842</a></div><br/><div id="37083635" class="c"><input type="checkbox" id="c-37083635" checked=""/><div class="controls bullet"><span class="by">kawogi</span><span>|</span><a href="#37082744">root</a><span>|</span><a href="#37083127">parent</a><span>|</span><a href="#37083171">next</a><span>|</span><label class="collapse" for="c-37083635">[-]</label><label class="expand" for="c-37083635">[2 more]</label></div><br/><div class="children"><div class="content">Not sure if that counts, but I successfully wrote Rust programs for several embedded systems and microcontollers.<p>The smallest one was an ATTiny 13A (64 bytes of RAM).</div><br/><div id="37085620" class="c"><input type="checkbox" id="c-37085620" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37082744">root</a><span>|</span><a href="#37083635">parent</a><span>|</span><a href="#37083171">next</a><span>|</span><label class="collapse" for="c-37085620">[-]</label><label class="expand" for="c-37085620">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Not sure if that counts, but I successfully wrote Rust programs for several embedded systems and microcontollers.<p>&gt; The smallest one was an ATTiny 13A (64 bytes of RAM).<p>It counts, but at that point (64bytes of RAM) there is no benefit to using Rust.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37083171" class="c"><input type="checkbox" id="c-37083171" checked=""/><div class="controls bullet"><span class="by">0xfedbee</span><span>|</span><a href="#37082744">parent</a><span>|</span><a href="#37082898">prev</a><span>|</span><a href="#37082815">next</a><span>|</span><label class="collapse" for="c-37083171">[-]</label><label class="expand" for="c-37083171">[1 more]</label></div><br/><div class="children"><div class="content">No. I just started a mega project in my company in C11 3 months ago and we already have insane velocity with zero problems. I intend to start many more in C in coming months. Sorry.</div><br/></div></div><div id="37082815" class="c"><input type="checkbox" id="c-37082815" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#37082744">parent</a><span>|</span><a href="#37083171">prev</a><span>|</span><a href="#37083465">next</a><span>|</span><label class="collapse" for="c-37082815">[-]</label><label class="expand" for="c-37082815">[4 more]</label></div><br/><div class="children"><div class="content">&gt; why people insist on carrying on with C in the face of its glaring issues is beyond me.<p>Most people and companies cant delay new features and bug fixes for years with the excuse of “we’re rewriting the thing in $currently_trending_language”</div><br/><div id="37082991" class="c"><input type="checkbox" id="c-37082991" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#37082744">root</a><span>|</span><a href="#37082815">parent</a><span>|</span><a href="#37083465">next</a><span>|</span><label class="collapse" for="c-37082991">[-]</label><label class="expand" for="c-37082991">[3 more]</label></div><br/><div class="children"><div class="content">&gt; $currently_trending_language<p>by your definition, is that any language less than 50 years old?</div><br/><div id="37083157" class="c"><input type="checkbox" id="c-37083157" checked=""/><div class="controls bullet"><span class="by">seabass-labrax</span><span>|</span><a href="#37082744">root</a><span>|</span><a href="#37082991">parent</a><span>|</span><a href="#37083465">next</a><span>|</span><label class="collapse" for="c-37083157">[-]</label><label class="expand" for="c-37083157">[2 more]</label></div><br/><div class="children"><div class="content">That would be more like 30 years since C was truly trendy, and maybe 20 in some areas like embedded software engineering and games development. C was the top of the pile for <i>decades</i>, and I think when you compare it strictly to other languages that were available during that time it becomes clear why (not that is necessarily <i>better</i> than those other languages, but why it was so terrifically popular).</div><br/><div id="37085675" class="c"><input type="checkbox" id="c-37085675" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37082744">root</a><span>|</span><a href="#37083157">parent</a><span>|</span><a href="#37083465">next</a><span>|</span><label class="collapse" for="c-37085675">[-]</label><label class="expand" for="c-37085675">[1 more]</label></div><br/><div class="children"><div class="content">Ah, that is why we now have everyone cheering for Zig, which is basically Modula-2 (1978) with C like syntax.<p>Apparently since the Morris worm (1988), it took a while to undestand what kind of features C was capable of.</div><br/></div></div></div></div></div></div></div></div><div id="37083465" class="c"><input type="checkbox" id="c-37083465" checked=""/><div class="controls bullet"><span class="by">5ADBEEF</span><span>|</span><a href="#37082744">parent</a><span>|</span><a href="#37082815">prev</a><span>|</span><label class="collapse" for="c-37083465">[-]</label><label class="expand" for="c-37083465">[1 more]</label></div><br/><div class="children"><div class="content">fair point. thankfully gcc will compile c++</div><br/></div></div></div></div></div></div></div></div></div></body></html>