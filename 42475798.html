<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734858060859" as="style"/><link rel="stylesheet" href="styles.css?v=1734858060859"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://samwho.dev/turing-machines/">Turing Machines</a> <span class="domain">(<a href="https://samwho.dev">samwho.dev</a>)</span></div><div class="subtext"><span>jakelazaroff</span> | <span>28 comments</span></div><br/><div><div id="42485084" class="c"><input type="checkbox" id="c-42485084" checked=""/><div class="controls bullet"><span class="by">bubblyworld</span><span>|</span><a href="#42484333">next</a><span>|</span><label class="collapse" for="c-42485084">[-]</label><label class="expand" for="c-42485084">[1 more]</label></div><br/><div class="children"><div class="content">My favourite trivia about &quot;On Computable Numbers&quot; is that Alan Turing got the definition of computable reals wrong! The way he defines them - namely that a computable real is a Turing machine that generates the sequence of digits of the real - has severe issues, because addition and other basic operations are incomputable due to subtle diagonalisation arguments (see <a href="https:&#x2F;&#x2F;jdh.hamkins.org&#x2F;alan-turing-on-computable-numbers&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jdh.hamkins.org&#x2F;alan-turing-on-computable-numbers&#x2F;</a> for instance).<p>It&#x27;s interesting that Turing didn&#x27;t realise this, as the whole paper revolves around diagonalisation arguments in a few places.<p>The &quot;modern&quot; take is to define a computable real to be a program that takes an epsilon as input and returns a rational number within that epsilon from the real being represented. Or something similar - in this case it is very simple to define addition, for instance, as you have control over these bounds.<p>One more fact - equality is incomputable for both of these representations! There&#x27;s no program that can uniformly decide whether two computable reals are the same, no matter how you cook up the definition. This one maybe isn&#x27;t too surprising - in some sense no matter how many digits or bounds you check between two reals you can never be sure there isn&#x27;t a smaller gap between them you haven&#x27;t gotten to yet.</div><br/></div></div><div id="42484333" class="c"><input type="checkbox" id="c-42484333" checked=""/><div class="controls bullet"><span class="by">fen11</span><span>|</span><a href="#42485084">prev</a><span>|</span><a href="#42475865">next</a><span>|</span><label class="collapse" for="c-42484333">[-]</label><label class="expand" for="c-42484333">[2 more]</label></div><br/><div class="children"><div class="content">&gt; In 1936 both Alan Turing and Alonzo Church independently reached the conclusion, using different methods, that the answer is &quot;no.&quot;<p>I think claiming these efforts were independent is misleading. Church was Turing’s PhD advisor in 1936, and one of the appendices of Turing’s thesis retroactively justifies the lambda calculus definition of computing, by proving it equivalent to his Turing machine definition. That sounds less like competing definitions of computability to me, and instead a story of collaboration to produce a philosophical justification (Turing machines) for Church’s pure mathematical theory (lambda calculus). Which is not to disparage Turing either: creating this philosophical justification was an impressive and fundamentally important achievement. I think Church sometimes gets unfairly maligned in these discussions as an out-of-touch purist who didn’t care to come up with a believable definition, but clearly he cared enough to support his student working on the problem!<p>Is there some evidence for the independence or competitiveness of their work that I’ve missed?<p>Anyway, apart from this nitpick about the introduction, I appreciate seeing this foundational stuff explained clearly!</div><br/><div id="42484650" class="c"><input type="checkbox" id="c-42484650" checked=""/><div class="controls bullet"><span class="by">jarpschop</span><span>|</span><a href="#42484333">parent</a><span>|</span><a href="#42475865">next</a><span>|</span><label class="collapse" for="c-42484650">[-]</label><label class="expand" for="c-42484650">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think Turing knew about the existence of the lambda calculus when he wrote the paper. It was later that he decided to study his PhD under Church and move to Princeton.</div><br/></div></div></div></div><div id="42475865" class="c"><input type="checkbox" id="c-42475865" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#42484333">prev</a><span>|</span><a href="#42483096">next</a><span>|</span><label class="collapse" for="c-42475865">[-]</label><label class="expand" for="c-42475865">[1 more]</label></div><br/><div class="children"><div class="content">I’m the author of this post! &lt;3<p>Happy to answer any questions you might have, and love to hear feedback good and bad.</div><br/></div></div><div id="42483096" class="c"><input type="checkbox" id="c-42483096" checked=""/><div class="controls bullet"><span class="by">sohkamyung</span><span>|</span><a href="#42475865">prev</a><span>|</span><a href="#42482622">next</a><span>|</span><label class="collapse" for="c-42483096">[-]</label><label class="expand" for="c-42483096">[2 more]</label></div><br/><div class="children"><div class="content">I hope this LEGO Ideas Turing Machine gets turned into a released LEGO product [1]. It&#x27;s not the first LEGO Turing Machine, but it is noteworthy because it is fully mechanical.<p>[1] <a href="https:&#x2F;&#x2F;ideas.lego.com&#x2F;projects&#x2F;10a3239f-4562-4d23-ba8e-f4fc94eef5c7" rel="nofollow">https:&#x2F;&#x2F;ideas.lego.com&#x2F;projects&#x2F;10a3239f-4562-4d23-ba8e-f4fc...</a></div><br/><div id="42483127" class="c"><input type="checkbox" id="c-42483127" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#42483096">parent</a><span>|</span><a href="#42482622">next</a><span>|</span><label class="collapse" for="c-42483127">[-]</label><label class="expand" for="c-42483127">[1 more]</label></div><br/><div class="children"><div class="content">I love it. I love it so much.</div><br/></div></div></div></div><div id="42482622" class="c"><input type="checkbox" id="c-42482622" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#42483096">prev</a><span>|</span><a href="#42484018">next</a><span>|</span><label class="collapse" for="c-42482622">[-]</label><label class="expand" for="c-42482622">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been playing around with interpreted machines quite a bit for genetic programming experiments. My current favorite minimal machine has 4 instructions:<p>0b00: Increment memory pointer (wraps)<p>0b01: Increment memory value (wraps)<p>0b10: Jump marker - Jump to next marker if memory value 1, prior if 2 (wraps)<p>0b11: Output current memory value<p>It has 2 tapes, instruction &amp; memory. Memory is an array of byte.<p>This cannot handle any kind of input, but is useful for generating programs that can. Being able to pack 32 instructions into each interpreter machine word opens up some interesting possibilities for how we search the space.</div><br/><div id="42482678" class="c"><input type="checkbox" id="c-42482678" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#42482622">parent</a><span>|</span><a href="#42482951">next</a><span>|</span><label class="collapse" for="c-42482678">[-]</label><label class="expand" for="c-42482678">[2 more]</label></div><br/><div class="children"><div class="content">I watched a fun talk in preparation for this post on unlimited register machines that you might enjoy: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;7Q-UwjgZ0q4?si=abEV1JKd9kuI8w8z" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;7Q-UwjgZ0q4?si=abEV1JKd9kuI8w8z</a></div><br/></div></div><div id="42482951" class="c"><input type="checkbox" id="c-42482951" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42482622">parent</a><span>|</span><a href="#42482678">prev</a><span>|</span><a href="#42484018">next</a><span>|</span><label class="collapse" for="c-42482951">[-]</label><label class="expand" for="c-42482951">[2 more]</label></div><br/><div class="children"><div class="content">What’s “marker” in the above?</div><br/><div id="42482996" class="c"><input type="checkbox" id="c-42482996" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#42482622">root</a><span>|</span><a href="#42482951">parent</a><span>|</span><a href="#42484018">next</a><span>|</span><label class="collapse" for="c-42482996">[-]</label><label class="expand" for="c-42482996">[1 more]</label></div><br/><div class="children"><div class="content">The jump instruction on the tape serves as both command and reference point.</div><br/></div></div></div></div></div></div><div id="42484018" class="c"><input type="checkbox" id="c-42484018" checked=""/><div class="controls bullet"><span class="by">VitoVan</span><span>|</span><a href="#42482622">prev</a><span>|</span><a href="#42482930">next</a><span>|</span><label class="collapse" for="c-42484018">[-]</label><label class="expand" for="c-42484018">[1 more]</label></div><br/><div class="children"><div class="content">Thank you, finally I got a chance to understand this concept, nice writing, nice sketches.</div><br/></div></div><div id="42482930" class="c"><input type="checkbox" id="c-42482930" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42484018">prev</a><span>|</span><a href="#42477109">next</a><span>|</span><label class="collapse" for="c-42482930">[-]</label><label class="expand" for="c-42482930">[7 more]</label></div><br/><div class="children"><div class="content">&gt; By the end of this post, you will know:<p>&gt; • What can and cannot be computed.<p>I don’t think it delivered on the “can” part. (And I don’t think we really know that well.)</div><br/><div id="42484152" class="c"><input type="checkbox" id="c-42484152" checked=""/><div class="controls bullet"><span class="by">voidhorse</span><span>|</span><a href="#42482930">parent</a><span>|</span><a href="#42482954">next</a><span>|</span><label class="collapse" for="c-42484152">[-]</label><label class="expand" for="c-42484152">[1 more]</label></div><br/><div class="children"><div class="content">Unless I am missing something, as far as the work of Turing and Church is concerned, their answers are actually quite clear on this question of &quot;can&quot;, namely the class of partial recursive functions. This is precisely what a Turing machine can compute. It is also possible to build up to these functions in a concrete way using the simpler class of primitive recursive functions. Rogers book on recursive functions and computability is a great reference on this topic.</div><br/></div></div><div id="42482954" class="c"><input type="checkbox" id="c-42482954" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#42482930">parent</a><span>|</span><a href="#42484152">prev</a><span>|</span><a href="#42477109">next</a><span>|</span><label class="collapse" for="c-42482954">[-]</label><label class="expand" for="c-42482954">[5 more]</label></div><br/><div class="children"><div class="content">When I was working on this post I found the way that Turing defined “computable numbers” I bit unsatisfying as well.<p>What would you suggest I do to deliver on this?</div><br/><div id="42482998" class="c"><input type="checkbox" id="c-42482998" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42482930">root</a><span>|</span><a href="#42482954">parent</a><span>|</span><a href="#42477109">next</a><span>|</span><label class="collapse" for="c-42482998">[-]</label><label class="expand" for="c-42482998">[4 more]</label></div><br/><div class="children"><div class="content">I would suggest to not promise it. ;)<p>Maybe rather:<p>• That some truths cannot be computed.</div><br/><div id="42483021" class="c"><input type="checkbox" id="c-42483021" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#42482930">root</a><span>|</span><a href="#42482998">parent</a><span>|</span><a href="#42477109">next</a><span>|</span><label class="collapse" for="c-42483021">[-]</label><label class="expand" for="c-42483021">[3 more]</label></div><br/><div class="children"><div class="content">I’m not sure I understand. I do explain what can be computed, don’t I?<p>&gt; Something is said to be &quot;computable&quot; if there exists an algorithm that can get from the given input to the expected output. For example, adding together 2 integers is computable.<p>I could probably have dug into some of the restrictions, like how it has to be a finite number of steps.</div><br/><div id="42483178" class="c"><input type="checkbox" id="c-42483178" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42482930">root</a><span>|</span><a href="#42483021">parent</a><span>|</span><a href="#42477109">next</a><span>|</span><label class="collapse" for="c-42483178">[-]</label><label class="expand" for="c-42483178">[2 more]</label></div><br/><div class="children"><div class="content">This defines the term “computable”, but it doesn’t give you a sense of what things can be computed. Defining a term is entirely different from  the above promise.<p>At the level you’re describing Turing machines, it’s also not clear that readers would have a precise notion of what an algorithm is. At no point (unless I missed it) do you explain that any algorithm is supposed to be implementable as a Turing machine, or the assumption of what is otherwise known as the Church–Turing thesis.</div><br/><div id="42483198" class="c"><input type="checkbox" id="c-42483198" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#42482930">root</a><span>|</span><a href="#42483178">parent</a><span>|</span><a href="#42477109">next</a><span>|</span><label class="collapse" for="c-42483198">[-]</label><label class="expand" for="c-42483198">[1 more]</label></div><br/><div class="children"><div class="content">That’s true, there’s no explicit definition of what an algorithm is. I may revisit this. Thank you for the feedback.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42477109" class="c"><input type="checkbox" id="c-42477109" checked=""/><div class="controls bullet"><span class="by">mrymd</span><span>|</span><a href="#42482930">prev</a><span>|</span><a href="#42475891">next</a><span>|</span><label class="collapse" for="c-42477109">[-]</label><label class="expand" for="c-42477109">[2 more]</label></div><br/><div class="children"><div class="content">dope</div><br/><div id="42482470" class="c"><input type="checkbox" id="c-42482470" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#42477109">parent</a><span>|</span><a href="#42475891">next</a><span>|</span><label class="collapse" for="c-42482470">[-]</label><label class="expand" for="c-42482470">[1 more]</label></div><br/><div class="children"><div class="content">Thank you &lt;3</div><br/></div></div></div></div><div id="42482688" class="c"><input type="checkbox" id="c-42482688" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#42475891">prev</a><span>|</span><label class="collapse" for="c-42482688">[-]</label><label class="expand" for="c-42482688">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;d argue the key difference between Turing machines and real-world computers is that computers do IO, respond to events, have real-time characteristics, and are interactive. All of these are key features in making computers useful, but are poorly (if at all) captured by Turing machine model. It&#x27;s one thing to compute something, and another thing to play Doom.</div><br/><div id="42484381" class="c"><input type="checkbox" id="c-42484381" checked=""/><div class="controls bullet"><span class="by">bjornsing</span><span>|</span><a href="#42482688">parent</a><span>|</span><a href="#42482981">next</a><span>|</span><label class="collapse" for="c-42484381">[-]</label><label class="expand" for="c-42484381">[1 more]</label></div><br/><div class="children"><div class="content">The key difference between Turing machines and real-world computers is that Turing machines have infinite memory. A real-world computer is thus not really a Turing machine, but rather a finite state machine.</div><br/></div></div><div id="42482981" class="c"><input type="checkbox" id="c-42482981" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42482688">parent</a><span>|</span><a href="#42484381">prev</a><span>|</span><a href="#42483014">next</a><span>|</span><label class="collapse" for="c-42482981">[-]</label><label class="expand" for="c-42482981">[1 more]</label></div><br/><div class="children"><div class="content">You can have your I&#x2F;O and Doom graphics on the Turing tape no problem.<p>What’s different is that accessing an arbitrary position on the tape isn’t O(1), like normally assumed for memory, On the other hand, memory (and address space) on real-world computers is finite, so you can always find a large-enough constant to make the Turing equivalent O(1) again.</div><br/></div></div><div id="42483014" class="c"><input type="checkbox" id="c-42483014" checked=""/><div class="controls bullet"><span class="by">mikewarot</span><span>|</span><a href="#42482688">parent</a><span>|</span><a href="#42482981">prev</a><span>|</span><a href="#42483201">next</a><span>|</span><label class="collapse" for="c-42483014">[-]</label><label class="expand" for="c-42483014">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s an <i>almost</i> Turing equivalent mechanism that has no program counter and runs everything in parallel. I call it a BitGrid (it&#x27;s my hobby horse).  Because you can operate on all of the bits at the same time, you can get deterministic real time performance.<p>It&#x27;s a systolic array of Look Up Tables, 4 bits in, 4 bits out, with a latch on each latched.</div><br/></div></div><div id="42483201" class="c"><input type="checkbox" id="c-42483201" checked=""/><div class="controls bullet"><span class="by">mithametacs</span><span>|</span><a href="#42482688">parent</a><span>|</span><a href="#42483014">prev</a><span>|</span><label class="collapse" for="c-42483201">[-]</label><label class="expand" for="c-42483201">[1 more]</label></div><br/><div class="children"><div class="content">I&#x2F;O is just built on top of the tape.  Real computers reserve a map of memory to I&#x2F;O.<p>This is like saying a CPU isn&#x27;t a computer.  It&#x27;s sort of right but sort of wrong, you know?</div><br/></div></div></div></div></div></div></div></div></div></body></html>