<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699606860631" as="style"/><link rel="stylesheet" href="styles.css?v=1699606860631"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lwn.net/Articles/948870/">Deferred scheduling for user-space critical sections</a>Â <span class="domain">(<a href="https://lwn.net">lwn.net</a>)</span></div><div class="subtext"><span>signa11</span> | <span>8 comments</span></div><br/><div><div id="38216576" class="c"><input type="checkbox" id="c-38216576" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38216319">next</a><span>|</span><label class="collapse" for="c-38216576">[-]</label><label class="expand" for="c-38216576">[1 more]</label></div><br/><div class="children"><div class="content">This is an interesting idea. The core of it seems to be that the most efficient way to write locks today is to spin for a bit on contention, then yield to the kernel if you&#x27;ve been waiting to long. The goal, of course, is that if the lock is quickly released you don&#x27;t take the full cost of a kernel call and can just keep going in userspace. Darwin&#x27;s os_unfair_lock (and the closely related WebKit WTF::Lock) both use this strategy.<p>Interestingly, XNU already has an implementation of this that is somewhat similar in spirit: preemption free zones (<a href="https:&#x2F;&#x2F;github.com&#x2F;search?q=repo%3Aapple-oss-distributions%2Fxnu%20pfz&amp;type=code">https:&#x2F;&#x2F;github.com&#x2F;search?q=repo%3Aapple-oss-distributions%2...</a>). As far as I can tell os_atomic_lock does <i>not</i> use it for this purpose. Instead, it exists to allow OSAtomicFifoEnqueue&#x2F;OSAtomicFifoDequeue to be lock-free, and in the typical Apple fashion solves the problem of &quot;what if a userspace application uses this for evil&quot; by implementing it in the kernel and mapping it via the commpage (think vDSO), so there isn&#x27;t really any room for anyone but Apple to put code there.<p>Apple being Apple, they could have absolutely added PFZ to os_atomic_lock (for themselves, of course). One wonders why they didn&#x27;t; perhaps it just turns out that it isn&#x27;t worth the complexity.<p>(Look, I&#x27;m sorry all I talk about is Apple stuff, that&#x27;s all I know.)</div><br/></div></div><div id="38216319" class="c"><input type="checkbox" id="c-38216319" checked=""/><div class="controls bullet"><span class="by">EdSchouten</span><span>|</span><a href="#38216576">prev</a><span>|</span><a href="#38216488">next</a><span>|</span><label class="collapse" for="c-38216319">[-]</label><label class="expand" for="c-38216319">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know how I should feel about changes like this. My concern with &#x27;spinlocks in userspace&#x27; (i.e., locks that don&#x27;t just call into the futex API when they run into contention) is that they merely try to optimize for their own performance. Sure, the futex API has more overhead, but it does mean that other processes on your system can run in the meantime.<p>It&#x27;s sort of similar to using a TCP congestion algorithm that&#x27;s overly aggressive. Your own network connections might become faster as a result of them, but at the same time your flatmates won&#x27;t be able to check their mail.</div><br/><div id="38216610" class="c"><input type="checkbox" id="c-38216610" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38216319">parent</a><span>|</span><a href="#38216488">next</a><span>|</span><label class="collapse" for="c-38216610">[-]</label><label class="expand" for="c-38216610">[1 more]</label></div><br/><div class="children"><div class="content">Generally unbounded spins are terrible in userspace, but bounded spins as part of &quot;hybrid&quot; locks generally strike a good balance between performance and system impact. When a system call is hundreds or thousands of cycles it can be quite effective to try spending some fraction of that yourself if it&#x27;ll get you the lock without the syscall. Like, not just from a pure throughput perspective: a yield to the kernel is not &quot;free&quot;, it takes time just to park yourself. So it&#x27;s good to make a gamble usually.</div><br/></div></div></div></div><div id="38216488" class="c"><input type="checkbox" id="c-38216488" checked=""/><div class="controls bullet"><span class="by">dpc_01234</span><span>|</span><a href="#38216319">prev</a><span>|</span><a href="#38216310">next</a><span>|</span><label class="collapse" for="c-38216488">[-]</label><label class="expand" for="c-38216488">[1 more]</label></div><br/><div class="children"><div class="content">Without digging into details: this seems like a a great idea. It&#x27;s a cooperative, advisory optimization that can&#x27;t really be gamed for permanent cpu time gain. A hint to scheduler that indicates that letting a process run just a tiny moment more might be good for overall system performance.</div><br/></div></div><div id="38216310" class="c"><input type="checkbox" id="c-38216310" checked=""/><div class="controls bullet"><span class="by">hamilyon2</span><span>|</span><a href="#38216488">prev</a><span>|</span><a href="#38215875">next</a><span>|</span><label class="collapse" for="c-38216310">[-]</label><label class="expand" for="c-38216310">[1 more]</label></div><br/><div class="children"><div class="content">Wow, this feels wrong way to do it. The way i see it, threads and processes <i>waiting</i> on some resource should be able to update some piece if metadata pointing to the thing they are waiting for. This will allow &quot;donating&quot; their priority and cpu share to the other process&#x2F;thread.<p>This can be a general mechanism, which can be incorporated in the things kernel already know, creating a chain of dependencies and giving priority to something at the end of chain.</div><br/></div></div><div id="38215875" class="c"><input type="checkbox" id="c-38215875" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#38216310">prev</a><span>|</span><label class="collapse" for="c-38215875">[-]</label><label class="expand" for="c-38215875">[2 more]</label></div><br/><div class="children"><div class="content">Seems like a natural and necessary adaptation.  This is fundamentally a consequence of the fact that today there are many cores.  Kernel schedulers originated in a world where cores were precious and the kernel had to aggressively preclude user space from monopolizing them, and so no provision was made to allow user space to defer preemption.<p>Hardware evolves faster than software.</div><br/><div id="38216590" class="c"><input type="checkbox" id="c-38216590" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38215875">parent</a><span>|</span><label class="collapse" for="c-38216590">[-]</label><label class="expand" for="c-38216590">[1 more]</label></div><br/><div class="children"><div class="content">Needing to prevent applications from monopolizing the hardware is as necessary as it&#x27;s ever been. The question is whether userspace can voluntarily promise that it&#x27;ll be a good little process and behave in exchange for better performance, and corresponding penalties to institute for when that trust is broken.</div><br/></div></div></div></div></div></div></div></div></div></body></html>