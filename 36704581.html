<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689238853539" as="style"/><link rel="stylesheet" href="styles.css?v=1689238853539"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://arxiv.org/abs/2306.07583">Invertible Bloom Lookup Tables with Less Randomness and Memory</a> <span class="domain">(<a href="https://arxiv.org">arxiv.org</a>)</span></div><div class="subtext"><span>keepamovin</span> | <span>15 comments</span></div><br/><div><div id="36705255" class="c"><input type="checkbox" id="c-36705255" checked=""/><div class="controls bullet"><span class="by">natch</span><span>|</span><label class="collapse" for="c-36705255">[-]</label><label class="expand" for="c-36705255">[14 more]</label></div><br/><div class="children"><div class="content">I can never understand why some bloom filter (or in this case IBLT) implementations insist on using multiple different independent hash functions.<p>Just append a new salt to each input. For input ‘abc’ hashed say 8 times you simply construct abc-1, abc-2, abc-3, etc. up to abc-8 and hash each one and there you have 8 hash values that are no more prone to collisions than values produced by 8 independent hash functions.<p>Concerned that abc-n might appear naturally in the input? Fine, append an odd string that’s unlikely to appear in the input if that really is your genuine concern. Or pass the salt in as a second parameter instead.<p>And if your one hash function is so bad that abc-n is entangled with abc-n’, find a better hash function.<p>I admit this is not my field so this may be a naive take. What am I missing?</div><br/><div id="36705503" class="c"><input type="checkbox" id="c-36705503" checked=""/><div class="controls bullet"><span class="by">gabesullice</span><span>|</span><a href="#36705255">parent</a><span>|</span><a href="#36705426">next</a><span>|</span><label class="collapse" for="c-36705503">[-]</label><label class="expand" for="c-36705503">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know the answer, so I&#x27;m purely speculating for the fun of it.<p>I guess that hash function outputs aren&#x27;t perfectly uniformly distributed. E.g. if a toy hash function (a) produces a 2-bit output for a gajillion random inputs, you wouldn&#x27;t get a quarter of the values in each bucket. Maybe you&#x27;d get 30% in 00, 20% in 01, and 25% in both buckets 10 and 11. Salting the inputs wouldn&#x27;t help with that. It&#x27;d only make similar inputs less likely to collide, but collisions would still be more likely in the worst case.<p>By combining different a hash function (b) with different &quot;lumps&quot;, I suppose that the lumps would even out so that you&#x27;d approach a probability of .25 in each bucket.<p><pre><code>        00   01   10   11
  a    .30  .20  .25  .25
  b    .22  .22  .25  .31  
  a+b  .26  .21  .25  .28
</code></pre>
Therefore, if you&#x27;re going to spend time hashing something more than once, you might as well use different hash functions for each cycle.</div><br/><div id="36705605" class="c"><input type="checkbox" id="c-36705605" checked=""/><div class="controls bullet"><span class="by">tadkar</span><span>|</span><a href="#36705255">root</a><span>|</span><a href="#36705503">parent</a><span>|</span><a href="#36705426">next</a><span>|</span><label class="collapse" for="c-36705605">[-]</label><label class="expand" for="c-36705605">[2 more]</label></div><br/><div class="children"><div class="content">I suspect that for most Bloom filters, the most commonly used hash functions are “good enough”. There’s also some literature to suggest that using just 2 hash functions and recombining the results is plenty. See kirsch-mitzenmacher [1] and [2]<p>[1] <a href="https:&#x2F;&#x2F;www.eecs.harvard.edu&#x2F;%7Emichaelm&#x2F;postscripts&#x2F;tr-02-05.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.eecs.harvard.edu&#x2F;%7Emichaelm&#x2F;postscripts&#x2F;tr-02-0...</a>
[2] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;70963247&#x2F;bloom-filters-with-the-kirsch-mitzenmacher-optimization" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;70963247&#x2F;bloom-filters-w...</a></div><br/><div id="36705623" class="c"><input type="checkbox" id="c-36705623" checked=""/><div class="controls bullet"><span class="by">giveexamples</span><span>|</span><a href="#36705255">root</a><span>|</span><a href="#36705605">parent</a><span>|</span><a href="#36705426">next</a><span>|</span><label class="collapse" for="c-36705623">[-]</label><label class="expand" for="c-36705623">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Double_hashing" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Double_hashing</a> is probably the canonical name for this</div><br/></div></div></div></div></div></div><div id="36705426" class="c"><input type="checkbox" id="c-36705426" checked=""/><div class="controls bullet"><span class="by">sakras</span><span>|</span><a href="#36705255">parent</a><span>|</span><a href="#36705503">prev</a><span>|</span><a href="#36705795">next</a><span>|</span><label class="collapse" for="c-36705426">[-]</label><label class="expand" for="c-36705426">[1 more]</label></div><br/><div class="children"><div class="content">I think the issue is awareness. The “modern” way to do it is to precompute a table of bit patterns, and use the bottom few bits of the hash to lookup the bit patterns and set them in the Bloom filter. I wrote a blog post about it if you’re curious: <a href="https:&#x2F;&#x2F;save-buffer.github.io&#x2F;bloom_filter.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;save-buffer.github.io&#x2F;bloom_filter.html</a></div><br/></div></div><div id="36705795" class="c"><input type="checkbox" id="c-36705795" checked=""/><div class="controls bullet"><span class="by">thomasmg</span><span>|</span><a href="#36705255">parent</a><span>|</span><a href="#36705426">prev</a><span>|</span><a href="#36705474">next</a><span>|</span><label class="collapse" for="c-36705795">[-]</label><label class="expand" for="c-36705795">[1 more]</label></div><br/><div class="children"><div class="content">When I started reading such papers this also confused me.<p>Yes, it&#x27;s about randomness and probability of collisions. Adding two characters might be OK or not, it depends on the hash function and the use case. For example, the Java &quot;String.hashCode&quot; method return &quot;abc-1&quot;: 92597638, &quot;abc-2&quot;: 92597639; the hash code of the &quot;-2&quot; is (almost) always one greater than the &quot;-1&quot; variant. So the two are not independent. Anyway 32-bit hash functions might not be good and you need 64 bit. Then you should use something like MurmurHash.<p>But you don&#x27;t need to compute MurmurHash twice. It is probably enough to compute one MurmurHash, and then hash this hash code using an integer hash function [1]: h1=integerHash(hash + 1), h2=integerHash(hash + 2). This is almost twice as fast for string data.<p>For certain use cases, for example for Bloom filters, you need more hash &quot;functions&quot;. For Bloom filters, it is even simpler: you can split a 64-bit hash code into a 32-bit start, and a 32-bit offset. And then use: h(x)=start+x*offset. That means h(3)=h(2)+offset and so on. It is really fast.<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;664014&#x2F;what-integer-hash-function-are-good-that-accepts-an-integer-hash-key&#x2F;12996028#12996028" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;664014&#x2F;what-integer-hash...</a></div><br/></div></div><div id="36705474" class="c"><input type="checkbox" id="c-36705474" checked=""/><div class="controls bullet"><span class="by">112233</span><span>|</span><a href="#36705255">parent</a><span>|</span><a href="#36705795">prev</a><span>|</span><a href="#36705419">next</a><span>|</span><label class="collapse" for="c-36705474">[-]</label><label class="expand" for="c-36705474">[1 more]</label></div><br/><div class="children"><div class="content">What you did just now is you constructed a family of independent hash functions. It is a terminology thing about those output collisions, and you provided one possible implementation.</div><br/></div></div><div id="36705419" class="c"><input type="checkbox" id="c-36705419" checked=""/><div class="controls bullet"><span class="by">boyter</span><span>|</span><a href="#36705255">parent</a><span>|</span><a href="#36705474">prev</a><span>|</span><a href="#36706039">next</a><span>|</span><label class="collapse" for="c-36705419">[-]</label><label class="expand" for="c-36705419">[1 more]</label></div><br/><div class="children"><div class="content">You aren’t missing anything. I don’t have the paper handy but I had the same question and found a study showing that a salt worked fine.<p>I’m just glad im not the only one to wonder this. Perhaps that’s the issue. It feels wrong for some reason despite not being an issue in practice.</div><br/></div></div><div id="36706039" class="c"><input type="checkbox" id="c-36706039" checked=""/><div class="controls bullet"><span class="by">jstanley</span><span>|</span><a href="#36705255">parent</a><span>|</span><a href="#36705419">prev</a><span>|</span><a href="#36706038">next</a><span>|</span><label class="collapse" for="c-36706039">[-]</label><label class="expand" for="c-36706039">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Concerned that abc-n might appear naturally in the input?<p>I&#x27;m not, because that would turn in to &quot;abc-n-1&quot;, &quot;abc-n-2&quot;, etc.</div><br/></div></div><div id="36706038" class="c"><input type="checkbox" id="c-36706038" checked=""/><div class="controls bullet"><span class="by">johanvts</span><span>|</span><a href="#36705255">parent</a><span>|</span><a href="#36706039">prev</a><span>|</span><a href="#36705821">next</a><span>|</span><label class="collapse" for="c-36706038">[-]</label><label class="expand" for="c-36706038">[1 more]</label></div><br/><div class="children"><div class="content">w.r.t the paper when they say they need k-wise independent hash functions, this is a requirement on the family of hash functions used. It’s not the functions that are independent of each other, it’s the values from any particular function that are independent of each other. Just in case this wasn’t already clear.</div><br/></div></div><div id="36705821" class="c"><input type="checkbox" id="c-36705821" checked=""/><div class="controls bullet"><span class="by">willvarfar</span><span>|</span><a href="#36705255">parent</a><span>|</span><a href="#36706038">prev</a><span>|</span><a href="#36705382">next</a><span>|</span><label class="collapse" for="c-36705821">[-]</label><label class="expand" for="c-36705821">[2 more]</label></div><br/><div class="children"><div class="content">And so we wonder, are there vectorized versions of a hash function where you can compute n hashes with different salts in the same cpu time as you&#x27;d normally do one?</div><br/><div id="36705954" class="c"><input type="checkbox" id="c-36705954" checked=""/><div class="controls bullet"><span class="by">sakras</span><span>|</span><a href="#36705255">root</a><span>|</span><a href="#36705821">parent</a><span>|</span><a href="#36705382">next</a><span>|</span><label class="collapse" for="c-36705954">[-]</label><label class="expand" for="c-36705954">[1 more]</label></div><br/><div class="children"><div class="content">Usually you&#x27;d just hash several different elements at once in a vectorized way.</div><br/></div></div></div></div><div id="36705382" class="c"><input type="checkbox" id="c-36705382" checked=""/><div class="controls bullet"><span class="by">davidst</span><span>|</span><a href="#36705255">parent</a><span>|</span><a href="#36705821">prev</a><span>|</span><label class="collapse" for="c-36705382">[-]</label><label class="expand" for="c-36705382">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you&#x27;re missing anything. Years ago, I made the same observation, and ran a test to compare independent hash functions vs salting. It showed no difference. I would be interested if someone here has a different opinion and a rationale to explain what I might have missed.</div><br/><div id="36705423" class="c"><input type="checkbox" id="c-36705423" checked=""/><div class="controls bullet"><span class="by">keepamovin</span><span>|</span><a href="#36705255">root</a><span>|</span><a href="#36705382">parent</a><span>|</span><label class="collapse" for="c-36705423">[-]</label><label class="expand" for="c-36705423">[1 more]</label></div><br/><div class="children"><div class="content">Seems legit. Good hash function digests should be as independent from each other respecting seed, as they are from digests of other hash functions with the same seed.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>