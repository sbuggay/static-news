<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689152467644" as="style"/><link rel="stylesheet" href="styles.css?v=1689152467644"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://research.swtch.com/pcdata">Storing Data in Control Flow</a> <span class="domain">(<a href="https://research.swtch.com">research.swtch.com</a>)</span></div><div class="subtext"><span>chmaynard</span> | <span>27 comments</span></div><br/><div><div id="36686888" class="c"><input type="checkbox" id="c-36686888" checked=""/><div class="controls bullet"><span class="by">knome</span><span>|</span><a href="#36688131">next</a><span>|</span><label class="collapse" for="c-36686888">[-]</label><label class="expand" for="c-36686888">[5 more]</label></div><br/><div class="children"><div class="content">There is a game called TIS-100 where you solve problems using a grid of networked processors that can each store one current register and a second value you can swap to. It&#x27;s an extremely constrained environment as such.<p>There is one challenge where you receive a series of numbers, have to sort and then output them. The game provides a couple of FIFO units you can read and write from in order to facilitate this.<p>I, instead, decided to do it without using them. I ended up storing all of the state in branching. By passing values down and then jumping and returning literals from branches, it gave me effectively a comparatively massive amount of space based on where the instruction pointer was sitting in any given node, letting me manipulate the state, storing it as branches taken, and then dumping out literals from the lowest levels of those before resetting the nodes for the next series of values.<p>It made me cognizant of how state, assumptions and literal values are &quot;stored&quot; by which branch you choose, with no actual variables.<p>This is also what happens when you run a &quot;check&quot; on a value rather than parsing it into a more specific type related to the check [1]. After a `if( !isa_username( somestring) ){ return ; }` you will often assume that `somename` is a username without actually encoding that into its type.<p>Because these assumptions are not checked by the compiler, then the compiler can&#x27;t stop you from inappropriately merging branches or accidentally cutting out checks later.<p>It&#x27;s powerful, common, and generally dangerous.<p>[1] <a href="https:&#x2F;&#x2F;lexi-lambda.github.io&#x2F;blog&#x2F;2019&#x2F;11&#x2F;05&#x2F;parse-don-t-validate&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;lexi-lambda.github.io&#x2F;blog&#x2F;2019&#x2F;11&#x2F;05&#x2F;parse-don-t-va...</a></div><br/><div id="36687329" class="c"><input type="checkbox" id="c-36687329" checked=""/><div class="controls bullet"><span class="by">riwsky</span><span>|</span><a href="#36686888">parent</a><span>|</span><a href="#36688131">next</a><span>|</span><label class="collapse" for="c-36687329">[-]</label><label class="expand" for="c-36687329">[4 more]</label></div><br/><div class="children"><div class="content">Not checked by the compiler, except for cases where they’re checked by the compiler: <a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;narrowing.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;narrowing.htm...</a><p>TS is probably the most famous gradual-type system to do this, but IIRC pycharm is smart enough to figure this out for its python linting, too</div><br/><div id="36687563" class="c"><input type="checkbox" id="c-36687563" checked=""/><div class="controls bullet"><span class="by">knome</span><span>|</span><a href="#36686888">root</a><span>|</span><a href="#36687329">parent</a><span>|</span><a href="#36688131">next</a><span>|</span><label class="collapse" for="c-36687563">[-]</label><label class="expand" for="c-36687563">[3 more]</label></div><br/><div class="children"><div class="content">Narrowing involves actual types. I was referring to the compiler not checking mere value validation.<p>I was referencing the kind of validation where someone checks a bunch of attributes of a string, usually, or perhaps the range of an integer, but never actually does anything excepting in fail cases and then passes it on to other functions that then just expect those invariants to hold. I doubt typescript is remembering that my string doesn&#x27;t have dashes in it or that it adheres to some regex, for example.<p>Type narrowing is fantastic for making things like nil punning work inside a complex type system.<p>I really like typescript&#x27;s types. From where they started, they did an absolutely incredible job creating a robust and powerful type system that could manage almost any existing javascript code pattern.<p>Just really amazing work by the authors.</div><br/><div id="36690915" class="c"><input type="checkbox" id="c-36690915" checked=""/><div class="controls bullet"><span class="by">riwsky</span><span>|</span><a href="#36686888">root</a><span>|</span><a href="#36687563">parent</a><span>|</span><a href="#36688131">next</a><span>|</span><label class="collapse" for="c-36690915">[-]</label><label class="expand" for="c-36690915">[2 more]</label></div><br/><div class="children"><div class="content">it will remember it if you ask it to, like in this example from <a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;play#example&#x2F;nominal-typing" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;play#example&#x2F;nominal-typing</a> :<p><pre><code>  type ValidatedInputString = string &amp; { __brand: &quot;User Input Post Validation&quot; };

  const validateUserInput = (input: string) =&gt; {
    const simpleValidatedInput = input.replace(&#x2F;\&lt;&#x2F;g, &quot;≤&quot;);
    return simpleValidatedInput as ValidatedInputString;
  };
</code></pre>
at runtime, simpleValidatedInput is still a string—it has not been parsed into a more specific type. The code just asserts (falsely) that it&#x27;s a ValidatedInputString, and defines the latter in a way that prevents passing string-strings as ValidatedInputStrings.</div><br/><div id="36691108" class="c"><input type="checkbox" id="c-36691108" checked=""/><div class="controls bullet"><span class="by">knome</span><span>|</span><a href="#36686888">root</a><span>|</span><a href="#36690915">parent</a><span>|</span><a href="#36688131">next</a><span>|</span><label class="collapse" for="c-36691108">[-]</label><label class="expand" for="c-36691108">[1 more]</label></div><br/><div class="children"><div class="content">I do appreciate your expounding on this, but I assure you I do get it.<p>Using types to track these things is the appropriate solution. In most languages you would either create a wrapping object you can get the original back from or perhaps extend the basic type. Here we can just use `as` to cast the value into an intersection with the number, which I assume allows it to continue being used as a number but will catch failures on functions that needs a ValidatedInputString, in much the same way the an inherited subtype might. Probably better.<p>I get it and you are right, this is the right thing to do.<p>My original comment was that for those that do <i>not</i> do this appropriate type level work to track that we have validated a value, then it becomes an assumed aspect of the branch.<p>This was very, very common in older code I&#x27;ve seen. I think I can safely assume that it still happens today, though if I am wrong I&#x27;ll be glad that parsing the values into new types has made enough headway that it is seen as simply the default.<p>Because it is certainly the RightThingToDo.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36688131" class="c"><input type="checkbox" id="c-36688131" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#36686888">prev</a><span>|</span><a href="#36687736">next</a><span>|</span><label class="collapse" for="c-36688131">[-]</label><label class="expand" for="c-36688131">[4 more]</label></div><br/><div class="children"><div class="content">I have second thoughts on the author&#x27;s assertion that &quot;When it’s possible to store state in code instead, that often leads to a clearer program.&quot;<p>I have found that an explicit state machine can be more readable when there are many states. When there are too many states, a straightforward transformation to control flow often cannot eliminate all the &quot;goto&quot;s like the author successfully did. Even if they were eliminated, there are usually too many nested &quot;if&quot; conditions and the like to be easily readable. That&#x27;s the kind of spaghetti code that first inspired a ban on goto. (And that&#x27;s not even including cases when you are writing code to a spec that&#x27;s a state machine, like the TCP state machine.)<p>What I personally like, sometimes, is to make the state variable an enum and give names to be states. State 0 becomes kBeforeStart, state 1 becomes kInsideQuote, state 2 becomes kAfterBackslash. It suddenly now becomes intuitive. If you&#x27;ve written any kind of emulator or interpreter it&#x27;s even more intuitive, because the state machine is just the DFA expanded from the regular expression. If I&#x27;m using a language with guaranteed tail calls, I can also replace each case in that switch by a separate named function.<p>It&#x27;s possible to write clear and readable code in either style. Doing so requires skill and expertise, of which I don&#x27;t think the author lacks.</div><br/><div id="36689012" class="c"><input type="checkbox" id="c-36689012" checked=""/><div class="controls bullet"><span class="by">ww520</span><span>|</span><a href="#36688131">parent</a><span>|</span><a href="#36688567">next</a><span>|</span><label class="collapse" for="c-36689012">[-]</label><label class="expand" for="c-36689012">[2 more]</label></div><br/><div class="children"><div class="content">Yes.  The second version is difficult to understand when there&#x27;s a need to add new states or modify the states.  The first version has a straightforward structure and shape, making it easier to understand and update the state machine.</div><br/><div id="36691915" class="c"><input type="checkbox" id="c-36691915" checked=""/><div class="controls bullet"><span class="by">barrkel</span><span>|</span><a href="#36688131">root</a><span>|</span><a href="#36689012">parent</a><span>|</span><a href="#36688567">next</a><span>|</span><label class="collapse" for="c-36691915">[-]</label><label class="expand" for="c-36691915">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t agree. The second version is the typical way hand-written compiler lexers are written, and they&#x27;re straightforward to add new &quot;states&quot; to, or to modify the states. The program counter is where you&#x27;re &quot;at&quot;, and the state space is normally straightforward. In fact it only gets complicated when additional non-control-flow state has been added.<p>A typical hand-written lexer looks a bit like this (EOF testing omitted for clarity):<p><pre><code>  &#x2F;&#x2F; skip whitespace
  while isWhiteSpace(peekChar())
    nextChar()

  &#x2F;&#x2F; determine token type
  switch (peekChar())
    case isAlpha
      start := currentPosition()
      nextChar()
      while isAlphaNumeric(peekChar())
        nextChar()
      tokenType = IDENT
      tokenValue = substring(start, currentPosition())
      
    case isNumeric
      start := currentPosition()
      nextChar()
      while isNumeric(peekChar())
        nextChar()
      tokenType = INT
      tokenValue = substring(start, currentPosition())
      tokenAsInt = int(tokenValue)

    case &#x27;+&#x27;
      nextChar()
      tokenType = PLUS

    &#x2F;&#x2F; and so on
</code></pre>
Adding new cases to this is trivial. Nested context-specific lexical details (like escape codes in strings) aren&#x27;t merged with a global state machine, and can be handed off to subroutines, enabling a modularity which is less confusing than having multiple state machines.</div><br/></div></div></div></div><div id="36688567" class="c"><input type="checkbox" id="c-36688567" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#36688131">parent</a><span>|</span><a href="#36689012">prev</a><span>|</span><a href="#36687736">next</a><span>|</span><label class="collapse" for="c-36688567">[-]</label><label class="expand" for="c-36688567">[1 more]</label></div><br/><div class="children"><div class="content">Completely agree. When control flow gets messy, materializing it in explicit state variables is in my experience a significant improvement.</div><br/></div></div></div></div><div id="36687736" class="c"><input type="checkbox" id="c-36687736" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#36688131">prev</a><span>|</span><a href="#36687640">next</a><span>|</span><label class="collapse" for="c-36687736">[-]</label><label class="expand" for="c-36687736">[7 more]</label></div><br/><div class="children"><div class="content">What&#x27;s really unfortunate is that compilers <i>already</i> perform this &quot;control flow -&gt; state machine&quot; transformation, but almost none of them expose it to the user for direct manipulation - instead, they tightly couple it to a bunch of unrelated abstractions like event loop runtimes, async executors, managed stacks, etc. I&#x27;d kill for a compiler that can properly:<p>* Parse a coroutine that produces and consumes values<p>* Perform all the normal function-level optimizations to minimize frame space (stack slot reuse via liveness analysis of local variables, re-computing temporaries across yield points, etc.)<p>* Expose that coroutine frame as a fixed-size struct that I can explicitly resume and query<p>Zig is <i>almost</i> there, but suspend&#x2F;resume cannot return values&#x2F;take arguments, which requires some unergonomic workarounds. Rust is making some promising progress on unified coroutines (<a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;2781">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;2781</a>), but the generator types are opaque so you can&#x27;t encapsulate them in a Sized struct or allocate an array of them. Not to mention that it&#x27;s still extra-unstable, and last I checked, there were issues with generator size optimizations (<a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;59087">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;59087</a>). C++20 coroutines are similarly opaque and cannot be allocated as a contiguous array.</div><br/><div id="36687885" class="c"><input type="checkbox" id="c-36687885" checked=""/><div class="controls bullet"><span class="by">AlphaSite</span><span>|</span><a href="#36687736">parent</a><span>|</span><a href="#36688549">next</a><span>|</span><label class="collapse" for="c-36687885">[-]</label><label class="expand" for="c-36687885">[5 more]</label></div><br/><div class="children"><div class="content">Are you asking for what is roughly Python generator expressions but in a compiled language?</div><br/><div id="36688006" class="c"><input type="checkbox" id="c-36688006" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#36687736">root</a><span>|</span><a href="#36687885">parent</a><span>|</span><a href="#36688549">next</a><span>|</span><label class="collapse" for="c-36688006">[-]</label><label class="expand" for="c-36688006">[4 more]</label></div><br/><div class="children"><div class="content">Yes, something like Python generators which have yield and send, but typed, and which compiles down to an efficiently sized struct with a resume function. Here&#x27;s a crude illustration of what I mean, using pseudo-code describing a TCP session flow:<p><pre><code>  coroutine tcp_session() {
    var syn_packet = @consume();
    if(!check_syn_flag(syn_packet)) {
      @produce(ERROR_BAD_INPUT);
      return;
    }
    var syn_ack_packet = build_tcp_segment(...);
    @produce(syn_ack_packet);
    var ack_packet = @consume();
    if(!check_ack_flag(ack_packet)) {
      @produce(ERROR_BAD_INPUT);
    }
    &#x2F;&#x2F; ... proceed with tcp session
  }
</code></pre>
Such a coroutine would then be usable elsewhere in code like so:<p><pre><code>  var tcp_connections = map&lt;(ip_address, u16), tcp_session&gt;::new();
  &#x2F;&#x2F; ...
  var incoming_ip_packet = read_ip_packet_from_raw_socket();
  var result = tcp_connections[get_dst(incoming_ip_packet)].resume(incoming_ip_packet);
  if(result == ERROR_BAD_INPUT) {
    &#x2F;&#x2F; ...
  }
</code></pre>
And the compiler would be able to determine upfront what the size of the tcp_session struct is, so there&#x27;d be no need for implicit boxing&#x2F;heap allocations.</div><br/><div id="36688419" class="c"><input type="checkbox" id="c-36688419" checked=""/><div class="controls bullet"><span class="by">tekacs</span><span>|</span><a href="#36687736">root</a><span>|</span><a href="#36688006">parent</a><span>|</span><a href="#36691581">next</a><span>|</span><label class="collapse" for="c-36688419">[-]</label><label class="expand" for="c-36688419">[2 more]</label></div><br/><div class="children"><div class="content">You kinda can do this in Rust at the moment with async, in the sense of:<p><a href="https:&#x2F;&#x2F;docs.rs&#x2F;async-stream&#x2F;latest&#x2F;async_stream&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.rs&#x2F;async-stream&#x2F;latest&#x2F;async_stream&#x2F;</a><p>So something like this, off the top of my head. It&#x27;s not the most Rust-native code because I tried to match your code block as closely as possible to make the parallels more obvious.<p><pre><code>  struct TCPHandle {
    sender: Sender&lt;TCPPacket&gt;,
    &#x2F;&#x2F; I&#x27;m taking liberties here, you can&#x27;t use impl like this
    &#x2F;&#x2F; so you&#x27;d have to engage in some shenanigans which I don&#x27;t
    &#x2F;&#x2F; want to type right now...
    stream_to_client: impl Stream&lt;Item = Result&lt;TCPPacket, TCPError&gt;&gt;,
  }
  
  fn tcp_session() -&gt; TCPHandle {
    let (sender, receiver) = channel();
    let stream_to_client = stream! {
      let syn_packet = receiver.recv().await;
      if (!check_syn_flag(syn_packet)) {
        yield Err(TCPError::BadInputError);
        return;
      }
      let syn_ack_packet = build_tcp_segment(...);
      yield Ok(syn_ack_packet);
      let ack_packet = receiver.recv().await;
      if (!check_ack_flag(ack_packet)) {
        yield Err(TCPError::BadInputError);
        return;
      }
      &#x2F;&#x2F; ... proceed with TCP session
    }
    TCPHandle { sender, stream_to_client }
  }
  
  let tcp_connections = HashMap&lt;(Ipv4Addr, u16), TCPHandle&gt;;
  loop {
    let incoming_ip_packet = read_ip_packet_from_raw_socket().await;
    let handle = tcp_connections.get_mut(get_dst(&amp;incoming_ip_packet));
    handle.sender.send(incoming_ip_packet).await;
    let result = handle.stream_to_client.next().await;
    match result {
      Ok(packet) =&gt; send_ip_packet_to_raw_socket(packet).await,
      Err(e) =&gt; { ... handle errors },
    }
  }
</code></pre>
I&#x27;m curious how something like this would work for your purposes... you could probably wrap the whole thing up a little more and make it behave even more like your example?</div><br/><div id="36688811" class="c"><input type="checkbox" id="c-36688811" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#36687736">root</a><span>|</span><a href="#36688419">parent</a><span>|</span><a href="#36691581">next</a><span>|</span><label class="collapse" for="c-36688811">[-]</label><label class="expand" for="c-36688811">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m aware that encapsulated control flow like this exists at a syntactic level, but the implementation deficiencies remain unaddressed:<p>1. No access to the actual concrete type, as you mentioned, which means you can&#x27;t do Vec&lt;Stream&lt;...&gt;&gt; - you have to resort to indirections like Vec&lt;Box&lt;dyn Stream&lt;...&gt;&gt;&gt;. You <i>might</i> be able to work around this somehow if you were determined enough (DWARF debug info and std::mem::transmute come to mind), but any such approach would result in an ugly and exceedingly fragile abomination.<p>2. Brittle, if any, optimization. `stream!` is basically async&#x2F;await with proc macro syntax dressing, and Rust&#x27;s async&#x2F;await implementation still suffers the same sort of bloated frame size issues as generators do, under certain circumstances.<p>To provide some context, suppose I want to write a custom event loop that handles millions of concurrent sessions (could be filesystem transactions, or TCP sessions, or some other I&#x2F;O). At that level, every kilobyte of per-session data I add equates to additional gigabytes of memory usage. Every byte of space used by the compiler-generated state machine has to be carefully accounted for. I can&#x27;t afford to have my per-session context blowing up in size because the compiler naively duplicates stack slots for arguments across yield points [1], or because one of my local variable types implements Copy [2], or because the compiler will simply fail to optimize local variables that are never live across a yield point [3]. I suppose if I care so much about memory usage, I could just draw up my own state machine, mentally track the liveness of each state variable and lay out a hand-written size-optimized struct accordingly, but that&#x27;s going to be a painful exercise and a maintainability nightmare.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;62958">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;62958</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;62952">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;62952</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;59087">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;59087</a></div><br/></div></div></div></div><div id="36691581" class="c"><input type="checkbox" id="c-36691581" checked=""/><div class="controls bullet"><span class="by">di4na</span><span>|</span><a href="#36687736">root</a><span>|</span><a href="#36688006">parent</a><span>|</span><a href="#36688419">prev</a><span>|</span><a href="#36688549">next</a><span>|</span><label class="collapse" for="c-36691581">[-]</label><label class="expand" for="c-36691581">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that basically what typed effect handlers are?</div><br/></div></div></div></div></div></div><div id="36688549" class="c"><input type="checkbox" id="c-36688549" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#36687736">parent</a><span>|</span><a href="#36687885">prev</a><span>|</span><a href="#36687640">next</a><span>|</span><label class="collapse" for="c-36688549">[-]</label><label class="expand" for="c-36688549">[1 more]</label></div><br/><div class="children"><div class="content">There is this if you are feeling brave: <a href="https:&#x2F;&#x2F;www.boost.org&#x2F;doc&#x2F;libs&#x2F;1_82_0&#x2F;boost&#x2F;asio&#x2F;coroutine.hpp" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.boost.org&#x2F;doc&#x2F;libs&#x2F;1_82_0&#x2F;boost&#x2F;asio&#x2F;coroutine.h...</a></div><br/></div></div></div></div><div id="36687640" class="c"><input type="checkbox" id="c-36687640" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#36687736">prev</a><span>|</span><a href="#36689044">next</a><span>|</span><label class="collapse" for="c-36687640">[-]</label><label class="expand" for="c-36687640">[3 more]</label></div><br/><div class="children"><div class="content">Thanks for this.<p>I think high level control over control flow manipulation is really underrated and underutilised in programming languages.<p>For example, the decision where to jump is extremely powerful but the primitives we have for it are weak. (Exceptions, algebraic effects, if statements)<p>Inheritance controls control flow but doesn&#x27;t actually solve the pattern of desired behaviour and code organisation most people want.<p>One idea I am exploring is the idea that efficient control flow can be compiled from the inferred relationships of a rule engine.<p>Information systems should be used to create all the relationships between data and associations of desired behaviour to data values or partial data values.<p>Then all the if statements, switch statements and vtables can be inferred.<p>In other words the types the code operates on is inferred from desired behaviour based on state.</div><br/><div id="36689991" class="c"><input type="checkbox" id="c-36689991" checked=""/><div class="controls bullet"><span class="by">xyzzy_plugh</span><span>|</span><a href="#36687640">parent</a><span>|</span><a href="#36689044">next</a><span>|</span><label class="collapse" for="c-36689991">[-]</label><label class="expand" for="c-36689991">[2 more]</label></div><br/><div class="children"><div class="content">I, too, once thought this way. The problem is that inference and implicit behavior is cognitively expensive. With any language, humans have to be able to act as an adhoc,  likely unoptimized or even worst case compiler.<p>You can work around this by transcending text with all the comforts of a modern IDE, interacting with the toolchain directly, but this has a cost too. The toolchain is often out of reach during code reviews, in diffs, snippets, etc.<p>Now I much prefer the ability to comprehend printed code revealed in spots under flickering candlelight or rasterized on a pocket display consumed while in a moving vehicle, or a drunken stupor even.</div><br/><div id="36691721" class="c"><input type="checkbox" id="c-36691721" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#36687640">root</a><span>|</span><a href="#36689991">parent</a><span>|</span><a href="#36689044">next</a><span>|</span><label class="collapse" for="c-36691721">[-]</label><label class="expand" for="c-36691721">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right, of course - it does indeed have the potential to increase cognitive expense. I would hope it would only increase cognitive load in the rule engine interface. But I would want that to be a GUI. I think I would prefer that to parsing custom code each time (that&#x27;s the tradeoff I&#x27;m making).<p>I just get very frustrated reading other people&#x27;s code that encode complicated rules that I need to decipher how they&#x27;ve represented the mapping of code to behaviour.<p>In corporate Java projects, I think what gets created is complicated structures and abstractions to handle flexibility and abstract over details that are harder to understand than the English explanation of what they&#x27;re trying to do. WHEN X DO Y.<p>When people reach for the visitor pattern, controllers, inheritance, runtime reflection control flow and annotations and object proxies, overridden methods and so on. It&#x27;s a overcomplicated bespoke dance about managing control flow and they&#x27;re all different strategies but they do the same thing.<p>The idea is in early stages. I&#x27;m currently working on something else, I am trying to understand the control flow of a coroutine and yield.</div><br/></div></div></div></div></div></div><div id="36689044" class="c"><input type="checkbox" id="c-36689044" checked=""/><div class="controls bullet"><span class="by">akdor1154</span><span>|</span><a href="#36687640">prev</a><span>|</span><a href="#36688150">next</a><span>|</span><label class="collapse" for="c-36689044">[-]</label><label class="expand" for="c-36689044">[2 more]</label></div><br/><div class="children"><div class="content">How would one go about this in C or Rust? Chans are idiomatic and fast in Golang, what would you do in places lacking that?<p>Context: all my Rust programs recently have been ending up structured around some threads communicating item-by-item with mpsc_channels. This feels (unsubstantiated) non-ideal, esp if I&#x27;m doing something latency sensitive like processing input. But what, if anything, to do instead?</div><br/><div id="36689306" class="c"><input type="checkbox" id="c-36689306" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#36689044">parent</a><span>|</span><a href="#36688150">next</a><span>|</span><label class="collapse" for="c-36689306">[-]</label><label class="expand" for="c-36689306">[1 more]</label></div><br/><div class="children"><div class="content">C is a language without much of a standard library. To do this in C you&#x27;d first need to write a coroutine library.<p>In Rust, your approach sounds fine. However you should also consider simply using Rust&#x27;s iterator. Define a struct containing the state you want, then implement it as an Iterator. In the future, you can also just write control flow and have the compiler transform that for you. Take a look at the first few sections of <a href="https:&#x2F;&#x2F;lang-team.rust-lang.org&#x2F;design_notes&#x2F;general_coroutines.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;lang-team.rust-lang.org&#x2F;design_notes&#x2F;general_corouti...</a></div><br/></div></div></div></div><div id="36688150" class="c"><input type="checkbox" id="c-36688150" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#36689044">prev</a><span>|</span><a href="#36689863">next</a><span>|</span><label class="collapse" for="c-36688150">[-]</label><label class="expand" for="c-36688150">[1 more]</label></div><br/><div class="children"><div class="content">This makes me think of tries.  You don’t actually need to store the value at the leaf if you simply knew the path traversed in the traversal function.  Of course sometimes it’s more efficient to store values.</div><br/></div></div><div id="36689863" class="c"><input type="checkbox" id="c-36689863" checked=""/><div class="controls bullet"><span class="by">philosopher1234</span><span>|</span><a href="#36688150">prev</a><span>|</span><a href="#36687936">next</a><span>|</span><label class="collapse" for="c-36689863">[-]</label><label class="expand" for="c-36689863">[1 more]</label></div><br/><div class="children"><div class="content">This is a lead up to a new proposal for go iterators.</div><br/></div></div><div id="36687936" class="c"><input type="checkbox" id="c-36687936" checked=""/><div class="controls bullet"><span class="by">ramesh31</span><span>|</span><a href="#36689863">prev</a><span>|</span><a href="#36686977">next</a><span>|</span><label class="collapse" for="c-36687936">[-]</label><label class="expand" for="c-36687936">[2 more]</label></div><br/><div class="children"><div class="content">Think of all the confusion and hot air that could be saved if we all just switched to Lisp.</div><br/><div id="36691044" class="c"><input type="checkbox" id="c-36691044" checked=""/><div class="controls bullet"><span class="by">kmstout</span><span>|</span><a href="#36687936">parent</a><span>|</span><a href="#36686977">next</a><span>|</span><label class="collapse" for="c-36691044">[-]</label><label class="expand" for="c-36691044">[1 more]</label></div><br/><div class="children"><div class="content">The game that I&#x27;m working on in my spare time has a lot of state machines in it compiled to CLOS, letting me use method calls as a means of directly sending  sending events.  Rather than write all those methods myself, with `case` forms on the state, I spent an afternoon writing this [0]<p><pre><code>  (defmacro defdelta (class &amp;body body)
    (let* ((body `(,@body
                   (- enter - - -)
                   (- leave - - -)))
           (acc (group-by
                 1
                 (let ((-q0) (-e) (-w) (-q) (-a))
                   (loop for (q0 e w q a) in (cdr body) do
                     (setf -q0 (tc q0 -q0)
                           -e  (tc e  -e)
                           -w  (tc w  -w)
                           -q  (tc q  -q)
                           -a  (tc a  -a))
                         collect (list -q0 -e -w -q -a))))))
      (push (cons class acc) *delta*)
      `(progn
         ,@(loop for (e . clauses) in acc collecting
                 `(progn
                    (defevent ,e)
                    (defmethod ,e ((me ,class) &amp;rest args)
                      (when (member *@* args)
                        (apply #&#x27;emit &#x27;,e (state me) me args))
                      (case (state me)
                        ,@ (loop for (q0 . deltas) in (group-by 0 clauses)
                                 collecting
                                 `(,q0 (random-case
                                         ,@ (loop for (- -- w q a) in deltas
                                                  collecting
                                                  `((,@(or w 1))
                                                    ,@(when (and q (not (eq q0 q)))
                                                        `((change-state me &#x27;,q args)))
                                                    ,@(when a
                                                        `((apply &#x27;,a me args)))))))))))))))

</code></pre>
which allows me to write, for example, this<p><pre><code>  (defdelta door
    (  q0        event       -  q         action       )
    ;;--------------------------------------------------
    (  locked    challenge   -  -         test-lock    )
    (  ^         unlock      -  unlocked  -            )
    (  ^         enter       -  -         to-locked    )
    ;;--------------------------------------------------
    (  unlocked  enter       -  -         to-unlocked  )
    (  ^         challenge   -  open      -            )
    (  ^         lock        -  locked    -            )
    ;;--------------------------------------------------
    (  open      enter       -  -         to-open      )
    (  ^         arrival     -  blocked   -            )
    (  ^         shut        -  unlocked  -            )
    ;;--------------------------------------------------
    (  blocked   departure   -  open      -            )
    (  ^         enter   -   -            to-blocked   ))
</code></pre>
along with some support code (e.g., the action functions) to define the auto-closing, auto-locking behavior of doors.<p>---<p>[0] Some helpers have been omitted.  `defevent` defines a generic function with the given name and a particular set of arguments, and a default method that does nothing.  `change-state` handles the mechanics of updating the state variable, sending a `leave` event just before the transition and `enter` just after.</div><br/></div></div></div></div></div></div></div></div></div></body></html>