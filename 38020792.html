<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1698310857959" as="style"/><link rel="stylesheet" href="styles.css?v=1698310857959"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://research.swtch.com/nih">Running the &quot;Reflections on Trusting Trust&quot; Compiler</a> <span class="domain">(<a href="https://research.swtch.com">research.swtch.com</a>)</span></div><div class="subtext"><span>rsc</span> | <span>26 comments</span></div><br/><div><div id="38021603" class="c"><input type="checkbox" id="c-38021603" checked=""/><div class="controls bullet"><span class="by">yegle</span><span>|</span><a href="#38021123">next</a><span>|</span><label class="collapse" for="c-38021603">[-]</label><label class="expand" for="c-38021603">[6 more]</label></div><br/><div class="children"><div class="content">What a coincidence, I was reading the GNU Mes project&#x27;s doc today that&#x27;s very relevant: <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;mes&#x2F;manual&#x2F;mes.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;mes&#x2F;manual&#x2F;mes.html</a></div><br/><div id="38021793" class="c"><input type="checkbox" id="c-38021793" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38021603">parent</a><span>|</span><a href="#38021123">next</a><span>|</span><label class="collapse" for="c-38021793">[-]</label><label class="expand" for="c-38021793">[5 more]</label></div><br/><div class="children"><div class="content">I thought of the term &quot;bootstrap pilgrimage&quot; years ago to concisely refer to such projects --- both to highlight the journey of learning they give, and to refer to the fact that not everyone may have the time nor skill to embark on one.</div><br/><div id="38022175" class="c"><input type="checkbox" id="c-38022175" checked=""/><div class="controls bullet"><span class="by">thaliaarchi</span><span>|</span><a href="#38021603">root</a><span>|</span><a href="#38021793">parent</a><span>|</span><a href="#38021900">next</a><span>|</span><label class="collapse" for="c-38022175">[-]</label><label class="expand" for="c-38022175">[2 more]</label></div><br/><div class="children"><div class="content">I like that term. I&#x27;ve tried a couple of bootstrap pilgrimages.<p>For a job, we needed Go on FreeBSD 8, which entailed a local patch to revert pipe2 to pipe in Go, and building from source. That was my first bootstrap. Go, as Russ mentions, is easy to bootstrap, and I&#x27;ve done it a couple of other times.<p>I&#x27;ve tried to bootstrap Rust, from its old compiler written in OCaml, but that one is trickier. It has not been maintained like Go&#x27;s bootstrap compiler and the bootstrap chain has long since been broken. Furthermore, rustc is only guaranteed to be able to be buildable with the previous release. As far as I can tell, no one has built rustboot in many years. I like doing software archaeology, so I&#x27;ll probably try again with that project sometime.<p>mrustc takes another approach, closer to the aforementioned GNU Mes, in that it&#x27;s a reimplementation of Rust, intended for bootstrapping rustc.
<a href="https:&#x2F;&#x2F;github.com&#x2F;thepowersgang&#x2F;mrustc">https:&#x2F;&#x2F;github.com&#x2F;thepowersgang&#x2F;mrustc</a></div><br/><div id="38022903" class="c"><input type="checkbox" id="c-38022903" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#38021603">root</a><span>|</span><a href="#38022175">parent</a><span>|</span><a href="#38021900">next</a><span>|</span><label class="collapse" for="c-38022903">[-]</label><label class="expand" for="c-38022903">[1 more]</label></div><br/><div class="children"><div class="content">Relevant is <a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;pull&#x2F;85542">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;pull&#x2F;85542</a> , a (very stale) PR that uses mrustc to get straight to Rust 1.29 and then walks the chain.</div><br/></div></div></div></div><div id="38021900" class="c"><input type="checkbox" id="c-38021900" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#38021603">root</a><span>|</span><a href="#38021793">parent</a><span>|</span><a href="#38022175">prev</a><span>|</span><a href="#38021123">next</a><span>|</span><label class="collapse" for="c-38021900">[-]</label><label class="expand" for="c-38021900">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always struggled to find a succinct way to describe the benefits of installing Arch Linux. &quot;bootstrap pilgrimage&quot; is the perfect term!</div><br/><div id="38022547" class="c"><input type="checkbox" id="c-38022547" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#38021603">root</a><span>|</span><a href="#38021900">parent</a><span>|</span><a href="#38021123">next</a><span>|</span><label class="collapse" for="c-38022547">[-]</label><label class="expand" for="c-38022547">[1 more]</label></div><br/><div class="children"><div class="content">Archlinux has gotten substantial easier to install in the last decade or so.  I no longer get any &#x27;bootstrap pilgrimage&#x27; feelings from it.  Lots of stuff now works out of the box, even.<p>But I guess, I&#x27;m too used to it, too?</div><br/></div></div></div></div></div></div></div></div><div id="38021123" class="c"><input type="checkbox" id="c-38021123" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38021603">prev</a><span>|</span><a href="#38021052">next</a><span>|</span><label class="collapse" for="c-38021123">[-]</label><label class="expand" for="c-38021123">[16 more]</label></div><br/><div class="children"><div class="content">There’s of course a couple of notes on combating this attack: most compilers of today don’t actually produce exactly the same code if you run them twice. In broad strokes they do but often they’ll have randomness creep in, such as different build hashes or iteration order of associative containers. To truly get a bit-for-bit identical output you may need to do some extra work, or perhaps run yet another step in a controlled environment to protect against this.<p>Second, and more importantly, many people carry a copy of a trusted compiler around, though it’s rarely mention in attacks like these: their head. In a pinch people can do spot checks to verify codegen to see whether it looks correct, unless the backdoor is incredibly subtle. But experience shows us that the more complex and hidden a backdoor is the more likely it is to break when subjected to unfamiliar examination.</div><br/><div id="38021687" class="c"><input type="checkbox" id="c-38021687" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38021123">parent</a><span>|</span><a href="#38021203">next</a><span>|</span><label class="collapse" for="c-38021687">[-]</label><label class="expand" for="c-38021687">[12 more]</label></div><br/><div class="children"><div class="content"><i>most compilers of today don’t actually produce exactly the same code if you run them twice.</i><p>Timestamps are one of the biggest offenders, but this is also why reproducible builds are important. Nondeterministic codegen is just scary.<p><i>Second, and more importantly, many people carry a copy of a trusted compiler around, though it’s rarely mention in attacks like these: their head.</i><p>This is also why I&#x27;m against inefficient bloated software in general: the bigger a binary is, the easier it is to hide something in it.<p>Along the same lines, a third idea I have for defending against such attacks is better <i>decompilers</i> --- ideally, repeatedly decompiling and recompiling should converge to a fixed point, whereas a backdoor in a compiler should cause it to decompile into source that&#x27;s noticeably divergent.</div><br/><div id="38022949" class="c"><input type="checkbox" id="c-38022949" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#38021123">root</a><span>|</span><a href="#38021687">parent</a><span>|</span><a href="#38022043">next</a><span>|</span><label class="collapse" for="c-38022949">[-]</label><label class="expand" for="c-38022949">[2 more]</label></div><br/><div class="children"><div class="content">&gt; decompilers  ... converge to a fixed point<p>but why would you assume that the decompiler is not backdoored? It would know to remove the backdoor code, so the fixpoint is not going to show anything.</div><br/><div id="38023121" class="c"><input type="checkbox" id="c-38023121" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#38021123">root</a><span>|</span><a href="#38022949">parent</a><span>|</span><a href="#38022043">next</a><span>|</span><label class="collapse" for="c-38023121">[-]</label><label class="expand" for="c-38023121">[1 more]</label></div><br/><div class="children"><div class="content">In theory, any computer tool you use could&#x27;ve already been compromised. You can&#x27;t be 100% certain (even if you bootstrap from hand-made punchcards, the backdoor could be hidden in <i>hardware</i>).<p>In practice, you can push the likelihood of this down to arbitrarily small levels. Pick a decompiler that&#x27;s as unrelated to your compiler as you can find. Then pick a <i>second</i> decompiler that&#x27;s maximally unrelated to both the compiler and the first decompiler. It&#x27;s highly unlikely all three tools will be backdoored in a fully compatible way.</div><br/></div></div></div></div><div id="38022043" class="c"><input type="checkbox" id="c-38022043" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38021123">root</a><span>|</span><a href="#38021687">parent</a><span>|</span><a href="#38022949">prev</a><span>|</span><a href="#38021203">next</a><span>|</span><label class="collapse" for="c-38022043">[-]</label><label class="expand" for="c-38022043">[9 more]</label></div><br/><div class="children"><div class="content">&gt;Timestamps are one of the biggest offenders<p>&gt;Nondeterministic codegen is just scary.<p>Why not focus on deterministic codegen only? Caring about some metadata changing does not seem to be as useful from a security perspective.</div><br/><div id="38022560" class="c"><input type="checkbox" id="c-38022560" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#38021123">root</a><span>|</span><a href="#38022043">parent</a><span>|</span><a href="#38022358">next</a><span>|</span><label class="collapse" for="c-38022560">[-]</label><label class="expand" for="c-38022560">[2 more]</label></div><br/><div class="children"><div class="content">If you can get your binaries bit-for-bit identical, any idiot (read: even a computer) can tell they are the same.<p>If you have to make exceptions for some metadata, all of a sudden there&#x27;s judgement and smarts involved.  And judgement can go wrong.</div><br/><div id="38023101" class="c"><input type="checkbox" id="c-38023101" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38021123">root</a><span>|</span><a href="#38022560">parent</a><span>|</span><a href="#38022358">next</a><span>|</span><label class="collapse" for="c-38023101">[-]</label><label class="expand" for="c-38023101">[1 more]</label></div><br/><div class="children"><div class="content">When a lot of software is mostly reproducible it may be easier to make the matching logic smarter instead of needing to chase down every possible build variation in every single application on Earth.<p>&gt;And judgement can go wrong.<p>Which is why it is important to have a good design and threat model.</div><br/></div></div></div></div><div id="38022358" class="c"><input type="checkbox" id="c-38022358" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#38021123">root</a><span>|</span><a href="#38022043">parent</a><span>|</span><a href="#38022560">prev</a><span>|</span><a href="#38022281">next</a><span>|</span><label class="collapse" for="c-38022358">[-]</label><label class="expand" for="c-38022358">[4 more]</label></div><br/><div class="children"><div class="content">In order to trust signed binaries, it is very valuable to be able to verify a binary came from some source.<p>This way anyone who signs modified code can be caught. This is especially easy with open source projects. Incidentally, Debian is working very hard on deterministic builds.</div><br/><div id="38022392" class="c"><input type="checkbox" id="c-38022392" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38021123">root</a><span>|</span><a href="#38022358">parent</a><span>|</span><a href="#38022281">next</a><span>|</span><label class="collapse" for="c-38022392">[-]</label><label class="expand" for="c-38022392">[3 more]</label></div><br/><div class="children"><div class="content">&gt;it is very valuable to be able to verify a binary came from some source.<p>Code signatures have already existed for decades and do not require reproducable builds.</div><br/><div id="38022960" class="c"><input type="checkbox" id="c-38022960" checked=""/><div class="controls bullet"><span class="by">bheadmaster</span><span>|</span><a href="#38021123">root</a><span>|</span><a href="#38022392">parent</a><span>|</span><a href="#38022281">next</a><span>|</span><label class="collapse" for="c-38022960">[-]</label><label class="expand" for="c-38022960">[2 more]</label></div><br/><div class="children"><div class="content">Yes, but reproducible builds allow anyone to rebuild the code and verify that the compiled binary release corresponds to the upstream source code.<p>Without deterministic builds, it&#x27;s possible for the attacker to switch the compiled binary release and sign it with a stolen key with nobody noticing.</div><br/><div id="38023025" class="c"><input type="checkbox" id="c-38023025" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#38021123">root</a><span>|</span><a href="#38022960">parent</a><span>|</span><a href="#38022281">next</a><span>|</span><label class="collapse" for="c-38023025">[-]</label><label class="expand" for="c-38023025">[1 more]</label></div><br/><div class="children"><div class="content">but if your threat model includes the key being stolen as a potential threat, then signing with said key would then be meaningless.</div><br/></div></div></div></div></div></div></div></div><div id="38022281" class="c"><input type="checkbox" id="c-38022281" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#38021123">root</a><span>|</span><a href="#38022043">parent</a><span>|</span><a href="#38022358">prev</a><span>|</span><a href="#38021203">next</a><span>|</span><label class="collapse" for="c-38022281">[-]</label><label class="expand" for="c-38022281">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Caring about some metadata changing does not seem to be as useful from a security perspective.<p>If the metadata were neatly separated from the executable portions of an artifact then it indeed wouldn&#x27;t be too much of an issue[1], but it often isn&#x27;t. It sometimes gets embedded into strings and other places in the executable itself where it theoretically could have an impact on the runtime (and of course makes executable signatures unreliable, etc.). Without that separation comparing two potentially-the-same executables becomes equivalent to the Halting Problem.<p>[1] You could sign only portions of the executable, for example... but such signature schemes are brittle and error-prone in practice, so best avoided. So you&#x27;d ideally want any and all metadata totally separate from the executable.</div><br/><div id="38022383" class="c"><input type="checkbox" id="c-38022383" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38021123">root</a><span>|</span><a href="#38022281">parent</a><span>|</span><a href="#38021203">next</a><span>|</span><label class="collapse" for="c-38022383">[-]</label><label class="expand" for="c-38022383">[1 more]</label></div><br/><div class="children"><div class="content">&gt;where it theoretically could have an impact on the runtime<p>If there is a backdoor in the code there is a backdoor regardless of if there is an extra timestamp that exists.</div><br/></div></div></div></div></div></div></div></div><div id="38021203" class="c"><input type="checkbox" id="c-38021203" checked=""/><div class="controls bullet"><span class="by">wyldfire</span><span>|</span><a href="#38021123">parent</a><span>|</span><a href="#38021687">prev</a><span>|</span><a href="#38021052">next</a><span>|</span><label class="collapse" for="c-38021203">[-]</label><label class="expand" for="c-38021203">[3 more]</label></div><br/><div class="children"><div class="content">clang+llvm releases do a three stage build and compare the output of the third stage with the second.  This is fairly effective at rooting out many sources of indeterminate behavior.<p>&gt; In broad strokes they do but often they’ll have randomness creep in, such as different build hashes or iteration order of associative containers.<p>In order to find defects related to codegen being altered by incidental ordering of objects in containers, a build option called LLVM_ENABLE_REVERSE_ITERATION was created.  Builders periodically run with this mode to verify that the regression test suite still passes when containers iterate in reverse.<p>That said, it&#x27;s true that there are probably remaining sources of variation among builds.  There is a significant effort [1] to find these and avoid them.<p>[1] <a href="https:&#x2F;&#x2F;reproducible-builds.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;reproducible-builds.org&#x2F;</a></div><br/><div id="38021399" class="c"><input type="checkbox" id="c-38021399" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38021123">root</a><span>|</span><a href="#38021203">parent</a><span>|</span><a href="#38021052">next</a><span>|</span><label class="collapse" for="c-38021399">[-]</label><label class="expand" for="c-38021399">[2 more]</label></div><br/><div class="children"><div class="content">Not all containers right? Just unordered containers. It’s a bit weird of a strategy though - most other applications use a random seed for unordered hash tables.</div><br/><div id="38021498" class="c"><input type="checkbox" id="c-38021498" checked=""/><div class="controls bullet"><span class="by">wyldfire</span><span>|</span><a href="#38021123">root</a><span>|</span><a href="#38021399">parent</a><span>|</span><a href="#38021052">next</a><span>|</span><label class="collapse" for="c-38021498">[-]</label><label class="expand" for="c-38021498">[1 more]</label></div><br/><div class="children"><div class="content">Rather than change the implementation of the DenseMap&#x2F;DenseSet&#x2F;StringMap&#x2F;StringSet containers to mask such codegen defects, the community opted to create a test strategy to find the defects instead.<p>I would guess that this may also end up favoring the execution performance of the compiler over other design choices, but I could be wrong about that one.</div><br/></div></div></div></div></div></div></div></div><div id="38021052" class="c"><input type="checkbox" id="c-38021052" checked=""/><div class="controls bullet"><span class="by">earthboundkid</span><span>|</span><a href="#38021123">prev</a><span>|</span><label class="collapse" for="c-38021052">[-]</label><label class="expand" for="c-38021052">[3 more]</label></div><br/><div class="children"><div class="content">Usually rsc’s blog posts are intimations of what he’s going to propose next for Go. Um, er, oh boy.</div><br/><div id="38022472" class="c"><input type="checkbox" id="c-38022472" checked=""/><div class="controls bullet"><span class="by">mseepgood</span><span>|</span><a href="#38021052">parent</a><span>|</span><a href="#38022754">next</a><span>|</span><label class="collapse" for="c-38022472">[-]</label><label class="expand" for="c-38022472">[1 more]</label></div><br/><div class="children"><div class="content">It is indirectly about the new reproducible Go toolchain builds introduced with Go 1.21. <a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;rebuild" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;rebuild</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>