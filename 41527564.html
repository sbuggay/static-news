<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726218064028" as="style"/><link rel="stylesheet" href="styles.css?v=1726218064028"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.hadijaveed.me/2024/09/08/does-your-startup-really-need-complex-cloud-infrastructure/">Does Your Startup Need Complex Cloud Infrastructure?</a> <span class="domain">(<a href="https://www.hadijaveed.me">www.hadijaveed.me</a>)</span></div><div class="subtext"><span>hjaveed</span> | <span>82 comments</span></div><br/><div><div id="41528879" class="c"><input type="checkbox" id="c-41528879" checked=""/><div class="controls bullet"><span class="by">ghomem</span><span>|</span><a href="#41527959">next</a><span>|</span><label class="collapse" for="c-41528879">[-]</label><label class="expand" for="c-41528879">[6 more]</label></div><br/><div class="children"><div class="content">I went through sweat and tears with this on different projects. People wanting to be cool because they use hype-train-tech ending up doing things of unbelievably bad quality because &quot;hey, we are not that many in the team&quot; but &quot;hey, we need infinite scalability&quot;. Teams immature to the point of not understanding what LTS means have decided that they needed Kubernetes because yes. I could go on.<p>I currently have distilled, compact Puppet code to create a hardened VM of any size on any provider that can run one more more Docker services or run directly a python backend, or serve static files. With this I create a service on a Hetzner VM in 5 minutes whether the VM has 2 cores or 48 cores and control the configuration in source controlled manifests while monitoring configuration compliance with a custom Naemon plugin. A perfectly reproducible process. The startups kids are meanwhile doing snowflakes in the cloud spending many KEUR per month to have something that is worse than what devops pioneers were able to do in 2017. And the stakeholders are paying for this ship.<p>I wrote a more structured opinion piece about this, called The Emperor&#x27;s New clouds:<p><a href="https:&#x2F;&#x2F;logical.li&#x2F;blog&#x2F;emperors-new-clouds&#x2F;" rel="nofollow">https:&#x2F;&#x2F;logical.li&#x2F;blog&#x2F;emperors-new-clouds&#x2F;</a></div><br/><div id="41528973" class="c"><input type="checkbox" id="c-41528973" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#41528879">parent</a><span>|</span><a href="#41527959">next</a><span>|</span><label class="collapse" for="c-41528973">[-]</label><label class="expand" for="c-41528973">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m with you, but for me Cloud does have one major benefit:<p>If you use it as IaaS, it&#x27;s a lot quicker to get prototypes working than if you use anything else, including VPS&#x27;s from other providers.<p>Google Cloud in particular has very few vectors for lock-in, and follows more principle of least surprise.<p>But once you have prototyped, you should <i>ask the question</i> about rebuilding it somewhere that is cheaper.<p>Near infinite scalability of disk drives is nice, and snapshotting, and cloud in general can allow you to extend your prototype into taking production load and allowing you to measure what you will need; but leaning in to &quot;cloud magick&quot; (cloud run, lambdas, etc) will consume almost as much time to learn and debug as just doing it the old school way anyway. In my lived experience.</div><br/><div id="41529097" class="c"><input type="checkbox" id="c-41529097" checked=""/><div class="controls bullet"><span class="by">ghomem</span><span>|</span><a href="#41528879">root</a><span>|</span><a href="#41528973">parent</a><span>|</span><a href="#41527959">next</a><span>|</span><label class="collapse" for="c-41529097">[-]</label><label class="expand" for="c-41529097">[4 more]</label></div><br/><div class="children"><div class="content">I am not against the cloud. VMs are also cloud, unless you run them on your own servers. For instance, the Hetzner Cloud (mostly VMs, plus load balancers and disks) is so cheap and has such a nice CLI API that it competes aggressively with dedicated servers - I would definitely start any with VMs, not with iron.<p>The biggest problem is the so called cloud native stuff which is both more expensive and more complex. There are contexts where it makes sense but for startups they are doing more harm than good.</div><br/><div id="41529150" class="c"><input type="checkbox" id="c-41529150" checked=""/><div class="controls bullet"><span class="by">finaard</span><span>|</span><a href="#41528879">root</a><span>|</span><a href="#41529097">parent</a><span>|</span><a href="#41527959">next</a><span>|</span><label class="collapse" for="c-41529150">[-]</label><label class="expand" for="c-41529150">[3 more]</label></div><br/><div class="children"><div class="content">Thing is, by the time the cloud native stuff makes sense most companies are at a scale where it&#x27;d be cheaper to just hire a good devops team, and start building your own cloud infra on own hardware.</div><br/><div id="41529242" class="c"><input type="checkbox" id="c-41529242" checked=""/><div class="controls bullet"><span class="by">ghomem</span><span>|</span><a href="#41528879">root</a><span>|</span><a href="#41529150">parent</a><span>|</span><a href="#41529269">next</a><span>|</span><label class="collapse" for="c-41529242">[-]</label><label class="expand" for="c-41529242">[1 more]</label></div><br/><div class="children"><div class="content">Probably so. And that would be likely my approach at such scale.<p>Still, my most benevolent interpretation of current reality is, rather than saying &quot;that cloud native stuff is crap&quot;, accepting that there are cases where it may make sense.<p>For instance, large companies might have trouble hiring a good ops team because they have in general trouble hiring and retaining talent (another conversation topic).<p>Ops people are a scarce good because univs do not train people for that and most people prefer coding. I am leaving the work devops out because the market completely perverted its meaning.<p>(my take on the devops funeral: <a href="https:&#x2F;&#x2F;logical.li&#x2F;blog&#x2F;devops&#x2F;" rel="nofollow">https:&#x2F;&#x2F;logical.li&#x2F;blog&#x2F;devops&#x2F;</a> )</div><br/></div></div><div id="41529269" class="c"><input type="checkbox" id="c-41529269" checked=""/><div class="controls bullet"><span class="by">ghomem</span><span>|</span><a href="#41528879">root</a><span>|</span><a href="#41529150">parent</a><span>|</span><a href="#41529242">prev</a><span>|</span><a href="#41527959">next</a><span>|</span><label class="collapse" for="c-41529269">[-]</label><label class="expand" for="c-41529269">[1 more]</label></div><br/><div class="children"><div class="content">Reference:<p><a href="https:&#x2F;&#x2F;survey.stackoverflow.co&#x2F;2022&#x2F;#developer-profile-developer-roles" rel="nofollow">https:&#x2F;&#x2F;survey.stackoverflow.co&#x2F;2022&#x2F;#developer-profile-deve...</a><p>Only around 11% of the whole devs identify as devops specialist or cloud infrastructure engineer.<p>This is why I am saying ops people are a scarce good (unfortunately) from a data driven perspective. Of course my daily life confirms it.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41527959" class="c"><input type="checkbox" id="c-41527959" checked=""/><div class="controls bullet"><span class="by">mattbillenstein</span><span>|</span><a href="#41528879">prev</a><span>|</span><a href="#41528946">next</a><span>|</span><label class="collapse" for="c-41527959">[-]</label><label class="expand" for="c-41527959">[5 more]</label></div><br/><div class="children"><div class="content">Basically doing this for a small startup - there are some complexities around autoscaling task queues with gpus and whatnot, but the heart of it is on a single VM (nginx, webapp, postgres, redis). We&#x27;re b2b, so there&#x27;s very little traffic anyway.<p>The additional benefit is devs can run all the same stuff on a Linux laptop (or Linux VM on some other platform) - and everyone can have their own VM in the cloud if they like to demo or test stuff using all the same setup. Bootstrapping a new system is checking in their ssh key and running a shell script.<p>Easy to debug, not complex or expensive, and we could vertically scale it all quite a ways before needing to scale horizontally. It&#x27;s not for everyone, but seed stage and earlier - totally appropriate imo.</div><br/><div id="41528485" class="c"><input type="checkbox" id="c-41528485" checked=""/><div class="controls bullet"><span class="by">normie3000</span><span>|</span><a href="#41527959">parent</a><span>|</span><a href="#41527965">next</a><span>|</span><label class="collapse" for="c-41528485">[-]</label><label class="expand" for="c-41528485">[2 more]</label></div><br/><div class="children"><div class="content">I love the simplicity of this approach. In your setup, how do you track config and updates of your VMs?</div><br/><div id="41528783" class="c"><input type="checkbox" id="c-41528783" checked=""/><div class="controls bullet"><span class="by">clvx</span><span>|</span><a href="#41527959">root</a><span>|</span><a href="#41528485">parent</a><span>|</span><a href="#41527965">next</a><span>|</span><label class="collapse" for="c-41528783">[-]</label><label class="expand" for="c-41528783">[1 more]</label></div><br/><div class="children"><div class="content">I like this but one of the issues with this approach is if no Docker images like traditional configuration management tool, you are going for a world of pain.
Docker and Docker images have tons of best practices already defined for plenty of use cases. If it&#x27;s already containerized; then, jumping to any orchestrator that supports OCI images is more about adjusting the business to a new set of operations.</div><br/></div></div></div></div><div id="41527965" class="c"><input type="checkbox" id="c-41527965" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#41527959">parent</a><span>|</span><a href="#41528485">prev</a><span>|</span><a href="#41528946">next</a><span>|</span><label class="collapse" for="c-41527965">[-]</label><label class="expand" for="c-41527965">[2 more]</label></div><br/><div class="children"><div class="content">I did this type of setup but without even redis. Postgres can do anything.</div><br/><div id="41527980" class="c"><input type="checkbox" id="c-41527980" checked=""/><div class="controls bullet"><span class="by">mattbillenstein</span><span>|</span><a href="#41527959">root</a><span>|</span><a href="#41527965">parent</a><span>|</span><a href="#41528946">next</a><span>|</span><label class="collapse" for="c-41527980">[-]</label><label class="expand" for="c-41527980">[1 more]</label></div><br/><div class="children"><div class="content">True, I use it mainly for a few convenience things - holding ephemeral monitoring data, distributed locks, redis streams for some pub&#x2F;sub stuff, sorted sets can be handy - things I could do in Postgres, but are a bit simpler in Redis.</div><br/></div></div></div></div></div></div><div id="41528946" class="c"><input type="checkbox" id="c-41528946" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#41527959">prev</a><span>|</span><a href="#41529252">next</a><span>|</span><label class="collapse" for="c-41528946">[-]</label><label class="expand" for="c-41528946">[2 more]</label></div><br/><div class="children"><div class="content">There is a core 20% of kubernetes, which is deployments, pods services and the way it handles blue-green deployments and declarative based definitions, namespace seperation, etc. that is really good. Just keeping to those simple basics, using a managed cloud kubernetes service, and  running your state (database) out of cluster is a good experience (IMO).<p>It&#x27;s when one starts getting sucked down the &quot;cloud native&quot; wormhole of all these niche open source systems and operators and ambassador and sidecar patterns, etc. that things go wrong. Those are for environments with many independent but interconnecting tech teams with diverse programming language use.</div><br/><div id="41529011" class="c"><input type="checkbox" id="c-41529011" checked=""/><div class="controls bullet"><span class="by">maeln</span><span>|</span><a href="#41528946">parent</a><span>|</span><a href="#41529252">next</a><span>|</span><label class="collapse" for="c-41529011">[-]</label><label class="expand" for="c-41529011">[1 more]</label></div><br/><div class="children"><div class="content">For a lot of company and project I worked on, this is the same conclusion I came to. 99% we only need &#x2F; want is docker-compose++. Things like 0-downtime deployment out of the box, simple configuration system for replica set and other replication &#x2F; distribution mechanism, and that is basically it.<p>I which there was something that did just that, because kube comes with a lot of baggage, and docker-compose is a bit too basic for some important production needs.</div><br/></div></div></div></div><div id="41529252" class="c"><input type="checkbox" id="c-41529252" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#41528946">prev</a><span>|</span><a href="#41527863">next</a><span>|</span><label class="collapse" for="c-41529252">[-]</label><label class="expand" for="c-41529252">[1 more]</label></div><br/><div class="children"><div class="content">VMs, block &amp; blob storage, DNS, IdP, domain registrar.<p>These are the only things I have ever been comfortable using in the cloud.<p>Once you get into FaaS and friends, things get really weird for me. I can&#x27;t handle not having visibility into the machine running my production environment. Debugging through cloud dashboards is a shit experience. I think Microsoft&#x27;s approach is closest to actually &quot;working&quot;, but it&#x27;s still really awful and I&#x27;d never touch it again.<p>The ideal architecture for me after 10 years is still a single VM with monolithic codebase talking to local instances of SQLite. The advent of NVMe storage has really put a kick into this one too. Backups handled by snapshotting the block storage device. Transactional durability handled by replicating WAL, if need be.<p>Dumbass simple. Lets me focus on the business and customer. Because they sure as hell don&#x27;t care about any of this and wouldn&#x27;t pay any money for it. All this code &amp; infra is pure downside. You want as little of it as possible.</div><br/></div></div><div id="41527863" class="c"><input type="checkbox" id="c-41527863" checked=""/><div class="controls bullet"><span class="by">mianos</span><span>|</span><a href="#41529252">prev</a><span>|</span><a href="#41529001">next</a><span>|</span><label class="collapse" for="c-41527863">[-]</label><label class="expand" for="c-41527863">[18 more]</label></div><br/><div class="children"><div class="content">Who is going to get a new job without k8s on their resume. :)<p>Seriously, I think a lot of people do things the hard way to learn large scale infrastructure. Another common reason is &#x27;things will be much easier when we scale to a massive number of clients&#x27;, or we can dynamically scale up on demand.<p>These are all valid to the people building this, just not as much to founders or professional CTOs.</div><br/><div id="41528704" class="c"><input type="checkbox" id="c-41528704" checked=""/><div class="controls bullet"><span class="by">kristopolous</span><span>|</span><a href="#41527863">parent</a><span>|</span><a href="#41527945">next</a><span>|</span><label class="collapse" for="c-41528704">[-]</label><label class="expand" for="c-41528704">[1 more]</label></div><br/><div class="children"><div class="content">Excuse my harshness but people doing it needlessly is just unprofessional waste and abuse.<p>Some people seem to have no concern with the needs and timetables of the would be customers but instead burn through cash building fancy nonsense.<p>It&#x27;s like going in to a car mechanic for tires and then finding out it took 3 weeks because the guy wanted to put on low rider hydraulics and spinner hubcaps for his personal enrichment.<p>The worst part is it&#x27;s inherently ambiguous to the next people. They don&#x27;t know if the reason something is there is because it&#x27;s needed or because it&#x27;s just shiny bling.</div><br/></div></div><div id="41527945" class="c"><input type="checkbox" id="c-41527945" checked=""/><div class="controls bullet"><span class="by">sussexby</span><span>|</span><a href="#41527863">parent</a><span>|</span><a href="#41528704">prev</a><span>|</span><a href="#41528749">next</a><span>|</span><label class="collapse" for="c-41527945">[-]</label><label class="expand" for="c-41527945">[15 more]</label></div><br/><div class="children"><div class="content">Just take a look at the level of complexity in home lab subreddits!<p>I don’t quite get if people do it for interest, for love of the tech, or if they are technocratic and believe in levelling up their skill to get k8s on their CV like you say.<p>All I think is “this looks painful to manage”!</div><br/><div id="41527987" class="c"><input type="checkbox" id="c-41527987" checked=""/><div class="controls bullet"><span class="by">from-nibly</span><span>|</span><a href="#41527863">root</a><span>|</span><a href="#41527945">parent</a><span>|</span><a href="#41528248">next</a><span>|</span><label class="collapse" for="c-41527987">[-]</label><label class="expand" for="c-41527987">[9 more]</label></div><br/><div class="children"><div class="content">K8s is painful to get started, and painful to learn. But once you have it up you can just keep adding stuff to it.<p>I run a k8s cluster at home. Part of it yes, is to apply my existing skills and keep them fresh. But part of it is that kubernetes can be easier long term.<p>Ive got magical hard drive storage with rook ceph. I can yoink a hard drive out of my servers and nothing happens to my workloads.<p>I can do maintenance on one of the servers with 0 down time.<p>All of my config for what I have deployed is in git.<p>I manage VMS and kubernetes at work, and im not going to pretend that kubernetes isnt complex, but it&#x27;s complex up front instead of down the road. VMs run into complexity when things change. I&#x27;m sure you can make VMS good but then why not use something like kubernetes, you will have to reinvent a lot of the stuff that&#x27;s already in kubernetes.<p>It&#x27;s a hammer for sure and not everything is a nail, but it can be really powerful and useful even for home labs.</div><br/><div id="41528440" class="c"><input type="checkbox" id="c-41528440" checked=""/><div class="controls bullet"><span class="by">cyberpunk</span><span>|</span><a href="#41527863">root</a><span>|</span><a href="#41527987">parent</a><span>|</span><a href="#41528247">next</a><span>|</span><label class="collapse" for="c-41528440">[-]</label><label class="expand" for="c-41528440">[1 more]</label></div><br/><div class="children"><div class="content">&gt; K8s is painful to get started<p>Is that really true anymore? Even self hosting k8s these days (e.g with rke&#x2F;rke2) is a single yaml file and one command to deploy an entire cluster.. Maybe back when we all used kubespray and networking was more complicated (to the user at least) etc.. But today? I don&#x27;t think so.<p>Using a hosted offering is even easier, literally a couple of clicks, a .&#x2F;gcloud-cli or terraform apply -- again not very hard and all the cloud providers provide you with example code you just need to plug some machine sizes etc into..<p>Dev setup? Install orbstack and click &#x27;kubernetes&#x27; and you&#x27;re done, your IDE (likely) will automagically pick up your kubeconfig and you can go right ahead creating services, deployments, jobs, whatevers...</div><br/></div></div><div id="41528247" class="c"><input type="checkbox" id="c-41528247" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#41527863">root</a><span>|</span><a href="#41527987">parent</a><span>|</span><a href="#41528440">prev</a><span>|</span><a href="#41528735">next</a><span>|</span><label class="collapse" for="c-41528247">[-]</label><label class="expand" for="c-41528247">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t run k8s at home, but I have worked in k8s-heavy environments and studied it deeply. This is the accurate, nuanced take.<p>Few <i>but not no</i> people will ever run into problems at the kind of scale k8s operates at. Plus, learning how it &quot;expects&quot; the programs running inside its Pods to behave is kind of like learning how Django or Rails &quot;expect&quot; a web app to work - it&#x27;s a more complicated style than just writing your own totally custom, hermetically-sealed Python apps for your personal use, sure, but it also comes with a slew of benefits in case you ever do hit that level of scale and want to move over.<p>Or, maybe you look over the app you&#x27;re writing and say &quot;Fat chance.&quot; In which case you can <i>justify</i> e.g. not making everything an API endpoint, keeping a ton of state mucking about, etc. But I still feel that&#x27;s an improvement over not even realizing the questions are being asked.</div><br/></div></div><div id="41528735" class="c"><input type="checkbox" id="c-41528735" checked=""/><div class="controls bullet"><span class="by">dambi0</span><span>|</span><a href="#41527863">root</a><span>|</span><a href="#41527987">parent</a><span>|</span><a href="#41528247">prev</a><span>|</span><a href="#41528105">next</a><span>|</span><label class="collapse" for="c-41528735">[-]</label><label class="expand" for="c-41528735">[2 more]</label></div><br/><div class="children"><div class="content">I’m sure there are countless other benefits. But how many layers of abstraction, services and things that need configuring are their compared to basic  RAID to get support for magical hard disks that can be yoinked without affecting workloads?</div><br/></div></div><div id="41528105" class="c"><input type="checkbox" id="c-41528105" checked=""/><div class="controls bullet"><span class="by">catdog</span><span>|</span><a href="#41527863">root</a><span>|</span><a href="#41527987">parent</a><span>|</span><a href="#41528735">prev</a><span>|</span><a href="#41528248">next</a><span>|</span><label class="collapse" for="c-41528105">[-]</label><label class="expand" for="c-41528105">[4 more]</label></div><br/><div class="children"><div class="content">What you also can do is starting with just a single node, incredibly easy to install with e.g. <a href="https:&#x2F;&#x2F;k3s.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;k3s.io&#x2F;</a>. You still have to invest the upfront effort to understand how it works but you can already reap a lot of benefits with a lot less complexity.<p>Kubernetes does not force you into the distributed systems hell, you can go that route later, or never.</div><br/><div id="41528138" class="c"><input type="checkbox" id="c-41528138" checked=""/><div class="controls bullet"><span class="by">rendaw</span><span>|</span><a href="#41527863">root</a><span>|</span><a href="#41528105">parent</a><span>|</span><a href="#41528248">next</a><span>|</span><label class="collapse" for="c-41528138">[-]</label><label class="expand" for="c-41528138">[3 more]</label></div><br/><div class="children"><div class="content">Kubernetes&#x2F;k3s on a single node turns what could have been immutable 1-step upgrades into multi-step mutable upgrades, since kubernetes&#x27;s software itself and all the management components you need are a mutable layer on top of the operating system.</div><br/><div id="41528993" class="c"><input type="checkbox" id="c-41528993" checked=""/><div class="controls bullet"><span class="by">angio</span><span>|</span><a href="#41527863">root</a><span>|</span><a href="#41528138">parent</a><span>|</span><a href="#41528241">next</a><span>|</span><label class="collapse" for="c-41528993">[-]</label><label class="expand" for="c-41528993">[1 more]</label></div><br/><div class="children"><div class="content">You can use Talos linux for an immutable (and tiny) OS.</div><br/></div></div><div id="41528241" class="c"><input type="checkbox" id="c-41528241" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#41527863">root</a><span>|</span><a href="#41528138">parent</a><span>|</span><a href="#41528993">prev</a><span>|</span><a href="#41528248">next</a><span>|</span><label class="collapse" for="c-41528241">[-]</label><label class="expand" for="c-41528241">[1 more]</label></div><br/><div class="children"><div class="content">a) It doesn&#x27;t have to be mutable. You can easily setup k3s on a single node, install the apps and bake an AMI or equivalent. And using something like ArgoCD or GitOps will ensure that your k8s stack is in sync with a tracked and managed Git repository.<p>b) In what world is upgrading your entire platform ever a single step. Even for a basic Python app you still have Python itself plus dependencies. And then of course whatever front end web server you&#x27;re using.</div><br/></div></div></div></div></div></div></div></div><div id="41528248" class="c"><input type="checkbox" id="c-41528248" checked=""/><div class="controls bullet"><span class="by">KeplerBoy</span><span>|</span><a href="#41527863">root</a><span>|</span><a href="#41527945">parent</a><span>|</span><a href="#41527987">prev</a><span>|</span><a href="#41528223">next</a><span>|</span><label class="collapse" for="c-41528248">[-]</label><label class="expand" for="c-41528248">[1 more]</label></div><br/><div class="children"><div class="content">Assembling complex systems is just inherently fun as long as you don&#x27;t have deadlines or performance metrics to hit.<p>It&#x27;s a bit like factorio with the extra dopamine hit of getting to unbox stuff.</div><br/></div></div><div id="41528223" class="c"><input type="checkbox" id="c-41528223" checked=""/><div class="controls bullet"><span class="by">udev4096</span><span>|</span><a href="#41527863">root</a><span>|</span><a href="#41527945">parent</a><span>|</span><a href="#41528248">prev</a><span>|</span><a href="#41528586">next</a><span>|</span><label class="collapse" for="c-41528223">[-]</label><label class="expand" for="c-41528223">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s because <i>it is</i> complex. And in the long run, things become simpler. The only difficulty is the initial setup and once you are past that, the overall maintenance workload just becomes easier compared to a single VM setup</div><br/><div id="41528270" class="c"><input type="checkbox" id="c-41528270" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#41527863">root</a><span>|</span><a href="#41528223">parent</a><span>|</span><a href="#41528586">next</a><span>|</span><label class="collapse" for="c-41528270">[-]</label><label class="expand" for="c-41528270">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  And in the long run, things become simpler.<p>aka, you&#x27;re front loading the complexity.<p>You can even think of it as paying insurance premiums upfront. You get to &quot;make a claim&quot; if the requirements do grow into the sort of need that suit such a cluster&#x2F;complex setup.</div><br/><div id="41528476" class="c"><input type="checkbox" id="c-41528476" checked=""/><div class="controls bullet"><span class="by">mianos</span><span>|</span><a href="#41527863">root</a><span>|</span><a href="#41528270">parent</a><span>|</span><a href="#41528586">next</a><span>|</span><label class="collapse" for="c-41528476">[-]</label><label class="expand" for="c-41528476">[1 more]</label></div><br/><div class="children"><div class="content">But, on the same insurance theme; I am not sure paying 10K a year to insure my 5K car makes a lot of sense, because, in the long run, I might write my car off.</div><br/></div></div></div></div></div></div><div id="41528586" class="c"><input type="checkbox" id="c-41528586" checked=""/><div class="controls bullet"><span class="by">GauntletWizard</span><span>|</span><a href="#41527863">root</a><span>|</span><a href="#41527945">parent</a><span>|</span><a href="#41528223">prev</a><span>|</span><a href="#41528749">next</a><span>|</span><label class="collapse" for="c-41528586">[-]</label><label class="expand" for="c-41528586">[1 more]</label></div><br/><div class="children"><div class="content">K8s is painful to manage. It&#x27;s a lot less painful than getting paged in the middle of the night because your server is down - And much much less than realizing that you&#x27;ve been down for an entire day and didn&#x27;t notice. (K8s isn&#x27;t even a complete solution to these problems! Just one part of a complete ~balanced breakfast~ production stack)<p>You don&#x27;t need k8s for all of that, but there&#x27;s not a simpler solution than k8s that handles as much.<p>Life is full of pain. Deal with it.</div><br/></div></div></div></div><div id="41528749" class="c"><input type="checkbox" id="c-41528749" checked=""/><div class="controls bullet"><span class="by">j45</span><span>|</span><a href="#41527863">parent</a><span>|</span><a href="#41527945">prev</a><span>|</span><a href="#41529001">next</a><span>|</span><label class="collapse" for="c-41528749">[-]</label><label class="expand" for="c-41528749">[1 more]</label></div><br/><div class="children"><div class="content">Resume driven development is worth learning to recognize.</div><br/></div></div></div></div><div id="41529001" class="c"><input type="checkbox" id="c-41529001" checked=""/><div class="controls bullet"><span class="by">roncesvalles</span><span>|</span><a href="#41527863">prev</a><span>|</span><a href="#41528027">next</a><span>|</span><label class="collapse" for="c-41529001">[-]</label><label class="expand" for="c-41529001">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve run a project for 6 years on a single $10&#x2F;month VPS (I pay even less due to a perpetual discount I bagged from lowendtalk) run by a gameserver-focused VPS provider for about SIX years with about 99.999 reliability if you exclude the one time I fucked up a config and it was down for a whole day because I wanted to do a clean OS reinstall, and one other time when they changed my IP address (they gave me notice).<p>VPS technology has come a very long way and is highly reliable. The disks on the node are set up in RAID 1 and the VM itself can be easily live migrated to another machine for node maintenance. You can take snapshots etc.<p>To me, I would only turn to cloud infra not for greater reliability but more for collaboration and the operational housekeeping features like IAM, secrets management, infra-as-code etc, or for datacenter compliance reasons like HIPAA.</div><br/></div></div><div id="41528027" class="c"><input type="checkbox" id="c-41528027" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41529001">prev</a><span>|</span><a href="#41527910">next</a><span>|</span><label class="collapse" for="c-41528027">[-]</label><label class="expand" for="c-41528027">[7 more]</label></div><br/><div class="children"><div class="content">But it&#x27;s so embarrassing if your startup is running on shared hosting, FCGI, Go programs, and MySQL, costing about $10 per month.</div><br/><div id="41529161" class="c"><input type="checkbox" id="c-41529161" checked=""/><div class="controls bullet"><span class="by">ghomem</span><span>|</span><a href="#41528027">parent</a><span>|</span><a href="#41528646">next</a><span>|</span><label class="collapse" for="c-41529161">[-]</label><label class="expand" for="c-41529161">[1 more]</label></div><br/><div class="children"><div class="content">hahahahahah that was funny :-)</div><br/></div></div><div id="41528646" class="c"><input type="checkbox" id="c-41528646" checked=""/><div class="controls bullet"><span class="by">groestl</span><span>|</span><a href="#41528027">parent</a><span>|</span><a href="#41529161">prev</a><span>|</span><a href="#41529100">next</a><span>|</span><label class="collapse" for="c-41528646">[-]</label><label class="expand" for="c-41528646">[4 more]</label></div><br/><div class="children"><div class="content">You immediately see there&#x27;s no load ;)</div><br/><div id="41528873" class="c"><input type="checkbox" id="c-41528873" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41528027">root</a><span>|</span><a href="#41528646">parent</a><span>|</span><a href="#41529078">next</a><span>|</span><label class="collapse" for="c-41528873">[-]</label><label class="expand" for="c-41528873">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not a joke. Go is a fast compiled language, and Go programs are self-contained executables. So you don&#x27;t need containers. FCGI is an orchestration system, like Kubernetes. It&#x27;s single-machine, but will start up and shut down processes as the load changes. A crashed process will be restarted. Host the web pages on a static page server, and use client-side Javascript for any dynamic stuff. Good for maybe 20-100 transactions per second. The database will be the bottleneck.<p>Boring, but useful.</div><br/></div></div><div id="41529078" class="c"><input type="checkbox" id="c-41529078" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#41528027">root</a><span>|</span><a href="#41528646">parent</a><span>|</span><a href="#41528873">prev</a><span>|</span><a href="#41529100">next</a><span>|</span><label class="collapse" for="c-41529078">[-]</label><label class="expand" for="c-41529078">[2 more]</label></div><br/><div class="children"><div class="content">When you know how much can be done on a $10 vpc, you&#x27;ll realise how much compute in a kubernetes cluster is only used to support the cluster</div><br/><div id="41529328" class="c"><input type="checkbox" id="c-41529328" checked=""/><div class="controls bullet"><span class="by">groestl</span><span>|</span><a href="#41528027">root</a><span>|</span><a href="#41529078">parent</a><span>|</span><a href="#41529100">next</a><span>|</span><label class="collapse" for="c-41529328">[-]</label><label class="expand" for="c-41529328">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t worry, I host serious stuff on a single machine, and am quite happy with it ;) What set me off a bit was the shared hosting. You don&#x27;t want noisy neighbors, usually. That&#x27;s worth a few bucks.</div><br/></div></div></div></div></div></div><div id="41529100" class="c"><input type="checkbox" id="c-41529100" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#41528027">parent</a><span>|</span><a href="#41528646">prev</a><span>|</span><a href="#41527910">next</a><span>|</span><label class="collapse" for="c-41529100">[-]</label><label class="expand" for="c-41529100">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, the MySQL part of that is kind of <i>faux pas</i> these days.<p>Thankfully. ;)</div><br/></div></div></div></div><div id="41527910" class="c"><input type="checkbox" id="c-41527910" checked=""/><div class="controls bullet"><span class="by">buglungtung</span><span>|</span><a href="#41528027">prev</a><span>|</span><a href="#41528793">next</a><span>|</span><label class="collapse" for="c-41527910">[-]</label><label class="expand" for="c-41527910">[1 more]</label></div><br/><div class="children"><div class="content">I agree that we are overthinking about infrastructure. Boring stack like traditional RDMS, single server with regular backup, few bash script for deployment is fine for normal startup that targets to non-tech customer. They will serve you well at least one or two years, then you will know what should be improve. 
One of the big surprise is database like PostgreSQL can handle like 100tps very well with cheap hardware cost. That mean you can handle up to 86 millions transaction per day.</div><br/></div></div><div id="41528793" class="c"><input type="checkbox" id="c-41528793" checked=""/><div class="controls bullet"><span class="by">riiii</span><span>|</span><a href="#41527910">prev</a><span>|</span><a href="#41528615">next</a><span>|</span><label class="collapse" for="c-41528793">[-]</label><label class="expand" for="c-41528793">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen more than one start up go tits up because they were too focused on designing &quot;Google scale ready&quot; infrastructure.</div><br/></div></div><div id="41528615" class="c"><input type="checkbox" id="c-41528615" checked=""/><div class="controls bullet"><span class="by">taw1285</span><span>|</span><a href="#41528793">prev</a><span>|</span><a href="#41528161">next</a><span>|</span><label class="collapse" for="c-41528615">[-]</label><label class="expand" for="c-41528615">[2 more]</label></div><br/><div class="children"><div class="content">&gt; 20-30 Lambda functions for different services<p>My team of 6 engineers have a social app at around 1,000 DAU. The previous stack has several machines serving APIs and several machines handling different background tasks. Our tech lead is forcing everyone to move to separate Lambdas using CDK to handle each each of these tasks. The debugging, deployment, and architecting shared stacks for Lambdas is taking a toll on me -- all in the name of separation of concerns. How (or should) I push back on this?</div><br/><div id="41528799" class="c"><input type="checkbox" id="c-41528799" checked=""/><div class="controls bullet"><span class="by">langsoul-com</span><span>|</span><a href="#41528615">parent</a><span>|</span><a href="#41528161">next</a><span>|</span><label class="collapse" for="c-41528799">[-]</label><label class="expand" for="c-41528799">[1 more]</label></div><br/><div class="children"><div class="content">Does the tech lead have the CTO or CEO&#x27;s graces for that decision?<p>Why did the tech lead decide to move everything to lambda when you only have 1k DAU? Can they be reasoned with or is it lambda or the highway?<p>You can pull put the stats and do comparison, note the wasted time, how it&#x27;s not beneficial but rather detrimental. Note how long it now takes to debug for such a small codebase, then extrapolate that out.<p>Having tons of lambdas is a massive pain in terms of debugging. Cloud watch is not that great to debug, and the debug tooling tends to be rather expensive, like data dog so not too much is invested. Or it&#x27;s too resource intensive to setup open telemetry.</div><br/></div></div></div></div><div id="41528161" class="c"><input type="checkbox" id="c-41528161" checked=""/><div class="controls bullet"><span class="by">OutOfHere</span><span>|</span><a href="#41528615">prev</a><span>|</span><a href="#41527932">next</a><span>|</span><label class="collapse" for="c-41528161">[-]</label><label class="expand" for="c-41528161">[4 more]</label></div><br/><div class="children"><div class="content">After reading all the comments here, the conclusion is to start simple, then switch to k8s and later to cloud-native only when your business has grown to 1000 and then 1 million daily customers respectively.</div><br/><div id="41528250" class="c"><input type="checkbox" id="c-41528250" checked=""/><div class="controls bullet"><span class="by">number6</span><span>|</span><a href="#41528161">parent</a><span>|</span><a href="#41528334">next</a><span>|</span><label class="collapse" for="c-41528250">[-]</label><label class="expand" for="c-41528250">[2 more]</label></div><br/><div class="children"><div class="content">We have B2B-Customers around 700. It all runs on a single Server (not VM though).<p>Since it&#x27;s B2B we don&#x27;t need zero downtime, updates at midnight are all right.<p>A day before rollout they go through the staging server and the test environment, so no surprises the next morning.<p>Before updates, the backups kick in, so if we need to recover from a bad update we can roll back.<p>Sounds all 2000 and not very fancy but boring and profitable cuts for us</div><br/></div></div></div></div><div id="41527932" class="c"><input type="checkbox" id="c-41527932" checked=""/><div class="controls bullet"><span class="by">sussexby</span><span>|</span><a href="#41528161">prev</a><span>|</span><a href="#41528992">next</a><span>|</span><label class="collapse" for="c-41527932">[-]</label><label class="expand" for="c-41527932">[1 more]</label></div><br/><div class="children"><div class="content">I think this goes for any technology group with any stage of company. I work in networking and genuinely of the product I sell, my customers only need a small amount of core functionality and default settings - the rest is “bells and whistles”.<p>But still, no matter what, the odd customer demands they need all these complexities turned on for no discernible reason.<p>IMO it’s a far better approach with any platform to deploy the minimum and turn things on if you need to as you develop.<p>Incidentally, I’ve been exposed to “traditional” cloud platforms (Azure, GCP, AWS) through work and tried a few times to use them for personal projects in recent years and get bewildered by the number of toggles in the interface and strange (to me) paradigms. I recently tried Cloudflare Workers as a test of an idea and was surprised how simple it was.</div><br/></div></div><div id="41528992" class="c"><input type="checkbox" id="c-41528992" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41527932">prev</a><span>|</span><a href="#41528596">next</a><span>|</span><label class="collapse" for="c-41528992">[-]</label><label class="expand" for="c-41528992">[2 more]</label></div><br/><div class="children"><div class="content">I quit my last job because of these kinds of shenanigans.<p>I was brought in to help get a full system rewrite across the finish line. Of course the deployment story was pretty great! Lots of automated scripts to get systems running nicely, autoscaling, even a nice CI builder. The works.<p>After joining, I found out all of this was to the detriment of so much. Nobody was running the full frontend&#x2F;backend on their machine. There was a team of 5 people but something like 10-15 services. CI was just busted when I joined, and people were constantly merging in things that broke the few tests that were present.<p>The killer was that because of this sort of division of labor, there&#x27;d be constant buck-passing because somebody wasn&#x27;t &quot;the person&quot; who worked on the other service. But in an alternate universe all of that would be in the same repo. Instead, everything ended up coordinated across three engineers.<p>A shame, because the operational story letting me really easy swap in a pod for my own machine in the test environment was cool! But the brittleness of the overall system was too much for me. Small teams really shouldn&#x27;t have fiefdoms.</div><br/><div id="41529158" class="c"><input type="checkbox" id="c-41529158" checked=""/><div class="controls bullet"><span class="by">ghomem</span><span>|</span><a href="#41528992">parent</a><span>|</span><a href="#41528596">next</a><span>|</span><label class="collapse" for="c-41529158">[-]</label><label class="expand" for="c-41529158">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There was a team of 5 people but something like 10-15 services<p>Puff! Talk about microservices! Or is it macropeople?! :-)</div><br/></div></div></div></div><div id="41528596" class="c"><input type="checkbox" id="c-41528596" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#41528992">prev</a><span>|</span><a href="#41528628">next</a><span>|</span><label class="collapse" for="c-41528596">[-]</label><label class="expand" for="c-41528596">[1 more]</label></div><br/><div class="children"><div class="content">It depends. I personally love cloud based solutions because they save me lots of time. But I&#x27;m highly selective in what I use and there are some solutions that are clearly counter productive because they are too complicated.<p>I run a small, bootstrapped startup. We don&#x27;t have enough money to pay ourselves and I make a living doing consulting on the side. Being budget and time constrained like that I have to be highly selective in what I use.<p>So, I love things like Google cloud. Our GCP bills are very modest. A few hundred euros per month. I would move to a cheaper provider except I can&#x27;t really justify the time investment. And I do like Google&#x27;s UI and tools relative to AWS, which I&#x27;ve used in the past.<p>I have no use for Kubernetes. Running an empty cluster would be more expensive than our current monthly GCP bills. And since I avoided falling into the micro-services pitfall, I have no need for it either. But I do love Docker. That makes deploying software stupidly easy. Our website is a Google storage bucket that is served via our load balancer and the Google CDN. The same load balancer routes rest calls to two vms that run our monolith. Which talk to a managed DB and managed Elasticsearch and a managed Redis. The DB and Elasticsearch are expensive. But having those managed saves a lot of time and hassle. That just about sums up everything we have. Nice and simple. And not that expensive.<p>I could move the whole thing to something like Hetzner and cut our bills by 50% or so. Worth doing maybe but not super urgent for me. Losing those managed services would make my life harder. I might have to go back to AWS at some point because some of our customers seem to prefer that. So, there is that as well.</div><br/></div></div><div id="41528628" class="c"><input type="checkbox" id="c-41528628" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#41528596">prev</a><span>|</span><a href="#41527963">next</a><span>|</span><label class="collapse" for="c-41528628">[-]</label><label class="expand" for="c-41528628">[1 more]</label></div><br/><div class="children"><div class="content">This is a retreaded and often tiresome debate. I&#x27;ll still throw my 2c in...<p>Should you pick a complex framework from day one? Probably not, unless your team has extensive experience with it.<p>My objection is towards the idea that managing infrastructure with a bespoke process and custom tooling will always be less effort to maintain than established tooling. It&#x27;s the idea of stubbornly rejecting the &quot;complexity&quot; bogeyman, even when the process you built yourself is far from simple, and takes a lot of your time from your core product anyway.<p>Everyone loves the simplicity of copying over a binary to a VPS, and restarting a service. But then you want to solve configuration and secret management, have multiple servers for availability&#x2F;redundancy so then you want gradual deployments, load balancing, rollbacks, etc. You probably also want some staging environment, so need to easily replicate this workflow. Then your team eventually grows and they find that it&#x27;s impossible to run a prod-like environment locally. And then, and then...<p>You&#x27;re forced to solve each new requirement with your own special approach, instead of relying on standard solutions others have figured out for you. It eventually gets to a question of sunken cost: do you want to abandon all this custom tooling you know and understand, in favor of &quot;complexity&quot; you don&#x27;t? The difficult thing is that the more you invest in it, the harder it will be to migrate away from it.<p>My suggestion is: start by following practices that will make your transition to the standard tooling later easier. This means deploying with containers from day 1, adopting the 12 factors methodology, etc. And when you do start to struggle with some feature you need, switch to established tooling sooner later than later. You&#x27;re likely find that your fear of the unknown was unwarranted, and you&#x27;ll spend less time working on infra in the long run.</div><br/></div></div><div id="41527963" class="c"><input type="checkbox" id="c-41527963" checked=""/><div class="controls bullet"><span class="by">pnathan</span><span>|</span><a href="#41528628">prev</a><span>|</span><a href="#41527951">next</a><span>|</span><label class="collapse" for="c-41527963">[-]</label><label class="expand" for="c-41527963">[4 more]</label></div><br/><div class="children"><div class="content">if you take the time to understand k8s and have a <i>straightforward</i> k8s deployment, these things aren&#x27;t really a problem - and you don&#x27;t have to do the custom sysadmin timesinks that need to go into the &quot;simple&quot; suggestion. What is suggested here is &quot;easy&quot;. But it is not simple: it proliferates custom work.<p>I have had great success with a very simple kube deployment:<p>- GKE (EKS works well but requires adding an autoscaler tool)<p>- Grafana + Loki + Prometheus for logs + metrics<p>- cert-manager for SSL<p>- nginx-ingress for routing<p>- external-dns for autosetup DNS<p>I manage these with helm. I might, one day, get around to using the Prometheus Operator thing, but it doesn&#x27;t seem to do anything for me except add a layer of hassle.<p>New deployments of my software roll out nicely. If I need to scale, cut a branch for testing, I roll into a new namespace easily, with TLS autosetup, DNS autosetup, logging to GCP bucket... no problem.<p>I&#x27;ve done the &quot;roll out an easy node and run&quot; thing before, and I regret it, badly, because the back half of the project was wrangling all these stupid little operational things that are a helm install away on k8s.<p>So if you&#x27;re doing a startup: roll out a nice simple k8s deployment, <i>don&#x27;t</i> muck it up with controllers, operators, service meshes, auto cicds, gitops, etc.  *KISS*.<p>If you&#x27;re trying to spin a number of small products: just use the same cluster with different DNS.<p>(note: if this seems particularly appealing to you, reach out, I&#x27;m happy to talk. This is a very straightforward toolset that has lasted me years and years, and I don&#x27;t anticipate having to change it much for a while)</div><br/><div id="41528017" class="c"><input type="checkbox" id="c-41528017" checked=""/><div class="controls bullet"><span class="by">catdog</span><span>|</span><a href="#41527963">parent</a><span>|</span><a href="#41528610">next</a><span>|</span><label class="collapse" for="c-41528017">[-]</label><label class="expand" for="c-41528017">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I manage these with helm. I might, one day, get around to using the Prometheus Operator thing, but it doesn&#x27;t seem to do anything for me except add a layer of hassle.<p>One big advantage of the operator is that its custom resources are practically kind of standard by now. This means helm charts for a lot of software ship those and integrating that piece of software into your monitoring is a matter of setting a few flags to true.
The go to solution for a k8s monitoring setup is <a href="https:&#x2F;&#x2F;github.com&#x2F;prometheus-community&#x2F;helm-charts&#x2F;tree&#x2F;main&#x2F;charts&#x2F;kube-prometheus-stack&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;prometheus-community&#x2F;helm-charts&#x2F;tree&#x2F;mai...</a></div><br/><div id="41528078" class="c"><input type="checkbox" id="c-41528078" checked=""/><div class="controls bullet"><span class="by">pnathan</span><span>|</span><a href="#41527963">root</a><span>|</span><a href="#41528017">parent</a><span>|</span><a href="#41528610">next</a><span>|</span><label class="collapse" for="c-41528078">[-]</label><label class="expand" for="c-41528078">[1 more]</label></div><br/><div class="children"><div class="content">yeah, I know, that&#x27;s the only reason I&#x27;m even thinking of using it. but tbqh I don&#x27;t really install many things, as you can see...</div><br/></div></div></div></div><div id="41528610" class="c"><input type="checkbox" id="c-41528610" checked=""/><div class="controls bullet"><span class="by">ramraj07</span><span>|</span><a href="#41527963">parent</a><span>|</span><a href="#41528017">prev</a><span>|</span><a href="#41527951">next</a><span>|</span><label class="collapse" for="c-41528610">[-]</label><label class="expand" for="c-41528610">[1 more]</label></div><br/><div class="children"><div class="content">I just hosted a site on Elastic beanstalk. Didn’t need to really do anything honestly. Upload a zip file with python code that runs locally really well. Database is on RDS. It has and continues to work well for 5+ years and lots of productivity.</div><br/></div></div></div></div><div id="41527951" class="c"><input type="checkbox" id="c-41527951" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#41527963">prev</a><span>|</span><a href="#41528147">next</a><span>|</span><label class="collapse" for="c-41527951">[-]</label><label class="expand" for="c-41527951">[2 more]</label></div><br/><div class="children"><div class="content">&gt; ... and Docker Swarm was deprecated..<p>I thought the same thing until recently.  Apparently there&#x27;s a &quot;Docker Swarm version 2&quot; around, and it was the original (version 1) Docker Swarm that was deprecated:<p><a href="https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;swarm&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;swarm&#x2F;</a><p><pre><code>  Do not confuse Docker Swarm mode with Docker Classic Swarm which is no
  longer actively developed.
</code></pre>
Haven&#x27;t personally tried out the version 2 Docker Swarm yet, but it might be worth a look at. :)</div><br/><div id="41528044" class="c"><input type="checkbox" id="c-41528044" checked=""/><div class="controls bullet"><span class="by">KronisLV</span><span>|</span><a href="#41527951">parent</a><span>|</span><a href="#41528147">next</a><span>|</span><label class="collapse" for="c-41528044">[-]</label><label class="expand" for="c-41528044">[1 more]</label></div><br/><div class="children"><div class="content">I use Swarm with Portainer, it’s quite a nice experience!</div><br/></div></div></div></div><div id="41528147" class="c"><input type="checkbox" id="c-41528147" checked=""/><div class="controls bullet"><span class="by">jumploops</span><span>|</span><a href="#41527951">prev</a><span>|</span><a href="#41527565">next</a><span>|</span><label class="collapse" for="c-41528147">[-]</label><label class="expand" for="c-41528147">[4 more]</label></div><br/><div class="children"><div class="content">Simple is robust.<p>Focus on product market fit (PMF) and keep things as straightforward as possible.<p>Create a monolith, duplicate code, use a single RDBMS, adopt proven tech instead of the “hot new framework”, etc.<p>The more simple the code, the easier it is to migrate&#x2F;scale later on.<p>Unnecessary complexity is the epitome of solving a problem that doesn’t exist.</div><br/><div id="41529165" class="c"><input type="checkbox" id="c-41529165" checked=""/><div class="controls bullet"><span class="by">ghomem</span><span>|</span><a href="#41528147">parent</a><span>|</span><a href="#41528531">next</a><span>|</span><label class="collapse" for="c-41529165">[-]</label><label class="expand" for="c-41529165">[1 more]</label></div><br/><div class="children"><div class="content">More of this.</div><br/></div></div><div id="41528531" class="c"><input type="checkbox" id="c-41528531" checked=""/><div class="controls bullet"><span class="by">kaptainscarlet</span><span>|</span><a href="#41528147">parent</a><span>|</span><a href="#41529165">prev</a><span>|</span><a href="#41527565">next</a><span>|</span><label class="collapse" for="c-41528531">[-]</label><label class="expand" for="c-41528531">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, I would focus on a better user experience over a  beautiful backend architecture.</div><br/><div id="41529168" class="c"><input type="checkbox" id="c-41529168" checked=""/><div class="controls bullet"><span class="by">ghomem</span><span>|</span><a href="#41528147">root</a><span>|</span><a href="#41528531">parent</a><span>|</span><a href="#41527565">next</a><span>|</span><label class="collapse" for="c-41529168">[-]</label><label class="expand" for="c-41529168">[1 more]</label></div><br/><div class="children"><div class="content">... and this!</div><br/></div></div></div></div></div></div><div id="41527565" class="c"><input type="checkbox" id="c-41527565" checked=""/><div class="controls bullet"><span class="by">hjaveed</span><span>|</span><a href="#41528147">prev</a><span>|</span><a href="#41528190">next</a><span>|</span><label class="collapse" for="c-41527565">[-]</label><label class="expand" for="c-41527565">[2 more]</label></div><br/><div class="children"><div class="content">After listening to @levelsio on Lex Friedman’s podcast, I became obsessed to simplify my deployments:<p>Do startups really need complex cloud architecture?<p>Inspired, I wrote a blog exploring simpler approaches and created a docker-compose template for deployment<p>Curious to know your thoughts on how you manage your infrastructure. How do you simplify it? How do you balance?</div><br/><div id="41527924" class="c"><input type="checkbox" id="c-41527924" checked=""/><div class="controls bullet"><span class="by">KronisLV</span><span>|</span><a href="#41527565">parent</a><span>|</span><a href="#41528190">next</a><span>|</span><label class="collapse" for="c-41527924">[-]</label><label class="expand" for="c-41527924">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Curious to know your thoughts on how you manage your infrastructure.<p>What I quite like about your repo:<p><pre><code>  - there is a separate API and background job instance
  - there is a separate web image, to not always couple front end deployments to back end
  - there are specialized data stores like Redis (or maybe RabbitMQ or MinIO in a different type of project)
  - Dozzle seems nice https:&#x2F;&#x2F;dozzle.dev&#x2F; (I use Portainer mostly, but seems useful)
</code></pre>
What I think works quite nicely in general:<p><pre><code>  - starting out with a monolithic back end but making it modular with feature flags (e.g. FEATURE_REPORTS, FEATURE_EMAILS, FEATURE_API), so that you can deploy vastly different types of workloads in separate containers BUT not duplicate your data model and don&#x27;t need to extract shared code libraries (yet) and if you ever need to split the codebase into multiple separate ones, then it won&#x27;t be *too* hard to do that
  - having a clear API (RESTful or otherwise) as the contract between a separate back end and front end deployment, so that even if your SPA technology gets deprecated (AngularJS, anyone?) then you can migrate to something, unlike when doing SSR and everything being coupled
  - the same applies to NOT having the same container build process have both the front end and back end build (I&#x27;ve seen a Java project install a specific Node version through Maven and then the build dragging on cause Maven ends up processing thousands of files as a part of the build)
  - using the right tool for the job: many might create full text search, key-value storage, message queues, JSON document storage, even blob storage all with PostgreSQL and that might be okay; others will go for separate instances of ElasticSearch, Redis, RabbitMQ, something S3 compatible and so on, probably a tradeoff between using well known libraries and tools vs building everything yourself against a single DB instance
  - in my experience, many projects out there are served perfectly fine by a single server so Docker Compose feels like the logical tool to start out with, if multiple instances indeed become necessary, there is always Docker Swarm (yes, still works, very simple), Hashicorp Nomad or K3s or one of the other more manageable Kubernetes distros
  - self-hosted (or self-hostable) software in general is pretty cool and gives you a bunch of freedom, though using managed cloud services will also be pleasant for many, more expensive upfront but less so in regards to your own time spent managing the stack; the former also lends itself nicely to being able to launch a local dev environment with the full stack, which feels like a superpower (being able to really test out breaking migrations, look at what happens with the whole stack etc.)
  - having some APM and tracing is nice, something like Apache Skywalking was pretty simple to setup, though there are more advanced options out there (e.g. cloud version of Sentry, because good luck running that locally)
  - having some uptime monitoring is also very nice, something like Uptime Kuma is just very pleasant to use
  - heck, if you really wanted to, you could even self-host a mail server: https:&#x2F;&#x2F;github.com&#x2F;docker-mailserver&#x2F;docker-mailserver (though that can be viewed as a hobbyist thing), or have MailCatcher &#x2F; Inbucket or something for development locally</code></pre></div><br/></div></div></div></div><div id="41528190" class="c"><input type="checkbox" id="c-41528190" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#41527565">prev</a><span>|</span><a href="#41527894">next</a><span>|</span><label class="collapse" for="c-41528190">[-]</label><label class="expand" for="c-41528190">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;ll allow me, I&#x27;d like to shill my company for a second.  We provide all the benefits of &quot;single server deployment&quot; while providing the scalability of the &quot;30 lambdas&quot; solution.<p>You can even run the whole thing locally.<p>We actually just did a Show HN about it:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41502094">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41502094</a></div><br/></div></div><div id="41527894" class="c"><input type="checkbox" id="c-41527894" checked=""/><div class="controls bullet"><span class="by">etaioinshrdlu</span><span>|</span><a href="#41528190">prev</a><span>|</span><a href="#41529262">next</a><span>|</span><label class="collapse" for="c-41527894">[-]</label><label class="expand" for="c-41527894">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, having done it both ways, first on VM&#x27;s, then on lots of fully or mostly managed services, I generally prefer the latter because systems tend to be a lot more &quot;self-healing&quot; - because they&#x27;re someone elses responsibility. This has had a dramatic effect on improving my sanity and sleeping well at night. I only wish I could migrate to an even more fully managed stack that&#x27;s more reliable and still less work. The cases where I haven&#x27;t been able to are either too expensive or would be too difficult to migrate.</div><br/></div></div><div id="41529262" class="c"><input type="checkbox" id="c-41529262" checked=""/><div class="controls bullet"><span class="by">ssss11</span><span>|</span><a href="#41527894">prev</a><span>|</span><a href="#41529045">next</a><span>|</span><label class="collapse" for="c-41529262">[-]</label><label class="expand" for="c-41529262">[1 more]</label></div><br/><div class="children"><div class="content">EC2 Linux VM with node, sqlite, let’s encrypt cert and a domain name.</div><br/></div></div><div id="41529045" class="c"><input type="checkbox" id="c-41529045" checked=""/><div class="controls bullet"><span class="by">mdavid626</span><span>|</span><a href="#41529262">prev</a><span>|</span><a href="#41529186">next</a><span>|</span><label class="collapse" for="c-41529045">[-]</label><label class="expand" for="c-41529045">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. Keep it simple. We&#x27;re running 1 monolith FastAPI service on EC2 with ECS (1 instance). Very simple, easy to debug and develop. Plus we have few lambdas for special tasks (like PDF generation), which run rarely, but are needed. Frontends are Vue projects served from a public S3 bucket. This setup might work for many years.</div><br/></div></div><div id="41529186" class="c"><input type="checkbox" id="c-41529186" checked=""/><div class="controls bullet"><span class="by">throwpok</span><span>|</span><a href="#41529045">prev</a><span>|</span><a href="#41528143">next</a><span>|</span><label class="collapse" for="c-41529186">[-]</label><label class="expand" for="c-41529186">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t matter how we build it if there are no users to use it. This is the real problem for many startups</div><br/></div></div><div id="41528143" class="c"><input type="checkbox" id="c-41528143" checked=""/><div class="controls bullet"><span class="by">sverhagen</span><span>|</span><a href="#41529186">prev</a><span>|</span><a href="#41528916">next</a><span>|</span><label class="collapse" for="c-41528143">[-]</label><label class="expand" for="c-41528143">[4 more]</label></div><br/><div class="children"><div class="content">Yes, use boring technology, I&#x27;m all for that.<p>But an application built in the high pressure environment of a startup also has the risk of becoming unmanageable, one or two years in. And to the extent you already have familiar tools to manage this complexity, I vote for using them. If you can divide and conquer your application complexity into a few different services, and you are already experienced in an appropriate application framework, that may not be such a bad choice. It helps focus on just one part of the application, and have multiple people work on the separate parts without stepping on each other.<p>I personally don&#x27;t think that should include k8s. But ECS&#x2F;Fargate with a simple build pipeline, all for that. &quot;Complex&quot; is the operative word in the article&#x27;s title.</div><br/><div id="41528153" class="c"><input type="checkbox" id="c-41528153" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#41528143">parent</a><span>|</span><a href="#41528916">next</a><span>|</span><label class="collapse" for="c-41528153">[-]</label><label class="expand" for="c-41528153">[3 more]</label></div><br/><div class="children"><div class="content">But it&#x27;s never just ECS&#x2F;Fargate is it. It&#x27;s ECR, S3, ALB, CF etc.<p>And at that point you&#x27;ve assembled a stack just as complex as doing it all inside a single k8s cluster.</div><br/><div id="41529179" class="c"><input type="checkbox" id="c-41529179" checked=""/><div class="controls bullet"><span class="by">ghomem</span><span>|</span><a href="#41528143">root</a><span>|</span><a href="#41528153">parent</a><span>|</span><a href="#41528908">next</a><span>|</span><label class="collapse" for="c-41529179">[-]</label><label class="expand" for="c-41529179">[1 more]</label></div><br/><div class="children"><div class="content">And if one of those services is down, your entire application is down. You basically build a server made of abstract components ECR, S3, ALB, CF , all of which are able to fail.</div><br/></div></div><div id="41528908" class="c"><input type="checkbox" id="c-41528908" checked=""/><div class="controls bullet"><span class="by">sverhagen</span><span>|</span><a href="#41528143">root</a><span>|</span><a href="#41528153">parent</a><span>|</span><a href="#41529179">prev</a><span>|</span><a href="#41528916">next</a><span>|</span><label class="collapse" for="c-41528908">[-]</label><label class="expand" for="c-41528908">[1 more]</label></div><br/><div class="children"><div class="content">Hence I said &quot;I personally&quot; and &quot;already have familiar tools&quot;.<p>Also, if you&#x27;re fair... not all those AWS acronyms you&#x27;re listing would be displaced by the single k8s cluster. (Maybe you weren&#x27;t arguing to swap out complexity, rather that the complexity floodgates were open already anyway?)</div><br/></div></div></div></div></div></div><div id="41528916" class="c"><input type="checkbox" id="c-41528916" checked=""/><div class="controls bullet"><span class="by">senko</span><span>|</span><a href="#41528143">prev</a><span>|</span><a href="#41528127">next</a><span>|</span><label class="collapse" for="c-41528916">[-]</label><label class="expand" for="c-41528916">[1 more]</label></div><br/><div class="children"><div class="content">Completely agree.<p>Scaling (and relatedly, high availability) are premature optimizations[0] implemented (and authorized) by people hoping for that sweet hockey stick growth, cargo culting practices needed by companies several orders of magnitude larger.<p>[0] <a href="https:&#x2F;&#x2F;blog.senko.net&#x2F;high-availability-is-premature-optimization" rel="nofollow">https:&#x2F;&#x2F;blog.senko.net&#x2F;high-availability-is-premature-optimi...</a></div><br/></div></div><div id="41528127" class="c"><input type="checkbox" id="c-41528127" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41528916">prev</a><span>|</span><a href="#41528747">next</a><span>|</span><label class="collapse" for="c-41528127">[-]</label><label class="expand" for="c-41528127">[3 more]</label></div><br/><div class="children"><div class="content">&gt; 20-30 Lambda functions for different services<p>Yes.  This is the basis of privilege separation and differential rollouts.  If you collapse all this down into a single server or even lambda you lose that.  Once your service sees load you will want this badly.<p>&gt; SQS and various background jobs backed by Lambda<p>Yes.  This is the basis of serverless.  The failure of one server is no longer a material concern to your operation.  Well done you.<p>&gt; Logs scattered across CloudWatch<p>Okay.  I can&#x27;t lie.  CloudWatch is dogturds.  There is no part of the service that is redeemable.  I created a DyanmoDB table and created a library which puts log lines collected into &quot;task records&quot; into the table paritioned by lambda name and sorted by record time.  Each lambda can configure the logging environment or use default which include a log entry expiration time.  Then I created a command line utility which can query and or &quot;tail&quot; this table.<p>This work took me 3 days.  It&#x27;s paid off 1000x fold since I did it.  You do sometimes have to roll your own out here.  CloudWatch is strictly about logging cold start times now.<p>&gt; Could this have been simplified to a single NodeJS container or Python Flask&#x2F;FastAPI app with Redis for background tasks? Absolutely.<p>Could this have been simplified into something far more fragile than what is described?  Absolutely.  Why you&#x27;d want this is entirely beyond me.</div><br/><div id="41528290" class="c"><input type="checkbox" id="c-41528290" checked=""/><div class="controls bullet"><span class="by">throwawaythekey</span><span>|</span><a href="#41528127">parent</a><span>|</span><a href="#41528747">next</a><span>|</span><label class="collapse" for="c-41528290">[-]</label><label class="expand" for="c-41528290">[2 more]</label></div><br/><div class="children"><div class="content">I agree that cloudwatch <i>is</i> dogturds, but want to dive deeper for illustrative purposes:<p>Your dynamodb solution isn&#x27;t foolproof. It has throughput limited to the partition granularity -&gt; in your case the lambda name. It&#x27;s also relatively expensive and fairly slow to query in bulk (DDB is designed for OLTP).<p>I don&#x27;t have direct experience here, but I expect slapping grafana on top of any disk basked source is likely to be cheaper, faster, and have better ergonomics. Once your logging is too much for a disk to handle (this will be later than you would&#x27;ve outgrown ddb, but before you would&#x27;ve outgrown cloudwatch) then you can bring something fancy in.</div><br/><div id="41528362" class="c"><input type="checkbox" id="c-41528362" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41528127">root</a><span>|</span><a href="#41528290">parent</a><span>|</span><a href="#41528747">next</a><span>|</span><label class="collapse" for="c-41528362">[-]</label><label class="expand" for="c-41528362">[1 more]</label></div><br/><div class="children"><div class="content">&gt; has throughput limited<p>The event volume is not particularly large as we tend to process things in batch and rarely on the edge of an event.  I also wouldn&#x27;t,  for example,  log API requests using this mechanism.  We&#x27;re nowhere near this being an issue as 20-30 lambdas is not a particular problem for us.  Choose a good naming convention and build your own deployment infrastructure and it&#x27;s no sweat.<p>&gt; relatively expensive<p>Large object compression and&#x2F;or offload to s3 is baked into our dynamodb interface library.  Not that this matters as almost all log records end up being less than 4kb anyways.<p>&gt; slow to query in bulk<p>Which is why time is part of the key.  You&#x27;re not often looking back more than an hour.  There&#x27;s bulk export back onto campus servers if you wanted that anyways.  TTL is default 1 day.  Running a &quot;tail&quot; is absurdly cheap,  much cheaper than CloudWatch&#x27;s laughable rate for their similar feature,  a miss is 1&#x2F;2 a read unit,  and a hit is almost never more than 2.<p>&gt; slapping grafana<p>I didn&#x27;t need &quot;observability.&quot;  I need current state and recent deltas.  This is particularly true when any changes are made.  Otherwise my logs are pure annoyance and don&#x27;t generally provide value.  We optimized for the exceptionally narrow case we felt the cloud underserved in and left it at that.</div><br/></div></div></div></div></div></div><div id="41528629" class="c"><input type="checkbox" id="c-41528629" checked=""/><div class="controls bullet"><span class="by">shahzaibmushtaq</span><span>|</span><a href="#41528747">prev</a><span>|</span><a href="#41528804">next</a><span>|</span><label class="collapse" for="c-41528629">[-]</label><label class="expand" for="c-41528629">[1 more]</label></div><br/><div class="children"><div class="content">Yes, your startup needs complex cloud infrastructure when your organizational infrastructure can afford it in terms of money, other resources and time.<p>One domain, an idea, an easy-to-use development stack for a bootstrapped as well as funded startup is more than good enough to locate product-market fit.<p>Alway remember this quote by Reid Hoffman “If you are not embarrassed by the first version of your product, you’ve launched too late.”</div><br/></div></div><div id="41528804" class="c"><input type="checkbox" id="c-41528804" checked=""/><div class="controls bullet"><span class="by">negus</span><span>|</span><a href="#41528629">prev</a><span>|</span><label class="collapse" for="c-41528804">[-]</label><label class="expand" for="c-41528804">[1 more]</label></div><br/><div class="children"><div class="content">TLDR: I&#x27;m not too good with the infrastucture (and this couple of teams also), so you should also go on steam engines.<p>Of cource it highly depends on the skills of the team. In a startup there could be no time to learn how to do infrastructure well. But having an infrastructure expert in the team can significantly improve the time to market and reduce the developer burnout and the  tech debt growth rate.</div><br/></div></div></div></div></div></div></div></body></html>