<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721034065349" as="style"/><link rel="stylesheet" href="styles.css?v=1721034065349"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://pr.pico.sh/">Git-PR: patch requests over SSH</a> <span class="domain">(<a href="https://pr.pico.sh">pr.pico.sh</a>)</span></div><div class="subtext"><span>steventhedev</span> | <span>98 comments</span></div><br/><div><div id="40966237" class="c"><input type="checkbox" id="c-40966237" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#40961624">next</a><span>|</span><label class="collapse" for="c-40966237">[-]</label><label class="expand" for="c-40966237">[1 more]</label></div><br/><div class="children"><div class="content">This is so slick. It&#x27;s amazing to see how well git works when used in the way Linus intended. It seems to be missing some fundamentals (readme.md, signing, ssh key rotation), which I might try contributing to get my feet with :)</div><br/></div></div><div id="40961624" class="c"><input type="checkbox" id="c-40961624" checked=""/><div class="controls bullet"><span class="by">beshrkayali</span><span>|</span><a href="#40966237">prev</a><span>|</span><a href="#40960611">next</a><span>|</span><label class="collapse" for="c-40961624">[-]</label><label class="expand" for="c-40961624">[5 more]</label></div><br/><div class="children"><div class="content">There&#x27;s definitely something very interesting here.<p>Keeping the user in their editor for code reviews is pretty nice indeed, but I think that with larger projects and bigger changes, it&#x27;s going to be way more difficult to skim through what has changed where, which helps me identify how to start reviewing. There would have to be an easier way to see what changed where quickly without having to mess up my working tree (which is almost always dirty with something) and having to stash or switch back and forth between branches for reviewing is going to be painful. Sometimes I have small comments or questions, I&#x27;d like to be able to do that without having to download the entire patch.<p>Also, I&#x27;m not sure if I missed something, but does every review get applied as a commit by itself that I (as repo owner) would have to squash? This feels like a chore by itself.<p>I have relied on github for previous work but for the last couple of years I&#x27;ve been primarily using Gerrit for my job, and although there are some drawbacks, I absolutely love its workflow. Github workflow is not free from drawbacks either, and if I&#x27;m asked now I absolutely prefer Gerrit&#x27;s to Github&#x27;s. Gerrit uses Git references in a unique way to facilitate code reviews and patches (which consist of one or more patchsets). I rarely use branches now except for extremely long-lived experiments, or for local temp purposes. A patch gets merged as a single commit no matter how many rounds of patchsets the submitter adds and reviews they get, and when needed I can quickly download the patch at any patchset to a different branch and then delete it.</div><br/><div id="40963295" class="c"><input type="checkbox" id="c-40963295" checked=""/><div class="controls bullet"><span class="by">Timshel</span><span>|</span><a href="#40961624">parent</a><span>|</span><a href="#40962413">next</a><span>|</span><label class="collapse" for="c-40963295">[-]</label><label class="expand" for="c-40963295">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There would have to be an easier way to see what changed where quickly without having to mess up my working tree (which is almost always dirty with something) and having to stash or switch back and forth between branches for reviewing is going to be painful.<p>I think it mesh well with worktree, you can setup one dedicated to review.</div><br/></div></div><div id="40962413" class="c"><input type="checkbox" id="c-40962413" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#40961624">parent</a><span>|</span><a href="#40963295">prev</a><span>|</span><a href="#40960611">next</a><span>|</span><label class="collapse" for="c-40962413">[-]</label><label class="expand" for="c-40962413">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There would have to be an easier way to see what changed where quickly without having to mess up my working tree (which is almost always dirty with something) and having to stash or switch back and forth between branches for reviewing is going to be painful. Sometimes I have small comments or questions, I&#x27;d like to be able to do that without having to download the entire patch.<p>I love this feedback and totally agree with you.  Pulling a PR down and applying to review is great until you need to reference what&#x27;s in main and have to ping-pong between them.  At the end of the day, `git-pr` supports pushing and pull patchsets and we do have ideas around how a reviewer could review a patch request without applying it locally for something lighter-weight.  Something like editing a patchset directly (with comments) and uploading that.<p>I think I need to play around with Gerrit.  When originally developing this idea, I looked at Gerrit but didn&#x27;t actually play around with it.<p>Someone else mentioned this already but I do want to experiment with revisions and supporting `git range-diff` workflows which I think could provide better support for larger reviews.</div><br/><div id="40962481" class="c"><input type="checkbox" id="c-40962481" checked=""/><div class="controls bullet"><span class="by">e3bc54b2</span><span>|</span><a href="#40961624">root</a><span>|</span><a href="#40962413">parent</a><span>|</span><a href="#40963048">next</a><span>|</span><label class="collapse" for="c-40962481">[-]</label><label class="expand" for="c-40962481">[1 more]</label></div><br/><div class="children"><div class="content">Gerrit is the gold standard of code reviews and I&#x27;ll die on that hill. I&#x27;ve heard many a good things about phabricator too, but it requires lot of special tooling while gerrit just uses plain old git semantics.<p>That said, I live git-pr so far. I have a forgejo instance and I like it for what it provides, but without federation, external contributors aren&#x27;t able to contribute.<p>If git-pr can be made to work with forgejo, I&#x27;ll just go for it (self hosted, of course).</div><br/></div></div><div id="40963048" class="c"><input type="checkbox" id="c-40963048" checked=""/><div class="controls bullet"><span class="by">germandiago</span><span>|</span><a href="#40961624">root</a><span>|</span><a href="#40962413">parent</a><span>|</span><a href="#40962481">prev</a><span>|</span><a href="#40960611">next</a><span>|</span><label class="collapse" for="c-40963048">[-]</label><label class="expand" for="c-40963048">[1 more]</label></div><br/><div class="children"><div class="content">Gerrit is really good at code reviews. It is a matter of getting used to at first, but later it is very easy to track even differences between patchsets. It also marks you what you did <i>not</i> reivew if a new patchset is pushed, without marking the files that did not change. It lets you pick the changes locally if you want as well. I think it is very good for reviews.</div><br/></div></div></div></div></div></div><div id="40960611" class="c"><input type="checkbox" id="c-40960611" checked=""/><div class="controls bullet"><span class="by">Daviey</span><span>|</span><a href="#40961624">prev</a><span>|</span><a href="#40960082">next</a><span>|</span><label class="collapse" for="c-40960611">[-]</label><label class="expand" for="c-40960611">[11 more]</label></div><br/><div class="children"><div class="content">Can you expand a bit more why this workflow (send patch over ssh, and rss feeds for owner), is better than either email workflow or using a centralised service with Pull Requests.</div><br/><div id="40961516" class="c"><input type="checkbox" id="c-40961516" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#40960611">parent</a><span>|</span><a href="#40964791">next</a><span>|</span><label class="collapse" for="c-40961516">[-]</label><label class="expand" for="c-40961516">[8 more]</label></div><br/><div class="children"><div class="content">Sure.  Pull Requests tend to force users into collaborating in a web view.  Further, they require a collaborator to:<p>- have an account on the platform<p>- fork the repo<p>- pull repo<p>- create a branch<p>- make the change<p>- push to forked repo<p>- click a button in the UI to create the PR<p>With `git-pr` it can be this simple:<p>- pull repo<p>- make the change<p>- submit pr with a single command `git format-patch | ssh host pr create x`<p>If you&#x27;ve ever used the email workflow I don&#x27;t think I need to explain why it sucks.</div><br/><div id="40961779" class="c"><input type="checkbox" id="c-40961779" checked=""/><div class="controls bullet"><span class="by">pkal</span><span>|</span><a href="#40960611">root</a><span>|</span><a href="#40961516">parent</a><span>|</span><a href="#40961863">next</a><span>|</span><label class="collapse" for="c-40961779">[-]</label><label class="expand" for="c-40961779">[5 more]</label></div><br/><div class="children"><div class="content">This seems to come very close to recognising that if someone without permissions pushes something to a repository, it should be convered into a PR.<p>&gt; If you&#x27;ve ever used the email workflow I don&#x27;t think I need to explain why it sucks.<p>I prefer it FWIW.  After setting up your Email, it is much easier and faster to send a mail than go through a PR-process.  On the reciving end you can respond inline to the patch, in the compfort of your email client, without having to use a browser.<p>My feeling is that people who don&#x27;t like this, don&#x27;t have a good mail setup (which is understandable given some hosts), making Email much more painful to use in general.</div><br/><div id="40962122" class="c"><input type="checkbox" id="c-40962122" checked=""/><div class="controls bullet"><span class="by">johnny22</span><span>|</span><a href="#40960611">root</a><span>|</span><a href="#40961779">parent</a><span>|</span><a href="#40961863">next</a><span>|</span><label class="collapse" for="c-40962122">[-]</label><label class="expand" for="c-40962122">[4 more]</label></div><br/><div class="children"><div class="content">If you review PRs as whole, you don&#x27;t need to use the web interface. I think it only gets harder when you want to do inline comments. At least that&#x27;s what the docs for github cli suggest. <a href="https:&#x2F;&#x2F;cli.github.com&#x2F;manual&#x2F;gh_pr_review" rel="nofollow">https:&#x2F;&#x2F;cli.github.com&#x2F;manual&#x2F;gh_pr_review</a><p>It does seem like it would be hard to support inline comments properly outside of an email quoting context without editor integration.</div><br/><div id="40962220" class="c"><input type="checkbox" id="c-40962220" checked=""/><div class="controls bullet"><span class="by">j5155</span><span>|</span><a href="#40960611">root</a><span>|</span><a href="#40962122">parent</a><span>|</span><a href="#40961863">next</a><span>|</span><label class="collapse" for="c-40962220">[-]</label><label class="expand" for="c-40962220">[3 more]</label></div><br/><div class="children"><div class="content">Some IDEs actually have GitHub PR integration (JetBrains ones) with full comment support. It is amazing and one of my favorite features by far.</div><br/><div id="40962330" class="c"><input type="checkbox" id="c-40962330" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#40960611">root</a><span>|</span><a href="#40962220">parent</a><span>|</span><a href="#40961863">next</a><span>|</span><label class="collapse" for="c-40962330">[-]</label><label class="expand" for="c-40962330">[2 more]</label></div><br/><div class="children"><div class="content">VSCode has it via their GitHub extension.</div><br/><div id="40965636" class="c"><input type="checkbox" id="c-40965636" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#40960611">root</a><span>|</span><a href="#40962330">parent</a><span>|</span><a href="#40961863">next</a><span>|</span><label class="collapse" for="c-40965636">[-]</label><label class="expand" for="c-40965636">[1 more]</label></div><br/><div class="children"><div class="content">And that can be used online, replace `GitHub.com` by `GitHub.dev` on a PR and it’ll drop you in the web based vscode.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40961863" class="c"><input type="checkbox" id="c-40961863" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#40960611">root</a><span>|</span><a href="#40961516">parent</a><span>|</span><a href="#40961779">prev</a><span>|</span><a href="#40964782">next</a><span>|</span><label class="collapse" for="c-40961863">[-]</label><label class="expand" for="c-40961863">[1 more]</label></div><br/><div class="children"><div class="content">On the general idea, I&#x27;m thoroughly in support of alternative interfaces and workflows, so I see git-pr as a net win.<p>On the above steps, I feel it&#x27;s misrepresenting what github&#x2F;gitlab have to offer. The only real step would be &quot;have an account on the platform&quot; and looking at the file in a browser. From there creating a MR&#x2F;PR in a new branch with the changes you want is painless and a matter of 3 or 4 clicks.<p>It works very well for repos with config files that only need the CI to be green, you get a full MR in 1 min if you want to.</div><br/></div></div><div id="40964782" class="c"><input type="checkbox" id="c-40964782" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40960611">root</a><span>|</span><a href="#40961516">parent</a><span>|</span><a href="#40961863">prev</a><span>|</span><a href="#40964791">next</a><span>|</span><label class="collapse" for="c-40964782">[-]</label><label class="expand" for="c-40964782">[1 more]</label></div><br/><div class="children"><div class="content">Are you not skipping the public key enrollment step in your simple description of `git-pr`?</div><br/></div></div></div></div><div id="40964791" class="c"><input type="checkbox" id="c-40964791" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40960611">parent</a><span>|</span><a href="#40961516">prev</a><span>|</span><a href="#40960082">next</a><span>|</span><label class="collapse" for="c-40964791">[-]</label><label class="expand" for="c-40964791">[2 more]</label></div><br/><div class="children"><div class="content">&gt; or using a centralised service<p>Notice that `git-pr` still has a centralized service, just an SSH-based one rather than HTTP-based.  I don&#x27;t see a win there.</div><br/><div id="40966026" class="c"><input type="checkbox" id="c-40966026" checked=""/><div class="controls bullet"><span class="by">carom</span><span>|</span><a href="#40960611">root</a><span>|</span><a href="#40964791">parent</a><span>|</span><a href="#40960082">next</a><span>|</span><label class="collapse" for="c-40966026">[-]</label><label class="expand" for="c-40966026">[1 more]</label></div><br/><div class="children"><div class="content">My understanding is that it accepts arbitrary keys.</div><br/></div></div></div></div></div></div><div id="40960082" class="c"><input type="checkbox" id="c-40960082" checked=""/><div class="controls bullet"><span class="by">rkta</span><span>|</span><a href="#40960611">prev</a><span>|</span><a href="#40960354">next</a><span>|</span><label class="collapse" for="c-40960082">[-]</label><label class="expand" for="c-40960082">[2 more]</label></div><br/><div class="children"><div class="content">After reading the website and also trying the mentioned `ssh pr.pico.sh help` I still don&#x27;t know what exactly to do to use this.<p>&gt; 4. External contributor submits a PR to SSH server
But how? That numbered list let me think of that old cartman profit meme.<p>I like the idea, but I&#x27;m not convinced yet, that this is really easier than just sending an email by `git request-pull`.</div><br/><div id="40960580" class="c"><input type="checkbox" id="c-40960580" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#40960082">parent</a><span>|</span><a href="#40960354">next</a><span>|</span><label class="collapse" for="c-40960580">[-]</label><label class="expand" for="c-40960580">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for that feedback, I removed a couple important pieces from the repo readme that I think would answer your questions around usage.  I&#x27;ll add them into the main site.</div><br/></div></div></div></div><div id="40960354" class="c"><input type="checkbox" id="c-40960354" checked=""/><div class="controls bullet"><span class="by">bobek</span><span>|</span><a href="#40960082">prev</a><span>|</span><a href="#40962489">next</a><span>|</span><label class="collapse" for="c-40960354">[-]</label><label class="expand" for="c-40960354">[5 more]</label></div><br/><div class="children"><div class="content">Patch review flow was one of the thing I&#x27;ve really enjoyed with Phabricator.</div><br/><div id="40964055" class="c"><input type="checkbox" id="c-40964055" checked=""/><div class="controls bullet"><span class="by">wyldfire</span><span>|</span><a href="#40960354">parent</a><span>|</span><a href="#40960512">next</a><span>|</span><label class="collapse" for="c-40964055">[-]</label><label class="expand" for="c-40964055">[1 more]</label></div><br/><div class="children"><div class="content">I think gerrit seems to use this same kind of workflow, but with a git frontend (but just for transmitting the patches).  More convenient than arcanist IMO.</div><br/></div></div><div id="40960512" class="c"><input type="checkbox" id="c-40960512" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#40960354">parent</a><span>|</span><a href="#40964055">prev</a><span>|</span><a href="#40962489">next</a><span>|</span><label class="collapse" for="c-40960512">[-]</label><label class="expand" for="c-40960512">[3 more]</label></div><br/><div class="children"><div class="content">pico team member here, I&#x27;d love to learn more about what your liked about using Phabricator.</div><br/><div id="40962512" class="c"><input type="checkbox" id="c-40962512" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40960354">root</a><span>|</span><a href="#40960512">parent</a><span>|</span><a href="#40962489">next</a><span>|</span><label class="collapse" for="c-40962512">[-]</label><label class="expand" for="c-40962512">[2 more]</label></div><br/><div class="children"><div class="content">Yeah me too. I used Phabricator extensively and in practice it is basically the same as Gitlab and GitHub and everyone else. You just say `arc diff` instead of `git push`.<p>Phabricator was pretty nice overall I would say. The bug tracker in particular was good. I have to use Jira now and it&#x27;s night and day.<p>The big flaw was there was essentially no CI support. That and the fact it was written in PHP, which you&#x27;d think wouldn&#x27;t matter, but I did end up being forced to learn some PHP to fix Phabricator bugs and write custom linters.<p>Now we&#x27;re using Gitlab which is also decent except it&#x27;s written in Ruby which if anything is worse than PHP! Absolutely unreadable code base. I can&#x27;t fix anything. (Except in gitlab-runner which is written in Go - I&#x27;ve contributed several fixes &amp; features there.)</div><br/><div id="40963901" class="c"><input type="checkbox" id="c-40963901" checked=""/><div class="controls bullet"><span class="by">zeotroph</span><span>|</span><a href="#40960354">root</a><span>|</span><a href="#40962512">parent</a><span>|</span><a href="#40962489">next</a><span>|</span><label class="collapse" for="c-40963901">[-]</label><label class="expand" for="c-40963901">[1 more]</label></div><br/><div class="children"><div class="content">&gt; just say `arc diff` instead of `git push`.<p>&quot;just&quot; - I bounced off Phabricator because I couldn&#x27;t use native git tooling, and what mapped to where wasn&#x27;t clear to me. The pure git approach of git-pr is the exact opposite of that. Sure, someone is going to write just-too-useful-to-skip-wrappers around that later, but you always know what&#x27;s going on under the hood.</div><br/></div></div></div></div></div></div></div></div><div id="40962489" class="c"><input type="checkbox" id="c-40962489" checked=""/><div class="controls bullet"><span class="by">gtest</span><span>|</span><a href="#40960354">prev</a><span>|</span><a href="#40960659">next</a><span>|</span><label class="collapse" for="c-40962489">[-]</label><label class="expand" for="c-40962489">[3 more]</label></div><br/><div class="children"><div class="content">Any solution has its cons. Github workflows has downsides and this solution does solve them (and introduces its own). But what I am not getting is why this approach is better than the email workflow.<p>The downsides of email workflow that the author mentioned are (1) Having to setup mailing list, (2) setting the mail client, (3) friction in submitting a patch, which I assume the author is referring to setting git-send, (4) email is limited such as not being able to modify it, not being able to download the patch, and limitation around the plain-text, and the author doesn&#x27;t hint into what limitation he is thinking of.<p>These are downsides of email workflow, and I do not think they are significant (except for 1, which could be done though a person&#x27;s email address if the project is small). But the SSH workflow replaces them with similar issues such as (1) setting SSH server and maintaining it and the cost associated with it, (2) clients will need to maintain their identities though SSH, (4) replace email-replies with code comments (email-replies is better as you can do more than just text). (3) Here SSH workflow is better as it requires no work, but configuring git-send is a very small and usually 1-time change.<p>In most cases, the only mail client requirement is to be able to write plain text. Virtually all mail clients can do this with a simple checkbox. Only the maintainer will need ability to `git am&#x27; the patch from an email message, and this is indeed a downside of email workflow.<p>All in all, nothing wrong with more options, and I am sure SSH meets certain needs, but to me email-workflow and SSH compete in the same category and email-workflow is superior.</div><br/><div id="40962968" class="c"><input type="checkbox" id="c-40962968" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40962489">parent</a><span>|</span><a href="#40960659">next</a><span>|</span><label class="collapse" for="c-40962968">[-]</label><label class="expand" for="c-40962968">[2 more]</label></div><br/><div class="children"><div class="content">Eh, (2)&#x2F;(3) can be a pain for web mail accounts. For instance, I couldn&#x27;t send patches to LKML through Gmail directly, since even for plain-text emails it wants to rewrap long lines itself. To get &quot;git send-email&quot; working through it, I had to wade through a bunch of outdated info to find the right method.<p>Even now there are persistent downsides: every email through &quot;git send-email&quot; contains my original IP address for everyone to see, unless I use a VPN service. Also, since I&#x27;m not a right-thinking person with a &#x27;real&#x27; client-based inbox, I have to fiddle with the In-Reply-To and References headers by hand, if I want to include a patch in a reply to another email.</div><br/><div id="40963693" class="c"><input type="checkbox" id="c-40963693" checked=""/><div class="controls bullet"><span class="by">dustyharddrive</span><span>|</span><a href="#40962489">root</a><span>|</span><a href="#40962968">parent</a><span>|</span><a href="#40960659">next</a><span>|</span><label class="collapse" for="c-40963693">[-]</label><label class="expand" for="c-40963693">[1 more]</label></div><br/><div class="children"><div class="content">&gt; every email through &quot;git send-email&quot; contains my original IP address for everyone to see<p>Is this the fault of git or your SMTP provider? I looked through a mailman archive and couldn&#x27;t find my client IP address. The first Received headers refer to my email host.</div><br/></div></div></div></div></div></div><div id="40960659" class="c"><input type="checkbox" id="c-40960659" checked=""/><div class="controls bullet"><span class="by">illegalmemory</span><span>|</span><a href="#40962489">prev</a><span>|</span><a href="#40960010">next</a><span>|</span><label class="collapse" for="c-40960659">[-]</label><label class="expand" for="c-40960659">[1 more]</label></div><br/><div class="children"><div class="content">That you, looks interesting. But the license is not specified on Github.</div><br/></div></div><div id="40960010" class="c"><input type="checkbox" id="c-40960010" checked=""/><div class="controls bullet"><span class="by">lifeisstillgood</span><span>|</span><a href="#40960659">prev</a><span>|</span><a href="#40962076">next</a><span>|</span><label class="collapse" for="c-40960010">[-]</label><label class="expand" for="c-40960010">[5 more]</label></div><br/><div class="children"><div class="content">I like the basic philosophy that everything should be inside the code (yes lots of great collaboration and review tools out there with great browser based diffing- it’s just I am thirty years of reading code and writing code in a tool and I kinda get used to the code in the tool</div><br/><div id="40960275" class="c"><input type="checkbox" id="c-40960275" checked=""/><div class="controls bullet"><span class="by">pushfoo</span><span>|</span><a href="#40960010">parent</a><span>|</span><a href="#40962076">next</a><span>|</span><label class="collapse" for="c-40960275">[-]</label><label class="expand" for="c-40960275">[4 more]</label></div><br/><div class="children"><div class="content">I agree for smaller projects, especially personal ones. For larger projects, approaches like GitHub&#x27;s web client + terminal interface might be the next best thing since grepping doesn&#x27;t scale well. For better or worse, GitHub branding also helps make their specific terminal tool an easier sell in large org environments.</div><br/><div id="40961110" class="c"><input type="checkbox" id="c-40961110" checked=""/><div class="controls bullet"><span class="by">tristan957</span><span>|</span><a href="#40960010">root</a><span>|</span><a href="#40960275">parent</a><span>|</span><a href="#40961126">next</a><span>|</span><label class="collapse" for="c-40961110">[-]</label><label class="expand" for="c-40961110">[1 more]</label></div><br/><div class="children"><div class="content">GitHub&#x27;s web client does not scale at all in my opinion. It is very slow to load source large patches, and the code navigation experience is not great, hence why they brought VSCode for Web to the product, but still.</div><br/></div></div><div id="40961126" class="c"><input type="checkbox" id="c-40961126" checked=""/><div class="controls bullet"><span class="by">xelamonster</span><span>|</span><a href="#40960010">root</a><span>|</span><a href="#40960275">parent</a><span>|</span><a href="#40961110">prev</a><span>|</span><a href="#40962076">next</a><span>|</span><label class="collapse" for="c-40961126">[-]</label><label class="expand" for="c-40961126">[2 more]</label></div><br/><div class="children"><div class="content">Heh, well GitHub&#x27;s search doesn&#x27;t exactly scale well either. They _still_ only index the main branch, so if you want to find anything under active development or on an old tag version you&#x27;re out of luck, clone + grep is the only way.</div><br/><div id="40961749" class="c"><input type="checkbox" id="c-40961749" checked=""/><div class="controls bullet"><span class="by">lifeisstillgood</span><span>|</span><a href="#40960010">root</a><span>|</span><a href="#40961126">parent</a><span>|</span><a href="#40962076">next</a><span>|</span><label class="collapse" for="c-40961749">[-]</label><label class="expand" for="c-40961749">[1 more]</label></div><br/><div class="children"><div class="content">Grepping for something “I am sure it was on a development branch somewhere” is always painful.<p>I do dream of one day tackling a whole load of these developer “gold plated porcelain” problems - everything from a “glimpse” index of every commit in a repo to better Jenkins config and how to set up mTLS the hard way.<p>It’s “Thedevmanual” and someday I will have time to write it</div><br/></div></div></div></div></div></div></div></div><div id="40962076" class="c"><input type="checkbox" id="c-40962076" checked=""/><div class="controls bullet"><span class="by">zeotroph</span><span>|</span><a href="#40960010">prev</a><span>|</span><a href="#40960901">next</a><span>|</span><label class="collapse" for="c-40962076">[-]</label><label class="expand" for="c-40962076">[4 more]</label></div><br/><div class="children"><div class="content">How do you envision pushing&#x2F;reviewing a branch of 3 cleanly separated commits (say: write failing test, fix code, refactor) into a repo with a fast-forward&#x2F;no-merge policy? The end result should of course be 3 commits, but review history should not be lost.<p>1) push 3 commits  (author)<p>2) push 3 commits + 1 review commit (reviewer)<p>or even 2a), + 3 interleaved review commits, might be needed if the final refactor removes something.<p>then<p>3a) force-push 3 commits with the review comments applied (you mentioned --force is supported)<p>3b) or push 3 + 1 + (worst case 3) fixup commits, then a squash later?<p>If 3a), does pico have the concept of patchsets like gerrit, so the state 2) can be retrieved later?<p>PS: ... or even 2c, if the line I am commenting on is removed in patch 2 I would need to push a whole &quot;review tree&quot; (or fix conflicts in b and c):<p><pre><code>   a -- b -- c -- review-c
    \   \
     \   `-review-b
      `- review-a</code></pre></div><br/><div id="40962479" class="c"><input type="checkbox" id="c-40962479" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#40962076">parent</a><span>|</span><a href="#40965957">next</a><span>|</span><label class="collapse" for="c-40962479">[-]</label><label class="expand" for="c-40962479">[2 more]</label></div><br/><div class="children"><div class="content">Right now, when force pushing, we preserve event logs for every server mutation, but the review themselves are lost.<p>We do see this as a problem and are thinking about ways to address it.  We do support the idea of a patchset (that&#x27;s what the patch request managed).  Right now we only support a single patchset for a patch request, but we are leaning toward introducing patch revisions where both contrib and owner submit entire versions of the patchset.  This could provide better tracability since reviews would be in a separate patchset &quot;channel&quot; and not lost to force pushing.<p>We also plan on supporting a patch request &quot;cover letter&quot; which includes all the events and comments during review.  This cover letter is just an empty patch which could be `git am --empty=keep` or `git am --empty=drop` depending on preference.</div><br/><div id="40963702" class="c"><input type="checkbox" id="c-40963702" checked=""/><div class="controls bullet"><span class="by">zeotroph</span><span>|</span><a href="#40962076">root</a><span>|</span><a href="#40962479">parent</a><span>|</span><a href="#40965957">next</a><span>|</span><label class="collapse" for="c-40963702">[-]</label><label class="expand" for="c-40963702">[1 more]</label></div><br/><div class="children"><div class="content">Good to hear, Gerrit does a lot of things right, see &quot;stacked diffs&quot; (or the realization that GitHub lacks these) now becoming more popular. And the patchset model is one important aspect of that, especially being able to see the difference just between patchsets - which git-pr can then do via `git range-diff` (which you already mentioned).<p>And even if everything git-pr does <i>could</i> be done by talking to the Gerrit REST-API, a simple straight forward and lightweight implementation of the &quot;essence&quot; of this model is very useful.</div><br/></div></div></div></div><div id="40965957" class="c"><input type="checkbox" id="c-40965957" checked=""/><div class="controls bullet"><span class="by">nektro</span><span>|</span><a href="#40962076">parent</a><span>|</span><a href="#40962479">prev</a><span>|</span><a href="#40960901">next</a><span>|</span><label class="collapse" for="c-40965957">[-]</label><label class="expand" for="c-40965957">[1 more]</label></div><br/><div class="children"><div class="content">they should be done as separate patches</div><br/></div></div></div></div><div id="40960901" class="c"><input type="checkbox" id="c-40960901" checked=""/><div class="controls bullet"><span class="by">notnmeyer</span><span>|</span><a href="#40962076">prev</a><span>|</span><a href="#40960971">next</a><span>|</span><label class="collapse" for="c-40960901">[-]</label><label class="expand" for="c-40960901">[2 more]</label></div><br/><div class="children"><div class="content">i really am a fan of what the pico.sh folks are doing. their ssh, cli-centric tools really speak to me.</div><br/><div id="40961546" class="c"><input type="checkbox" id="c-40961546" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#40960901">parent</a><span>|</span><a href="#40960971">next</a><span>|</span><label class="collapse" for="c-40961546">[-]</label><label class="expand" for="c-40961546">[1 more]</label></div><br/><div class="children"><div class="content">thanks!</div><br/></div></div></div></div><div id="40960971" class="c"><input type="checkbox" id="c-40960971" checked=""/><div class="controls bullet"><span class="by">ericyd</span><span>|</span><a href="#40960901">prev</a><span>|</span><a href="#40963386">next</a><span>|</span><label class="collapse" for="c-40960971">[-]</label><label class="expand" for="c-40960971">[4 more]</label></div><br/><div class="children"><div class="content">&gt; There are tools and plugins that allow users to review PRs inside their IDE, but it requires a herculean effort to make it usable.<p>Definitely not my experience with VSCode and GitHub&#x27;s PR extension, but I don&#x27;t think I&#x27;m the target audience for this product anyway.</div><br/><div id="40961538" class="c"><input type="checkbox" id="c-40961538" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#40960971">parent</a><span>|</span><a href="#40961092">next</a><span>|</span><label class="collapse" for="c-40961538">[-]</label><label class="expand" for="c-40961538">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Definitely not my experience with VSCode and GitHub&#x27;s PR extension<p>What about other editors and IDEs?  It might work great for VSCode, heavily leveraging vertical integration, but everything else is out of scope.<p>`git-pr` removes all of this overhead by being creative with its design.  You don&#x27;t need a VSCode extension, just write the review in code and we help make that manageable.</div><br/><div id="40961642" class="c"><input type="checkbox" id="c-40961642" checked=""/><div class="controls bullet"><span class="by">ericyd</span><span>|</span><a href="#40960971">root</a><span>|</span><a href="#40961538">parent</a><span>|</span><a href="#40961092">next</a><span>|</span><label class="collapse" for="c-40961642">[-]</label><label class="expand" for="c-40961642">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely, I was just responding to the herculean effort part. I realize it&#x27;s a nit, but I think it might be more accurate to say that not all editors are supported, because in some cases it takes barely any effort at all.</div><br/></div></div></div></div><div id="40961092" class="c"><input type="checkbox" id="c-40961092" checked=""/><div class="controls bullet"><span class="by">tristan957</span><span>|</span><a href="#40960971">parent</a><span>|</span><a href="#40961538">prev</a><span>|</span><a href="#40963386">next</a><span>|</span><label class="collapse" for="c-40961092">[-]</label><label class="expand" for="c-40961092">[1 more]</label></div><br/><div class="children"><div class="content">GitHub has done a good job of getting the product into VSCode. I think this product is targeting people who already likely using a terminal editor and work well within a CLI environment, which is what all of Pico&#x27;s services are trying to do already.</div><br/></div></div></div></div><div id="40963386" class="c"><input type="checkbox" id="c-40963386" checked=""/><div class="controls bullet"><span class="by">redleader55</span><span>|</span><a href="#40960971">prev</a><span>|</span><a href="#40961403">next</a><span>|</span><label class="collapse" for="c-40963386">[-]</label><label class="expand" for="c-40963386">[1 more]</label></div><br/><div class="children"><div class="content">How does the data backend for this look like? Does the review live after the PR being merged?<p>One of the required features of a review flow is having a way to look at a patch, understand the reasoning behind it, and the thoughts of people that reviewed and accepted it.</div><br/></div></div><div id="40961403" class="c"><input type="checkbox" id="c-40961403" checked=""/><div class="controls bullet"><span class="by">EPWN3D</span><span>|</span><a href="#40963386">prev</a><span>|</span><a href="#40960942">next</a><span>|</span><label class="collapse" for="c-40961403">[-]</label><label class="expand" for="c-40961403">[4 more]</label></div><br/><div class="children"><div class="content">Nifty, but it seems like this would lose commit message content and history entirely during the course of the review since you have to submit a single patch that gets applied, rather than publishing commits to a branch that gets merged. Am I understanding correctly?</div><br/><div id="40961491" class="c"><input type="checkbox" id="c-40961491" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#40961403">parent</a><span>|</span><a href="#40961437">next</a><span>|</span><label class="collapse" for="c-40961491">[-]</label><label class="expand" for="c-40961491">[1 more]</label></div><br/><div class="children"><div class="content">Not quite.  We have adapted the `git format-patch | git send-email` flow to support editing the patchset.  You can add, remove, even `--force` replace all patches within a patch request.<p>The goal is to provide the flexibility of a pull request with the simplicity of generating patches.<p>At the end of the day, the maintainer of the repo has to load the patchset locally, apply it, fix it up, then push to upstream.  They have full control here.</div><br/></div></div><div id="40961437" class="c"><input type="checkbox" id="c-40961437" checked=""/><div class="controls bullet"><span class="by">beepbooptheory</span><span>|</span><a href="#40961403">parent</a><span>|</span><a href="#40961491">prev</a><span>|</span><a href="#40960942">next</a><span>|</span><label class="collapse" for="c-40961437">[-]</label><label class="expand" for="c-40961437">[2 more]</label></div><br/><div class="children"><div class="content">Github also squashes the commits of a PR before it merges&#x2F;rebases it onto a branch though.</div><br/><div id="40961466" class="c"><input type="checkbox" id="c-40961466" checked=""/><div class="controls bullet"><span class="by">maxicarlos08</span><span>|</span><a href="#40961403">root</a><span>|</span><a href="#40961437">parent</a><span>|</span><a href="#40960942">next</a><span>|</span><label class="collapse" for="c-40961466">[-]</label><label class="expand" for="c-40961466">[1 more]</label></div><br/><div class="children"><div class="content">Not necessarily, there are different ways of merging a PR in github</div><br/></div></div></div></div></div></div><div id="40960942" class="c"><input type="checkbox" id="c-40960942" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#40961403">prev</a><span>|</span><a href="#40962395">next</a><span>|</span><label class="collapse" for="c-40960942">[-]</label><label class="expand" for="c-40960942">[2 more]</label></div><br/><div class="children"><div class="content">This looks kind of small and homely and is obviously designed to appeal to a certain niche, which is nice. But the problem with a lot of &quot;alternative code hosting&quot; tools like this, IMO, is that they aren&#x27;t actually that good for code review. This really dulls their appeal. What&#x27;s the point of setting all this up if I don&#x27;t read the patches?<p>If you are only accepting 1 patch a year, then the reality is anything will work. Email, uploading .patch files to a bug tracker, GitHub, whatever. But if you&#x27;re doing review and managing a dozen active patch sets at once with people who are asynchronous to you, then you need something better than that. Let&#x27;s say 5-10 active contributors. That&#x27;s where projects actually tend to struggle.<p>There&#x27;s this book called &quot;Rethinking UI&quot; and one of the first things it talks about is to write down features for your system, because the user interface <i>comes from</i> features. You can&#x27;t design the UI without laying out a list of features. What features do <i>I</i> need in a code review tool? The two most important ones IMO are:<p>1. Code review is iterative, so a good feature is being able to see the history of a change as it is iterated on.<p>2. It&#x27;s normal to have many patches in flight (your own + others). So, it&#x27;s very useful to be able to quickly find things in a particular state: you need to review it (patch from someone else), you need to update it (patch you wrote and that got reviewed), it needs to be merged.<p>Extra:<p>3. It should be easy to safely integrate a change when it&#x27;s ready.<p>Most tools are very bad at these core ideas:<p>- Almost no actual mainstream review tools, or modern pop-up clones, ever include &quot;git range-diff&quot; in their repertoire of tools. range-diff is essential for many projects to do iterative review, and tools like Linux&#x27;s b4 automate them. I won&#x27;t include it all here, but I wrote about this review style elsewhere: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;thoughtpolice&#x2F;9c45287550a56b2047c6311fbadebed2" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;thoughtpolice&#x2F;9c45287550a56b2047c631...</a><p>- Most tools fall apart at &quot;What state is this in.&quot; For instance, in GitHub it&#x27;s impossible to tell what state anything is in, except &quot;Can be merged&quot; or &quot;Cannot be merged.&quot; For instance, do I need to do another review on this PR after I did one before, and a coworker did one too? I have to go and look to see if everything was addressed properly. Tools like Gerrit have a more granular concept called &quot;The Attention Set&quot; which formalizes the concept of &quot;Do I need to do something?&quot; because it shows you when <i>you</i> need to take an action, like re-review or merge a patch.<p>git-pr doesn&#x27;t really seem to make those core problems any easier.<p>Your approach sort of sidesteps these, these because you&#x27;re expected to apply code manually and view it in your own editor. You could range-diff on your own. Part of the argument here goes back to the argument that best thing to do is sit in your editor -- but with a good review tool, you can do lots of review purely from your tool with no editor involved! I did <i>tons</i> of code review with Gerrit every day without ever opening my editor for 99% of it.<p>A semi-related thing some people say is &quot;Well, in the Linux kernel style you can just send a pull request through any medium&quot;, while GitHub and these other tools use a specific interface. The problem is you still need state to track the state of the work. That&#x27;s required (it&#x27;s one of my features!), notably so you can look at the change evolution and see if it&#x27;s ready to merge. If I tell you &quot;Please merge my branch from <a href="https:&#x2F;&#x2F;example.com&#x2F;foo.git" rel="nofollow">https:&#x2F;&#x2F;example.com&#x2F;foo.git</a> with tag xyz-123&quot; that&#x27;s technically a &quot;pull request&quot; like you would send to Linus, but understanding the actual state that PR is in is impossible without a lot of extra knowledge that a third party tool formalizes (even if poorly.) b4, the Linux kernel patch series tool, has a ton of stuff for things like this like digging up the right email threads to do diffs between, showing the cover letter, etc.<p>And in the &quot;How do Patch Requests work?&quot; section, this sort of shows exactly the problem with this approach. I don&#x27;t want to manually apply patches and run commands to merge it and push manually! I have 10 other patches to read after this one! Integrating things is why my tool is there! Why are steps 13 and 14 even necessary, for instance?<p>Gerrit does all 3 of the above properly and is a very, very powerful and productive tool when you get used to it.<p>Your approach does have a conceptual advantage which is that it focuses on the <i>patch</i> and not the &quot;branch&quot; as the unit of work. This is smart. So, if you keep going down this road and follow it to its logical conclusion, I think you&#x27;ll tread some familiar ground. But I think realistically, you need to track actual state a patch is in, so that you can do things like range-diff it -- that would make the appeal of &quot;Just write comments in the code&quot; or whatever much higher because at least you can see when those comments get handled. You&#x27;ll want to think about concepts like &quot;Change IDs&quot; as Gerrit calls them. Etc.<p>BTW, Gerrit does all if this, it uses this &#x27;Git notes&#x27; approach you briefly mention, and it stores all its content in a Git repo too, no extra database. The web UI has tons of affordances, and everything you do in the web UI is just a commit in the underlying repo. And you can interact with Gerrit entirely over SSH with pubkeys if you want; it looks like running normal commands e.g. `ssh austin@gerrit.foo.com gerrit review ...` -- in theory you could write a whole TUI. I strongly suggest spending some time with it, if you haven&#x27;t.</div><br/><div id="40961591" class="c"><input type="checkbox" id="c-40961591" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#40960942">parent</a><span>|</span><a href="#40962395">next</a><span>|</span><label class="collapse" for="c-40961591">[-]</label><label class="expand" for="c-40961591">[1 more]</label></div><br/><div class="children"><div class="content">Pico creator here.  Thanks so much for your perspective, it&#x27;s actually kind of hard to find users that live outside the pull request workflow.  I think you are absolutely right about scaling issues.  We have been thinking about range-diff and how it could work in our PR format.  I&#x27;m going to read your thorough gist and ponder on what we can learn from it to improve our project.<p>Thanks!</div><br/></div></div></div></div><div id="40962395" class="c"><input type="checkbox" id="c-40962395" checked=""/><div class="controls bullet"><span class="by">germandiago</span><span>|</span><a href="#40960942">prev</a><span>|</span><a href="#40960246">next</a><span>|</span><label class="collapse" for="c-40962395">[-]</label><label class="expand" for="c-40962395">[1 more]</label></div><br/><div class="children"><div class="content">Gerrit allows you to see patchsets as they are applied on the same merge request. What are exactly the differences? It looks to me like similar to what you would do with Gerrit.</div><br/></div></div><div id="40960246" class="c"><input type="checkbox" id="c-40960246" checked=""/><div class="controls bullet"><span class="by">bruh2</span><span>|</span><a href="#40962395">prev</a><span>|</span><a href="#40960943">next</a><span>|</span><label class="collapse" for="c-40960246">[-]</label><label class="expand" for="c-40960246">[2 more]</label></div><br/><div class="children"><div class="content">This is amazing!<p>I found the text a bit too reference-y, as in giving too much theoretical background, while what I&#x27;m actually looking for is workflow breakdown. The demo video at the top of the page[1] demonstrates it beautifully and I recommend you go give it a watch.</div><br/><div id="40960597" class="c"><input type="checkbox" id="c-40960597" checked=""/><div class="controls bullet"><span class="by">rakoo</span><span>|</span><a href="#40960246">parent</a><span>|</span><a href="#40960943">next</a><span>|</span><label class="collapse" for="c-40960597">[-]</label><label class="expand" for="c-40960597">[1 more]</label></div><br/><div class="children"><div class="content">The details of a given patch give some info about the workflow</div><br/></div></div></div></div><div id="40960943" class="c"><input type="checkbox" id="c-40960943" checked=""/><div class="controls bullet"><span class="by">djha-skin</span><span>|</span><a href="#40960246">prev</a><span>|</span><a href="#40961892">next</a><span>|</span><label class="collapse" for="c-40960943">[-]</label><label class="expand" for="c-40960943">[5 more]</label></div><br/><div class="children"><div class="content">I recently switched to neomutt and offlineimap&#x2F;isync as my email client. I tried really hard after that to get a setup going so that I could accept git patches mailing list wise. I had to figure out how to set up a keyboard macro with just the right incantation[1] of b4[2]. I realized accepting patches meant my friends would also have to learn (neo)mutt if I wanted them to accept mine. It was really difficult. I can&#x27;t imagine asking my friends to do that and collaborating with them. (I still like mutt though and still use it as my main client.)<p>By the way, good luck getting that set up to work on Windows, which a large population of developers use because of their work laptops (or because they simply prefer the interface!).<p>I made a script[3] that makes it easy to accept patches using an fzf interface, as a sort of reply to git-send-email[4]. I made sure to get it to work on Windows as well.<p>I kind of think I might like this better. My script only involves some setup of two other third-party tools to accept a patch, but this feels a little cleaner.<p>1: <a href="https:&#x2F;&#x2F;git.sr.ht&#x2F;~skin&#x2F;dotfiles&#x2F;tree&#x2F;main&#x2F;item&#x2F;dot-muttrc#L107" rel="nofollow">https:&#x2F;&#x2F;git.sr.ht&#x2F;~skin&#x2F;dotfiles&#x2F;tree&#x2F;main&#x2F;item&#x2F;dot-muttrc#L...</a><p>2: <a href="https:&#x2F;&#x2F;github.com&#x2F;mricon&#x2F;b4">https:&#x2F;&#x2F;github.com&#x2F;mricon&#x2F;b4</a><p>3: <a href="https:&#x2F;&#x2F;git.sr.ht&#x2F;~skin&#x2F;git-receive-mail&#x2F;" rel="nofollow">https:&#x2F;&#x2F;git.sr.ht&#x2F;~skin&#x2F;git-receive-mail&#x2F;</a><p>4: <a href="https:&#x2F;&#x2F;git-send-email.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;git-send-email.io&#x2F;</a></div><br/><div id="40961121" class="c"><input type="checkbox" id="c-40961121" checked=""/><div class="controls bullet"><span class="by">tristan957</span><span>|</span><a href="#40960943">parent</a><span>|</span><a href="#40961892">next</a><span>|</span><label class="collapse" for="c-40961121">[-]</label><label class="expand" for="c-40961121">[4 more]</label></div><br/><div class="children"><div class="content">Why would a collaborator have to learn your email client?</div><br/><div id="40961302" class="c"><input type="checkbox" id="c-40961302" checked=""/><div class="controls bullet"><span class="by">djha-skin</span><span>|</span><a href="#40960943">root</a><span>|</span><a href="#40961121">parent</a><span>|</span><a href="#40962284">next</a><span>|</span><label class="collapse" for="c-40961302">[-]</label><label class="expand" for="c-40961302">[1 more]</label></div><br/><div class="children"><div class="content">They would need to learn <i>a</i> email client. The patch is in their email inbox and they don&#x27;t have an easy way of applying it to their git Repository. Aerc or Mutt is necessary to accept patches easily usually, but then you have to learn those tools.</div><br/></div></div><div id="40962284" class="c"><input type="checkbox" id="c-40962284" checked=""/><div class="controls bullet"><span class="by">hakre</span><span>|</span><a href="#40960943">root</a><span>|</span><a href="#40961121">parent</a><span>|</span><a href="#40961302">prev</a><span>|</span><a href="#40961589">next</a><span>|</span><label class="collapse" for="c-40962284">[-]</label><label class="expand" for="c-40962284">[1 more]</label></div><br/><div class="children"><div class="content">Messaging is very simple, but made hard so that the benefit is not on your side. Business opportunities, yay!</div><br/></div></div><div id="40961589" class="c"><input type="checkbox" id="c-40961589" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#40960943">root</a><span>|</span><a href="#40961121">parent</a><span>|</span><a href="#40962284">prev</a><span>|</span><a href="#40961892">next</a><span>|</span><label class="collapse" for="c-40961589">[-]</label><label class="expand" for="c-40961589">[1 more]</label></div><br/><div class="children"><div class="content">If you just copy paste into most email clients they somehow screw up the patch.</div><br/></div></div></div></div></div></div><div id="40961892" class="c"><input type="checkbox" id="c-40961892" checked=""/><div class="controls bullet"><span class="by">tekknolagi</span><span>|</span><a href="#40960943">prev</a><span>|</span><a href="#40960834">next</a><span>|</span><label class="collapse" for="c-40961892">[-]</label><label class="expand" for="c-40961892">[2 more]</label></div><br/><div class="children"><div class="content">I think permissions are a bit wonky? I could, as a random person, close some other project&#x27;s PRs. How is the authz supposed to work?</div><br/><div id="40962500" class="c"><input type="checkbox" id="c-40962500" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#40961892">parent</a><span>|</span><a href="#40960834">next</a><span>|</span><label class="collapse" for="c-40962500">[-]</label><label class="expand" for="c-40962500">[1 more]</label></div><br/><div class="children"><div class="content">SSH authentication and authorization.  Everything is done via pubkeys.  We have an ACL system for interacting with PRs and plan to expand it.</div><br/></div></div></div></div><div id="40960834" class="c"><input type="checkbox" id="c-40960834" checked=""/><div class="controls bullet"><span class="by">elric</span><span>|</span><a href="#40961892">prev</a><span>|</span><a href="#40960323">next</a><span>|</span><label class="collapse" for="c-40960834">[-]</label><label class="expand" for="c-40960834">[1 more]</label></div><br/><div class="children"><div class="content">Would be even nicer if the command could be simplified (perhaps using a git alias) so that users don&#x27;t have to go through the hassle of piping through ssh by hand.</div><br/></div></div><div id="40960323" class="c"><input type="checkbox" id="c-40960323" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40960834">prev</a><span>|</span><a href="#40960803">next</a><span>|</span><label class="collapse" for="c-40960323">[-]</label><label class="expand" for="c-40960323">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Github is bringing the IDE to the browser in order to support their workflow, we want to flip that idea on its head by making code reviews a first-class citizen inside your local development environment.<p>What like this? <a href="https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=GitHub.vscode-pull-request-github" rel="nofollow">https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=GitHub.v...</a><p>I&#x27;m all for standardising the pull request process but their suggested workflow sounds way worse than what we have now. Given how dominant Github is I seriously doubt anyone except the nerdiest nerds will use this.<p>IMO if anyone is going to solve this it&#x27;s going to have to happen inside Git, which I can&#x27;t see happening.</div><br/><div id="40960555" class="c"><input type="checkbox" id="c-40960555" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#40960323">parent</a><span>|</span><a href="#40960803">next</a><span>|</span><label class="collapse" for="c-40960555">[-]</label><label class="expand" for="c-40960555">[2 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s a fair observation.  We don&#x27;t expect massive companies to use this tool.  Even within GitHub many companies are feeling its PR review feature-set lacking, especially for massive, long-standing code changes (just look at all the companies productizing code reviews).<p>Our target demographic is the self-hosted hacker enthusiast.  If you want a full-blown pull request workflow in the browser, this will never be that.<p>However, there&#x27;s a large demo of users that want a simple self-hosted solution that doesn&#x27;t require a bunch of infra to manage. If you want to self-host a git collaboration tool you basically need to bootup gitea-scale services or be relegated to `git send-email`. The sweet spot for `git-pr` is right in-between those two tools.<p>All you need is a tiny VM and a golang binary and you have a code review tool that is leveraging utilities you already have installed: git, ssh, and an editor.  End users do not need to create an account, install any clients locally, and all user personas and workflows can be accomplished in the browser.</div><br/><div id="40960673" class="c"><input type="checkbox" id="c-40960673" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40960323">root</a><span>|</span><a href="#40960555">parent</a><span>|</span><a href="#40960803">next</a><span>|</span><label class="collapse" for="c-40960673">[-]</label><label class="expand" for="c-40960673">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you basically need to bootup gitea-scale services<p>Is that actually difficult though? I was always under the impression that Gogs&#x2F;Gitea were pretty easy to run because they&#x27;re also written in Go.<p>I just checked Gogs and it looks like it has exactly the same dependencies as Git-PR (Git and and SSH server).<p>It would definitely be cool if Gogs&#x2F;Gitea&#x2F;Gitlab&#x2F;Sourcehut standardised a PR API, but... like properly.</div><br/></div></div></div></div></div></div><div id="40960803" class="c"><input type="checkbox" id="c-40960803" checked=""/><div class="controls bullet"><span class="by">g-b-r</span><span>|</span><a href="#40960323">prev</a><span>|</span><a href="#40960410">next</a><span>|</span><label class="collapse" for="c-40960803">[-]</label><label class="expand" for="c-40960803">[1 more]</label></div><br/><div class="children"><div class="content">Interesting, unfortunately format-patch does not support merge commits though.</div><br/></div></div><div id="40960410" class="c"><input type="checkbox" id="c-40960410" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#40960803">prev</a><span>|</span><a href="#40960241">next</a><span>|</span><label class="collapse" for="c-40960410">[-]</label><label class="expand" for="c-40960410">[2 more]</label></div><br/><div class="children"><div class="content">Not sure what I get from this that I won&#x27;t from Gitea, and that doesn&#x27;t need any adaptations to interfaces and if I want I get some basic project tracking tools and so on.</div><br/><div id="40960520" class="c"><input type="checkbox" id="c-40960520" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#40960410">parent</a><span>|</span><a href="#40960241">next</a><span>|</span><label class="collapse" for="c-40960520">[-]</label><label class="expand" for="c-40960520">[1 more]</label></div><br/><div class="children"><div class="content">We are thinking about basic issue tracking, still in the &quot;idea&quot; status.</div><br/></div></div></div></div><div id="40960241" class="c"><input type="checkbox" id="c-40960241" checked=""/><div class="controls bullet"><span class="by">michael-ax</span><span>|</span><a href="#40960410">prev</a><span>|</span><a href="#40960744">next</a><span>|</span><label class="collapse" for="c-40960241">[-]</label><label class="expand" for="c-40960241">[1 more]</label></div><br/><div class="children"><div class="content">wow, ty, this is brilliant!</div><br/></div></div><div id="40960744" class="c"><input type="checkbox" id="c-40960744" checked=""/><div class="controls bullet"><span class="by">quectophoton</span><span>|</span><a href="#40960241">prev</a><span>|</span><a href="#40960619">next</a><span>|</span><label class="collapse" for="c-40960744">[-]</label><label class="expand" for="c-40960744">[27 more]</label></div><br/><div class="children"><div class="content">GitHub&#x27;s greatest win has been convincing everyone that &quot;pull request&quot; means having a web interface for code review as well (conflating sharing code with reviewing it) and can only be done by creating accounts in websites; and that patch-based workflows can only be done through email.<p>They even convinced people that repository clones are called &quot;forks&quot; when they have a web interface but not when they&#x27;re local.<p>I like that this project is trying to remove those misconceptions.<p>Of course if the contributor already has their own publicly available repository, then they can send you a pull request through HackerNews if they want.<p><pre><code>    Hey I made some performance improvements, they are at https:&#x2F;&#x2F;example.com&#x2F;git-pr.git on branch `improvements`.
</code></pre>
That was a pull request. You can check out changes with `git pull <a href="https:&#x2F;&#x2F;example.com&#x2F;git-pr.git" rel="nofollow">https:&#x2F;&#x2F;example.com&#x2F;git-pr.git</a> improvements` and review them.<p>I&#x27;ve also done ad-hoc patches through Slack, using `git diff` and `git apply` but the idea is the same.<p>And yes I&#x27;ve also done stuff like this but with just `git push` instead of `git format-patch | ssh` (you want to look at pre-receive hook) messing around with friends on IRC. The problem is not how possible or easy it is, the problem is &quot;just&quot; gaining traction and having a good plan for moderating The Stuff People On Internet Will Upload.<p>See GitTorrent for another (unrelated) example of a good idea that never gained traction.</div><br/><div id="40960910" class="c"><input type="checkbox" id="c-40960910" checked=""/><div class="controls bullet"><span class="by">LudwigNagasena</span><span>|</span><a href="#40960744">parent</a><span>|</span><a href="#40960858">next</a><span>|</span><label class="collapse" for="c-40960910">[-]</label><label class="expand" for="c-40960910">[21 more]</label></div><br/><div class="children"><div class="content">GitHub&#x27;s greatest win has been good UX. They didn’t need to convince people much.</div><br/><div id="40961006" class="c"><input type="checkbox" id="c-40961006" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40960910">parent</a><span>|</span><a href="#40960858">next</a><span>|</span><label class="collapse" for="c-40961006">[-]</label><label class="expand" for="c-40961006">[20 more]</label></div><br/><div class="children"><div class="content">You mean the UX where you have to make an entire fork of a project in order to add one line of code?</div><br/><div id="40961202" class="c"><input type="checkbox" id="c-40961202" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961006">parent</a><span>|</span><a href="#40961048">next</a><span>|</span><label class="collapse" for="c-40961202">[-]</label><label class="expand" for="c-40961202">[3 more]</label></div><br/><div class="children"><div class="content">This entire github fork is still cheaper than a forked process on windows.</div><br/><div id="40961223" class="c"><input type="checkbox" id="c-40961223" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961202">parent</a><span>|</span><a href="#40961048">next</a><span>|</span><label class="collapse" for="c-40961223">[-]</label><label class="expand" for="c-40961223">[2 more]</label></div><br/><div class="children"><div class="content">But then when you find an unmaintained project and want to find out if it has a maintained fork, you have to browse through hundreds of forks that were created just to submit one patch.</div><br/><div id="40961960" class="c"><input type="checkbox" id="c-40961960" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961223">parent</a><span>|</span><a href="#40961048">next</a><span>|</span><label class="collapse" for="c-40961960">[-]</label><label class="expand" for="c-40961960">[1 more]</label></div><br/><div class="children"><div class="content">&gt; hundreds of forks that were created just to submit one patch.<p>Or, <i>worse</i> (IMHO) when they created the fork to house a patch - sometimes a meaningful feature, bugfix, or security fix - and then left it because the submission process was too onerous to bother. Onerous can also include never getting the PR reviewed, too, which is far more damaging (IMHO) because it disincentivizes <i>future</i> contributions, too<p>I actually would love an &quot;implied PR&quot; view of the forks which would enable quickly filtering out the -0,+0 &quot;shallow forks&quot; from the -50,+2000 &quot;oh, that&#x27;s likely doing something interesting&quot; ones, provided it has the sane ?w=0 to hide forks that felt it necessary to push up simple reformatting changes</div><br/></div></div></div></div></div></div><div id="40961048" class="c"><input type="checkbox" id="c-40961048" checked=""/><div class="controls bullet"><span class="by">pindab0ter</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961006">parent</a><span>|</span><a href="#40961202">prev</a><span>|</span><a href="#40961537">next</a><span>|</span><label class="collapse" for="c-40961048">[-]</label><label class="expand" for="c-40961048">[13 more]</label></div><br/><div class="children"><div class="content">What would the alternative be, as you can&#x27;t just edit someone else&#x27;s repo?<p>Besides just cloning it and making the change locally, of course.</div><br/><div id="40961060" class="c"><input type="checkbox" id="c-40961060" checked=""/><div class="controls bullet"><span class="by">aftbit</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961048">parent</a><span>|</span><a href="#40961154">next</a><span>|</span><label class="collapse" for="c-40961060">[-]</label><label class="expand" for="c-40961060">[1 more]</label></div><br/><div class="children"><div class="content">IMO the alternative would be for GitHub to have a lightweight process for creating a PR that doesn&#x27;t require me to copy the project into my namespace.</div><br/></div></div><div id="40961154" class="c"><input type="checkbox" id="c-40961154" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961048">parent</a><span>|</span><a href="#40961060">prev</a><span>|</span><a href="#40961061">next</a><span>|</span><label class="collapse" for="c-40961154">[-]</label><label class="expand" for="c-40961154">[9 more]</label></div><br/><div class="children"><div class="content">&gt; What would the alternative be, as you can&#x27;t just edit someone else&#x27;s repo?<p>git push directly to the repository, in a separate branch namespace. This is how e.g. Gerrit works (pushing to a special ref makes a review, which is essentially the same as a pull request).<p>&gt; Besides just cloning it and making the change locally, of course.<p>With GitHub, you cannot do that and get a PR out in the other end. You _must_ fork the repository into your own user&#x2F;organization, push to that and then send a PR from that.</div><br/><div id="40961205" class="c"><input type="checkbox" id="c-40961205" checked=""/><div class="controls bullet"><span class="by">unshavedyak</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961154">parent</a><span>|</span><a href="#40961926">next</a><span>|</span><label class="collapse" for="c-40961205">[-]</label><label class="expand" for="c-40961205">[2 more]</label></div><br/><div class="children"><div class="content">&gt; git push directly to the repository, in a separate branch namespace. This is how e.g. Gerrit works (pushing to a special ref makes a review, which is essentially the same as a pull request).<p>What&#x27;s the material difference? They build special mechanisms to provide access control for sub namespaces, which sound a lot like &quot;forks&quot;.<p>Also i have no clue on their backend (iirc this info is researchable tho), but i wouldn&#x27;t be surprised if functionally that is <i>exactly</i> how they do it anyway. It&#x27;s all content addressed, i doubt they pay 2x the storage anytime you fork a repo right?</div><br/><div id="40961294" class="c"><input type="checkbox" id="c-40961294" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961205">parent</a><span>|</span><a href="#40961926">next</a><span>|</span><label class="collapse" for="c-40961294">[-]</label><label class="expand" for="c-40961294">[1 more]</label></div><br/><div class="children"><div class="content">The big difference is how it is organized to the users viewing it. My GitHub account is littered with old forks of repositories I created just to submit one line patches; and despite the pull request to a repository in some sense being data relating to the history of that project -- certainly the discussion is all organized under that project -- if the original person actually removes fork to garbage collect their namespace the commits referenced in that pull request just disappear. Meanwhile, despite people now using the word &quot;fork&quot; for this purpose due to GitHub, there is actual value in being able to search for <i>actual forks</i> of a project--things that people are choosing to publicly distribute and maybe maintain themselves--rather than seeing a thousand repositories which exist only for the purpose of contributing a single patch (or, though this is another topic, people making the metaphorical equivalent of a &quot;backup copy&quot; within the strange set of semantics and ownership that is GitHub).</div><br/></div></div></div></div><div id="40961926" class="c"><input type="checkbox" id="c-40961926" checked=""/><div class="controls bullet"><span class="by">quectophoton</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961154">parent</a><span>|</span><a href="#40961205">prev</a><span>|</span><a href="#40961269">next</a><span>|</span><label class="collapse" for="c-40961926">[-]</label><label class="expand" for="c-40961926">[2 more]</label></div><br/><div class="children"><div class="content">&gt; git push directly to the repository, in a separate branch namespace. This is how e.g. Gerrit works (pushing to a special ref makes a review, which is essentially the same as a pull request).<p>And that `git push` doesn&#x27;t need to be literally to the one and only repository. The SSH daemon could create an isolated environment (e.g. QEMU, FreeBSD jail, etc) that contains a copy of the repository, and run the commands in there. Obviously this could also check SSH keys and the requested git commands before doing anything at all.<p>It would probably be like what Sourcehut does[1] for letting you SSH into build VMs, but instead of a build it&#x27;s a push. And they already do some logic during a push[2], so their code for those two places is probably a good place to look for how to implement this kind of thing.<p>[1]: <a href="https:&#x2F;&#x2F;man.sr.ht&#x2F;builds.sr.ht&#x2F;build-ssh.md" rel="nofollow">https:&#x2F;&#x2F;man.sr.ht&#x2F;builds.sr.ht&#x2F;build-ssh.md</a><p>[2]: <a href="https:&#x2F;&#x2F;sourcehut.org&#x2F;blog&#x2F;2019-11-22-what-happens-on-git-push&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sourcehut.org&#x2F;blog&#x2F;2019-11-22-what-happens-on-git-pu...</a></div><br/><div id="40962010" class="c"><input type="checkbox" id="c-40962010" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961926">parent</a><span>|</span><a href="#40961269">next</a><span>|</span><label class="collapse" for="c-40962010">[-]</label><label class="expand" for="c-40962010">[1 more]</label></div><br/><div class="children"><div class="content">&gt;And that `git push` doesn&#x27;t need to be literally to the one and only repository<p>I believe github already has their own implementation of a git server, so any commands submitted to it are abstracted away. They probably don&#x27;t have a literal .git directory sitting on a server.</div><br/></div></div></div></div><div id="40961269" class="c"><input type="checkbox" id="c-40961269" checked=""/><div class="controls bullet"><span class="by">jagged-chisel</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961154">parent</a><span>|</span><a href="#40961926">prev</a><span>|</span><a href="#40961061">next</a><span>|</span><label class="collapse" for="c-40961269">[-]</label><label class="expand" for="c-40961269">[4 more]</label></div><br/><div class="children"><div class="content">&gt; … git push directly to the repository<p>Then we have a security problem or two.</div><br/><div id="40961401" class="c"><input type="checkbox" id="c-40961401" checked=""/><div class="controls bullet"><span class="by">commodoreboxer</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961269">parent</a><span>|</span><a href="#40961061">next</a><span>|</span><label class="collapse" for="c-40961401">[-]</label><label class="expand" for="c-40961401">[3 more]</label></div><br/><div class="children"><div class="content">You cut off the important part:<p>&gt; in a separate branch namespace<p>So not really.  It&#x27;s a special branch path that only exists for opening PRs, and doesn&#x27;t do anything other than opening a PR.  Yes, they share an object space, but so do forks in the first place, so any security issues with this flow are the same ones in the fork-PR flow.<p>You can check out this which covers the whole flow: <a href="https:&#x2F;&#x2F;git-repo.info&#x2F;en&#x2F;2020&#x2F;03&#x2F;agit-flow-and-git-repo&#x2F;" rel="nofollow">https:&#x2F;&#x2F;git-repo.info&#x2F;en&#x2F;2020&#x2F;03&#x2F;agit-flow-and-git-repo&#x2F;</a><p>Or for a simpler overview, look at Gitea&#x2F;Forgejo&#x27;s implementation: <a href="https:&#x2F;&#x2F;forgejo.org&#x2F;docs&#x2F;latest&#x2F;user&#x2F;agit-support&#x2F;" rel="nofollow">https:&#x2F;&#x2F;forgejo.org&#x2F;docs&#x2F;latest&#x2F;user&#x2F;agit-support&#x2F;</a></div><br/><div id="40961582" class="c"><input type="checkbox" id="c-40961582" checked=""/><div class="controls bullet"><span class="by">mlhpdx</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961401">parent</a><span>|</span><a href="#40961061">next</a><span>|</span><label class="collapse" for="c-40961582">[-]</label><label class="expand" for="c-40961582">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s still a security problem.  If you put an unlocked outside door on your house and rely on the interior doors to be locked, we&#x27;d agree that&#x27;s not safe, right? Or to keep it safe would require the kind of uniform attentiveness that people are generally bad at.<p>Folks with accounts &quot;littered with old forks created to make PRs&quot; may not have that kind of attentiveness.</div><br/><div id="40961699" class="c"><input type="checkbox" id="c-40961699" checked=""/><div class="controls bullet"><span class="by">commodoreboxer</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961582">parent</a><span>|</span><a href="#40961061">next</a><span>|</span><label class="collapse" for="c-40961699">[-]</label><label class="expand" for="c-40961699">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand the analogy. What&#x27;s the actual risk exposed by pushing to a magic branch path that opens a PR instead of actually creating a branch, compared to creating a fork and making a PR in that way?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40961061" class="c"><input type="checkbox" id="c-40961061" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961048">parent</a><span>|</span><a href="#40961154">prev</a><span>|</span><a href="#40961537">next</a><span>|</span><label class="collapse" for="c-40961061">[-]</label><label class="expand" for="c-40961061">[2 more]</label></div><br/><div class="children"><div class="content">Sending a patch to the maintainer.</div><br/><div id="40961331" class="c"><input type="checkbox" id="c-40961331" checked=""/><div class="controls bullet"><span class="by">MaxBarraclough</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961061">parent</a><span>|</span><a href="#40961537">next</a><span>|</span><label class="collapse" for="c-40961331">[-]</label><label class="expand" for="c-40961331">[1 more]</label></div><br/><div class="children"><div class="content">Right. Email can be used for this. This is how git was originally meant to be used, and this model is still used by the Linux kernel.<p>See also the SourceHut forge software, which is built around this model.<p>* <a href="https:&#x2F;&#x2F;git-send-email.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;git-send-email.io&#x2F;</a><p>* <a href="https:&#x2F;&#x2F;drewdevault.com&#x2F;2022&#x2F;07&#x2F;25&#x2F;Code-review-with-aerc.html" rel="nofollow">https:&#x2F;&#x2F;drewdevault.com&#x2F;2022&#x2F;07&#x2F;25&#x2F;Code-review-with-aerc.htm...</a></div><br/></div></div></div></div></div></div><div id="40961537" class="c"><input type="checkbox" id="c-40961537" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961006">parent</a><span>|</span><a href="#40961048">prev</a><span>|</span><a href="#40960858">next</a><span>|</span><label class="collapse" for="c-40961537">[-]</label><label class="expand" for="c-40961537">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a shared&#x2F;copy-on-write backend.  An &quot;entire fork&quot; consists of 20-byte commit ID and whatever metadata identifies the owner and organization, and you create the &quot;entire fork&quot; in the UX by clicking on a single button.  I don&#x27;t understand the criticism here, do you just not like the use of the word &quot;fork&quot; because it implies a copy that doesn&#x27;t exist?</div><br/><div id="40966072" class="c"><input type="checkbox" id="c-40966072" checked=""/><div class="controls bullet"><span class="by">carom</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961537">parent</a><span>|</span><a href="#40961865">next</a><span>|</span><label class="collapse" for="c-40966072">[-]</label><label class="expand" for="c-40966072">[1 more]</label></div><br/><div class="children"><div class="content">Not doubting you, but do you have a source where I could read about this? I feel that would create some wild problems if the original repository was deleted.<p>Edit: I guess they would just not delete the data if there were more references to it.</div><br/></div></div><div id="40961865" class="c"><input type="checkbox" id="c-40961865" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961537">parent</a><span>|</span><a href="#40966072">prev</a><span>|</span><a href="#40960858">next</a><span>|</span><label class="collapse" for="c-40961865">[-]</label><label class="expand" for="c-40961865">[1 more]</label></div><br/><div class="children"><div class="content">I don’t like that it appears in the list of forks, making it hard to find actual forks.</div><br/></div></div></div></div></div></div></div></div><div id="40960858" class="c"><input type="checkbox" id="c-40960858" checked=""/><div class="controls bullet"><span class="by">ithinkso</span><span>|</span><a href="#40960744">parent</a><span>|</span><a href="#40960910">prev</a><span>|</span><a href="#40961198">next</a><span>|</span><label class="collapse" for="c-40960858">[-]</label><label class="expand" for="c-40960858">[1 more]</label></div><br/><div class="children"><div class="content">Although I do agree with your overall sentiment<p>&gt; the problem is &quot;just&quot; gaining traction and having a good plan for moderating The Stuff People On Internet Will Upload.
See GitTorrent for another (unrelated) example of a good idea that never gained traction.<p>maybe there is a reason why github gained traction</div><br/></div></div><div id="40961198" class="c"><input type="checkbox" id="c-40961198" checked=""/><div class="controls bullet"><span class="by">tiffanyh</span><span>|</span><a href="#40960744">parent</a><span>|</span><a href="#40960858">prev</a><span>|</span><a href="#40961572">next</a><span>|</span><label class="collapse" for="c-40961198">[-]</label><label class="expand" for="c-40961198">[3 more]</label></div><br/><div class="children"><div class="content">&gt; “convincing everyone that ‘pull request’ means having a web interface”<p>What’s more convenient, making this accessible via the web … or forcing the use of SSH?<p>I don’t disagree with your point, and find pico.sh super interesting - but web is a much lower bar than ssh.</div><br/><div id="40961473" class="c"><input type="checkbox" id="c-40961473" checked=""/><div class="controls bullet"><span class="by">koolala</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961198">parent</a><span>|</span><a href="#40961840">next</a><span>|</span><label class="collapse" for="c-40961473">[-]</label><label class="expand" for="c-40961473">[1 more]</label></div><br/><div class="children"><div class="content">Unless... you use the Web to ssh!</div><br/></div></div><div id="40961840" class="c"><input type="checkbox" id="c-40961840" checked=""/><div class="controls bullet"><span class="by">quectophoton</span><span>|</span><a href="#40960744">root</a><span>|</span><a href="#40961198">parent</a><span>|</span><a href="#40961473">prev</a><span>|</span><a href="#40961572">next</a><span>|</span><label class="collapse" for="c-40961840">[-]</label><label class="expand" for="c-40961840">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that part was mostly because people tend to think in terms of &quot;pull request, therefore web&quot; or &quot;email, therefore messing around with weird configs and stuff&quot;. Tell someone that they can use Discord instead of email and they&#x27;re probably like &quot;you can do that?!&quot;.<p>It&#x27;s the same as when people say &quot;GitHub&quot; when they mean &quot;Git&quot;; or when they ask for your GitHub[1] to read some code. It&#x27;s understood what they&#x27;re trying to say, but thinking that &quot;GitHub&quot; is the same as &quot;Git&quot; causes unnecessary bias in thoughts.<p>Using a different ecosystem as example, you can see this happening with ActivityPub implementations being biased towards Twitter-like usage thanks to Mastodon (where here ActivityPub would be equivalent to Git, and Mastodon equivalent to GitHub).<p>But thankfully there&#x27;s people who know they shouldn&#x27;t be conflated, and are slowly bringing us collaboration between Git repositories through ActivityPub, starting with a web implementation (because as you say it has the lower barrier to entry). This should open more doors to more creative &quot;bridges&quot; that integrate with this ActivityPub flow.<p>A more clear bias you see everywhere is that Git forges tend to just copy GitHub&#x27;s flat URL structure of &quot;username&#x2F;reponame&quot;. It&#x27;s rare to find something that does not have a flat structure like that (e.g. &quot;username&#x2F;hackernews&#x2F;repo-for-that-thread&quot;) (yes I&#x27;m keeping &quot;username&quot; in the URL on purpose but it doesn&#x27;t need to be there). Don&#x27;t get me wrong, I like to organize things relatively flat most of the time, but I really appreciate a nested structure when I mirror thirdparty repositories (e.g. &quot;example.com&#x2F;mirrors&#x2F;github.com&#x2F;username&#x2F;reponame&quot;).<p>So yeah, I like that from time to time we&#x27;re getting projects like this that try to improve git collaboration and start from a point of view different than mimicking GitHub on everything.<p>[1]: I&#x27;ve noticed when people ask for repos to read code they tend to ask for a GitHub link, but it&#x27;s understood that a link to some Codeberg&#x2F;Gitea&#x2F;cgit&#x2F;stagit instance also works.</div><br/></div></div></div></div></div></div><div id="40961293" class="c"><input type="checkbox" id="c-40961293" checked=""/><div class="controls bullet"><span class="by">tpoacher</span><span>|</span><a href="#40960619">prev</a><span>|</span><label class="collapse" for="c-40961293">[-]</label><label class="expand" for="c-40961293">[1 more]</label></div><br/><div class="children"><div class="content">meanwhile the equivalent process in svn is simply &quot;svn copy&quot; followed by &quot;set permissions&quot;.<p>i feel like branch permissions in bare git repos should be a thing already. (rather than, say, having to rely on third-party providers implementing it into their centralised-git web service)</div><br/></div></div></div></div></div></div></div></body></html>