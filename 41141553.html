<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722762051907" as="style"/><link rel="stylesheet" href="styles.css?v=1722762051907"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://twitter.com/VictorTaelin/status/1819208143638831404">Discovering algorithms by enumerating terms in Haskell</a> <span class="domain">(<a href="https://twitter.com">twitter.com</a>)</span></div><div class="subtext"><span>agomez314</span> | <span>37 comments</span></div><br/><div><div id="41148925" class="c"><input type="checkbox" id="c-41148925" checked=""/><div class="controls bullet"><span class="by">bmc7505</span><span>|</span><a href="#41149893">next</a><span>|</span><label class="collapse" for="c-41148925">[-]</label><label class="expand" for="c-41148925">[7 more]</label></div><br/><div class="children"><div class="content">Maciej Bendkowski has some related work [1] on generating random lambda terms, but was unable to overcome what he calls the asymptotic sparsity problem:<p><pre><code>  Sampling simply-typed terms seems notoriously more challenging than sampling closed ones. Even rejection sampling, whenever applicable, admits serious limitations due to the imminent asymptotic sparsity problem — asymptotically almost no term, be it either plain or closed, is at the same time (simply) typeable. [...] Asymptotic sparsity of simply-typed λ-terms is an impenetrable barrier to rejection sampling techniques. As the term size tends to infinity, so does the induced rejection overhead. In order to postpone this inevitable obstacle, it is possible to use dedicated mechanisms interrupting the sampler as soon as it is clear that the partially generated term cannot be extended to a typeable one. The current state-of-the-art samplers take this approach, combining Boltzmann models with modern logic programming execution engines backed by highly-optimised unification algorithms. Nonetheless, even with these sophisticated optimisations, such samplers are not likely to generate terms of sizes larger than one hundred.
</code></pre>
I would be curious to see a more rigorous analysis of the sample complexity of generating well-typed expressions in, e.g., the STLC. Maybe there is a way to avoid or reduce the rejection rate before evaluation.<p>[1]: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2005.08856" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2005.08856</a></div><br/><div id="41149270" class="c"><input type="checkbox" id="c-41149270" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#41148925">parent</a><span>|</span><a href="#41150430">next</a><span>|</span><label class="collapse" for="c-41149270">[-]</label><label class="expand" for="c-41149270">[5 more]</label></div><br/><div class="children"><div class="content">There are quite a few publications that explore the concept of generating programs, either using typed or untyped functional languages.<p>For example, wake-sleep learning and NN on a Lisp-like language [1] or synthesis of Haskell guided by refinement types [2].<p>[1] <a href="https:&#x2F;&#x2F;royalsocietypublishing.org&#x2F;doi&#x2F;full&#x2F;10.1098&#x2F;rsta.2022.0050" rel="nofollow">https:&#x2F;&#x2F;royalsocietypublishing.org&#x2F;doi&#x2F;full&#x2F;10.1098&#x2F;rsta.202...</a>.<p>[2] <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;abs&#x2F;10.1145&#x2F;2980983.2908093" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;abs&#x2F;10.1145&#x2F;2980983.2908093</a></div><br/><div id="41149652" class="c"><input type="checkbox" id="c-41149652" checked=""/><div class="controls bullet"><span class="by">bmc7505</span><span>|</span><a href="#41148925">root</a><span>|</span><a href="#41149270">parent</a><span>|</span><a href="#41150233">next</a><span>|</span><label class="collapse" for="c-41149652">[-]</label><label class="expand" for="c-41149652">[2 more]</label></div><br/><div class="children"><div class="content">The trick is not just synthesizing valid functions, but doing so in a parallel communication-free manner, without compromising soundness or completeness. You want to massively scale up a discrete sampler without replacement. One very efficient way of doing this is by constructing an explicit bijection from the sample space to the integers, sampling integers, then decoding them into programs.<p>While this technique enjoys certain advantages, i.e., it is embarrassingly parallelizable and guaranteed to enumerate distinct solutions with a bounded delay,  it also somewhat unnatural. By flattening the distribution onto the integers a la Gödel numbering, it destroys locality, does not play well with incremental decoding methods (left-to-right is currently en vogue in generative language modeling), and will fail if the sample space is uncountable.<p>Another key step is reducing symmetries in your sample space by quotienting it somehow (e.g., by α-equivalence). The author seems to be invoking some kind of equivalence relation by “superposition”, but the technical details here are a little fuzzy.<p>This problem is also closely related to model counting in the CSP literature, so a practical speedup could lead to improvements on a lot of interesting downstream benchmarks.<p>In general, the problem of program induction from input-output examples is not well-posed, so specialized solvers that can make stronger assumptions will usually have an advantage on domain-specific benchmarks. Most existing program synthesizers do not satisfy all of these desiderata (e.g., soundness, completeness, naturalness, incrementality).</div><br/><div id="41150240" class="c"><input type="checkbox" id="c-41150240" checked=""/><div class="controls bullet"><span class="by">YeGoblynQueenne</span><span>|</span><a href="#41148925">root</a><span>|</span><a href="#41149652">parent</a><span>|</span><a href="#41150233">next</a><span>|</span><label class="collapse" for="c-41150240">[-]</label><label class="expand" for="c-41150240">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; The trick is not just synthesizing valid functions, but doing so in a parallel communication-free manner, without compromising soundness or completeness.<p>Right! A great way to do this is to learn a program by using it to prove the training examples while it is being learned. A very cool ability that some systems of the new wave of Inductive Logic Programming can pull off, but probably nothing else can far as I can tell.</div><br/></div></div></div></div><div id="41150233" class="c"><input type="checkbox" id="c-41150233" checked=""/><div class="controls bullet"><span class="by">YeGoblynQueenne</span><span>|</span><a href="#41148925">root</a><span>|</span><a href="#41149270">parent</a><span>|</span><a href="#41149652">prev</a><span>|</span><a href="#41149460">next</a><span>|</span><label class="collapse" for="c-41150233">[-]</label><label class="expand" for="c-41150233">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; There are quite a few publications that explore the concept of generating programs, either using typed or untyped functional languages.<p>That&#x27;s Inductive Functional Programming (IFP), a kind of Inductive Programming that also includes Inductive Logic Programming (ILP). The canonical example of IFP is Magic Haskeller:<p><a href="https:&#x2F;&#x2F;nautilus.cs.miyazaki-u.ac.jp&#x2F;~skata&#x2F;MagicHaskeller.html" rel="nofollow">https:&#x2F;&#x2F;nautilus.cs.miyazaki-u.ac.jp&#x2F;~skata&#x2F;MagicHaskeller.h...</a><p>As an example of a modern ILP I suggest Popper:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;logic-and-learning-lab&#x2F;Popper&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;logic-and-learning-lab&#x2F;Popper&#x2F;</a><p>Or Louise (mine):<p><a href="https:&#x2F;&#x2F;github.com&#x2F;stassa&#x2F;louise">https:&#x2F;&#x2F;github.com&#x2F;stassa&#x2F;louise</a><p>One of the DreamCoder papers describes Inductive Programming as a form of weakly supervised learning, in the sense that such systems learn to generate programs not from examples of programs, but from examples of the target programs&#x27; <i>beuav908rs</i>, i.e. their inputs and outputs. By contrast LLMs or slightly older neural program synthesis systems are trained on examples that consist of pairs of (programming-task, program-solving-the-task).<p>Another way to see the difference between Inductive Programming systems and conventional machine learning systems used for program synthesis is that Inductive Programming systems learn by solving problems rather than from observing solutions.<p>The advantage is that, in this way, we can learn programs that we don&#x27;t know how to write (because we don&#x27;t have to generate examples of such programs) whereas with conventional machine learning we can only generate programs like the ones the system&#x27;s been trained on before.<p>Another advantage is that it&#x27;s much easier to generate examples. For instance, if I want to learn a program that reverses a list, I give some examples of lists and their reverse, e.g. reverse([a,b,c],[c,b,a]) and reverse([1,2,3],[3,2,1]) whereas e.g. an LLM must be trained on explicit examples of list-reversing programs; like, their source code.<p>IFP and ILP systems are also very sample efficient, so they only need a handful of examples, often just one, whereas neural net-based systems may need millions (no exaggeration- can give a ref if needed).<p>The disadvantage is that learning a program usually (but not always - see Louise, above) implies searching a very large combinatorial space and that can get very expensive, very, very fast. But, there are ways around that.</div><br/></div></div><div id="41149460" class="c"><input type="checkbox" id="c-41149460" checked=""/><div class="controls bullet"><span class="by">tomsmeding</span><span>|</span><a href="#41148925">root</a><span>|</span><a href="#41149270">parent</a><span>|</span><a href="#41150233">prev</a><span>|</span><a href="#41150430">next</a><span>|</span><label class="collapse" for="c-41149460">[-]</label><label class="expand" for="c-41149460">[1 more]</label></div><br/><div class="children"><div class="content">Another relevant publication in this line of research: <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3632919" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3632919</a></div><br/></div></div></div></div><div id="41150430" class="c"><input type="checkbox" id="c-41150430" checked=""/><div class="controls bullet"><span class="by">6gvONxR4sf7o</span><span>|</span><a href="#41148925">parent</a><span>|</span><a href="#41149270">prev</a><span>|</span><a href="#41149893">next</a><span>|</span><label class="collapse" for="c-41150430">[-]</label><label class="expand" for="c-41150430">[1 more]</label></div><br/><div class="children"><div class="content">I did some work on this about a decade ago, using RL on STLC, and that was the same problem I faced. It’s too bad so few well typed expression trees are very useful programs.</div><br/></div></div></div></div><div id="41149893" class="c"><input type="checkbox" id="c-41149893" checked=""/><div class="controls bullet"><span class="by">grnnja</span><span>|</span><a href="#41148925">prev</a><span>|</span><a href="#41147798">next</a><span>|</span><label class="collapse" for="c-41149893">[-]</label><label class="expand" for="c-41149893">[5 more]</label></div><br/><div class="children"><div class="content">What the author is getting at is a pretty cool research area called program synthesis, where the goal is to create a program that satisfies a specification.<p>Most techniques are essentially brute force enumeration with tricks to improve performance, so they tend to struggle to find larger programs. A lot of active research is in improving performance.<p>Compared to asking a LLM to write a program, program synthesis approaches will guarantee that a solution will satisfy the specification which can be very powerful.<p>In particular, as the author has discovered, one area where program synthesis excels is finding small intricate bitwise operator heavy programs that can be hard to reason about as a human.<p>The most famous example of program synthesis is Microsoft&#x27;s FlashFill, which is used in Excel. You give it a few input output examples and FlashFill will try to create a small program to generalize them, and you can apply the program to more inputs, which saves you a bunch of time. An example from the paper is:<p><pre><code>  Input -&gt; Output

  International Business Machines -&gt; IBM
  Principles Of Programming Languages -&gt; POPL
  International Conference on Software Engineering -&gt; ICSE

  String Program: Loop(\w : Concatenate(SubStr2(v_1, UpperTok, w)))

</code></pre>
Here&#x27;s a few papers:<p>EUSOLVER: <a href="https:&#x2F;&#x2F;www.cis.upenn.edu&#x2F;~alur&#x2F;Tacas17.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cis.upenn.edu&#x2F;~alur&#x2F;Tacas17.pdf</a><p>FlashFill: <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;wp-content&#x2F;uploads&#x2F;2016&#x2F;12&#x2F;popl11-synthesis.pdf" rel="nofollow">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;wp-content&#x2F;uploads&#x2F;...</a><p>BlinkFill: <a href="https:&#x2F;&#x2F;www.vldb.org&#x2F;pvldb&#x2F;vol9&#x2F;p816-singh.pdf" rel="nofollow">https:&#x2F;&#x2F;www.vldb.org&#x2F;pvldb&#x2F;vol9&#x2F;p816-singh.pdf</a><p>Synquid: <a href="https:&#x2F;&#x2F;cseweb.ucsd.edu&#x2F;~npolikarpova&#x2F;publications&#x2F;pldi16.pdf" rel="nofollow">https:&#x2F;&#x2F;cseweb.ucsd.edu&#x2F;~npolikarpova&#x2F;publications&#x2F;pldi16.pd...</a></div><br/><div id="41150152" class="c"><input type="checkbox" id="c-41150152" checked=""/><div class="controls bullet"><span class="by">YeGoblynQueenne</span><span>|</span><a href="#41149893">parent</a><span>|</span><a href="#41150197">next</a><span>|</span><label class="collapse" for="c-41150152">[-]</label><label class="expand" for="c-41150152">[1 more]</label></div><br/><div class="children"><div class="content">Note that FlashFill is an example of <i>inductive</i> program synthesis, i.e. program synthesis from an incomplete specification, e.g. one in the form of input-output examples, program traces, or natural language descriptions.<p>Program synthesis from a complete specification is known as <i>deductive</i> program synthesis and the simplest example is compilation of a program in a high-level language to a machine code. A &quot;complete&quot; specification is what it says on the tin: it fully specifies the program to be synthesised.</div><br/></div></div><div id="41150197" class="c"><input type="checkbox" id="c-41150197" checked=""/><div class="controls bullet"><span class="by">amritananda</span><span>|</span><a href="#41149893">parent</a><span>|</span><a href="#41150152">prev</a><span>|</span><a href="#41150765">next</a><span>|</span><label class="collapse" for="c-41150197">[-]</label><label class="expand" for="c-41150197">[1 more]</label></div><br/><div class="children"><div class="content">Program synthesis is also pretty much equivalent to generating proofs of propositions by the Curry-Howard Isomorphism. There was a post from a few days ago about using ML to generate proofs in Lean. I&#x27;m sure there&#x27;s ongoing research to do the same thing with synthesis (which imo is probably going to be more effective at pruning the search space than brute force).</div><br/></div></div><div id="41150765" class="c"><input type="checkbox" id="c-41150765" checked=""/><div class="controls bullet"><span class="by">sashank_1509</span><span>|</span><a href="#41149893">parent</a><span>|</span><a href="#41150197">prev</a><span>|</span><a href="#41147798">next</a><span>|</span><label class="collapse" for="c-41150765">[-]</label><label class="expand" for="c-41150765">[2 more]</label></div><br/><div class="children"><div class="content">Either I have become paranoid or this feels LLM generated</div><br/><div id="41151311" class="c"><input type="checkbox" id="c-41151311" checked=""/><div class="controls bullet"><span class="by">IIAOPSW</span><span>|</span><a href="#41149893">root</a><span>|</span><a href="#41150765">parent</a><span>|</span><a href="#41147798">next</a><span>|</span><label class="collapse" for="c-41151311">[-]</label><label class="expand" for="c-41151311">[1 more]</label></div><br/><div class="children"><div class="content">or both</div><br/></div></div></div></div></div></div><div id="41147798" class="c"><input type="checkbox" id="c-41147798" checked=""/><div class="controls bullet"><span class="by">dleslie</span><span>|</span><a href="#41149893">prev</a><span>|</span><a href="#41147865">next</a><span>|</span><label class="collapse" for="c-41147798">[-]</label><label class="expand" for="c-41147798">[1 more]</label></div><br/><div class="children"><div class="content">Might help to read some of the author&#x27;s earlier work, like:<p><a href="https:&#x2F;&#x2F;medium.com&#x2F;@maiavictor&#x2F;solving-the-mystery-behind-abstract-algorithms-magical-optimizations-144225164b07" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;@maiavictor&#x2F;solving-the-mystery-behind-ab...</a><p>And the Omega documentation:<p><a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;control-monad-omega-0.3&#x2F;docs&#x2F;Control-Monad-Omega.html" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;control-monad-omega-0.3&#x2F;...</a><p>But I&#x27;ll admit, I want to see a paper or code.</div><br/></div></div><div id="41147865" class="c"><input type="checkbox" id="c-41147865" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41147798">prev</a><span>|</span><a href="#41147818">next</a><span>|</span><label class="collapse" for="c-41147865">[-]</label><label class="expand" for="c-41147865">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the original submission has enough details for us to reproduce or even understand what&#x27;s being done. Omega monad is just a diagonal search monad that supports infinity. I don&#x27;t understand the syntax in the screenshot. What&#x27;s the type of the terms being enumerated? I can see lambda, but what&#x27;s @inc or the pluses and minuses?</div><br/></div></div><div id="41147818" class="c"><input type="checkbox" id="c-41147818" checked=""/><div class="controls bullet"><span class="by">mordechai9000</span><span>|</span><a href="#41147865">prev</a><span>|</span><a href="#41150582">next</a><span>|</span><label class="collapse" for="c-41147818">[-]</label><label class="expand" for="c-41147818">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Perhaps I&#x27;m being really naive and an exponential wall is about to humble (and embarrass) me.&quot;<p>There is something fascinating and awe-inspiring about searching very large, enumerative datasets for useful results. Like wandering Borge&#x27;s Library of Babel in search of not just meaning but something true and useful.</div><br/></div></div><div id="41150582" class="c"><input type="checkbox" id="c-41150582" checked=""/><div class="controls bullet"><span class="by">cvoss</span><span>|</span><a href="#41147818">prev</a><span>|</span><a href="#41147706">next</a><span>|</span><label class="collapse" for="c-41150582">[-]</label><label class="expand" for="c-41150582">[1 more]</label></div><br/><div class="children"><div class="content">Did you know that there is an efficient algorithm for learning (guessing) a regular language from a series of examples&#x2F;non-examples? Basically, you directly construct the smallest automaton that correctly discriminates the training inputs. It&#x27;s Dana Angluin&#x27;s L* algorithm.<p>The technique generalizes to finite tree automata, meaning you can discover generators of simple expression grammars, given examples&#x2F;non-examples.<p>So if you can construe your problem as a labeled tree recognition problem, assuming it&#x27;s solvable using a finite tree automaton, then you can discover the algorithm for it efficiently.<p>For example, if you have three strings of bits (2 inputs and 1 output) and line them up as a single string of triplets of bits, it does not surprise me that it is easy to discover the automaton state transition rules that give you the carry bit for each triple and tell you when to reject the triple because the output bit is not correct for the two input bits.<p>The author has arranged the problem this way when sketching the ADC template and has also jump-started the search by assuming the solution space includes exactly one output bit for each pair of input bits. (That may seem like an obvious necessity, but that is a constraint which is not required by the tree automaton formulation, which need not differentiate &quot;inputs&quot; and &quot;outputs&quot;.)</div><br/></div></div><div id="41147706" class="c"><input type="checkbox" id="c-41147706" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#41150582">prev</a><span>|</span><a href="#41148277">next</a><span>|</span><label class="collapse" for="c-41147706">[-]</label><label class="expand" for="c-41147706">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confused, what is the search space? All possible functions from Int -&gt; Int? And how do you verify a result is optimal across inputs?</div><br/><div id="41149584" class="c"><input type="checkbox" id="c-41149584" checked=""/><div class="controls bullet"><span class="by">LightMachine</span><span>|</span><a href="#41147706">parent</a><span>|</span><a href="#41149255">next</a><span>|</span><label class="collapse" for="c-41149584">[-]</label><label class="expand" for="c-41149584">[2 more]</label></div><br/><div class="children"><div class="content">The search space I&#x27;m using is that of all functions of a given dependent type. That allows you to make the search space by using a strong enough type.<p>For example, if you search for `Integer -&gt; Integer -&gt; Integer` function, it will consider Integers of different bit-sizes. But if you instead search for `∀(n: Nat). Int(n) -&gt; Int(n) -&gt; Int(n)`, you will only consider integers of the same bit-size, which is a much smaller space. You can make arbitrary restrictions to shorten your search.</div><br/><div id="41150103" class="c"><input type="checkbox" id="c-41150103" checked=""/><div class="controls bullet"><span class="by">YeGoblynQueenne</span><span>|</span><a href="#41147706">root</a><span>|</span><a href="#41149584">parent</a><span>|</span><a href="#41149255">next</a><span>|</span><label class="collapse" for="c-41150103">[-]</label><label class="expand" for="c-41150103">[1 more]</label></div><br/><div class="children"><div class="content">So you&#x27;re enumerating a search space of functions, with some constraints to keep the search tractable?<p>When you do this kind of thing, there are two worst cases:<p>a) Your constraints are too strong and the search space does not include the target.<p>b) The search space includes the target but it is too large to search in polynomial time.<p>How are you dealing with those?<p>To clarify, the happy case is when your search target is easy to find, i.e. when the search space is small and includes the target. But that happens... rarely (because program search spaces are large).</div><br/></div></div></div></div><div id="41149255" class="c"><input type="checkbox" id="c-41149255" checked=""/><div class="controls bullet"><span class="by">solomatov</span><span>|</span><a href="#41147706">parent</a><span>|</span><a href="#41149584">prev</a><span>|</span><a href="#41148277">next</a><span>|</span><label class="collapse" for="c-41149255">[-]</label><label class="expand" for="c-41149255">[1 more]</label></div><br/><div class="children"><div class="content">My guess is they sample closed lambda terms representing functions.</div><br/></div></div></div></div><div id="41148277" class="c"><input type="checkbox" id="c-41148277" checked=""/><div class="controls bullet"><span class="by">diwank</span><span>|</span><a href="#41147706">prev</a><span>|</span><a href="#41148815">next</a><span>|</span><label class="collapse" for="c-41148277">[-]</label><label class="expand" for="c-41148277">[1 more]</label></div><br/><div class="children"><div class="content">More on the Omega monad from its author:<p><a href="http:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20210616105135&#x2F;http:&#x2F;&#x2F;lukepalmer.wordpress.com&#x2F;2008&#x2F;05&#x2F;02&#x2F;enumerating-a-context-free-language&#x2F;" rel="nofollow">http:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20210616105135&#x2F;http:&#x2F;&#x2F;lukepalmer....</a></div><br/></div></div><div id="41148815" class="c"><input type="checkbox" id="c-41148815" checked=""/><div class="controls bullet"><span class="by">LightMachine</span><span>|</span><a href="#41148277">prev</a><span>|</span><a href="#41148927">next</a><span>|</span><label class="collapse" for="c-41148815">[-]</label><label class="expand" for="c-41148815">[5 more]</label></div><br/><div class="children"><div class="content">Uhm author here. Not sure why this tweet is on Hacker News, as it is just a non-technical &quot;blog post&quot;. But I&#x27;ve posted a follow-up today with some code and details, if you&#x27;re curious:<p><a href="https:&#x2F;&#x2F;x.com&#x2F;VictorTaelin&#x2F;status&#x2F;1819774880130158663" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;VictorTaelin&#x2F;status&#x2F;1819774880130158663</a><p>That&#x27;s as much as I can share for now though</div><br/><div id="41149128" class="c"><input type="checkbox" id="c-41149128" checked=""/><div class="controls bullet"><span class="by">smusamashah</span><span>|</span><a href="#41148815">parent</a><span>|</span><a href="#41150129">next</a><span>|</span><label class="collapse" for="c-41149128">[-]</label><label class="expand" for="c-41149128">[3 more]</label></div><br/><div class="children"><div class="content">Only thing I could read (don&#x27;t understand any of this otherwise) was that you take input pairs and you give python function to generate that output. Does that mean that many math etc problems can be just solved? What kind of python code will it generate to return primes?</div><br/><div id="41149565" class="c"><input type="checkbox" id="c-41149565" checked=""/><div class="controls bullet"><span class="by">LightMachine</span><span>|</span><a href="#41148815">root</a><span>|</span><a href="#41149128">parent</a><span>|</span><a href="#41149392">next</a><span>|</span><label class="collapse" for="c-41149565">[-]</label><label class="expand" for="c-41149565">[1 more]</label></div><br/><div class="children"><div class="content">It will just return the smallest function that passes your tests.<p>It works by enumerating ALL possible functions and running them. Obviously, that naive approach is exponential, so, the entire point is whether we can apply some clever tricks (based on optimal evaluators) to make this search &quot;slightly less intractable&quot;.<p>So, to answer your question directly: if you asked it to design a prime number generator, if it found anything at all, it would probably be a simple, slow trial-and-error algorithm, or something in these lines.</div><br/></div></div><div id="41149392" class="c"><input type="checkbox" id="c-41149392" checked=""/><div class="controls bullet"><span class="by">pyinstallwoes</span><span>|</span><a href="#41148815">root</a><span>|</span><a href="#41149128">parent</a><span>|</span><a href="#41149565">prev</a><span>|</span><a href="#41150129">next</a><span>|</span><label class="collapse" for="c-41149392">[-]</label><label class="expand" for="c-41149392">[1 more]</label></div><br/><div class="children"><div class="content">I imagine it like content addressable computation which implicitly means data too.<p>Why compute anything more than once? Find by identity and reuse.<p>This then opens up interesting things when applied in a network that can optimize pathing (like an internet, DHT-like overlay).</div><br/></div></div></div></div><div id="41150129" class="c"><input type="checkbox" id="c-41150129" checked=""/><div class="controls bullet"><span class="by">YeGoblynQueenne</span><span>|</span><a href="#41148815">parent</a><span>|</span><a href="#41149128">prev</a><span>|</span><a href="#41148927">next</a><span>|</span><label class="collapse" for="c-41150129">[-]</label><label class="expand" for="c-41150129">[1 more]</label></div><br/><div class="children"><div class="content">Hi LightMachine. I can&#x27;t read Haskel (?). In this screenshot:<p><a href="https:&#x2F;&#x2F;x.com&#x2F;VictorTaelin&#x2F;status&#x2F;1819208143638831404&#x2F;photo&#x2F;1" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;VictorTaelin&#x2F;status&#x2F;1819208143638831404&#x2F;photo&#x2F;...</a><p>What&#x27;s the highlighted program (?) on line 1875997?</div><br/></div></div></div></div><div id="41148927" class="c"><input type="checkbox" id="c-41148927" checked=""/><div class="controls bullet"><span class="by">sporkl</span><span>|</span><a href="#41148815">prev</a><span>|</span><a href="#41149001">next</a><span>|</span><label class="collapse" for="c-41148927">[-]</label><label class="expand" for="c-41148927">[2 more]</label></div><br/><div class="children"><div class="content">This kind of reminds me of what happens when you implement an interpreter in a relational programming language, which lets you do cool stuff like generating quines by specifying that the program and it’s output should be the same.<p>Quick search lead to this paper which is exactly what I’m talking about: <a href="http:&#x2F;&#x2F;webyrd.net&#x2F;quines&#x2F;quines.pdf" rel="nofollow">http:&#x2F;&#x2F;webyrd.net&#x2F;quines&#x2F;quines.pdf</a></div><br/><div id="41150114" class="c"><input type="checkbox" id="c-41150114" checked=""/><div class="controls bullet"><span class="by">YeGoblynQueenne</span><span>|</span><a href="#41148927">parent</a><span>|</span><a href="#41149001">next</a><span>|</span><label class="collapse" for="c-41150114">[-]</label><label class="expand" for="c-41150114">[1 more]</label></div><br/><div class="children"><div class="content">William Byrd is the creator of miniKanren btw. And an HN user.</div><br/></div></div></div></div><div id="41149001" class="c"><input type="checkbox" id="c-41149001" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#41148927">prev</a><span>|</span><a href="#41147710">next</a><span>|</span><label class="collapse" for="c-41149001">[-]</label><label class="expand" for="c-41149001">[1 more]</label></div><br/><div class="children"><div class="content">Super interesting. Sounds like the algo I created Prioritized Grammar Enumeration.<p><a href="https:&#x2F;&#x2F;seminars.math.binghamton.edu&#x2F;ComboSem&#x2F;worm-chiu.pge_gecco2013.pdf" rel="nofollow">https:&#x2F;&#x2F;seminars.math.binghamton.edu&#x2F;ComboSem&#x2F;worm-chiu.pge_...</a><p>PGE is essentially a BFS&#x2F;DFS traversal of the space of all formulas, by using local enumeration of the AST. The biggest gains where from eliminating duplicate work (commutativity &#x2F; associativity) and not going down bad branches (too much complexity added for no meaningful change to output). A lot of overlap in ideas here, and a lot of open research questions that could be worked on (like can use use RL to help guide the search like A*). There&#x27;s definitely an exponential explosion or wall as the AST gets wider &#x2F; deeper.<p>At one point I wrote the core algorithm in Haskell, which made it so much more concise and beautiful, but eventually landed on python <a href="https:&#x2F;&#x2F;github.com&#x2F;verdverm&#x2F;pypge">https:&#x2F;&#x2F;github.com&#x2F;verdverm&#x2F;pypge</a><p>In all of Genetic Programming &#x2F; Symbolic Regression, everyone starts by trying to generate computer code and then switches to just math formula. They are different classes of problems because code has more &quot;genes&quot; and is order sensitive, whereas math is not</div><br/></div></div><div id="41147710" class="c"><input type="checkbox" id="c-41147710" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#41149001">prev</a><span>|</span><a href="#41147912">next</a><span>|</span><label class="collapse" for="c-41147710">[-]</label><label class="expand" for="c-41147710">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confused about what this could be, with a title as technical as this but being posted somewhere with the signal:noise of Twitter, also where I can&#x27;t view it.</div><br/><div id="41148479" class="c"><input type="checkbox" id="c-41148479" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#41147710">parent</a><span>|</span><a href="#41147912">next</a><span>|</span><label class="collapse" for="c-41148479">[-]</label><label class="expand" for="c-41148479">[3 more]</label></div><br/><div class="children"><div class="content">For non-twitter, I was looking the other day at <a href="https:&#x2F;&#x2F;reasonablypolymorphic.com&#x2F;blog&#x2F;syntax-guided-synthesis&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;reasonablypolymorphic.com&#x2F;blog&#x2F;syntax-guided-synthes...</a> , which unfortunately points at a dead page related to <a href="https:&#x2F;&#x2F;sygus.org&#x2F;comp&#x2F;2019&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sygus.org&#x2F;comp&#x2F;2019&#x2F;</a> , but seems related?</div><br/><div id="41148655" class="c"><input type="checkbox" id="c-41148655" checked=""/><div class="controls bullet"><span class="by">pbib</span><span>|</span><a href="#41147710">root</a><span>|</span><a href="#41148479">parent</a><span>|</span><a href="#41147912">next</a><span>|</span><label class="collapse" for="c-41148655">[-]</label><label class="expand" for="c-41148655">[2 more]</label></div><br/><div class="children"><div class="content">I believe the dead link in the article is referencing this journal paper[1], which is an expanded version of the original syntax guided synthesis paper.<p>[1] <a href="https:&#x2F;&#x2F;web.eecs.umich.edu&#x2F;~weimerw&#x2F;2022-481W&#x2F;readings&#x2F;Alur13.pdf" rel="nofollow">https:&#x2F;&#x2F;web.eecs.umich.edu&#x2F;~weimerw&#x2F;2022-481W&#x2F;readings&#x2F;Alur1...</a></div><br/><div id="41148719" class="c"><input type="checkbox" id="c-41148719" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#41147710">root</a><span>|</span><a href="#41148655">parent</a><span>|</span><a href="#41147912">next</a><span>|</span><label class="collapse" for="c-41148719">[-]</label><label class="expand" for="c-41148719">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! Looks like barliman is also (like its namesake?) slowly progressing: <a href="https:&#x2F;&#x2F;github.com&#x2F;webyrd&#x2F;Barliman">https:&#x2F;&#x2F;github.com&#x2F;webyrd&#x2F;Barliman</a></div><br/></div></div></div></div></div></div></div></div><div id="41147912" class="c"><input type="checkbox" id="c-41147912" checked=""/><div class="controls bullet"><span class="by">garyrob</span><span>|</span><a href="#41147710">prev</a><span>|</span><a href="#41149853">next</a><span>|</span><label class="collapse" for="c-41147912">[-]</label><label class="expand" for="c-41147912">[1 more]</label></div><br/><div class="children"><div class="content">Maybe this could be used with the Evolutionary Algorithm subset known as Genetic Programming, originally popularized by John Koza in the 80s?</div><br/></div></div><div id="41149853" class="c"><input type="checkbox" id="c-41149853" checked=""/><div class="controls bullet"><span class="by">jmull</span><span>|</span><a href="#41147912">prev</a><span>|</span><a href="#41150118">next</a><span>|</span><label class="collapse" for="c-41149853">[-]</label><label class="expand" for="c-41149853">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s kind of vague, but... it sounds like this is essentially a breadth first search (where the graph being searched is represented by a grammar)?<p>Hard to tell.</div><br/></div></div><div id="41150118" class="c"><input type="checkbox" id="c-41150118" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#41149853">prev</a><span>|</span><label class="collapse" for="c-41150118">[-]</label><label class="expand" for="c-41150118">[1 more]</label></div><br/><div class="children"><div class="content">My intuition tells me you will quickly run out of memory on anything that isn&#x27;t just a small function. Your state space will just be so big that your super positions will become too large.</div><br/></div></div></div></div></div></div></div></body></html>