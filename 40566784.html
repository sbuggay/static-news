<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717578075940" as="style"/><link rel="stylesheet" href="styles.css?v=1717578075940"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://safinaskar.writeas.com/">Use context-free grammars instead of parser combinators and PEG</a>Â <span class="domain">(<a href="https://safinaskar.writeas.com">safinaskar.writeas.com</a>)</span></div><div class="subtext"><span>mmastrac</span> | <span>35 comments</span></div><br/><div><div id="40572510" class="c"><input type="checkbox" id="c-40572510" checked=""/><div class="controls bullet"><span class="by">HelloNurse</span><span>|</span><a href="#40581714">next</a><span>|</span><label class="collapse" for="c-40572510">[-]</label><label class="expand" for="c-40572510">[5 more]</label></div><br/><div class="children"><div class="content">Parsing is an application domain where I&#x27;d expect more hard logic and less soft feelings than in this article.<p>&quot;I feel that CFGs more naturally represent how we think&quot; but<p>&quot;All this doesn&#x27;t apply to situations where you trying to parse some language, whose specification explicitly says that the language is based on PEG formalism&quot;<p>A terrible context free grammar (with left and right recursion, not a small feat) is presented.<p>&quot;I blindly converted grammar above to Haskell code&quot;<p>&quot;I accidentally discovered my grammar was ambiguous!&quot;<p>&quot;All this gave me psychological trauma (figuratively speaking). I will never use Parsec (and PEG parsers) anymore.&quot;<p>Denial that an ambiguous grammar is a defect, denial that the ambiguity has to be resolved, refusal to use parser combinators to resolve the ambiguity in the correct way.<p>It&#x27;s also strange to see someone react to a modest, non-shameful failure (guess what, parsing is difficult is language design is even more difficult) that should be a nice learning opportunity (elegant context free grammars are usually insufficient in practical usage) with anger and radicalization far beyond an acceptable level of blaming the tools.<p>The other post in the blog, however, follows a similar general pattern: never use a popular technique (de Bruijn indices rather than parser combinators), because they advocate another technique (expressing lambda calculus terms with randomly generated globally unique identifiers for all bound variables rather than pure context free grammars) because that&#x27;s what they like.</div><br/><div id="40581152" class="c"><input type="checkbox" id="c-40581152" checked=""/><div class="controls bullet"><span class="by">eslaught</span><span>|</span><a href="#40572510">parent</a><span>|</span><a href="#40581799">next</a><span>|</span><label class="collapse" for="c-40581152">[-]</label><label class="expand" for="c-40581152">[2 more]</label></div><br/><div class="children"><div class="content">So, I agree with your take as a reaction to this article specifically.<p>However, I <i>also</i> think that there is a legitimate point here. Which is that parser combinators, even in languages like Haskell, are shockingly tricky to use correctly. In particular, they violate the usual Haskell principle that &quot;if it compiles, then it will probably run correctly&quot;. Having written multiple parsers in multiple languages with multiple parsing frameworks (including direct recursive descent), using Parsec in Haskell was the <i>only</i> time I had to write a test suite for the parser specifically. And that&#x27;s because there were so many footguns that I was repeatedly making mistakes despite the fact that this was a port of a parser I&#x27;d already written (and therefore, ought to know backward and forward). (For the record, this was not my first Haskell project either, which is why I was so shocked it went so poorly.)<p>I&#x27;m sure it&#x27;s possible to make mistakes in CFGs too, but practically speaking I can&#x27;t remember running into that situation myself. Whereas with Parsec I ran into it repeatedly.</div><br/><div id="40582191" class="c"><input type="checkbox" id="c-40582191" checked=""/><div class="controls bullet"><span class="by">HelloNurse</span><span>|</span><a href="#40572510">root</a><span>|</span><a href="#40581152">parent</a><span>|</span><a href="#40581799">next</a><span>|</span><label class="collapse" for="c-40582191">[-]</label><label class="expand" for="c-40582191">[1 more]</label></div><br/><div class="children"><div class="content">PEG parsing is likely to squash some grammar ambiguities in unexpected ways, making a test suite a very good idea; but we shouldn&#x27;t forget that this kind of failure can only happen starting from an ambiguous grammar specification, so the work of taming PEG precedence or combinator behaviour is not an additional burden of the technology but an additional tool to correct the grammar to become less ambiguous, an alternative to rewriting it in unnatural, verbose and complex ways.</div><br/></div></div></div></div><div id="40581799" class="c"><input type="checkbox" id="c-40581799" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#40572510">parent</a><span>|</span><a href="#40581152">prev</a><span>|</span><a href="#40581102">next</a><span>|</span><label class="collapse" for="c-40581799">[-]</label><label class="expand" for="c-40581799">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Parsing is an application domain where I&#x27;d expect more hard logic and less soft feelings than in this article.<p>Ah, an S-expr enjoyer I see</div><br/></div></div><div id="40581102" class="c"><input type="checkbox" id="c-40581102" checked=""/><div class="controls bullet"><span class="by">just_mc</span><span>|</span><a href="#40572510">parent</a><span>|</span><a href="#40581799">prev</a><span>|</span><a href="#40581714">next</a><span>|</span><label class="collapse" for="c-40581102">[-]</label><label class="expand" for="c-40581102">[1 more]</label></div><br/><div class="children"><div class="content">Well said.</div><br/></div></div></div></div><div id="40581714" class="c"><input type="checkbox" id="c-40581714" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#40572510">prev</a><span>|</span><a href="#40582636">next</a><span>|</span><label class="collapse" for="c-40581714">[-]</label><label class="expand" for="c-40581714">[7 more]</label></div><br/><div class="children"><div class="content">&gt; And if you agree with me that grammar above in intuitive sense is ambiguous, i. e. if you agree that A :: B ==&gt; C allows two parse trees, then your brain thinks in terms of CFG, too! CFGs are simply more natural.<p>Count me as my brain being on team PEG then, so also a data point against CFGs being more natural.  In fact, I think this example proves that author of TFA does not think in CFG, otherwise they wouldn&#x27;t have accidentally written an ambiguous grammar!<p>In my experience, it&#x27;s an extraordinarily tiny fraction of people who actually <i>want</i> parse forests instead of parse trees in the languages they are constructing (TFA specifically excludes pre-existing languages).  A PEG will be unambiguous.  People want unambiguous.  There&#x27;s a chance it disambiguates against the intent of the author, but a CFG won&#x27;t disambiguate at all, which will <i>nearly always</i> be against the intent of the author.</div><br/><div id="40582287" class="c"><input type="checkbox" id="c-40582287" checked=""/><div class="controls bullet"><span class="by">thequux</span><span>|</span><a href="#40581714">parent</a><span>|</span><a href="#40582236">next</a><span>|</span><label class="collapse" for="c-40582287">[-]</label><label class="expand" for="c-40582287">[1 more]</label></div><br/><div class="children"><div class="content">The question here is whether it is better to silently guess at the author&#x27;s intent or to loudly say &quot;your intent isn&#x27;t clear; try again&quot;.<p>I strongly believe that the second is the better approach for nearly all use cases. When I&#x27;m writing a grammar, I&#x27;m focused on the happy case and not on how the rules interact with each other. My intent was to write a grammar with only a single result, indeed, but if that&#x27;s not what I&#x27;ve done, I&#x27;d want to know!</div><br/></div></div><div id="40582236" class="c"><input type="checkbox" id="c-40582236" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#40581714">parent</a><span>|</span><a href="#40582287">prev</a><span>|</span><a href="#40582636">next</a><span>|</span><label class="collapse" for="c-40582236">[-]</label><label class="expand" for="c-40582236">[5 more]</label></div><br/><div class="children"><div class="content">Great! Someone who&#x27;s brain is on team PEG. You are just the person I need. Can you explain in plain English what strings match the following PEG grammar?<p><pre><code>    Str = &quot;a&quot; Str &quot;a&quot; &#x2F; &quot;a&quot;</code></pre></div><br/><div id="40582353" class="c"><input type="checkbox" id="c-40582353" checked=""/><div class="controls bullet"><span class="by">HelloNurse</span><span>|</span><a href="#40581714">root</a><span>|</span><a href="#40582236">parent</a><span>|</span><a href="#40582636">next</a><span>|</span><label class="collapse" for="c-40582353">[-]</label><label class="expand" for="c-40582353">[4 more]</label></div><br/><div class="children"><div class="content">Any odd number 2n+1 of &quot;a&quot; repetitions, longest match. The inflating first rule is preferred about 2n times until it fails at input end, then the parser backtracks until the middle &quot;a&quot; is matched by the second rule and the others by n expansions of the first rule.</div><br/><div id="40582511" class="c"><input type="checkbox" id="c-40582511" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#40581714">root</a><span>|</span><a href="#40582353">parent</a><span>|</span><a href="#40582636">next</a><span>|</span><label class="collapse" for="c-40582511">[-]</label><label class="expand" for="c-40582511">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sorry that is not correct at all. It does not match the string &quot;aaaaa&quot; for example.</div><br/><div id="40582633" class="c"><input type="checkbox" id="c-40582633" checked=""/><div class="controls bullet"><span class="by">HelloNurse</span><span>|</span><a href="#40581714">root</a><span>|</span><a href="#40582511">parent</a><span>|</span><a href="#40582636">next</a><span>|</span><label class="collapse" for="c-40582633">[-]</label><label class="expand" for="c-40582633">[2 more]</label></div><br/><div class="children"><div class="content">Why not? Preferring the first rule, after seeing a you expect Str a; after seeing another a you expect Str a a; after seeing the third a you expect Str a a a (and you can already realize it cannot match) so after some backtracking you match the third a with the second rule instead, expecting a a, which are the fourth and fifth a in the input.<p>Do you have a different parsing algorithm in mind?</div><br/><div id="40582683" class="c"><input type="checkbox" id="c-40582683" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#40581714">root</a><span>|</span><a href="#40582633">parent</a><span>|</span><a href="#40582636">next</a><span>|</span><label class="collapse" for="c-40582683">[-]</label><label class="expand" for="c-40582683">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Do you have a different parsing algorithm in mind?<p>Yes, since I specified a PEG grammar I assumed a PEG parsing algorithm.<p>You can try the grammar yourself in a PEG parser, e.g. <a href="https:&#x2F;&#x2F;shamansir.github.io&#x2F;pegjs-fn&#x2F;" rel="nofollow">https:&#x2F;&#x2F;shamansir.github.io&#x2F;pegjs-fn&#x2F;</a>.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40582636" class="c"><input type="checkbox" id="c-40582636" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40581714">prev</a><span>|</span><a href="#40581604">next</a><span>|</span><label class="collapse" for="c-40582636">[-]</label><label class="expand" for="c-40582636">[2 more]</label></div><br/><div class="children"><div class="content">&gt; when I wrote that grammar, I meant it is CFG. Simply because my brain thinks in terms of CFG.<p>&gt; I blindly converted grammar above to Haskell code.<p>&gt; But then I accidentally discovered my grammar was ambiguous!<p>You wrote an ambiguous CFG, implemented its parser, and then discovered that it was ambiguous.<p>Would the CFG have become non-ambiguous if you took your advice and avoided parser combinators?<p>This makes me <i>really</i> want to avoid the CFG step altogether.</div><br/><div id="40582760" class="c"><input type="checkbox" id="c-40582760" checked=""/><div class="controls bullet"><span class="by">sparkie</span><span>|</span><a href="#40582636">parent</a><span>|</span><a href="#40581604">next</a><span>|</span><label class="collapse" for="c-40582760">[-]</label><label class="expand" for="c-40582760">[1 more]</label></div><br/><div class="children"><div class="content">The advice to &quot;use CFGs&quot; is incomplete. What you really want is to use one of the deterministic subsets of CFGs, like LR(<i>k</i>), and importantly, with a parser-generator which will reject any non-LR productions in the grammar before even generating the parser. This way, you can get a guarantee that there are no ambiguities in the language you&#x27;ve defined <i>ahead-of-time</i>.<p>You might consider this to be analogous to the difference between static and dynamic typing. A statically typed program will reject an erroneously typed program before attempting to run it, but the dynamically typed language may accept it and attempt to run it, only to fail at runtime if there&#x27;s a type mismatch.<p>Parser combinators are more like the dynamic language. You find out <i>at runtime</i> (when parsing), whether the text you have parsed has ambiguities because more than one parse result is returned if that is the case. Normal operation is that the combinator returns a single result, in which case there are no ambiguities in the input, but the parser combinator doesn&#x27;t provide any guarantees about absence of ambiguity <i>in the language it defines</i> - it only proves that there&#x27;s no ambiguity <i>for the given input</i>. And there&#x27;s no practical way of testing <i>for all inputs</i> that the defined language is unambiguous, because there are infinite possible inputs.<p>LL&#x2F;LR are like a type system for grammar. They&#x27;ll take your input grammar, and check that all rules adhere to the constraints of LL&#x2F;LR, and <i>iff</i> that&#x27;s the case, then they&#x27;ll produce a valid, provably unambiguous parser.<p>PEG are also provably unambiguous, but for a given input, the &quot;correct parse&quot; is not necessarily the &quot;desired parse&quot;. Essentially, when you&#x27;re using a PEG, the language <i>is defined by its grammar</i>. Whereas when we use CFGs, we&#x27;re attempting to use the constraints to formalize a grammar for our language, which we define ourselves.</div><br/></div></div></div></div><div id="40581604" class="c"><input type="checkbox" id="c-40581604" checked=""/><div class="controls bullet"><span class="by">vidarh</span><span>|</span><a href="#40582636">prev</a><span>|</span><a href="#40581730">next</a><span>|</span><label class="collapse" for="c-40581604">[-]</label><label class="expand" for="c-40581604">[5 more]</label></div><br/><div class="children"><div class="content">His problem isn&#x27;t primarily the choice of formalism, but that his grammar is wildly overcomplicated and makes it really hard to see what language it specifies irrespective of formalism.<p>This is a common problem.<p>In this case the amount of recursion makes it hard to even guess at what it is trying to express.<p>If my grammar looked like that, I&#x27;d throw it away and start over, because the problem to me appears to be not quite having a clear idea of what the grammar is expressing.<p>EDIT:  Trying to clean up his grammar into something readable<p><pre><code>    t0 = t1 | a
    t1 = t3 (&quot;==&gt;&quot; t1)?
    t3 = (id | d)+ c? | b

    a  = &quot;!!&quot;  id c &quot;.&quot; t0
    b  = &quot;%&quot; id c &quot;.&quot; t3
    c  = &quot;::&quot; t0
    d = &quot;(&quot; t0 &quot;)&quot;
</code></pre>
t999 in the original was left-recursive, but in this case that&#x27;s a matter that can be left to the parse tree construction if he insists on keeping it that way. For your own sanity don&#x27;t mix left and right-recursion in a parser, and decide how you structure the parse-tree in terms of left&#x2F;right binding separately, and only express that in the grammar if your tool doesn&#x27;t let you express it when building the tree, or if it <i>actually</i> changes the language <i>recognised</i>.<p>One thing to note, is that my first instinct when writing parsers is to look for opportunities to factor out rules that start with a terminal, because it&#x27;s usually a good way of avoiding or reducing the need for lookahead. Hence the extra rules, that to me at least makes it a lot clearer. The part of the grammar to look for places where your formalism causes ambiguities is now much smaller.<p>This grammar still gives me hives, but without knowing his constraints and intent, it&#x27;s tricky to see if it can be cleaned up further.</div><br/><div id="40581816" class="c"><input type="checkbox" id="c-40581816" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40581604">parent</a><span>|</span><a href="#40581730">next</a><span>|</span><label class="collapse" for="c-40581816">[-]</label><label class="expand" for="c-40581816">[4 more]</label></div><br/><div class="children"><div class="content">&gt; If my grammar looked like that, I&#x27;d throw it away and start over, because the problem to me appears to be not quite having a clear idea of what the grammar is expressing.<p>That&#x27;s fine if you are working in a purely academic domain, or you&#x27;re just having fun writing something on your free time.<p>In production settings, you need to keep extending whatever language you have. The alternative is having to start to maintain two separate parsers and a migration tool, and be stuck with that for years.<p>The point is that being able to throw away code is a luxury that virtually no one is able to afford.</div><br/><div id="40582556" class="c"><input type="checkbox" id="c-40582556" checked=""/><div class="controls bullet"><span class="by">HelloNurse</span><span>|</span><a href="#40581604">root</a><span>|</span><a href="#40581816">parent</a><span>|</span><a href="#40582127">next</a><span>|</span><label class="collapse" for="c-40582556">[-]</label><label class="expand" for="c-40582556">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In production settings, you need to keep extending whatever language you have.<p>Then the hard work of leaving behind simplistic, ambiguous, imprecise, inefficient grammar specifications has already been done (mostly) and you are ready to add small new features without serious rewrites.</div><br/></div></div><div id="40582127" class="c"><input type="checkbox" id="c-40582127" checked=""/><div class="controls bullet"><span class="by">vidarh</span><span>|</span><a href="#40581604">root</a><span>|</span><a href="#40581816">parent</a><span>|</span><a href="#40582556">prev</a><span>|</span><a href="#40581942">next</a><span>|</span><label class="collapse" for="c-40582127">[-]</label><label class="expand" for="c-40582127">[1 more]</label></div><br/><div class="children"><div class="content">No, I&#x27;m not talking about an academic setting.<p>This is not about the <i>language</i> but about his expression of it in this specific instance of the grammar.<p>As the article makes clear, he didn&#x27;t understand the language, and my claim is that is to a large extent down to how it is expressed.<p><i>Not</i> throwing away this specific grammar instance is something you can&#x27;t afford.</div><br/></div></div><div id="40581942" class="c"><input type="checkbox" id="c-40581942" checked=""/><div class="controls bullet"><span class="by">bruce343434</span><span>|</span><a href="#40581604">root</a><span>|</span><a href="#40581816">parent</a><span>|</span><a href="#40582127">prev</a><span>|</span><a href="#40581730">next</a><span>|</span><label class="collapse" for="c-40581942">[-]</label><label class="expand" for="c-40581942">[1 more]</label></div><br/><div class="children"><div class="content">What do you mean? Stuff gets refactored all the time.</div><br/></div></div></div></div></div></div><div id="40581730" class="c"><input type="checkbox" id="c-40581730" checked=""/><div class="controls bullet"><span class="by">Eliah_Lakhin</span><span>|</span><a href="#40581604">prev</a><span>|</span><a href="#40581162">next</a><span>|</span><label class="collapse" for="c-40581730">[-]</label><label class="expand" for="c-40581730">[5 more]</label></div><br/><div class="children"><div class="content">I think it all depends on the language, but I found it (usually) easier to implement the recursive-descending parsers just manually. This may include combination approach too, but using my own combinatorial and domain-specific functions.<p>In a nutshell such a parser is PEG in a sense that the choice is ordered, but with little to no test expressions. In other words, I try to stick to lookahead-1 most of the time. Left recursion quite often could be resolved by lifting the branches to their siblings rather than re-parsing the same things many times using the cache (packrat). In fact both approaches, the packrat and the nodes lifting, are the same in a nutshell, but nodes lifting is usually easier to maintain (again, it all depends).<p>Writing the parser manually, or in other words a set of relatively simple mutually recursive functions, in my opinion, is not the hardest problem in practical engineering. At least it&#x27;s not so hard when you have a mental model of the language&#x27;s syntax upfront.<p>If the language fits specific class of formal grammars very well, perhaps it would be not so hard to implement it using the parsers generator tool. But it is likely there will be edge cases that are hard to express properly using the formal grammar, and fighting with the tool specifics will waste a lot of your time rather than benefit you.</div><br/><div id="40581804" class="c"><input type="checkbox" id="c-40581804" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40581730">parent</a><span>|</span><a href="#40581787">next</a><span>|</span><label class="collapse" for="c-40581804">[-]</label><label class="expand" for="c-40581804">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think it all depends on the language, but I found it (usually) easier to implement the recursive-descending parsers just manually.<p>I think that packrat parsers are even easier to implement by hand, and even troubleshoot.<p>It&#x27;s all procedural code, and you just call the next routine to figure out if you have a token match or not.<p>More importantly, PEGs promise to be easier to maintain in smaller custom parsers. To support an enum, all you need to do is add a function call, and that&#x27;s it. One line of code. Can&#x27;t beat that.</div><br/></div></div><div id="40581787" class="c"><input type="checkbox" id="c-40581787" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40581730">parent</a><span>|</span><a href="#40581804">prev</a><span>|</span><a href="#40581162">next</a><span>|</span><label class="collapse" for="c-40581787">[-]</label><label class="expand" for="c-40581787">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I think it all depends on the language, but I found it (usually) easier to implement the recursive-descending parsers just manually. This may include combination approach too, but using my own combinatorial and domain-specific functions.<p>Working in what languages did you make this observation?<p>In something like C I would probably agree with you.  But in eg Haskell or OCaml, I would probably prefer parser combinators.</div><br/><div id="40581926" class="c"><input type="checkbox" id="c-40581926" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#40581730">root</a><span>|</span><a href="#40581787">parent</a><span>|</span><a href="#40581808">next</a><span>|</span><label class="collapse" for="c-40581926">[-]</label><label class="expand" for="c-40581926">[1 more]</label></div><br/><div class="children"><div class="content">In other functional languages I tend to reach for combinators, but in OCaml I either use Menhir or regret not using it.</div><br/></div></div><div id="40581808" class="c"><input type="checkbox" id="c-40581808" checked=""/><div class="controls bullet"><span class="by">Eliah_Lakhin</span><span>|</span><a href="#40581730">root</a><span>|</span><a href="#40581787">parent</a><span>|</span><a href="#40581926">prev</a><span>|</span><a href="#40581162">next</a><span>|</span><label class="collapse" for="c-40581808">[-]</label><label class="expand" for="c-40581808">[1 more]</label></div><br/><div class="children"><div class="content">I work with Rust most of the time. As of the pure functional languages, yes, perhaps using parser combinators is better.</div><br/></div></div></div></div></div></div><div id="40581162" class="c"><input type="checkbox" id="c-40581162" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40581730">prev</a><span>|</span><a href="#40582252">next</a><span>|</span><label class="collapse" for="c-40581162">[-]</label><label class="expand" for="c-40581162">[1 more]</label></div><br/><div class="children"><div class="content">The reality however is that many applications find a recursive descent parser easier to handle once the grammar has been fixed (and in spite of its many caveats!), so PEG is a natural formalism for them.<p>For example I once tried to write a full parser for Lua in LALRPOP and gave up after a week because it was too slow to compile and too hard to avoid conflicts; I ended up writing a recursive descent parser in a single day. I already knew that LALRPOP doesn&#x27;t resolve shift-reduce conflicts and also how to transform the grammar to avoid them, but that wasn&#x27;t enough for me.<p>I think there is a niche for CFG-like formalisms with <i>bounded</i> PEG-like constructs so that it can be quickly adjusted without giving up all the benefits of CFG. I have been already in situations where I really want to have such formalisms for multiple times, including the aforementioned one.</div><br/></div></div><div id="40582252" class="c"><input type="checkbox" id="c-40582252" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#40581162">prev</a><span>|</span><a href="#40581116">next</a><span>|</span><label class="collapse" for="c-40582252">[-]</label><label class="expand" for="c-40582252">[2 more]</label></div><br/><div class="children"><div class="content">PEGs are more expressive than CFGs, iirc. So use the right tool for the job. I have come to quite like PEGs and they become quite natural, once one understands things like no left recursion. I also often prefer them over complex regexes.</div><br/><div id="40582607" class="c"><input type="checkbox" id="c-40582607" checked=""/><div class="controls bullet"><span class="by">sparkie</span><span>|</span><a href="#40582252">parent</a><span>|</span><a href="#40581116">next</a><span>|</span><label class="collapse" for="c-40582607">[-]</label><label class="expand" for="c-40582607">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s difficult to conclude meaningfully that any one is more expressive than the other. They parse different languages, though there is a large subset of PEGs which are also CFGs, they&#x27;re not a proper superset - there are things you can parse with a CFG which cannot be parsed with PEG, and vice-versa.<p>OTOH, when comparing LL and LR, we can conclusively say that LR are more expressive than LL because they&#x27;re a proper superset - any language that can be parsed by an LL(<i>k</i>) grammar can be parsed by an LR(<i>k</i>) grammar (for same <i>k</i>).</div><br/></div></div></div></div><div id="40581116" class="c"><input type="checkbox" id="c-40581116" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#40582252">prev</a><span>|</span><a href="#40581453">next</a><span>|</span><label class="collapse" for="c-40581116">[-]</label><label class="expand" for="c-40581116">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Parser and lexer for reversible parsing with guaranteed reversibility. Seems to be totally unique across all programming languages. Of course, CFG-based.<p>There&#x27;s also the parser combinator approach of parser-printers ;)</div><br/></div></div><div id="40581453" class="c"><input type="checkbox" id="c-40581453" checked=""/><div class="controls bullet"><span class="by">yawpitch</span><span>|</span><a href="#40581116">prev</a><span>|</span><a href="#40581026">next</a><span>|</span><label class="collapse" for="c-40581453">[-]</label><label class="expand" for="c-40581453">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Python spec says Python is PEG, so you should use PEG parser for parsing Python.<p>Python <i>switched</i> to PEG in IIRC 3.9, the language standard, parser and the grammer were previously CFG, specifically LL(1).<p>That switch implies that maybe the author is only correct <i>until</i> your language is widely (if not wildly) successful?<p><a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0617&#x2F;" rel="nofollow">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0617&#x2F;</a></div><br/></div></div><div id="40580898" class="c"><input type="checkbox" id="c-40580898" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#40581026">prev</a><span>|</span><label class="collapse" for="c-40580898">[-]</label><label class="expand" for="c-40580898">[4 more]</label></div><br/><div class="children"><div class="content">This also applies to LLM constrained generation. Instead of outputting something that promised to be a JSON (but maybe it&#x27;s not, or maybe it&#x27;s an incomplete JSON, or maybe it&#x27;s a JSON but doesn&#x27;t conform to your JSON schema), just use CFGs (e.g., GBNF) to guide the model to generate the exact JSON you want. It&#x27;s guaranteed, and you don&#x27;t have to send lengthy JSON schemas to the LLM.</div><br/><div id="40581106" class="c"><input type="checkbox" id="c-40581106" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#40580898">parent</a><span>|</span><label class="collapse" for="c-40581106">[-]</label><label class="expand" for="c-40581106">[3 more]</label></div><br/><div class="children"><div class="content">With the caveat that you significantly change the distribution of the output. Picking on JSON with current-gen LLMs, consider<p>(1) Retry till the output passes the grammar<p>(2) Only generate tokens passing the grammar<p>Assuming (2) actually runs (not guaranteed for all grammars and distributions theoretically, basically never a problem in practice), one of many common failure modes is forcing the generation of grammar-valid tokens after an error has been made.<p>E.g., one sort of &quot;truncation&quot; error happens when the LLM is producing an object with metadata around a transcription (e.g., an author, timestamp, and blob of text). A common incorrect result looks like<p>{&quot;author&quot;: &quot;John Doe&quot;, &quot;timestamp&quot;: &quot;20:23:58&quot;, &quot;transcript&quot;: &quot;My name is John Doe, and ...<p>Those ellipses weren&#x27;t just cutting off my description of the invalid data. The model will produce ellipses after the string carries on for too long. If you greedily produce tokens adhering to a grammar, your only options at that point are continuing the string and ending it, and both options are very wrong.<p>Contrast that with option (1). Empirically, if the model is willing to actually produce those tokens rather than cut off its answer, it&#x27;s much more likely to be correct (i.e., the presence of that ellipses bug will tend to cut off the entire response, not just truncating the string and still generating a valid object). If you just retry till the model succeeds then you have a substantially higher accuracy in that task.<p>That particular example may or may not apply to your favorite problem and favorite model, but it highlights the problem that constraining to a grammar forces a large skew in your result distribution. A large part of the power of an LLM is its autoregressiveness, and other sampling algorithms only tend to perform well when there&#x27;s some outside knowledge relevant to the real-world problem being solved (e.g., if the LLM has &gt;50% accuracy on a task with a small, finite number of outputs, then you might want to drop the temperature to 0 and just sample repeatedly, selecting the most likely option), but messing with the result distribution without a rationale for why you&#x27;re still likely to get good results is risky.</div><br/><div id="40581277" class="c"><input type="checkbox" id="c-40581277" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#40580898">root</a><span>|</span><a href="#40581106">parent</a><span>|</span><label class="collapse" for="c-40581277">[-]</label><label class="expand" for="c-40581277">[2 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s say the grammar forces a JSON like this:<p><pre><code>    {&quot;transaction_number&quot;: &lt;number&gt;}
</code></pre>
Is this also problematic? My understanding is that the model is first forced to generate &quot;transaction_number&quot;, which then hints to the model that it must generate the number of the transaction, not something else. I understand that maybe the model didn&#x27;t want to start writing &quot;transaction_number&quot; without enforcing the grammar, but after being forced to, it has to only continue the generation.</div><br/><div id="40581529" class="c"><input type="checkbox" id="c-40581529" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#40580898">root</a><span>|</span><a href="#40581277">parent</a><span>|</span><label class="collapse" for="c-40581529">[-]</label><label class="expand" for="c-40581529">[1 more]</label></div><br/><div class="children"><div class="content">In general, all bets are off. The model has a certain auto-regressive property (a factoring of conditional probabilities), and every other sampling should be examined with extreme suspicion. At a bare minimum, a lot of real-world problems in your desired domain should be spot-checked.<p>For more constrained examples like that, you&#x27;re probably a lot safer than with completely unconstrained strings.<p>Even for very simple constraints like that, it&#x27;s not terribly hard to imagine exactly the same ellipses problem (especially if your chosen JSON grammar isn&#x27;t very careful with unbounded vs 53-bit integers). You really want a non-negative integer, you&#x27;re using JSON and don&#x27;t want to roll your own grammer so you use an off-the-shelf JSON LLM CFG toolkit of some flavor, and you allow _numbers_ in that field. I haven&#x27;t personally seen ellipses bugs after only a few dozen characters in current-gen LLMs, but to have something concrete talk about let&#x27;s say your model &quot;tries&quot; to write a transaction_number of 3141592635.... They want to truncate the actual result with an ellipsis. On the first period, the only allowable results include more digits (the grammar prevents the actual ellipsis from happening). You successfully adhere to the grammar and have garbage in that field, where a simple retry loop would have likely completed correctly.<p>Assuming the grammar actually correctly restricts to just a non-empty contiguous sequence of digits in that spot, that&#x27;s _harder_ to force a bug into, but it&#x27;s not impossible. For starters, the whole thing is probabilistic. Suppose the model uses &quot;0&quot; as the first digit. The only remaining valid (integer) JSON is finishing the field. Multiple leading zeros&#x27;s aren&#x27;t allowed. If for _any_ reason the model is more likely to produce invalid JSON after incorrectly using a &quot;0&quot; for the first digit, the grammar-constrained implementation will have more errors than a basic retry loop.<p>You can probably do something clever with changing the sampling temperature based on which part of the grammar you&#x27;re in to side-step some of those issues. You might also find that for a particular problem my theoretical complaints don&#x27;t seem to apply in practice. Maybe, for business reasons, past a certain accuracy rate you value being able to write simpler code (i.e., assume valid JSON) even if you dip down from 99% to 98% accuracy on a task. Nothing I&#x27;ve outlined says &quot;don&#x27;t guide an LLM with grammars.&quot; Do be careful with it though and consciously consider the task at hand and your proposed solution. It&#x27;s not a free lunch.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>