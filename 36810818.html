<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689930062989" as="style"/><link rel="stylesheet" href="styles.css?v=1689930062989"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.evanjones.ca/nanosecond-collisions.html">Nanosecond timestamp collisions are common</a> <span class="domain">(<a href="https://www.evanjones.ca">www.evanjones.ca</a>)</span></div><div class="subtext"><span>ingve</span> | <span>61 comments</span></div><br/><div><div id="36811040" class="c"><input type="checkbox" id="c-36811040" checked=""/><div class="controls bullet"><span class="by">wood_spirit</span><span>|</span><a href="#36811603">next</a><span>|</span><label class="collapse" for="c-36811040">[-]</label><label class="expand" for="c-36811040">[10 more]</label></div><br/><div class="children"><div class="content">This is why you should use ids that combine both a time component and a sequence.<p>Eg UUIDv7 has a milliseconds time component and then a field that increments for each event in the same millisecond, and then enough random bits to make collisions between ids generated on different machines astronomically unlikely.<p>Of course there are only so many bits so you might generate too many events in the same time slice so the sequence overflows, and you might actually get collisions between machines, and you are limiting your event generation speed by forcing your cpu to sync on the increment etc.<p>But in practice UUIDv7 works great at scale.</div><br/><div id="36811464" class="c"><input type="checkbox" id="c-36811464" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#36811040">parent</a><span>|</span><a href="#36811262">next</a><span>|</span><label class="collapse" for="c-36811464">[-]</label><label class="expand" for="c-36811464">[3 more]</label></div><br/><div class="children"><div class="content">Why do you need the time component anyway?  It&#x27;s just eating up bits in your UUID without contributing much entropy.</div><br/><div id="36811515" class="c"><input type="checkbox" id="c-36811515" checked=""/><div class="controls bullet"><span class="by">c0balt</span><span>|</span><a href="#36811040">root</a><span>|</span><a href="#36811464">parent</a><span>|</span><a href="#36811570">next</a><span>|</span><label class="collapse" for="c-36811515">[-]</label><label class="expand" for="c-36811515">[1 more]</label></div><br/><div class="children"><div class="content">Because it allows te encoding of information the id. This makes it, at least in my experience, somewhat sortable.</div><br/></div></div><div id="36811570" class="c"><input type="checkbox" id="c-36811570" checked=""/><div class="controls bullet"><span class="by">madsbuch</span><span>|</span><a href="#36811040">root</a><span>|</span><a href="#36811464">parent</a><span>|</span><a href="#36811515">prev</a><span>|</span><a href="#36811262">next</a><span>|</span><label class="collapse" for="c-36811570">[-]</label><label class="expand" for="c-36811570">[1 more]</label></div><br/><div class="children"><div class="content">You need it to make database indices perform better.<p>If you don&#x27;t need that, but just need a random UUID, UUIDv4 is better.</div><br/></div></div></div></div><div id="36811262" class="c"><input type="checkbox" id="c-36811262" checked=""/><div class="controls bullet"><span class="by">Mikhail_Edoshin</span><span>|</span><a href="#36811040">parent</a><span>|</span><a href="#36811464">prev</a><span>|</span><a href="#36811222">next</a><span>|</span><label class="collapse" for="c-36811262">[-]</label><label class="expand" for="c-36811262">[4 more]</label></div><br/><div class="children"><div class="content">Isn’t it simpler to use sequence keys then?</div><br/><div id="36811293" class="c"><input type="checkbox" id="c-36811293" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#36811040">root</a><span>|</span><a href="#36811262">parent</a><span>|</span><a href="#36811369">next</a><span>|</span><label class="collapse" for="c-36811293">[-]</label><label class="expand" for="c-36811293">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but only on single machines, UUID and co are intended for distributed systems.<p>Although now I wonder if &#x2F; how UUID v7 can do sequential keys on distributed systems. Mind you, on those systems &quot;close enough&quot; will probably be good enough, and sorting will be done by date instead of incremental ID.</div><br/></div></div><div id="36811369" class="c"><input type="checkbox" id="c-36811369" checked=""/><div class="controls bullet"><span class="by">michaelt</span><span>|</span><a href="#36811040">root</a><span>|</span><a href="#36811262">parent</a><span>|</span><a href="#36811293">prev</a><span>|</span><a href="#36811222">next</a><span>|</span><label class="collapse" for="c-36811369">[-]</label><label class="expand" for="c-36811369">[2 more]</label></div><br/><div class="children"><div class="content">Ah but you see, UUIDs are web scale.<p>And by web scale, I mean they&#x27;re too big to exchange by any offline channel.</div><br/><div id="36811428" class="c"><input type="checkbox" id="c-36811428" checked=""/><div class="controls bullet"><span class="by">Tade0</span><span>|</span><a href="#36811040">root</a><span>|</span><a href="#36811369">parent</a><span>|</span><a href="#36811222">next</a><span>|</span><label class="collapse" for="c-36811428">[-]</label><label class="expand" for="c-36811428">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s 128 bits vs 64 bits - not really that much of a difference.</div><br/></div></div></div></div></div></div><div id="36811222" class="c"><input type="checkbox" id="c-36811222" checked=""/><div class="controls bullet"><span class="by">darkclouds</span><span>|</span><a href="#36811040">parent</a><span>|</span><a href="#36811262">prev</a><span>|</span><a href="#36811603">next</a><span>|</span><label class="collapse" for="c-36811222">[-]</label><label class="expand" for="c-36811222">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This is why you should use ids that combine both a time component and a sequence.<p>Computers should run like clockwork, so in this example of using all the cores, in Windows and likely some other OS&#x27;s, threads are assigned to cores when they are started and you can have many threads per core, ergo the time component should also have the thread and the core number combined with it with multi core systems.<p>Its possible to write the code in such a way some variables are bounced out of the cpu cache back to memory to avoid any caching issues because I think the cache on some cpu&#x27;s are per core, and some are per cpu.</div><br/><div id="36811565" class="c"><input type="checkbox" id="c-36811565" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#36811040">root</a><span>|</span><a href="#36811222">parent</a><span>|</span><a href="#36811603">next</a><span>|</span><label class="collapse" for="c-36811565">[-]</label><label class="expand" for="c-36811565">[1 more]</label></div><br/><div class="children"><div class="content">&gt; threads are assigned to cores when they are started<p>Do they? I thought the normal behaviour was for cores to pick any available thread to run, so core migration is quite normal.<p>&gt; ergo the time component should also have the thread and the core number combined with it with multi core systems.<p>Sorry, how exactly does it follow from the previous? You seem to have omitted the other half of your syllogism. After all, clockworks do not have thread nor core numbers so I don&#x27;t quite see how having those in UUIDs will make computers run like clockwork.</div><br/></div></div></div></div></div></div><div id="36811603" class="c"><input type="checkbox" id="c-36811603" checked=""/><div class="controls bullet"><span class="by">godelski</span><span>|</span><a href="#36811040">prev</a><span>|</span><a href="#36811561">next</a><span>|</span><label class="collapse" for="c-36811603">[-]</label><label class="expand" for="c-36811603">[1 more]</label></div><br/><div class="children"><div class="content">Despite the resolution being nanoseconds, what is the actual precision of computer clocks? I can&#x27;t imagine it is actually nanoseconds. Takes me back to teaching physics labs where I had to hound students to remember that the accuracy of their measuring device is not identical to the smallest number it displays...</div><br/></div></div><div id="36811561" class="c"><input type="checkbox" id="c-36811561" checked=""/><div class="controls bullet"><span class="by">efitz</span><span>|</span><a href="#36811603">prev</a><span>|</span><a href="#36811167">next</a><span>|</span><label class="collapse" for="c-36811561">[-]</label><label class="expand" for="c-36811561">[1 more]</label></div><br/><div class="children"><div class="content">Related<p>I used to be the program manager owner of the security event log in windows.<p>When things happen simultaneously or very closely in time on multi-core systems, thread scheduling can significantly affect observations of those things.  For example, your thread quantum might expire before you get to the syscall to get a time stamp, or before you can pass a buffer to queue your event for subsequent time stamping.<p>In fact, on multiprocessing systems, it was very common to see out of order event log entries on Windows back in the day (2000-oughts).  You also could not count on the log timestamp accuracy too precisely; 1s was pretty much the safe lower bound (some components truncated or rounded time stamps IIRC).</div><br/></div></div><div id="36811167" class="c"><input type="checkbox" id="c-36811167" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#36811561">prev</a><span>|</span><a href="#36811001">next</a><span>|</span><label class="collapse" for="c-36811167">[-]</label><label class="expand" for="c-36811167">[14 more]</label></div><br/><div class="children"><div class="content">If you want unique identifiers, use version 4 (random) UUIDs. Problem solved.<p>The probability of a collision is roughly the same as the probability of a fully grown dinosaur spontaneously manifesting in your bedroom due to quantum fluctuations.</div><br/><div id="36811181" class="c"><input type="checkbox" id="c-36811181" checked=""/><div class="controls bullet"><span class="by">jraph</span><span>|</span><a href="#36811167">parent</a><span>|</span><a href="#36811247">next</a><span>|</span><label class="collapse" for="c-36811181">[-]</label><label class="expand" for="c-36811181">[8 more]</label></div><br/><div class="children"><div class="content">I will take my chance :-)<p>More seriously, If you can use them, good old increments are probably best. They are fast and cheap. Especially in a database. They can have privacy&#x2F;security issues (you could guess things by the values of ids of stuff). UUIDs are better in those case or when you deal with a distributed system.</div><br/><div id="36811244" class="c"><input type="checkbox" id="c-36811244" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#36811167">root</a><span>|</span><a href="#36811181">parent</a><span>|</span><a href="#36811214">next</a><span>|</span><label class="collapse" for="c-36811244">[-]</label><label class="expand" for="c-36811244">[6 more]</label></div><br/><div class="children"><div class="content">&gt; They can have privacy&#x2F;security issues (you could guess things by the values of ids of stuff).<p>Push them through a secure hash function, and that problem is solved too (assuming you can keep the base counter private).</div><br/><div id="36811324" class="c"><input type="checkbox" id="c-36811324" checked=""/><div class="controls bullet"><span class="by">cacheyourdreams</span><span>|</span><a href="#36811167">root</a><span>|</span><a href="#36811244">parent</a><span>|</span><a href="#36811214">next</a><span>|</span><label class="collapse" for="c-36811324">[-]</label><label class="expand" for="c-36811324">[5 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re going to do that then you might as well just use UUID, since you effectively reintroduce the negative aspects of that (infinitesimally miniscule chance of collisions, computation involved in the calculation, etc.)</div><br/><div id="36811357" class="c"><input type="checkbox" id="c-36811357" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#36811167">root</a><span>|</span><a href="#36811324">parent</a><span>|</span><a href="#36811214">next</a><span>|</span><label class="collapse" for="c-36811357">[-]</label><label class="expand" for="c-36811357">[4 more]</label></div><br/><div class="children"><div class="content">The difference is that you can still use sequential IDs internally, while exposing hashed IDs to the outside. This protects your database from collisions under all circumstances, while in the absolute worst case, a single user might experience bugs because two external IDs collide.</div><br/><div id="36811397" class="c"><input type="checkbox" id="c-36811397" checked=""/><div class="controls bullet"><span class="by">cacheyourdreams</span><span>|</span><a href="#36811167">root</a><span>|</span><a href="#36811357">parent</a><span>|</span><a href="#36811214">next</a><span>|</span><label class="collapse" for="c-36811397">[-]</label><label class="expand" for="c-36811397">[3 more]</label></div><br/><div class="children"><div class="content">Yes, I tend to like this philosophy in database design, of internal sequential ids which are used for joins between tables etc. and an exposed &quot;external reference&quot;. But I typically would use a UUID for my external reference rather than a hash of the internal id.</div><br/><div id="36811482" class="c"><input type="checkbox" id="c-36811482" checked=""/><div class="controls bullet"><span class="by">newaccount74</span><span>|</span><a href="#36811167">root</a><span>|</span><a href="#36811397">parent</a><span>|</span><a href="#36811214">next</a><span>|</span><label class="collapse" for="c-36811482">[-]</label><label class="expand" for="c-36811482">[2 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t that just add a whole lot of unnecessary complexity? If elements have multiple IDs, one of which should not be leaked to the outside, that&#x27;s just asking for trouble in my opinion.<p>Is generating UUIDv4 or UUIDv7 really too much effort? I&#x27;d assume that writing the row to the database takes longer than generating the UUID.</div><br/><div id="36811586" class="c"><input type="checkbox" id="c-36811586" checked=""/><div class="controls bullet"><span class="by">iforgotpassword</span><span>|</span><a href="#36811167">root</a><span>|</span><a href="#36811482">parent</a><span>|</span><a href="#36811214">next</a><span>|</span><label class="collapse" for="c-36811586">[-]</label><label class="expand" for="c-36811586">[1 more]</label></div><br/><div class="children"><div class="content">It also means once your hash function leaks for whatever reason or gets brute forced because of whatever weird weakness in your system, it&#x27;s game over and everybody will forever be able to predict any future ids, guess neighboring ids, etc., unless you&#x27;re willing to change the hash and invalidate all links to any content on your site.<p>If I&#x27;m in a scenario where I think I need consecutive ids internally and random ones externally, I&#x27;ll just have two fields in my tables.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36811214" class="c"><input type="checkbox" id="c-36811214" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#36811167">root</a><span>|</span><a href="#36811181">parent</a><span>|</span><a href="#36811244">prev</a><span>|</span><a href="#36811247">next</a><span>|</span><label class="collapse" for="c-36811214">[-]</label><label class="expand" for="c-36811214">[1 more]</label></div><br/><div class="children"><div class="content">Unless the RNG itself is the problem, there&#x27;s no reason not to. All kinds of civilization-ending catastrophes are <i>vastly</i> more likely than a collision in a space of size 2^122.</div><br/></div></div></div></div><div id="36811247" class="c"><input type="checkbox" id="c-36811247" checked=""/><div class="controls bullet"><span class="by">dtech</span><span>|</span><a href="#36811167">parent</a><span>|</span><a href="#36811181">prev</a><span>|</span><a href="#36811184">next</a><span>|</span><label class="collapse" for="c-36811247">[-]</label><label class="expand" for="c-36811247">[2 more]</label></div><br/><div class="children"><div class="content">v7 looks nicer since it solves v4&#x27;s locality issue and you&#x27;re still a gazillion times more likely to win the lottery than generate a collision.</div><br/><div id="36811280" class="c"><input type="checkbox" id="c-36811280" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#36811167">root</a><span>|</span><a href="#36811247">parent</a><span>|</span><a href="#36811184">next</a><span>|</span><label class="collapse" for="c-36811280">[-]</label><label class="expand" for="c-36811280">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately, many libraries don&#x27;t implement it yet.</div><br/></div></div></div></div><div id="36811184" class="c"><input type="checkbox" id="c-36811184" checked=""/><div class="controls bullet"><span class="by">enyone</span><span>|</span><a href="#36811167">parent</a><span>|</span><a href="#36811247">prev</a><span>|</span><a href="#36811194">next</a><span>|</span><label class="collapse" for="c-36811184">[-]</label><label class="expand" for="c-36811184">[2 more]</label></div><br/><div class="children"><div class="content">the dinosaur is now on my bed, what next?</div><br/><div id="36811207" class="c"><input type="checkbox" id="c-36811207" checked=""/><div class="controls bullet"><span class="by">MattPalmer1086</span><span>|</span><a href="#36811167">root</a><span>|</span><a href="#36811184">parent</a><span>|</span><a href="#36811194">next</a><span>|</span><label class="collapse" for="c-36811207">[-]</label><label class="expand" for="c-36811207">[1 more]</label></div><br/><div class="children"><div class="content">Close the door and immediately switch to v5.</div><br/></div></div></div></div><div id="36811194" class="c"><input type="checkbox" id="c-36811194" checked=""/><div class="controls bullet"><span class="by">fendy3002</span><span>|</span><a href="#36811167">parent</a><span>|</span><a href="#36811184">prev</a><span>|</span><a href="#36811001">next</a><span>|</span><label class="collapse" for="c-36811194">[-]</label><label class="expand" for="c-36811194">[1 more]</label></div><br/><div class="children"><div class="content">but is it higher or lower if the dinosaur is not fully grown?</div><br/></div></div></div></div><div id="36811001" class="c"><input type="checkbox" id="c-36811001" checked=""/><div class="controls bullet"><span class="by">JacobSeated</span><span>|</span><a href="#36811167">prev</a><span>|</span><a href="#36811107">next</a><span>|</span><label class="collapse" for="c-36811001">[-]</label><label class="expand" for="c-36811001">[3 more]</label></div><br/><div class="children"><div class="content">Timestamps should probably never be used as a &quot;unique&quot; id.</div><br/><div id="36811193" class="c"><input type="checkbox" id="c-36811193" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#36811001">parent</a><span>|</span><a href="#36811107">next</a><span>|</span><label class="collapse" for="c-36811193">[-]</label><label class="expand" for="c-36811193">[2 more]</label></div><br/><div class="children"><div class="content">The problem is achieving locality in cohesion&#x2F;meaning, which usually involves locality in time, which provokes using timestamps as part of the id at the very least. But it&#x27;s a chain of very lazy thinking IMHO and it&#x27;s like a peek at the house of cards some large systems are built like.</div><br/><div id="36811481" class="c"><input type="checkbox" id="c-36811481" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#36811001">root</a><span>|</span><a href="#36811193">parent</a><span>|</span><a href="#36811107">next</a><span>|</span><label class="collapse" for="c-36811481">[-]</label><label class="expand" for="c-36811481">[1 more]</label></div><br/><div class="children"><div class="content">Why do you want this kind of locality anyway?</div><br/></div></div></div></div></div></div><div id="36811107" class="c"><input type="checkbox" id="c-36811107" checked=""/><div class="controls bullet"><span class="by">techNoob123</span><span>|</span><a href="#36811001">prev</a><span>|</span><a href="#36811024">next</a><span>|</span><label class="collapse" for="c-36811107">[-]</label><label class="expand" for="c-36811107">[2 more]</label></div><br/><div class="children"><div class="content">At some point doesn’t this come down to the ISA? A CPU running at 3GHz gets 3 clock cycles per nanosecond.<p>I bet there is a fair amount of optimization in the compiler that leads to back to back assembly calls of reading the clock register. If subsequent time.Now() calls happen within 3 clock cycles of each other, can you really fairly expect unique nanosecond precision…</div><br/><div id="36811155" class="c"><input type="checkbox" id="c-36811155" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#36811107">parent</a><span>|</span><a href="#36811024">next</a><span>|</span><label class="collapse" for="c-36811155">[-]</label><label class="expand" for="c-36811155">[1 more]</label></div><br/><div class="children"><div class="content">Linux will (x86_64) use RDTSC and adjust that against a value read from the VDSO, so it can indeed happen very quickly.</div><br/></div></div></div></div><div id="36811024" class="c"><input type="checkbox" id="c-36811024" checked=""/><div class="controls bullet"><span class="by">getmeinrn</span><span>|</span><a href="#36811107">prev</a><span>|</span><a href="#36811061">next</a><span>|</span><label class="collapse" for="c-36811024">[-]</label><label class="expand" for="c-36811024">[8 more]</label></div><br/><div class="children"><div class="content">I was going to post about &quot;use a UUID&quot;, but I was surprised to learn that no UUID uses both timestamp + a random component. You can either get fully random with UUID4, or have a time + MAC based UUID with UUID1. Strange, I would have thought there would exist a UUID that uses time + random to minimize collisions like described in the post.</div><br/><div id="36811058" class="c"><input type="checkbox" id="c-36811058" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#36811024">parent</a><span>|</span><a href="#36811052">next</a><span>|</span><label class="collapse" for="c-36811058">[-]</label><label class="expand" for="c-36811058">[1 more]</label></div><br/><div class="children"><div class="content">I believe the proposed UUIDv7 standard uses this.<p><a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;draft-peabody-dispatch-new-uuid-format#name-uuid-version-7" rel="nofollow noreferrer">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;draft-peabody-dispatch...</a><p>It&#x27;s a draft but there&#x27;s a lot of implementations out there.</div><br/></div></div><div id="36811052" class="c"><input type="checkbox" id="c-36811052" checked=""/><div class="controls bullet"><span class="by">wood_spirit</span><span>|</span><a href="#36811024">parent</a><span>|</span><a href="#36811058">prev</a><span>|</span><a href="#36811060">next</a><span>|</span><label class="collapse" for="c-36811052">[-]</label><label class="expand" for="c-36811052">[2 more]</label></div><br/><div class="children"><div class="content">the new UUIDv6, 7 and 8 work the way you deacribe.</div><br/><div id="36811264" class="c"><input type="checkbox" id="c-36811264" checked=""/><div class="controls bullet"><span class="by">dtech</span><span>|</span><a href="#36811024">root</a><span>|</span><a href="#36811052">parent</a><span>|</span><a href="#36811060">next</a><span>|</span><label class="collapse" for="c-36811264">[-]</label><label class="expand" for="c-36811264">[1 more]</label></div><br/><div class="children"><div class="content">Only v6 and v7, v8 is &quot;whatever you want&quot;.</div><br/></div></div></div></div><div id="36811060" class="c"><input type="checkbox" id="c-36811060" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#36811024">parent</a><span>|</span><a href="#36811052">prev</a><span>|</span><a href="#36811054">next</a><span>|</span><label class="collapse" for="c-36811060">[-]</label><label class="expand" for="c-36811060">[1 more]</label></div><br/><div class="children"><div class="content">ULID (and I think UUIDv7 draft) has millisecond timestamp + 80b randomness.</div><br/></div></div><div id="36811054" class="c"><input type="checkbox" id="c-36811054" checked=""/><div class="controls bullet"><span class="by">zote</span><span>|</span><a href="#36811024">parent</a><span>|</span><a href="#36811060">prev</a><span>|</span><a href="#36811053">next</a><span>|</span><label class="collapse" for="c-36811054">[-]</label><label class="expand" for="c-36811054">[1 more]</label></div><br/><div class="children"><div class="content">someone else in the thread mentioned UUIDv7</div><br/></div></div><div id="36811053" class="c"><input type="checkbox" id="c-36811053" checked=""/><div class="controls bullet"><span class="by">nabogh</span><span>|</span><a href="#36811024">parent</a><span>|</span><a href="#36811054">prev</a><span>|</span><a href="#36811061">next</a><span>|</span><label class="collapse" for="c-36811053">[-]</label><label class="expand" for="c-36811053">[2 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t find much info about it but is this UUID v7?</div><br/></div></div></div></div><div id="36811061" class="c"><input type="checkbox" id="c-36811061" checked=""/><div class="controls bullet"><span class="by">grose</span><span>|</span><a href="#36811024">prev</a><span>|</span><a href="#36811122">next</a><span>|</span><label class="collapse" for="c-36811061">[-]</label><label class="expand" for="c-36811061">[1 more]</label></div><br/><div class="children"><div class="content">This is why it scares me a bit to use a raw timestamp as a sort key in DynamoDB. I append a (random) unique ID to the timestamp text to avoid it. Better safe than sorry, I figure.</div><br/></div></div><div id="36811122" class="c"><input type="checkbox" id="c-36811122" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#36811061">prev</a><span>|</span><a href="#36811020">next</a><span>|</span><label class="collapse" for="c-36811122">[-]</label><label class="expand" for="c-36811122">[3 more]</label></div><br/><div class="children"><div class="content">I guess I&#x27;m old, the macOS behaviour is more in line with my expectations.<p>But this got me thinking, how feasible it would be to tie the various clock systems of a computer to some reference clock, like 10 MHz GPSDO? Obviously it wouldn&#x27;t improve the granularity, but you could ensure that the timestamps are actually accurate. Because otherwise I doubt that random computer clock would be accurate down to 32ns even with NTP.</div><br/><div id="36811201" class="c"><input type="checkbox" id="c-36811201" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#36811122">parent</a><span>|</span><a href="#36811020">next</a><span>|</span><label class="collapse" for="c-36811201">[-]</label><label class="expand" for="c-36811201">[2 more]</label></div><br/><div class="children"><div class="content">Getting a 10MHz PPS signal requires specialized expensive hardware and typically doesn&#x27;t scale well to cover every server. That sort of thing is best left to extreme applications with FPGAs or ASICs. In particular the 10MHz version; a lot of commodity hardware only supports the 1Hz one.<p>There&#x27;s still an in-between of PPS and NTP: PTP.</div><br/><div id="36811617" class="c"><input type="checkbox" id="c-36811617" checked=""/><div class="controls bullet"><span class="by">mlichvar</span><span>|</span><a href="#36811122">root</a><span>|</span><a href="#36811201">parent</a><span>|</span><a href="#36811020">next</a><span>|</span><label class="collapse" for="c-36811617">[-]</label><label class="expand" for="c-36811617">[1 more]</label></div><br/><div class="children"><div class="content">A major problem in synchronization of the system clock is PCIe. Hardware can timestamp PPS signal or PTP&#x2F;NTP packets with accuracy of a few nanoseconds if everything is well compensated, but the PCIe bus between the CPU and the timestamping HW has a latency of hundreds of nanoseconds with potentially large asymmetry, degrading the accuracy significantly.<p>Measuring that error is difficult. A possibility is to run a program periodically making random reads from memory (avoiding the CPU cache) to generate a PPS signal on the memory bus, which can be observed with a scope. There is a lot of noise due to other memory activity, RAM refresh, etc. From the configured memory speed and tRCD+tCL timings the uncertainty of the error can be reduced.<p>This might improve with new hardware. There is a feature called Precision Time Measurement (PTM), which is a hardware implementation of an NTP-like protocol in PCIe, but so far I have seen this working only on some onboard NICs.</div><br/></div></div></div></div></div></div><div id="36811020" class="c"><input type="checkbox" id="c-36811020" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#36811122">prev</a><span>|</span><a href="#36811140">next</a><span>|</span><label class="collapse" for="c-36811020">[-]</label><label class="expand" for="c-36811020">[8 more]</label></div><br/><div class="children"><div class="content">If you need unique nanosecond, keep track of the previously generated one and increase it if necessary. Would require global lock or atomic stuff, but should be good enough for practical uses.</div><br/><div id="36811128" class="c"><input type="checkbox" id="c-36811128" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#36811020">parent</a><span>|</span><a href="#36811051">next</a><span>|</span><label class="collapse" for="c-36811128">[-]</label><label class="expand" for="c-36811128">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Logical Physical Clocks&quot; may be of interest. The timestamps are monotonic and don&#x27;t require atomic clocks like in google spanner.<p><i>HLC captures the causality relationship like logical clocks, and enables easy identification of consistent snapshots in distributed systems. Dually, HLC can be used in lieu of physical&#x2F;NTP clocks since it maintains its logical clock to be always close to the NTP clock. Moreover HLC fits in to 64 bits NTP timestamp format, and is masking tolerant to NTP kinks and uncertainties.</i><p><a href="https:&#x2F;&#x2F;cse.buffalo.edu&#x2F;~demirbas&#x2F;publications&#x2F;hlc.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;cse.buffalo.edu&#x2F;~demirbas&#x2F;publications&#x2F;hlc.pdf</a></div><br/></div></div><div id="36811051" class="c"><input type="checkbox" id="c-36811051" checked=""/><div class="controls bullet"><span class="by">pyrale</span><span>|</span><a href="#36811020">parent</a><span>|</span><a href="#36811128">prev</a><span>|</span><a href="#36811079">next</a><span>|</span><label class="collapse" for="c-36811051">[-]</label><label class="expand" for="c-36811051">[3 more]</label></div><br/><div class="children"><div class="content">One benefit of UUID is that you don&#x27;t need coordination. In coordinated systems, unique IDs are a non-issue.</div><br/><div id="36811072" class="c"><input type="checkbox" id="c-36811072" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#36811020">root</a><span>|</span><a href="#36811051">parent</a><span>|</span><a href="#36811079">next</a><span>|</span><label class="collapse" for="c-36811072">[-]</label><label class="expand" for="c-36811072">[2 more]</label></div><br/><div class="children"><div class="content">Is there any other benefit? That&#x27;s the raison d&#x27;être - <i>Universally</i>.</div><br/><div id="36811484" class="c"><input type="checkbox" id="c-36811484" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#36811020">root</a><span>|</span><a href="#36811072">parent</a><span>|</span><a href="#36811079">next</a><span>|</span><label class="collapse" for="c-36811484">[-]</label><label class="expand" for="c-36811484">[1 more]</label></div><br/><div class="children"><div class="content">Depends on what you compare them with.</div><br/></div></div></div></div></div></div><div id="36811079" class="c"><input type="checkbox" id="c-36811079" checked=""/><div class="controls bullet"><span class="by">buster</span><span>|</span><a href="#36811020">parent</a><span>|</span><a href="#36811051">prev</a><span>|</span><a href="#36811140">next</a><span>|</span><label class="collapse" for="c-36811079">[-]</label><label class="expand" for="c-36811079">[3 more]</label></div><br/><div class="children"><div class="content">If you do that, just take some redis server and increment an integer every time you need a new number?</div><br/><div id="36811141" class="c"><input type="checkbox" id="c-36811141" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#36811020">root</a><span>|</span><a href="#36811079">parent</a><span>|</span><a href="#36811140">next</a><span>|</span><label class="collapse" for="c-36811141">[-]</label><label class="expand" for="c-36811141">[2 more]</label></div><br/><div class="children"><div class="content">or y&#x27;know, use the thing that was designed specifically for this case: UUID&#x27;s</div><br/><div id="36811254" class="c"><input type="checkbox" id="c-36811254" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#36811020">root</a><span>|</span><a href="#36811141">parent</a><span>|</span><a href="#36811140">next</a><span>|</span><label class="collapse" for="c-36811254">[-]</label><label class="expand" for="c-36811254">[1 more]</label></div><br/><div class="children"><div class="content">UUIDs are designed to solve a slightly different, albeit related, problem: where you don’t have synchronisation of the system as a whole. The solution the GP is solving is for systems that are synchronised and therefore generating a UUID is additional and unnecessary overhead.</div><br/></div></div></div></div></div></div></div></div><div id="36811140" class="c"><input type="checkbox" id="c-36811140" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#36811020">prev</a><span>|</span><a href="#36811313">next</a><span>|</span><label class="collapse" for="c-36811140">[-]</label><label class="expand" for="c-36811140">[8 more]</label></div><br/><div class="children"><div class="content">A lot of mention of UUDv7 in this thread which is good. But I also wonder what the collision rate for Ulids are.</div><br/><div id="36811177" class="c"><input type="checkbox" id="c-36811177" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#36811140">parent</a><span>|</span><a href="#36811497">next</a><span>|</span><label class="collapse" for="c-36811177">[-]</label><label class="expand" for="c-36811177">[6 more]</label></div><br/><div class="children"><div class="content">I frankly don&#x27;t understand how it&#x27;s good. UUID originally was intended as something you use very sparingly, to name, say, a product SKU maybe, an organization, something like that. Not literally content that collides commonly at the same nanosecond, in the same application, in the same platform&#x2F;org.<p>At some point we have to question the sanity of using one single flat address space for everything from the tiniest identifier to the... well, &quot;Universe&quot;, as if it makes sense.<p>We can have registrars for global ids, and we can nest local ids inside them, we can have a hierarchy, and we can have local compact ids, 32, 64 or 128 bit, which will never collide, and be locally cohesive.<p>So why aren&#x27;t we doing this? Is it ignorance? Is it because magic is easier than actually figuring out the synchronization and order of things in a system like this (and no, synchronization does NOT imply you need to issue ids strictly linearly).<p>Honestly I&#x27;m at a loss of words.</div><br/><div id="36811386" class="c"><input type="checkbox" id="c-36811386" checked=""/><div class="controls bullet"><span class="by">pravus</span><span>|</span><a href="#36811140">root</a><span>|</span><a href="#36811177">parent</a><span>|</span><a href="#36811284">next</a><span>|</span><label class="collapse" for="c-36811386">[-]</label><label class="expand" for="c-36811386">[2 more]</label></div><br/><div class="children"><div class="content">&gt; We can have registrars for global ids, and we can nest local ids inside them, we can have a hierarchy, and we can have local compact ids, 32, 64 or 128 bit, which will never collide, and be locally cohesive.<p>We have this.  It&#x27;s called OID (Object Identifier) and is used in X.509, LDAP, SNMP, and many other technologies.  A global registry exists (I have an entry) and it&#x27;s a giant tree.<p>&gt; So why aren&#x27;t we doing this? Is it ignorance?<p>The problem you are solving here is for durable, long-lasting keys.  There is also a need to generate large batches of short-lived keys that need to never collide for security&#x2F;identification purposes.  A centralized registry will not work for that and it requires a wholly different technique.</div><br/><div id="36811537" class="c"><input type="checkbox" id="c-36811537" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#36811140">root</a><span>|</span><a href="#36811386">parent</a><span>|</span><a href="#36811284">next</a><span>|</span><label class="collapse" for="c-36811537">[-]</label><label class="expand" for="c-36811537">[1 more]</label></div><br/><div class="children"><div class="content">My point was, let&#x27;s start with that large OID tree, for example.<p>And continue this concept downward. Except when it&#x27;s inside your org, you&#x27;re the registrar of your namespace&#x27;s sub-OIDs, and so on. And there&#x27;s precisely no reason not to have hierarchical sequential ids for everything. You need to generate ids on 100 servers? Good, give each server a namespace. You need to do that in a 100 processes on each server? Good, give a sub-namespace to those too.<p>And the best of all is that the above-organization OID part of the tree is ONLY needed if you show these ids outside your organization. Otherwise you can use the internal private part of the identifiers.<p>So what am I missing here? Maybe they need to be hard to guess, so add a random key part to them (distinct from the generated sequence part) as a &quot;password&quot;. Done.</div><br/></div></div></div></div><div id="36811284" class="c"><input type="checkbox" id="c-36811284" checked=""/><div class="controls bullet"><span class="by">creatonez</span><span>|</span><a href="#36811140">root</a><span>|</span><a href="#36811177">parent</a><span>|</span><a href="#36811386">prev</a><span>|</span><a href="#36811287">next</a><span>|</span><label class="collapse" for="c-36811284">[-]</label><label class="expand" for="c-36811284">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  I frankly don&#x27;t understand how it&#x27;s good. UUID originally was intended as something you use very sparingly, to name, say, a product SKU maybe, an organization, something like that. Not literally content that collides commonly at the same nanosecond, in the same application, in the same platform&#x2F;org.<p>Wikipedia gives a different history, that it was originally for networked computers - <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Universally_unique_identifier#History" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Universally_unique_identifier#...</a></div><br/></div></div><div id="36811287" class="c"><input type="checkbox" id="c-36811287" checked=""/><div class="controls bullet"><span class="by">RicardoLuis0</span><span>|</span><a href="#36811140">root</a><span>|</span><a href="#36811177">parent</a><span>|</span><a href="#36811284">prev</a><span>|</span><a href="#36811497">next</a><span>|</span><label class="collapse" for="c-36811287">[-]</label><label class="expand" for="c-36811287">[2 more]</label></div><br/><div class="children"><div class="content">&gt; So why aren&#x27;t we doing this?<p>isn&#x27;t IPv6 is basically that? just restricted to internet addresses</div><br/><div id="36811548" class="c"><input type="checkbox" id="c-36811548" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#36811140">root</a><span>|</span><a href="#36811287">parent</a><span>|</span><a href="#36811497">next</a><span>|</span><label class="collapse" for="c-36811548">[-]</label><label class="expand" for="c-36811548">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s sort of this. Although it would&#x27;ve been nice if the size of the IP wasn&#x27;t restricted, so one day we can add an optional segment on top and connect the whole Milky Way, or something.</div><br/></div></div></div></div></div></div><div id="36811497" class="c"><input type="checkbox" id="c-36811497" checked=""/><div class="controls bullet"><span class="by">newaccount74</span><span>|</span><a href="#36811140">parent</a><span>|</span><a href="#36811177">prev</a><span>|</span><a href="#36811313">next</a><span>|</span><label class="collapse" for="c-36811497">[-]</label><label class="expand" for="c-36811497">[1 more]</label></div><br/><div class="children"><div class="content">ULIDs are almost the same as UUIDv7, except that they have a few extra random bits that UUIDv7 use to encode the version of UUID. Every UUIDv7 is a valid ULID, and the main difference is the encoding when displayed in a textual form.</div><br/></div></div></div></div><div id="36811313" class="c"><input type="checkbox" id="c-36811313" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#36811140">prev</a><span>|</span><label class="collapse" for="c-36811313">[-]</label><label class="expand" for="c-36811313">[1 more]</label></div><br/><div class="children"><div class="content">&gt; On my system, the minimum increment was 32 ns.<p>Then you aren’t using a nanosecond clock.<p>If you want actual nanosecond precision then you probably want rdtsc.</div><br/></div></div></div></div></div></div></div></body></html>