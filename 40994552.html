<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721379649402" as="style"/><link rel="stylesheet" href="styles.css?v=1721379649402"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a>Ask HN: What&#x27;s Prolog like in 2024?</a> </div><div class="subtext"><span>overclock351</span> | <span>182 comments</span></div><br/><div><div id="40994816" class="c"><input type="checkbox" id="c-40994816" checked=""/><div class="controls bullet"><span class="by">upghost</span><span>|</span><a href="#40995255">next</a><span>|</span><label class="collapse" for="c-40994816">[-]</label><label class="expand" for="c-40994816">[27 more]</label></div><br/><div class="children"><div class="content">Prolog has reached an exciting new milestone with Scryer prolog.  It is the first highly performant open source iso-compliant Prolog.<p>I would check out Markus Triska&#x27;s work to have your mind blown:<p><a href="https:&#x2F;&#x2F;www.metalevel.at&#x2F;prolog" rel="nofollow">https:&#x2F;&#x2F;www.metalevel.at&#x2F;prolog</a><p><a href="https:&#x2F;&#x2F;youtube.com&#x2F;@thepowerofprolog" rel="nofollow">https:&#x2F;&#x2F;youtube.com&#x2F;@thepowerofprolog</a></div><br/><div id="41003666" class="c"><input type="checkbox" id="c-41003666" checked=""/><div class="controls bullet"><span class="by">usgroup</span><span>|</span><a href="#40994816">parent</a><span>|</span><a href="#40995476">next</a><span>|</span><label class="collapse" for="c-41003666">[-]</label><label class="expand" for="c-41003666">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps you could include a link to a benchmark proving its high performance?</div><br/></div></div><div id="40995476" class="c"><input type="checkbox" id="c-40995476" checked=""/><div class="controls bullet"><span class="by">mark_l_watson</span><span>|</span><a href="#40994816">parent</a><span>|</span><a href="#41003666">prev</a><span>|</span><a href="#40994897">next</a><span>|</span><label class="collapse" for="c-40995476">[-]</label><label class="expand" for="c-40995476">[12 more]</label></div><br/><div class="children"><div class="content">I interviewed and helped hire Mark Thom, the original author of Scryer. I also follow Scryer with interest, even though most of my limited Prolog use has been with SWI Prolog (and one large project with ExperProlog in the 1980s).<p>One thing to check out: Prolog plays fairly well with Python, providing opportunities for hybrid projects.</div><br/><div id="40995720" class="c"><input type="checkbox" id="c-40995720" checked=""/><div class="controls bullet"><span class="by">klibertp</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40995476">parent</a><span>|</span><a href="#40995889">next</a><span>|</span><label class="collapse" for="c-40995720">[-]</label><label class="expand" for="c-40995720">[4 more]</label></div><br/><div class="children"><div class="content">To playing well with Python, this was on a front page some time ago: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2308.15893" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2308.15893</a><p>&quot;The Janus System: Multi-paradigm Programming in Prolog and Python&quot;</div><br/><div id="40996177" class="c"><input type="checkbox" id="c-40996177" checked=""/><div class="controls bullet"><span class="by">philzook</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40995720">parent</a><span>|</span><a href="#40997299">next</a><span>|</span><label class="collapse" for="c-40996177">[-]</label><label class="expand" for="c-40996177">[1 more]</label></div><br/><div class="children"><div class="content">I am quite pleased with the ability to easily use prolog from within python and  vice versa. It makes it now one of the easiest and most expressive solvers to plug into for my tastes. I&#x27;m starting to accumulate useful solvers here <a href="https:&#x2F;&#x2F;github.com&#x2F;philzook58&#x2F;prologsolvers&#x2F;tree&#x2F;164297d87f67202e5906d03a5b07d6ff7ce75ef9">https:&#x2F;&#x2F;github.com&#x2F;philzook58&#x2F;prologsolvers&#x2F;tree&#x2F;164297d87f6...</a><p>You need to install swi prolog <a href="https:&#x2F;&#x2F;www.swi-prolog.org&#x2F;download&#x2F;stable" rel="nofollow">https:&#x2F;&#x2F;www.swi-prolog.org&#x2F;download&#x2F;stable</a> and pip install janus_swi<p>A simple example to get started:
<a href="https:&#x2F;&#x2F;www.swi-prolog.org&#x2F;pldoc&#x2F;doc_for?object=section(%27packages&#x2F;janus.html%27)" rel="nofollow">https:&#x2F;&#x2F;www.swi-prolog.org&#x2F;pldoc&#x2F;doc_for?object=section(%27p...</a><p><pre><code>  import janus_swi as janus
  janus.consult(&quot;path&quot;, &quot;&quot;&quot;
  edge(a,b).
  edge(b,c).    
  edge(c,d).

  :- table path&#x2F;2.
  path(X,Y) :- edge(X,Y).
  path(X,Y) :- edge(X,Z), path(Z,Y).
  &quot;&quot;&quot;)
  list(janus.query(&quot;path(a,Y).&quot;))</code></pre></div><br/></div></div><div id="40997299" class="c"><input type="checkbox" id="c-40997299" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40995720">parent</a><span>|</span><a href="#40996177">prev</a><span>|</span><a href="#40996060">next</a><span>|</span><label class="collapse" for="c-40997299">[-]</label><label class="expand" for="c-40997299">[1 more]</label></div><br/><div class="children"><div class="content">On the topic of multi-paradigm programming, including logic programming, Oz&#x2F;Mozart is an obligatory mention. See CTM and <a href="http:&#x2F;&#x2F;mozart2.org&#x2F;mozart-v1&#x2F;doc-1.4.0&#x2F;tutorial&#x2F;index.html" rel="nofollow">http:&#x2F;&#x2F;mozart2.org&#x2F;mozart-v1&#x2F;doc-1.4.0&#x2F;tutorial&#x2F;index.html</a>.<p>The authors were fairly prominent Prolog researchers. It&#x27;s sad Van Roy is retiring and nobody is taking this forward. AliceML, a StandardML dialect inspired by Oz is also abandonware.</div><br/></div></div><div id="40996060" class="c"><input type="checkbox" id="c-40996060" checked=""/><div class="controls bullet"><span class="by">mark_l_watson</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40995720">parent</a><span>|</span><a href="#40997299">prev</a><span>|</span><a href="#40995889">next</a><span>|</span><label class="collapse" for="c-40996060">[-]</label><label class="expand" for="c-40996060">[1 more]</label></div><br/><div class="children"><div class="content">Hey, thanks! That looks cool.</div><br/></div></div></div></div><div id="40995889" class="c"><input type="checkbox" id="c-40995889" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40995476">parent</a><span>|</span><a href="#40995720">prev</a><span>|</span><a href="#40994897">next</a><span>|</span><label class="collapse" for="c-40995889">[-]</label><label class="expand" for="c-40995889">[7 more]</label></div><br/><div class="children"><div class="content">How do you normally use Prolog and Python together? I had looked into embedding logic programming within Python in the past, and found a lack of satisfying options, but maybe I didn&#x27;t know where to look.</div><br/><div id="40996050" class="c"><input type="checkbox" id="c-40996050" checked=""/><div class="controls bullet"><span class="by">mark_l_watson</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40995889">parent</a><span>|</span><a href="#40994897">next</a><span>|</span><label class="collapse" for="c-40996050">[-]</label><label class="expand" for="c-40996050">[6 more]</label></div><br/><div class="children"><div class="content">I have two short examples in one of my books that I am currently re-writing. Here is a link directly to the Python+ Prolog interop examples <a href="https:&#x2F;&#x2F;leanpub.com&#x2F;pythonai&#x2F;read#use-predicate-logic-by-calling-swi-prolog" rel="nofollow">https:&#x2F;&#x2F;leanpub.com&#x2F;pythonai&#x2F;read#use-predicate-logic-by-cal...</a></div><br/><div id="40996787" class="c"><input type="checkbox" id="c-40996787" checked=""/><div class="controls bullet"><span class="by">networked</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40996050">parent</a><span>|</span><a href="#41000196">next</a><span>|</span><label class="collapse" for="c-40996787">[-]</label><label class="expand" for="c-40996787">[4 more]</label></div><br/><div class="children"><div class="content">Thanks for the link.
I have played with PySwip (<a href="https:&#x2F;&#x2F;github.com&#x2F;yuce&#x2F;pyswip">https:&#x2F;&#x2F;github.com&#x2F;yuce&#x2F;pyswip</a>),
and the MQI looks like a more maintainable approach to integrating SWI-Prolog with Python (<a href="https:&#x2F;&#x2F;github.com&#x2F;SWI-Prolog&#x2F;packages-mqi">https:&#x2F;&#x2F;github.com&#x2F;SWI-Prolog&#x2F;packages-mqi</a>).<p>The biggest source of friction I noticed when playing with PySwip was that because Prolog code was represented as strings, you avoided generating it on the fly.
It would be nice to have an embedded DSL for Prolog in Python.
(I am thinking something like SymPy or the Pony ORM—<a href="https:&#x2F;&#x2F;github.com&#x2F;ponyorm&#x2F;pony">https:&#x2F;&#x2F;github.com&#x2F;ponyorm&#x2F;pony</a>.)</div><br/><div id="41002392" class="c"><input type="checkbox" id="c-41002392" checked=""/><div class="controls bullet"><span class="by">NegativeLatency</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40996787">parent</a><span>|</span><a href="#40999509">next</a><span>|</span><label class="collapse" for="c-41002392">[-]</label><label class="expand" for="c-41002392">[1 more]</label></div><br/><div class="children"><div class="content">Don’t go looking at pony’s source code for inspiration. The api is neat but when your app starts to get complicated it begins to not work well.</div><br/></div></div><div id="40999509" class="c"><input type="checkbox" id="c-40999509" checked=""/><div class="controls bullet"><span class="by">nickswalker</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40996787">parent</a><span>|</span><a href="#41002392">prev</a><span>|</span><a href="#41000196">next</a><span>|</span><label class="collapse" for="c-40999509">[-]</label><label class="expand" for="c-40999509">[2 more]</label></div><br/><div class="children"><div class="content">I noticed the same friction while trying to integrate Answer Set Programming solvers into Python projects. The people who built the dominant ASP solver actually provide nice solutions though. Possible inspiration for Prolog tooling:<p>Clorm (Clingo ORM) [1] makes it easy to create facts after you define simple predicate Python classes. Here&#x27;s an example project of mine which uses it to set up a scheduling problem (Python -&gt; ASP) and to present the results (ASP -&gt; Python).<p><a href="https:&#x2F;&#x2F;github.com&#x2F;raceconditionrunning&#x2F;relay-scheduler">https:&#x2F;&#x2F;github.com&#x2F;raceconditionrunning&#x2F;relay-scheduler</a><p>Clingo (the solver) exposes its internal AST implementation through Python bindings[2], so you can build up rules or other statements from typed components instead of strings. This simplifies the translation bits of implementing an ORM or whatever kind of wrapper a developer would prefer.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;potassco&#x2F;clorm">https:&#x2F;&#x2F;github.com&#x2F;potassco&#x2F;clorm</a>
[2] <a href="https:&#x2F;&#x2F;potassco.org&#x2F;clingo&#x2F;python-api&#x2F;current&#x2F;clingo&#x2F;ast.html" rel="nofollow">https:&#x2F;&#x2F;potassco.org&#x2F;clingo&#x2F;python-api&#x2F;current&#x2F;clingo&#x2F;ast.ht...</a></div><br/><div id="41002626" class="c"><input type="checkbox" id="c-41002626" checked=""/><div class="controls bullet"><span class="by">networked</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40999509">parent</a><span>|</span><a href="#41000196">next</a><span>|</span><label class="collapse" for="c-41002626">[-]</label><label class="expand" for="c-41002626">[1 more]</label></div><br/><div class="children"><div class="content">This is cool! I am glad to see that other people have thought in the same direction—and actually wrote the code. I have another reason to learn ASP.</div><br/></div></div></div></div></div></div><div id="41000196" class="c"><input type="checkbox" id="c-41000196" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40996050">parent</a><span>|</span><a href="#40996787">prev</a><span>|</span><a href="#40994897">next</a><span>|</span><label class="collapse" for="c-41000196">[-]</label><label class="expand" for="c-41000196">[1 more]</label></div><br/><div class="children"><div class="content">Thank you!</div><br/></div></div></div></div></div></div></div></div><div id="40994897" class="c"><input type="checkbox" id="c-40994897" checked=""/><div class="controls bullet"><span class="by">overclock351</span><span>|</span><a href="#40994816">parent</a><span>|</span><a href="#40995476">prev</a><span>|</span><a href="#40995255">next</a><span>|</span><label class="collapse" for="c-40994897">[-]</label><label class="expand" for="c-40994897">[13 more]</label></div><br/><div class="children"><div class="content">Do you have any papers comparing Scryer with other prolog systems (like SWI-prolog or SICStus prolog) performance-wise ?</div><br/><div id="40994996" class="c"><input type="checkbox" id="c-40994996" checked=""/><div class="controls bullet"><span class="by">jodrellblank</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40994897">parent</a><span>|</span><a href="#40995255">next</a><span>|</span><label class="collapse" for="c-40994996">[-]</label><label class="expand" for="c-40994996">[12 more]</label></div><br/><div class="children"><div class="content">There are some benchmarks here of SWI Prolog&#x27;s benchmark suite on diffrent Prolog systems by Jan Wielemaker the SWI Prolog author:<p><a href="https:&#x2F;&#x2F;swi-prolog.discourse.group&#x2F;t&#x2F;porting-the-swi-prolog-benchmark-suite-comparing-8-prolog-systems&#x2F;6997#the-modern-systems-vs-swi-prolog-2" rel="nofollow">https:&#x2F;&#x2F;swi-prolog.discourse.group&#x2F;t&#x2F;porting-the-swi-prolog-...</a><p>He finds Scryer performs worse, which he does comment on, he also explains some tradeoffs and historic choices in SWI&#x27;s design which affects its performance. I think I have seen the author of Scryer saying that&#x27;s not surprising and Scryer is still building up core functionality where SWI has had 30+ years to optimise, but I don&#x27;t remember where I read that.<p>SWI has a document explaining some strengths and weaknesses regarding performance: <a href="https:&#x2F;&#x2F;www.swi-prolog.org&#x2F;pldoc&#x2F;man?section=swiorother" rel="nofollow">https:&#x2F;&#x2F;www.swi-prolog.org&#x2F;pldoc&#x2F;man?section=swiorother</a><p>Edit: some discussion on Scryer previously on HN: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28966133">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28966133</a></div><br/><div id="40995627" class="c"><input type="checkbox" id="c-40995627" checked=""/><div class="controls bullet"><span class="by">jfmc</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40994996">parent</a><span>|</span><a href="#40996314">next</a><span>|</span><label class="collapse" for="c-40995627">[-]</label><label class="expand" for="c-40995627">[1 more]</label></div><br/><div class="children"><div class="content">Another table (in the same thread) comparing more systems: <a href="https:&#x2F;&#x2F;swi-prolog.discourse.group&#x2F;t&#x2F;porting-the-swi-prolog-benchmark-suite-comparing-8-prolog-systems&#x2F;6997&#x2F;31" rel="nofollow">https:&#x2F;&#x2F;swi-prolog.discourse.group&#x2F;t&#x2F;porting-the-swi-prolog-...</a></div><br/></div></div><div id="40996314" class="c"><input type="checkbox" id="c-40996314" checked=""/><div class="controls bullet"><span class="by">b800h</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40994996">parent</a><span>|</span><a href="#40995627">prev</a><span>|</span><a href="#40995255">next</a><span>|</span><label class="collapse" for="c-40996314">[-]</label><label class="expand" for="c-40996314">[10 more]</label></div><br/><div class="children"><div class="content">So SWI appears to be more performant, it has an open license, so as per the GGP&#x27;s claim regarding Scryer in the post above, it must not be ISO-compliant?</div><br/><div id="40996543" class="c"><input type="checkbox" id="c-40996543" checked=""/><div class="controls bullet"><span class="by">jodrellblank</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40996314">parent</a><span>|</span><a href="#40998667">next</a><span>|</span><label class="collapse" for="c-40996543">[-]</label><label class="expand" for="c-40996543">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s right; comedian Emo Phillips had a bit about it:<p>&quot;Once I saw this guy on a bridge about to jump. I said, &quot;Don&#x27;t do it!&quot; He said, &quot;Nobody understand me.&quot; I said, &quot;What&#x27;s so special about you?&quot;<p>He said, &quot;I&#x27;m a computer guy.&quot; I said, &quot;Me too! Desktop, tablet, console, smartphone?&quot; He said &quot;Desktop, mostly&quot;, I said &quot;Me, too! Mac, Linux or Windows?&quot; He said, &quot;Any, I&#x27;m a programmer.&quot; I said, &quot;Me, too! which style? OOP, Imperative, Functional, Logic, Array, Stack&quot; He said, &quot;Logic.&quot; I said, &quot;Me, too! What subset? Answer Set Programming, Abductive Programming, Prolog, Datalog?&quot; He said, &quot;Prolog.&quot; I said, &quot;Me, too! Conformant with the ISO&#x2F;IEC 13211-1:1995 (core) standard term syntax for the period character or non-conformant extention decried by members of the ISO&#x2F;IEC JTC1 SC22 WG17 working group?&quot;<p>He said, &quot;SWI Prolog 7&quot; I said, &quot;Die, heretic!&quot; And I pushed him over.&quot;<p>- <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26624442">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26624442</a><p>or read more seriously here:<p>- <a href="https:&#x2F;&#x2F;www.complang.tuwien.ac.at&#x2F;ulrich&#x2F;iso-prolog&#x2F;SWI7_and_ISO" rel="nofollow">https:&#x2F;&#x2F;www.complang.tuwien.ac.at&#x2F;ulrich&#x2F;iso-prolog&#x2F;SWI7_and...</a></div><br/><div id="40997170" class="c"><input type="checkbox" id="c-40997170" checked=""/><div class="controls bullet"><span class="by">rlupi</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40996543">parent</a><span>|</span><a href="#40998667">next</a><span>|</span><label class="collapse" for="c-40997170">[-]</label><label class="expand" for="c-40997170">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t help.<p>&gt; &quot;Once I saw this guy on a bridge about to jump. I said, &quot;Don&#x27;t do it!&quot; He said, &quot;Nobody understand me.&quot; I said, &quot;What&#x27;s so special about you?&quot;<p>He said: &quot;I don&#x27;t want to jump&quot;.</div><br/></div></div></div></div><div id="40998667" class="c"><input type="checkbox" id="c-40998667" checked=""/><div class="controls bullet"><span class="by">triska</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40996314">parent</a><span>|</span><a href="#40996543">prev</a><span>|</span><a href="#40996907">next</a><span>|</span><label class="collapse" for="c-40998667">[-]</label><label class="expand" for="c-40998667">[5 more]</label></div><br/><div class="children"><div class="content">A key performance attraction of Scryer Prolog is its <i>space</i> efficiency for representing lists of characters, yielding a 24 <i>times</i> (!) more compact representation than a naive implementation would.<p>With Scryer Prolog and other recent systems that implement this representation, such as Trealla Prolog, we can easily process many GBs of text with DCGs, arguably realizing the full potential of the originally intended use case of Prolog for the first time. Trealla Prolog goes even further already, and allows overhead-free processing of files, using the system-call mmap(2) to virtually map files to memory, delegating the mapping to the operating system instead of the Prolog system.<p>The linked benchmarks do not test these aspects at all, and in addition use a version of Scryer Prolog that was completely outdated already at the time the benchmarks were made: The benchmarks use Scryer Prolog v0.8.127, which was tagged in August 2020, more than 3 <i>years</i> (!) before the benchmarks were posted. The linked benchmarks thus ignore more than 3 years of development of a system that was at that time 7 years old. Newer versions of Scryer Prolog perform much better due to many improvements that have since been applied. More than 1700 commits were applied between these dates.<p>In the face of the 24-<i>fold</i> reduction of memory use that the above-mentioned efficient string representation enables, small factors of difference in speed between different systems are in my opinion barely worth mentioning at all in any direction.<p>And yes, in addition to this great space efficiency, the strong ISO conformance of Scryer Prolog is also a major attraction especially when using it in highly regulated areas. For example, here is a recently envisaged application of Scryer Prolog in the context of machine protection systems (MPS) of giant particle accelerators, where adherence to industry standards is of great importance for warranty reasons among others:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;mthom&#x2F;scryer-prolog&#x2F;discussions&#x2F;2441">https:&#x2F;&#x2F;github.com&#x2F;mthom&#x2F;scryer-prolog&#x2F;discussions&#x2F;2441</a><p>As another example, a medical application of Scryer Prolog, in the highly regulated domain of oncology trial design:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;mthom&#x2F;scryer-prolog&#x2F;discussions&#x2F;2332">https:&#x2F;&#x2F;github.com&#x2F;mthom&#x2F;scryer-prolog&#x2F;discussions&#x2F;2332</a><p>Here is an overview of syntactic ISO conformance of different Prolog systems:<p><a href="https:&#x2F;&#x2F;www.complang.tuwien.ac.at&#x2F;ulrich&#x2F;iso-prolog&#x2F;conformity_testing" rel="nofollow">https:&#x2F;&#x2F;www.complang.tuwien.ac.at&#x2F;ulrich&#x2F;iso-prolog&#x2F;conformi...</a></div><br/><div id="40999741" class="c"><input type="checkbox" id="c-40999741" checked=""/><div class="controls bullet"><span class="by">derdi</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40998667">parent</a><span>|</span><a href="#40996907">next</a><span>|</span><label class="collapse" for="c-40999741">[-]</label><label class="expand" for="c-40999741">[4 more]</label></div><br/><div class="children"><div class="content">&gt; adherence to industry standards is of great importance for warranty reasons among others<p>This is mostly a nice talking point rather than an actual thing, right? Scryer&#x27;s license contains the usual all-caps NO WARRANTY and NO FITNESS FOR A PARTICULAR PURPOSE wording. Also, the links you provided describe these applications without references to warranties and standards and regulation. The users in these super-sensitive domains don&#x27;t seem as sensitive about them as you claim.</div><br/><div id="40999885" class="c"><input type="checkbox" id="c-40999885" checked=""/><div class="controls bullet"><span class="by">triska</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40999741">parent</a><span>|</span><a href="#40996907">next</a><span>|</span><label class="collapse" for="c-40999885">[-]</label><label class="expand" for="c-40999885">[3 more]</label></div><br/><div class="children"><div class="content">&gt; the links you provided describe these applications without references to warranties and standards and regulation.<p>This is not true. For example, quoting from page 2 of the paper that is linked to in a discussion I posted, <i>An Executable Specification of Oncology Dose-Escalation Protocols with Prolog</i>, available from <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2402.08334" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2402.08334</a>:<p><i>&quot;Standards are of great importance in the medical sector and play a significant role in procurement decisions, resolution of legal disputes, warranty questions, and the preparation of teaching material. It is to be expected that the use of an ISO-standardized programming language will enable the broadest possible adoption of our approach in such a safety-critical application area. For these reasons, we are using Scryer Prolog for our application. Scryer Prolog is a modern Prolog system written in Rust that aims for strict conformance to the Prolog ISO standard and satisfies all syntactic conformity tests given in <a href="https:&#x2F;&#x2F;www.complang.tuwien.ac.at&#x2F;ulrich&#x2F;iso-prolog&#x2F;conformity_testing" rel="nofollow">https:&#x2F;&#x2F;www.complang.tuwien.ac.at&#x2F;ulrich&#x2F;iso-prolog&#x2F;conformi...</a>.&quot;</i><p>Regarding warranty guarantees of Scryer Prolog, may I suggest you contact its author if you need to negotiate arrangements that are not catered for by the only licence terms you currently have access to?<p>One important advantage you get from the strict syntactic conformance of Scryer Prolog is that it reliably tells you what is Prolog syntax and what is not. In this way, you can use it as a free reference system to learn what Prolog is. The conformance makes it easier to switch to other conforming systems, such as SICStus Prolog which also offers different licences and commercial support, when you need to.<p>&gt; The users in these super-sensitive domains don&#x27;t seem as sensitive about them as you claim.<p>I am at a loss at this phrasing and also about the content of this text. Apart from the facts that I did not use the wording &quot;super-sensitive&quot;, and that the importance of standards is explicitly stated in the paper I quoted above, is there even the slightest doubt about the great importance of standards when building and operating giant particle accelerators or devising dose escalation trials in clinical oncology?</div><br/><div id="41000220" class="c"><input type="checkbox" id="c-41000220" checked=""/><div class="controls bullet"><span class="by">derdi</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40999885">parent</a><span>|</span><a href="#40996907">next</a><span>|</span><label class="collapse" for="c-41000220">[-]</label><label class="expand" for="c-41000220">[2 more]</label></div><br/><div class="children"><div class="content">I acknowledge that you also included your nice talking point in a paper you published on arXiv. Citing yourself doesn&#x27;t convince me any more of the credibility of this argument.<p>&gt; is there even the slightest doubt about the importance of standards when building and operating giant particle accelerators<p>The particle accelerator application is a checker for existing JSON config files. The accelerator is already running with those files. The proposed project is in an early stage. The checker will add more assurance, which is nice. The checker&#x27;s author does not talk about the importance of warranties or standards. The checker could just as well be implemented in some non-ISO dialect as long as that dialect has a reliable specification and implementation.<p>So yes, there is the slightest doubt.<p>Edit: BTW, your oncology paper heavily uses CLP(Z), which does not have an ISO standard, so your argument is... The base language must be standardized, but arbitrary nonstandard extensions are OK? Please clarify as I&#x27;ve probably misunderstood.</div><br/><div id="41002210" class="c"><input type="checkbox" id="c-41002210" checked=""/><div class="controls bullet"><span class="by">triska</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#41000220">parent</a><span>|</span><a href="#40996907">next</a><span>|</span><label class="collapse" for="c-41002210">[-]</label><label class="expand" for="c-41002210">[1 more]</label></div><br/><div class="children"><div class="content">&gt; CLP(Z), which does not have an ISO standard<p>CLP(FD&#x2F;Z) is a candidate for inclusion in the Prolog standard: Several Prolog systems provide it with notable commonalities in features, it fits perfectly into the existing language, and it follows the logic of the standard including its error system. It can even be implemented within Prolog, provided a few basic features are present in a Prolog system. For instance, the CLP(Z) system I provide and which is used in the paper runs with little modifications already in several different Prolog systems, including SICStus, Scryer and Trealla. CLP(FD&#x2F;Z) is an admissible <i>extension</i> of the existing standard:<p><pre><code>    5.5 Extensions

    A processor may support, as an implementation specific
    feature, any construct that is implicitly or explicitly
    undefined in the part of ISO&#x2F;IEC 13211.
</code></pre>
This is completely different from <i>modifications</i> of the standard that do not fit at all into the standard. For instance, interpreting double-quoted strings differently from what the standard prescribes is <i>not</i> an extension in the sense the standard defines it, but a <i>modification</i> of the standard.<p>In addition, Scryer Prolog has an execution mode where all its extensions are turned off. This is called a <i>strictly conforming mode</i>, and is also prescribed by the standard:<p><pre><code>    5 Compliance

    5.1 Prolog processor

    A conforming Prolog processor shall:

      ...

      e) Offer a strictly conforming mode which shall reject
      the use of an implementation specific feature in Prolog
      text or while executing a goal.
</code></pre>
In Scryer Prolog, the strictly conforming mode is the default execution mode.<p>Regarding the other points you mention: Even though it may sound easy to say &quot;as long as that dialect has a reliable specification and implementation&quot;, I know no such system that exists, and what I see from systems that do not adhere to the Prolog standard makes me doubt that such a thing is possible. The systems that do not follow the standard often have elementary syntactic problems, such as reading a Prolog term that they themselves emit into a <i>different</i> Prolog term, a recipe for disaster and unacceptable in every domain I know.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40996509" class="c"><input type="checkbox" id="c-40996509" checked=""/><div class="controls bullet"><span class="by">derdi</span><span>|</span><a href="#40994816">root</a><span>|</span><a href="#40996314">parent</a><span>|</span><a href="#40996907">prev</a><span>|</span><a href="#40995255">next</a><span>|</span><label class="collapse" for="c-40996509">[-]</label><label class="expand" for="c-40996509">[1 more]</label></div><br/><div class="children"><div class="content">Or maybe the GGP was wrong about performance?<p>Some default settings in SWI are not ISO-compliant (for example, it uses a string type that does not exist in ISO). But these are minor things that won&#x27;t usually trip you up when feeding it ISO code. You can set flags to get it to conform in the way you want. And you <i>should</i> set flags whenever you want your ISO Prolog programs to be portable, because the standard is very lax and leaves a lot of things implementation-defined. But it specifies the flags to get implementations into the state you want.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40995255" class="c"><input type="checkbox" id="c-40995255" checked=""/><div class="controls bullet"><span class="by">gorkempacaci</span><span>|</span><a href="#40994816">prev</a><span>|</span><a href="#40998716">next</a><span>|</span><label class="collapse" for="c-40995255">[-]</label><label class="expand" for="c-40995255">[19 more]</label></div><br/><div class="children"><div class="content">Prolog, and Constraint Programming especially are great to have in your toolbox. I’ve done research in the field for years, and my job in the industry today is writing Prolog. There are real issues with Prolog:<p>- no proper module nor package system in the modern sense.<p>- in large code bases extra-logical constructs (like cuts) are unavoidable and turn Prolog code into an untenable mess. SWI prolog has single-sided unification guards which tackle this to a degree.<p>- lack of static and strong types makes it harder to write robust code. At least some strong typing would have been nice. See Mercury as an example of this.<p>All being said, Prolog is amazing, has a place in the future of programming, and gives you a level-up understanding of programming when you get how the types in every OO program is a Prolog program itself.</div><br/><div id="40996365" class="c"><input type="checkbox" id="c-40996365" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#40995255">parent</a><span>|</span><a href="#40996021">next</a><span>|</span><label class="collapse" for="c-40996365">[-]</label><label class="expand" for="c-40996365">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;d advise to not use Prolog as general-purpose programming language, but as an embedded DSL or as a service for the part it&#x27;s really suited for (if your app involves exploration and search over a large combinatorical space in the first place, such as in discrete optimization in industry, logistics, and finance). You really don&#x27;t need yet another package manager and pointless premature modularization for modelling your business domains in optimization.</div><br/><div id="41000324" class="c"><input type="checkbox" id="c-41000324" checked=""/><div class="controls bullet"><span class="by">Karrot_Kream</span><span>|</span><a href="#40995255">root</a><span>|</span><a href="#40996365">parent</a><span>|</span><a href="#40997390">next</a><span>|</span><label class="collapse" for="c-41000324">[-]</label><label class="expand" for="c-41000324">[3 more]</label></div><br/><div class="children"><div class="content">At this point, why not use one of the many other CP solver packages out there and the layers on top like OR-tools?</div><br/><div id="41003243" class="c"><input type="checkbox" id="c-41003243" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#40995255">root</a><span>|</span><a href="#41000324">parent</a><span>|</span><a href="#41002851">next</a><span>|</span><label class="collapse" for="c-41003243">[-]</label><label class="expand" for="c-41003243">[1 more]</label></div><br/><div class="children"><div class="content">The domain-specific Prolog code bases you&#x27;re going to create still can become large and represent a significant development effort. Prolog being an ISO standard with many conformant (or at least mostly conformant) implementations available and relatively strong mindshare and ecosystem compared to extremely niche &quot;CP solver packages and OR-tools&quot; (which one exactly?) significantly reduces project risks such as not being able to find experts, the system not meeting functional or performance requirements, or becoming obsolete down the road. The same cannot be said for some mythical &quot;CP solver packages and OR-tools&quot;; you&#x27;ve nowhere to go if your &quot;CP solver packages and OR-tools&quot; project fails. Optimization and scheduling&#x2F;planning projects, by their nature, are somewhat experimental and need exploration. It would thus be very difficult to pick &quot;CP solver packages and OR-tools&quot; upfront.</div><br/></div></div><div id="41002851" class="c"><input type="checkbox" id="c-41002851" checked=""/><div class="controls bullet"><span class="by">throwaway3306a</span><span>|</span><a href="#40995255">root</a><span>|</span><a href="#41000324">parent</a><span>|</span><a href="#41003243">prev</a><span>|</span><a href="#40997390">next</a><span>|</span><label class="collapse" for="c-41002851">[-]</label><label class="expand" for="c-41002851">[1 more]</label></div><br/><div class="children"><div class="content">Which one is as developed, as universal and as capable as Prolog with CLP and&#x2F;or DCG?<p>Serious question, I&#x27;d like to have something that&#x27;s easy to integrate with Node.js.</div><br/></div></div></div></div><div id="40997390" class="c"><input type="checkbox" id="c-40997390" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#40995255">root</a><span>|</span><a href="#40996365">parent</a><span>|</span><a href="#41000324">prev</a><span>|</span><a href="#40997358">next</a><span>|</span><label class="collapse" for="c-40997390">[-]</label><label class="expand" for="c-40997390">[2 more]</label></div><br/><div class="children"><div class="content">To me this makes Prolog sound like a tool to reach for similar to SQL.  Specialized language for asking specific kinds of search or query over your data.</div><br/><div id="41002753" class="c"><input type="checkbox" id="c-41002753" checked=""/><div class="controls bullet"><span class="by">gorkempacaci</span><span>|</span><a href="#40995255">root</a><span>|</span><a href="#40997390">parent</a><span>|</span><a href="#40997358">next</a><span>|</span><label class="collapse" for="c-41002753">[-]</label><label class="expand" for="c-41002753">[1 more]</label></div><br/><div class="children"><div class="content">Indeed Prolog programs are also called databases sometimes. Some things Prolog can do over SQL:<p>- infinite data defined by recursive predicates<p>- flexible data structures (think JSON but better, called complex terms) and a way to query them (called unification algorithm)<p>- execution strategy fine-tuned for reasoning (called resolution algorithm). You can do this with SQL but you’d have to formalize things using set operations and it’d be very very slow.<p>On the other hand, SQL can query plain data very very fast.</div><br/></div></div></div></div><div id="40997358" class="c"><input type="checkbox" id="c-40997358" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#40995255">root</a><span>|</span><a href="#40996365">parent</a><span>|</span><a href="#40997390">prev</a><span>|</span><a href="#40996021">next</a><span>|</span><label class="collapse" for="c-40997358">[-]</label><label class="expand" for="c-40997358">[2 more]</label></div><br/><div class="children"><div class="content">I concur, Prolog particularly excels at being an advanced configuration, embeddable DSL that allows one to express system configurations that would otherwise be not easily possible using a bespoke configuration language or a format. I have used an embedded Prolog core to express complex installation configurations in the past with a great success, and I would do it again for the right problem space.</div><br/><div id="40998398" class="c"><input type="checkbox" id="c-40998398" checked=""/><div class="controls bullet"><span class="by">hosh</span><span>|</span><a href="#40995255">root</a><span>|</span><a href="#40997358">parent</a><span>|</span><a href="#40996021">next</a><span>|</span><label class="collapse" for="c-40998398">[-]</label><label class="expand" for="c-40998398">[1 more]</label></div><br/><div class="children"><div class="content">The cluster autoscaler in Kubernetes uses a constraint solver. It&#x27;s translating configuration against dynamic, and changing state within the cluster.<p>Using something like an embedded Prolog or miniKenran as the core of a Kubernetes operator is something I&#x27;ve wanted to try my hands on.</div><br/></div></div></div></div></div></div><div id="40996021" class="c"><input type="checkbox" id="c-40996021" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#40995255">parent</a><span>|</span><a href="#40996365">prev</a><span>|</span><a href="#40996014">next</a><span>|</span><label class="collapse" for="c-40996021">[-]</label><label class="expand" for="c-40996021">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; when you get how the types in every OO program is a Prolog program itself</i><p>&quot;Any sufficiently complicated type system contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Prolog.&quot;</div><br/><div id="40998894" class="c"><input type="checkbox" id="c-40998894" checked=""/><div class="controls bullet"><span class="by">Arch-TK</span><span>|</span><a href="#40995255">root</a><span>|</span><a href="#40996021">parent</a><span>|</span><a href="#40996014">next</a><span>|</span><label class="collapse" for="c-40998894">[-]</label><label class="expand" for="c-40998894">[1 more]</label></div><br/><div class="children"><div class="content">Any sufficiently complex type system is indistinguishable from an esolang.</div><br/></div></div></div></div><div id="40996014" class="c"><input type="checkbox" id="c-40996014" checked=""/><div class="controls bullet"><span class="by">radomir_cernoch</span><span>|</span><a href="#40995255">parent</a><span>|</span><a href="#40996021">prev</a><span>|</span><a href="#40995834">next</a><span>|</span><label class="collapse" for="c-40996014">[-]</label><label class="expand" for="c-40996014">[3 more]</label></div><br/><div class="children"><div class="content">You write Prolog code for a living? Where? Do you happen to have a story to share? I&#x27;m very curious.</div><br/><div id="41002683" class="c"><input type="checkbox" id="c-41002683" checked=""/><div class="controls bullet"><span class="by">gorkempacaci</span><span>|</span><a href="#40995255">root</a><span>|</span><a href="#40996014">parent</a><span>|</span><a href="#41000916">next</a><span>|</span><label class="collapse" for="c-41002683">[-]</label><label class="expand" for="c-41002683">[1 more]</label></div><br/><div class="children"><div class="content">Yes :) we make software that helps sell complex products (If your product has a million options and takes up a whole factory floor you can’t just have a series of dropdowns)</div><br/></div></div><div id="41000916" class="c"><input type="checkbox" id="c-41000916" checked=""/><div class="controls bullet"><span class="by">BJones12</span><span>|</span><a href="#40995255">root</a><span>|</span><a href="#40996014">parent</a><span>|</span><a href="#41002683">prev</a><span>|</span><a href="#40995834">next</a><span>|</span><label class="collapse" for="c-41000916">[-]</label><label class="expand" for="c-41000916">[1 more]</label></div><br/><div class="children"><div class="content">I suspect that his work is related to this: <a href="https:&#x2F;&#x2F;www.tacton.com&#x2F;products&#x2F;tacton-cpq&#x2F;configurator&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.tacton.com&#x2F;products&#x2F;tacton-cpq&#x2F;configurator&#x2F;</a></div><br/></div></div></div></div><div id="40995834" class="c"><input type="checkbox" id="c-40995834" checked=""/><div class="controls bullet"><span class="by">ecshafer</span><span>|</span><a href="#40995255">parent</a><span>|</span><a href="#40996014">prev</a><span>|</span><a href="#40995994">next</a><span>|</span><label class="collapse" for="c-40995834">[-]</label><label class="expand" for="c-40995834">[1 more]</label></div><br/><div class="children"><div class="content">There are a lot of problems that Prolog &#x2F; Constrain programming will solve very elegantly, and much more easily than imperative languages. I think constraint based programming is seriously under used in the industry, and too many programmers are unaware or unable to write constraint based code. I have always hoped to have just a constrain based programming subsystem in a lot of languages, for those niche cases.</div><br/></div></div><div id="40995994" class="c"><input type="checkbox" id="c-40995994" checked=""/><div class="controls bullet"><span class="by">ToucanLoucan</span><span>|</span><a href="#40995255">parent</a><span>|</span><a href="#40995834">prev</a><span>|</span><a href="#40998716">next</a><span>|</span><label class="collapse" for="c-40995994">[-]</label><label class="expand" for="c-40995994">[4 more]</label></div><br/><div class="children"><div class="content">Maybe it&#x27;s just me but I see a lack of a package manager as a massive, massive pro. I can&#x27;t stand how seemingly every language has a package manager which requires it&#x27;s own installation and you have to learn how to use THAT thing and then you need some library off github that does some minor task really well but you can&#x27;t just download the fucking code, you have to import it via, idk, the Fork-Lyft manager which requires Python 3.3 and the PillJump framework and it&#x27;s just like, I just want a fucking function to parse JSON, I don&#x27;t want to saddle my system with 600 MB of shit I don&#x27;t need.<p>Old_man_yells_at_cloud.jpg</div><br/><div id="40996199" class="c"><input type="checkbox" id="c-40996199" checked=""/><div class="controls bullet"><span class="by">phailhaus</span><span>|</span><a href="#40995255">root</a><span>|</span><a href="#40995994">parent</a><span>|</span><a href="#41000471">next</a><span>|</span><label class="collapse" for="c-40996199">[-]</label><label class="expand" for="c-40996199">[1 more]</label></div><br/><div class="children"><div class="content">You can always just download the code, nobody&#x27;s forcing you to use a package manager. It just turns out that unless you want to spend most of your life building and fixing other people&#x27;s code, it&#x27;s much easier to use the package manager. The inefficiency is the price we pay, but it&#x27;s worth it.</div><br/></div></div><div id="41000471" class="c"><input type="checkbox" id="c-41000471" checked=""/><div class="controls bullet"><span class="by">duranga1234</span><span>|</span><a href="#40995255">root</a><span>|</span><a href="#40995994">parent</a><span>|</span><a href="#40996199">prev</a><span>|</span><a href="#40996408">next</a><span>|</span><label class="collapse" for="c-41000471">[-]</label><label class="expand" for="c-41000471">[1 more]</label></div><br/><div class="children"><div class="content">Me too! I absolutely see a lack of package manager as a pro. I also hate to saddle anything with 600MB I don&#x27;t need. 100% agree.<p>I would go as far as to say that Prolog is more a problem solving language rather than a system building language. Package managers and module systems are for modularization of big systems. You don&#x27;t need that when solving small recurrent problems. Furthermore, lack of them forces you to avoid dependencies, that most of the time would end as technical debt. IMHO.</div><br/></div></div><div id="40996408" class="c"><input type="checkbox" id="c-40996408" checked=""/><div class="controls bullet"><span class="by">qu1j0t3</span><span>|</span><a href="#40995255">root</a><span>|</span><a href="#40995994">parent</a><span>|</span><a href="#41000471">prev</a><span>|</span><a href="#40998716">next</a><span>|</span><label class="collapse" for="c-40996408">[-]</label><label class="expand" for="c-40996408">[1 more]</label></div><br/><div class="children"><div class="content">don&#x27;t confuse &quot;module system&quot; with &quot;package manager&quot;</div><br/></div></div></div></div></div></div><div id="40998716" class="c"><input type="checkbox" id="c-40998716" checked=""/><div class="controls bullet"><span class="by">z5h</span><span>|</span><a href="#40995255">prev</a><span>|</span><a href="#40996001">next</a><span>|</span><label class="collapse" for="c-40998716">[-]</label><label class="expand" for="c-40998716">[1 more]</label></div><br/><div class="children"><div class="content">In theory, Prolog is the king of languages. Simultaneously a logical formalism, and (with a resolution system) a language for computation, AND the ultimate meta-programming language as its homoiconic but only <i>goals</i> are evaluated (there is no eager&#x2F;lazy evaluation fuss - a term is just a term), and goals can only succeed (and have any consequence) if there is already a matching clause.<p>In practice, there are some very performant and maintained implementations with small but helpful communities.<p>Also in practice. With all of this power, it&#x27;s clear that anything could be done (well) in Prolog, but it&#x27;s not always clear what that way might be. DCGs are an example of a beautiful, elegant, simple, powerful way of building parsers (or state machines) that was not immediately evident to the Prolog community for some time. The perpetual conundrum as a user will be &quot;I could do it this way, but there are certainly better ways of doing this, and I have many avenues I could explore, and I don&#x27;t know which might be fruitful in what timeline&quot;.</div><br/></div></div><div id="40996001" class="c"><input type="checkbox" id="c-40996001" checked=""/><div class="controls bullet"><span class="by">grose</span><span>|</span><a href="#40998716">prev</a><span>|</span><a href="#40994674">next</a><span>|</span><label class="collapse" for="c-40996001">[-]</label><label class="expand" for="c-40996001">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s great to hear new people are interested in the language! I was enlightened a couple years ago and fell in love.<p>Currently I&#x27;m focusing on creating easy-to-use embeddings of Trealla Prolog using Wasm. You can find my TypeScript library here: <a href="https:&#x2F;&#x2F;github.com&#x2F;guregu&#x2F;trealla-js">https:&#x2F;&#x2F;github.com&#x2F;guregu&#x2F;trealla-js</a> and Go library here: <a href="https:&#x2F;&#x2F;github.com&#x2F;trealla-prolog&#x2F;go">https:&#x2F;&#x2F;github.com&#x2F;trealla-prolog&#x2F;go</a>. The goal is to make the libraries as painless as possible. Trealla is a portable and lightweight Prolog written in C that supports CLP(Z) and is broadly compatible with Scryer. It&#x27;s quite fast! I&#x27;m currently using it for some expert system stuff at $work and as an internet forum embedded scripting language for $fun.<p>Speaking of Scryer, they recently got their WebAssembly build working and I hope to contribute a JS library for them in the future as their API stabilizes. Scryer and Trealla are both aiming for ISO compatibility, so it&#x27;s my hope that we can foster an ecosystem for modern ISO Prolog and provide more embeddings in the future. It&#x27;s super convenient to get logic programmer superpowers in your favorite language. Also check out Scryer&#x27;s new website: <a href="https:&#x2F;&#x2F;www.scryer.pl&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.scryer.pl&#x2F;</a><p>For something on the silly side, check out <a href="https:&#x2F;&#x2F;php.energy" rel="nofollow">https:&#x2F;&#x2F;php.energy</a>. Prolog Home Page, it&#x27;s web scale :-). It&#x27;s proof that you can integrate Prolog with bleeding edge stuff like Spin (server-side wasm ecosystem).</div><br/></div></div><div id="40994674" class="c"><input type="checkbox" id="c-40994674" checked=""/><div class="controls bullet"><span class="by">tomstuart</span><span>|</span><a href="#40996001">prev</a><span>|</span><a href="#40996999">next</a><span>|</span><label class="collapse" for="c-40994674">[-]</label><label class="expand" for="c-40994674">[14 more]</label></div><br/><div class="children"><div class="content">Definitive reference: <a href="https:&#x2F;&#x2F;www.urbanautomaton.com&#x2F;blog&#x2F;2015&#x2F;08&#x2F;10&#x2F;the-pledge-to-put-prolog-in-production&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.urbanautomaton.com&#x2F;blog&#x2F;2015&#x2F;08&#x2F;10&#x2F;the-pledge-to...</a></div><br/><div id="40999110" class="c"><input type="checkbox" id="c-40999110" checked=""/><div class="controls bullet"><span class="by">Suppafly</span><span>|</span><a href="#40994674">parent</a><span>|</span><a href="#40995935">next</a><span>|</span><label class="collapse" for="c-40999110">[-]</label><label class="expand" for="c-40999110">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Q: What if Prolog is not suitable for my employer’s problem domain?<p>&gt;<p>&gt;Prolog is not suitable for any problem domain, although this is more readily apparent for some domains than others.<p>At least they are honest about it LOL</div><br/></div></div><div id="40995935" class="c"><input type="checkbox" id="c-40995935" checked=""/><div class="controls bullet"><span class="by">drmeister</span><span>|</span><a href="#40994674">parent</a><span>|</span><a href="#40999110">prev</a><span>|</span><a href="#40995106">next</a><span>|</span><label class="collapse" for="c-40995935">[-]</label><label class="expand" for="c-40995935">[2 more]</label></div><br/><div class="children"><div class="content">Dang, substitute Lisp for Prolog and this describes me.  Seriously though - Prolog is an awesome tool to have in your toolbox. I&#x27;ve implemented Prolog-like logic programming solutions in several places in my 40+ years of programming. Like rules for assigning molecular mechanics force field atom types.</div><br/><div id="40996127" class="c"><input type="checkbox" id="c-40996127" checked=""/><div class="controls bullet"><span class="by">infinite8s</span><span>|</span><a href="#40994674">root</a><span>|</span><a href="#40995935">parent</a><span>|</span><a href="#40995106">next</a><span>|</span><label class="collapse" for="c-40996127">[-]</label><label class="expand" for="c-40996127">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Like rules for assigning molecular mechanics force field atom types.<p>Can you describe a bit more how prolog helped you here? Thanks!</div><br/></div></div></div></div><div id="40995106" class="c"><input type="checkbox" id="c-40995106" checked=""/><div class="controls bullet"><span class="by">nickpeterson</span><span>|</span><a href="#40994674">parent</a><span>|</span><a href="#40995935">prev</a><span>|</span><a href="#40994707">next</a><span>|</span><label class="collapse" for="c-40995106">[-]</label><label class="expand" for="c-40995106">[1 more]</label></div><br/><div class="children"><div class="content">I only have one thing to say to this man, “hey! Quit stealing my moves!”</div><br/></div></div><div id="40994707" class="c"><input type="checkbox" id="c-40994707" checked=""/><div class="controls bullet"><span class="by">overclock351</span><span>|</span><a href="#40994674">parent</a><span>|</span><a href="#40995106">prev</a><span>|</span><a href="#40995175">next</a><span>|</span><label class="collapse" for="c-40994707">[-]</label><label class="expand" for="c-40994707">[2 more]</label></div><br/><div class="children"><div class="content">Looks fun :D, i think that if i ask my manager to build something out of Prolog i would probably get stab... i mean fired since most of us work in OOP. 
I would love to be that insane one asking for that :D.</div><br/><div id="40994953" class="c"><input type="checkbox" id="c-40994953" checked=""/><div class="controls bullet"><span class="by">Avshalom</span><span>|</span><a href="#40994674">root</a><span>|</span><a href="#40994707">parent</a><span>|</span><a href="#40995175">next</a><span>|</span><label class="collapse" for="c-40994953">[-]</label><label class="expand" for="c-40994953">[1 more]</label></div><br/><div class="children"><div class="content">You can use <a href="https:&#x2F;&#x2F;logtalk.org" rel="nofollow">https:&#x2F;&#x2F;logtalk.org</a> for oop in Prolog, use it on top of SWI and you have bidirectional bridges to Python an Java<p><a href="https:&#x2F;&#x2F;www.swi-prolog.org&#x2F;FAQ&#x2F;Python.md" rel="nofollow">https:&#x2F;&#x2F;www.swi-prolog.org&#x2F;FAQ&#x2F;Python.md</a><p><a href="https:&#x2F;&#x2F;www.swi-prolog.org&#x2F;pldoc&#x2F;doc_for?object=section(%27packages&#x2F;jpl.html%27)" rel="nofollow">https:&#x2F;&#x2F;www.swi-prolog.org&#x2F;pldoc&#x2F;doc_for?object=section(%27p...</a></div><br/></div></div></div></div><div id="40995175" class="c"><input type="checkbox" id="c-40995175" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#40994674">parent</a><span>|</span><a href="#40994707">prev</a><span>|</span><a href="#40994907">next</a><span>|</span><label class="collapse" for="c-40995175">[-]</label><label class="expand" for="c-40995175">[2 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s an official production system you want, then use OPS-5, not Prolog!<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;OPS5" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;OPS5</a><p>&gt;OPS5 is a rule-based or production system computer language, notable as the first such language to be used in a successful expert system, the R1&#x2F;XCON system used to configure VAX computers.<p>&gt;The OPS (said to be short for &quot;Official Production System&quot;) family was developed in the late 1970s by Charles Forgy while at Carnegie Mellon University. Allen Newell&#x27;s research group in artificial intelligence had been working on production systems for some time, but Forgy&#x27;s implementation, based on his Rete algorithm, was especially efficient, sufficiently so that it was possible to scale up to larger problems involving hundreds or thousands of rules.</div><br/><div id="40998286" class="c"><input type="checkbox" id="c-40998286" checked=""/><div class="controls bullet"><span class="by">wduquette</span><span>|</span><a href="#40994674">root</a><span>|</span><a href="#40995175">parent</a><span>|</span><a href="#40994907">next</a><span>|</span><label class="collapse" for="c-40998286">[-]</label><label class="expand" for="c-40998286">[1 more]</label></div><br/><div class="children"><div class="content">I used DEC&#x27;s VAX OPS5 for a couple years about around 1990.  I quite liked it, and the later versions had some really nice extensions over Forgy&#x27;s original design.<p>Then we discovered that our particular rule base could easily be ported into C using a sequence of nested if&#x2F;thens that ran <i>much</i> faster, and we stopped using OPS5.  It was a great tool for doing the initial development, though.</div><br/></div></div></div></div><div id="40994907" class="c"><input type="checkbox" id="c-40994907" checked=""/><div class="controls bullet"><span class="by">chx</span><span>|</span><a href="#40994674">parent</a><span>|</span><a href="#40995175">prev</a><span>|</span><a href="#40996999">next</a><span>|</span><label class="collapse" for="c-40994907">[-]</label><label class="expand" for="c-40994907">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Prolog is not suitable for any problem domain, although this is more readily apparent for some domains than others.<p>Fuckin&#x27; A.</div><br/><div id="40996240" class="c"><input type="checkbox" id="c-40996240" checked=""/><div class="controls bullet"><span class="by">jjtheblunt</span><span>|</span><a href="#40994674">root</a><span>|</span><a href="#40994907">parent</a><span>|</span><a href="#40996999">next</a><span>|</span><label class="collapse" for="c-40996240">[-]</label><label class="expand" for="c-40996240">[4 more]</label></div><br/><div class="children"><div class="content">what does that mean?</div><br/><div id="40997327" class="c"><input type="checkbox" id="c-40997327" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#40994674">root</a><span>|</span><a href="#40996240">parent</a><span>|</span><a href="#40996999">next</a><span>|</span><label class="collapse" for="c-40997327">[-]</label><label class="expand" for="c-40997327">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an except from the article. Getting an explanation out of context is worthless.</div><br/><div id="41000517" class="c"><input type="checkbox" id="c-41000517" checked=""/><div class="controls bullet"><span class="by">jjtheblunt</span><span>|</span><a href="#40994674">root</a><span>|</span><a href="#40997327">parent</a><span>|</span><a href="#40996999">next</a><span>|</span><label class="collapse" for="c-41000517">[-]</label><label class="expand" for="c-41000517">[2 more]</label></div><br/><div class="children"><div class="content">Excerpt from what article?  (edit:  i see you&#x27;re referring to the indented quote from the article, but i was asking what the &quot;fuckin a.&quot; thing meant.)</div><br/><div id="41000691" class="c"><input type="checkbox" id="c-41000691" checked=""/><div class="controls bullet"><span class="by">mkl</span><span>|</span><a href="#40994674">root</a><span>|</span><a href="#41000517">parent</a><span>|</span><a href="#40996999">next</a><span>|</span><label class="collapse" for="c-41000691">[-]</label><label class="expand" for="c-41000691">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.urbandictionary.com&#x2F;define.php?term=fucking%20a" rel="nofollow">https:&#x2F;&#x2F;www.urbandictionary.com&#x2F;define.php?term=fucking%20a</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40996999" class="c"><input type="checkbox" id="c-40996999" checked=""/><div class="controls bullet"><span class="by">jodrellblank</span><span>|</span><a href="#40994674">prev</a><span>|</span><a href="#40995918">next</a><span>|</span><label class="collapse" for="c-40996999">[-]</label><label class="expand" for="c-40996999">[39 more]</label></div><br/><div class="children"><div class="content">What is it like? 50 years of historic cruft. Questionable whether there are more trip hazards than usefulness for ordinary coding. A fractured community which feels like there are more Prolog systems than Prolog code. Learning Prolog is less &quot;how do I do things in Prolog&quot; and more &quot;how do I contort my things to avoid tripping over Prolog?&quot;.<p>A few dedicated clever people and idealists and dreamers talking about ontologies and building things I don&#x27;t understand, e.g. the link in <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40994780">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40994780</a> that could either be genuinely &quot;Prolog is suitable for things no other language is&quot; or &quot;Fusion is 10 years away&quot; or &quot;Perpetual motion is here and so is cold fusion!&quot;, I can&#x27;t tell. But I suspect from the lack of visible activity out in the wider world, closer to the latter than the former. Or perhaps the people able to make use of its strengths are few and far between.<p>There&#x27;s a saying about driving to a town which has been hollowed out and is now a road through some empty store fronts and car parks: &quot;there&#x27;s no <i>there</i> there&quot;. The soul of a place is missing, it&#x27;s no longer a <i>destination</i>, just some buildings on some land. Prolog has the opposite of that, a main road straight past it, few buildings or people, but there is a <i>there</i> there - an attractor, spark of something interesting and fun. Buried in years of cruft. Might be a Siren&#x27;s call though, a trap - but if it is it appears less dangerous than the LISP one.</div><br/><div id="40997798" class="c"><input type="checkbox" id="c-40997798" checked=""/><div class="controls bullet"><span class="by">everforward</span><span>|</span><a href="#40996999">parent</a><span>|</span><a href="#40997220">next</a><span>|</span><label class="collapse" for="c-40997798">[-]</label><label class="expand" for="c-40997798">[14 more]</label></div><br/><div class="children"><div class="content">&gt; A few dedicated clever people and idealists and dreamers talking about ontologies and building things I don&#x27;t understand<p>I was briefly deeply interested in ontologies via OWL and I suspect Prolog has the same issues that I think plague ontologies in general.<p>They are a fantastic tool for a system complex enough to be nearly useless. Modelling an ontology for a reasonably complex domain is unreasonably difficult. Not because the tools are bad, but because trying to define concrete boundaries around abstract ideas is hard.<p>What is a camera? A naive attempt would say an item that takes pictures, but that would include X-rays. Are deep-space radio telescopes cameras? Trying to fix those issues then causes second order issues; you can say it’s something that takes images from the visible light spectrum, but then night vision cameras aren’t cameras anymore.<p>The reasoning systems work well, they just don’t solve the hard part of designing the model.</div><br/><div id="40998812" class="c"><input type="checkbox" id="c-40998812" checked=""/><div class="controls bullet"><span class="by">strangattractor</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40997798">parent</a><span>|</span><a href="#40999036">next</a><span>|</span><label class="collapse" for="c-40998812">[-]</label><label class="expand" for="c-40998812">[2 more]</label></div><br/><div class="children"><div class="content">I had similar discussions with people that wanted to encode published research into ontologies. I would ask researchers what they think - the answer was always great idea. I would then follow up with - How would you use it? No response. I finally concluded that it would never happen.<p>1. No one wanted it enough to pay for it to happen.<p>2. There is always a turn over of ideas coming and going which can never be sufficiently updated to keep it useful. Again no one would pay anyway.<p>Tools like LLMs seem to be fill the role now. I would like to see a Prolog integrated with LLMs is someway (lack of imagination fails me how that would happen).</div><br/><div id="40998913" class="c"><input type="checkbox" id="c-40998913" checked=""/><div class="controls bullet"><span class="by">rscho</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40998812">parent</a><span>|</span><a href="#40999036">next</a><span>|</span><label class="collapse" for="c-40998913">[-]</label><label class="expand" for="c-40998913">[1 more]</label></div><br/><div class="children"><div class="content">A theorem prover for the medical literature:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;webyrd&#x2F;mediKanren">https:&#x2F;&#x2F;github.com&#x2F;webyrd&#x2F;mediKanren</a><p><a href="http:&#x2F;&#x2F;minikanren.org&#x2F;workshop&#x2F;2020&#x2F;minikanren-2020-paper7.pdf" rel="nofollow">http:&#x2F;&#x2F;minikanren.org&#x2F;workshop&#x2F;2020&#x2F;minikanren-2020-paper7.p...</a><p>Not prolog though. But gives an idea about the goals behind the classification of science papers.</div><br/></div></div></div></div><div id="40999036" class="c"><input type="checkbox" id="c-40999036" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40997798">parent</a><span>|</span><a href="#40998812">prev</a><span>|</span><a href="#40999577">next</a><span>|</span><label class="collapse" for="c-40999036">[-]</label><label class="expand" for="c-40999036">[3 more]</label></div><br/><div class="children"><div class="content">This is why Lenat and CYC had settled on micro-theories. They found it impossible to build a useful universal ontology so had to fracture them on domain boundaries.</div><br/><div id="41000332" class="c"><input type="checkbox" id="c-41000332" checked=""/><div class="controls bullet"><span class="by">imglorp</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40999036">parent</a><span>|</span><a href="#40999577">next</a><span>|</span><label class="collapse" for="c-41000332">[-]</label><label class="expand" for="c-41000332">[2 more]</label></div><br/><div class="children"><div class="content">I was just pondering if the Prolog universal quantifier would be applicable to reasoning about Cyc frames. Does your comment imply it&#x27;s not?</div><br/><div id="41000893" class="c"><input type="checkbox" id="c-41000893" checked=""/><div class="controls bullet"><span class="by">nl</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#41000332">parent</a><span>|</span><a href="#40999577">next</a><span>|</span><label class="collapse" for="c-41000893">[-]</label><label class="expand" for="c-41000893">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m somewhat familiar with Cyc but I&#x27;d never heard of this development of &quot;micro-theories&quot;. It makes perfect sense though - to generalize hugely structured ontologies break as soon as the second person tries to use them or they are used on a slightly different domain.<p>Anyway, Prolog should be suitable for reasoning over them, but it is only grounded in the &quot;micro-theory&quot; part.</div><br/></div></div></div></div></div></div><div id="40999577" class="c"><input type="checkbox" id="c-40999577" checked=""/><div class="controls bullet"><span class="by">drdeca</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40997798">parent</a><span>|</span><a href="#40999036">prev</a><span>|</span><a href="#41000961">next</a><span>|</span><label class="collapse" for="c-40999577">[-]</label><label class="expand" for="c-40999577">[1 more]</label></div><br/><div class="children"><div class="content">I don’t see an issue with saying “X-ray photography machines, and deep-space radio telescopes, are (or at least contains-a, in the case of the telescope) cameras”. They just aren’t ordinary cameras of the sort that a typical person might take a picture with.<p>I think most of the reasoning you would want to do with a concept of “camera” that excludes X-ray machines and telescopes, but includes night-vision, could be handled with “portable camera”?<p>Hm, I guess you probably want to include security cameras though..<p>Ok. “Portable cameras or security cameras”.</div><br/></div></div><div id="41000961" class="c"><input type="checkbox" id="c-41000961" checked=""/><div class="controls bullet"><span class="by">worik</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40997798">parent</a><span>|</span><a href="#40999577">prev</a><span>|</span><a href="#40998380">next</a><span>|</span><label class="collapse" for="c-41000961">[-]</label><label class="expand" for="c-41000961">[5 more]</label></div><br/><div class="children"><div class="content">Ontology: Study of the nature of being, becoming, existence or reality, as well as the basic categories of being and their relations (philosophy)<p>What does that have to do with this?<p>Is there some use of &quot;ontology&quot; in logic I have not heard of?</div><br/><div id="41001565" class="c"><input type="checkbox" id="c-41001565" checked=""/><div class="controls bullet"><span class="by">everforward</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#41000961">parent</a><span>|</span><a href="#41001496">next</a><span>|</span><label class="collapse" for="c-41001565">[-]</label><label class="expand" for="c-41001565">[1 more]</label></div><br/><div class="children"><div class="content">It would be this version of ontology: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ontology_(information_science)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ontology_(information_science)</a><p>Loosely speaking, ontologies are categories of objects defined by their attributes and relationships to other things.  Where a hierarchy is a branching structure where items can only appear on the tree once, ontologies do not require everything to stem from a single &quot;root&quot; node and items can appear in the tree in more than one place.<p>It&#x27;s a way of working around how hierarchies can&#x27;t model some things very well.  E.g. &quot;bipedal&quot; is an attribute that can apply to both animals and robots; where does it go in a hierarchy that it can apply to both animals and robots without also implying that robots are animals or vice versa.</div><br/></div></div><div id="41001496" class="c"><input type="checkbox" id="c-41001496" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#41000961">parent</a><span>|</span><a href="#41001565">prev</a><span>|</span><a href="#41001025">next</a><span>|</span><label class="collapse" for="c-41001496">[-]</label><label class="expand" for="c-41001496">[1 more]</label></div><br/><div class="children"><div class="content">Domain Driven Design - one of those things like Agile that triggers all sorts of holy wars - has a lot of overlap with the general concept of ontologies, to the point that I&#x27;ve seen some teams formalize all communication between microservices through a shared &quot;ontology&quot;, which in reality was essentially a giant XML based descript of valid nouns and verbs that events could use to communicate between services.<p>Additionally, there&#x27;s a good deal of overlap with the &quot;semantic web&quot; concept, which itself had a good deal of hype with very limited (but important) application- even the W3C has some published content on how all three fit together: <a href="https:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;sw&#x2F;BestPractices&#x2F;SE&#x2F;ODA&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;sw&#x2F;BestPractices&#x2F;SE&#x2F;ODA&#x2F;</a></div><br/></div></div><div id="41001025" class="c"><input type="checkbox" id="c-41001025" checked=""/><div class="controls bullet"><span class="by">scheme271</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#41000961">parent</a><span>|</span><a href="#41001496">prev</a><span>|</span><a href="#41000994">next</a><span>|</span><label class="collapse" for="c-41001025">[-]</label><label class="expand" for="c-41001025">[1 more]</label></div><br/><div class="children"><div class="content">Maybe more in philosophy and classic general AI.  Basically ontologies are systems of categorizing and classifying knowledge.  E.g. if you want to reason about self driving, you would have an ontology that lets you separate traffic signs from billboards.</div><br/></div></div><div id="41000994" class="c"><input type="checkbox" id="c-41000994" checked=""/><div class="controls bullet"><span class="by">mannyv</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#41000961">parent</a><span>|</span><a href="#41001025">prev</a><span>|</span><a href="#40998380">next</a><span>|</span><label class="collapse" for="c-41000994">[-]</label><label class="expand" for="c-41000994">[1 more]</label></div><br/><div class="children"><div class="content">In this context ontology means common vocabulary&#x2F;categories.</div><br/></div></div></div></div><div id="40998380" class="c"><input type="checkbox" id="c-40998380" checked=""/><div class="controls bullet"><span class="by">wslh</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40997798">parent</a><span>|</span><a href="#41000961">prev</a><span>|</span><a href="#40998096">next</a><span>|</span><label class="collapse" for="c-40998380">[-]</label><label class="expand" for="c-40998380">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I think that is the experience, for example, in what we called (or call) data science: most of the time is spent in ETLs rather than using ML methods. In a real company linking data difficulty is not technical but time and resource consuming.</div><br/></div></div><div id="40998096" class="c"><input type="checkbox" id="c-40998096" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40997798">parent</a><span>|</span><a href="#40998380">prev</a><span>|</span><a href="#40997220">next</a><span>|</span><label class="collapse" for="c-40998096">[-]</label><label class="expand" for="c-40998096">[1 more]</label></div><br/><div class="children"><div class="content">your camera example demonstrates that human knowledge is loosely structured and formalized in general, so you can&#x27;t create strict onthology. One way to work around is to assign some confidence score on statements, so you will have something like that Nikon device is likely camera, and x-ray machine is unlikely camera based on current world model.</div><br/></div></div></div></div><div id="40997220" class="c"><input type="checkbox" id="c-40997220" checked=""/><div class="controls bullet"><span class="by">chamomeal</span><span>|</span><a href="#40996999">parent</a><span>|</span><a href="#40997798">prev</a><span>|</span><a href="#41001781">next</a><span>|</span><label class="collapse" for="c-40997220">[-]</label><label class="expand" for="c-40997220">[13 more]</label></div><br/><div class="children"><div class="content">What do you mean by LISP as a siren call?<p>I’ve just started learning clojure and besides the lack of static types (which is pretty harsh for me), it seems like a fun and practical language.</div><br/><div id="40998447" class="c"><input type="checkbox" id="c-40998447" checked=""/><div class="controls bullet"><span class="by">wk_end</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40997220">parent</a><span>|</span><a href="#40997241">next</a><span>|</span><label class="collapse" for="c-40998447">[-]</label><label class="expand" for="c-40998447">[3 more]</label></div><br/><div class="children"><div class="content">Imagine it&#x27;s, like, 1980 - or even earlier - and you can work in a language roughly as nice as Clojure, except the rest of the world is stuck working with pre-ANSI C or Pascal or FORTRAN or COBOL or raw assembly language. There&#x27;s no Python or Java or C# or Ruby or Perl or Haskell or Scala or Kotlin or Rust or JS&#x2F;TS. Nothing really resembling our modern idea of a high-level language.<p>(OK, there was Smalltalk. Let&#x27;s ignore Smalltalk. Lord knows everyone else did.)<p>That&#x27;ll alter your perception of reality a bit. Here they were, in possession of a tool massively more powerful - and more elegant - than what everyone else is using. And moreover, everyone else took a look at it and <i>turned their noses up</i>.<p>Clearly, you and your fellow Lisp programmers are a different breed, capable of seeing further than the rest of the unwashed masses. In a word, you were better than them.<p>It sounds like I&#x27;m being disparaging, but to a certain extent, I don&#x27;t even think this was totally a wrong attitude to have. Elitist, definitely, but not wholly unwarranted. Lisp really was - in terms of expressiveness, anyway - really that far ahead of the competition. And yet somehow that competition won. The world is cruel and unjust.<p>So Lisp becomes a kind of Us v. Them cult: if you&#x27;ve heard the good word of McCarthy, you&#x27;re one of Us. If not, you&#x27;re best ignored - too stupid to possibly have anything worthwhile to say.<p>(If you think I&#x27;m exaggerating, spend some time reading the words of Usenet Lisp institution Erik Naggum - R.I.P. - who serves as the most extreme but hardly the only example.)<p>This blinded Lisp diehards to the outside world, which slowly but surely, in many respects, began to catch up or even exceed Lisp.<p>The other thing is - not only is Lisp a powerful language, at its core is a beautiful and simple and expressive mathematical idea. Combine that with the way macros allow you to extend the language virtually infinitely, there can be a near religiosity at the heart of Lisp - from one lambda all things depend. Lisp isn&#x27;t just good engineering - it&#x27;s a glimpse at the fundamental nature of computation, of the universe itself.<p>I&#x27;m not going to sit here and tell you that this is somehow a terrible thing, per se. But it can be incredibly alluring to the right kind of mind, and once you&#x27;re in its thralls it&#x27;s hard to get out. You might be working with the tool, but in another sense the tool is working with you. A Siren Song.</div><br/><div id="40999435" class="c"><input type="checkbox" id="c-40999435" checked=""/><div class="controls bullet"><span class="by">forgetfulness</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40998447">parent</a><span>|</span><a href="#41001915">next</a><span>|</span><label class="collapse" for="c-40999435">[-]</label><label class="expand" for="c-40999435">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also the not all small factor that there was glam to Lisp.<p>Early Internet discourse around programming was dominated by people who had ties to elite universities in the 1980s, who yearned for the times when the US Government was throwing an abundance of money to the AI industry of the time.<p>They were the ones rubbing elbows with researchers from MIT, Stanford, Harvard, and Berkeley, who were using specialized hardware and software beyond the capabilities available to that of developers working on more mundane applications, all graciously funded by DARPA initiatives.<p>That experience was, in truth, unrelatable to young people reading the recollections of ESR and RMS of the period, the in-jokes of these people, their ideas and interactions, but the tales of Lisp, the Lisp hackers and their fabled Lisp machines would be extremely appealing to someone who was very passionate about programming, striving for excellence as a programmer, and to advance in life through merit. Paul Graham would seal the deal with his essays.</div><br/></div></div><div id="41001915" class="c"><input type="checkbox" id="c-41001915" checked=""/><div class="controls bullet"><span class="by">asimpletune</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40998447">parent</a><span>|</span><a href="#40999435">prev</a><span>|</span><a href="#40997241">next</a><span>|</span><label class="collapse" for="c-41001915">[-]</label><label class="expand" for="c-41001915">[1 more]</label></div><br/><div class="children"><div class="content">Learning about the curse of lisp is always an eye opening point in one’s career</div><br/></div></div></div></div><div id="40997241" class="c"><input type="checkbox" id="c-40997241" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40997220">parent</a><span>|</span><a href="#40998447">prev</a><span>|</span><a href="#40998378">next</a><span>|</span><label class="collapse" for="c-40997241">[-]</label><label class="expand" for="c-40997241">[7 more]</label></div><br/><div class="children"><div class="content">Clojure is probably the most beautiful language I&#x27;ve ever worked with. Nothing is perfect, but Clojure is <i>very</i> simple and elegant.</div><br/><div id="41003769" class="c"><input type="checkbox" id="c-41003769" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40997241">parent</a><span>|</span><a href="#40997296">next</a><span>|</span><label class="collapse" for="c-41003769">[-]</label><label class="expand" for="c-41003769">[1 more]</label></div><br/><div class="children"><div class="content">What makes Clojure a non-starter for me is that it runs on the JVM.</div><br/></div></div><div id="40997296" class="c"><input type="checkbox" id="c-40997296" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40997241">parent</a><span>|</span><a href="#41003769">prev</a><span>|</span><a href="#40998378">next</a><span>|</span><label class="collapse" for="c-40997296">[-]</label><label class="expand" for="c-40997296">[5 more]</label></div><br/><div class="children"><div class="content">Only downside is I don&#x27;t know Java, so some things that should be obvious are opaque to me.</div><br/><div id="40999968" class="c"><input type="checkbox" id="c-40999968" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40997296">parent</a><span>|</span><a href="#40998642">next</a><span>|</span><label class="collapse" for="c-40999968">[-]</label><label class="expand" for="c-40999968">[3 more]</label></div><br/><div class="children"><div class="content">You really don’t need to know any java. I don’t know java either.<p>Even if you’re doing java interop, it’s quite easy to figure it out.</div><br/><div id="40999984" class="c"><input type="checkbox" id="c-40999984" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40999968">parent</a><span>|</span><a href="#40998642">next</a><span>|</span><label class="collapse" for="c-40999984">[-]</label><label class="expand" for="c-40999984">[2 more]</label></div><br/><div class="children"><div class="content">Last time I looked about file IO it involves calling out to some Java class that I had no clue about as I don&#x27;t use Java. All the doc of the time just assumed you should be able to figure this all out.<p>Edit: it&#x27;s been like 5 years</div><br/><div id="41002126" class="c"><input type="checkbox" id="c-41002126" checked=""/><div class="controls bullet"><span class="by">andrewflnr</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40999984">parent</a><span>|</span><a href="#40998642">next</a><span>|</span><label class="collapse" for="c-41002126">[-]</label><label class="expand" for="c-41002126">[1 more]</label></div><br/><div class="children"><div class="content">This was my experience too, at about the same time. I should really dig back into it at some point.</div><br/></div></div></div></div></div></div><div id="40998642" class="c"><input type="checkbox" id="c-40998642" checked=""/><div class="controls bullet"><span class="by">xyproto</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40997296">parent</a><span>|</span><a href="#40999968">prev</a><span>|</span><a href="#40998378">next</a><span>|</span><label class="collapse" for="c-40998642">[-]</label><label class="expand" for="c-40998642">[1 more]</label></div><br/><div class="children"><div class="content">Java frolicks in opaqueness.</div><br/></div></div></div></div></div></div><div id="40998378" class="c"><input type="checkbox" id="c-40998378" checked=""/><div class="controls bullet"><span class="by">ethagnawl</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40997220">parent</a><span>|</span><a href="#40997241">prev</a><span>|</span><a href="#40998850">next</a><span>|</span><label class="collapse" for="c-40998378">[-]</label><label class="expand" for="c-40998378">[1 more]</label></div><br/><div class="children"><div class="content">core.logic is pretty neat, too. Especially as it applies to this thread and the ancestor comments.</div><br/></div></div><div id="40998850" class="c"><input type="checkbox" id="c-40998850" checked=""/><div class="controls bullet"><span class="by">jolt42</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40997220">parent</a><span>|</span><a href="#40998378">prev</a><span>|</span><a href="#41001781">next</a><span>|</span><label class="collapse" for="c-40998850">[-]</label><label class="expand" for="c-40998850">[1 more]</label></div><br/><div class="children"><div class="content">Lisps don&#x27;t get in your way, but they also have no opinions, which is problematic for community development. As a static type fan, it&#x27;s the only language I think the pros outweigh than one con.</div><br/></div></div></div></div><div id="40997397" class="c"><input type="checkbox" id="c-40997397" checked=""/><div class="controls bullet"><span class="by">slashdave</span><span>|</span><a href="#40996999">parent</a><span>|</span><a href="#41001781">prev</a><span>|</span><a href="#40995918">next</a><span>|</span><label class="collapse" for="c-40997397">[-]</label><label class="expand" for="c-40997397">[10 more]</label></div><br/><div class="children"><div class="content">Who still has nightmares of infinitely nested parenthesis?</div><br/><div id="40999451" class="c"><input type="checkbox" id="c-40999451" checked=""/><div class="controls bullet"><span class="by">forgetfulness</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40997397">parent</a><span>|</span><a href="#40998818">next</a><span>|</span><label class="collapse" for="c-40999451">[-]</label><label class="expand" for="c-40999451">[8 more]</label></div><br/><div class="children"><div class="content">The more nightmarish thing about Clojure is realizing that, in truth, you have no idea what all these dicts you are passing around the terse, nil-punning functions of your codebase hold at any given time.</div><br/><div id="41000355" class="c"><input type="checkbox" id="c-41000355" checked=""/><div class="controls bullet"><span class="by">nogridbag</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40999451">parent</a><span>|</span><a href="#41000444">next</a><span>|</span><label class="collapse" for="c-41000355">[-]</label><label class="expand" for="c-41000355">[1 more]</label></div><br/><div class="children"><div class="content">That was the case for me. I went all in drinking the Clojure koolaid and wrote some small internal CLI tools with it. If I came back to that code a month or two later I could only properly understand it if I opened up a REPL to debug it. I ported those tools to Java and they were dead simple to comprehend.</div><br/></div></div><div id="41000444" class="c"><input type="checkbox" id="c-41000444" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40999451">parent</a><span>|</span><a href="#41000355">prev</a><span>|</span><a href="#40998818">next</a><span>|</span><label class="collapse" for="c-41000444">[-]</label><label class="expand" for="c-41000444">[6 more]</label></div><br/><div class="children"><div class="content">Yup. I learned Clojure just so I can use a Lisp and get paid for it, but there is some weird cult against all forms of typing. Even coming from a Common Lisp background, this was strange to me. In Common Lisp, there are implementations (like SBCL and ECL) that can make use of type declarations to produce efficient machine code <i>and</i> allow the compiler to catch errors that would otherwise be run-time errors. There&#x27;s also other benefits like contextual autocomplete. The autocomplete in Clojure tooling is very basic, and many Clojure libraries try to make up for this by using qualified keywords everywhere. That way, rather than seeing all keywords ever interned, you can type &quot;:some.namespace&#x2F;&quot; and your editor shows a dozen keys instead of hundreds of unrelated keys.<p>Many in the Clojure community believe that occasionally validating maps against a schema &quot;at the boundaries&quot; is good enough. In practice, I have found this to be insufficient. Nearly every Clojure programmer I know has had to &quot;chase nils&quot; as a result of a map no longer including a key and several functions passing down a nil value until some function throws an exception. (Note: I don&#x27;t specify which exception, because it depends on how that nil value gets used!)<p>Refactoring Clojure code in general is a nightmare, and I suspect it is why many in the community are reluctant to change code in existing libraries and build entirely new things in parallel instead. Backwards compatibility is one often-cited reason, but I do think another reason is that refactoring Clojure code creates an endless game of bug fixing unless you have full test coverage of your codebase and use generative testing everywhere. (I&#x27;ve never seen a Clojure codebase with both of these things. I can count on one hand the number of Clojure codebases where generative testing is used at all).<p>Function spec instrumentation provides something that feels like runtime type checks in Common Lisp, but now you have to manually run certain functions at the REPL just to ensure some change in your codebase did not introduce a type error.<p>On the flip side, Java has things like DTOs which always felt too boilerplate-ish for me (though at least it provides useful names for endpoint data when generating Swagger&#x2F;OpenAPI documentation). Even then, records in Java provide what are essentially maps with type safety and similar characteristics as DTOs.<p>I think the structural typing offered by languages like OCaml and TypeScript provide exactly what I&#x27;d want in Clojure. But when faced with feature requests in Clojure, people will state something like &quot;I have never had a use-case for X, therefore you don&#x27;t need X&quot;. In the case of criticisms, the response is often &quot;I may have ran into X before, but it&#x27;s so rare that I don&#x27;t consider it a problem&quot;.</div><br/><div id="41000585" class="c"><input type="checkbox" id="c-41000585" checked=""/><div class="controls bullet"><span class="by">nogridbag</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#41000444">parent</a><span>|</span><a href="#41000838">next</a><span>|</span><label class="collapse" for="c-41000585">[-]</label><label class="expand" for="c-41000585">[3 more]</label></div><br/><div class="children"><div class="content">I still don&#x27;t get how Java records can be used for anything like a DTO. Since you&#x27;re a Clojure dev you may remember the pattern Rich Hickey described as &quot;place oriented programming&quot; :) Nearly every endpoint will have more than 2-3 fields and you really don&#x27;t want a Java record with more than that many fields for the same reason you don&#x27;t want a Java method with that many fields e.g. doIt(Long, String,String,Long,String,int,int,String) &lt;-- code smell.<p>And the problem I always see is something may start off as a Java record and then need to be refactored into a class as soon as 1-2 more fields are added.</div><br/><div id="41000751" class="c"><input type="checkbox" id="c-41000751" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#41000585">parent</a><span>|</span><a href="#41000838">next</a><span>|</span><label class="collapse" for="c-41000751">[-]</label><label class="expand" for="c-41000751">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I still don&#x27;t get how Java records can be used for anything like a DTO<p>In Clojure, we often deserialize a result set from a database to a vector of maps. These maps have different keys depending on what exactly your query was selecting. In Java, one often &quot;projects&quot; results to some DTO. This is one scenario where records offer identical functionality while avoiding boilerplate.<p>Regarding &quot;place-oriented programming&quot;, records are immutable, so that is one technical advantage they have over handwriting a DTO. And from my short experience using web frameworks like Quarkus, it seems that a lot of the &quot;design patterns&quot; I see in documentation exist to help design easy-to-test programs rather than unfettered mutation.<p>Additionally, I have found records useful for describing the payload of endpoints that accept map-like data. Without records, I would be writing POJOs with public fields anyway.<p>Overall, Java records behave like TypeScript interfaces with awkward syntax. I have found them ideal for expressing type-safe, map-like data with minimal boilerplate.</div><br/><div id="41003218" class="c"><input type="checkbox" id="c-41003218" checked=""/><div class="controls bullet"><span class="by">nogridbag</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#41000751">parent</a><span>|</span><a href="#41000838">next</a><span>|</span><label class="collapse" for="c-41003218">[-]</label><label class="expand" for="c-41003218">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m also using it for projections. But to be honest we have a fairly large Quarkus app and only use projections in a few places. For immutable classes with a large number of fields where instances have to be created manually I usually use the builder pattern. But the analogy to typescript interfaces is interesting.</div><br/></div></div></div></div></div></div><div id="41000838" class="c"><input type="checkbox" id="c-41000838" checked=""/><div class="controls bullet"><span class="by">ghufran_syed</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#41000444">parent</a><span>|</span><a href="#41000585">prev</a><span>|</span><a href="#40998818">next</a><span>|</span><label class="collapse" for="c-41000838">[-]</label><label class="expand" for="c-41000838">[2 more]</label></div><br/><div class="children"><div class="content">Could you use <a href="https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;core.typed">https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;core.typed</a> ? Or <a href="https:&#x2F;&#x2F;clojure.org&#x2F;guides&#x2F;spec" rel="nofollow">https:&#x2F;&#x2F;clojure.org&#x2F;guides&#x2F;spec</a> ?</div><br/><div id="41001309" class="c"><input type="checkbox" id="c-41001309" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#41000838">parent</a><span>|</span><a href="#40998818">next</a><span>|</span><label class="collapse" for="c-41001309">[-]</label><label class="expand" for="c-41001309">[1 more]</label></div><br/><div class="children"><div class="content">Typed Clojure is interesting. However, until two months ago, it was practically unusable for most Clojure projects because of the lack of type inference in higher-order functions. This has changed, but there&#x27;s another huge problem: nobody maintains type declarations for widely used libraries. If you look at alternatives to TypeScript, such as ReScript, you will find similar issues.<p>I still use Clojure, but I am fully aware of the kind of bugs to expect down the road. Typed Clojure would work if I could maintain types for each library I use, but that is simply too much effort on my part.<p>As for clojure.spec, I already addressed this in my post, but I will state the following.<p>Schema, Malli, and Spec are not substitutes for a type system. Each of these libraries explicitly state so. You still need to enable instrumentation and <i>run</i> erroneous code violating some contract. Most Clojure programmers have the habit of enabling instrumentation in dev and disabling it in production because validation is an expensive operation. I personally use Malli for data validation and coercion, but it does not make refactoring any easier, nor does it help autocomplete and other development-related tooling.<p>(Someone will probably link a malli document demonstrating clj-kondo linter generation, but even that is not a substitute. At best it detects arity errors and primitive type mismatches, not the shape of data in a map).</div><br/></div></div></div></div></div></div></div></div><div id="40998818" class="c"><input type="checkbox" id="c-40998818" checked=""/><div class="controls bullet"><span class="by">jolt42</span><span>|</span><a href="#40996999">root</a><span>|</span><a href="#40997397">parent</a><span>|</span><a href="#40999451">prev</a><span>|</span><a href="#40995918">next</a><span>|</span><label class="collapse" for="c-40998818">[-]</label><label class="expand" for="c-40998818">[1 more]</label></div><br/><div class="children"><div class="content">They seem to disappear with parinfer.</div><br/></div></div></div></div></div></div><div id="40995918" class="c"><input type="checkbox" id="c-40995918" checked=""/><div class="controls bullet"><span class="by">GistNoesis</span><span>|</span><a href="#40996999">prev</a><span>|</span><a href="#40999776">next</a><span>|</span><label class="collapse" for="c-40995918">[-]</label><label class="expand" for="c-40995918">[12 more]</label></div><br/><div class="children"><div class="content">The &quot;magic&quot; of Prolog is built upon two interesting concepts : Unification ( <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Unification_(computer_science)#A_unification_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Unification_(computer_science)...</a> ) and Backtracking ( <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Backtracking" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Backtracking</a> ).<p>Often bad teachers only present the declarative aspect of the language.<p>By virtue of being declarative, it allows to express inverse problems in a dangerously simple fashion, but doesn&#x27;t provide any clue for a solution. And you are then using a declarative language to provide clues to guide the bad engine toward a solution. Making the whole code an awful mashup of declarative and imperative.<p>Rules :<p>- N integer, a integer &gt; 1, b integer &gt; 1<p>- N := a * b<p>Goal :<p>N = 2744977<p>You can embed such a simple problem easily but solving it is another thing.<p>The real surge of Prolog and other declarative constraint programming type of language will be when the solving engines will be better.<p>Unification is limited to the first order logic, high-order logic unification is undecidable in the general case. So we probably will have to rely on heuristics. By rewriting prolog goal solving as a game, you can use deep learning algorithms like alphago (Montecarlo tree search).<p>This engine internally adds intermediate logical rules to your simply defined problem, based on similar problems it has encountered in its training set. And then solve them like LLM, by picking the heuristically picking the right rule from intuition.<p>The continuous equivalent in a sort of unification is Rao-Blackwellisation (done automagically by deep-learning from its training experience) which allows to pick the right associations efficiently kind of the same way that a &quot;most general unification algorithm&quot; allows to pick the right variable to unify the terms.</div><br/><div id="40997129" class="c"><input type="checkbox" id="c-40997129" checked=""/><div class="controls bullet"><span class="by">abeppu</span><span>|</span><a href="#40995918">parent</a><span>|</span><a href="#40996105">next</a><span>|</span><label class="collapse" for="c-40997129">[-]</label><label class="expand" for="c-40997129">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The continuous equivalent in a sort of unification is Rao-Blackwellisation (done automagically by deep-learning from its training experience) which allows to pick the right associations efficiently kind of the same way that a &quot;most general unification algorithm&quot; allows to pick the right variable to unify the terms.<p>I don&#x27;t know how to reconcile this statement about deep learning with my understanding of Rao-Blackwell. Can you explain:<p>- what is the value being estimated?<p>- what is the sufficient statistic?<p>- what is the crude estimator? what is the improved estimator?<p>Roughly, I think sufficient statistics don&#x27;t really do anything useful in deep learning. If they did, they would give a recipe for embarassingly parallel training that would be assured to reach exactly the same value a fully sequential training. And from an information geometry perspective, because sufficient statistics are geodesics, the exploratory (hand-waving) and slow nature of SGD could be skipped.</div><br/><div id="40997759" class="c"><input type="checkbox" id="c-40997759" checked=""/><div class="controls bullet"><span class="by">GistNoesis</span><span>|</span><a href="#40995918">root</a><span>|</span><a href="#40997129">parent</a><span>|</span><a href="#40996105">next</a><span>|</span><label class="collapse" for="c-40997759">[-]</label><label class="expand" for="c-40997759">[1 more]</label></div><br/><div class="children"><div class="content">Once you view prolog goal reaching as a game. You can apply Reinforcement Learning methodologies. The goal is writing a valid proof, aka a sequence of picking valid rules and variables assignment.<p>Value being estimated : The expected discounted reward of reaching the goal. The shorted the proof the better.<p>The sufficient statistic : The embedding representation of the current solving state (the inner state of your LLM (or any other model) that you use to make your choices). You make sure it&#x27;s sufficient by being able to regenerate the state from the representation (using an auto-encoder or vae does the trick). You build this statistic across various instances of problems. This tells you what is a judicious choice of variable based on experience. Similar problems yield similar choices.<p>The crude estimator : All choices of have the same value therefore a random choice, The improved estimator : The choice value is conditioned on the current embedding representation of the state using a Neural Network.<p>You can apply Rao-Blackwell once again, based by also conditioning one-step look-ahead. (Or at the limit applying it infinitely many times by solving the bellman equation.)<p>(You can alternatively view each update step of your model, as an application of Rao-Blackwell theorem on your previous estimator. You have to make sure though that there is no mode collapse.)<p>You don&#x27;t have to do it explicitly, it happens under the hood by your choice of modelisation in how to pick the decision.</div><br/></div></div></div></div><div id="40996105" class="c"><input type="checkbox" id="c-40996105" checked=""/><div class="controls bullet"><span class="by">radomir_cernoch</span><span>|</span><a href="#40995918">parent</a><span>|</span><a href="#40997129">prev</a><span>|</span><a href="#40997193">next</a><span>|</span><label class="collapse" for="c-40996105">[-]</label><label class="expand" for="c-40996105">[3 more]</label></div><br/><div class="children"><div class="content">Do you see a good way to include backtracking in an imperative programming language?<p>I can imagine how unification would work, since the ubiquitous &quot;pattern matching&quot; is a special case of Prolog&#x27;s unification. But I&#x27;ve never seen how backtracking could be useful...</div><br/><div id="40996162" class="c"><input type="checkbox" id="c-40996162" checked=""/><div class="controls bullet"><span class="by">vmchale</span><span>|</span><a href="#40995918">root</a><span>|</span><a href="#40996105">parent</a><span>|</span><a href="#40997193">next</a><span>|</span><label class="collapse" for="c-40996162">[-]</label><label class="expand" for="c-40996162">[2 more]</label></div><br/><div class="children"><div class="content">backtracking is perilous in general; logic programming languages have really nice abilities for such but I don&#x27;t know how to avoid pathological inefficiency.</div><br/><div id="41000247" class="c"><input type="checkbox" id="c-41000247" checked=""/><div class="controls bullet"><span class="by">YeGoblynQueenne</span><span>|</span><a href="#40995918">root</a><span>|</span><a href="#40996162">parent</a><span>|</span><a href="#40997193">next</a><span>|</span><label class="collapse" for="c-41000247">[-]</label><label class="expand" for="c-41000247">[1 more]</label></div><br/><div class="children"><div class="content">With memoization as in tabling (a.k.a. SLG-Resolution):<p><a href="https:&#x2F;&#x2F;www.swi-prolog.org&#x2F;pldoc&#x2F;man?section=tabling" rel="nofollow">https:&#x2F;&#x2F;www.swi-prolog.org&#x2F;pldoc&#x2F;man?section=tabling</a><p><i>Re-evaluation of a tabled predicate is avoided by memoizing the answers. This can realise huge performance enhancements as illustrated in section 7.1. It also comes with two downsides: the memoized answers are not automatically updated or invalidated if the world (set of predicates on which the answers depend) changes and the answer tables must be stored (in memory).</i><p>Known to the Prolog community since about the 1980&#x27;s if I got my references right.</div><br/></div></div></div></div></div></div><div id="40997193" class="c"><input type="checkbox" id="c-40997193" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#40995918">parent</a><span>|</span><a href="#40996105">prev</a><span>|</span><a href="#40999776">next</a><span>|</span><label class="collapse" for="c-40997193">[-]</label><label class="expand" for="c-40997193">[6 more]</label></div><br/><div class="children"><div class="content">A unique property of Prolog is that, given an answer, it can arrive at the original question (or, a set of questions – speaking more broadly).<p>Or, using layman terms, a Prolog programme can be run backward.</div><br/><div id="40997461" class="c"><input type="checkbox" id="c-40997461" checked=""/><div class="controls bullet"><span class="by">ted_dunning</span><span>|</span><a href="#40995918">root</a><span>|</span><a href="#40997193">parent</a><span>|</span><a href="#40998327">next</a><span>|</span><label class="collapse" for="c-40997461">[-]</label><label class="expand" for="c-40997461">[4 more]</label></div><br/><div class="children"><div class="content">To be precise, a small number of very small Prolog programs can be run backwards.<p>There are essentially no significant Prolog programs that are reversible with acceptable efficiency.</div><br/><div id="40999336" class="c"><input type="checkbox" id="c-40999336" checked=""/><div class="controls bullet"><span class="by">derdi</span><span>|</span><a href="#40995918">root</a><span>|</span><a href="#40997461">parent</a><span>|</span><a href="#40998327">next</a><span>|</span><label class="collapse" for="c-40999336">[-]</label><label class="expand" for="c-40999336">[3 more]</label></div><br/><div class="children"><div class="content">To be even more precise, Prolog programs only ever run forward because the order of evaluation is fixed as top-down, left-to-right. These notions of &quot;forward&quot; and &quot;backward&quot; are very unhelpful and should be given up. Beginners find the order of evaluation hard enough to understand, let&#x27;s not confuse them even more.<p>Also, the notion is woefully incomplete. Let&#x27;s say we consider this &quot;forward&quot;:<p><pre><code>    ?- list_length([a, b, c], Length).
    Length = 3.
</code></pre>
Then you would say that this is &quot;backward&quot;:<p><pre><code>    ?- list_length(List, 3).
    List = [_A, _B, _C].
</code></pre>
Fine, but what&#x27;s this then? &quot;Inward&quot;?<p><pre><code>    ?- list_length([a, b, c], 3).
    true.
</code></pre>
And then presumably this is &quot;outward&quot;:<p><pre><code>    ?- list_length(List, Length).
    List = [], Length = 0 ;
    ...
    List = [a, b, c], Length = 3 .
</code></pre>
None of these cases change the order of evaluation. They are all evaluated top-down, left-to-right. The sooner beginning Prolog programmers understand this, the better. The sooner we stop lying to people to market Prolog, the better.</div><br/><div id="41001701" class="c"><input type="checkbox" id="c-41001701" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40995918">root</a><span>|</span><a href="#40999336">parent</a><span>|</span><a href="#40998327">next</a><span>|</span><label class="collapse" for="c-41001701">[-]</label><label class="expand" for="c-41001701">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s going on in the second example? Did Prolog generate a list term stuffed with gensym variables, which satisifies the list_length being 3?</div><br/><div id="41002370" class="c"><input type="checkbox" id="c-41002370" checked=""/><div class="controls bullet"><span class="by">derdi</span><span>|</span><a href="#40995918">root</a><span>|</span><a href="#41001701">parent</a><span>|</span><a href="#40998327">next</a><span>|</span><label class="collapse" for="c-41002370">[-]</label><label class="expand" for="c-41002370">[1 more]</label></div><br/><div class="children"><div class="content">It generated a list stuffed with distinct logical variables. Any list of length 3 is unifiable with this list. Or in other words, this is the unique (up to variable renaming) most general list of length 3.<p>Whether this is a &quot;yes&quot; to your question depends on what your mental model of &quot;gensym variables&quot; is. They are variables, not symbols (which Prolog would call atoms).</div><br/></div></div></div></div></div></div></div></div><div id="40998327" class="c"><input type="checkbox" id="c-40998327" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#40995918">root</a><span>|</span><a href="#40997193">parent</a><span>|</span><a href="#40997461">prev</a><span>|</span><a href="#40999776">next</a><span>|</span><label class="collapse" for="c-40998327">[-]</label><label class="expand" for="c-40998327">[1 more]</label></div><br/><div class="children"><div class="content">the bidirectional (relational) aspect of prolog is what got me into this. I love symmetries so it was a natural appeal even before I learned about logic programming (Sean Parent made a google talk about similar ideas implemented in cpp). That said it&#x27;s very limited. But I wonder how far it could go. (the kanren guys might have more clues)</div><br/></div></div></div></div></div></div><div id="40999776" class="c"><input type="checkbox" id="c-40999776" checked=""/><div class="controls bullet"><span class="by">hpincket</span><span>|</span><a href="#40995918">prev</a><span>|</span><a href="#40995231">next</a><span>|</span><label class="collapse" for="c-40999776">[-]</label><label class="expand" for="c-40999776">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve played around with Prolog on and off for 7 years. Still a novice. It&#x27;s one of those languages that forces your mind to grow in new directions.<p>It&#x27;s difficult to make a case for it. The declarative paradigm is nice, but compared to other languages you&#x27;re only saving a couple for-loops. I think its benefit comes from expressiveness for problems where clpfd can be applied. I once built an internal tool with Python and SWI Prolog that combined user input with CLPFD to configure test accounts in a consistent and useful way. Users could provide partial constraints, and the system would fill in the rest. Again, the ease of clpfd is great.<p>I&#x27;ve had some fun generating Prolog facts&#x2F;databases with LLMs and it&#x27;s something I want to explore more.<p>Note: I was just messing around with Prolog this week: <a href="https:&#x2F;&#x2F;hpincket.com&#x2F;adding-an-easter-egg-to-our-numeronym-predicate.html" rel="nofollow">https:&#x2F;&#x2F;hpincket.com&#x2F;adding-an-easter-egg-to-our-numeronym-p...</a></div><br/></div></div><div id="40995231" class="c"><input type="checkbox" id="c-40995231" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#40999776">prev</a><span>|</span><a href="#40996133">next</a><span>|</span><label class="collapse" for="c-40995231">[-]</label><label class="expand" for="c-40995231">[5 more]</label></div><br/><div class="children"><div class="content">Though i only know Prolog cursorily it is in my todo list of languages to study. I think it has great value in that it teaches you a different <i>paradigm</i> for programming.<p>You might also want to look at Erlang which is used in the Industry and would be helpful for your future. Joe Armstrong was originally inspired by Prolog and he conceived Erlang as Prolog-Ideas+Functional&#x2F;Procedural+Concurrency+Fault-Tolerance. Hence you might find a lot of commonalities here. Here is a recent HN thread on a comparison - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40521585">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40521585</a><p>There is also &quot;Erlog&quot; (by Robert Virding, one of the co-creators of Erlang) which is described as, <i>Erlog is a Prolog interpreter implemented in Erlang and integrated with the Erlang runtime system. It is a subset of the Prolog standard. An Erlog shell (REPL) is also included.</i> It also says, <i>If you want to pass data between Erlang and Prolog it is pretty easy to do so. Data types map pretty cleanly between the two languages due to the fact that Erlang evolved from Prolog.</i> - <a href="https:&#x2F;&#x2F;github.com&#x2F;rvirding&#x2F;erlog">https:&#x2F;&#x2F;github.com&#x2F;rvirding&#x2F;erlog</a></div><br/><div id="40998368" class="c"><input type="checkbox" id="c-40998368" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#40995231">parent</a><span>|</span><a href="#40998201">next</a><span>|</span><label class="collapse" for="c-40998368">[-]</label><label class="expand" for="c-40998368">[2 more]</label></div><br/><div class="children"><div class="content">Sure, Erlang was prototyped on Prolog because Prolog has excellent built-in facilities for domain-specific languages: you can define new unary or binary operators along with priorities and associativity rules (you can use this to implement JSON or other expression parsing in like two lines of code, which is kindof shocking for newcomers, but comes very handy for integrating Prolog &quot;microservices&quot; into backend stacks), and you get recursive-decent parsing with backtracking for free as a trivial specialization of Prolog evaluation with a built-in short syntax (definite clause grammars) even.<p>But apart from syntax, Erlang has quite different goals as a backend language for interruption-free telco equipment compared to Prolog.</div><br/><div id="40998683" class="c"><input type="checkbox" id="c-40998683" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#40995231">root</a><span>|</span><a href="#40998368">parent</a><span>|</span><a href="#40998201">next</a><span>|</span><label class="collapse" for="c-40998683">[-]</label><label class="expand" for="c-40998683">[1 more]</label></div><br/><div class="children"><div class="content">In <i>The Development of Erlang</i> Joe Armstrong says &quot;We concluded that we would like something like Prolog with added facilities for concurrency and improved error handling&quot;.<p>See pdf linked here - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40998632">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40998632</a></div><br/></div></div></div></div><div id="40998201" class="c"><input type="checkbox" id="c-40998201" checked=""/><div class="controls bullet"><span class="by">btbuildem</span><span>|</span><a href="#40995231">parent</a><span>|</span><a href="#40998368">prev</a><span>|</span><a href="#40996133">next</a><span>|</span><label class="collapse" for="c-40998201">[-]</label><label class="expand" for="c-40998201">[2 more]</label></div><br/><div class="children"><div class="content">Ha! That explains a lot. I&#x27;ve started looking into Prolog recently, and there were some... familiar echoes in there, reminiscent of Erlang.<p>But of course, the submarine is like a cigar, not cigar like a submarine.</div><br/><div id="40998632" class="c"><input type="checkbox" id="c-40998632" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#40995231">root</a><span>|</span><a href="#40998201">parent</a><span>|</span><a href="#40996133">next</a><span>|</span><label class="collapse" for="c-40998632">[-]</label><label class="expand" for="c-40998632">[1 more]</label></div><br/><div class="children"><div class="content"><i>The Development of Erlang</i> by Joe Armstrong (pdf) - <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;258948.258967" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;258948.258967</a></div><br/></div></div></div></div></div></div><div id="40996133" class="c"><input type="checkbox" id="c-40996133" checked=""/><div class="controls bullet"><span class="by">vmchale</span><span>|</span><a href="#40995231">prev</a><span>|</span><a href="#40994955">next</a><span>|</span><label class="collapse" for="c-40996133">[-]</label><label class="expand" for="c-40996133">[4 more]</label></div><br/><div class="children"><div class="content">Girard has some commentary scattered about his writing.<p>The search algorithms for logic programming are simply slow, it&#x27;s a very interesting idea in programming languages, but there&#x27;s a reason it&#x27;s not widely used.<p>&gt; PROLOG, its misery. Logic programming was bound to failure, not be- cause of a want of quality, but because of its exaggerations. Indeed, the slogan was something like « pose the question, PROLOG will do the rest ». This paradigm of declarative programming, based on a « generic » algorithmics, is a sort of all-terrain vehicle, capable of doing everything and therefore doing everything badly. It would have been more reasonable to confine PROLOG to tasks for which it is well-adapted, e.g., the maintenance of data bases.<p>&gt; On the contrary, attempts were made to improve its efficiency. Thus, as systematic search was too costly, « control » primitives, of the style « don’t try this possibility if... » were introduced. And this slogan « logic + control13 », which forgets that the starting point was the logical soundness of the deduction. What can be said of this control which plays against logic14? One recognises the sectarian attitude that we exposed several times: the logic of the idea kills the idea.<p>&gt; The result is the most inefficient language ever designed; thus, PROLOG is very sensitive to the order in which the clauses (axioms) have been written.</div><br/><div id="40996263" class="c"><input type="checkbox" id="c-40996263" checked=""/><div class="controls bullet"><span class="by">withoutboats3</span><span>|</span><a href="#40996133">parent</a><span>|</span><a href="#40994955">next</a><span>|</span><label class="collapse" for="c-40996263">[-]</label><label class="expand" for="c-40996263">[3 more]</label></div><br/><div class="children"><div class="content">This is a great quote and sadly true. What text is this from?</div><br/><div id="41000345" class="c"><input type="checkbox" id="c-41000345" checked=""/><div class="controls bullet"><span class="by">YeGoblynQueenne</span><span>|</span><a href="#40996133">root</a><span>|</span><a href="#40996263">parent</a><span>|</span><a href="#40996574">next</a><span>|</span><label class="collapse" for="c-41000345">[-]</label><label class="expand" for="c-41000345">[1 more]</label></div><br/><div class="children"><div class="content">For me this kind of criticism is very familiar. It comes from theoretical computer scientists who have these purist ideological convictions about how a declarative language should look and behave, that are as unrealistic, because impossible to implement on a real-world computer, as they are uninteresting for practicing programmers because strictly a matter of aesthetics. Such critics have never made anything useable themselves and are simply angry that someone else made something that works in the real world while they were busy intellectually masturbating over their pure and untouchable vision.<p>Although I concede that my comment might be a bit unfair to Girard who did, after all, invent the mustard watch.</div><br/></div></div><div id="40996574" class="c"><input type="checkbox" id="c-40996574" checked=""/><div class="controls bullet"><span class="by">thih9</span><span>|</span><a href="#40996133">root</a><span>|</span><a href="#40996263">parent</a><span>|</span><a href="#41000345">prev</a><span>|</span><a href="#40994955">next</a><span>|</span><label class="collapse" for="c-40996574">[-]</label><label class="expand" for="c-40996574">[1 more]</label></div><br/><div class="children"><div class="content">&quot;The Blind Spot: Lectures on Logic&quot; by Jean-Yves Girard</div><br/></div></div></div></div></div></div><div id="40994955" class="c"><input type="checkbox" id="c-40994955" checked=""/><div class="controls bullet"><span class="by">felixyz</span><span>|</span><a href="#40996133">prev</a><span>|</span><a href="#40994870">next</a><span>|</span><label class="collapse" for="c-40994955">[-]</label><label class="expand" for="c-40994955">[6 more]</label></div><br/><div class="children"><div class="content">Shameless plug: you should check out my podcast The Search Space for a view of the broader landscape of Prolog and logic programming: <a href="https:&#x2F;&#x2F;thesearch.space&#x2F;" rel="nofollow">https:&#x2F;&#x2F;thesearch.space&#x2F;</a><p>I don&#x27;t publish episodes often but I have a lot of good interviewees lined up :)<p>In general, I would advice you to look beyond Prolog and explore Answer Set Programming, the Picat language, and the connections between logic programming and databases (SQL, RDF or otherwise). Not instead of Prolog, but in parallel. Prolog is awesome!</div><br/><div id="41000554" class="c"><input type="checkbox" id="c-41000554" checked=""/><div class="controls bullet"><span class="by">duranga1234</span><span>|</span><a href="#40994955">parent</a><span>|</span><a href="#40995023">next</a><span>|</span><label class="collapse" for="c-41000554">[-]</label><label class="expand" for="c-41000554">[1 more]</label></div><br/><div class="children"><div class="content">I love your podcast! I wish you published episodes more often!<p>I particularly enjoyed the first episode, the conversation with Robert Kowalski.</div><br/></div></div><div id="40995023" class="c"><input type="checkbox" id="c-40995023" checked=""/><div class="controls bullet"><span class="by">forks</span><span>|</span><a href="#40994955">parent</a><span>|</span><a href="#41000554">prev</a><span>|</span><a href="#40998405">next</a><span>|</span><label class="collapse" for="c-40995023">[-]</label><label class="expand" for="c-40995023">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll second the plug: it&#x27;s an excellent podcast</div><br/></div></div><div id="40998405" class="c"><input type="checkbox" id="c-40998405" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#40994955">parent</a><span>|</span><a href="#40995023">prev</a><span>|</span><a href="#40995500">next</a><span>|</span><label class="collapse" for="c-40998405">[-]</label><label class="expand" for="c-40998405">[1 more]</label></div><br/><div class="children"><div class="content">thanks for the thread for allowing to find you and you for making the interviews</div><br/></div></div><div id="40995500" class="c"><input type="checkbox" id="c-40995500" checked=""/><div class="controls bullet"><span class="by">harperlee</span><span>|</span><a href="#40994955">parent</a><span>|</span><a href="#40998405">prev</a><span>|</span><a href="#40994962">next</a><span>|</span><label class="collapse" for="c-40995500">[-]</label><label class="expand" for="c-40995500">[1 more]</label></div><br/><div class="children"><div class="content">Good to know there is further content lined up! I’m subscribed and eagerly waiting for it!</div><br/></div></div><div id="40994962" class="c"><input type="checkbox" id="c-40994962" checked=""/><div class="controls bullet"><span class="by">overclock351</span><span>|</span><a href="#40994955">parent</a><span>|</span><a href="#40995500">prev</a><span>|</span><a href="#40994870">next</a><span>|</span><label class="collapse" for="c-40994962">[-]</label><label class="expand" for="c-40994962">[1 more]</label></div><br/><div class="children"><div class="content">ASP is in another uni course of mine ;). I&#x27;ll check the podcast, thanks</div><br/></div></div></div></div><div id="40994870" class="c"><input type="checkbox" id="c-40994870" checked=""/><div class="controls bullet"><span class="by">sirwhinesalot</span><span>|</span><a href="#40994955">prev</a><span>|</span><a href="#40995530">next</a><span>|</span><label class="collapse" for="c-40994870">[-]</label><label class="expand" for="c-40994870">[22 more]</label></div><br/><div class="children"><div class="content">Not sure about Prolog itself but Datalog really needs to overtake SQL, it&#x27;s just so much better.<p>Related areas like constraint programming are still very relevant.</div><br/><div id="40994972" class="c"><input type="checkbox" id="c-40994972" checked=""/><div class="controls bullet"><span class="by">pfilo8</span><span>|</span><a href="#40994870">parent</a><span>|</span><a href="#40995188">next</a><span>|</span><label class="collapse" for="c-40994972">[-]</label><label class="expand" for="c-40994972">[13 more]</label></div><br/><div class="children"><div class="content">Could you explain more or point out some interesting references? I&#x27;m currently trying to understand how Datalog compares to SQL and, potentially GraphDBs</div><br/><div id="40995241" class="c"><input type="checkbox" id="c-40995241" checked=""/><div class="controls bullet"><span class="by">felixyz</span><span>|</span><a href="#40994870">root</a><span>|</span><a href="#40994972">parent</a><span>|</span><a href="#40997120">next</a><span>|</span><label class="collapse" for="c-40995241">[-]</label><label class="expand" for="c-40995241">[1 more]</label></div><br/><div class="children"><div class="content">TypeDb is a practical Datalog-based database system [1] (with a different syntax). TerminusDb is a project in a similar vein [2], but actually an RDF store at its core. If you want to experiment with the connections between Datalog, relational algebra, and SQL, check out the Datalog Educational System. And if you want to jump into the theory, Foundations of Databases (the &quot;Alice book&quot;) is very thorough but relatively readable [4]! Oh, and there&#x27;s a Google project, Logica, to do Datalog over Postgres databases [5].<p>[1]: <a href="https:&#x2F;&#x2F;typedb.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;typedb.com&#x2F;</a>
[2]: <a href="https:&#x2F;&#x2F;terminusdb.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;terminusdb.com&#x2F;</a>
[3]: <a href="http:&#x2F;&#x2F;www.fdi.ucm.es&#x2F;profesor&#x2F;fernan&#x2F;des&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.fdi.ucm.es&#x2F;profesor&#x2F;fernan&#x2F;des&#x2F;</a>
[4]: <a href="http:&#x2F;&#x2F;webdam.inria.fr&#x2F;Alice&#x2F;" rel="nofollow">http:&#x2F;&#x2F;webdam.inria.fr&#x2F;Alice&#x2F;</a>
[5]: <a href="https:&#x2F;&#x2F;github.com&#x2F;evgskv&#x2F;logica">https:&#x2F;&#x2F;github.com&#x2F;evgskv&#x2F;logica</a></div><br/></div></div><div id="40997120" class="c"><input type="checkbox" id="c-40997120" checked=""/><div class="controls bullet"><span class="by">burakemir</span><span>|</span><a href="#40994870">root</a><span>|</span><a href="#40994972">parent</a><span>|</span><a href="#40995241">prev</a><span>|</span><a href="#40995107">next</a><span>|</span><label class="collapse" for="c-40997120">[-]</label><label class="expand" for="c-40997120">[1 more]</label></div><br/><div class="children"><div class="content">Mangle is a language that includes &quot;textbook datalog&quot; as a subset <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;mangle">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;mangle</a> ; like any real-world datalog language, it extends datalog with various facilities to make it practical.<p>It was discussed on HN <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33756800">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33756800</a> and is implemented in go. There is the beginnings of a Rust implementation meanwhile.<p>If you are looking for datalog in the textbooks, here are some references: <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;mangle&#x2F;blob&#x2F;main&#x2F;docs&#x2F;bibliography.md">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;mangle&#x2F;blob&#x2F;main&#x2F;docs&#x2F;bibliography...</a><p>A graph DBs short intro to datalog: just like the edges of a graph could be represented as a simple table (src, target), you could consider a database tuple or a datalog or prolog fact foo(x1, ..., xN) as a &quot;generalized edge.&quot; The nice thing about datalog is then that as one is able to express a connections in an elegant way as &quot;foo(...X...), bar(...X...)&quot; (a conjunction, X being a &quot;node&quot;), whereas in the SQL world one has to deal with a clumsy JOIN statement to express the same thing.</div><br/></div></div><div id="40995107" class="c"><input type="checkbox" id="c-40995107" checked=""/><div class="controls bullet"><span class="by">sirwhinesalot</span><span>|</span><a href="#40994870">root</a><span>|</span><a href="#40994972">parent</a><span>|</span><a href="#40997120">prev</a><span>|</span><a href="#40995131">next</a><span>|</span><label class="collapse" for="c-40995107">[-]</label><label class="expand" for="c-40995107">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t have any interesting references, sorry. My reasoning is mainly one of simplicity and power. In SQL you need to think in terms of tables, inner joins, outer joins, foreign keys etc. whereas datalog you do everything with relations as in prolog.<p>Not only is it conceptually much simpler, it&#x27;s also a &quot;pit of success&quot; situation as thinking in terms of relations instead of tables leads you towards normal forms by default.<p>Add the ability to automatically derive new facts based on rules and it just wins by a country mile. I recommend giving Soufflé a try.<p>I haven&#x27;t worked with GraphDBs enough to comment on that.</div><br/></div></div><div id="40995131" class="c"><input type="checkbox" id="c-40995131" checked=""/><div class="controls bullet"><span class="by">greenavocado</span><span>|</span><a href="#40994870">root</a><span>|</span><a href="#40994972">parent</a><span>|</span><a href="#40995107">prev</a><span>|</span><a href="#40995188">next</a><span>|</span><label class="collapse" for="c-40995131">[-]</label><label class="expand" for="c-40995131">[9 more]</label></div><br/><div class="children"><div class="content">Prolog and Datalog example (they are identical in this case)<p><pre><code>    % Facts
    parent(john, mary).
    parent(mary, ann).
    parent(mary, tom).

    % Rules
    ancestor(X, Y) :- parent(X, Y).
    ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).

    % Query
    ?- ancestor(john, X).
</code></pre>
The Prolog code looks identical to Datalog but the execution model is different. Prolog uses depth-first search and backtracking, which can lead to infinite loops if the rules are not carefully ordered.<p>Datalog starts by evaluating all possible combinations of facts and rules. It builds a bottom-up derivation of all possible facts:<p>a. First, it derives all direct parent relationships.<p>b. Then, it applies the ancestor rules iteratively until no new facts can be derived.<p>For the query ancestor(john, X):<p>It returns all X that satisfy the ancestor relationship with john. This includes mary, ann, and tom. The order of rules doesn&#x27;t affect the result or termination. Datalog guarantees termination because it operates on a finite set of possible facts.<p>Prolog uses a top-down, depth-first search strategy with backtracking.<p>For the query ancestor(john, X):<p>a. It first tries to satisfy parent(john, X). This succeeds with X = mary.<p>b. It then backtracks and tries the second rule: It satisfies parent(john, Y) with Y = mary. Then recursively calls ancestor(mary, X).<p>c. This process continues, exploring the tree depth-first.<p>Prolog will find solutions in this order: mary, ann, tom.<p>The order of clauses can affect both the order of results and termination: If the recursive rule were listed first, Prolog could enter an infinite loop. Prolog doesn&#x27;t guarantee termination, especially with recursive rules.<p>SQL is more verbose. The equivalent of the Datalog&#x2F;Prolog example above is:<p><pre><code>    -- Create and populate the table
    CREATE TABLE Parent (
        parent VARCHAR(50),
        child VARCHAR(50)
    );

    INSERT INTO Parent VALUES (&#x27;john&#x27;, &#x27;mary&#x27;);
    INSERT INTO Parent VALUES (&#x27;mary&#x27;, &#x27;ann&#x27;);
    INSERT INTO Parent VALUES (&#x27;mary&#x27;, &#x27;tom&#x27;);

    -- Recursive query to find ancestors
    WITH RECURSIVE Ancestor AS (
        SELECT parent, child
        FROM Parent
        UNION ALL
        SELECT a.parent, p.child
        FROM Ancestor a
        JOIN Parent p ON a.child = p.parent
    )
    SELECT DISTINCT parent AS ancestor
    FROM Ancestor
    WHERE child IN (&#x27;ann&#x27;, &#x27;tom&#x27;);
</code></pre>
This is a more interesting example of how one might use Datalog on a large dataset:<p><pre><code>    % Define the base relation
    friend(Person1, Person2).

    % Define friend-of-friend relation
    friend_of_friend(X, Z) :- friend(X, Y), friend(Y, Z), X != Z.

    % Define potential friend recommendation
    % (friend of friend who is not already a friend)
    recommend_friend(X, Z) :- friend_of_friend(X, Z), not friend(X, Z).

    % Count mutual friends for recommendations
    mutual_friend_count(X, Z, Count) :- 
        recommend_friend(X, Z),
        Count = count{Y : friend(X, Y), friend(Y, Z)}.

    % Query to get top friend recommendations for a person
    top_recommendations(Person, RecommendedFriend, MutualCount) :-
        mutual_friend_count(Person, RecommendedFriend, MutualCount),
        MutualCount &gt;= 5,
        MutualCount = max{C : mutual_friend_count(Person, _, C)}.
</code></pre>
The equivalent Postgres example would be:<p><pre><code>    WITH RECURSIVE
    -- Base friend relation
    friends AS (
        SELECT DISTINCT person1, person2
        FROM friendship
        UNION
        SELECT person2, person1
        FROM friendship
    ),

    -- Friend of friend relation
    friend_of_friend AS (
        SELECT f1.person1 AS person, f2.person2 AS friend_of_friend
        FROM friends f1
        JOIN friends f2 ON f1.person2 = f2.person1
        WHERE f1.person1 &lt;&gt; f2.person2
    ),

    -- Potential friend recommendations
    potential_recommendations AS (
        SELECT fof.person, fof.friend_of_friend, 
            COUNT(*) AS mutual_friend_count
        FROM friend_of_friend fof
        LEFT JOIN friends f ON fof.person = f.person1 AND fof.friend_of_friend = f.person2
        WHERE f.person1 IS NULL  -- Ensure they&#x27;re not already friends
        GROUP BY fof.person, fof.friend_of_friend
        HAVING COUNT(*) &gt;= 5  -- Minimum mutual friends threshold
    ),

    -- Rank recommendations
    ranked_recommendations AS (
        SELECT person, friend_of_friend, mutual_friend_count,
            RANK() OVER (PARTITION BY person ORDER BY mutual_friend_count DESC) as rank
        FROM potential_recommendations
    )

    -- Get top recommendations
    SELECT person, friend_of_friend, mutual_friend_count
    FROM ranked_recommendations
    WHERE rank = 1;
</code></pre>
Full example you can run yourself: <a href="https:&#x2F;&#x2F;onecompiler.com&#x2F;postgresql&#x2F;42khbswat" rel="nofollow">https:&#x2F;&#x2F;onecompiler.com&#x2F;postgresql&#x2F;42khbswat</a></div><br/><div id="40995691" class="c"><input type="checkbox" id="c-40995691" checked=""/><div class="controls bullet"><span class="by">dkarl</span><span>|</span><a href="#40994870">root</a><span>|</span><a href="#40995131">parent</a><span>|</span><a href="#40995969">next</a><span>|</span><label class="collapse" for="c-40995691">[-]</label><label class="expand" for="c-40995691">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Prolog uses depth-first search and backtracking, which can lead to infinite loops if the rules are not carefully ordered<p>Is this an issue in practice? Most languages can create programs with infinite loops, but it&#x27;s easy to spot in code reviews. It&#x27;s been over a decade since I encountered an infinite loop in production in the backend. Just wondering if the same is true for Prolog.</div><br/><div id="40996755" class="c"><input type="checkbox" id="c-40996755" checked=""/><div class="controls bullet"><span class="by">jodrellblank</span><span>|</span><a href="#40994870">root</a><span>|</span><a href="#40995691">parent</a><span>|</span><a href="#40996278">next</a><span>|</span><label class="collapse" for="c-40996755">[-]</label><label class="expand" for="c-40996755">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s an infinite loop in Prolog, getting the length of a list:<p><pre><code>    length(List_of_animals, Len)
</code></pre>
Oops, List_of_animals hasn&#x27;t been bound to any value, so length&#x2F;2 will backtrack forever making it a longer and longer list of empty placeholders. Nothing will warn you that the variable wasn&#x27;t declared because that&#x27;s also a normal thing to do. Here&#x27;s another, checking if something is in a list:<p><pre><code>    member(cat, List_of_animals)
</code></pre>
same problem, if the list isn&#x27;t grounded to a fixed length list by the time this line executes, backtracking will generate longer and longer lists with `cat` in them and lots of placeholders:<p><pre><code>    [cat]
    [_, cat]
    [_, _, cat]
    ...
</code></pre>
forever. It&#x27;s not just that you can accidentally write an infinite for(;;) loop by typoing the exit condition, it&#x27;s that a lot of things in Prolog can be used in ways which finish deterministically <i>or</i> in ways that act a bit like Python generators <i>yield</i>ing endless answers. So it&#x27;s about the context in which you call them, and the surrounding code. e.g. one reason you&#x27;re using Prolog is that you want it to generate List_of_animals for you (making up fictional animal names, or something), so you can&#x27;t look for a missing `List_of_animals = [...]` because there might not be one anywhere.</div><br/></div></div><div id="40996278" class="c"><input type="checkbox" id="c-40996278" checked=""/><div class="controls bullet"><span class="by">derdi</span><span>|</span><a href="#40994870">root</a><span>|</span><a href="#40995691">parent</a><span>|</span><a href="#40996755">prev</a><span>|</span><a href="#40997521">next</a><span>|</span><label class="collapse" for="c-40996278">[-]</label><label class="expand" for="c-40996278">[1 more]</label></div><br/><div class="children"><div class="content">There are classes of infinite loops that are harder to spot for beginners, it takes a while to really understand the execution model.<p>Prolog variables can have two states at runtime: unbound or bound. A bound variable refers to some value, while an unbound variable is a &quot;hole&quot; to be filled in at a later time. It&#x27;s common to pass an unbound variable into some call and expect the callee to bind it to a value. This can cause problems with infinite recursion where you intend to write a call that binds some variable, but the way you&#x27;ve structured your program, it will not actually bind it. So the callee ends up in the same state as the caller, makes a recursive call hoping its callee will bind the variable, and down the infinite recursion you go. With experience you can definitely spot this in code review. You&#x27;ll also catch it in testing, if you test properly. But it&#x27;s different enough from other languages that learners struggle with it at first.<p>Another source of (seeming) nontermination is when you ask Prolog&#x27;s backtracking search to find an answer to some query in a search space that is too large and may not contain an answer at all, or only an answer that is impracticably far away. This is also sort of Prolog-specific since in other languages you rarely write the same kind of optimistic recursive search. This is harder to spot in code review since it&#x27;s really application-specific what the search space looks like. But again, you test. And when in doubt, you direct and limit the search appropriately.</div><br/></div></div><div id="40997521" class="c"><input type="checkbox" id="c-40997521" checked=""/><div class="controls bullet"><span class="by">ted_dunning</span><span>|</span><a href="#40994870">root</a><span>|</span><a href="#40995691">parent</a><span>|</span><a href="#40996278">prev</a><span>|</span><a href="#40996412">next</a><span>|</span><label class="collapse" for="c-40997521">[-]</label><label class="expand" for="c-40997521">[1 more]</label></div><br/><div class="children"><div class="content">Infinite loops in Prolog can appear with very subtle changes in the use of code.<p>One of the core problems is related to the reversible nature of Prolog. Not only are some programs reversible and some are, practically speaking, not, there are many gradations on this.<p>The result is that programs that look equivalent and whose tests appear equivalent may exhibit non-termination in surprising ways. This is, in my experience, the rule rather than the exception with Prolog.</div><br/></div></div><div id="40996412" class="c"><input type="checkbox" id="c-40996412" checked=""/><div class="controls bullet"><span class="by">yaantc</span><span>|</span><a href="#40994870">root</a><span>|</span><a href="#40995691">parent</a><span>|</span><a href="#40997521">prev</a><span>|</span><a href="#40996257">next</a><span>|</span><label class="collapse" for="c-40996412">[-]</label><label class="expand" for="c-40996412">[1 more]</label></div><br/><div class="children"><div class="content">Take the infinite loop as just an example of an issue with depth-first search and backtracking. To be more general, I&#x27;d say that the issue is that the overall performance of a Prolog program can be very dependent on the ordering of its rules.<p>As an anecdote, a long time ago for a toy project switching two rules order got the runtime to finding all solutions from ~15mn to a around the second (long time, memory fuzzy...). The difference was going into a &quot;wrong&quot; path and wasting a lot of time evaluating failing possibilities, vs. taking the right path and getting to the solutions very quickly.<p>So in practice even if Prolog is declarative to get good results you need to understand how the search is done, and organize the rules so that this search is done in the most efficient way. The runtime search is a leaky abstraction in a way ;)<p>It&#x27;s not an issue limited to Prolog, many solvers can be helped by steering the search in the &quot;right&quot; way. A declarative language for constraint problem like MiniZinc provides way to pass to the solver some indication on how to best search for example.<p>Also, most modern Prolog support tabling, which departs from strict DFS+backtracking and can help in some cases. But here too, to get the best results may require understanding how the engine will search, including tabling.</div><br/></div></div><div id="40996257" class="c"><input type="checkbox" id="c-40996257" checked=""/><div class="controls bullet"><span class="by">Normal_gaussian</span><span>|</span><a href="#40994870">root</a><span>|</span><a href="#40995691">parent</a><span>|</span><a href="#40996412">prev</a><span>|</span><a href="#40995969">next</a><span>|</span><label class="collapse" for="c-40996257">[-]</label><label class="expand" for="c-40996257">[1 more]</label></div><br/><div class="children"><div class="content">Yes.<p>It is trivially easy to create loops of rules when describing abstract properties.<p>Concrete properties tend to have &quot;levels&quot; to them, but many human concepts are self-referential.<p>In this way, its possible to spot that there may be an issue now or in the future, because the presence or lack of a loop depends on the specific choice of dependencies of a concept. However spotting the potential for a loop doesn&#x27;t do a lot to help remove its potential existence, or show that it is there or not there.</div><br/></div></div></div></div><div id="40995969" class="c"><input type="checkbox" id="c-40995969" checked=""/><div class="controls bullet"><span class="by">dmpk2k</span><span>|</span><a href="#40994870">root</a><span>|</span><a href="#40995131">parent</a><span>|</span><a href="#40995691">prev</a><span>|</span><a href="#40995188">next</a><span>|</span><label class="collapse" for="c-40995969">[-]</label><label class="expand" for="c-40995969">[2 more]</label></div><br/><div class="children"><div class="content">How does the Datalog approach compare with RETE?</div><br/><div id="40997557" class="c"><input type="checkbox" id="c-40997557" checked=""/><div class="controls bullet"><span class="by">ted_dunning</span><span>|</span><a href="#40994870">root</a><span>|</span><a href="#40995969">parent</a><span>|</span><a href="#40995188">next</a><span>|</span><label class="collapse" for="c-40997557">[-]</label><label class="expand" for="c-40997557">[1 more]</label></div><br/><div class="children"><div class="content">The big deal about Datalog is that it is equivalent to SQL-with-recursion. Thus, it can compile to database queries.</div><br/></div></div></div></div></div></div></div></div><div id="40995188" class="c"><input type="checkbox" id="c-40995188" checked=""/><div class="controls bullet"><span class="by">worldsayshi</span><span>|</span><a href="#40994870">parent</a><span>|</span><a href="#40994972">prev</a><span>|</span><a href="#40995530">next</a><span>|</span><label class="collapse" for="c-40995188">[-]</label><label class="expand" for="c-40995188">[8 more]</label></div><br/><div class="children"><div class="content">Are there any production ready open source databases using it?</div><br/><div id="40995648" class="c"><input type="checkbox" id="c-40995648" checked=""/><div class="controls bullet"><span class="by">networked</span><span>|</span><a href="#40994870">root</a><span>|</span><a href="#40995188">parent</a><span>|</span><a href="#40995586">next</a><span>|</span><label class="collapse" for="c-40995648">[-]</label><label class="expand" for="c-40995648">[1 more]</label></div><br/><div class="children"><div class="content">DataScript, Datahike, Datalevin, and XTDB 1.x are open-source.
(XTDB 2.x is also open-source but has switched from Datalog to its own query language and SQL.)
DataScript, Datalevin, and XTDB have been used in production; not sure about Datahike.
All of these databases come from the Clojure community and target Clojure as the primary language.
The XTDB team has published a comparison matrix at <a href="https:&#x2F;&#x2F;clojurelog.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;clojurelog.github.io&#x2F;</a>.<p>Aside:
I write a lot more Python than Clojure,
and I wish someone ported Datalevin&#x2F;Datahike&#x2F;persistent DataScript to Python.
I&#x27;d try it as an alternative to SQLite.
I suspect with thoughtful API design, an embedded Datalog could feel organic in Python.
It might be easier to prototype with than SQLite.
There are Datalog and miniKanren implementations for Python, but they are not designed as an on-disk database.
PyCozo might be the closest thing that exists.
(A sibling comment <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40995652">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40995652</a> already mentions Cozo.)</div><br/></div></div><div id="40995586" class="c"><input type="checkbox" id="c-40995586" checked=""/><div class="controls bullet"><span class="by">refset</span><span>|</span><a href="#40994870">root</a><span>|</span><a href="#40995188">parent</a><span>|</span><a href="#40995648">prev</a><span>|</span><a href="#40995309">next</a><span>|</span><label class="collapse" for="c-40995586">[-]</label><label class="expand" for="c-40995586">[1 more]</label></div><br/><div class="children"><div class="content">Compiling Datalog to SQL with Logica is possibly the easiest path if you need a production ready open source Datalog setup (i.e. choose your favourite managed Postgres provider): <a href="https:&#x2F;&#x2F;logica.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;logica.dev&#x2F;</a></div><br/></div></div><div id="40995309" class="c"><input type="checkbox" id="c-40995309" checked=""/><div class="controls bullet"><span class="by">sirwhinesalot</span><span>|</span><a href="#40994870">root</a><span>|</span><a href="#40995188">parent</a><span>|</span><a href="#40995586">prev</a><span>|</span><a href="#40995652">next</a><span>|</span><label class="collapse" for="c-40995309">[-]</label><label class="expand" for="c-40995309">[4 more]</label></div><br/><div class="children"><div class="content">Datomic uses Datalog with a weird clojure syntax instead of the usual prolog-like syntax.</div><br/><div id="40995418" class="c"><input type="checkbox" id="c-40995418" checked=""/><div class="controls bullet"><span class="by">worldsayshi</span><span>|</span><a href="#40994870">root</a><span>|</span><a href="#40995309">parent</a><span>|</span><a href="#40995652">next</a><span>|</span><label class="collapse" for="c-40995418">[-]</label><label class="expand" for="c-40995418">[3 more]</label></div><br/><div class="children"><div class="content">Not open source though?</div><br/><div id="40996146" class="c"><input type="checkbox" id="c-40996146" checked=""/><div class="controls bullet"><span class="by">KingMob</span><span>|</span><a href="#40994870">root</a><span>|</span><a href="#40995418">parent</a><span>|</span><a href="#40995505">next</a><span>|</span><label class="collapse" for="c-40996146">[-]</label><label class="expand" for="c-40996146">[1 more]</label></div><br/><div class="children"><div class="content">No. It&#x27;s only free as in beer. There&#x27;s some weird mention about the Apache 2 license, but it only applies to the <i>binaries</i>, for some odd reason.</div><br/></div></div><div id="40995505" class="c"><input type="checkbox" id="c-40995505" checked=""/><div class="controls bullet"><span class="by">sirwhinesalot</span><span>|</span><a href="#40994870">root</a><span>|</span><a href="#40995418">parent</a><span>|</span><a href="#40996146">prev</a><span>|</span><a href="#40995652">next</a><span>|</span><label class="collapse" for="c-40995505">[-]</label><label class="expand" for="c-40995505">[1 more]</label></div><br/><div class="children"><div class="content">Hmm open source I&#x27;m not sure, there are many SQLite equivalents listed on wikipedia though, if that counts.</div><br/></div></div></div></div></div></div><div id="40995652" class="c"><input type="checkbox" id="c-40995652" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#40994870">root</a><span>|</span><a href="#40995188">parent</a><span>|</span><a href="#40995309">prev</a><span>|</span><a href="#40995530">next</a><span>|</span><label class="collapse" for="c-40995652">[-]</label><label class="expand" for="c-40995652">[1 more]</label></div><br/><div class="children"><div class="content">Not sure if &quot;production ready&quot; but it&#x27;s worth looking at Cozo:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;cozodb&#x2F;cozo">https:&#x2F;&#x2F;github.com&#x2F;cozodb&#x2F;cozo</a><p>Has a dialect of Datalog + some vector support. Multiple storage engines for backend including SQLite, so if your concern is data stability that seems like a reasonable, proven option.</div><br/></div></div></div></div></div></div><div id="40995530" class="c"><input type="checkbox" id="c-40995530" checked=""/><div class="controls bullet"><span class="by">honorious</span><span>|</span><a href="#40994870">prev</a><span>|</span><a href="#40995032">next</a><span>|</span><label class="collapse" for="c-40995530">[-]</label><label class="expand" for="c-40995530">[1 more]</label></div><br/><div class="children"><div class="content">I have been interested in Prolog since my time at the University, and I loved the idea of logic programming.<p>For &quot;proper&quot; Prolog, in 2024 it is a niche language alive in specific constraint solving applications, but not really used outside of that. I haven&#x27;t seen anyone attempting at using prolog as a general purpose language since the 90&#x27;.<p>Datalog and logic-inspired languages tend to pop up here and there as domain-specific languages.<p>Rego is a recent incarnation which had good adoption for k8s and other &quot;modern&quot; systems. However, when trying to get people in my org to adopt it in practice, I saw engineers struggle with the paradigm when complexity grows to more than toy problems.</div><br/></div></div><div id="40995032" class="c"><input type="checkbox" id="c-40995032" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#40995530">prev</a><span>|</span><a href="#41003563">next</a><span>|</span><label class="collapse" for="c-40995032">[-]</label><label class="expand" for="c-40995032">[4 more]</label></div><br/><div class="children"><div class="content">With compliments to your prof ;), interest in Prolog just now is recovering from a year-long focus on W3C&#x27;s RDF&#x2F;SPARQL. TBL surely had an itch to scratch with regards to logical knowledge representation dating back even longer than the web [1]. But Prolog has broader applicability not only in logical&#x2F;knowledge graph querying, but also in solving all kinds of discrete combinatorical optimization problems. Or, as the Quantum Prolog site [2] puts it, &quot;planning, optimization, diagnostics, and complex configuration.&quot; The site demos logistics optimization (in-browser demo) and reports initial optimization (parallelization) of Inductive Logic Programming and other ML tasks for partially auto-generating Prolog code from existing solutions.<p>Edit: ... and on performance vs SWI Prolog, too<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ENQUIRE" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ENQUIRE</a><p>[2]: <a href="https:&#x2F;&#x2F;quantumprolog.sgml.io" rel="nofollow">https:&#x2F;&#x2F;quantumprolog.sgml.io</a></div><br/><div id="40996033" class="c"><input type="checkbox" id="c-40996033" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#40995032">parent</a><span>|</span><a href="#41003563">next</a><span>|</span><label class="collapse" for="c-40996033">[-]</label><label class="expand" for="c-40996033">[3 more]</label></div><br/><div class="children"><div class="content">The problem w&#x2F; OWL is that everybody wants to work with first-order logic + math,  but Gödel proved it isn&#x27;t decidable.<p>For instance if I wanted to express financial regulations or business rules inside a bank or other business I&#x27;d need to use math:  for instance to express the conditions for reserve requirements or approving a loan.<p>OWL is best thought of as a set of templates for generating first-order logic rules that are decidable and also (in theory) quick to evaluate with the Tableau algorithm.<p>In certain domains you might tolerate tools that are imperfect,  like it isn&#x27;t fair to expect a SMT solver to figure out this one<p><pre><code>   x^N + y^N = z^N
</code></pre>
where x,y,z and N are all positive integers with N&gt;2.  For that one it would try to find solutions and probably time out.  For some similar problems (a different polynomial) it might give you an answer.<p>OWL doesn&#x27;t want to go there which is a big reason people say &quot;Nein Danke!&quot;</div><br/><div id="40996321" class="c"><input type="checkbox" id="c-40996321" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#40995032">root</a><span>|</span><a href="#40996033">parent</a><span>|</span><a href="#41003563">next</a><span>|</span><label class="collapse" for="c-40996321">[-]</label><label class="expand" for="c-40996321">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Gödel proved it isn&#x27;t decidable.<p>He did no such thing. He proved undecidable problems exist in any system powerful enough to be useful. That doesn’t make those systems useless, though.</div><br/><div id="40997074" class="c"><input type="checkbox" id="c-40997074" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#40995032">root</a><span>|</span><a href="#40996321">parent</a><span>|</span><a href="#41003563">next</a><span>|</span><label class="collapse" for="c-40997074">[-]</label><label class="expand" for="c-40997074">[1 more]</label></div><br/><div class="children"><div class="content">The trouble is the creators of OWL wanted to have performance and reliability bounds.  That is,  they want to make systems that act like more like a conventional database server than an SMT solver.<p>I think they could have made a more expressive standard and something like that might have had more appeal to people but been less consistent in terms of performance.</div><br/></div></div></div></div></div></div></div></div><div id="41003563" class="c"><input type="checkbox" id="c-41003563" checked=""/><div class="controls bullet"><span class="by">kamaal</span><span>|</span><a href="#40995032">prev</a><span>|</span><a href="#40997351">next</a><span>|</span><label class="collapse" for="c-41003563">[-]</label><label class="expand" for="c-41003563">[1 more]</label></div><br/><div class="children"><div class="content">If you are struggling to get Prolog.<p>Think about it this way. In a regular programming language you write code and then write unit test cases to validate it.<p>In prolog, all you do is write the test cases and then its up to the compiler to write and run the code for you. In other words you define a set of cases for which a logic is supposed to hold true. The compiler then decides what the code must look like if that is the case.<p>This might look easy for simple True&#x2F;False kind of cases. But when you have to write test cases for functions that return deeply nested data structures and all their variations. Then it becomes easier said than done. The other part that makes Prolog hard to get, is you are only allowed recursion to iterate or define things. All of this makes it a little hard to think, write and trouble shoot Prolog.<p>If you are reading Prolog code then try to think of it like you have access to a code repo&#x27;s unit test cases, but the actual code doesn&#x27;t exist. The test cases are considered sufficient enough to define the code in a concrete way.<p>As you might have started to notice by now. This is actually harder than writing the code itself. In a regular programming language, you get sufficient space to write a function that might not do 100% of what was intended(bugs). Im prolog such an adventure will produce absolutely something else altogether.</div><br/></div></div><div id="40997351" class="c"><input type="checkbox" id="c-40997351" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#41003563">prev</a><span>|</span><a href="#40994700">next</a><span>|</span><label class="collapse" for="c-40997351">[-]</label><label class="expand" for="c-40997351">[1 more]</label></div><br/><div class="children"><div class="content">My honest opinion is to avoid Prolog for most enterprise needs in favor of a regular general purpose programming language that calls out to a mathematical or constraint solver via API when the need arises. This way you get a language that is easier to learn with a strong ecosystem of libraries along with a solver that is built for your particular problem.<p>Prolog may excel in some niche cases that are documented out there which is fine. For the majority of cases I can think of...it is too esoteric.<p>Prolog is SUPER cool though as is it&#x27;s history. You should definitely play with it a bit.</div><br/></div></div><div id="40994700" class="c"><input type="checkbox" id="c-40994700" checked=""/><div class="controls bullet"><span class="by">hendler</span><span>|</span><a href="#40997351">prev</a><span>|</span><a href="#40994766">next</a><span>|</span><label class="collapse" for="c-40994700">[-]</label><label class="expand" for="c-40994700">[7 more]</label></div><br/><div class="children"><div class="content">Prolog itself is still developed and used in various settings (mostly swi-prolog?), but other languages and logic engines solve domain specific but similar problems better (rule engines, formal proof verifiers, etc). For exploratory work it can be useful.<p>I have tried to use it in combination will LLMs unsuccessfully, partly because the domain was not specific enough. Otherwise you need a lot of real world knowledge and a large fact database.<p>Logic engines for first order logic in RDF&#x2F;OWL also have interesting logical inference abilities, like graphdbs.<p>Any programming language can do &quot;logic&quot; and the work at MIT&#x2F;CSAIL in probabilistic programming may turn out to be a better way to combine fuzzy logic and formal proofs.<p>Not sure this answers your question, but maybe this points towards some interesting directions.</div><br/><div id="40994759" class="c"><input type="checkbox" id="c-40994759" checked=""/><div class="controls bullet"><span class="by">overclock351</span><span>|</span><a href="#40994700">parent</a><span>|</span><a href="#40995007">next</a><span>|</span><label class="collapse" for="c-40994759">[-]</label><label class="expand" for="c-40994759">[4 more]</label></div><br/><div class="children"><div class="content">Any answer here is a good one since the question is soooo unspecific :D.
My professor is a staunch advocate for RDF&#x2F;OWL, inference engines and stuff like that  (hence why i also mentioned ontologies :D).<p>The thing is that i think that the language itself has so much untapped potential and the world that i dived into with my studies is so vast, so full of stuff that it left me kind of dazed to be fair!<p>I got some papers in regards to knowledge representation (that to be fair i still have to read... exams and work got in the midst of all :&#x2F;) but still it seems so... odd:
when we were studying OOP in my bachelor we went over the usual examples that made you understand &quot;this is not an imperative paradigm but there are object abstractions&quot; while, in my studies, prolog and logic programming in general was seen as a tool of sorts for reaching an objective like &quot;hey we have a MAS system, let&#x27;s sprinkle some prolog in it for fun :D&quot; (maybe i am exaggerating but it feels like this lol). 
I feel it can do much much more</div><br/><div id="40994986" class="c"><input type="checkbox" id="c-40994986" checked=""/><div class="controls bullet"><span class="by">felixyz</span><span>|</span><a href="#40994700">root</a><span>|</span><a href="#40994759">parent</a><span>|</span><a href="#40996028">next</a><span>|</span><label class="collapse" for="c-40994986">[-]</label><label class="expand" for="c-40994986">[2 more]</label></div><br/><div class="children"><div class="content">You are definitely on to something here. OOP has some common roots with formal ontologies and knowledge representation (not so much the programming languages, but object oriented modeling). OO fails at this for various reasons, whereas logic is tailored for this specific purpose. Check out ErgoAI (formerly Flora-2), it&#x27;s the most advanced Prolog flavor for representing and reasoning over knowledge. <a href="https:&#x2F;&#x2F;github.com&#x2F;ErgoAI">https:&#x2F;&#x2F;github.com&#x2F;ErgoAI</a></div><br/><div id="40995020" class="c"><input type="checkbox" id="c-40995020" checked=""/><div class="controls bullet"><span class="by">overclock351</span><span>|</span><a href="#40994700">root</a><span>|</span><a href="#40994986">parent</a><span>|</span><a href="#40996028">next</a><span>|</span><label class="collapse" for="c-40995020">[-]</label><label class="expand" for="c-40995020">[1 more]</label></div><br/><div class="children"><div class="content">you guys are giving me so much to read thanks &lt;3 i&#x27;ll give this a check when i have some time out of exams&#x2F;work. I will surely check ErgoAI</div><br/></div></div></div></div><div id="40996028" class="c"><input type="checkbox" id="c-40996028" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#40994700">root</a><span>|</span><a href="#40994759">parent</a><span>|</span><a href="#40994986">prev</a><span>|</span><a href="#40995007">next</a><span>|</span><label class="collapse" for="c-40996028">[-]</label><label class="expand" for="c-40996028">[1 more]</label></div><br/><div class="children"><div class="content">If you want to see something truly fascinating, take apart <a href="https:&#x2F;&#x2F;logtalk.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;logtalk.org&#x2F;</a> - it implements an OO system for prolog which gives you all sorts of advantages (the least of which being a not-terrible way of getting namespaces).<p>Reading &quot;The Art of Prolog&quot; and &quot;The Craft of Prolog&quot; was fun for me, as was learning how the Warren Abstract Machine works.<p>(I am not at all a prolog expert, merely a programmer who happens to be fascinated by it, so this is all dabbling on my end but hopefully provides some stuff that&#x27;s fun to learn for you as well)</div><br/></div></div></div></div><div id="40995007" class="c"><input type="checkbox" id="c-40995007" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#40994700">parent</a><span>|</span><a href="#40994759">prev</a><span>|</span><a href="#40994766">next</a><span>|</span><label class="collapse" for="c-40995007">[-]</label><label class="expand" for="c-40995007">[2 more]</label></div><br/><div class="children"><div class="content">Hi! Are you Jim Hendler (or related to him), my Reagan-era AI professor from UMD?<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;James_Hendler" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;James_Hendler</a><p>My Prolog programming assignment #4, a Prolog &quot;nehcihsahA&quot; detector (maternal uncle: a mother&#x27;s brother, or any equivalent relative) seemed designed to make me hate Prolog with a passion, involving bending over backwards by defining ridiculous predicates like siblish, sibloid, relatoid, sistoid, brothoid, mothoid, and fathoid.<p><a href="https:&#x2F;&#x2F;www.donhopkins.com&#x2F;home&#x2F;code&#x2F;nehcihsaha.prolog.txt" rel="nofollow">https:&#x2F;&#x2F;www.donhopkins.com&#x2F;home&#x2F;code&#x2F;nehcihsaha.prolog.txt</a><p>I much more enjoyed the OPS-5 programming assignment #6, for which I made a worm simulation that hacked into Ollie North&#x27;s Intimus-007s (&quot;the ace of security paper shredders&quot;) in the White House basement, via Professor Hendler&#x27;s Sun workstation dormouse, rms&#x27;s account with password rms on prep, and Casper Weinberger&#x27;s account on UMD&#x27;s Vax 11&#x2F;780 mimsy and NSA&#x27;s PDP-11&#x2F;70 tycho, connected via the NSA&#x27;s MILNET IMP 57 at Fort Mead, then posted Ollie North&#x27;s secret diary and notes it found in the paper shredder to talk.rumors via the UCB-Vax usenet gateway.<p><a href="https:&#x2F;&#x2F;www.donhopkins.com&#x2F;home&#x2F;code&#x2F;crack-ollie.ops5.txt" rel="nofollow">https:&#x2F;&#x2F;www.donhopkins.com&#x2F;home&#x2F;code&#x2F;crack-ollie.ops5.txt</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18376750">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18376750</a><p>&gt;At the University of Maryland, our network access was through the NSA&#x27;s &quot;secret&quot; MILNET IMP 57 at Fort Mead. It was pretty obvious that UMD got their network access via NSA, because mimsy.umd.edu had a similar &quot;*.57&quot; IP address as dockmaster, tycho and coins. [...]</div><br/><div id="40995556" class="c"><input type="checkbox" id="c-40995556" checked=""/><div class="controls bullet"><span class="by">derdi</span><span>|</span><a href="#40994700">root</a><span>|</span><a href="#40995007">parent</a><span>|</span><a href="#40994766">next</a><span>|</span><label class="collapse" for="c-40995556">[-]</label><label class="expand" for="c-40995556">[1 more]</label></div><br/><div class="children"><div class="content">&gt; My Prolog programming assignment #4, a Prolog &quot;nehcihsahA&quot; detector (maternal uncle: a mother&#x27;s brother, or any equivalent relative) seemed designed to make me hate Prolog with a passion, involving bending over backwards by defining ridiculous predicates<p>Your attempt at a solution definitely defines ridiculous predicates, but you should not blame that on your teacher or the language. For example, there is no way that defining &quot;a mother&#x27;s brother&quot; would need to refer to a &quot;same sex&quot; predicate in any way. You took a wrong turn somewhere with your approach, but again it&#x27;s neither the language nor your teacher that forced you down that path.</div><br/></div></div></div></div></div></div><div id="40994766" class="c"><input type="checkbox" id="c-40994766" checked=""/><div class="controls bullet"><span class="by">sprayk</span><span>|</span><a href="#40994700">prev</a><span>|</span><a href="#40997800">next</a><span>|</span><label class="collapse" for="c-40994766">[-]</label><label class="expand" for="c-40994766">[1 more]</label></div><br/><div class="children"><div class="content">The most recent prolog news I&#x27;ve come across in recent years is some updates to SWIprolog (can&#x27;t find a good link) and some talk of Scryer-prolog[0] which is a more recent implementation of Prolog in Rust.<p>One interesting development recently is a load of research into, reverse engineering of and emulation of the 1986 Sega AI Computer[1], which used prolog under the hood for mostly educational software. Unfortunately it does not seem there is a way to actually write some prolog for the thing today :(<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;mthom&#x2F;scryer-prolog">https:&#x2F;&#x2F;github.com&#x2F;mthom&#x2F;scryer-prolog</a><p>[1] <a href="https:&#x2F;&#x2F;www.smspower.org&#x2F;SegaAI&#x2F;Index" rel="nofollow">https:&#x2F;&#x2F;www.smspower.org&#x2F;SegaAI&#x2F;Index</a></div><br/></div></div><div id="40997800" class="c"><input type="checkbox" id="c-40997800" checked=""/><div class="controls bullet"><span class="by">tpoacher</span><span>|</span><a href="#40994766">prev</a><span>|</span><a href="#40995695">next</a><span>|</span><label class="collapse" for="c-40997800">[-]</label><label class="expand" for="c-40997800">[1 more]</label></div><br/><div class="children"><div class="content">You may find this paper interesting: <a href="https:&#x2F;&#x2F;www.cambridge.org&#x2F;core&#x2F;journals&#x2F;theory-and-practice-of-logic-programming&#x2F;article&#x2F;fifty-years-of-prolog-and-beyond&#x2F;3A5329B6E3639879301A6D44346FD1DD" rel="nofollow">https:&#x2F;&#x2F;www.cambridge.org&#x2F;core&#x2F;journals&#x2F;theory-and-practice-...</a><p>title: Fifty Years of Prolog and Beyond (2022)</div><br/></div></div><div id="40995695" class="c"><input type="checkbox" id="c-40995695" checked=""/><div class="controls bullet"><span class="by">Nihilartikel</span><span>|</span><a href="#40997800">prev</a><span>|</span><a href="#40994909">next</a><span>|</span><label class="collapse" for="c-40995695">[-]</label><label class="expand" for="c-40995695">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve brushed up against it in the form of datalog as the query language for databases like datomic and xtdb, so it&#x27;s soul is alive and well!<p>I&#x27;m also considering a prolog like domain specific language to make a state syncing engine with pure declarations of how the state in system A is reflected in System B, etc.<p>Prolog itself may not be mainstream, but it is an answer to a the universal problem space of constraint solution, so comp sci will always be in its long shadow.</div><br/></div></div><div id="40994909" class="c"><input type="checkbox" id="c-40994909" checked=""/><div class="controls bullet"><span class="by">aldousd666</span><span>|</span><a href="#40995695">prev</a><span>|</span><a href="#40994753">next</a><span>|</span><label class="collapse" for="c-40994909">[-]</label><label class="expand" for="c-40994909">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve actually been thinking about this quite a bit. I remember a foray into prolog when I was a younger pup in 2004-6. With the Advent of llms, I think that perhaps we could use llms to extract triples from large corpuses of text and then use that to build our prolog stores or ontologies and work on them. I haven&#x27;t really experimented much with it but you saying this has reminded me that I should dig that back up again.</div><br/></div></div><div id="40994753" class="c"><input type="checkbox" id="c-40994753" checked=""/><div class="controls bullet"><span class="by">a-french-anon</span><span>|</span><a href="#40994909">prev</a><span>|</span><a href="#40998895">next</a><span>|</span><label class="collapse" for="c-40994753">[-]</label><label class="expand" for="c-40994753">[3 more]</label></div><br/><div class="children"><div class="content">No idea, but it might be worth looking into Mercury and {mini,micro}Kanren&#x2F;core.logic as more practical iterations on it (either by adding things to Prolog or extracting the interesting to stuff to use in more general purpose languages).</div><br/><div id="40994997" class="c"><input type="checkbox" id="c-40994997" checked=""/><div class="controls bullet"><span class="by">Avshalom</span><span>|</span><a href="#40994753">parent</a><span>|</span><a href="#40998895">next</a><span>|</span><label class="collapse" for="c-40994997">[-]</label><label class="expand" for="c-40994997">[2 more]</label></div><br/><div class="children"><div class="content">At the end of the day &quot;practical&quot; means library support and community knowledge, by which measure Prolog and more specifically SWI and Sicstus are far more practical than any of the other logic languages or implementation options</div><br/><div id="40995757" class="c"><input type="checkbox" id="c-40995757" checked=""/><div class="controls bullet"><span class="by">harperlee</span><span>|</span><a href="#40994753">root</a><span>|</span><a href="#40994997">parent</a><span>|</span><a href="#40998895">next</a><span>|</span><label class="collapse" for="c-40995757">[-]</label><label class="expand" for="c-40995757">[1 more]</label></div><br/><div class="children"><div class="content">Well if your problem does not require a solution that’s 100% written in prolog, then any relational&#x2F;CLP system that can be hosted or work as a library is going to win in terms of library support and community knowledge, at solution level.<p>So e.g. a core.logic solution can make extensive use of the jvm ecosystem.</div><br/></div></div></div></div></div></div><div id="40998895" class="c"><input type="checkbox" id="c-40998895" checked=""/><div class="controls bullet"><span class="by">wkyleg</span><span>|</span><a href="#40994753">prev</a><span>|</span><a href="#40995284">next</a><span>|</span><label class="collapse" for="c-40998895">[-]</label><label class="expand" for="c-40998895">[1 more]</label></div><br/><div class="children"><div class="content">I like Peter Norvig&#x27;s book &quot;Paradigms of AI Programming,&quot; where you learn old fashioned symbolic AI with LISP and Prolog. Is it outdated? Absolutely, but it is a classic read.<p>Maybe a use case for new AI models could be creating more old fashioned expert systems written in LISP or Prolog that are easier for humans to audit. Everything tends to come back full circle.<p><a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Paradigms-Artificial-Intelligence-Programming-Studies&#x2F;dp&#x2F;1558601910" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;Paradigms-Artificial-Intelligence-Pro...</a></div><br/></div></div><div id="40995284" class="c"><input type="checkbox" id="c-40995284" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#40998895">prev</a><span>|</span><a href="#40994723">next</a><span>|</span><label class="collapse" for="c-40995284">[-]</label><label class="expand" for="c-40995284">[1 more]</label></div><br/><div class="children"><div class="content">Tangent to Prolog, perhaps check Flix, which includes logic programming features [1], and is discussed here from time to time [2].<p>--<p>1: <a href="https:&#x2F;&#x2F;doc.flix.dev&#x2F;fixpoints.html" rel="nofollow">https:&#x2F;&#x2F;doc.flix.dev&#x2F;fixpoints.html</a><p>2: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25513397">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25513397</a><p>2: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31448889">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31448889</a><p>2: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38419263">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38419263</a></div><br/></div></div><div id="40994723" class="c"><input type="checkbox" id="c-40994723" checked=""/><div class="controls bullet"><span class="by">xavxav</span><span>|</span><a href="#40995284">prev</a><span>|</span><a href="#40994780">next</a><span>|</span><label class="collapse" for="c-40994723">[-]</label><label class="expand" for="c-40994723">[1 more]</label></div><br/><div class="children"><div class="content">There is still academic work on Prolog, and more broadly deductive &#x2F; logic programming. If you are looking at things with a more industrial bent, I would look to Datalog which trades generality in Prolog for performance and predictability. Alternatively, you can go the other way and look at lambdaProlog which adds real abstractions &#x2F; HOFs to Prolog.<p>What I&#x27;ve seen in practice is that while Prolog may be good at <i>describing</i> a solution, its performance is often too lackluster and brittle for actual deployment: it probably fits more as a prototyping language before you do a classic implementation of the solution in a more traditional language.</div><br/></div></div><div id="40994780" class="c"><input type="checkbox" id="c-40994780" checked=""/><div class="controls bullet"><span class="by">mtsfz2</span><span>|</span><a href="#40994723">prev</a><span>|</span><a href="#41001030">next</a><span>|</span><label class="collapse" for="c-40994780">[-]</label><label class="expand" for="c-40994780">[2 more]</label></div><br/><div class="children"><div class="content">There are certain (academic) problems for which Prolog is simply the best tool for the job, see e.g., <a href="https:&#x2F;&#x2F;github.com&#x2F;hbrouwer&#x2F;dfs-tools">https:&#x2F;&#x2F;github.com&#x2F;hbrouwer&#x2F;dfs-tools</a></div><br/><div id="40995198" class="c"><input type="checkbox" id="c-40995198" checked=""/><div class="controls bullet"><span class="by">moffkalast</span><span>|</span><a href="#40994780">parent</a><span>|</span><a href="#41001030">next</a><span>|</span><label class="collapse" for="c-40995198">[-]</label><label class="expand" for="c-40995198">[1 more]</label></div><br/><div class="children"><div class="content">&gt; (academic)<p>Ah, for a second I thought someone just found a way to make Prolog useful for something. What a terrifying thought indeed, luckily the crisis has been averted, the natural order is restored and all is well.</div><br/></div></div></div></div><div id="41001030" class="c"><input type="checkbox" id="c-41001030" checked=""/><div class="controls bullet"><span class="by">wolfspider</span><span>|</span><a href="#40994780">prev</a><span>|</span><a href="#40998289">next</a><span>|</span><label class="collapse" for="c-41001030">[-]</label><label class="expand" for="c-41001030">[1 more]</label></div><br/><div class="children"><div class="content">Formal verification uses Prolog a lot. System on TPTP at U of Miami utilizes this for many of the formally verified tests on there. It is just a more intense discipline than general programming which is why I’m perpetually drawn to it trying to find more real world applications. It is not exactly Prolog but close enough to mention the similarities.</div><br/></div></div><div id="40998289" class="c"><input type="checkbox" id="c-40998289" checked=""/><div class="controls bullet"><span class="by">waldrews</span><span>|</span><a href="#41001030">prev</a><span>|</span><a href="#41000850">next</a><span>|</span><label class="collapse" for="c-40998289">[-]</label><label class="expand" for="c-40998289">[1 more]</label></div><br/><div class="children"><div class="content">There are a few magical algorithms&#x2F;systems which give you superpowers if you can find the right application for them.  At least in the pre-LLM era, they were some of the magical tools we had, for just solving declaratively specified difficult problems without us explicitly writing code, while (unlike certain AI techniques which shall remain nameless) providing correctness guarantees and often being deterministic and stable.<p>Prolog and logic programming is one, together with its relative, constraint logic programming, and its relative mixed integer programming, which in turn is part of the broader linear and convex programming family.<p>What else should we put in that category?</div><br/></div></div><div id="41000850" class="c"><input type="checkbox" id="c-41000850" checked=""/><div class="controls bullet"><span class="by">ghufran_syed</span><span>|</span><a href="#40998289">prev</a><span>|</span><a href="#40995222">next</a><span>|</span><label class="collapse" for="c-41000850">[-]</label><label class="expand" for="c-41000850">[1 more]</label></div><br/><div class="children"><div class="content">I know almost nothing about prolog, but I enjoyed this tutorial using Datalog, a subset of prolog as an alternative data query language to SQL: <a href="https:&#x2F;&#x2F;www.learndatalogtoday.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.learndatalogtoday.org&#x2F;</a></div><br/></div></div><div id="40995222" class="c"><input type="checkbox" id="c-40995222" checked=""/><div class="controls bullet"><span class="by">zelos</span><span>|</span><a href="#41000850">prev</a><span>|</span><label class="collapse" for="c-40995222">[-]</label><label class="expand" for="c-40995222">[1 more]</label></div><br/><div class="children"><div class="content">Eclipse CLP still seems slightly active: <a href="https:&#x2F;&#x2F;eclipseclp.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;eclipseclp.org&#x2F;</a>. I used it for some process scheduling research in the early 2000s but I&#x27;ve never had the chance to apply it in the non-academic world</div><br/></div></div></div></div></div></div></div></body></html>