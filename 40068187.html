<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713430860368" as="style"/><link rel="stylesheet" href="styles.css?v=1713430860368"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://antithesis.com/blog/sdtalk/">How Antithesis finds bugs</a> <span class="domain">(<a href="https://antithesis.com">antithesis.com</a>)</span></div><div class="subtext"><span>wwilson</span> | <span>51 comments</span></div><br/><div><div id="40071185" class="c"><input type="checkbox" id="c-40071185" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#40074264">next</a><span>|</span><label class="collapse" for="c-40071185">[-]</label><label class="expand" for="c-40071185">[5 more]</label></div><br/><div class="children"><div class="content">Have you tried to &#x27;rediscover&#x27; classic (in)famous bugs? E.g. take an old version of OpenSSL vulnerable to heartbleed and run Antethesis on it to &#x27;discover&#x27; heartbleed via fuzzing. It would be interesting to see how much fine tuning would be needed to discover it.</div><br/><div id="40071828" class="c"><input type="checkbox" id="c-40071828" checked=""/><div class="controls bullet"><span class="by">nlavezzo</span><span>|</span><a href="#40071185">parent</a><span>|</span><a href="#40071914">next</a><span>|</span><label class="collapse" for="c-40071828">[-]</label><label class="expand" for="c-40071828">[1 more]</label></div><br/><div class="children"><div class="content">This is a cool idea. I’ll ask the team about it. Would make for a very interesting blog post or talk!</div><br/></div></div><div id="40071914" class="c"><input type="checkbox" id="c-40071914" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#40071185">parent</a><span>|</span><a href="#40071828">prev</a><span>|</span><a href="#40071776">next</a><span>|</span><label class="collapse" for="c-40071914">[-]</label><label class="expand" for="c-40071914">[1 more]</label></div><br/><div class="children"><div class="content">Excellent idea and it would be a great way to pitch it. What about collaborations with Jepsen?</div><br/></div></div><div id="40072707" class="c"><input type="checkbox" id="c-40072707" checked=""/><div class="controls bullet"><span class="by">eichin</span><span>|</span><a href="#40071185">parent</a><span>|</span><a href="#40071776">prev</a><span>|</span><a href="#40074264">next</a><span>|</span><label class="collapse" for="c-40072707">[-]</label><label class="expand" for="c-40072707">[1 more]</label></div><br/><div class="children"><div class="content">Heh, yeah, &quot;being able to predict the present&quot; is an important benchmarking technique</div><br/></div></div></div></div><div id="40074264" class="c"><input type="checkbox" id="c-40074264" checked=""/><div class="controls bullet"><span class="by">suprfnk</span><span>|</span><a href="#40071185">prev</a><span>|</span><a href="#40068922">next</a><span>|</span><label class="collapse" for="c-40074264">[-]</label><label class="expand" for="c-40074264">[1 more]</label></div><br/><div class="children"><div class="content">@wwilson How do you define the X&#x2F;Y &quot;distance&quot; of a non-Mario application? I.e. any (distributed or not) system that doesn&#x27;t have a relatively trivial &quot;higher x&#x2F;y is better&quot; fitness function?</div><br/></div></div><div id="40068922" class="c"><input type="checkbox" id="c-40068922" checked=""/><div class="controls bullet"><span class="by">mrkmarron</span><span>|</span><a href="#40074264">prev</a><span>|</span><a href="#40068747">next</a><span>|</span><label class="collapse" for="c-40068922">[-]</label><label class="expand" for="c-40068922">[16 more]</label></div><br/><div class="children"><div class="content">FYI playing Super Mario with fuzzing (AFL) was done in a fun 2020 S&amp;P paper. Also finds bugs and security issues.<p>&quot;IJON: Exploring Deep State Spaces via Fuzzing&quot;
<a href="https:&#x2F;&#x2F;casa.rub.de&#x2F;fileadmin&#x2F;img&#x2F;Publikationen_PDFs&#x2F;2020_IJON_Exploring_Deep_State_Spaces_via_Fuzzing_Publication_ClusterofExcellence_CASA_Bochum.pdf" rel="nofollow">https:&#x2F;&#x2F;casa.rub.de&#x2F;fileadmin&#x2F;img&#x2F;Publikationen_PDFs&#x2F;2020_IJ...</a></div><br/><div id="40069670" class="c"><input type="checkbox" id="c-40069670" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#40068922">parent</a><span>|</span><a href="#40068965">next</a><span>|</span><label class="collapse" for="c-40069670">[-]</label><label class="expand" for="c-40069670">[4 more]</label></div><br/><div class="children"><div class="content">A lot of fuzzers use Mario or other simple games as an internal testcase. I&#x27;m aware of a hypervisor fuzzer from 2016 that did it, and I&#x27;m positive there are others (both before and since). Hell, tom7 has a fuzzer for exploring program states that uses Super Mario Bros as the example from 2013 (<a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~tom7&#x2F;mario&#x2F;mario.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~tom7&#x2F;mario&#x2F;mario.pdf</a>, plus a youtube video <a href="https:&#x2F;&#x2F;youtu.be&#x2F;xOCurBYI_gY" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;xOCurBYI_gY</a>), and he&#x27;s definitely not the first either.</div><br/><div id="40069709" class="c"><input type="checkbox" id="c-40069709" checked=""/><div class="controls bullet"><span class="by">wwilson</span><span>|</span><a href="#40068922">root</a><span>|</span><a href="#40069670">parent</a><span>|</span><a href="#40069707">next</a><span>|</span><label class="collapse" for="c-40069709">[-]</label><label class="expand" for="c-40069709">[2 more]</label></div><br/><div class="children"><div class="content">We are huge fans of tom7 and that paper was one of our inspirations for using NES as a domain for researching autonomous state space search! I think he does a very good job of explaining why the problem is hard.</div><br/><div id="40069748" class="c"><input type="checkbox" id="c-40069748" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#40068922">root</a><span>|</span><a href="#40069709">parent</a><span>|</span><a href="#40069707">next</a><span>|</span><label class="collapse" for="c-40069748">[-]</label><label class="expand" for="c-40069748">[1 more]</label></div><br/><div class="children"><div class="content">Right, in case it wasn&#x27;t clear to readers this isn&#x27;t a bad thing. Lots of people use games because they&#x27;re good analogs for other programs and evocatively show fuzzing exploration progress. Not being the first to point a fuzzer at Mario doesn&#x27;t matter.</div><br/></div></div></div></div><div id="40069707" class="c"><input type="checkbox" id="c-40069707" checked=""/><div class="controls bullet"><span class="by">mrkmarron</span><span>|</span><a href="#40068922">root</a><span>|</span><a href="#40069670">parent</a><span>|</span><a href="#40069709">prev</a><span>|</span><a href="#40068965">next</a><span>|</span><label class="collapse" for="c-40069707">[-]</label><label class="expand" for="c-40069707">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing, I felt like there were earlier but the x,y trick jumped out at me and that was the one I remembered off the top of my head.</div><br/></div></div></div></div><div id="40068965" class="c"><input type="checkbox" id="c-40068965" checked=""/><div class="controls bullet"><span class="by">wwilson</span><span>|</span><a href="#40068922">parent</a><span>|</span><a href="#40069670">prev</a><span>|</span><a href="#40069802">next</a><span>|</span><label class="collapse" for="c-40068965">[-]</label><label class="expand" for="c-40068965">[8 more]</label></div><br/><div class="children"><div class="content">Thanks for flagging this! The work we&#x27;re announcing today was completed in 2018, and we have since moved on to much more challenging problems both in the Nintendo domain and elsewhere. Totally not looking to pick a fight over priority though. This is such a hilariously understudied and under-explored area, we really value anybody else who&#x27;s trying to work on these problems.</div><br/><div id="40069659" class="c"><input type="checkbox" id="c-40069659" checked=""/><div class="controls bullet"><span class="by">mrkmarron</span><span>|</span><a href="#40068922">root</a><span>|</span><a href="#40068965">parent</a><span>|</span><a href="#40069802">next</a><span>|</span><label class="collapse" for="c-40069659">[-]</label><label class="expand" for="c-40069659">[7 more]</label></div><br/><div class="children"><div class="content">I think you underestimate the level to which this area has been studied. And I wish you would talk about these new results then instead of announcing 5+ year old results then.<p>It would be great to see progress in this area (not my primary area of work BTW) but I am not seeing anything here, technically, that is going to make that happen -- maybe it is just getting all the parts in place and magic happens. It just makes me scratch my head a bit.</div><br/><div id="40069727" class="c"><input type="checkbox" id="c-40069727" checked=""/><div class="controls bullet"><span class="by">wwilson</span><span>|</span><a href="#40068922">root</a><span>|</span><a href="#40069659">parent</a><span>|</span><a href="#40069802">next</a><span>|</span><label class="collapse" for="c-40069727">[-]</label><label class="expand" for="c-40069727">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s possible you did not make it to the end of the talk where I explain this, but the thing that excites me is that we can now apply fuzzing and related techniques to things which are neither Nintendo games nor tiny stateless libraries and parsers, because of this: <a href="https:&#x2F;&#x2F;antithesis.com&#x2F;blog&#x2F;deterministic_hypervisor&#x2F;" rel="nofollow">https:&#x2F;&#x2F;antithesis.com&#x2F;blog&#x2F;deterministic_hypervisor&#x2F;</a><p>As for getting to the newer stuff, yeah, totally, just give us some time. There&#x27;s a bit of a backlog. :-)</div><br/><div id="40069966" class="c"><input type="checkbox" id="c-40069966" checked=""/><div class="controls bullet"><span class="by">mrkmarron</span><span>|</span><a href="#40068922">root</a><span>|</span><a href="#40069727">parent</a><span>|</span><a href="#40069802">next</a><span>|</span><label class="collapse" for="c-40069966">[-]</label><label class="expand" for="c-40069966">[5 more]</label></div><br/><div class="children"><div class="content">I just rewatched the end of the video to make sure I didn&#x27;t miss anything. Deterministic execution and replay is very-very well-known and understood. It is possible that your packaging and market fit is right on. Lots of cottage industry in DB testing and bug finding -- but not clear how this generalizes and why something like Coyote [1] (to pick one) wouldn&#x27;t work as well.<p>So, fuzzing has been applied to very stateful and very large industrial systems for some time. And yes it is very cool but I feel like I am seeing more &quot;sizzle than steak&quot; so to speak. Great engineering though, hypervisor work is very challenging.<p>[1] <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;blog&#x2F;coyote-making-it-easier-for-developers-to-build-reliable-asynchronous-software&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;blog&#x2F;coyote-making-...</a></div><br/><div id="40070054" class="c"><input type="checkbox" id="c-40070054" checked=""/><div class="controls bullet"><span class="by">wwilson</span><span>|</span><a href="#40068922">root</a><span>|</span><a href="#40069966">parent</a><span>|</span><a href="#40071639">next</a><span>|</span><label class="collapse" for="c-40070054">[-]</label><label class="expand" for="c-40070054">[3 more]</label></div><br/><div class="children"><div class="content">It is absolutely possible to write a large stateful system from the ground up so that autonomous testing techniques can be applied to it. FoundationDB and Tiger Beetle are both examples of this, I think Resonate might be another one, and Toby Bell&#x27;s talk at Strange Loop last year is a great guide on how to do so.<p>What&#x27;s much harder is to take an arbitrary system, written in an arbitrary way, without these techniques in mind, and make it amenable to this sort of testing. From the start of our company, we believed that unless this was possible, the market would be too hard to crack, because most human beings are not very foresightful and not able to justify a bunch of extra work.<p>Hypervisor-based snapshot fuzzing like Nyx-Net and deterministic userspaces like Facebook&#x27;s now-discontinued Hermit project are the other ways I know of accomplishing that goal. We believe that both of them have some pretty serious practical limitations which our approach does not share.<p>EDIT: Maybe the way to get to the crux of the disagreement is for me to turn the question around. Why do you believe that the vast majority of stateful and concurrent systems are not tested with fuzzing?</div><br/><div id="40070229" class="c"><input type="checkbox" id="c-40070229" checked=""/><div class="controls bullet"><span class="by">mrkmarron</span><span>|</span><a href="#40068922">root</a><span>|</span><a href="#40070054">parent</a><span>|</span><a href="#40070309">next</a><span>|</span><label class="collapse" for="c-40070229">[-]</label><label class="expand" for="c-40070229">[1 more]</label></div><br/><div class="children"><div class="content">At the end of the day you have 2 problems (1) how to make execution deterministic within some boundary be it a process, hypervisor, or distributed system and (2) how you handle non-determinism when data crosses this boundary. You can move the boundaries and effort around but the problems always exist. So, if you are claiming that you have a sweet spot on this tradeoff then I could certainly believe that, if you claim that you eliminated this boundary issue then I am highly credulous.<p>I&#x27;ll agree with you on indeterminate behaviors though, I suspect they will eventually be seen like the &quot;billion dollar&quot; mistake of null pointers.</div><br/></div></div><div id="40070309" class="c"><input type="checkbox" id="c-40070309" checked=""/><div class="controls bullet"><span class="by">mrkmarron</span><span>|</span><a href="#40068922">root</a><span>|</span><a href="#40070054">parent</a><span>|</span><a href="#40070229">prev</a><span>|</span><a href="#40071639">next</a><span>|</span><label class="collapse" for="c-40070309">[-]</label><label class="expand" for="c-40070309">[1 more]</label></div><br/><div class="children"><div class="content">Just saw the edit. I have 2 answers:<p>1) Fuzzing is under-utilized even for simple code. AFL is dead easy to use and, even so, most projects don&#x27;t have it in CI runs. So, despite how much I like it, in general it seems people do not see value in this type of testing.<p>2) The effort to handle external state (say a restful call to get stock ticker info) needs to be mocked -- which is deeply unpopular -- or handled by record&#x2F;replay which works ok-ish but eventually breaks down with divergences. Outside of well-chosen domains it these eventually pop-up and add an additional pain point that builds on item 1.</div><br/></div></div></div></div><div id="40071639" class="c"><input type="checkbox" id="c-40071639" checked=""/><div class="controls bullet"><span class="by">amw-zero</span><span>|</span><a href="#40068922">root</a><span>|</span><a href="#40069966">parent</a><span>|</span><a href="#40070054">prev</a><span>|</span><a href="#40069802">next</a><span>|</span><label class="collapse" for="c-40071639">[-]</label><label class="expand" for="c-40071639">[1 more]</label></div><br/><div class="children"><div class="content">Deterministic execution might be well understood by its proponents, but it&#x27;s a completely niche technique that practically no one uses in practice. You have this jaded tone like this is something that everyone is doing, and everyone knows that this isn&#x27;t true, so we&#x27;re curious... why are you writing these things?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40069802" class="c"><input type="checkbox" id="c-40069802" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#40068922">parent</a><span>|</span><a href="#40068965">prev</a><span>|</span><a href="#40068747">next</a><span>|</span><label class="collapse" for="c-40069802">[-]</label><label class="expand" for="c-40069802">[3 more]</label></div><br/><div class="children"><div class="content">Have any of these methods found clips and speedrunning shortcuts? Examples: Clip the base of the flagpole to skip some animation time. Clip into and walk below the floor to run past obstacles. Etc.</div><br/><div id="40070101" class="c"><input type="checkbox" id="c-40070101" checked=""/><div class="controls bullet"><span class="by">wwilson</span><span>|</span><a href="#40068922">root</a><span>|</span><a href="#40069802">parent</a><span>|</span><a href="#40068747">next</a><span>|</span><label class="collapse" for="c-40070101">[-]</label><label class="expand" for="c-40070101">[2 more]</label></div><br/><div class="children"><div class="content">We find a ton of glitches in Mario, and even more in other games. See, e.g.: <a href="https:&#x2F;&#x2F;vimeo.com&#x2F;807601164" rel="nofollow">https:&#x2F;&#x2F;vimeo.com&#x2F;807601164</a></div><br/><div id="40070119" class="c"><input type="checkbox" id="c-40070119" checked=""/><div class="controls bullet"><span class="by">wwilson</span><span>|</span><a href="#40068922">root</a><span>|</span><a href="#40070101">parent</a><span>|</span><a href="#40068747">next</a><span>|</span><label class="collapse" for="c-40070119">[-]</label><label class="expand" for="c-40070119">[1 more]</label></div><br/><div class="children"><div class="content">Hmm... looks like Vimeo is currently having some kind of outage. If anybody at Vimeo is reading this and wants some help with testing backend systems, email is in bio.</div><br/></div></div></div></div></div></div></div></div><div id="40068747" class="c"><input type="checkbox" id="c-40068747" checked=""/><div class="controls bullet"><span class="by">wwilson</span><span>|</span><a href="#40068922">prev</a><span>|</span><a href="#40071950">next</a><span>|</span><label class="collapse" for="c-40068747">[-]</label><label class="expand" for="c-40068747">[18 more]</label></div><br/><div class="children"><div class="content">This is Will (I gave the talk linked in the post). Happy to answer any questions about this work, or how it generalizes to testing things that aren&#x27;t Nintendo games.</div><br/><div id="40069253" class="c"><input type="checkbox" id="c-40069253" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#40068747">parent</a><span>|</span><a href="#40069945">next</a><span>|</span><label class="collapse" for="c-40069253">[-]</label><label class="expand" for="c-40069253">[12 more]</label></div><br/><div class="children"><div class="content">Why is Mario so jumpy?</div><br/><div id="40069361" class="c"><input type="checkbox" id="c-40069361" checked=""/><div class="controls bullet"><span class="by">wwilson</span><span>|</span><a href="#40068747">root</a><span>|</span><a href="#40069253">parent</a><span>|</span><a href="#40069538">next</a><span>|</span><label class="collapse" for="c-40069361">[-]</label><label class="expand" for="c-40069361">[9 more]</label></div><br/><div class="children"><div class="content">This is actually an incredibly deep and difficult question to answer. I would expect no less from cperciva. :-)<p>As I mention in the talk, you get very bad tactical performance from taking a uniform random distribution and piping it into the emulator. The fuzzer is exponentially unlikely to hold the jump button for many successive frames without a break. In the fully general case, I think instead of maximum entropy, you want something more like Marcus Hutter&#x27;s AIXI where you spend energy on inputs inversely proportional to their Kolmogorov complexity. Unfortunately, that&#x27;s uncomputable, but it turns out that just switching to toggling bits with low probability does a lot better than pure randomness. The approach is analogous to swarm testing (<a href="https:&#x2F;&#x2F;users.cs.utah.edu&#x2F;~regehr&#x2F;papers&#x2F;swarm12.pdf" rel="nofollow">https:&#x2F;&#x2F;users.cs.utah.edu&#x2F;~regehr&#x2F;papers&#x2F;swarm12.pdf</a>).<p>All of which is to say, the result that we show here is vastly <i>less</i> jumpy than our first tries. The reason it&#x27;s still more jumpy than a human player is that our platform has no idea where it is in the game, or even that it&#x27;s playing a game. So if a jump doesn&#x27;t harm it in the exploration process, there&#x27;s some chance the first input getting somewhere new will involve a jump, and that will then get locked in.<p>We do have the capability to do optimization on inputs (what conventional PBT calls &quot;shrinking&quot;), and indeed if you apply this to Mario you can get it to jump a lot less and complete levels a lot faster. That capability didn&#x27;t exist yet when this video was recorded. We should totally do a another post on this topic!</div><br/><div id="40072386" class="c"><input type="checkbox" id="c-40072386" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#40068747">root</a><span>|</span><a href="#40069361">parent</a><span>|</span><a href="#40071490">next</a><span>|</span><label class="collapse" for="c-40072386">[-]</label><label class="expand" for="c-40072386">[1 more]</label></div><br/><div class="children"><div class="content">To reframe the problem with purely random &quot;Tactics&quot;, some frequencies may be an inefficient way to get to desired states of the system. That is, it is useful to consider the correlation between random inputs across time.<p>This reminds me a lot of the problem space involving Perlin Noise. I&#x27;d hypothesize that by using a fractal noise pattern you can generate inputs with correlated values yet still remain random enough to get to any state. Have you tried using noise generators for random inputs?</div><br/></div></div><div id="40071490" class="c"><input type="checkbox" id="c-40071490" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#40068747">root</a><span>|</span><a href="#40069361">parent</a><span>|</span><a href="#40072386">prev</a><span>|</span><a href="#40070125">next</a><span>|</span><label class="collapse" for="c-40071490">[-]</label><label class="expand" for="c-40071490">[1 more]</label></div><br/><div class="children"><div class="content">What if you optimized inputs based on the strategy? E.g when you&#x27;re in the air pressing down has no effect, or more measurably, the code paths between runs where you do or don&#x27;t press down are very similar or completely converge. Similarly, jumping while running on a flat floor at full speed doesn&#x27;t affect the game much, so prune it.<p>Maybe call it &quot;strategy-informed tactics&quot;</div><br/></div></div><div id="40070125" class="c"><input type="checkbox" id="c-40070125" checked=""/><div class="controls bullet"><span class="by">someplaceguy</span><span>|</span><a href="#40068747">root</a><span>|</span><a href="#40069361">parent</a><span>|</span><a href="#40071490">prev</a><span>|</span><a href="#40069538">next</a><span>|</span><label class="collapse" for="c-40070125">[-]</label><label class="expand" for="c-40070125">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Unfortunately, that&#x27;s uncomputable<p>Minor nitpick, but while Kolmogorov complexity as typically defined is uncomputable, I would argue that this result is only a theoretical curiosity and mostly irrelevant.<p>That is, the &quot;uncomputable&quot; Kolmogorov complexity computation presupposes that you have a Turing machine, i.e. a machine with <i>literally</i> infinite memory, which is not possible to construct in our universe. Or alternatively, it presupposes that &quot;computable function&quot; is one that can be computed by a machine with an infinite amount of storage, which amounts to the same thing as having a Turing machine.<p>You could probably define some version of Kolmogorov complexity that is parametrized by the memory size (e.g. of a linear bounded automaton or similar model that better represents a computer with finite resources), which should make it computable. That said, in practice it would probably take an unreasonable amount of time to perform this computation (but that is orthogonal to whether it&#x27;s computable or not).</div><br/><div id="40070738" class="c"><input type="checkbox" id="c-40070738" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#40068747">root</a><span>|</span><a href="#40070125">parent</a><span>|</span><a href="#40070242">next</a><span>|</span><label class="collapse" for="c-40070738">[-]</label><label class="expand" for="c-40070738">[4 more]</label></div><br/><div class="children"><div class="content">While reading your comment, I kept having the vague feeling that your idea of &quot;theoretically computable&quot; (within the given memory bounds) will still leave some exponential time and&#x2F;or space complexity, and so effectively will still be &quot;practically not computable&quot;.<p>Your last paragraph then seemed to confirm that, i.e. there was no particular shortcut for this specific case that would make it any different from general Kolmogorov complexity.<p>In that sense, isn&#x27;t your comment itself also &quot;only a theoretical curiosity&quot;? As we went to from &quot;uncomputable&quot;, to &quot;theoretically computable under the given constraints&quot;, to &quot;practically uncomputable&quot;?<p>While suffering from lack of rigor, I think a lot of times--probably even the majority of times outside purely cs-theoretical treatments--when we colloquially speak of &quot;uncomputable&quot;, we are always talking about practical computers without an infinite touring tape, and so actually mean &quot;practically uncomputable&quot;.<p>Because, yes, while everyone immediately understands that actual computers don&#x27;t have infinite memory, at the same time everyone understands that &quot;exponential time&quot; is still &quot;never&quot; in practical terms.</div><br/><div id="40071366" class="c"><input type="checkbox" id="c-40071366" checked=""/><div class="controls bullet"><span class="by">someplaceguy</span><span>|</span><a href="#40068747">root</a><span>|</span><a href="#40070738">parent</a><span>|</span><a href="#40070242">next</a><span>|</span><label class="collapse" for="c-40071366">[-]</label><label class="expand" for="c-40071366">[3 more]</label></div><br/><div class="children"><div class="content">I would somewhat agree with your comment, but I think you&#x27;re missing some important points:<p>&gt; everyone understands that &quot;exponential time&quot; is still &quot;never&quot; in practical terms.<p>It&#x27;s important to note that this is not necessarily true:<p>1. &quot;exponential time&quot; is somewhat ambiguous. An algorithm might be exponential time yet have a very low exponential base (e.g. 1.0001), so in practical terms it might be practically computable for reasonable sizes.<p>2. Even if the exponential base is high, it still doesn&#x27;t say anything about whether an algorithm can be used practically or not. The algorithm might still be very efficient for reasonable problem sizes even though it has a high exponential base (important question: exponential in terms of what, exactly?).<p>3. Exponential time algorithms might only be so in the worst case but might not necessarily be exponential in the average case, or even the vast majority of interesting cases. As an example, it might be easy (or at least doable) to solve the halting problem for normal computer programs. Humans do this all the time with real-world programs when performing formal verification (as these programming languages, logics and tools force you to prove that loops and recursive functions always terminate, even when assuming a model equivalent to a Turing machine), and AFAIK there&#x27;s no proof that computers can&#x27;t efficiently do the same for the vast majority of real-world programs (cryptographic algorithms being the usual exception).<p>4. Whenever someone mentions that the halting problem and Kolmogorov complexity are uncomputable, the discussion ends there. But notice that when I pointed out that it&#x27;s in fact computable, the discussion turned into one about how efficient  the computation might be (which I argue, is how all such discussions should be).<p>5. As a side note, every single time I argued this point in the past, usually in the context of the halting problem, someone always argued that such an algorithm would necessarily have a time complexity of 2^N, where N=nr. of bits of the machine. <i>This is not true</i>. It would only be true for the simplest and most naive solution to the halting problem, which is inevitably what that person has in mind. In fact, there&#x27;s already a family of algorithms that solve the halting problem with less complexity for almost all programs: &quot;Floyd&#x27;s tortoise and hare&quot; and similar ones (see [1]). Note that these algorithms don&#x27;t even inspect the program, they just run it step by step. This leads me to think that there are undiscovered algorithms that are far more efficient by virtue of exploiting knowledge about the program being analyzed.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cycle_detection" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cycle_detection</a></div><br/><div id="40071979" class="c"><input type="checkbox" id="c-40071979" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#40068747">root</a><span>|</span><a href="#40071366">parent</a><span>|</span><a href="#40070242">next</a><span>|</span><label class="collapse" for="c-40071979">[-]</label><label class="expand" for="c-40071979">[2 more]</label></div><br/><div class="children"><div class="content">Oh but that was specifically what I was trying to get at, i.e. point #4 of this reply of yours: Are there any shortcuts that make this <i>reasonably</i> computable or not?<p>In your original reply, you started with (transcribing) &quot;Kolmogorov complexity is not <i>technically</i> uncomputable in the practical case of not having an infinite tape&quot;, which gave me hope that we would start talking about how there are some reasonable shortcuts in this particular case (as you mention in this answer now).<p>But then you ended with (literally) &quot;That said, in practice it would probably take an unreasonable amount of time to perform this computation (but that is orthogonal to whether it&#x27;s computable or not)&quot;, which squashed my hopes, seemed to just have replaced &quot;theoretically uncomputable&quot; with &quot;practically uncomputable&quot;, and made me wonder how it changed anything that OP already wrote in practical terms, namely: &quot;Unfortunately, that&#x27;s uncomputable&quot;<p>But now it seems we&#x27;re back to (potentially) discussing how in this particular use case there might be tractable ways to (limited, but useful) computability, which is good again!</div><br/><div id="40072125" class="c"><input type="checkbox" id="c-40072125" checked=""/><div class="controls bullet"><span class="by">someplaceguy</span><span>|</span><a href="#40068747">root</a><span>|</span><a href="#40071979">parent</a><span>|</span><a href="#40070242">next</a><span>|</span><label class="collapse" for="c-40072125">[-]</label><label class="expand" for="c-40072125">[1 more]</label></div><br/><div class="children"><div class="content">I should note that I&#x27;m not a computer scientist and I&#x27;m currently a bit sleep-deprived, but to continue discussing what you&#x27;re interested in:<p>I tend to think that an efficient computation of some finite-state version of Kolmogorov complexity would necessarily require an efficient computation of a finite-state version of the halting problem, but I&#x27;m not entirely sure of this.<p>Naively, it seems that this Kolmogorov calculation would require enumerating all programs (in increasing program size) and then running each of them until they either 1) enter an infinite loop, 2) produce the input string and halt, or 3) start producing a different string.<p>However, I&#x27;m not sure this would be the most efficient algorithm. For example, it might be easy to inspect each program and discard almost all that would &quot;obviously&quot; not produce the input string before we even try to run them.<p>Or better yet, never even enumerate such programs that can be proven not to produce the input string. In other words, cut the search space significantly.<p>Perhaps there might even be a shortcut to directly construct the smallest program that produces a given string, or at least, a family of small candidate programs that would be a very small subset of all possible programs and yet would be guaranteed to contain the solution.<p>As you might have noticed, unfortunately I don&#x27;t know if there are such extraordinarily efficient shortcuts, I&#x27;m only speculating that they might exist.<p>That said, I still suspect that this might be intractable due to having to account for the worst case, i.e. undecipherable random-looking programs. In the case of the halting problem in the context of formal verification, I&#x27;m more optimistic since we usually don&#x27;t need to care about such random-looking programs, only human-constructed ones (usually), which might be far easier to analyze algorithmically. I don&#x27;t know if that makes sense...</div><br/></div></div></div></div></div></div></div></div><div id="40070242" class="c"><input type="checkbox" id="c-40070242" checked=""/><div class="controls bullet"><span class="by">wwilson</span><span>|</span><a href="#40068747">root</a><span>|</span><a href="#40070125">parent</a><span>|</span><a href="#40070738">prev</a><span>|</span><a href="#40069538">next</a><span>|</span><label class="collapse" for="c-40070242">[-]</label><label class="expand" for="c-40070242">[1 more]</label></div><br/><div class="children"><div class="content">Thank you. Comments like this are why I love HN.</div><br/></div></div></div></div></div></div><div id="40069538" class="c"><input type="checkbox" id="c-40069538" checked=""/><div class="controls bullet"><span class="by">gwern</span><span>|</span><a href="#40068747">root</a><span>|</span><a href="#40069253">parent</a><span>|</span><a href="#40069361">prev</a><span>|</span><a href="#40069945">next</a><span>|</span><label class="collapse" for="c-40069538">[-]</label><label class="expand" for="c-40069538">[2 more]</label></div><br/><div class="children"><div class="content">Most RL agents are &#x27;jumpy&#x27; or jitter a lot, because it makes no difference to the reward, and where it does make a difference, that tends to only matter close to convergence where slight speedups are all that&#x27;s left. If you want to reduce that, you have to reward-shape it to penalize excess movement. (Which is relevant in robotics, where &#x27;jitter&#x27; can be very bad for the machinery in a way not reflected in the simple tasks&#x27; reward functions.)</div><br/><div id="40070771" class="c"><input type="checkbox" id="c-40070771" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#40068747">root</a><span>|</span><a href="#40069538">parent</a><span>|</span><a href="#40069945">next</a><span>|</span><label class="collapse" for="c-40070771">[-]</label><label class="expand" for="c-40070771">[1 more]</label></div><br/><div class="children"><div class="content">Case in point: Watch an actual Mario speed running world record video, and the human players there are jumping around a lot while running around flat sections with no obstacles.<p>As I understand, the jumping (at least in this case) does nothing to Mario&#x27;s horizontal speed at all, so they basically just do it for &quot;fun&quot;.<p>The difference is that the human players know that they&#x27;re doing something inconsequential for variety, while the fuzzer has no &quot;idea&quot; (i.e. no concept) that the jumping does not matter, or even that it is &quot;jumping&quot;. More generally, it does not know nor care that this particular part of the input is irrelevant. It just found an input that works, and sometimes that happens to include a useless jump.</div><br/></div></div></div></div></div></div><div id="40069945" class="c"><input type="checkbox" id="c-40069945" checked=""/><div class="controls bullet"><span class="by">mustknow2201</span><span>|</span><a href="#40068747">parent</a><span>|</span><a href="#40069253">prev</a><span>|</span><a href="#40068830">next</a><span>|</span><label class="collapse" for="c-40069945">[-]</label><label class="expand" for="c-40069945">[1 more]</label></div><br/><div class="children"><div class="content">How close is or isn&#x27;t this to a genetic algorithm in practice? It seems like as soon as you start scaling out to multiple threads&#x2F;nodes you&#x27;d benefit from crossover, selection techniques and so on?</div><br/></div></div><div id="40068830" class="c"><input type="checkbox" id="c-40068830" checked=""/><div class="controls bullet"><span class="by">thsksbd</span><span>|</span><a href="#40068747">parent</a><span>|</span><a href="#40069945">prev</a><span>|</span><a href="#40071960">next</a><span>|</span><label class="collapse" for="c-40068830">[-]</label><label class="expand" for="c-40068830">[3 more]</label></div><br/><div class="children"><div class="content">How does this distinguish between a bug and a &quot;feature&quot;?<p>Edit: i mean this is the spirit of Knuth&#x27;s quip that when he dies all the bugs in tex will become features</div><br/><div id="40068900" class="c"><input type="checkbox" id="c-40068900" checked=""/><div class="controls bullet"><span class="by">wwilson</span><span>|</span><a href="#40068747">root</a><span>|</span><a href="#40068830">parent</a><span>|</span><a href="#40071960">next</a><span>|</span><label class="collapse" for="c-40068900">[-]</label><label class="expand" for="c-40068900">[2 more]</label></div><br/><div class="children"><div class="content">There was a LOT of discussion of this in the Q&amp;A after the talk. Currently we have 4 main approaches:<p>(1) There&#x27;s some stuff that&#x27;s pretty much a bug for every program. If it segfaults, exits with a nonzero code, OOMs, triggers a TSAN error, fills the disk with fatal error messages, etc., etc., that&#x27;s pretty easy to qualify.<p>(2) You can use our SDK to define additional custom test properties. Think like a normal assertions library, but you can also do existential quantification (&quot;this code is reachable&#x2F;this situation can happen&quot;) and soon temporal assertions (&quot;this should never happen without this other thing happening first, possibly on a different node&quot;).<p>(3) We store all the output of your system in every timeline in a giant analytic database and support ad-hoc querying against it. Think &quot;pre-observability&quot;, observability but for mirror universes. You can then do all the spelunking and analysis you would do with your production traces, but before your real customers are exposed to any issue.<p>(4) We have some very cool ML approaches in the pipeline that I can&#x27;t talk about quite yet.</div><br/><div id="40070810" class="c"><input type="checkbox" id="c-40070810" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#40068747">root</a><span>|</span><a href="#40068900">parent</a><span>|</span><a href="#40071960">next</a><span>|</span><label class="collapse" for="c-40070810">[-]</label><label class="expand" for="c-40070810">[1 more]</label></div><br/><div class="children"><div class="content">Can you define equivalence classes (mutations that shouldn&#x27;t change the result) eg timing, order of events, idempotence, etc? So that you can use (3) to define the correct result for all members of the class<p>(Sorry if this is explained in the talk - I&#x27;ll watch it but it&#x27;s now too late in the day in my timezone)</div><br/></div></div></div></div></div></div><div id="40071960" class="c"><input type="checkbox" id="c-40071960" checked=""/><div class="controls bullet"><span class="by">iamcreasy</span><span>|</span><a href="#40068747">parent</a><span>|</span><a href="#40068830">prev</a><span>|</span><a href="#40071950">next</a><span>|</span><label class="collapse" for="c-40071960">[-]</label><label class="expand" for="c-40071960">[1 more]</label></div><br/><div class="children"><div class="content">Very cool presentation. Thanks for doing this.<p>Choosing next input based on present sounds a lot like a Markov chain - is that something you guys use when simulating user interaction with distributed system?</div><br/></div></div></div></div><div id="40071950" class="c"><input type="checkbox" id="c-40071950" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#40068747">prev</a><span>|</span><a href="#40073702">next</a><span>|</span><label class="collapse" for="c-40071950">[-]</label><label class="expand" for="c-40071950">[1 more]</label></div><br/><div class="children"><div class="content">In Will&#x27;s talk he defines two terms related to optimizing fuzzers [2]: Strategy and Tactics.<p>Strategy is the datum you choose to optimize for as the fuzzer randomly walks the states of the system. E.g. optimize to maximize Mario&#x27;s X value, or optimize for reaching all tile positions etc. This generalizes the concept of &quot;coverage guided&quot; to include domain-specific details about your target program (e.g. that the program has the concept of a grid of possible positions).<p>Tactics is the choice of input distribution. Sometimes the frequency of the randomness should be tuned for the application. For example, randomly changing the state of the A button every frame is not a good frequency to properly test long jumps, maybe a normal distribution with average hold&#x2F;not hold time of 1s would be better. Also, encoding the randomness within the program&#x27;s valid domain can help avoid over-testing parsing&#x2F;validation code at the expense of more interesting code further in the program. [1][2]<p>[0]: Barton P. Miller, Lars Fredriksen, and Bryan So. 1990. An empirical study of the reliability of UNIX utilities. Commun. ACM 33, 12 (Dec. 1990), 32–44. <a href="https:&#x2F;&#x2F;doi.org&#x2F;10.1145&#x2F;96267.96279" rel="nofollow">https:&#x2F;&#x2F;doi.org&#x2F;10.1145&#x2F;96267.96279</a><p>[1]: This reference appears to be related: Rohan Padhye, Caroline Lemieux, Koushik Sen, Laurent Simon, and Hayawardh Vijayakumar. 2019. FuzzFactory: domain-specific fuzzing with waypoints. Proc. ACM Program. Lang. 3, OOPSLA, Article 174 (October 2019), 29 pages. <a href="https:&#x2F;&#x2F;doi.org&#x2F;10.1145&#x2F;3360600" rel="nofollow">https:&#x2F;&#x2F;doi.org&#x2F;10.1145&#x2F;3360600</a><p>[2]: I introduce the concept of fuzzing in another comment: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40068187#40071972">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40068187#40071972</a></div><br/></div></div><div id="40073702" class="c"><input type="checkbox" id="c-40073702" checked=""/><div class="controls bullet"><span class="by">t4ng0pwn3d</span><span>|</span><a href="#40071950">prev</a><span>|</span><a href="#40068899">next</a><span>|</span><label class="collapse" for="c-40073702">[-]</label><label class="expand" for="c-40073702">[1 more]</label></div><br/><div class="children"><div class="content">I see a lot of fuzzing tools for CLI apps, but are there any good alternatives for web applications&#x2F;APIs? I&#x27;ve used Hypothesis for generating random datas in requests but maybe there&#x27;s something better out there.</div><br/></div></div><div id="40068899" class="c"><input type="checkbox" id="c-40068899" checked=""/><div class="controls bullet"><span class="by">Taikonerd</span><span>|</span><a href="#40073702">prev</a><span>|</span><a href="#40069841">next</a><span>|</span><label class="collapse" for="c-40068899">[-]</label><label class="expand" for="c-40068899">[1 more]</label></div><br/><div class="children"><div class="content">Super Mario is such a fun example.  Well chosen.</div><br/></div></div><div id="40069841" class="c"><input type="checkbox" id="c-40069841" checked=""/><div class="controls bullet"><span class="by">yanniszark</span><span>|</span><a href="#40068899">prev</a><span>|</span><a href="#40070317">next</a><span>|</span><label class="collapse" for="c-40069841">[-]</label><label class="expand" for="c-40069841">[3 more]</label></div><br/><div class="children"><div class="content">This is fascinating! I thought only Reinforcement Learning was doing things like this but you&#x27;re saying you can do this via fuzzying? What does this mean exactly? How is it able to learn to advance through all these levels? Is there an underlying learning mechanism at play?</div><br/><div id="40070185" class="c"><input type="checkbox" id="c-40070185" checked=""/><div class="controls bullet"><span class="by">vojev</span><span>|</span><a href="#40069841">parent</a><span>|</span><a href="#40071972">next</a><span>|</span><label class="collapse" for="c-40070185">[-]</label><label class="expand" for="c-40070185">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no learning exactly, as the post explains the fuzzer is aware of various RAM addresses (as well as having a tactic for how it &quot;presses&quot; buttons in the game). It&#x27;s just trying to explore the space of Mario&#x27;s level + his x and y coordinates.<p>(I&#x27;m an Antithesis employee.)</div><br/></div></div><div id="40071972" class="c"><input type="checkbox" id="c-40071972" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#40069841">parent</a><span>|</span><a href="#40070185">prev</a><span>|</span><a href="#40070317">next</a><span>|</span><label class="collapse" for="c-40071972">[-]</label><label class="expand" for="c-40071972">[1 more]</label></div><br/><div class="children"><div class="content">It appears that you are not familiar with the concept of fuzzing.<p>Fuzzing is a moderately advanced software testing technique popularized in the &#x27;90s that operates on a very simple idea: If you feed a program&#x27;s inputs with arbitrary&#x2F;random data, this could be used to discover bugs in the program with little human effort.<p>In the 90s they fed random data into the stdin of unix utilities and found that many programs crashed. [0] In this context printing an error message that says &quot;I can&#x27;t interpret the input&quot; is a valid state, but reading past the end of a buffer because the input confused the program is a bug. Variants can be designed to test any API layer.<p>More recently Coverage Guided Fuzzers use information about which code paths are executed for each input as a way to reach a variety of program states more quickly. Also, starting with a prefix known to produce an interesting state can also speed up testing.<p>I wrote a comment relating this to the article and talk in the OP here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40068187#40071950">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40068187#40071950</a></div><br/></div></div></div></div><div id="40070317" class="c"><input type="checkbox" id="c-40070317" checked=""/><div class="controls bullet"><span class="by">m3kw9</span><span>|</span><a href="#40069841">prev</a><span>|</span><a href="#40070085">next</a><span>|</span><label class="collapse" for="c-40070317">[-]</label><label class="expand" for="c-40070317">[2 more]</label></div><br/><div class="children"><div class="content">Doesn’t explain how it finds bugs it’s just had the AI play Mario bros</div><br/><div id="40070843" class="c"><input type="checkbox" id="c-40070843" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#40070317">parent</a><span>|</span><a href="#40070085">next</a><span>|</span><label class="collapse" for="c-40070843">[-]</label><label class="expand" for="c-40070843">[1 more]</label></div><br/><div class="children"><div class="content">I think everyone in the target audience of this blog post is immediately able to make the connection.</div><br/></div></div></div></div><div id="40070085" class="c"><input type="checkbox" id="c-40070085" checked=""/><div class="controls bullet"><span class="by">bbor</span><span>|</span><a href="#40070317">prev</a><span>|</span><a href="#40068465">next</a><span>|</span><label class="collapse" for="c-40070085">[-]</label><label class="expand" for="c-40070085">[1 more]</label></div><br/><div class="children"><div class="content">At what point can we start suing companies on behalf of the commons for taking words from the lexicon? I miss the days when this would be called “Wilson &amp; Co.’s automated testing solution” instead of such a beautiful, philosophically meaningful word. Same thoughts on that Devin.AI scam taking the name “Cognition” and Vercel somehow bribing their way into claiming the “ai” name on NPM.<p>Technically awesome post tho! Love the heatmap esp. Maybe bring up changing your name to investors because some rando online doesn’t like it though, please.</div><br/></div></div></div></div></div></div></div></body></html>