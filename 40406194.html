<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716195673996" as="style"/><link rel="stylesheet" href="styles.css?v=1716195673996"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://bernsteinbear.com/blog/weval/">Compilers for free with weval</a>Â <span class="domain">(<a href="https://bernsteinbear.com">bernsteinbear.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>39 comments</span></div><br/><div><div id="40408147" class="c"><input type="checkbox" id="c-40408147" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#40407589">next</a><span>|</span><label class="collapse" for="c-40408147">[-]</label><label class="expand" for="c-40408147">[5 more]</label></div><br/><div class="children"><div class="content">I remember being really excited about the derive-a-compiler-from-a-partial-evaluator premise when I first ran across it. You genuinely do get a compiler from an interpreter plus a partial evaluator. That trick does work.<p>The gotcha I didn&#x27;t spot at the time is that a compiler is (I think, could be argued either way) easier to write than a partial evaluator. The &quot;get it for free bit&quot; only really applies if someone else gave you the partial evaluator <i>and</i> if you somehow don&#x27;t need to spend ages debugging why that partial evaluator isn&#x27;t behaving like you hoped.<p>Now that I&#x27;m somewhat more beaten down by toolchain dev, I&#x27;m starting to think compilers are easier to write than interpreters. It&#x27;s definitely not a clear win in favour of the interpreter. If you compile to x64, or to C, or to javascript or whatever, you now have a thing you can debug with whatever tools are native to that target. If you run in an interpreter, you get to debug that interpreter running the program, with whatever somewhat ad hoc debugging tools you put into the interpreter yourself.<p>Getting useful semantic error message out of an interpreter at partial evaluation time (aka the &quot;compile time&quot; of the aggregate tool) is probably solvable but not likely to work out of the box. Partial eval isn&#x27;t really a phase separation friendly thing.</div><br/><div id="40408300" class="c"><input type="checkbox" id="c-40408300" checked=""/><div class="controls bullet"><span class="by">cfallin</span><span>|</span><a href="#40408147">parent</a><span>|</span><a href="#40408892">next</a><span>|</span><label class="collapse" for="c-40408300">[-]</label><label class="expand" for="c-40408300">[2 more]</label></div><br/><div class="children"><div class="content">This is indeed a good point and something I want to write about when I eventually do a blog post on weval.<p>A few counterpoints that I&#x27;d offer (and what led me to still take this approach):<p>- If the target has sub-par debugging infrastructure, it can be easier to debug an interpreter (which is portable) then apply the semantics-preserving PE. In particular when targeting Wasm outside the browser, there is... not really a good debug experience, anywhere, for that. It was way easier to get an interpreter right by developing on native with gdb&#x2F;rr&#x2F;whatever, and then separately ensure weval preserves semantics (which I tested with lockstep differential execution).<p>- Maintenance: if one is going to have an interpreter and a compiler anyway (and one often wants this or needs this e.g. to handle eval()), easier for them both to come from the same source.<p>- Amortized cost: in the Wasm world we want AOT compilers for many languages eventually; there are interpreter ports with no Wasm backends; developing weval was a one-time cost and we can eventually apply it multiple times.<p>- If the semantics of the existing interpreter are quite nontrivial, that can push the balance the other way.  I designed weval as part of my work on SpiderMonkey; extremely nontrivial interpreter with all sorts of edge cases; replicating that in a from-scratch compiler seemed a far harder path. (It&#x27;s since been done by someone else and you can find the &quot;wasm32 codegen&quot; patchset in Bugzilla but there are other phasing issues with it from our use-case&#x27;s PoV; it&#x27;s not true AOT, it requires codegen at runtime.)<p>I don&#x27;t think the tradeoff is always clear and if one is building a language from scratch, and targeting a simple ISA, by all means write a direct compiler! But other interesting use-cases do exist.</div><br/><div id="40408429" class="c"><input type="checkbox" id="c-40408429" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#40408147">root</a><span>|</span><a href="#40408300">parent</a><span>|</span><a href="#40408892">next</a><span>|</span><label class="collapse" for="c-40408429">[-]</label><label class="expand" for="c-40408429">[1 more]</label></div><br/><div class="children"><div class="content">The divergent semantics risk between the interpreter and the compiler is a really big deal. It&#x27;s genuinely difficult to get a language implementation to behave exactly as specified, even when the spec is do the same as some other implementation. Treating &quot;compiled code&quot; as specialising the interpreter with respect to the program is a great solution to that, since the bugs in the optimiser&#x2F;partial-evaluator (they&#x27;re kind of the same thing) are unlikely to be of the same class as bugs from independent implementations.<p>Wasm is a really solid target for heroic compiler optimisations. It&#x27;s relatively precisely specified, user facing semantic diagnostics are in some language front end out of sight, aliasing is limited and syscalls are finite with known semantics. Pretty much because it was designed by compiler people. You&#x27;ve picked a good target for this technique.</div><br/></div></div></div></div><div id="40408892" class="c"><input type="checkbox" id="c-40408892" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#40408147">parent</a><span>|</span><a href="#40408300">prev</a><span>|</span><a href="#40407589">next</a><span>|</span><label class="collapse" for="c-40408892">[-]</label><label class="expand" for="c-40408892">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The gotcha I didn&#x27;t spot at the time is that a compiler is (I think, could be argued either way) easier to write than a partial evaluator.<p>I agree that this is sometimes true, but there are several, IMHO bigger, issues:<p>1. The partial evaluation of the interpreter might degenerate back to getting a copy of the interpreter loop (or multiple!) and not achieve any speedup, just memory overhead<p>2. The partial evaluator might need additional annotations on what is and is not mutable; it might need a lot of help in order to constant-fold away a key piece of data. Tuning that and getting wrong and result in #1.<p>3. Partially evaluating the interpreter is a <i>pretty slow</i> compiler. You need to do the second Futamura projection (apply the partial evaluator to an interpreter loop without the user code) in order to get a fast compiler. That means the partial evaluator needs to be in the same IR as the partial evaluator&#x27;s input language.<p>That said, I&#x27;ve chatted a bit with Chris offline about this, and I think this work is really cool and promising. I might tinker with this a little in Wizard too.</div><br/><div id="40409908" class="c"><input type="checkbox" id="c-40409908" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#40408147">root</a><span>|</span><a href="#40408892">parent</a><span>|</span><a href="#40407589">next</a><span>|</span><label class="collapse" for="c-40409908">[-]</label><label class="expand" for="c-40409908">[1 more]</label></div><br/><div class="children"><div class="content">That is better expressed than my rambling! The futamura projection is satisfied by passing the &quot;program&quot; directly to the interpreter without optimising either, which is sometimes useful as a packaging exercise and does look somewhat like a non-optimising compiler.<p>If you want this trickery to make a useful compiler, the partial evaluator picks up global value numbering, dead code elimination, loop transforms - the effective partial evaluator is very much the optimisation passes of a compiler. It can still be a win if someone else wrote said partial evaluator.<p>Point 2 is the usual &quot;my compiler is not sufficiently smart, I must annotate the program&quot; problem, with the slight twist that you&#x27;re annotating the interpreter in the hope that it does useful things with the end program. Interacts with hoping someone else built the dependency well.<p>And yeah, generated compilers in this fashion have a reputation for being slow, and for not being great optimising compilers, where self application might dig oneself out of the hole. Very like adding optimisations to your compiler to make your compiler faster when building your compiler.<p>All in all the compiler for free tagline (not specifically this post, it&#x27;s written on a lot of futamura references) feels a bit like an inside joke. It reminds me of the sad discovery that a metacircular interpreter can&#x27;t interpret itself after all since what you&#x27;ve written is a heavily obfuscated infinite loop.</div><br/></div></div></div></div></div></div><div id="40407589" class="c"><input type="checkbox" id="c-40407589" checked=""/><div class="controls bullet"><span class="by">cfallin</span><span>|</span><a href="#40408147">prev</a><span>|</span><a href="#40407292">next</a><span>|</span><label class="collapse" for="c-40407589">[-]</label><label class="expand" for="c-40407589">[1 more]</label></div><br/><div class="children"><div class="content">weval author here (thanks Max for the blog post!). Also AMA!<p>The talk about weval that Max mentions was at NEU and also CMU; the latter was recorded and is here: <a href="https:&#x2F;&#x2F;vimeo.com&#x2F;940568191" rel="nofollow">https:&#x2F;&#x2F;vimeo.com&#x2F;940568191</a><p>I also plan to write up a blog post on weval in depth, plus its application to SpiderMonkey-on-Wasm, in a few months; it&#x27;s pretty exciting though, currently getting 4-5x speedups on some benchmarks on a decidedly nontrivial interpreter!</div><br/></div></div><div id="40407292" class="c"><input type="checkbox" id="c-40407292" checked=""/><div class="controls bullet"><span class="by">rst</span><span>|</span><a href="#40407589">prev</a><span>|</span><a href="#40408556">next</a><span>|</span><label class="collapse" for="c-40407292">[-]</label><label class="expand" for="c-40407292">[7 more]</label></div><br/><div class="children"><div class="content">The most elaborate deployed version of this idea is probably PyPy, an alternative Python implementation that works by giving a JIT-compiling partial evaluator a hint-annotated Python interpreter as the program, and the Python code to be executed as its input.  Slightly abstruse overview here: <a href="https:&#x2F;&#x2F;doc.pypy.org&#x2F;en&#x2F;latest&#x2F;architecture.html" rel="nofollow">https:&#x2F;&#x2F;doc.pypy.org&#x2F;en&#x2F;latest&#x2F;architecture.html</a></div><br/><div id="40407968" class="c"><input type="checkbox" id="c-40407968" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#40407292">parent</a><span>|</span><a href="#40407517">next</a><span>|</span><label class="collapse" for="c-40407968">[-]</label><label class="expand" for="c-40407968">[2 more]</label></div><br/><div class="children"><div class="content">PyPy used partial evaluation at one point, but now it&#x27;s  &quot;meta-tracing&quot;:<p><i>Why did we Abandon Partial Evaluation?</i> - <a href="https:&#x2F;&#x2F;www.pypy.org&#x2F;posts&#x2F;2018&#x2F;09&#x2F;the-first-15-years-of-pypy-3412615975376972020.html#why-did-we-abandon-partial-evaluation" rel="nofollow">https:&#x2F;&#x2F;www.pypy.org&#x2F;posts&#x2F;2018&#x2F;09&#x2F;the-first-15-years-of-pyp...</a></div><br/><div id="40408412" class="c"><input type="checkbox" id="c-40408412" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#40407292">root</a><span>|</span><a href="#40407968">parent</a><span>|</span><a href="#40407517">next</a><span>|</span><label class="collapse" for="c-40408412">[-]</label><label class="expand" for="c-40408412">[1 more]</label></div><br/><div class="children"><div class="content">Taking meta-tracing to the next level would reconstruct not just hot loops but even the original CFG, as speculated in: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38778372">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38778372</a><p>Anyone know of non-fictional work in this area?</div><br/></div></div></div></div><div id="40407517" class="c"><input type="checkbox" id="c-40407517" checked=""/><div class="controls bullet"><span class="by">alserio</span><span>|</span><a href="#40407292">parent</a><span>|</span><a href="#40407968">prev</a><span>|</span><a href="#40408082">next</a><span>|</span><label class="collapse" for="c-40407517">[-]</label><label class="expand" for="c-40407517">[2 more]</label></div><br/><div class="children"><div class="content">Futamura projections should still be the basis for GraalVM</div><br/><div id="40408797" class="c"><input type="checkbox" id="c-40408797" checked=""/><div class="controls bullet"><span class="by">evacchi</span><span>|</span><a href="#40407292">root</a><span>|</span><a href="#40407517">parent</a><span>|</span><a href="#40408082">next</a><span>|</span><label class="collapse" for="c-40408797">[-]</label><label class="expand" for="c-40408797">[1 more]</label></div><br/><div class="children"><div class="content">they are for Truffle-based language implementations <a href="https:&#x2F;&#x2F;chrisseaton.com&#x2F;rubytruffle&#x2F;pldi17-truffle&#x2F;pldi17-truffle.pdf" rel="nofollow">https:&#x2F;&#x2F;chrisseaton.com&#x2F;rubytruffle&#x2F;pldi17-truffle&#x2F;pldi17-tr...</a></div><br/></div></div></div></div><div id="40407369" class="c"><input type="checkbox" id="c-40407369" checked=""/><div class="controls bullet"><span class="by">tekknolagi</span><span>|</span><a href="#40407292">parent</a><span>|</span><a href="#40408082">prev</a><span>|</span><a href="#40408556">next</a><span>|</span><label class="collapse" for="c-40407369">[-]</label><label class="expand" for="c-40407369">[1 more]</label></div><br/><div class="children"><div class="content">I think PyPy moved away from partial evaluation to trace optimization, fwiw</div><br/></div></div></div></div><div id="40408556" class="c"><input type="checkbox" id="c-40408556" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#40407292">prev</a><span>|</span><a href="#40407194">next</a><span>|</span><label class="collapse" for="c-40408556">[-]</label><label class="expand" for="c-40408556">[8 more]</label></div><br/><div class="children"><div class="content">If the wasi+weval version is better than the compiled one, doesn&#x27;t it mean that the compiler made a bad job at optimizing out the constant parts?<p>To be fair, in order for weval to do its magic, the code has to be changed and annotated. I&#x27;m wondering if a similar set of annotations could convince clang to generate a binary that runs in less than 40 ms.</div><br/><div id="40410246" class="c"><input type="checkbox" id="c-40410246" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#40408556">parent</a><span>|</span><a href="#40407194">next</a><span>|</span><label class="collapse" for="c-40410246">[-]</label><label class="expand" for="c-40410246">[7 more]</label></div><br/><div class="children"><div class="content">Clang doesn&#x27;t know about the static code, so it can&#x27;t do the optimizations this does.<p>You could probably do the same thing with some hacky C++ code gen and templates, but I&#x27;m not sure clang et al would be able to optimize them.</div><br/><div id="40410331" class="c"><input type="checkbox" id="c-40410331" checked=""/><div class="controls bullet"><span class="by">tekknolagi</span><span>|</span><a href="#40408556">root</a><span>|</span><a href="#40410246">parent</a><span>|</span><a href="#40407194">next</a><span>|</span><label class="collapse" for="c-40410331">[-]</label><label class="expand" for="c-40410331">[6 more]</label></div><br/><div class="children"><div class="content">In the limit, that&#x27;s called Copy and Patch!</div><br/><div id="40410420" class="c"><input type="checkbox" id="c-40410420" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#40408556">root</a><span>|</span><a href="#40410331">parent</a><span>|</span><a href="#40407194">next</a><span>|</span><label class="collapse" for="c-40410420">[-]</label><label class="expand" for="c-40410420">[5 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t copy and patch just jitter: new fangled kids&#x27; version?</div><br/><div id="40411987" class="c"><input type="checkbox" id="c-40411987" checked=""/><div class="controls bullet"><span class="by">tekknolagi</span><span>|</span><a href="#40408556">root</a><span>|</span><a href="#40410420">parent</a><span>|</span><a href="#40407194">next</a><span>|</span><label class="collapse" for="c-40411987">[-]</label><label class="expand" for="c-40411987">[4 more]</label></div><br/><div class="children"><div class="content">As far as I can tell from the jitter docs, no; the big thing about copy and patch is that you can piggy back on the existing C compiler and whatever backends it already supports.</div><br/><div id="40412224" class="c"><input type="checkbox" id="c-40412224" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#40408556">root</a><span>|</span><a href="#40411987">parent</a><span>|</span><a href="#40407194">next</a><span>|</span><label class="collapse" for="c-40412224">[-]</label><label class="expand" for="c-40412224">[3 more]</label></div><br/><div class="children"><div class="content">&gt; piggy back on the existing C compiler and whatever backends it already supports<p>that is the whole point of jitter</div><br/><div id="40412328" class="c"><input type="checkbox" id="c-40412328" checked=""/><div class="controls bullet"><span class="by">tekknolagi</span><span>|</span><a href="#40408556">root</a><span>|</span><a href="#40412224">parent</a><span>|</span><a href="#40407194">next</a><span>|</span><label class="collapse" for="c-40412328">[-]</label><label class="expand" for="c-40412328">[2 more]</label></div><br/><div class="children"><div class="content">Does jitter compile C at run-time or just stitch it together? (EDIT: looks like stitch at run-time)<p>The other thing C&amp;P does is allow for a library of stencils and stitch them together intelligently depending on where arguments are coming from, where the return should go, where the flow of control should go next, etc<p>EDIT: So I guess they look fairly similar, huh</div><br/><div id="40412562" class="c"><input type="checkbox" id="c-40412562" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#40408556">root</a><span>|</span><a href="#40412328">parent</a><span>|</span><a href="#40407194">next</a><span>|</span><label class="collapse" for="c-40412562">[-]</label><label class="expand" for="c-40412562">[1 more]</label></div><br/><div class="children"><div class="content">yup, jitter does that too; e.g. <a href="https:&#x2F;&#x2F;ageinghacker.net&#x2F;talks&#x2F;jitter-slides--saiu--bts-2022--2022-03-06.pdf" rel="nofollow">https:&#x2F;&#x2F;ageinghacker.net&#x2F;talks&#x2F;jitter-slides--saiu--bts-2022...</a> page 23 and 35<p>fwiw i thought this was a stupid, hacky, pointless approach when it was called jitter and i still think it&#x27;s a stupid, hacky, pointless approach when it&#x27;s called copy-and-patch ;)<p>but still like to see credit where it&#x27;s due</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40407194" class="c"><input type="checkbox" id="c-40407194" checked=""/><div class="controls bullet"><span class="by">posnet</span><span>|</span><a href="#40408556">prev</a><span>|</span><a href="#40408885">next</a><span>|</span><label class="collapse" for="c-40407194">[-]</label><label class="expand" for="c-40407194">[2 more]</label></div><br/><div class="children"><div class="content">I will never not be amazed by Futamura Projections.</div><br/><div id="40407862" class="c"><input type="checkbox" id="c-40407862" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#40407194">parent</a><span>|</span><a href="#40408885">next</a><span>|</span><label class="collapse" for="c-40407862">[-]</label><label class="expand" for="c-40407862">[1 more]</label></div><br/><div class="children"><div class="content">They are pretty remarkable.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Partial_evaluation#Futamura_projections" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Partial_evaluation#Futamura_pr...</a></div><br/></div></div></div></div><div id="40408885" class="c"><input type="checkbox" id="c-40408885" checked=""/><div class="controls bullet"><span class="by">abeppu</span><span>|</span><a href="#40407194">prev</a><span>|</span><a href="#40407173">next</a><span>|</span><label class="collapse" for="c-40408885">[-]</label><label class="expand" for="c-40408885">[3 more]</label></div><br/><div class="children"><div class="content">This is cool, but the post swaps in a tiny interpreter bc it says that CPython and SpiderMonkey are both huge. It then goes on to talk about modifying the interpreter to make some specific info visible to weval, and I can imagine that those changes would be considerable for CPython or SpiderMonkey. But if we ignore those specialization sections, and just consider the material up through the &quot;Enter weval&quot; section ... could weval have handled CPython or SpiderMonkey (or some other real interpreter that people use regularly)? Or does the partial evaluation have some scaling behavior that explodes or bogs down with large or complex interpreters? I.e. was the tiny interpreter needed just to make the following sections compact, or does even the basic use of weval require a small input?</div><br/><div id="40409340" class="c"><input type="checkbox" id="c-40409340" checked=""/><div class="controls bullet"><span class="by">tekknolagi</span><span>|</span><a href="#40408885">parent</a><span>|</span><a href="#40407173">next</a><span>|</span><label class="collapse" for="c-40409340">[-]</label><label class="expand" for="c-40409340">[2 more]</label></div><br/><div class="children"><div class="content">You should wait for Chris&#x27;s upcoming post :) the minimal changes are the same as the ones I have for my tiny interpreter. There are some more advanced changes you can make for more performance</div><br/><div id="40411973" class="c"><input type="checkbox" id="c-40411973" checked=""/><div class="controls bullet"><span class="by">cfallin</span><span>|</span><a href="#40408885">root</a><span>|</span><a href="#40409340">parent</a><span>|</span><a href="#40407173">next</a><span>|</span><label class="collapse" for="c-40411973">[-]</label><label class="expand" for="c-40411973">[1 more]</label></div><br/><div class="children"><div class="content">Indeed; the tl;dr is &quot;yes it works on SpiderMonkey, and was designed to do so&quot;. Blog post in a few months, I promise!</div><br/></div></div></div></div></div></div><div id="40407173" class="c"><input type="checkbox" id="c-40407173" checked=""/><div class="controls bullet"><span class="by">tekknolagi</span><span>|</span><a href="#40408885">prev</a><span>|</span><a href="#40410446">next</a><span>|</span><label class="collapse" for="c-40407173">[-]</label><label class="expand" for="c-40407173">[11 more]</label></div><br/><div class="children"><div class="content">Author here! Feel free to ask questions or leave comments or whatever.</div><br/><div id="40407521" class="c"><input type="checkbox" id="c-40407521" checked=""/><div class="controls bullet"><span class="by">burakemir</span><span>|</span><a href="#40407173">parent</a><span>|</span><a href="#40409367">next</a><span>|</span><label class="collapse" for="c-40407521">[-]</label><label class="expand" for="c-40407521">[3 more]</label></div><br/><div class="children"><div class="content">Thanks for the write-up.<p>Neil Jones&#x27; (free) book about partial evaluation deserves a mention here, since it explains how&#x2F;why it works in some detail.<p>Query languages are a very cool application of this stuff. I was planning to use wasm for Mangle implementation (a language extending datalog, with its implementation a library for deductive database), following Tiark Rompf and Nada Amin&#x27;s &quot;a SQL to C compiler in 500 lines of code&quot;... but of course I only have the interpreter for now and started a Rust rewrite instead.</div><br/><div id="40408287" class="c"><input type="checkbox" id="c-40408287" checked=""/><div class="controls bullet"><span class="by">quag</span><span>|</span><a href="#40407173">root</a><span>|</span><a href="#40407521">parent</a><span>|</span><a href="#40409367">next</a><span>|</span><label class="collapse" for="c-40408287">[-]</label><label class="expand" for="c-40408287">[2 more]</label></div><br/><div class="children"><div class="content">The free book on partial evaluations: <a href="http:&#x2F;&#x2F;www.itu.dk&#x2F;people&#x2F;sestoft&#x2F;pebook&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.itu.dk&#x2F;people&#x2F;sestoft&#x2F;pebook&#x2F;</a></div><br/><div id="40409561" class="c"><input type="checkbox" id="c-40409561" checked=""/><div class="controls bullet"><span class="by">sestep</span><span>|</span><a href="#40407173">root</a><span>|</span><a href="#40408287">parent</a><span>|</span><a href="#40409367">next</a><span>|</span><label class="collapse" for="c-40409561">[-]</label><label class="expand" for="c-40409561">[1 more]</label></div><br/><div class="children"><div class="content">Is the book enlightening beyond what one can learn from sources like this post and the aforementioned paper by Rompf and Amin? I&#x27;m trying to decide whether I should spend the time to dig deeper into it.</div><br/></div></div></div></div></div></div><div id="40409367" class="c"><input type="checkbox" id="c-40409367" checked=""/><div class="controls bullet"><span class="by">azakai</span><span>|</span><a href="#40407173">parent</a><span>|</span><a href="#40407521">prev</a><span>|</span><a href="#40410446">next</a><span>|</span><label class="collapse" for="c-40409367">[-]</label><label class="expand" for="c-40409367">[7 more]</label></div><br/><div class="children"><div class="content">I understand that by making the bytecode constant a lot of optimization become possible. But I can&#x27;t see how you can unroll the interpreter loop past unknown inputs to the program?<p>That is, if the program is a pure function like power(x, y) (from the top of the article) then I understand if the bytecode is constant and the inputs x, y are constant then you can unroll completely. In fact, in that case, you can just do a full evaluation of the entire program to a constant. But, if x and y are unknown at compile time then you can do very little, I think?<p>I guess the example at the top of the article is saying that if you know y but not x then partial evaluation can still help a lot. But in a real-world program the first unknown input that causes a significant branch in execution will block progress, won&#x27;t it? (edit: in particular unrolling has to stop, unless you consider multiple paths)</div><br/><div id="40410364" class="c"><input type="checkbox" id="c-40410364" checked=""/><div class="controls bullet"><span class="by">n_plus_1_acc</span><span>|</span><a href="#40407173">root</a><span>|</span><a href="#40409367">parent</a><span>|</span><a href="#40409512">next</a><span>|</span><label class="collapse" for="c-40410364">[-]</label><label class="expand" for="c-40410364">[4 more]</label></div><br/><div class="children"><div class="content">For a given function like `power`, you can unroll the interpreter loop and eliminate branches on the instruction, so the code has less branching overall.</div><br/><div id="40410412" class="c"><input type="checkbox" id="c-40410412" checked=""/><div class="controls bullet"><span class="by">azakai</span><span>|</span><a href="#40407173">root</a><span>|</span><a href="#40410364">parent</a><span>|</span><a href="#40409512">next</a><span>|</span><label class="collapse" for="c-40410412">[-]</label><label class="expand" for="c-40410412">[3 more]</label></div><br/><div class="children"><div class="content">But can you only do that when you know what the inputs are? That is, if x and y are determined only at runtime for power(x, y) then I don&#x27;t see what can be optimized. But that seems like the common case to me. Likely I&#x27;m missing something and maybe not asking the question clearly, sorry.</div><br/><div id="40411963" class="c"><input type="checkbox" id="c-40411963" checked=""/><div class="controls bullet"><span class="by">cfallin</span><span>|</span><a href="#40407173">root</a><span>|</span><a href="#40410412">parent</a><span>|</span><a href="#40409512">next</a><span>|</span><label class="collapse" for="c-40411963">[-]</label><label class="expand" for="c-40411963">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That is, if x and y are determined only at runtime for power(x, y) then I don&#x27;t see what can be optimized.<p>Yes, the example in Max&#x27;s post is specifically assuming one wants to generate a specialized version of `power` where `y` is fixed.<p>To take it back to weval: we can know what the bytecode input to the interpreter is; we provide an intrinsic (part of the &quot;wevaling&quot; request) to indicate that some function argument is a pointer to memory with constant, guaranteed-not-to-change content. That, together with context specialization on PC (another intrinsic), allows us to unroll the interpreter loop and branch-fold it so we get the equivalent of a template method compiler that reconstitutes the CFG embedded in the bytecode.</div><br/><div id="40412134" class="c"><input type="checkbox" id="c-40412134" checked=""/><div class="controls bullet"><span class="by">azakai</span><span>|</span><a href="#40407173">root</a><span>|</span><a href="#40411963">parent</a><span>|</span><a href="#40409512">next</a><span>|</span><label class="collapse" for="c-40412134">[-]</label><label class="expand" for="c-40412134">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, I think I see now. So `y` is the bytecode, in the analogy. Makes sense.<p>(For me at least a concrete example would have helped, something like showing the specialized output of running on the bytecode for `power` with that interpreter. But maybe that would be too verbose...)</div><br/></div></div></div></div></div></div></div></div><div id="40409512" class="c"><input type="checkbox" id="c-40409512" checked=""/><div class="controls bullet"><span class="by">tekknolagi</span><span>|</span><a href="#40407173">root</a><span>|</span><a href="#40409367">parent</a><span>|</span><a href="#40410364">prev</a><span>|</span><a href="#40410446">next</a><span>|</span><label class="collapse" for="c-40409512">[-]</label><label class="expand" for="c-40409512">[2 more]</label></div><br/><div class="children"><div class="content">Weval has intrinsics that unroll the loop and specialize on the PC, merging paths with the same PC. So if you pick a good specialization context like PC, the unrolling stops eventually.</div><br/></div></div></div></div></div></div><div id="40410446" class="c"><input type="checkbox" id="c-40410446" checked=""/><div class="controls bullet"><span class="by">aatd86</span><span>|</span><a href="#40407173">prev</a><span>|</span><label class="collapse" for="c-40410446">[-]</label><label class="expand" for="c-40410446">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I understand.
This would be useful if, for instance, a runtime (compiled as a wasm function) accepted code as input to be run.<p>But not if the code was compiled to wasm alongside the runtime?<p>Asking because I have compiled the go compiler and the standard library package as wasm. Would weval help here?
Is that what wasmbindgen does?</div><br/></div></div></div></div></div></div></div></body></html>