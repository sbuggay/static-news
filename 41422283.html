<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725267676795" as="style"/><link rel="stylesheet" href="styles.css?v=1725267676795"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.raygard.net/awkdoc/pages/awk_parsing_is_tricky.html">Parsing Awk Is Tricky</a> <span class="domain">(<a href="https://www.raygard.net">www.raygard.net</a>)</span></div><div class="subtext"><span>oliverkwebb</span> | <span>17 comments</span></div><br/><div><div id="41423719" class="c"><input type="checkbox" id="c-41423719" checked=""/><div class="controls bullet"><span class="by">teleforce</span><span>|</span><a href="#41423384">next</a><span>|</span><label class="collapse" for="c-41423719">[-]</label><label class="expand" for="c-41423719">[1 more]</label></div><br/><div class="children"><div class="content">If you think AWK is hard to parse then try C++. The latter is so hard to parse thus very slow compile time that most probably inspired a funny programmer skit like this, one of the most popular XKCDs of all time [1].<p>Then come along fast compilation modern languages like Go and D. The latter is such a fresh air is that even though it&#x27;s a complex language like C++ and Rust but it managed to compile very fast.  Heck it even has RDMD facility that can perform compiled REPL as you interacting with the prompt similar to interpreted programming languages like Python and Matlab.<p>According to its author, the main reason D has very fast compile time (as long as you avoid the CTFE) is because of the language design decisions avoid the notorious symbols that can complicated symbol table just like happened in C++ and the popular &lt;&lt; and &gt;&gt;  overloading for I&#x2F;O and shifting. But the fact that Rust come much later than C++ and D but still slow to compile is bewildering to say the least.<p>[1] Compiling:<p><a href="https:&#x2F;&#x2F;xkcd.com&#x2F;303&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;303&#x2F;</a></div><br/></div></div><div id="41422614" class="c"><input type="checkbox" id="c-41422614" checked=""/><div class="controls bullet"><span class="by">RodgerTheGreat</span><span>|</span><a href="#41423384">prev</a><span>|</span><a href="#41423238">next</a><span>|</span><label class="collapse" for="c-41422614">[-]</label><label class="expand" for="c-41422614">[7 more]</label></div><br/><div class="children"><div class="content">I think this is a good illustration of why parser-generator middleware like yacc is fundamentally misguided; they create <i>totally unnecessary gaps</i> between design intent and the action of the parser. In a hand-rolled recursive descent parser, or even a set of PEG productions, ambiguities and complex lookahead or backtracking leap out at the programmer immediately.</div><br/><div id="41423735" class="c"><input type="checkbox" id="c-41423735" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#41422614">parent</a><span>|</span><a href="#41422815">next</a><span>|</span><label class="collapse" for="c-41423735">[-]</label><label class="expand" for="c-41423735">[1 more]</label></div><br/><div class="children"><div class="content">I think it would be interesting and adequate to hear about and link to the reflections of the original awk authors (Aho, Kernighan, Weinberg et al) considering they were also experts for yacc and other compiler-compiler tools from the 1977–1985 era and authors of the dragon book. After all, awk syntax was the starting point for JavaScript including warts such as regexp literals, optional semicolons, for (e in a), delete a[e], introducing the function keyword to a C-like language, etc. I recall at least Kernighan talked about optional semicolons as something he‘d reconsider given the chance.</div><br/></div></div><div id="41422815" class="c"><input type="checkbox" id="c-41422815" checked=""/><div class="controls bullet"><span class="by">jasone</span><span>|</span><a href="#41422614">parent</a><span>|</span><a href="#41423735">prev</a><span>|</span><a href="#41422969">next</a><span>|</span><label class="collapse" for="c-41422815">[-]</label><label class="expand" for="c-41422815">[3 more]</label></div><br/><div class="children"><div class="content">Hard disagree. Yacc has unnecessary footguns, in particular the fallout from using LALR(1), but more modern parser generators like bison provide LR(1) and IELR(1). Hand-rolled recursive descent parsers as well as parser combinators can easily obscure implicit resolution of grammar ambiguities. A good LR(1) parser generator enables a level of grammar consistency that is very difficult to achieve otherwise.</div><br/><div id="41423466" class="c"><input type="checkbox" id="c-41423466" checked=""/><div class="controls bullet"><span class="by">thomasmg</span><span>|</span><a href="#41422614">root</a><span>|</span><a href="#41422815">parent</a><span>|</span><a href="#41423367">next</a><span>|</span><label class="collapse" for="c-41423466">[-]</label><label class="expand" for="c-41423466">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Hand-rolled recursive descent parsers as well as parser combinators can easily obscure implicit resolution of grammar ambiguities.<p>Could you give a concrete, real-life example of this? I have written many recursive-descent parsers and never ran into this problem (Apache Jackrabbit Oak SQL and XPath parser, H2 database engine, PointBase Micro database engine, HypersonicSQL, NewSQL, Regex parsers, GraphQL parsers, and currently the Bau programming language).<p>I have often heard that Bison &#x2F; Yacc &#x2F; ANTLR etc are &quot;superior&quot;, but mostly from people that didn&#x27;t actually have to write and maintain production-quality parsers. I do have experience with the above parser generators, eg. for university projects, and Apache Jackrabbit (2.x). I remember that in each case, the parser generators had some &quot;limitations&quot; that caused problems down the line. Then I had to spend more time trying to work around the parser generator limitations than actually doing productive work.<p>This may sound harsh, but well that&#x27;s my experience... I would love to hear from people that had a different experience for non-trivial projects...</div><br/></div></div><div id="41423367" class="c"><input type="checkbox" id="c-41423367" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#41422614">root</a><span>|</span><a href="#41422815">parent</a><span>|</span><a href="#41423466">prev</a><span>|</span><a href="#41422969">next</a><span>|</span><label class="collapse" for="c-41423367">[-]</label><label class="expand" for="c-41423367">[1 more]</label></div><br/><div class="children"><div class="content">Same. LR(k) and LL(k) are readable and completely unambiguous, in contrast to PEG, where ambiguity is resolved ad hoc: PEG doesn&#x27;t have a single definition, so implementations may differ, and the original PEG uses the order of the rules and backtracking to resolve ambiguity, which may lead to different resolutions in different contexts. Ambiguity does not leap out to the programmer.<p>OTOH, an LL(1) grammar can be used to generate a top-down&#x2F;recursive descent parser, and will always be correct.</div><br/></div></div></div></div><div id="41422969" class="c"><input type="checkbox" id="c-41422969" checked=""/><div class="controls bullet"><span class="by">Levitating</span><span>|</span><a href="#41422614">parent</a><span>|</span><a href="#41422815">prev</a><span>|</span><a href="#41423238">next</a><span>|</span><label class="collapse" for="c-41422969">[-]</label><label class="expand" for="c-41422969">[2 more]</label></div><br/><div class="children"><div class="content">And GNU is notorious for their use of yacc. Even gnulib functions like parse_datetime (primarily used to power the date command) rely on a yacc generated parser.</div><br/><div id="41423539" class="c"><input type="checkbox" id="c-41423539" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#41422614">root</a><span>|</span><a href="#41422969">parent</a><span>|</span><a href="#41423238">next</a><span>|</span><label class="collapse" for="c-41423539">[-]</label><label class="expand" for="c-41423539">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s mostly for historical reasons. Nobody felt the need to switch and do all the work needed to avoid breaking edge cases.<p>GCC used to have Bison grammars but it switched to recursive descent about 20 years ago.
The C++ grammar was especially horrible.</div><br/></div></div></div></div></div></div><div id="41423238" class="c"><input type="checkbox" id="c-41423238" checked=""/><div class="controls bullet"><span class="by">v3ss0n</span><span>|</span><a href="#41422614">prev</a><span>|</span><label class="collapse" for="c-41423238">[-]</label><label class="expand" for="c-41423238">[7 more]</label></div><br/><div class="children"><div class="content">Reading awk as a human is hard too. And performance of awk is crap. A lot slower than most interpreter language out there.  I had replaced all the awk scripts in python and everything is a lot faster.</div><br/><div id="41423389" class="c"><input type="checkbox" id="c-41423389" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#41423238">parent</a><span>|</span><a href="#41423687">next</a><span>|</span><label class="collapse" for="c-41423389">[-]</label><label class="expand" for="c-41423389">[1 more]</label></div><br/><div class="children"><div class="content">Discussing performance only makes sense in the context of a particular awk implementation, like TFA is doing as well. If you‘re (stuck) on gawk, try setting LANG=C to prevent Unicode&#x2F;multi-byte regexp execution, or switch to mawk (which according to [1] is much faster than cpython).<p>[1]: <a href="https:&#x2F;&#x2F;brenocon.com&#x2F;blog&#x2F;2009&#x2F;09&#x2F;dont-mawk-awk-the-fastest-and-most-elegant-big-data-munging-language&#x2F;" rel="nofollow">https:&#x2F;&#x2F;brenocon.com&#x2F;blog&#x2F;2009&#x2F;09&#x2F;dont-mawk-awk-the-fastest-...</a></div><br/></div></div><div id="41423687" class="c"><input type="checkbox" id="c-41423687" checked=""/><div class="controls bullet"><span class="by">n4r9</span><span>|</span><a href="#41423238">parent</a><span>|</span><a href="#41423389">prev</a><span>|</span><a href="#41423312">next</a><span>|</span><label class="collapse" for="c-41423687">[-]</label><label class="expand" for="c-41423687">[1 more]</label></div><br/><div class="children"><div class="content">Awk is blazingly fast for some operations. I remember using it to solve Project Euler problem 67 [0] in a couple of milliseconds, which is more comparable to C&#x2F;Rust than Python. Weirdly the forum posts from between 2013 Nd 2023 are missing so I can&#x27;t see what I wrote there.<p>[0] <a href="https:&#x2F;&#x2F;projecteuler.net&#x2F;problem=67" rel="nofollow">https:&#x2F;&#x2F;projecteuler.net&#x2F;problem=67</a></div><br/></div></div><div id="41423312" class="c"><input type="checkbox" id="c-41423312" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#41423238">parent</a><span>|</span><a href="#41423687">prev</a><span>|</span><label class="collapse" for="c-41423312">[-]</label><label class="expand" for="c-41423312">[4 more]</label></div><br/><div class="children"><div class="content">skill issue</div><br/><div id="41423514" class="c"><input type="checkbox" id="c-41423514" checked=""/><div class="controls bullet"><span class="by">creesch</span><span>|</span><a href="#41423238">root</a><span>|</span><a href="#41423312">parent</a><span>|</span><a href="#41423652">next</a><span>|</span><label class="collapse" for="c-41423514">[-]</label><label class="expand" for="c-41423514">[1 more]</label></div><br/><div class="children"><div class="content">Sure. I do not live in the terminal. But, I work with Linux enough to comfortably navigate around, read various shell scripts with relative ease. With the exception of awk. Which to me signals that, at least in my case, awk has a higher barrier for entry compared to most other things in the same environment.<p>So with alternatives around I can more easily parse myself, I happily concede that I have a skill issue with awk.</div><br/></div></div><div id="41423652" class="c"><input type="checkbox" id="c-41423652" checked=""/><div class="controls bullet"><span class="by">watt</span><span>|</span><a href="#41423238">root</a><span>|</span><a href="#41423312">parent</a><span>|</span><a href="#41423514">prev</a><span>|</span><a href="#41423710">next</a><span>|</span><label class="collapse" for="c-41423652">[-]</label><label class="expand" for="c-41423652">[1 more]</label></div><br/><div class="children"><div class="content">once there are more productive alternatives that require less specialized &quot;skill&quot;, your condescending &quot;skill issue&quot; becomes a devex issue, and basically a productivity gap which will doom your language or tool.</div><br/></div></div><div id="41423710" class="c"><input type="checkbox" id="c-41423710" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#41423238">root</a><span>|</span><a href="#41423312">parent</a><span>|</span><a href="#41423652">prev</a><span>|</span><label class="collapse" for="c-41423710">[-]</label><label class="expand" for="c-41423710">[1 more]</label></div><br/><div class="children"><div class="content">You just need to have the skill to overcome whatever non-technical, legacy, lack of education, or poor judgement issues that are steamrolling you into choosing to use awk instead of a sane rational decent modern efficient maintainable language.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>