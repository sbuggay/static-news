<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729760475229" as="style"/><link rel="stylesheet" href="styles.css?v=1729760475229"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://pypy.org/posts/2024/10/jit-peephole-dsl.html">A DSL for peephole transformation rules of integer operations in the PyPy JIT</a>Â <span class="domain">(<a href="https://pypy.org">pypy.org</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>11 comments</span></div><br/><div><div id="41927220" class="c"><input type="checkbox" id="c-41927220" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#41933081">next</a><span>|</span><label class="collapse" for="c-41927220">[-]</label><label class="expand" for="c-41927220">[1 more]</label></div><br/><div class="children"><div class="content">GCC does this match.pd.  Here&#x27;s the add_zero example, I think:<p><pre><code>    &#x2F;* Simplifications of operations with one constant operand and
       simplifications to constants or single values.  *&#x2F;
    
    (for op (plus pointer_plus minus bit_ior bit_xor)
      (simplify
        (op @0 integer_zerop)
        (non_lvalue @0)))
</code></pre>
<a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;git&#x2F;?p=gcc.git;a=blob;f=gcc&#x2F;match.pd" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;git&#x2F;?p=gcc.git;a=blob;f=gcc&#x2F;match.pd</a><p>The floating point case can be more complicated because of signed zeros and signaling NaNs, see fold_real_zero_addition_p.</div><br/></div></div><div id="41933081" class="c"><input type="checkbox" id="c-41933081" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#41927220">prev</a><span>|</span><a href="#41931428">next</a><span>|</span><label class="collapse" for="c-41933081">[-]</label><label class="expand" for="c-41933081">[1 more]</label></div><br/><div class="children"><div class="content">A cost model would give a proof of termination - require the output of each transform to be cheaper than the input. Confluence is less obvious.</div><br/></div></div><div id="41930026" class="c"><input type="checkbox" id="c-41930026" checked=""/><div class="controls bullet"><span class="by">hoten</span><span>|</span><a href="#41931428">prev</a><span>|</span><a href="#41929803">next</a><span>|</span><label class="collapse" for="c-41930026">[-]</label><label class="expand" for="c-41930026">[3 more]</label></div><br/><div class="children"><div class="content">The before&#x2F;after delta is very satisfying and clearly easier to work with. Very nice.<p>How does the DSL handle side effects? I&#x27;m assuming any term here could be a compound expression, so what part of the system prevents &quot;0*callfn()&quot; from reducing to &quot;0&quot;?</div><br/><div id="41930114" class="c"><input type="checkbox" id="c-41930114" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#41930026">parent</a><span>|</span><a href="#41929803">next</a><span>|</span><label class="collapse" for="c-41930114">[-]</label><label class="expand" for="c-41930114">[2 more]</label></div><br/><div class="children"><div class="content">I believe this operates on values in something akin to registers, not expression trees. By the time you get to a place where one of these rules is relevant, the side effect has already taken place. This just prevents the return of such a function call to be operated on, like in your example.</div><br/><div id="41931822" class="c"><input type="checkbox" id="c-41931822" checked=""/><div class="controls bullet"><span class="by">cfbolztereick</span><span>|</span><a href="#41930026">root</a><span>|</span><a href="#41930114">parent</a><span>|</span><a href="#41929803">next</a><span>|</span><label class="collapse" for="c-41931822">[-]</label><label class="expand" for="c-41931822">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, that&#x27;s exactly right. It&#x27;s operating on an SSA-based intermediate representation. So if an operation gets removed, the arguments are still being computed. The earlier operations that produce those arguments can also be removed by dead code elimination (which runs later), but indeed only if they have no side effects.<p>I suppose the notation of the rule heads makes it look like there actually are expression trees, which is maybe sort of confusing.</div><br/></div></div></div></div></div></div><div id="41929803" class="c"><input type="checkbox" id="c-41929803" checked=""/><div class="controls bullet"><span class="by">mjcohen</span><span>|</span><a href="#41930026">prev</a><span>|</span><a href="#41927655">next</a><span>|</span><label class="collapse" for="c-41929803">[-]</label><label class="expand" for="c-41929803">[1 more]</label></div><br/><div class="children"><div class="content">Interesting to see which optimizations are never used.</div><br/></div></div><div id="41927655" class="c"><input type="checkbox" id="c-41927655" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#41929803">prev</a><span>|</span><a href="#41927762">next</a><span>|</span><label class="collapse" for="c-41927655">[-]</label><label class="expand" for="c-41927655">[2 more]</label></div><br/><div class="children"><div class="content">math.fma fused multiply add is in Python 3.13. Are there already rules to transform expressions to math.fma?<p>And does Z3 verification indicate differences in output due to minimizing float-rounding error?<p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;math.html#math.fma" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;math.html#math.fma</a> :<p>&gt; <i>math.fma(x, y, z)</i><p>&gt; <i>Fused multiply-add operation. Return (x * y) + z, computed as though with infinite precision and range followed by a single round to the float format. This operation often provides better accuracy than the direct expression (x * y) + z.</i><p>&gt; <i>This function follows the specification of the fusedMultiplyAdd operation described in the IEEE 754 standard.</i></div><br/><div id="41928178" class="c"><input type="checkbox" id="c-41928178" checked=""/><div class="controls bullet"><span class="by">cfbolztereick</span><span>|</span><a href="#41927655">parent</a><span>|</span><a href="#41927762">next</a><span>|</span><label class="collapse" for="c-41928178">[-]</label><label class="expand" for="c-41928178">[1 more]</label></div><br/><div class="children"><div class="content">I only support integer operations in the DSL so far.<p>(but yes, turning the python expression x*y+z into an fma call would not be a legal optimization for the jit anyway. And Z3 would rightfully complain. The results must be bitwise identical before and after optimization)</div><br/></div></div></div></div></div></div></div></div></div></body></html>