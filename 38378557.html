<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700816457832" as="style"/><link rel="stylesheet" href="styles.css?v=1700816457832"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lwn.net/Articles/351422/">POSIX v. reality: A position on O_PONIES (2009)</a> <span class="domain">(<a href="https://lwn.net">lwn.net</a>)</span></div><div class="subtext"><span>nolist_policy</span> | <span>54 comments</span></div><br/><div><div id="38397614" class="c"><input type="checkbox" id="c-38397614" checked=""/><div class="controls bullet"><span class="by">dale_glass</span><span>|</span><a href="#38400296">next</a><span>|</span><label class="collapse" for="c-38397614">[-]</label><label class="expand" for="c-38397614">[32 more]</label></div><br/><div class="children"><div class="content">I believe the solution is actually pretty simple, though maybe not easily implementable:<p>Provide new API calls with precisely defined semantics.<p>Rather have this rigamarole with fsync and rename, provide an actual syscall with the actual effect the userspace developers are looking for. Eg, an atomic_replace() syscall that ensures that either a file is replaced with a new, fully written to disk version, or nothing happens.<p>The main problem I see is that this of course would be Linux specific, so of course somebody would build a library to either invoke the syscall or do the fsync&#x2F;rename mess underneath, and this would of course run into the same exact problem on those systems.</div><br/><div id="38398958" class="c"><input type="checkbox" id="c-38398958" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#38397614">parent</a><span>|</span><a href="#38398359">next</a><span>|</span><label class="collapse" for="c-38398958">[-]</label><label class="expand" for="c-38398958">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve proposed this informally before, along these lines:<p>- Unit files. You create, you write, you close, and then others can read the new version. Until the original writer closes and gets a good close status, nobody else can read it. If the program aborts or the system crashes before closing cleanly, the file reverts. All readers see a fully written file. This is the default. It&#x27;s what most programs need. Replacing a file by creating a new one on top of it is both permitted and an atomic operation. UCLA-LOCUS and some IBM systems that followed worked that way.<p>- Temporary files. Disappear on system crash.<p>- Log files. Append-only. All readers are guaranteed to see an end of file position that corresponds to the end of a previous write. Usually the most recent write, but buffering may make log file reading run a little behind.<p>- Managed files. Read, write, share. Write operations return two completions, probably via some async mechanism. The first completion means &quot;buffer contents taken&quot;. The second completion means &quot;committed to storage that will survive a crash&quot;. Database systems would use this, but few other programs would bother.<p>This tells the database what it really needs to know - when is the data safe? That tells the database when it can commit a transaction. The database can do other things, including more I&#x2F;O, while waiting for commitment.<p>&quot;fsync&quot; is really a clunky way of getting that second completion.</div><br/><div id="38399555" class="c"><input type="checkbox" id="c-38399555" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38398958">parent</a><span>|</span><a href="#38400341">next</a><span>|</span><label class="collapse" for="c-38399555">[-]</label><label class="expand" for="c-38399555">[4 more]</label></div><br/><div class="children"><div class="content">I think most of those things are implementable in userspace with the right combination of O_TMPFILE, rename, fsync, fsync(dir), sync_file_range and io_uring.<p>So all that&#x27;s needed is encapsulating it in a library that provides those different abstractions.<p>Well ok, we could also use an additional flag for linkat() that allows atomically replacing the target to close that tiny window where a temporary file might get left behind after a crash.</div><br/><div id="38399774" class="c"><input type="checkbox" id="c-38399774" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38399555">parent</a><span>|</span><a href="#38400341">next</a><span>|</span><label class="collapse" for="c-38399774">[-]</label><label class="expand" for="c-38399774">[3 more]</label></div><br/><div class="children"><div class="content">Actually, a good chunk of that is available via memfd + linkat.<p>- Unit files: memfd, fdatasync, linkat, fsync(dir)<p>- Temporary files. memfd, preferably within &#x2F;tmp to avoid any disk I&#x2F;O unless you have a particularly large file to buffer<p>- Log files. This is trickier. Probably requires running on a fs that supports reflinks and creating a new memfd that’s a true clone of the original file, appending, &amp; then replacing it. The one piece that is incompatible with this is that other file descriptors are stale and you have to reopen to see new data but that’s at odds with APIs available today - either readers can see partial writes or you have to have a new file. There have been proposals to allow buffering writes but delaying publishing the metadata acking the data but that hasn’t gone anywhere unfortunately.<p>- Managed files. I’m not sure that completions are the right contract here because technically the kernel could defer that completion indefinitely whereas databases typical need some kind of latency bounds of “OK - I really want this to commit to disk nowish”.</div><br/><div id="38400786" class="c"><input type="checkbox" id="c-38400786" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38399774">parent</a><span>|</span><a href="#38400341">next</a><span>|</span><label class="collapse" for="c-38400786">[-]</label><label class="expand" for="c-38400786">[2 more]</label></div><br/><div class="children"><div class="content">&quot;memfd + linkat&quot;? How shall that work?<p>memfd is for files in RAM. linkat cannot get them onto disk. What you seem to have in mind is what the grandparent post already described: &quot;O_TMPFILE + linkat&quot;.</div><br/><div id="38401020" class="c"><input type="checkbox" id="c-38401020" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38400786">parent</a><span>|</span><a href="#38400341">next</a><span>|</span><label class="collapse" for="c-38401020">[-]</label><label class="expand" for="c-38401020">[1 more]</label></div><br/><div class="children"><div class="content">Sorry that’s right. O_TMPFILE is indeed what I meant</div><br/></div></div></div></div></div></div></div></div><div id="38400341" class="c"><input type="checkbox" id="c-38400341" checked=""/><div class="controls bullet"><span class="by">throwaway09223</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38398958">parent</a><span>|</span><a href="#38399555">prev</a><span>|</span><a href="#38398359">next</a><span>|</span><label class="collapse" for="c-38400341">[-]</label><label class="expand" for="c-38400341">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not, though, because fsync has no relation whatsoever to what other processes see.<p>Durability is totally different from concurrency or multiprocess consistency.<p>There are already guarantees about how we can order reads and writes in a shared file. Very well defined guarantees -- ones we&#x27;ve built entire RDBMS systems on top of.<p>Guaranteeing durability (persistence across a crash) is a totally separate problem from understanding write visibility between threads.</div><br/><div id="38401458" class="c"><input type="checkbox" id="c-38401458" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38400341">parent</a><span>|</span><a href="#38398359">next</a><span>|</span><label class="collapse" for="c-38401458">[-]</label><label class="expand" for="c-38401458">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s not, though, because fsync has no relation whatsoever to what other processes see.<p>Ah, the SQLite people. I was thinking in terms of databases such as MySQL and Postgres where one process owns the files and client programs communicate with it.</div><br/></div></div></div></div></div></div><div id="38398359" class="c"><input type="checkbox" id="c-38398359" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38397614">parent</a><span>|</span><a href="#38398958">prev</a><span>|</span><a href="#38397738">next</a><span>|</span><label class="collapse" for="c-38398359">[-]</label><label class="expand" for="c-38398359">[7 more]</label></div><br/><div class="children"><div class="content">The problem is every filesystem would implement a different version of fsync_that_works or rename_for_safety and then applications will have to call all of them, and then people will start building a compat framework that tries to assemble the optimal sequence of calls for each filesystem except it won&#x27;t work in every case and so a new fsync_but_no_cheating function will be proposed.</div><br/><div id="38398806" class="c"><input type="checkbox" id="c-38398806" checked=""/><div class="controls bullet"><span class="by">dale_glass</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38398359">parent</a><span>|</span><a href="#38398730">next</a><span>|</span><label class="collapse" for="c-38398806">[-]</label><label class="expand" for="c-38398806">[2 more]</label></div><br/><div class="children"><div class="content">The trick is not allowing such a thing. Don&#x27;t have something vague like &quot;fsync_that_works&quot; that could be implemented arbitrarily.<p>Have a function that is documented to implement a highly specific contract, like &quot;writes all pending blocks of this file to disk, and ensures they&#x27;ll be there if there&#x27;s a crash after the function returns&quot;.</div><br/><div id="38399010" class="c"><input type="checkbox" id="c-38399010" checked=""/><div class="controls bullet"><span class="by">fl0ki</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38398806">parent</a><span>|</span><a href="#38398730">next</a><span>|</span><label class="collapse" for="c-38399010">[-]</label><label class="expand" for="c-38399010">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly what people expect from fsync(). The problem explained in the article is that, due to the difficulties of tracing every possible related write, it is (was?) often implemented conservatively and waited for more writes to land than were strictly necessary.<p>I don&#x27;t know how much this tracing has improved in various kernels since 2009, but I do know that I would want them to benefit fsync(), not to make a new function with a subtly different contract.</div><br/></div></div></div></div><div id="38398730" class="c"><input type="checkbox" id="c-38398730" checked=""/><div class="controls bullet"><span class="by">appplication</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38398359">parent</a><span>|</span><a href="#38398806">prev</a><span>|</span><a href="#38397738">next</a><span>|</span><label class="collapse" for="c-38398730">[-]</label><label class="expand" for="c-38398730">[4 more]</label></div><br/><div class="children"><div class="content">Does this suggest that the idea of an overarching fsync&#x2F;rename is perhaps being proposed at the wrong level of abstraction? If it can’t be reliably implemented at every subsequent level, what’s the point in having it at this level?</div><br/><div id="38398886" class="c"><input type="checkbox" id="c-38398886" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38398730">parent</a><span>|</span><a href="#38397738">next</a><span>|</span><label class="collapse" for="c-38398886">[-]</label><label class="expand" for="c-38398886">[3 more]</label></div><br/><div class="children"><div class="content">Different filesystems have different on disk structures, with varying degrees of complexity and cost in getting those things on disk. Everything can reliably get everything written eventually, but if you want to fully utilize your disk bandwidth, you only want to flush the data that can get there fast, which is going to vary by filesystem. And different applications have different durability requirements.</div><br/><div id="38398965" class="c"><input type="checkbox" id="c-38398965" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38398886">parent</a><span>|</span><a href="#38397738">next</a><span>|</span><label class="collapse" for="c-38398965">[-]</label><label class="expand" for="c-38398965">[2 more]</label></div><br/><div class="children"><div class="content">This is still no argument to not define syscalls for the semantics that applications typically care about. If it is slow on a particular file system, then so be it, it’s still the semantics the application requires.</div><br/><div id="38399390" class="c"><input type="checkbox" id="c-38399390" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38398965">parent</a><span>|</span><a href="#38397738">next</a><span>|</span><label class="collapse" for="c-38399390">[-]</label><label class="expand" for="c-38399390">[1 more]</label></div><br/><div class="children"><div class="content">So call fsync.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38397738" class="c"><input type="checkbox" id="c-38397738" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#38397614">parent</a><span>|</span><a href="#38398359">prev</a><span>|</span><a href="#38399019">next</a><span>|</span><label class="collapse" for="c-38397738">[-]</label><label class="expand" for="c-38397738">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think there&#x27;s really any issue with it being Linux specific. There are plenty of Linux specific APIs that people happily use already.<p>Seems to me the bigger issue is the deification of POSIX and UNIX. There&#x27;s a stupidly large contingent of people that think that they are flawless and must be followed unthinkingly.</div><br/><div id="38398575" class="c"><input type="checkbox" id="c-38398575" checked=""/><div class="controls bullet"><span class="by">anonacct37</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38397738">parent</a><span>|</span><a href="#38399019">next</a><span>|</span><label class="collapse" for="c-38398575">[-]</label><label class="expand" for="c-38398575">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve noticed that this week. After spending a little time just reading on how to correctly write posix compliant code that was also guaranteed to do what I want, it&#x27;s hard to come to any other conclusion than &quot;posix is a last ditch attempt to slap a bandaid on Unix fragmentation by attempting to retcon some lowest common denominator behavior from a couple popular unixish operating systems and calling that a spec&quot;.<p>It&#x27;s not what I would actually call designed. The closest analogy I can think of for non-c programmers is that posix is like if we decided that people should only make websites using javascript that was mutually interpretable by IE6 and Netscape navigator and we occasionally made updates every decade or two.<p>There&#x27;s really nothing particularly noble or good or correct or elegant about all the API calls with implementation defined semantics. At best it&#x27;s a necessary evil for compatibility. You can admire the cleverness required to get a single simple c codebase that works correctly on multiple operating systems and future operating systems that conform to posix in creative ways, but only in the way I admire those old school zines that are simultaneously a PDF and a jpeg and a shell script. Clever and ingenious but not actually good engineering design.</div><br/><div id="38398866" class="c"><input type="checkbox" id="c-38398866" checked=""/><div class="controls bullet"><span class="by">dale_glass</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38398575">parent</a><span>|</span><a href="#38400232">next</a><span>|</span><label class="collapse" for="c-38398866">[-]</label><label class="expand" for="c-38398866">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s that, and there&#x27;s a lot of UNIX actually sucks these days and was made for different times.<p>Like signals, for instance. Okay idea when users are writing C from scratch to implement simple things. Horrible pain in modern times, with threads and libraries not playing well with signals.</div><br/></div></div><div id="38400232" class="c"><input type="checkbox" id="c-38400232" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38398575">parent</a><span>|</span><a href="#38398866">prev</a><span>|</span><a href="#38399019">next</a><span>|</span><label class="collapse" for="c-38400232">[-]</label><label class="expand" for="c-38400232">[1 more]</label></div><br/><div class="children"><div class="content">If there&#x27;s a bug in a Unix derivative, does the issue lie with the implementation or the POSIX spec?<p>Answer: It lies with the people wanting a fix!<p>Moral of the story: backwards compatibility is a menace.</div><br/></div></div></div></div></div></div><div id="38399019" class="c"><input type="checkbox" id="c-38399019" checked=""/><div class="controls bullet"><span class="by">Denvercoder9</span><span>|</span><a href="#38397614">parent</a><span>|</span><a href="#38397738">prev</a><span>|</span><a href="#38400320">next</a><span>|</span><label class="collapse" for="c-38399019">[-]</label><label class="expand" for="c-38399019">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see how new APIs will help here. The problem is that the semantics that application developers want is expensive (performance-wise), so they use a similar API that doesn&#x27;t guarantee those semantics but provides them in practice 99% of the time. You could create a new set of API&#x27;s, but it&#x27;s really hard to implement any API in a way that doesn&#x27;t give extra, unspecified semantics in practice, so what prevents application developers from making the same choice?</div><br/><div id="38399252" class="c"><input type="checkbox" id="c-38399252" checked=""/><div class="controls bullet"><span class="by">Filligree</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38399019">parent</a><span>|</span><a href="#38400320">next</a><span>|</span><label class="collapse" for="c-38399252">[-]</label><label class="expand" for="c-38399252">[1 more]</label></div><br/><div class="children"><div class="content">They aren&#x27;t <i>that</i> expensive. ZFS provides them by default, in that no operations are ever reordered in a user-visible fashion even without fsync. That&#x27;s a stronger guarantee than we&#x27;re asking for here.</div><br/></div></div></div></div><div id="38400320" class="c"><input type="checkbox" id="c-38400320" checked=""/><div class="controls bullet"><span class="by">throwaway09223</span><span>|</span><a href="#38397614">parent</a><span>|</span><a href="#38399019">prev</a><span>|</span><a href="#38397840">next</a><span>|</span><label class="collapse" for="c-38400320">[-]</label><label class="expand" for="c-38400320">[6 more]</label></div><br/><div class="children"><div class="content">But there is no rigamarole. The article is just super confused.<p>Atomicity is orthogonal to durability. rename() is atomic and always has been atomic. It is atomic without guaranteeing durability.<p>In fact, to guarantee durability after rename you must:<p>1) rename(a, b)<p>2) open(the parent dir)<p>3) fsync(the parent dir)<p>This is to guarantee durability of the <i>metadata</i> written by rename() in the dirent.<p>All of this is totally separate from guaranteeing the durability of the data in the file, which requires its own separate fsync() on the file itself.<p>Atomicity and durability are never the same. This article is gibberish.</div><br/><div id="38401821" class="c"><input type="checkbox" id="c-38401821" checked=""/><div class="controls bullet"><span class="by">dale_glass</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38400320">parent</a><span>|</span><a href="#38400886">next</a><span>|</span><label class="collapse" for="c-38401821">[-]</label><label class="expand" for="c-38401821">[1 more]</label></div><br/><div class="children"><div class="content">Okay, so why not create a single syscall to encompass all that? So that the developer can clearly say &quot;this is what I&#x27;m trying to achieve&quot;, and accomplish it simply, and reliably?<p>I think this would be a benefit, because first you don&#x27;t need userspace developers dig into the gory details of dirent metadata durability, and second because by making this explicit it helps put pressure on filesystem developers to optimize what the users actually want.</div><br/></div></div><div id="38400886" class="c"><input type="checkbox" id="c-38400886" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38400320">parent</a><span>|</span><a href="#38401821">prev</a><span>|</span><a href="#38397840">next</a><span>|</span><label class="collapse" for="c-38400886">[-]</label><label class="expand" for="c-38400886">[4 more]</label></div><br/><div class="children"><div class="content">The phrase &quot;atomic across crashes&quot; has a meaning that is distinct from durability.  It is also different from atomic across a live system.</div><br/><div id="38400927" class="c"><input type="checkbox" id="c-38400927" checked=""/><div class="controls bullet"><span class="by">throwaway09223</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38400886">parent</a><span>|</span><a href="#38397840">next</a><span>|</span><label class="collapse" for="c-38400927">[-]</label><label class="expand" for="c-38400927">[3 more]</label></div><br/><div class="children"><div class="content">The phrase &quot;atomic across crashes&quot; is meaningless. Atomicity deals with the running system state at the moment a system call executes. It has nothing to do with crashes (which are not atomic in and of themselves), or what bits actually end up on disk.</div><br/><div id="38400986" class="c"><input type="checkbox" id="c-38400986" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38400927">parent</a><span>|</span><a href="#38397840">next</a><span>|</span><label class="collapse" for="c-38400986">[-]</label><label class="expand" for="c-38400986">[2 more]</label></div><br/><div class="children"><div class="content">Are you being willfully obtuse, or do you honestly believe that the word &quot;atomicity&quot; only applies to such a narrow context?</div><br/><div id="38401007" class="c"><input type="checkbox" id="c-38401007" checked=""/><div class="controls bullet"><span class="by">throwaway09223</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38400986">parent</a><span>|</span><a href="#38397840">next</a><span>|</span><label class="collapse" for="c-38401007">[-]</label><label class="expand" for="c-38401007">[1 more]</label></div><br/><div class="children"><div class="content">The latter. What do you think it means?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38397840" class="c"><input type="checkbox" id="c-38397840" checked=""/><div class="controls bullet"><span class="by">Gibbon1</span><span>|</span><a href="#38397614">parent</a><span>|</span><a href="#38400320">prev</a><span>|</span><a href="#38400296">next</a><span>|</span><label class="collapse" for="c-38397840">[-]</label><label class="expand" for="c-38397840">[5 more]</label></div><br/><div class="children"><div class="content">I think that was the problem with how Linux implemented pselect() circa 10 years ago. I think pselect fixes the race condition you get when you set a timer then call select(). Linux&#x27;s implementation was a function that set a timer and then called select().  ... slam head on keyboard.<p>So I think that fear is valid that they&#x27;ll implement the API without the guarantees.<p>Myself I&#x27;m annoyed with the reckless push always to remove guarantees in return for &#x27;performance&#x27;.</div><br/><div id="38397902" class="c"><input type="checkbox" id="c-38397902" checked=""/><div class="controls bullet"><span class="by">leoc</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38397840">parent</a><span>|</span><a href="#38400296">next</a><span>|</span><label class="collapse" for="c-38397902">[-]</label><label class="expand" for="c-38397902">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m starting to come round to the belief that the only robust remedy is to release the chaos monkey: have the kernel delete all the state of the filesystem driver at randomly-chosen intervals, a few hours apart on average, and force the driver to recover itself.</div><br/><div id="38398098" class="c"><input type="checkbox" id="c-38398098" checked=""/><div class="controls bullet"><span class="by">bcrl</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38397902">parent</a><span>|</span><a href="#38400296">next</a><span>|</span><label class="collapse" for="c-38398098">[-]</label><label class="expand" for="c-38398098">[3 more]</label></div><br/><div class="children"><div class="content">That is pretty close to what those of us building robust storage systems in the real world have to do.  At a previous employer, we had test suites that exercised all kinds of corner cases by triggering failover and system reboots in the middle of heavy persistent messaging workloads.<p>Filesystems have other horrors that you learn about during testing.  I had one test case where it would take ext4 80 seconds to write out an 8MB file after a fresh mount of an 8TB filesystem.  Free space was fragmented in just the right way that we hit the single threaded reading of block groups and bitmaps in the kernel and it took <i>forever</i> to get that data off the disk array.</div><br/><div id="38398397" class="c"><input type="checkbox" id="c-38398397" checked=""/><div class="controls bullet"><span class="by">Gibbon1</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38398098">parent</a><span>|</span><a href="#38400296">next</a><span>|</span><label class="collapse" for="c-38398397">[-]</label><label class="expand" for="c-38398397">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done the same with embedded drivers, randomly flip bits in the drivers state and see what happens. Does it recover, throw fault, hang, or explode like a bomb. I got that from a hardware designer talking about robust state machines. Any random illegal state should sequence back to a known good state.</div><br/><div id="38400783" class="c"><input type="checkbox" id="c-38400783" checked=""/><div class="controls bullet"><span class="by">zbentley</span><span>|</span><a href="#38397614">root</a><span>|</span><a href="#38398397">parent</a><span>|</span><a href="#38400296">next</a><span>|</span><label class="collapse" for="c-38400783">[-]</label><label class="expand" for="c-38400783">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Any random illegal state should sequence back to a known good state.<p>What benefit does that property provide? Other than helping to deal with random memory corruption bit-flips, I&#x27;m having trouble understanding why state machines (in hardware, or any level of software) should ever be expected to handle arbitrary memory manipulation outside of the rules of the state machine.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38400296" class="c"><input type="checkbox" id="c-38400296" checked=""/><div class="controls bullet"><span class="by">throwaway09223</span><span>|</span><a href="#38397614">prev</a><span>|</span><a href="#38397461">next</a><span>|</span><label class="collapse" for="c-38400296">[-]</label><label class="expand" for="c-38400296">[14 more]</label></div><br/><div class="children"><div class="content">This article is just plain wrong. The author doesn&#x27;t seem to understand how filesystems work - specifically the difference between writing data and renaming directory entries. LWN should either issue a correction or take it down.<p>First: The author is confusing atomicity techniques with durability techniques. rename() isn&#x27;t at all relevant to durability. Never has been.<p>Second: Nothing about using rename() is relevant to what happens when pages are lost on crash. Using rename() or link() has no bearing on dirty writes. This whole section should just be deleted.<p>Third: When pages are lost, they&#x27;re not back-filled with random unallocated space (and if they were, see the second point above). Filesystems are designed to ensure these regions are zeroed out before the area can be used - either proactively or in fsck.<p>Finally, this quote: &quot;Which brings us to the present day fsync&#x2F;rename&#x2F;O_PONIES controversy, in which many file systems developers argue that applications should explicitly call fsync() before renaming a file if they want the file&#x27;s data to be on disk before the rename takes effect&quot;<p>There is no such controversy because rename() is utterly unrelated to the durability of data on a disk. This is a pure hallucination.<p>What a bizarre article.</div><br/><div id="38400401" class="c"><input type="checkbox" id="c-38400401" checked=""/><div class="controls bullet"><span class="by">throwaway09223</span><span>|</span><a href="#38400296">parent</a><span>|</span><a href="#38400574">next</a><span>|</span><label class="collapse" for="c-38400401">[-]</label><label class="expand" for="c-38400401">[6 more]</label></div><br/><div class="children"><div class="content">I read a bit more and figured out why the article was written. In 2009, ext4 (and ONLY ext4) adopted this behavior:<p><a href="https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;tytso&#x2F;ext4.git&#x2F;commit&#x2F;?id=dbc85aa9f11d8c13c15527d43a3def8d7beffdc8" rel="nofollow noreferrer">https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;tytso&#x2F;ext4.g...</a><p>I don&#x27;t think any other unix filesystems do this. It&#x27;s not posix, and it&#x27;s not behavior that any apps should be depending on if they care about their data.<p>I would suggest updating the LWN article to clarify that this is a piece specifically about ext4 -- not POSIX, or even Linux in general.</div><br/><div id="38400610" class="c"><input type="checkbox" id="c-38400610" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#38400296">root</a><span>|</span><a href="#38400401">parent</a><span>|</span><a href="#38400746">next</a><span>|</span><label class="collapse" for="c-38400610">[-]</label><label class="expand" for="c-38400610">[2 more]</label></div><br/><div class="children"><div class="content">What you say is correct, and ext4&#x27;s current default behaviour can be quite confusing:<p>* ext4 turns rename() into an invisible fsync(), if the target file existed.<p>* ext4 turns close() into an invisible fsync(), if the opened file existed.<p>This leads to surprising results:<p>If you unzip something the first time, it&#x27;s nice and fast.<p>If you unzip the same file again, force-overwriting existing files, suddenly it&#x27;s 10x slower. You now spend hours finding out why, and start cargo-culting vodoo that doing `rm` before makes it inexplicably fast again.<p>Invisible fsync()s that the application programmer cannot turn off are quite bad.<p>My speculation is that Ted Ts&#x27;o agrees with that in principle, but that he got tired of having to explain people that if they don&#x27;t fsync(), there are no guarantees; so he added this hack that makes 95% of the cases go away with surprising special-case behaviour.</div><br/><div id="38400613" class="c"><input type="checkbox" id="c-38400613" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#38400296">root</a><span>|</span><a href="#38400610">parent</a><span>|</span><a href="#38400746">next</a><span>|</span><label class="collapse" for="c-38400613">[-]</label><label class="expand" for="c-38400613">[1 more]</label></div><br/><div class="children"><div class="content">For people who want to read more about this in _up-to-date_ documentation:<p>* `auto_da_alloc` section of <a href="https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;admin-guide&#x2F;ext4.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;admin-guide&#x2F;ext4.html</a><p>* <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ext4#Delayed_allocation_and_potential_data_loss" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ext4#Delayed_allocation_and_po...</a></div><br/></div></div></div></div><div id="38400746" class="c"><input type="checkbox" id="c-38400746" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#38400296">root</a><span>|</span><a href="#38400401">parent</a><span>|</span><a href="#38400610">prev</a><span>|</span><a href="#38400847">next</a><span>|</span><label class="collapse" for="c-38400746">[-]</label><label class="expand" for="c-38400746">[2 more]</label></div><br/><div class="children"><div class="content">That’s not quite true.  There used to be a performance bug in ext3 that caused it to order the writes before the journal flush that created the files.<p>Then, gnome(?) and only gnome(?) relied on it, leading to massive filesystem corruption, so the kernel team gave up and made the old braindead behavior the default.<p>(The current default behavior is braindead because it makes rename extremely slow for correct programs that don’t care about durability across crashes, and therefore don’t call fsync).</div><br/><div id="38400852" class="c"><input type="checkbox" id="c-38400852" checked=""/><div class="controls bullet"><span class="by">throwaway09223</span><span>|</span><a href="#38400296">root</a><span>|</span><a href="#38400746">parent</a><span>|</span><a href="#38400847">next</a><span>|</span><label class="collapse" for="c-38400852">[-]</label><label class="expand" for="c-38400852">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, all filesystems are allowed to synchronize to disk as often as they want, in whatever way they want in &#x2F;addition&#x2F; to what&#x27;s specified. Filesystems can even make their own guarantees, above and beyond generalized specifications like fsync().<p>I could write a filesystem that synchronized files after every 42 megabytes, or once every 69 seconds. Apps might even come to depend on this behavior. All filesystems will have predictable, implementation dependent idiosyncrasies.<p>But these aren&#x27;t specified behaviors. They&#x27;re not part of an interface and they shouldn&#x27;t be depended on. The article implying that they ought to be is, I think, shortsighted. Other filesystems don&#x27;t do this and your code will break if you assume it.<p>I agree it&#x27;s braindead.</div><br/></div></div></div></div><div id="38400847" class="c"><input type="checkbox" id="c-38400847" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#38400296">root</a><span>|</span><a href="#38400401">parent</a><span>|</span><a href="#38400746">prev</a><span>|</span><a href="#38400574">next</a><span>|</span><label class="collapse" for="c-38400847">[-]</label><label class="expand" for="c-38400847">[1 more]</label></div><br/><div class="children"><div class="content">From the article:<p>&gt; However, the ordering effect of rename() turns out to be a file system specific implementation side effect. It only works when changes to the file data in the file system are ordered with respect to changes in the file system metadata. In ext3&#x2F;4 [...]<p>Seems pretty clear to me that this is talking about an ext3&#x2F;4 implementation detail that people have started to rely on...? I also pretty clearly remember that from back in 2009.<p>&gt; This article is just plain wrong.<p>Articles like this helped me understand the distinction between theoretical POSIX semantics and what Linux was actually doing at the time.<p>It seems like you are reading more into this article than at least I got out of it – maybe it&#x27;s because I still remember that 2009 controversy, but I wouldn&#x27;t have drawn any of the (incorrect, and I agree on that!) conclusions you&#x27;re listing above.</div><br/></div></div></div></div><div id="38400574" class="c"><input type="checkbox" id="c-38400574" checked=""/><div class="controls bullet"><span class="by">fao_</span><span>|</span><a href="#38400296">parent</a><span>|</span><a href="#38400401">prev</a><span>|</span><a href="#38397461">next</a><span>|</span><label class="collapse" for="c-38400574">[-]</label><label class="expand" for="c-38400574">[7 more]</label></div><br/><div class="children"><div class="content">&gt; The author doesn&#x27;t seem to understand how filesystems work<p>At the time of writing (2009) the author had 10 years of experience under Sun Microsystems, IBM, Intel, and Red Hat -- all working on filesystems. Including ZFS, ext2&#x2F;3, and ChunkFS. (It&#x27;s literally on her Wikipedia page)<p>So I&#x27;m more likely to regard her comments in high regard versus a driveby post written by a throwaway account.</div><br/><div id="38400607" class="c"><input type="checkbox" id="c-38400607" checked=""/><div class="controls bullet"><span class="by">throwaway09223</span><span>|</span><a href="#38400296">root</a><span>|</span><a href="#38400574">parent</a><span>|</span><a href="#38397461">next</a><span>|</span><label class="collapse" for="c-38400607">[-]</label><label class="expand" for="c-38400607">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s pretty common for people with some experience to not understand filesystem nuance - there&#x27;s quite a bit of it right here in the hn comment section. You&#x27;ll note below I also corrected someone significantly more credentialed than the author of this LWN post.<p>My suggestion to you: Worry less about measuring resumes and more about who is actually correct as a matter of demonstrable fact.<p>If you have actionable questions, ask them. Use facts, not appeals to (frankly not very substantial) authorities.</div><br/><div id="38400755" class="c"><input type="checkbox" id="c-38400755" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#38400296">root</a><span>|</span><a href="#38400607">parent</a><span>|</span><a href="#38397461">next</a><span>|</span><label class="collapse" for="c-38400755">[-]</label><label class="expand" for="c-38400755">[5 more]</label></div><br/><div class="children"><div class="content">The throwaway acccount is right.<p>In POSIX, file content data and metadata (directory entries) are separate. Atomicity and durability are separate.<p>It is likely that the LWN post author understands this very well, but omitted this important info from the article.<p>--<p>I can also understand throwaway&#x27;s criticism, e.g. on sections like this:<p>&gt; Given this situation, application developers came to rely on what is, on the face of it, a completely reasonable assumption: rename() of one file over another will either result in the contents of the old file, or the contents of the new file as of the time of the rename().<p>No. There is nothing reasonable about this. This is programming. When you&#x27;re programming against a spec (POSIX), you don&#x27;t &quot;make assumptions&quot;. You rely only on what it says in the spec.<p>It would be &quot;reasonable&quot; to wish that somebody creates spec that ensures the mentioned rename semantics. But assuming that a spec says something it doesn&#x27;t is wishful thinking.<p>People are quick to lazy it out, assume, copy-paste, etc, instead of critically thinking &quot;wait, does the code I write here really guarantee the desired effect, e.g. to write my file to disk&quot;.<p>Reject assumption-based programming. Go check. Read the docs.<p>That makes good programs.<p>Or, as the throwaway says, rely on &quot;demonstrable fact&quot;.</div><br/><div id="38400859" class="c"><input type="checkbox" id="c-38400859" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#38400296">root</a><span>|</span><a href="#38400755">parent</a><span>|</span><a href="#38400818">next</a><span>|</span><label class="collapse" for="c-38400859">[-]</label><label class="expand" for="c-38400859">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The throwaway acccount is right.<p>&gt; In POSIX, file content data and metadata (directory entries) are separate. Atomicity and durability are separate.<p>&gt; It is likely that the LWN post author understands this very well, but omitted this important info from the article.<p>1. If the author understands this, then the throwaway is wrong, since they claimed the author didn&#x27;t know this.<p>2. The entire point of TFA was that POSIX is underspecified here, so I think they covered it sufficiently; something that worked on FFS didn&#x27;t work on ext4, and the suggestion is that it should work going forwards, regardless of what POSIX requires.</div><br/><div id="38400952" class="c"><input type="checkbox" id="c-38400952" checked=""/><div class="controls bullet"><span class="by">throwaway09223</span><span>|</span><a href="#38400296">root</a><span>|</span><a href="#38400859">parent</a><span>|</span><a href="#38400818">next</a><span>|</span><label class="collapse" for="c-38400952">[-]</label><label class="expand" for="c-38400952">[1 more]</label></div><br/><div class="children"><div class="content">POSIX isn&#x27;t underspecified here. rename() has no durability guarantees. That&#x27;s the answer.<p>&quot;something that worked on FFS didn&#x27;t work on ext4,&quot;<p>As the article notes this is NOT durable on FFS. Early FFS (and early ext) could lose the entire filesystem after a crash. ext2 still can.<p>ext4 is the oddball here. TFA is not framing things correctly.</div><br/></div></div></div></div><div id="38400818" class="c"><input type="checkbox" id="c-38400818" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#38400296">root</a><span>|</span><a href="#38400755">parent</a><span>|</span><a href="#38400859">prev</a><span>|</span><a href="#38400890">next</a><span>|</span><label class="collapse" for="c-38400818">[-]</label><label class="expand" for="c-38400818">[1 more]</label></div><br/><div class="children"><div class="content">&gt; No. There is nothing reasonable about this. This is programming. When you&#x27;re programming against a spec (POSIX), you don&#x27;t &quot;make assumptions&quot;. You rely only on what it says in the spec.<p>Are you sure 100% of Linux application developers first and foremost think about POSIX, and never rely on an implementation-defined oddity to get the behavior they need?<p>Hyrum&#x27;s Law is powerful: &quot;With a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody.&quot;<p>&gt; People are quick to lazy it out, assume, copy-paste, etc, instead of critically thinking &quot;wait, does the code I write here really guarantee the desired effect, e.g. to write my file to disk&quot;.<p>Exactly. That is a fact of life that Linux kernel developers have to balance with POSIX.</div><br/></div></div><div id="38400890" class="c"><input type="checkbox" id="c-38400890" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#38400296">root</a><span>|</span><a href="#38400755">parent</a><span>|</span><a href="#38400818">prev</a><span>|</span><a href="#38397461">next</a><span>|</span><label class="collapse" for="c-38400890">[-]</label><label class="expand" for="c-38400890">[1 more]</label></div><br/><div class="children"><div class="content">&gt; When you&#x27;re programming against a spec (POSIX), you don&#x27;t &quot;make assumptions&quot;. You rely only on what it says in the spec.<p>I&#x27;ve been burned several times by relying on what it says in a spec, when the implementation turned out to behave slightly differently.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38397461" class="c"><input type="checkbox" id="c-38397461" checked=""/><div class="controls bullet"><span class="by">nolist_policy</span><span>|</span><a href="#38400296">prev</a><span>|</span><a href="#38397093">next</a><span>|</span><label class="collapse" for="c-38397461">[-]</label><label class="expand" for="c-38397461">[1 more]</label></div><br/><div class="children"><div class="content">By the way, Valerie has more great articles on lwn.net: <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Archives&#x2F;GuestIndex&#x2F;#Aurora_Henson_Valerie" rel="nofollow noreferrer">https:&#x2F;&#x2F;lwn.net&#x2F;Archives&#x2F;GuestIndex&#x2F;#Aurora_Henson_Valerie</a></div><br/></div></div><div id="38397093" class="c"><input type="checkbox" id="c-38397093" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#38397461">prev</a><span>|</span><a href="#38399275">next</a><span>|</span><label class="collapse" for="c-38397093">[-]</label><label class="expand" for="c-38397093">[2 more]</label></div><br/><div class="children"><div class="content">Would that more PM&#x27;s had had ponies as children: then they might understand that some shiny must-have features are the sort where (a) one occasionally has to call in expensive consultants, just to return them to the (b) steady state where they merely require constant feeding and cleaning-up-after.</div><br/><div id="38398085" class="c"><input type="checkbox" id="c-38398085" checked=""/><div class="controls bullet"><span class="by">h2odragon</span><span>|</span><a href="#38397093">parent</a><span>|</span><a href="#38399275">next</a><span>|</span><label class="collapse" for="c-38398085">[-]</label><label class="expand" for="c-38398085">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a narrow window of &quot;has ponies&quot; and &quot;has to care for the ponies&quot; that learns those lessons.</div><br/></div></div></div></div><div id="38399275" class="c"><input type="checkbox" id="c-38399275" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38397093">prev</a><span>|</span><a href="#38385319">next</a><span>|</span><label class="collapse" for="c-38399275">[-]</label><label class="expand" for="c-38399275">[3 more]</label></div><br/><div class="children"><div class="content">fsync doesn&#x27;t have to &quot;perform&quot;, because it doesn&#x27;t have to do anything. It just has to wait for some certain events to occur that will eventually occur anyway.<p>Now some people might not like how long it takes; maybe it&#x27;s waiting for some unnecessary events that are not relevant to this file.</div><br/><div id="38400839" class="c"><input type="checkbox" id="c-38400839" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#38399275">parent</a><span>|</span><a href="#38400735">next</a><span>|</span><label class="collapse" for="c-38400839">[-]</label><label class="expand" for="c-38400839">[1 more]</label></div><br/><div class="children"><div class="content">No. If you don&#x27;t call fsync(), there&#x27;s no guarantee that your data will _ever_ be written to disk.<p>Some file systems with some settings may write data to hardware after some delay or periodically, but others may not.<p>fsync() &quot;performs&quot; e.g. an ATA FLUSH command on the underlying hardware.</div><br/></div></div><div id="38400735" class="c"><input type="checkbox" id="c-38400735" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#38399275">parent</a><span>|</span><a href="#38400839">prev</a><span>|</span><a href="#38385319">next</a><span>|</span><label class="collapse" for="c-38400735">[-]</label><label class="expand" for="c-38400735">[1 more]</label></div><br/><div class="children"><div class="content">Surely fsync() should at least initiate syncing the data to the disk? Otherwise, everything FS-related could theoretically still fit in the memory cache forever, and so fsync() will never return.</div><br/></div></div></div></div></div></div></div></div></div></body></html>