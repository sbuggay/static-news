<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1686646858271" as="style"/><link rel="stylesheet" href="styles.css?v=1686646858271"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://justine.lol/sorting/">Understanding DeepMind&#x27;s sorting algorithm</a> <span class="domain">(<a href="https://justine.lol">justine.lol</a>)</span></div><div class="subtext"><span>jart</span> | <span>43 comments</span></div><br/><div><div id="36299335" class="c"><input type="checkbox" id="c-36299335" checked=""/><div class="controls bullet"><span class="by">mlochbaum</span><span>|</span><a href="#36303703">next</a><span>|</span><label class="collapse" for="c-36299335">[-]</label><label class="expand" for="c-36299335">[10 more]</label></div><br/><div class="children"><div class="content">Hang on, you can&#x27;t just quote MB&#x2F;s numbers for an O(n log(n)) sort. What length were these tests run at?<p>The code size might not end up quite as good (also requires malloc), but a branchless merge sort is a contender for a fast and lightweight sort. Just published, tiny-sort-rs[0] cites 632 bytes and looks like ~350MB&#x2F;s at 1e4 elements on Zen 3. In my tests, my own pisort[1] benches a little over twice as fast as LongSort, but it uses sorting networks as the base case so it&#x27;s like 5KB. It&#x27;s roughly based on piposort[2] which has more complicated recursion but a simpler base case.<p>400 MB&#x2F;s seems a bit slow for a radix sort on that hardware: I&#x27;m hitting those numbers on my i5-6200U, which has less than half the clock rate, with my own radix sort. Recommend checking ska_sort_copy from [3] as it has about the same performance.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;Voultapher&#x2F;tiny-sort-rs">https:&#x2F;&#x2F;github.com&#x2F;Voultapher&#x2F;tiny-sort-rs</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;mlochbaum&#x2F;SingeliSort&#x2F;blob&#x2F;master&#x2F;src&#x2F;merge.singeli#L136-L152">https:&#x2F;&#x2F;github.com&#x2F;mlochbaum&#x2F;SingeliSort&#x2F;blob&#x2F;master&#x2F;src&#x2F;mer...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;scandum&#x2F;piposort">https:&#x2F;&#x2F;github.com&#x2F;scandum&#x2F;piposort</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;skarupke&#x2F;ska_sort">https:&#x2F;&#x2F;github.com&#x2F;skarupke&#x2F;ska_sort</a></div><br/><div id="36299980" class="c"><input type="checkbox" id="c-36299980" checked=""/><div class="controls bullet"><span class="by">jstanley</span><span>|</span><a href="#36299335">parent</a><span>|</span><a href="#36303414">next</a><span>|</span><label class="collapse" for="c-36299980">[-]</label><label class="expand" for="c-36299980">[4 more]</label></div><br/><div class="children"><div class="content">&gt; What length were these tests run at?<p>The first example is &quot;assembly code they published for sorting an array with three items&quot; - this isn&#x27;t an entire general-purpose sorting algorithm, it&#x27;s just the innermost part.</div><br/><div id="36300311" class="c"><input type="checkbox" id="c-36300311" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#36299335">root</a><span>|</span><a href="#36299980">parent</a><span>|</span><a href="#36300036">next</a><span>|</span><label class="collapse" for="c-36300311">[-]</label><label class="expand" for="c-36300311">[2 more]</label></div><br/><div class="children"><div class="content">The alpha dev post claims 1.7% improvement on large sequences (250k+)</div><br/><div id="36302550" class="c"><input type="checkbox" id="c-36302550" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#36299335">root</a><span>|</span><a href="#36300311">parent</a><span>|</span><a href="#36300036">next</a><span>|</span><label class="collapse" for="c-36302550">[-]</label><label class="expand" for="c-36302550">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and as both posts say, that’s because large sequences are implemented by building up from small sequences :)</div><br/></div></div></div></div><div id="36300036" class="c"><input type="checkbox" id="c-36300036" checked=""/><div class="controls bullet"><span class="by">mlochbaum</span><span>|</span><a href="#36299335">root</a><span>|</span><a href="#36299980">parent</a><span>|</span><a href="#36300311">prev</a><span>|</span><a href="#36303414">next</a><span>|</span><label class="collapse" for="c-36300036">[-]</label><label class="expand" for="c-36300036">[1 more]</label></div><br/><div class="children"><div class="content">Second part of the article, starting at &quot;I thought it&#x27;d be useful to share something that&#x27;s actually portable and executable&quot;.</div><br/></div></div></div></div><div id="36303414" class="c"><input type="checkbox" id="c-36303414" checked=""/><div class="controls bullet"><span class="by">Paul-Craft</span><span>|</span><a href="#36299335">parent</a><span>|</span><a href="#36299980">prev</a><span>|</span><a href="#36299432">next</a><span>|</span><label class="collapse" for="c-36303414">[-]</label><label class="expand" for="c-36303414">[4 more]</label></div><br/><div class="children"><div class="content">&gt; ...632 bytes... 5KB...<p>How much does code size matter here?  As long as the code has a good access pattern that maintains cache locality, is there any fundamental difference between 632 bytes and 5KB?  L1 cache sizes are generally somewhere around 16-64 KB these days, so it seems like there wouldn&#x27;t be a big difference here.  Or am I just totally off base?</div><br/><div id="36304416" class="c"><input type="checkbox" id="c-36304416" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#36299335">root</a><span>|</span><a href="#36303414">parent</a><span>|</span><a href="#36303748">next</a><span>|</span><label class="collapse" for="c-36304416">[-]</label><label class="expand" for="c-36304416">[1 more]</label></div><br/><div class="children"><div class="content">&gt; L1 cache sizes are generally somewhere around 16-64 KB these days, so it seems like there wouldn&#x27;t be a big difference here.<p>Would you want to depend on a C library that claims all 64kb of your L1 cache for itself? Of course not. You&#x27;d want to use a library that stays out of the way, so that <i>your code</i> can be the one exploiting system resources.</div><br/></div></div><div id="36303748" class="c"><input type="checkbox" id="c-36303748" checked=""/><div class="controls bullet"><span class="by">mlochbaum</span><span>|</span><a href="#36299335">root</a><span>|</span><a href="#36303414">parent</a><span>|</span><a href="#36304416">prev</a><span>|</span><a href="#36303636">next</a><span>|</span><label class="collapse" for="c-36303748">[-]</label><label class="expand" for="c-36303748">[1 more]</label></div><br/><div class="children"><div class="content">longsort appears in cosmopolitan libc, and possibly gets embedded in all the output executables? For most applications the requirements are much less restrictive. I&#x27;m working on sorting for interpreted programming languages; I see &gt;20KB for each sort now and don&#x27;t have a problem with that. For small arrays only a fraction of the code will be used. I still make some effort to reduce size, but if you&#x27;re doing HPC work where sorting matters you can go much bigger with sorting networks for every size of something like that. icache is 32KB&#x2F;core on every processor I&#x27;ve checked, although it&#x27;s often reported weird. But it&#x27;s fine for a hybrid sort targetting large arrays to exceed that because many components like partitioning will spend their time running on lots of data, so the time to load is relatively insignificant.</div><br/></div></div><div id="36303636" class="c"><input type="checkbox" id="c-36303636" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#36299335">root</a><span>|</span><a href="#36303414">parent</a><span>|</span><a href="#36303748">prev</a><span>|</span><a href="#36299432">next</a><span>|</span><label class="collapse" for="c-36303636">[-]</label><label class="expand" for="c-36303636">[1 more]</label></div><br/><div class="children"><div class="content">I think the benefit is that when you start getting inlined code you can have multiple copies of it, so it can multiply out, and ideally you always want your code to be as small as possible so that you can have fewer instruction cache misses. So it&#x27;s unlikely to matter if you&#x27;re calling a single function in a loop whether the code is 632 bytes or 5KB (well, instruction decoding throughput aside I suppose), but when you&#x27;re looking more broadly it might matter.</div><br/></div></div></div></div><div id="36299432" class="c"><input type="checkbox" id="c-36299432" checked=""/><div class="controls bullet"><span class="by">mlochbaum</span><span>|</span><a href="#36299335">parent</a><span>|</span><a href="#36303414">prev</a><span>|</span><a href="#36303703">next</a><span>|</span><label class="collapse" for="c-36299432">[-]</label><label class="expand" for="c-36299432">[1 more]</label></div><br/><div class="children"><div class="content">Just realized that obviously you don&#x27;t need stability if you&#x27;re using in-place quicksort, so the tiny-sort heapsort is a better recommendation. 304 bytes, although the scaling to large arrays is much worse because of the awful access patterns.</div><br/></div></div></div></div><div id="36303703" class="c"><input type="checkbox" id="c-36303703" checked=""/><div class="controls bullet"><span class="by">Paul-Craft</span><span>|</span><a href="#36299335">prev</a><span>|</span><a href="#36304474">next</a><span>|</span><label class="collapse" for="c-36303703">[-]</label><label class="expand" for="c-36303703">[5 more]</label></div><br/><div class="children"><div class="content">&gt; DeepMind basically built an artificial intelligence that fiddles around with assembly code and deletes stuff at random to see if it breaks.<p>When it&#x27;s not done by &quot;artificial intelligence,&quot; we just call this &quot;mutation testing&quot;: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mutation_testing" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mutation_testing</a><p>&gt;  The above algorithm shows what the new and improved libcxx is doing. It&#x27;s basically quicksort except it switches to the sorting kernels and insertion sort when recursing into smaller slices.<p>This is a pretty standard technique, isn&#x27;t it?  You can eliminate hella recursive calls just by cutting off the bottom level of the call tree.  For instance, take the following (Emacs lisp) functions:<p><pre><code>    (defun fib1 (n)
      (if (or (= n 1) (= n 0))
          1
          (+ (fib1 (- n 1)) (fib1 (- n 2)))))

    (defun fib2 (n)
      (if (or (= n 1) (= n 0))
          1
      (if (= n 2)
          2
          (+ (fib2 (- n 1)) (fib2 (- n 2))))))

</code></pre>
Using the first function to calculate (fib 5) makes 29 recursive calls before finally terminating, while the second only 17.<p>With libcxx I think they even took the added step of schlepping in heapsort, which is kind of slow, but prevents adversaries from smashing your stack.</div><br/><div id="36305602" class="c"><input type="checkbox" id="c-36305602" checked=""/><div class="controls bullet"><span class="by">zodzedzi</span><span>|</span><a href="#36303703">parent</a><span>|</span><a href="#36304474">next</a><span>|</span><label class="collapse" for="c-36305602">[-]</label><label class="expand" for="c-36305602">[4 more]</label></div><br/><div class="children"><div class="content">&gt; ... heapsort, which is kind of slow, but prevents adversaries from smashing your stack.<p>How does heapsort protect against a stack attack?</div><br/><div id="36306105" class="c"><input type="checkbox" id="c-36306105" checked=""/><div class="controls bullet"><span class="by">Paul-Craft</span><span>|</span><a href="#36303703">root</a><span>|</span><a href="#36305602">parent</a><span>|</span><a href="#36305815">next</a><span>|</span><label class="collapse" for="c-36306105">[-]</label><label class="expand" for="c-36306105">[1 more]</label></div><br/><div class="children"><div class="content">Oh, yeah.  I forgot to quote that, because I was going to comment on it.  It&#x27;s an iterative, in-place algorithm, so there are no recursive calls to be made.<p>The bit I meant to comment on was the &quot;kind of slow&quot; part.  It is true that heapsort tends to be slower than a well-implemented quicksort, but you don&#x27;t use heapsort when you need the absolute best speed.  The (IMO) best thing about heapsort is that its best case and worst case are the same order of magnitude, so sorting n things will take a fairly consistent amount of time, no matter what.</div><br/></div></div><div id="36305815" class="c"><input type="checkbox" id="c-36305815" checked=""/><div class="controls bullet"><span class="by">ReaLNero</span><span>|</span><a href="#36303703">root</a><span>|</span><a href="#36305602">parent</a><span>|</span><a href="#36306105">prev</a><span>|</span><a href="#36304474">next</a><span>|</span><label class="collapse" for="c-36305815">[-]</label><label class="expand" for="c-36305815">[2 more]</label></div><br/><div class="children"><div class="content">Heap sort can sort n elements with O(1) auxiliary data while quick sort (which is what libcxx usually relies on) in its worst-case performance would require storing O(n) stack frames. Since stack sizes are usually small, an adversary making you sort a million elements would likely cause a stack overflow.</div><br/><div id="36306866" class="c"><input type="checkbox" id="c-36306866" checked=""/><div class="controls bullet"><span class="by">Paul-Craft</span><span>|</span><a href="#36303703">root</a><span>|</span><a href="#36305815">parent</a><span>|</span><a href="#36304474">next</a><span>|</span><label class="collapse" for="c-36306866">[-]</label><label class="expand" for="c-36306866">[1 more]</label></div><br/><div class="children"><div class="content">Quicksort can be implemented iteratively, with O(1) auxiliary storage, as well: <a href="https:&#x2F;&#x2F;alienryderflex.com&#x2F;quicksort&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;alienryderflex.com&#x2F;quicksort&#x2F;</a></div><br/></div></div></div></div></div></div></div></div><div id="36304474" class="c"><input type="checkbox" id="c-36304474" checked=""/><div class="controls bullet"><span class="by">anonymousiam</span><span>|</span><a href="#36303703">prev</a><span>|</span><a href="#36299982">next</a><span>|</span><label class="collapse" for="c-36304474">[-]</label><label class="expand" for="c-36304474">[2 more]</label></div><br/><div class="children"><div class="content">Just an aside, but I noticed when I was reading this that Justine&#x27;s C coding style resembles my preference, and it reminded me of why I like to code this way.  I learned Pascal before C and Pascal required that you define all methods before they are used.  (This is a restriction that ANSI C and C++ worked around with function prototypes.)  You can still code C without prototypes if you completely define all functions in the same file, before they are called.  IMHO, code without forward references and&#x2F;or function prototypes is inherently easier to read, but unfortunately it&#x27;s not always possible to produce.</div><br/><div id="36304612" class="c"><input type="checkbox" id="c-36304612" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#36304474">parent</a><span>|</span><a href="#36299982">next</a><span>|</span><label class="collapse" for="c-36304612">[-]</label><label class="expand" for="c-36304612">[1 more]</label></div><br/><div class="children"><div class="content">I learned Pascal before C too :-)</div><br/></div></div></div></div><div id="36299982" class="c"><input type="checkbox" id="c-36299982" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#36304474">prev</a><span>|</span><a href="#36305538">next</a><span>|</span><label class="collapse" for="c-36299982">[-]</label><label class="expand" for="c-36299982">[1 more]</label></div><br/><div class="children"><div class="content">Is it strange that it&#x27;s slower in jart&#x27;s testing but claimed to be faster in the AlphaDev blog post?<p>jart doesn&#x27;t provide detail about length of sequences used in testing, and AlphaDev basically says that between 6 and 249,999 elements the optimizations are slower (they only claim improvement for very small and 250k+ element sequences).<p>The AlphaDev numbers are so curious as well. AFAICT there&#x27;s extra branching when you splice the tiny-sequence optimized versions (slower), but better sorting for the tiny sequences (faster).<p>Is it, like, branch prediction gets an edge when the leaf nodes of the recursion are all sorting tiny sequences? In jart&#x27;s code, it&#x27;s DFS, which I can only guess would trample a bit on branch prediction. I wonder if a BFS search could be better<p>No idea what would cause this though, curious if anyone has other ideas, I really don&#x27;t know.</div><br/></div></div><div id="36305538" class="c"><input type="checkbox" id="c-36305538" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#36299982">prev</a><span>|</span><a href="#36306005">next</a><span>|</span><label class="collapse" for="c-36305538">[-]</label><label class="expand" for="c-36305538">[1 more]</label></div><br/><div class="children"><div class="content">This is all making headlines by making one implementation 1% faster by removing one copy.<p>Meanwhile I can just make sort 10 times faster with vectorization.</div><br/></div></div><div id="36306005" class="c"><input type="checkbox" id="c-36306005" checked=""/><div class="controls bullet"><span class="by">yuz</span><span>|</span><a href="#36305538">prev</a><span>|</span><a href="#36301182">next</a><span>|</span><label class="collapse" for="c-36306005">[-]</label><label class="expand" for="c-36306005">[2 more]</label></div><br/><div class="children"><div class="content">How do compilers detect the need to replace high-level code with a hard-coded three-number sorting algorithm? As someone not deeply familiar with compiler internals, I&#x27;m eager to understand the underlying mechanisms. Could anyone shed light on how modern compilers recognize situations where it&#x27;s beneficial to replace generic code with optimized assembly instructions specifically designed for sorting three numbers?</div><br/><div id="36307159" class="c"><input type="checkbox" id="c-36307159" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#36306005">parent</a><span>|</span><a href="#36301182">next</a><span>|</span><label class="collapse" for="c-36307159">[-]</label><label class="expand" for="c-36307159">[1 more]</label></div><br/><div class="children"><div class="content">They don&#x27;t</div><br/></div></div></div></div><div id="36301182" class="c"><input type="checkbox" id="c-36301182" checked=""/><div class="controls bullet"><span class="by">cammil</span><span>|</span><a href="#36306005">prev</a><span>|</span><a href="#36301802">next</a><span>|</span><label class="collapse" for="c-36301182">[-]</label><label class="expand" for="c-36301182">[2 more]</label></div><br/><div class="children"><div class="content">Why is sorting not done by specialised hardware? Or is it already?</div><br/><div id="36301257" class="c"><input type="checkbox" id="c-36301257" checked=""/><div class="controls bullet"><span class="by">bmc7505</span><span>|</span><a href="#36301182">parent</a><span>|</span><a href="#36301802">next</a><span>|</span><label class="collapse" for="c-36301257">[-]</label><label class="expand" for="c-36301257">[1 more]</label></div><br/><div class="children"><div class="content">It can be done for fixed-length lists. Optimal sorting networks [1] are an active research topic with many interesting connections to differentiable sorting and ranking [2].<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sorting_network#Optimal_sorting_networks" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sorting_network#Optimal_sortin...</a><p>[2]: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2105.04019" rel="nofollow noreferrer">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2105.04019</a></div><br/></div></div></div></div><div id="36301802" class="c"><input type="checkbox" id="c-36301802" checked=""/><div class="controls bullet"><span class="by">CalChris</span><span>|</span><a href="#36301182">prev</a><span>|</span><a href="#36301451">next</a><span>|</span><label class="collapse" for="c-36301802">[-]</label><label class="expand" for="c-36301802">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  mov %rdx,%rcx
</code></pre>
Wouldn&#x27;t this <i>mov</i> instruction be handled by the register renamer (Allocate&#x2F;Rename&#x2F;MoveElimination&#x2F;ZeroIdiom) at essentially &#x27;zero&#x27; cost? Yet clearly they&#x27;re measuring a difference. I&#x27;ll be curious what Agner Fog and Peter Cordes think.<p>Answer: renaming can fail if the operands aren&#x27;t ready and it isn&#x27;t zero cost, just less.</div><br/><div id="36302617" class="c"><input type="checkbox" id="c-36302617" checked=""/><div class="controls bullet"><span class="by">dundarious</span><span>|</span><a href="#36301802">parent</a><span>|</span><a href="#36301451">next</a><span>|</span><label class="collapse" for="c-36302617">[-]</label><label class="expand" for="c-36302617">[1 more]</label></div><br/><div class="children"><div class="content">Just having to go through the hardware frontend is a cost. It&#x27;s one of the reasons SIMD is fast: you go through the frontend 1 time for N lanes of data.</div><br/></div></div></div></div><div id="36301451" class="c"><input type="checkbox" id="c-36301451" checked=""/><div class="controls bullet"><span class="by">fred256</span><span>|</span><a href="#36301802">prev</a><span>|</span><a href="#36300663">next</a><span>|</span><label class="collapse" for="c-36301451">[-]</label><label class="expand" for="c-36301451">[2 more]</label></div><br/><div class="children"><div class="content">This reminds me of challenge 28 from the game Human Resource Machine.</div><br/><div id="36307489" class="c"><input type="checkbox" id="c-36307489" checked=""/><div class="controls bullet"><span class="by">minitoar</span><span>|</span><a href="#36301451">parent</a><span>|</span><a href="#36300663">next</a><span>|</span><label class="collapse" for="c-36307489">[-]</label><label class="expand" for="c-36307489">[1 more]</label></div><br/><div class="children"><div class="content">Loved that game.</div><br/></div></div></div></div><div id="36300663" class="c"><input type="checkbox" id="c-36300663" checked=""/><div class="controls bullet"><span class="by">tabtab</span><span>|</span><a href="#36301451">prev</a><span>|</span><a href="#36300103">next</a><span>|</span><label class="collapse" for="c-36300663">[-]</label><label class="expand" for="c-36300663">[1 more]</label></div><br/><div class="children"><div class="content">Several years ago I read about using genetic algorithms to &quot;evolve&quot; better mini-sorts. I wonder how the two compare.</div><br/></div></div><div id="36300197" class="c"><input type="checkbox" id="c-36300197" checked=""/><div class="controls bullet"><span class="by">smodad</span><span>|</span><a href="#36300103">prev</a><span>|</span><a href="#36304077">next</a><span>|</span><label class="collapse" for="c-36300197">[-]</label><label class="expand" for="c-36300197">[11 more]</label></div><br/><div class="children"><div class="content">I just realized that Justine was the person responsible for the massive reduction in the memory footprint of the Llama models back in March.[1] Super impressive! These are my favorite kinds of blog posts.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;ggerganov&#x2F;llama.cpp&#x2F;pull&#x2F;613">https:&#x2F;&#x2F;github.com&#x2F;ggerganov&#x2F;llama.cpp&#x2F;pull&#x2F;613</a></div><br/><div id="36300383" class="c"><input type="checkbox" id="c-36300383" checked=""/><div class="controls bullet"><span class="by">gajnadsgjoas</span><span>|</span><a href="#36300197">parent</a><span>|</span><a href="#36300675">next</a><span>|</span><label class="collapse" for="c-36300383">[-]</label><label class="expand" for="c-36300383">[6 more]</label></div><br/><div class="children"><div class="content">You wanted to say the one was banned by the author because of all the drama that followed</div><br/><div id="36301707" class="c"><input type="checkbox" id="c-36301707" checked=""/><div class="controls bullet"><span class="by">jimsimmons</span><span>|</span><a href="#36300197">root</a><span>|</span><a href="#36300383">parent</a><span>|</span><a href="#36300675">next</a><span>|</span><label class="collapse" for="c-36301707">[-]</label><label class="expand" for="c-36301707">[5 more]</label></div><br/><div class="children"><div class="content">What drama. Ooc</div><br/><div id="36302113" class="c"><input type="checkbox" id="c-36302113" checked=""/><div class="controls bullet"><span class="by">pcj-github</span><span>|</span><a href="#36300197">root</a><span>|</span><a href="#36301707">parent</a><span>|</span><a href="#36300675">next</a><span>|</span><label class="collapse" for="c-36302113">[-]</label><label class="expand" for="c-36302113">[4 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;github-drama&#x2F;github-drama&#x2F;pull&#x2F;46">https:&#x2F;&#x2F;github.com&#x2F;github-drama&#x2F;github-drama&#x2F;pull&#x2F;46</a></div><br/><div id="36302778" class="c"><input type="checkbox" id="c-36302778" checked=""/><div class="controls bullet"><span class="by">skeaker</span><span>|</span><a href="#36300197">root</a><span>|</span><a href="#36302113">parent</a><span>|</span><a href="#36300675">next</a><span>|</span><label class="collapse" for="c-36302778">[-]</label><label class="expand" for="c-36302778">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand this. What&#x27;s the contention that&#x27;s actually getting people upset here?</div><br/><div id="36302958" class="c"><input type="checkbox" id="c-36302958" checked=""/><div class="controls bullet"><span class="by">nl</span><span>|</span><a href="#36300197">root</a><span>|</span><a href="#36302778">parent</a><span>|</span><a href="#36300675">next</a><span>|</span><label class="collapse" for="c-36302958">[-]</label><label class="expand" for="c-36302958">[2 more]</label></div><br/><div class="children"><div class="content">Having read through a bunch of outraged comments the issue seems to have been:<p><pre><code>  * It changed the file format
  * For some people it was slower that the original version particularly on low end computers
</code></pre>
One person was particularly outraged and reverted the whole change.<p>However, the current version does use a similar approach to that which was proposed: <a href="https:&#x2F;&#x2F;github.com&#x2F;ggerganov&#x2F;llama.cpp&#x2F;commit&#x2F;f963b63afa0e057cfb9eba4d88407c6a0850a0d8">https:&#x2F;&#x2F;github.com&#x2F;ggerganov&#x2F;llama.cpp&#x2F;commit&#x2F;f963b63afa0e05...</a></div><br/><div id="36306774" class="c"><input type="checkbox" id="c-36306774" checked=""/><div class="controls bullet"><span class="by">nicman23</span><span>|</span><a href="#36300197">root</a><span>|</span><a href="#36302958">parent</a><span>|</span><a href="#36300675">next</a><span>|</span><label class="collapse" for="c-36306774">[-]</label><label class="expand" for="c-36306774">[1 more]</label></div><br/><div class="children"><div class="content">Lol why oss people are so antisocial - I include myself in the subset</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36300675" class="c"><input type="checkbox" id="c-36300675" checked=""/><div class="controls bullet"><span class="by">m00x</span><span>|</span><a href="#36300197">parent</a><span>|</span><a href="#36300383">prev</a><span>|</span><a href="#36303984">next</a><span>|</span><label class="collapse" for="c-36300675">[-]</label><label class="expand" for="c-36300675">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s just using mmap, nothing too impressive. It&#x27;s a nice contribution nonetheless.</div><br/><div id="36303989" class="c"><input type="checkbox" id="c-36303989" checked=""/><div class="controls bullet"><span class="by">dundarious</span><span>|</span><a href="#36300197">root</a><span>|</span><a href="#36300675">parent</a><span>|</span><a href="#36303984">next</a><span>|</span><label class="collapse" for="c-36303989">[-]</label><label class="expand" for="c-36303989">[1 more]</label></div><br/><div class="children"><div class="content">There was more. You can&#x27;t just splat giant C structs with pointers into shared memory&#x2F;a file, and expect another process to just mmap and be able to recreate valid state again. At the very least the pointers are going to be all wrong. There was necessary work to adjust the file format. Not rocket science, but not just turning while(fread()) into open();mmap().<p>Also, there were insights into how to minimize which models needed adjustment. The ideas and code were worked on by at least 2 people, and I&#x27;m an outsider on that project, but I didn&#x27;t see anything untoward like &quot;stealing credit&quot;. The magic change wasn&#x27;t a perfect move, but is the kind of thing I do locally when I don&#x27;t know the project&#x2F;binary format well yet, so not exactly the megalomaniacal move it was painted as. Better that only the version number changed, but she&#x27;s independent and doing good work, so you&#x27;d kind of <i>hope</i> she has a self-promotion streak! Changing the magic would be on the very very low end of letting that side go a bit too far, <i>assuming</i> that was the impetus.</div><br/></div></div></div></div><div id="36303984" class="c"><input type="checkbox" id="c-36303984" checked=""/><div class="controls bullet"><span class="by">CaptainNegative</span><span>|</span><a href="#36300197">parent</a><span>|</span><a href="#36300675">prev</a><span>|</span><a href="#36304077">next</a><span>|</span><label class="collapse" for="c-36303984">[-]</label><label class="expand" for="c-36303984">[2 more]</label></div><br/><div class="children"><div class="content">Why is it Justine posts and seemingly only Justine posts that always get this type of comments? Do people regularly comment on the authors of other content, for better or for worse, and I miss it?</div><br/><div id="36305314" class="c"><input type="checkbox" id="c-36305314" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#36300197">root</a><span>|</span><a href="#36303984">parent</a><span>|</span><a href="#36304077">next</a><span>|</span><label class="collapse" for="c-36305314">[-]</label><label class="expand" for="c-36305314">[1 more]</label></div><br/><div class="children"><div class="content">Faster Than Lime, too.</div><br/></div></div></div></div></div></div><div id="36304077" class="c"><input type="checkbox" id="c-36304077" checked=""/><div class="controls bullet"><span class="by">ma2rten</span><span>|</span><a href="#36300197">prev</a><span>|</span><label class="collapse" for="c-36304077">[-]</label><label class="expand" for="c-36304077">[2 more]</label></div><br/><div class="children"><div class="content">Someone just asked GPT-4 and got the same result as DeepMind did:<p><a href="https:&#x2F;&#x2F;twitter.com&#x2F;DimitrisPapail&#x2F;status&#x2F;1666843952824168465" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;DimitrisPapail&#x2F;status&#x2F;166684395282416846...</a></div><br/><div id="36304620" class="c"><input type="checkbox" id="c-36304620" checked=""/><div class="controls bullet"><span class="by">optimalsolver</span><span>|</span><a href="#36304077">parent</a><span>|</span><label class="collapse" for="c-36304620">[-]</label><label class="expand" for="c-36304620">[1 more]</label></div><br/><div class="children"><div class="content">He practically tells it the solution. Very leading prompt.</div><br/></div></div></div></div></div></div></div></div></div></body></html>