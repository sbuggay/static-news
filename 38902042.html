<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704790865241" as="style"/><link rel="stylesheet" href="styles.css?v=1704790865241"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/quickwit-oss/quickwit">Show HN: Quickwit – OSS Alternative to Elasticsearch, Splunk, Datadog</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>francoismassot</span> | <span>35 comments</span></div><br/><div><div id="38923654" class="c"><input type="checkbox" id="c-38923654" checked=""/><div class="controls bullet"><span class="by">sidcool</span><span>|</span><a href="#38922545">next</a><span>|</span><label class="collapse" for="c-38923654">[-]</label><label class="expand" for="c-38923654">[2 more]</label></div><br/><div class="children"><div class="content">When open source providers say  &#x27;alternative&#x27; to a commercial solution, do they consider the serious engineering needed to scale such systems?  I mean I used SigNoz, and it&#x27;s comparable to Datadog feature wise but nowhere close in performance and scalability.</div><br/><div id="38923798" class="c"><input type="checkbox" id="c-38923798" checked=""/><div class="controls bullet"><span class="by">francoismassot</span><span>|</span><a href="#38923654">parent</a><span>|</span><a href="#38922545">next</a><span>|</span><label class="collapse" for="c-38923798">[-]</label><label class="expand" for="c-38923798">[1 more]</label></div><br/><div class="children"><div class="content">I must admit that &#x27;alternative&#x27; is always a tricky word... Datadog, Elasticsearch, and Splunk are giant beasts, and the alternative makes sense only on a subset of features (and hopefully, we will successfully execute our 2024 roadmap to reduce the difference)<p>For Quickwit, our users proved to us it was scaling up to petabytes. So we consider this scale factor in the &quot;alternative&quot;. But... we don&#x27;t have a dedicated metrics storage engine yet, so if you want to store metrics in Quickwit, it won&#x27;t be efficient in the current version. It will come later this year.</div><br/></div></div></div></div><div id="38922545" class="c"><input type="checkbox" id="c-38922545" checked=""/><div class="controls bullet"><span class="by">dikei</span><span>|</span><a href="#38923654">prev</a><span>|</span><a href="#38922954">next</a><span>|</span><label class="collapse" for="c-38922545">[-]</label><label class="expand" for="c-38922545">[2 more]</label></div><br/><div class="children"><div class="content">&gt; To give you a concrete example, one company is ingesting hundreds of terabytes of logs daily and migrating from Elasticsearch to Quickwit. They divided their compute costs by 5x and storage costs by 2x while increasing retention from 3 to 30 days<p>I guess that&#x27;s to be expected. Almost anything is more storage-efficient than Elasticsearch, FTS is so expensive.</div><br/><div id="38923182" class="c"><input type="checkbox" id="c-38923182" checked=""/><div class="controls bullet"><span class="by">fulmicoton</span><span>|</span><a href="#38922545">parent</a><span>|</span><a href="#38922954">next</a><span>|</span><label class="collapse" for="c-38923182">[-]</label><label class="expand" for="c-38923182">[1 more]</label></div><br/><div class="children"><div class="content">Quickwit is FTS too though. I think the difference comes from the fact they stored stuff on EBS while Quickwit stores its index on S3.</div><br/></div></div></div></div><div id="38922954" class="c"><input type="checkbox" id="c-38922954" checked=""/><div class="controls bullet"><span class="by">marsupialtail_2</span><span>|</span><a href="#38922545">prev</a><span>|</span><a href="#38922726">next</a><span>|</span><label class="collapse" for="c-38922954">[-]</label><label class="expand" for="c-38922954">[2 more]</label></div><br/><div class="children"><div class="content">Glad this is getting some love. This is seriously good software. Have you guys supported generic substring search yet? I recall it was not supported as of a few months ago.</div><br/><div id="38923732" class="c"><input type="checkbox" id="c-38923732" checked=""/><div class="controls bullet"><span class="by">fulmicoton</span><span>|</span><a href="#38922954">parent</a><span>|</span><a href="#38922726">next</a><span>|</span><label class="collapse" for="c-38923732">[-]</label><label class="expand" for="c-38923732">[1 more]</label></div><br/><div class="children"><div class="content">Not yet. Only prefixes.
Also you could probably cook something with an ngram tokenizer.<p>Is it for a field with a high cardinality?
If you tell us more about your use case, maybe we can find a workaround.</div><br/></div></div></div></div><div id="38922726" class="c"><input type="checkbox" id="c-38922726" checked=""/><div class="controls bullet"><span class="by">jjtang1</span><span>|</span><a href="#38922954">prev</a><span>|</span><a href="#38923628">next</a><span>|</span><label class="collapse" for="c-38922726">[-]</label><label class="expand" for="c-38922726">[1 more]</label></div><br/><div class="children"><div class="content">Congrats on the launch, we&#x27;ll have to get you integrated with Rootly :). We can enable incident responders to fetch metrics while they respond to incidents in Slack!</div><br/></div></div><div id="38923628" class="c"><input type="checkbox" id="c-38923628" checked=""/><div class="controls bullet"><span class="by">wiradikusuma</span><span>|</span><a href="#38922726">prev</a><span>|</span><a href="#38921801">next</a><span>|</span><label class="collapse" for="c-38923628">[-]</label><label class="expand" for="c-38923628">[2 more]</label></div><br/><div class="children"><div class="content">How is it compared to Signoz, which is also open source?</div><br/><div id="38923747" class="c"><input type="checkbox" id="c-38923747" checked=""/><div class="controls bullet"><span class="by">jakozaur</span><span>|</span><a href="#38923628">parent</a><span>|</span><a href="#38921801">next</a><span>|</span><label class="collapse" for="c-38923747">[-]</label><label class="expand" for="c-38923747">[1 more]</label></div><br/><div class="children"><div class="content">I know that SigNoz uses Clickhouse and focuses more on observability UX.<p>Quickwit is its own data engine.</div><br/></div></div></div></div><div id="38921801" class="c"><input type="checkbox" id="c-38921801" checked=""/><div class="controls bullet"><span class="by">figmert</span><span>|</span><a href="#38923628">prev</a><span>|</span><a href="#38905110">next</a><span>|</span><label class="collapse" for="c-38921801">[-]</label><label class="expand" for="c-38921801">[4 more]</label></div><br/><div class="children"><div class="content">Looking at the docker compose, this seems like a very complicated tool to run.<p>You&#x27;d need Kafka, zookeeper, and Jaeger. All would need to be HA. Then also this service. Not mentioning postgres because in theory you can use aurora or the like.<p>How quick have your current customers been able to get up and running so far? And how much maintainence have they needed?</div><br/><div id="38923388" class="c"><input type="checkbox" id="c-38923388" checked=""/><div class="controls bullet"><span class="by">fulmicoton</span><span>|</span><a href="#38921801">parent</a><span>|</span><a href="#38923401">next</a><span>|</span><label class="collapse" for="c-38923388">[-]</label><label class="expand" for="c-38923388">[1 more]</label></div><br/><div class="children"><div class="content">Most users do not use Kafka&#x2F;Zookeeper.
The only external service for them is a S3 bucket. They then use the PushAPI.
It is perfectly fine if you have only a couple of TB a day.<p>For the crazy large use cases, like the one described in the blog post,
Kafka becomes necessary. At that scale, our users usually already have their data in Kafka or RedPanda and are actually happy to be able to get native integration:
- their data does not need to be copied&#x2F;replicated in a WAL &quot;again&quot;
- we get exactly-once semantics<p>Also, in 0.8, we will be adding proper support for distributed ingest.
The feature is actually already implemented and was originally scheduled for 0.7.
but we preferred to test it more before actually shipping it.</div><br/></div></div><div id="38923401" class="c"><input type="checkbox" id="c-38923401" checked=""/><div class="controls bullet"><span class="by">francoismassot</span><span>|</span><a href="#38921801">parent</a><span>|</span><a href="#38923388">prev</a><span>|</span><a href="#38923367">next</a><span>|</span><label class="collapse" for="c-38923401">[-]</label><label class="expand" for="c-38923401">[1 more]</label></div><br/><div class="children"><div class="content">Quickwit supports different data sources: Kafka, Pulsar, Google pubsub, ... and we have our own ingest API (not HA right now, but it will be the case in the next release in 1 month or so).<p>Postgresql is not mandatory; it&#x27;s also possible to use Quickwit with a metastore on S3. For large use cases, Postgresql is the way to go. I&#x27;ve seen users using Quickwit with metastore on S3, RDS, and Aurora.<p>On the UI side, we have several users who have their own UI. Jaeger is used just for the UI part so it&#x27;s quite simple to have it in HA, I don&#x27;t thing it&#x27;s hard to have HA for Grafana but I&#x27;m not sure on this point.<p>Which docker compose did you look at?</div><br/></div></div><div id="38923367" class="c"><input type="checkbox" id="c-38923367" checked=""/><div class="controls bullet"><span class="by">PaoloBarbolini</span><span>|</span><a href="#38921801">parent</a><span>|</span><a href="#38923401">prev</a><span>|</span><a href="#38905110">next</a><span>|</span><label class="collapse" for="c-38923367">[-]</label><label class="expand" for="c-38923367">[1 more]</label></div><br/><div class="children"><div class="content">According to the documentation[1] Kafka is just one of the supported inputs for ingestion, so it should be possible to run Quickwit without it if you&#x27;re not intending to write logs into Kafka. Jaeger also seems like another optional dependency. Same also probably for Zookeeper?<p>1: <a href="https:&#x2F;&#x2F;quickwit.io&#x2F;docs&#x2F;ingest-data&#x2F;kafka" rel="nofollow">https:&#x2F;&#x2F;quickwit.io&#x2F;docs&#x2F;ingest-data&#x2F;kafka</a></div><br/></div></div></div></div><div id="38905110" class="c"><input type="checkbox" id="c-38905110" checked=""/><div class="controls bullet"><span class="by">BrandoElFollito</span><span>|</span><a href="#38921801">prev</a><span>|</span><a href="#38921634">next</a><span>|</span><label class="collapse" for="c-38905110">[-]</label><label class="expand" for="c-38905110">[2 more]</label></div><br/><div class="children"><div class="content">What I am really missing in these (really nice) alternatives to ELK is Kibana and its Lens.<p>I tried to tapping this with Grafana but never learned to have graphs as easily as with Kibana. Maybe I was not trying hard enough?<p>Has anyone replaced Kibana with Grafana for non time based graphs?</div><br/><div id="38905212" class="c"><input type="checkbox" id="c-38905212" checked=""/><div class="controls bullet"><span class="by">francoismassot</span><span>|</span><a href="#38905110">parent</a><span>|</span><a href="#38921634">next</a><span>|</span><label class="collapse" for="c-38905212">[-]</label><label class="expand" for="c-38905212">[1 more]</label></div><br/><div class="children"><div class="content">Good point. Several users are asking us the OpenDashboard&#x2F;Kibana compatibility, and this is on the 2024 roadmap.<p>That being said, we also hear users complaining about OpenDashboard&#x2F;Kibana, looking for an alternative different from Kibana&#x2F;Grafana explore view (the view used for log and tracing search). You will also find users satisfied by the Grafana Explore view.<p>Personally, I don&#x27;t find the Grafana Explore view great for log searches. I saw that Grafana recently made some improvements, and I need to dig into that to adapt the Quickwit Grafana plugin. I don&#x27;t have a clear opinion on Kibana, one of my dreams is to build a better UI for log&#x2F;traces search anyway, not yet on the roadmap though :)</div><br/></div></div></div></div><div id="38921634" class="c"><input type="checkbox" id="c-38921634" checked=""/><div class="controls bullet"><span class="by">evanjrowley</span><span>|</span><a href="#38905110">prev</a><span>|</span><a href="#38902524">next</a><span>|</span><label class="collapse" for="c-38921634">[-]</label><label class="expand" for="c-38921634">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised no one has mentioned that it&#x27;s mostly programmed in Rust.</div><br/><div id="38921989" class="c"><input type="checkbox" id="c-38921989" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#38921634">parent</a><span>|</span><a href="#38922648">next</a><span>|</span><label class="collapse" for="c-38921989">[-]</label><label class="expand" for="c-38921989">[1 more]</label></div><br/><div class="children"><div class="content">Next time don&#x27;t mention it and we&#x27;ll enjoy the peace and quiet :)</div><br/></div></div><div id="38922648" class="c"><input type="checkbox" id="c-38922648" checked=""/><div class="controls bullet"><span class="by">laserbeam</span><span>|</span><a href="#38921634">parent</a><span>|</span><a href="#38921989">prev</a><span>|</span><a href="#38902524">next</a><span>|</span><label class="collapse" for="c-38922648">[-]</label><label class="expand" for="c-38922648">[1 more]</label></div><br/><div class="children"><div class="content">Elasticsearch was written in Java. No one cared. We still used it because it was good software.</div><br/></div></div></div></div><div id="38902524" class="c"><input type="checkbox" id="c-38902524" checked=""/><div class="controls bullet"><span class="by">debarshri</span><span>|</span><a href="#38921634">prev</a><span>|</span><a href="#38903106">next</a><span>|</span><label class="collapse" for="c-38902524">[-]</label><label class="expand" for="c-38902524">[11 more]</label></div><br/><div class="children"><div class="content">I see that you persist the logs in cloud storage where are the indexes stored?</div><br/><div id="38904208" class="c"><input type="checkbox" id="c-38904208" checked=""/><div class="controls bullet"><span class="by">jszymborski</span><span>|</span><a href="#38902524">parent</a><span>|</span><a href="#38902558">next</a><span>|</span><label class="collapse" for="c-38904208">[-]</label><label class="expand" for="c-38904208">[6 more]</label></div><br/><div class="children"><div class="content">The most interesting part of Quickwit for me has been that because it stores the index in object stores, you can theoretically abstract away a lot of the horizontal scaling with things like MinIO or SeaweedFS that have S3-compatible APIs w&#x2F;o having to go to the cloud.<p>Unfortunately, I think it&#x27;s a large reason why it was made a design choice that indexed documents are immutable (IIRC), which doesn&#x27;t work for my use case.</div><br/><div id="38904305" class="c"><input type="checkbox" id="c-38904305" checked=""/><div class="controls bullet"><span class="by">francoismassot</span><span>|</span><a href="#38902524">root</a><span>|</span><a href="#38904208">parent</a><span>|</span><a href="#38902558">next</a><span>|</span><label class="collapse" for="c-38904305">[-]</label><label class="expand" for="c-38904305">[5 more]</label></div><br/><div class="children"><div class="content">So yes, currently we only support infrequent deletes for GDPR reasons mainly.<p>It&#x27;s possible to add updates&#x2F;deletes to Quickwit, but this is a lot of work, and for now, we have not prioritized this development.<p>Do you mind sharing your use case?</div><br/><div id="38908908" class="c"><input type="checkbox" id="c-38908908" checked=""/><div class="controls bullet"><span class="by">jszymborski</span><span>|</span><a href="#38902524">root</a><span>|</span><a href="#38904305">parent</a><span>|</span><a href="#38902558">next</a><span>|</span><label class="collapse" for="c-38908908">[-]</label><label class="expand" for="c-38908908">[4 more]</label></div><br/><div class="children"><div class="content">Oh, just run-of-the-mill full-text search of web crawls.<p>Some web pages update frequently, so I would need something that can handle that.<p>I do understand that you seem to be targeting the log use-case of Elasticsearch moreso than the &quot;Apache Solr&quot; use-case.<p>I would be in passing curious of what about the GDPR makes infrequent deletes a design choice. My understanding of GDPR is that the &quot;right to be forgotten&quot; aspects would if anything require deletions to be inexpensive.</div><br/><div id="38923402" class="c"><input type="checkbox" id="c-38923402" checked=""/><div class="controls bullet"><span class="by">fulmicoton</span><span>|</span><a href="#38902524">root</a><span>|</span><a href="#38908908">parent</a><span>|</span><a href="#38922723">next</a><span>|</span><label class="collapse" for="c-38923402">[-]</label><label class="expand" for="c-38923402">[1 more]</label></div><br/><div class="children"><div class="content">Web crawl can be an ok use case actually.<p>The idea then would be to &quot;reindex&quot; the world.
It might seem ludicrous, but to give you an idea, indexing CommonCrawl takes about a day with 8vCPUs.</div><br/></div></div><div id="38922723" class="c"><input type="checkbox" id="c-38922723" checked=""/><div class="controls bullet"><span class="by">piperswe</span><span>|</span><a href="#38902524">root</a><span>|</span><a href="#38908908">parent</a><span>|</span><a href="#38923402">prev</a><span>|</span><a href="#38902558">next</a><span>|</span><label class="collapse" for="c-38922723">[-]</label><label class="expand" for="c-38922723">[2 more]</label></div><br/><div class="children"><div class="content">I would assume that users requesting to be forgotten is a fairly infrequent occurrence compared to just about any other operation.</div><br/><div id="38923192" class="c"><input type="checkbox" id="c-38923192" checked=""/><div class="controls bullet"><span class="by">jszymborski</span><span>|</span><a href="#38902524">root</a><span>|</span><a href="#38922723">parent</a><span>|</span><a href="#38902558">next</a><span>|</span><label class="collapse" for="c-38923192">[-]</label><label class="expand" for="c-38923192">[1 more]</label></div><br/><div class="children"><div class="content">True, but it can also require massive deletes&#x2F;updates.<p>I suppose their are ways to structure things to minimize this, though.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38902558" class="c"><input type="checkbox" id="c-38902558" checked=""/><div class="controls bullet"><span class="by">francoismassot</span><span>|</span><a href="#38902524">parent</a><span>|</span><a href="#38904208">prev</a><span>|</span><a href="#38903106">next</a><span>|</span><label class="collapse" for="c-38902558">[-]</label><label class="expand" for="c-38902558">[4 more]</label></div><br/><div class="children"><div class="content">We store the indexes on the object storage. We worked on the index data structure to optimize the query path.<p>For use cases where you have a lot of QPS, we recommend using Garage or MinIO or the feature to cache index data on the local disks (new in the 0.7).<p>I wrote a blog post that explains how we do that: <a href="https:&#x2F;&#x2F;quickwit.io&#x2F;blog&#x2F;quickwit-101" rel="nofollow">https:&#x2F;&#x2F;quickwit.io&#x2F;blog&#x2F;quickwit-101</a></div><br/><div id="38902620" class="c"><input type="checkbox" id="c-38902620" checked=""/><div class="controls bullet"><span class="by">debarshri</span><span>|</span><a href="#38902524">root</a><span>|</span><a href="#38902558">parent</a><span>|</span><a href="#38903106">next</a><span>|</span><label class="collapse" for="c-38902620">[-]</label><label class="expand" for="c-38902620">[3 more]</label></div><br/><div class="children"><div class="content">Why don&#x27;t you use clickhouse or some columnar storage for the logs? You get indexing or querying for free.</div><br/><div id="38907770" class="c"><input type="checkbox" id="c-38907770" checked=""/><div class="controls bullet"><span class="by">fulmicoton</span><span>|</span><a href="#38902524">root</a><span>|</span><a href="#38902620">parent</a><span>|</span><a href="#38902751">next</a><span>|</span><label class="collapse" for="c-38907770">[-]</label><label class="expand" for="c-38907770">[1 more]</label></div><br/><div class="children"><div class="content">It is a indexing vs search trade-off.<p>Let&#x27;s just consider IO, as it is the main effect here.
With a columnar, you have to read all of the fields targeted by your query.<p>If this is log, let&#x27;s assume<p>- 200B per line of logs<p>- 100TB of logs = 500 billions lines of logs<p>- 30 days of retention.<p>- a body text field taking 70% of your data.<p>- highly compressible (10x compression ratio). Note this will come with a higher cpu cost, but let&#x27;s focus on an IO lower bound.<p>If you have 100TB of data, regardless of the query, you will have to read (and decompress, but let&#x27;s not talk about cpu) 7TB worth of data.<p>Now with an inverted index? You will have to read the posting lists only. The posting lists are delta-encoded and bitpacked.<p>Assuming the probability of presence of a given term in a log line is p, the worst thing that can happen is having a token that is in 99% of the documents.<p>In that case, you will have to read 2.06 bits per documents.
That&#x27;s 128GB for the worst posting list.<p>If you are looking for a single keyword, in the worst possible case, you will have to read 54 times less data than with the columnar solution.<p>In practice, users search for several keywords, but also considerably less pathological than the example I just gave. Overall you will typically end up reading 20 to 100 times less data than with the grep solution.<p>I left CPU aside, but actual search engines are also much more CPU efficient.<p>But I said there was a trade-off... where is it?
Well you had to pay a much higher cost at indexing.<p>Some search engine implementation makes it seem like indexing is more expensive than it should be.  Quickwit&#x2F;tantivy are especially efficient there. With a 4vCPUs VM, you can expect to index at 2TB&#x2F;day. So in the example above, you will have to dedicate 8vCPUs for indexing. This is perfectly reasonable.<p>BUT if your retention is much much shorter (few days), indexing might not be worth it.<p>If your volume of data is small too, you probably do not need to care at all about efficiency.</div><br/></div></div><div id="38902751" class="c"><input type="checkbox" id="c-38902751" checked=""/><div class="controls bullet"><span class="by">francoismassot</span><span>|</span><a href="#38902524">root</a><span>|</span><a href="#38902620">parent</a><span>|</span><a href="#38907770">prev</a><span>|</span><a href="#38903106">next</a><span>|</span><label class="collapse" for="c-38902751">[-]</label><label class="expand" for="c-38902751">[1 more]</label></div><br/><div class="children"><div class="content">So Quickwit is primarily a search engine and thus relies on an inverted index.
We also implemented our schemaless columnar storage optimized for object storage.<p>The inverted index and columnar storage are part of tantivy [0], which is the fastest OSS search library out there (except for the academic project pisa) [1]. We maintain it, and we decided to build the distributed engine on top of it.<p>[0] tantivy github repo: <a href="https:&#x2F;&#x2F;github.com&#x2F;quickwit-oss&#x2F;tantivy">https:&#x2F;&#x2F;github.com&#x2F;quickwit-oss&#x2F;tantivy</a><p>[1] tantivy bench <a href="https:&#x2F;&#x2F;tantivy-search.github.io&#x2F;bench&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tantivy-search.github.io&#x2F;bench&#x2F;</a></div><br/></div></div></div></div></div></div></div></div><div id="38903106" class="c"><input type="checkbox" id="c-38903106" checked=""/><div class="controls bullet"><span class="by">jcwayne</span><span>|</span><a href="#38902524">prev</a><span>|</span><label class="collapse" for="c-38903106">[-]</label><label class="expand" for="c-38903106">[5 more]</label></div><br/><div class="children"><div class="content">I find presenting this as an open source alternative to commercial solutions a little disingenuous when any commercial use of it also requires a paid license. Like many other cases it seems like the AGPL is functioning more as a trial license.</div><br/><div id="38904018" class="c"><input type="checkbox" id="c-38904018" checked=""/><div class="controls bullet"><span class="by">francoismassot</span><span>|</span><a href="#38903106">parent</a><span>|</span><a href="#38904551">next</a><span>|</span><label class="collapse" for="c-38904018">[-]</label><label class="expand" for="c-38904018">[1 more]</label></div><br/><div class="children"><div class="content">Well, I would say it depends. We have many companies using the AGPL version without buying a license. We also know that some companies have strict policies and will forbid using AGPL software unless taking a commercial license. We&#x27;re happy with both users.<p>I like the example of Grafana with all their AGPL projects (Grafana, Loki, Tempo, ...). There are a LOT of companies using Grafana with the AGPL version.</div><br/></div></div><div id="38904551" class="c"><input type="checkbox" id="c-38904551" checked=""/><div class="controls bullet"><span class="by">dwb</span><span>|</span><a href="#38903106">parent</a><span>|</span><a href="#38904018">prev</a><span>|</span><a href="#38907797">next</a><span>|</span><label class="collapse" for="c-38904551">[-]</label><label class="expand" for="c-38904551">[1 more]</label></div><br/><div class="children"><div class="content">The GNU AGPL is considered a Free Software licence by the OSI, FSF, and the Debian project. That&#x27;s good enough for me.</div><br/></div></div><div id="38907797" class="c"><input type="checkbox" id="c-38907797" checked=""/><div class="controls bullet"><span class="by">fulmicoton</span><span>|</span><a href="#38903106">parent</a><span>|</span><a href="#38904551">prev</a><span>|</span><a href="#38904878">next</a><span>|</span><label class="collapse" for="c-38907797">[-]</label><label class="expand" for="c-38907797">[1 more]</label></div><br/><div class="children"><div class="content">You can use AGPL for commercial use. The limitation is that you will have to opensource any patch you make to it.</div><br/></div></div><div id="38904878" class="c"><input type="checkbox" id="c-38904878" checked=""/><div class="controls bullet"><span class="by">dvfjsdhgfv</span><span>|</span><a href="#38903106">parent</a><span>|</span><a href="#38907797">prev</a><span>|</span><label class="collapse" for="c-38904878">[-]</label><label class="expand" for="c-38904878">[1 more]</label></div><br/><div class="children"><div class="content">I find AGPL perfect for this use case, and my org (&gt;100k hosts) can use it without any problem as we are using it for internal purposes, and not, say, rebranding it and offering as a part of our own product.</div><br/></div></div></div></div></div></div></div></div></div></body></html>