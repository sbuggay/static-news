<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709974863926" as="style"/><link rel="stylesheet" href="styles.css?v=1709974863926"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/mighty-gerbils/gerbil-persist/blob/master/persist.md">Orthogonal Persistence</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>mpweiher</span> | <span>30 comments</span></div><br/><div><div id="39646938" class="c"><input type="checkbox" id="c-39646938" checked=""/><div class="controls bullet"><span class="by">geophile</span><span>|</span><a href="#39644920">next</a><span>|</span><label class="collapse" for="c-39646938">[-]</label><label class="expand" for="c-39646938">[4 more]</label></div><br/><div class="children"><div class="content">That phrase certainly brings back memories, from when I worked at an object-oriented database startup.<p>The object-orientation was actually pretty unimportant, (except for those products that brought in persistence via inheritance -- so not <i>really</i> orthogonal). No, the point was adding a new storage class to programming languages.<p>I worked at Object Design, and we had (IMHO) an incredibly elegant approach. In our approach, persistence really was orthogonal to type, for C&#x2F;C++. If you want a FooBar, you would write &quot;new FooBar(123)&quot;. That gives you a FooBar in the heap, disappears at process end (or on deletion), etc. Or you could write &quot;new(db) FooBar(123)&quot;, and then on commit (we had transactions of course), the FooBar would be in the database, and accessible by other processes.<p>A page-faulting mechanism would bring in pages containing locations that your program referenced. That itself was very elegant.<p>But the really beautiful thing about this architecture was getting it to work in a 32-bit address space. We did some clever things about mapping portions of the address space during the faulting process to make things work transparently. (This problem pretty much disappears with a 64-bit address space.)<p>Separate from all that, we had a collection library, integrated with an OO query language. E.g., you could have a collections of widgets in your database, write &quot;widgets[: weight &lt; 0.01 and !strcmp(color, &#x27;red&#x27;) :], and get back a set containing the qualifying widgets. We also supported 1:1, 1:n, and m:n relationships, which would maintain pointers and sets of pointers in both directions.<p>It was a &quot;database system&quot; because our VCs wanted it to be. But it really wasn&#x27;t. It really was a new storage class for C&#x2F;C++, and later, for Smalltalk and Java.<p>Object Design also had a spectacularly talented group of engineers, many of whom came from MIT AI Lab&#x2F;Symbolics.</div><br/><div id="39649703" class="c"><input type="checkbox" id="c-39649703" checked=""/><div class="controls bullet"><span class="by">jdougan</span><span>|</span><a href="#39646938">parent</a><span>|</span><a href="#39649157">next</a><span>|</span><label class="collapse" for="c-39649703">[-]</label><label class="expand" for="c-39649703">[1 more]</label></div><br/><div class="children"><div class="content">How would you compare it to Gemstone&#x2F;S? I spent a large chunk of the 90s working on a maintenance management system witha GS back end.</div><br/></div></div><div id="39649157" class="c"><input type="checkbox" id="c-39649157" checked=""/><div class="controls bullet"><span class="by">aeontech</span><span>|</span><a href="#39646938">parent</a><span>|</span><a href="#39649703">prev</a><span>|</span><a href="#39644920">next</a><span>|</span><label class="collapse" for="c-39649157">[-]</label><label class="expand" for="c-39649157">[2 more]</label></div><br/><div class="children"><div class="content">That sounds fascinating! Does anything like this exist now in the open source world?</div><br/><div id="39649167" class="c"><input type="checkbox" id="c-39649167" checked=""/><div class="controls bullet"><span class="by">geophile</span><span>|</span><a href="#39646938">root</a><span>|</span><a href="#39649157">parent</a><span>|</span><a href="#39644920">next</a><span>|</span><label class="collapse" for="c-39649167">[-]</label><label class="expand" for="c-39649167">[1 more]</label></div><br/><div class="children"><div class="content">Not that I know of.</div><br/></div></div></div></div></div></div><div id="39644920" class="c"><input type="checkbox" id="c-39644920" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#39646938">prev</a><span>|</span><a href="#39646485">next</a><span>|</span><label class="collapse" for="c-39644920">[-]</label><label class="expand" for="c-39644920">[1 more]</label></div><br/><div class="children"><div class="content">See the end for a discussion of &quot;Unfriendly Persistence&quot;: <a href="https:&#x2F;&#x2F;github.com&#x2F;mighty-gerbils&#x2F;gerbil-persist&#x2F;blob&#x2F;master&#x2F;persist.md#coda-friendly-vs-unfriendly-persistence">https:&#x2F;&#x2F;github.com&#x2F;mighty-gerbils&#x2F;gerbil-persist&#x2F;blob&#x2F;master...</a><p>(the data you&#x27;d like to keep is more volatile than you&#x27;d wish, but the data others keep on you is much less volatile that you&#x27;d wish)</div><br/></div></div><div id="39646485" class="c"><input type="checkbox" id="c-39646485" checked=""/><div class="controls bullet"><span class="by">thom</span><span>|</span><a href="#39644920">prev</a><span>|</span><a href="#39648583">next</a><span>|</span><label class="collapse" for="c-39646485">[-]</label><label class="expand" for="c-39646485">[2 more]</label></div><br/><div class="children"><div class="content">This was very fashionable 15-20 years ago, in both application and OS research. One such Java framework:<p><a href="https:&#x2F;&#x2F;prevayler.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;prevayler.org&#x2F;</a><p>Less ambitious than TFA overall, I grant you.</div><br/><div id="39649721" class="c"><input type="checkbox" id="c-39649721" checked=""/><div class="controls bullet"><span class="by">sillywalk</span><span>|</span><a href="#39646485">parent</a><span>|</span><a href="#39648583">next</a><span>|</span><label class="collapse" for="c-39649721">[-]</label><label class="expand" for="c-39649721">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure if counts as &quot;orthogonal persistence&quot;,  but there&#x27;s the Aurora Operating System[0] from 2021. It&#x27;s apparently based on FreeBSD, and can run most unmodified apps, as well as having an API to support its Store.<p>&quot;We present the Aurora single level store
(SLS), an OS that simplifies persistence by automatically per-
sisting all traditionally ephemeral application state. With
recent storage hardware like NVMe SSDs and NVDIMMs,
Aurora is able to continuously checkpoint entire applications
with millisecond granularity.
Aurora is the first full POSIX single level store to han-
dle complex applications ranging from databases to web
browsers&quot;<p>[0] <a href="https:&#x2F;&#x2F;rcs.uwaterloo.ca&#x2F;pubs&#x2F;hotos21-aurora.pdf" rel="nofollow">https:&#x2F;&#x2F;rcs.uwaterloo.ca&#x2F;pubs&#x2F;hotos21-aurora.pdf</a></div><br/></div></div></div></div><div id="39648583" class="c"><input type="checkbox" id="c-39648583" checked=""/><div class="controls bullet"><span class="by">couchand</span><span>|</span><a href="#39646485">prev</a><span>|</span><a href="#39644548">next</a><span>|</span><label class="collapse" for="c-39648583">[-]</label><label class="expand" for="c-39648583">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Atomic sections must be short: long atomic sections will break liveness, i.e. may cause the system to become unresponsive.<p>&gt; ...<p>&gt; Based on disk latency, we may target say a millisecond as duration before which to commit the current transaction. When the timer is reached, the transaction is delayed until all current atomic sections are completed; and (possibly after a grace period) new atomic sections are blocked from even being started, until after the transaction is committed.<p>Maybe I&#x27;m reading this wrong, but the limitations on transaction duration seem to be disqualifying for real usage?  If it&#x27;s not possible to run an atomic transaction for longer than a few milliseconds without bringing the system down?</div><br/></div></div><div id="39644548" class="c"><input type="checkbox" id="c-39644548" checked=""/><div class="controls bullet"><span class="by">qazxcvbnm</span><span>|</span><a href="#39648583">prev</a><span>|</span><a href="#39646943">next</a><span>|</span><label class="collapse" for="c-39644548">[-]</label><label class="expand" for="c-39644548">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Persistence is Orthogonal to the Data Model, ...<p>I have some experience with a custom data runtime where the persistence is orthogonal to the data model, with silhouettes reminiscent of the described solutions in many of the features of my system, including multiple orthogonal&#x2F;model-agnostic persistence backends, automatic data synchronisation, persistable executions, automatable schema changes, automatic reactivity.<p>This direction can indeed bring about great savings in various parts of development; however, it seems to me that more subtlety than indicated in the post is required.<p>The programmer must be provided with ergonomic means to give denotations for things like when and where to persist, in order to reduce data movement, and to keep the system performant (this does not violate orthogonality; we may specify e.g. to persist at the <i>logical</i> location, say, in the cloud, without having to specify the physical persistence). For instance, considering the case of schema changes, unless the system bundles its language inside the database, for performance sake, to perform such changes in an &quot;Orthogonal Persistence&quot; system external to the database would take an completely disproportionate amount of time relative to using SQL in the database. The data runtime I work with uses the idea of lenses (where valid lenses would necessarily be reversible) to allow for coherent, undoable schema changes, but I still resort to SQL for regular (eager) migrations (the lenses system for schema changes can still be useful for migrations applied lazily).</div><br/><div id="39646601" class="c"><input type="checkbox" id="c-39646601" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#39644548">parent</a><span>|</span><a href="#39646943">next</a><span>|</span><label class="collapse" for="c-39646601">[-]</label><label class="expand" for="c-39646601">[2 more]</label></div><br/><div class="children"><div class="content">Or, to put it another like, like visual programming, like &quot;programming languages should be able to wear syntaxes like themes&quot;, like &quot;there ought to be some sort of nocode type solution with all the power of conventional programming but easy enough for anyone to pick up&quot;, there are <i>reasons</i> why this is not how all programming works already. Good ones and big ones. And none of those reasons are that nobody has had the idea before or put work into implementing it. If you want to succeed with an approach like this, you&#x27;re going to need to understand them.<p>To be honest, such experience as I&#x27;ve had with automated persistence has generally actually <i>strongly</i> convinced me of the opposite, that it is a <i>positive good</i> that we do not get persistence everywhere. Consider the understanding that we get from functional programming that state is generally dangerous and to be carefully managed. Pervasive persistence fights <i>hard</i> against that careful management. Now state is not just in your program up until the OS process is terminated, but it&#x27;s <i>all</i> permanently and automatically persisted. You get a <i>huge</i> new class of bugs involving path dependence on what bits of code were running across what bits of state when, and who ran which versions, and you hit them <i>all the time</i>, and they are <i>nightmares</i> to debug. At least when the program has the courtesy to completely cease existing and leave some particular concrete bit of state behind for the future, and then run through your code to load it back from that location, you have boundaries, and procedures for minimization and reconstruction. I actually shy away from too much automated persistence, and also have a very skeptical eye on the ever-present promise of memory that is as fast as RAM but persists like SSDs... I rather expect the computing world will discover that &quot;rebooting&quot; is not just a crutch, but actually a pretty fundamental and useful tool. However much in <i>theory</i> your software should never need it, in practice it&#x27;s just too useful.<p>That said, best of luck to those jousting with this windmill. I&#x27;m not saying don&#x27;t joust, people in general probably don&#x27;t joust enough, I&#x27;m just saying, learn the history of why this hasn&#x27;t worked before and learn the challenges. Success is at the very least more likely if one learns from the previous efforts.</div><br/><div id="39648028" class="c"><input type="checkbox" id="c-39648028" checked=""/><div class="controls bullet"><span class="by">dTal</span><span>|</span><a href="#39644548">root</a><span>|</span><a href="#39646601">parent</a><span>|</span><a href="#39646943">next</a><span>|</span><label class="collapse" for="c-39648028">[-]</label><label class="expand" for="c-39648028">[1 more]</label></div><br/><div class="children"><div class="content">Offtopic perhaps, but I am interested in reading an explanation of the good, big reasons why not &quot;programming languages should be able to wear syntaxes like themes&quot;. Racket seems quite an interesting counterpoint, and I&#x27;ve never heard it argued as fundamentally flawed.</div><br/></div></div></div></div></div></div><div id="39646943" class="c"><input type="checkbox" id="c-39646943" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#39644548">prev</a><span>|</span><a href="#39643970">next</a><span>|</span><label class="collapse" for="c-39646943">[-]</label><label class="expand" for="c-39646943">[2 more]</label></div><br/><div class="children"><div class="content">&gt;servers only see a unindexed random-looking key value store<p>(quoted from the main readme)<p>I bet there&#x27;s some fun attacks waiting to happen, related to watching for specific access patterns. Avoidable I&#x27;m sure, but I imagine it&#x27;ll require awareness from application developers.</div><br/><div id="39647127" class="c"><input type="checkbox" id="c-39647127" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#39646943">parent</a><span>|</span><a href="#39643970">next</a><span>|</span><label class="collapse" for="c-39647127">[-]</label><label class="expand" for="c-39647127">[1 more]</label></div><br/><div class="children"><div class="content">idk if the authors are reading this, but here&#x27;s some feedback on the row encryption scheme:<p>1. Please use an AEAD!<p>2. IIUC, the current design exposes the hashes of the data values. This seems undesirable and I think you can avoid it.</div><br/></div></div></div></div><div id="39643970" class="c"><input type="checkbox" id="c-39643970" checked=""/><div class="controls bullet"><span class="by">qazxcvbnm</span><span>|</span><a href="#39646943">prev</a><span>|</span><a href="#39645902">next</a><span>|</span><label class="collapse" for="c-39643970">[-]</label><label class="expand" for="c-39643970">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Transactions are not modular because every function needs to know whether itâs already in a transaction or not, to be conscious of what global entry point in a completely different module owns the transaction.<p>I fail to understand the section about why transactions are unmodular. I&#x27;ve never encountered transaction code where the initiator of the transaction would affect the computation; could anyone elucidate this?</div><br/><div id="39647551" class="c"><input type="checkbox" id="c-39647551" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#39643970">parent</a><span>|</span><a href="#39645577">next</a><span>|</span><label class="collapse" for="c-39647551">[-]</label><label class="expand" for="c-39647551">[1 more]</label></div><br/><div class="children"><div class="content">This is probably about the nesting of transactions.<p>If you start a transaction when the calling code already started a transaction, then either you get an error because nested transactions are forbidden, or a reference counter is incremented for the transaction, so that when you close your inner transaction, no commit is done at that point, and instead the commit is only done when outermost transaction closes.<p>This latter case means that you donât know when your inner transaction really commits, and also if you perform multiple inner transactions and the later one fails, the earlier one will implicitly also be rolled back, because they are all really just one shared outer transaction.<p>Of course, you could use separate database connections with independent transactions, but then you get into deadlocks or other problems when you really work on the same data.<p>So you canât have modules that build on each other, while each being able to use transactions independently from each other. Transactions donât compose in that way.<p>You would basically have to âcolorâ every function based on wether it may perform a transaction or not, and within a transaction block you would only be allowed to call functions that donât themselves perform a transaction. It becomes more complicated when you have transactions that are not lexically scoped, but for example live in an object.</div><br/></div></div><div id="39645577" class="c"><input type="checkbox" id="c-39645577" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#39643970">parent</a><span>|</span><a href="#39647551">prev</a><span>|</span><a href="#39645902">next</a><span>|</span><label class="collapse" for="c-39645577">[-]</label><label class="expand" for="c-39645577">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t write this in any random function that you don&#x27;t know who will call:<p>do $$<p>begin transaction;<p>update page set change_count = change_count + 1 where page_id = 1;<p>if (select change_count = 100 from page where page_id = 1) then<p><pre><code>    rollback;
</code></pre>
else<p><pre><code>    commit;
</code></pre>
end if;<p>$$</div><br/></div></div></div></div><div id="39645902" class="c"><input type="checkbox" id="c-39645902" checked=""/><div class="controls bullet"><span class="by">AnthonyMQ</span><span>|</span><a href="#39643970">prev</a><span>|</span><a href="#39645586">next</a><span>|</span><label class="collapse" for="c-39645902">[-]</label><label class="expand" for="c-39645902">[1 more]</label></div><br/><div class="children"><div class="content">You should have a look at <a href="https:&#x2F;&#x2F;internetcomputer.org" rel="nofollow">https:&#x2F;&#x2F;internetcomputer.org</a> they built everything around orthogonal persistence.
Pretty interesting and fun to build on it.
I developed <a href="https:&#x2F;&#x2F;www.aedile.io" rel="nofollow">https:&#x2F;&#x2F;www.aedile.io</a></div><br/></div></div><div id="39645586" class="c"><input type="checkbox" id="c-39645586" checked=""/><div class="controls bullet"><span class="by">nahuel0x</span><span>|</span><a href="#39645902">prev</a><span>|</span><a href="#39643391">next</a><span>|</span><label class="collapse" for="c-39645586">[-]</label><label class="expand" for="c-39645586">[3 more]</label></div><br/><div class="children"><div class="content">Surprised of not seeing Smalltalk mentioned on the article.</div><br/><div id="39649727" class="c"><input type="checkbox" id="c-39649727" checked=""/><div class="controls bullet"><span class="by">jdougan</span><span>|</span><a href="#39645586">parent</a><span>|</span><a href="#39647633">next</a><span>|</span><label class="collapse" for="c-39649727">[-]</label><label class="expand" for="c-39649727">[1 more]</label></div><br/><div class="children"><div class="content">Not so much Smalltalk, but Gemstone&#x2F;S should have gotten a mention.</div><br/></div></div><div id="39647633" class="c"><input type="checkbox" id="c-39647633" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#39645586">parent</a><span>|</span><a href="#39649727">prev</a><span>|</span><a href="#39643391">next</a><span>|</span><label class="collapse" for="c-39647633">[-]</label><label class="expand" for="c-39647633">[1 more]</label></div><br/><div class="children"><div class="content">Smalltalk doesnât persist by default, you have to explicitly save a snapshot of your image.</div><br/></div></div></div></div><div id="39643391" class="c"><input type="checkbox" id="c-39643391" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#39645586">prev</a><span>|</span><a href="#39643733">next</a><span>|</span><label class="collapse" for="c-39643391">[-]</label><label class="expand" for="c-39643391">[8 more]</label></div><br/><div class="children"><div class="content">having this as a model would be lovely and I agree wholeheartedly with the exposition. its interesting though to think about what impact this model would have on programming. a lot of our processing and tooling are built around the notion that programs are _almost_ right, and that we can bring them in and out - and hopefully in the process our precious data hasn&#x27;t been mangled.<p>when we express state directly in programs, we gain a lot, but our notion of trashy disposable execution goes away and now we have to think a lot more about how that system evolves.</div><br/><div id="39643781" class="c"><input type="checkbox" id="c-39643781" checked=""/><div class="controls bullet"><span class="by">usrusr</span><span>|</span><a href="#39643391">parent</a><span>|</span><a href="#39643733">next</a><span>|</span><label class="collapse" for="c-39643781">[-]</label><label class="expand" for="c-39643781">[7 more]</label></div><br/><div class="children"><div class="content">Reminds me of the discussions on hn when Intel Optane wasn&#x27;t quite dead yet. Those always seemed to end with the conclusion that if separation between volatile and persistent memory had not been forced on us by technological reality, it would be a concept we&#x27;d better have invented at some point.</div><br/><div id="39644886" class="c"><input type="checkbox" id="c-39644886" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#39643391">root</a><span>|</span><a href="#39643781">parent</a><span>|</span><a href="#39643891">next</a><span>|</span><label class="collapse" for="c-39644886">[-]</label><label class="expand" for="c-39644886">[2 more]</label></div><br/><div class="children"><div class="content">I was tangentially involved with an orthogonally persistent OS, and we indeed had had to reinvent a distinct journalling channel and special optionally-volatile storage, for DBMS-style applications.</div><br/><div id="39645138" class="c"><input type="checkbox" id="c-39645138" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#39643391">root</a><span>|</span><a href="#39644886">parent</a><span>|</span><a href="#39643891">next</a><span>|</span><label class="collapse" for="c-39645138">[-]</label><label class="expand" for="c-39645138">[1 more]</label></div><br/><div class="children"><div class="content">other reasons to need optionally-volatile storage include secure encryption key generation (reusing randomness often fatally compromises it) and device drivers (if you restore the internal state of your device driver from a checkpoint, but not the state of the device, you will probably crash the system the next time the driver tries to frob the device)<p>despite this, virtual machine checkpoints in qemu work well enough for many purposes</div><br/></div></div></div></div><div id="39643891" class="c"><input type="checkbox" id="c-39643891" checked=""/><div class="controls bullet"><span class="by">catskul2</span><span>|</span><a href="#39643391">root</a><span>|</span><a href="#39643781">parent</a><span>|</span><a href="#39644886">prev</a><span>|</span><a href="#39646558">next</a><span>|</span><label class="collapse" for="c-39643891">[-]</label><label class="expand" for="c-39643891">[2 more]</label></div><br/><div class="children"><div class="content">Think you can find any of those discussions? I&#x27;d be curious to read&#x2F;browse.</div><br/><div id="39644701" class="c"><input type="checkbox" id="c-39644701" checked=""/><div class="controls bullet"><span class="by">usrusr</span><span>|</span><a href="#39643391">root</a><span>|</span><a href="#39643891">parent</a><span>|</span><a href="#39646558">next</a><span>|</span><label class="collapse" for="c-39644701">[-]</label><label class="expand" for="c-39644701">[1 more]</label></div><br/><div class="children"><div class="content">This  is the one that was featured in my memory:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32314814">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32314814</a><p>But the most recent one is also interesting:
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38527437">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38527437</a></div><br/></div></div></div></div><div id="39646558" class="c"><input type="checkbox" id="c-39646558" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#39643391">root</a><span>|</span><a href="#39643781">parent</a><span>|</span><a href="#39643891">prev</a><span>|</span><a href="#39643733">next</a><span>|</span><label class="collapse" for="c-39646558">[-]</label><label class="expand" for="c-39646558">[2 more]</label></div><br/><div class="children"><div class="content">I am not sure about this?<p>Volatile memory is at this time merely an outgrowth of the uptime of the system. Back when people routinely turned their machines &quot;off and on again&quot;, it became part of that convention. But now uptime can be measured in years, and even personal laptops can enter and exit suspended state for weeks on end without clearing volatile memory.<p>What we have developed in <i>software</i> systems to accommodate this on long running processes is garbage collection.<p>If the volatile&#x2F;non-volatile distinction had never developed, all that would have happened is that R&amp;D into garbage collection would have been more intense, and earlier.<p>In fact Lisp had garbage collection from day 1.<p>Systems like Smalltalk were also built from the ground up on  an image-based model where all reachable state was persistent.<p>In other words: transient data does not necessitate volatile memory. It necessitates garbage collection, though. (And likely also a distinction in programming between &quot;performant&quot; memory areas and non-performant, assuming our NV storage is the latter.)<p>In a way, programmers having to deal with their garbage upfront and not relying on <i>&quot;have you tried turning it off and on again?&quot;</i> could have created better software engineering practices earlier? Maybe?</div><br/><div id="39647669" class="c"><input type="checkbox" id="c-39647669" checked=""/><div class="controls bullet"><span class="by">48864w6ui</span><span>|</span><a href="#39643391">root</a><span>|</span><a href="#39646558">parent</a><span>|</span><a href="#39643733">next</a><span>|</span><label class="collapse" for="c-39647669">[-]</label><label class="expand" for="c-39647669">[1 more]</label></div><br/><div class="children"><div class="content">Back in the days when minicomputers (which required a walk to the air-conditioned machine room to reboot) and microcomputers (which had a case or keyboard switch) coexisted, the former were way less flaky than the latter.</div><br/></div></div></div></div></div></div></div></div><div id="39643733" class="c"><input type="checkbox" id="c-39643733" checked=""/><div class="controls bullet"><span class="by">bugbuddy</span><span>|</span><a href="#39643391">prev</a><span>|</span><label class="collapse" for="c-39643733">[-]</label><label class="expand" for="c-39643733">[1 more]</label></div><br/><div class="children"><div class="content">Yes, we can absolutely implement this but your computer now runs x times slower and or is y times more expensive. For the vast majority of people, this would be a quaint exercise and real market exists for it.</div><br/></div></div></div></div></div></div></div></body></html>