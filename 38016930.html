<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1698310857959" as="style"/><link rel="stylesheet" href="styles.css?v=1698310857959"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://buttondown.email/jaffray/archive/the-case-of-a-curious-sql-query/">The Case of a Curious SQL Query</a>Â <span class="domain">(<a href="https://buttondown.email">buttondown.email</a>)</span></div><div class="subtext"><span>petercooper</span> | <span>34 comments</span></div><br/><div><div id="38018029" class="c"><input type="checkbox" id="c-38018029" checked=""/><div class="controls bullet"><span class="by">somat</span><span>|</span><a href="#38017560">next</a><span>|</span><label class="collapse" for="c-38018029">[-]</label><label class="expand" for="c-38018029">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really know what I am talking about, But I thought that postgres function volatility was introduced for this exact reason, that is, As a clue to the optimizer where it can and cannot push stuff down.<p><a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;15&#x2F;xfunc-volatility.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;15&#x2F;xfunc-volatility.html</a><p>I do note that the postgres explain appears to keep the join filter on the top level.<p><pre><code>  explain select count(*) from
   generate_series(0,999) a
     inner join
   generate_series(0,999)
     on random() &lt; 0.5
  ;
                                      QUERY PLAN                                      
  --------------------------------------------------------------------------------------
   Aggregate  (cost=25843.34..25843.35 rows=1 width=8)
     -&gt;  Nested Loop  (cost=0.01..25010.01 rows=333333 width=0)
          Join Filter: (random() &lt; &#x27;0.5&#x27;::double precision)
          -&gt;  Function Scan on generate_series a  (cost=0.00..10.00 rows=1000 width=0)
         -&gt;  Function Scan on generate_series  (cost=0.00..10.00 rows=1000 width=0)</code></pre></div><br/><div id="38018592" class="c"><input type="checkbox" id="c-38018592" checked=""/><div class="controls bullet"><span class="by">minkzilla</span><span>|</span><a href="#38018029">parent</a><span>|</span><a href="#38017560">next</a><span>|</span><label class="collapse" for="c-38018592">[-]</label><label class="expand" for="c-38018592">[1 more]</label></div><br/><div class="children"><div class="content">And if you make a function with with a volatility level of stable it does a One-Time Filter. So you will either get 0 or 1000000<p><pre><code>  create function random2() returns float as $$
  begin
      return random();
  end;
  $$ language plpgsql stable;

  select count(*) from one_thousand join one_thousand b on random2() &gt; 0.5;
</code></pre>
Query Plan<p><pre><code>  Aggregate  (cost=97615.13..97615.14 rows=1 width=8) (actual time=0.028..0.029 rows=1 loops=1)
    -&gt;  Result  (cost=0.25..81358.88 rows=6502500 width=0) (actual time=0.026..0.027 rows=0 loops=1)
          One-Time Filter: (random3() &gt; &#x27;0.5&#x27;::double precision)
          -&gt;  Nested Loop  (cost=0.25..81358.88 rows=6502500 width=0) (never executed)
                -&gt;  Seq Scan on one_thousand  (cost=0.00..35.50 rows=2550 width=0) (never executed)
                -&gt;  Materialize  (cost=0.00..48.25 rows=2550 width=0) (never executed)
                      -&gt;  Seq Scan on one_thousand b  (cost=0.00..35.50 rows=2550 width=0) (never executed)</code></pre></div><br/></div></div></div></div><div id="38017560" class="c"><input type="checkbox" id="c-38017560" checked=""/><div class="controls bullet"><span class="by">petercooper</span><span>|</span><a href="#38018029">prev</a><span>|</span><a href="#38023146">next</a><span>|</span><label class="collapse" for="c-38017560">[-]</label><label class="expand" for="c-38017560">[3 more]</label></div><br/><div class="children"><div class="content">After submitting, I noticed this was submitted a few times without attracting any comments, and it might be because it&#x27;s a slow burn to get started. It&#x27;s a neat look at how optimization approaches taken by different databases can lead to very different outcome distributions for the same query.</div><br/><div id="38018161" class="c"><input type="checkbox" id="c-38018161" checked=""/><div class="controls bullet"><span class="by">progmetaldev</span><span>|</span><a href="#38017560">parent</a><span>|</span><a href="#38017840">next</a><span>|</span><label class="collapse" for="c-38018161">[-]</label><label class="expand" for="c-38018161">[1 more]</label></div><br/><div class="children"><div class="content">This was a great read, super interesting, and I hadn&#x27;t seen anything like this article before.</div><br/></div></div><div id="38017840" class="c"><input type="checkbox" id="c-38017840" checked=""/><div class="controls bullet"><span class="by">eckza</span><span>|</span><a href="#38017560">parent</a><span>|</span><a href="#38018161">prev</a><span>|</span><a href="#38023146">next</a><span>|</span><label class="collapse" for="c-38017840">[-]</label><label class="expand" for="c-38017840">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m glad you posted this. I haven&#x27;t seen it here (or anywhere else) before, and it was a fun read.</div><br/></div></div></div></div><div id="38023146" class="c"><input type="checkbox" id="c-38023146" checked=""/><div class="controls bullet"><span class="by">xnorswap</span><span>|</span><a href="#38017560">prev</a><span>|</span><a href="#38020144">next</a><span>|</span><label class="collapse" for="c-38023146">[-]</label><label class="expand" for="c-38023146">[1 more]</label></div><br/><div class="children"><div class="content">This is very enlightening, and it&#x27;s not surprising that it&#x27;s not well defined in the spec but it does surprise me that it differs so much between engines.</div><br/></div></div><div id="38020144" class="c"><input type="checkbox" id="c-38020144" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#38023146">prev</a><span>|</span><a href="#38022618">next</a><span>|</span><label class="collapse" for="c-38020144">[-]</label><label class="expand" for="c-38020144">[2 more]</label></div><br/><div class="children"><div class="content">&gt; SQLite plans are unfortunately not the most enlightening<p>&gt; sqlite&gt; explain select<p>About 5 years ago, sqlite introduced EXPLAIN QUERY PLAN to get something more like what other databases give with just EXPLAIN.<p><a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;eqp.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.sqlite.org&#x2F;eqp.html</a></div><br/><div id="38020213" class="c"><input type="checkbox" id="c-38020213" checked=""/><div class="controls bullet"><span class="by">foldU</span><span>|</span><a href="#38020144">parent</a><span>|</span><a href="#38022618">next</a><span>|</span><label class="collapse" for="c-38020213">[-]</label><label class="expand" for="c-38020213">[1 more]</label></div><br/><div class="children"><div class="content">I had no idea, thanks!</div><br/></div></div></div></div><div id="38022618" class="c"><input type="checkbox" id="c-38022618" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38020144">prev</a><span>|</span><a href="#38018665">next</a><span>|</span><label class="collapse" for="c-38022618">[-]</label><label class="expand" for="c-38022618">[1 more]</label></div><br/><div class="children"><div class="content">Nit: SQLite `random()` returns a full 64-bit signed integer, so `random() &lt; 0.5` in SQLite is (very) slightly different from others. The relevant portion of SQLite source code by the way is the `pushDownWhereTerms` function in select.c [1]; apparently it doesn&#x27;t do the deterministic function check (i.e. `SQLITE_FUNC_CONSTANT`).<p>[1] <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;src&#x2F;info&#x2F;64c9bc7494f3d220a27498137551762c25458282388ea9ac0a710dd6d5dc1510" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.sqlite.org&#x2F;src&#x2F;info&#x2F;64c9bc7494f3d220a27498137551...</a></div><br/></div></div><div id="38018665" class="c"><input type="checkbox" id="c-38018665" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#38022618">prev</a><span>|</span><a href="#38018462">next</a><span>|</span><label class="collapse" for="c-38018665">[-]</label><label class="expand" for="c-38018665">[1 more]</label></div><br/><div class="children"><div class="content">Other tricky cases:<p>WITH c AS (
  SELECT random() AS r FROM t1
)
SELECT * FROM c WHERE r &lt; 0.5;<p>I&#x27;ve seen bugs where this returned rows with r &gt; 0.5. The semantics of such functions can be very tricky when the database engine assumes it can freely evaluate everything at any point. Similarly:<p>SELECT random() AS r FROM t1 WHERE r &lt; 0.5 HAVING r &lt; 0.5;<p>ANSI SQL doesn&#x27;t allow this query (projection comes after filtering, so you cannot filter on something that is only created in projection), but some databases do, and can give counterintuitive results.</div><br/></div></div><div id="38018462" class="c"><input type="checkbox" id="c-38018462" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#38018665">prev</a><span>|</span><a href="#38018108">next</a><span>|</span><label class="collapse" for="c-38018462">[-]</label><label class="expand" for="c-38018462">[4 more]</label></div><br/><div class="children"><div class="content">Well, since random() doesnât depend on anything, it could also just be evaluated once for the whole query and be treated like a constant. But really, this is simply a case of the language semantics being underspecified.</div><br/><div id="38021648" class="c"><input type="checkbox" id="c-38021648" checked=""/><div class="controls bullet"><span class="by">somat</span><span>|</span><a href="#38018462">parent</a><span>|</span><a href="#38019563">next</a><span>|</span><label class="collapse" for="c-38021648">[-]</label><label class="expand" for="c-38021648">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think they should optimize based solely on table access. What the function does matters as well. Now the optimizer either does not know what the function does(it could be modifying rows, who knows?) or, in the specific case of random() it is intentionally different every single call. The only sane thing to do in this case is avoid moving it around trying to optimize it.<p>Now if you could mark a function as &quot;pure&quot;, that is, it&#x27;s outputs are strictly dependent on it&#x27;s inputs, the optimizer would be free to, well, optimize it&#x27;s location.<p>I think this is what postgres is trying to do with it&#x27;s function volatility syntax(volatile, stable, immutable) one of the examples in the article, cockroachdb, has inherited this syntax. but they either drew a different conclusion as to what it means, or they ignore it.</div><br/></div></div><div id="38019563" class="c"><input type="checkbox" id="c-38019563" checked=""/><div class="controls bullet"><span class="by">codeulike</span><span>|</span><a href="#38018462">parent</a><span>|</span><a href="#38021648">prev</a><span>|</span><a href="#38018831">next</a><span>|</span><label class="collapse" for="c-38019563">[-]</label><label class="expand" for="c-38019563">[1 more]</label></div><br/><div class="children"><div class="content">in practice SQL engines will know whether functions are determinsitic or non-deterministic. So with random() it will know it needs to re-evauluate it all the time because its non-deterministic. with left(somecolumn,2) it knows its deterministic so will only re-evaluate it when somecolumn changes</div><br/></div></div><div id="38018831" class="c"><input type="checkbox" id="c-38018831" checked=""/><div class="controls bullet"><span class="by">tantalor</span><span>|</span><a href="#38018462">parent</a><span>|</span><a href="#38019563">prev</a><span>|</span><a href="#38018108">next</a><span>|</span><label class="collapse" for="c-38018831">[-]</label><label class="expand" for="c-38018831">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;xkcd.com&#x2F;221&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;xkcd.com&#x2F;221&#x2F;</a></div><br/></div></div></div></div><div id="38018108" class="c"><input type="checkbox" id="c-38018108" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#38018462">prev</a><span>|</span><label class="collapse" for="c-38018108">[-]</label><label class="expand" for="c-38018108">[19 more]</label></div><br/><div class="children"><div class="content">Interesting investigation. I&#x27;d argue that the SQL query itself is wrong in that the predicate is in no way related to the tables so the entire thing should be rejected.</div><br/><div id="38018733" class="c"><input type="checkbox" id="c-38018733" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#38018108">parent</a><span>|</span><a href="#38018574">next</a><span>|</span><label class="collapse" for="c-38018733">[-]</label><label class="expand" for="c-38018733">[4 more]</label></div><br/><div class="children"><div class="content">Replace<p><pre><code>  random() &lt; 0.5
</code></pre>
by<p><pre><code>  abc.a + random() &lt; abc.a + 0.5
</code></pre>
and you have (almost because of the inexactness of float computations) the same query, but that isnât âin no way related to the tablesâ.<p>Now, that predicate is biased towards table <i>abc</i>, but thatâs correctible:<p><pre><code>  abc.a + def.d + random()
      &lt; abc.a + def.d + 0.5
</code></pre>
If the SQL engine is allowed to ignore the subtleties of floats, it can still prove that in this query the predicate isnât really related to the tables, but it canât do that in general.<p>So, you can change the spec to make the simple cases invalid sql, but that wonât get rid of this problem.</div><br/><div id="38018883" class="c"><input type="checkbox" id="c-38018883" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#38018108">root</a><span>|</span><a href="#38018733">parent</a><span>|</span><a href="#38018574">next</a><span>|</span><label class="collapse" for="c-38018883">[-]</label><label class="expand" for="c-38018883">[3 more]</label></div><br/><div class="children"><div class="content">You are completely correct, but please see below where I acknowledge that half the problem is that a nondeterministic input - the rand() - is the other half. Hopefully by banning nondeterministic functions in predicates, then requiring predicates to be linked to the tables, that should fix it. Good catch, thanks.</div><br/><div id="38021767" class="c"><input type="checkbox" id="c-38021767" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#38018108">root</a><span>|</span><a href="#38018883">parent</a><span>|</span><a href="#38019541">next</a><span>|</span><label class="collapse" for="c-38021767">[-]</label><label class="expand" for="c-38021767">[1 more]</label></div><br/><div class="children"><div class="content">Why shouldn&#x27;t I be able to randomly sample a table? Some common use cases include queues and A&#x2F;B tests.</div><br/></div></div><div id="38019541" class="c"><input type="checkbox" id="c-38019541" checked=""/><div class="controls bullet"><span class="by">chris_wot</span><span>|</span><a href="#38018108">root</a><span>|</span><a href="#38018883">parent</a><span>|</span><a href="#38021767">prev</a><span>|</span><a href="#38018574">next</a><span>|</span><label class="collapse" for="c-38019541">[-]</label><label class="expand" for="c-38019541">[1 more]</label></div><br/><div class="children"><div class="content">Out of curiosity, is there a list of built-in non-deterministic SQL functions?</div><br/></div></div></div></div></div></div><div id="38018574" class="c"><input type="checkbox" id="c-38018574" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#38018108">parent</a><span>|</span><a href="#38018733">prev</a><span>|</span><a href="#38018179">next</a><span>|</span><label class="collapse" for="c-38018574">[-]</label><label class="expand" for="c-38018574">[13 more]</label></div><br/><div class="children"><div class="content">You cannot reject a predicate just because it doesn&#x27;t refer to a table. SELECT * FROM t1 WHERE 2+2=4 is a completely valid query and should be allowed.</div><br/><div id="38018770" class="c"><input type="checkbox" id="c-38018770" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#38018108">root</a><span>|</span><a href="#38018574">parent</a><span>|</span><a href="#38018179">next</a><span>|</span><label class="collapse" for="c-38018770">[-]</label><label class="expand" for="c-38018770">[12 more]</label></div><br/><div class="children"><div class="content">It depends. For what you&#x27;re suggesting, we have the cross join&#x2F;cartesian join. That would be the correct thing to use in this case, not what you&#x27;ve put.<p>But actually you have a point in that half the problem is the predicate is not linked to the tables, but the other half is the predicate is not predictable, after all it is a RAND(). That compounds the issue.</div><br/><div id="38018992" class="c"><input type="checkbox" id="c-38018992" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#38018108">root</a><span>|</span><a href="#38018770">parent</a><span>|</span><a href="#38018179">next</a><span>|</span><label class="collapse" for="c-38018992">[-]</label><label class="expand" for="c-38018992">[11 more]</label></div><br/><div class="children"><div class="content">I have no idea what a Cartesian product would have to do with my query; there&#x27;s only a single table there.<p>&gt; But actually you have a point in that half the problem is the predicate is not linked to the tables<p>No, it really isn&#x27;t a problem at all that the predicate isn&#x27;t linked to the tables. That in itself is entirely legal and unproblematic.</div><br/><div id="38019073" class="c"><input type="checkbox" id="c-38019073" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#38018108">root</a><span>|</span><a href="#38018992">parent</a><span>|</span><a href="#38018179">next</a><span>|</span><label class="collapse" for="c-38019073">[-]</label><label class="expand" for="c-38019073">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;m an idiot sorry about that. Okay, let&#x27;s try again, suppose you wrote<p>SELECT * FROM t1 WHERE 2+2=4<p>Which is semantically identical to<p>SELECT * FROM t1<p>While the first is correct in that it has a semantic meaning and a valid output, wouldn&#x27;t you rather have the system warn you that you&#x27;ve written something redundant? Because it&#x27;s hardly likely a human would write the former if they meant the latter.</div><br/><div id="38019243" class="c"><input type="checkbox" id="c-38019243" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#38018108">root</a><span>|</span><a href="#38019073">parent</a><span>|</span><a href="#38019287">next</a><span>|</span><label class="collapse" for="c-38019243">[-]</label><label class="expand" for="c-38019243">[1 more]</label></div><br/><div class="children"><div class="content">There are _tons_ of SQL queries that involve redundant and&#x2F;or stupid things. A lot of them come from autogenerated queries where the user has nearly zero control over the actual SQL. An optimizer&#x27;s job is to optimize that away, not reject them as âplease be more efficientâ. They are legal queries. All legal queries should be accepted and executed, no matter how silly one may consider them.<p>As an aside, C compilers generally try to give warnings (not errors) on things like this, but need tons of heuristics to distinguish the âobviously wrongâ cases from the ânot obviously wrongâ cases (e.g., those that arose from inlining and&#x2F;or constant folding and&#x2F;or preprocessor expansion and&#x2F;or dead code removal).</div><br/></div></div><div id="38019287" class="c"><input type="checkbox" id="c-38019287" checked=""/><div class="controls bullet"><span class="by">tremon</span><span>|</span><a href="#38018108">root</a><span>|</span><a href="#38019073">parent</a><span>|</span><a href="#38019243">prev</a><span>|</span><a href="#38019538">next</a><span>|</span><label class="collapse" for="c-38019287">[-]</label><label class="expand" for="c-38019287">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not my style, but a previous team would always add a where-clause starting with<p><pre><code>  WHERE 1=1
</code></pre>
Because then any and all query predicates would be nicely aligned on the following lines, like this:<p><pre><code>  WHERE 1=1
      AND t1.col1 = 1
      AND t2.col2 = 1
</code></pre>
(Why they couldn&#x27;t just lower the indent to read<p><pre><code>  WHERE t1.col1 = 1
    AND t2.col2 = 1
</code></pre>
Is beyond me)<p>Point being, don&#x27;t assume that humans will never write an always-true predicate.</div><br/><div id="38022037" class="c"><input type="checkbox" id="c-38022037" checked=""/><div class="controls bullet"><span class="by">ako</span><span>|</span><a href="#38018108">root</a><span>|</span><a href="#38019287">parent</a><span>|</span><a href="#38020116">next</a><span>|</span><label class="collapse" for="c-38022037">[-]</label><label class="expand" for="c-38022037">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27; a common way to implement (faceted) search where the search expressions are dynamic depending on the user input. With this style, if the user wants to search on one or more fields you simply add &quot;and field = :value&quot; and you don&#x27;t have to check if it&#x27;s the first or next search expression.<p>The 1=1 doesn&#x27;t hurt, as it will be removed by the query optimizer anyways.</div><br/></div></div><div id="38020116" class="c"><input type="checkbox" id="c-38020116" checked=""/><div class="controls bullet"><span class="by">lgas</span><span>|</span><a href="#38018108">root</a><span>|</span><a href="#38019287">parent</a><span>|</span><a href="#38022037">prev</a><span>|</span><a href="#38020802">next</a><span>|</span><label class="collapse" for="c-38020116">[-]</label><label class="expand" for="c-38020116">[2 more]</label></div><br/><div class="children"><div class="content">Presumably it&#x27;s to make copy&#x2F;pasting or otherwise adding&#x2F;removing entries easy.  In the latter case you have to muck about with WHERE vs AND if you modify the top entry whereas if the immediate condition after WHERE is 1=1 then all the real conditions take on the identical form of &#x27;AND x&#x27; which can be copy&#x2F;pasted, reordered, etc without complications.</div><br/><div id="38020216" class="c"><input type="checkbox" id="c-38020216" checked=""/><div class="controls bullet"><span class="by">throwaway201606</span><span>|</span><a href="#38018108">root</a><span>|</span><a href="#38020116">parent</a><span>|</span><a href="#38020802">next</a><span>|</span><label class="collapse" for="c-38020216">[-]</label><label class="expand" for="c-38020216">[1 more]</label></div><br/><div class="children"><div class="content">100% this: part of this crew.<p>I have, over the course of my career, found that the teams that tend to do this are pure-SQL teams ie in DB developers who spend all their time writing - and more importantly - reading SQL. Doing this actually removes a lot of debugging and code-fixing friction</div><br/></div></div></div></div><div id="38020802" class="c"><input type="checkbox" id="c-38020802" checked=""/><div class="controls bullet"><span class="by">porridgeraisin</span><span>|</span><a href="#38018108">root</a><span>|</span><a href="#38019287">parent</a><span>|</span><a href="#38020116">prev</a><span>|</span><a href="#38019538">next</a><span>|</span><label class="collapse" for="c-38020802">[-]</label><label class="expand" for="c-38020802">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also useful to build a query string with where clauses appearing conditionally.<p><pre><code>  where_clause = &quot;where 1=1&quot;
  if video.nsfw:
      where_clause += &quot; and age &gt; 18&quot;
  if whatever:
      where_clause += &quot; and whatever&quot;
  
  query = &quot;select * from user {where_clause}&quot;</code></pre></div><br/></div></div></div></div><div id="38019538" class="c"><input type="checkbox" id="c-38019538" checked=""/><div class="controls bullet"><span class="by">codeulike</span><span>|</span><a href="#38018108">root</a><span>|</span><a href="#38019073">parent</a><span>|</span><a href="#38019287">prev</a><span>|</span><a href="#38018179">next</a><span>|</span><label class="collapse" for="c-38019538">[-]</label><label class="expand" for="c-38019538">[3 more]</label></div><br/><div class="children"><div class="content">suprisingly often in real situations when I just want to get the columns of a table with no data I have done<p>select * from table where (1=0)</div><br/><div id="38020123" class="c"><input type="checkbox" id="c-38020123" checked=""/><div class="controls bullet"><span class="by">lgas</span><span>|</span><a href="#38018108">root</a><span>|</span><a href="#38019538">parent</a><span>|</span><a href="#38018179">next</a><span>|</span><label class="collapse" for="c-38020123">[-]</label><label class="expand" for="c-38020123">[2 more]</label></div><br/><div class="children"><div class="content">why not just `select * from table where false` ?</div><br/><div id="38020805" class="c"><input type="checkbox" id="c-38020805" checked=""/><div class="controls bullet"><span class="by">sixbrx</span><span>|</span><a href="#38018108">root</a><span>|</span><a href="#38020123">parent</a><span>|</span><a href="#38018179">next</a><span>|</span><label class="collapse" for="c-38020805">[-]</label><label class="expand" for="c-38020805">[1 more]</label></div><br/><div class="children"><div class="content">some databases such as Oracle do not support boolean literals or boolean at all  as a user accessible type</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="38018179" class="c"><input type="checkbox" id="c-38018179" checked=""/><div class="controls bullet"><span class="by">progmetaldev</span><span>|</span><a href="#38018108">parent</a><span>|</span><a href="#38018574">prev</a><span>|</span><label class="collapse" for="c-38018179">[-]</label><label class="expand" for="c-38018179">[1 more]</label></div><br/><div class="children"><div class="content">I think that would probably be best, unless this type of thing is well documented (although I don&#x27;t see it entering ANSI SQL).</div><br/></div></div></div></div></div></div></div></div></div></body></html>