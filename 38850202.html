<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704272454178" as="style"/><link rel="stylesheet" href="styles.css?v=1704272454178"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://cachemon.github.io/SIEVE-website/blog/2023/12/17/sieve-is-simpler-than-lru/">Sieve is simpler than LRU</a> <span class="domain">(<a href="https://cachemon.github.io">cachemon.github.io</a>)</span></div><div class="subtext"><span>SerCe</span> | <span>23 comments</span></div><br/><div><div id="38852073" class="c"><input type="checkbox" id="c-38852073" checked=""/><div class="controls bullet"><span class="by">Sandworm5639</span><span>|</span><a href="#38851641">next</a><span>|</span><label class="collapse" for="c-38852073">[-]</label><label class="expand" for="c-38852073">[1 more]</label></div><br/><div class="children"><div class="content">Why call it &quot;FIFO queue&quot;(isn&#x27;t it just stack?) when actually you need to remove elements from the middle?<p>Also I think you could do away with storing &quot;prev&quot; for each node and make it like std::forward_list(with some additional work during eviction).<p>&gt; We pushed SIEVE a bit further by letting it peek into the future – well, sort of. We tested how well it could guess the next request. It turns out, with this extra bit of foresight, SIEVE is nailing it, outperforming the rest in almost all scenarios.<p>No idea what they mean here.</div><br/></div></div><div id="38851641" class="c"><input type="checkbox" id="c-38851641" checked=""/><div class="controls bullet"><span class="by">blt</span><span>|</span><a href="#38852073">prev</a><span>|</span><a href="#38851896">next</a><span>|</span><label class="collapse" for="c-38851641">[-]</label><label class="expand" for="c-38851641">[3 more]</label></div><br/><div class="children"><div class="content"><i>SIEVE isn&#x27;t just playing the part of a cache eviction algorithm; it&#x27;s stepping up as a cache design superstar. Think of it like giving a fresh spin to classics.</i><p>Is this how academics write about their own work in blog posts now?<p>The result seems really strong. It&#x27;s sad the author feels this kind of hype is necessary.</div><br/><div id="38851842" class="c"><input type="checkbox" id="c-38851842" checked=""/><div class="controls bullet"><span class="by">falsandtru</span><span>|</span><a href="#38851641">parent</a><span>|</span><a href="#38851715">next</a><span>|</span><label class="collapse" for="c-38851842">[-]</label><label class="expand" for="c-38851842">[1 more]</label></div><br/><div class="children"><div class="content">Recent hype cache algorithms are characterized by cherry-picking hit rates in content caching such as CDNs. Common cache algorithms such as ARC, LIRS, and TinyLFU have made consistent and common comparisons across a variety of disk access patterns, but hype cache algorithms boast hit&#x2F;miss rates for network accesses without these comparisons. Hype cache algorithms have only been validated in a very narrow domain, and their general superiority has not been validated at all.</div><br/></div></div><div id="38851715" class="c"><input type="checkbox" id="c-38851715" checked=""/><div class="controls bullet"><span class="by">lstamour</span><span>|</span><a href="#38851641">parent</a><span>|</span><a href="#38851842">prev</a><span>|</span><a href="#38851896">next</a><span>|</span><label class="collapse" for="c-38851715">[-]</label><label class="expand" for="c-38851715">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t read the original article yet but your excerpt here reminds me strongly of what ChatGPT writes when you ask it to rewrite technical prose in an approachable, non-technical &quot;for dummies&quot; style.<p>As in, I asked ChatGPT to rewrite some text with metaphors and it kept giving me answers that included the phrase &quot;Think of it like....&quot; And whatever the metaphor it came up with was. It also often used words like &quot;superstar&quot; far more than I would.</div><br/></div></div></div></div><div id="38851896" class="c"><input type="checkbox" id="c-38851896" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#38851641">prev</a><span>|</span><a href="#38851823">next</a><span>|</span><label class="collapse" for="c-38851896">[-]</label><label class="expand" for="c-38851896">[1 more]</label></div><br/><div class="children"><div class="content">From the look of it, it seems like this really doesn&#x27;t like frequently accessed items being close by, as they probably get evicted the first time there is a cache miss on the currently-pointed item (but anyway end up further down the array which would mitigate the problem the second time around)<p>Which also means, this does not perform well at all with very high hit rates. A dumb LRU cache might perform better if you can fit most of your items in the cache.<p>In any case, seems simple enough, but very unintuitive compared to a LRU algorithm which makes obvious sense. It is really hard on paper, without looking at actual numbers, to tell how this would be better than LRU.</div><br/></div></div><div id="38851823" class="c"><input type="checkbox" id="c-38851823" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#38851896">prev</a><span>|</span><a href="#38851790">next</a><span>|</span><label class="collapse" for="c-38851823">[-]</label><label class="expand" for="c-38851823">[1 more]</label></div><br/><div class="children"><div class="content">LRU makes sense to me, so that is what I use.<p>The fact that some algos outperform it on some distributions (which might or might not be relevant to the use cases I might face) isn&#x27;t good enough to convince me to switch.</div><br/></div></div><div id="38851790" class="c"><input type="checkbox" id="c-38851790" checked=""/><div class="controls bullet"><span class="by">tommiegannert</span><span>|</span><a href="#38851823">prev</a><span>|</span><a href="#38851886">next</a><span>|</span><label class="collapse" for="c-38851790">[-]</label><label class="expand" for="c-38851790">[4 more]</label></div><br/><div class="children"><div class="content">Replaced the linked list with a Python list, for clarity: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;tommie&#x2F;577b4e154731a280136295180211e953" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;tommie&#x2F;577b4e154731a280136295180211e...</a> (and I hope I got it right)<p>Since this is using a 1-bit visited counter, a small cache could use a bit vector and bit shifting to &quot;remove&quot; a value from the queue.</div><br/><div id="38852043" class="c"><input type="checkbox" id="c-38852043" checked=""/><div class="controls bullet"><span class="by">ianbicking</span><span>|</span><a href="#38851790">parent</a><span>|</span><a href="#38851888">next</a><span>|</span><label class="collapse" for="c-38852043">[-]</label><label class="expand" for="c-38852043">[1 more]</label></div><br/><div class="children"><div class="content">Python&#x27;s ordered dict uses an efficient linked list implementation, it might be elegant here?</div><br/></div></div><div id="38851888" class="c"><input type="checkbox" id="c-38851888" checked=""/><div class="controls bullet"><span class="by">falserum</span><span>|</span><a href="#38851790">parent</a><span>|</span><a href="#38852043">prev</a><span>|</span><a href="#38851886">next</a><span>|</span><label class="collapse" for="c-38851888">[-]</label><label class="expand" for="c-38851888">[2 more]</label></div><br/><div class="children"><div class="content">Python list is backed by array. So removing an element from the middle of list is costly. (I assume this was the reason for linked list usage in original version)</div><br/><div id="38851992" class="c"><input type="checkbox" id="c-38851992" checked=""/><div class="controls bullet"><span class="by">tommiegannert</span><span>|</span><a href="#38851790">root</a><span>|</span><a href="#38851888">parent</a><span>|</span><a href="#38851886">next</a><span>|</span><label class="collapse" for="c-38851992">[-]</label><label class="expand" for="c-38851992">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, but this is clearer to read.</div><br/></div></div></div></div></div></div><div id="38851886" class="c"><input type="checkbox" id="c-38851886" checked=""/><div class="controls bullet"><span class="by">latch</span><span>|</span><a href="#38851790">prev</a><span>|</span><a href="#38851718">next</a><span>|</span><label class="collapse" for="c-38851886">[-]</label><label class="expand" for="c-38851886">[1 more]</label></div><br/><div class="children"><div class="content">I feel like a simple improvement to LRU is to not promote on every fetch. This adds some frequency bias into the mix and reduces the need to synchronize between threads. Is this a known&#x2F;used technique?</div><br/></div></div><div id="38851660" class="c"><input type="checkbox" id="c-38851660" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38851718">prev</a><span>|</span><a href="#38851680">next</a><span>|</span><label class="collapse" for="c-38851660">[-]</label><label class="expand" for="c-38851660">[3 more]</label></div><br/><div class="children"><div class="content">There is obviously a LRU-like element in the algorithm because<p>1. Evacuation generally shifts items to the right.<p>2. The Hand moves to the left.<p>3. Items skipped by the Hand (appearing to its right) are spared from eviction until the Hand wraps around.<p>You can see it in the animation. D is flipped to visited just in the nick of time, and the Hand moves over it. Then it is spared from then on until the Hand wraps around (the animation doesn&#x27;t go that far). Items that are used frequently will tend to be in the Visited state when the Hand passes over them, and stay cached.</div><br/><div id="38851793" class="c"><input type="checkbox" id="c-38851793" checked=""/><div class="controls bullet"><span class="by">cryptonym</span><span>|</span><a href="#38851660">parent</a><span>|</span><a href="#38851680">next</a><span>|</span><label class="collapse" for="c-38851793">[-]</label><label class="expand" for="c-38851793">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand why D is NOT switched to false when the hand moves left and removes E. At the beginning A is switched to false when the hand moves left over it.</div><br/><div id="38851874" class="c"><input type="checkbox" id="c-38851874" checked=""/><div class="controls bullet"><span class="by">joaomacp</span><span>|</span><a href="#38851660">root</a><span>|</span><a href="#38851793">parent</a><span>|</span><a href="#38851680">next</a><span>|</span><label class="collapse" for="c-38851874">[-]</label><label class="expand" for="c-38851874">[1 more]</label></div><br/><div class="children"><div class="content">I watched it again and read the algorithm description part, and I think you&#x27;re right - D should have been switched to false, as the hand was pointing to it when a cache miss happened.</div><br/></div></div></div></div></div></div><div id="38851680" class="c"><input type="checkbox" id="c-38851680" checked=""/><div class="controls bullet"><span class="by">nsajko</span><span>|</span><a href="#38851660">prev</a><span>|</span><a href="#38851663">next</a><span>|</span><label class="collapse" for="c-38851680">[-]</label><label class="expand" for="c-38851680">[1 more]</label></div><br/><div class="children"><div class="content">Context: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cache_replacement_policies" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cache_replacement_policies</a></div><br/></div></div><div id="38851663" class="c"><input type="checkbox" id="c-38851663" checked=""/><div class="controls bullet"><span class="by">hknmtt</span><span>|</span><a href="#38851680">prev</a><span>|</span><label class="collapse" for="c-38851663">[-]</label><label class="expand" for="c-38851663">[6 more]</label></div><br/><div class="children"><div class="content">&gt;On a cache hit, SIEVE marks the object as visited. On a cache miss, SIEVE checks the object pointed to by the hand. If the object has been visited, its visited bit is reset, and the hand moves to the next position, keeping the retained object in its original position in the queue. This continues until an unvisited object is found and evicted. After eviction, the hand moves to the next position.<p>Dude, what?</div><br/><div id="38851816" class="c"><input type="checkbox" id="c-38851816" checked=""/><div class="controls bullet"><span class="by">Epa095</span><span>|</span><a href="#38851663">parent</a><span>|</span><a href="#38851835">next</a><span>|</span><label class="collapse" for="c-38851816">[-]</label><label class="expand" for="c-38851816">[2 more]</label></div><br/><div class="children"><div class="content">Maybe it&#x27;s a bit odd that it resets the &#x27;visited&#x27; bit on non-related objects (why are they suddenly not visited)?<p>For me it helped to rather think about &#x27;visited&#x27; as a special case of a counter called &#x27;valuation&#x27; (or something like that). New objects come in with valuation 1, on cache hits a objects valuation is set to 2, and when the hand moves left it decreases objects valuations until it reaches one that gets valuation 0, then it&#x27;s evicted immediately. One could easily imagine a modified algorithm where &#x27;valuation&#x27; could be increased further than 2 if an object got visited many times (but then eviction would be much slower in some cases).<p>Then this is all optimized by using a bool instead of an int since we truncate &#x27;valuation&#x27; at max 2.<p>Idk why they choose to call it &#x27;visited&#x27; though.</div><br/><div id="38852035" class="c"><input type="checkbox" id="c-38852035" checked=""/><div class="controls bullet"><span class="by">vidarh</span><span>|</span><a href="#38851663">root</a><span>|</span><a href="#38851816">parent</a><span>|</span><a href="#38851835">next</a><span>|</span><label class="collapse" for="c-38852035">[-]</label><label class="expand" for="c-38852035">[1 more]</label></div><br/><div class="children"><div class="content">What &quot;visited&quot; really denotes is &quot;accessed since the last time the hand reached this node&quot;.</div><br/></div></div></div></div><div id="38851835" class="c"><input type="checkbox" id="c-38851835" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#38851663">parent</a><span>|</span><a href="#38851816">prev</a><span>|</span><a href="#38851795">next</a><span>|</span><label class="collapse" for="c-38851835">[-]</label><label class="expand" for="c-38851835">[1 more]</label></div><br/><div class="children"><div class="content">Yahoo has (or had) a very similar &#x27;cache&#x27; for tracking abuse (ydod). As I recall it was patented, but I can&#x27;t find the patent to confirm it has expired.<p>Really handy for tracking potentially abusive ips, if your table is big enough; on a request, check if it&#x27;s in the table - if so increase the count and if it&#x27;s above the theshold mark it. If it&#x27;s not in the list, decrement the current item and move current to the next item.<p>An agressive user will clear out a slot for itself, and rapidly hit the threshold. Other users will come and go. You can iterate through and try to always clear a spot for a new entry, but it might not be necessary, depending on what you&#x27;re caching.</div><br/></div></div><div id="38851795" class="c"><input type="checkbox" id="c-38851795" checked=""/><div class="controls bullet"><span class="by">vidarh</span><span>|</span><a href="#38851663">parent</a><span>|</span><a href="#38851835">prev</a><span>|</span><a href="#38851735">next</a><span>|</span><label class="collapse" for="c-38851795">[-]</label><label class="expand" for="c-38851795">[1 more]</label></div><br/><div class="children"><div class="content">Look at the animation. The description is confusing.<p>It uses a list that&#x27;s treated as a ring buffer to keep track of keys currently in the cache.<p>The &quot;hand&quot; is a pointer that points to a given node in that ring buffer.<p>When the cache is full and a space is needed, the &quot;hand&quot; moves through that buffer (possibly wrapping around). Whenever it points at a node that hasn&#x27;t been touched since the last time it was seen, that node is evicted and you&#x27;re done for this time, otherwise it <i>clears the visited bit</i> for that node and keeps going.<p>(You&#x27;re always guaranteed to find a node to evict, because worst case you scan through the entire set of nodes, and find the first node you cleared the visited bit of)</div><br/></div></div><div id="38851735" class="c"><input type="checkbox" id="c-38851735" checked=""/><div class="controls bullet"><span class="by">echelon</span><span>|</span><a href="#38851663">parent</a><span>|</span><a href="#38851795">prev</a><span>|</span><label class="collapse" for="c-38851735">[-]</label><label class="expand" for="c-38851735">[1 more]</label></div><br/><div class="children"><div class="content">The hand is a pointer on the queue to the current cache item being inspected. The cache miss eviction behavior depends on if the pointed to element is marked as visited.<p>If you&#x27;re familiar with LRU&#x2F;LFU, ring buffers (though this isn&#x27;t such), and data structures this will probably make a lot more sense.<p>A rigorous course in data structures is fantastic for any engineer. Everything is data structures and algorithms at the end of the day.</div><br/></div></div></div></div></div></div></div></div></div></body></html>