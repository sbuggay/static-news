<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1727946065570" as="style"/><link rel="stylesheet" href="styles.css?v=1727946065570"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://eaftan.github.io/hash-ordering/">Hash Ordering and Hyrum&#x27;s Law</a> <span class="domain">(<a href="https://eaftan.github.io">eaftan.github.io</a>)</span></div><div class="subtext"><span>ColinWright</span> | <span>23 comments</span></div><br/><div><div id="41726064" class="c"><input type="checkbox" id="c-41726064" checked=""/><div class="controls bullet"><span class="by">smarks</span><span>|</span><a href="#41723634">next</a><span>|</span><label class="collapse" for="c-41726064">[-]</label><label class="expand" for="c-41726064">[4 more]</label></div><br/><div class="children"><div class="content">(from Feb 2021)<p>Some of the JDK&#x27;s unmodifiable collections, such as those from `Set.of()` and `Map.of()`, also randomize iteration order. At the time they were added, Go and Python also randomized iteration order. However, more recently, Python moved away from randomization. Early in the Python 3.x releases, dict iteration order was randomized. In 3.6, iteration order was insertion order, but only as an implementation detail. In 3.7, this was elevated to a guarantee.<p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;stdtypes.html#dict" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;stdtypes.html#dict</a><p>(search for &quot;dictionary order&quot;)<p>There are occasional complaints about Java&#x27;s unmodifiable collections&#x27; randomized order, as it can occasionally cause intermittent test failures or even failures in production. However, the advantage of the randomized order is that we&#x27;ve been able to reorganize the internal implementations of these data structures -- twice -- without worrying about compatibility problems caused by changing the ordering. Historically this has been a problem with other structures such as `HashMap`. Even though HashMap&#x27;s order isn&#x27;t guaranteed, it&#x27;s predictable and stable, and changing its ordering has definitely flushed out bugs.</div><br/><div id="41726597" class="c"><input type="checkbox" id="c-41726597" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41726064">parent</a><span>|</span><a href="#41723634">next</a><span>|</span><label class="collapse" for="c-41726597">[-]</label><label class="expand" for="c-41726597">[3 more]</label></div><br/><div class="children"><div class="content">IMO the <i>real</i> problem is that sometimes you really <i>do</i> want a deterministic order (not caring which one), but the container doesn&#x27;t offer <i>any</i> API that provides it.<p>And since hash-first languages provide a broken API, there&#x27;s no way to provide it for arbitrary types. Compare-first languages (like C++) generally provide it, but paying the price of tree-based structures (assuming a B-tree can&#x27;t negate it) isn&#x27;t actually necessary.<p>Rather than either of those choices, I argue that languages really should be &quot;key-first&quot; - rather than having classes implement hashing or comparison themselves, they should return a tuple of the data that will be fed into said hash or comparison. Besides being a nicer API, this also prevents many common bugs.</div><br/><div id="41728281" class="c"><input type="checkbox" id="c-41728281" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41726064">root</a><span>|</span><a href="#41726597">parent</a><span>|</span><a href="#41723634">next</a><span>|</span><label class="collapse" for="c-41728281">[-]</label><label class="expand" for="c-41728281">[2 more]</label></div><br/><div class="children"><div class="content">&gt; IMO the real problem is that sometimes you really do want a deterministic order (not caring which one), but the container doesn&#x27;t offer any API that provides it.<p>This would be a lot more convincing if you had an actual concrete example where this was true, rather than just insisting that &quot;sometimes&quot; it&#x27;s true.</div><br/><div id="41728588" class="c"><input type="checkbox" id="c-41728588" checked=""/><div class="controls bullet"><span class="by">alexhornby</span><span>|</span><a href="#41726064">root</a><span>|</span><a href="#41728281">parent</a><span>|</span><a href="#41723634">next</a><span>|</span><label class="collapse" for="c-41728588">[-]</label><label class="expand" for="c-41728588">[1 more]</label></div><br/><div class="children"><div class="content">Few examples I’ve come across: hashing, float summation, reproducible serialisation</div><br/></div></div></div></div></div></div></div></div><div id="41723634" class="c"><input type="checkbox" id="c-41723634" checked=""/><div class="controls bullet"><span class="by">jbandela1</span><span>|</span><a href="#41726064">prev</a><span>|</span><a href="#41727804">next</a><span>|</span><label class="collapse" for="c-41723634">[-]</label><label class="expand" for="c-41723634">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ncHmEUmJZf4" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ncHmEUmJZf4</a><p>Is a fun presentation by Matthew Kulukundis (designer of Google&#x27;s Hash Table) with Hyrum Wright offering objections from the crowd (Hyrum&#x27;s law) about the design and rollout of it at Google</div><br/></div></div><div id="41727804" class="c"><input type="checkbox" id="c-41727804" checked=""/><div class="controls bullet"><span class="by">mseepgood</span><span>|</span><a href="#41723634">prev</a><span>|</span><a href="#41724298">next</a><span>|</span><label class="collapse" for="c-41727804">[-]</label><label class="expand" for="c-41727804">[1 more]</label></div><br/><div class="children"><div class="content">Just don&#x27;t make it uniformly distributed random, otherwise people will depend on it as a random number generator, what you don&#x27;t want either.</div><br/></div></div><div id="41724298" class="c"><input type="checkbox" id="c-41724298" checked=""/><div class="controls bullet"><span class="by">lsy</span><span>|</span><a href="#41727804">prev</a><span>|</span><a href="#41726901">next</a><span>|</span><label class="collapse" for="c-41724298">[-]</label><label class="expand" for="c-41724298">[10 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the advantage of specifying it as random over specifying it as sequential in some way? Aren&#x27;t both just specifying a behavior, where one behavior is potentially more useful than the other? I guess I understand the principled point that a set of hash keys is not an array. But it seems like more complexity than is necessary, and even possible to fall victim to Hyrum&#x27;s law besides… you can imagine someone using random hash ordering to implicitly randomize something without needing to call an RNG explicitly.<p>It seems like the most principled approach might be an re-specification of the data structure: why is &quot;iteration&quot; even possible over a hash table? Shouldn&#x27;t the keys be specified as a &quot;set&quot; on which only set-appropriate operations like map can be performed?</div><br/><div id="41725484" class="c"><input type="checkbox" id="c-41725484" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#41724298">parent</a><span>|</span><a href="#41726554">next</a><span>|</span><label class="collapse" for="c-41725484">[-]</label><label class="expand" for="c-41725484">[6 more]</label></div><br/><div class="children"><div class="content">One advantage to randomization, and why various languages did it in the first place, is that it prevents miscreants from DoSing your service if they know its implementation.<p>Say you&#x27;re operating a service and you share its source on GitHub such that anyone can see it. Your language doesn&#x27;t randomize hash values. Hashes are O(1), right? Well, not if a clever attacker can send you a set of values where they know each one will hash into the same bucket. The you end up with like 9 empty buckets and 1 with 100,000 items in it. Oops!<p>Old Python pre-randomization had a dict.items() method that would yield all the keys in order, conceptually kind of like:<p><pre><code>  for bucket in self._buckets:
      for item in bucket:
          yield item
</code></pre>
The order of those buckets would be repeatable between runs, so bucket foo would always come first, then bucket bar. Then Python added hash randomization so that the resulting hash key was something like hash(salt+key) instead of just hash(key). Now there&#x27;s no way to tell in advance which bucket an item would get filed into, and the buckets would end up more or less balanced in size.<p>Newer Pythons (since 3.6? 3.7?) do something altogether different, and I can&#x27;t explain exactly how their ordered dicts work, except to say I sat through a presentation on them and thought it was freaking genius even if I could re-implement it myself without sitting down with their docs.</div><br/><div id="41725711" class="c"><input type="checkbox" id="c-41725711" checked=""/><div class="controls bullet"><span class="by">quelltext</span><span>|</span><a href="#41724298">root</a><span>|</span><a href="#41725484">parent</a><span>|</span><a href="#41727200">next</a><span>|</span><label class="collapse" for="c-41725711">[-]</label><label class="expand" for="c-41725711">[4 more]</label></div><br/><div class="children"><div class="content">&gt; and I can&#x27;t explain exactly how their ordered dicts work<p>Traditionally you simply use a doubly linked list approach on the entries (each entry maintains two additional references to the previous and next entry) for that like LinkedHashMap: <a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;LinkedHashMap.html" rel="nofollow">https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;LinkedH...</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;openjdk-mirror&#x2F;jdk7u-jdk&#x2F;blob&#x2F;master&#x2F;src&#x2F;share&#x2F;classes&#x2F;java&#x2F;util&#x2F;LinkedHashMap.java#L318">https:&#x2F;&#x2F;github.com&#x2F;openjdk-mirror&#x2F;jdk7u-jdk&#x2F;blob&#x2F;master&#x2F;src&#x2F;...</a><p>Which is also what Python seems to be doing: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;34496644" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;34496644</a><p>It&#x27;s fairly intuitive.<p>Do their new default (now also ordered?) dics do this differently?</div><br/><div id="41726313" class="c"><input type="checkbox" id="c-41726313" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#41724298">root</a><span>|</span><a href="#41725711">parent</a><span>|</span><a href="#41727200">next</a><span>|</span><label class="collapse" for="c-41726313">[-]</label><label class="expand" for="c-41726313">[3 more]</label></div><br/><div class="children"><div class="content">Note that OrderedDict is an implementation in Python. CPython&#x27;s dict has a different implementation. There&#x27;s more about it at <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3.6&#x2F;whatsnew&#x2F;3.6.html#new-dict-implementation" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3.6&#x2F;whatsnew&#x2F;3.6.html#new-dict-imple...</a> and <a href="https:&#x2F;&#x2F;mail.python.org&#x2F;pipermail&#x2F;python-dev&#x2F;2012-December&#x2F;123028.html" rel="nofollow">https:&#x2F;&#x2F;mail.python.org&#x2F;pipermail&#x2F;python-dev&#x2F;2012-December&#x2F;1...</a> .</div><br/><div id="41726704" class="c"><input type="checkbox" id="c-41726704" checked=""/><div class="controls bullet"><span class="by">quelltext</span><span>|</span><a href="#41724298">root</a><span>|</span><a href="#41726313">parent</a><span>|</span><a href="#41727200">next</a><span>|</span><label class="collapse" for="c-41726704">[-]</label><label class="expand" for="c-41726704">[2 more]</label></div><br/><div class="children"><div class="content">This implementation was used from 3.6, right?<p>It&#x27;s interesting that the idea mail mentions that nothing changes about the implementation (including order) but the memory layout. Which would imply insertion order was already preserved in older versions (not the case IIRC) or the idea underwent a few more changes that did in fact impact order.<p>EDIT: I couldn&#x27;t quite find an answer but <a href="https:&#x2F;&#x2F;softwaremaniacs.org&#x2F;blog&#x2F;2020&#x2F;02&#x2F;05&#x2F;dicts-ordered&#x2F;" rel="nofollow">https:&#x2F;&#x2F;softwaremaniacs.org&#x2F;blog&#x2F;2020&#x2F;02&#x2F;05&#x2F;dicts-ordered&#x2F;</a> mentions the behavior happens since then because the implementation only tracks indices in the hash table itself and relies on maintaining entries separately in a second array that gets expanded in insertion order.<p>This would also seem straightforward but it raises a few questions such as how deletion is implemented (efficiently).<p>EDIT2: Okay, the talk (<a href="https:&#x2F;&#x2F;youtu.be&#x2F;p33CVV29OG8" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;p33CVV29OG8</a>) mentions they just leave holes until the next resize (at around 42:00).<p>Raymond also mentions there that his original idea didn&#x27;t preserve ordering but happened due to an additional compacting optimization? Should probably watch the whole thing some time to get the history. Sounds like a fun talk.</div><br/><div id="41727325" class="c"><input type="checkbox" id="c-41727325" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#41724298">root</a><span>|</span><a href="#41726704">parent</a><span>|</span><a href="#41727200">next</a><span>|</span><label class="collapse" for="c-41727325">[-]</label><label class="expand" for="c-41727325">[1 more]</label></div><br/><div class="children"><div class="content">Oh! Yeah, that was the talk, but repeated at PyCon. It’s a very clever design that wasn’t at all obvious to me.</div><br/></div></div></div></div></div></div></div></div><div id="41727200" class="c"><input type="checkbox" id="c-41727200" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41724298">root</a><span>|</span><a href="#41725484">parent</a><span>|</span><a href="#41725711">prev</a><span>|</span><a href="#41726554">next</a><span>|</span><label class="collapse" for="c-41727200">[-]</label><label class="expand" for="c-41727200">[1 more]</label></div><br/><div class="children"><div class="content">Note that this relies on all the <i>object classes</i> having correct hash implementation (which is actually quite difficult); it&#x27;s not <i>really</i> a property of the container.<p>That said, the attack is almost always on builtin types, so ...</div><br/></div></div></div></div><div id="41726554" class="c"><input type="checkbox" id="c-41726554" checked=""/><div class="controls bullet"><span class="by">prattmic</span><span>|</span><a href="#41724298">parent</a><span>|</span><a href="#41725484">prev</a><span>|</span><a href="#41724389">next</a><span>|</span><label class="collapse" for="c-41726554">[-]</label><label class="expand" for="c-41726554">[1 more]</label></div><br/><div class="children"><div class="content">In addition to the DoS aspect mentioned in a sibling comment, the primary reason you would do this is to avoid constraining the implementation. If you want to change the design to improve performance, for example, being forced to match the implicit ordering of the old implementation may be very difficult.<p>It certainly may be useful to define an specific ordering. Maps ordered by insertion time and maps ordered by key order are fairly common. But maps with these constraints probably won&#x27;t be as fast as those with arbitrary ordering, so there is a trade-off decision to be made. A map constrained to the arbitrary ordering of the initial implementation is the worst of both worlds: difficult to make faster despite not having a particularly useful ordering.<p>As a concrete example, I am currently in the middle of rewriting Go&#x27;s map implementation to use a more efficient design (<a href="https:&#x2F;&#x2F;go.dev&#x2F;issue&#x2F;54766" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;issue&#x2F;54766</a>). If Go hadn&#x27;t randomized map iteration order this work would likely be impossible. It is unlikely we could completely change the design while keeping iteration order identical to the old implementation (assuming we want the new version to be faster at least).</div><br/></div></div><div id="41724389" class="c"><input type="checkbox" id="c-41724389" checked=""/><div class="controls bullet"><span class="by">fwip</span><span>|</span><a href="#41724298">parent</a><span>|</span><a href="#41726554">prev</a><span>|</span><a href="#41726901">next</a><span>|</span><label class="collapse" for="c-41724389">[-]</label><label class="expand" for="c-41724389">[2 more]</label></div><br/><div class="children"><div class="content">I think removing methods from the Hashmap was not in scope for their work - they were working on the JDK, and presumably didn&#x27;t have the bandwidth to patch every single Java library used at Google to use set-based methods instead of iteration-based.<p>Also, I think in practice you&#x27;ll find you want to extract items from a set in some order, so you need some kind of transformation from set-&gt;list. e.g: you want to print them out.<p>Edit: Forgot to address your main question. If the specification requires a specific ordering, the implementation is forever bound to do that, even if other implementations would be more efficient&#x2F;secure&#x2F;other-desirable-properties. By introducing randomness, you reduce the risk of people accidentally relying on unspecified behavior, and are more able to change your implementation later.</div><br/><div id="41725981" class="c"><input type="checkbox" id="c-41725981" checked=""/><div class="controls bullet"><span class="by">zanecodes</span><span>|</span><a href="#41724298">root</a><span>|</span><a href="#41724389">parent</a><span>|</span><a href="#41726901">next</a><span>|</span><label class="collapse" for="c-41725981">[-]</label><label class="expand" for="c-41725981">[1 more]</label></div><br/><div class="children"><div class="content">One solution could be adding a `sort` argument (which takes a function that compares two `&lt;T&gt;` items and returns `true` or `false` depending on their order) to all functions on unordered collections of `&lt;T&gt;` items in which an order must be chosen, or requiring that the items in such collections implement a `TotalOrder` interface or something similar. This isn&#x27;t very ergonomic in languages that don&#x27;t have an equivalent of Traits or typeclasses though. In languages which permit side effects, this would include any functions that iterate over the items in an unordered collection.</div><br/></div></div></div></div></div></div><div id="41726901" class="c"><input type="checkbox" id="c-41726901" checked=""/><div class="controls bullet"><span class="by">stygiansonic</span><span>|</span><a href="#41724298">prev</a><span>|</span><a href="#41727600">next</a><span>|</span><label class="collapse" for="c-41726901">[-]</label><label class="expand" for="c-41726901">[1 more]</label></div><br/><div class="children"><div class="content">I wrote about something similar, which was motivated by an issue I saw caused by an (incorrect) expectation that a Java hashmap iteration order would be random: <a href="https:&#x2F;&#x2F;peterchng.com&#x2F;blog&#x2F;2022&#x2F;06&#x2F;17&#x2F;what-iteration-order-can-you-expect-from-a-java-hashmap&#x2F;" rel="nofollow">https:&#x2F;&#x2F;peterchng.com&#x2F;blog&#x2F;2022&#x2F;06&#x2F;17&#x2F;what-iteration-order-c...</a></div><br/></div></div><div id="41727600" class="c"><input type="checkbox" id="c-41727600" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#41726901">prev</a><span>|</span><a href="#41724544">next</a><span>|</span><label class="collapse" for="c-41727600">[-]</label><label class="expand" for="c-41727600">[1 more]</label></div><br/><div class="children"><div class="content">Shades of Rusty&#x27;s API Design Manifesto.</div><br/></div></div><div id="41724544" class="c"><input type="checkbox" id="c-41724544" checked=""/><div class="controls bullet"><span class="by">hoistbypetard</span><span>|</span><a href="#41727600">prev</a><span>|</span><a href="#41723764">next</a><span>|</span><label class="collapse" for="c-41724544">[-]</label><label class="expand" for="c-41724544">[1 more]</label></div><br/><div class="children"><div class="content">Relevant XKCD:<p><a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1172&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;1172&#x2F;</a></div><br/></div></div><div id="41723764" class="c"><input type="checkbox" id="c-41723764" checked=""/><div class="controls bullet"><span class="by">ljnelson</span><span>|</span><a href="#41724544">prev</a><span>|</span><a href="#41723403">next</a><span>|</span><label class="collapse" for="c-41723764">[-]</label><label class="expand" for="c-41723764">[1 more]</label></div><br/><div class="children"><div class="content">Interesting note: the JDK deliberately randomizes iteration order of certain immutable sets and maps (<a href="https:&#x2F;&#x2F;github.com&#x2F;openjdk&#x2F;jdk&#x2F;blob&#x2F;jdk-23%2B37&#x2F;src&#x2F;java.base&#x2F;share&#x2F;classes&#x2F;java&#x2F;util&#x2F;ImmutableCollections.java#L53-L59">https:&#x2F;&#x2F;github.com&#x2F;openjdk&#x2F;jdk&#x2F;blob&#x2F;jdk-23%2B37&#x2F;src&#x2F;java.bas...</a>).</div><br/></div></div><div id="41723403" class="c"><input type="checkbox" id="c-41723403" checked=""/><div class="controls bullet"><span class="by">sorokod</span><span>|</span><a href="#41723764">prev</a><span>|</span><a href="#41724242">next</a><span>|</span><label class="collapse" for="c-41723403">[-]</label><label class="expand" for="c-41723403">[1 more]</label></div><br/><div class="children"><div class="content"><i>Hash iteration order is a great example of Hyrum’s Law</i><p>An even better example (requires less words) <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1172&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;1172&#x2F;</a></div><br/></div></div><div id="41724242" class="c"><input type="checkbox" id="c-41724242" checked=""/><div class="controls bullet"><span class="by">mise_en_place</span><span>|</span><a href="#41723403">prev</a><span>|</span><label class="collapse" for="c-41724242">[-]</label><label class="expand" for="c-41724242">[1 more]</label></div><br/><div class="children"><div class="content">Alternatively, maintain backward compatibility as much as possible. Function overloading might be too clever. Extra verbosity in exchange for clarity might be a worthwhile tradeoff. WET is acceptable in these scenarios.</div><br/></div></div></div></div></div></div></div></body></html>