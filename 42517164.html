<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735290050552" as="style"/><link rel="stylesheet" href="styles.css?v=1735290050552"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.jmeiners.com/lc3-vm/">Write Your Own Virtual Machine (2022)</a> <span class="domain">(<a href="https://www.jmeiners.com">www.jmeiners.com</a>)</span></div><div class="subtext"><span>sebg</span> | <span>44 comments</span></div><br/><div><div id="42518090" class="c"><input type="checkbox" id="c-42518090" checked=""/><div class="controls bullet"><span class="by">UniverseHacker</span><span>|</span><a href="#42520703">next</a><span>|</span><label class="collapse" for="c-42518090">[-]</label><label class="expand" for="c-42518090">[16 more]</label></div><br/><div class="children"><div class="content">As a teenager I took an intro CS class at a community college, and the instructor had us design a simple cpu instruction set, and write our own VM and assembler that worked and let me write and run assembly programs. It was shockingly easy, and it was amazing how much is demystified computers for me.<p>I feel like one could learn every level of computing this way- from designing a real cpu for a FPGA, to writing a simple OS and programs that run on it. This stuff is all shockingly simple if you just want it to work and don’t need all of the extra performance and security modern computing needs.</div><br/><div id="42518337" class="c"><input type="checkbox" id="c-42518337" checked=""/><div class="controls bullet"><span class="by">spit2wind</span><span>|</span><a href="#42518090">parent</a><span>|</span><a href="#42518364">next</a><span>|</span><label class="collapse" for="c-42518337">[-]</label><label class="expand" for="c-42518337">[2 more]</label></div><br/><div class="children"><div class="content">That sounds like a fun class! It sounds very similar to <a href="https:&#x2F;&#x2F;www.nand2tetris.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.nand2tetris.org&#x2F;</a> or Charles Petzold&#x27;s book &quot;Code&quot;.</div><br/><div id="42519865" class="c"><input type="checkbox" id="c-42519865" checked=""/><div class="controls bullet"><span class="by">NooneAtAll3</span><span>|</span><a href="#42518090">root</a><span>|</span><a href="#42518337">parent</a><span>|</span><a href="#42518364">next</a><span>|</span><label class="collapse" for="c-42519865">[-]</label><label class="expand" for="c-42519865">[1 more]</label></div><br/><div class="children"><div class="content">or <a href="https:&#x2F;&#x2F;nandgame.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nandgame.com&#x2F;</a></div><br/></div></div></div></div><div id="42518364" class="c"><input type="checkbox" id="c-42518364" checked=""/><div class="controls bullet"><span class="by">markus_zhang</span><span>|</span><a href="#42518090">parent</a><span>|</span><a href="#42518337">prev</a><span>|</span><a href="#42519071">next</a><span>|</span><label class="collapse" for="c-42518364">[-]</label><label class="expand" for="c-42518364">[9 more]</label></div><br/><div class="children"><div class="content">I think once you move from early fantasy CPUs to early CPUs in production such as 80286, the complexity immediately moves up drastically. IIRC it involves at least memory segmentation,  protected mode (MMU).</div><br/><div id="42518598" class="c"><input type="checkbox" id="c-42518598" checked=""/><div class="controls bullet"><span class="by">sunday_serif</span><span>|</span><a href="#42518090">root</a><span>|</span><a href="#42518364">parent</a><span>|</span><a href="#42518708">next</a><span>|</span><label class="collapse" for="c-42518598">[-]</label><label class="expand" for="c-42518598">[4 more]</label></div><br/><div class="children"><div class="content">True enough, but having designed a “fantasy cpu” gives you a better frame of reference for understanding the more complex features of a cpu (privilege levels, memory segmentation, virtual addresses, cache hierarchy, etc.)<p>I often feel like those who haven’t done the exercise of understanding the ISA of a “fantasy cpu” have a really hard time understanding those more advanced features.<p>I guess all I am saying is that learning the “fantasy cpu” still has value even if everything else in the real world is more complex.<p>Walking before running and all that.</div><br/><div id="42518806" class="c"><input type="checkbox" id="c-42518806" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42518090">root</a><span>|</span><a href="#42518598">parent</a><span>|</span><a href="#42520044">next</a><span>|</span><label class="collapse" for="c-42518806">[-]</label><label class="expand" for="c-42518806">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been doing some planning for a 24-bit fantasy CPU,  my plan is to make it pretty baroque.  For instance it has some instructions to do things like unpack UTF-8 strings into chars, do alpha compositing, etc.  The CPU part looks like a strange mainframe that didn&#x27;t quite get built into the 1970s and it is coupled to a video system that would make a Neo-Geo blush.</div><br/></div></div><div id="42520044" class="c"><input type="checkbox" id="c-42520044" checked=""/><div class="controls bullet"><span class="by">jeffrallen</span><span>|</span><a href="#42518090">root</a><span>|</span><a href="#42518598">parent</a><span>|</span><a href="#42518806">prev</a><span>|</span><a href="#42519014">next</a><span>|</span><label class="collapse" for="c-42520044">[-]</label><label class="expand" for="c-42520044">[1 more]</label></div><br/><div class="children"><div class="content">Forget advanced features... Without understanding a CPU it&#x27;s easy to never really understand pointers, and without pointers, it&#x27;s hard to understand lots of data structures.<p>I was easily 12 months ahead of other students in my CS education because I learned 6502 assembly in high school. I wish all CS courses started with &quot;make a VM&quot;.</div><br/></div></div><div id="42519014" class="c"><input type="checkbox" id="c-42519014" checked=""/><div class="controls bullet"><span class="by">markus_zhang</span><span>|</span><a href="#42518090">root</a><span>|</span><a href="#42518598">parent</a><span>|</span><a href="#42520044">prev</a><span>|</span><a href="#42518708">next</a><span>|</span><label class="collapse" for="c-42519014">[-]</label><label class="expand" for="c-42519014">[1 more]</label></div><br/><div class="children"><div class="content">agreed! A fantasy CPU is good for the first project.</div><br/></div></div></div></div><div id="42518708" class="c"><input type="checkbox" id="c-42518708" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#42518090">root</a><span>|</span><a href="#42518364">parent</a><span>|</span><a href="#42518598">prev</a><span>|</span><a href="#42518471">next</a><span>|</span><label class="collapse" for="c-42518708">[-]</label><label class="expand" for="c-42518708">[1 more]</label></div><br/><div class="children"><div class="content">80286 is the PHP of CPUs.<p>A wonderfully different early CPU with plenty of existing software is the <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;RCA_1802" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;RCA_1802</a> which was a target of the <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;CHIP-8" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;CHIP-8</a> interpreter.</div><br/></div></div><div id="42518471" class="c"><input type="checkbox" id="c-42518471" checked=""/><div class="controls bullet"><span class="by">remexre</span><span>|</span><a href="#42518090">root</a><span>|</span><a href="#42518364">parent</a><span>|</span><a href="#42518708">prev</a><span>|</span><a href="#42519071">next</a><span>|</span><label class="collapse" for="c-42518471">[-]</label><label class="expand" for="c-42518471">[3 more]</label></div><br/><div class="children"><div class="content">the 80286 has its own problems&#x2F;inessential complexity<p>if you look at this from the riscv angle, moving from &quot;u-mode only vm that doesn&#x27;t use paging under the hood&quot; to &quot;u+s-mode vm with sv39&quot; isn&#x27;t an enormous jump in complexity imo<p>i think i might teach it starting as like, &quot;sv21&quot; (page tables aren&#x27;t nested), then pose real sv39 and the tree structure as the solution to making a sparse mapping over 512GiB<p>then moving on to the idea of having a TLB is simple, especially if students have already been introduced to hashtables</div><br/><div id="42519098" class="c"><input type="checkbox" id="c-42519098" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42518090">root</a><span>|</span><a href="#42518471">parent</a><span>|</span><a href="#42519071">next</a><span>|</span><label class="collapse" for="c-42519098">[-]</label><label class="expand" for="c-42519098">[2 more]</label></div><br/><div class="children"><div class="content">Sometimes I dream of a 24-bit generation of computers (in terms of address space and the space of index math) of which<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Zilog_eZ80" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Zilog_eZ80</a><p>may be the best realization.  You can <i>almost</i> run a real operating system on that chip in the sense of a 24 bit supervisor that could run multiple 16 bit processes (if you could get CP&#x2F;M to run you have one heck of a userspace) Unfortunately you can&#x27;t trap the instruction that switches back to 24 bit mode.<p>Would be nice too if a 24 bit supervisor could contain a 24 bit application,  that requires some kind of memory management and I&#x27;d imagine something a little lighter weight than the usual paging system,  say something that maps (0..N) in logical space to (i+0..i+N) in physical address space.  I like the &quot;access register&quot; concept<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Access_register" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Access_register</a><p>but would probably have a small number of memory banks such as 16 or 64.  In a load-store architecture it doesn&#x27;t seem like much of a burden to add a bank id to stores and loads.  In return you get not just more RAM but also separation of code and data, video memory, file mmap(ing) and such.<p>What bugs me is how to control the mapping of memory banks to physical memory,  on one hand you want the supervisor in charge so it can be used for memory protection,  on the other hand some programming techniques would want the speed of changing the memory banks from user space.<p>The 80286 was a turkey because it didn&#x27;t meet the minimal viable product level of being a target for a 24-bit OS that could virtualize DOS applications.  It was already crazy fast and became affordable pretty quickly but it seemed tragic that it couldn&#x27;t do that.</div><br/><div id="42520700" class="c"><input type="checkbox" id="c-42520700" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42518090">root</a><span>|</span><a href="#42519098">parent</a><span>|</span><a href="#42519071">next</a><span>|</span><label class="collapse" for="c-42520700">[-]</label><label class="expand" for="c-42520700">[1 more]</label></div><br/><div class="children"><div class="content">Also PIC24 family of μcontrollers.</div><br/></div></div></div></div></div></div></div></div><div id="42519071" class="c"><input type="checkbox" id="c-42519071" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#42518090">parent</a><span>|</span><a href="#42518364">prev</a><span>|</span><a href="#42520173">next</a><span>|</span><label class="collapse" for="c-42519071">[-]</label><label class="expand" for="c-42519071">[2 more]</label></div><br/><div class="children"><div class="content">Our CS 101 class had such a system. Simple computer&#x2F;assembler written in BASIC on the PDP.<p>One of the assignments was to do a simple multiply (i.e. add in a loop).<p>Rather than do that, my friend simply altered the program and created a new MUL command.<p>The teacher was not amused.</div><br/><div id="42519113" class="c"><input type="checkbox" id="c-42519113" checked=""/><div class="controls bullet"><span class="by">JoeAltmaier</span><span>|</span><a href="#42518090">root</a><span>|</span><a href="#42519071">parent</a><span>|</span><a href="#42520173">next</a><span>|</span><label class="collapse" for="c-42519113">[-]</label><label class="expand" for="c-42519113">[1 more]</label></div><br/><div class="children"><div class="content">Teachers don&#x27;t want extra work.<p>My first 360 assembler class our first assignment: add two numbers, fault, print the crashdump and circle the answer to the ADD in the printout.<p>I wrote an RPN calculator, had it do a series of calculations and print the result. Turned that in.<p>The teacher wrote on it &quot;You have 24 hours to turn in the required assignment&quot;</div><br/></div></div></div></div><div id="42520173" class="c"><input type="checkbox" id="c-42520173" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#42518090">parent</a><span>|</span><a href="#42519071">prev</a><span>|</span><a href="#42518271">next</a><span>|</span><label class="collapse" for="c-42520173">[-]</label><label class="expand" for="c-42520173">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This stuff is all shockingly simple<p>it is, but the thing is that these simple building blocks end up quite far away from an actual production level outcome that someone looking at a computer might see or interact with. It&#x27;s hundreds of levels deep.<p>Someone with curiosity and eager to learn will be able to easily learn these foundational layers. Someone looking to &quot;get rich quick&quot; and be ready and employable ASAP won&#x27;t.</div><br/></div></div><div id="42518271" class="c"><input type="checkbox" id="c-42518271" checked=""/><div class="controls bullet"><span class="by">tralarpa</span><span>|</span><a href="#42518090">parent</a><span>|</span><a href="#42520173">prev</a><span>|</span><a href="#42520703">next</a><span>|</span><label class="collapse" for="c-42518271">[-]</label><label class="expand" for="c-42518271">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what the nand2tetris course does, I think (I only looked at the first lessons)</div><br/></div></div></div></div><div id="42520703" class="c"><input type="checkbox" id="c-42520703" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#42518090">prev</a><span>|</span><a href="#42517607">next</a><span>|</span><label class="collapse" for="c-42520703">[-]</label><label class="expand" for="c-42520703">[1 more]</label></div><br/><div class="children"><div class="content">Some books that i was pointed to;<p>1) <i>Virtual Machines: Versatile Platforms for Systems and Processes</i> by Smith and Nair - Seems to be a comprehensive subject overview book.<p>2) <i>Virtual Machines</i> by Iain Craig - Seems like a more hands-on book with languages and VMs.<p>3) <i>Virtual Machine Design and Implementation in C&#x2F;C++</i> by Bill Blunden - Seems like an hands-on implementation.<p>If somebody who has read any of the above can add some comments that would be helpful to everybody.</div><br/></div></div><div id="42517607" class="c"><input type="checkbox" id="c-42517607" checked=""/><div class="controls bullet"><span class="by">saithound</span><span>|</span><a href="#42520703">prev</a><span>|</span><a href="#42519194">next</a><span>|</span><label class="collapse" for="c-42517607">[-]</label><label class="expand" for="c-42517607">[21 more]</label></div><br/><div class="children"><div class="content">Alas, educational architectures like the Brookshear Machine and Little Computer look nothing like real ones, making them worse than useless: in my experience students who take courses using these often end up with a more distorted understanding of computers than those who take no classes at all.<p>Most people who want to learn a bit about how their machines work would be better served by taking an operating systems course. Same goes here: if you only have time for a short tutorial, I recommend &quot;Writing my own bootloader&quot; instead. [1]<p>(This is not meant to say that the Write your own VM tutorial is a bad tutorial; only that, in my experience,  most people who&#x27;d do it would be best served by a different subject)<p>[1] <a href="https:&#x2F;&#x2F;dev.to&#x2F;frosnerd&#x2F;writing-my-own-boot-loader-3mld" rel="nofollow">https:&#x2F;&#x2F;dev.to&#x2F;frosnerd&#x2F;writing-my-own-boot-loader-3mld</a></div><br/><div id="42518817" class="c"><input type="checkbox" id="c-42518817" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42517607">parent</a><span>|</span><a href="#42517857">next</a><span>|</span><label class="collapse" for="c-42518817">[-]</label><label class="expand" for="c-42518817">[1 more]</label></div><br/><div class="children"><div class="content">I think of Knuth&#x27;s old MIX which was a decimal machine which might have gotten built in the 1960s but which nobody has built since the 1970s.  A system like that can teach you many fundamentals but not the tricks here<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hacker%27s_Delight" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hacker%27s_Delight</a><p>which mainly depend on conventional numeric representations.</div><br/></div></div><div id="42517857" class="c"><input type="checkbox" id="c-42517857" checked=""/><div class="controls bullet"><span class="by">markus_zhang</span><span>|</span><a href="#42517607">parent</a><span>|</span><a href="#42518817">prev</a><span>|</span><a href="#42519183">next</a><span>|</span><label class="collapse" for="c-42517857">[-]</label><label class="expand" for="c-42517857">[6 more]</label></div><br/><div class="children"><div class="content">I just did the LC-3 one and look forward to learning a bit about dynamic recompilation using LC-3 as an (inappropriate) target machine in the current project.<p>Can you please elaborate why it is bad to use LC-3 for studying computer architecture? I do understand it is completely different from real hardware, and too simplified. But from the perspective of writing CPU emulators, is it bad for me?</div><br/><div id="42520294" class="c"><input type="checkbox" id="c-42520294" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42517607">root</a><span>|</span><a href="#42517857">parent</a><span>|</span><a href="#42519886">next</a><span>|</span><label class="collapse" for="c-42520294">[-]</label><label class="expand" for="c-42520294">[1 more]</label></div><br/><div class="children"><div class="content">When studying <i>computer architecture</i>, I think the implementation details of a real architecture, even a simple one, might actually slow you down if your goal is to learn about dynamic recompilation. The commenter you replied to seems to be coming from a software engineering perspective, i.e. learning how to program a computer (which someone interested in computer architecture probably knows about already).</div><br/></div></div><div id="42519886" class="c"><input type="checkbox" id="c-42519886" checked=""/><div class="controls bullet"><span class="by">saithound</span><span>|</span><a href="#42517607">root</a><span>|</span><a href="#42517857">parent</a><span>|</span><a href="#42520294">prev</a><span>|</span><a href="#42519183">next</a><span>|</span><label class="collapse" for="c-42519886">[-]</label><label class="expand" for="c-42519886">[4 more]</label></div><br/><div class="children"><div class="content">I answered a similar question by anyfoo downthread, the point about implementing a PIT should explain what I mean, and why I think that emulating a simple real architecture might be more useful while requiring similar effort.</div><br/><div id="42519947" class="c"><input type="checkbox" id="c-42519947" checked=""/><div class="controls bullet"><span class="by">c0wb0yc0d3r</span><span>|</span><a href="#42517607">root</a><span>|</span><a href="#42519886">parent</a><span>|</span><a href="#42520297">next</a><span>|</span><label class="collapse" for="c-42519947">[-]</label><label class="expand" for="c-42519947">[1 more]</label></div><br/><div class="children"><div class="content">Link in case the order changes.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42519788">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42519788</a></div><br/></div></div><div id="42520297" class="c"><input type="checkbox" id="c-42520297" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42517607">root</a><span>|</span><a href="#42519886">parent</a><span>|</span><a href="#42519947">prev</a><span>|</span><a href="#42519183">next</a><span>|</span><label class="collapse" for="c-42520297">[-]</label><label class="expand" for="c-42520297">[2 more]</label></div><br/><div class="children"><div class="content">Again, you are coming at this from a software engineering direction, not a computer architecture&#x2F;engineering one.</div><br/><div id="42520466" class="c"><input type="checkbox" id="c-42520466" checked=""/><div class="controls bullet"><span class="by">saithound</span><span>|</span><a href="#42517607">root</a><span>|</span><a href="#42520297">parent</a><span>|</span><a href="#42519183">next</a><span>|</span><label class="collapse" for="c-42520466">[-]</label><label class="expand" for="c-42520466">[1 more]</label></div><br/><div class="children"><div class="content">Since I have the exact same thought (that <i>you</i> are coming at this from a software engineering direction, not a computer architecture&#x2F;engineering one), this is unlikely to be further productive :(<p>You say you want students to be able to write emulators&#x2F;simulators  etc. (you list  a bunch of software.engineering tasks). I say writing an LC-3 emulator won&#x27;t give you any transferable skills for writing, say, a Gameboy Emulator (still a 30yo system), because these educational arhitectures are bad and abstract away precisely the things that you have to get right to do that, leaving you with something trivial to implement: a C array for &quot;memory&quot; and a few bitwise operations.<p>Since we&#x27;re largely looking at the same things and coming to orthogonal conclusions, I suggest we agree to disagree on this one.</div><br/></div></div></div></div></div></div></div></div><div id="42519183" class="c"><input type="checkbox" id="c-42519183" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#42517607">parent</a><span>|</span><a href="#42517857">prev</a><span>|</span><a href="#42518931">next</a><span>|</span><label class="collapse" for="c-42519183">[-]</label><label class="expand" for="c-42519183">[1 more]</label></div><br/><div class="children"><div class="content">The LC-3 has pretty odd addressing modes - in particular, you can do a doubly indirect load through a PC-relative word in the middle. But you still have to generate subtraction from negation, and negation from NOT and ADD ,,#-1. (I suppose NOT d,s = XOR d,s,#-1 would be a better use of the limited instruction encoding space too.)</div><br/></div></div><div id="42518931" class="c"><input type="checkbox" id="c-42518931" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42517607">parent</a><span>|</span><a href="#42519183">prev</a><span>|</span><a href="#42518656">next</a><span>|</span><label class="collapse" for="c-42518931">[-]</label><label class="expand" for="c-42518931">[6 more]</label></div><br/><div class="children"><div class="content">Can you elaborate what you don’t like about this one, LC-3, in particular? I’m not familiar with it, but just had a look at it on Wikipedia. After your comic, I was expecting something weird, but upon a quick glance, it doesn’t seem too jarring. A bit like a mixture of s&#x2F;360, some x86, and a tiny bit of ARM (or other RISCy architectures). With lots of omissions and some weirdness of course, but the goal seems to be to quickly come to a working implementation. I’m curious what exactly you think makes it “worse than useless” for teaching.</div><br/><div id="42519788" class="c"><input type="checkbox" id="c-42519788" checked=""/><div class="controls bullet"><span class="by">saithound</span><span>|</span><a href="#42517607">root</a><span>|</span><a href="#42518931">parent</a><span>|</span><a href="#42518656">next</a><span>|</span><label class="collapse" for="c-42519788">[-]</label><label class="expand" for="c-42519788">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not talking about the instruction set, or teaching basic assembly (probably anything except Malbolge is suitable for that).<p>Let&#x27;s look at just one thing every programmer has to deal with, memory.<p>On an LC-3, the address space is exactly 64KiB. There is no concept of missing memory, all addresses are assumed to exist, no memory detection is needed or possible, and memory mapped IO uses fixed addresses.<p>There are no memory management capabilities on the LC-3, no MMU,  no paging, no segmentation. In turn there are no memory-related exceptions, page faults or protection faults.<p>When an x86 machine boots with 1MB of RAM, the 4GB address space still exists in full, but accessing certain addresses will cause bus timeouts, crashes. One must track and manage available memory. There&#x27;s a BIOS, and manually probing memory locations may trash its critical structures. There&#x27;s INT 0x15.<p>I picked memory arbitrarily but you run into the same limitations no matter what you pick. Would a students who was educated on LC-3 know how a computer keeps time? Of course not, there&#x27;s no PIT, there&#x27;s no CMOS clock. Would they have thought about caches? Nope.<p>Oh, but wouldn&#x27;t a student who implements a timer emulation extension for LC-3 learn more about timers than somebody who just learned to use an x86 PIT? Alas, no. There are 20 equally easy and reasonable mathematical ways to implement a timer abstraction. A good 15 of these are physically impossible on real hardware, out of the remaining 5 two would be prohibiitively expensive due to electrical engineering reasons, one has never been implemented in real hardware due to historical accidents, and two are designs that are actually in use. So to write timer emulation that teaches you anything at all about how actual timers work, you&#x27;ll have to look at and understand a real architecture anyway.<p>That&#x27;s why educational architectures are so contraproductive. They abstract away exactly the things that make modern computers modern computers. One comes away with fundamentally wrong ideas about what computers do and how they actually work, or could work.<p>It&#x27;s like learning to drive in GTA: in principle, there could be plenty of skills that transfer to the real thing, but in practice you&#x27;ll prefer to teach how to drive to the person who didn&#x27;t play GTA at all.</div><br/><div id="42520267" class="c"><input type="checkbox" id="c-42520267" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42517607">root</a><span>|</span><a href="#42519788">parent</a><span>|</span><a href="#42520210">next</a><span>|</span><label class="collapse" for="c-42520267">[-]</label><label class="expand" for="c-42520267">[1 more]</label></div><br/><div class="children"><div class="content">There seems to be a misunderstanding what fields those learning architectures are geared towards.<p>They are usually not for learning about application or even systems programming, in assembly and otherwise. They are about CPU architectures (and some surrounding concepts) themselves. The goal is to be able to quickly build your own emulator&#x2F;simulator (like the VM behind the link), and maybe an assembler. <i>Or</i>, coming from the other side, given a working emulator&#x2F;simulator, implement a high level language compiler, such as for a simplified C language.<p>In both those goals the CPU architecture is geared towards quickly converging towards a working system. So of course they don&#x27;t require you to implement (as someone learning architecture engineering) or even use (as someone learning to build a compiler) an entire MMU, much like your first project car likely wouldn&#x27;t contain a computerized double clutch transmission. Instead, they are simplified CPU architectures that allow you to make steady progress, without being slowed down by the tedious complexity that a real architecture brings for reasons that are not relevant yet when starting out.<p>Then, once that is achieved, you can freely add things like an MMU, a cache controller, maybe shift towards a pipelined or even superscalar architectures...<p>Besides, a very large class of computers don&#x27;t have many of the things that you mentioned. For one, even very advanced microcontrollers explicitly don&#x27;t even have an MMU, because that would destroy latency guarantees (very bad for automative controllers). For the rest, I&#x27;ve got to say that there is a certain irony in complaining that computer architecture students don&#x27;t know about &quot;modern computers&quot;, while in the same breath mentioning things like INT 15h, segmentation, and x86 PITs, as if we were in the 1990s.</div><br/></div></div><div id="42520210" class="c"><input type="checkbox" id="c-42520210" checked=""/><div class="controls bullet"><span class="by">upghost</span><span>|</span><a href="#42517607">root</a><span>|</span><a href="#42519788">parent</a><span>|</span><a href="#42520267">prev</a><span>|</span><a href="#42518656">next</a><span>|</span><label class="collapse" for="c-42520210">[-]</label><label class="expand" for="c-42520210">[3 more]</label></div><br/><div class="children"><div class="content">Interesting. How would you advocate actually gaining that knowledge then?<p>It seems like a student would need to know a significant amount of coding in order to learn those abstractions in an interactive manner.<p>And by learn them I mean <i>learn</i> them (not just following a tutorial), organizing the code for a fully working x86 architecture is no joke.<p>But a student with that level of skill probably doesn&#x27;t <i>need</i> to learn the x86 architecture so intensively, they are probably already employable.<p>I am asking this seriously, by the way, not trying to nitpick. I&#x27;m trying to put together a free course based on the video game Turing Complete[1] but from what you&#x27;re saying it sounds like it might not be very effective. (to be clear the goal is to teach programming, not Computer Engineering)<p>[1]: <a href="https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;1444480&#x2F;Turing_Complete&#x2F;" rel="nofollow">https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;1444480&#x2F;Turing_Complete&#x2F;</a></div><br/><div id="42520419" class="c"><input type="checkbox" id="c-42520419" checked=""/><div class="controls bullet"><span class="by">saithound</span><span>|</span><a href="#42517607">root</a><span>|</span><a href="#42520210">parent</a><span>|</span><a href="#42520278">next</a><span>|</span><label class="collapse" for="c-42520419">[-]</label><label class="expand" for="c-42520419">[1 more]</label></div><br/><div class="children"><div class="content">Very good question.<p>My working assumption throughout was that the people in a computer architecture class already had 1 or 2 semesters of other programming courses where they worked in a high-level language, and are looking to learn how computers work &quot;closer to the hardware&quot;. And educational architectures create a completely false impression in this domain.<p>If I had to teach assembly programming to people who never programmed before, I&#x27;d _definitely_ not want to start with x86 assembly. I&#x27;d start by teaching them JavaScript so that they can program the computers that they themselves, and other people, actually use. At that point they&#x27;d be ready to learn computer architechture through an x86 deep dive, but would no longer need to learn it, since, as you said, they&#x27;d probably already be employable. But the same goes for learning LC-3, and much more so.<p>To be honest, my opinion is only that educational architectures are a poor way to learn what modern computers actually do, and while I think I have good reasons for holding that particular opinion, I don&#x27;t have the breadth of experience to generalize this specific observation into an overarching theory about teaching programming and&#x2F;or compsci. I hope your course will be a useful resource for many people, but I doubt listening to me will make it better: my experience does not generalize to the domain you&#x27;re targeting.</div><br/></div></div></div></div></div></div></div></div><div id="42518656" class="c"><input type="checkbox" id="c-42518656" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42517607">parent</a><span>|</span><a href="#42518931">prev</a><span>|</span><a href="#42517875">next</a><span>|</span><label class="collapse" for="c-42518656">[-]</label><label class="expand" for="c-42518656">[5 more]</label></div><br/><div class="children"><div class="content">My recommendation is to use an old 8-bit architecture like 6502 or Z80.<p>Apparently a lot of CS courses in India still use the 8086&#x2F;8088 too.</div><br/><div id="42519119" class="c"><input type="checkbox" id="c-42519119" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#42517607">root</a><span>|</span><a href="#42518656">parent</a><span>|</span><a href="#42519030">next</a><span>|</span><label class="collapse" for="c-42519119">[-]</label><label class="expand" for="c-42519119">[1 more]</label></div><br/><div class="children"><div class="content">I wrote a simple 6502 simulator. Just made it a byte code interpreter.<p>No cycle accurate anything. Simple I&#x2F;O. Since I&#x2F;O on the 6502 is all memory accesses, adding console is as simple as echoing whenever a character is stored in a particular memory address. No reason the simulate a VIA chip or UART or anything that low level.<p>Fun project. You can take it as deep as you like.</div><br/></div></div><div id="42519030" class="c"><input type="checkbox" id="c-42519030" checked=""/><div class="controls bullet"><span class="by">markus_zhang</span><span>|</span><a href="#42517607">root</a><span>|</span><a href="#42518656">parent</a><span>|</span><a href="#42519119">prev</a><span>|</span><a href="#42517875">next</a><span>|</span><label class="collapse" for="c-42519030">[-]</label><label class="expand" for="c-42519030">[3 more]</label></div><br/><div class="children"><div class="content">Back in China my first comp arch class used 8051, it was fun. I remember everyone getting a development board and playing with assembly.</div><br/><div id="42519286" class="c"><input type="checkbox" id="c-42519286" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42517607">root</a><span>|</span><a href="#42519030">parent</a><span>|</span><a href="#42517875">next</a><span>|</span><label class="collapse" for="c-42519286">[-]</label><label class="expand" for="c-42519286">[2 more]</label></div><br/><div class="children"><div class="content">8051-core SoCs seem to be found in tons of cheap Chinese electronics. MP3 players, toys, SD card&#x2F;USB drive controllers, touchscreen drivers etc.</div><br/><div id="42519399" class="c"><input type="checkbox" id="c-42519399" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#42517607">root</a><span>|</span><a href="#42519286">parent</a><span>|</span><a href="#42517875">next</a><span>|</span><label class="collapse" for="c-42519399">[-]</label><label class="expand" for="c-42519399">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, the 8051 family is still pretty popular, unlike, for example, the 68HC11&#x2F;08&#x2F;12 etc..  I think it&#x27;s not as popular as the PIC, ARM, AVR, or even MSP430, but it seems to be more popular than STM8, M16C, SH-4, MAXQ, MIPS, or 8086.  I&#x27;m not sure how to assess the Z80 (8080 variant), Z8, RL78, and RX families, all of which seem to be showing disturbing signs of life.  Fortunately the 8048 seems to be dead.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42519194" class="c"><input type="checkbox" id="c-42519194" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#42517607">prev</a><span>|</span><label class="collapse" for="c-42519194">[-]</label><label class="expand" for="c-42519194">[5 more]</label></div><br/><div class="children"><div class="content">To be That Guy: this is an emulator, not a VM.  While the term can apply in a descriptive sense, and in the pre-hardware-virtualization past there was some ambiguity, the overwhelmingly common usage of &quot;Virtual Machine&quot; in the modern world refers to an environment making use of hardware virtualization features like VT-x et. al.</div><br/><div id="42519718" class="c"><input type="checkbox" id="c-42519718" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#42519194">parent</a><span>|</span><a href="#42520727">next</a><span>|</span><label class="collapse" for="c-42519718">[-]</label><label class="expand" for="c-42519718">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that terminology is &quot;overwhelmingly common&quot;, and I&#x27;d argue that it isn&#x27;t even entirely correct.  The JVM is widely deployed, the Ethereum VM is called the &quot;EVM&quot;, <a href="https:&#x2F;&#x2F;www.linuxfoundation.org&#x2F;hubfs&#x2F;LF%20Research&#x2F;The_State_of_eBPF_010824.pdf?hsLang=en" rel="nofollow">https:&#x2F;&#x2F;www.linuxfoundation.org&#x2F;hubfs&#x2F;LF%20Research&#x2F;The_Stat...</a> describes BPF and eBPF repeatedly as &quot;virtual machines&quot;, <a href="https:&#x2F;&#x2F;webassembly.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;webassembly.org&#x2F;</a> begins by saying, &quot;WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine,&quot; etc.  &quot;Virtual machine&quot; is still the most common term for fictional machines.  (Myself, I think I&#x27;d prefer &quot;fictive machine&quot;, &quot;fictious machine&quot;, &quot;imaginary computer&quot;, or &quot;fantastic automaton&quot;, but I doubt these terms will gain adoption.)<p>You can&#x27;t always use the term &quot;emulator&quot; instead of &quot;virtual machine&quot;, because while you could say wasmtime was an &quot;emulator&quot;, you can&#x27;t correctly say that WebAssembly itself is an &quot;emulator&quot;.  Rather, WebAssembly is the virtual machine which wasmtime emulates.  It&#x27;s also common to call emulators &quot;virtual machines&quot;.  (The Wasmtime web site mostly calls wasmtime a &quot;runtime&quot; and WebAssembly an &quot;instruction format&quot;, FWIW.)  And of course a running instance of an emulator is also a &quot;virtual machine&quot; in a different sense.<p>I think it&#x27;s also reasonable to use &quot;virtual machine&quot; in the way you are describing, and it has some overlap with this last sense of &quot;virtual machine&quot;.  Perhaps in your current environment that is the overwhelmingly most common usage, but that is definitely not true elsewhere.</div><br/></div></div><div id="42520727" class="c"><input type="checkbox" id="c-42520727" checked=""/><div class="controls bullet"><span class="by">LeFantome</span><span>|</span><a href="#42519194">parent</a><span>|</span><a href="#42519718">prev</a><span>|</span><a href="#42519938">next</a><span>|</span><label class="collapse" for="c-42520727">[-]</label><label class="expand" for="c-42520727">[1 more]</label></div><br/><div class="children"><div class="content">This is a VM like in JVM ( Java Virtual Machine ). I think you will find Java qualifies for “overwhelmingly common usage”.</div><br/></div></div><div id="42519938" class="c"><input type="checkbox" id="c-42519938" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#42519194">parent</a><span>|</span><a href="#42520727">prev</a><span>|</span><a href="#42520189">next</a><span>|</span><label class="collapse" for="c-42519938">[-]</label><label class="expand" for="c-42519938">[1 more]</label></div><br/><div class="children"><div class="content">&gt; To be That Guy: this is an emulator, not a VM. While the term can apply in a descriptive sense, and in the pre-hardware-virtualization past there was some ambiguity, the overwhelmingly common usage of &quot;Virtual Machine&quot; in the modern world refers to an environment making use of hardware virtualization features like VT-x et. al.<p>I don&#x27;t think the distinction you&#x27;re advocating for actually exists. &#x27;Virtual machine&#x27; is commonly used for any software that executes machine- or bytecode, irrespective of the reason. This can include virtualisation, but you also commonly see the term used for language runtimes: e.g. Java&#x27;s JVM, Ruby&#x27;s YARV (Yet Another Ruby VM).<p>The one area you don&#x27;t actually hear the term that often is in emulation, and this is in part because most modern emulators have tended away from emulating entire systems, and towards techniques like dynamic recompilation (dynarec) of emulated software.</div><br/></div></div></div></div></div></div></div></div></div></body></html>