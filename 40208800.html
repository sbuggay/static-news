<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1714554069589" as="style"/><link rel="stylesheet" href="styles.css?v=1714554069589"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/ncruces/go-sqlite3/tree/main/vfs/adiantum">Show HN: Roast my SQLite encryption at-rest</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>ncruces</span> | <span>22 comments</span></div><br/><div><div id="40212190" class="c"><input type="checkbox" id="c-40212190" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#40212315">next</a><span>|</span><label class="collapse" for="c-40212190">[-]</label><label class="expand" for="c-40212190">[2 more]</label></div><br/><div class="children"><div class="content">How do you feel yours compares with (say) SQLCipher, which is a very popular C based one, and keeps fairly close to the upstream SQLite releases?<p>* <a href="https:&#x2F;&#x2F;www.zetetic.net&#x2F;sqlcipher&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.zetetic.net&#x2F;sqlcipher&#x2F;</a><p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;sqlcipher&#x2F;sqlcipher">https:&#x2F;&#x2F;github.com&#x2F;sqlcipher&#x2F;sqlcipher</a><p>Their most recent release (v4.5.7) is based upon SQLite v3.45.3, which is the latest version of SQLite:<p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;sqlcipher&#x2F;sqlcipher&#x2F;releases&#x2F;tag&#x2F;v4.5.7">https:&#x2F;&#x2F;github.com&#x2F;sqlcipher&#x2F;sqlcipher&#x2F;releases&#x2F;tag&#x2F;v4.5.7</a></div><br/><div id="40212868" class="c"><input type="checkbox" id="c-40212868" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#40212190">parent</a><span>|</span><a href="#40212315">next</a><span>|</span><label class="collapse" for="c-40212868">[-]</label><label class="expand" for="c-40212868">[1 more]</label></div><br/><div class="children"><div class="content">So, I haven&#x27;t studied their solution much, but ISTM what they did was fork SQLite at (around) the time of the commit that removed SQLITE_HAS_CODEC, and forward port the 4 years of changes since then.<p>That&#x27;s a bit untenable for me, since I&#x27;d rather keep as close as possible to SQLite compiled with Clang, and use the extension points already provided by SQLite (the VFS API).<p>Most SQLite encryption solutions (SQLite Encryption Extension, SQLCipher, SQLite3 Multiple Ciphers, sqleet) encrypt page content, and some need to reserve  a few bytes of every page to do so (for nounces, MACs). This was &quot;easy&quot; to do with SQLITE_HAS_CODEC, but requires some &quot;reverse engineering&quot; to do from the VFS layer. Some of this &quot;reverse engineering&quot; is likely stable, because the &quot;checksum VFS&quot; [1] depends on it. OTOH, extension points that are not part of the &quot;public API&quot; have been summarily dropped in the past [2].<p>My scheme does not care about the SQLite file format(s) at all, because instead of encrypting just page content, it encrypts entire files. It uses 4K blocks, so setting page size to (at least) 4K is advised, but not required. The only assumption it makes is that SQLite is not sensitive to file sizes rounding up to the next block (4K) size. An assumption that holds for databases, journals and WALs.<p>The scheme does not try to authenticate blocks, so it doesn&#x27;t try to protect against forgery. Other solutions may include MACs, but to offer random access they don&#x27;t protect against reverting a page to an older version of itself, so IMO, this is of limited value.<p>Other schemes add a nounce to each page, which allows on disk content to change, while the decrypted content stays the same. I don&#x27;t include a nounce, so if an adversary gets hold of multiple encrypted backups of the same database he knows not only which blocks couldn&#x27;t possibly have changed, but also which ones definitely did.<p>[1] <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;cksumvfs.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;cksumvfs.html</a><p>[2] <a href="https:&#x2F;&#x2F;sqlite.org&#x2F;forum&#x2F;forumpost&#x2F;db235b3070" rel="nofollow">https:&#x2F;&#x2F;sqlite.org&#x2F;forum&#x2F;forumpost&#x2F;db235b3070</a></div><br/></div></div></div></div><div id="40212315" class="c"><input type="checkbox" id="c-40212315" checked=""/><div class="controls bullet"><span class="by">nemo1618</span><span>|</span><a href="#40212190">prev</a><span>|</span><a href="#40214315">next</a><span>|</span><label class="collapse" for="c-40212315">[-]</label><label class="expand" for="c-40212315">[3 more]</label></div><br/><div class="children"><div class="content">Hey, it&#x27;s my Adiantum package! How&#x27;s the performance? Revisiting the API now, I see that Encrypt and Decrypt return newly-allocated slices, which is unfortunate. Should I add Append variants that don&#x27;t force an allocation?</div><br/><div id="40213231" class="c"><input type="checkbox" id="c-40213231" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#40212315">parent</a><span>|</span><a href="#40214315">next</a><span>|</span><label class="collapse" for="c-40213231">[-]</label><label class="expand" for="c-40213231">[2 more]</label></div><br/><div class="children"><div class="content">Hey! That&#x27;s amazing that you found this.<p>I haven&#x27;t benchmarked much, but I think I measured a 15% hit on speedtest1 [1] (with about 10% inside your library). Less if I kept temporary files in memory. Other solutions claim less of a performance hit. I&#x27;d have to measure to make sure.<p>There are some things I could do to improve performance. A partial block update needs a read-update-write cycle; journals and WALs do some of these. I could buffer consecutive writes in memory unencrypted and only flush them on fsync. Didn&#x27;t do that as it requires some additional bookkeeping.<p>I don&#x27;t think Encrypt and Decrypt allocate at all! They encrypt&#x2F;decrypt in-place; the returned slice just aliases the input block. But thanks, it&#x27;d be pretty bad if they did.<p>[1] <a href="https:&#x2F;&#x2F;sqlite.org&#x2F;src&#x2F;file&#x2F;test&#x2F;speedtest1.c" rel="nofollow">https:&#x2F;&#x2F;sqlite.org&#x2F;src&#x2F;file&#x2F;test&#x2F;speedtest1.c</a></div><br/><div id="40213848" class="c"><input type="checkbox" id="c-40213848" checked=""/><div class="controls bullet"><span class="by">nemo1618</span><span>|</span><a href="#40212315">root</a><span>|</span><a href="#40213231">parent</a><span>|</span><a href="#40214315">next</a><span>|</span><label class="collapse" for="c-40213848">[-]</label><label class="expand" for="c-40213848">[1 more]</label></div><br/><div class="children"><div class="content">Ha, you&#x27;re right, I even have benchmarks in the README showing 0 allocs&#x2F;op. Nice. (Sorry for doubting you, past-self!)<p>In the past I&#x27;ve implemented a form of the write-buffering you describe -- it was not fun. But it was a lot more important in that context, because flushing a write meant uploading many MB to remote servers. With 4 KB pages flushed locally, I&#x27;d wager it&#x27;s not worth it.</div><br/></div></div></div></div></div></div><div id="40214315" class="c"><input type="checkbox" id="c-40214315" checked=""/><div class="controls bullet"><span class="by">pyuser583</span><span>|</span><a href="#40212315">prev</a><span>|</span><a href="#40215007">next</a><span>|</span><label class="collapse" for="c-40214315">[-]</label><label class="expand" for="c-40214315">[5 more]</label></div><br/><div class="children"><div class="content">SQLite has a paid version. One of the paid features is encryption.<p>They’re not going to make it easy.</div><br/><div id="40214479" class="c"><input type="checkbox" id="c-40214479" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#40214315">parent</a><span>|</span><a href="#40215816">next</a><span>|</span><label class="collapse" for="c-40214479">[-]</label><label class="expand" for="c-40214479">[3 more]</label></div><br/><div class="children"><div class="content">Of course, nor would I expect them to make it so.<p>In fact, I mention the SEE in my package&#x27;s documentation. If you have a license to the paid extension, it should be easy to compile it and use it with my package.<p>It will be slow, however, because it will be running the reference AES implementation in Wasm.<p>That said, if anyone is interested in sponsoring a SEE license, I can look into doing the encryption Go (which uses assembly on most platforms for those bits).</div><br/><div id="40215543" class="c"><input type="checkbox" id="c-40215543" checked=""/><div class="controls bullet"><span class="by">cipherboy</span><span>|</span><a href="#40214315">root</a><span>|</span><a href="#40214479">parent</a><span>|</span><a href="#40215816">next</a><span>|</span><label class="collapse" for="c-40215543">[-]</label><label class="expand" for="c-40215543">[2 more]</label></div><br/><div class="children"><div class="content">Which reference AES implementation? My memory is that the one from the spec has terrible timing side channel attacks... e.g. <a href="https:&#x2F;&#x2F;www.redhat.com&#x2F;en&#x2F;blog&#x2F;its-all-question-time-aes-timing-attacks-openssl" rel="nofollow">https:&#x2F;&#x2F;www.redhat.com&#x2F;en&#x2F;blog&#x2F;its-all-question-time-aes-tim...</a> seems to corroborate my memory.<p>I seem to recall this was remotely exploitable, and exploiting timing side channels has only gotten better since 2014.</div><br/><div id="40215622" class="c"><input type="checkbox" id="c-40215622" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#40214315">root</a><span>|</span><a href="#40215543">parent</a><span>|</span><a href="#40215816">next</a><span>|</span><label class="collapse" for="c-40215622">[-]</label><label class="expand" for="c-40215622">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have a license, so can&#x27;t know for sure.<p>But the only versions mentioned in [1] that should compile out of the box into Wasm, are the ones that say they use <i>&quot;the Rijndaal reference implementation.&quot;</i><p>I don&#x27;t think compiling OpenSSL into Wasm is tenable. But some wrappers around the Go AES implementation should work.<p>[1] <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;see&#x2F;doc&#x2F;release&#x2F;www&#x2F;readme.wiki" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;see&#x2F;doc&#x2F;release&#x2F;www&#x2F;readme.wiki</a></div><br/></div></div></div></div></div></div><div id="40215816" class="c"><input type="checkbox" id="c-40215816" checked=""/><div class="controls bullet"><span class="by">acheong08</span><span>|</span><a href="#40214315">parent</a><span>|</span><a href="#40214479">prev</a><span>|</span><a href="#40215007">next</a><span>|</span><label class="collapse" for="c-40215816">[-]</label><label class="expand" for="c-40215816">[1 more]</label></div><br/><div class="children"><div class="content">That was a complete surprise to me.<p>Here’s the relevant link:<p><a href="https:&#x2F;&#x2F;sqlite.org&#x2F;prosupport.html" rel="nofollow">https:&#x2F;&#x2F;sqlite.org&#x2F;prosupport.html</a></div><br/></div></div></div></div><div id="40215007" class="c"><input type="checkbox" id="c-40215007" checked=""/><div class="controls bullet"><span class="by">bityard</span><span>|</span><a href="#40214315">prev</a><span>|</span><a href="#40215900">next</a><span>|</span><label class="collapse" for="c-40215007">[-]</label><label class="expand" for="c-40215007">[4 more]</label></div><br/><div class="children"><div class="content">Have you considered targeting libSQL for this instead? <a href="https:&#x2F;&#x2F;github.com&#x2F;tursodatabase&#x2F;libsql">https:&#x2F;&#x2F;github.com&#x2F;tursodatabase&#x2F;libsql</a><p>SQLite is a great product and I use it a lot, but it does not have a great history of outside contributions and collaboration. If I were developing any kind of extension, I feel like I would have a better shot at getting help and feedback from a community-based project.</div><br/><div id="40215205" class="c"><input type="checkbox" id="c-40215205" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#40215007">parent</a><span>|</span><a href="#40220091">next</a><span>|</span><label class="collapse" for="c-40215205">[-]</label><label class="expand" for="c-40215205">[2 more]</label></div><br/><div class="children"><div class="content">My extension targets my Go SQLite bindings (the VFS is implemented in Go) [1].<p>This extension, and the wrapper, target public SQLite APIs, so if anyone wants to replace SQLite with libSQL, that should be easy.<p>You simply need to include a little bit of glue C code that I append to the amalgamation, and use some SQLite compile options.<p>I explicitly support building and providing your own, custom, Wasm SQLite &quot;blob&quot; (it just needs to include my glue code).<p>As for Adiantum encryption, as I said, reimplementing this in C&#x2F;C++&#x2F;Rust to make it a loadable extension is perfectly viable, and would be compatible with libSQL, again because this uses only public SQLite APIs (that&#x27;s the point, basically!)<p>But this is predicated on it being a secure scheme (that&#x27;s the feedback I was looking for this time around).<p>PS: I&#x27;ve got nothing against Turso, or libSQL. In fact I spent the last year perusing their virtual WAL API. The problem is that I found no documentation, nor any useful open source implementations of it. If there any I&#x27;d be very interested. So, thus far, I also don&#x27;t have anything that drives towards libSQL.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;ncruces&#x2F;go-sqlite3">https:&#x2F;&#x2F;github.com&#x2F;ncruces&#x2F;go-sqlite3</a></div><br/><div id="40220266" class="c"><input type="checkbox" id="c-40220266" checked=""/><div class="controls bullet"><span class="by">avinassh</span><span>|</span><a href="#40215007">root</a><span>|</span><a href="#40215205">parent</a><span>|</span><a href="#40220091">next</a><span>|</span><label class="collapse" for="c-40220266">[-]</label><label class="expand" for="c-40220266">[1 more]</label></div><br/><div class="children"><div class="content">&gt; PS: I&#x27;ve got nothing against Turso, or libSQL. In fact I spent the last year perusing their virtual WAL API. The problem is that I found no documentation, nor any useful open source implementations of it. If there any I&#x27;d be very interested. So, thus far, I also don&#x27;t have anything that drives towards libSQL.<p>Hey, this is v and I am an engineer at Turso. We do have some documentation and an example implementation of Virtual WAL<p>docs: <a href="https:&#x2F;&#x2F;github.com&#x2F;tursodatabase&#x2F;libsql&#x2F;blob&#x2F;ef44612&#x2F;libsql-sqlite3&#x2F;doc&#x2F;libsql_extensions.md#virtual-wal">https:&#x2F;&#x2F;github.com&#x2F;tursodatabase&#x2F;libsql&#x2F;blob&#x2F;ef44612&#x2F;libsql-...</a><p>example: <a href="https:&#x2F;&#x2F;github.com&#x2F;tursodatabase&#x2F;libsql&#x2F;blob&#x2F;ef44612&#x2F;libsql-sqlite3&#x2F;test&#x2F;rust_suite&#x2F;src&#x2F;virtual_wal.rs">https:&#x2F;&#x2F;github.com&#x2F;tursodatabase&#x2F;libsql&#x2F;blob&#x2F;ef44612&#x2F;libsql-...</a><p>for an open source implementation, you may check how Bottomless works. Bottomless is another project which does back up like litestream and it internally implements a Virtual WAL.<p>Bottomless - <a href="https:&#x2F;&#x2F;github.com&#x2F;tursodatabase&#x2F;libsql&#x2F;tree&#x2F;main&#x2F;bottomless">https:&#x2F;&#x2F;github.com&#x2F;tursodatabase&#x2F;libsql&#x2F;tree&#x2F;main&#x2F;bottomless</a><p>I am sure we can improve our docs, make it more discover-able and easy to find. I am open to feedback and suggestions!</div><br/></div></div></div></div><div id="40220091" class="c"><input type="checkbox" id="c-40220091" checked=""/><div class="controls bullet"><span class="by">avinassh</span><span>|</span><a href="#40215007">parent</a><span>|</span><a href="#40215205">prev</a><span>|</span><a href="#40215900">next</a><span>|</span><label class="collapse" for="c-40220091">[-]</label><label class="expand" for="c-40220091">[1 more]</label></div><br/><div class="children"><div class="content">Turso &#x2F; libsql supports encryption, integrated with MultipleCiphers<p>Example and usage code is here - <a href="https:&#x2F;&#x2F;turso.tech&#x2F;blog&#x2F;fully-open-source-encryption-for-sqlite-b3858225" rel="nofollow">https:&#x2F;&#x2F;turso.tech&#x2F;blog&#x2F;fully-open-source-encryption-for-sql...</a></div><br/></div></div></div></div><div id="40215694" class="c"><input type="checkbox" id="c-40215694" checked=""/><div class="controls bullet"><span class="by">580515975</span><span>|</span><a href="#40215900">prev</a><span>|</span><a href="#40212504">next</a><span>|</span><label class="collapse" for="c-40215694">[-]</label><label class="expand" for="c-40215694">[5 more]</label></div><br/><div class="children"><div class="content">A couple of thoughts:<p>First, great job on the readme! One way you could improve it is by expanding on the &quot;Caution&quot; section. What&#x27;s written is the beginnings of a threat model, but it could be improved by being more explicit about which attacks this system does&#x2F;doesn&#x27;t defend against.<p>&gt; The only security property that disk encryption (and this package) provides is that all information such an adversary can obtain is whether the data in a sector has (or has not) changed over time.<p>I think the adversary learns a bit more than this. Randomized encryption would provide the above probably, but the _deterministic_ scheme that&#x27;s used here will let the adversary learn not only whether a sector changed, but whether its value matches what it was at a previous point in time.<p>How does this translate into the security of the database, itself? Seeing what blocks have changed might reveal information about what data has changed. Let&#x27;s consider a security game where I (the adversary) get to submit sql queries, and then learn which blocks on disk has changed. After this initial phase (where I can learn where data is stored), I submit two different sql queries, you pick one of them at random and run it, and then tell me which blocks have changed. I win if I can guess which sql query you picked.<p>Suppose I submit queries which each insert into a different table. Because the tables are stored separately on-disk, it&#x27;ll probably be pretty easy for me to distinguish them. But okay, that&#x27;s still count-ish&#x2F;size-ish, and maybe out of scope.<p>What if I submit two queries which each insert different values, but into the same table. Further, let&#x27;s say that this table has an index. Based on which pages were written to, I can now learn something about the _values_ that were inserted, because different values will write into the index in different places.<p>Now, it&#x27;s completely valid if the threat model says, &quot;if you can see more than two copies of the database file, then all is lost.&quot; However, I think it&#x27;d be worth translating the current write-up of the threat model into the implications for leaking the database. For more examples of attacks based on seeing what indices&#x2F;sizes changed [1] and [2].<p>Is it valid to pad the sqlite file to a multiple of the block size? Does sqlite ever call truncate on a non-block-aligned size and expect any truncated bytes to be fully removed?<p>What are the atomicity requirements for a sqlite VFS? SQLite, in general, is supposed to not get corrupted if power were to be yanked mid-write. However, because this VFS writes one block at-a-time, the computer dying mid-write could corrupt more bytes around the write position than would normally be corrupted if the the standard VFS was used. It&#x27;s possible this is a non-issue, but it&#x27;s worth considering what contract sqlite has for VFSes.<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;CRIME" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;CRIME</a>
[2]: <a href="https:&#x2F;&#x2F;www.usenix.org&#x2F;legacy&#x2F;events&#x2F;sec07&#x2F;tech&#x2F;full_papers&#x2F;wright&#x2F;wright.pdf" rel="nofollow">https:&#x2F;&#x2F;www.usenix.org&#x2F;legacy&#x2F;events&#x2F;sec07&#x2F;tech&#x2F;full_papers&#x2F;...</a></div><br/><div id="40216138" class="c"><input type="checkbox" id="c-40216138" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40215694">parent</a><span>|</span><a href="#40217132">next</a><span>|</span><label class="collapse" for="c-40216138">[-]</label><label class="expand" for="c-40216138">[3 more]</label></div><br/><div class="children"><div class="content">The threat model has to exclude:<p>- attacks on a running app that has the keys loaded, naturally<p>The threat model has to include at least:<p>- passive attacks against the DB itself, lacking access to the keys<p>The threat model really should also include:<p>- active attacks against the DB lacking access to the keys (e.g., replace blocks)<p>IMO ZFS does a pretty good job against these threats, for example, so ZFS is a good yardstick for measuring things like TFA.<p>However, the fact that a <i>running system</i> must have access to the <i>keys</i> means that at-rest data encryption does not buy one much protection against server compromise, especially when the system must be running much&#x2F;most&#x2F;all of the time.  So you really also want to do the utmost to secure the server&#x2F;application.</div><br/><div id="40217168" class="c"><input type="checkbox" id="c-40217168" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#40215694">root</a><span>|</span><a href="#40216138">parent</a><span>|</span><a href="#40217132">next</a><span>|</span><label class="collapse" for="c-40217168">[-]</label><label class="expand" for="c-40217168">[2 more]</label></div><br/><div class="children"><div class="content">ZFS, AFAIK, can offer something in addition which is harder for a VFS to offer, and which AFAICT no other SQLite encryption offers: a kind of HMAC Merkel tree that authenticates an entire database (at a point in time).<p>Alternatives, even those that use MACs only authenticate pages&#x2F;blocks. They still allow mix-and-match of pages&#x2F;blocks from previous backups.<p>I could, potentially, add optional&#x2F;configurable nounces and MACs at the VFS layer.<p>I&#x27;ve refrained from doing so because (1) it complicates the implementation; (2) it can be added later, compatibly; (3) it doesn&#x27;t fix mix-and-match; (4) it will impact performance further; and (5) it would be MAC-then-encrypt (against best practice).</div><br/><div id="40217256" class="c"><input type="checkbox" id="c-40217256" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40215694">root</a><span>|</span><a href="#40217168">parent</a><span>|</span><a href="#40217132">next</a><span>|</span><label class="collapse" for="c-40217256">[-]</label><label class="expand" for="c-40217256">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s right.  In fact, ZFS w&#x2F; encryption gives you two Merkle hash trees, one using a hash function <i>and</i> using a MAC.  SQLite3 could do this, but it would have to change its database format fairly radically.<p>A SQLite3 VFS could, maybe, store additional metadata on the side knowing the SQLite3 database file format, I suppose.  But if you <i>really</i> want this it&#x27;s best to do it in the database itself.</div><br/></div></div></div></div></div></div><div id="40217132" class="c"><input type="checkbox" id="c-40217132" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#40215694">parent</a><span>|</span><a href="#40216138">prev</a><span>|</span><a href="#40212504">next</a><span>|</span><label class="collapse" for="c-40217132">[-]</label><label class="expand" for="c-40217132">[1 more]</label></div><br/><div class="children"><div class="content">First of all, thanks for the review. I&#x27;ll try to respond to all points.<p>Disk encryption, on which this is based, is usually deterministic in nature.<p>So yes, an adversary 1 that can inspect multiple versions of a database (e.g. backups) can learn exactly: which (blocks) changed, which didn&#x27;t change, which have been reverted; but that is <i>all</i> they should learn.<p>An adversary 2 that can modify files, can also mix-and-match blocks between versions to produce a valid file with high probability .<p>And an adversary 3 that can submit changes and see their effect on the encrypted data can probably infer a lot about the database.<p>I&#x27;ll try to make these more explicit in the README. In practical terms: adversary 1 is the one I thought I&#x27;d covered reasonably well; adversary 2 means that backups should be independently signed, and signatures verified before restoring them; adversaries 2 and 3 mean that this is ineffective against live attacks.<p>Security, though, is also about comparing options. Reading the documentation for alternatives (even the expensive ones) I don&#x27;t see this kind of analysis. I see 2 advantages to the alternatives that encrypt page data with a nounce and a MAC. The nounce allows reverts to go unnoticed. No change, means a block definitely didn&#x27;t change. But ciphertext changing doesn&#x27;t necessarily mean plaintext changed. The MAC ensures blocks are valid. But they still be reverted to previous versions of themselves, mix-and-match is still possible. Do these two properties make a huge difference? Is there anything else I&#x27;m missing?<p>On your other points.<p>Yes it&#x27;s always safe to round up file sizes to block size, for databases, journals and WALs (I could detail why, but the formats are documented). It may not be safe for all temporary files (I&#x27;m assuming it is), but that can be fixed for those files by remembering the file size in memory.<p>About atomicity, corruption, etc, the VFS is supposed to declare its characteristics [1] to SQLite. Your concerns are covered by SAFE_APPEND and POWERSAFE_OVERWRITE. See also [2]. As a wrapper VFS, I filter most of those characteristics from the underlying VFS, forcing SQLite to assume the worst.<p>[1] <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;c3ref&#x2F;c_iocap_atomic.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;c3ref&#x2F;c_iocap_atomic.html</a><p>[2] <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;psow.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;psow.html</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>