<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706086859910" as="style"/><link rel="stylesheet" href="styles.css?v=1706086859910"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a>Ask HN: Does (or why does) anyone use MapReduce anymore?</a> </div><div class="subtext"><span>bk146</span> | <span>19 comments</span></div><br/><div><div id="39114357" class="c"><input type="checkbox" id="c-39114357" checked=""/><div class="controls bullet"><span class="by">tjhunter</span><span>|</span><a href="#39114459">next</a><span>|</span><label class="collapse" for="c-39114357">[-]</label><label class="expand" for="c-39114357">[3 more]</label></div><br/><div class="children"><div class="content">(2nd user &amp; developer of spark here). It depends on what you ask.<p>MapReduce the framework is proprietary to Google, and some pipelines are still running inside google.<p>MapReduce as a concept is very much in use. Hadoop was inspired by MapReduce. Spark was originally built around the primitives of MapReduce, and you see still see that in the description of its operations (exchange, collect). However, spark and all the other modern frameworks realized that:<p>- users did not care mapping and reducing, they wanted higher level primitives (filtering, joins, ...)<p>- mapreduce was great for one-shot batch processing of data, but struggled to accomodate other very common use cases at scale (low latency, graph processing, streaming, distributed machine learning, ...). You can do it on top of mapreduce, but if you really start tuning for the specific case, you end up with something rather different. For example, kafka (scalable streaming engine) is inspired by the general principles of MR but the use cases and APIs are now quite different.</div><br/><div id="39114414" class="c"><input type="checkbox" id="c-39114414" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39114357">parent</a><span>|</span><a href="#39114502">next</a><span>|</span><label class="collapse" for="c-39114414">[-]</label><label class="expand" for="c-39114414">[1 more]</label></div><br/><div class="children"><div class="content">Also see <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37313576">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37313576</a></div><br/></div></div><div id="39114502" class="c"><input type="checkbox" id="c-39114502" checked=""/><div class="controls bullet"><span class="by">H8crilA</span><span>|</span><a href="#39114357">parent</a><span>|</span><a href="#39114414">prev</a><span>|</span><a href="#39114459">next</a><span>|</span><label class="collapse" for="c-39114502">[-]</label><label class="expand" for="c-39114502">[1 more]</label></div><br/><div class="children"><div class="content">There really was always only Map and Shuffle (Reduce is just Shuffle+Map; also another name for Shuffle is GroupByKey). And you see those primitives under the hood of most parallel systems.</div><br/></div></div></div></div><div id="39114459" class="c"><input type="checkbox" id="c-39114459" checked=""/><div class="controls bullet"><span class="by">dehrmann</span><span>|</span><a href="#39114357">prev</a><span>|</span><a href="#39114293">next</a><span>|</span><label class="collapse" for="c-39114459">[-]</label><label class="expand" for="c-39114459">[1 more]</label></div><br/><div class="children"><div class="content">At a high level, most distributed data systems look something like MapReduce, and that&#x27;s really just fancy divide-and-conquer. It&#x27;s hard to reason about, and most data at this size is tabular, so you&#x27;re usually better off using something where you can write a SQL query and let the query engine do the low-level map-reduce work.</div><br/></div></div><div id="39114293" class="c"><input type="checkbox" id="c-39114293" checked=""/><div class="controls bullet"><span class="by">throwaway5959</span><span>|</span><a href="#39114459">prev</a><span>|</span><a href="#39114472">next</a><span>|</span><label class="collapse" for="c-39114293">[-]</label><label class="expand" for="c-39114293">[1 more]</label></div><br/><div class="children"><div class="content">I feel like that’s kind of like saying we don’t use Assembly anymore now that we have C. We’ve just built higher level abstractions on top of it.</div><br/></div></div><div id="39114472" class="c"><input type="checkbox" id="c-39114472" checked=""/><div class="controls bullet"><span class="by">BenoitP</span><span>|</span><a href="#39114293">prev</a><span>|</span><a href="#39114195">next</a><span>|</span><label class="collapse" for="c-39114472">[-]</label><label class="expand" for="c-39114472">[1 more]</label></div><br/><div class="children"><div class="content">The concept is quite alive, and the fancy deep learning have it: jax.lax.map, jax.lax.reduce.<p>It&#x27;s going to stay because it is useful:<p>Any operation that you can express with an associative behavior is automatically parallelizeable. And both in Spark and Torch&#x2F;Jax this means scalable to a cluster, with the code going to the data. This is the unfair advantage of solving bigger problems.<p>If you were talking about the Hadoop ecosystem, then yes Spark pretty much nailed it and is dominant (no need to have another implementation)</div><br/></div></div><div id="39114195" class="c"><input type="checkbox" id="c-39114195" checked=""/><div class="controls bullet"><span class="by">atombender</span><span>|</span><a href="#39114472">prev</a><span>|</span><a href="#39114861">next</a><span>|</span><label class="collapse" for="c-39114195">[-]</label><label class="expand" for="c-39114195">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s my understanding. MR is very simplistic and awkward&#x2F;impossible to express many problems in, whereas dataflow processors like Spark and Apache Beam support creating complex DAGs of rich set of operators for grouping, windowing, joining, etc. that you just don&#x27;t have in MR. You can do MR within a DAG, so you could say that dataflows are a generalization or superset of the MR model.</div><br/><div id="39114247" class="c"><input type="checkbox" id="c-39114247" checked=""/><div class="controls bullet"><span class="by">danpalmer</span><span>|</span><a href="#39114195">parent</a><span>|</span><a href="#39114861">next</a><span>|</span><label class="collapse" for="c-39114247">[-]</label><label class="expand" for="c-39114247">[3 more]</label></div><br/><div class="children"><div class="content">&gt; You can do MR within a DAG, so you could say that dataflows are a generalization or superset of the MR model.<p>I think it&#x27;s the opposite of this. MapReduce is a very generic mechanism for splitting computation up so that it can be distributed. It would be possible to build Spark&#x2F;Beam and all their higher level DAG components out of MapReduce operations.</div><br/><div id="39114298" class="c"><input type="checkbox" id="c-39114298" checked=""/><div class="controls bullet"><span class="by">atombender</span><span>|</span><a href="#39114195">root</a><span>|</span><a href="#39114247">parent</a><span>|</span><a href="#39114312">next</a><span>|</span><label class="collapse" for="c-39114298">[-]</label><label class="expand" for="c-39114298">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t mean generalization that way. Dataflow operators can be expressed as MR as the underlying primitive, as you say. But MR itself, as described in the original paper at least, only has the two stages, map and reduce; it&#x27;s not a dataflow system. And it turns out people want dataflow systems, not hand-code MR and do the DAG manually.</div><br/></div></div><div id="39114312" class="c"><input type="checkbox" id="c-39114312" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39114195">root</a><span>|</span><a href="#39114247">parent</a><span>|</span><a href="#39114298">prev</a><span>|</span><a href="#39114861">next</a><span>|</span><label class="collapse" for="c-39114312">[-]</label><label class="expand" for="c-39114312">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what you describe is the opposite?<p>I mean, you can implement function calls (and other control flow operators like exceptions or loops) as GOTOs and conditional branches, and that&#x27;s what your compiler does.<p>But that doesn&#x27;t really mean it&#x27;s useful to think of GOTOs being the generalisation.<p>Most of the time, it&#x27;s just the opposite: you can think of a GOTO as a very specific kind of function call, a tail-call without any arguments.  See eg <a href="https:&#x2F;&#x2F;www2.cs.sfu.ca&#x2F;CourseCentral&#x2F;383&#x2F;havens&#x2F;pubs&#x2F;lambda-the-ultimate-goto.pdf" rel="nofollow">https:&#x2F;&#x2F;www2.cs.sfu.ca&#x2F;CourseCentral&#x2F;383&#x2F;havens&#x2F;pubs&#x2F;lambda-...</a></div><br/></div></div></div></div></div></div><div id="39114861" class="c"><input type="checkbox" id="c-39114861" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#39114195">prev</a><span>|</span><a href="#39114652">next</a><span>|</span><label class="collapse" for="c-39114861">[-]</label><label class="expand" for="c-39114861">[1 more]</label></div><br/><div class="children"><div class="content">I feel like a lot of the underlying concepts of mapreduce live large in multi-threaded applications even on a single machine.<p>Its definitely not a dead concept, I guess its not sexy to talk about though.</div><br/></div></div><div id="39114652" class="c"><input type="checkbox" id="c-39114652" checked=""/><div class="controls bullet"><span class="by">monero-xmr</span><span>|</span><a href="#39114861">prev</a><span>|</span><a href="#39114349">next</a><span>|</span><label class="collapse" for="c-39114652">[-]</label><label class="expand" for="c-39114652">[5 more]</label></div><br/><div class="children"><div class="content">The correct language for querying data is, as always, SQL. No one cares about the implementation details.<p>“I have data and I know SQL. What is it about your database that makes retrieving it better?”<p>Any other paradigm is going to be a niche at best, likely outright fail.</div><br/><div id="39115051" class="c"><input type="checkbox" id="c-39115051" checked=""/><div class="controls bullet"><span class="by">nprateem</span><span>|</span><a href="#39114652">parent</a><span>|</span><a href="#39114919">next</a><span>|</span><label class="collapse" for="c-39115051">[-]</label><label class="expand" for="c-39115051">[1 more]</label></div><br/><div class="children"><div class="content">I know I&#x27;m replying to a troll comment, but:<p>&gt; “I have data and I know SQL. What is it about your database that makes retrieving it better?”<p>Because my data comes from a variety of unstructured, possibly dirty sources which need cleaning and transforming before they can be made sense of.</div><br/></div></div><div id="39114919" class="c"><input type="checkbox" id="c-39114919" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#39114652">parent</a><span>|</span><a href="#39115051">prev</a><span>|</span><a href="#39114349">next</a><span>|</span><label class="collapse" for="c-39114919">[-]</label><label class="expand" for="c-39114919">[3 more]</label></div><br/><div class="children"><div class="content">Spark is really failing, all right.<p>SQL lacks type safety, testability, and composability.</div><br/><div id="39114957" class="c"><input type="checkbox" id="c-39114957" checked=""/><div class="controls bullet"><span class="by">monero-xmr</span><span>|</span><a href="#39114652">root</a><span>|</span><a href="#39114919">parent</a><span>|</span><a href="#39114349">next</a><span>|</span><label class="collapse" for="c-39114957">[-]</label><label class="expand" for="c-39114957">[2 more]</label></div><br/><div class="children"><div class="content">It’s crazy to think how old I am now. But give it 20 more years and you’ll come around.</div><br/><div id="39115195" class="c"><input type="checkbox" id="c-39115195" checked=""/><div class="controls bullet"><span class="by">blowski</span><span>|</span><a href="#39114652">root</a><span>|</span><a href="#39114957">parent</a><span>|</span><a href="#39114349">next</a><span>|</span><label class="collapse" for="c-39115195">[-]</label><label class="expand" for="c-39115195">[1 more]</label></div><br/><div class="children"><div class="content">[delayed]</div><br/></div></div></div></div></div></div></div></div><div id="39114349" class="c"><input type="checkbox" id="c-39114349" checked=""/><div class="controls bullet"><span class="by">justrealist</span><span>|</span><a href="#39114652">prev</a><span>|</span><label class="collapse" for="c-39114349">[-]</label><label class="expand" for="c-39114349">[2 more]</label></div><br/><div class="children"><div class="content">You have no idea how long the tail of legacy MR-based daily stat aggregation workflows is in BigCorps.<p>The batch daily log processor jobs will last longer than Fortran.  Longer than Cobol.  Longer than earth itself.</div><br/><div id="39114418" class="c"><input type="checkbox" id="c-39114418" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#39114349">parent</a><span>|</span><label class="collapse" for="c-39114418">[-]</label><label class="expand" for="c-39114418">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The batch daily log processor jobs will last longer than Fortran. Longer than Cobol.<p>Nonsense... They&#x27;ll end at the same time. Which is approximately concurrently with the universe.</div><br/></div></div></div></div></div></div></div></div></div></body></html>