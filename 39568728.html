<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709370077097" as="style"/><link rel="stylesheet" href="styles.css?v=1709370077097"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://wizardzines.com/comics/bash-debugging/">Bash Debugging</a>Â <span class="domain">(<a href="https://wizardzines.com">wizardzines.com</a>)</span></div><div class="subtext"><span>ColinWright</span> | <span>34 comments</span></div><br/><div><div id="39569939" class="c"><input type="checkbox" id="c-39569939" checked=""/><div class="controls bullet"><span class="by">E39M5S62</span><span>|</span><a href="#39569479">next</a><span>|</span><label class="collapse" for="c-39569939">[-]</label><label class="expand" for="c-39569939">[1 more]</label></div><br/><div class="children"><div class="content">We use a couple nice home-grown functions in ZFSBootMenu to help debug things. We have a zdebug logging function that&#x27;s peppered liberally throughout the code base - <a href="https:&#x2F;&#x2F;github.com&#x2F;zbm-dev&#x2F;zfsbootmenu&#x2F;blob&#x2F;master&#x2F;zfsbootmenu&#x2F;lib&#x2F;kmsg-log-lib.sh#L16-L38">https:&#x2F;&#x2F;github.com&#x2F;zbm-dev&#x2F;zfsbootmenu&#x2F;blob&#x2F;master&#x2F;zfsbootme...</a><p>Hitting ctrl-t on our main menu will, when booting with debug logging enabled, show a screen like this: <a href="https:&#x2F;&#x2F;i.imgur.com&#x2F;Ge75zkP.png" rel="nofollow">https:&#x2F;&#x2F;i.imgur.com&#x2F;Ge75zkP.png</a><p>We also have a flamegraph profiling mechanism that can be enabled with <a href="https:&#x2F;&#x2F;github.com&#x2F;zbm-dev&#x2F;zfsbootmenu&#x2F;blob&#x2F;master&#x2F;zfsbootmenu&#x2F;profiling&#x2F;profiling-lib.sh">https:&#x2F;&#x2F;github.com&#x2F;zbm-dev&#x2F;zfsbootmenu&#x2F;blob&#x2F;master&#x2F;zfsbootme...</a> . That will dump data to a serial port, which when re-assembled, can be used to produce a graph like <a href="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;zbm-dev&#x2F;zfsbootmenu&#x2F;master&#x2F;media&#x2F;flamechart-v1.12.svg" rel="nofollow">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;zbm-dev&#x2F;zfsbootmenu&#x2F;master...</a><p>Bash is suprisingly flexible.</div><br/></div></div><div id="39569479" class="c"><input type="checkbox" id="c-39569479" checked=""/><div class="controls bullet"><span class="by">jclulow</span><span>|</span><a href="#39569939">prev</a><span>|</span><a href="#39569816">next</a><span>|</span><label class="collapse" for="c-39569479">[-]</label><label class="expand" for="c-39569479">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actually possible to produce a stack trace of sorts, if you use a lot of bash functions.  One possible implementation is: <a href="https:&#x2F;&#x2F;github.com&#x2F;TritonDataCenter&#x2F;sdc-headnode&#x2F;blob&#x2F;master&#x2F;buildtools&#x2F;lib&#x2F;error_handler.sh">https:&#x2F;&#x2F;github.com&#x2F;TritonDataCenter&#x2F;sdc-headnode&#x2F;blob&#x2F;master...</a></div><br/><div id="39569842" class="c"><input type="checkbox" id="c-39569842" checked=""/><div class="controls bullet"><span class="by">drizzleword</span><span>|</span><a href="#39569479">parent</a><span>|</span><a href="#39569816">next</a><span>|</span><label class="collapse" for="c-39569842">[-]</label><label class="expand" for="c-39569842">[1 more]</label></div><br/><div class="children"><div class="content">Another stack trace implementation [1] that allows you to write:<p><pre><code>  some-command || fail &quot;message&quot;
</code></pre>
to produce a stack trace and exit the shell in case of non-zero exit status from some-command, or write<p><pre><code>  some-command || softfail &quot;message&quot; || return $?
</code></pre>
in case you want to produce a stack trace and return from the function.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;runag&#x2F;runag&#x2F;blob&#x2F;main&#x2F;lib&#x2F;fail.sh">https:&#x2F;&#x2F;github.com&#x2F;runag&#x2F;runag&#x2F;blob&#x2F;main&#x2F;lib&#x2F;fail.sh</a></div><br/></div></div></div></div><div id="39569816" class="c"><input type="checkbox" id="c-39569816" checked=""/><div class="controls bullet"><span class="by">jph</span><span>|</span><a href="#39569479">prev</a><span>|</span><a href="#39569325">next</a><span>|</span><label class="collapse" for="c-39569816">[-]</label><label class="expand" for="c-39569816">[2 more]</label></div><br/><div class="children"><div class="content">Good info. You can improve your debugging by using exit codes like this:<p><pre><code>    # die: print error message to stderr, then exit with error code.
    # example: die 69 &quot;Service unavailable.&quot;
    die() {
            n=&quot;$1&quot; ; shift ; &gt;&amp;2 printf %s\\n &quot;$*&quot; ; exit &quot;$n&quot;
    }
</code></pre>
Many more shell script exit codes and helper functions:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;SixArm&#x2F;unix-shell-script-kit&#x2F;blob&#x2F;main&#x2F;unix-shell-script-kit">https:&#x2F;&#x2F;github.com&#x2F;SixArm&#x2F;unix-shell-script-kit&#x2F;blob&#x2F;main&#x2F;un...</a></div><br/><div id="39570781" class="c"><input type="checkbox" id="c-39570781" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#39569816">parent</a><span>|</span><a href="#39569325">next</a><span>|</span><label class="collapse" for="c-39570781">[-]</label><label class="expand" for="c-39570781">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a nice list; I guess every experienced user has their helper functions.  However, I have a small criticism for the philosophy of that `die`: `die` functions should pass by default the exit code of the failed command, and not silence its error output.  If I want to give my own meaning to the command failure in a large script for instance, I will use a different, more specialized `die`.  My own die is roughly as follows:<p><pre><code>    __errex() {
     printf &#x27;Fatal error [%s] on line %s in &#x27;&quot;&#x27;&quot;&#x27;%s&#x27;&quot;&#x27;&quot;&#x27;: %s\n&#x27; \
            &quot;${1:-&quot;?&quot;}&quot;                                         \
            &quot;${2:-&quot;?&quot;}&quot;                                         \
            &quot;${3:-&quot;unknown script&quot;}&quot;                            \
            &quot;${4:-&quot;unknown error&quot;}&quot; &gt;&amp;2                         ;
     exit &quot;${1:-1}&quot;
    }
    alias die=&#x27;__errex &quot;$?&quot; &quot;${LINENO}&quot; &quot;$0&quot;&#x27;</code></pre></div><br/></div></div></div></div><div id="39569325" class="c"><input type="checkbox" id="c-39569325" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#39569816">prev</a><span>|</span><a href="#39570833">next</a><span>|</span><label class="collapse" for="c-39569325">[-]</label><label class="expand" for="c-39569325">[2 more]</label></div><br/><div class="children"><div class="content">I always put<p>set -euxo pipefail<p>at the top of my bash scripts. It makes some conditional testing more difficult but it has paid for itself many times over just because of pipefail</div><br/><div id="39569397" class="c"><input type="checkbox" id="c-39569397" checked=""/><div class="controls bullet"><span class="by">ddlsmurf</span><span>|</span><a href="#39569325">parent</a><span>|</span><a href="#39570833">next</a><span>|</span><label class="collapse" for="c-39569397">[-]</label><label class="expand" for="c-39569397">[1 more]</label></div><br/><div class="children"><div class="content">You can also set it for a bunch of lines then deactivate it with `set +x`. It gets rather tedious otherwise...</div><br/></div></div></div></div><div id="39570833" class="c"><input type="checkbox" id="c-39570833" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#39569325">prev</a><span>|</span><a href="#39569941">next</a><span>|</span><label class="collapse" for="c-39570833">[-]</label><label class="expand" for="c-39570833">[1 more]</label></div><br/><div class="children"><div class="content">The `trap DEBUG` thing is pretty interesting; I almost always write POSIX code, so I don&#x27;t get to play with such tricks.  Does anybody know of some wizardry that could mimic this in arbitrary POSIX compliant shells?</div><br/></div></div><div id="39569941" class="c"><input type="checkbox" id="c-39569941" checked=""/><div class="controls bullet"><span class="by">thaumaturgy</span><span>|</span><a href="#39570833">prev</a><span>|</span><a href="#39569837">next</a><span>|</span><label class="collapse" for="c-39569941">[-]</label><label class="expand" for="c-39569941">[3 more]</label></div><br/><div class="children"><div class="content">The `die()` trick is good, but bash has an annoying quirk: if you try to `exit` while you&#x27;re inside a subshell, then the subshell exits but the rest of the script continues. Example:<p><pre><code>    #!&#x2F;bin&#x2F;bash
    
    die() { echo &quot;$1&quot; &gt;&amp;2; exit 1; }
    
    cat myfile | while read line; do
        if [[ &quot;$line&quot; =~ &quot;information&quot; ]]; then
            die &quot;Found match&quot;
        fi
    done
    echo &quot;I don&#x27;t want this line&quot;
</code></pre>
...&quot;I don&#x27;t want this line&quot; will be printed.<p>You can often avoid subshells (and in this specific example, shellcheck is absolutely right to complain about UUOC, and fixing that will also fix the die-from-a-subshell problem).<p>But, sometimes you can&#x27;t, or avoiding a subshell really complicates the script. For those occasions, you can grab the script&#x27;s PID at the top of the script and then use that to kill it dead:<p><pre><code>    #!&#x2F;bin&#x2F;bash
    
    MYPID=$$
    
    die() { echo &quot;$1&quot; &gt;&amp;2; kill -9 $MYPID; exit 1;  }
    
    cat myfile | while read line; do
        if [[ &quot;$line&quot; =~ &quot;information&quot; ]]; then
            die &quot;Found match&quot;
        fi
    done
    echo &quot;I don&#x27;t want this line&quot;
</code></pre>
...but, of course, there are tradeoffs here too; killing it this way is a little bit brutal, and I&#x27;ve found that (for reasons I don&#x27;t understand) it&#x27;s not entirely reliable either.</div><br/><div id="39570221" class="c"><input type="checkbox" id="c-39570221" checked=""/><div class="controls bullet"><span class="by">whatindaheck</span><span>|</span><a href="#39569941">parent</a><span>|</span><a href="#39569837">next</a><span>|</span><label class="collapse" for="c-39570221">[-]</label><label class="expand" for="c-39570221">[2 more]</label></div><br/><div class="children"><div class="content">Could killing the PID like that create zombies?</div><br/><div id="39570525" class="c"><input type="checkbox" id="c-39570525" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#39569941">root</a><span>|</span><a href="#39570221">parent</a><span>|</span><a href="#39569837">next</a><span>|</span><label class="collapse" for="c-39570525">[-]</label><label class="expand" for="c-39570525">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps, but in any case I would never write code like this.<p>First of all, sending sigkill is literally overkill and perpetuates a bad practice.  Send `TERM`.  If it doesn&#x27;t work, figure out why.<p>Secondly, subshells should be made as clear as possible and not hidden in pipes.  Related, looping over `read` is essentially never the right thing to do.  If you really need to do that, don&#x27;t use pipes; use heredocs or herestrings.<p>Fourth, if you cannot avoid subshells and you want to terminate the full script on some condition, exit with a specific exit code from the subshell, check for it outside and terminate appropriately.</div><br/></div></div></div></div></div></div><div id="39569837" class="c"><input type="checkbox" id="c-39569837" checked=""/><div class="controls bullet"><span class="by">bewuethr</span><span>|</span><a href="#39569941">prev</a><span>|</span><a href="#39569489">next</a><span>|</span><label class="collapse" for="c-39569837">[-]</label><label class="expand" for="c-39569837">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also a fairly powerful gdb style actual debugger: <a href="https:&#x2F;&#x2F;bashdb.sourceforge.net&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bashdb.sourceforge.net&#x2F;</a></div><br/></div></div><div id="39569489" class="c"><input type="checkbox" id="c-39569489" checked=""/><div class="controls bullet"><span class="by">asicsp</span><span>|</span><a href="#39569837">prev</a><span>|</span><a href="#39569454">next</a><span>|</span><label class="collapse" for="c-39569489">[-]</label><label class="expand" for="c-39569489">[1 more]</label></div><br/><div class="children"><div class="content">See also:<p>Why doesn&#x27;t set -e (or set -o errexit, or trap ERR) do what I expected?
 <a href="https:&#x2F;&#x2F;mywiki.wooledge.org&#x2F;BashFAQ&#x2F;105" rel="nofollow">https:&#x2F;&#x2F;mywiki.wooledge.org&#x2F;BashFAQ&#x2F;105</a><p>What are the advantages and disadvantages of using set -u (or set -o nounset)?
 <a href="https:&#x2F;&#x2F;mywiki.wooledge.org&#x2F;BashFAQ&#x2F;112" rel="nofollow">https:&#x2F;&#x2F;mywiki.wooledge.org&#x2F;BashFAQ&#x2F;112</a><p>Safe ways to do things in bash <a href="https:&#x2F;&#x2F;github.com&#x2F;anordal&#x2F;shellharden&#x2F;blob&#x2F;master&#x2F;how_to_do_things_safely_in_bash.md">https:&#x2F;&#x2F;github.com&#x2F;anordal&#x2F;shellharden&#x2F;blob&#x2F;master&#x2F;how_to_do...</a><p>Better Bash Scripting in 15 Minutes <a href="https:&#x2F;&#x2F;robertmuth.blogspot.com&#x2F;2012&#x2F;08&#x2F;better-bash-scripting-in-15-minutes.html" rel="nofollow">https:&#x2F;&#x2F;robertmuth.blogspot.com&#x2F;2012&#x2F;08&#x2F;better-bash-scriptin...</a><p>Writing Robust Bash Shell Scripts <a href="https:&#x2F;&#x2F;www.davidpashley.com&#x2F;articles&#x2F;writing-robust-shell-scripts&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.davidpashley.com&#x2F;articles&#x2F;writing-robust-shell-s...</a></div><br/></div></div><div id="39569454" class="c"><input type="checkbox" id="c-39569454" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#39569489">prev</a><span>|</span><a href="#39569268">next</a><span>|</span><label class="collapse" for="c-39569454">[-]</label><label class="expand" for="c-39569454">[1 more]</label></div><br/><div class="children"><div class="content">I have almost that same die() in every script, except I call it abrt(). Maybe I&#x27;ll switch to die() since it&#x27;s shorter. Mine also prepends $0 and sometimes I use printf or echo -e so I can pass larger more complex messages with linefeeds and escape codes etc.</div><br/></div></div><div id="39569268" class="c"><input type="checkbox" id="c-39569268" checked=""/><div class="controls bullet"><span class="by">memco</span><span>|</span><a href="#39569454">prev</a><span>|</span><a href="#39569555">next</a><span>|</span><label class="collapse" for="c-39569268">[-]</label><label class="expand" for="c-39569268">[6 more]</label></div><br/><div class="children"><div class="content">Good stuff! I use set-x frequently and have used a similar thing to die (but Juliaâs version is nicer). Iâll consider using the debugger thing but stepping through a bash script line by line sounds a bit tedious. Perhaps less so than having to reread a log and rerun the script a bunch.</div><br/><div id="39569455" class="c"><input type="checkbox" id="c-39569455" checked=""/><div class="controls bullet"><span class="by">halostatue</span><span>|</span><a href="#39569268">parent</a><span>|</span><a href="#39569305">next</a><span>|</span><label class="collapse" for="c-39569455">[-]</label><label class="expand" for="c-39569455">[4 more]</label></div><br/><div class="children"><div class="content">I often add a fail-unless function:<p><pre><code>    fail-unless() {
      local result
      &quot;$@&quot;
      result=$?

      if ((result != 0)); then
        echo &gt;2&amp;1 &quot;Failed  ${result} with command &#x27;$*&#x27;.&quot;
        exit ${result}
      fi
    }
</code></pre>
That way, I know exactly what failed in the script.</div><br/><div id="39570253" class="c"><input type="checkbox" id="c-39570253" checked=""/><div class="controls bullet"><span class="by">sureglymop</span><span>|</span><a href="#39569268">root</a><span>|</span><a href="#39569455">parent</a><span>|</span><a href="#39569784">next</a><span>|</span><label class="collapse" for="c-39570253">[-]</label><label class="expand" for="c-39570253">[2 more]</label></div><br/><div class="children"><div class="content">You do e.g. `fail-unless somecommand`. The result (exit&#x2F;return code) is captured in the function and based on that, the function logs and exits or not.</div><br/><div id="39570537" class="c"><input type="checkbox" id="c-39570537" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#39569268">root</a><span>|</span><a href="#39570253">parent</a><span>|</span><a href="#39569784">next</a><span>|</span><label class="collapse" for="c-39570537">[-]</label><label class="expand" for="c-39570537">[1 more]</label></div><br/><div class="children"><div class="content">You probably meant to reply to BeefySwain, right?</div><br/></div></div></div></div><div id="39569784" class="c"><input type="checkbox" id="c-39569784" checked=""/><div class="controls bullet"><span class="by">BeefySwain</span><span>|</span><a href="#39569268">root</a><span>|</span><a href="#39569455">parent</a><span>|</span><a href="#39570253">prev</a><span>|</span><a href="#39569305">next</a><span>|</span><label class="collapse" for="c-39569784">[-]</label><label class="expand" for="c-39569784">[1 more]</label></div><br/><div class="children"><div class="content">How does this work exactly? What calls that function and when?</div><br/></div></div></div></div><div id="39569305" class="c"><input type="checkbox" id="c-39569305" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#39569268">parent</a><span>|</span><a href="#39569455">prev</a><span>|</span><a href="#39569555">next</a><span>|</span><label class="collapse" for="c-39569305">[-]</label><label class="expand" for="c-39569305">[1 more]</label></div><br/><div class="children"><div class="content">The line-by-line debugging would probably only be useful for a particular section of your script that you&#x27;re trying to fix. In that case, you can remove the trap at the end of it with `trap - DEBUG`</div><br/></div></div></div></div><div id="39569555" class="c"><input type="checkbox" id="c-39569555" checked=""/><div class="controls bullet"><span class="by">colordrops</span><span>|</span><a href="#39569268">prev</a><span>|</span><a href="#39570051">next</a><span>|</span><label class="collapse" for="c-39569555">[-]</label><label class="expand" for="c-39569555">[8 more]</label></div><br/><div class="children"><div class="content">Is there a reason bash is still the de facto shell scripting language other than sheer momentum of legacy? I&#x27;m able to get what I need done in it, but it&#x27;s clunky and the syntax is horrid. I guess it forces you to move to a proper language once scripts grow to a certain size&#x2F;complexity, so perhaps it&#x27;s by design?</div><br/><div id="39570201" class="c"><input type="checkbox" id="c-39570201" checked=""/><div class="controls bullet"><span class="by">theonemind</span><span>|</span><a href="#39569555">parent</a><span>|</span><a href="#39569846">next</a><span>|</span><label class="collapse" for="c-39570201">[-]</label><label class="expand" for="c-39570201">[1 more]</label></div><br/><div class="children"><div class="content">bourne shell scripting is good enough, which makes it nearly impossible to replace. Plan9&#x27;s rc is a bit cleaner, and no one is going to switch for &#x27;more of the same, but cleaner&#x27;. You haven&#x27;t switched to something similar but better even though you could literally do it right now <a href="https:&#x2F;&#x2F;pkgsrc.se&#x2F;shells" rel="nofollow">https:&#x2F;&#x2F;pkgsrc.se&#x2F;shells</a> , and it doesn&#x27;t run any different for anyone else.   It usually takes something several times better in some crucial aspect to replace an entrenched technology. For example, Plan 9 is better than UNIX-like systems, but not good enough to replace them. I don&#x27;t think it&#x27;s possible to make something good enough to replace bourne shell scripting in its niche because before you have something several times better, good enough to actually replace it, you&#x27;re in a different ecological niche or problem domain, for real scripting languages like Perl, Python, and Ruby. It&#x27;s a local maximum solution that sucks the air out of the room for potential competition closer to the theoretical global maximum solution for the narrow problem domain.</div><br/></div></div><div id="39569846" class="c"><input type="checkbox" id="c-39569846" checked=""/><div class="controls bullet"><span class="by">hyperadvanced</span><span>|</span><a href="#39569555">parent</a><span>|</span><a href="#39570201">prev</a><span>|</span><a href="#39569574">next</a><span>|</span><label class="collapse" for="c-39569846">[-]</label><label class="expand" for="c-39569846">[1 more]</label></div><br/><div class="children"><div class="content">It really is just legacy and momentum. Recent additions build on sh&#x2F;bash really well but in the end shell scripting is a means to an end that need to evolve much slower than standard programming languages.<p>I think bash&#x2F;shâs key feature is that they are anti-entropy, thereâs no development or evolution so thereâs no chance you need to mess with dependencies or new features, the stuff that worked 20 years ago will continue to be the âbread and butterâ. By design, this results in a system thatâs averse to change and incentivizes people to reach outside of its limits when they are met.</div><br/></div></div><div id="39569574" class="c"><input type="checkbox" id="c-39569574" checked=""/><div class="controls bullet"><span class="by">jimkoen</span><span>|</span><a href="#39569555">parent</a><span>|</span><a href="#39569846">prev</a><span>|</span><a href="#39570906">next</a><span>|</span><label class="collapse" for="c-39569574">[-]</label><label class="expand" for="c-39569574">[4 more]</label></div><br/><div class="children"><div class="content">Are you sure it&#x27;s bash? Most scripts on FreeBSD&#x27;s are written for sh, which I feel is much more widely supported due to being part of the POSIX standard. Bash is just popular I think.</div><br/><div id="39570276" class="c"><input type="checkbox" id="c-39570276" checked=""/><div class="controls bullet"><span class="by">HankB99</span><span>|</span><a href="#39569555">root</a><span>|</span><a href="#39569574">parent</a><span>|</span><a href="#39570464">next</a><span>|</span><label class="collapse" for="c-39570276">[-]</label><label class="expand" for="c-39570276">[1 more]</label></div><br/><div class="children"><div class="content">Bash is pretty much expected to be installed on any Linux distro. On FreeBSD (and likely other BSDs) it is an optional install. If you want a script to run on either, use sh. If strictly Linux, bash is probably safe.<p>Bash&#x2F;sh is good for when you need to combine some commands and what needs to be done can be accomplished mostly by CLI commands with a little glue to tie them together. Some times it is surprising what can be accomplished. I wrote a program to import pictures from an SD card on Windows using C#, copying pictures to C:\Pictures\YYYY\MM\DD according to the EXIF data or failing that, file time stamp. I tried to port it to Linux but ran into problems trying to connect to the EXIF library. After struggling with that, I rewrote it using sh, some EXIF tool and various file utilities. It took 31 lines, about half of which were actual commands and the rest comments or white space.<p>A much bigger project is a script to install Debian with root on ZFS. It&#x27;s mostly a series of CLI commands with some variable substitution and conditionals depending on stuff like encrypted or not.</div><br/></div></div><div id="39570464" class="c"><input type="checkbox" id="c-39570464" checked=""/><div class="controls bullet"><span class="by">xp84</span><span>|</span><a href="#39569555">root</a><span>|</span><a href="#39569574">parent</a><span>|</span><a href="#39570276">prev</a><span>|</span><a href="#39570906">next</a><span>|</span><label class="collapse" for="c-39570464">[-]</label><label class="expand" for="c-39570464">[2 more]</label></div><br/><div class="children"><div class="content">I suppose itâs an ambiguous designation.<p>I feel like when I see a shell script in my work, which is not in operating systems development of course, people are targeting bash. I agree many things are careful to target sh for certain reasons (e.g. a script that runs in a container where the base image doesnât have bash installed) but i still think GPâs question is interesting because itâs not common to see, say, a zsh shell script, but seeing #!&#x2F;bin&#x2F;bash is super common.</div><br/><div id="39570584" class="c"><input type="checkbox" id="c-39570584" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#39569555">root</a><span>|</span><a href="#39570464">parent</a><span>|</span><a href="#39570906">next</a><span>|</span><label class="collapse" for="c-39570584">[-]</label><label class="expand" for="c-39570584">[1 more]</label></div><br/><div class="children"><div class="content">I have done some delightful stuff in `zsh`, but I always lament how slow its numerical array traversal is.  Frustratingly, experts told me it really doesn&#x27;t have to be slow, the devs just don&#x27;t seem to be bothering to revamp the underlying data structure because they are focusing more on associative arrays.</div><br/></div></div></div></div></div></div><div id="39570906" class="c"><input type="checkbox" id="c-39570906" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#39569555">parent</a><span>|</span><a href="#39569574">prev</a><span>|</span><a href="#39570051">next</a><span>|</span><label class="collapse" for="c-39570906">[-]</label><label class="expand" for="c-39570906">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s ubiquitous.<p>But bash is so bad I wrote a ton of namespace shortened utils for using groovy scripts.<p>Sooooooooooooooooo much better. use IDEs for dev, save library system, groovy smoothed almost all Java annoyances</div><br/></div></div></div></div><div id="39570051" class="c"><input type="checkbox" id="c-39570051" checked=""/><div class="controls bullet"><span class="by">mmmpetrichor</span><span>|</span><a href="#39569555">prev</a><span>|</span><label class="collapse" for="c-39570051">[-]</label><label class="expand" for="c-39570051">[5 more]</label></div><br/><div class="children"><div class="content">If I ever have to debug anything in bash. I stop using bash hah.</div><br/><div id="39570668" class="c"><input type="checkbox" id="c-39570668" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#39570051">parent</a><span>|</span><a href="#39570165">next</a><span>|</span><label class="collapse" for="c-39570668">[-]</label><label class="expand" for="c-39570668">[2 more]</label></div><br/><div class="children"><div class="content">I find such reasoning backwards.  Indeed, shell scripting is not friendly to debugging.  But ensuring correctness of shell scripts is essential: usually, they touch part of your &quot;$HOME&quot; or system folders and do tons of I&#x2F;O, some of it destructive.  I find it baffling to see people write careless scripts; sometimes using `rm` for cleanup with unquoted parameters, or much worse, dangerous uses of `mv`.</div><br/><div id="39571106" class="c"><input type="checkbox" id="c-39571106" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#39570051">root</a><span>|</span><a href="#39570668">parent</a><span>|</span><a href="#39570165">next</a><span>|</span><label class="collapse" for="c-39571106">[-]</label><label class="expand" for="c-39571106">[1 more]</label></div><br/><div class="children"><div class="content">I believe OP&#x27;s point was that any shell script complex enough to require debugging should not be a shell script any more.</div><br/></div></div></div></div><div id="39570165" class="c"><input type="checkbox" id="c-39570165" checked=""/><div class="controls bullet"><span class="by">sureglymop</span><span>|</span><a href="#39570051">parent</a><span>|</span><a href="#39570668">prev</a><span>|</span><label class="collapse" for="c-39570165">[-]</label><label class="expand" for="c-39570165">[2 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t make sense. What if you get a script someone else wrote? Printing every command and confirming as you run every command is a great idea.<p>And, unfortunately shell has become the norm in CI&#x2F;CD environments, pipelines etc. Can be convenient at times but can also be inconvenient and confusing as these scripts don&#x27;t run in interactive shells.</div><br/><div id="39571097" class="c"><input type="checkbox" id="c-39571097" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#39570051">root</a><span>|</span><a href="#39570165">parent</a><span>|</span><label class="collapse" for="c-39571097">[-]</label><label class="expand" for="c-39571097">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And, unfortunately shell has become the norm in CI&#x2F;CD environments, pipelines etc.<p>A pipeline which relies on shell is not worth using, tbh. That&#x27;s how much shell sucks.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>