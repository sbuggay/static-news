<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720602064561" as="style"/><link rel="stylesheet" href="styles.css?v=1720602064561"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/maelstrom-software/maelstrom">Show HN: Maelstrom – A Hermetic, Clustered Test Runner for Python and Rust</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>nfachan</span> | <span>14 comments</span></div><br/><div><div id="40923057" class="c"><input type="checkbox" id="c-40923057" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#40923428">next</a><span>|</span><label class="collapse" for="c-40923057">[-]</label><label class="expand" for="c-40923057">[3 more]</label></div><br/><div class="children"><div class="content">Why did you build this? Any particular motivating experience? At $WORK, we use Jest to run each test suite in its own process. The places we struggle with isolation are for integration tests that read&#x2F;write from the DB, so I’m curious what kinds of issues motivated container-per-test.<p>Are you going to sell it somehow?<p>Does it work nested inside Docker? I already have a CI setup that stripes batches of tests across worker containers.</div><br/><div id="40923462" class="c"><input type="checkbox" id="c-40923462" checked=""/><div class="controls bullet"><span class="by">nfachan</span><span>|</span><a href="#40923057">parent</a><span>|</span><a href="#40923486">next</a><span>|</span><label class="collapse" for="c-40923462">[-]</label><label class="expand" for="c-40923462">[1 more]</label></div><br/><div class="children"><div class="content">At my previous company, we had a lot of tests. They were a mix of C and Python. Running all of them on a single machine took on the order of an hour or more. Even just limiting the tests run to those that could theoretically be affected by your change could take minutes or even tens of minutes.<p>We ended up building a shared cluster of ~1000 cores that was available to all developers, and that was used by CI. This changed our developers&#x27; workflows quite a bit. It was now possible to run large amounts of tests regularly: like every few minutes instead of a once or twice a day. This in turn encouraged developers to write more tests and do more test-driven development.<p>On top of that, having the cluster available provided other benefits. If a test was flakey, it was easy to run it tens or even hundreds of thousands of times, making it easy to reproduce and identify the bug. We also occasionally did Monte Carlo simulations, and it was really handy to have a lot of cores available for general developer use.<p>I got used to working that way and I&#x27;ve missed it since I left that company. So this project is an attempt to make a more general-purpose implementation of that system. I hope others will find similar workflows that make them more productive using this system or something like it.<p>Regarding the container-per-test idea. It really comes about because it&#x27;s the obvious way to package up jobs to submit them to a cluster. Plus, it makes tests reproducible for all developers in a project, and between developer machines and CI. Using Linux namespaces, the overhead of running tests in individual containers isn&#x27;t much more than running tests in individual processes.</div><br/></div></div><div id="40923486" class="c"><input type="checkbox" id="c-40923486" checked=""/><div class="controls bullet"><span class="by">nfachan</span><span>|</span><a href="#40923057">parent</a><span>|</span><a href="#40923462">prev</a><span>|</span><a href="#40923428">next</a><span>|</span><label class="collapse" for="c-40923486">[-]</label><label class="expand" for="c-40923486">[1 more]</label></div><br/><div class="children"><div class="content">I forgot to answer your two other questions.<p>Maelstrom is open source and we plan to keep it that way. We may look at ways of selling access to a hosted cluster as service. Test running is very elastic, and could benefit from having an elastic service to support it.<p>Maelstrom is completely root-less, so it&#x27;ll work inside of Docker just fine. We regularly test Maelstrom within Maelstrom.</div><br/></div></div></div></div><div id="40923428" class="c"><input type="checkbox" id="c-40923428" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#40923057">prev</a><span>|</span><a href="#40924610">next</a><span>|</span><label class="collapse" for="c-40923428">[-]</label><label class="expand" for="c-40923428">[2 more]</label></div><br/><div class="children"><div class="content">For Rust tests, can Maelstrom be combined with nextest [0]? (Maelstrom provides the cargo maelstrom command, and nextest provides the cargo nextest command, with no obvious way to compose them)<p>I guess an env variable to specify which test command to run (very low level) or something like cargo maelstrom --nextest would work (but then how to compose with other test runners?)<p>Now,<p>&gt; It&#x27;s fast. In most cases, Maelstrom is faster than cargo test, even without using clustering.<p>That&#x27;s surprising. Why is this the case?<p>Will Maelstrom without clustering (running on a single machine) be faster than nextest as well? (Nextest is also faster than bare cargo test [1])<p>Would combining nextest with Maelstrom bring further performance benefits, or is Malestrom already doing whatever improvements nextest do?<p>[0] <a href="https:&#x2F;&#x2F;nexte.st&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nexte.st&#x2F;</a><p>[1] <a href="https:&#x2F;&#x2F;nexte.st&#x2F;docs&#x2F;design&#x2F;how-it-works&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nexte.st&#x2F;docs&#x2F;design&#x2F;how-it-works&#x2F;</a></div><br/><div id="40923569" class="c"><input type="checkbox" id="c-40923569" checked=""/><div class="controls bullet"><span class="by">nfachan</span><span>|</span><a href="#40923428">parent</a><span>|</span><a href="#40924610">next</a><span>|</span><label class="collapse" for="c-40923569">[-]</label><label class="expand" for="c-40923569">[1 more]</label></div><br/><div class="children"><div class="content">Our desire is to provide a general test-running and job-running framework, not to built the world&#x27;s next test runner. We think nextest is great, and we were inspired by some of the things they did.<p>We&#x27;ve designed Maelstrom to be usable as a library. So you can build your own test runner or job runner. We&#x27;ve been in contact with Rain, the primary developer of nextest, regarding how we can make it so that nextest can use Maelstrom. We&#x27;d love nothing more than to have nextest be Maelstrom-ized (Maelstrom-ified?).<p>We definitely have a little bit of work to do, but we plan to make big steps with the API for the next release. Currently, the client library doesn&#x27;t give per-test updates until the test finishes. This means that you don&#x27;t know how long a test is taking to run until it&#x27;s completed (though we do provide a timeout feature). This is fine for our currently limited UI, but is probably insufficient for nextest.<p>Maelstrom in standalone mode running on a single machine is usually a bit slower than nextest. Maelstrom and nextest are similar in that they both run each test in their own processes, and they both do a good job of running enough test processes in parallel to keep the machine busy. Maelstrom has to do a little bit more work each time it starts a new process to set up the namespaces, so it&#x27;s always going to be a bit slower than nextest, but not by much.<p>One thing that Maelstrom does that I don&#x27;t think nextest does is to use Longest Processing Time First (LPT) scheduling (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Longest-processing-time-first_scheduling" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Longest-processing-time-first_...</a>). When the runtimes of tests varies a lot within a project, using LPT can result in big wins and more predictable runtimes. Maelstrom itself actually has some pretty long-running integration tests, and once we added LPT, running Maelstrom tests on Maelstrom is usually faster than running them on nextest. But again, we&#x27;re not talking about huge differences in single-machine cases.<p>I think cargo test is usually slower than both Maelstrom and nextest for the reasons described in the nextest documentation: cargo test doesn&#x27;t always keep enough test threads running to keep the machine busy. However, if you have a lot of really small tests all in a single crate, then cargo test can and does outperform both Maelstrom and nextest. The clap project (<a href="https:&#x2F;&#x2F;github.com&#x2F;clap-rs&#x2F;clap)is">https:&#x2F;&#x2F;github.com&#x2F;clap-rs&#x2F;clap)is</a> a good example of this.<p>I think Maelstrom does most of the performance things that nextest does. However, nextest obviously has a lot more features and integrations than Maelstrom.</div><br/></div></div></div></div><div id="40924610" class="c"><input type="checkbox" id="c-40924610" checked=""/><div class="controls bullet"><span class="by">geekodour</span><span>|</span><a href="#40923428">prev</a><span>|</span><a href="#40923278">next</a><span>|</span><label class="collapse" for="c-40924610">[-]</label><label class="expand" for="c-40924610">[1 more]</label></div><br/><div class="children"><div class="content">at first i thought it was about <a href="https:&#x2F;&#x2F;github.com&#x2F;jepsen-io&#x2F;maelstrom&#x2F;tree&#x2F;main">https:&#x2F;&#x2F;github.com&#x2F;jepsen-io&#x2F;maelstrom&#x2F;tree&#x2F;main</a> which shares the same name</div><br/></div></div><div id="40923278" class="c"><input type="checkbox" id="c-40923278" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40924610">prev</a><span>|</span><a href="#40922305">next</a><span>|</span><label class="collapse" for="c-40923278">[-]</label><label class="expand" for="c-40923278">[5 more]</label></div><br/><div class="children"><div class="content">A container implementation that depends neither on Docker <i>nor on runc</i> is at the very least interesting, by itself.</div><br/><div id="40923629" class="c"><input type="checkbox" id="c-40923629" checked=""/><div class="controls bullet"><span class="by">nfachan</span><span>|</span><a href="#40923278">parent</a><span>|</span><a href="#40923294">next</a><span>|</span><label class="collapse" for="c-40923629">[-]</label><label class="expand" for="c-40923629">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re interested, the main part of the container implementation is here: <a href="https:&#x2F;&#x2F;github.com&#x2F;maelstrom-software&#x2F;maelstrom&#x2F;blob&#x2F;main&#x2F;crates&#x2F;maelstrom-worker&#x2F;src&#x2F;executor.rs">https:&#x2F;&#x2F;github.com&#x2F;maelstrom-software&#x2F;maelstrom&#x2F;blob&#x2F;main&#x2F;cr...</a><p>For each test we run, we clone the worker process, then make a bunch of Linux syscalls to set everything up for the container, then exec the test. We use the trick of having the child process share the virtual memory of the parent until the test is exec&#x27;ed.<p>We also use a technique where we build up a &quot;program&quot; of simple operations (each operation more or less maps to a syscall) in the parent before cloning, then evaluate the program in the child. This gives us the same performance benefits of using posix_spawn or vfork, but lets us configure all of the namespace stuff while we&#x27;re spawning.<p>The code that&#x27;s run in the child can be found here: <a href="https:&#x2F;&#x2F;github.com&#x2F;maelstrom-software&#x2F;maelstrom&#x2F;blob&#x2F;main&#x2F;crates&#x2F;maelstrom-worker-child&#x2F;src&#x2F;lib.rs">https:&#x2F;&#x2F;github.com&#x2F;maelstrom-software&#x2F;maelstrom&#x2F;blob&#x2F;main&#x2F;cr...</a></div><br/></div></div><div id="40923294" class="c"><input type="checkbox" id="c-40923294" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#40923278">parent</a><span>|</span><a href="#40923629">prev</a><span>|</span><a href="#40922305">next</a><span>|</span><label class="collapse" for="c-40923294">[-]</label><label class="expand" for="c-40923294">[3 more]</label></div><br/><div class="children"><div class="content">It’s very easy to write one. I’ve done it in half an hour <i>in bash</i>.  (Most of the half hour was spent cursing at various versions of util-linux that were broken in creative ways.)<p>Doing it <i>well</i> is a different story.</div><br/><div id="40923376" class="c"><input type="checkbox" id="c-40923376" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40923278">root</a><span>|</span><a href="#40923294">parent</a><span>|</span><a href="#40922305">next</a><span>|</span><label class="collapse" for="c-40923376">[-]</label><label class="expand" for="c-40923376">[2 more]</label></div><br/><div class="children"><div class="content">Well, yes, chroot, cgroups, mount --bind, and some ipfw &#x2F; iptables stuff is enough to create a makeshift container.<p>I <i>hope</i> these guys are into doing it <i>well</i>, else runc would be more than adequate for low-level stuff.</div><br/><div id="40923717" class="c"><input type="checkbox" id="c-40923717" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#40923278">root</a><span>|</span><a href="#40923376">parent</a><span>|</span><a href="#40922305">next</a><span>|</span><label class="collapse" for="c-40923717">[-]</label><label class="expand" for="c-40923717">[1 more]</label></div><br/><div class="children"><div class="content">If anyone is doing it from scratch, in a real programming language (which, for better or for worse, seems to currently mean C or Go or futzing with the FFI raw syscalls), one shouldn’t use chroot or the mount syscall. The new mount API is <i>much</i> better.<p>Cgroups are nice and add some fun features, but they’re just icing on the cake and are also not necessary, even for a very functional and nicely secure container, unless the stuff inside the container needs cgroup delegation.<p>Using iptables to make a container is IMO pathetic, and I’m hoping to find time at some point to work out something better.</div><br/></div></div></div></div></div></div></div></div><div id="40922305" class="c"><input type="checkbox" id="c-40922305" checked=""/><div class="controls bullet"><span class="by">electric_mayhem</span><span>|</span><a href="#40923278">prev</a><span>|</span><label class="collapse" for="c-40922305">[-]</label><label class="expand" for="c-40922305">[2 more]</label></div><br/><div class="children"><div class="content">Came here for the 90s shareware game from Ambrosia for the Mac.<p>I guess this is cool too though.</div><br/><div id="40923427" class="c"><input type="checkbox" id="c-40923427" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#40922305">parent</a><span>|</span><label class="collapse" for="c-40923427">[-]</label><label class="expand" for="c-40923427">[1 more]</label></div><br/><div class="children"><div class="content">There was also a development company called Maelstrom Games, known for <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Midwinter_(video_game)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Midwinter_(video_game)</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>