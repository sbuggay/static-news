<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1718614868161" as="style"/><link rel="stylesheet" href="styles.css?v=1718614868161"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mko.re/blog/swift-alpine-packaging/">Packaging Swift Apps for Alpine Linux</a> <span class="domain">(<a href="https://mko.re">mko.re</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>38 comments</span></div><br/><div><div id="40698799" class="c"><input type="checkbox" id="c-40698799" checked=""/><div class="controls bullet"><span class="by">silisili</span><span>|</span><a href="#40703591">prev</a><span>|</span><a href="#40698503">next</a><span>|</span><label class="collapse" for="c-40698799">[-]</label><label class="expand" for="c-40698799">[15 more]</label></div><br/><div class="children"><div class="content">I was curious how large these static binaries would be since the last announcement.  Being honest, 100MB is quite a bit larger than I was expecting.  Probably fine for CI business apps and such, but kinda rules out a lot of linux util type things.</div><br/><div id="40699390" class="c"><input type="checkbox" id="c-40699390" checked=""/><div class="controls bullet"><span class="by">repelsteeltje</span><span>|</span><a href="#40698799">parent</a><span>|</span><a href="#40700464">next</a><span>|</span><label class="collapse" for="c-40699390">[-]</label><label class="expand" for="c-40699390">[8 more]</label></div><br/><div class="children"><div class="content">I seem to have missed the part where he explains <i>why</i> he&#x27;s targeting Alpine Linux for his Swift app. Alpine isn&#x27;t mainstream (the way Ubuntu or rhel are) and stands out mostly for being compact and clutter free.<p>So... indeed... If you somehow end up with 100MB package for what is essentially just 250kB, I&#x27;d say something did not go right. Feels very square peg in round hole.</div><br/><div id="40699727" class="c"><input type="checkbox" id="c-40699727" checked=""/><div class="controls bullet"><span class="by">Tildey</span><span>|</span><a href="#40698799">root</a><span>|</span><a href="#40699390">parent</a><span>|</span><a href="#40699550">next</a><span>|</span><label class="collapse" for="c-40699727">[-]</label><label class="expand" for="c-40699727">[3 more]</label></div><br/><div class="children"><div class="content">If I had to guess, Alpine is a very popular choice for building container images in Docker&#x2F;Kubernetes&#x2F;whatever the new hotness is since I last worked with containers. Mostly because the aforementioned small size and low overhead add up if you’re at any sort of scale (even one instance on top of your desktop OS).<p>If you’re wanting to containerise the program, maybe it’s less resource intensive to add those things to Alpine than to run another distro with more support? Obviously only speculation</div><br/><div id="40700389" class="c"><input type="checkbox" id="c-40700389" checked=""/><div class="controls bullet"><span class="by">iudqnolq</span><span>|</span><a href="#40698799">root</a><span>|</span><a href="#40699727">parent</a><span>|</span><a href="#40699550">next</a><span>|</span><label class="collapse" for="c-40700389">[-]</label><label class="expand" for="c-40700389">[2 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t Kubernetes deduplicate layers by hash? I thought the key to minimizing overhead was standardizing on a limited set of images across everything you&#x27;ll be running on the same host.<p>Just from reading HN it seems like Alpine had a brief fad a few years ago but never got much traction.</div><br/><div id="40700492" class="c"><input type="checkbox" id="c-40700492" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#40698799">root</a><span>|</span><a href="#40700389">parent</a><span>|</span><a href="#40699550">next</a><span>|</span><label class="collapse" for="c-40700492">[-]</label><label class="expand" for="c-40700492">[1 more]</label></div><br/><div class="children"><div class="content">the underlying container runtime (usually containerd) will dedupe shared layers, but there&#x27;s a lot of things you don&#x27;t get to directly control, like third party apps, and the bottleneck when spinning up new nodes is real. Plus, envs where there isn&#x27;t that much caching, like CI.</div><br/></div></div></div></div></div></div><div id="40699550" class="c"><input type="checkbox" id="c-40699550" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#40698799">root</a><span>|</span><a href="#40699390">parent</a><span>|</span><a href="#40699727">prev</a><span>|</span><a href="#40700189">next</a><span>|</span><label class="collapse" for="c-40699550">[-]</label><label class="expand" for="c-40699550">[1 more]</label></div><br/><div class="children"><div class="content">Some of us are just using Alpine as our primary OS, and would need a compelling reason to do anything else.</div><br/></div></div><div id="40700189" class="c"><input type="checkbox" id="c-40700189" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#40698799">root</a><span>|</span><a href="#40699390">parent</a><span>|</span><a href="#40699550">prev</a><span>|</span><a href="#40700088">next</a><span>|</span><label class="collapse" for="c-40700189">[-]</label><label class="expand" for="c-40700189">[2 more]</label></div><br/><div class="children"><div class="content">The Alpine Linux docker image is 7.8 MiB to Ubuntu&#x27;s 76 MiB, so they get a savings of about 68 MiB in image size by using Alpine Linux over Ubuntu.<p>From the stats in TFA it looks like about 43 MiB of the file size is the Swift runtime itself, which would need to be installed in any OS. This leaves ~57 MiB extra in their static binary approach vs what they&#x27;d get out of dynamic linking.<p>68 MiB (saved by using alpine) - 57 MiB (lost to static linking) = 11 MiB (net gains from Alpine), so their Alpine Linux solution is actually about 10% smaller than the equivalent that uses an Ubuntu image.<p>Is that worth the extra work they put into it? It probably depends on the application.</div><br/><div id="40701920" class="c"><input type="checkbox" id="c-40701920" checked=""/><div class="controls bullet"><span class="by">jonhohle</span><span>|</span><a href="#40698799">root</a><span>|</span><a href="#40700189">parent</a><span>|</span><a href="#40700088">next</a><span>|</span><label class="collapse" for="c-40701920">[-]</label><label class="expand" for="c-40701920">[1 more]</label></div><br/><div class="children"><div class="content">Depending on how builds and deployments are done, there is a high likelihood that the lower userspace layers are much slower moving than the upper application layers. After your second build, dynamic linking wins and everything after that it pulls even further ahead.<p>Smart builds can make application deltas really small. I helped design a system where our several hundred MB monolith could be hot patches with a layer of a few thousand kilobytes and most builds were 10-20MB. Obviously this wouldn’t have worked for a statically linked app.</div><br/></div></div></div></div></div></div><div id="40700464" class="c"><input type="checkbox" id="c-40700464" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#40698799">parent</a><span>|</span><a href="#40699390">prev</a><span>|</span><a href="#40700671">next</a><span>|</span><label class="collapse" for="c-40700464">[-]</label><label class="expand" for="c-40700464">[4 more]</label></div><br/><div class="children"><div class="content">A big chunk (roughly a quarter) of it is the Unicode handling library.<p>I think eventually the stdlib will be split up more so that it’s not one giant blob, but there’s a lot of areas that will be reducing in the future.</div><br/><div id="40700539" class="c"><input type="checkbox" id="c-40700539" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40698799">root</a><span>|</span><a href="#40700464">parent</a><span>|</span><a href="#40700671">next</a><span>|</span><label class="collapse" for="c-40700539">[-]</label><label class="expand" for="c-40700539">[3 more]</label></div><br/><div class="children"><div class="content">75M is still huge for this type of thing.<p>My smallest Go CLI is 1.6M. This is probably about as small as you can get in Go and still do something useful. Some of my other (larger) Go CLIs range from ~2.5M to ~6.5M. Go is not known for producing small binaries.</div><br/><div id="40700916" class="c"><input type="checkbox" id="c-40700916" checked=""/><div class="controls bullet"><span class="by">BoingBoomTschak</span><span>|</span><a href="#40698799">root</a><span>|</span><a href="#40700539">parent</a><span>|</span><a href="#40701859">next</a><span>|</span><label class="collapse" for="c-40700916">[-]</label><label class="expand" for="c-40700916">[1 more]</label></div><br/><div class="children"><div class="content">For fun, I made an executable hello world with SBCL and it came out weighing 40MB (no compression, of course); this also includes Unicode data and a complete compiler. Something&#x27;s wrong here.</div><br/></div></div><div id="40701859" class="c"><input type="checkbox" id="c-40701859" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#40698799">root</a><span>|</span><a href="#40700539">parent</a><span>|</span><a href="#40700916">prev</a><span>|</span><a href="#40700671">next</a><span>|</span><label class="collapse" for="c-40701859">[-]</label><label class="expand" for="c-40701859">[1 more]</label></div><br/><div class="children"><div class="content">My point is that the issue is the stdlib is monolithic at the moment. As it gets split up in the near future, the binaries will reduce in size.</div><br/></div></div></div></div></div></div></div></div><div id="40698503" class="c"><input type="checkbox" id="c-40698503" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#40698799">prev</a><span>|</span><a href="#40700971">next</a><span>|</span><label class="collapse" for="c-40698503">[-]</label><label class="expand" for="c-40698503">[3 more]</label></div><br/><div class="children"><div class="content">Similar to chroot, I wonder if flatpak is a good option? Obviously native is better but I know that that works because that&#x27;s how I&#x27;ve run Steam on Alpine</div><br/><div id="40699245" class="c"><input type="checkbox" id="c-40699245" checked=""/><div class="controls bullet"><span class="by">xena</span><span>|</span><a href="#40698503">parent</a><span>|</span><a href="#40700971">next</a><span>|</span><label class="collapse" for="c-40699245">[-]</label><label class="expand" for="c-40699245">[2 more]</label></div><br/><div class="children"><div class="content">Flatpak isn&#x27;t really intended for command-line apps. Maybe this is where something like dockerc (<a href="https:&#x2F;&#x2F;github.com&#x2F;NilsIrl&#x2F;dockerc">https:&#x2F;&#x2F;github.com&#x2F;NilsIrl&#x2F;dockerc</a>) can shine?</div><br/><div id="40700267" class="c"><input type="checkbox" id="c-40700267" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#40698503">root</a><span>|</span><a href="#40699245">parent</a><span>|</span><a href="#40700971">next</a><span>|</span><label class="collapse" for="c-40700267">[-]</label><label class="expand" for="c-40700267">[1 more]</label></div><br/><div class="children"><div class="content">Nix is another option for static builds. There is a `pkgsStatic` tree for building static musl-linked binaries, which would be a perfect integration point for Swift&#x27;s static Linux target.</div><br/></div></div></div></div></div></div><div id="40700971" class="c"><input type="checkbox" id="c-40700971" checked=""/><div class="controls bullet"><span class="by">xvilka</span><span>|</span><a href="#40698503">prev</a><span>|</span><a href="#40698915">next</a><span>|</span><label class="collapse" for="c-40700971">[-]</label><label class="expand" for="c-40700971">[12 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no reason to use Swift outside of the Apple platform. Rust is much better option and more cross-platform. And they work hard on reducing the binary size as well.</div><br/><div id="40702010" class="c"><input type="checkbox" id="c-40702010" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#40700971">parent</a><span>|</span><a href="#40701007">next</a><span>|</span><label class="collapse" for="c-40702010">[-]</label><label class="expand" for="c-40702010">[9 more]</label></div><br/><div class="children"><div class="content">This is like a C++ dev saying there’s no reason to use rust.<p>Swift offers a lot of ergonomic values over rust in ways that have made me switch over as my default choice.<p>Things like default argument values, lazy static initializers, computed properties, optional chaining.  I’ve personally also come around to ref counting by default being a sensible choice for most programs.<p>Though the thing that won me over was the recent C++ interoperability. Rust doesn’t have a good story there yet that’s as comparable. Hours&#x2F;days&#x2F;months writing Rust bindings for a C++ library are often minutes in Swift.<p>Each language has its own place and own benefits, but to say there’s “no reason to use a language” feels short sighted and defensively dismissive</div><br/><div id="40702027" class="c"><input type="checkbox" id="c-40702027" checked=""/><div class="controls bullet"><span class="by">xvilka</span><span>|</span><a href="#40700971">root</a><span>|</span><a href="#40702010">parent</a><span>|</span><a href="#40701007">next</a><span>|</span><label class="collapse" for="c-40702027">[-]</label><label class="expand" for="c-40702027">[8 more]</label></div><br/><div class="children"><div class="content">I would agree with you but in the case of Swift is largely confined to the Apple ecosystem with other platforms as an afterthought, while both C++ and Rust try to cover as many targets as possible.</div><br/><div id="40702062" class="c"><input type="checkbox" id="c-40702062" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#40700971">root</a><span>|</span><a href="#40702027">parent</a><span>|</span><a href="#40703353">next</a><span>|</span><label class="collapse" for="c-40702062">[-]</label><label class="expand" for="c-40702062">[6 more]</label></div><br/><div class="children"><div class="content">But that is exactly what is changing right now.<p>Foundation is being rewritten in Swift, Swift has moved out from under apples GitHub and is pushing more cross platform tooling for windows and Linux.<p>It’s not as flexible in terms of targets yet as Rust, but it’s also not just locked to Apple platforms.<p>And for a big chunk of developers, that trade off is fine.</div><br/><div id="40703108" class="c"><input type="checkbox" id="c-40703108" checked=""/><div class="controls bullet"><span class="by">graboid</span><span>|</span><a href="#40700971">root</a><span>|</span><a href="#40702062">parent</a><span>|</span><a href="#40702545">next</a><span>|</span><label class="collapse" for="c-40703108">[-]</label><label class="expand" for="c-40703108">[3 more]</label></div><br/><div class="children"><div class="content">I am quite curious about Swift as a &quot;more ergonomic Rust&quot;. How would you say it fares for typical backend stuff?</div><br/><div id="40703264" class="c"><input type="checkbox" id="c-40703264" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#40700971">root</a><span>|</span><a href="#40703108">parent</a><span>|</span><a href="#40702545">next</a><span>|</span><label class="collapse" for="c-40703264">[-]</label><label class="expand" for="c-40703264">[2 more]</label></div><br/><div class="children"><div class="content">Currently the state of server side dev is a bit here and there.<p>Vapor is the preferred framework and in general will seem familiar to anyone using any of the Rust server frameworks like actix web etc…<p>A tutorial for reference <a href="https:&#x2F;&#x2F;swift.org&#x2F;getting-started&#x2F;vapor-web-server&#x2F;" rel="nofollow">https:&#x2F;&#x2F;swift.org&#x2F;getting-started&#x2F;vapor-web-server&#x2F;</a><p>From an ergonomics perspective, I write less code with Vapor than the equivalent Rust frameworks. It is slower today though but plenty for my needs, with some speed ups coming with Vapor refactors down the pipe.<p>I find that I need to spend less time managing shared resources with concurrency , and my code is clearer while being less verbose in general. Features like the trailing closure syntax are much easier to read for me.<p>I find it closer to how I’d write my Flask servers in the amount of code I need to do myself.</div><br/><div id="40703317" class="c"><input type="checkbox" id="c-40703317" checked=""/><div class="controls bullet"><span class="by">graboid</span><span>|</span><a href="#40700971">root</a><span>|</span><a href="#40703264">parent</a><span>|</span><a href="#40702545">next</a><span>|</span><label class="collapse" for="c-40703317">[-]</label><label class="expand" for="c-40703317">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing.</div><br/></div></div></div></div></div></div><div id="40702545" class="c"><input type="checkbox" id="c-40702545" checked=""/><div class="controls bullet"><span class="by">bobajeff</span><span>|</span><a href="#40700971">root</a><span>|</span><a href="#40702062">parent</a><span>|</span><a href="#40703108">prev</a><span>|</span><a href="#40703353">next</a><span>|</span><label class="collapse" for="c-40702545">[-]</label><label class="expand" for="c-40702545">[2 more]</label></div><br/><div class="children"><div class="content">It remains to be seen weather Swift will break out of being just a language for programming Apple applications.<p>There is still no way to make gui applications outside of Apple devices. Unless you want to make your own library or generate&#x2F;maintain Swift bindings for an existing UI library.<p>Maybe, it will be okay for console only programs or servers but why use that over Java&#x2F;JVM, nodejs or go?</div><br/><div id="40702792" class="c"><input type="checkbox" id="c-40702792" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#40700971">root</a><span>|</span><a href="#40702545">parent</a><span>|</span><a href="#40703353">next</a><span>|</span><label class="collapse" for="c-40702792">[-]</label><label class="expand" for="c-40702792">[1 more]</label></div><br/><div class="children"><div class="content">UI libraries are a poor reason to pick Rust over Swift, given that Rust has a very poor UI story.<p>Doesn’t your comment apply very equally to Rust? There’s basically Slint and Tauri, and several bindings in various states of disarray. Not exactly very compelling.<p>The Rust ecosystem has very many strengths, but UI is not one of them.<p>Regardless, you’re incorrect about there being no way to make GUI applications<p>Here’s a Gnome binding <a href="https:&#x2F;&#x2F;swift.org&#x2F;blog&#x2F;adwaita-swift&#x2F;" rel="nofollow">https:&#x2F;&#x2F;swift.org&#x2F;blog&#x2F;adwaita-swift&#x2F;</a><p>The C++ interop allows easy binding to Qt <a href="https:&#x2F;&#x2F;github.com&#x2F;qt&#x2F;qtdeclarative&#x2F;tree&#x2F;dev&#x2F;tests&#x2F;manual&#x2F;helloswift">https:&#x2F;&#x2F;github.com&#x2F;qt&#x2F;qtdeclarative&#x2F;tree&#x2F;dev&#x2F;tests&#x2F;manual&#x2F;he...</a><p>Win32 <a href="https:&#x2F;&#x2F;github.com&#x2F;compnerd&#x2F;swift-win32">https:&#x2F;&#x2F;github.com&#x2F;compnerd&#x2F;swift-win32</a><p>The fact that Swift has easier C++ interop than Rust makes the cross platform UI story much easier and more compelling than what I’ve found in Rust.<p>Bindings are much simpler to manage and can be handled by a single module map file with a single line in it most of the time.<p>Adding to that, many well established UI libraries depend on classes to implement them. Rusts lack of classes, while wonderful otherwise, makes binding to heavy class based libraries very onerous.<p>Don’t get me wrong, I really enjoy rust. It’s just, it’s very ill suited for UI work today itself. I almost always write my UI side in C++ if I have to and bind over when needed instead.</div><br/></div></div></div></div></div></div><div id="40703353" class="c"><input type="checkbox" id="c-40703353" checked=""/><div class="controls bullet"><span class="by">JoeMattiello</span><span>|</span><a href="#40700971">root</a><span>|</span><a href="#40702027">parent</a><span>|</span><a href="#40702062">prev</a><span>|</span><a href="#40701007">next</a><span>|</span><label class="collapse" for="c-40703353">[-]</label><label class="expand" for="c-40703353">[1 more]</label></div><br/><div class="children"><div class="content">It really isn’t though. All my iOS swift code that doesn’t touch UIKit has been running unit tests with Linux Debian on GitHub actions for a few years now with almost no extra effort.<p>Any api or data model code, pretty much 80% of my app code works crosss platform</div><br/></div></div></div></div></div></div><div id="40701007" class="c"><input type="checkbox" id="c-40701007" checked=""/><div class="controls bullet"><span class="by">isodev</span><span>|</span><a href="#40700971">parent</a><span>|</span><a href="#40702010">prev</a><span>|</span><a href="#40701142">next</a><span>|</span><label class="collapse" for="c-40701007">[-]</label><label class="expand" for="c-40701007">[1 more]</label></div><br/><div class="children"><div class="content">Also self-inflicting Apple’s “what happens not a Mac” developer experience may not be what one wants to go through during the lifetime of an app.</div><br/></div></div><div id="40701142" class="c"><input type="checkbox" id="c-40701142" checked=""/><div class="controls bullet"><span class="by">mannuch</span><span>|</span><a href="#40700971">parent</a><span>|</span><a href="#40701007">prev</a><span>|</span><a href="#40698915">next</a><span>|</span><label class="collapse" for="c-40701142">[-]</label><label class="expand" for="c-40701142">[1 more]</label></div><br/><div class="children"><div class="content">Well I for one appreciate Swift’s focus on ergonomics and progressive disclosure. I think Rust is great, but I don’t see it as a great application-level programming language.<p>I think it’s wonderful that Swift is trying to be more cross-platform. No need to shoot down the efforts of people trying to bring a language they like to more places.</div><br/></div></div></div></div><div id="40698915" class="c"><input type="checkbox" id="c-40698915" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40700971">prev</a><span>|</span><a href="#40698820">next</a><span>|</span><label class="collapse" for="c-40698915">[-]</label><label class="expand" for="c-40698915">[5 more]</label></div><br/><div class="children"><div class="content">Hmm, so it includes the entirety of Swift&#x27;s standard library? Isn&#x27;t there an option to tree shake&#x2F;trim it? That&#x27;s what .NET AOT compilation does (standard library is always included, sans the dependency on glibc or musl, which you can statically link into the binary as well should you need that)</div><br/><div id="40698985" class="c"><input type="checkbox" id="c-40698985" checked=""/><div class="controls bullet"><span class="by">JCWasmx86</span><span>|</span><a href="#40698915">parent</a><span>|</span><a href="#40699700">next</a><span>|</span><label class="collapse" for="c-40698985">[-]</label><label class="expand" for="c-40698985">[3 more]</label></div><br/><div class="children"><div class="content">The biggest symbol of a statically linked swift binary that I have, is icudt_swift65_dat with 27.98MB, so I think that&#x27;s not so easy to remove (nm v3.1.2 --size-sort --radix=d|swift demangle) And I think if you strip debuginfo it will be smaller (For a statically linked program of mine: 98MB -&gt; 56MB)<p>But I think for a distribution it makes more sense to link swift programs dynamically against the runtime libraries, like it&#x27;s the case for e.g. the C standard library, OpenSSL etc., as you can assume they all work with the same version and are ABI-compatible.<p>I tested it with a nearly static build (Still links against glibc and friends): 55MB get stripped to 44MB, so not that much. 27MB of that is icudt_swift65_dat, so I guess you would have to optimise that first</div><br/><div id="40699098" class="c"><input type="checkbox" id="c-40699098" checked=""/><div class="controls bullet"><span class="by">0xTim</span><span>|</span><a href="#40698915">root</a><span>|</span><a href="#40698985">parent</a><span>|</span><a href="#40699057">next</a><span>|</span><label class="collapse" for="c-40699098">[-]</label><label class="expand" for="c-40699098">[1 more]</label></div><br/><div class="children"><div class="content">With the new Foundation work going on, when you migrate to that, if you don&#x27;t import `FoundationInternationalization` then you won&#x27;t pull in all of ICU and it won&#x27;t be bundled in</div><br/></div></div><div id="40699057" class="c"><input type="checkbox" id="c-40699057" checked=""/><div class="controls bullet"><span class="by">georgelyon</span><span>|</span><a href="#40698915">root</a><span>|</span><a href="#40698985">parent</a><span>|</span><a href="#40699098">prev</a><span>|</span><a href="#40699700">next</a><span>|</span><label class="collapse" for="c-40699057">[-]</label><label class="expand" for="c-40699057">[1 more]</label></div><br/><div class="children"><div class="content">If I’m not mistaken, the embedded swift mode aims to make ICU (the 27mb file for Unicode support) optional (and thus easily removed where it isn’t needed)</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>