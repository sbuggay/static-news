<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1736586060714" as="style"/><link rel="stylesheet" href="styles.css?v=1736586060714"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.cs.cornell.edu/~asampson/blog/flattening.html">Flattening ASTs and other compiler data structures (2023)</a> <span class="domain">(<a href="https://www.cs.cornell.edu">www.cs.cornell.edu</a>)</span></div><div class="subtext"><span>aw1621107</span> | <span>22 comments</span></div><br/><div><div id="42660665" class="c"><input type="checkbox" id="c-42660665" checked=""/><div class="controls bullet"><span class="by">dmagyari</span><span>|</span><a href="#42663700">next</a><span>|</span><label class="collapse" for="c-42660665">[-]</label><label class="expand" for="c-42660665">[4 more]</label></div><br/><div class="children"><div class="content">&quot;Instead of allocating Expr objects willy-nilly on the heap, we’ll pack them into a single, contiguous array.&quot;
Zig compiler pipeline (AST, Zir, Air, Sema) does exactly this on all layers. Not only contiguous, but instead of array-of-structs it is struct-of-arrays, so walking the tree is even more cache friendly. For AST see: <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;master&#x2F;lib&#x2F;std&#x2F;zig&#x2F;Ast.zig#L13">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;master&#x2F;lib&#x2F;std&#x2F;zig&#x2F;Ast.z...</a></div><br/><div id="42664068" class="c"><input type="checkbox" id="c-42664068" checked=""/><div class="controls bullet"><span class="by">gritzko</span><span>|</span><a href="#42660665">parent</a><span>|</span><a href="#42662156">next</a><span>|</span><label class="collapse" for="c-42664068">[-]</label><label class="expand" for="c-42664068">[1 more]</label></div><br/><div class="children"><div class="content">I work on a C dialect where <i>everything</i> is flattened. JSON and other trees in particular. Binary heaps are flat, merge sort and iterator heaps are absolutely great, can build LSM databases with that. Stacks, circular buffers, hash maps, etc, all flat. Templated output (PHP like) is done by a flat data structure.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;gritzko&#x2F;librdx&#x2F;blob&#x2F;master&#x2F;abc&#x2F;B.md">https:&#x2F;&#x2F;github.com&#x2F;gritzko&#x2F;librdx&#x2F;blob&#x2F;master&#x2F;abc&#x2F;B.md</a><p>Apart from locality and lifetimes, these flat data structures improve <i>composability</i>.
When every data structure is a flat buffer, you can mmap them or zip them or send them by the network, all by the same routine. They are uniform like bricks, in a sense.</div><br/></div></div><div id="42662156" class="c"><input type="checkbox" id="c-42662156" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#42660665">parent</a><span>|</span><a href="#42664068">prev</a><span>|</span><a href="#42663700">next</a><span>|</span><label class="collapse" for="c-42662156">[-]</label><label class="expand" for="c-42662156">[2 more]</label></div><br/><div class="children"><div class="content">Makes me wonder if people in APL&#x2F;J&#x2F;K community have not been influenced or influencing this kind of technique. IIRC Aaron Hsu does tree processing through arrays (but i&#x27;m not skilled enough to analyze his code)</div><br/><div id="42663960" class="c"><input type="checkbox" id="c-42663960" checked=""/><div class="controls bullet"><span class="by">gsf_emergency</span><span>|</span><a href="#42660665">root</a><span>|</span><a href="#42662156">parent</a><span>|</span><a href="#42663700">next</a><span>|</span><label class="collapse" for="c-42663960">[-]</label><label class="expand" for="c-42663960">[1 more]</label></div><br/><div class="children"><div class="content">Do you have a link to such an example of Aaron&#x27;s code? Thank you in advance!</div><br/></div></div></div></div></div></div><div id="42663700" class="c"><input type="checkbox" id="c-42663700" checked=""/><div class="controls bullet"><span class="by">jgrowl</span><span>|</span><a href="#42660665">prev</a><span>|</span><a href="#42664308">next</a><span>|</span><label class="collapse" for="c-42663700">[-]</label><label class="expand" for="c-42663700">[1 more]</label></div><br/><div class="children"><div class="content">I thought a reddit comment on this article had an interesting point:<p><a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;1d3b356&#x2F;my_new_favorite_way_to_represent_asts_or_any&#x2F;l6al1q8&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;1d3b356&#x2F;my_new_favori...</a><p>[–]Timzhy0 3 points 7 months ago<p>Btw I think one can go a step further than the author, there is no need to keep two explicit ExprRef baked in a binary node (lhs, rhs). You can exploit locality, basically the AST, seen it the LISP way, is just an arbitrarily nestable list, where elements are atoms or other lists. Hence all you need to know is where each list ends (and if it&#x27;s an atom you can assume it spans one node) and actually one bit to know if it is the last entry in the list is quite ergonomic as well (because then you can distinguish whether moving next slot in the AST means there is a sibling). Basically it&#x27;s easier to keep it sync while constructing and takes up less memory per node. I pay 40 bits per node, stored interleaved for best cache locality (some unaligned accesses but I think it&#x27;s still worthwhile), 8 bits for the tag, 32 for the data, if data is bigger, 32 is an index into some auxiliary segment (basically a ptr).</div><br/></div></div><div id="42664308" class="c"><input type="checkbox" id="c-42664308" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42663700">prev</a><span>|</span><a href="#42660934">next</a><span>|</span><label class="collapse" for="c-42664308">[-]</label><label class="expand" for="c-42664308">[2 more]</label></div><br/><div class="children"><div class="content">Rediscovering techniques that were somewhat well-known in the 70s and 80s.<p>See also: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Binary_heap" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Binary_heap</a></div><br/><div id="42664354" class="c"><input type="checkbox" id="c-42664354" checked=""/><div class="controls bullet"><span class="by">Taniwha</span><span>|</span><a href="#42664308">parent</a><span>|</span><a href="#42660934">next</a><span>|</span><label class="collapse" for="c-42664354">[-]</label><label class="expand" for="c-42664354">[1 more]</label></div><br/><div class="children"><div class="content">heh - I built compilers this back in the 70s because the machine I was working on didn&#x27;t really do pointers as a 1st class data structure (B6700 algol), it&#x27;s not really surprising finding someone doing something similar in another language that makes pointers difficult to deal with</div><br/></div></div></div></div><div id="42660934" class="c"><input type="checkbox" id="c-42660934" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42664308">prev</a><span>|</span><a href="#42660769">next</a><span>|</span><label class="collapse" for="c-42660934">[-]</label><label class="expand" for="c-42660934">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Instead of allocating Expr objects willy-nilly on the heap, we’ll pack them into a single, contiguous array.</i><p>This happens naturally if you bump-allocate them in a garbage-collected run-time, particularly under a copying collector. Free lists also tend to co-locate because they are produced during sweep phases of GC which run through heaps in order of address.<p>Don&#x27;t make me bring out the L word for the billionth time.<p>&gt; <i>A flat array of Exprs can make it fun and easy to implement hash consing</i><p>OK, it&#x27;s not a case of L-ignorance, just willful neglect.</div><br/><div id="42661057" class="c"><input type="checkbox" id="c-42661057" checked=""/><div class="controls bullet"><span class="by">samps</span><span>|</span><a href="#42660934">parent</a><span>|</span><a href="#42660769">next</a><span>|</span><label class="collapse" for="c-42661057">[-]</label><label class="expand" for="c-42661057">[1 more]</label></div><br/><div class="children"><div class="content">FWIW I did acknowledge this in the article:<p>&gt; A sufficiently smart memory allocator might achieve the same thing, especially if you allocate the whole AST up front and never add to it<p>&gt; Again, a really fast malloc might be hard to compete with—but you basically can’t beat bump allocation on sheer simplicity.</div><br/></div></div></div></div><div id="42660769" class="c"><input type="checkbox" id="c-42660769" checked=""/><div class="controls bullet"><span class="by">emptysea</span><span>|</span><a href="#42660934">prev</a><span>|</span><a href="#42660674">next</a><span>|</span><label class="collapse" for="c-42660769">[-]</label><label class="expand" for="c-42660769">[2 more]</label></div><br/><div class="children"><div class="content">Rust-analyzer uses a similar technique for parsing  <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust-analyzer&#x2F;blob&#x2F;master&#x2F;crates&#x2F;parser&#x2F;src&#x2F;event.rs">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust-analyzer&#x2F;blob&#x2F;master&#x2F;crate...</a> which then gets fed into <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-analyzer&#x2F;rowan">https:&#x2F;&#x2F;github.com&#x2F;rust-analyzer&#x2F;rowan</a> (lossless syntax tree)</div><br/><div id="42662028" class="c"><input type="checkbox" id="c-42662028" checked=""/><div class="controls bullet"><span class="by">bradrn</span><span>|</span><a href="#42660769">parent</a><span>|</span><a href="#42660674">next</a><span>|</span><label class="collapse" for="c-42662028">[-]</label><label class="expand" for="c-42662028">[1 more]</label></div><br/><div class="children"><div class="content">There is a longer overview of it here: <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust-analyzer&#x2F;blob&#x2F;master&#x2F;docs&#x2F;dev&#x2F;syntax.md">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust-analyzer&#x2F;blob&#x2F;master&#x2F;docs&#x2F;...</a></div><br/></div></div></div></div><div id="42660674" class="c"><input type="checkbox" id="c-42660674" checked=""/><div class="controls bullet"><span class="by">cardanome</span><span>|</span><a href="#42660769">prev</a><span>|</span><a href="#42663611">next</a><span>|</span><label class="collapse" for="c-42660674">[-]</label><label class="expand" for="c-42660674">[1 more]</label></div><br/><div class="children"><div class="content">Amazing article, very good advice to keep your data structures flat.<p>Adding to that, it also makes editing the AST vastly more efficient.<p>I have discovered that principle on my own when I worked on an editor that directly operated on the AST instead of text. I found manipulating the tree-style AST so painful, constantly traversing the tree and all. Once I made it flat, my life was a hell lot easier. You can just directly index any part of AST in linear time.</div><br/></div></div><div id="42663611" class="c"><input type="checkbox" id="c-42663611" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#42660674">prev</a><span>|</span><a href="#42660621">next</a><span>|</span><label class="collapse" for="c-42663611">[-]</label><label class="expand" for="c-42663611">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>Flattening ASTs and other compiler data structures (2023)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42181603">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42181603</a> - Nov 2024 (2 comments)<p><i>Flattening ASTs and other compiler data structures</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36559346">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36559346</a> - July 2023 (81 comments)</div><br/></div></div><div id="42660621" class="c"><input type="checkbox" id="c-42660621" checked=""/><div class="controls bullet"><span class="by">ww520</span><span>|</span><a href="#42663611">prev</a><span>|</span><a href="#42661956">next</a><span>|</span><label class="collapse" for="c-42660621">[-]</label><label class="expand" for="c-42660621">[1 more]</label></div><br/><div class="children"><div class="content">This is a fantastic idea. AST works well in an array based allocation block since it has no need for freeing individual nodes. It’s an add-only allocation.</div><br/></div></div><div id="42661956" class="c"><input type="checkbox" id="c-42661956" checked=""/><div class="controls bullet"><span class="by">hencq</span><span>|</span><a href="#42660621">prev</a><span>|</span><a href="#42660888">next</a><span>|</span><label class="collapse" for="c-42661956">[-]</label><label class="expand" for="c-42661956">[4 more]</label></div><br/><div class="children"><div class="content">As the article mentions, this makes it quite similar to a bytecode vm. I think the traditional wisdom is that an AST walker is easy to write, but for speed you&#x27;d want a bytecode interpreter. It&#x27;d be interesting to see how close the performance gets with this flattened AST.<p>In practice I think there are more differences. E.g. AST interpreters tend to pass environments around while bytecode interpreters often store these on a stack (though I guess there&#x27;s nothing stopping you from doing this with an AST either). I wonder if there&#x27;s some goldilocks zone for ease of implementation with decent performance.</div><br/><div id="42662165" class="c"><input type="checkbox" id="c-42662165" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42661956">parent</a><span>|</span><a href="#42660888">next</a><span>|</span><label class="collapse" for="c-42662165">[-]</label><label class="expand" for="c-42662165">[3 more]</label></div><br/><div class="children"><div class="content">If you instead flatten the expression tree into RPN, then you can execute it like that, with a stack machine.<p>I seem to recall that the Red Dragon Book (<i>Compilers: Principles, Techniques and Tools</i>, Aho, Sethi, Ullman [1988]) describes a technique whereby intermediate code is represented in RPN, and transformations are performed by pattern matches on it.</div><br/><div id="42662547" class="c"><input type="checkbox" id="c-42662547" checked=""/><div class="controls bullet"><span class="by">finnh</span><span>|</span><a href="#42661956">root</a><span>|</span><a href="#42662165">parent</a><span>|</span><a href="#42660888">next</a><span>|</span><label class="collapse" for="c-42662547">[-]</label><label class="expand" for="c-42662547">[2 more]</label></div><br/><div class="children"><div class="content">The sample flat program in the post is exactly RPN, no?</div><br/><div id="42662905" class="c"><input type="checkbox" id="c-42662905" checked=""/><div class="controls bullet"><span class="by">samps</span><span>|</span><a href="#42661956">root</a><span>|</span><a href="#42662547">parent</a><span>|</span><a href="#42660888">next</a><span>|</span><label class="collapse" for="c-42662905">[-]</label><label class="expand" for="c-42662905">[1 more]</label></div><br/><div class="children"><div class="content">I think it would be more like RPN if it used a stack, and operands were specified as relative offsets (i.e., stack offsets). In the version I wrote, operands are still represented as absolute offsets in the expression table.</div><br/></div></div></div></div></div></div></div></div><div id="42660888" class="c"><input type="checkbox" id="c-42660888" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#42661956">prev</a><span>|</span><a href="#42663662">next</a><span>|</span><label class="collapse" for="c-42660888">[-]</label><label class="expand" for="c-42660888">[2 more]</label></div><br/><div class="children"><div class="content">Cool! Carbon is doing exactly this. I had asked leads if there was a paper on this approach, but they didn&#x27;t have anything for me. I&#x27;ll send them this post!</div><br/><div id="42661320" class="c"><input type="checkbox" id="c-42661320" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#42660888">parent</a><span>|</span><a href="#42663662">next</a><span>|</span><label class="collapse" for="c-42661320">[-]</label><label class="expand" for="c-42661320">[1 more]</label></div><br/><div class="children"><div class="content">Zig uses a MultiArrayList which sounds similar <a href="https:&#x2F;&#x2F;mitchellh.com&#x2F;zig&#x2F;parser" rel="nofollow">https:&#x2F;&#x2F;mitchellh.com&#x2F;zig&#x2F;parser</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>