<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734858060859" as="style"/><link rel="stylesheet" href="styles.css?v=1734858060859"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://0x80.pl/notesen/2024-12-21-uint8-division.html">Dividing unsigned 8-bit numbers</a> <span class="domain">(<a href="http://0x80.pl">0x80.pl</a>)</span></div><div class="subtext"><span>mfiguiere</span> | <span>62 comments</span></div><br/><div><div id="42481958" class="c"><input type="checkbox" id="c-42481958" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#42482145">next</a><span>|</span><label class="collapse" for="c-42481958">[-]</label><label class="expand" for="c-42481958">[17 more]</label></div><br/><div class="children"><div class="content">What&#x27;s not mentioned is that in most cases you have a <i>constant</i> divisor which lets you replace division by multiplication with the reciprocal. The reciprocal can be rounded to a nearby dyadic rational, letting you do the division with a right-shift.<p>For example, 8-bit division by 3 is equivalent to widening multiplication by 171 followed by a right-shift of 9, as 171&#x2F;2^9 = 0.333984375 which is close enough to 1&#x2F;3 that the results match exactly.</div><br/><div id="42482159" class="c"><input type="checkbox" id="c-42482159" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#42481958">parent</a><span>|</span><a href="#42483213">next</a><span>|</span><label class="collapse" for="c-42482159">[-]</label><label class="expand" for="c-42482159">[1 more]</label></div><br/><div class="children"><div class="content">A shift of 16 is enough for every 8-bit numerator, ie. x&#x2F;a is (u32(x)*b)&gt;&gt;16 for some b depending only on a. You could precompute b for each a and store it a lookup table. The largest b is b=65536 for a=1 and the smallest is b=258 for a=255, so b fits in a u16 if stored with a 1-offset. Not sure it&#x27;s worth it unless you reuse the denominator many times though.</div><br/></div></div><div id="42483213" class="c"><input type="checkbox" id="c-42483213" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#42481958">parent</a><span>|</span><a href="#42482159">prev</a><span>|</span><a href="#42482565">next</a><span>|</span><label class="collapse" for="c-42483213">[-]</label><label class="expand" for="c-42483213">[2 more]</label></div><br/><div class="children"><div class="content">These methods are especially useful in hardware&#x2F;FPGA implementations where it&#x27;s infeasible to have a ton of fully pipelined dividers.</div><br/><div id="42483493" class="c"><input type="checkbox" id="c-42483493" checked=""/><div class="controls bullet"><span class="by">andrepd</span><span>|</span><a href="#42481958">root</a><span>|</span><a href="#42483213">parent</a><span>|</span><a href="#42482565">next</a><span>|</span><label class="collapse" for="c-42483493">[-]</label><label class="expand" for="c-42483493">[1 more]</label></div><br/><div class="children"><div class="content">They are actually useful for optimising compilers too! Mul or mul+shifts is often faster than div</div><br/></div></div></div></div><div id="42482581" class="c"><input type="checkbox" id="c-42482581" checked=""/><div class="controls bullet"><span class="by">kevinventullo</span><span>|</span><a href="#42481958">parent</a><span>|</span><a href="#42482565">prev</a><span>|</span><a href="#42483414">next</a><span>|</span><label class="collapse" for="c-42482581">[-]</label><label class="expand" for="c-42482581">[5 more]</label></div><br/><div class="children"><div class="content">Also, if you know ahead of time that it’s exact division, there is a similar approach that doesn’t even need widening multiplication!</div><br/><div id="42482808" class="c"><input type="checkbox" id="c-42482808" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#42481958">root</a><span>|</span><a href="#42482581">parent</a><span>|</span><a href="#42483051">next</a><span>|</span><label class="collapse" for="c-42482808">[-]</label><label class="expand" for="c-42482808">[2 more]</label></div><br/><div class="children"><div class="content">Yes, if you know something is an exact multiple of n = r*2^k where r is odd, you can divide out the multiple by right-shifting k followed by modular multiplication by the modular multiplicative inverse of r.</div><br/><div id="42484138" class="c"><input type="checkbox" id="c-42484138" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#42481958">root</a><span>|</span><a href="#42482808">parent</a><span>|</span><a href="#42483051">next</a><span>|</span><label class="collapse" for="c-42484138">[-]</label><label class="expand" for="c-42484138">[1 more]</label></div><br/><div class="children"><div class="content">Theoretically, you could also take advantage of two&#x27;s complement arithmetic:<p><pre><code>       00011011 (27)
     x 01010101 (-0.333...)
    ------------------------
       11110111 (-9)
    
    invert and add one:
    
       00001001 (9, like we wanted)
</code></pre>
I&#x27;d be interested in extending this to non-exact multiples, but if that&#x27;s possible I don&#x27;t know how.</div><br/></div></div></div></div><div id="42483051" class="c"><input type="checkbox" id="c-42483051" checked=""/><div class="controls bullet"><span class="by">Footkerchief</span><span>|</span><a href="#42481958">root</a><span>|</span><a href="#42482581">parent</a><span>|</span><a href="#42482808">prev</a><span>|</span><a href="#42483414">next</a><span>|</span><label class="collapse" for="c-42483051">[-]</label><label class="expand" for="c-42483051">[2 more]</label></div><br/><div class="children"><div class="content">Can you provide an example with details?  Thanks!</div><br/><div id="42483334" class="c"><input type="checkbox" id="c-42483334" checked=""/><div class="controls bullet"><span class="by">kevinventullo</span><span>|</span><a href="#42481958">root</a><span>|</span><a href="#42483051">parent</a><span>|</span><a href="#42483414">next</a><span>|</span><label class="collapse" for="c-42483334">[-]</label><label class="expand" for="c-42483334">[1 more]</label></div><br/><div class="children"><div class="content">In 8-bit arithmetic (i.e. mod 256), the multiplicative inverse of 11 is 163. So, if you take some multiple of 11, say 154, then you can compute 154&#x2F;11 instead as 154*163.<p>Indeed,<p>154*163 = 25102, and<p>25102 = 14 (mod 256).</div><br/></div></div></div></div></div></div><div id="42482571" class="c"><input type="checkbox" id="c-42482571" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#42481958">parent</a><span>|</span><a href="#42483414">prev</a><span>|</span><a href="#42483639">next</a><span>|</span><label class="collapse" for="c-42482571">[-]</label><label class="expand" for="c-42482571">[5 more]</label></div><br/><div class="children"><div class="content">&gt; For example, 8-bit division by 3 is equivalent to widening multiplication by 171 followed by a right-shift of 9, as 171&#x2F;2^9 = 0.333984375 which is close enough to 1&#x2F;3 that the results match exactly.<p>Is this related to the fact that 171 is the multiplicative inverse of 3 (mod 256), or is that a coincidence?</div><br/><div id="42483232" class="c"><input type="checkbox" id="c-42483232" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42481958">root</a><span>|</span><a href="#42482571">parent</a><span>|</span><a href="#42482884">next</a><span>|</span><label class="collapse" for="c-42483232">[-]</label><label class="expand" for="c-42483232">[3 more]</label></div><br/><div class="children"><div class="content">Sort of. (After all, a &quot;reciprocal&quot; for our purposes is just a multiplicative inverse in the reals, so it makes sense that it would be related to the multiplicative inverse in other domains.)<p>3 times 171 is 513. So to divide by 3, we could multiply by 171 and then divide by 513. Dividing by 513... isn&#x27;t any easier, but 513 is close to 512, so we hope that dividing by 512 (which is trivial - just a right-shift) gets us close enough.<p>Suppose for a moment we try dividing 3 by 3 using this trick. First we&#x27;ll multiply by 171 to get 513. Consider that value in binary:<p><pre><code>    1000000001
     ^^^^^^^^^
      ~~~~~~~~
</code></pre>
Dividing by 512 will shift away the ^ bits. For floor division, we therefore want the ^ underlined value to be close to zero. (That way, when we divide 255 (say) by 3, the error won&#x27;t be big enough to overflow into the result bits.)<p>The multiplicative inverse fact is equivalent to telling us that the ~ underlined bits are <i>exactly</i> 1. Conveniently, that&#x27;s close to 0 - but we didn&#x27;t account for all the ^ underlined bits. For example, the multiplicative inverse of 7 (mod 256) is 183, but 7 times 183 is 1281. That&#x27;s close to 1280, but that doesn&#x27;t really help us - we could right-shift by 8 but then we still have to divide by 5. If we just ignore the problem and divide by 1024 (right-shift by 10), of course we get a lot of wrong results. (Even 6 &#x2F; 7 would give us 1 instead of 0.)<p>It also turns out that we&#x27;ll need more bits for accurate results in the general case. I <i>think</i> it&#x27;s possible without overflowing 16-bit numbers, but it definitely requires a bit more trickery for problematic divisors like (from my testing) 195. I thought I remembered the details here but proved myself wrong at the Python REPL :(</div><br/><div id="42483358" class="c"><input type="checkbox" id="c-42483358" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#42481958">root</a><span>|</span><a href="#42483232">parent</a><span>|</span><a href="#42482884">next</a><span>|</span><label class="collapse" for="c-42483358">[-]</label><label class="expand" for="c-42483358">[2 more]</label></div><br/><div class="children"><div class="content">Division by 195 is trivial. The answer is simply<p><pre><code>    uint8_t div195(uint8_t x) { return x &gt;= 195; }</code></pre></div><br/><div id="42483427" class="c"><input type="checkbox" id="c-42483427" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42481958">root</a><span>|</span><a href="#42483358">parent</a><span>|</span><a href="#42482884">next</a><span>|</span><label class="collapse" for="c-42483427">[-]</label><label class="expand" for="c-42483427">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but you can&#x27;t incorporate that into an algorithm that allows the divisor to vary and avoids branching. 195 is problematic <i>for the multiply-shift strategy</i>.</div><br/></div></div></div></div></div></div><div id="42482884" class="c"><input type="checkbox" id="c-42482884" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#42481958">root</a><span>|</span><a href="#42482571">parent</a><span>|</span><a href="#42483232">prev</a><span>|</span><a href="#42483639">next</a><span>|</span><label class="collapse" for="c-42482884">[-]</label><label class="expand" for="c-42482884">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not entirely a coincidence but also not a general result that one should use the modular inverse as multiplier.<p>171 * 3 = 2^9 + 1, which is not surprising as we know that 171 * 3 = 1 (mod 2^8). So rearranged we have 171 &#x2F; 2^9 = 1&#x2F;3 + 1&#x2F;(2^9*3) which shows it&#x27;s a close approximation of 1&#x2F;3.</div><br/></div></div></div></div></div></div><div id="42482145" class="c"><input type="checkbox" id="c-42482145" checked=""/><div class="controls bullet"><span class="by">mlochbaum</span><span>|</span><a href="#42481958">prev</a><span>|</span><a href="#42481868">next</a><span>|</span><label class="collapse" for="c-42482145">[-]</label><label class="expand" for="c-42482145">[1 more]</label></div><br/><div class="children"><div class="content">We implemented something like this in CBQN last year (mainly for modulus, as floor division isn&#x27;t a primitive). Commit is <a href="https:&#x2F;&#x2F;github.com&#x2F;dzaima&#x2F;CBQN&#x2F;commit&#x2F;d333902">https:&#x2F;&#x2F;github.com&#x2F;dzaima&#x2F;CBQN&#x2F;commit&#x2F;d333902</a>, some proofs of when and why it works at <a href="https:&#x2F;&#x2F;mlochbaum.github.io&#x2F;BQN&#x2F;implementation&#x2F;primitive&#x2F;arithmetic.html#integer-division-with-floats" rel="nofollow">https:&#x2F;&#x2F;mlochbaum.github.io&#x2F;BQN&#x2F;implementation&#x2F;primitive&#x2F;ari...</a>.</div><br/></div></div><div id="42481868" class="c"><input type="checkbox" id="c-42481868" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42482145">prev</a><span>|</span><a href="#42482991">next</a><span>|</span><label class="collapse" for="c-42481868">[-]</label><label class="expand" for="c-42481868">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not certain it&#x27;ll actually be faster, but you should be able to merge the reciprocal, multiplication and rounding adjustment into a single fma in log space via evil floating point bit hacks. Then you&#x27;d just be paying the cost of converting to and from the float representation of the integer.</div><br/><div id="42481901" class="c"><input type="checkbox" id="c-42481901" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#42481868">parent</a><span>|</span><a href="#42482991">next</a><span>|</span><label class="collapse" for="c-42481901">[-]</label><label class="expand" for="c-42481901">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d also love to see such comparisons. In SimSIMD, if AVX-512FP16 is available, I use FP16 for most I8&#x2F;U8 operations, but can&#x27;t speak about division.<p>Overall, using F64 directly for I32 division is a well known trick, and it should hold for smaller representations as well.</div><br/><div id="42481960" class="c"><input type="checkbox" id="c-42481960" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42481868">root</a><span>|</span><a href="#42481901">parent</a><span>|</span><a href="#42482991">next</a><span>|</span><label class="collapse" for="c-42481960">[-]</label><label class="expand" for="c-42481960">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t have time to figure out the actual numbers myself, but here&#x27;s an example doing the same for various transcendental functions:
<a href="https:&#x2F;&#x2F;github.com&#x2F;J-Montgomery&#x2F;hacky_float_math&#x2F;blob&#x2F;623ee9f13da8343dda2af36c9a1bb9decca1fa04&#x2F;softmax.cc#L34">https:&#x2F;&#x2F;github.com&#x2F;J-Montgomery&#x2F;hacky_float_math&#x2F;blob&#x2F;623ee9...</a><p>a*(1.xxx&#x2F;b) = a*(-1*1.xxx*log2(b)), which means you should be able to do a*(fma(b, magic, constant)) with appropriate conversions on either side. Should work in 32 bits for u8s.</div><br/></div></div></div></div></div></div><div id="42482991" class="c"><input type="checkbox" id="c-42482991" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#42481868">prev</a><span>|</span><a href="#42482000">next</a><span>|</span><label class="collapse" for="c-42482991">[-]</label><label class="expand" for="c-42482991">[2 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a version of the vrcpps idea, doing whole vectors of 32 u8&#x27;s, bypassing lane crossing and somewhat simplifying the packing&#x2F;unpacking, that&#x27;s ~1.5x faster on Haswell: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;TExGahv3z" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;TExGahv3z</a></div><br/><div id="42483581" class="c"><input type="checkbox" id="c-42483581" checked=""/><div class="controls bullet"><span class="by">Cold_Miserable</span><span>|</span><a href="#42482991">parent</a><span>|</span><a href="#42482000">next</a><span>|</span><label class="collapse" for="c-42483581">[-]</label><label class="expand" for="c-42483581">[1 more]</label></div><br/><div class="children"><div class="content">This is ~9.6x faster than &quot;scalar&quot;.<p>ASM_TestDiv proc    ;rcx out, rdx A, r8 B
mov rax,05555555555555555H
kmovq k1,rax
vmovdqu8 zmm0,zmmword ptr [rdx]
vmovdqu8 zmm4,zmmword ptr [r8]
vpbroadcastw zmm3,word ptr [FLOAT16_F8]
vmovdqu8 zmm2{k1},zmm0  ;lower 8-bit
vmovdqu8 zmm16{k1},zmm4  ;lower 8-bit
vpsrlw zmm1,zmm0,8  ;higher 8-bit
vpsrlw zmm5,zmm4,8  ;higher 8-bit
vpord zmm1,zmm1,zmm3
vpord zmm2,zmm2,zmm3
vpord zmm5,zmm5,zmm3
vpord zmm16,zmm16,zmm3
vsubph zmm1,zmm1,zmm3{rd-sae}  ;fast conv 16FP
vsubph zmm2,zmm2,zmm3{rd-sae}
vsubph zmm5,zmm5,zmm3{ru-sae}
vsubph zmm16,zmm16,zmm3{ru-sae}
vrcpph zmm5,zmm5
vrcpph zmm16,zmm16
vfmadd213ph zmm1,zmm5,zmm3{rd-sae}
vfmadd213ph zmm2,zmm16,zmm3{rd-sae}
vxorpd zmm1,zmm1,zmm3
vxorpd zmm2,zmm2,zmm3
vpsllw zmm1,zmm1,8
vpord zmm1,zmm1,zmm2
vmovdqu8 zmmword ptr [rcx],zmm1  ;16 8-bit unsigned int
ret</div><br/></div></div></div></div><div id="42482000" class="c"><input type="checkbox" id="c-42482000" checked=""/><div class="controls bullet"><span class="by">foundry27</span><span>|</span><a href="#42482991">prev</a><span>|</span><a href="#42484072">next</a><span>|</span><label class="collapse" for="c-42482000">[-]</label><label class="expand" for="c-42482000">[2 more]</label></div><br/><div class="children"><div class="content">I think the approximate reciprocal approach is interesting here. The doc mentions multiplying the dividend by ~1.00025 in the math to avoid FP error so you don’t end up off-by-one after truncation, but I think this hack is still incomplete! On some inputs (like 255, or other unlucky divisors near powers of two), you might get borderline rounding behaviour that flips a bit of the final integer. It’s easy to forget that single-precision floats don’t line up neatly with every 8bit integer ratio in real code, and a single off-by-one can break pixel ops or feed subtle bugs into a bigger pipeline.<p>I suspect a hybrid scheme like using approximate reciprocals for most values but punting to scalar for unlucky ones could handle these corner cases without killing performance. That’d be interesting to benchmark</div><br/><div id="42482149" class="c"><input type="checkbox" id="c-42482149" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#42482000">parent</a><span>|</span><a href="#42484072">next</a><span>|</span><label class="collapse" for="c-42482149">[-]</label><label class="expand" for="c-42482149">[1 more]</label></div><br/><div class="children"><div class="content">There are only 65280 possible inputs, that&#x27;s easily small enough to test every value for correctness.</div><br/></div></div></div></div><div id="42484072" class="c"><input type="checkbox" id="c-42484072" checked=""/><div class="controls bullet"><span class="by">jonhohle</span><span>|</span><a href="#42482000">prev</a><span>|</span><a href="#42484219">next</a><span>|</span><label class="collapse" for="c-42484072">[-]</label><label class="expand" for="c-42484072">[1 more]</label></div><br/><div class="children"><div class="content">I do a fair amount of decompiling and the list of constants is awesome! I usually can make a reasonable guess or have intuition, but frequently end up stepping through several integers to find the right value. Having a handy lookup table will be great.</div><br/></div></div><div id="42484219" class="c"><input type="checkbox" id="c-42484219" checked=""/><div class="controls bullet"><span class="by">xpe</span><span>|</span><a href="#42484072">prev</a><span>|</span><a href="#42482652">next</a><span>|</span><label class="collapse" for="c-42484219">[-]</label><label class="expand" for="c-42484219">[1 more]</label></div><br/><div class="children"><div class="content">The bit-division burns my eyes and makes a mockery of my puny intellect, my liege. Mine fellow vassals possess skills most frightful in their potency.</div><br/></div></div><div id="42482652" class="c"><input type="checkbox" id="c-42482652" checked=""/><div class="controls bullet"><span class="by">synthos</span><span>|</span><a href="#42484219">prev</a><span>|</span><a href="#42483463">next</a><span>|</span><label class="collapse" for="c-42482652">[-]</label><label class="expand" for="c-42482652">[1 more]</label></div><br/><div class="children"><div class="content">Newton Raphson could be used to calculate a reciprocal. (in a bit width larger than 8). If starting from a good reciprocal approximation, convergence to bit accurate reciprocal should not take many iterations. Then multiply the reciprocal with the numerator to perform the divide</div><br/></div></div><div id="42483463" class="c"><input type="checkbox" id="c-42483463" checked=""/><div class="controls bullet"><span class="by">purplesyringa</span><span>|</span><a href="#42482652">prev</a><span>|</span><a href="#42482143">next</a><span>|</span><label class="collapse" for="c-42483463">[-]</label><label class="expand" for="c-42483463">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s odd that the only reason AVX-512 long division wins in the end is that it&#x27;s compared to AVX2 reciprocal. Would it be possible to compare it to AVX-512 reciprocal computation?</div><br/></div></div><div id="42482143" class="c"><input type="checkbox" id="c-42482143" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42483463">prev</a><span>|</span><a href="#42482253">next</a><span>|</span><label class="collapse" for="c-42482143">[-]</label><label class="expand" for="c-42482143">[2 more]</label></div><br/><div class="children"><div class="content">Why not use libdivide?<p><a href="https:&#x2F;&#x2F;libdivide.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;libdivide.com&#x2F;</a></div><br/><div id="42482167" class="c"><input type="checkbox" id="c-42482167" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#42482143">parent</a><span>|</span><a href="#42482253">next</a><span>|</span><label class="collapse" for="c-42482167">[-]</label><label class="expand" for="c-42482167">[1 more]</label></div><br/><div class="children"><div class="content">libdivide is optimized for the case of a common divisor used many times, not for a long array of distinct divisors.</div><br/></div></div></div></div><div id="42482253" class="c"><input type="checkbox" id="c-42482253" checked=""/><div class="controls bullet"><span class="by">ack_complete</span><span>|</span><a href="#42482143">prev</a><span>|</span><a href="#42482605">next</a><span>|</span><label class="collapse" for="c-42482253">[-]</label><label class="expand" for="c-42482253">[1 more]</label></div><br/><div class="children"><div class="content">Think the SSE2 implementation could be tightened up by using the same register for the dividend and the quotient, shifting the quotient bits into the dividend as the dividend bits are shifted out. This was common practice in software CPU division routines.</div><br/></div></div><div id="42482605" class="c"><input type="checkbox" id="c-42482605" checked=""/><div class="controls bullet"><span class="by">Cold_Miserable</span><span>|</span><a href="#42482253">prev</a><span>|</span><a href="#42481797">next</a><span>|</span><label class="collapse" for="c-42482605">[-]</label><label class="expand" for="c-42482605">[3 more]</label></div><br/><div class="children"><div class="content">Heh?
Surely fast convert 8-bit int to 16-bit FP,rcp+mul&#x2F;div is a no-brainer?
edit make that fast convert,rcp,fma (float 16 constant 1.0) and xor (same constant)</div><br/><div id="42483918" class="c"><input type="checkbox" id="c-42483918" checked=""/><div class="controls bullet"><span class="by">bremac</span><span>|</span><a href="#42482605">parent</a><span>|</span><a href="#42483906">next</a><span>|</span><label class="collapse" for="c-42483918">[-]</label><label class="expand" for="c-42483918">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately none of the hardware used for testing supports FP16 arithmetic. Between Intel and AMD, the only platform that supports AVX512-FP16 is currently Sapphire Rapids.</div><br/></div></div><div id="42483906" class="c"><input type="checkbox" id="c-42483906" checked=""/><div class="controls bullet"><span class="by">purplesyringa</span><span>|</span><a href="#42482605">parent</a><span>|</span><a href="#42483918">prev</a><span>|</span><a href="#42481797">next</a><span>|</span><label class="collapse" for="c-42483906">[-]</label><label class="expand" for="c-42483906">[1 more]</label></div><br/><div class="children"><div class="content">I tried a similar approach with 32-bit FP before, and the problem here is that fast conversion is only fast in the sense of latency. Throughput-wise, it takes 2 uops instead of one, so in the end, a plain float&lt;-&gt;int conversion wins.</div><br/></div></div></div></div><div id="42481797" class="c"><input type="checkbox" id="c-42481797" checked=""/><div class="controls bullet"><span class="by">abcd_f</span><span>|</span><a href="#42482605">prev</a><span>|</span><a href="#42484076">next</a><span>|</span><label class="collapse" for="c-42481797">[-]</label><label class="expand" for="c-42481797">[16 more]</label></div><br/><div class="children"><div class="content">Since it&#x27;s 8bit by 8bit, a precomputed lookup table (64K in size) will be another option.</div><br/><div id="42482147" class="c"><input type="checkbox" id="c-42482147" checked=""/><div class="controls bullet"><span class="by">ack_complete</span><span>|</span><a href="#42481797">parent</a><span>|</span><a href="#42481822">next</a><span>|</span><label class="collapse" for="c-42482147">[-]</label><label class="expand" for="c-42482147">[5 more]</label></div><br/><div class="children"><div class="content">A lookup table in memory can only be accessed an element at a time, so it gets bottlenecked in the execution units on the load and address generation traffic. This algorithm uses 8-bit integers, so the vectorized version is processing between 16-64 elements per operation depending on the vector width. It&#x27;s even worse if the 8-bit divide is integrated with other vector operations as then the lookup table method also has insert&#x2F;extract overhead to exchange the values between the vector and integer units.<p>A hybrid approach using small in-register lookup tables in the vector unit (pshufb&#x2F;tbl) can be lucrative, but are very limited in table size.</div><br/><div id="42482365" class="c"><input type="checkbox" id="c-42482365" checked=""/><div class="controls bullet"><span class="by">mithametacs</span><span>|</span><a href="#42481797">root</a><span>|</span><a href="#42482147">parent</a><span>|</span><a href="#42481822">next</a><span>|</span><label class="collapse" for="c-42482365">[-]</label><label class="expand" for="c-42482365">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never thought of a micro-lookup-table!<p>That&#x27;s cool.  What have you used those for?</div><br/><div id="42484993" class="c"><input type="checkbox" id="c-42484993" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#42481797">root</a><span>|</span><a href="#42482365">parent</a><span>|</span><a href="#42484867">next</a><span>|</span><label class="collapse" for="c-42484993">[-]</label><label class="expand" for="c-42484993">[1 more]</label></div><br/><div class="children"><div class="content">You can test whether a register full of bytes belong to a class of bytes with the high bit unset and distinct lower nibbles in 2 instructions (each with 1 cycle latency). For example the characters that commonly occur in text and must be escaped in json are &quot;\&quot;\\\r\n\t&quot; (5 different bytes). Their lower nibbles are:<p>\&quot;: 0010<p>\t: 1001<p>\n: 1010<p>\\: 1100<p>\r: 1101<p>Since there are no duplicate lower nibbles, we can test for membership in this set in 2 instructions. If we want to get the value into a general-purpose register and branch on whether it&#x27;s 0 or not, that&#x27;s 2 more instructions.<p>For larger sets or sets determined at runtime, see here: <a href="http:&#x2F;&#x2F;0x80.pl&#x2F;notesen&#x2F;2018-10-18-simd-byte-lookup.html" rel="nofollow">http:&#x2F;&#x2F;0x80.pl&#x2F;notesen&#x2F;2018-10-18-simd-byte-lookup.html</a></div><br/></div></div><div id="42484867" class="c"><input type="checkbox" id="c-42484867" checked=""/><div class="controls bullet"><span class="by">glangdale</span><span>|</span><a href="#42481797">root</a><span>|</span><a href="#42482365">parent</a><span>|</span><a href="#42484993">prev</a><span>|</span><a href="#42482494">next</a><span>|</span><label class="collapse" for="c-42484867">[-]</label><label class="expand" for="c-42484867">[1 more]</label></div><br/><div class="children"><div class="content">Not OP, but we use these tables all the time in Hyperscan (for string and character class matching) and it&#x27;s a long-standing technique to use it for things like SIMD population count (obsoleted now if you have the right AVX-512 ISA, ofc).</div><br/></div></div><div id="42482494" class="c"><input type="checkbox" id="c-42482494" checked=""/><div class="controls bullet"><span class="by">ack_complete</span><span>|</span><a href="#42481797">root</a><span>|</span><a href="#42482365">parent</a><span>|</span><a href="#42484867">prev</a><span>|</span><a href="#42481822">next</a><span>|</span><label class="collapse" for="c-42482494">[-]</label><label class="expand" for="c-42482494">[1 more]</label></div><br/><div class="children"><div class="content">Typically just like conventional lookup tables, where you can get the table size down small enough. Indexed palette &#x2F; quantization coding is a case where this can often work. It&#x27;s pretty niche given the limitations, but if you can make it work it&#x27;s often a major speedup since you&#x27;re able to do 16&#x2F;32&#x2F;64 lookups in parallel.</div><br/></div></div></div></div></div></div><div id="42481822" class="c"><input type="checkbox" id="c-42481822" checked=""/><div class="controls bullet"><span class="by">mmastrac</span><span>|</span><a href="#42481797">parent</a><span>|</span><a href="#42482147">prev</a><span>|</span><a href="#42481859">next</a><span>|</span><label class="collapse" for="c-42481822">[-]</label><label class="expand" for="c-42481822">[8 more]</label></div><br/><div class="children"><div class="content">Lookup tables aren&#x27;t necessarily faster these days for a lot of things when using low-level languages, but it would have been interesting to see the comparison here.</div><br/><div id="42481851" class="c"><input type="checkbox" id="c-42481851" checked=""/><div class="controls bullet"><span class="by">adhoc32</span><span>|</span><a href="#42481797">root</a><span>|</span><a href="#42481822">parent</a><span>|</span><a href="#42481859">next</a><span>|</span><label class="collapse" for="c-42481851">[-]</label><label class="expand" for="c-42481851">[7 more]</label></div><br/><div class="children"><div class="content">pretty sure a memory access is faster than the methods presented in the article.</div><br/><div id="42482088" class="c"><input type="checkbox" id="c-42482088" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#42481797">root</a><span>|</span><a href="#42481851">parent</a><span>|</span><a href="#42481953">next</a><span>|</span><label class="collapse" for="c-42482088">[-]</label><label class="expand" for="c-42482088">[1 more]</label></div><br/><div class="children"><div class="content">Depends also heavily on the context. You pay for each cache miss twice - once for the miss itself, and next time when you access whatever was evicted during the first miss. This is why LUTs often shine in microbenchmarks, but drag down performance in real world scenarios when mixed with other cache bound code.</div><br/></div></div><div id="42481953" class="c"><input type="checkbox" id="c-42481953" checked=""/><div class="controls bullet"><span class="by">retrac</span><span>|</span><a href="#42481797">root</a><span>|</span><a href="#42481851">parent</a><span>|</span><a href="#42482088">prev</a><span>|</span><a href="#42482201">next</a><span>|</span><label class="collapse" for="c-42481953">[-]</label><label class="expand" for="c-42481953">[1 more]</label></div><br/><div class="children"><div class="content">Access to main memory can be many many cycles; a short routine already in cache may be able to recompute a value more quickly than pulling it from main memory.</div><br/></div></div><div id="42482201" class="c"><input type="checkbox" id="c-42482201" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42481797">root</a><span>|</span><a href="#42481851">parent</a><span>|</span><a href="#42481953">prev</a><span>|</span><a href="#42482083">next</a><span>|</span><label class="collapse" for="c-42482201">[-]</label><label class="expand" for="c-42482201">[2 more]</label></div><br/><div class="children"><div class="content">An uncached random memory access is around 100 cycles.</div><br/><div id="42482926" class="c"><input type="checkbox" id="c-42482926" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#42481797">root</a><span>|</span><a href="#42482201">parent</a><span>|</span><a href="#42482083">next</a><span>|</span><label class="collapse" for="c-42482926">[-]</label><label class="expand" for="c-42482926">[1 more]</label></div><br/><div class="children"><div class="content">100 cycles would be very low. Many systems have more than 100 ns!</div><br/></div></div></div></div><div id="42482083" class="c"><input type="checkbox" id="c-42482083" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#42481797">root</a><span>|</span><a href="#42481851">parent</a><span>|</span><a href="#42482201">prev</a><span>|</span><a href="#42481875">next</a><span>|</span><label class="collapse" for="c-42482083">[-]</label><label class="expand" for="c-42482083">[1 more]</label></div><br/><div class="children"><div class="content">64K is enough to fill L1 on many systems</div><br/></div></div><div id="42481875" class="c"><input type="checkbox" id="c-42481875" checked=""/><div class="controls bullet"><span class="by">dist-epoch</span><span>|</span><a href="#42481797">root</a><span>|</span><a href="#42481851">parent</a><span>|</span><a href="#42482083">prev</a><span>|</span><a href="#42481859">next</a><span>|</span><label class="collapse" for="c-42481875">[-]</label><label class="expand" for="c-42481875">[1 more]</label></div><br/><div class="children"><div class="content">Hitting L2 is more than 3-4 cycles</div><br/></div></div></div></div></div></div><div id="42481859" class="c"><input type="checkbox" id="c-42481859" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#42481797">parent</a><span>|</span><a href="#42481822">prev</a><span>|</span><a href="#42484076">next</a><span>|</span><label class="collapse" for="c-42481859">[-]</label><label class="expand" for="c-42481859">[2 more]</label></div><br/><div class="children"><div class="content">64 KB is a pretty significant budget for such a small operation. I&#x27;ve had a variant that uses 768 bytes with some extra logic, but will deprecate that kernel soon.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;StringZilla&#x2F;blob&#x2F;0d47be212c5abd69bf2bbf2a97c93c718d4fd423&#x2F;include&#x2F;stringzilla&#x2F;stringzilla.h#L3136">https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;StringZilla&#x2F;blob&#x2F;0d47be212c5...</a></div><br/><div id="42481893" class="c"><input type="checkbox" id="c-42481893" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#42481797">root</a><span>|</span><a href="#42481859">parent</a><span>|</span><a href="#42484076">next</a><span>|</span><label class="collapse" for="c-42481893">[-]</label><label class="expand" for="c-42481893">[1 more]</label></div><br/><div class="children"><div class="content">This seems like something that could be in hardware to allow native execution of the instruction. Is that not the case anywhere?</div><br/></div></div></div></div></div></div><div id="42484076" class="c"><input type="checkbox" id="c-42484076" checked=""/><div class="controls bullet"><span class="by">afstr</span><span>|</span><a href="#42481797">prev</a><span>|</span><a href="#42482068">next</a><span>|</span><label class="collapse" for="c-42484076">[-]</label><label class="expand" for="c-42484076">[1 more]</label></div><br/><div class="children"><div class="content">M  I’m looking I’m I’m
O
; r</div><br/></div></div><div id="42482068" class="c"><input type="checkbox" id="c-42482068" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42484076">prev</a><span>|</span><label class="collapse" for="c-42482068">[-]</label><label class="expand" for="c-42482068">[9 more]</label></div><br/><div class="children"><div class="content">&gt; SIMD ISAs usually do not provide the integer division; the only known exception is RISC-V Vector Extension<p>It&#x27;s kind of funny to read &quot;the only known exception is...&quot; in this context. What would an unknown exception be - an ISA that accidentally implements this but that the author believes nobody is aware of yet?<p>More seriously, I actually don&#x27;t understand the intended meaning here. I assume the author means &quot;out of all the ISAs I know&quot;? What is that set of ISAs?</div><br/><div id="42482316" class="c"><input type="checkbox" id="c-42482316" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#42482068">parent</a><span>|</span><a href="#42482177">next</a><span>|</span><label class="collapse" for="c-42482316">[-]</label><label class="expand" for="c-42482316">[1 more]</label></div><br/><div class="children"><div class="content">Some SIMD ISAs with integer division:<p>- Arm SVE, though only for 32-bit and 64-bit element types: <a href="https:&#x2F;&#x2F;developer.arm.com&#x2F;architectures&#x2F;instruction-sets&#x2F;intrinsics&#x2F;#f:@navigationhierarchiesreturnbasetype=[int,uint]&amp;f:@navigationhierarchiessimdisa=[sve]&amp;q=svdiv" rel="nofollow">https:&#x2F;&#x2F;developer.arm.com&#x2F;architectures&#x2F;instruction-sets&#x2F;int...</a><p>- loongarch64 LSX&#x2F;LASX: <a href="https:&#x2F;&#x2F;jia.je&#x2F;unofficial-loongarch-intrinsics-guide&#x2F;viewer&#x2F;?q=_vdiv_" rel="nofollow">https:&#x2F;&#x2F;jia.je&#x2F;unofficial-loongarch-intrinsics-guide&#x2F;viewer&#x2F;...</a><p>- MRISC32 (though that&#x27;s somewhat obvious as basically everything in it is shared between scalar and vector).</div><br/></div></div><div id="42482177" class="c"><input type="checkbox" id="c-42482177" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#42482068">parent</a><span>|</span><a href="#42482316">prev</a><span>|</span><a href="#42482283">next</a><span>|</span><label class="collapse" for="c-42482177">[-]</label><label class="expand" for="c-42482177">[2 more]</label></div><br/><div class="children"><div class="content">Practically, could the expression “only know exception” mean anything other than “known by me?” I mean, it is clearly possible for an exception to exist, on account of the existing known exception, so they can’t know that more exceptions don’t exist out there somewhere.<p>I dunno. I think it is a more meaningful statement if we know more about the author; if we assume that they are very well informed, I guess we would assume that the fact that they don’t know about something is really meaningful. In the case of a blog post where most of us don’t know the author, it is hard to infer much. But at least it tells us why they decided to do the thing.</div><br/><div id="42483405" class="c"><input type="checkbox" id="c-42483405" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42482068">root</a><span>|</span><a href="#42482177">parent</a><span>|</span><a href="#42482283">next</a><span>|</span><label class="collapse" for="c-42483405">[-]</label><label class="expand" for="c-42483405">[1 more]</label></div><br/><div class="children"><div class="content">If a SIMD ISA exists, someone must know that it exists, because definitionally we only apply the term &quot;SIMD ISA&quot; to things that were consciously created to be such. So we could simply check every such example. Saying &quot;only known example&quot; is indeed silly.<p>But e.g. in mathematics, if we say that &quot;almost every member of set X has property Y; the only known exception is Z&quot; then there absolutely could be more exceptions, even if we pool the knowledge of every mathematician. It isn&#x27;t necessary that X is finite, or even enumerable. It could be possible for exceptions other than Z to exist even though every other member of the set that we know about has the property. It could be possible to prove that there are at most finitely many exceptions in an infinite set, and only know of Z but not be able to rule out the possibility of more exceptions than that.<p>We don&#x27;t even need to appeal to infinities. For example, there are problems in discrete math where nobody has found the exact answer (which necessarily is integer, by the construction of the problem) but we can prove upper and lower bounds. Suppose we find a problem where the known bounds are very tight (but not exact) and the bounded value is positive. Now, construct a set of integers ranging from 0 up to (proven upper bound + 1) inclusive... you can probably see where this is going.<p>The latter doesn&#x27;t apply to SIMD ISAs, because we know all the interesting (big hand-wave!) properties of all of them rather precisely - since they&#x27;re <i>designed</i> to have those properties.</div><br/></div></div></div></div><div id="42482283" class="c"><input type="checkbox" id="c-42482283" checked=""/><div class="controls bullet"><span class="by">camel-cdr</span><span>|</span><a href="#42482068">parent</a><span>|</span><a href="#42482177">prev</a><span>|</span><a href="#42482121">next</a><span>|</span><label class="collapse" for="c-42482283">[-]</label><label class="expand" for="c-42482283">[1 more]</label></div><br/><div class="children"><div class="content">The Convex C1 [0] and for a newer example NEC SX Aurora [1] both also support vector integer division.<p>[0] <a href="https:&#x2F;&#x2F;bitsavers.org&#x2F;pdf&#x2F;convex&#x2F;080-000120-000_CONVEX_Architecture_Handbook_1984.pdf" rel="nofollow">https:&#x2F;&#x2F;bitsavers.org&#x2F;pdf&#x2F;convex&#x2F;080-000120-000_CONVEX_Archi...</a><p>[1] <a href="https:&#x2F;&#x2F;ftp.libre-soc.org&#x2F;NEC_SX_Aurora_TSUBASA_VectorEngine-as-manual-v1.2.pdf" rel="nofollow">https:&#x2F;&#x2F;ftp.libre-soc.org&#x2F;NEC_SX_Aurora_TSUBASA_VectorEngine...</a></div><br/></div></div><div id="42482121" class="c"><input type="checkbox" id="c-42482121" checked=""/><div class="controls bullet"><span class="by">michaelhoffman</span><span>|</span><a href="#42482068">parent</a><span>|</span><a href="#42482283">prev</a><span>|</span><a href="#42482148">next</a><span>|</span><label class="collapse" for="c-42482121">[-]</label><label class="expand" for="c-42482121">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I assume the author means &quot;out of all the ISAs I know&quot;?<p>Out of all the ISAs where they know whether it provides integer division or not.</div><br/><div id="42482169" class="c"><input type="checkbox" id="c-42482169" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42482068">root</a><span>|</span><a href="#42482121">parent</a><span>|</span><a href="#42482148">next</a><span>|</span><label class="collapse" for="c-42482169">[-]</label><label class="expand" for="c-42482169">[1 more]</label></div><br/><div class="children"><div class="content">Yeah but my point is that as a reader I&#x27;m trying to figure out which ISAs actually don&#x27;t provide this (vs. which ISAs the author lacks knowledge of), and I still don&#x27;t know what those are. The sentence looks like it&#x27;s supposed to tell me, but it doesn&#x27;t.</div><br/></div></div></div></div><div id="42482148" class="c"><input type="checkbox" id="c-42482148" checked=""/><div class="controls bullet"><span class="by">perching_aix</span><span>|</span><a href="#42482068">parent</a><span>|</span><a href="#42482121">prev</a><span>|</span><a href="#42482254">next</a><span>|</span><label class="collapse" for="c-42482148">[-]</label><label class="expand" for="c-42482148">[1 more]</label></div><br/><div class="children"><div class="content">You could come up with an ISA that implements it and it wouldn&#x27;t be &quot;known&quot;. Maybe that helps?</div><br/></div></div></div></div></div></div></div></div></div></body></html>