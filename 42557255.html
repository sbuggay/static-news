<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735808452641" as="style"/><link rel="stylesheet" href="styles.css?v=1735808452641"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://olano.dev/blog/software-design-is-knowledge-building/">Software Design Is Knowledge Building</a> <span class="domain">(<a href="https://olano.dev">olano.dev</a>)</span></div><div class="subtext"><span>signa11</span> | <span>69 comments</span></div><br/><div><div id="42568303" class="c"><input type="checkbox" id="c-42568303" checked=""/><div class="controls bullet"><span class="by">nosefurhairdo</span><span>|</span><a href="#42569352">next</a><span>|</span><label class="collapse" for="c-42568303">[-]</label><label class="expand" for="c-42568303">[23 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve handed off a few services I built with minimal oversight or documentation. The receiving teams have been able to make changes without my involvement and everyone is happy.<p>I believe the only reason I&#x27;ve been successful in this is because I agonize over simplicity. There are times during the development of any project where one might be tempted to hack around an issue, or commit the ugly code that seems to work. These are the rough edges that inheritors of a codebase use as evidence that a blank slate would be preferable. They&#x27;re also the bits where the underlying business logic becomes murky. My goal is for the code to be so clear that documentation would feel redundant.<p>This approach of course takes more time and requires that your management trusts you and is willing to compromise on timelines. It&#x27;s extremely rewarding if you can sell it and deliver.</div><br/><div id="42568802" class="c"><input type="checkbox" id="c-42568802" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#42568303">parent</a><span>|</span><a href="#42569458">next</a><span>|</span><label class="collapse" for="c-42568802">[-]</label><label class="expand" for="c-42568802">[3 more]</label></div><br/><div class="children"><div class="content">I have the same experience, and I agree that simplicity leads to success. The more things software <i>can</i> do, the harder it is to reason about what it&#x27;s <i>supposed</i> to do. It&#x27;s very much the IQ bell curve meme: junior developers only solve the problem at hand, mid-level developers build powerful, but complex frameworks which can solve the problem at hand but also potential future problems, and senior &quot;X10&quot; developers only solve the problem at hand.<p>&gt; There are times during the development of any project where one might be tempted to hack around an issue, or commit the ugly code that seems to work. These are the rough edges that inheritors of a codebase use as evidence that a blank slate would be preferable.<p>Yes, one thing I&#x27;ve learned is to never underestimate the power of inertia in a codebase. When adding functionality, 99% of developers will go for the path of least resistance, which is mimicking whatever patterns already exist. To loop back to the article, this is often due to lack of full understanding; the default assumption is that because something <i>is</i> written in a certain way, that it&#x27;s the best way. This isn&#x27;t true; it may not even be the correct way! But copying what already exists has an element of safety built into it, without needing to spend the effort to deeply understand existing code (which tends to be developers&#x27; least favorite activity).<p>So if you put in an ugly hack, or have a code structure which doesn&#x27;t make sense, expect that to persist for years, or decades.</div><br/><div id="42570027" class="c"><input type="checkbox" id="c-42570027" checked=""/><div class="controls bullet"><span class="by">tkiolp4</span><span>|</span><a href="#42568303">root</a><span>|</span><a href="#42568802">parent</a><span>|</span><a href="#42570512">next</a><span>|</span><label class="collapse" for="c-42570027">[-]</label><label class="expand" for="c-42570027">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think it’s up to the developers only to decide. If we are working in a sprint, if all my manager cares about is “shipping impact”, then I’m not going to spend time on things that won’t benefit me in my performance review. I’ll take the shortcuts. Now, if management knew what we know, sure certainly everyone would benefit from that… but that’s not the real world.</div><br/></div></div><div id="42570512" class="c"><input type="checkbox" id="c-42570512" checked=""/><div class="controls bullet"><span class="by">anal_reactor</span><span>|</span><a href="#42568303">root</a><span>|</span><a href="#42568802">parent</a><span>|</span><a href="#42570027">prev</a><span>|</span><a href="#42569458">next</a><span>|</span><label class="collapse" for="c-42570512">[-]</label><label class="expand" for="c-42570512">[1 more]</label></div><br/><div class="children"><div class="content">&gt; without needing to spend the effort to deeply understand existing code<p>Or, more importantly, explain to others why you&#x27;re deviating from &quot;standard&quot;</div><br/></div></div></div></div><div id="42569458" class="c"><input type="checkbox" id="c-42569458" checked=""/><div class="controls bullet"><span class="by">jack_h</span><span>|</span><a href="#42568303">parent</a><span>|</span><a href="#42568802">prev</a><span>|</span><a href="#42569924">next</a><span>|</span><label class="collapse" for="c-42569458">[-]</label><label class="expand" for="c-42569458">[1 more]</label></div><br/><div class="children"><div class="content">What you&#x27;ve said echoes the concept behind the quote &quot;I didn’t have time to write you a short letter, so I wrote you a long one.&quot; This, or some variation of it, has been around for quite a while. I think this reveals a fundamental truth about knowledge based work that is inherent to humans. Purposeful simplicity is harder than accidental complexity.<p>&gt; This approach of course takes more time and requires that your management trusts you and is willing to compromise on timelines.<p>I would say that most management and even most programmers don&#x27;t see the value in this. In my experience focusing on simplicity gives much better long-term results but it has higher and more unpredictable upfront cost. Blasting code onto main is seen as being more productive even though long-term it seems to have much higher overall costs.</div><br/></div></div><div id="42569924" class="c"><input type="checkbox" id="c-42569924" checked=""/><div class="controls bullet"><span class="by">gofreddygo</span><span>|</span><a href="#42568303">parent</a><span>|</span><a href="#42569458">prev</a><span>|</span><a href="#42568752">next</a><span>|</span><label class="collapse" for="c-42569924">[-]</label><label class="expand" for="c-42569924">[1 more]</label></div><br/><div class="children"><div class="content">simplicity is a noble ambition, but let it not impede progress, for it is subjective and subject to discretion. The art to be learned and practiced is knowing when to cut corners and where to be relentless with yourself and demand that of others.<p>Getting v0.1 out, albeit with murky code and iterating to v2.5 with 10 paying customers is the way to progress. The hard, non-science part is getting management to spend billable hours for no short term benefit. Thats the key skill.</div><br/></div></div><div id="42568752" class="c"><input type="checkbox" id="c-42568752" checked=""/><div class="controls bullet"><span class="by">MrMcCall</span><span>|</span><a href="#42568303">parent</a><span>|</span><a href="#42569924">prev</a><span>|</span><a href="#42569049">next</a><span>|</span><label class="collapse" for="c-42568752">[-]</label><label class="expand" for="c-42568752">[4 more]</label></div><br/><div class="children"><div class="content">Documentation is useful, when done well. The code is always the authority, and there are very many ways the correct logic can be constructed. How it is constructed is the difference between good enough and excellent.<p>And getting &quot;compromise on timelines&quot; is a most sublime political art. It requires the combination of both a humble, competent manager and an established, successful engineer worthy of trust.<p>Congratulations on your success on those two varied fronts!</div><br/><div id="42568793" class="c"><input type="checkbox" id="c-42568793" checked=""/><div class="controls bullet"><span class="by">chrsig</span><span>|</span><a href="#42568303">root</a><span>|</span><a href="#42568752">parent</a><span>|</span><a href="#42569534">next</a><span>|</span><label class="collapse" for="c-42568793">[-]</label><label class="expand" for="c-42568793">[2 more]</label></div><br/><div class="children"><div class="content">I think it depends on who the documentation is intended for.  I often let public facing documentation be the source of truth for expected behavior unless it&#x27;s infeasible to coerce the system to that behavior.  If the latter does occur, the documentation gets updated.<p>If the question is what does the software <i>actually</i> do, then of course the code, toolchain, and runtime are the authority.</div><br/><div id="42569630" class="c"><input type="checkbox" id="c-42569630" checked=""/><div class="controls bullet"><span class="by">MrMcCall</span><span>|</span><a href="#42568303">root</a><span>|</span><a href="#42568793">parent</a><span>|</span><a href="#42569534">next</a><span>|</span><label class="collapse" for="c-42569630">[-]</label><label class="expand" for="c-42569630">[1 more]</label></div><br/><div class="children"><div class="content">Good point. I was only speaking to targeting other developers.</div><br/></div></div></div></div><div id="42569534" class="c"><input type="checkbox" id="c-42569534" checked=""/><div class="controls bullet"><span class="by">nosefurhairdo</span><span>|</span><a href="#42568303">root</a><span>|</span><a href="#42568752">parent</a><span>|</span><a href="#42568793">prev</a><span>|</span><a href="#42569049">next</a><span>|</span><label class="collapse" for="c-42569534">[-]</label><label class="expand" for="c-42569534">[1 more]</label></div><br/><div class="children"><div class="content">Thank you! I am indeed very fortunate to have a great manager.</div><br/></div></div></div></div><div id="42569049" class="c"><input type="checkbox" id="c-42569049" checked=""/><div class="controls bullet"><span class="by">worik</span><span>|</span><a href="#42568303">parent</a><span>|</span><a href="#42568752">prev</a><span>|</span><a href="#42569352">next</a><span>|</span><label class="collapse" for="c-42569049">[-]</label><label class="expand" for="c-42569049">[13 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve handed off a few services I built with minimal oversight or documentation. The receiving teams have been able to make changes without my involvement and everyone is happy.<p>I struggle to believe this.  Perhaps my personal situation, inheriting a 150k line embedded C programme, which started sprouting weird bugs when ported from X86 -&gt; ARM.<p>&gt; minimal oversight or documentation<p>Why?  Why do you not have documentation?<p>&gt; I&#x27;ve been successful in this is because I agonize over simplicity<p>I will break this down: &quot;I&#x27;ve been successful in this &quot; I do not believe this statement<p>&gt; I agonize over simplicity<p>I wonder if   the subordinates in your organisation who are not allowed to criticise you, wish you had agonised over documentation (I do not know what power you have over the folks who follow you, I am hypothesising it is a lot)<p>Documentation is very hard.  It is harder than writing code because there is no parsing of documentation, no demonstration of correctness.<p>Inaccurate, or lazy, documentation can be worse than useless, but no documentation condemns the system to a slow death<p>I wish my fellow computer programmers would stop making excuses for not doing the extremely hard work of documenting what they were thinking they were doing when they (inevitably) did something slightly differnent</div><br/><div id="42572752" class="c"><input type="checkbox" id="c-42572752" checked=""/><div class="controls bullet"><span class="by">delifue</span><span>|</span><a href="#42568303">root</a><span>|</span><a href="#42569049">parent</a><span>|</span><a href="#42570575">next</a><span>|</span><label class="collapse" for="c-42572752">[-]</label><label class="expand" for="c-42572752">[1 more]</label></div><br/><div class="children"><div class="content">The bugs coming from porting from X86 to ARM may be related to memory order. ARM has weaker memory order than X86. You may need to add memory barriers or synchronization. Of course there are other causes.</div><br/></div></div><div id="42570575" class="c"><input type="checkbox" id="c-42570575" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#42568303">root</a><span>|</span><a href="#42569049">parent</a><span>|</span><a href="#42572752">prev</a><span>|</span><a href="#42569488">next</a><span>|</span><label class="collapse" for="c-42570575">[-]</label><label class="expand" for="c-42570575">[1 more]</label></div><br/><div class="children"><div class="content">I somewhat agree with you, I don&#x27;t understand the disdain many programmers have for documentation.<p>Every company I&#x27;ve worked had parts of the codebase that were full of complicated business logic whose purpose was totally non-obvious, or complex interactions with outside APIs etc. I took care to document those things carefully so they would be understandable.</div><br/></div></div><div id="42569488" class="c"><input type="checkbox" id="c-42569488" checked=""/><div class="controls bullet"><span class="by">nosefurhairdo</span><span>|</span><a href="#42568303">root</a><span>|</span><a href="#42569049">parent</a><span>|</span><a href="#42570575">prev</a><span>|</span><a href="#42569103">next</a><span>|</span><label class="collapse" for="c-42569488">[-]</label><label class="expand" for="c-42569488">[1 more]</label></div><br/><div class="children"><div class="content">Totally fair to be skeptical; there&#x27;s no way I can convince you that my coworkers would agree with what I&#x27;ve claimed here. I do still interact with many of the folks that inherited my code though, and on multiple occasions they&#x27;ve expressed how my services have been easier to work on than others.<p>Will also note I have no subordinates. In most cases I&#x27;ve handed these services off to teams with more seniority&#x2F;higher rank than myself.<p>Re: documentation, I suspect the embedded C and adjacent systems you work on warrant docs more than the web app plumbing work that I do. I&#x27;ve done brief write-ups with some diagrams, but I wouldn&#x27;t know how to document further without just restating what is already clear from the code.</div><br/></div></div><div id="42569103" class="c"><input type="checkbox" id="c-42569103" checked=""/><div class="controls bullet"><span class="by">chaps</span><span>|</span><a href="#42568303">root</a><span>|</span><a href="#42569049">parent</a><span>|</span><a href="#42569488">prev</a><span>|</span><a href="#42569352">next</a><span>|</span><label class="collapse" for="c-42569103">[-]</label><label class="expand" for="c-42569103">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Why? Why do you not have documentation?<p>&gt; Documentation is very hard. It is harder than writing code because there is no parsing of documentation, no demonstration of correctness.<p>You answered your own question :)</div><br/><div id="42569241" class="c"><input type="checkbox" id="c-42569241" checked=""/><div class="controls bullet"><span class="by">worik</span><span>|</span><a href="#42568303">root</a><span>|</span><a href="#42569103">parent</a><span>|</span><a href="#42569352">next</a><span>|</span><label class="collapse" for="c-42569241">[-]</label><label class="expand" for="c-42569241">[8 more]</label></div><br/><div class="children"><div class="content">&gt; You answered your own question :)<p>So &quot;do not do the hard parts&quot;?<p>That is very unprofessional</div><br/><div id="42569359" class="c"><input type="checkbox" id="c-42569359" checked=""/><div class="controls bullet"><span class="by">chaps</span><span>|</span><a href="#42568303">root</a><span>|</span><a href="#42569241">parent</a><span>|</span><a href="#42569308">next</a><span>|</span><label class="collapse" for="c-42569359">[-]</label><label class="expand" for="c-42569359">[1 more]</label></div><br/><div class="children"><div class="content">Unprofessional to who, exactly? Like a sister comment says, an understandable system was built, so  it seems like a strong professional relationship existed.<p>Every codebase is going to have different definitions of &quot;professional standards&quot;.</div><br/></div></div><div id="42569308" class="c"><input type="checkbox" id="c-42569308" checked=""/><div class="controls bullet"><span class="by">nicce</span><span>|</span><a href="#42568303">root</a><span>|</span><a href="#42569241">parent</a><span>|</span><a href="#42569359">prev</a><span>|</span><a href="#42569278">next</a><span>|</span><label class="collapse" for="c-42569308">[-]</label><label class="expand" for="c-42569308">[3 more]</label></div><br/><div class="children"><div class="content">There is a limited time available. The root comment was getting success with other means. Adding good documentation would have costed much more time. That might have made their projects less successful in this case.</div><br/><div id="42571189" class="c"><input type="checkbox" id="c-42571189" checked=""/><div class="controls bullet"><span class="by">worik</span><span>|</span><a href="#42568303">root</a><span>|</span><a href="#42569308">parent</a><span>|</span><a href="#42569278">next</a><span>|</span><label class="collapse" for="c-42571189">[-]</label><label class="expand" for="c-42571189">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Adding good documentation would have costed much more time<p>That is the problem<p>Not that it is true, it is not, for many reasons.  It is a problem that is believed</div><br/><div id="42571266" class="c"><input type="checkbox" id="c-42571266" checked=""/><div class="controls bullet"><span class="by">bdangubic</span><span>|</span><a href="#42568303">root</a><span>|</span><a href="#42571189">parent</a><span>|</span><a href="#42569278">next</a><span>|</span><label class="collapse" for="c-42571266">[-]</label><label class="expand" for="c-42571266">[1 more]</label></div><br/><div class="children"><div class="content">costed more = it would take time. you have magic ways in which <i>good</i> documentation can be created without any time at all allocated to the effort?</div><br/></div></div></div></div></div></div><div id="42569278" class="c"><input type="checkbox" id="c-42569278" checked=""/><div class="controls bullet"><span class="by">golergka</span><span>|</span><a href="#42568303">root</a><span>|</span><a href="#42569241">parent</a><span>|</span><a href="#42569308">prev</a><span>|</span><a href="#42569352">next</a><span>|</span><label class="collapse" for="c-42569278">[-]</label><label class="expand" for="c-42569278">[3 more]</label></div><br/><div class="children"><div class="content">Achieving desired result is professional. And achieving desired result without doing the hard parts is not only professional, but smart and actually kind of awesome.</div><br/><div id="42571209" class="c"><input type="checkbox" id="c-42571209" checked=""/><div class="controls bullet"><span class="by">worik</span><span>|</span><a href="#42568303">root</a><span>|</span><a href="#42569278">parent</a><span>|</span><a href="#42569352">next</a><span>|</span><label class="collapse" for="c-42571209">[-]</label><label class="expand" for="c-42571209">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Achieving desired result is professional.<p>No. It is geeking out, part of the job...<p>&gt; achieving desired result without doing the hard parts is not only professional, but smart and actually kind of awesome.<p>That is a menace.  I think I am working on code you wrote<p>It is the opposite of professional. It is amateur, irresponsible dilettantism</div><br/><div id="42571929" class="c"><input type="checkbox" id="c-42571929" checked=""/><div class="controls bullet"><span class="by">floating-io</span><span>|</span><a href="#42568303">root</a><span>|</span><a href="#42571209">parent</a><span>|</span><a href="#42569352">next</a><span>|</span><label class="collapse" for="c-42571929">[-]</label><label class="expand" for="c-42571929">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Professional&quot; is doing what they&#x27;re paying you for, end of story.<p>Most employers have less than zero interest in paying coders to document in my experience.  If they want documentation to exist, they hire a technical writer.<p>Sadly, I&#x27;ve never met an employed tech writer (and no, journalists don&#x27;t count).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42569352" class="c"><input type="checkbox" id="c-42569352" checked=""/><div class="controls bullet"><span class="by">picometer</span><span>|</span><a href="#42568303">prev</a><span>|</span><a href="#42568983">next</a><span>|</span><label class="collapse" for="c-42569352">[-]</label><label class="expand" for="c-42569352">[2 more]</label></div><br/><div class="children"><div class="content">This is a well-referenced essay, drawing the on writing of David Parnas [1], Peter Naur [2], and Zach Tellman [3].<p>As software developers we’re intimately familiar with these ideas. But the industry still treats it as “folk knowledge”, despite decades of academic work and systemization attempts like the original Agile.<p>We really need more connective work, relating the theoretical ideas to the observed behavior of real-life software projects, and to the subsequent damage and dysfunction. I liked this essay because it scratches that itch for me. But we need this work to go beyond personal blogs&#x2F;newsletters&#x2F;dev.to articles. It needs to be recognized &amp; accepted as formal “scientific” knowledge, and to be seen and grokked by industry and corporate leadership.<p>[1] <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.5555&#x2F;257734.257788" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.5555&#x2F;257734.257788</a><p>[2] <a href="https:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;Naur.pdf" rel="nofollow">https:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;Naur.pdf</a><p>[3] <a href="https:&#x2F;&#x2F;explaining.software&#x2F;" rel="nofollow">https:&#x2F;&#x2F;explaining.software&#x2F;</a></div><br/><div id="42570588" class="c"><input type="checkbox" id="c-42570588" checked=""/><div class="controls bullet"><span class="by">physicles</span><span>|</span><a href="#42569352">parent</a><span>|</span><a href="#42568983">next</a><span>|</span><label class="collapse" for="c-42570588">[-]</label><label class="expand" for="c-42570588">[1 more]</label></div><br/><div class="children"><div class="content">I suspect systemization would require quantifying some of the variables involved, which include things like<p>- The size and complexity of the code base (for some definition of size and complexity)<p>- The quality of the code and docs (for some definition of quality)<p>- The skill and experience of the people involved<p>In four years in a big tech role, my team twice inherited and had to modify a code base without any input from the original authors. One was a quagmire, the other was a resounding success:<p>- The first was a media player control that we had to update to support a new COM interface and have a new UI. We decided that it was too complicated, and nobody understood it, so we’d reimplement it from scratch. One year later it mostly worked, but still had bugs and performance issues that the original version didn’t have. In hindsight, I suspect it would’ve been cheaper to try to revive the original code base.<p>- The second was a music database for an app running on a mobile device. Our current one was based on the version of SQL available, but some principal engineers on another team suggested replacing it with a custom in-memory database that already shipped in another device. We argued that the original authors had left and the code was unwieldy; they argued that “it’s just code, we can read it” and its performance was known to be better. They did the work to revive it and successfully integrated it into our app. Wild success.<p>The flip side of “it’s impossible to revive a dead system” is “don’t rewrite a working system from scratch”. Absent more research, the only way to correctly guess which situation you’re actually in is to have tons of experience.</div><br/></div></div></div></div><div id="42568983" class="c"><input type="checkbox" id="c-42568983" checked=""/><div class="controls bullet"><span class="by">siscia</span><span>|</span><a href="#42569352">prev</a><span>|</span><a href="#42568623">next</a><span>|</span><label class="collapse" for="c-42568983">[-]</label><label class="expand" for="c-42568983">[8 more]</label></div><br/><div class="children"><div class="content">Most of our white collar jobs are about knowledge sharing and synchronization between people.<p>And surprisingly this is an aspect in which I see very very little progress.<p>The most we have are tools like confluence or Jira that are actually quite bad in my opinion.<p>The bad part is how knowledge is shared. At the moment is just formatted text with a questionable search.<p>LLMs I believe can help in synthesize what knowledge is there and what is missing.<p>Moreover it would be possible to ask what is missing or what could be improved. And it would be possible to continuously test the knowledge base, asking the model question about the topic and checking the answer.<p>I am working on a prototype and it is looking great. If someone is interested, please let me know.</div><br/><div id="42569016" class="c"><input type="checkbox" id="c-42569016" checked=""/><div class="controls bullet"><span class="by">mdgrech23</span><span>|</span><a href="#42568983">parent</a><span>|</span><a href="#42569558">next</a><span>|</span><label class="collapse" for="c-42569016">[-]</label><label class="expand" for="c-42569016">[5 more]</label></div><br/><div class="children"><div class="content">knowledge is power and people don&#x27;t always want to share. Maybe it&#x27;s more reflective of my company culture but I&#x27;ve seen knowledge effectively hoarded and used strategically as a weapon at times.</div><br/><div id="42569355" class="c"><input type="checkbox" id="c-42569355" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#42568983">root</a><span>|</span><a href="#42569016">parent</a><span>|</span><a href="#42569330">next</a><span>|</span><label class="collapse" for="c-42569355">[-]</label><label class="expand" for="c-42569355">[2 more]</label></div><br/><div class="children"><div class="content">Of course there is no upside for spending time updating documentation unless it actually is part of your job description or there is legal requirement for company.<p>If you put knowledge in wiki, no one will read it and they will keep asking about stuff anyway.<p>Then if you put it there and keep it up to date you open yourself to a bunch of attacks from unhappy coworkers who might use it as a weapon nagging that you did not do good job or find some gaps they can nag about.</div><br/><div id="42571238" class="c"><input type="checkbox" id="c-42571238" checked=""/><div class="controls bullet"><span class="by">PsylentKnight</span><span>|</span><a href="#42568983">root</a><span>|</span><a href="#42569355">parent</a><span>|</span><a href="#42569330">next</a><span>|</span><label class="collapse" for="c-42571238">[-]</label><label class="expand" for="c-42571238">[1 more]</label></div><br/><div class="children"><div class="content">I write documentation because I enjoy it and I see it as a tool for consolidating&#x2F;solidifying my own knowledge</div><br/></div></div></div></div><div id="42569330" class="c"><input type="checkbox" id="c-42569330" checked=""/><div class="controls bullet"><span class="by">nicce</span><span>|</span><a href="#42568983">root</a><span>|</span><a href="#42569016">parent</a><span>|</span><a href="#42569355">prev</a><span>|</span><a href="#42569067">next</a><span>|</span><label class="collapse" for="c-42569330">[-]</label><label class="expand" for="c-42569330">[1 more]</label></div><br/><div class="children"><div class="content">It is visible everywhere. Some people hoard knowledge so that they stay important in the company. Some people hoard knowledge so that they can get more money from bug bounties. It is almost always about personal gain.</div><br/></div></div><div id="42569067" class="c"><input type="checkbox" id="c-42569067" checked=""/><div class="controls bullet"><span class="by">siscia</span><span>|</span><a href="#42568983">root</a><span>|</span><a href="#42569016">parent</a><span>|</span><a href="#42569330">prev</a><span>|</span><a href="#42569558">next</a><span>|</span><label class="collapse" for="c-42569067">[-]</label><label class="expand" for="c-42569067">[1 more]</label></div><br/><div class="children"><div class="content">Of course, but at least in my personal case is more about the lack of tooling.</div><br/></div></div></div></div><div id="42569558" class="c"><input type="checkbox" id="c-42569558" checked=""/><div class="controls bullet"><span class="by">tylerchurch</span><span>|</span><a href="#42568983">parent</a><span>|</span><a href="#42569016">prev</a><span>|</span><a href="#42568623">next</a><span>|</span><label class="collapse" for="c-42569558">[-]</label><label class="expand" for="c-42569558">[2 more]</label></div><br/><div class="children"><div class="content">&gt; LLMs I believe can help in synthesize what knowledge is there and what is missing.<p>How could the LLM help?<p>Given that it is missing the critical context and knowledge described in the article, wouldn’t it be (at best) on par with a new developer making guesses about a codebase?</div><br/><div id="42569734" class="c"><input type="checkbox" id="c-42569734" checked=""/><div class="controls bullet"><span class="by">nyrikki</span><span>|</span><a href="#42568983">root</a><span>|</span><a href="#42569558">parent</a><span>|</span><a href="#42568623">next</a><span>|</span><label class="collapse" for="c-42569734">[-]</label><label class="expand" for="c-42569734">[1 more]</label></div><br/><div class="children"><div class="content">The open domain frame problem is simply the halting problem.<p><a href="https:&#x2F;&#x2F;philarchive.org&#x2F;rec&#x2F;DIEEOT-2" rel="nofollow">https:&#x2F;&#x2F;philarchive.org&#x2F;rec&#x2F;DIEEOT-2</a><p>While humans and computers both suffer from the frame problem, the LLMs do not have access to symantic properties, let alone the open domain.<p>This is related to why pair programming and self organizing cross functional teams work so well btw.</div><br/></div></div></div></div></div></div><div id="42568623" class="c"><input type="checkbox" id="c-42568623" checked=""/><div class="controls bullet"><span class="by">gatinsama</span><span>|</span><a href="#42568983">prev</a><span>|</span><a href="#42571752">next</a><span>|</span><label class="collapse" for="c-42568623">[-]</label><label class="expand" for="c-42568623">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the mental model that allows the designer to map a subset of the world (the domain) to and from the system, and not the system itself, is the primary product of the software design activity<p>This is spot on. I was never able to put it in such precise words.<p>This theory has Brook&#x27;s Law as a corollary:<p>&quot;Adding manpower to a late software project makes it later.&quot;<p>Because the developers need time to develop this mental model before they can meaningfully contribute to the codebase.</div><br/></div></div><div id="42571752" class="c"><input type="checkbox" id="c-42571752" checked=""/><div class="controls bullet"><span class="by">wwarner</span><span>|</span><a href="#42568623">prev</a><span>|</span><a href="#42570236">next</a><span>|</span><label class="collapse" for="c-42571752">[-]</label><label class="expand" for="c-42571752">[2 more]</label></div><br/><div class="children"><div class="content">This is really why AI is going to hit s&#x2F;w development so hard. It&#x27;s not merely going to make code easier to write, it&#x27;s going to be a massive knowledge repository that takes a team from initial conception, through product design and finally engineering design and coding.</div><br/><div id="42572209" class="c"><input type="checkbox" id="c-42572209" checked=""/><div class="controls bullet"><span class="by">n_ary</span><span>|</span><a href="#42571752">parent</a><span>|</span><a href="#42570236">next</a><span>|</span><label class="collapse" for="c-42572209">[-]</label><label class="expand" for="c-42572209">[1 more]</label></div><br/><div class="children"><div class="content">No, LLM needs excellent communicator. It can statistically spit out knowledge but someone has to embed that knowledge. Given how vague and contradictory most requirements are and how complete and excruciatingly detailed prompts must be, LLMs will be useful to generate prototypes faster to check assumptions of the lost knowledge, nothing more or less.</div><br/></div></div></div></div><div id="42570236" class="c"><input type="checkbox" id="c-42570236" checked=""/><div class="controls bullet"><span class="by">deskr</span><span>|</span><a href="#42571752">prev</a><span>|</span><a href="#42568899">next</a><span>|</span><label class="collapse" for="c-42570236">[-]</label><label class="expand" for="c-42570236">[1 more]</label></div><br/><div class="children"><div class="content">I have another suggestion which I&#x27;m sure played a large part in this.<p>SVC was an unwanted child. It wasn&#x27;t their &quot;product&quot;. One employee was tasked to write it to save paying money to a &quot;seemingly innocuous middleware SaaS&quot;.<p>To anyone in ORG working on it, it was a dead end. No one wanted to own it and perhaps no one did. A team was asked to add features to it.<p>Doing the ground work of actually understanding SVC had many negative consequences:<p>* It would take a very long time, making managers not happy. It would be largely a wasted effort, since no further work was then needed on SVG.<p>* If you became an expert on SVG, it would be yours to keep and no one wanted that.</div><br/></div></div><div id="42568899" class="c"><input type="checkbox" id="c-42568899" checked=""/><div class="controls bullet"><span class="by">harrall</span><span>|</span><a href="#42570236">prev</a><span>|</span><a href="#42571109">next</a><span>|</span><label class="collapse" for="c-42568899">[-]</label><label class="expand" for="c-42568899">[10 more]</label></div><br/><div class="children"><div class="content">I feel that the real problem is a lot of people don’t care about collecting requirements.<p>It’s one of my favorite parts of the process.<p>People just want to build the app that they want to build. I’ve talked to engineers who just say “I don’t really care until we can start coding.”<p>I got into engineering because I like building things that are useful.</div><br/><div id="42569572" class="c"><input type="checkbox" id="c-42569572" checked=""/><div class="controls bullet"><span class="by">sibit</span><span>|</span><a href="#42568899">parent</a><span>|</span><a href="#42568993">next</a><span>|</span><label class="collapse" for="c-42569572">[-]</label><label class="expand" for="c-42569572">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I feel that the real problem is a lot of people don’t care about collecting requirements.<p>As someone who _really_ enjoyed requirements gathering for many years and now has become one of the &quot;I don&#x27;t care let&#x27;s just build it&quot; people I can assure you that some of us crashed out thanks to Scrum Masters™, Project Managers™, Product Owners™, or any of the other big &quot;A&quot; Agile™ cronies.</div><br/></div></div><div id="42568993" class="c"><input type="checkbox" id="c-42568993" checked=""/><div class="controls bullet"><span class="by">avg_dev</span><span>|</span><a href="#42568899">parent</a><span>|</span><a href="#42569572">prev</a><span>|</span><a href="#42569165">next</a><span>|</span><label class="collapse" for="c-42568993">[-]</label><label class="expand" for="c-42568993">[5 more]</label></div><br/><div class="children"><div class="content">Where I live, most software developers are not legally allowed to call themselves software engineers (engineering is licensed by regulatory body). Still, many do call themselves that and so do their employers. But in my view, &quot;I don&#x27;t really care until we can start coding&quot; is not actually engineering at all.</div><br/><div id="42569079" class="c"><input type="checkbox" id="c-42569079" checked=""/><div class="controls bullet"><span class="by">harrall</span><span>|</span><a href="#42568899">root</a><span>|</span><a href="#42568993">parent</a><span>|</span><a href="#42569070">next</a><span>|</span><label class="collapse" for="c-42569079">[-]</label><label class="expand" for="c-42569079">[1 more]</label></div><br/><div class="children"><div class="content">I’m not sure why you are making a point about engineering certification.<p>It’s not like physical products are immune to this problem. I could list you a billion poorly designed products that don’t seem to meet the correct requirements.<p>At the end of the day, some people just like to build stuff without understanding who they are building for. It could be because they like engineering. It could be because they think they will make money because “people will come if you build it.” Both strategies make poor solutions.<p>When it should be “the users have these specific problems and the product should make their life easier.”</div><br/></div></div><div id="42569070" class="c"><input type="checkbox" id="c-42569070" checked=""/><div class="controls bullet"><span class="by">worik</span><span>|</span><a href="#42568899">root</a><span>|</span><a href="#42568993">parent</a><span>|</span><a href="#42569079">prev</a><span>|</span><a href="#42570734">next</a><span>|</span><label class="collapse" for="c-42569070">[-]</label><label class="expand" for="c-42569070">[2 more]</label></div><br/><div class="children"><div class="content">&gt; developers are not legally allowed to call themselves software engineers<p>How about &quot;Solution Architect&quot;?<p>I think a collection of nonsense job titles for computer programmers would be fun...</div><br/><div id="42569259" class="c"><input type="checkbox" id="c-42569259" checked=""/><div class="controls bullet"><span class="by">Nevermark</span><span>|</span><a href="#42568899">root</a><span>|</span><a href="#42569070">parent</a><span>|</span><a href="#42570734">next</a><span>|</span><label class="collapse" for="c-42569259">[-]</label><label class="expand" for="c-42569259">[1 more]</label></div><br/><div class="children"><div class="content">Every Solution Architect should have at least seven Framework Framers and two Data Plumbers supporting them, to give the title its proper gravitas.</div><br/></div></div></div></div><div id="42570734" class="c"><input type="checkbox" id="c-42570734" checked=""/><div class="controls bullet"><span class="by">drewcoo</span><span>|</span><a href="#42568899">root</a><span>|</span><a href="#42568993">parent</a><span>|</span><a href="#42569070">prev</a><span>|</span><a href="#42569165">next</a><span>|</span><label class="collapse" for="c-42570734">[-]</label><label class="expand" for="c-42570734">[1 more]</label></div><br/><div class="children"><div class="content">Where I live we require a license for barbering and cosmetology. Apparently there are illegal haircuts. I have never heard of the hair police but I&#x27;m sure that people complain about it in fora.</div><br/></div></div></div></div><div id="42569165" class="c"><input type="checkbox" id="c-42569165" checked=""/><div class="controls bullet"><span class="by">forinti</span><span>|</span><a href="#42568899">parent</a><span>|</span><a href="#42568993">prev</a><span>|</span><a href="#42569140">next</a><span>|</span><label class="collapse" for="c-42569165">[-]</label><label class="expand" for="c-42569165">[2 more]</label></div><br/><div class="children"><div class="content">I find that the client often expects you to just code whatever they need without much interaction.<p>The truth is that requirements gathering is also a moment of discovery for the client.</div><br/><div id="42569833" class="c"><input type="checkbox" id="c-42569833" checked=""/><div class="controls bullet"><span class="by">tonyedgecombe</span><span>|</span><a href="#42568899">root</a><span>|</span><a href="#42569165">parent</a><span>|</span><a href="#42569140">next</a><span>|</span><label class="collapse" for="c-42569833">[-]</label><label class="expand" for="c-42569833">[1 more]</label></div><br/><div class="children"><div class="content">I once had a client who had that written into the contract. I’d consider that a huge red flag now.</div><br/></div></div></div></div><div id="42569140" class="c"><input type="checkbox" id="c-42569140" checked=""/><div class="controls bullet"><span class="by">CT4u8798</span><span>|</span><a href="#42568899">parent</a><span>|</span><a href="#42569165">prev</a><span>|</span><a href="#42571109">next</a><span>|</span><label class="collapse" for="c-42569140">[-]</label><label class="expand" for="c-42569140">[1 more]</label></div><br/><div class="children"><div class="content">I am not a developer by trade but being technically capable I inherited a system once that I kept running beyond its real lifespan. Eventually it was to be replaced and an outside company was contracted to develop a new system. Despite multiple meetings in which I demonstrated the shortcomings of the current system and the workflow on which it was based, all this company did was replicated the old system in their chosen software stack (which also didn&#x27;t really work because to old version was relational and theirs was no-sql). I got the impression that they already had an idea of what they were going to create and didn&#x27;t listen at all. I&#x27;ve since moved on, but I hear the new system is worse than the old system.<p>TL;DR, I have direct experience of: “I don’t really care until we can start coding.”</div><br/></div></div></div></div><div id="42571109" class="c"><input type="checkbox" id="c-42571109" checked=""/><div class="controls bullet"><span class="by">gr3ml1n</span><span>|</span><a href="#42568899">prev</a><span>|</span><a href="#42569433">next</a><span>|</span><label class="collapse" for="c-42571109">[-]</label><label class="expand" for="c-42571109">[1 more]</label></div><br/><div class="children"><div class="content">This is an interesting argument for the (definitely common) pattern the author describes in the intro.<p>A more cynical take (that I&#x27;m inclined towards is): the median software developer is simply not very good.  X10 was a good developer; the people on TEAM and TEAM++ were not.</div><br/></div></div><div id="42569433" class="c"><input type="checkbox" id="c-42569433" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#42571109">prev</a><span>|</span><a href="#42568268">next</a><span>|</span><label class="collapse" for="c-42569433">[-]</label><label class="expand" for="c-42569433">[1 more]</label></div><br/><div class="children"><div class="content">The focus of this article is on the big political project that fails (the SVC), but the part that resonates most with me is the small forgotten project that lives (the SaaS).<p>Over the years, I&#x27;ve built a number of contraptions under a similar set of circumstances: a technical problem usually created by an organizational issue suddenly appears that is both severe enough to threaten a project yet falls outside the core business, so it needs to be fixed both yesterday and on the cheap.<p>Inevitably, I get saddled with it and produce a kludge that is equally effective and cursed before going back to business as usual. More than once I&#x27;ve learned to my horror that years later the thing is not only unmaintained yet still in place, but its usage expanded to the point where it became load-bearing, because the underlying organizational issue was never solved.<p>In a manner of speaking, it is the opposite situation as described in the article: a complete lack of software design that somehow manages to survive in spite of a lack of knowledge building.</div><br/></div></div><div id="42568268" class="c"><input type="checkbox" id="c-42568268" checked=""/><div class="controls bullet"><span class="by">uludag</span><span>|</span><a href="#42569433">prev</a><span>|</span><a href="#42571725">next</a><span>|</span><label class="collapse" for="c-42568268">[-]</label><label class="expand" for="c-42568268">[1 more]</label></div><br/><div class="children"><div class="content">I find this article spot on and resonates with what I&#x27;ve experienced.<p>The article mentions Zach Tellman&#x27;s newsletter &quot;Explaining Software Design&quot; (<a href="https:&#x2F;&#x2F;explaining.software&#x2F;" rel="nofollow">https:&#x2F;&#x2F;explaining.software&#x2F;</a>) which I highly recommend reading.  I have found his works to provide deep insight into the process of software design.</div><br/></div></div><div id="42571725" class="c"><input type="checkbox" id="c-42571725" checked=""/><div class="controls bullet"><span class="by">nextworddev</span><span>|</span><a href="#42568268">prev</a><span>|</span><a href="#42570015">next</a><span>|</span><label class="collapse" for="c-42571725">[-]</label><label class="expand" for="c-42571725">[1 more]</label></div><br/><div class="children"><div class="content">Kind of a roundabout way of saying that you can’t evolve a program without fully understanding the codebase</div><br/></div></div><div id="42570015" class="c"><input type="checkbox" id="c-42570015" checked=""/><div class="controls bullet"><span class="by">jt2190</span><span>|</span><a href="#42571725">prev</a><span>|</span><a href="#42569733">next</a><span>|</span><label class="collapse" for="c-42570015">[-]</label><label class="expand" for="c-42570015">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Knowing that [program] revival [i.e. bringing a new development team “up to speed” by having them learn the model] is a plausible future need has powerful consequences for our work.<p>I’m not sure that most developers are <i>willing</i> to revive software, based on my observation that very few read anything at all, especially the source code. Instead I see a lot of adjusting the input and output of the existing program by adding a new layer. This new code is <i>totally</i> understood by the new dev, and they can modify&#x2F;maintain it easily without worrying that they broke the existing system. It also usually duplicates something that already exists inside the system. As the process repeats more and more layers are added.<p>I think a few lucky teams have developed a culture that encourages learning the existing code. (Popular web frameworks comes to mind as an example.)</div><br/></div></div><div id="42569733" class="c"><input type="checkbox" id="c-42569733" checked=""/><div class="controls bullet"><span class="by">gervwyk</span><span>|</span><a href="#42570015">prev</a><span>|</span><a href="#42568962">next</a><span>|</span><label class="collapse" for="c-42569733">[-]</label><label class="expand" for="c-42569733">[1 more]</label></div><br/><div class="children"><div class="content">Totally resonated with me re software lifecycle etc. Great article.<p>I know this is not what the article is about. But perhaps exec should have spent resources and time trying to increase revenue instead of cutting cost marginally, and creating an expensive system down the road. Derailing team focus.<p>Build vs buy… Build is almost always not cheaper. Many other reasons to build though.</div><br/></div></div><div id="42568962" class="c"><input type="checkbox" id="c-42568962" checked=""/><div class="controls bullet"><span class="by">avg_dev</span><span>|</span><a href="#42569733">prev</a><span>|</span><a href="#42570038">next</a><span>|</span><label class="collapse" for="c-42568962">[-]</label><label class="expand" for="c-42568962">[1 more]</label></div><br/><div class="children"><div class="content">Yes, artifacts (PRs, tickets, commit messages) should have good context (documentation) associated with them, and yes, simplicity is very important, and yes, some tech debt is always going to be incurred, but most importantly, <i>not understanding a &quot;legacy&quot; system that is already running in production, and then modifying it significantly, is not going to lead to good results.</i> I think it&#x27;s as simple as that.</div><br/></div></div><div id="42570038" class="c"><input type="checkbox" id="c-42570038" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#42568962">prev</a><span>|</span><a href="#42568332">next</a><span>|</span><label class="collapse" for="c-42570038">[-]</label><label class="expand" for="c-42570038">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The problem is that TEAM members don’t have enough elements to build a satisfactory mental model of SVC. They need to go by a mix of the client’s interpretation of what the system should be, and what they can tell from the code that the system actually is. These views can be disconnected and contradictory. The code may tell the what and the how, but it doesn’t tell the why. Only X10 could say what was a functional requirement, what a technical necessity, what a whim, what an accident. The team has to resort to reverse engineering, extrapolating, and guessing.<p>Hence, write down your thought process, mental model, and assumptions alongside the code. Tip: Call the process &quot;writing documentation&quot; instead of &quot;commenting code&quot;.</div><br/></div></div><div id="42568332" class="c"><input type="checkbox" id="c-42568332" checked=""/><div class="controls bullet"><span class="by">softwaredoug</span><span>|</span><a href="#42570038">prev</a><span>|</span><a href="#42568788">next</a><span>|</span><label class="collapse" for="c-42568332">[-]</label><label class="expand" for="c-42568332">[2 more]</label></div><br/><div class="children"><div class="content">I see star, lone-wolf ICs get too out in front of their teams all the time. It usually doesn’t end well. The star IC could objectively be building the right thing (like a state of the art recommendation system). But, like the article says, requirements change, bugs need to be fixed, the team needs to adjust the implementation and eventually the team reimplements the thing to within their capabilities.<p>It’s more than the usual software maintenance too-It’s the entire operation of a piece of software. Scaling it out, being on call for it, adding monitoring, alerting and  logging. Inter-operating with other software in the company. Developing libraries and services for other developers to consume. Security. Understanding and deploying the dependencies of the software. And more.<p>The clever recsys in my example is only the tiny kernel of the actual challenge of delivering this to users. Its the complex care and feeding of a live service that matters.</div><br/><div id="42570643" class="c"><input type="checkbox" id="c-42570643" checked=""/><div class="controls bullet"><span class="by">physicles</span><span>|</span><a href="#42568332">parent</a><span>|</span><a href="#42568788">next</a><span>|</span><label class="collapse" for="c-42570643">[-]</label><label class="expand" for="c-42570643">[1 more]</label></div><br/><div class="children"><div class="content">According to the article, the mistake wasn’t that X10 got too far out in front of the team (the initiative to build svc was supposed to be a lone effort), it was Org’s failure to orchestrate a hand-off from X10 to team.</div><br/></div></div></div></div><div id="42568788" class="c"><input type="checkbox" id="c-42568788" checked=""/><div class="controls bullet"><span class="by">tekchip</span><span>|</span><a href="#42568332">prev</a><span>|</span><a href="#42569576">next</a><span>|</span><label class="collapse" for="c-42568788">[-]</label><label class="expand" for="c-42568788">[1 more]</label></div><br/><div class="children"><div class="content">This is a general problem. Why&#x27;s and how&#x27;s. Or in project management, and what should be associated documentation, process and procedures. In this case code is procedure or how. The steps to do the thing. Which is great but it&#x27;s hard to make meaningful and useful changes without understanding the Why, process, does the thing needing to be done and why, process, are the procedures or code doing the things they are in the way they are.<p>Presumably for code you would get enough why&#x2F;process via comments but that seems unlikely. Perhaps coding needs to take some other tools from project management or something? Knowledge sharing&#x2F;transfer is hard.</div><br/></div></div><div id="42569576" class="c"><input type="checkbox" id="c-42569576" checked=""/><div class="controls bullet"><span class="by">binary_slinger</span><span>|</span><a href="#42568788">prev</a><span>|</span><a href="#42568608">next</a><span>|</span><label class="collapse" for="c-42569576">[-]</label><label class="expand" for="c-42569576">[1 more]</label></div><br/><div class="children"><div class="content">Also related: <a href="https:&#x2F;&#x2F;blog.codinghorror.com&#x2F;commandos-infantry-and-police&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.codinghorror.com&#x2F;commandos-infantry-and-police&#x2F;</a><p>I work a lot in the transition area between commando and infantry aka X_10 and TEAM. I’ve also found myself on TEAM++ coming in to replace TEAM.<p>It is difficult to explain to customers that SVC was built on a set of assumptions which I turn informed the design. Once the assumptions changed then design typically needs to change as well.</div><br/></div></div><div id="42568608" class="c"><input type="checkbox" id="c-42568608" checked=""/><div class="controls bullet"><span class="by">brettgriffin</span><span>|</span><a href="#42569576">prev</a><span>|</span><a href="#42569420">next</a><span>|</span><label class="collapse" for="c-42568608">[-]</label><label class="expand" for="c-42568608">[4 more]</label></div><br/><div class="children"><div class="content">There&#x27;s some really interesting stuff in here, but I think, given the example, it is burying the lede: organizations systemically underestimate the total cost of ownership of a service. By, like, orders of magnitude.<p>In this example, it isn&#x27;t entirely clear if this service (&#x27;saas middleware&#x27;) is deeply integrated with org&#x27;s core competency or value. But I&#x27;ll assume  it isn&#x27;t.<p>They do not understand the service domain well enough and cannot staff or motivate the people to build and maintain it correctly. This is exactly why SaaS exists and is so ubiquitous. You&#x27;re just not going to be able to build something as good or better for less in the long run.<p>If they properly understood the cost of building and maintaining this, compared to the (probably) insignificant increase in enterprise value to the org, they would have probably would have just RIF&#x27;d these spare engineers and just pay the SaaS provider.<p>I deal with the internals of many engineering teams across companies of all sizes, and sure as shit, every. single. one. of them has multiple of these internal failed creations. I just don&#x27;t think people truly understand how much of a liability these systems are orgs.<p>But yeah, once they made the first mistake, the rest of the blog pretty much hits the nail on the head.</div><br/><div id="42568895" class="c"><input type="checkbox" id="c-42568895" checked=""/><div class="controls bullet"><span class="by">dambi0</span><span>|</span><a href="#42568608">parent</a><span>|</span><a href="#42569420">next</a><span>|</span><label class="collapse" for="c-42568895">[-]</label><label class="expand" for="c-42568895">[3 more]</label></div><br/><div class="children"><div class="content">I think the article is trying to say more than that the development and ownership of projects is often underestimated. It’s attempting to explain why that is the case. Because the cost of theory building is misunderstood. I don’t think the lede has been buried at all.</div><br/><div id="42570972" class="c"><input type="checkbox" id="c-42570972" checked=""/><div class="controls bullet"><span class="by">brettgriffin</span><span>|</span><a href="#42568608">root</a><span>|</span><a href="#42568895">parent</a><span>|</span><a href="#42569420">next</a><span>|</span><label class="collapse" for="c-42570972">[-]</label><label class="expand" for="c-42570972">[2 more]</label></div><br/><div class="children"><div class="content">The whole scenario only exists because of the axiom introduced between points 3 and 5:<p>&gt; 3 ...ORG spends an egregious amount of money on middleware SaaS<p>&gt; 4 ...executive figures  they should be able to replace SaaS with in-house system<p>&gt; 5 ...manager tasks one of ORG ’s finest engineers with the job of building it<p>If in Point 4 it was determined this was a low value, high TCO project with many replacements, the stud engineer doesn&#x27;t work on the project, no events past this point occur.<p>If point 3 was that they had an opportunity to build a flagship product&#x2F;feature in their wheelhouse and drastically grow market share, nothing past 6 and or 7 happens.<p>Like I said, there are interesting things here about knowledge transfer, but the root cause seems to be missed from the analysis. Maybe there&#x27;s some other real world scenarios where teams of critical software are getting replaced whole sale and remain confused, but I&#x27;m not convinced most of these issues would come up in a situation that wasn&#x27;t the one described in 3-5.</div><br/><div id="42572029" class="c"><input type="checkbox" id="c-42572029" checked=""/><div class="controls bullet"><span class="by">carbonguy</span><span>|</span><a href="#42568608">root</a><span>|</span><a href="#42570972">parent</a><span>|</span><a href="#42569420">next</a><span>|</span><label class="collapse" for="c-42572029">[-]</label><label class="expand" for="c-42572029">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The whole scenario only exists because of the axiom introduced between points 3 and 5...<p>I&#x27;ll argue that the higher-level context introduced in point 2 is even more important here: &quot;ORG shifts from assume we have infinite budget mode to we need to break even next year or we’ll die&quot; i.e. the whole scenario exists not because the business can&#x27;t accurately evaluate TCO, it&#x27;s because the business is in do-or-die mode and long-term TCO doesn&#x27;t matter NOW.<p>That is, this whole scenario takes place in a situation where there is a organizationally vital need to cut costs. What happens afterwards is a trade of long-term risk (internalizing an essential business function and giving it a bus factor of one) for immediate financial improvement (no more SaaS spend). Long-term TCO doesn&#x27;t matter if the company collapses next quarter, right?<p>And in that short-term frame, the project is an unqualified success: X10 delivers exactly what was needed, and the SaaS spend is eliminated. But the risk hits: X10 leaves the company.<p>[So, pointing out this hypothetical company isn&#x27;t correctly estimating TCO is correct, but irrelevant; they&#x27;re in a position where having to pay the long term costs will be a better problem than the one they have now - a reasonable business decision, though not a great one to have to make.]<p>For what it&#x27;s worth, I completely agree with your original point: organizations really do systemically underestimate the total cost of ownership of a service. Within the example in the article, the flawed assumption is pretty explicitly laid out in point 7: &quot;For all intents and purposes, development is done, they only need to keep the lights on.&quot; - and exploring WHY this assumption is flawed  is the core of the article (section 3).<p>So, ultimately I agree with dambi0 in the GP comment - the lede hasn&#x27;t been buried here, rather the whole article is a discussion of one aspect of the very point you make. Why DO organizations systematically underestimate service TCO? Because, at least in part, there is not yet a widespread understanding that a service is not &quot;software&quot; in and of itself; rather, a service is <i>the organizational understanding of a solution to an organizational problem domain</i>, and maintaining organizations is orders of a magnitude more expensive than maintaining tools in and of themselves.</div><br/></div></div></div></div></div></div></div></div><div id="42569420" class="c"><input type="checkbox" id="c-42569420" checked=""/><div class="controls bullet"><span class="by">mfld</span><span>|</span><a href="#42568608">prev</a><span>|</span><a href="#42568233">next</a><span>|</span><label class="collapse" for="c-42569420">[-]</label><label class="expand" for="c-42569420">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t resist to point out that, in theory, there are at least two other options avoid wasting many resources via the failing new teams:<p>1. Get the original dev to explain his theories (keep employees longer or engage them as consultants)
2. Make and get a &quot;diary&quot; of the original devs theory building.<p>In this story, and in probably many places, the business environment however supports the explained outcome.</div><br/></div></div><div id="42568233" class="c"><input type="checkbox" id="c-42568233" checked=""/><div class="controls bullet"><span class="by">smikhanov</span><span>|</span><a href="#42569420">prev</a><span>|</span><a href="#42570189">next</a><span>|</span><label class="collapse" for="c-42568233">[-]</label><label class="expand" for="c-42568233">[1 more]</label></div><br/><div class="children"><div class="content">Good article, both in spirit and factually.<p>One thing to add: the author talks about reviving a system as “slow and difficult process”, and it is. However, the concrete example described is not worthy of hand-wringing of this kind: a system that could have been built by a single competent engineer in 6 months (inevitably of alpha quality, at best), could be resurrected by a competent team of several programmers and brought to, say, beta quality, while keeping the lights on their alpha system on in how long? Let’s say, 9-12 months. No biggie, really.<p>Most companies routinely discard man-years of programmer’s effort, so those 9-12 months are likely just a blip in the lifetime of that firm.</div><br/></div></div><div id="42570189" class="c"><input type="checkbox" id="c-42570189" checked=""/><div class="controls bullet"><span class="by">deskr</span><span>|</span><a href="#42568233">prev</a><span>|</span><a href="#42568193">next</a><span>|</span><label class="collapse" for="c-42570189">[-]</label><label class="expand" for="c-42570189">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The program should preferably be discarded, and the new team should be given the opportunity to resolve the problem from scratch.<p>Yeah right. &quot;We don&#x27;t know how it works so we&#x27;re going to ditch it and create it again.&quot;<p>It works in some cases but by no means should that be the default.</div><br/></div></div><div id="42568193" class="c"><input type="checkbox" id="c-42568193" checked=""/><div class="controls bullet"><span class="by">chrisweekly</span><span>|</span><a href="#42570189">prev</a><span>|</span><a href="#42570678">next</a><span>|</span><label class="collapse" for="c-42568193">[-]</label><label class="expand" for="c-42568193">[1 more]</label></div><br/><div class="children"><div class="content">Great article, +1 Insightful.<p>&gt; the ultimate goal of software design should be (organizational) knowledge building</div><br/></div></div><div id="42570678" class="c"><input type="checkbox" id="c-42570678" checked=""/><div class="controls bullet"><span class="by">contingencies</span><span>|</span><a href="#42568193">prev</a><span>|</span><label class="collapse" for="c-42570678">[-]</label><label class="expand" for="c-42570678">[1 more]</label></div><br/><div class="children"><div class="content">I imagine that experienced cross-disciplinary designers would concur that all complex design is knowledge building, which is why documenting design decisions is important. You tend to learn this lesson when maintaining projects of nontrivial complexity over a longer period.</div><br/></div></div></div></div></div></div></div></body></html>